
                    DSDT Release version 2.5
                   ==========================

Table of Content:
-----------------
1) Release History 
2) Source Code Orgnization
3) General Introduction
4) HOW TO - Build qdDrv.o for vxWorks
5) HOW TO - Build qdDrv.lib for WinCE
6) HOW TO - Build qdDrv.o for Linux
7) HOW TO - Build msDiag and run the test for vxWorks
8) Changes
9) New APIs


1) Release History 
------------------
DSDT2.5.zip - Nov. 2005, added support for 88E6065, 88E6035, 88E6055, 88E6061, and 88E6031,
		  and bug fixes in the previous release.
		  1. New APIs are added to support new devices.
		  2. Bug fixes: 
		  	1) gfdbGetAtuEntryNext API returns GT_NO_SUCH when Entry's MAC is Broadcast address.
		  	2) entryState in GT_ATU_ENTRY follows the definition.
		  	3) gsysSetTrunkMaskTable API does not overwrite HashTrunk value anymore.
		  	4) 10/100 FastEthernet Phy Reset occurs along with Speed, Duplex modification.


DSDT2.4a.zip - Oct. 2005, added support for 88E6131 and a bug fix.
		  1. gprtPortPowerDown(gtPhyCtrl.c) didn't work due to reset - reset is not called after PowerDown bit change.

DSDT2.4.zip - Aug. 2005, bug fixes and modifications
		  1. gprtSetPktGenEnable(gtPhyCtrl.c) didn't work with Serdes Device - resolved.
		  2. gprtSetPortAutoMode(gtPhyCtrl.c) dropped 1000Mbps Half duplex mode - resolved.
		  3. gprtGetPhyLinkStatus(gtPhyCtrl.c) returned LinkOn when there is no phy connected - resolved.
		  4. gprtSetPortDuplexMode(gtPhyCtrl.c) reset 1000M Speed - resolved.
		  5. gfdbSetAtuSize(gtBrgFdb.c), now, returns GT_NOT_SUPPORT if ATU size of the device 
		     is not configurable.
		  6. gprtSetPortLoopback(gtPhyCtrl.c) treats Fast Ethernet Phy and Gigabit Ethernet Phy
		  	 differently.
		  7. GT_GET_SERDES_PORT, now, does the error checking.
		  8. IS_CONFIGURABLE_PHY reads PHY ID and returns the ID

DSDT2.4pre.zip - July. 2005, added support for 88E6108
		  1. New features are added.
		  2. Arguments in gprtSetPause and gprtSetPortSpeed are modified to support
			 1000M Phys.
		  3. Driver functions are added to support Marvell Alask Phys and to be
		     expanded easily for the future Phys.

DSDT2.3c.zip - May. 2005,
		  1. New features in Rev1 or Rev2 of 88E6095 are added
		  2. gfdbGetAgingTimeout, and gfdbGetLearnEnable are added
		  3. Bug fixes in grcSetEgressRate and grcSetPri0Rate
		  4. Resetting TrunkID, when gprtSetTrunkPort is called to disable Trunk, is applied
		     only to Rev0 of 88E6095 and 88E6185

DSDT2.3b.zip - Mar. 2005, 
		  1. gstpSetMode function does not modify Port State any more, since STP module
		     sets the port state. gstpSetMode sets the switch so that it can receive 
			  BPDU packets.
		  2. gtLoadDriver clears Rsvd2Cpu and Rsvd2CpuEn bits.
		  3. TrunkID will be reset when gprtSetTrunkPort is called to disable Trunk.
		  4. "Check PPU Status in order to verify PPU disabled" is applied to gtVct.c

DSDT2.3a.zip - Jan. 2005, added support for 88E6152, 88E6155, 88E6182, and 88E6092 
		  devices, removed non-existing devices, and bug fix in 2.3 release.
		  Fix :
		  Check PPU Status in order to verify PPU disabled.

DSDT2.3.zip - Nov. 2004, support for 88E6185 and bug fixes in 2.3 preliminary release.
		  Fixes :
		  1) Provide some delay after disabling PPU.
		  2) VCT runs after disabling PPU.

DSDT2.3pre.zip - Nov. 2004, added preliminary support for 88E6185.

DSDT2.2a.zip - Nov. 2004, added semaphore support for MII Access with multi address mode.

DSDT2.2.zip - Oct. 2004, support for 88E6095 and bug fixes in 2.2 preliminary release.

DSDT2.2pre.zip - Sep. 2004, added preliminary support for 88E6095 and work-around for VCT
		  based on VCT Application Note.

DSDT2.1a.zip - Apr. 2004, support 88E6093 and bug fixes.
		  Device Driver Package name has been changed from QDDriver to DSDT(Datacom
		  Same Driver Technology).
		  Bug Fixes : 
		  1) DBNum was not correctly handled while getting entry from VTU Table.
		  2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
		  3) Correction of 88E6183 RMON Counter Structure and Enum.
		  4) ATU Interrupt Handling routine

qdDriver2.1-pre.zip - Apr. 2004, added preliminary support for 88E6093 and bug fixes.
		  Bug Fixes : 
		  1) DBNum was not incorrectly handled while getting entry from 
		  VTU Table.
		  2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
		
qdDriver2.0a.zip - Dec. 2003, privides functions which can read/write  
		  Switch Port Registers and Switch Global Registers:
		  gprtGetSwitchReg,
		  gprtSetSwitchReg,
		  gprtGetGlobalReg, and
		  gprtSetGlobalReg

qdDriver2.0.zip - July. 2003, supports Multi Address Mode for upcomming device.
		  AUTO_SCAN_MODE, MANUAL_MODE, and MULTI_ADDR_MODE are added
		  to find a QD Family device.
		  Supports Sapphire (10 port Gigabit switch).

qdDriver1.4a.zip - Apr. 2003, bug fixes.
		  Bug fixes on portVec in GT_ATU_ENTRY structure which supported only 
		  total of 8 ports (defined as GT_U8). It's now defined as GT_U32.
		  utils.c and testApi.c in Diag directory also modified to support 
		  the switch with more than 8 ports.

qdDriver1.4.zip - Apr. 2003, added support for Ocatne (6083).
		  Removed NO-OPs which created when DBG_PRINT is undefined. 
		  Bug fixes on gprtSetIGMPSnoop and gprtGetIGMPSnoop functions,
		  and GT_PRI0_RATE enum type.

qdDriver1.3h.zip - Feb. 2003, added support for Extended Cable Status, 
		  such as Impediance mismatch,Pair Skew,Pair Swap and Pair Polarity.
		  Bug fixes on FFox-EG and FFox-XP device ID.

qdDriver1.3g.zip - Dec. 2002, added preliminary support for Octane (6083)

qdDriver1.3.zip - Oct. 2002, added support for ClipperShip (6063)
		  This driver works with all released devices, including
		  6051, 6052, 6021, and 6063

qdDriver1.2.zip - Aug. 2002, added support for FullSail (6021)
				
qdDriver1.1.zip - June, 2002 OS independent QuarterDeck Driver Release 
		  Based on 1.0 release, but removed OS dependecy. The driver
		  is designed to work with any OS without code changes.

qdDriver1.0.zip - Feb. 2002, Initial QuaterDeck Driver Release
		  Based on vxWorks OS, support 6051/6052


2) Source Code Orgnization
--------------------------
	2.1) src
		DSDT Driver Suite Source Code.

	2.2) Include directory
		DSDT Driver Suite Header files and Prototype files

	2.3) Library
		Object files for DSDT driver Suite

	2.4) Sample
		Sample Code that shows how to use MSAPIs, e.g., init DSDT, setup VLAN for Home Gateway, etc.

	2.5) Diag
	 	Testing program for DSDT Driver Suite	

	* The DSDT Driver Suite Source Code are OS independent, and fully supported by Marvell.
	* The Sample Code and Testing Program are tested under vxworks, and is provided for reference only.


3) General Introduction
-----------------------

The DSDT driver suite is standalone program which is independent of both OS and Platform. 
As such, applications of MSAPIs need to register plateform specific functions. 
This is done by calling qdLoadDriver function. This function returns a pointer (*dev), 
which contains the device and platform information. It will then be used for each MSAPI call. 

msApiInit.c file in Diag directory and Sample\Initialization directory demonstrate 
how you can register those functions.

msApiInit.c
	qdStart is the main function to initialize DSDT Driver and does the 
	followings:
	a) register the platform specific functions. 
	   1.1 and 1.2 below are required. 1.3 to 1.6 are optional.
		1.1) readMii - BSP specific MII read function 
		1.2) writeMii - BSP specific MII write function 
		1.3) semCreate - OS specific semaphore create function.
		1.4) semDelete - OS specific semaphore delete function.
		1.5) semTake - OS specific semaphore take function.
		1.6) semGive - OS specific semaphore give function.

		Notes) The given example will use DB-88E6218 BSP as an example.

	b) Initialize BSP provided routine (if required).

	c) Calls qdLoadDriver routine.
		1.1) Input (GT_SYS_CONFIG) - CPU Port Number (Board Specific) and Port Mode 
		(either 1 for Forwarding mode or 0 for Hardware default mode)
		1.2) Output (GT_QD_DEV) - Contains all device (QD) and platform specific info.
		     It will be used for all API calls.

	d) Calls sysEnable (for future use.)


4) HOW TO - Build qdDrv.o for vxWorks
-------------------------------------

1. Extract the given ZIP file into c:\DSDT_2.x directory
   You may change the directory name to your choice, and change the enviroment variable below accordingly.
2. Edit setenv.bat file in c:\DSDT_2.x\tools
3. Modify the folloing variables according to your setup.
set USER_BASE=C:\DSDT_2.x
set PROJ_NAME=qdDrv
set WIND_BASE=C:\Tornado
set TARGETCPU=MIPS		;ARM for ARM Cpu
set WIND_HOST_TYPE=x86-win32
4. run "setenv"
5. Change directory to c:\DSDT_2.x\src
6. run "make"
7. qdDrv.o and qdDrv.map will be created in c:\DSDT_2.x\Library.


5) HOW TO - Build qdDrv.lib for WinCE
-------------------------------------

1. Extract the given ZIP file into c:\DSDT_2.x directory(directory can be changed)
2. Edit setenv.bat file in c:\DSDT_2.x\tools
3. Modify the following variables according to your setup.
set USER_BASE=C:\DSDT_2.x
set PROJ_NAME=qdDrv
set TARGETCPU=x86		;MIPSIV for MIPS IV
set WCEROOT=C:\WINCE400

4. run "setenv WINCE"
5. Change directory to c:\DSDT_2.x\src
6. run "make"
7. qdDrv.lib will be created in c:\DSDT_2.x\Library.


6) HOW TO - Build qdDrv.o for Linux
-----------------------------------

1. Extract the given ZIP file into $HOME/DSDT_2.x directory(directory can be changed)
	in Linux system (verified with RedHat 7.3)
2. Edit setenv file in $HOME/DSDT_2.x/tools
3. Modify the folloing variables according to your setup.
	declare -x USER_BASE=$HOME/DSDT_2.x
	declare -x PROJ_NAME=qdDrv
4. run "source setenv"
5. Change directory to $HOME/DSDT_2.x/src
6. run "make"
7. qdDrv.o and qdDrv.map will be created in $HOME/DSDT_2.x/Library.


7) HOW TO - Build msDiag and run the test for vxWorks
-----------------------------------------------------

0. qdDrv.o has to be created in c:\DSDT_2.x\Library
1. Change Directory to c:\DSDT_2.x\diag
2. run "make"
3. msDiag.o will be created in the current directory.
4. in vxworks shell, do the following:
   4.1)	To test the driver on hardware
	> ld < msDiag.o
	> qdStart 5 	// where 5 is CPU port
	> testHelp
	>testAll dev

   4.2)	To test the driver on software simulator
	> ld < msDiag.o
	> qdStart 5, 1,deviceID		// where 5 is CPU port
	> testHelp
	>testAll dev

	* deviceID - the device you want to simulate: 
		     6051 - 0x51
		     6052 - 0x52
		     6021 - 0x21
		     6063 - 0x153
		     6083 - 0x83

	* when test the driver on hardware, no deviceId needs to be provided. 
	  the driver will find it out by reading hardware registers


8) Changes from previous release
--------------------------------
	8.1) New APIs for 88E6065,88E6055,88E6035,88E6061,and 88E6031 are added
	8.2) Bug fixes: 
	  	1) gfdbGetAtuEntryNext API returns GT_NO_SUCH when Entry's MAC is Broadcast address.
	  	2) entryState in GT_ATU_ENTRY follows the definition.
	  	3) gsysSetTrunkMaskTable API does not overwrite HashTrunk value anymore.
	  	4) 10/100 FastEthernet Phy Reset occurs along with Speed, Duplex modification.
		

9) New APIs
-----------

9.1) gtBrgVlan.c

	1) gvlnSetForceMap

		DESCRIPTION:
			This routine enables/disables Force Map feature.
			When Force Map feature is enabled, all received frames will be
			considered MGMT and they are mapped to the port or ports defined
			in the VLAN Table overriding the mapping from the address database.

		SYNOPSIS:
			GT_STATUS gvlnSetForceMap
			(
			    IN  GT_QD_DEV   *dev,
			    IN  GT_LPORT 	port,
			    IN  GT_BOOL  	mode
			)
			
		INPUTS:
			port	- logical port number
			mode    - GT_TRUE, to enable force map feature
			          GT_FAULSE, otherwise 

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gvlnGetForceMap

		DESCRIPTION:
			This routine checks if Force Map feature is enabled.
			When Force Map feature is enabled, all received frames will be
			considered MGMT and they are mapped to the port or ports defined
			in the VLAN Table overriding the mapping from the address database.

		SYNOPSIS:
			GT_STATUS gvlnGetForceMap
			(
			    IN  GT_QD_DEV   *dev,
			    IN  GT_LPORT 	port,
			    OUT GT_BOOL  	*mode
			)
			
		INPUTS:
			port	- logical port number

		OUTPUTS:
			mode    - GT_TRUE, to enable force map feature
			          GT_FAULSE, otherwise 

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.2) gtEvents.c

	1) geventSetAgeIntEn

		DESCRIPTION:
			This routine enables/disables Age Interrupt for a port.
			When it's enabled, ATU Age Violation interrupts from this port are enabled.
			An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
			and the ingressing frame's SA is contained in the ATU as a non-Static 
			entry with a EntryState less than 0x4.

		SYNOPSIS:
			GT_STATUS geventSetAgeIntEn
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port	- logical port number
			mode 	- GT_TRUE to enable Age Interrupt,
					  GT_FALUSE to disable

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) geventGetAgeIntEn

		DESCRIPTION:
			This routine gets Age Interrupt Enable for a port.
			When it's enabled, ATU Age Violation interrupts from this port are enabled.
			An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
			and the ingressing frame's SA is contained in the ATU as a non-Static 
			entry with a EntryState less than 0x4.

		SYNOPSIS:
			GT_STATUS geventGetAgeIntEn
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port	- logical port number

		OUTPUTS:
			mode 	- GT_TRUE to enable Age Interrupt,
					  GT_FALUSE to disable

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.3) gtPIRL.c

	1) gpirlActivate

		DESCRIPTION:
			This routine activates Ingress Rate Limiting for the given ports by 
			initializing a resource bucket, assigning ports, and configuring
			Bucket Parameters.

		SYNOPSIS:
			GT_STATUS gpirlActivate
			(
				IN  GT_QD_DEV 	*dev,
				IN  GT_U32		irlUnit,
				IN  GT_U32		portVec,
				IN  GT_PIRL_DATA	*pirlData
			)
			
		INPUTS:
			irlUnit		- bucket to be used
			portVec		- the list of ports that share the bucket
			pirlData	- PIRL resource parameters

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gpirlDeactivate

		DESCRIPTION:
			This routine deactivates Ingress Rate Limiting for the given bucket.
			It simply removes every ports from the Ingress Rate Resource.
			It is assumed that gpirlActivate has been successfully called with
			the irlUnit before this function is called.

		SYNOPSIS:
			GT_STATUS gpirlDeactivate
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_U32		irlUnit
			)
			
		INPUTS:
			irlUnit		- bucket to be deactivated

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	3) gpirlUpdateParam

		DESCRIPTION:
			This routine updates IRL Parameter.
			It is assumed that gpirlActivate has been successfully called with
			the given irlUnit before this function is called.

		SYNOPSIS:
			GT_STATUS gpirlUpdateParam
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_U32		irlUnit,
				IN  GT_PIRL_DATA	*pirlData
			)
			
		INPUTS:
			irlUnit		- bucket to be deactivated
			pirlData 	- PIRL resource parameters

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) gpirlReadParam

		DESCRIPTION:
			This routine retrieves IRL Parameter.
			It is assumed that gpirlActivate has been successfully called with
			the given irlUnit before this function is called.

		SYNOPSIS:
			GT_STATUS gpirlReadParam
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_U32		irlUnit,
				OUT GT_PIRL_DATA	*pirlData
			)
			
		INPUTS:
			irlUnit		- bucket to be deactivated

		OUTPUTS:
			pirlData 	- PIRL resource parameters

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) gpirlUpdatePortVec

		DESCRIPTION:
			This routine updates port list that share the bucket.
			It is assumed that gpirlActivate has been successfully called with
			the given irlUnit before this function is called.

		SYNOPSIS:
			GT_STATUS gpirlUpdatePortVec
			(
				IN  GT_QD_DEV 	*dev,
				IN  GT_U32		irlUnit,
				IN  GT_U32		portVec
			)
			
		INPUTS:
			irlUnit		- bucket to be deactivated
			portVec  	- the list of ports that share the bucket.

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	6) gpirlReadPortVec

		DESCRIPTION:
			This routine retrieves port list that share the bucket.
			It is assumed that gpirlActivate has been successfully called with
			the given irlUnit before this function is called.

		SYNOPSIS:
			GT_STATUS gpirlReadPortVec
			(
				IN  GT_QD_DEV 	*dev,
				IN  GT_U32		irlUnit,
				OUT GT_U32		*portVec
			)
			
		INPUTS:
			irlUnit		- bucket to be deactivated
			portVec  	- the list of ports that share the bucket.

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - on invalid parameter
			GT_NOT_SUPPORTED - if current device does not support this feature.


	7) grcGetPirlFcMode

		DESCRIPTION:
			This routine gets Port Ingress Rate Limit Flow Control mode.
			When EBSLimitAction is programmed to generate a flow control message, 
			the deassertion of flow control is controlled by this mode.
				GT_PIRL_FC_DEASSERT_EMPTY:
					De-assert when the ingress rate resource has become empty
				GT_PIRL_FC_DEASSERT_CBS_LIMIT
					De-assert when the ingress rate resource has enough room as
					specified by the CBSLimit.
			Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
			CBSLimit.


		SYNOPSIS:
			GT_STATUS grcGetPirlFcMode
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_PIRL_FC_DEASSERT		*mode
			)
			
		INPUTS:
			port 	- logical port number

		OUTPUTS:
			mode 	- GT_PIRL_FC_DEASSERT enum type

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	8) gpirlGetIngressRateResource

		DESCRIPTION:
			This routine gets Ingress Rate Limiting Resources assigned to the port.
			This vector is used to attach specific counter resources to the physical
			port. And the same counter resource can be attached to more than one port.

		SYNOPSIS:
			GT_STATUS gpirlGetIngressRateResource
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_U32		*resVec
			)
			
		INPUTS:
			port 	- logical port number

		OUTPUTS:
			resVec 	- resource vector (bit 0 for irl unit 0, bit 1 for irl unit 1, etc.)

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.4) gtPortStatus.c

	1) gprtGetPxMode

		DESCRIPTION:
			This routine retrives 4 bits of Px_MODE Configuration value.
			If speed and duplex modes are forced, the returned mode value would be
			different from the configuration pin values.

		SYNOPSIS:
			GT_STATUS gprtGetPxMode
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT 	port,
				OUT GT_U32  	*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- Px_MODE configuration value

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gprtGetMiiInterface

		DESCRIPTION:
			This routine retrives Mii Interface Mode.

		SYNOPSIS:
			GT_STATUS gprtGetMiiInterface
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT 	port,
				OUT GT_BOOL  	*state
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			state 	- GT_TRUE, if Mii Interface is enabled
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	3) gprtGetFdFlowDis

		DESCRIPTION:
			This routine retrives the real time value of the Full Duplex Flow Control mode.

		SYNOPSIS:
			GT_STATUS gprtGetFdFlowDis
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT 	port,
				OUT GT_BOOL  	*state
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			state 	- GT_TRUE, if Full Duplex Flow Control is disabled
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) gprtGetHdFlowDis

		DESCRIPTION:
			This routine retrives the real time value of the Half Duplex Flow Control mode.

		SYNOPSIS:
			GT_STATUS gprtGetHdFlowDis
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT 	port,
				OUT GT_BOOL  	*state
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			state 	- GT_TRUE, if Half Duplex Flow Control is disabled
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) gprtGetOutQSize

		DESCRIPTION:
			This routine gets egress queue size counter value.
			This counter reflects the current number of Egress buffers switched to 
			this port. This is the total number of buffers across all four priority 
			queues.

		SYNOPSIS:
			GT_STATUS gprtGetOutQSize
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_U16		*count
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			count 	- egress queue size counter value

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.5) gtPortCtrl.c
	
	1) gprtSetSAFiltering

		DESCRIPTION:
			This routine set the Source Address(SA) fitering method.
				GT_SA_FILTERING_DISABLE :
					no frame will be filtered.
				GT_SA_DROP_ON_LOCK :
					discard if SA field is not in the ATU's address database.
				GT_SA_DROP_ON_UNLOC : 
					discard if SA field is in the ATU's address database as Static 
					entry with a PortVec of all zeros.
				GT_SA_DROP_TO_CPU : 
					Ingressing frames will be mapped to the CPU Port if their SA 
					field is in the ATU's address database as Static entry with a 
					PortVec of all zeros. Otherwise, the frames will be discarded 
					if their SA field is not in the ATU's address database or if this
					port's bit is not set in the PortVec bits for the frame's SA.

		SYNOPSIS:
			GT_STATUS gprtSetSAFiltering
			(
			    IN GT_QD_DEV  *dev,
			    IN GT_LPORT   port,
			    IN GT_SA_FILTERING    mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_SA_FILTERING structure

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gprtGetSAFiltering

		DESCRIPTION:
			This routine gets the Source Address(SA) fitering method.
				GT_SA_FILTERING_DISABLE :
					no frame will be filtered.
				GT_SA_DROP_ON_LOCK :
					discard if SA field is not in the ATU's address database.
				GT_SA_DROP_ON_UNLOC : 
					discard if SA field is in the ATU's address database as Static 
					entry with a PortVec of all zeros.
				GT_SA_DROP_TO_CPU : 
					Ingressing frames will be mapped to the CPU Port if their SA 
					field is in the ATU's address database as Static entry with a 
					PortVec of all zeros. Otherwise, the frames will be discarded 
					if their SA field is not in the ATU's address database or if this
					port's bit is not set in the PortVec bits for the frame's SA.

		SYNOPSIS:
			GT_STATUS gprtGetSAFiltering
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    OUT GT_SA_FILTERING    *mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_SA_FILTERING structure

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	3) gprtSetARPtoCPU

		DESCRIPTION:
			When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.

		SYNOPSIS:
			GT_STATUS gprtSetARPtoCPU
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
			    IN  GT_BOOL 	mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE, to map ARP frames to CPU Port
					  GT_FALSE, otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) gprtGetARPtoCPU

		DESCRIPTION:
			When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.

		SYNOPSIS:
			GT_STATUS gprtGetARPtoCPU
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
			    OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE, to map ARP frames to CPU Port
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) gprtSetEgressFlood

		DESCRIPTION:
			This routine set Egress Flooding Mode.
			Frames with unknown DA (Destination Address that is not in ATU database)
			generally flood out all the ports. This mode can be used to prevent
			those frames from egressing this port as follows:
				GT_BLOCK_EGRESS_UNKNOWN
					do not egress frame with unknown DA (both unicast and multicast)
				GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
					do not egress frame with unknown multicast DA
				GT_BLOCK_EGRESS_UNKNOWN_UNICAST
					do not egress frame with unknown unicast DA
				GT_BLOCK_EGRESS_NONE
					egress all frames with unknown DA

		SYNOPSIS:
			GT_STATUS gprtSetEgressFlood
			(
			    IN  GT_QD_DEV   *dev,
			    IN  GT_LPORT     port,
			    IN  GT_EGRESS_FLOOD      mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_EGRESS_FLOOD structure

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	6) gprtGetEgressFlood

		DESCRIPTION:
			This routine gets Egress Flooding Mode.
			Frames with unknown DA (Destination Address that is not in ATU database)
			generally flood out all the ports. This mode can be used to prevent
			those frames from egressing this port as follows:
				GT_BLOCK_EGRESS_UNKNOWN
					do not egress frame with unknown DA (both unicast and multicast)
				GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
					do not egress frame with unknown multicast DA
				GT_BLOCK_EGRESS_UNKNOWN_UNICAST
					do not egress frame with unknown unicast DA
				GT_BLOCK_EGRESS_NONE
					egress all frames with unknown DA

		SYNOPSIS:
			GT_STATUS gprtGetEgressFlood
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT 	port,
				OUT GT_EGRESS_FLOOD 	*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_EGRESS_FLOOD structure

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	7) gprtSetPortSched

		DESCRIPTION:
			This routine sets Port Scheduling Mode.
			When usePortSched is enablied, this mode is used to select the Queue
			controller's scheduling on the port as follows:
				GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
				GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme

		SYNOPSIS:
			GT_STATUS gprtSetPortSched
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_PORT_SCHED_MODE		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_PORT_SCHED_MODE enum type

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	8) gprtGetPortSched

		DESCRIPTION:
			This routine gets Port Scheduling Mode.
			When usePortSched is enablied, this mode is used to select the Queue
			controller's scheduling on the port as follows:
				GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
				GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme

		SYNOPSIS:
			GT_STATUS gprtGetPortSched
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_PORT_SCHED_MODE		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_PORT_SCHED_MODE enum type

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	9) gprtSetProviderTag

		DESCRIPTION:
			This routine sets Provider Tag which indicates the provider tag (Ether 
			Type) value that needs to be matched to in ingress to determine if a
			frame is Provider tagged or not.

		SYNOPSIS:
			GT_STATUS gprtSetProviderTag
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_U16		tag
			)
			
		INPUTS:
			port 	- the logical port number
			tag 	- Provider Tag (Ether Type)

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	10) gprtGetProviderTag

		DESCRIPTION:
			This routine gets Provider Tag which indicates the provider tag (Ether 
			Type) value that needs to be matched to in ingress to determine if a
			frame is Provider tagged or not.

		SYNOPSIS:
			GT_STATUS gprtGetProviderTag
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_U16		*tag
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			tag 	- Provider Tag (Ether Type)

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.6) gtPortRateCtrl.c
	
	1) grcSetVidNrlEn

		DESCRIPTION:
			This routine enables/disables VID None Rate Limit (NRL).
			When VID NRL is enabled and the determined VID of a frame results in a VID
			whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
			will not be ingress nor egress rate limited.

		SYNOPSIS:
			GT_STATUS grcSetVidNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE to enable VID None Rate Limit
					  GT_FALSE, otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) grcGetVidNrlEn

		DESCRIPTION:
			This routine gets VID None Rate Limit (NRL) mode.
			When VID NRL is enabled and the determined VID of a frame results in a VID
			whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
			will not be ingress nor egress rate limited.

		SYNOPSIS:
			GT_STATUS grcGetVidNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE to enable VID None Rate Limit
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	3) grcSetSaNrlEn

		DESCRIPTION:
			This routine enables/disables SA None Rate Limit (NRL).
			When SA NRL is enabled and the source address of a frame results in a ATU
			hit where the SA's MAC address returns an EntryState that indicates Non
			Rate Limited, then the frame will not be ingress nor egress rate limited.

		SYNOPSIS:
			GT_STATUS grcSetSaNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE to enable SA None Rate Limit
					  GT_FALSE, otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) grcGetSaNrlEn

		DESCRIPTION:
			This routine gets SA None Rate Limit (NRL) mode.
			When SA NRL is enabled and the source address of a frame results in a ATU
			hit where the SA's MAC address returns an EntryState that indicates Non
			Rate Limited, then the frame will not be ingress nor egress rate limited.

		SYNOPSIS:
			GT_STATUS grcGetSaNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE to enable SA None Rate Limit
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) grcSetDaNrlEn

		DESCRIPTION:
			This routine enables/disables DA None Rate Limit (NRL).
			When DA NRL is enabled and the destination address of a frame results in 
			a ATU hit where the DA's MAC address returns an EntryState that indicates 
			Non Rate Limited, then the frame will not be ingress nor egress rate 
			limited.

		SYNOPSIS:
			GT_STATUS grcSetDaNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE to enable DA None Rate Limit
					  GT_FALSE, otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	6) grcGetDaNrlEn

		DESCRIPTION:
			This routine gets DA None Rate Limit (NRL) mode.
			When DA NRL is enabled and the destination address of a frame results in 
			a ATU hit where the DA's MAC address returns an EntryState that indicates 
			Non Rate Limited, then the frame will not be ingress nor egress rate 
			limited.

		SYNOPSIS:
			GT_STATUS grcGetDaNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE to enable DA None Rate Limit
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	7) grcSetELimitMode

		DESCRIPTION:
			This routine sets Egress Rate Limit counting mode.
			The supported modes are as follows:
				GT_PIRL_ELIMIT_LAYER1 -
					Count all Layer 1 bytes:
					Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
				GT_PIRL_ELIMIT_LAYER2 -
					Count all Layer 2 bytes: Frame's DA to CRC
				GT_PIRL_ELIMIT_LAYER3 -
					Count all Layer 3 bytes: 
						Frame's DA to CRC - 18 - 4 (if frame is tagged)

		SYNOPSIS:
			GT_STATUS grcSetELimitMode
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				IN  GT_PIRL_ELIMIT_MODE		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_PIRL_ELIMIT_MODE enum type

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	8) grcGetELimitMode

		DESCRIPTION:
			This routine gets Egress Rate Limit counting mode.
			The supported modes are as follows:
				GT_PIRL_ELIMIT_LAYER1 -
					Count all Layer 1 bytes:
					Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
				GT_PIRL_ELIMIT_LAYER2 -
					Count all Layer 2 bytes: Frame's DA to CRC
				GT_PIRL_ELIMIT_LAYER3 -
					Count all Layer 3 bytes: 
						Frame's DA to CRC - 18 - 4 (if frame is tagged)

		SYNOPSIS:
			GT_STATUS grcGetELimitMode
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT	port,
				OUT GT_PIRL_ELIMIT_MODE		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_PIRL_ELIMIT_MODE enum type

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	9) grcSetRsvdNrlEn

		DESCRIPTION:
			This routine sets Reserved Non Rate Limit.
			When this feature is enabled, frames that match the requirements of the 
			Rsvd2Cpu bit below will also be considered to be ingress and egress non 
			rate limited.

		SYNOPSIS:
			GT_STATUS grcSetRsvdNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_BOOL  	en
			)
			
		INPUTS:
			en 	- GT_TRUE to enable Reserved Non Rate Limit
				  GT_FALSE to disable

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	10) grcGetRsvdNrlEn

		DESCRIPTION:
			This routine gets Reserved Non Rate Limit.
			When this feature is enabled, frames that match the requirements of the 
			Rsvd2Cpu bit below will also be considered to be ingress and egress non 
			rate limited.

		SYNOPSIS:
			GT_STATUS grcGetRsvdNrlEn
			(
			    IN  GT_QD_DEV	*dev,
			    OUT GT_BOOL  	*en
			)
			
		INPUTS:
			None.

		OUTPUTS:
			en 	- GT_TRUE to enable Reserved Non Rate Limit
				  GT_FALSE to disable

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.



9.7) gtPortRmon.c
	
	1) gstatsGetRealtimePortCounter

		DESCRIPTION:
			This routine gets a specific realtime counter of the given port

		SYNOPSIS:
			GT_STATUS gstatsGetRealtimePortCounter
			(
				IN  GT_QD_DEV		*dev,
				IN  GT_LPORT		port,
				IN  GT_STATS_COUNTERS3	counter,
				OUT GT_U32			*statsData
			)
			
		INPUTS:
			port 	- the logical port number
			counter	- the counter which will be read

		OUTPUTS:
			statsData 	- points to 32bit data storage for the MIB counter

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.8) gtQosMap.c
	
	1) gqosSetVIDFPriOverride

		DESCRIPTION:
			This routine sets VID Frame Priority Override. When this feature is enabled,
			VID Frame priority overrides can occur on this port.
			VID Frame priority override occurs when the determined VID of a frame 
			results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
			When this occurs the VIDFPri value assigned to the frame's VID (in the 
			VTU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new VIDFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetVIDFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for VID Frame Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gqosGetVIDFPriOverride

		DESCRIPTION:
			This routine gets VID Frame Priority Override. When this feature is enabled,
			VID Frame priority overrides can occur on this port.
			VID Frame priority override occurs when the determined VID of a frame 
			results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
			When this occurs the VIDFPri value assigned to the frame's VID (in the 
			VTU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new VIDFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetVIDFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for VID Frame Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.



	3) gqosSetSAFPriOverride

		DESCRIPTION:
			This routine sets Source Address(SA) Frame Priority Override. 
			When this feature is enabled, SA Frame priority overrides can occur on 
			this port.
			SA ATU Frame priority override occurs when the determined source address
			of a frame results in an ATU hit where the SA's MAC address entry contains 
			the useATUFPri field set to GT_TRUE.
			When this occurs the ATUFPri value assigned to the frame's SA (in the 
			ATU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new ATUFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetSAFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for SA Frame Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) gqosGetSAFPriOverride

		DESCRIPTION:
			This routine gets Source Address(SA) Frame Priority Override. 
			When this feature is enabled, SA Frame priority overrides can occur on 
			this port.
			SA ATU Frame priority override occurs when the determined source address
			of a frame results in an ATU hit where the SA's MAC address entry contains 
			the useATUFPri field set to GT_TRUE.
			When this occurs the ATUFPri value assigned to the frame's SA (in the 
			ATU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new ATUFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetSAFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for SA Frame Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) gqosSetDAFPriOverride

		DESCRIPTION:
			This routine sets Destination Address(DA) Frame Priority Override. 
			When this feature is enabled, DA Frame priority overrides can occur on 
			this port.
			DA ATU Frame priority override occurs when the determined destination address
			of a frame results in an ATU hit where the DA's MAC address entry contains 
			the useATUFPri field set to GT_TRUE.
			When this occurs the ATUFPri value assigned to the frame's DA (in the 
			ATU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new ATUFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetDAFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for DA Frame Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	6) gqosGetDAFPriOverride

		DESCRIPTION:
			This routine gets Destination Address(DA) Frame Priority Override. 
			When this feature is enabled, DA Frame priority overrides can occur on 
			this port.
			DA ATU Frame priority override occurs when the determined destination address
			of a frame results in an ATU hit where the DA's MAC address entry contains 
			the useATUFPri field set to GT_TRUE.
			When this occurs the ATUFPri value assigned to the frame's DA (in the 
			ATU Table) is used to overwrite the frame's previously determined frame 
			priority. If the frame egresses tagged the priority in the frame will be
			this new ATUFPri value. This function does not affect the egress queue
			priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetDAFPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for DA Frame Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	7) gqosSetVIDQPriOverride

		DESCRIPTION:
			This routine sets VID Queue Priority Override. When this feature is enabled,
			VID Queue priority overrides can occur on this port.
			VID Queue priority override occurs when the determined VID of a frame 
			results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
			When this occurs the VIDQPri value assigned to the frame's VID (in the 
			VTU Table) is used to overwrite the frame's previously determined queue 
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new VIDQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetVIDQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for VID Queue Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	8) gqosGetVIDQPriOverride

		DESCRIPTION:
			This routine gets VID Queue Priority Override. When this feature is enabled,
			VID Queue priority overrides can occur on this port.
			VID Queue priority override occurs when the determined VID of a frame 
			results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
			When this occurs the VIDQPri value assigned to the frame's VID (in the 
			VTU Table) is used to overwrite the frame's previously determined queue 
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new VIDQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetVIDQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for VID Queue Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	9) gqosSetSAQPriOverride

		DESCRIPTION:
			This routine sets Source Address(SA) Queue Priority Override. 
			When this feature is enabled, SA Queue priority overrides can occur on 
			this port.
			SA ATU Queue priority override occurs when the determined source address
			of a frame results in an ATU hit where the SA's MAC address entry contains 
			the useATUQPri field set to GT_TRUE.
			When this occurs the ATUQPri value assigned to the frame's SA (in the 
			ATU Table) is used to overwrite the frame's previously determined queue 
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new ATUQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetSAQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for SA Queue Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	10) gqosGetSAQPriOverride

		DESCRIPTION:
			This routine gets Source Address(SA) Queue Priority Override. 
			When this feature is enabled, SA Queue priority overrides can occur on 
			this port.
			SA ATU Queue priority override occurs when the determined source address
			of a frame results in an ATU hit where the SA's MAC address entry contains 
			the useATUQPri field set to GT_TRUE.
			When this occurs the ATUQPri value assigned to the frame's SA (in the 
			ATU Table) is used to overwrite the frame's previously determined queue 
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new ATUQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetSAQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for SA Queue Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	11) gqosSetDAQPriOverride

		DESCRIPTION:
			This routine sets Destination Address(DA) Queue Priority Override. 
			When this feature is enabled, DA Queue priority overrides can occur on 
			this port.
			DA ATU Queue priority override occurs when the determined destination address
			of a frame results in an ATU hit where the DA's MAC address entry contains 
			the useATUQPri field set to GT_TRUE.
			When this occurs the ATUQPri value assigned to the frame's DA (in the 
			ATU Table) is used to overwrite the frame's previously determined queue
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new ATUQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetDAQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for DA Queue Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	12) gqosGetDAQPriOverride

		DESCRIPTION:
			This routine gets Destination Address(DA) Queue Priority Override. 
			When this feature is enabled, DA Queue priority overrides can occur on 
			this port.
			DA ATU Queue priority override occurs when the determined destination address
			of a frame results in an ATU hit where the DA's MAC address entry contains 
			the useATUQPri field set to GT_TRUE.
			When this occurs the ATUQPri value assigned to the frame's DA (in the 
			ATU Table) is used to overwrite the frame's previously determined queue
			priority. If the frame egresses tagged the priority in the frame will not
			be modified by this new ATUQPri value. This function affects the egress
			queue priority (QPri) the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetDAQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for DA Queue Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	13) gqosSetARPQPriOverride

		DESCRIPTION:
			This routine sets ARP Queue Priority Override. 
			When this feature is enabled, ARP Queue priority overrides can occur on 
			this port.
			ARP Queue priority override occurs for all ARP frames.
			When this occurs, the frame's previously determined egress queue priority
			will be overwritten with ArpQPri.
			If the frame egresses tagged the priority in the frame will not
			be modified. When used, the two bits of the ArpQPri priority determine the
			egress queue the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosSetARPQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				IN  GT_BOOL		mode
			)
			
		INPUTS:
			port 	- the logical port number
			mode 	- GT_TRUE for ARP Queue Priority Override,
					  GT_FALSE otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	14) gqosGetARPQPriOverride

		DESCRIPTION:
			This routine gets ARP Queue Priority Override. 
			When this feature is enabled, ARP Queue priority overrides can occur on 
			this port.
			ARP Queue priority override occurs for all ARP frames.
			When this occurs, the frame's previously determined egress queue priority
			will be overwritten with ArpQPri.
			If the frame egresses tagged the priority in the frame will not
			be modified. When used, the two bits of the ArpQPri priority determine the
			egress queue the frame is switched into.

		SYNOPSIS:
			GT_STATUS gqosGetARPQPriOverride
			(
				IN  GT_QD_DEV	*dev,
				IN  GT_LPORT	port,
				OUT GT_BOOL		*mode
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			mode 	- GT_TRUE for ARP Queue Priority Override,
					  GT_FALSE otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	15) gqosSetQPriValue

		DESCRIPTION:
			This routine sets Queue priority value to used when forced.
			When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
			are mapped to the priority queue defined in this value, unless a VTU, SA,
			DA or ARP priority override occurs. The Frame's priority (FPri) is not
			effected by this value.

		SYNOPSIS:
			GT_STATUS gqosSetQPriValue
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    IN  GT_U8      pri
			)
			
		INPUTS:
			port 	- the logical port number
			pri 	- Queue priority value

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - if pri > 3
			GT_NOT_SUPPORTED - if current device does not support this feature.


	16) gqosGetQPriValue

		DESCRIPTION:
			This routine gets Queue priority value to used when forced.
			When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
			are mapped to the priority queue defined in this value, unless a VTU, SA,
			DA or ARP priority override occurs. The Frame's priority (FPri) is not
			effected by this value.

		SYNOPSIS:
			GT_STATUS gqosGetQPriValue
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    OUT GT_U8      *pri
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			pri 	- Queue priority value

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	17) gqosSetForceQPri

		DESCRIPTION:
			This routine enables/disables forcing Queue priority.
			When ForceQPri is disabled, normal priority queue mapping is used on all 
			ingressing frames entering this port. When it's enabled, all frames
			entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
			a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
			is not effected by this feature.

		SYNOPSIS:
			GT_STATUS gqosSetForceQPri
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    IN  GT_BOOL    en
			)
			
		INPUTS:
			port 	- the logical port number
			en 		- GT_TRUE, to force Queue Priority
					  GT_FALSE, otherwise

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	18) gqosGetForceQPri

		DESCRIPTION:
			This routine checks if forcing Queue priority is enabled.
			When ForceQPri is disabled, normal priority queue mapping is used on all 
			ingressing frames entering this port. When it's enabled, all frames
			entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
			a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
			is not effected by this feature.

		SYNOPSIS:
			GT_STATUS gqosGetForceQPri
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    OUT GT_BOOL    *en
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			en 		- GT_TRUE, to force Queue Priority
					  GT_FALSE, otherwise

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	19) gqosSetDefFPri

		DESCRIPTION:
			This routine sets the default frame priority (0 ~ 7).
			This priority is used as the default frame priority (FPri) to use when 
			no other priority information is available.

		SYNOPSIS:
			GT_STATUS gqosSetDefFPri
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    IN  GT_U8      pri
			)
			
		INPUTS:
			port 	- the logical port number
			pri  	- default frame priority

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - if pri > 7
			GT_NOT_SUPPORTED - if current device does not support this feature.


	20) gqosGetDefFPri

		DESCRIPTION:
			This routine gets the default frame priority (0 ~ 7).
			This priority is used as the default frame priority (FPri) to use when 
			no other priority information is available.

		SYNOPSIS:
			GT_STATUS gqosGetDefFPri
			(
			    IN  GT_QD_DEV  *dev,
			    IN  GT_LPORT   port,
			    OUT  GT_U8      *pri
			)
			
		INPUTS:
			port 	- the logical port number

		OUTPUTS:
			pri  	- default frame priority

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	21) gqosSetArpQPri

		DESCRIPTION:
			This routine sets ARP queue Priority to use for ARP QPri Overridden 
			frames. When a ARP frame is received on a por tthat has its ARP 
			QPriOVerride is enabled, the QPri assigned to the frame comes from
			this value

		SYNOPSIS:
			GT_STATUS gqosSetArpQPri
			(
			    IN  GT_QD_DEV *dev,
			    IN  GT_U8     pri
			)
			
		INPUTS:
			pri  	- ARP Queue Priority (0 ~ 3)

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_BAD_PARAM  - if pri > 3
			GT_NOT_SUPPORTED - if current device does not support this feature.


	22) gqosGetArpQPri

		DESCRIPTION:
			This routine gets ARP queue Priority to use for ARP QPri Overridden 
			frames. When a ARP frame is received on a por tthat has its ARP 
			QPriOVerride is enabled, the QPri assigned to the frame comes from
			this value

		SYNOPSIS:
			GT_STATUS gqosGetArpQPri
			(
			    IN  GT_QD_DEV *dev,
			    OUT GT_U8     *pri
			)
			
		INPUTS:
			None.

		OUTPUTS:
			pri  	- ARP Queue Priority (0 ~ 3)

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.8) gtSysCtrl.c
	
	1) gsysSetUsePortSchedule

		DESCRIPTION:
			This routine sets per port scheduling mode

		SYNOPSIS:
			GT_STATUS gsysSetUsePortSchedule
			(
			    IN  GT_QD_DEV *dev,
			    IN  GT_BOOL   en
			)
			
		INPUTS:
			en 	- GT_TRUE to enable per port scheduling
				  GT_FALSE to disable

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	2) gsysGetUsePortSchedule

		DESCRIPTION:
			This routine gets per port scheduling mode

		SYNOPSIS:
			GT_STATUS gsysGetUsePortSchedule
			(
			    IN  GT_QD_DEV *dev,
			    OUT GT_BOOL   *en
			)
			
		INPUTS:
			None.

		OUTPUTS:
			en 	- GT_TRUE to enable per port scheduling
				  GT_FALSE to disable

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	3) gsysSetOldHader

		DESCRIPTION:
			This routine sets Egress Old Header.
			When this feature is enabled and frames are egressed with a Marvell Header, 
			the format of the Header is slightly modified to be backwards compatible 
			with previous devices that used the original Header. Specifically, bit 3
			of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
			is available in the Header.

		SYNOPSIS:
			GT_STATUS gsysSetOldHader
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_BOOL  	en
			)
			
		INPUTS:
			en 	- GT_TRUE to enable Old Header Mode
				  GT_FALSE to disable

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	4) gsysGetOldHader

		DESCRIPTION:
			This routine gets Egress Old Header.
			When this feature is enabled and frames are egressed with a Marvell Header, 
			the format of the Header is slightly modified to be backwards compatible 
			with previous devices that used the original Header. Specifically, bit 3
			of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
			is available in the Header.

		SYNOPSIS:
			GT_STATUS gsysGetOldHader
			(
			    IN  GT_QD_DEV	*dev,
			    OUT GT_BOOL  	*en
			)
			
		INPUTS:
			None.

		OUTPUTS:
			en 	- GT_TRUE to enable Old Header Mode
				  GT_FALSE to disable

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	5) gsysSetRecursiveStrippingDisable

		DESCRIPTION:
			This routine determines if recursive tag stripping feature needs to be
			disabled.

		SYNOPSIS:
			GT_STATUS gsysSetRecursiveStrippingDisable
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_BOOL  	en
			)
			
		INPUTS:
			en 	- GT_TRUE to enable Recursive Tag Stripping
				  GT_FALSE to disable

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	6) gsysGetRecursiveStrippingDisable

		DESCRIPTION:
			This routine checks if recursive tag stripping feature is disabled.

		SYNOPSIS:
			GT_STATUS gsysGetRecursiveStrippingDisable
			(
			    IN  GT_QD_DEV	*dev,
			    OUT GT_BOOL  	*en
			)
			
		INPUTS:
			None.

		OUTPUTS:
			en 	- GT_TRUE to enable Recursive Tag Stripping
				  GT_FALSE to disable

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	7) gsysSetCPUPort

		DESCRIPTION:
			This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
			frames are destined.

		SYNOPSIS:
			GT_STATUS gsysSetCPUPort
			(
			    IN  GT_QD_DEV	*dev,
			    IN  GT_LPORT 	cpuPort
			)
			
		INPUTS:
			cpuPort 	- CPU Port

		OUTPUTS:
			None.

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


	8) gsysGetCPUPort

		DESCRIPTION:
			This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
			frames are destined.

		SYNOPSIS:
			GT_STATUS gsysGetCPUPort
			(
			    IN  GT_QD_DEV	*dev,
			    OUT GT_LPORT 	*cpuPort
			)
			
		INPUTS:
			None.

		OUTPUTS:
			cpuPort 	- CPU Port

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.


9.9) gtSysStatus.c
	
	1) gsysGetFreeQSize

		DESCRIPTION:
			This routine gets Free Queue Counter. This counter reflects the 
			current number of unalllocated buffers available for all the ports.

		SYNOPSIS:
			GT_STATUS gsysGetFreeQSize
			(
			    IN  GT_QD_DEV	*dev,
			    OUT GT_U16 		*count
			)
			
		INPUTS:
			None.

		OUTPUTS:
			count 	- Free Queue Counter

		RETURNS:
			GT_OK         - on success
			GT_FAIL       - on error
			GT_NOT_SUPPORTED - if current device does not support this feature.

Index: athrs_qos.c
===================================================================
--- athrs_qos.c	(revision 0)
+++ athrs_qos.c	(revision 15908)
@@ -0,0 +1,196 @@
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include "athrs_qos.h"
+
+int athrs_config_qos(struct eth_cfg_params *ethcfg, int cmd)
+{
+    struct ath_qops *qmac;
+    struct net_device *dev;
+
+    if(cmd != S26_QOS_CTL)
+        return -EINVAL;
+
+    cmd = ethcfg->cmd;
+    qmac = get_qmac(ethcfg->ad_name);
+    dev = get_ndev(ethcfg->ad_name);
+    if (((cmd != ETH_SOFT_CLASS) && (qmac->qos_cap == 0))
+         && !(cmd == ETH_PORT_ILIMIT
+         || cmd == ETH_PORT_ELIMIT
+         || cmd == ETH_PORT_EQLIMIT)) {
+
+        printk("QOS capability not enabled\n");
+        return -EINVAL;
+    }
+
+    netif_carrier_off(dev);
+    netif_stop_queue(dev);
+    printk(KERN_INFO "Qos Config %x,%x,%s,%x,%x,%x\n",cmd,ethcfg->val,ethcfg->ad_name,ethcfg->portnum,
+		ethcfg->vlanid,ethcfg->mac_addr[0]);
+    switch(cmd){
+        case ETH_SOFT_CLASS:
+            if( (ethcfg->val > 0) && (qmac->qos_cap == 0) ) {
+                qmac->enable_qos(ethcfg->ad_name);
+            }else if((ethcfg->val == 0) && (qmac->qos_cap != 0)){
+                qmac->disable_qos(ethcfg->ad_name);
+            }         
+            break;
+        case ETH_PORT_QOS:
+            if(ethcfg->val >= 0 && ethcfg->val < 4 ) {
+                qmac->reg_rmw_clear(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + (ethcfg->portnum * 256),
+                      (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN));
+       
+                qmac->reg_rmw_set(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + 
+                      (ethcfg->portnum * 256),ATHR_PORT_PRI_EN);
+       
+                qmac->reg_rmw_clear(ethcfg->ad_name,PORT_BASE_VLAN_REGISTER0 + 
+                      (ethcfg->portnum * 256),(0x3 << 28));
+
+                qmac->reg_rmw_set(ethcfg->ad_name,PORT_BASE_VLAN_REGISTER0 + 
+                      (ethcfg->portnum * 256),((ethcfg->val & 0xf) << 28));
+            }
+            break;
+        case ETH_VLAN_QOS:
+            if (ethcfg->val >= 0 && ethcfg->val < 8) {
+                int portmap = 0;
+                int i;
+                python_ioctl_vlan_qos(ethcfg->vlanid, ethcfg->val, &portmap);
+                for(i=1; i<5; i++){
+                    if((portmap & (0x1 << i)) != 0){
+                    qmac->reg_rmw_clear(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + (i * 256),
+                         (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_PORT_PRI_EN));
+
+                    qmac->reg_rmw_set(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + 
+                         (i * 256),ATHR_VLAN_PRI_EN);
+                    }
+                }
+            }
+            break;
+        case ETH_IP_QOS:
+            {
+                int i;
+                for(i=1; i<5; i++){
+                    qmac->reg_rmw_clear(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + (i * 256),
+                         (ATHR_DA_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+
+                    qmac->reg_rmw_set(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 +
+                         (i * 256),ATHR_TOS_PRI_EN);
+                }
+                if(ethcfg->tos != 0 || ethcfg->val != 0){
+                    qmac->reg_rmw_clear(ethcfg->ad_name, ATHR_IP_PRI_MAP0 + (((ethcfg->tos >> 1)/32)<<2),
+                         0x3 << ((ethcfg->tos%64) >> 1));
+
+                    qmac->reg_rmw_set(ethcfg->ad_name, ATHR_IP_PRI_MAP0 + (((ethcfg->tos >> 1)/32)<<2),
+                         ethcfg->val << ((ethcfg->tos%64) >> 1));
+                }
+            }
+            break;
+        case ETH_DA_QOS:
+            if (ethcfg->val >= 0 && ethcfg->val < 4) {
+                int i=0;
+                for(i=1; i<5; i++){
+                    qmac->reg_rmw_clear(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + (i * 256),
+                        (ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+                    qmac->reg_rmw_set(ethcfg->ad_name,ATHR_PRI_CTRL_PORT_0 + 
+                         (i * 256),ATHR_DA_PRI_EN);
+                }
+                python_fdb_add_qos(ethcfg->mac_addr, (ethcfg->val & 0x3),(ethcfg->portnum));
+            }
+            break;
+        case ETH_PORT_ILIMIT:
+			{
+                int val;
+                val = ethcfg->val & 0x7fff;
+                qmac->reg_rmw_clear(ethcfg->ad_name, RATE_LIMIT_REGISTER0 + 
+                      (ethcfg->portnum * 256), 0x7fff);
+                qmac->reg_rmw_set(ethcfg->ad_name, RATE_LIMIT_REGISTER0 +
+                      (ethcfg->portnum * 256), val);
+			}
+            break;
+        case ETH_PORT_ELIMIT:
+            {
+                int val;
+
+                qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 + 
+                      (ethcfg->portnum * 256), 0x7fff7fff);
+                qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 + 
+                      (ethcfg->portnum * 256), 0x7fff7fff);
+                qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 + 
+                      (ethcfg->portnum * 256), 0x7fff7fff);
+                qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 + 
+                      (ethcfg->portnum * 256), 0x7fff7fff);
+
+                val = ethcfg->val & 0x7fff;
+                if(val != 0x7fff){
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT_REGISTER0 +
+                          (ethcfg->portnum * 256), (0x1 << 23));
+
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), 0x7fff<<16);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), val<<16);
+                }else{
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT_REGISTER0 +
+                          (ethcfg->portnum * 256), (0x1 << 23));
+ 
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 + 
+                          (ethcfg->portnum * 256), 0x7fff<<16);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), val<<16);
+                }
+            }
+            break;	
+        case ETH_PORT_EQLIMIT:
+            {
+                int val;
+                int queue_id;
+                val = ethcfg->val & 0x7fff;
+                queue_id = ethcfg->phy_reg;
+
+                qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT_REGISTER0 +
+                      (ethcfg->portnum * 256), (0x1 << 23));
+                qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                      (ethcfg->portnum * 256), 0x7fff<<16);
+                qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                      (ethcfg->portnum * 256), 0x7fff);
+
+                if (0 == queue_id) {
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 +
+                          (ethcfg->portnum * 256), 0x7fff);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 +
+                          (ethcfg->portnum * 256), val);
+                } else if (1 == queue_id) {
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 +
+                          (ethcfg->portnum * 256), 0x7fff<<16);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT1_REGISTER0 +
+                          (ethcfg->portnum * 256), val<<16);
+                } else if (2 == queue_id) {
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), 0x7fff);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), val);
+                } else if (3 == queue_id) {
+                    qmac->reg_rmw_clear(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 + 
+                          (ethcfg->portnum * 256), 0x7fff<<16);
+                    qmac->reg_rmw_set(ethcfg->ad_name,RATE_LIMIT2_REGISTER0 +
+                          (ethcfg->portnum * 256), val<<16);
+                }			
+            }
+            break;
+        default:
+            break;
+    }
+    
+    if(!netif_carrier_ok(dev)) {
+        netif_carrier_on(dev);
+        netif_start_queue(dev);
+    }
+    return 0;
+}
+
+int athr_register_qos(void *mac)
+{
+    set_mac_qops(mac);
+    return 0;
+}   
Index: athrf1_phy.c
===================================================================
--- athrf1_phy.c	(revision 0)
+++ athrf1_phy.c	(revision 15908)
@@ -0,0 +1,385 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include "ag7240_phy.h"
+#include "ag7240.h"
+#include "eth_diag.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+//extern int ag7240_check_link(ag7240_mac_t *);
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    
+    phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+    phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, (ATHR_ADVERTISE_1000FULL));
+    phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printk(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printk(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printk(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printk(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+    int       phyUnit = 0;
+    int       liveLinks = 0;
+
+    athr_auto_neg(ethUnit,phyUnit);
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+        liveLinks++;
+        ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+    } else {
+        ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+    }
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return AG7240_PHY_SPEED_10T;
+        case 1:
+            return AG7240_PHY_SPEED_100TX;
+        case 2:
+            return AG7240_PHY_SPEED_1000T;
+        default:
+            printk("Unkown speed read!\n");
+        }
+    }
+
+    //printk("athr_phy_speed: link down, returning 10t\n");
+    return AG7240_PHY_SPEED_10T;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+         * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+        else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
Index: athrs16_phy.c
===================================================================
--- athrs16_phy.c	(revision 0)
+++ athrs16_phy.c	(revision 15908)
@@ -0,0 +1,799 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright Â© 2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include "ag7240_phy.h"
+/*#include "ag7240.h"
+#include "eth_diag.h"*/
+#include "athrs16_phy.h" 
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+
+/*depend on connection between cpu mac and s16 mac*/
+#if defined (CONFIG_PORT0_AS_SWITCH)
+#define ENET_UNIT_LAN 0  
+#define ENET_UNIT_WAN 1
+#define CFG_BOARD_AP96 1
+
+#elif defined (CONFIG_AG7240_GE0_IS_CONNECTED)
+#define ENET_UNIT_LAN 0  
+#define CFG_BOARD_PB45 0
+#define CFG_BOARD_AP96 1
+
+#else
+#define ENET_UNIT_LAN 1  
+#define ENET_UNIT_WAN 0
+#define CFG_BOARD_PB45 1
+#endif
+
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS16"
+extern int xmii_val;
+extern int ag7240_open(struct net_device *dev);
+extern int ag7240_stop(struct net_device *dev);
+extern ag7240_mac_t *ag7240_macs[2];
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,//ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+static void phy_mode_setup(void);
+
+static void phy_mode_setup(void) 
+{
+#ifdef ATHRS16_VER_1_0
+    printk("phy_mode_setup\n");
+
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+#endif
+}
+
+void athrs16_reg_init(int ethUinit)
+{
+    /* if using header for register configuration, we have to     */
+    /* configure s16 register after frame transmission is enabled */
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /*tx delay*/   
+    athrs16_reg_write(0x108, 0x2be0001);  /*mac0 rgmii mode*/ 
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x8, 0x012e1bea);
+    athrs16_reg_write(0x8, 0x01261be2);
+#endif
+    
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER0, 0x7e);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER1, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER2, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER3, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER4, 0x200);
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+    printk("CFG Board PB45 \n");
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x600, 0x0);
+    printk("CFG Board AP96 \n");
+    athrs16_reg_write(0x600, 0x200);
+#endif
+
+    athrs16_reg_write(S16_FLD_MASK_REG, 0x003f003f);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)        
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6004);
+#endif
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4, 0x6004);    
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5, 0x6004);    
+#else
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+#endif
+
+#ifdef FULL_FEATURE
+	hsl_dev_init(0, 2);
+#endif
+
+#if 1
+   /* Enable ARP packets to CPU port */
+    athrs16_reg_write(S16_ARL_TBL_CTRL_REG,(athrs16_reg_read(S16_ARL_TBL_CTRL_REG) | 0x100000));
+   /* Enable Broadcast packets to CPU port */
+//    athrs16_reg_write(S16_FLD_MASK_REG,(athrs16_reg_read(S16_FLD_MASK_REG) | S16_ENABLE_CPU_BROADCAST ));
+    athrs16_reg_write(S16_FLD_MASK_REG,0x003f003f | S16_ENABLE_CPU_BROADCAST); // enable multicast and unicast on all ports, in case that bootloader did not initialize it in correct way
+    //jumbo, 8316 only
+    athrs16_reg_write(0x30,(athrs16_reg_read(0x30)&AR8316_GCTRL_MTU)|(9018 + 8 + 2));
+
+#endif
+#ifndef CONFIG_S26_SWITCH_ONLY_MODE
+    athrs16_reg_write(S16_CPU_PORT_REGISTER,0x000001f0);
+
+
+#if 0
+// config wan = port 4, lan = 0 - 3
+    /* Recognize tag packet from CPU */
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER0,0xc03e0001); // 1111100000000000000001
+    /* Insert PVID 1 to LAN ports */
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER1,0x001d0001); //  111010000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER2,0x001b0001); //  110110000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER3,0x00170001); //  101110000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER4,0x000f0001); //  011110000000000000001
+   /* Insert PVID 2 to WAN port */
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER5,0x00010002); // 0000010000000000000010
+
+   /* Egress tag packet to CPU and untagged packet to LAN port */
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0,0x00006204);
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5,0x00006104);
+
+  /* Group port - 0,1,2,3 to VID 1 */
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER1,0x0000081f); // 100000011111
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER0,0x0001000a);
+
+  /*  port - 4  to VID 2 */
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER1,0x00000821); // 100000100001
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER0,0x0002000a); 
+
+
+#else
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER0,0xc03e0001); // 1111100000000000000001
+
+    /* Insert PVID 1 to LAN ports */
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER1,0x00010002); // 0000010000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER2,0x00390001); // 1110010000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER3,0x00350001); // 1101010000000000000001
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER4,0x002d0001); // 1011010000000000000001
+
+   /* Insert PVID 2 to WAN port */
+    athrs16_reg_write(S16_PORT_BASE_VLAN_REGISTER5,0x001d0001); // 0111010000000000000010
+
+
+   /* Egress tag packet to CPU and untagged packet to LAN port */
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0,0x00006204);
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4,0x00006104);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5,0x00006104);
+
+  /* Group port - 0,1,2,3 to VID 1 */
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER1,0x0000083d); // 100000111101
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER0,0x0001000a);
+
+  /*  port - 4  to VID 2 */
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER1,0x00000803); // 100000000011
+    athrs16_reg_write(S16_VLAN_FUNC_REGISTER0,0x0002000a); 
+
+#endif
+
+
+
+#endif
+    athr16_init_flag = 1;
+    printk("athrs16_reg_init complete.\n");
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    mdelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            mdelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+        
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                mdelay(10);
+            } while(--ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    ag7240_phy_speed_t phySpeed = 0;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = AG7240_PHY_SPEED_10T;
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                mdelay(10);
+            }while(--ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = AG7240_PHY_SPEED_10T;
+                break;
+            case 1:
+                phySpeed = AG7240_PHY_SPEED_100TX;
+                break;
+            case 2:
+                phySpeed = AG7240_PHY_SPEED_1000T;
+                break;
+            default:
+                printk("Unkown speed read!\n");
+            }
+        } 
+
+        phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+        
+        if(phySpeed == AG7240_PHY_SPEED_100TX) {
+            phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {            
+            phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = AG7240_PHY_SPEED_1000T;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                printk("\nenet%d port%d up\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
+void athrs16_reg_dev(ag7240_mac_t **mac)
+{
+    if( mac[0]) {
+    ag7240_macs[0] = mac[0];
+    ag7240_macs[0]->mac_speed = 0xff;
+    }
+    else
+      printk("MAC [0] not registered \n");
+
+    if( mac[1]) {
+    ag7240_macs[1] = mac[1];
+    ag7240_macs[1]->mac_speed = 0xff;
+    }
+    else
+      printk("MAC [1] not registered \n");
+    return;
+
+}
+
+
+int athrs16_ioctl(struct eth_cfg_params *etd, int cmd)
+{
+//    uint32_t ar7240_revid;
+    if(cmd  == S26_RD_PHY) {
+        if(etd->portnum != 0xf)
+            etd->val = phy_reg_read(0,etd->portnum,etd->phy_reg);
+        else
+            etd->val = athrs16_reg_read(etd->phy_reg);
+    }
+    else if(cmd  == S26_WR_PHY) {
+        if(etd->portnum != 0xf)
+            phy_reg_write(0,etd->portnum,etd->phy_reg,etd->val);
+        else
+            athrs16_reg_write(etd->phy_reg,etd->val);
+    }
+    else
+        return -EINVAL;
+
+    return 0;
+}
+
+
Index: athrs_qos.h
===================================================================
--- athrs_qos.h	(revision 0)
+++ athrs_qos.h	(revision 15908)
@@ -0,0 +1,289 @@
+#ifndef _ATHRS_QOPS_H
+#define _ATHRS_QOPS_H 1
+
+#include "athrs_ioctl.h"
+
+#if defined(CONFIG_MACH_AR7240)
+
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#include "ag7240_mac.h"
+extern ag7240_mac_t *ag7240_macs[2];
+
+#ifdef CONFIG_AR7240_S26_PHY
+#include "ar7240_s26_phy.h"
+#endif
+
+#ifdef CONFIG_AR7242_RGMII_PHY
+#include "athrf1_phy.h"
+#endif
+
+#ifdef CONFIG_AR7242_S16_PHY
+#include "athrs16_phy.h"
+#endif
+
+static uint32_t
+ag7240_mac_reg_read(char *ad_name,uint32_t Reg) {
+
+#ifdef CONFIG_AR7242_S16_PHY
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+
+    if (mac->mac_unit == 1 && is_ar7242()) 
+        return (athrs16_reg_read(Reg));
+    else
+#endif
+        return (athrs26_reg_read(Reg));
+
+}
+
+static void
+ag7240_mac_reg_write(char *ad_name,uint32_t Reg, uint32_t Val) 
+{
+
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+#ifdef CONFIG_AR7242_S16_PHY
+
+    if (mac->mac_unit == 1 && is_ar7242()) 
+        athrs16_reg_write(Reg,Val);
+    else
+#endif
+    printk(KERN_INFO "[%x] QoS Reg write %x=%x\n",mac->mac_unit,Reg,Val);
+        athrs26_reg_write(Reg,Val);
+    return;
+
+}
+
+static void
+ag7240_mac_reg_rmw_set(char *ad_name,uint32_t Reg, uint32_t Val) 
+{
+    int tval = ag7240_mac_reg_read(ad_name,Reg);
+
+    ag7240_mac_reg_write(ad_name,Reg,(tval | Val));
+}
+
+static void
+ag7240_mac_reg_rmw_clear(char *ad_name,uint32_t Reg, uint32_t Val) 
+{
+    int tval = ag7240_mac_reg_read(ad_name,Reg);
+
+    ag7240_mac_reg_write(ad_name,Reg,(tval & ~Val));
+}
+
+static int 
+ag7240_enable_mac_qos(char *ad_name) {
+
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+    struct net_device *dev = mac->mac_dev;
+    int val = 0;
+
+    dev->stop(dev);
+    if(mac_has_flag(mac,ETH_SWONLY_MODE))
+        return -1;
+
+    mac_set_flag(mac,WAN_QOS_SOFT_CLASS);
+
+    if (mac->mac_unit == ENET_UNIT_LAN) {
+        val = ag7240_mac_reg_read(ad_name, ATHR_CTRL_PORT_0);
+        if( (val & ATHR_HDR_EN) == 0){
+            ag7240_mac_reg_rmw_set(ad_name,ATHR_CTRL_PORT_0, ATHR_HDR_EN);
+            mac->qos->qos_flag |= 0x1 << 0;
+        } 
+
+        val = ag7240_mac_reg_read(ad_name, ATHR_CPU_PORT); 
+        if( (val & ATHR_CPU_EN) == 0){
+            ag7240_mac_reg_rmw_set(ad_name,ATHR_CPU_PORT, ATHR_CPU_EN);
+            mac->qos->qos_flag |= 0x1 << 1;
+        } 
+        ag7240_mac_reg_rmw_set(ad_name,ATHR_QOS_MODE_REGISTER,ATHR_QOS_WEIGHTED);
+
+#ifdef CONFIG_AR7242_S16_PHY
+        if (is_ar7242() && mac->mac_unit == 0)
+            mac_set_flag(mac,ATHR_S16_HEADER);
+        else
+#endif
+#ifndef CONFIG_ATHEROS_HEADER_EN
+            mac_set_flag(mac,ATHR_S26_HEADER);
+#endif
+        for (val = 1; val <= 4; val++){
+            ag7240_mac_reg_rmw_clear(ad_name,ATHR_PRI_CTRL_PORT_0 +
+              (val * 256) , (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+        }
+    }
+    else {
+     /* WAN MAC setting */
+        ag7240_mac_reg_rmw_clear(ad_name,ATHR_PRI_CTRL_PORT_0 +
+               (5 * 256) , (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+    }
+    mac->qos->qos_cap = 1;
+    dev->open(dev);
+    return 0;
+}
+
+static void 
+ag7240_disable_mac_qos(char *ad_name) {
+
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+    struct net_device *dev = mac->mac_dev;
+    int val = 0;
+
+    dev->stop(dev);
+
+    mac_clear_flag(mac,WAN_QOS_SOFT_CLASS);
+
+    if (mac->mac_unit == ENET_UNIT_LAN) {
+        if(mac->qos->qos_flag != 0){
+            if( (0x1 & mac->qos->qos_flag) != 0)
+                ag7240_mac_reg_rmw_clear(ad_name,ATHR_CTRL_PORT_0 ,ATHR_HDR_EN);
+            if( ( (0x1 << 1) & mac->qos->qos_flag) != 0)
+                ag7240_mac_reg_rmw_clear(ad_name,ATHR_CPU_PORT, ATHR_CPU_EN);
+        }
+        ag7240_mac_reg_rmw_clear(ad_name,ATHR_QOS_MODE_REGISTER,ATHR_QOS_WEIGHTED);
+
+#ifdef CONFIG_AR7242_S16_PHY
+        if (is_ar7242() && mac->mac_unit == 0)
+            mac_clear_flag(mac,ATHR_S16_HEADER);
+        else
+#endif
+#ifndef CONFIG_ATHEROS_HEADER_EN
+            mac_clear_flag(mac,ATHR_S26_HEADER);
+#endif
+        for (val = 1; val <= 4; val++){
+            ag7240_mac_reg_rmw_clear(ad_name,ATHR_PRI_CTRL_PORT_0 +
+                 (val * 256) , (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+        }
+    }
+    else {
+        /* WAN MAC setting */
+        ag7240_mac_reg_rmw_clear(ad_name,ATHR_PRI_CTRL_PORT_0 +
+                 (5 * 256) , (ATHR_DA_PRI_EN|ATHR_TOS_PRI_EN|ATHR_VLAN_PRI_EN|ATHR_PORT_PRI_EN));
+
+    }
+    mac->qos->qos_cap = 0;
+	mac->qos->qos_flag = 0;
+    dev->open(dev);
+}
+
+struct ath_qops ath_qos_ops = {
+    ag7240_mac_reg_read,
+    ag7240_mac_reg_write,
+    ag7240_mac_reg_rmw_set,
+    ag7240_mac_reg_rmw_clear,
+    ag7240_enable_mac_qos,
+    ag7240_disable_mac_qos,
+    0,
+};
+
+static inline struct ath_qops
+*get_qmac(char *ad_name)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+
+    if (mac_has_flag(mac,ETH_SWONLY_MODE))
+        mac = ag7240_unit2mac(1);
+
+    return (mac->qos);
+}
+
+static inline  struct net_device 
+*get_ndev(char *ad_name)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(ad_name);
+
+    if (mac_has_flag(mac,ETH_SWONLY_MODE))
+        mac = ag7240_unit2mac(1);
+
+    return (mac->mac_dev);
+}
+
+static inline void
+set_mac_qops(void *mac)
+{
+    ag7240_mac_t *qmac = (ag7240_mac_t *)mac;
+
+    qmac->qos = &ath_qos_ops;
+    printk("%s : %p\n",__func__,qmac->mac_dev);
+}
+
+#elif defined(CONFIG_MACH_AR7100)
+
+#include "ar7100.h"
+
+#define #define ag7100_name2mac(name)      \
+    strcmp(name,"eth0") ? ag7100_unit2mac(1) : ag7100_unit2mac(0)
+
+#if defined(CONFIG_ATHRS26_PHY)
+#include "athrs26_phy.h"
+#elif  defined(CONFIG_ATHRS16_PHY)
+#include "athrs16_phy.h"
+#endif
+
+static uint32_t
+ag7100_mac_reg_read(char *ad_name,uint32_t Reg) {
+
+#if defined(CONFIG_ATHRS26_PHY)
+    return (athrs26_reg_read(Reg));
+#elif defined(CONFIG_ATHRS16_PHY)
+    return (athrs16_reg_read(Reg));
+#endif
+
+}
+
+static void
+ag7100_mac_reg_write(char *ad_name,uint32_t Reg, uint32_t Val) {
+
+#if defined(CONFIG_ATHRS26_PHY)
+    return (athrs26_reg_write(Reg,Val));
+#elif defined(CONFIG_ATHRS16_PHY)
+    return (athrs16_reg_write(Reg,Val));
+#endif
+
+}
+
+static void
+ag7100_mac_reg_rmw_set(char *ad_name,uint32_t Reg, uint32_t Val) {
+
+    int tval = ag7100_mac_reg_read(ad_name,Reg);
+    ag7100_mac_reg_write(ad_name,Reg,(tval | Val));
+    return;
+}
+
+static void
+ag7100_mac_reg_rmw_clear(char *ad_name,uint32_t Reg, uint32_t Val) {
+
+    int tval = ag7100_mac_reg_read(ad_name,Reg);
+    ag7100_mac_reg_write(ad_name,Reg,(tval & ~Val));
+    return;
+}
+
+struct ath_qops ath_qos_ops = {
+    ag7100_mac_reg_read,
+    ag7100_mac_reg_write,
+    ag7100_mac_reg_rmw_set,
+    ag7100_mac_reg_rmw_clear,
+};
+
+static inline struct ath_qops
+*get_qmac(char *ad_name)
+{
+    ag7100_mac_t *mac = ag7100_name2mac(ad_name);
+    return (mac->qos);
+}
+
+static inline void
+set_mac_qops(void *mac)
+{
+    ag7100_mac_t *qmac = (ag7100_mac_t *)mac;
+    qmac->qos = &ath_qos_ops;
+}
+
+static inline  struct net_device 
+*get_ndev(char *ad_name)
+{
+    ag7100_mac_t *mac = ag7100_name2mac(ad_name);
+    return (mac->mac_dev);
+}
+
+#endif
+
+#endif  //_ATHRS_QOS_H
Index: athrf1_phy.h
===================================================================
--- athrf1_phy.h	(revision 0)
+++ athrf1_phy.h	(revision 15908)
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+
+#endif
Index: athrs16_phy.h
===================================================================
--- athrs16_phy.h	(revision 0)
+++ athrs16_phy.h	(revision 15908)
@@ -0,0 +1,213 @@
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+#define BITS(_s, _n)	(((1UL << (_n)) - 1) << _s)
+
+#define AR8216_REG_GLOBAL_CTRL		0x0030
+#define   AR8316_GCTRL_MTU		BITS(0, 14)
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S16 CSR Registers */
+
+#define S16_PORT_STATUS_REGISTER0            0x0100 
+#define S16_PORT_STATUS_REGISTER1            0x0200
+#define S16_PORT_STATUS_REGISTER2            0x0300
+#define S16_PORT_STATUS_REGISTER3            0x0400
+#define S16_PORT_STATUS_REGISTER4            0x0500
+#define S16_PORT_STATUS_REGISTER5            0x0600
+
+#define S16_PORT_BASE_VLAN_REGISTER0         0x0108 
+#define S16_PORT_BASE_VLAN_REGISTER1         0x0208
+#define S16_PORT_BASE_VLAN_REGISTER2         0x0308
+#define S16_PORT_BASE_VLAN_REGISTER3         0x0408
+#define S16_PORT_BASE_VLAN_REGISTER4         0x0508
+#define S16_PORT_BASE_VLAN_REGISTER5         0x0608
+
+#define S16_VLAN_FUNC_REGISTER0               0x0040
+#define S16_VLAN_FUNC_REGISTER1               0x0044
+
+
+#define S16_RATE_LIMIT_REGISTER0             0x010C
+#define S16_RATE_LIMIT_REGISTER1             0x020C
+#define S16_RATE_LIMIT_REGISTER2             0x030C
+#define S16_RATE_LIMIT_REGISTER3             0x040C
+#define S16_RATE_LIMIT_REGISTER4             0x050C
+#define S16_RATE_LIMIT_REGISTER5             0x060C
+
+#define S16_PORT_CONTROL_REGISTER0           0x0104
+#define S16_PORT_CONTROL_REGISTER1           0x0204
+#define S16_PORT_CONTROL_REGISTER2           0x0304
+#define S16_PORT_CONTROL_REGISTER3           0x0404
+#define S16_PORT_CONTROL_REGISTER4           0x0504
+#define S16_PORT_CONTROL_REGISTER5           0x0604
+
+#define S16_CPU_PORT_REGISTER                0x0078
+#define S16_MDIO_CTRL_REGISTER               0x0098
+
+#define S16_ARL_TBL_FUNC_REG0                0x0050
+#define S16_ARL_TBL_FUNC_REG1                0x0054
+#define S16_ARL_TBL_FUNC_REG2                0x0058
+#define S16_FLD_MASK_REG                     0x002c
+#define S16_ARL_TBL_CTRL_REG                 0x005c
+#define S16_GLOBAL_INTR_REG                  0x10
+#define S16_GLOBAL_INTR_MASK_REG             0x14
+#define S16_PWR_ON_STRAP_REG                 0x8
+
+
+#define S16_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S16_PHY_LINK_CHANGE_REG               0x4
+#define S16_PHY_LINK_UP               0x400
+#define S16_PHY_LINK_DOWN             0x800
+#define S16_PHY_LINK_DUPLEX_CHANGE        0x2000
+#define S16_PHY_LINK_SPEED_CHANGE         0x4000
+#define S16_PHY_LINK_INTRS            (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_PRI_CTRL_PORT_0              0x110 /* CPU PORT */
+#define ATHR_PRI_CTRL_PORT_1              0x210
+#define ATHR_PRI_CTRL_PORT_2              0x310
+#define ATHR_PRI_CTRL_PORT_3              0x410
+#define ATHR_PRI_CTRL_PORT_4              0x510
+#define ATHR_PRI_CTRL_PORT_5              0x610
+
+#define ATHR_TOS_PRI_EN                       (1 << 16)
+#define ATHR_VLAN_PRI_EN                      (1 << 17)
+#define ATHR_DA_PRI_EN                        (1 << 18)
+#define ATHR_PORT_PRI_EN                      (1 << 19)
+
+#define ATHR_QOS_MODE_REGISTER                0x030
+#define ATHR_QOS_FIXED_PRIORITY               ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED                     ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                        ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S16_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(int ethUnit);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+int athrs16_phy_is_link_alive(int phyUnit);
+void athrs16_reg_dev(ag7240_mac_t **mac);
+uint32_t athrs16_reg_read(uint32_t reg_addr);
+void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+int athrs16_ioctl(struct eth_cfg_params *ethcfg, int cmd);
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0;
+    uint16_t    priority;
+    uint16_t    type ;
+    uint16_t    broadcast;
+    uint16_t    from_cpu;
+    uint16_t    reserved1;
+    uint16_t    port_num;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+#endif
+
+
Index: athrs_ioctl.h
===================================================================
--- athrs_ioctl.h	(revision 0)
+++ athrs_ioctl.h	(revision 15908)
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS_IOCTL_H
+#define _ATHRS_IOCTL_H 1
+
+#ifndef ETHREG_TOOL_BUILD
+#include <linux/types.h>
+#include <linux/spinlock_types.h>
+#include <linux/workqueue.h>
+#include <asm/system.h>
+#include <linux/netdevice.h>
+#include <net/inet_ecn.h>                /* XXX for TOS */
+#include <linux/if_ether.h>
+#else
+#include <stdint.h>
+#endif
+#define S26_RD_PHY       (SIOCDEVPRIVATE | 0x1)
+#define S26_WR_PHY       (SIOCDEVPRIVATE | 0x2)
+#define S26_FORCE_PHY    (SIOCDEVPRIVATE | 0x3)
+
+
+struct eth_cfg_params {
+    uint16_t cmd;
+    char    ad_name[IFNAMSIZ];      /* if name, e.g. "eth0" */
+    uint16_t vlanid;
+    uint16_t portnum;           /* pack to fit, yech */
+    uint32_t phy_reg;
+    uint32_t tos;
+    uint32_t val;
+    uint8_t duplex;
+    uint8_t  mac_addr[6];
+};
+
+
+#ifdef CONFIG_ATHRS_QOS
+
+#define ETH_SOFT_CLASS   (SIOCDEVPRIVATE | 0x4)
+#define ETH_PORT_QOS     (SIOCDEVPRIVATE | 0x5)
+#define ETH_VLAN_QOS     (SIOCDEVPRIVATE | 0x6)
+#define ETH_DA_QOS       (SIOCDEVPRIVATE | 0x7)
+#define ETH_IP_QOS       (SIOCDEVPRIVATE | 0x8)
+#define ETH_PORT_ILIMIT  (SIOCDEVPRIVATE | 0x9)
+#define ETH_PORT_ELIMIT  (SIOCDEVPRIVATE | 0xa)
+#define ETH_PORT_EQLIMIT (SIOCDEVPRIVATE | 0xb)
+struct ath_qops {
+    uint32_t  (*reg_read)(char *ad_name,uint32_t Reg);
+    void      (*reg_write)(char *ad_name,uint32_t Reg, uint32_t Val);
+    void      (*reg_rmw_set)(char *ad_name,uint32_t Reg, uint32_t Val);
+    void      (*reg_rmw_clear)(char *ad_name,uint32_t Reg, uint32_t Val);
+    int       (*enable_qos)(char *ad_name);
+    void      (*disable_qos)(char *ad_name);
+    int       qos_cap;
+    int       qos_flag;
+};
+
+int athrs_config_qos(struct eth_cfg_params *ethcfg, int cmd);
+int athr_register_qos(void *mac);
+
+#endif
+
+#ifdef CONFIG_MACH_AR7240
+#define SW_ONLY_MODE     (SIOCDEVPRIVATE | 0x8)
+#define SOFT_LED_BLINK   (SIOCDEVPRIVATE | 0x9)
+#define ETH_DMA_CHECK    (SIOCDEVPRIVATE | 0xa)
+#endif
+
+#ifdef CONFIG_ATHRS_QOS
+#define  S26_QOS_CTL			(SIOCDEVPRIVATE | 0x9)
+#endif
+
+#ifdef CONFIG_AR7240_S26_VLAN_IGMP
+// Add or remove ports to the device
+// bit0--->port0;bit1--->port1.
+#define  S26_VLAN_ADDPORTS      (SIOCDEVPRIVATE | 0x4)
+#define  S26_VLAN_DELPORTS      (SIOCDEVPRIVATE | 0x5)
+
+// Set the tag mode to the port.
+#define  S26_VLAN_SETTAGMODE    (SIOCDEVPRIVATE | 0x6)
+
+// Set default vlan id to the port
+#define  S26_VLAN_SETDEFAULTID  (SIOCDEVPRIVATE | 0x7)
+
+// Enable or disable IGMP snooping based on a vlanid
+#define  S26_IGMP_ON_OFF    (SIOCDEVPRIVATE | 0x8)
+//#define  S26_IGMP_OFF         (SIOCDEVPRIVATE | 0x9)
+
+// Get a link status from the specified port.
+#define  S26_LINK_GETSTAT   (SIOCDEVPRIVATE | 0xA)
+
+#define  S26_VLAN_ENABLE    (SIOCDEVPRIVATE | 0xB)
+#define  S26_VLAN_DISABLE   (SIOCDEVPRIVATE | 0xC)
+
+#define  S26_ARL_ADD            (SIOCDEVPRIVATE | 0xD)
+#define  S26_ARL_DEL            (SIOCDEVPRIVATE | 0xE)
+
+#define  S26_MCAST_CLR      (SIOCDEVPRIVATE | 0xF)
+#define  S26_PACKET_FLAG    (SIOCDEVPRIVATE | 0x0)
+
+#define  VLAN_DEV_INFO(x) ((struct eth_vlan_dev_info *)x->priv)
+
+struct eth_vlan_dev_info {
+    unsigned long inmap[8];
+    char * outmap[16];
+    unsigned short vlan_id;
+};
+
+#endif
+
+typedef struct {
+    u_int8_t uc[6];
+} mac_addr_t;
+
+struct arl_struct {
+    mac_addr_t mac_addr;
+    int port_map;
+    int sa_drop; 
+};
+
+
+
+#endif //_ATHRS_IOCTL_H
Index: ar7240_s26_phy.h
===================================================================
--- ar7240_s26_phy.h	(revision 15022)
+++ ar7240_s26_phy.h	(working copy)
@@ -50,7 +50,7 @@
 #define BITS(_s, _n)	(((1UL << (_n)) - 1) << _s)
 #define BIT(nr)			(1UL << (nr))
 #define AR8216_REG_GLOBAL_CTRL		0x0030
-#define AR8216_GCTRL_MTU		BITS(0, 10)
+#define AR8216_GCTRL_MTU		BITS(0, 11)
 
 
 #define ATHR_RESET_DONE(phy_control)                   \
@@ -146,14 +146,21 @@
 
 /* SWITCH QOS REGISTERS */
 
-#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
-#define ATHR_QOS_PORT_1			0x210
-#define ATHR_QOS_PORT_2			0x310
-#define ATHR_QOS_PORT_3			0x410
-#define ATHR_QOS_PORT_4			0x510
+#define ATHR_PRI_CTRL_PORT_0             0x110 /* CPU PORT */
+#define ATHR_PRI_CTRL_PORT_1             0x210
+#define ATHR_PRI_CTRL_PORT_2             0x310
+#define ATHR_PRI_CTRL_PORT_3             0x410
+#define ATHR_PRI_CTRL_PORT_4             0x510
+#define ATHR_PRI_CTRL_PORT_5             0x610
 
-#define ATHR_ENABLE_TOS                 (1 << 16)
+#define ATHR_TOS_PRI_EN                      (1 << 16)
+#define ATHR_VLAN_PRI_EN                     (1 << 17)
+#define ATHR_DA_PRI_EN                       (1 << 18)
+#define ATHR_PORT_PRI_EN                     (1 << 19)
+#define ATHR_HDR_EN              (1 << 11)
+#define ATHR_CPU_EN              (1 << 8 )
 
+
 #define ATHR_QOS_MODE_REGISTER          0x030
 #define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
 #define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
@@ -166,22 +173,38 @@
 
 #undef S26_VER_1_0
 
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
 typedef enum {
-    NORMAL_PACKET, 
+    NORMAL_PACKET,
     RESERVED0,
-    MIB_1ST, 
+    MIB_1ST,
     RESERVED1,
     RESERVED2,
     READ_WRITE_REG,
     READ_WRITE_REG_ACK,
-    RESERVED3				        
+    RESERVED3
 } AT_HEADER_TYPE;
 
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
 
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
 int ag7240_hard_start(struct sk_buff *skb, struct net_device *dev);
 
-void athrs26_reg_init(void);
-void athrs26_reg_init_lan(void);
+void athrs26_reg_init(int ethUnit);
+void athrs26_reg_init_lan(int ethUnit);
 int athrs26_phy_is_up(int unit);
 int athrs26_phy_is_fdx(int unit,int phyUnit);
 int athrs26_phy_speed(int unit,int phyUnit);
@@ -192,6 +215,10 @@
 void athrs26_phy_off(ag7240_mac_t *mac);
 void athrs26_phy_on(ag7240_mac_t *mac);
 void athrs26_mac_speed_set(ag7240_mac_t *mac, ag7240_phy_speed_t speed);
+void athrs26_reg_dev(ag7240_mac_t **mac);
+int athrs26_ioctl(struct net_device *dev,void *args, int cmd);
+uint32_t athrs26_reg_read(unsigned int s26_addr);
+void athrs26_reg_write(unsigned int s26_addr, unsigned int s26_write_data);
 
 #define S26_FORCE_100M 1
 #endif
Index: ag7240.c
===================================================================
--- ag7240.c	(revision 15022)
+++ ag7240.c	(working copy)
@@ -40,15 +40,11 @@
 #include "ag7240_phy.h"
 #include "ag7240_trc.h"
 
-static ag7240_mac_t *ag7240_macs[2];
+ag7240_mac_t *ag7240_macs[2];
 static void ag7240_hw_setup(ag7240_mac_t *mac);
 static void ag7240_hw_stop(ag7240_mac_t *mac);
 static void ag7240_oom_timer(unsigned long data);
-int  ag7240_check_link(ag7240_mac_t *mac,int phyUnit);
-#ifdef CHECK_DMA_STATUS
-static int  check_for_dma_status(ag7240_mac_t *mac);
-static uint32_t prev_ts;
-#endif
+static int  check_for_dma_status(ag7240_mac_t *mac,int ac);
 static int  ag7240_tx_alloc(ag7240_mac_t *mac);
 static int  ag7240_rx_alloc(ag7240_mac_t *mac);
 static void ag7240_rx_free(ag7240_mac_t *mac);
@@ -56,11 +52,7 @@
 static int  ag7240_ring_alloc(ag7240_ring_t *r, int count);
 static int  ag7240_rx_replenish(ag7240_mac_t *mac);
 static void ag7240_get_default_macaddr(ag7240_mac_t *mac, u8 *mac_addr);
-#ifdef CONFIG_AG7240_QOS
 static int  ag7240_tx_reap(ag7240_mac_t *mac,int ac);
-#else
-static int  ag7240_tx_reap(ag7240_mac_t *mac);
-#endif
 static void ag7240_ring_release(ag7240_mac_t *mac, ag7240_ring_t  *r);
 static void ag7240_ring_free(ag7240_ring_t *r);
 static void ag7240_tx_timeout_task(struct work_struct *work);
@@ -101,18 +93,18 @@
     {"GMii", "Mii", "RGMii", "RMii"},
     {"GMii","Mii","RGMii", "RMii"}
 };
+int rg_phy_speed = -1 , rg_phy_duplex = -1;
 char *spd_str[] = {"10Mbps", "100Mbps", "1000Mbps"};
 char *dup_str[] = {"half duplex", "full duplex"};
 
 #define MODULE_NAME "AG7240"
 MODULE_LICENSE("Dual BSD/GPL");
 
+static uint32_t prev_dma_chk_ts;
 /* if 0 compute in init */
 int tx_len_per_ds = 0;
 int phy_in_reset = 0;
-#ifdef CONFIG_AG7240_QOS
 int enet_ac = 0;
-#endif
 module_param(tx_len_per_ds, int, 0);
 MODULE_PARM_DESC(tx_len_per_ds, "Size of DMA chunk");
 
@@ -141,6 +133,8 @@
 module_param(fifo_5, int, 0);
 MODULE_PARM_DESC(fifo_5, "fifo cfg 5 settings");
 
+int xmii_val = 0x16000000;
+
 int ignore_packet_inspection = 0;
 
 void set_packet_inspection_flag(int flag)
@@ -175,7 +169,7 @@
 #define AG7240_TX_MIN_DS_LEN        128
 #define AG7240_TX_MAX_DS_LEN        AG7240_TX_FIFO_LEN
 
-#define AG7240_TX_MTU_LEN           1536
+#define AG7240_TX_MTU_LEN           AG71XX_TX_MTU_LEN
 
 #define AG7240_TX_DESC_CNT          CONFIG_AG7240_NUMBER_TX_PKTS*tx_max_desc_per_ds_pkt
 #define AG7240_TX_REAP_THRESH       AG7240_TX_DESC_CNT/2
@@ -190,7 +184,7 @@
 #define ENET_UNIT_LAN 1
 #define ENET_UNIT_WAN 0
 
-#ifdef CONFIG_AG7240_QOS
+
 static inline int ag7240_tx_reap_thresh(ag7240_mac_t *mac,int ac)
 {
     ag7240_ring_t *r = &mac->mac_txring[ac];
@@ -205,22 +199,6 @@
     ag7240_trc_new(ag7240_ndesc_unused(mac, r),"tx ring full");
     return (ag7240_ndesc_unused(mac, r) < tx_max_desc_per_ds_pkt + 2);
 }
-#else
-static inline int ag7240_tx_reap_thresh(ag7240_mac_t *mac)
-{
-    ag7240_ring_t *r = &mac->mac_txring;
-
-    return (ag7240_ndesc_unused(mac, r) < AG7240_TX_REAP_THRESH);
-}
-
-static inline int ag7240_tx_ring_full(ag7240_mac_t *mac)
-{
-    ag7240_ring_t *r = &mac->mac_txring;
-
-    ag7240_trc_new(ag7240_ndesc_unused(mac, r),"tx ring full");
-    return (ag7240_ndesc_unused(mac, r) < tx_max_desc_per_ds_pkt + 2);
-}
-#endif
 static int
 ag7240_open(struct net_device *dev)
 {
@@ -234,6 +212,10 @@
 #endif
 
     assert(mac);
+    if (mac_has_flag(mac,WAN_QOS_SOFT_CLASS))
+        mac->mac_noacs = 4;
+    else
+        mac->mac_noacs = 1;
 
     st = request_irq(mac->mac_irq, ag7240_intr, 0, dev->name, dev);
     if (st < 0)
@@ -258,37 +240,34 @@
     spin_unlock_irqrestore(&mac->mac_lock, flags);
 
     ag7240_hw_setup(mac);
-#ifdef SWITCH_AHB_FREQ
-    /* 
-    * Reduce the AHB frequency to 100MHz while setting up the 
-    * S26 phy. 
-    */
-    pll= ar7240_reg_rd(AR7240_PLL_CONFIG);
-    tmp_pll = pll& ~((PLL_DIV_MASK << PLL_DIV_SHIFT) | (PLL_REF_DIV_MASK << PLL_REF_DIV_SHIFT));
-    tmp_pll = tmp_pll | (0x64 << PLL_DIV_SHIFT) |
-        (0x5 << PLL_REF_DIV_SHIFT) | (1 << AHB_DIV_SHIFT);
-
-    ar7240_reg_wr_nf(AR7240_PLL_CONFIG, tmp_pll);
+#ifdef CONFIG_AR7242_VIR_PHY
+ #ifndef SWITCH_AHB_FREQ
+    u32 tmp_pll ;
+ #endif
+    tmp_pll = 0x62000000 ;
+    ar7240_reg_wr_nf(AR7242_ETH_XMII_CONFIG, tmp_pll);
     udelay(100*1000);
 #endif
 
     mac->mac_speed = -1;
 
-    if (mac->mac_unit == 0)
-        athrs26_reg_init();
-    else
-	athrs26_reg_init_lan();
+    ag7240_phy_reg_init(mac->mac_unit);
 
+
     printk("Setting PHY...\n");
 
-#ifdef ETH_SOFT_LED
+    if (mac_has_flag(mac,ETH_SOFT_LED)) {
     /* Resetting PHY will disable MDIO access needed by soft LED task.
      * Hence, Do not reset PHY until Soft LED task get completed.
      */
-    while(atomic_read(&Ledstatus) == 1);
-#endif
+        while(atomic_read(&Ledstatus) == 1);
+    }
     phy_in_reset = 1;
-    ag7240_phy_setup(mac->mac_unit);
+#ifndef CONFIG_AR7242_VIR_PHY
+     ag7240_phy_setup(mac->mac_unit);
+#else
+     athr_vir_phy_setup(mac->mac_unit);
+#endif 
     phy_in_reset = 0;
 
 #ifdef SWITCH_AHB_FREQ
@@ -313,8 +292,25 @@
  
     mac->mac_ifup = 1;
     ag7240_int_enable(mac);
-    athrs26_enable_linkIntrs(mac->mac_unit);
 
+    if (is_ar7240())
+        ag7240_intr_enable_rxovf(mac);
+
+#if defined(CONFIG_AR7242_RGMII_PHY)||defined(CONFIG_AR7242_S16_PHY)||defined(CONFIG_AR7242_VIR_PHY)   
+    
+    if(is_ar7242() && mac->mac_unit == 0) {
+
+        init_timer(&mac->mac_phy_timer);
+        mac->mac_phy_timer.data     = (unsigned long)mac;
+        mac->mac_phy_timer.function = (void *)ag7242_check_link;
+        ag7242_check_link(mac);
+
+    }
+#endif
+    
+    if (is_ar7240() || is_ar7241() || (is_ar7242() && mac->mac_unit == 1))
+	athrs26_enable_linkIntrs(mac->mac_unit);
+
     ag7240_rx_start(mac);	
     netif_start_queue(dev);
    
@@ -350,18 +346,17 @@
  * Clearing the software link status while bringing the interface down
  * will avoid the race condition during PHY RESET.
  */
-#ifdef ETH_SOFT_LED
-    if (mac->mac_unit == ENET_UNIT_LAN) {
-        for(i = 0;i < 4; i++)
-            PLedCtrl.ledlink[i] = 0;
+    if (mac_has_flag(mac,ETH_SOFT_LED)) {
+        if (mac->mac_unit == ENET_UNIT_LAN) {
+            for(i = 0;i < 4; i++)
+                PLedCtrl.ledlink[i] = 0;
+        }
+        else {
+            PLedCtrl.ledlink[4] = 0;
+        }
     }
-    else {
-        PLedCtrl.ledlink[4] = 0;
-    }
-#endif
-#ifdef CHECK_DMA_STATUS
-    del_timer(&mac->mac_phy_timer);
-#endif
+    if (is_ar7242())
+        del_timer(&mac->mac_phy_timer);
     spin_unlock_irqrestore(&mac->mac_lock, flags);
 
     /*ag7240_trc_dump();*/
@@ -441,43 +436,30 @@
 static void
 ag7240_hw_setup(ag7240_mac_t *mac)
 {
-#ifdef CONFIG_AG7240_QOS
     ag7240_ring_t *tx, *rx = &mac->mac_rxring;
-    int ac;
-#else
-    ag7240_ring_t *tx = &mac->mac_txring, *rx = &mac->mac_rxring;
-#endif
     ag7240_desc_t *r0, *t0;
-    uint32_t mgmt_cfg_val;
+    uint32_t mgmt_cfg_val,ac;
     u32 check_cnt;
 
     if(mac->mac_unit)
     {
-        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
-            AG7240_MAC_CFG1_TX_EN | AG7240_MAC_CFG1_RX_FCTL | AG7240_MAC_CFG1_TX_FCTL));
-
-#ifdef CONFIG_ATHEROS_HEADER_EN
-	/* Disable AG7240_MAC_CFG2_LEN_CHECK to fix the bug that 
-	 * the mac address is mistaken as length when enabling Atheros header 
-	 */ 
-        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
-             AG7240_MAC_CFG2_IF_1000));
-#else
-        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
-            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
-#endif
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN | AG7240_MAC_CFG1_TX_EN | AG7240_MAC_CFG1_RX_FCTL | AG7240_MAC_CFG1_TX_FCTL));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN | AG7240_MAC_CFG2_IF_1000 | AG7240_MAC_CFG2_LEN_CHECK));
     } 
     else 
     {
         ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
-                    AG7240_MAC_CFG1_TX_EN));
-        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
-            AG7240_MAC_CFG2_LEN_CHECK));
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN | AG7240_MAC_CFG2_LEN_CHECK));
     }
 
     ag7240_reg_wr(mac, AG71XX_REG_MAC_MFL, AG71XX_TX_MTU_LEN);
 
-    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, FIFO_CFG0_INIT);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+//    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, FIFO_CFG0_INIT);
+
+    if (mac_has_flag(mac,ATHR_S26_HEADER) || mac_has_flag(mac,ATHR_S16_HEADER))
+        ag7240_reg_rmw_clear(mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_LEN_CHECK)
     /*
     * set the mii if type - NB reg not in the gigE space
     */
@@ -508,74 +490,97 @@
             default:
                      mgmt_cfg_val = 0x7;
         }
-	if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_0) {
-	    /* Virian */	
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                mgmt_cfg_val = 0x6;
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0); 
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
             mgmt_cfg_val = 0x4;
+
+            if (mac_has_flag(mac,ETH_SWONLY_MODE)) {
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_SW_ONLY_MODE); 
+                ag7240_reg_rmw_set(ag7240_macs[0], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST);;
+            }
             ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
             ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
-	    printk("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+            printk("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
         }
-	else { /* Python 1.0 & 1.1 */
-        	if (mac->mac_unit == 0) {
-            		check_cnt = 0;
-            		while (check_cnt++ < 10) {
-                		ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
-                		ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
-                		if(athrs26_mdc_check() == 0) 
-                    			break;
-            		}
-            		if(check_cnt == 11)
-                		printk("%s: MDC check failed\n", __func__);
-       		}
-    	}
+        else { /* Python 1.0 & 1.1 */
+            if (mac->mac_unit == 0) {
+                check_cnt = 0;
+                while (check_cnt++ < 10) {
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+                    if(athrs26_mdc_check() == 0) 
+                        break;
+                }
+                if(check_cnt == 11)
+                    printk("%s: MDC check failed\n", __func__);
+            }
+        }
     }
         
     ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
     ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0x015500aa);
+
     /*
-    * Weed out junk frames (CRC errored, short collision'ed frames etc.)
-    */
-    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_4, FIFO_CFG4_INIT);
+     * Weed out junk frames (CRC errored, short collision'ed frames etc.)
+     */
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+
     /*
      * Drop CRC Errors, Pause Frames ,Length Error frames, Truncated Frames
      * dribble nibble and rxdv error frames.
      */
     DPRINTF("Setting Drop CRC Errors, Pause Frames and Length Error frames \n");
-    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, FIFO_CFG5_INIT);
-
-#ifdef CONFIG_AG7240_QOS
+    if(mac_has_flag(mac,ATHR_S26_HEADER)){
+        ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xe6bc0);
+    }else{
+        ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x66b82);
+    }
+    if (mac->mac_unit == 0 && is_ar7242()){
+       ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xe6be2);
+    }
+    if (mac_has_flag(mac,WAN_QOS_SOFT_CLASS)) {
     /* Enable Fixed priority */
 #if 1
-  ag7240_reg_wr(mac,AG7240_DMA_TX_ARB_CFG,AG7240_TX_QOS_MODE_WEIGHTED
-			| AG7240_TX_QOS_WGT_0(0x7)
-			| AG7240_TX_QOS_WGT_1(0x5) 
-			| AG7240_TX_QOS_WGT_2(0x3)
-			| AG7240_TX_QOS_WGT_3(0x1));
+        ag7240_reg_wr(mac,AG7240_DMA_TX_ARB_CFG,AG7240_TX_QOS_MODE_WEIGHTED
+                    | AG7240_TX_QOS_WGT_0(0x7)
+                    | AG7240_TX_QOS_WGT_1(0x5) 
+                    | AG7240_TX_QOS_WGT_2(0x3)
+                    | AG7240_TX_QOS_WGT_3(0x1));
 #else
-  ag7240_reg_wr(mac,AG7240_DMA_TX_ARB_CFG,AG7240_TX_QOS_MODE_FIXED);
+        ag7240_reg_wr(mac,AG7240_DMA_TX_ARB_CFG,AG7240_TX_QOS_MODE_FIXED);
 #endif
-    for(ac = 0;ac <  ENET_NUM_AC; ac++) {
-       tx = &mac->mac_txring[ac];
-       t0  =  &tx->ring_desc[0];
-       switch(ac) {
-            case ENET_AC_VO:
-                ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q0, ag7240_desc_dma_addr(tx, t0));
-		break;
-            case ENET_AC_VI:
-                ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q1, ag7240_desc_dma_addr(tx, t0));
-		break;
-            case ENET_AC_BK:
-                ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q2, ag7240_desc_dma_addr(tx, t0));
-		break;
-            case ENET_AC_BE:
-                ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q3, ag7240_desc_dma_addr(tx, t0));
-		break;
-       }
+        for(ac = 0;ac < mac->mac_noacs; ac++) {
+            tx = &mac->mac_txring[ac];
+            t0  =  &tx->ring_desc[0];
+            switch(ac) {
+                case ENET_AC_VO:
+                    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q0, ag7240_desc_dma_addr(tx, t0));
+                    break;
+                case ENET_AC_VI:
+                    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q1, ag7240_desc_dma_addr(tx, t0));
+                    break;
+                case ENET_AC_BK:
+                    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q2, ag7240_desc_dma_addr(tx, t0));
+                    break;
+                case ENET_AC_BE:
+                    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q3, ag7240_desc_dma_addr(tx, t0));
+                    break;
+            }
+        }
     }
-#else
-    t0  =  &tx->ring_desc[0];
-    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, ag7240_desc_dma_addr(tx, t0));
-#endif
+    else {
+        tx = &mac->mac_txring[0];
+        t0  =  &tx->ring_desc[0];
+        ag7240_reg_wr(mac, AG7240_DMA_TX_DESC_Q0, ag7240_desc_dma_addr(tx, t0));
+    }
     r0  =  &rx->ring_desc[0];
     ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, ag7240_desc_dma_addr(rx, r0));
 
@@ -594,7 +599,7 @@
     * put everything into reset.
     * Dont Reset WAN MAC as we are using eth0 MDIO to access S26 Registers.
     */
-    if(mac->mac_unit == 1)
+    if(mac->mac_unit == 1 || is_ar7241() || is_ar7242())
         ag7240_reg_rmw_set(mac, AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST);
 }
 
@@ -632,18 +637,24 @@
     case AG7240_PHY_SPEED_1000T:
         ag7240_set_mac_if(mac, 1);
         ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+        if (is_ar7242() &&( mac->mac_unit == 0))
+            ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,xmii_val);
         break;
 
     case AG7240_PHY_SPEED_100TX:
         ag7240_set_mac_if(mac, 0);
         ag7240_set_mac_speed(mac, 1);
         ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+        if (is_ar7242() &&( mac->mac_unit == 0))
+            ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
         break;
 
     case AG7240_PHY_SPEED_10T:
         ag7240_set_mac_if(mac, 0);
         ag7240_set_mac_speed(mac, 0);
         ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+        if (is_ar7242() &&( mac->mac_unit == 0))
+            ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
         break;
 
     default:
@@ -656,7 +667,6 @@
     DPRINTF(MODULE_NAME ": cfg_5: %#x\n", ag7240_reg_rd(mac, AG7240_MAC_FIFO_CFG_5));
 }
 
-#ifdef ETH_SOFT_LED
 static int 
 led_control_func(ATH_LED_CONTROL *pledctrl) 
 {
@@ -664,9 +674,11 @@
     const LED_BLINK_RATES  *bRateTab; 
     static uint32_t pkt_count;
     ag7240_mac_t *mac;
+    mac = ag7240_macs[1];
 
+    if (mac_has_flag(mac,ETH_SOFT_LED)) {
+        atomic_inc(&Ledstatus);
 
-    mac = ag7240_macs[1];
     atomic_inc(&Ledstatus);
   
     /* 
@@ -756,21 +768,20 @@
             s26_wr_phy(4,0x19,0x0);
         }
     }
+}
 done: 
-#ifdef CHECK_DMA_STATUS
-    if(ag7240_get_diff(prev_ts,jiffies) >= (1*HZ / 2)) {
-        if (ag7240_macs[0]->mac_ifup) check_for_dma_status(ag7240_macs[0]);      
-        if (ag7240_macs[1]->mac_ifup) check_for_dma_status(ag7240_macs[1]);
-        prev_ts = jiffies;
-    } 
-#endif     
+    if (mac_has_flag(mac,CHECK_DMA_STATUS)) { 
+        if(ag7240_get_diff(prev_dma_chk_ts,jiffies) >= (1*HZ / 2)) {
+            if (ag7240_macs[0]->mac_ifup) check_for_dma_status(ag7240_macs[0],0);      
+            if (ag7240_macs[1]->mac_ifup) check_for_dma_status(ag7240_macs[1],0);
+            prev_dma_chk_ts = jiffies;
+        }
+    }
     mod_timer(&PLedCtrl.led_timer,(jiffies + AG7240_LED_POLL_SECONDS));
     atomic_dec(&Ledstatus);
     return 0;
 }
-#endif
 
-#ifdef CHECK_DMA_STATUS
 static int check_dma_status_pause(ag7240_mac_t *mac) { 
 
     int RxFsm,TxFsm,RxFD,RxCtrl,TxCtrl;
@@ -806,9 +817,9 @@
     }
 }
 
-static int check_for_dma_status(ag7240_mac_t *mac) {
+static int check_for_dma_status(ag7240_mac_t *mac,int ac) {
 
-    ag7240_ring_t   *r     = &mac->mac_txring;
+    ag7240_ring_t   *r     = &mac->mac_txring[ac];
     int              head  = r->ring_head, tail = r->ring_tail;
     ag7240_desc_t   *ds;
     uint32_t rx_ds;
@@ -818,7 +829,7 @@
 
     /* If Tx hang is asserted reset the MAC and restore the descriptors
      * and interrupt state.
-    */
+     */
     while (tail != head)
     {
         ds   = &r->ring_desc[tail];
@@ -827,30 +838,30 @@
         if(ag7240_tx_owned_by_dma(ds)) {
             if ((ag7240_get_diff(bp->trans_start,jiffies)) > ((1 * HZ/10))) {
 
-		/*
-		 * If the DMA is in pause state reset kernel watchdog timer
-		 */
-		
+                 /*
+                  * If the DMA is in pause state reset kernel watchdog timer
+                  */
+        
                 if(check_dma_status_pause(mac)) {
-		    mac->mac_dev->trans_start = jiffies;
-		    return 0;
-		}
+                    mac->mac_dev->trans_start = jiffies;
+                    return 0;
+                } 
                 printk(MODULE_NAME ": Tx Dma status eth%d : %s\n",mac->mac_unit,
-                 ag7240_tx_stopped(mac) ? "inactive" : "active");                               
+                            ag7240_tx_stopped(mac) ? "inactive" : "active");                               
 
                 spin_lock_irqsave(&mac->mac_lock, flags);
                                                                                                 
                 int_mask = ag7240_reg_rd(mac,AG7240_DMA_INTR_MASK);
 
-	        ag7240_tx_stop(mac);
-	        ag7240_rx_stop(mac);
+                ag7240_tx_stop(mac);
+                ag7240_rx_stop(mac);
 
                 rx_ds = ag7240_reg_rd(mac,AG7240_DMA_RX_DESC);
                 mask = ag7240_reset_mask(mac->mac_unit);
 
                 /*
-                * put into reset, hold, pull out.
-                */
+                 * put into reset, hold, pull out.
+                 */
                 ar7240_reg_rmw_set(AR7240_RESET, mask);
                 udelay(10);
                 ar7240_reg_rmw_clear(AR7240_RESET, mask);
@@ -871,25 +882,33 @@
                 ag7240_set_mac_from_link(mac, mac->mac_speed, mac->mac_fdx);
                 
                 mac->dma_check = 1;
-                ag7240_tx_start(mac);
+
+                if (mac_has_flag(mac,WAN_QOS_SOFT_CLASS)) {
+                    ag7240_tx_start_qos(mac,ac);
+                }
+                else {
+                    ag7240_tx_start(mac);
+                }
+
                 ag7240_rx_start(mac);
                
                 /*
                  * Restore interrupts
                  */
-                 ag7240_reg_wr(mac,AG7240_DMA_INTR_MASK,int_mask);
+                ag7240_reg_wr(mac,AG7240_DMA_INTR_MASK,int_mask);
 
-                 spin_unlock_irqrestore(&mac->mac_lock,flags);
-		 break;
-           }
+                spin_unlock_irqrestore(&mac->mac_lock,flags);
+                break;
+            }
         }
         ag7240_ring_incr(tail);
     }
     return 0;
 }
-#endif
 
+
 /*
+ *
  * phy link state management
  */
 int
@@ -899,20 +918,19 @@
     int                 carrier = netif_carrier_ok(dev), fdx, phy_up;
     ag7240_phy_speed_t  speed;
     int                 rc;
-    uint8_t  intlink;
-    uint16_t rd_data;
 
     /* The vitesse switch uses an indirect method to communicate phy status
-    * so it is best to limit the number of calls to what is necessary.
-    * However a single call returns all three pieces of status information.
-    * 
-    * This is a trivial change to the other PHYs ergo this change.
-    *
-    */
+     * so it is best to limit the number of calls to what is necessary.
+     * However a single call returns all three pieces of status information.
+     * 
+     * This is a trivial change to the other PHYs ergo this change.
+     *
+     */
   
     rc = ag7240_get_link_status(mac->mac_unit, &phy_up, &fdx, &speed, phyUnit);
 
     athrs26_phy_stab_wr(phyUnit,phy_up,speed);
+
     if (rc < 0)
         goto done;
 
@@ -920,7 +938,7 @@
     {
         if (carrier)
         {
-            printk(MODULE_NAME ": unit %d: phy %0d not up carrier %d\n", mac->mac_unit, phyUnit, carrier);
+            printk(MODULE_NAME ":unit %d: phy %0d not up carrier %d\n", mac->mac_unit, phyUnit, carrier);
 
             /* A race condition is hit when the queue is switched on while tx interrupts are enabled.
              * To avoid that disable tx interrupts when phy is down.
@@ -928,20 +946,21 @@
             ag7240_intr_disable_tx(mac);
 
             netif_carrier_off(dev);
-#ifdef  ETH_SOFT_LED
-       PLedCtrl.ledlink[phyUnit] = 0;
-       s26_wr_phy(phyUnit,0x19,0x0);
-#endif
+            netif_stop_queue(dev);
+            if (mac_has_flag(mac,ETH_SOFT_LED)) {
+                PLedCtrl.ledlink[phyUnit] = 0;
+                s26_wr_phy(phyUnit,0x19,0x0);
+            }
         }
         goto done;
     }
    
     if(!mac->mac_ifup)
-	goto done; 
+        goto done; 
     /*
-    * phy is up. Either nothing changed or phy setttings changed while we 
-    * were sleeping.
-    */
+     * phy is up. Either nothing changed or phy setttings changed while we 
+     * were sleeping.
+     */
 
     if ((fdx < 0) || (speed < 0))
     {
@@ -954,65 +973,129 @@
 
     if (athrs26_phy_is_link_alive(phyUnit)) 
     {
-       printk(MODULE_NAME ": enet unit:%d phy:%d is up...", mac->mac_unit,phyUnit);
-       printk("%s %s %s\n", mii_str[mac->mac_unit][mii_if(mac)], 
+        printk(MODULE_NAME ": enet unit:%d phy:%d is up...", mac->mac_unit,phyUnit);
+        printk("%s %s %s\n", mii_str[mac->mac_unit][mii_if(mac)], 
            spd_str[speed], dup_str[fdx]);
 
-       ag7240_set_mac_from_link(mac, speed, fdx);
+        ag7240_set_mac_from_link(mac, speed, fdx);
 
-       printk(MODULE_NAME ": done cfg2 %#x ifctl %#x miictrl  \n", 
+        printk(MODULE_NAME ": done cfg2 %#x ifctl %#x miictrl  \n", 
            ag7240_reg_rd(mac, AG7240_MAC_CFG2), 
            ag7240_reg_rd(mac, AG7240_MAC_IFCTL));
+        /*
+         * in business
+         */
+        netif_carrier_on(dev);
+        netif_start_queue(dev);
+        /* 
+         * WAR: Enable link LED to glow if speed is negotiated as 10 Mbps 
+         */
+        if (mac_has_flag(mac,ETH_SOFT_LED)) {
+            PLedCtrl.ledlink[phyUnit] = 1;
+            PLedCtrl.speed[phyUnit] = speed;
 
-       /* Check the LAN port interface link */
-       if (mac->mac_unit == ENET_UNIT_LAN) {
-           intlink = 0x8; /* Set MII inteface link */
-           s26_wr_phy(phyUnit,ATHR_DEBUG_PORT_ADDRESS,0x12);
-           rd_data = s26_rd_phy(phyUnit,ATHR_DEBUG_PORT_DATA);
-       printk(MODULE_NAME ": enet unit %d phy %d mode 0x%x\n",mac->mac_unit,phyUnit,rd_data);
-       if (rd_data & intlink ) {
-           rd_data &= ~intlink;
-           s26_wr_phy(phyUnit,ATHR_DEBUG_PORT_ADDRESS,0x12);
-           s26_wr_phy(phyUnit,ATHR_DEBUG_PORT_DATA,rd_data);
-        }}
+            s26_wr_phy(phyUnit,0x19,0x3c0);
+        }
+    }
+    else {
+        if (mac_has_flag(mac,ETH_SOFT_LED)) {
+            PLedCtrl.ledlink[phyUnit] = 0;
+            s26_wr_phy(phyUnit,0x19,0x0);
+        }
+        printk(MODULE_NAME ": enet unit:%d phy:%d is down...\n", mac->mac_unit,phyUnit);
+    }
 
-       /*
-       * in business
-       */
-       netif_carrier_on(dev);
-       /* 
-        * WAR: Enable link LED to glow if speed is negotiated as 10 Mbps 
-       */
-#ifdef ETH_SOFT_LED
-       PLedCtrl.ledlink[phyUnit] = 1;
-       PLedCtrl.speed[phyUnit] = speed;
+done:
+    return 0;
+}
 
-       s26_wr_phy(phyUnit,0x19,0x3c0);
-#endif
+#if defined(CONFIG_AR7242_RGMII_PHY)||defined(CONFIG_AR7242_S16_PHY)||defined(CONFIG_AR7242_VIR_PHY)   
+/*
+ * phy link state management
+ */
+int
+ag7242_check_link(ag7240_mac_t *mac)
+{
+    struct net_device  *dev     = mac->mac_dev;
+    int                 carrier = netif_carrier_ok(dev), fdx, phy_up;
+    ag7240_phy_speed_t  speed;
+    int                 rc,phyUnit = 0;
+
+
+    rc = ag7240_get_link_status(mac->mac_unit, &phy_up, &fdx, &speed, phyUnit);
+
+    if (rc < 0)
+        goto done;
+
+    if (!phy_up)
+    {
+        if (carrier)
+        {
+            printk(MODULE_NAME ": unit %d: phy %0d not up carrier %d\n", mac->mac_unit, phyUnit, carrier);
+
+            /* A race condition is hit when the queue is switched on while tx interrupts are enabled.
+             * To avoid that disable tx interrupts when phy is down.
+             */
+            ag7240_intr_disable_tx(mac);
+
+            netif_carrier_off(dev);
+            netif_stop_queue(dev);
+       }
+       goto done;
     }
-    else {
-#ifdef  ETH_SOFT_LED
-	PLedCtrl.ledlink[phyUnit] = 0;
-	s26_wr_phy(phyUnit,0x19,0x0);
+
+    if(!mac->mac_ifup) {
+        goto done;
+    }
+
+    if ((fdx < 0) || (speed < 0))
+    {
+        printk(MODULE_NAME ": phy not connected?\n");
+        return 0;
+    }
+
+    if (carrier && (speed == rg_phy_speed ) && (fdx == rg_phy_duplex)) {
+        goto done;
+    }
+#ifdef CONFIG_AR7242_RGMII_PHY
+    if (athr_phy_is_link_alive(phyUnit)) 
 #endif
-	    printk(MODULE_NAME ": enet unit:%d phy:%d is down...\n", mac->mac_unit,phyUnit);
+    {
+        printk(MODULE_NAME ": enet unit:%d is up...\n", mac->mac_unit);
+        printk("%s %s %s\n", mii_str[mac->mac_unit][mii_if(mac)],
+           spd_str[speed], dup_str[fdx]);
+
+        rg_phy_speed = speed;
+        rg_phy_duplex = fdx;
+        /* Set GEO to be always at Giga Bit */
+        speed = AG7240_PHY_SPEED_1000T;
+        ag7240_set_mac_from_link(mac, speed, fdx);
+
+        printk(MODULE_NAME ": done cfg2 %#x ifctl %#x miictrl  \n",
+           ag7240_reg_rd(mac, AG7240_MAC_CFG2),
+           ag7240_reg_rd(mac, AG7240_MAC_IFCTL));
+        /*
+         * in business
+         */
+        netif_carrier_on(dev);
+        netif_start_queue(dev);
     }
-
+    
 done:
+    mod_timer(&mac->mac_phy_timer, jiffies + AG7240_PHY_POLL_SECONDS*HZ);
     return 0;
 }
 
+#endif
+
 uint16_t
 ag7240_mii_read(int unit, uint32_t phy_addr, uint8_t reg)
 {
-    ag7240_mac_t *mac   = ag7240_unit2mac(0);
+    ag7240_mac_t *mac   = ag7240_unit2mac(unit);
     uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
     volatile int           rddata;
     uint16_t      ii = 0x1000;
 
-    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_0) {
-       mac = ag7240_unit2mac(1);
-    }
 
     ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
     ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
@@ -1033,14 +1116,11 @@
 void
 ag7240_mii_write(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
 {
-    ag7240_mac_t *mac   = ag7240_unit2mac(0);
+    ag7240_mac_t *mac   = ag7240_unit2mac(unit);
     uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
     volatile int rddata;
     uint16_t      ii = 0x1000;
 
-    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_0) {
-       mac = ag7240_unit2mac(1);
-    }
 
     ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
     ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
@@ -1089,24 +1169,13 @@
  *
  * ******************************
  */
-#ifdef CONFIG_AG7240_QOS 
 static ag7240_desc_t *
 ag7240_get_tx_ds(ag7240_mac_t *mac, int *len, unsigned char **start,int ac)
-#else
-static ag7240_desc_t *
-ag7240_get_tx_ds(ag7240_mac_t *mac, int *len, unsigned char **start)
-#endif
 {
     ag7240_desc_t      *ds;
     int                len_this_ds;
-#ifdef CONFIG_AG7240_QOS
     ag7240_ring_t      *r   = &mac->mac_txring[ac];
-#else
-    ag7240_ring_t      *r   = &mac->mac_txring;
-#endif
-#ifdef CHECK_DMA_STATUS
     ag7240_buffer_t    *bp;
-#endif
 
 
 
@@ -1132,10 +1201,10 @@
     *len   -= len_this_ds;
     *start += len_this_ds;
 
-#ifdef CHECK_DMA_STATUS
-     bp = &r->ring_buffer[r->ring_head];
-     bp->trans_start = jiffies; /*Time stamp each packet */
-#endif
+    if (mac_has_flag(mac,CHECK_DMA_STATUS)) {
+        bp = &r->ring_buffer[r->ring_head];
+        bp->trans_start = jiffies; 
+    }
 
     ag7240_ring_incr(r->ring_head);
 
@@ -1146,71 +1215,72 @@
 ag7240_hard_start(struct sk_buff *skb, struct net_device *dev)
 {
     ag7240_mac_t       *mac = (ag7240_mac_t *)netdev_priv(dev);
-#ifdef CONFIG_AG7240_QOS
     ag7240_ring_t      *r;
     struct ethhdr *eh = (struct ethhdr *) skb->data;
     int                ac;
-#else
-    ag7240_ring_t      *r   = &mac->mac_txring;
-#endif
     ag7240_buffer_t    *bp;
     ag7240_desc_t      *ds, *fds;
     unsigned char      *start;
     int                len;
     int                nds_this_pkt;
-
-#if defined(CONFIG_ATHEROS_HEADER_EN)
-    /* add header to normal frames */
-    /* check if normal frames */
-    if (mac->mac_unit == 1) 
-    {
-        skb_push(skb, 2);
-        skb->data[0] = 0x30; /* broadcast = 0; from_cpu = 0; reserved = 1; port_num = 0 */
-        skb->data[1] = 0x40; /* reserved = 0b10; priority = 0; type = 0 (normal) */
-    }
-#endif
-
 //#ifdef CONFIG_AR7240_S26_VLAN_IGMP
     if(unlikely((skb->len <= 0) || (skb->len > (dev->mtu + ETH_VLAN_HLEN +6 ))))
 //#else
-//    if(unlikely((skb->len <= 0) || (skb->len > (dev->mtu + ETH_HLEN))))
+//    if(unlikely((skb->len <= 0) || (skb->len > (dev->mtu + ETH_HLEN + 4))))
 //#endif
     {
         printk(MODULE_NAME ": bad skb, len %d\n", skb->len);
         goto dropit;
     }
 
-#ifdef CONFIG_AG7240_QOS
-    for (ac = 0;ac < ENET_NUM_AC; ac++) {
-
-    if (ag7240_tx_reap_thresh(mac,ac)) 
-        ag7240_tx_reap(mac,ac);
+    for (ac = 0;ac < mac->mac_noacs; ac++) {
+        if (ag7240_tx_reap_thresh(mac,ac)) 
+            ag7240_tx_reap(mac,ac);
     }
 
     /* 
      * Select the TX based on access category 
      */
-   
-    /* Default priority */
     ac = ENET_AC_BE;
+    if ( (mac_has_flag(mac,WAN_QOS_SOFT_CLASS)) || (mac_has_flag(mac,ATHR_S26_HEADER))
+        || (mac_has_flag(mac,ATHR_S16_HEADER)))  { 
+        /* Default priority */
+        eh = (struct ethhdr *) skb->data;
 
-    if (eh->h_proto  == __constant_htons(ETHERTYPE_IP))
+        if (eh->h_proto  == __constant_htons(ETHERTYPE_IP))
+        {
+            const struct iphdr *ip = (struct iphdr *)
+                        (skb->data + sizeof (struct ethhdr));
+            /*
+             * IP frame: exclude ECN bits 0-1 and map DSCP bits 2-7
+             * from TOS byte.
+             */
+            ac = TOS_TO_ENET_AC ((ip->tos >> TOS_ECN_SHIFT) & 0x3F);
+        }
+    }
+    skb->priority=ac;
+    /* add header to normal frames sent to LAN*/
+    if (mac_has_flag(mac,ATHR_S26_HEADER))
     {
-        const struct iphdr *ip = (struct iphdr *)
-                    (skb->data + sizeof (struct ethhdr));
-        /*
-         * IP frame: exclude ECN bits 0-1 and map DSCP bits 2-7
-         * from TOS byte.
-         */
-        ac = TOS_TO_ENET_AC ((ip->tos & (~INET_ECN_MASK)) >> IP_PRI_SHIFT);
+        skb_push(skb, ATHR_HEADER_LEN);
+        skb->data[0] = 0x30; /* broadcast = 0; from_cpu = 0; reserved = 1; port_num = 0 */
+        skb->data[1] = (0x40 | (ac << HDR_PRIORITY_SHIFT)); /* reserved = 0b10; priority = 0; type = 0 (normal) */
+        skb->priority=ENET_AC_BE;
+    }
 
+    if (mac_has_flag(mac,ATHR_S16_HEADER))
+    {
+        skb_push(skb, ATHR_HEADER_LEN);
+        memcpy(skb->data,skb->data + ATHR_HEADER_LEN, 12);
+
+        skb->data[12] = 0x30; /* broadcast = 0; from_cpu = 0; reserved = 1; port_num = 0 */
+        skb->data[13] = 0x40 | ((ac << HDR_PRIORITY_SHIFT)); /* reserved = 0b10; priority = 0; type = 0 (normal) */
+        skb->priority=ENET_AC_BE;
     }
-    skb->priority = ac;
+    /*hdr_dump("Tx",mac->mac_unit,skb->data,ac,0);*/
     r = &mac->mac_txring[skb->priority];
-#else
-    if (ag7240_tx_reap_thresh(mac)) 
-        ag7240_tx_reap(mac);
-#endif
+
+    assert(r);
     ag7240_trc_new(r->ring_head,"hard-stop hd");
     ag7240_trc_new(r->ring_tail,"hard-stop tl");
 
@@ -1227,19 +1297,11 @@
     assert(len>4);
 
     nds_this_pkt = 1;
-#ifdef CONFIG_AG7240_QOS
     fds = ds = ag7240_get_tx_ds(mac, &len, &start,skb->priority);
-#else
-    fds = ds = ag7240_get_tx_ds(mac, &len, &start);
-#endif
 
     while (len>0)
     {
-#ifdef CONFIG_AG7240_QOS
         ds = ag7240_get_tx_ds(mac, &len, &start,skb->priority);
-#else
-        ds = ag7240_get_tx_ds(mac, &len, &start);
-#endif
         nds_this_pkt++;
         ag7240_tx_give_to_dma(ds);
     }
@@ -1265,21 +1327,18 @@
 
     ag7240_trc(ag7240_reg_rd(mac, AG7240_DMA_TX_CTRL),"dma idle");
 
-#ifdef CONFIG_AG7240_QOS
-    ag7240_tx_start_qos(mac,skb->priority);
-
-    for ( ac = 0;ac < ENET_NUM_AC; ac++) {
+    if (mac_has_flag(mac,WAN_QOS_SOFT_CLASS)) {
+        ag7240_tx_start_qos(mac,skb->priority);
+    }
+    else {
+        ag7240_tx_start(mac);
+    }
+    for ( ac = 0;ac < mac->mac_noacs; ac++) {
         if (unlikely(ag7240_tx_ring_full(mac,ac))) 
             ag7240_handle_tx_full(mac);
     }
-#else
-    ag7240_tx_start(mac);
 
-    if (unlikely(ag7240_tx_ring_full(mac)))
-        ag7240_handle_tx_full(mac);
-#endif
 
-
     dev->trans_start = jiffies;
 
     return NETDEV_TX_OK;
@@ -1326,11 +1385,7 @@
 {
     struct net_device *dev  = (struct net_device *)dev_id;
     ag7240_mac_t      *mac  = (ag7240_mac_t *)netdev_priv(dev);
-#ifdef CONFIG_AG7240_QOS
     int   isr, imr, handled = 0,ac;
-#else
-    int   isr, imr, handled = 0;
-#endif
 
     isr   = ag7240_get_isr(mac);
     imr   = ag7240_reg_rd(mac, AG7240_DMA_INTR_MASK);
@@ -1342,7 +1397,10 @@
     if (isr & (AG7240_INTR_RX_OVF))
     {
         handled = 1;
+
+    if (is_ar7240()) 
         ag7240_reg_wr(mac,AG7240_MAC_CFG1,(ag7240_reg_rd(mac,AG7240_MAC_CFG1)&0xfffffff3));
+
         ag7240_intr_ack_rxovf(mac);
     }
     if (likely(isr & AG7240_INTR_RX))
@@ -1373,13 +1431,9 @@
     {
         handled = 1;
         ag7240_intr_ack_tx(mac);
-#ifdef CONFIG_AG7240_QOS
 	/* Which queue to reap ??????????? */
-        for(ac = 0; ac < ENET_NUM_AC;ac++)
+        for(ac = 0; ac < mac->mac_noacs;ac++)
             ag7240_tx_reap(mac,ac);
-#else
-        ag7240_tx_reap(mac);
-#endif
     }
     if (unlikely(isr & AG7240_INTR_RX_BUS_ERROR))
     {
@@ -1736,8 +1790,10 @@
     */
     wmb();
 
-    ag7240_reg_wr(mac,AG7240_MAC_CFG1,(ag7240_reg_rd(mac,AG7240_MAC_CFG1)|0xc));
-    ag7240_rx_start(mac);
+    if (is_ar7240()) {
+        ag7240_reg_wr(mac,AG7240_MAC_CFG1,(ag7240_reg_rd(mac,AG7240_MAC_CFG1)|0xc));
+        ag7240_rx_start(mac);
+    }
 
     r->ring_tail = tail;
     ag7240_trc(refilled,"refilled");
@@ -1748,30 +1804,18 @@
 /* 
  * Reap from tail till the head or whenever we encounter an unxmited packet.
  */
-#ifdef CONFIG_AG7240_QOS
 static int
 ag7240_tx_reap(ag7240_mac_t *mac,int ac)
-#else
-static int
-ag7240_tx_reap(ag7240_mac_t *mac)
-#endif
 {    
-#ifdef CONFIG_AG7240_QOS
     ag7240_ring_t   *r;
     int              head, tail, reaped = 0, i;
-#else
-    ag7240_ring_t   *r     = &mac->mac_txring;
-    int              head  = r->ring_head, tail = r->ring_tail, reaped = 0, i;
-#endif
     ag7240_desc_t   *ds;
     ag7240_buffer_t *bf;
     uint32_t    flags;
 
-#ifdef CONFIG_AG7240_QOS
     r = &mac->mac_txring[ac];
     head = r->ring_head;
     tail = r->ring_tail;
-#endif
     ag7240_trc_new(head,"hd");
     ag7240_trc_new(tail,"tl");
 
@@ -1830,19 +1874,13 @@
 static int
 ag7240_tx_alloc(ag7240_mac_t *mac)
 {
-#ifdef CONFIG_AG7240_QOS
     ag7240_ring_t *r ;
     int ac;
-#else
-    ag7240_ring_t *r = &mac->mac_txring;
-#endif
     ag7240_desc_t *ds;
     int i, next;
-#ifdef CONFIG_AG7240_QOS
-    for(ac = 0;ac < ENET_NUM_AC; ac++) {
+    for(ac = 0;ac < mac->mac_noacs; ac++) {
 
         r  = &mac->mac_txring[ac];
-#endif
         if (ag7240_ring_alloc(r, AG7240_TX_DESC_CNT))
             return 1;
 
@@ -1856,9 +1894,7 @@
             ds[i].next_desc     =   ag7240_desc_dma_addr(r, &ds[next]);
             ag7240_tx_own(&ds[i]);
        }
-#ifdef CONFIG_AG7240_QOS
    }
-#endif
     return 0;
 }
 
@@ -1913,17 +1949,12 @@
 static void
 ag7240_tx_free(ag7240_mac_t *mac)
 {
-#ifdef CONFIG_AG7240_QOS
     int ac;
     
-    for(ac = 0;ac < ENET_NUM_AC; ac++) {
+    for(ac = 0;ac < mac->mac_noacs; ac++) {
         ag7240_ring_release(mac, &mac->mac_txring[ac]);
         ag7240_ring_free(&mac->mac_txring[ac]);
    }
-#else
-    ag7240_ring_release(mac, &mac->mac_txring);
-    ag7240_ring_free(&mac->mac_txring);
-#endif
 }
 
 static void
@@ -2030,6 +2061,7 @@
 {
     ag7240_mac_t *mac = container_of(work, ag7240_mac_t, mac_tx_timeout);
     ag7240_trc(mac,"mac");
+    check_for_dma_status(mac,0);
     ag7240_stop(mac->mac_dev);
     ag7240_open(mac->mac_dev);
 }
@@ -2056,11 +2088,7 @@
 static int
 ag7240_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
-#ifdef CONFIG_AR7240_S26_VLAN_IGMP
-    return athr_ioctl(dev,(uint32_t *)ifr, cmd);
-#else
-    return athr_ioctl((uint32_t *)ifr, cmd);
-#endif
+    return athrs_do_ioctl(dev,ifr, cmd);
 }
 static struct net_device_stats 
     *ag7240_get_stats(struct net_device *dev)
@@ -2137,6 +2165,13 @@
 }
 static struct net_device_ops mac_net_ops;
 
+static int ag7240_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu<=(AG71XX_TX_MTU_LEN-18))
+	    dev->mtu = new_mtu;
+	return 0;
+}
+
 /*
  * All allocations (except irq and rings).
  */
@@ -2205,7 +2240,29 @@
         mac->mac_unit               =  i;
         mac->mac_base               =  ag7240_mac_base(i);
         mac->mac_irq                =  ag7240_mac_irq(i);
+        mac->mac_noacs              =  1;
         ag7240_macs[i]              =  mac;
+#ifdef CONFIG_ATHEROS_HEADER_EN
+        if (mac->mac_unit == ENET_UNIT_LAN)    
+	    mac_set_flag(mac,ATHR_S26_HEADER);
+#endif 
+#ifdef CONFIG_ETH_SOFT_LED
+        if (is_ar7240())
+            mac_set_flag(mac,ETH_SOFT_LED);
+#endif
+#ifdef CONFIG_CHECK_DMA_STATUS 
+        mac_set_flag(mac,CHECK_DMA_STATUS);
+#endif
+#ifdef CONFIG_S26_SWITCH_ONLY_MODE
+        if (is_ar7241()) {
+            if(i) {
+                mac_set_flag(mac,ETH_SWONLY_MODE);
+                }
+            else {
+                continue;
+            }
+        }
+#endif
         spin_lock_init(&mac->mac_lock);
         /*
         * out of memory timer
@@ -2233,7 +2290,7 @@
         mac_net_ops.ndo_get_stats = ag7240_get_stats;
         mac_net_ops.ndo_tx_timeout= ag7240_tx_timeout;
         mac_net_ops.ndo_do_ioctl        =  ag7240_do_ioctl;
-	mac_net_ops.ndo_change_mtu		= eth_change_mtu;
+	mac_net_ops.ndo_change_mtu		= ag7240_change_mtu;
 	mac_net_ops.ndo_set_mac_address	= eth_mac_addr;
 	mac_net_ops.ndo_validate_addr	= eth_validate_addr;
 	netif_napi_add(dev, &mac->mac_napi, ag7240_poll, AG7240_NAPI_WEIGHT);
@@ -2277,21 +2334,25 @@
 
     ag7240_trc_init();
 
-    athrs26_reg_dev(ag7240_macs);
-#ifdef CHECK_DMA_STATUS
-    prev_ts = jiffies;
-#endif
-#ifdef ETH_SOFT_LED
-    init_timer(&PLedCtrl.led_timer);
-    PLedCtrl.led_timer.data     = (unsigned long)(&PLedCtrl);
-    PLedCtrl.led_timer.function = (void *)led_control_func;
-    mod_timer(&PLedCtrl.led_timer,(jiffies + AG7240_LED_POLL_SECONDS));
-#endif
+    athrs_reg_dev(ag7240_macs);
+    if (mac_has_flag(mac,CHECK_DMA_STATUS))
+        prev_dma_chk_ts = jiffies;
+
+    if (mac_has_flag(mac,ETH_SOFT_LED)) {
+        init_timer(&PLedCtrl.led_timer);
+        PLedCtrl.led_timer.data     = (unsigned long)(&PLedCtrl);
+        PLedCtrl.led_timer.function = (void *)led_control_func;
+        mod_timer(&PLedCtrl.led_timer,(jiffies + AG7240_LED_POLL_SECONDS));
+    }
     return 0;
 failed:
     free_irq(AR7240_MISC_IRQ_ENET_LINK, ag7240_macs[0]->mac_dev);
     for(i = 0; i < AG7240_NMACS; i++)
     {
+#ifdef CONFIG_S26_SWITCH_ONLY_MODE
+        if (is_ar7241() && i == 0)
+            continue;
+#endif
         if (!ag7240_macs[i]) 
             continue;
         if (ag7240_macs[i]->mac_dev) 
@@ -2310,14 +2371,17 @@
     free_irq(AR7240_MISC_IRQ_ENET_LINK, ag7240_macs[0]->mac_dev);
     for(i = 0; i < AG7240_NMACS; i++)
     {
+        if (mac_has_flag(ag7240_macs[1],ETH_SWONLY_MODE) && i == 0) {
+            kfree(ag7240_macs[i]);
+            continue;
+        }
         unregister_netdev(ag7240_macs[i]->mac_dev);
         free_netdev(ag7240_macs[i]->mac_dev);
         kfree(ag7240_macs[i]);
         printk("%s Freeing at 0x%lx\n",__func__,(unsigned long) ag7240_macs[i]);
     }
-#ifdef ETH_SOFT_LED
-    del_timer(&PLedCtrl.led_timer);
-#endif
+    if (mac_has_flag(ag7240_macs[0],ETH_SOFT_LED)) 
+        del_timer(&PLedCtrl.led_timer);
     printk(MODULE_NAME ": cleanup done\n");
 }
 
Index: ag7240.h
===================================================================
--- ag7240.h	(revision 15022)
+++ ag7240.h	(working copy)
@@ -30,7 +30,6 @@
 #undef CONFIG_AR9100
 #endif
 
-#ifdef CONFIG_AG7240_QOS
 
 #include <net/inet_ecn.h>                /* XXX for TOS */
 #include <linux/if_ether.h>
@@ -48,15 +47,20 @@
 #define ENET_AC_VI       2               /* video */
 #define ENET_AC_VO       3               /* voice */
 
+#define HDR_PACKET_TYPE_MASK    0x0F            
+#define HDR_PRIORITY_SHIFT      0x4
+#define HDR_PRIORITY_MASK       0x3
+#define TOS_ECN_SHIFT           0x2
+#define TOS_ECN_MASK            0xFC
+
 #define TOS_TO_ENET_AC(_tos) (      \
     (((_tos) == 0) || ((_tos) == 3)) ? ENET_AC_BE : \
     (((_tos) == 1) || ((_tos) == 2)) ? ENET_AC_BK : \
     (((_tos) == 4) || ((_tos) == 5)) ? ENET_AC_VI : \
         ENET_AC_VO)
-#endif
 
-//#define CHECK_DMA_STATUS 1
-#define ETH_SOFT_LED 1
+#define CONFIG_CHECK_DMA_STATUS 1
+#define CONFIG_ETH_SOFT_LED 1
 
 #ifdef AG7240_DEBUG
 #define DPRINTF(_fmt,...) do {         \
@@ -91,12 +95,7 @@
     struct sk_buff *buf_pkt;        /*ptr to skb*/
     int             buf_nds;        /*no. of desc for this skb*/
     ag7240_desc_t  *buf_lastds;     /*the last desc. (for convenience)*/
-#ifdef CHECK_DMA_STATUS
     unsigned long   trans_start;    /*  descriptor time stamp */
-#else
-    uint32_t 	pad;
-
-#endif
 }ag7240_buffer_t;
 
 /*
@@ -136,11 +135,9 @@
     uint32_t                mac_unit;
     uint32_t                mac_base;
     int                     mac_irq;
-#ifdef CONFIG_AG7240_QOS
-    ag7240_ring_t           mac_txring[ENET_NUM_AC];
-#else
-    ag7240_ring_t           mac_txring;
-#endif
+    uint8_t                 mac_ifup;
+    uint8_t                 mac_noacs;
+    ag7240_ring_t           mac_txring[4];
     ag7240_ring_t           mac_rxring;
     ag7240_stats_t          mac_stats;
     spinlock_t              mac_lock;
@@ -154,10 +151,8 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
     struct napi_struct mac_napi;
 #endif
-    uint32_t                 mac_ifup;
-#ifdef CHECK_DMA_STATUS
+    uint16_t                mac_flags;
     uint32_t		    dma_check;
-#endif
 }ag7240_mac_t;
 
 #define net_rx_packets      mac_net_stats.rx_packets
@@ -216,6 +211,8 @@
 
 #define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
 #define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+#define phy_reg_read    ag7240_mii_read
+#define phy_reg_write   ag7240_mii_write
 
 #define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
     ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
@@ -228,7 +225,7 @@
  */
 #define ETHERNET_FCS_SIZE            4
 #define AG71XX_TX_FIFO_LEN	2048
-#define AG71XX_TX_MTU_LEN	1536
+#define AG71XX_TX_MTU_LEN	1544
 #define AG7240_RX_RESERVE           (64)
 #define AG7240_RX_BUF_SIZE      \
     (AG7240_RX_RESERVE + ETH_HLEN + ETH_FRAME_LEN + ETHERNET_FCS_SIZE)
@@ -329,7 +326,6 @@
 #define AG7240_DMA_DMA_STATE 	       0x3
 #define AG7240_DMA_AHB_STATE 	       0x7
 
-#ifdef CONFIG_AG7240_QOS
 /*
  * QOS register Defines 
  */
@@ -352,7 +348,6 @@
 #define AG7240_TX_QOS_WGT_2(x)		  ((x & 0x3F) << 20)
 #define AG7240_TX_QOS_WGT_3(x)		  ((x & 0x3F) << 26)
 
-#endif
 /*
  * tx/rx ctrl and status bits
  */
@@ -417,10 +412,22 @@
 #define AG7240_TOTAL_COL_CNTR		0x10c
 #define AG7240_TX_CRC_ERR_CNTR		0x11c
 
+
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+
 /*
  * Everything but TX
  */
-#define AG7240_INTR_MASK    (AG7240_INTR_RX | AG7240_INTR_RX_OVF |  \
+#define AG7240_INTR_MASK    (AG7240_INTR_RX | \
                              AG7240_INTR_RX_BUS_ERROR |             \
                              AG7240_INTR_TX_BUS_ERROR              \
                              /*| AG7240_INTR_TX_URN | AG7240_INTR_TX*/)
@@ -460,7 +467,6 @@
 #define ag7240_rx_stop(_mac)                                            \
     ag7240_reg_wr((_mac), AG7240_DMA_RX_CTRL, 0)
 
-#ifdef CONFIG_AG7240_QOS
 
 #define ag7240_tx_start_qos(_mac,ac)                                       \
 switch(ac) {  								   \
@@ -478,12 +484,10 @@
 		break;							   \
 }
 
-#else
 
 #define ag7240_tx_start(_mac)                                           \
     ag7240_reg_wr((_mac), AG7240_DMA_TX_CTRL, AG7240_TXE)
 
-#endif
 
 #define ag7240_tx_stop(_mac)						\
     ag7240_reg_wr((_mac), AG7240_DMA_TX_CTRL, 0)
@@ -547,6 +551,7 @@
     ag7240_reg_wr_nf((_mac), AG7240_DMA_RX_STATUS, AG7240_RX_STATUS_PKT_RCVD);
 #define ag7240_intr_ack_rxovf(_mac)                                           \
     ag7240_reg_wr((_mac), AG7240_DMA_RX_STATUS, AG7240_RX_STATUS_OVF);
+
 /*
  * Not used currently
  */
@@ -577,11 +582,15 @@
     ag7240_reg_rmw_clear(mac, AG7240_DMA_INTR_MASK,                         \
                         (AG7240_INTR_RX ));
 
+#define ag7240_intr_enable_rxovf(_mac)                                      \
+    ag7240_reg_rmw_set((_mac), AG7240_DMA_INTR_MASK, AG7240_INTR_RX_OVF);
+
 #define ag7240_intr_disable_rxovf(_mac)                                      \
     ag7240_reg_rmw_clear(mac, AG7240_DMA_INTR_MASK,                         \
                         (AG7240_INTR_RX_OVF));
 
 
+
 #define ag7240_intr_enable_recv(_mac)                                      \
     ag7240_reg_rmw_set(mac, AG7240_DMA_INTR_MASK,                          \
                         (AG7240_INTR_RX | AG7240_INTR_RX_OVF));
@@ -626,8 +635,38 @@
 uint16_t ag7240_mii_read(int unit, uint32_t phy_addr, uint8_t reg);
 void ag7240_mii_write(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data);
 unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+int  ag7240_check_link(ag7240_mac_t *mac,int phyUnit);
+int  ag7242_check_link(ag7240_mac_t *mac);
 
-#ifdef ETH_SOFT_LED
+#define CHECK_DMA_STATUS    0x0001
+#define ETH_SOFT_LED        0x0002
+#define WAN_QOS_SOFT_CLASS      0x0004
+#define ETH_SWONLY_MODE         0x0008
+#define ATHR_S26_HEADER         0x0010
+#define ATHR_S16_HEADER         0x0020
+#define ETH_PKT_INSPECT         0x0040
+
+static inline int
+mac_has_flag(ag7240_mac_t *mac, u_int16_t flag)
+{
+      return ((mac->mac_flags & flag) != 0);
+}
+
+static inline void
+mac_set_flag(ag7240_mac_t *mac, u_int16_t flag)
+{
+    mac->mac_flags |= flag;
+    return;
+    
+}
+
+static inline void
+mac_clear_flag(ag7240_mac_t *mac, u_int16_t flag)
+{
+    mac->mac_flags &= ~flag;
+    return;
+}
+
 /**
  * Added for customizing LED control operations
  */
@@ -665,6 +704,5 @@
     {  MB(10),  1,  1 }, /* on:10ms  off:42ms */
     {  0xffffffff, 0 , 1 }
 };
-#endif
 
 #endif
Index: ag7240_phy.h
===================================================================
--- ag7240_phy.h	(revision 15022)
+++ ag7240_phy.h	(working copy)
@@ -17,91 +17,116 @@
 #ifndef _AG7240_PHY_H
 #define _AG7240_PHY_H
 
-#define phy_reg_read        ag7240_mii_read
-#define phy_reg_write       ag7240_mii_write
-
 #include "ag7240.h"
+#include "athrs_ioctl.h"
 
-#ifdef __BDI
+#ifdef CONFIG_AR7240_S26_PHY
 
-/* Empty */
+#include "ar7240_s26_phy.h" 
+#ifdef CONFIG_AR7242_RGMII_PHY
+#include "athrf1_phy.h"
+#endif
+#ifdef CONFIG_AR7242_S16_PHY
+#include "athrs16_phy.h"
+#endif
+extern ag7240_mac_t *ag7240_macs[2];
+#define ag7240_phy_is_up(unit)          athrs26_phy_is_up (unit)
+#define ag7240_phy_speed(unit,phyUnit)  athrs26_phy_speed (unit,phyUnit)
+#define ag7240_phy_is_fdx(unit,phyUnit) athrs26_phy_is_fdx(unit,phyUnit)
+#define ag7240_phy_is_lan_pkt           athr_is_lan_pkt
+#define ag7240_phy_set_pkt_port         athr_set_pkt_port
+#define ag7240_phy_tag_len              ATHR_VLAN_TAG_SIZE
+#define ag7240_phy_get_counters         athrs26_get_counters
 
-#else
-#ifdef __ECOS
-
-/* ecos will set the value of CYGNUM_USE_ENET_PHY to one of the following strings
- * based on the cdl. These are defined here in no particuilar way so the
- * #if statements that follow will have something to compare to.
- */
-#define AR7240_VSC_ENET_PHY             1
-#define AR7240_VSC8601_ENET_PHY         2
-#define AR7240_VSC8601_VSC8601_ENET_PHY 3
-#define AR7240_VSC8601_VSC73XX_ENET_PHY 4
-#define AR7240_ICPLUS_ENET_PHY          5
-#define AR7240_REALTEK_ENET_PHY         6
-#define AR7240_ADMTEK_ENET_PHY          7  
-#define AR7240_ATHRF1_ENET_PHY          8
-#define AR7240_ATHRS26_ENET_PHY         9
-
-#if (CYGNUM_USE_ENET_PHY == AR7240_VSC_ENET_PHY) 
-#   define CONFIG_VITESSE_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_VSC8601_ENET_PHY) 
-#   define CONFIG_VITESSE_8601_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_VSC8601_VSC73XX_ENET_PHY)
-#   define CONFIG_VITESSE_8601_7395_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_ICPLUS_ENET_PHY)
-#   define CONFIG_ICPLUS_PHY 
-#elif (CYGNUM_USE_ENET_PHY == AR7240_REALTEK_ENET_PHY)
-#   define CONFIG_REALTEK_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_ADMTEK_ENET_PHY)
-#   define CONFIG_ADM6996FC_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_ATHRF1_ENET_PHY)
-#   define CONFIG_ATHRF1_PHY
-#elif (CYGNUM_USE_ENET_PHY == AR7240_ATHRS26_ENET_PHY)
-#   define CONFIG_ATHRS26_PHY
-#else
-#error unknown PHY type CYGNUM_USE_ENET_PHY
+static inline void athrs_reg_dev(ag7240_mac_t **ag7240_macs)
+{
+#if defined(CONFIG_AR7242_S16_PHY)
+  if (is_ar7242())
+    athrs16_reg_dev(ag7240_macs);
 #endif
+  athrs26_reg_dev(ag7240_macs);
 
-#include "vsc8601_phy.h"
-#include "vsc73xx.h"
-#include "ipPhy.h"
-#include "rtPhy.h"
-#include "adm_phy.h"
-#include "athr_phy.h"
-#include "ar7240_s26_phy.h"
+  return ;
 
-#define in_interrupt(x)    0
-#define schedule_work(x)
-#define INIT_WORK(x,y)
+}
 
-#else /* Must be Linux, CONFIGs are defined in .config */
+static inline int athrs_do_ioctl(struct net_device *dev,struct ifreq *ifr, int cmd)
+{
+  ag7240_mac_t *mac = (ag7240_mac_t *)netdev_priv(dev);
+  int ret = -1;
 
-/* Empty */
-
+  if (is_ar7240() || mac->mac_unit == 1)
+    ret = athrs26_ioctl(dev,ifr, cmd);
+#ifdef CONFIG_AR7242_S16_PHY
+  else if(is_ar7242())
+    ret = athrs16_ioctl(ifr->ifr_data, cmd);
 #endif
+#ifdef CONFIG_ATHRS_QOS
+  if(ret < 0) 
+    ret = athrs_config_qos(ifr->ifr_data,cmd);
 #endif
+  return ret;
+}
 
-#ifdef CONFIG_AR7240_S26_PHY
+static inline void ag7240_phy_reg_init(int unit)
+{
+#ifndef CONFIG_AR7242_S16_PHY
+  if (unit == 0)
+    athrs26_reg_init(unit);
+#else
+  if (unit == 0 && is_ar7242())
+    athrs16_reg_init(unit);
+#endif
+  else
+    athrs26_reg_init_lan(unit);
+} 
 
-#include "ar7240_s26_phy.h"
+static inline void ag7240_phy_setup(int unit)
+{
+  if (is_ar7241() || is_ar7240())
+    athrs26_phy_setup (unit);
+  else if (is_ar7242() && unit == 1) 
+    athrs26_phy_setup (unit);
+#ifdef CONFIG_AR7242_RGMII_PHY
+  else if (is_ar7242() && unit == 0)
+    athr_phy_setup(unit);
+#endif
+#ifdef CONFIG_AR7242_S16_PHY
+  else if (is_ar7242() && unit == 0)
+    athrs16_phy_setup(unit);
+#endif
+}
 
-#define ag7240_phy_ioctl(unit, args)    athr_ioctl(unit,args)
-#define ag7240_phy_setup(unit)          athrs26_phy_setup (unit)
-#define ag7240_phy_is_up(unit)          athrs26_phy_is_up (unit)
-#define ag7240_phy_speed(unit,phyUnit)  athrs26_phy_speed (unit,phyUnit)
-#define ag7240_phy_is_fdx(unit,phyUnit) athrs26_phy_is_fdx(unit,phyUnit)
-#define ag7240_phy_is_lan_pkt           athr_is_lan_pkt
-#define ag7240_phy_set_pkt_port         athr_set_pkt_port
-#define ag7240_phy_tag_len              ATHR_VLAN_TAG_SIZE
-#define ag7240_phy_get_counters         athrs26_get_counters
-
 static inline unsigned int 
 ag7240_get_link_status(int unit, int *link, int *fdx, ag7240_phy_speed_t *speed,int phyUnit)
 {
-  *link=ag7240_phy_is_up(unit);
-  *fdx=ag7240_phy_is_fdx(unit, phyUnit);
-  *speed=ag7240_phy_speed(unit, phyUnit);
+  if (is_ar7240() || is_ar7241() || (is_ar7242() && unit == 1)) {
+    *link=ag7240_phy_is_up(unit);
+    *fdx=ag7240_phy_is_fdx(unit, phyUnit);
+    *speed=ag7240_phy_speed(unit, phyUnit);
+  } 
+#ifdef CONFIG_AR7242_RGMII_PHY
+  else if(is_ar7242() && unit == 0){
+    *link=athr_phy_is_up(unit);
+    *fdx=athr_phy_is_fdx(unit,phyUnit);
+    *speed=athr_phy_speed(unit,phyUnit);
+  }
+#endif
+#ifdef CONFIG_AR7242_VIR_PHY
+  else if(is_ar7242() && unit == 0){
+    *link=athr_vir_phy_is_up(unit);
+    *fdx=athr_vir_phy_is_fdx(unit);
+    *speed=athr_vir_phy_speed(unit);
+  }
+#endif
+
+#ifdef CONFIG_AR7242_S16_PHY
+  else if(is_ar7242() && unit == 0){
+    *link=athrs16_phy_is_up(unit);
+    *fdx=athrs16_phy_is_fdx(unit);
+    *speed=athrs16_phy_speed(unit);
+  }
+#endif
   return 0;
 }
 
Index: ar7240_s26_phy.c
===================================================================
--- ar7240_s26_phy.c	(revision 15022)
+++ ar7240_s26_phy.c	(working copy)
@@ -1,5 +1,4 @@
-/*
- * Copyright (c) 2008, Atheros Communications Inc.
+/* Copyright (c) 2008, Atheros Communications Inc.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -148,7 +147,6 @@
 
 static uint8_t athr26_init_flag = 0,athr26_init_flag1 = 0;
 static DECLARE_WAIT_QUEUE_HEAD (hd_conf_wait);
-static ag7240_mac_t *ag7240_macs[2];
 
 #define ATHR_GLOBALREGBASE    0
 
@@ -232,10 +230,21 @@
 void athrs26_enable_linkIntrs(int ethUnit) 
 {
      int phyUnit = 0, phyAddr = 0;
+     ag7240_mac_t *mac = ag7240_macs[ethUnit];
 
     /* Enable global PHY link status interrupt */
     athrs26_reg_write(S26_GLOBAL_INTR_MASK_REG,PHY_LINK_CHANGE_REG); 
 
+    if (mac_has_flag(mac,ETH_SWONLY_MODE)) {
+        if (ethUnit == 1) {
+            for (phyUnit = 0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+                phyAddr = ATHR_PHYADDR(phyUnit);
+                s26_wr_phy(phyAddr,ATHR_PHY_INTR_ENABLE,PHY_LINK_INTRS);
+            }
+        }
+        return ;
+    }
+
      if (ethUnit == ENET_UNIT_WAN) {
          s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_INTR_ENABLE,PHY_LINK_INTRS);
      } 
@@ -250,6 +259,16 @@
 void athrs26_disable_linkIntrs(int ethUnit) 
 {
      int phyUnit = 0, phyAddr = 0;
+     ag7240_mac_t *mac = ag7240_macs[ethUnit];
+     if (mac_has_flag(mac,ETH_SWONLY_MODE)) {
+         if (ethUnit == 1) {
+             for (phyUnit = 0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+                 phyAddr = ATHR_PHYADDR(phyUnit);
+                 s26_wr_phy(phyAddr,ATHR_PHY_INTR_ENABLE,0x0);
+             }
+         }
+         return ;
+     }
 
      if (ethUnit == ENET_UNIT_WAN) {
          s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_INTR_ENABLE,0x0);
@@ -327,11 +346,13 @@
     phy_in_reset = 0;
 }
 
-void athrs26_reg_init(void)
+void athrs26_reg_init(int ethUnit)
 {
     uint32_t ar7240_revid;
     uint32_t rd_data;
 
+    ag7240_mac_t *mac = ag7240_macs[ethUnit];
+
     /* if using header for register configuration, we have to     */
     /* configure s26 register after frame transmission is enabled */
     if (athr26_init_flag)
@@ -361,17 +382,27 @@
     /* Disable WAN mac inside S26 */
     athrs26_reg_write(PORT_STATUS_REGISTER5,0x0);
 
+    /* Enable WAN mac inside S26 */
+    if (mac_has_flag(mac,ETH_SWONLY_MODE)) 
+        athrs26_reg_write(PORT_STATUS_REGISTER5,0x200);
+
     /* Enable MDIO Access if PHY is Powered-down */
     s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x3);
     rd_data = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA);
     s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x3);
     s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,(rd_data & 0xfffffeff) );
-    athrs26_reg_write(0x30,(athrs26_reg_read(0x30)&0xfffff800)|0x6b4);
 
+    if (mac_has_flag(mac,ATHR_S26_HEADER))
+        athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+    else
+        athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+
+    athrs26_reg_write(0x30,(athrs26_reg_read(0x30)&AR8216_GCTRL_MTU)|1716);
+
     athr26_init_flag = 1;
 }
 
-void athrs26_reg_init_lan(void)
+void athrs26_reg_init_lan(int ethUnit)
 {
     int i = 60;
     int       phyUnit;
@@ -381,6 +412,7 @@
     uint32_t  queue_ctrl_reg = 0;
     uint32_t  ar7240_revid;
     uint32_t rd_data;
+    ag7240_mac_t *mac = ag7240_macs[ethUnit];
     
     /* if using header for register configuration, we have to     */
     /* configure s26 register after frame transmission is enabled */
@@ -407,8 +439,12 @@
     */
     athrs26_reg_write(0x118,0x0032b5555);
 
-    for (phyUnit=0; phyUnit < ATHR_PHY_MAX - 1; phyUnit++) {
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX ; phyUnit++) {
 
+        if ((ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) &&
+            !mac_has_flag(mac,ETH_SWONLY_MODE))
+            continue;
+
         foundPhy = TRUE;
         phyBase = ATHR_PHYBASE(phyUnit);
         phyAddr = ATHR_PHYADDR(phyUnit);
@@ -466,18 +502,10 @@
      * status[5]=1'h1;     - Rx Flow Ctrl En
      * status[6]=1'h1;     - Duplex Mode
      */
-#ifdef CONFIG_AR7240_EMULATION
-    athrs26_reg_write(PORT_STATUS_REGISTER0, 0x7e);  /* CPU Port */
-    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x3c);
-    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x3c);
-    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x3c);
-    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x3c);
-#else
     athrs26_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
     athrs26_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
     athrs26_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
     athrs26_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
-#endif
 
     /* QM Control */
     athrs26_reg_write(0x38, 0xc000050e);
@@ -487,13 +515,10 @@
      * status[7] = 1'b1;   - Learn One Lock
      * status[14] = 1'b0;  - Learn Enable
      */
-#ifdef CONFIG_AR7240_EMULATION
-    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x04);
-    athrs26_reg_write(PORT_CONTROL_REGISTER1, 0x4004);
-#else
-   /* Atheros Header Disable */
-    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
-#endif
+    if (mac_has_flag(mac,ATHR_S26_HEADER))
+        athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+    else 
+        athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
 
    /* Tag Priority Mapping */
 //      athrs26_reg_write(0x70, 0x41af);
@@ -529,31 +554,32 @@
     DPRINTF("S26 PORT_CONTROL_REGISTER2 :%x\n", athrs26_reg_read ( PORT_CONTROL_REGISTER2 ));
     DPRINTF("S26 PORT_CONTROL_REGISTER3 :%x\n", athrs26_reg_read ( PORT_CONTROL_REGISTER3 ));
     DPRINTF("S26 PORT_CONTROL_REGISTER4 :%x\n", athrs26_reg_read ( PORT_CONTROL_REGISTER4 ));
+    if (mac_has_flag(mac,WAN_QOS_SOFT_CLASS)) {
+        athrs26_reg_write(ATHR_PRI_CTRL_PORT_2,(athrs26_reg_read(ATHR_PRI_CTRL_PORT_2)|ATHR_TOS_PRI_EN));
+        athrs26_reg_write(ATHR_PRI_CTRL_PORT_3,(athrs26_reg_read(ATHR_PRI_CTRL_PORT_3)|ATHR_TOS_PRI_EN));
+        athrs26_reg_write(ATHR_PRI_CTRL_PORT_4,(athrs26_reg_read(ATHR_PRI_CTRL_PORT_4)|ATHR_TOS_PRI_EN));
+        athrs26_reg_write(ATHR_PRI_CTRL_PORT_5,(athrs26_reg_read(ATHR_PRI_CTRL_PORT_5)|ATHR_TOS_PRI_EN));
+        athrs26_reg_write(ATHR_QOS_MODE_REGISTER,ATHR_QOS_FIXED_PRIORITY);
 
-#ifdef CONFIG_AG7240_QOS 
-    athrs26_reg_write(ATHR_QOS_PORT_1,(athrs26_reg_read(ATHR_QOS_PORT_1)|ATHR_ENABLE_TOS));
-    athrs26_reg_write(ATHR_QOS_PORT_2,(athrs26_reg_read(ATHR_QOS_PORT_2)|ATHR_ENABLE_TOS));
-    athrs26_reg_write(ATHR_QOS_PORT_3,(athrs26_reg_read(ATHR_QOS_PORT_3)|ATHR_ENABLE_TOS));
-    athrs26_reg_write(ATHR_QOS_PORT_4,(athrs26_reg_read(ATHR_QOS_PORT_4)|ATHR_ENABLE_TOS));
-#endif
-
+    }
     /* Disable WAN mac inside S26 after S26 Reset*/
 
     athrs26_reg_write(PORT_STATUS_REGISTER5,0x0);
 
 //#ifdef CONFIG_AR7240_S26_VLAN_IGMP
     // Set Max MTU to 1518+6 for vlan and header space.
-    athrs26_reg_write(0x30,(athrs26_reg_read(0x30)&0xfffff800)|0x6b4);
+    athrs26_reg_write(0x30,(athrs26_reg_read(0x30)&AR8216_GCTRL_MTU)|1716);
+//    athrs26_reg_write(0x30,(athrs26_reg_read(0x30)&0xfffff800)|0x6b4);
 //#endif
 
-#if defined(CONFIG_ATHEROS_HEADER_EN)
-   //Set CPU port0 to Atheros Header Enable.
-   athrs26_reg_write(0x104,athrs26_reg_read(0x104)|(0x1<<11));
+    if(mac_has_flag(mac,ATHR_S26_HEADER))
+        /* Set CPU port0 to Atheros Header Enable. */
+        athrs26_reg_write(0x104,athrs26_reg_read(0x104)|(0x1<<11));
 
-   // Clear Multicast over vlans.
-   //athrs26_reg_write(0x2c, athrs26_reg_read(0x2c)&0xffc0ffff);
-#endif
+    if (mac_has_flag(mac,ETH_SWONLY_MODE))
+        athrs26_reg_write(PORT_STATUS_REGISTER5,0x200);
 
+
     athr26_init_flag1 = 1;
 }
 static unsigned int phy_val_saved = 0;
@@ -712,9 +738,10 @@
      */
     for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
 
-        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+
+        if ((ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) &&
+                !mac_has_flag(ag7240_macs[ENET_UNIT_LAN],ETH_SWONLY_MODE))
             continue;
-        }
 
         timeout=20;
         for (;;) {
@@ -904,9 +931,11 @@
     uint32_t      phyAddr;
 
     for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
-        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+        if(mac_has_flag(ag7240_macs[ENET_UNIT_LAN],ETH_SWONLY_MODE))
+            ethUnit = ENET_UNIT_LAN;
+
+        if (!ATHR_IS_ETHUNIT(phyUnit,ethUnit))
             continue;
-        }
 
         phyBase = ATHR_PHYBASE(phyUnit);
         phyAddr = ATHR_PHYADDR(phyUnit);
@@ -963,14 +992,21 @@
     return (linkCount);
 
 }
-
 void athrs26_reg_dev(ag7240_mac_t **mac)
 {
-    ag7240_macs[0] = mac[0];
-    ag7240_macs[0]->mac_speed = 0xff;
-    
-    ag7240_macs[1] = mac[1];
-    ag7240_macs[1]->mac_speed = 0xff;
+    if( mac[0]) {
+        ag7240_macs[0] = mac[0];
+        ag7240_macs[0]->mac_speed = 0xff;
+    }
+    else 
+        printk("MAC [0] not registered \n");
+   
+    if( mac[1]) {
+        ag7240_macs[1] = mac[1];
+        ag7240_macs[1]->mac_speed = 0xff;
+    }
+    else 
+        printk("MAC [1] not registered \n");
     return;
 
 }
@@ -981,7 +1017,7 @@
     unsigned int addr_temp;
     unsigned int s26_rd_csr_low, s26_rd_csr_high, s26_rd_csr;
     unsigned int data;
-    unsigned int phy_address, reg_address;
+    unsigned int phy_address, reg_address, unit = 0;
 
     addr_temp = (s26_addr & 0xfffffffc) >>2;
     data = addr_temp >> 7;
@@ -989,14 +1025,21 @@
     phy_address = 0x1f;
     reg_address = 0x10;
 
-    phy_reg_write(0,phy_address, reg_address, data);
+    if (is_ar7240()) {
+        unit = 0;
+    } 
+    else if(is_ar7241() || is_ar7242()) {
+        unit = 1;
+    }
 
+    phy_reg_write(unit,phy_address, reg_address, data);
+
     phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
     reg_address = ((addr_temp << 1) & 0x1e);
-    s26_rd_csr_low = (uint32_t) phy_reg_read(0,phy_address, reg_address);
+    s26_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
 
     reg_address = reg_address | 0x1;
-    s26_rd_csr_high = (uint32_t) phy_reg_read(0,phy_address, reg_address);
+    s26_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
     s26_rd_csr = (s26_rd_csr_high << 16) | s26_rd_csr_low ;
 
     return(s26_rd_csr);
@@ -1007,7 +1050,7 @@
 {
     unsigned int addr_temp;
     unsigned int data;
-    unsigned int phy_address, reg_address;
+    unsigned int phy_address, reg_address, unit = 0;
 
 
     addr_temp = (s26_addr &  0xfffffffc) >>2;
@@ -1016,18 +1059,31 @@
     phy_address = 0x1f;
     reg_address = 0x10;
 
-    phy_reg_write(0,phy_address, reg_address, data);
+    if (is_ar7240()) {
+        unit = 0;
+    } 
+    else if(is_ar7241() || is_ar7242()) {
+        unit = 1;
+    }
 
+    phy_reg_write(unit,phy_address, reg_address, data);
+
     phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
-    reg_address = ((addr_temp << 1) & 0x1e);
-    data = s26_write_data  & 0xffff;
-    phy_reg_write(0,phy_address, reg_address, data);
 
     reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
     data = s26_write_data >> 16;
-    phy_reg_write(0,phy_address, reg_address, data);
+    phy_reg_write(unit,phy_address, reg_address, data);
+    
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s26_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
 }
 
+void athrs26_reg_rmw(unsigned int s26_addr, unsigned int s26_write_data) 
+{
+    int val = athrs26_reg_read(s26_addr);
+    athrs26_reg_write(s26_addr,(val | s26_write_data));
+}
 
 unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
 {
@@ -1087,13 +1143,14 @@
 
 }
 
-#ifdef CONFIG_AR7240_S26_VLAN_IGMP
-int athr_ioctl(struct net_device *dev,uint32_t *args, int cmd)
+int athrs26_ioctl(struct net_device *dev,void *args, int cmd)
 {
-    struct eth_diag *etd =(struct eth_diag *) args;
+    struct ifreq * ifr = (struct ifreq *) args;
+    struct eth_cfg_params *ethcfg;
     uint32_t ar7240_revid;
-    struct ifreq * ifr = (struct ifreq *) args;
+    ag7240_mac_t *mac;
 
+#ifdef CONFIG_AR7240_S26_VLAN_IGMP
     struct arl_struct * arl = (struct arl_struct *) (&ifr->ifr_ifru.ifru_mtu);
     unsigned int vlan_value = ifr->ifr_ifru.ifru_ivalue;
     unsigned short vlan_id = vlan_value >> 16;
@@ -1101,211 +1158,157 @@
     unsigned short vlan_port = vlan_value & 0x1f;
     unsigned int flag = 0;
     uint32_t ret = 0;
+#endif
 
+    ethcfg = (struct eth_cfg_params *)ifr->ifr_data;
+
     switch(cmd){
-            case S26_PACKET_FLAG:
-		printk("ag7240::S26_PACKET_FLAG %d \n",vlan_value);
-		set_packet_inspection_flag(vlan_value);
-		break;
+#ifdef CONFIG_AR7240_S26_VLAN_IGMP
+        case S26_PACKET_FLAG:
+            printk("ag7240::S26_PACKET_FLAG %d \n",vlan_value);
+            set_packet_inspection_flag(vlan_value);
+            break;
 
-	    case S26_RD_PHY: 
-		if(etd->ed_u.portnum != 0xf)
-		    etd->val = s26_rd_phy(etd->ed_u.portnum,etd->phy_reg);
-		else
-		    etd->val = athrs26_reg_read(etd->phy_reg);
-		break;
+        case S26_VLAN_ADDPORTS:
+            if(vlan_id>4095) return -EINVAL;
+            printk("ag7240::S26_ADD_PORT vid = %d ports=%x.\n",vlan_id,vlan_port);
+            ret = python_ioctl_vlan_addports(vlan_id,vlan_port);
+            break;
 
-	    case S26_WR_PHY: 
-		if(etd->ed_u.portnum != 0xf)
-		    s26_wr_phy(etd->ed_u.portnum,etd->phy_reg,etd->val);
-		else
-		    athrs26_reg_write(etd->phy_reg,etd->val);
-		break;
+        case S26_VLAN_DELPORTS:
+            if(vlan_id>4095) return -EINVAL;
+            printk("ag7240::S26_DEL_PORT vid = %d ports=%x.\n",vlan_id,vlan_port);
+            ret = python_ioctl_vlan_delports(vlan_id,vlan_port);
+            break;
 
-	    case S26_FORCE_PHY:
-		 if(etd->phy_reg < ATHR_PHY_MAX) {
-		    if(etd->val == 10) {
-		       printk("Forcing 10 on port:%d \n",(etd->phy_reg));
-		       athrs26_force_10M(etd->phy_reg,etd->ed_u.duplex);
-		    }
-		    else if(etd->val == 100) {
-		       printk("Forcing 100 on port:%d \n",(etd->phy_reg));
-		       athrs26_force_100M(etd->phy_reg,etd->ed_u.duplex);
-		    }
-		    else if(etd->val == 0) {
-		       printk("Enabling Auto Neg on port:%d \n",(etd->phy_reg));
+        case S26_VLAN_SETTAGMODE:
+            printk("ag7240::S26_VLAN_SETTAGMODE mode=%d portno=%d .\n",mode,vlan_port);
+            ret = python_port_egvlanmode_set(vlan_port,mode);
+            break;
 
-		       ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+        case S26_VLAN_SETDEFAULTID:
+            if(vlan_id>4095) return -EINVAL;
+            printk("ag7240::S26_VLAN_SETDEFAULTID vid = %d portno=%d.\n",vlan_id,vlan_port);
+            ret = python_port_default_vid_set(vlan_port,vlan_id);
+            break;
 
-		       if(ar7240_revid == AR7240_REV_1_0) {
-		           s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x0);
-		           s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_DATA,0x2ee);
-		           s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x3);
-		           s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_DATA,0x3a11);
-		       }
-		       s26_wr_phy(etd->phy_reg,ATHR_PHY_CONTROL,0x9000);
-		    }
-		    else
-		       return -EINVAL;
-		}
-		else {
-		    return -EINVAL;
-		}
-		break;
+        case  S26_IGMP_ON_OFF:
+        {
+            int tmp = 0;
+            tmp = vlan_value & (0x1 << 7);
+            vlan_port &= ~(0x1 << 7);
+            if(vlan_port>4) return -EINVAL;
+            if(tmp != 0){
+                printk("ag7240::Enable IGMP snooping in port no %x.\n",vlan_port);
+                ret= python_port_igmps_status_set(vlan_port,1);
+            }else{
+                printk("ag7240::Disable IGMP snooping in port no %x.\n",vlan_port);
+                ret= python_port_igmps_status_set(vlan_port,0);
+            }
+        }
+            break;
 
-	    case S26_VLAN_ADDPORTS:
-		if(vlan_id>4095) return -EINVAL;
-		printk("ag7240::S26_ADD_PORT vid = %d ports=%x.\n",vlan_id,vlan_port);
-		ret = python_ioctl_vlan_addports(vlan_id,vlan_port);
-		break;
+        case S26_LINK_GETSTAT:
+            if(vlan_port>4){/* if port=WAN */
+                int fdx, phy_up;
+                ag7240_phy_speed_t  speed;
+                ag7240_get_link_status(0, &phy_up, &fdx, &speed, 4);
+                ifr->ifr_ifru.ifru_ivalue = (speed<<16|fdx<<8|phy_up);
+                printk("ag7240::S26_LINK_GETSTAT portno WAN is %x.\n",ifr->ifr_ifru.ifru_ivalue);
+            }else if(vlan_port > 0){
+                flag = athrs26_phy_is_link_alive(vlan_port-1);
+                ifr->ifr_ifru.ifru_ivalue = flag;
+                printk("ag7240::S26_LINK_GETSTAT portno %d is %s.\n",vlan_port,flag?"up":"down");
+            }else{
+                ifr->ifr_ifru.ifru_ivalue = 1;
+            }
+            /* PHY 0-4 <---> port 1-5 in user space. */
+            break;
 
-	    case S26_VLAN_DELPORTS:
-		if(vlan_id>4095) return -EINVAL;
-		printk("ag7240::S26_DEL_PORT vid = %d ports=%x.\n",vlan_id,vlan_port);
-		ret = python_ioctl_vlan_delports(vlan_id,vlan_port);
-		break;
+        case S26_VLAN_ENABLE:
+            python_ioctl_enable_vlan();
+            printk("ag7240::S26_VLAN_ENABLE.\n");
+            break;
 
-	    case S26_VLAN_SETTAGMODE:
-		printk("ag7240::S26_VLAN_SETTAGMODE mode=%d portno=%d .\n",mode,vlan_port);
-		ret = python_port_egvlanmode_set(vlan_port,mode);
-		break;
+        case S26_VLAN_DISABLE:
+            python_ioctl_disable_vlan();
+            printk("ag7240::S26_VLAN_DISABLE.\n");
+            break;
 
-	    case S26_VLAN_SETDEFAULTID:
-		if(vlan_id>4095) return -EINVAL;
-		printk("ag7240::S26_VLAN_SETDEFAULTID vid = %d portno=%d.\n",vlan_id,vlan_port);
-		ret = python_port_default_vid_set(vlan_port,vlan_id);
-		break;
+        case S26_ARL_ADD:
+            ret = python_fdb_add(arl->mac_addr,arl->port_map,arl->sa_drop);
+            printk("ag7240::S26_ARL_ADD,mac:[%x.%x.%x.%x.%x.%x] port[%x] drop %d\n",
+                arl->mac_addr.uc[0],arl->mac_addr.uc[1],arl->mac_addr.uc[2],arl->mac_addr.uc[3],
+                arl->mac_addr.uc[4],arl->mac_addr.uc[5],arl->port_map,arl->sa_drop);
+            break;
 
-	    case  S26_IGMP_ON:
-		if(vlan_port>4) return -EINVAL;
-		printk("ag7240::Enable IGMP snooping in port no %x.\n",vlan_port);
-		ret= python_port_igmps_status_set(vlan_port,1);
-		break;
+        case S26_ARL_DEL:
+            ret = python_fdb_del(arl->mac_addr);
+            printk("ag7240::S26_ARL_DEL mac:[%x.%x.%x.%x.%x.%x].\n",arl->mac_addr.uc[0],arl->mac_addr.uc[1],
+            arl->mac_addr.uc[2],arl->mac_addr.uc[3],arl->mac_addr.uc[4],arl->mac_addr.uc[5]);
+            break;
+        case S26_MCAST_CLR:
+            /* 0: switch off the unkown multicast packets over vlan. 1: allow the unknown multicaset packets over vlans. */
+            if(!vlan_value)
+                python_clear_multi();
+            else
+                python_set_multi();
+                printk("athr_gmac::S26_MCAST_CLR --- %s.\n", vlan_value?"enable Multicast":"disable Multicast");
+            break;
+#endif
+        case S26_RD_PHY: 
+            if(ethcfg->portnum != 0xf)
+                ethcfg->val = s26_rd_phy(ethcfg->portnum,ethcfg->phy_reg);
+            else
+                ethcfg->val = athrs26_reg_read(ethcfg->phy_reg);
+            break;
+        
+        case S26_WR_PHY:
+            if(ethcfg->portnum != 0xf)
+                s26_wr_phy(ethcfg->portnum,ethcfg->phy_reg,ethcfg->val);
+            else
+                athrs26_reg_write(ethcfg->phy_reg,ethcfg->val);
+            break;
+        case S26_FORCE_PHY:
+            printk("Duplex %d\n",ethcfg->duplex);
+            if(ethcfg->phy_reg < ATHR_PHY_MAX) {
+                if(ethcfg->val == 10) {
+                    printk("Forcing 10Mbps %s on port:%d \n",
+                         dup_str[ethcfg->duplex],(ethcfg->phy_reg));
+                    athrs26_force_10M(ethcfg->phy_reg,ethcfg->duplex);
+                }else if(ethcfg->val == 100) {
+                    printk("Forcing 100Mbps %s on port:%d \n",
+                         dup_str[ethcfg->duplex],(ethcfg->phy_reg));
+                    athrs26_force_100M(ethcfg->phy_reg,ethcfg->duplex);
+                }else if(ethcfg->val == 0) {
+                    printk("Enabling Auto Neg on port:%d \n",(ethcfg->phy_reg));
+                    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
 
-	    case S26_IGMP_OFF:
-		if(vlan_port>4) return -EINVAL;
-		printk("ag7240::Disable IGMP snooping in port no %x.\n",vlan_port);
-		ret= python_port_igmps_status_set(vlan_port,0);
-		break;
+                    if(ar7240_revid == AR7240_REV_1_0) {
+                        s26_wr_phy(ethcfg->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x0);
+                        s26_wr_phy(ethcfg->phy_reg,ATHR_DEBUG_PORT_DATA,0x2ee);
+                        s26_wr_phy(ethcfg->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x3);
+                        s26_wr_phy(ethcfg->phy_reg,ATHR_DEBUG_PORT_DATA,0x3a11);
+                    }
+                    s26_wr_phy(ethcfg->phy_reg,ATHR_PHY_CONTROL,0x9000);
+               }else
+                   return -EINVAL;
 
-	    case S26_LINK_GETSTAT:
-		// PHY 0-4 <---> port 1-5 in user space.
-		if(vlan_port>4){//if port=WAN
-			int fdx, phy_up;
-			ag7240_phy_speed_t  speed;
-			ag7240_get_link_status(0, &phy_up, &fdx, &speed, 4);
-			ifr->ifr_ifru.ifru_ivalue = (speed<<16|fdx<<8|phy_up);
-			printk("ag7240::S26_LINK_GETSTAT portno WAN is %x.\n",ifr->ifr_ifru.ifru_ivalue);
-		}else{
-		flag = athrs26_phy_is_link_alive(vlan_port-1);
-		ifr->ifr_ifru.ifru_ivalue = flag;
-		printk("ag7240::S26_LINK_GETSTAT portno %d is %s.\n",vlan_port,flag?"up":"down");
-		}
-		break;
-
-            case S26_VLAN_ENABLE:
-		python_ioctl_enable_vlan();
-		printk("ag7240::S26_VLAN_ENABLE.\n");
-		break;
-
-            case S26_VLAN_DISABLE:
-		python_ioctl_disable_vlan();
-		printk("ag7240::S26_VLAN_DISABLE.\n");
-		break;
-
-            case S26_ARL_ADD:
-		ret = python_fdb_add(arl->mac_addr,arl->port_map,arl->sa_drop);
-		printk("ag7240::S26_ARL_ADD,mac:[%x.%x.%x.%x.%x.%x] port[%x] drop %d\n",arl->mac_addr.uc[0],arl->mac_addr.uc[1],
-			arl->mac_addr.uc[2],arl->mac_addr.uc[3],arl->mac_addr.uc[4],arl->mac_addr.uc[5],arl->port_map,arl->sa_drop);
-		break;
-
-            case S26_ARL_DEL:
-		ret = python_fdb_del(arl->mac_addr);
-		printk("ag7240::S26_ARL_DEL mac:[%x.%x.%x.%x.%x.%x].\n",arl->mac_addr.uc[0],arl->mac_addr.uc[1],
-			arl->mac_addr.uc[2],arl->mac_addr.uc[3],arl->mac_addr.uc[4],arl->mac_addr.uc[5]);
-		break;
-
-            case S26_MCAST_CLR:
-		//0: switch off the unkown multicast packets over vlan. 1: allow the unknown multicaset packets over vlans.
-		if((vlan_port%2)==0)
-			python_clear_multi();
-		else
-			python_set_multi();
-		printk("ag7240::S26_MCAST_CLR --- %s.\n",(vlan_port%2)?"enable Multicast":"disable Multicast");
-		break;
-		
-	    default:
-		return -EINVAL;
-    }
-    if(ret != PYTHON_OK)  
-    {
-	 printk(" Failure ret = %d .\n",ret);
-         return -EINVAL;
-    }
-
-    return 0;
-}
-#else
-int athr_ioctl(uint32_t *args, int cmd)
-{
-    struct eth_diag *etd =(struct eth_diag *) args;
-    uint32_t ar7240_revid;
-
-    if(cmd  == S26_RD_PHY) {
-        if(etd->ed_u.portnum != 0xf)
-            etd->val = s26_rd_phy(etd->ed_u.portnum,etd->phy_reg);
-        else
-            etd->val = athrs26_reg_read(etd->phy_reg);
-    }
-    else if(cmd  == S26_WR_PHY) {
-        if(etd->ed_u.portnum != 0xf)
-            s26_wr_phy(etd->ed_u.portnum,etd->phy_reg,etd->val);
-        else
-            athrs26_reg_write(etd->phy_reg,etd->val);
-    }
-    else if(cmd == S26_FORCE_PHY) {
-         if(etd->phy_reg < ATHR_PHY_MAX) {
-            if(etd->val == 10) {
-	       printk("Forcing 10Mbps %s on port:%d \n",
-                         dup_str[etd->ed_u.duplex],(etd->phy_reg));
-               athrs26_force_10M(etd->phy_reg,etd->ed_u.duplex);
-            }
-            else if(etd->val == 100) {
-	       printk("Forcing 100Mbps %s on port:%d \n",
-                         dup_str[etd->ed_u.duplex],(etd->phy_reg));
-               athrs26_force_100M(etd->phy_reg,etd->ed_u.duplex);
-            }
-	    else if(etd->val == 0) {
-	       printk("Enabling Auto Neg on port:%d \n",(etd->phy_reg));
-
-               ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
-
-               if(ar7240_revid == AR7240_REV_1_0) {
-                   s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x0);
-                   s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_DATA,0x2ee);
-                   s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_ADDRESS,0x3);
-                   s26_wr_phy(etd->phy_reg,ATHR_DEBUG_PORT_DATA,0x3a11);
+               if(ATHR_ETHUNIT(ethcfg->phy_reg) == ENET_UNIT_WAN) {
+                   if(mac_has_flag(ag7240_macs[ENET_UNIT_LAN],ETH_SWONLY_MODE))
+                       ag7240_check_link(ag7240_macs[ENET_UNIT_LAN],ethcfg->phy_reg);
+                   else
+                       ag7240_check_link(ag7240_macs[0],ethcfg->phy_reg);
+               }else{ 
+                   ag7240_check_link(ag7240_macs[1],ethcfg->phy_reg);
                }
-               s26_wr_phy(etd->phy_reg,ATHR_PHY_CONTROL,0x9000);
-            }
-            else
-               return -EINVAL;
-
-            if(ATHR_ETHUNIT(etd->phy_reg) == ENET_UNIT_WAN) 
-                ag7240_check_link(ag7240_macs[0],etd->phy_reg);
-            else  
-                ag7240_check_link(ag7240_macs[1],etd->phy_reg);
-        }
-        else {
+            break;
+            } 
+        default: 
             return -EINVAL;
         }
-    }
-    else
-        return -EINVAL;
-
     return 0;
 }
-#endif
 
 int athrs26_mdc_check()
 {
@@ -1369,10 +1372,15 @@
                if (!athrs26_phy_is_link_alive(phyUnit) && !((linkDown >> phyUnit) & 0x1))
                         continue;
 
-               if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) 
-                    ag7240_check_link(ag7240_macs[0],phyUnit);
-               else  
+               if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+                    if (mac_has_flag(ag7240_macs[ENET_UNIT_LAN],ETH_SWONLY_MODE))
+                        ag7240_check_link(ag7240_macs[ENET_UNIT_LAN],phyUnit);
+                    else
+                        ag7240_check_link(ag7240_macs[0],phyUnit);
+               }
+               else {  
                     ag7240_check_link(ag7240_macs[1],phyUnit);
+               }
            }
        }
        athrs26_reg_write(S26_GLOBAL_INTR_MASK_REG,PHY_LINK_CHANGE_REG); 
Index: Makefile
===================================================================
--- Makefile	(revision 15022)
+++ Makefile	(working copy)
@@ -5,6 +5,9 @@
 
 obj-phy-$(CONFIG_AR7240_S26_PHY) 	+= ar7240_s26_phy.o
 obj-phy-$(CONFIG_AR7240_S26_VLAN_IGMP)		+= python_vlan_igmp.o
+obj-phy-$(CONFIG_AR7242_RGMII_PHY)      += athrf1_phy.o
+obj-phy-$(CONFIG_AR7242_S16_PHY)        += athrs16_phy.o
+obj-phy-$(CONFIG_AR7242_VIR_PHY)        += athr_vir_phy.o
 
 ag7240_mod-objs			:=	$(obj-phy-y) ag7240.o
 

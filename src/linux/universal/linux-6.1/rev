Index: arch/x86/include/asm/vsyscall.h
===================================================================
--- arch/x86/include/asm/vsyscall.h	(revision 55465)
+++ arch/x86/include/asm/vsyscall.h	(revision 55464)
@@ -4,7 +4,6 @@
 
 #include <linux/seqlock.h>
 #include <uapi/asm/vsyscall.h>
-#include <asm/page_types.h>
 
 #ifdef CONFIG_X86_VSYSCALL_EMULATION
 extern void map_vsyscall(void);
@@ -25,13 +24,4 @@
 }
 #endif
 
-/*
- * The (legacy) vsyscall page is the long page in the kernel portion
- * of the address space that has user-accessible permissions.
- */
-static inline bool is_vsyscall_vaddr(unsigned long vaddr)
-{
-	return unlikely((vaddr & PAGE_MASK) == VSYSCALL_ADDR);
-}
-
 #endif /* _ASM_X86_VSYSCALL_H */
Index: arch/x86/kernel/cpu/resctrl/internal.h
===================================================================
--- arch/x86/kernel/cpu/resctrl/internal.h	(revision 55465)
+++ arch/x86/kernel/cpu/resctrl/internal.h	(revision 55464)
@@ -281,10 +281,14 @@
  * struct mbm_state - status for each MBM counter in each domain
  * @prev_bw_bytes: Previous bytes value read for bandwidth calculation
  * @prev_bw:	The most recent bandwidth in MBps
+ * @delta_bw:	Difference between the current and previous bandwidth
+ * @delta_comp:	Indicates whether to compute the delta_bw
  */
 struct mbm_state {
 	u64	prev_bw_bytes;
 	u32	prev_bw;
+	u32	delta_bw;
+	bool	delta_comp;
 };
 
 /**
Index: arch/x86/kernel/cpu/resctrl/monitor.c
===================================================================
--- arch/x86/kernel/cpu/resctrl/monitor.c	(revision 55465)
+++ arch/x86/kernel/cpu/resctrl/monitor.c	(revision 55464)
@@ -428,6 +428,9 @@
 
 	cur_bw = bytes / SZ_1M;
 
+	if (m->delta_comp)
+		m->delta_bw = abs(cur_bw - m->prev_bw);
+	m->delta_comp = false;
 	m->prev_bw = cur_bw;
 }
 
@@ -505,11 +508,11 @@
 {
 	u32 closid, rmid, cur_msr_val, new_msr_val;
 	struct mbm_state *pmbm_data, *cmbm_data;
+	u32 cur_bw, delta_bw, user_bw;
 	struct rdt_resource *r_mba;
 	struct rdt_domain *dom_mba;
 	struct list_head *head;
 	struct rdtgroup *entry;
-	u32 cur_bw, user_bw;
 
 	if (!is_mbm_local_enabled())
 		return;
@@ -528,6 +531,7 @@
 
 	cur_bw = pmbm_data->prev_bw;
 	user_bw = dom_mba->mbps_val[closid];
+	delta_bw = pmbm_data->delta_bw;
 
 	/* MBA resource doesn't support CDP */
 	cur_msr_val = resctrl_arch_get_config(r_mba, dom_mba, closid, CDP_NONE);
@@ -539,6 +543,7 @@
 	list_for_each_entry(entry, head, mon.crdtgrp_list) {
 		cmbm_data = &dom_mbm->mbm_local[entry->mon.rmid];
 		cur_bw += cmbm_data->prev_bw;
+		delta_bw += cmbm_data->delta_bw;
 	}
 
 	/*
@@ -545,19 +550,20 @@
 	 * Scale up/down the bandwidth linearly for the ctrl group.  The
 	 * bandwidth step is the bandwidth granularity specified by the
 	 * hardware.
-	 * Always increase throttling if current bandwidth is above the
-	 * target set by user.
-	 * But avoid thrashing up and down on every poll by checking
-	 * whether a decrease in throttling is likely to push the group
-	 * back over target. E.g. if currently throttling to 30% of bandwidth
-	 * on a system with 10% granularity steps, check whether moving to
-	 * 40% would go past the limit by multiplying current bandwidth by
-	 * "(30 + 10) / 30".
+	 *
+	 * The delta_bw is used when increasing the bandwidth so that we
+	 * dont alternately increase and decrease the control values
+	 * continuously.
+	 *
+	 * For ex: consider cur_bw = 90MBps, user_bw = 100MBps and if
+	 * bandwidth step is 20MBps(> user_bw - cur_bw), we would keep
+	 * switching between 90 and 110 continuously if we only check
+	 * cur_bw < user_bw.
 	 */
 	if (cur_msr_val > r_mba->membw.min_bw && user_bw < cur_bw) {
 		new_msr_val = cur_msr_val - r_mba->membw.bw_gran;
 	} else if (cur_msr_val < MAX_MBA_BW &&
-		   (user_bw > (cur_bw * (cur_msr_val + r_mba->membw.min_bw) / cur_msr_val))) {
+		   (user_bw > (cur_bw + delta_bw))) {
 		new_msr_val = cur_msr_val + r_mba->membw.bw_gran;
 	} else {
 		return;
@@ -564,6 +570,22 @@
 	}
 
 	resctrl_arch_update_one(r_mba, dom_mba, closid, CDP_NONE, new_msr_val);
+
+	/*
+	 * Delta values are updated dynamically package wise for each
+	 * rdtgrp every time the throttle MSR changes value.
+	 *
+	 * This is because (1)the increase in bandwidth is not perfectly
+	 * linear and only "approximately" linear even when the hardware
+	 * says it is linear.(2)Also since MBA is a core specific
+	 * mechanism, the delta values vary based on number of cores used
+	 * by the rdtgrp.
+	 */
+	pmbm_data->delta_comp = true;
+	list_for_each_entry(entry, head, mon.crdtgrp_list) {
+		cmbm_data = &dom_mbm->mbm_local[entry->mon.rmid];
+		cmbm_data->delta_comp = true;
+	}
 }
 
 static void mbm_update(struct rdt_resource *r, struct rdt_domain *d, int rmid)
Index: arch/x86/kernel/acpi/cppc.c
===================================================================
--- arch/x86/kernel/acpi/cppc.c	(revision 55465)
+++ arch/x86/kernel/acpi/cppc.c	(revision 55464)
@@ -20,7 +20,7 @@
 		    (boot_cpu_data.x86_model >= 0x20 && boot_cpu_data.x86_model <= 0x2f)))
 			return true;
 		else if (boot_cpu_data.x86 == 0x17 &&
-			 boot_cpu_data.x86_model >= 0x30 && boot_cpu_data.x86_model <= 0x7f)
+			 boot_cpu_data.x86_model >= 0x70 && boot_cpu_data.x86_model <= 0x7f)
 			return true;
 		return boot_cpu_has(X86_FEATURE_CPPC);
 	}
Index: arch/x86/mm/maccess.c
===================================================================
--- arch/x86/mm/maccess.c	(revision 55465)
+++ arch/x86/mm/maccess.c	(revision 55464)
@@ -3,8 +3,6 @@
 #include <linux/uaccess.h>
 #include <linux/kernel.h>
 
-#include <asm/vsyscall.h>
-
 #ifdef CONFIG_X86_64
 bool copy_from_kernel_nofault_allowed(const void *unsafe_src, size_t size)
 {
@@ -18,14 +16,6 @@
 		return false;
 
 	/*
-	 * Reading from the vsyscall page may cause an unhandled fault in
-	 * certain cases.  Though it is at an address above TASK_SIZE_MAX, it is
-	 * usually considered as a user space address.
-	 */
-	if (is_vsyscall_vaddr(vaddr))
-		return false;
-
-	/*
 	 * Allow everything during early boot before 'x86_virt_bits'
 	 * is initialized.  Needed for instruction decoding in early
 	 * exception handlers.
Index: arch/x86/mm/fault.c
===================================================================
--- arch/x86/mm/fault.c	(revision 55465)
+++ arch/x86/mm/fault.c	(revision 55464)
@@ -818,6 +818,15 @@
 	show_opcodes(regs, loglvl);
 }
 
+/*
+ * The (legacy) vsyscall page is the long page in the kernel portion
+ * of the address space that has user-accessible permissions.
+ */
+static bool is_vsyscall_vaddr(unsigned long vaddr)
+{
+	return unlikely((vaddr & PAGE_MASK) == VSYSCALL_ADDR);
+}
+
 static void
 __bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
 		       unsigned long address, u32 pkey, int si_code)
Index: arch/x86/mm/mem_encrypt_identity.c
===================================================================
--- arch/x86/mm/mem_encrypt_identity.c	(revision 55465)
+++ arch/x86/mm/mem_encrypt_identity.c	(revision 55464)
@@ -507,6 +507,7 @@
 	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;
 	unsigned int eax, ebx, ecx, edx;
 	unsigned long feature_mask;
+	bool active_by_default;
 	unsigned long me_mask;
 	char buffer[16];
 	bool snp;
@@ -592,19 +593,22 @@
 	     : "p" (sme_cmdline_off));
 
 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))
-		sme_me_mask = me_mask;
+		active_by_default = true;
+	else
+		active_by_default = false;
 
 	cmdline_ptr = (const char *)((u64)bp->hdr.cmd_line_ptr |
 				     ((u64)bp->ext_cmd_line_ptr << 32));
 
 	if (cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer)) < 0)
-		goto out;
+		return;
 
 	if (!strncmp(buffer, cmdline_on, sizeof(buffer)))
 		sme_me_mask = me_mask;
 	else if (!strncmp(buffer, cmdline_off, sizeof(buffer)))
 		sme_me_mask = 0;
-
+	else
+		sme_me_mask = active_by_default ? me_mask : 0;
 out:
 	if (sme_me_mask) {
 		physical_mask &= ~sme_me_mask;
Index: arch/x86/events/amd/core.c
===================================================================
--- arch/x86/events/amd/core.c	(revision 55465)
+++ arch/x86/events/amd/core.c	(revision 55464)
@@ -604,6 +604,7 @@
 
 	kfree(cpuhw->lbr_sel);
 	cpuhw->lbr_sel = NULL;
+	amd_pmu_cpu_reset(cpu);
 
 	if (!x86_pmu.amd_nb_constraints)
 		return;
Index: arch/x86/xen/smp.c
===================================================================
--- arch/x86/xen/smp.c	(revision 55465)
+++ arch/x86/xen/smp.c	(revision 55464)
@@ -65,8 +65,6 @@
 	char *resched_name, *callfunc_name, *debug_name;
 
 	resched_name = kasprintf(GFP_KERNEL, "resched%d", cpu);
-	if (!resched_name)
-		goto fail_mem;
 	per_cpu(xen_resched_irq, cpu).name = resched_name;
 	rc = bind_ipi_to_irqhandler(XEN_RESCHEDULE_VECTOR,
 				    cpu,
@@ -79,8 +77,6 @@
 	per_cpu(xen_resched_irq, cpu).irq = rc;
 
 	callfunc_name = kasprintf(GFP_KERNEL, "callfunc%d", cpu);
-	if (!callfunc_name)
-		goto fail_mem;
 	per_cpu(xen_callfunc_irq, cpu).name = callfunc_name;
 	rc = bind_ipi_to_irqhandler(XEN_CALL_FUNCTION_VECTOR,
 				    cpu,
@@ -94,9 +90,6 @@
 
 	if (!xen_fifo_events) {
 		debug_name = kasprintf(GFP_KERNEL, "debug%d", cpu);
-		if (!debug_name)
-			goto fail_mem;
-
 		per_cpu(xen_debug_irq, cpu).name = debug_name;
 		rc = bind_virq_to_irqhandler(VIRQ_DEBUG, cpu,
 					     xen_debug_interrupt,
@@ -108,9 +101,6 @@
 	}
 
 	callfunc_name = kasprintf(GFP_KERNEL, "callfuncsingle%d", cpu);
-	if (!callfunc_name)
-		goto fail_mem;
-
 	per_cpu(xen_callfuncsingle_irq, cpu).name = callfunc_name;
 	rc = bind_ipi_to_irqhandler(XEN_CALL_FUNCTION_SINGLE_VECTOR,
 				    cpu,
@@ -124,8 +114,6 @@
 
 	return 0;
 
- fail_mem:
-	rc = -ENOMEM;
  fail:
 	xen_smp_intr_free(cpu);
 	return rc;
Index: arch/x86/tools/relocs.c
===================================================================
--- arch/x86/tools/relocs.c	(revision 55465)
+++ arch/x86/tools/relocs.c	(revision 55464)
@@ -653,14 +653,6 @@
 		if (!(sec_applies->shdr.sh_flags & SHF_ALLOC)) {
 			continue;
 		}
-		/*
-		 * Do not perform relocations in .notes section; any
-		 * values there are meant for pre-boot consumption (e.g.
-		 * startup_xen).
-		 */
-		if (sec_applies->shdr.sh_type == SHT_NOTE) {
-			continue;
-		}
 		sh_symtab  = sec_symtab->symtab;
 		sym_strtab = sec_symtab->link->strtab;
 		for (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {
Index: arch/arm/boot/dts/imx6dl-yapp4-common.dtsi
===================================================================
--- arch/arm/boot/dts/imx6dl-yapp4-common.dtsi	(revision 55465)
+++ arch/arm/boot/dts/imx6dl-yapp4-common.dtsi	(revision 55464)
@@ -106,6 +106,8 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_enet>;
 	phy-mode = "rgmii-id";
+	phy-reset-gpios = <&gpio1 25 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <20>;
 	phy-supply = <&sw2_reg>;
 	status = "okay";
 
@@ -118,10 +120,17 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		phy_port2: phy@1 {
+			reg = <1>;
+		};
+
+		phy_port3: phy@2 {
+			reg = <2>;
+		};
+
 		switch@10 {
 			compatible = "qca,qca8334";
-			reg = <0x10>;
-			reset-gpios = <&gpio1 25 GPIO_ACTIVE_LOW>;
+			reg = <10>;
 
 			switch_ports: ports {
 				#address-cells = <1>;
@@ -142,7 +151,6 @@
 				eth2: port@2 {
 					reg = <2>;
 					label = "eth2";
-					phy-mode = "internal";
 					phy-handle = <&phy_port2>;
 				};
 
@@ -149,23 +157,9 @@
 				eth1: port@3 {
 					reg = <3>;
 					label = "eth1";
-					phy-mode = "internal";
 					phy-handle = <&phy_port3>;
 				};
 			};
-
-			mdio {
-				#address-cells = <1>;
-				#size-cells = <0>;
-
-				phy_port2: ethernet-phy@1 {
-					reg = <1>;
-				};
-
-				phy_port3: ethernet-phy@2 {
-					reg = <2>;
-				};
-			};
 		};
 	};
 };
Index: arch/arm/boot/dts/qcom-msm8974.dtsi
===================================================================
--- arch/arm/boot/dts/qcom-msm8974.dtsi	(revision 55465)
+++ arch/arm/boot/dts/qcom-msm8974.dtsi	(revision 55464)
@@ -1134,7 +1134,7 @@
 
 		qfprom: qfprom@fc4bc000 {
 			compatible = "qcom,msm8974-qfprom", "qcom,qfprom";
-			reg = <0xfc4bc000 0x2100>;
+			reg = <0xfc4bc000 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <1>;
 			tsens_calib: calib@d0 {
Index: arch/arm/boot/dts/arm-realview-pb1176.dts
===================================================================
--- arch/arm/boot/dts/arm-realview-pb1176.dts	(revision 55465)
+++ arch/arm/boot/dts/arm-realview-pb1176.dts	(revision 55464)
@@ -451,7 +451,7 @@
 
 		/* Direct-mapped development chip ROM */
 		pb1176_rom@10200000 {
-			compatible = "mtd-rom";
+			compatible = "direct-mapped";
 			reg = <0x10200000 0x4000>;
 			bank-width = <1>;
 		};
Index: arch/arm/boot/dts/r8a73a4-ape6evm.dts
===================================================================
--- arch/arm/boot/dts/r8a73a4-ape6evm.dts	(revision 55465)
+++ arch/arm/boot/dts/r8a73a4-ape6evm.dts	(revision 55464)
@@ -209,18 +209,6 @@
 	status = "okay";
 };
 
-&extal1_clk {
-	clock-frequency = <26000000>;
-};
-
-&extal2_clk {
-	clock-frequency = <48000000>;
-};
-
-&extalr_clk {
-	clock-frequency = <32768>;
-};
-
 &pfc {
 	scifa0_pins: scifa0 {
 		groups = "scifa0_data";
Index: arch/arm/boot/dts/r8a73a4.dtsi
===================================================================
--- arch/arm/boot/dts/r8a73a4.dtsi	(revision 55465)
+++ arch/arm/boot/dts/r8a73a4.dtsi	(revision 55464)
@@ -450,20 +450,17 @@
 		extalr_clk: extalr {
 			compatible = "fixed-clock";
 			#clock-cells = <0>;
-			/* This value must be overridden by the board. */
-			clock-frequency = <0>;
+			clock-frequency = <32768>;
 		};
 		extal1_clk: extal1 {
 			compatible = "fixed-clock";
 			#clock-cells = <0>;
-			/* This value must be overridden by the board. */
-			clock-frequency = <0>;
+			clock-frequency = <25000000>;
 		};
 		extal2_clk: extal2 {
 			compatible = "fixed-clock";
 			#clock-cells = <0>;
-			/* This value must be overridden by the board. */
-			clock-frequency = <0>;
+			clock-frequency = <48000000>;
 		};
 		fsiack_clk: fsiack {
 			compatible = "fixed-clock";
Index: arch/arm/crypto/sha256_glue.c
===================================================================
--- arch/arm/crypto/sha256_glue.c	(revision 55465)
+++ arch/arm/crypto/sha256_glue.c	(revision 55464)
@@ -24,8 +24,8 @@
 
 #include "sha256_glue.h"
 
-asmlinkage void sha256_block_data_order(struct sha256_state *state,
-					const u8 *data, int num_blks);
+asmlinkage void sha256_block_data_order(u32 *digest, const void *data,
+					unsigned int num_blks);
 
 int crypto_sha256_arm_update(struct shash_desc *desc, const u8 *data,
 			     unsigned int len)
@@ -33,13 +33,15 @@
 	/* make sure casting to sha256_block_fn() is safe */
 	BUILD_BUG_ON(offsetof(struct sha256_state, state) != 0);
 
-	return sha256_base_do_update(desc, data, len, sha256_block_data_order);
+	return sha256_base_do_update(desc, data, len,
+				(sha256_block_fn *)sha256_block_data_order);
 }
 EXPORT_SYMBOL(crypto_sha256_arm_update);
 
 static int crypto_sha256_arm_final(struct shash_desc *desc, u8 *out)
 {
-	sha256_base_do_finalize(desc, sha256_block_data_order);
+	sha256_base_do_finalize(desc,
+				(sha256_block_fn *)sha256_block_data_order);
 	return sha256_base_finish(desc, out);
 }
 
@@ -46,7 +48,8 @@
 int crypto_sha256_arm_finup(struct shash_desc *desc, const u8 *data,
 			    unsigned int len, u8 *out)
 {
-	sha256_base_do_update(desc, data, len, sha256_block_data_order);
+	sha256_base_do_update(desc, data, len,
+			      (sha256_block_fn *)sha256_block_data_order);
 	return crypto_sha256_arm_final(desc, out);
 }
 EXPORT_SYMBOL(crypto_sha256_arm_finup);
Index: arch/arm/crypto/sha512-glue.c
===================================================================
--- arch/arm/crypto/sha512-glue.c	(revision 55465)
+++ arch/arm/crypto/sha512-glue.c	(revision 55464)
@@ -25,18 +25,19 @@
 MODULE_ALIAS_CRYPTO("sha384-arm");
 MODULE_ALIAS_CRYPTO("sha512-arm");
 
-asmlinkage void sha512_block_data_order(struct sha512_state *state,
-					u8 const *src, int blocks);
+asmlinkage void sha512_block_data_order(u64 *state, u8 const *src, int blocks);
 
 int sha512_arm_update(struct shash_desc *desc, const u8 *data,
 		      unsigned int len)
 {
-	return sha512_base_do_update(desc, data, len, sha512_block_data_order);
+	return sha512_base_do_update(desc, data, len,
+		(sha512_block_fn *)sha512_block_data_order);
 }
 
 static int sha512_arm_final(struct shash_desc *desc, u8 *out)
 {
-	sha512_base_do_finalize(desc, sha512_block_data_order);
+	sha512_base_do_finalize(desc,
+		(sha512_block_fn *)sha512_block_data_order);
 	return sha512_base_finish(desc, out);
 }
 
@@ -43,7 +44,8 @@
 int sha512_arm_finup(struct shash_desc *desc, const u8 *data,
 		     unsigned int len, u8 *out)
 {
-	sha512_base_do_update(desc, data, len, sha512_block_data_order);
+	sha512_base_do_update(desc, data, len,
+		(sha512_block_fn *)sha512_block_data_order);
 	return sha512_arm_final(desc, out);
 }
 
Index: arch/arm64/include/asm/fpsimd.h
===================================================================
--- arch/arm64/include/asm/fpsimd.h	(revision 55465)
+++ arch/arm64/include/asm/fpsimd.h	(revision 55464)
@@ -36,13 +36,13 @@
  * When we defined the maximum SVE vector length we defined the ABI so
  * that the maximum vector length included all the reserved for future
  * expansion bits in ZCR rather than those just currently defined by
- * the architecture.  Using this length to allocate worst size buffers
- * results in excessively large allocations, and this effect is even
- * more pronounced for SME due to ZA.  Define more suitable VLs for
- * these situations.
+ * the architecture. While SME follows a similar pattern the fact that
+ * it includes a square matrix means that any allocations that attempt
+ * to cover the maximum potential vector length (such as happen with
+ * the regset used for ptrace) end up being extremely large. Define
+ * the much lower actual limit for use in such situations.
  */
-#define ARCH_SVE_VQ_MAX ((ZCR_ELx_LEN_MASK >> ZCR_ELx_LEN_SHIFT) + 1)
-#define SME_VQ_MAX	((SMCR_ELx_LEN_MASK >> SMCR_ELx_LEN_SHIFT) + 1)
+#define SME_VQ_MAX	16
 
 struct task_struct;
 
Index: arch/arm64/boot/dts/rockchip/rk356x.dtsi
===================================================================
--- arch/arm64/boot/dts/rockchip/rk356x.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/rockchip/rk356x.dtsi	(revision 55464)
@@ -596,7 +596,6 @@
 		compatible = "rockchip,rk3568-vpu";
 		reg = <0x0 0xfdea0000 0x0 0x800>;
 		interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
-		interrupt-names = "vdpu";
 		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
 		clock-names = "aclk", "hclk";
 		iommus = <&vdpu_mmu>;
Index: arch/arm64/boot/dts/qcom/sm8150.dtsi
===================================================================
--- arch/arm64/boot/dts/qcom/sm8150.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/qcom/sm8150.dtsi	(revision 55464)
@@ -1822,8 +1822,8 @@
 			phys = <&pcie0_lane>;
 			phy-names = "pciephy";
 
-			perst-gpios = <&tlmm 35 GPIO_ACTIVE_HIGH>;
-			wake-gpios = <&tlmm 37 GPIO_ACTIVE_HIGH>;
+			perst-gpio = <&tlmm 35 GPIO_ACTIVE_HIGH>;
+			enable-gpio = <&tlmm 37 GPIO_ACTIVE_HIGH>;
 
 			pinctrl-names = "default";
 			pinctrl-0 = <&pcie0_default_state>;
@@ -1925,7 +1925,7 @@
 			phys = <&pcie1_lane>;
 			phy-names = "pciephy";
 
-			perst-gpios = <&tlmm 102 GPIO_ACTIVE_HIGH>;
+			perst-gpio = <&tlmm 102 GPIO_ACTIVE_HIGH>;
 			enable-gpio = <&tlmm 104 GPIO_ACTIVE_HIGH>;
 
 			pinctrl-names = "default";
Index: arch/arm64/boot/dts/qcom/sdm845-db845c.dts
===================================================================
--- arch/arm64/boot/dts/qcom/sdm845-db845c.dts	(revision 55465)
+++ arch/arm64/boot/dts/qcom/sdm845-db845c.dts	(revision 55464)
@@ -532,7 +532,7 @@
 &pcie0 {
 	status = "okay";
 	perst-gpios = <&tlmm 35 GPIO_ACTIVE_LOW>;
-	wake-gpios = <&tlmm 134 GPIO_ACTIVE_HIGH>;
+	enable-gpio = <&tlmm 134 GPIO_ACTIVE_HIGH>;
 
 	vddpe-3v3-supply = <&pcie0_3p3v_dual>;
 
Index: arch/arm64/boot/dts/freescale/imx8mm-kontron-bl-osm-s.dts
===================================================================
--- arch/arm64/boot/dts/freescale/imx8mm-kontron-bl-osm-s.dts	(revision 55465)
+++ arch/arm64/boot/dts/freescale/imx8mm-kontron-bl-osm-s.dts	(revision 55464)
@@ -294,8 +294,8 @@
 
 	pinctrl_i2c4: i2c4grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x40000083
-			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x40000083
+			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x400001c3
 		>;
 	};
 
@@ -313,19 +313,19 @@
 
 	pinctrl_uart1: uart1grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SAI2_RXC_UART1_DCE_RX		0x0
-			MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX		0x0
-			MX8MM_IOMUXC_SAI2_RXD0_UART1_DCE_RTS_B		0x0
-			MX8MM_IOMUXC_SAI2_TXFS_UART1_DCE_CTS_B		0x0
+			MX8MM_IOMUXC_SAI2_RXC_UART1_DCE_RX		0x140
+			MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX		0x140
+			MX8MM_IOMUXC_SAI2_RXD0_UART1_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_SAI2_TXFS_UART1_DCE_CTS_B		0x140
 		>;
 	};
 
 	pinctrl_uart2: uart2grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SAI3_TXFS_UART2_DCE_RX		0x0
-			MX8MM_IOMUXC_SAI3_TXC_UART2_DCE_TX		0x0
-			MX8MM_IOMUXC_SAI3_RXD_UART2_DCE_RTS_B		0x0
-			MX8MM_IOMUXC_SAI3_RXC_UART2_DCE_CTS_B		0x0
+			MX8MM_IOMUXC_SAI3_TXFS_UART2_DCE_RX		0x140
+			MX8MM_IOMUXC_SAI3_TXC_UART2_DCE_TX		0x140
+			MX8MM_IOMUXC_SAI3_RXD_UART2_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_SAI3_RXC_UART2_DCE_CTS_B		0x140
 		>;
 	};
 
@@ -337,40 +337,40 @@
 
 	pinctrl_usdhc2: usdhc2grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x90
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x190
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d0
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d0
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d0
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d0
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d0
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 
 	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x94
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x194
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d4
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d4
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d4
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d4
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d4
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 
 	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x96
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x196
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d6
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d6
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d6
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d6
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d6
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 };
Index: arch/arm64/boot/dts/freescale/imx8mm-kontron-bl.dts
===================================================================
--- arch/arm64/boot/dts/freescale/imx8mm-kontron-bl.dts	(revision 55465)
+++ arch/arm64/boot/dts/freescale/imx8mm-kontron-bl.dts	(revision 55464)
@@ -277,8 +277,8 @@
 
 	pinctrl_i2c4: i2c4grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x40000083
-			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x40000083
+			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x400001c3
 		>;
 	};
 
@@ -290,19 +290,19 @@
 
 	pinctrl_uart1: uart1grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SAI2_RXC_UART1_DCE_RX		0x0
-			MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX		0x0
-			MX8MM_IOMUXC_SAI2_RXD0_UART1_DCE_RTS_B		0x0
-			MX8MM_IOMUXC_SAI2_TXFS_UART1_DCE_CTS_B		0x0
+			MX8MM_IOMUXC_SAI2_RXC_UART1_DCE_RX		0x140
+			MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX		0x140
+			MX8MM_IOMUXC_SAI2_RXD0_UART1_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_SAI2_TXFS_UART1_DCE_CTS_B		0x140
 		>;
 	};
 
 	pinctrl_uart2: uart2grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SAI3_TXFS_UART2_DCE_RX		0x0
-			MX8MM_IOMUXC_SAI3_TXC_UART2_DCE_TX		0x0
-			MX8MM_IOMUXC_SAI3_RXD_UART2_DCE_RTS_B		0x0
-			MX8MM_IOMUXC_SAI3_RXC_UART2_DCE_CTS_B		0x0
+			MX8MM_IOMUXC_SAI3_TXFS_UART2_DCE_RX		0x140
+			MX8MM_IOMUXC_SAI3_TXC_UART2_DCE_TX		0x140
+			MX8MM_IOMUXC_SAI3_RXD_UART2_DCE_RTS_B		0x140
+			MX8MM_IOMUXC_SAI3_RXC_UART2_DCE_CTS_B		0x140
 		>;
 	};
 
@@ -314,40 +314,40 @@
 
 	pinctrl_usdhc2: usdhc2grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x90
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x190
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d0
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d0
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d0
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d0
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d0
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 
 	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x94
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x194
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d4
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d4
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d4
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d4
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d4
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 
 	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
 		fsl,pins = <
-			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x96
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK			0x196
 			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD			0x1d6
 			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0		0x1d6
 			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1		0x1d6
 			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2		0x1d6
 			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3		0x1d6
-			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x19
-			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xd0
+			MX8MM_IOMUXC_SD2_CD_B_GPIO2_IO12		0x019
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0
 		>;
 	};
 };
Index: arch/arm64/boot/dts/freescale/imx8mm-kontron-osm-s.dtsi
===================================================================
--- arch/arm64/boot/dts/freescale/imx8mm-kontron-osm-s.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/freescale/imx8mm-kontron-osm-s.dtsi	(revision 55464)
@@ -205,7 +205,7 @@
 		reg = <0x52>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_rtc>;
-		interrupts-extended = <&gpio4 1 IRQ_TYPE_LEVEL_LOW>;
+		interrupts-extended = <&gpio4 1 IRQ_TYPE_LEVEL_HIGH>;
 		trickle-diode-disable;
 	};
 };
@@ -247,8 +247,8 @@
 
 	pinctrl_i2c1: i2c1grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x40000083
-			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x40000083
+			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x400001c3
 		>;
 	};
 
Index: arch/arm64/boot/dts/freescale/imx8mm-kontron-sl.dtsi
===================================================================
--- arch/arm64/boot/dts/freescale/imx8mm-kontron-sl.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/freescale/imx8mm-kontron-sl.dtsi	(revision 55464)
@@ -237,8 +237,8 @@
 
 	pinctrl_i2c1: i2c1grp {
 		fsl,pins = <
-			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x40000083
-			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x40000083
+			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x400001c3
 		>;
 	};
 
Index: arch/arm64/boot/dts/freescale/imx8mm-venice-gw71xx.dtsi
===================================================================
--- arch/arm64/boot/dts/freescale/imx8mm-venice-gw71xx.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/freescale/imx8mm-venice-gw71xx.dtsi	(revision 55464)
@@ -47,6 +47,17 @@
 		gpios = <&gpio1 15 GPIO_ACTIVE_HIGH>;
 		status = "okay";
 	};
+
+	reg_usb_otg1_vbus: regulator-usb-otg1 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usb1_en>;
+		compatible = "regulator-fixed";
+		regulator-name = "usb_otg1_vbus";
+		gpio = <&gpio1 10 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
 };
 
 /* off-board header */
@@ -135,10 +146,9 @@
 };
 
 &usbotg1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usbotg1>;
 	dr_mode = "otg";
 	over-current-active-low;
+	vbus-supply = <&reg_usb_otg1_vbus>;
 	status = "okay";
 };
 
@@ -196,6 +206,14 @@
 		>;
 	};
 
+	pinctrl_reg_usb1_en: regusb1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO10_GPIO1_IO10	0x41
+			MX8MM_IOMUXC_GPIO1_IO12_GPIO1_IO12	0x141
+			MX8MM_IOMUXC_GPIO1_IO13_USB1_OTG_OC	0x41
+		>;
+	};
+
 	pinctrl_spi2: spi2grp {
 		fsl,pins = <
 			MX8MM_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK	0xd6
@@ -218,11 +236,4 @@
 			MX8MM_IOMUXC_UART3_TXD_UART3_DCE_TX	0x140
 		>;
 	};
-
-	pinctrl_usbotg1: usbotg1grp {
-		fsl,pins = <
-			MX8MM_IOMUXC_GPIO1_IO12_GPIO1_IO12	0x141
-			MX8MM_IOMUXC_GPIO1_IO13_USB1_OTG_OC	0x41
-		>;
-	};
 };
Index: arch/arm64/boot/dts/marvell/armada-37xx.dtsi
===================================================================
--- arch/arm64/boot/dts/marvell/armada-37xx.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/marvell/armada-37xx.dtsi	(revision 55464)
@@ -426,14 +426,14 @@
 			crypto: crypto@90000 {
 				compatible = "inside-secure,safexcel-eip97ies";
 				reg = <0x90000 0x20000>;
-				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
 					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
 					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
 					     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
-				interrupt-names = "ring0", "ring1", "ring2",
-						  "ring3", "eip", "mem";
+					     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "mem", "ring0", "ring1",
+						  "ring2", "ring3", "eip";
 				clocks = <&nb_periph_clk 15>;
 			};
 
Index: arch/arm64/boot/dts/marvell/armada-ap80x.dtsi
===================================================================
--- arch/arm64/boot/dts/marvell/armada-ap80x.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/marvell/armada-ap80x.dtsi	(revision 55464)
@@ -133,6 +133,7 @@
 
 			odmi: odmi@300000 {
 				compatible = "marvell,odmi-controller";
+				interrupt-controller;
 				msi-controller;
 				marvell,odmi-frames = <4>;
 				reg = <0x300000 0x4000>,
Index: arch/arm64/boot/dts/marvell/armada-cp11x.dtsi
===================================================================
--- arch/arm64/boot/dts/marvell/armada-cp11x.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/marvell/armada-cp11x.dtsi	(revision 55464)
@@ -506,14 +506,14 @@
 		CP11X_LABEL(crypto): crypto@800000 {
 			compatible = "inside-secure,safexcel-eip197b";
 			reg = <0x800000 0x200000>;
-			interrupts = <88 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts = <87 IRQ_TYPE_LEVEL_HIGH>,
+				<88 IRQ_TYPE_LEVEL_HIGH>,
 				<89 IRQ_TYPE_LEVEL_HIGH>,
 				<90 IRQ_TYPE_LEVEL_HIGH>,
 				<91 IRQ_TYPE_LEVEL_HIGH>,
-				<92 IRQ_TYPE_LEVEL_HIGH>,
-				<87 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "ring0", "ring1", "ring2", "ring3",
-					  "eip", "mem";
+				<92 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "mem", "ring0", "ring1",
+				"ring2", "ring3", "eip";
 			clock-names = "core", "reg";
 			clocks = <&CP11X_LABEL(clk) 1 26>,
 				 <&CP11X_LABEL(clk) 1 17>;
Index: arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt7622-bananapi-bpi-r64.dts	(revision 55464)
@@ -74,7 +74,6 @@
 
 	memory@40000000 {
 		reg = <0 0x40000000 0 0x40000000>;
-		device_type = "memory";
 	};
 
 	reg_1p8v: regulator-1p8v {
Index: arch/arm64/boot/dts/mediatek/mt7622-rfb1.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt7622-rfb1.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt7622-rfb1.dts	(revision 55464)
@@ -56,7 +56,6 @@
 
 	memory@40000000 {
 		reg = <0 0x40000000 0 0x20000000>;
-		device_type = "memory";
 	};
 
 	reg_1p8v: regulator-1p8v {
Index: arch/arm64/boot/dts/mediatek/mt8183-kukui-jacuzzi.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8183-kukui-jacuzzi.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8183-kukui-jacuzzi.dtsi	(revision 55464)
@@ -4,8 +4,6 @@
  */
 
 #include "mt8183-kukui.dtsi"
-/* Must come after mt8183-kukui.dtsi to modify cros_ec */
-#include <arm/cros-ec-keyboard.dtsi>
 
 / {
 	panel: panel {
Index: arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8183-kukui.dtsi	(revision 55464)
@@ -896,6 +896,10 @@
 			google,usb-port-id = <0>;
 		};
 
+		cbas {
+			compatible = "google,cros-cbas";
+		};
+
 		typec {
 			compatible = "google,cros-ec-typec";
 			#address-cells = <1>;
@@ -995,4 +999,5 @@
 	};
 };
 
+#include <arm/cros-ec-keyboard.dtsi>
 #include <arm/cros-ec-sbs.dtsi>
Index: arch/arm64/boot/dts/mediatek/mt8195-demo.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8195-demo.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8195-demo.dts	(revision 55464)
@@ -111,7 +111,6 @@
 		compatible = "mediatek,mt6360";
 		reg = <0x34>;
 		interrupt-controller;
-		#interrupt-cells = <1>;
 		interrupts-extended = <&pio 101 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-names = "IRQB";
 
Index: arch/arm64/boot/dts/mediatek/mt8192.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8192.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8192.dtsi	(revision 55464)
@@ -1539,7 +1539,7 @@
 			mediatek,scp = <&scp>;
 			power-domains = <&spm MT8192_POWER_DOMAIN_VENC>;
 			clocks = <&vencsys CLK_VENC_SET1_VENC>;
-			clock-names = "venc_sel";
+			clock-names = "venc-set1";
 			assigned-clocks = <&topckgen CLK_TOP_VENC_SEL>;
 			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
 		};
Index: arch/arm64/boot/dts/mediatek/mt7986a.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt7986a.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt7986a.dtsi	(revision 55464)
@@ -110,7 +110,6 @@
 			compatible = "mediatek,mt7986-infracfg", "syscon";
 			reg = <0 0x10001000 0 0x1000>;
 			#clock-cells = <1>;
-			#reset-cells = <1>;
 		};
 
 		wed_pcie: wed-pcie@10003000 {
Index: arch/arm64/boot/dts/mediatek/mt8183-kukui-kakadu.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8183-kukui-kakadu.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8183-kukui-kakadu.dtsi	(revision 55464)
@@ -372,16 +372,6 @@
 	};
 };
 
-&cros_ec {
-	cbas {
-		compatible = "google,cros-cbas";
-	};
-
-	keyboard-controller {
-		compatible = "google,cros-ec-keyb-switches";
-	};
-};
-
 &qca_wifi {
 	qcom,ath10k-calibration-variant = "GO_KAKADU";
 };
Index: arch/arm64/boot/dts/mediatek/mt8183-kukui-kodama.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8183-kukui-kodama.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8183-kukui-kodama.dtsi	(revision 55464)
@@ -339,16 +339,6 @@
 	};
 };
 
-&cros_ec {
-	cbas {
-		compatible = "google,cros-cbas";
-	};
-
-	keyboard-controller {
-		compatible = "google,cros-ec-keyb-switches";
-	};
-};
-
 &qca_wifi {
 	qcom,ath10k-calibration-variant = "GO_KODAMA";
 };
Index: arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8183-kukui-krane.dtsi	(revision 55464)
@@ -343,16 +343,6 @@
 	};
 };
 
-&cros_ec {
-	cbas {
-		compatible = "google,cros-cbas";
-	};
-
-	keyboard-controller {
-		compatible = "google,cros-ec-keyb-switches";
-	};
-};
-
 &qca_wifi {
 	qcom,ath10k-calibration-variant = "LE_Krane";
 };
Index: arch/arm64/boot/dts/mediatek/mt8192-asurada.dtsi
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8192-asurada.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8192-asurada.dtsi	(revision 55464)
@@ -819,6 +819,10 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		base_detection: cbas {
+			compatible = "google,cros-cbas";
+		};
+
 		cros_ec_pwm: pwm {
 			compatible = "google,cros-ec-pwm";
 			#pwm-cells = <1>;
Index: arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r1.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r1.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r1.dts	(revision 55464)
@@ -13,7 +13,3 @@
 &ts_10 {
 	status = "okay";
 };
-
-&watchdog {
-	/delete-property/ mediatek,disable-extrst;
-};
Index: arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r2.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r2.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r2.dts	(revision 55464)
@@ -33,7 +33,3 @@
 &ts_10 {
 	status = "okay";
 };
-
-&watchdog {
-	/delete-property/ mediatek,disable-extrst;
-};
Index: arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r3.dts
===================================================================
--- arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r3.dts	(revision 55465)
+++ arch/arm64/boot/dts/mediatek/mt8195-cherry-tomato-r3.dts	(revision 55464)
@@ -34,7 +34,3 @@
 &ts_10 {
 	status = "okay";
 };
-
-&watchdog {
-	/delete-property/ mediatek,disable-extrst;
-};
Index: arch/arm64/boot/dts/renesas/ulcb-kf.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/ulcb-kf.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/ulcb-kf.dtsi	(revision 55464)
@@ -251,7 +251,6 @@
 		gpio-controller;
 		#gpio-cells = <2>;
 		interrupt-controller;
-		#interrupt-cells = <2>;
 		interrupt-parent = <&gpio6>;
 		interrupts = <8 IRQ_TYPE_EDGE_FALLING>;
 
@@ -312,7 +311,6 @@
 		gpio-controller;
 		#gpio-cells = <2>;
 		interrupt-controller;
-		#interrupt-cells = <2>;
 		interrupt-parent = <&gpio6>;
 		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
 	};
@@ -333,7 +331,6 @@
 		gpio-controller;
 		#gpio-cells = <2>;
 		interrupt-controller;
-		#interrupt-cells = <2>;
 		interrupt-parent = <&gpio7>;
 		interrupts = <3 IRQ_TYPE_EDGE_FALLING>;
 	};
@@ -344,7 +341,6 @@
 		gpio-controller;
 		#gpio-cells = <2>;
 		interrupt-controller;
-		#interrupt-cells = <2>;
 		interrupt-parent = <&gpio5>;
 		interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
 	};
Index: arch/arm64/boot/dts/renesas/r8a779a0.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r8a779a0.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r8a779a0.dtsi	(revision 55464)
@@ -656,8 +656,8 @@
 
 		avb0: ethernet@e6800000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
-			reg = <0 0xe6800000 0 0x1000>;
+				     "renesas,etheravb-rcar-gen3";
+			reg = <0 0xe6800000 0 0x800>;
 			interrupts = <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>,
@@ -704,8 +704,8 @@
 
 		avb1: ethernet@e6810000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
-			reg = <0 0xe6810000 0 0x1000>;
+				     "renesas,etheravb-rcar-gen3";
+			reg = <0 0xe6810000 0 0x800>;
 			interrupts = <GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
@@ -752,7 +752,7 @@
 
 		avb2: ethernet@e6820000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
+				     "renesas,etheravb-rcar-gen3";
 			reg = <0 0xe6820000 0 0x1000>;
 			interrupts = <GIC_SPI 306 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 307 IRQ_TYPE_LEVEL_HIGH>,
@@ -800,7 +800,7 @@
 
 		avb3: ethernet@e6830000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
+				     "renesas,etheravb-rcar-gen3";
 			reg = <0 0xe6830000 0 0x1000>;
 			interrupts = <GIC_SPI 331 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 332 IRQ_TYPE_LEVEL_HIGH>,
@@ -848,7 +848,7 @@
 
 		avb4: ethernet@e6840000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
+				     "renesas,etheravb-rcar-gen3";
 			reg = <0 0xe6840000 0 0x1000>;
 			interrupts = <GIC_SPI 356 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 357 IRQ_TYPE_LEVEL_HIGH>,
@@ -896,7 +896,7 @@
 
 		avb5: ethernet@e6850000 {
 			compatible = "renesas,etheravb-r8a779a0",
-				     "renesas,etheravb-rcar-gen4";
+				     "renesas,etheravb-rcar-gen3";
 			reg = <0 0xe6850000 0 0x1000>;
 			interrupts = <GIC_SPI 381 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 382 IRQ_TYPE_LEVEL_HIGH>,
@@ -1019,7 +1019,7 @@
 
 		msiof0: spi@e6e90000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6e90000 0 0x0064>;
 			interrupts = <GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 618>;
@@ -1034,7 +1034,7 @@
 
 		msiof1: spi@e6ea0000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6ea0000 0 0x0064>;
 			interrupts = <GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 619>;
@@ -1049,7 +1049,7 @@
 
 		msiof2: spi@e6c00000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6c00000 0 0x0064>;
 			interrupts = <GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 620>;
@@ -1064,7 +1064,7 @@
 
 		msiof3: spi@e6c10000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6c10000 0 0x0064>;
 			interrupts = <GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 621>;
@@ -1079,7 +1079,7 @@
 
 		msiof4: spi@e6c20000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6c20000 0 0x0064>;
 			interrupts = <GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 622>;
@@ -1094,7 +1094,7 @@
 
 		msiof5: spi@e6c28000 {
 			compatible = "renesas,msiof-r8a779a0",
-				     "renesas,rcar-gen4-msiof";
+				     "renesas,rcar-gen3-msiof";
 			reg = <0 0xe6c28000 0 0x0064>;
 			interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD 623>;
Index: arch/arm64/boot/dts/renesas/r8a779g0.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r8a779g0.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r8a779g0.dtsi	(revision 55464)
@@ -337,7 +337,7 @@
 		avb0: ethernet@e6800000 {
 			compatible = "renesas,etheravb-r8a779g0",
 				     "renesas,etheravb-rcar-gen4";
-			reg = <0 0xe6800000 0 0x1000>;
+			reg = <0 0xe6800000 0 0x800>;
 			interrupts = <GIC_SPI 335 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 336 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 337 IRQ_TYPE_LEVEL_HIGH>,
@@ -384,7 +384,7 @@
 		avb1: ethernet@e6810000 {
 			compatible = "renesas,etheravb-r8a779g0",
 				     "renesas,etheravb-rcar-gen4";
-			reg = <0 0xe6810000 0 0x1000>;
+			reg = <0 0xe6810000 0 0x800>;
 			interrupts = <GIC_SPI 360 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 361 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 362 IRQ_TYPE_LEVEL_HIGH>,
Index: arch/arm64/boot/dts/renesas/r9a07g043.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r9a07g043.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r9a07g043.dtsi	(revision 55464)
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 /*
- * Device Tree Source for the RZ/Five and RZ/G2UL SoCs
+ * Device Tree Source for the RZ/G2UL SoC
  *
  * Copyright (C) 2022 Renesas Electronics Corp.
  */
@@ -68,8 +68,36 @@
 		};
 	};
 
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a55";
+			reg = <0>;
+			device_type = "cpu";
+			#cooling-cells = <2>;
+			next-level-cache = <&L3_CA55>;
+			enable-method = "psci";
+			clocks = <&cpg CPG_CORE R9A07G043_CLK_I>;
+			operating-points-v2 = <&cluster0_opp>;
+		};
+
+		L3_CA55: cache-controller-0 {
+			compatible = "cache";
+			cache-unified;
+			cache-size = <0x40000>;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0", "arm,psci-0.2";
+		method = "smc";
+	};
+
 	soc: soc {
 		compatible = "simple-bus";
+		interrupt-parent = <&gic>;
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
@@ -517,6 +545,12 @@
 		sysc: system-controller@11020000 {
 			compatible = "renesas,r9a07g043-sysc";
 			reg = <0 0x11020000 0 0x10000>;
+			interrupts = <SOC_PERIPHERAL_IRQ(42) IRQ_TYPE_LEVEL_HIGH>,
+				     <SOC_PERIPHERAL_IRQ(43) IRQ_TYPE_LEVEL_HIGH>,
+				     <SOC_PERIPHERAL_IRQ(44) IRQ_TYPE_LEVEL_HIGH>,
+				     <SOC_PERIPHERAL_IRQ(45) IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "lpm_int", "ca55stbydone_int",
+					  "cm33stbyr_int", "ca55_deny";
 			status = "disabled";
 		};
 
@@ -569,6 +603,16 @@
 			dma-channels = <16>;
 		};
 
+		gic: interrupt-controller@11900000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <3>;
+			#address-cells = <0>;
+			interrupt-controller;
+			reg = <0x0 0x11900000 0 0x40000>,
+			      <0x0 0x11940000 0 0x60000>;
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_LOW>;
+		};
+
 		sdhi0: mmc@11c00000 {
 			compatible = "renesas,sdhi-r9a07g043",
 				     "renesas,rcar-gen3-sdhi";
@@ -849,4 +893,12 @@
 			};
 		};
 	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts-extended = <&gic GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+				      <&gic GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+	};
 };
Index: arch/arm64/boot/dts/renesas/r9a07g043u.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r9a07g043u.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r9a07g043u.dtsi	(revision 55464)
@@ -10,139 +10,3 @@
 #define SOC_PERIPHERAL_IRQ(nr)		GIC_SPI nr
 
 #include "r9a07g043.dtsi"
-
-/ {
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu0: cpu@0 {
-			compatible = "arm,cortex-a55";
-			reg = <0>;
-			device_type = "cpu";
-			#cooling-cells = <2>;
-			next-level-cache = <&L3_CA55>;
-			enable-method = "psci";
-			clocks = <&cpg CPG_CORE R9A07G043_CLK_I>;
-			operating-points-v2 = <&cluster0_opp>;
-		};
-
-		L3_CA55: cache-controller-0 {
-			compatible = "cache";
-			cache-unified;
-			cache-size = <0x40000>;
-		};
-	};
-
-	psci {
-		compatible = "arm,psci-1.0", "arm,psci-0.2";
-		method = "smc";
-	};
-
-	timer {
-		compatible = "arm,armv8-timer";
-		interrupts-extended = <&gic GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-				      <&gic GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-				      <&gic GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-				      <&gic GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
-	};
-};
-
-&soc {
-	interrupt-parent = <&gic>;
-
-	irqc: interrupt-controller@110a0000 {
-		compatible = "renesas,r9a07g043u-irqc",
-			     "renesas,rzg2l-irqc";
-		reg = <0 0x110a0000 0 0x10000>;
-		#interrupt-cells = <2>;
-		#address-cells = <0>;
-		interrupt-controller;
-		interrupts = <SOC_PERIPHERAL_IRQ(0) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(1) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(2) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(3) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(4) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(5) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(6) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(7) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(8) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(444) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(445) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(446) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(447) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(448) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(449) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(450) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(451) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(452) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(453) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(454) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(455) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(456) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(457) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(458) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(459) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(460) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(461) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(462) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(463) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(464) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(465) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(466) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(467) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(468) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(469) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(470) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(471) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(472) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(473) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(474) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(475) IRQ_TYPE_LEVEL_HIGH>,
-			     <SOC_PERIPHERAL_IRQ(25) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(34) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(35) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(36) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(37) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(38) IRQ_TYPE_EDGE_RISING>,
-			     <SOC_PERIPHERAL_IRQ(39) IRQ_TYPE_EDGE_RISING>;
-		interrupt-names = "nmi",
-				  "irq0", "irq1", "irq2", "irq3",
-				  "irq4", "irq5", "irq6", "irq7",
-				  "tint0", "tint1", "tint2", "tint3",
-				  "tint4", "tint5", "tint6", "tint7",
-				  "tint8", "tint9", "tint10", "tint11",
-				  "tint12", "tint13", "tint14", "tint15",
-				  "tint16", "tint17", "tint18", "tint19",
-				  "tint20", "tint21", "tint22", "tint23",
-				  "tint24", "tint25", "tint26", "tint27",
-				  "tint28", "tint29", "tint30", "tint31",
-				  "bus-err", "ec7tie1-0", "ec7tie2-0",
-				  "ec7tiovf-0", "ec7tie1-1", "ec7tie2-1",
-				  "ec7tiovf-1";
-		clocks = <&cpg CPG_MOD R9A07G043_IA55_CLK>,
-			<&cpg CPG_MOD R9A07G043_IA55_PCLK>;
-		clock-names = "clk", "pclk";
-		power-domains = <&cpg>;
-		resets = <&cpg R9A07G043_IA55_RESETN>;
-	};
-
-	gic: interrupt-controller@11900000 {
-		compatible = "arm,gic-v3";
-		#interrupt-cells = <3>;
-		#address-cells = <0>;
-		interrupt-controller;
-		reg = <0x0 0x11900000 0 0x40000>,
-		      <0x0 0x11940000 0 0x60000>;
-		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_LOW>;
-	};
-};
-
-&sysc {
-	interrupts = <SOC_PERIPHERAL_IRQ(42) IRQ_TYPE_LEVEL_HIGH>,
-		     <SOC_PERIPHERAL_IRQ(43) IRQ_TYPE_LEVEL_HIGH>,
-		     <SOC_PERIPHERAL_IRQ(44) IRQ_TYPE_LEVEL_HIGH>,
-		     <SOC_PERIPHERAL_IRQ(45) IRQ_TYPE_LEVEL_HIGH>;
-	interrupt-names = "lpm_int", "ca55stbydone_int",
-			  "cm33stbyr_int", "ca55_deny";
-};
Index: arch/arm64/boot/dts/renesas/r9a07g044.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r9a07g044.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r9a07g044.dtsi	(revision 55464)
@@ -698,27 +698,7 @@
 				     <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 473 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 474 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 475 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 25 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 34 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 35 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 36 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 37 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 38 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 39 IRQ_TYPE_EDGE_RISING>;
-			interrupt-names = "nmi", "irq0", "irq1", "irq2", "irq3",
-					  "irq4", "irq5", "irq6", "irq7",
-					  "tint0", "tint1", "tint2", "tint3",
-					  "tint4", "tint5", "tint6", "tint7",
-					  "tint8", "tint9", "tint10", "tint11",
-					  "tint12", "tint13", "tint14", "tint15",
-					  "tint16", "tint17", "tint18", "tint19",
-					  "tint20", "tint21", "tint22", "tint23",
-					  "tint24", "tint25", "tint26", "tint27",
-					  "tint28", "tint29", "tint30", "tint31",
-					  "bus-err", "ec7tie1-0", "ec7tie2-0",
-					  "ec7tiovf-0", "ec7tie1-1", "ec7tie2-1",
-					  "ec7tiovf-1";
+				     <GIC_SPI 475 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD R9A07G044_IA55_CLK>,
 				 <&cpg CPG_MOD R9A07G044_IA55_PCLK>;
 			clock-names = "clk", "pclk";
Index: arch/arm64/boot/dts/renesas/r9a07g054.dtsi
===================================================================
--- arch/arm64/boot/dts/renesas/r9a07g054.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/renesas/r9a07g054.dtsi	(revision 55464)
@@ -704,27 +704,7 @@
 				     <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 473 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 474 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 475 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 25 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 34 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 35 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 36 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 37 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 38 IRQ_TYPE_EDGE_RISING>,
-				     <GIC_SPI 39 IRQ_TYPE_EDGE_RISING>;
-			interrupt-names = "nmi", "irq0", "irq1", "irq2", "irq3",
-					  "irq4", "irq5", "irq6", "irq7",
-					  "tint0", "tint1", "tint2", "tint3",
-					  "tint4", "tint5", "tint6", "tint7",
-					  "tint8", "tint9", "tint10", "tint11",
-					  "tint12", "tint13", "tint14", "tint15",
-					  "tint16", "tint17", "tint18", "tint19",
-					  "tint20", "tint21", "tint22", "tint23",
-					  "tint24", "tint25", "tint26", "tint27",
-					  "tint28", "tint29", "tint30", "tint31",
-					  "bus-err", "ec7tie1-0", "ec7tie2-0",
-					  "ec7tiovf-0", "ec7tie1-1", "ec7tie2-1",
-					  "ec7tiovf-1";
+				     <GIC_SPI 475 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&cpg CPG_MOD R9A07G054_IA55_CLK>,
 				 <&cpg CPG_MOD R9A07G054_IA55_PCLK>;
 			clock-names = "clk", "pclk";
Index: arch/arm64/boot/dts/nvidia/tegra234-p3737-0000+p3701-0000.dts
===================================================================
--- arch/arm64/boot/dts/nvidia/tegra234-p3737-0000+p3701-0000.dts	(revision 55465)
+++ arch/arm64/boot/dts/nvidia/tegra234-p3737-0000+p3701-0000.dts	(revision 55464)
@@ -2024,7 +2024,7 @@
 			status = "okay";
 
 			phy-handle = <&mgbe0_phy>;
-			phy-mode = "10gbase-r";
+			phy-mode = "usxgmii";
 
 			mdio {
 				#address-cells = <1>;
Index: arch/arm64/boot/dts/allwinner/sun50i-h6-beelink-gs1.dts
===================================================================
--- arch/arm64/boot/dts/allwinner/sun50i-h6-beelink-gs1.dts	(revision 55465)
+++ arch/arm64/boot/dts/allwinner/sun50i-h6-beelink-gs1.dts	(revision 55464)
@@ -291,8 +291,6 @@
 };
 
 &spdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spdif_tx_pin>;
 	status = "okay";
 };
 
Index: arch/arm64/boot/dts/allwinner/sun50i-h6-tanix.dtsi
===================================================================
--- arch/arm64/boot/dts/allwinner/sun50i-h6-tanix.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/allwinner/sun50i-h6-tanix.dtsi	(revision 55464)
@@ -166,8 +166,6 @@
 };
 
 &spdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spdif_tx_pin>;
 	status = "okay";
 };
 
Index: arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
===================================================================
--- arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi	(revision 55464)
@@ -406,7 +406,6 @@
 				function = "spi1";
 			};
 
-			/omit-if-no-ref/
 			spdif_tx_pin: spdif-tx-pin {
 				pins = "PH7";
 				function = "spdif";
@@ -656,8 +655,10 @@
 			clocks = <&ccu CLK_BUS_SPDIF>, <&ccu CLK_SPDIF>;
 			clock-names = "apb", "spdif";
 			resets = <&ccu RST_BUS_SPDIF>;
-			dmas = <&dma 2>, <&dma 2>;
-			dma-names = "rx", "tx";
+			dmas = <&dma 2>;
+			dma-names = "tx";
+			pinctrl-names = "default";
+			pinctrl-0 = <&spdif_tx_pin>;
 			status = "disabled";
 		};
 
Index: arch/arm64/boot/dts/amazon/alpine-v2.dtsi
===================================================================
--- arch/arm64/boot/dts/amazon/alpine-v2.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/amazon/alpine-v2.dtsi	(revision 55464)
@@ -145,6 +145,7 @@
 		msix: msix@fbe00000 {
 			compatible = "al,alpine-msix";
 			reg = <0x0 0xfbe00000 0x0 0x100000>;
+			interrupt-controller;
 			msi-controller;
 			al,msi-base-spi = <160>;
 			al,msi-num-spis = <160>;
Index: arch/arm64/boot/dts/amazon/alpine-v3.dtsi
===================================================================
--- arch/arm64/boot/dts/amazon/alpine-v3.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/amazon/alpine-v3.dtsi	(revision 55464)
@@ -351,6 +351,7 @@
 		msix: msix@fbe00000 {
 			compatible = "al,alpine-msix";
 			reg = <0x0 0xfbe00000 0x0 0x100000>;
+			interrupt-controller;
 			msi-controller;
 			al,msi-base-spi = <336>;
 			al,msi-num-spis = <959>;
Index: arch/arm64/boot/dts/broadcom/bcmbca/bcm4908.dtsi
===================================================================
--- arch/arm64/boot/dts/broadcom/bcmbca/bcm4908.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/broadcom/bcmbca/bcm4908.dtsi	(revision 55464)
@@ -180,6 +180,9 @@
 				brcm,num-gphy = <5>;
 				brcm,num-rgmii-ports = <2>;
 
+				#address-cells = <1>;
+				#size-cells = <0>;
+
 				ports: ports {
 					#address-cells = <1>;
 					#size-cells = <0>;
Index: arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi
===================================================================
--- arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi	(revision 55464)
@@ -584,7 +584,6 @@
 			#gpio-cells = <2>;
 			gpio-controller;
 			interrupt-controller;
-			#interrupt-cells = <2>;
 			interrupts = <GIC_SPI 400 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
Index: arch/arm64/boot/dts/broadcom/stingray/stingray.dtsi
===================================================================
--- arch/arm64/boot/dts/broadcom/stingray/stingray.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/broadcom/stingray/stingray.dtsi	(revision 55464)
@@ -442,7 +442,6 @@
 			#gpio-cells = <2>;
 			gpio-controller;
 			interrupt-controller;
-			#interrupt-cells = <2>;
 			interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
 			gpio-ranges = <&pinmux 0 0 16>,
 					<&pinmux 16 71 2>,
Index: arch/arm64/boot/dts/lg/lg1312.dtsi
===================================================================
--- arch/arm64/boot/dts/lg/lg1312.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/lg/lg1312.dtsi	(revision 55464)
@@ -124,6 +124,7 @@
 	amba {
 		#address-cells = <2>;
 		#size-cells = <1>;
+		#interrupt-cells = <3>;
 
 		compatible = "simple-bus";
 		interrupt-parent = <&gic>;
Index: arch/arm64/boot/dts/lg/lg1313.dtsi
===================================================================
--- arch/arm64/boot/dts/lg/lg1313.dtsi	(revision 55465)
+++ arch/arm64/boot/dts/lg/lg1313.dtsi	(revision 55464)
@@ -124,6 +124,7 @@
 	amba {
 		#address-cells = <2>;
 		#size-cells = <1>;
+		#interrupt-cells = <3>;
 
 		compatible = "simple-bus";
 		interrupt-parent = <&gic>;
Index: arch/arm64/kernel/ptrace.c
===================================================================
--- arch/arm64/kernel/ptrace.c	(revision 55465)
+++ arch/arm64/kernel/ptrace.c	(revision 55464)
@@ -1450,8 +1450,7 @@
 #ifdef CONFIG_ARM64_SVE
 	[REGSET_SVE] = { /* Scalable Vector Extension */
 		.core_note_type = NT_ARM_SVE,
-		.n = DIV_ROUND_UP(SVE_PT_SIZE(ARCH_SVE_VQ_MAX,
-					      SVE_PT_REGS_SVE),
+		.n = DIV_ROUND_UP(SVE_PT_SIZE(SVE_VQ_MAX, SVE_PT_REGS_SVE),
 				  SVE_VQ_BYTES),
 		.size = SVE_VQ_BYTES,
 		.align = SVE_VQ_BYTES,
Index: arch/powerpc/platforms/pseries/papr_platform_attributes.c
===================================================================
--- arch/powerpc/platforms/pseries/papr_platform_attributes.c	(revision 55465)
+++ arch/powerpc/platforms/pseries/papr_platform_attributes.c	(revision 55464)
@@ -101,12 +101,10 @@
 		esi_buf_size = ESI_HDR_SIZE + (CURR_MAX_ESI_ATTRS * max_esi_attrs);
 
 		temp_buf = krealloc(buf, esi_buf_size, GFP_KERNEL);
-		if (temp_buf) {
+		if (temp_buf)
 			buf = temp_buf;
-		} else {
-			ret = -ENOMEM;
-			goto out_buf;
-		}
+		else
+			return -ENOMEM;
 
 		goto retry;
 	}
Index: arch/powerpc/platforms/embedded6xx/linkstation.c
===================================================================
--- arch/powerpc/platforms/embedded6xx/linkstation.c	(revision 55465)
+++ arch/powerpc/platforms/embedded6xx/linkstation.c	(revision 55464)
@@ -99,6 +99,9 @@
 	mpic_init(mpic);
 }
 
+extern void avr_uart_configure(void);
+extern void avr_uart_send(const char);
+
 static void __noreturn linkstation_restart(char *cmd)
 {
 	local_irq_disable();
Index: arch/powerpc/platforms/embedded6xx/mpc10x.h
===================================================================
--- arch/powerpc/platforms/embedded6xx/mpc10x.h	(revision 55465)
+++ arch/powerpc/platforms/embedded6xx/mpc10x.h	(revision 55464)
@@ -156,7 +156,4 @@
 /* For MPC107 boards that use the built-in openpic */
 void mpc10x_set_openpic(void);
 
-void avr_uart_configure(void);
-void avr_uart_send(const char c);
-
 #endif	/* __PPC_KERNEL_MPC10X_H */
Index: arch/powerpc/include/asm/vmalloc.h
===================================================================
--- arch/powerpc/include/asm/vmalloc.h	(revision 55465)
+++ arch/powerpc/include/asm/vmalloc.h	(revision 55464)
@@ -7,7 +7,7 @@
 #ifdef CONFIG_HAVE_ARCH_HUGE_VMAP
 
 #define arch_vmap_pud_supported arch_vmap_pud_supported
-static __always_inline bool arch_vmap_pud_supported(pgprot_t prot)
+static inline bool arch_vmap_pud_supported(pgprot_t prot)
 {
 	/* HPT does not cope with large pages in the vmalloc area */
 	return radix_enabled();
@@ -14,7 +14,7 @@
 }
 
 #define arch_vmap_pmd_supported arch_vmap_pmd_supported
-static __always_inline bool arch_vmap_pmd_supported(pgprot_t prot)
+static inline bool arch_vmap_pmd_supported(pgprot_t prot)
 {
 	return radix_enabled();
 }
Index: arch/powerpc/perf/hv-gpci.c
===================================================================
--- arch/powerpc/perf/hv-gpci.c	(revision 55465)
+++ arch/powerpc/perf/hv-gpci.c	(revision 55464)
@@ -164,20 +164,6 @@
 
 	ret = plpar_hcall_norets(H_GET_PERF_COUNTER_INFO,
 			virt_to_phys(arg), HGPCI_REQ_BUFFER_SIZE);
-
-	/*
-	 * ret value as 'H_PARAMETER' with detail_rc as 'GEN_BUF_TOO_SMALL',
-	 * specifies that the current buffer size cannot accommodate
-	 * all the information and a partial buffer returned.
-	 * Since in this function we are only accessing data for a given starting index,
-	 * we don't need to accommodate whole data and can get required count by
-	 * accessing first entry data.
-	 * Hence hcall fails only incase the ret value is other than H_SUCCESS or
-	 * H_PARAMETER with detail_rc value as GEN_BUF_TOO_SMALL(0x1B).
-	 */
-	if (ret == H_PARAMETER && be32_to_cpu(arg->params.detail_rc) == 0x1B)
-		ret = 0;
-
 	if (ret) {
 		pr_devel("hcall failed: 0x%lx\n", ret);
 		goto out;
@@ -242,7 +228,6 @@
 {
 	u64 count;
 	u8 length;
-	unsigned long ret;
 
 	/* Not our event */
 	if (event->attr.type != event->pmu->type)
@@ -273,23 +258,13 @@
 	}
 
 	/* check if the request works... */
-	ret = single_gpci_request(event_get_request(event),
+	if (single_gpci_request(event_get_request(event),
 				event_get_starting_index(event),
 				event_get_secondary_index(event),
 				event_get_counter_info_version(event),
 				event_get_offset(event),
 				length,
-				&count);
-
-	/*
-	 * ret value as H_AUTHORITY implies that partition is not permitted to retrieve
-	 * performance information, and required to set
-	 * "Enable Performance Information Collection" option.
-	 */
-	if (ret == H_AUTHORITY)
-		return -EPERM;
-
-	if (ret) {
+				&count)) {
 		pr_devel("gpci hcall failed\n");
 		return -EINVAL;
 	}
Index: arch/riscv/boot/dts/sifive/hifive-unmatched-a00.dts
===================================================================
--- arch/riscv/boot/dts/sifive/hifive-unmatched-a00.dts	(revision 55465)
+++ arch/riscv/boot/dts/sifive/hifive-unmatched-a00.dts	(revision 55464)
@@ -123,7 +123,6 @@
 		interrupt-parent = <&gpio>;
 		interrupts = <1 IRQ_TYPE_LEVEL_LOW>;
 		interrupt-controller;
-		#interrupt-cells = <2>;
 
 		onkey {
 			compatible = "dlg,da9063-onkey";
Index: arch/s390/include/uapi/asm/dasd.h
===================================================================
--- arch/s390/include/uapi/asm/dasd.h	(revision 55465)
+++ arch/s390/include/uapi/asm/dasd.h	(revision 55464)
@@ -78,7 +78,6 @@
  * 0x040: give access to raw eckd data
  * 0x080: enable discard support
  * 0x100: enable autodisable for IFCC errors (default)
- * 0x200: enable requeue of all requests on autoquiesce
  */
 #define DASD_FEATURE_READONLY	      0x001
 #define DASD_FEATURE_USEDIAG	      0x002
@@ -89,7 +88,6 @@
 #define DASD_FEATURE_USERAW	      0x040
 #define DASD_FEATURE_DISCARD	      0x080
 #define DASD_FEATURE_PATH_AUTODISABLE 0x100
-#define DASD_FEATURE_REQUEUEQUIESCE   0x200
 #define DASD_FEATURE_DEFAULT	      DASD_FEATURE_PATH_AUTODISABLE
 
 #define DASD_PARTN_BITS 2
Index: arch/s390/kernel/cache.c
===================================================================
--- arch/s390/kernel/cache.c	(revision 55465)
+++ arch/s390/kernel/cache.c	(revision 55464)
@@ -166,6 +166,5 @@
 			ci_leaf_init(this_leaf++, pvt, ctype, level, cpu);
 		}
 	}
-	this_cpu_ci->cpu_map_populated = true;
 	return 0;
 }
Index: arch/s390/kernel/perf_pai_crypto.c
===================================================================
--- arch/s390/kernel/perf_pai_crypto.c	(revision 55465)
+++ arch/s390/kernel/perf_pai_crypto.c	(revision 55464)
@@ -647,7 +647,7 @@
 	for (i = 0; i < ARRAY_SIZE(paicrypt_ctrnames); i++) {
 		ret = attr_event_init_one(attrs, i);
 		if (ret) {
-			attr_event_free(attrs, i);
+			attr_event_free(attrs, i - 1);
 			return ret;
 		}
 	}
Index: arch/s390/kernel/perf_pai_ext.c
===================================================================
--- arch/s390/kernel/perf_pai_ext.c	(revision 55465)
+++ arch/s390/kernel/perf_pai_ext.c	(revision 55464)
@@ -612,7 +612,7 @@
 	for (i = 0; i < ARRAY_SIZE(paiext_ctrnames); i++) {
 		ret = attr_event_init_one(attrs, i);
 		if (ret) {
-			attr_event_free(attrs, i);
+			attr_event_free(attrs, i - 1);
 			return ret;
 		}
 	}
Index: arch/s390/kernel/vdso32/Makefile
===================================================================
--- arch/s390/kernel/vdso32/Makefile	(revision 55465)
+++ arch/s390/kernel/vdso32/Makefile	(revision 55464)
@@ -22,7 +22,7 @@
 KBUILD_CFLAGS_32 := $(filter-out -m64,$(KBUILD_CFLAGS))
 KBUILD_CFLAGS_32 += -m31 -fPIC -shared -fno-common -fno-builtin
 
-LDFLAGS_vdso32.so.dbg += -shared -soname=linux-vdso32.so.1 \
+LDFLAGS_vdso32.so.dbg += -fPIC -shared -soname=linux-vdso32.so.1 \
 	--hash-style=both --build-id=sha1 -melf_s390 -T
 
 $(targets:%=$(obj)/%.dbg): KBUILD_CFLAGS = $(KBUILD_CFLAGS_32)
Index: arch/s390/kernel/vdso64/Makefile
===================================================================
--- arch/s390/kernel/vdso64/Makefile	(revision 55465)
+++ arch/s390/kernel/vdso64/Makefile	(revision 55464)
@@ -26,7 +26,7 @@
 
 KBUILD_CFLAGS_64 := $(filter-out -m64,$(KBUILD_CFLAGS))
 KBUILD_CFLAGS_64 += -m64 -fPIC -fno-common -fno-builtin
-ldflags-y := -shared -soname=linux-vdso64.so.1 \
+ldflags-y := -fPIC -shared -soname=linux-vdso64.so.1 \
 	     --hash-style=both --build-id=sha1 -T
 
 $(targets:%=$(obj)/%.dbg): KBUILD_CFLAGS = $(KBUILD_CFLAGS_64)
Index: arch/s390/kernel/vtime.c
===================================================================
--- arch/s390/kernel/vtime.c	(revision 55465)
+++ arch/s390/kernel/vtime.c	(revision 55464)
@@ -210,13 +210,13 @@
 		virt_timer_expire();
 
 	steal = S390_lowcore.steal_timer;
-	avg_steal = S390_lowcore.avg_steal_timer;
+	avg_steal = S390_lowcore.avg_steal_timer / 2;
 	if ((s64) steal > 0) {
 		S390_lowcore.steal_timer = 0;
 		account_steal_time(cputime_to_nsecs(steal));
 		avg_steal += steal;
 	}
-	S390_lowcore.avg_steal_timer = avg_steal / 2;
+	S390_lowcore.avg_steal_timer = avg_steal;
 }
 
 static u64 vtime_delta(void)
Index: arch/mips/include/asm/ptrace.h
===================================================================
--- arch/mips/include/asm/ptrace.h	(revision 55465)
+++ arch/mips/include/asm/ptrace.h	(revision 55464)
@@ -60,7 +60,6 @@
                                            unsigned long val)
 {
 	regs->cp0_epc = val;
-	regs->cp0_cause &= ~CAUSEF_BD;
 }
 
 /* Query offset/name of register from its name/offset */
Index: arch/parisc/kernel/ftrace.c
===================================================================
--- arch/parisc/kernel/ftrace.c	(revision 55465)
+++ arch/parisc/kernel/ftrace.c	(revision 55464)
@@ -78,7 +78,7 @@
 #endif
 }
 
-#if defined(CONFIG_DYNAMIC_FTRACE) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+#ifdef CONFIG_FUNCTION_GRAPH_TRACER
 int ftrace_enable_ftrace_graph_caller(void)
 {
 	static_key_enable(&ftrace_graph_enable.key);
Index: arch/sparc/kernel/leon_pci_grpci1.c
===================================================================
--- arch/sparc/kernel/leon_pci_grpci1.c	(revision 55465)
+++ arch/sparc/kernel/leon_pci_grpci1.c	(revision 55464)
@@ -696,7 +696,7 @@
 	return err;
 }
 
-static const struct of_device_id grpci1_of_match[] = {
+static const struct of_device_id grpci1_of_match[] __initconst = {
 	{
 	 .name = "GAISLER_PCIFBRG",
 	 },
Index: arch/sparc/kernel/leon_pci_grpci2.c
===================================================================
--- arch/sparc/kernel/leon_pci_grpci2.c	(revision 55465)
+++ arch/sparc/kernel/leon_pci_grpci2.c	(revision 55464)
@@ -887,7 +887,7 @@
 	return err;
 }
 
-static const struct of_device_id grpci2_of_match[] = {
+static const struct of_device_id grpci2_of_match[] __initconst = {
 	{
 	 .name = "GAISLER_GRPCI2",
 	 },
Index: drivers/firmware/efi/libstub/x86-stub.c
===================================================================
--- drivers/firmware/efi/libstub/x86-stub.c	(revision 55465)
+++ drivers/firmware/efi/libstub/x86-stub.c	(revision 55464)
@@ -21,8 +21,6 @@
 /* Maximum physical address for 64-bit kernel with 4-level paging */
 #define MAXMEM_X86_64_4LEVEL (1ull << 46)
 
-extern char _bss[], _ebss[];
-
 const efi_system_table_t *efi_system_table;
 const efi_dxe_services_table_t *efi_dxe_table;
 extern u32 image_offset;
@@ -467,9 +465,6 @@
 	efi_status_t status;
 	char *cmdline_ptr;
 
-	if (efi_is_native())
-		memset(_bss, 0, _ebss - _bss);
-
 	efi_system_table = sys_table_arg;
 
 	/* Check if we were booted by the EFI firmware */
Index: drivers/firmware/arm_scmi/smc.c
===================================================================
--- drivers/firmware/arm_scmi/smc.c	(revision 55465)
+++ drivers/firmware/arm_scmi/smc.c	(revision 55464)
@@ -171,13 +171,6 @@
 	struct scmi_chan_info *cinfo = p;
 	struct scmi_smc *scmi_info = cinfo->transport_info;
 
-	/*
-	 * Different protocols might share the same chan info, so a previous
-	 * smc_chan_free call might have already freed the structure.
-	 */
-	if (!scmi_info)
-		return 0;
-
 	/* Ignore any possible further reception on the IRQ path */
 	if (scmi_info->irq > 0)
 		free_irq(scmi_info->irq, scmi_info);
Index: drivers/bluetooth/hci_qca.c
===================================================================
--- drivers/bluetooth/hci_qca.c	(revision 55465)
+++ drivers/bluetooth/hci_qca.c	(revision 55464)
@@ -2254,7 +2254,7 @@
 
 		qcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, "enable",
 					       GPIOD_OUT_LOW);
-		if (IS_ERR(qcadev->bt_en) &&
+		if (IS_ERR_OR_NULL(qcadev->bt_en) &&
 		    (data->soc_type == QCA_WCN6750 ||
 		     data->soc_type == QCA_WCN6855)) {
 			dev_err(&serdev->dev, "failed to acquire BT_EN gpio\n");
@@ -2263,7 +2263,7 @@
 
 		qcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev, "swctrl",
 					       GPIOD_IN);
-		if (IS_ERR(qcadev->sw_ctrl) &&
+		if (IS_ERR_OR_NULL(qcadev->sw_ctrl) &&
 		    (data->soc_type == QCA_WCN6750 ||
 		     data->soc_type == QCA_WCN6855 ||
 		     data->soc_type == QCA_WCN7850))
@@ -2285,7 +2285,7 @@
 	default:
 		qcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, "enable",
 					       GPIOD_OUT_LOW);
-		if (IS_ERR(qcadev->bt_en)) {
+		if (IS_ERR_OR_NULL(qcadev->bt_en)) {
 			dev_warn(&serdev->dev, "failed to acquire enable gpio\n");
 			power_ctrl_enabled = false;
 		}
Index: drivers/clk/hisilicon/clk-hi3519.c
===================================================================
--- drivers/clk/hisilicon/clk-hi3519.c	(revision 55465)
+++ drivers/clk/hisilicon/clk-hi3519.c	(revision 55464)
@@ -130,7 +130,7 @@
 	of_clk_del_provider(pdev->dev.of_node);
 
 	hisi_clk_unregister_gate(hi3519_gate_clks,
-				ARRAY_SIZE(hi3519_gate_clks),
+				ARRAY_SIZE(hi3519_mux_clks),
 				crg->clk_data);
 	hisi_clk_unregister_mux(hi3519_mux_clks,
 				ARRAY_SIZE(hi3519_mux_clks),
Index: drivers/clk/hisilicon/clk-hi3559a.c
===================================================================
--- drivers/clk/hisilicon/clk-hi3559a.c	(revision 55465)
+++ drivers/clk/hisilicon/clk-hi3559a.c	(revision 55464)
@@ -491,6 +491,7 @@
 
 		clk = clk_register(NULL, &p_clk->hw);
 		if (IS_ERR(clk)) {
+			devm_kfree(dev, p_clk);
 			dev_err(dev, "%s: failed to register clock %s\n",
 			       __func__, clks[i].name);
 			continue;
Index: drivers/clk/qcom/reset.c
===================================================================
--- drivers/clk/qcom/reset.c	(revision 55465)
+++ drivers/clk/qcom/reset.c	(revision 55464)
@@ -22,8 +22,8 @@
 	return 0;
 }
 
-static int qcom_reset_set_assert(struct reset_controller_dev *rcdev,
-				 unsigned long id, bool assert)
+static int
+qcom_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)
 {
 	struct qcom_reset_controller *rst;
 	const struct qcom_reset_map *map;
@@ -33,22 +33,21 @@
 	map = &rst->reset_map[id];
 	mask = map->bitmask ? map->bitmask : BIT(map->bit);
 
-	regmap_update_bits(rst->regmap, map->reg, mask, assert ? mask : 0);
-
-	/* Read back the register to ensure write completion, ignore the value */
-	regmap_read(rst->regmap, map->reg, &mask);
-
-	return 0;
+	return regmap_update_bits(rst->regmap, map->reg, mask, mask);
 }
 
-static int qcom_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)
+static int
+qcom_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)
 {
-	return qcom_reset_set_assert(rcdev, id, true);
-}
+	struct qcom_reset_controller *rst;
+	const struct qcom_reset_map *map;
+	u32 mask;
 
-static int qcom_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)
-{
-	return qcom_reset_set_assert(rcdev, id, false);
+	rst = to_qcom_reset_controller(rcdev);
+	map = &rst->reset_map[id];
+	mask = map->bitmask ? map->bitmask : BIT(map->bit);
+
+	return regmap_update_bits(rst->regmap, map->reg, mask, 0);
 }
 
 const struct reset_control_ops qcom_reset_ops = {
Index: drivers/clk/qcom/dispcc-sdm845.c
===================================================================
--- drivers/clk/qcom/dispcc-sdm845.c	(revision 55465)
+++ drivers/clk/qcom/dispcc-sdm845.c	(revision 55464)
@@ -759,8 +759,6 @@
 
 static struct gdsc mdss_gdsc = {
 	.gdscr = 0x3000,
-	.en_few_wait_val = 0x6,
-	.en_rest_wait_val = 0x5,
 	.pd = {
 		.name = "mdss_gdsc",
 	},
Index: drivers/clk/renesas/r8a779f0-cpg-mssr.c
===================================================================
--- drivers/clk/renesas/r8a779f0-cpg-mssr.c	(revision 55465)
+++ drivers/clk/renesas/r8a779f0-cpg-mssr.c	(revision 55464)
@@ -159,7 +159,7 @@
 	DEF_MOD("cmt1",		911,	R8A779F0_CLK_R),
 	DEF_MOD("cmt2",		912,	R8A779F0_CLK_R),
 	DEF_MOD("cmt3",		913,	R8A779F0_CLK_R),
-	DEF_MOD("pfc0",		915,	R8A779F0_CLK_CPEX),
+	DEF_MOD("pfc0",		915,	R8A779F0_CLK_CL16M),
 	DEF_MOD("tsc",		919,	R8A779F0_CLK_CL16M),
 	DEF_MOD("ufs",		1514,	R8A779F0_CLK_S0D4_HSC),
 };
Index: drivers/clk/renesas/r8a779g0-cpg-mssr.c
===================================================================
--- drivers/clk/renesas/r8a779g0-cpg-mssr.c	(revision 55465)
+++ drivers/clk/renesas/r8a779g0-cpg-mssr.c	(revision 55464)
@@ -22,7 +22,7 @@
 
 enum clk_ids {
 	/* Core Clock Outputs exported to DT */
-	LAST_DT_CORE_CLK = R8A779G0_CLK_CP,
+	LAST_DT_CORE_CLK = R8A779G0_CLK_R,
 
 	/* External Input Clocks */
 	CLK_EXTAL,
@@ -139,7 +139,6 @@
 	DEF_FIXED("svd2_vip",	R8A779G0_CLK_SVD2_VIP,	CLK_SV_VIP,	2, 1),
 	DEF_FIXED("cbfusa",	R8A779G0_CLK_CBFUSA,	CLK_EXTAL,	2, 1),
 	DEF_FIXED("cpex",	R8A779G0_CLK_CPEX,	CLK_EXTAL,	2, 1),
-	DEF_FIXED("cp",		R8A779G0_CLK_CP,	CLK_EXTAL,	2, 1),
 	DEF_FIXED("viobus",	R8A779G0_CLK_VIOBUS,	CLK_VIO,	1, 1),
 	DEF_FIXED("viobusd2",	R8A779G0_CLK_VIOBUSD2,	CLK_VIO,	2, 1),
 	DEF_FIXED("vcbus",	R8A779G0_CLK_VCBUS,	CLK_VC,		1, 1),
@@ -170,17 +169,10 @@
 	DEF_MOD("i2c4",		522,	R8A779G0_CLK_S0D6_PER),
 	DEF_MOD("i2c5",		523,	R8A779G0_CLK_S0D6_PER),
 	DEF_MOD("wdt1:wdt0",	907,	R8A779G0_CLK_R),
-	DEF_MOD("cmt0",		910,	R8A779G0_CLK_R),
-	DEF_MOD("cmt1",		911,	R8A779G0_CLK_R),
-	DEF_MOD("cmt2",		912,	R8A779G0_CLK_R),
-	DEF_MOD("cmt3",		913,	R8A779G0_CLK_R),
-	DEF_MOD("pfc0",		915,	R8A779G0_CLK_CP),
-	DEF_MOD("pfc1",		916,	R8A779G0_CLK_CP),
-	DEF_MOD("pfc2",		917,	R8A779G0_CLK_CP),
-	DEF_MOD("pfc3",		918,	R8A779G0_CLK_CP),
-	DEF_MOD("tsc",		919,	R8A779G0_CLK_CL16M),
-	DEF_MOD("ssiu",		2926,	R8A779G0_CLK_S0D6_PER),
-	DEF_MOD("ssi",		2927,	R8A779G0_CLK_S0D6_PER),
+	DEF_MOD("pfc0",		915,	R8A779G0_CLK_CL16M),
+	DEF_MOD("pfc1",		916,	R8A779G0_CLK_CL16M),
+	DEF_MOD("pfc2",		917,	R8A779G0_CLK_CL16M),
+	DEF_MOD("pfc3",		918,	R8A779G0_CLK_CL16M),
 };
 
 /*
Index: drivers/clk/clk.c
===================================================================
--- drivers/clk/clk.c	(revision 55465)
+++ drivers/clk/clk.c	(revision 55464)
@@ -407,9 +407,6 @@
 	if (IS_ERR(hw))
 		return ERR_CAST(hw);
 
-	if (!hw)
-		return NULL;
-
 	return hw->core;
 }
 
Index: drivers/clk/meson/axg.c
===================================================================
--- drivers/clk/meson/axg.c	(revision 55465)
+++ drivers/clk/meson/axg.c	(revision 55464)
@@ -2144,9 +2144,7 @@
 	&axg_vclk_input,
 	&axg_vclk2_input,
 	&axg_vclk_div,
-	&axg_vclk_div1,
 	&axg_vclk2_div,
-	&axg_vclk2_div1,
 	&axg_vclk_div2_en,
 	&axg_vclk_div4_en,
 	&axg_vclk_div6_en,
Index: drivers/clk/samsung/clk-exynos850.c
===================================================================
--- drivers/clk/samsung/clk-exynos850.c	(revision 55465)
+++ drivers/clk/samsung/clk-exynos850.c	(revision 55464)
@@ -572,7 +572,7 @@
 
 static const struct samsung_gate_clock apm_gate_clks[] __initconst = {
 	GATE(CLK_GOUT_CLKCMU_CMGP_BUS, "gout_clkcmu_cmgp_bus", "dout_apm_bus",
-	     CLK_CON_GAT_CLKCMU_CMGP_BUS, 21, CLK_SET_RATE_PARENT, 0),
+	     CLK_CON_GAT_CLKCMU_CMGP_BUS, 21, 0, 0),
 	GATE(CLK_GOUT_CLKCMU_CHUB_BUS, "gout_clkcmu_chub_bus",
 	     "mout_clkcmu_chub_bus",
 	     CLK_CON_GAT_GATE_CLKCMU_CHUB_BUS, 21, 0, 0),
@@ -936,19 +936,19 @@
 static const struct samsung_mux_clock cmgp_mux_clks[] __initconst = {
 	MUX(CLK_MOUT_CMGP_ADC, "mout_cmgp_adc", mout_cmgp_adc_p,
 	    CLK_CON_MUX_CLK_CMGP_ADC, 0, 1),
-	MUX_F(CLK_MOUT_CMGP_USI0, "mout_cmgp_usi0", mout_cmgp_usi0_p,
-	      CLK_CON_MUX_MUX_CLK_CMGP_USI_CMGP0, 0, 1, CLK_SET_RATE_PARENT, 0),
-	MUX_F(CLK_MOUT_CMGP_USI1, "mout_cmgp_usi1", mout_cmgp_usi1_p,
-	      CLK_CON_MUX_MUX_CLK_CMGP_USI_CMGP1, 0, 1, CLK_SET_RATE_PARENT, 0),
+	MUX(CLK_MOUT_CMGP_USI0, "mout_cmgp_usi0", mout_cmgp_usi0_p,
+	    CLK_CON_MUX_MUX_CLK_CMGP_USI_CMGP0, 0, 1),
+	MUX(CLK_MOUT_CMGP_USI1, "mout_cmgp_usi1", mout_cmgp_usi1_p,
+	    CLK_CON_MUX_MUX_CLK_CMGP_USI_CMGP1, 0, 1),
 };
 
 static const struct samsung_div_clock cmgp_div_clks[] __initconst = {
 	DIV(CLK_DOUT_CMGP_ADC, "dout_cmgp_adc", "gout_clkcmu_cmgp_bus",
 	    CLK_CON_DIV_DIV_CLK_CMGP_ADC, 0, 4),
-	DIV_F(CLK_DOUT_CMGP_USI0, "dout_cmgp_usi0", "mout_cmgp_usi0",
-	      CLK_CON_DIV_DIV_CLK_CMGP_USI_CMGP0, 0, 5, CLK_SET_RATE_PARENT, 0),
-	DIV_F(CLK_DOUT_CMGP_USI1, "dout_cmgp_usi1", "mout_cmgp_usi1",
-	      CLK_CON_DIV_DIV_CLK_CMGP_USI_CMGP1, 0, 5, CLK_SET_RATE_PARENT, 0),
+	DIV(CLK_DOUT_CMGP_USI0, "dout_cmgp_usi0", "mout_cmgp_usi0",
+	    CLK_CON_DIV_DIV_CLK_CMGP_USI_CMGP0, 0, 5),
+	DIV(CLK_DOUT_CMGP_USI1, "dout_cmgp_usi1", "mout_cmgp_usi1",
+	    CLK_CON_DIV_DIV_CLK_CMGP_USI_CMGP1, 0, 5),
 };
 
 static const struct samsung_gate_clock cmgp_gate_clks[] __initconst = {
@@ -963,12 +963,12 @@
 	     "gout_clkcmu_cmgp_bus",
 	     CLK_CON_GAT_GOUT_CMGP_GPIO_PCLK, 21, CLK_IGNORE_UNUSED, 0),
 	GATE(CLK_GOUT_CMGP_USI0_IPCLK, "gout_cmgp_usi0_ipclk", "dout_cmgp_usi0",
-	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP0_IPCLK, 21, CLK_SET_RATE_PARENT, 0),
+	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP0_IPCLK, 21, 0, 0),
 	GATE(CLK_GOUT_CMGP_USI0_PCLK, "gout_cmgp_usi0_pclk",
 	     "gout_clkcmu_cmgp_bus",
 	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP0_PCLK, 21, 0, 0),
 	GATE(CLK_GOUT_CMGP_USI1_IPCLK, "gout_cmgp_usi1_ipclk", "dout_cmgp_usi1",
-	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP1_IPCLK, 21, CLK_SET_RATE_PARENT, 0),
+	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP1_IPCLK, 21, 0, 0),
 	GATE(CLK_GOUT_CMGP_USI1_PCLK, "gout_cmgp_usi1_pclk",
 	     "gout_clkcmu_cmgp_bus",
 	     CLK_CON_GAT_GOUT_CMGP_USI_CMGP1_PCLK, 21, 0, 0),
@@ -1409,9 +1409,8 @@
 	    mout_peri_uart_user_p, PLL_CON0_MUX_CLKCMU_PERI_UART_USER, 4, 1),
 	MUX(CLK_MOUT_PERI_HSI2C_USER, "mout_peri_hsi2c_user",
 	    mout_peri_hsi2c_user_p, PLL_CON0_MUX_CLKCMU_PERI_HSI2C_USER, 4, 1),
-	MUX_F(CLK_MOUT_PERI_SPI_USER, "mout_peri_spi_user",
-	      mout_peri_spi_user_p, PLL_CON0_MUX_CLKCMU_PERI_SPI_USER, 4, 1,
-	      CLK_SET_RATE_PARENT, 0),
+	MUX(CLK_MOUT_PERI_SPI_USER, "mout_peri_spi_user", mout_peri_spi_user_p,
+	    PLL_CON0_MUX_CLKCMU_PERI_SPI_USER, 4, 1),
 };
 
 static const struct samsung_div_clock peri_div_clks[] __initconst = {
@@ -1421,8 +1420,8 @@
 	    CLK_CON_DIV_DIV_CLK_PERI_HSI2C_1, 0, 5),
 	DIV(CLK_DOUT_PERI_HSI2C2, "dout_peri_hsi2c2", "gout_peri_hsi2c2",
 	    CLK_CON_DIV_DIV_CLK_PERI_HSI2C_2, 0, 5),
-	DIV_F(CLK_DOUT_PERI_SPI0, "dout_peri_spi0", "mout_peri_spi_user",
-	      CLK_CON_DIV_DIV_CLK_PERI_SPI_0, 0, 5, CLK_SET_RATE_PARENT, 0),
+	DIV(CLK_DOUT_PERI_SPI0, "dout_peri_spi0", "mout_peri_spi_user",
+	    CLK_CON_DIV_DIV_CLK_PERI_SPI_0, 0, 5),
 };
 
 static const struct samsung_gate_clock peri_gate_clks[] __initconst = {
@@ -1464,7 +1463,7 @@
 	     "mout_peri_bus_user",
 	     CLK_CON_GAT_GOUT_PERI_PWM_MOTOR_PCLK, 21, 0, 0),
 	GATE(CLK_GOUT_SPI0_IPCLK, "gout_spi0_ipclk", "dout_peri_spi0",
-	     CLK_CON_GAT_GOUT_PERI_SPI_0_IPCLK, 21, CLK_SET_RATE_PARENT, 0),
+	     CLK_CON_GAT_GOUT_PERI_SPI_0_IPCLK, 21, 0, 0),
 	GATE(CLK_GOUT_SPI0_PCLK, "gout_spi0_pclk", "mout_peri_bus_user",
 	     CLK_CON_GAT_GOUT_PERI_SPI_0_PCLK, 21, 0, 0),
 	GATE(CLK_GOUT_SYSREG_PERI_PCLK, "gout_sysreg_peri_pclk",
Index: drivers/clk/zynq/clkc.c
===================================================================
--- drivers/clk/zynq/clkc.c	(revision 55465)
+++ drivers/clk/zynq/clkc.c	(revision 55464)
@@ -42,7 +42,6 @@
 #define SLCR_SWDT_CLK_SEL		(zynq_clkc_base + 0x204)
 
 #define NUM_MIO_PINS	54
-#define CLK_NAME_LEN	16
 
 #define DBG_CLK_CTRL_CLKACT_TRC		BIT(0)
 #define DBG_CLK_CTRL_CPU_1XCLKACT	BIT(1)
@@ -216,7 +215,7 @@
 	int i;
 	u32 tmp;
 	int ret;
-	char clk_name[CLK_NAME_LEN];
+	char *clk_name;
 	unsigned int fclk_enable = 0;
 	const char *clk_output_name[clk_max];
 	const char *cpu_parents[4];
@@ -427,10 +426,12 @@
 			"gem1_emio_mux", CLK_SET_RATE_PARENT,
 			SLCR_GEM1_CLK_CTRL, 0, 0, &gem1clk_lock);
 
+	tmp = strlen("mio_clk_00x");
+	clk_name = kmalloc(tmp, GFP_KERNEL);
 	for (i = 0; i < NUM_MIO_PINS; i++) {
 		int idx;
 
-		snprintf(clk_name, CLK_NAME_LEN, "mio_clk_%2.2d", i);
+		snprintf(clk_name, tmp, "mio_clk_%2.2d", i);
 		idx = of_property_match_string(np, "clock-names", clk_name);
 		if (idx >= 0)
 			can_mio_mux_parents[i] = of_clk_get_parent_name(np,
@@ -438,6 +439,7 @@
 		else
 			can_mio_mux_parents[i] = dummy_nm;
 	}
+	kfree(clk_name);
 	clk_register_mux(NULL, "can_mux", periph_parents, 4,
 			CLK_SET_RATE_NO_REPARENT, SLCR_CAN_CLK_CTRL, 4, 2, 0,
 			&canclk_lock);
Index: drivers/cpufreq/qcom-cpufreq-nvmem.c
===================================================================
--- drivers/cpufreq/qcom-cpufreq-nvmem.c	(revision 55465)
+++ drivers/cpufreq/qcom-cpufreq-nvmem.c	(revision 55464)
@@ -22,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/nvmem-consumer.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_opp.h>
Index: drivers/cpufreq/brcmstb-avs-cpufreq.c
===================================================================
--- drivers/cpufreq/brcmstb-avs-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/brcmstb-avs-cpufreq.c	(revision 55464)
@@ -481,8 +481,6 @@
 static unsigned int brcm_avs_cpufreq_get(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (!policy)
-		return 0;
 	struct private_data *priv = policy->driver_data;
 
 	cpufreq_cpu_put(policy);
Index: drivers/cpufreq/armada-37xx-cpufreq.c
===================================================================
--- drivers/cpufreq/armada-37xx-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/armada-37xx-cpufreq.c	(revision 55464)
@@ -14,8 +14,10 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/mfd/syscon.h>
-#include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/platform_device.h>
 #include <linux/pm_opp.h>
 #include <linux/regmap.h>
Index: drivers/cpufreq/mediatek-cpufreq-hw.c
===================================================================
--- drivers/cpufreq/mediatek-cpufreq-hw.c	(revision 55465)
+++ drivers/cpufreq/mediatek-cpufreq-hw.c	(revision 55464)
@@ -10,10 +10,8 @@
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 
 #define LUT_MAX_ENTRIES			32U
@@ -297,24 +295,8 @@
 static int mtk_cpufreq_hw_driver_probe(struct platform_device *pdev)
 {
 	const void *data;
-	int ret, cpu;
-	struct device *cpu_dev;
-	struct regulator *cpu_reg;
+	int ret;
 
-	/* Make sure that all CPU supplies are available before proceeding. */
-	for_each_possible_cpu(cpu) {
-		cpu_dev = get_cpu_device(cpu);
-		if (!cpu_dev)
-			return dev_err_probe(&pdev->dev, -EPROBE_DEFER,
-					     "Failed to get cpu%d device\n", cpu);
-
-		cpu_reg = devm_regulator_get(cpu_dev, "cpu");
-		if (IS_ERR(cpu_reg))
-			return dev_err_probe(&pdev->dev, PTR_ERR(cpu_reg),
-					     "CPU%d regulator get failed\n", cpu);
-	}
-
-
 	data = of_device_get_match_data(&pdev->dev);
 	if (!data)
 		return -EINVAL;
Index: drivers/cpufreq/ppc_cbe_cpufreq.c
===================================================================
--- drivers/cpufreq/ppc_cbe_cpufreq.c	(revision 55465)
+++ drivers/cpufreq/ppc_cbe_cpufreq.c	(revision 55464)
@@ -9,7 +9,7 @@
 
 #include <linux/cpufreq.h>
 #include <linux/module.h>
-#include <linux/of.h>
+#include <linux/of_platform.h>
 
 #include <asm/machdep.h>
 #include <asm/cell-regs.h>
Index: drivers/cpufreq/ppc_cbe_cpufreq_pmi.c
===================================================================
--- drivers/cpufreq/ppc_cbe_cpufreq_pmi.c	(revision 55465)
+++ drivers/cpufreq/ppc_cbe_cpufreq_pmi.c	(revision 55464)
@@ -11,6 +11,7 @@
 #include <linux/types.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/of_platform.h>
 #include <linux/pm_qos.h>
 #include <linux/slab.h>
 
Index: drivers/cpufreq/scpi-cpufreq.c
===================================================================
--- drivers/cpufreq/scpi-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/scpi-cpufreq.c	(revision 55464)
@@ -14,7 +14,7 @@
 #include <linux/cpumask.h>
 #include <linux/export.h>
 #include <linux/module.h>
-#include <linux/platform_device.h>
+#include <linux/of_platform.h>
 #include <linux/pm_opp.h>
 #include <linux/scpi_protocol.h>
 #include <linux/slab.h>
Index: drivers/cpufreq/sti-cpufreq.c
===================================================================
--- drivers/cpufreq/sti-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/sti-cpufreq.c	(revision 55464)
@@ -13,7 +13,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/platform_device.h>
+#include <linux/of_platform.h>
 #include <linux/pm_opp.h>
 #include <linux/regmap.h>
 
Index: drivers/cpufreq/ti-cpufreq.c
===================================================================
--- drivers/cpufreq/ti-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/ti-cpufreq.c	(revision 55464)
@@ -12,7 +12,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/of.h>
-#include <linux/platform_device.h>
+#include <linux/of_platform.h>
 #include <linux/pm_opp.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
Index: drivers/cpufreq/vexpress-spc-cpufreq.c
===================================================================
--- drivers/cpufreq/vexpress-spc-cpufreq.c	(revision 55465)
+++ drivers/cpufreq/vexpress-spc-cpufreq.c	(revision 55464)
@@ -18,6 +18,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/pm_opp.h>
 #include <linux/slab.h>
Index: drivers/dma/Kconfig
===================================================================
--- drivers/dma/Kconfig	(revision 55465)
+++ drivers/dma/Kconfig	(revision 55464)
@@ -665,16 +665,16 @@
 
 config TEGRA210_ADMA
 	tristate "NVIDIA Tegra210 ADMA support"
-	depends on (ARCH_TEGRA || COMPILE_TEST)
+	depends on (ARCH_TEGRA_210_SOC || COMPILE_TEST)
 	select DMA_ENGINE
 	select DMA_VIRTUAL_CHANNELS
 	help
-	  Support for the NVIDIA Tegra210/Tegra186/Tegra194/Tegra234 ADMA
-	  controller driver. The DMA controller has multiple DMA channels
-	  and is used to service various audio clients in the Tegra210
-	  audio processing engine (APE). This DMA controller transfers
-	  data from memory to peripheral and vice versa. It does not
-	  support memory to memory data transfer.
+	  Support for the NVIDIA Tegra210 ADMA controller driver. The
+	  DMA controller has multiple DMA channels and is used to service
+	  various audio clients in the Tegra210 audio processing engine
+	  (APE). This DMA controller transfers data from memory to
+	  peripheral and vice versa. It does not support memory to
+	  memory data transfer.
 
 config TIMB_DMA
 	tristate "Timberdale FPGA DMA support"
Index: drivers/gpio/Kconfig
===================================================================
--- drivers/gpio/Kconfig	(revision 55465)
+++ drivers/gpio/Kconfig	(revision 55464)
@@ -679,8 +679,7 @@
 	  Say yes here to support UniPhier GPIOs.
 
 config GPIO_VF610
-	bool "VF610 GPIO support"
-	default y if SOC_VF610
+	def_bool y
 	depends on ARCH_MXC
 	select GPIOLIB_IRQCHIP
 	help
Index: drivers/gpu/drm/amd/amdgpu/soc15.c
===================================================================
--- drivers/gpu/drm/amd/amdgpu/soc15.c	(revision 55465)
+++ drivers/gpu/drm/amd/amdgpu/soc15.c	(revision 55464)
@@ -584,34 +584,11 @@
 		return AMD_RESET_METHOD_MODE1;
 }
 
-static bool soc15_need_reset_on_resume(struct amdgpu_device *adev)
-{
-	u32 sol_reg;
-
-	sol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);
-
-	/* Will reset for the following suspend abort cases.
-	 * 1) Only reset limit on APU side, dGPU hasn't checked yet.
-	 * 2) S3 suspend abort and TOS already launched.
-	 */
-	if (adev->flags & AMD_IS_APU && adev->in_s3 &&
-			!adev->suspend_complete &&
-			sol_reg)
-		return true;
-
-	return false;
-}
-
 static int soc15_asic_reset(struct amdgpu_device *adev)
 {
 	/* original raven doesn't have full asic reset */
-	/* On the latest Raven, the GPU reset can be performed
-	 * successfully. So now, temporarily enable it for the
-	 * S3 suspend abort case.
-	 */
-	if (((adev->apu_flags & AMD_APU_IS_RAVEN) ||
-	    (adev->apu_flags & AMD_APU_IS_RAVEN2)) &&
-		!soc15_need_reset_on_resume(adev))
+	if ((adev->apu_flags & AMD_APU_IS_RAVEN) ||
+	    (adev->apu_flags & AMD_APU_IS_RAVEN2))
 		return 0;
 
 	switch (soc15_asic_reset_method(adev)) {
@@ -1308,6 +1285,24 @@
 	return soc15_common_hw_fini(adev);
 }
 
+static bool soc15_need_reset_on_resume(struct amdgpu_device *adev)
+{
+	u32 sol_reg;
+
+	sol_reg = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);
+
+	/* Will reset for the following suspend abort cases.
+	 * 1) Only reset limit on APU side, dGPU hasn't checked yet.
+	 * 2) S3 suspend abort and TOS already launched.
+	 */
+	if (adev->flags & AMD_IS_APU && adev->in_s3 &&
+			!adev->suspend_complete &&
+			sol_reg)
+		return true;
+
+	return false;
+}
+
 static int soc15_common_resume(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
Index: drivers/gpu/drm/amd/amdgpu/atom.c
===================================================================
--- drivers/gpu/drm/amd/amdgpu/atom.c	(revision 55465)
+++ drivers/gpu/drm/amd/amdgpu/atom.c	(revision 55464)
@@ -313,7 +313,7 @@
 				DEBUG("IMM 0x%02X\n", val);
 			return val;
 		}
-		break;
+		return 0;
 	case ATOM_ARG_PLL:
 		idx = U8(*ptr);
 		(*ptr)++;
Index: drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
===================================================================
--- drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c	(revision 55465)
+++ drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c	(revision 55464)
@@ -1358,7 +1358,7 @@
 	const uint32_t rd_buf_size = 10;
 	struct pipe_ctx *pipe_ctx;
 	ssize_t result = 0;
-	int i, r, str_len = 10;
+	int i, r, str_len = 30;
 
 	rd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);
 
Index: drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
===================================================================
--- drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c	(revision 55465)
+++ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c	(revision 55464)
@@ -1854,9 +1854,6 @@
 {
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
-	if (!stream)
-		return false;
-
 	if (dpp == NULL)
 		return false;
 
@@ -1879,8 +1876,8 @@
 	} else
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 
-	if (stream->ctx &&
-	    stream->out_transfer_func) {
+	if (stream != NULL && stream->ctx != NULL &&
+			stream->out_transfer_func != NULL) {
 		log_tf(stream->ctx,
 				stream->out_transfer_func,
 				dpp->regamma_params.hw_points_num);
Index: drivers/gpu/drm/tegra/dpaux.c
===================================================================
--- drivers/gpu/drm/tegra/dpaux.c	(revision 55465)
+++ drivers/gpu/drm/tegra/dpaux.c	(revision 55464)
@@ -524,7 +524,7 @@
 	if (err < 0) {
 		dev_err(dpaux->dev, "failed to request IRQ#%u: %d\n",
 			dpaux->irq, err);
-		goto err_pm_disable;
+		return err;
 	}
 
 	disable_irq(dpaux->irq);
@@ -544,7 +544,7 @@
 	 */
 	err = tegra_dpaux_pad_config(dpaux, DPAUX_PADCTL_FUNC_I2C);
 	if (err < 0)
-		goto err_pm_disable;
+		return err;
 
 #ifdef CONFIG_GENERIC_PINCONF
 	dpaux->desc.name = dev_name(&pdev->dev);
@@ -557,8 +557,7 @@
 	dpaux->pinctrl = devm_pinctrl_register(&pdev->dev, &dpaux->desc, dpaux);
 	if (IS_ERR(dpaux->pinctrl)) {
 		dev_err(&pdev->dev, "failed to register pincontrol\n");
-		err = PTR_ERR(dpaux->pinctrl);
-		goto err_pm_disable;
+		return PTR_ERR(dpaux->pinctrl);
 	}
 #endif
 	/* enable and clear all interrupts */
@@ -574,15 +573,10 @@
 	err = devm_of_dp_aux_populate_ep_devices(&dpaux->aux);
 	if (err < 0) {
 		dev_err(dpaux->dev, "failed to populate AUX bus: %d\n", err);
-		goto err_pm_disable;
+		return err;
 	}
 
 	return 0;
-
-err_pm_disable:
-	pm_runtime_put_sync(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
-	return err;
 }
 
 static int tegra_dpaux_remove(struct platform_device *pdev)
Index: drivers/gpu/drm/tegra/dsi.c
===================================================================
--- drivers/gpu/drm/tegra/dsi.c	(revision 55465)
+++ drivers/gpu/drm/tegra/dsi.c	(revision 55464)
@@ -1534,11 +1534,9 @@
 	np = of_parse_phandle(dsi->dev->of_node, "nvidia,ganged-mode", 0);
 	if (np) {
 		struct platform_device *gangster = of_find_device_by_node(np);
-		of_node_put(np);
-		if (!gangster)
-			return -EPROBE_DEFER;
 
 		dsi->slave = platform_get_drvdata(gangster);
+		of_node_put(np);
 
 		if (!dsi->slave) {
 			put_device(&gangster->dev);
@@ -1586,58 +1584,48 @@
 
 	if (!pdev->dev.pm_domain) {
 		dsi->rst = devm_reset_control_get(&pdev->dev, "dsi");
-		if (IS_ERR(dsi->rst)) {
-			err = PTR_ERR(dsi->rst);
-			goto remove;
-		}
+		if (IS_ERR(dsi->rst))
+			return PTR_ERR(dsi->rst);
 	}
 
 	dsi->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(dsi->clk)) {
-		err = dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk),
-				    "cannot get DSI clock\n");
-		goto remove;
+		dev_err(&pdev->dev, "cannot get DSI clock\n");
+		return PTR_ERR(dsi->clk);
 	}
 
 	dsi->clk_lp = devm_clk_get(&pdev->dev, "lp");
 	if (IS_ERR(dsi->clk_lp)) {
-		err = dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk_lp),
-				    "cannot get low-power clock\n");
-		goto remove;
+		dev_err(&pdev->dev, "cannot get low-power clock\n");
+		return PTR_ERR(dsi->clk_lp);
 	}
 
 	dsi->clk_parent = devm_clk_get(&pdev->dev, "parent");
 	if (IS_ERR(dsi->clk_parent)) {
-		err = dev_err_probe(&pdev->dev, PTR_ERR(dsi->clk_parent),
-				    "cannot get parent clock\n");
-		goto remove;
+		dev_err(&pdev->dev, "cannot get parent clock\n");
+		return PTR_ERR(dsi->clk_parent);
 	}
 
 	dsi->vdd = devm_regulator_get(&pdev->dev, "avdd-dsi-csi");
 	if (IS_ERR(dsi->vdd)) {
-		err = dev_err_probe(&pdev->dev, PTR_ERR(dsi->vdd),
-				    "cannot get VDD supply\n");
-		goto remove;
+		dev_err(&pdev->dev, "cannot get VDD supply\n");
+		return PTR_ERR(dsi->vdd);
 	}
 
 	err = tegra_dsi_setup_clocks(dsi);
 	if (err < 0) {
 		dev_err(&pdev->dev, "cannot setup clocks\n");
-		goto remove;
+		return err;
 	}
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	dsi->regs = devm_ioremap_resource(&pdev->dev, regs);
-	if (IS_ERR(dsi->regs)) {
-		err = PTR_ERR(dsi->regs);
-		goto remove;
-	}
+	if (IS_ERR(dsi->regs))
+		return PTR_ERR(dsi->regs);
 
 	dsi->mipi = tegra_mipi_request(&pdev->dev, pdev->dev.of_node);
-	if (IS_ERR(dsi->mipi)) {
-		err = PTR_ERR(dsi->mipi);
-		goto remove;
-	}
+	if (IS_ERR(dsi->mipi))
+		return PTR_ERR(dsi->mipi);
 
 	dsi->host.ops = &tegra_dsi_host_ops;
 	dsi->host.dev = &pdev->dev;
@@ -1665,12 +1653,9 @@
 	return 0;
 
 unregister:
-	pm_runtime_disable(&pdev->dev);
 	mipi_dsi_host_unregister(&dsi->host);
 mipi_free:
 	tegra_mipi_free(dsi->mipi);
-remove:
-	tegra_output_remove(&dsi->output);
 	return err;
 }
 
Index: drivers/gpu/drm/tegra/fb.c
===================================================================
--- drivers/gpu/drm/tegra/fb.c	(revision 55465)
+++ drivers/gpu/drm/tegra/fb.c	(revision 55464)
@@ -166,7 +166,6 @@
 
 		if (gem->size < size) {
 			err = -EINVAL;
-			drm_gem_object_put(gem);
 			goto unreference;
 		}
 
Index: drivers/gpu/drm/tegra/hdmi.c
===================================================================
--- drivers/gpu/drm/tegra/hdmi.c	(revision 55465)
+++ drivers/gpu/drm/tegra/hdmi.c	(revision 55464)
@@ -1776,6 +1776,7 @@
 static int tegra_hdmi_probe(struct platform_device *pdev)
 {
 	struct tegra_hdmi *hdmi;
+	struct resource *regs;
 	int err;
 
 	hdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);
@@ -1837,15 +1838,14 @@
 	if (err < 0)
 		return err;
 
-	hdmi->regs = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(hdmi->regs)) {
-		err = PTR_ERR(hdmi->regs);
-		goto remove;
-	}
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hdmi->regs = devm_ioremap_resource(&pdev->dev, regs);
+	if (IS_ERR(hdmi->regs))
+		return PTR_ERR(hdmi->regs);
 
 	err = platform_get_irq(pdev, 0);
 	if (err < 0)
-		goto remove;
+		return err;
 
 	hdmi->irq = err;
 
@@ -1854,7 +1854,7 @@
 	if (err < 0) {
 		dev_err(&pdev->dev, "failed to request IRQ#%u: %d\n",
 			hdmi->irq, err);
-		goto remove;
+		return err;
 	}
 
 	platform_set_drvdata(pdev, hdmi);
@@ -1861,11 +1861,11 @@
 
 	err = devm_pm_runtime_enable(&pdev->dev);
 	if (err)
-		goto remove;
+		return err;
 
 	err = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);
 	if (err)
-		goto remove;
+		return err;
 
 	INIT_LIST_HEAD(&hdmi->client.list);
 	hdmi->client.ops = &hdmi_client_ops;
@@ -1875,14 +1875,10 @@
 	if (err < 0) {
 		dev_err(&pdev->dev, "failed to register host1x client: %d\n",
 			err);
-		goto remove;
+		return err;
 	}
 
 	return 0;
-
-remove:
-	tegra_output_remove(&hdmi->output);
-	return err;
 }
 
 static int tegra_hdmi_remove(struct platform_device *pdev)
Index: drivers/gpu/drm/tegra/output.c
===================================================================
--- drivers/gpu/drm/tegra/output.c	(revision 55465)
+++ drivers/gpu/drm/tegra/output.c	(revision 55464)
@@ -139,10 +139,8 @@
 						       GPIOD_IN,
 						       "HDMI hotplug detect");
 	if (IS_ERR(output->hpd_gpio)) {
-		if (PTR_ERR(output->hpd_gpio) != -ENOENT) {
-			err = PTR_ERR(output->hpd_gpio);
-			goto put_i2c;
-		}
+		if (PTR_ERR(output->hpd_gpio) != -ENOENT)
+			return PTR_ERR(output->hpd_gpio);
 
 		output->hpd_gpio = NULL;
 	}
@@ -151,7 +149,7 @@
 		err = gpiod_to_irq(output->hpd_gpio);
 		if (err < 0) {
 			dev_err(output->dev, "gpiod_to_irq(): %d\n", err);
-			goto put_i2c;
+			return err;
 		}
 
 		output->hpd_irq = err;
@@ -164,7 +162,7 @@
 		if (err < 0) {
 			dev_err(output->dev, "failed to request IRQ#%u: %d\n",
 				output->hpd_irq, err);
-			goto put_i2c;
+			return err;
 		}
 
 		output->connector.polled = DRM_CONNECTOR_POLL_HPD;
@@ -178,12 +176,6 @@
 	}
 
 	return 0;
-
-put_i2c:
-	if (output->ddc)
-		i2c_put_adapter(output->ddc);
-
-	return err;
 }
 
 void tegra_output_remove(struct tegra_output *output)
Index: drivers/gpu/drm/tegra/rgb.c
===================================================================
--- drivers/gpu/drm/tegra/rgb.c	(revision 55465)
+++ drivers/gpu/drm/tegra/rgb.c	(revision 55464)
@@ -214,21 +214,19 @@
 	rgb->clk = devm_clk_get(dc->dev, NULL);
 	if (IS_ERR(rgb->clk)) {
 		dev_err(dc->dev, "failed to get clock\n");
-		err = PTR_ERR(rgb->clk);
-		goto remove;
+		return PTR_ERR(rgb->clk);
 	}
 
 	rgb->clk_parent = devm_clk_get(dc->dev, "parent");
 	if (IS_ERR(rgb->clk_parent)) {
 		dev_err(dc->dev, "failed to get parent clock\n");
-		err = PTR_ERR(rgb->clk_parent);
-		goto remove;
+		return PTR_ERR(rgb->clk_parent);
 	}
 
 	err = clk_set_parent(rgb->clk, rgb->clk_parent);
 	if (err < 0) {
 		dev_err(dc->dev, "failed to set parent clock: %d\n", err);
-		goto remove;
+		return err;
 	}
 
 	rgb->pll_d_out0 = clk_get_sys(NULL, "pll_d_out0");
@@ -235,7 +233,7 @@
 	if (IS_ERR(rgb->pll_d_out0)) {
 		err = PTR_ERR(rgb->pll_d_out0);
 		dev_err(dc->dev, "failed to get pll_d_out0: %d\n", err);
-		goto remove;
+		return err;
 	}
 
 	if (dc->soc->has_pll_d2_out0) {
@@ -243,7 +241,7 @@
 		if (IS_ERR(rgb->pll_d2_out0)) {
 			err = PTR_ERR(rgb->pll_d2_out0);
 			dev_err(dc->dev, "failed to get pll_d2_out0: %d\n", err);
-			goto put_pll;
+			return err;
 		}
 	}
 
@@ -250,12 +248,6 @@
 	dc->rgb = &rgb->output;
 
 	return 0;
-
-put_pll:
-	clk_put(rgb->pll_d_out0);
-remove:
-	tegra_output_remove(&rgb->output);
-	return err;
 }
 
 int tegra_dc_rgb_remove(struct tegra_dc *dc)
Index: drivers/gpu/drm/nouveau/nouveau_bo.c
===================================================================
--- drivers/gpu/drm/nouveau/nouveau_bo.c	(revision 55465)
+++ drivers/gpu/drm/nouveau/nouveau_bo.c	(revision 55464)
@@ -1194,8 +1194,6 @@
 			drm_vma_node_unmap(&nvbo->bo.base.vma_node,
 					   bdev->dev_mapping);
 			nouveau_ttm_io_mem_free_locked(drm, nvbo->bo.resource);
-			nvbo->bo.resource->bus.offset = 0;
-			nvbo->bo.resource->bus.addr = NULL;
 			goto retry;
 		}
 
Index: drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c
===================================================================
--- drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c	(revision 55465)
+++ drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c	(revision 55464)
@@ -228,13 +228,6 @@
 	return dpu_enc->wide_bus_en;
 }
 
-bool dpu_encoder_is_dsc_enabled(const struct drm_encoder *drm_enc)
-{
-	const struct dpu_encoder_virt *dpu_enc = to_dpu_encoder_virt(drm_enc);
-
-	return dpu_enc->dsc ? true : false;
-}
-
 int dpu_encoder_get_crc_values_cnt(const struct drm_encoder *drm_enc)
 {
 	struct dpu_encoder_virt *dpu_enc;
@@ -1871,9 +1864,7 @@
 	dsc_common_mode = 0;
 	pic_width = dsc->pic_width;
 
-	dsc_common_mode = DSC_MODE_SPLIT_PANEL;
-	if (dpu_encoder_use_dsc_merge(enc_master->parent))
-		dsc_common_mode |= DSC_MODE_MULTIPLEX;
+	dsc_common_mode = DSC_MODE_MULTIPLEX | DSC_MODE_SPLIT_PANEL;
 	if (enc_master->intf_mode == INTF_MODE_VIDEO)
 		dsc_common_mode |= DSC_MODE_VIDEO;
 
Index: drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.c
===================================================================
--- drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.c	(revision 55465)
+++ drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.c	(revision 55464)
@@ -154,8 +154,13 @@
 	hsync_ctl = (hsync_period << 16) | p->hsync_pulse_width;
 	display_hctl = (hsync_end_x << 16) | hsync_start_x;
 
+	/*
+	 * DATA_HCTL_EN controls data timing which can be different from
+	 * video timing. It is recommended to enable it for all cases, except
+	 * if compression is enabled in 1 pixel per clock mode
+	 */
 	if (p->wide_bus_en)
-		intf_cfg2 |= INTF_CFG2_DATABUS_WIDEN;
+		intf_cfg2 |= INTF_CFG2_DATABUS_WIDEN | INTF_CFG2_DATA_HCTL_EN;
 
 	data_width = p->width;
 
@@ -225,14 +230,6 @@
 	DPU_REG_WRITE(c, INTF_CONFIG, intf_cfg);
 	DPU_REG_WRITE(c, INTF_PANEL_FORMAT, panel_format);
 	if (ctx->cap->features & BIT(DPU_DATA_HCTL_EN)) {
-		/*
-		 * DATA_HCTL_EN controls data timing which can be different from
-		 * video timing. It is recommended to enable it for all cases, except
-		 * if compression is enabled in 1 pixel per clock mode
-		 */
-		if (!(p->compression_en && !p->wide_bus_en))
-			intf_cfg2 |= INTF_CFG2_DATA_HCTL_EN;
-
 		DPU_REG_WRITE(c, INTF_CONFIG2, intf_cfg2);
 		DPU_REG_WRITE(c, INTF_DISPLAY_DATA_HCTL, display_data_hctl);
 		DPU_REG_WRITE(c, INTF_ACTIVE_DATA_HCTL, active_data_hctl);
Index: drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.h
===================================================================
--- drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.h	(revision 55465)
+++ drivers/gpu/drm/msm/disp/dpu1/dpu_hw_intf.h	(revision 55464)
@@ -33,7 +33,6 @@
 	u32 hsync_skew;
 
 	bool wide_bus_en;
-	bool compression_en;
 };
 
 struct intf_prog_fetch {
Index: drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.h
===================================================================
--- drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.h	(revision 55465)
+++ drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.h	(revision 55464)
@@ -176,13 +176,6 @@
 bool dpu_encoder_is_widebus_enabled(const struct drm_encoder *drm_enc);
 
 /**
- * dpu_encoder_is_dsc_enabled - indicate whether dsc is enabled
- *				for the encoder.
- * @drm_enc:    Pointer to previously created drm encoder structure
- */
-bool dpu_encoder_is_dsc_enabled(const struct drm_encoder *drm_enc);
-
-/**
  * dpu_encoder_get_crc_values_cnt - get number of physical encoders contained
  *	in virtual encoder that can collect CRC values
  * @drm_enc:    Pointer to previously created drm encoder structure
Index: drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c
===================================================================
--- drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c	(revision 55465)
+++ drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c	(revision 55464)
@@ -100,7 +100,6 @@
 	}
 
 	timing->wide_bus_en = dpu_encoder_is_widebus_enabled(phys_enc->parent);
-	timing->compression_en = dpu_encoder_is_dsc_enabled(phys_enc->parent);
 
 	/*
 	 * for DP, divide the horizonal parameters by 2 when
@@ -257,14 +256,12 @@
 		mode.htotal >>= 1;
 		mode.hsync_start >>= 1;
 		mode.hsync_end >>= 1;
-		mode.hskew >>= 1;
 
 		DPU_DEBUG_VIDENC(phys_enc,
-			"split_role %d, halve horizontal %d %d %d %d %d\n",
+			"split_role %d, halve horizontal %d %d %d %d\n",
 			phys_enc->split_role,
 			mode.hdisplay, mode.htotal,
-			mode.hsync_start, mode.hsync_end,
-			mode.hskew);
+			mode.hsync_start, mode.hsync_end);
 	}
 
 	drm_mode_to_intf_timing_params(phys_enc, &mode, &timing_params);
Index: drivers/gpu/drm/panel/panel-edp.c
===================================================================
--- drivers/gpu/drm/panel/panel-edp.c	(revision 55465)
+++ drivers/gpu/drm/panel/panel-edp.c	(revision 55464)
@@ -413,7 +413,8 @@
 	if (!p->prepared)
 		return 0;
 
-	ret = pm_runtime_put_sync_suspend(panel->dev);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
 	if (ret < 0)
 		return ret;
 	p->prepared = false;
Index: drivers/gpu/drm/tidss/tidss_crtc.c
===================================================================
--- drivers/gpu/drm/tidss/tidss_crtc.c	(revision 55465)
+++ drivers/gpu/drm/tidss/tidss_crtc.c	(revision 55464)
@@ -270,16 +270,6 @@
 
 	reinit_completion(&tcrtc->framedone_completion);
 
-	/*
-	 * If a layer is left enabled when the videoport is disabled, and the
-	 * vid pipeline that was used for the layer is taken into use on
-	 * another videoport, the DSS will report sync lost issues. Disable all
-	 * the layers here as a work-around.
-	 */
-	for (u32 layer = 0; layer < tidss->feat->num_planes; layer++)
-		dispc_ovr_enable_layer(tidss->dispc, tcrtc->hw_videoport, layer,
-				       false);
-
 	dispc_vp_disable(tidss->dispc, tcrtc->hw_videoport);
 
 	if (!wait_for_completion_timeout(&tcrtc->framedone_completion,
Index: drivers/gpu/drm/tidss/tidss_plane.c
===================================================================
--- drivers/gpu/drm/tidss/tidss_plane.c	(revision 55465)
+++ drivers/gpu/drm/tidss/tidss_plane.c	(revision 55464)
@@ -211,7 +211,7 @@
 
 	drm_plane_helper_add(&tplane->plane, &tidss_plane_helper_funcs);
 
-	drm_plane_create_zpos_property(&tplane->plane, tidss->num_planes, 0,
+	drm_plane_create_zpos_property(&tplane->plane, hw_plane_id, 0,
 				       num_planes - 1);
 
 	ret = drm_plane_create_color_properties(&tplane->plane,
Index: drivers/gpu/drm/mediatek/mtk_drm_crtc.c
===================================================================
--- drivers/gpu/drm/mediatek/mtk_drm_crtc.c	(revision 55465)
+++ drivers/gpu/drm/mediatek/mtk_drm_crtc.c	(revision 55464)
@@ -91,13 +91,11 @@
 	struct drm_crtc *crtc = &mtk_crtc->base;
 	unsigned long flags;
 
-	if (mtk_crtc->event) {
-		spin_lock_irqsave(&crtc->dev->event_lock, flags);
-		drm_crtc_send_vblank_event(crtc, mtk_crtc->event);
-		drm_crtc_vblank_put(crtc);
-		mtk_crtc->event = NULL;
-		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-	}
+	spin_lock_irqsave(&crtc->dev->event_lock, flags);
+	drm_crtc_send_vblank_event(crtc, mtk_crtc->event);
+	drm_crtc_vblank_put(crtc);
+	mtk_crtc->event = NULL;
+	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 }
 
 static void mtk_drm_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)
Index: drivers/gpu/drm/mediatek/mtk_dsi.c
===================================================================
--- drivers/gpu/drm/mediatek/mtk_dsi.c	(revision 55465)
+++ drivers/gpu/drm/mediatek/mtk_dsi.c	(revision 55464)
@@ -70,8 +70,8 @@
 #define DSI_PS_WC			0x3fff
 #define DSI_PS_SEL			(3 << 16)
 #define PACKED_PS_16BIT_RGB565		(0 << 16)
-#define PACKED_PS_18BIT_RGB666		(1 << 16)
-#define LOOSELY_PS_24BIT_RGB666		(2 << 16)
+#define LOOSELY_PS_18BIT_RGB666		(1 << 16)
+#define PACKED_PS_18BIT_RGB666		(2 << 16)
 #define PACKED_PS_24BIT_RGB888		(3 << 16)
 
 #define DSI_VSA_NL		0x20
@@ -366,10 +366,10 @@
 		ps_bpp_mode |= PACKED_PS_24BIT_RGB888;
 		break;
 	case MIPI_DSI_FMT_RGB666:
-		ps_bpp_mode |= LOOSELY_PS_24BIT_RGB666;
+		ps_bpp_mode |= PACKED_PS_18BIT_RGB666;
 		break;
 	case MIPI_DSI_FMT_RGB666_PACKED:
-		ps_bpp_mode |= PACKED_PS_18BIT_RGB666;
+		ps_bpp_mode |= LOOSELY_PS_18BIT_RGB666;
 		break;
 	case MIPI_DSI_FMT_RGB565:
 		ps_bpp_mode |= PACKED_PS_16BIT_RGB565;
@@ -423,7 +423,7 @@
 		dsi_tmp_buf_bpp = 3;
 		break;
 	case MIPI_DSI_FMT_RGB666:
-		tmp_reg = LOOSELY_PS_24BIT_RGB666;
+		tmp_reg = LOOSELY_PS_18BIT_RGB666;
 		dsi_tmp_buf_bpp = 3;
 		break;
 	case MIPI_DSI_FMT_RGB666_PACKED:
Index: drivers/gpu/drm/radeon/ni.c
===================================================================
--- drivers/gpu/drm/radeon/ni.c	(revision 55465)
+++ drivers/gpu/drm/radeon/ni.c	(revision 55464)
@@ -813,7 +813,7 @@
 			err = 0;
 		} else if (rdev->smc_fw->size != smc_req_size) {
 			pr_err("ni_mc: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->smc_fw->size, fw_name);
+			       rdev->mc_fw->size, fw_name);
 			err = -EINVAL;
 		}
 	}
Index: drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
===================================================================
--- drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c	(revision 55465)
+++ drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c	(revision 55464)
@@ -65,11 +65,8 @@
 	ttm_resource_init(bo, place, *res);
 
 	id = ida_alloc_max(&gman->gmr_ida, gman->max_gmr_ids - 1, GFP_KERNEL);
-	if (id < 0) {
-		ttm_resource_fini(man, *res);
-		kfree(*res);
+	if (id < 0)
 		return id;
-	}
 
 	spin_lock(&gman->lock);
 
Index: drivers/gpu/drm/rockchip/inno_hdmi.c
===================================================================
--- drivers/gpu/drm/rockchip/inno_hdmi.c	(revision 55465)
+++ drivers/gpu/drm/rockchip/inno_hdmi.c	(revision 55464)
@@ -411,7 +411,7 @@
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_L, value & 0xFF);
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
 
-	value = mode->htotal - mode->hsync_start;
+	value = mode->hsync_start - mode->hdisplay;
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_L, value & 0xFF);
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
 
@@ -426,7 +426,7 @@
 	value = mode->vtotal - mode->vdisplay;
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VBLANK, value & 0xFF);
 
-	value = mode->vtotal - mode->vsync_start;
+	value = mode->vsync_start - mode->vdisplay;
 	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDELAY, value & 0xFF);
 
 	value = mode->vsync_end - mode->vsync_start;
Index: drivers/gpu/drm/rockchip/rockchip_lvds.c
===================================================================
--- drivers/gpu/drm/rockchip/rockchip_lvds.c	(revision 55465)
+++ drivers/gpu/drm/rockchip/rockchip_lvds.c	(revision 55464)
@@ -577,7 +577,8 @@
 		ret = -EINVAL;
 		goto err_put_port;
 	} else if (ret) {
-		dev_err_probe(dev, ret, "failed to find panel and bridge node\n");
+		DRM_DEV_ERROR(dev, "failed to find panel and bridge node\n");
+		ret = -EPROBE_DEFER;
 		goto err_put_port;
 	}
 	if (lvds->panel)
Index: drivers/gpu/drm/lima/lima_gem.c
===================================================================
--- drivers/gpu/drm/lima/lima_gem.c	(revision 55465)
+++ drivers/gpu/drm/lima/lima_gem.c	(revision 55464)
@@ -75,14 +75,18 @@
 	} else {
 		bo->base.sgt = kmalloc(sizeof(*bo->base.sgt), GFP_KERNEL);
 		if (!bo->base.sgt) {
-			ret = -ENOMEM;
-			goto err_out0;
+			sg_free_table(&sgt);
+			return -ENOMEM;
 		}
 	}
 
 	ret = dma_map_sgtable(dev, &sgt, DMA_BIDIRECTIONAL, 0);
-	if (ret)
-		goto err_out1;
+	if (ret) {
+		sg_free_table(&sgt);
+		kfree(bo->base.sgt);
+		bo->base.sgt = NULL;
+		return ret;
+	}
 
 	*bo->base.sgt = sgt;
 
@@ -89,20 +93,11 @@
 	if (vm) {
 		ret = lima_vm_map_bo(vm, bo, old_size >> PAGE_SHIFT);
 		if (ret)
-			goto err_out2;
+			return ret;
 	}
 
 	bo->heap_size = new_size;
 	return 0;
-
-err_out2:
-	dma_unmap_sgtable(dev, &sgt, DMA_BIDIRECTIONAL, 0);
-err_out1:
-	kfree(bo->base.sgt);
-	bo->base.sgt = NULL;
-err_out0:
-	sg_free_table(&sgt);
-	return ret;
 }
 
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
Index: drivers/infiniband/core/device.c
===================================================================
--- drivers/infiniband/core/device.c	(revision 55465)
+++ drivers/infiniband/core/device.c	(revision 55464)
@@ -1730,7 +1730,7 @@
 {
 	int ret;
 
-	lockdep_assert_held(&clients_rwsem);
+	down_write(&clients_rwsem);
 	/*
 	 * The add/remove callbacks must be called in FIFO/LIFO order. To
 	 * achieve this we assign client_ids so they are sorted in
@@ -1739,11 +1739,14 @@
 	client->client_id = highest_client_id;
 	ret = xa_insert(&clients, client->client_id, client, GFP_KERNEL);
 	if (ret)
-		return ret;
+		goto out;
 
 	highest_client_id++;
 	xa_set_mark(&clients, client->client_id, CLIENT_REGISTERED);
-	return 0;
+
+out:
+	up_write(&clients_rwsem);
+	return ret;
 }
 
 static void remove_client_id(struct ib_client *client)
@@ -1773,35 +1776,25 @@
 {
 	struct ib_device *device;
 	unsigned long index;
-	bool need_unreg = false;
 	int ret;
 
 	refcount_set(&client->uses, 1);
 	init_completion(&client->uses_zero);
-
-	/*
-	 * The devices_rwsem is held in write mode to ensure that a racing
-	 * ib_register_device() sees a consisent view of clients and devices.
-	 */
-	down_write(&devices_rwsem);
-	down_write(&clients_rwsem);
 	ret = assign_client_id(client);
 	if (ret)
-		goto out;
+		return ret;
 
-	need_unreg = true;
+	down_read(&devices_rwsem);
 	xa_for_each_marked (&devices, index, device, DEVICE_REGISTERED) {
 		ret = add_client_context(device, client);
-		if (ret)
-			goto out;
+		if (ret) {
+			up_read(&devices_rwsem);
+			ib_unregister_client(client);
+			return ret;
+		}
 	}
-	ret = 0;
-out:
-	up_write(&clients_rwsem);
-	up_write(&devices_rwsem);
-	if (need_unreg && ret)
-		ib_unregister_client(client);
-	return ret;
+	up_read(&devices_rwsem);
+	return 0;
 }
 EXPORT_SYMBOL(ib_register_client);
 
Index: drivers/infiniband/hw/irdma/verbs.c
===================================================================
--- drivers/infiniband/hw/irdma/verbs.c	(revision 55465)
+++ drivers/infiniband/hw/irdma/verbs.c	(revision 55464)
@@ -277,7 +277,7 @@
 	struct irdma_alloc_ucontext_req req = {};
 	struct irdma_alloc_ucontext_resp uresp = {};
 	struct irdma_ucontext *ucontext = to_ucontext(uctx);
-	struct irdma_uk_attrs *uk_attrs = &iwdev->rf->sc_dev.hw_attrs.uk_attrs;
+	struct irdma_uk_attrs *uk_attrs;
 
 	if (udata->inlen < IRDMA_ALLOC_UCTX_MIN_REQ_LEN ||
 	    udata->outlen < IRDMA_ALLOC_UCTX_MIN_RESP_LEN)
@@ -292,9 +292,7 @@
 	ucontext->iwdev = iwdev;
 	ucontext->abi_ver = req.userspace_ver;
 
-	if (req.comp_mask & IRDMA_ALLOC_UCTX_USE_RAW_ATTR)
-		ucontext->use_raw_attrs = true;
-
+	uk_attrs = &iwdev->rf->sc_dev.hw_attrs.uk_attrs;
 	/* GEN_1 legacy support with libi40iw */
 	if (udata->outlen == IRDMA_ALLOC_UCTX_MIN_RESP_LEN) {
 		if (uk_attrs->hw_rev != IRDMA_GEN_1)
@@ -329,7 +327,6 @@
 		uresp.max_hw_cq_size = uk_attrs->max_hw_cq_size;
 		uresp.min_hw_cq_size = uk_attrs->min_hw_cq_size;
 		uresp.hw_rev = uk_attrs->hw_rev;
-		uresp.comp_mask |= IRDMA_ALLOC_UCTX_USE_RAW_ATTR;
 		if (ib_copy_to_udata(udata, &uresp,
 				     min(sizeof(uresp), udata->outlen))) {
 			rdma_user_mmap_entry_remove(ucontext->db_mmap_entry);
@@ -570,86 +567,6 @@
 }
 
 /**
- * irdma_setup_umode_qp - setup sq and rq size in user mode qp
- * @iwdev: iwarp device
- * @iwqp: qp ptr (user or kernel)
- * @info: initialize info to return
- * @init_attr: Initial QP create attributes
- */
-static int irdma_setup_umode_qp(struct ib_udata *udata,
-				struct irdma_device *iwdev,
-				struct irdma_qp *iwqp,
-				struct irdma_qp_init_info *info,
-				struct ib_qp_init_attr *init_attr)
-{
-	struct irdma_ucontext *ucontext = rdma_udata_to_drv_context(udata,
-				struct irdma_ucontext, ibucontext);
-	struct irdma_qp_uk_init_info *ukinfo = &info->qp_uk_init_info;
-	struct irdma_create_qp_req req;
-	unsigned long flags;
-	int ret;
-
-	ret = ib_copy_from_udata(&req, udata,
-				 min(sizeof(req), udata->inlen));
-	if (ret) {
-		ibdev_dbg(&iwdev->ibdev, "VERBS: ib_copy_from_data fail\n");
-		return ret;
-	}
-
-	iwqp->ctx_info.qp_compl_ctx = req.user_compl_ctx;
-	iwqp->user_mode = 1;
-	if (req.user_wqe_bufs) {
-		info->qp_uk_init_info.legacy_mode = ucontext->legacy_mode;
-		spin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);
-		iwqp->iwpbl = irdma_get_pbl((unsigned long)req.user_wqe_bufs,
-					    &ucontext->qp_reg_mem_list);
-		spin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);
-
-		if (!iwqp->iwpbl) {
-			ret = -ENODATA;
-			ibdev_dbg(&iwdev->ibdev, "VERBS: no pbl info\n");
-			return ret;
-		}
-	}
-
-	if (!ucontext->use_raw_attrs) {
-		/**
-		 * Maintain backward compat with older ABI which passes sq and
-		 * rq depth in quanta in cap.max_send_wr and cap.max_recv_wr.
-		 * There is no way to compute the correct value of
-		 * iwqp->max_send_wr/max_recv_wr in the kernel.
-		 */
-		iwqp->max_send_wr = init_attr->cap.max_send_wr;
-		iwqp->max_recv_wr = init_attr->cap.max_recv_wr;
-		ukinfo->sq_size = init_attr->cap.max_send_wr;
-		ukinfo->rq_size = init_attr->cap.max_recv_wr;
-		irdma_uk_calc_shift_wq(ukinfo, &ukinfo->sq_shift,
-				       &ukinfo->rq_shift);
-	} else {
-		ret = irdma_uk_calc_depth_shift_sq(ukinfo, &ukinfo->sq_depth,
-						   &ukinfo->sq_shift);
-		if (ret)
-			return ret;
-
-		ret = irdma_uk_calc_depth_shift_rq(ukinfo, &ukinfo->rq_depth,
-						   &ukinfo->rq_shift);
-		if (ret)
-			return ret;
-
-		iwqp->max_send_wr =
-			(ukinfo->sq_depth - IRDMA_SQ_RSVD) >> ukinfo->sq_shift;
-		iwqp->max_recv_wr =
-			(ukinfo->rq_depth - IRDMA_RQ_RSVD) >> ukinfo->rq_shift;
-		ukinfo->sq_size = ukinfo->sq_depth >> ukinfo->sq_shift;
-		ukinfo->rq_size = ukinfo->rq_depth >> ukinfo->rq_shift;
-	}
-
-	irdma_setup_virt_qp(iwdev, iwqp, info);
-
-	return 0;
-}
-
-/**
  * irdma_setup_kmode_qp - setup initialization for kernel mode qp
  * @iwdev: iwarp device
  * @iwqp: qp ptr (user or kernel)
@@ -662,28 +579,40 @@
 				struct ib_qp_init_attr *init_attr)
 {
 	struct irdma_dma_mem *mem = &iwqp->kqp.dma_mem;
+	u32 sqdepth, rqdepth;
+	u8 sqshift, rqshift;
 	u32 size;
 	int status;
 	struct irdma_qp_uk_init_info *ukinfo = &info->qp_uk_init_info;
+	struct irdma_uk_attrs *uk_attrs = &iwdev->rf->sc_dev.hw_attrs.uk_attrs;
 
-	status = irdma_uk_calc_depth_shift_sq(ukinfo, &ukinfo->sq_depth,
-					      &ukinfo->sq_shift);
+	irdma_get_wqe_shift(uk_attrs,
+		uk_attrs->hw_rev >= IRDMA_GEN_2 ? ukinfo->max_sq_frag_cnt + 1 :
+						  ukinfo->max_sq_frag_cnt,
+		ukinfo->max_inline_data, &sqshift);
+	status = irdma_get_sqdepth(uk_attrs, ukinfo->sq_size, sqshift,
+				   &sqdepth);
 	if (status)
 		return status;
 
-	status = irdma_uk_calc_depth_shift_rq(ukinfo, &ukinfo->rq_depth,
-					      &ukinfo->rq_shift);
+	if (uk_attrs->hw_rev == IRDMA_GEN_1)
+		rqshift = IRDMA_MAX_RQ_WQE_SHIFT_GEN1;
+	else
+		irdma_get_wqe_shift(uk_attrs, ukinfo->max_rq_frag_cnt, 0,
+				    &rqshift);
+
+	status = irdma_get_rqdepth(uk_attrs, ukinfo->rq_size, rqshift,
+				   &rqdepth);
 	if (status)
 		return status;
 
 	iwqp->kqp.sq_wrid_mem =
-		kcalloc(ukinfo->sq_depth, sizeof(*iwqp->kqp.sq_wrid_mem), GFP_KERNEL);
+		kcalloc(sqdepth, sizeof(*iwqp->kqp.sq_wrid_mem), GFP_KERNEL);
 	if (!iwqp->kqp.sq_wrid_mem)
 		return -ENOMEM;
 
 	iwqp->kqp.rq_wrid_mem =
-		kcalloc(ukinfo->rq_depth, sizeof(*iwqp->kqp.rq_wrid_mem), GFP_KERNEL);
-
+		kcalloc(rqdepth, sizeof(*iwqp->kqp.rq_wrid_mem), GFP_KERNEL);
 	if (!iwqp->kqp.rq_wrid_mem) {
 		kfree(iwqp->kqp.sq_wrid_mem);
 		iwqp->kqp.sq_wrid_mem = NULL;
@@ -693,7 +622,7 @@
 	ukinfo->sq_wrtrk_array = iwqp->kqp.sq_wrid_mem;
 	ukinfo->rq_wrid_array = iwqp->kqp.rq_wrid_mem;
 
-	size = (ukinfo->sq_depth + ukinfo->rq_depth) * IRDMA_QP_WQE_MIN_SIZE;
+	size = (sqdepth + rqdepth) * IRDMA_QP_WQE_MIN_SIZE;
 	size += (IRDMA_SHADOW_AREA_SIZE << 3);
 
 	mem->size = ALIGN(size, 256);
@@ -709,18 +638,16 @@
 
 	ukinfo->sq = mem->va;
 	info->sq_pa = mem->pa;
-	ukinfo->rq = &ukinfo->sq[ukinfo->sq_depth];
-	info->rq_pa = info->sq_pa + (ukinfo->sq_depth * IRDMA_QP_WQE_MIN_SIZE);
-	ukinfo->shadow_area = ukinfo->rq[ukinfo->rq_depth].elem;
-	info->shadow_area_pa =
-		info->rq_pa + (ukinfo->rq_depth * IRDMA_QP_WQE_MIN_SIZE);
-	ukinfo->sq_size = ukinfo->sq_depth >> ukinfo->sq_shift;
-	ukinfo->rq_size = ukinfo->rq_depth >> ukinfo->rq_shift;
+	ukinfo->rq = &ukinfo->sq[sqdepth];
+	info->rq_pa = info->sq_pa + (sqdepth * IRDMA_QP_WQE_MIN_SIZE);
+	ukinfo->shadow_area = ukinfo->rq[rqdepth].elem;
+	info->shadow_area_pa = info->rq_pa + (rqdepth * IRDMA_QP_WQE_MIN_SIZE);
+	ukinfo->sq_size = sqdepth >> sqshift;
+	ukinfo->rq_size = rqdepth >> rqshift;
+	ukinfo->qp_id = iwqp->ibqp.qp_num;
 
-	iwqp->max_send_wr = (ukinfo->sq_depth - IRDMA_SQ_RSVD) >> ukinfo->sq_shift;
-	iwqp->max_recv_wr = (ukinfo->rq_depth - IRDMA_RQ_RSVD) >> ukinfo->rq_shift;
-	init_attr->cap.max_send_wr = iwqp->max_send_wr;
-	init_attr->cap.max_recv_wr = iwqp->max_recv_wr;
+	init_attr->cap.max_send_wr = (sqdepth - IRDMA_SQ_RSVD) >> sqshift;
+	init_attr->cap.max_recv_wr = (rqdepth - IRDMA_RQ_RSVD) >> rqshift;
 
 	return 0;
 }
@@ -878,14 +805,18 @@
 	struct irdma_device *iwdev = to_iwdev(ibpd->device);
 	struct irdma_pci_f *rf = iwdev->rf;
 	struct irdma_qp *iwqp = to_iwqp(ibqp);
+	struct irdma_create_qp_req req = {};
 	struct irdma_create_qp_resp uresp = {};
 	u32 qp_num = 0;
 	int err_code;
+	int sq_size;
+	int rq_size;
 	struct irdma_sc_qp *qp;
 	struct irdma_sc_dev *dev = &rf->sc_dev;
 	struct irdma_uk_attrs *uk_attrs = &dev->hw_attrs.uk_attrs;
 	struct irdma_qp_init_info init_info = {};
 	struct irdma_qp_host_ctx_info *ctx_info;
+	unsigned long flags;
 
 	err_code = irdma_validate_qp_attrs(init_attr, iwdev);
 	if (err_code)
@@ -895,10 +826,13 @@
 		      udata->outlen < IRDMA_CREATE_QP_MIN_RESP_LEN))
 		return -EINVAL;
 
+	sq_size = init_attr->cap.max_send_wr;
+	rq_size = init_attr->cap.max_recv_wr;
+
 	init_info.vsi = &iwdev->vsi;
 	init_info.qp_uk_init_info.uk_attrs = uk_attrs;
-	init_info.qp_uk_init_info.sq_size = init_attr->cap.max_send_wr;
-	init_info.qp_uk_init_info.rq_size = init_attr->cap.max_recv_wr;
+	init_info.qp_uk_init_info.sq_size = sq_size;
+	init_info.qp_uk_init_info.rq_size = rq_size;
 	init_info.qp_uk_init_info.max_sq_frag_cnt = init_attr->cap.max_send_sge;
 	init_info.qp_uk_init_info.max_rq_frag_cnt = init_attr->cap.max_recv_sge;
 	init_info.qp_uk_init_info.max_inline_data = init_attr->cap.max_inline_data;
@@ -940,7 +874,7 @@
 	iwqp->host_ctx.size = IRDMA_QP_CTX_SIZE;
 
 	init_info.pd = &iwpd->sc_pd;
-	init_info.qp_uk_init_info.qp_id = qp_num;
+	init_info.qp_uk_init_info.qp_id = iwqp->ibqp.qp_num;
 	if (!rdma_protocol_roce(&iwdev->ibdev, 1))
 		init_info.qp_uk_init_info.first_sq_wq = 1;
 	iwqp->ctx_info.qp_compl_ctx = (uintptr_t)qp;
@@ -948,9 +882,36 @@
 	init_waitqueue_head(&iwqp->mod_qp_waitq);
 
 	if (udata) {
+		err_code = ib_copy_from_udata(&req, udata,
+					      min(sizeof(req), udata->inlen));
+		if (err_code) {
+			ibdev_dbg(&iwdev->ibdev,
+				  "VERBS: ib_copy_from_data fail\n");
+			goto error;
+		}
+
+		iwqp->ctx_info.qp_compl_ctx = req.user_compl_ctx;
+		iwqp->user_mode = 1;
+		if (req.user_wqe_bufs) {
+			struct irdma_ucontext *ucontext =
+				rdma_udata_to_drv_context(udata,
+							  struct irdma_ucontext,
+							  ibucontext);
+
+			init_info.qp_uk_init_info.legacy_mode = ucontext->legacy_mode;
+			spin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);
+			iwqp->iwpbl = irdma_get_pbl((unsigned long)req.user_wqe_bufs,
+						    &ucontext->qp_reg_mem_list);
+			spin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);
+
+			if (!iwqp->iwpbl) {
+				err_code = -ENODATA;
+				ibdev_dbg(&iwdev->ibdev, "VERBS: no pbl info\n");
+				goto error;
+			}
+		}
 		init_info.qp_uk_init_info.abi_ver = iwpd->sc_pd.abi_ver;
-		err_code = irdma_setup_umode_qp(udata, iwdev, iwqp, &init_info,
-						init_attr);
+		irdma_setup_virt_qp(iwdev, iwqp, &init_info);
 	} else {
 		INIT_DELAYED_WORK(&iwqp->dwork_flush, irdma_flush_worker);
 		init_info.qp_uk_init_info.abi_ver = IRDMA_ABI_VER;
@@ -1005,6 +966,8 @@
 	spin_lock_init(&iwqp->sc_qp.pfpdu.lock);
 	iwqp->sig_all = (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) ? 1 : 0;
 	rf->qp_table[qp_num] = iwqp;
+	iwqp->max_send_wr = sq_size;
+	iwqp->max_recv_wr = rq_size;
 
 	if (rdma_protocol_roce(&iwdev->ibdev, 1)) {
 		if (dev->ws_add(&iwdev->vsi, 0)) {
@@ -1025,8 +988,8 @@
 			if (rdma_protocol_iwarp(&iwdev->ibdev, 1))
 				uresp.lsmm = 1;
 		}
-		uresp.actual_sq_size = init_info.qp_uk_init_info.sq_size;
-		uresp.actual_rq_size = init_info.qp_uk_init_info.rq_size;
+		uresp.actual_sq_size = sq_size;
+		uresp.actual_rq_size = rq_size;
 		uresp.qp_id = qp_num;
 		uresp.qp_caps = qp->qp_uk.qp_caps;
 
Index: drivers/infiniband/hw/irdma/verbs.h
===================================================================
--- drivers/infiniband/hw/irdma/verbs.h	(revision 55465)
+++ drivers/infiniband/hw/irdma/verbs.h	(revision 55464)
@@ -18,8 +18,7 @@
 	struct list_head qp_reg_mem_list;
 	spinlock_t qp_reg_mem_list_lock; /* protect QP memory list */
 	int abi_ver;
-	u8 legacy_mode : 1;
-	u8 use_raw_attrs : 1;
+	bool legacy_mode;
 };
 
 struct irdma_pd {
Index: drivers/infiniband/hw/irdma/uk.c
===================================================================
--- drivers/infiniband/hw/irdma/uk.c	(revision 55465)
+++ drivers/infiniband/hw/irdma/uk.c	(revision 55464)
@@ -1415,78 +1415,6 @@
 }
 
 /**
- * irdma_uk_calc_shift_wq - calculate WQE shift for both SQ and RQ
- * @ukinfo: qp initialization info
- * @sq_shift: Returns shift of SQ
- * @rq_shift: Returns shift of RQ
- */
-void irdma_uk_calc_shift_wq(struct irdma_qp_uk_init_info *ukinfo, u8 *sq_shift,
-			    u8 *rq_shift)
-{
-	bool imm_support = ukinfo->uk_attrs->hw_rev >= IRDMA_GEN_2;
-
-	irdma_get_wqe_shift(ukinfo->uk_attrs,
-			    imm_support ? ukinfo->max_sq_frag_cnt + 1 :
-					  ukinfo->max_sq_frag_cnt,
-			    ukinfo->max_inline_data, sq_shift);
-
-	irdma_get_wqe_shift(ukinfo->uk_attrs, ukinfo->max_rq_frag_cnt, 0,
-			    rq_shift);
-
-	if (ukinfo->uk_attrs->hw_rev == IRDMA_GEN_1) {
-		if (ukinfo->abi_ver > 4)
-			*rq_shift = IRDMA_MAX_RQ_WQE_SHIFT_GEN1;
-	}
-}
-
-/**
- * irdma_uk_calc_depth_shift_sq - calculate depth and shift for SQ size.
- * @ukinfo: qp initialization info
- * @sq_depth: Returns depth of SQ
- * @sq_shift: Returns shift of SQ
- */
-int irdma_uk_calc_depth_shift_sq(struct irdma_qp_uk_init_info *ukinfo,
-				 u32 *sq_depth, u8 *sq_shift)
-{
-	bool imm_support = ukinfo->uk_attrs->hw_rev >= IRDMA_GEN_2;
-	int status;
-
-	irdma_get_wqe_shift(ukinfo->uk_attrs,
-			    imm_support ? ukinfo->max_sq_frag_cnt + 1 :
-			    ukinfo->max_sq_frag_cnt,
-			    ukinfo->max_inline_data, sq_shift);
-	status = irdma_get_sqdepth(ukinfo->uk_attrs, ukinfo->sq_size,
-				   *sq_shift, sq_depth);
-
-	return status;
-}
-
-/**
- * irdma_uk_calc_depth_shift_rq - calculate depth and shift for RQ size.
- * @ukinfo: qp initialization info
- * @rq_depth: Returns depth of RQ
- * @rq_shift: Returns shift of RQ
- */
-int irdma_uk_calc_depth_shift_rq(struct irdma_qp_uk_init_info *ukinfo,
-				 u32 *rq_depth, u8 *rq_shift)
-{
-	int status;
-
-	irdma_get_wqe_shift(ukinfo->uk_attrs, ukinfo->max_rq_frag_cnt, 0,
-			    rq_shift);
-
-	if (ukinfo->uk_attrs->hw_rev == IRDMA_GEN_1) {
-		if (ukinfo->abi_ver > 4)
-			*rq_shift = IRDMA_MAX_RQ_WQE_SHIFT_GEN1;
-	}
-
-	status = irdma_get_rqdepth(ukinfo->uk_attrs, ukinfo->rq_size,
-				   *rq_shift, rq_depth);
-
-	return status;
-}
-
-/**
  * irdma_uk_qp_init - initialize shared qp
  * @qp: hw qp (user and kernel)
  * @info: qp initialization info
@@ -1500,6 +1428,7 @@
 {
 	int ret_code = 0;
 	u32 sq_ring_size;
+	u8 sqshift, rqshift;
 
 	qp->uk_attrs = info->uk_attrs;
 	if (info->max_sq_frag_cnt > qp->uk_attrs->max_hw_wq_frags ||
@@ -1506,6 +1435,16 @@
 	    info->max_rq_frag_cnt > qp->uk_attrs->max_hw_wq_frags)
 		return -EINVAL;
 
+	irdma_get_wqe_shift(qp->uk_attrs, info->max_rq_frag_cnt, 0, &rqshift);
+	if (qp->uk_attrs->hw_rev == IRDMA_GEN_1) {
+		irdma_get_wqe_shift(qp->uk_attrs, info->max_sq_frag_cnt,
+				    info->max_inline_data, &sqshift);
+		if (info->abi_ver > 4)
+			rqshift = IRDMA_MAX_RQ_WQE_SHIFT_GEN1;
+	} else {
+		irdma_get_wqe_shift(qp->uk_attrs, info->max_sq_frag_cnt + 1,
+				    info->max_inline_data, &sqshift);
+	}
 	qp->qp_caps = info->qp_caps;
 	qp->sq_base = info->sq;
 	qp->rq_base = info->rq;
@@ -1519,7 +1458,7 @@
 	qp->sq_size = info->sq_size;
 	qp->push_mode = false;
 	qp->max_sq_frag_cnt = info->max_sq_frag_cnt;
-	sq_ring_size = qp->sq_size << info->sq_shift;
+	sq_ring_size = qp->sq_size << sqshift;
 	IRDMA_RING_INIT(qp->sq_ring, sq_ring_size);
 	IRDMA_RING_INIT(qp->initial_ring, sq_ring_size);
 	if (info->first_sq_wq) {
@@ -1534,9 +1473,9 @@
 	qp->rq_size = info->rq_size;
 	qp->max_rq_frag_cnt = info->max_rq_frag_cnt;
 	qp->max_inline_data = info->max_inline_data;
-	qp->rq_wqe_size = info->rq_shift;
+	qp->rq_wqe_size = rqshift;
 	IRDMA_RING_INIT(qp->rq_ring, qp->rq_size);
-	qp->rq_wqe_size_multiplier = 1 << info->rq_shift;
+	qp->rq_wqe_size_multiplier = 1 << rqshift;
 	if (qp->uk_attrs->hw_rev == IRDMA_GEN_1)
 		qp->wqe_ops = iw_wqe_uk_ops_gen_1;
 	else
Index: drivers/infiniband/hw/irdma/user.h
===================================================================
--- drivers/infiniband/hw/irdma/user.h	(revision 55465)
+++ drivers/infiniband/hw/irdma/user.h	(revision 55464)
@@ -295,12 +295,6 @@
 		      struct irdma_cq_uk_init_info *info);
 int irdma_uk_qp_init(struct irdma_qp_uk *qp,
 		     struct irdma_qp_uk_init_info *info);
-void irdma_uk_calc_shift_wq(struct irdma_qp_uk_init_info *ukinfo, u8 *sq_shift,
-			    u8 *rq_shift);
-int irdma_uk_calc_depth_shift_sq(struct irdma_qp_uk_init_info *ukinfo,
-				 u32 *sq_depth, u8 *sq_shift);
-int irdma_uk_calc_depth_shift_rq(struct irdma_qp_uk_init_info *ukinfo,
-				 u32 *rq_depth, u8 *rq_shift);
 struct irdma_sq_uk_wr_trk_info {
 	u64 wrid;
 	u32 wr_len;
@@ -380,12 +374,8 @@
 	u32 max_sq_frag_cnt;
 	u32 max_rq_frag_cnt;
 	u32 max_inline_data;
-	u32 sq_depth;
-	u32 rq_depth;
 	u8 first_sq_wq;
 	u8 type;
-	u8 sq_shift;
-	u8 rq_shift;
 	int abi_ver;
 	bool legacy_mode;
 };
Index: drivers/infiniband/hw/hns/hns_roce_hw_v2.c
===================================================================
--- drivers/infiniband/hw/hns/hns_roce_hw_v2.c	(revision 55465)
+++ drivers/infiniband/hw/hns/hns_roce_hw_v2.c	(revision 55464)
@@ -4886,15 +4886,12 @@
 			   struct hns_roce_congestion_algorithm *cong_alg)
 {
 	struct hns_roce_dev *hr_dev = to_hr_dev(ibqp->device);
-	struct hns_roce_qp *hr_qp = to_hr_qp(ibqp);
 
-	if (ibqp->qp_type == IB_QPT_UD || ibqp->qp_type == IB_QPT_GSI)
-		hr_qp->cong_type = CONG_TYPE_DCQCN;
-	else
-		hr_qp->cong_type = hr_dev->caps.cong_type;
+	if (ibqp->qp_type == IB_QPT_UD)
+		hr_dev->caps.cong_type = CONG_TYPE_DCQCN;
 
 	/* different congestion types match different configurations */
-	switch (hr_qp->cong_type) {
+	switch (hr_dev->caps.cong_type) {
 	case CONG_TYPE_DCQCN:
 		cong_alg->alg_sel = CONG_DCQCN;
 		cong_alg->alg_sub_sel = UNSUPPORT_CONG_LEVEL;
@@ -4922,8 +4919,8 @@
 	default:
 		ibdev_warn(&hr_dev->ib_dev,
 			   "invalid type(%u) for congestion selection.\n",
-			   hr_qp->cong_type);
-		hr_qp->cong_type = CONG_TYPE_DCQCN;
+			   hr_dev->caps.cong_type);
+		hr_dev->caps.cong_type = CONG_TYPE_DCQCN;
 		cong_alg->alg_sel = CONG_DCQCN;
 		cong_alg->alg_sub_sel = UNSUPPORT_CONG_LEVEL;
 		cong_alg->dip_vld = DIP_INVALID;
@@ -4942,7 +4939,6 @@
 	struct hns_roce_congestion_algorithm cong_field;
 	struct ib_device *ibdev = ibqp->device;
 	struct hns_roce_dev *hr_dev = to_hr_dev(ibdev);
-	struct hns_roce_qp *hr_qp = to_hr_qp(ibqp);
 	u32 dip_idx = 0;
 	int ret;
 
@@ -4955,7 +4951,7 @@
 		return ret;
 
 	hr_reg_write(context, QPC_CONG_ALGO_TMPL_ID, hr_dev->cong_algo_tmpl_id +
-		     hr_qp->cong_type * HNS_ROCE_CONG_SIZE);
+		     hr_dev->caps.cong_type * HNS_ROCE_CONG_SIZE);
 	hr_reg_clear(qpc_mask, QPC_CONG_ALGO_TMPL_ID);
 	hr_reg_write(&context->ext, QPCEX_CONG_ALG_SEL, cong_field.alg_sel);
 	hr_reg_clear(&qpc_mask->ext, QPCEX_CONG_ALG_SEL);
Index: drivers/infiniband/hw/hns/hns_roce_device.h
===================================================================
--- drivers/infiniband/hw/hns/hns_roce_device.h	(revision 55465)
+++ drivers/infiniband/hw/hns/hns_roce_device.h	(revision 55464)
@@ -595,13 +595,6 @@
 	u32 queue_num;
 };
 
-enum hns_roce_cong_type {
-	CONG_TYPE_DCQCN,
-	CONG_TYPE_LDCP,
-	CONG_TYPE_HC3,
-	CONG_TYPE_DIP,
-};
-
 struct hns_roce_qp {
 	struct ib_qp		ibqp;
 	struct hns_roce_wq	rq;
@@ -646,7 +639,6 @@
 	struct list_head	sq_node; /* all send qps are on a list */
 	struct hns_user_mmap_entry *dwqe_mmap_entry;
 	u32			config;
-	enum hns_roce_cong_type	cong_type;
 };
 
 struct hns_roce_ib_iboe {
@@ -718,6 +710,13 @@
 	struct hns_roce_eq	*eq;
 };
 
+enum cong_type {
+	CONG_TYPE_DCQCN,
+	CONG_TYPE_LDCP,
+	CONG_TYPE_HC3,
+	CONG_TYPE_DIP,
+};
+
 struct hns_roce_caps {
 	u64		fw_ver;
 	u8		num_ports;
@@ -848,7 +847,7 @@
 	u16		default_aeq_period;
 	u16		default_aeq_arm_st;
 	u16		default_ceq_arm_st;
-	enum hns_roce_cong_type cong_type;
+	enum cong_type	cong_type;
 };
 
 enum hns_roce_device_state {
Index: drivers/infiniband/hw/mlx5/devx.c
===================================================================
--- drivers/infiniband/hw/mlx5/devx.c	(revision 55465)
+++ drivers/infiniband/hw/mlx5/devx.c	(revision 55464)
@@ -2951,7 +2951,7 @@
 	MLX5_IB_METHOD_DEVX_OBJ_MODIFY,
 	UVERBS_ATTR_IDR(MLX5_IB_ATTR_DEVX_OBJ_MODIFY_HANDLE,
 			UVERBS_IDR_ANY_OBJECT,
-			UVERBS_ACCESS_READ,
+			UVERBS_ACCESS_WRITE,
 			UA_MANDATORY),
 	UVERBS_ATTR_PTR_IN(
 		MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN,
Index: drivers/infiniband/hw/mlx5/wr.c
===================================================================
--- drivers/infiniband/hw/mlx5/wr.c	(revision 55465)
+++ drivers/infiniband/hw/mlx5/wr.c	(revision 55464)
@@ -78,7 +78,7 @@
 		 */
 		copysz = min_t(u64, *cur_edge - (void *)eseg->inline_hdr.start,
 			       left);
-		memcpy(eseg->inline_hdr.data, pdata, copysz);
+		memcpy(eseg->inline_hdr.start, pdata, copysz);
 		stride = ALIGN(sizeof(struct mlx5_wqe_eth_seg) -
 			       sizeof(eseg->inline_hdr.start) + copysz, 16);
 		*size += stride / 16;
Index: drivers/infiniband/ulp/srpt/ib_srpt.c
===================================================================
--- drivers/infiniband/ulp/srpt/ib_srpt.c	(revision 55465)
+++ drivers/infiniband/ulp/srpt/ib_srpt.c	(revision 55464)
@@ -3209,6 +3209,7 @@
 
 	INIT_IB_EVENT_HANDLER(&sdev->event_handler, sdev->device,
 			      srpt_event_handler);
+	ib_register_event_handler(&sdev->event_handler);
 
 	for (i = 1; i <= sdev->device->phys_port_cnt; i++) {
 		sport = &sdev->port[i - 1];
@@ -3231,7 +3232,6 @@
 		}
 	}
 
-	ib_register_event_handler(&sdev->event_handler);
 	spin_lock(&srpt_dev_lock);
 	list_add_tail(&sdev->list, &srpt_dev_list);
 	spin_unlock(&srpt_dev_lock);
@@ -3242,6 +3242,7 @@
 
 err_port:
 	srpt_unregister_mad_agent(sdev, i);
+	ib_unregister_event_handler(&sdev->event_handler);
 err_cm:
 	if (sdev->cm_id)
 		ib_destroy_cm_id(sdev->cm_id);
Index: drivers/infiniband/ulp/rtrs/rtrs-clt-sysfs.c
===================================================================
--- drivers/infiniband/ulp/rtrs/rtrs-clt-sysfs.c	(revision 55465)
+++ drivers/infiniband/ulp/rtrs/rtrs-clt-sysfs.c	(revision 55464)
@@ -133,7 +133,7 @@
 
 	/* distinguish "mi" and "min-latency" with length */
 	len = strnlen(buf, NAME_MAX);
-	if (len && buf[len - 1] == '\n')
+	if (buf[len - 1] == '\n')
 		len--;
 
 	if (!strncasecmp(buf, "round-robin", 11) ||
Index: drivers/input/keyboard/gpio_keys_polled.c
===================================================================
--- drivers/input/keyboard/gpio_keys_polled.c	(revision 55465)
+++ drivers/input/keyboard/gpio_keys_polled.c	(revision 55464)
@@ -319,10 +319,12 @@
 
 			error = devm_gpio_request_one(dev, button->gpio,
 					flags, button->desc ? : DRV_NAME);
-			if (error)
-				return dev_err_probe(dev, error,
-						     "unable to claim gpio %u\n",
-						     button->gpio);
+			if (error) {
+				dev_err(dev,
+					"unable to claim gpio %u, err=%d\n",
+					button->gpio, error);
+				return error;
+			}
 
 			bdata->gpiod = gpio_to_desc(button->gpio);
 			if (!bdata->gpiod) {
Index: drivers/iommu/intel/perfmon.c
===================================================================
--- drivers/iommu/intel/perfmon.c	(revision 55465)
+++ drivers/iommu/intel/perfmon.c	(nonexistent)
@@ -1,172 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Support Intel IOMMU PerfMon
- * Copyright(c) 2023 Intel Corporation.
- */
-#define pr_fmt(fmt)	"DMAR: " fmt
-#define dev_fmt(fmt)	pr_fmt(fmt)
-
-#include <linux/dmar.h>
-#include "iommu.h"
-#include "perfmon.h"
-
-static inline void __iomem *
-get_perf_reg_address(struct intel_iommu *iommu, u32 offset)
-{
-	u32 off = dmar_readl(iommu->reg + offset);
-
-	return iommu->reg + off;
-}
-
-int alloc_iommu_pmu(struct intel_iommu *iommu)
-{
-	struct iommu_pmu *iommu_pmu;
-	int i, j, ret;
-	u64 perfcap;
-	u32 cap;
-
-	if (!ecap_pms(iommu->ecap))
-		return 0;
-
-	/* The IOMMU PMU requires the ECMD support as well */
-	if (!cap_ecmds(iommu->cap))
-		return -ENODEV;
-
-	perfcap = dmar_readq(iommu->reg + DMAR_PERFCAP_REG);
-	/* The performance monitoring is not supported. */
-	if (!perfcap)
-		return -ENODEV;
-
-	/* Sanity check for the number of the counters and event groups */
-	if (!pcap_num_cntr(perfcap) || !pcap_num_event_group(perfcap))
-		return -ENODEV;
-
-	/* The interrupt on overflow is required */
-	if (!pcap_interrupt(perfcap))
-		return -ENODEV;
-
-	iommu_pmu = kzalloc(sizeof(*iommu_pmu), GFP_KERNEL);
-	if (!iommu_pmu)
-		return -ENOMEM;
-
-	iommu_pmu->num_cntr = pcap_num_cntr(perfcap);
-	iommu_pmu->cntr_width = pcap_cntr_width(perfcap);
-	iommu_pmu->filter = pcap_filters_mask(perfcap);
-	iommu_pmu->cntr_stride = pcap_cntr_stride(perfcap);
-	iommu_pmu->num_eg = pcap_num_event_group(perfcap);
-
-	iommu_pmu->evcap = kcalloc(iommu_pmu->num_eg, sizeof(u64), GFP_KERNEL);
-	if (!iommu_pmu->evcap) {
-		ret = -ENOMEM;
-		goto free_pmu;
-	}
-
-	/* Parse event group capabilities */
-	for (i = 0; i < iommu_pmu->num_eg; i++) {
-		u64 pcap;
-
-		pcap = dmar_readq(iommu->reg + DMAR_PERFEVNTCAP_REG +
-				  i * IOMMU_PMU_CAP_REGS_STEP);
-		iommu_pmu->evcap[i] = pecap_es(pcap);
-	}
-
-	iommu_pmu->cntr_evcap = kcalloc(iommu_pmu->num_cntr, sizeof(u32 *), GFP_KERNEL);
-	if (!iommu_pmu->cntr_evcap) {
-		ret = -ENOMEM;
-		goto free_pmu_evcap;
-	}
-	for (i = 0; i < iommu_pmu->num_cntr; i++) {
-		iommu_pmu->cntr_evcap[i] = kcalloc(iommu_pmu->num_eg, sizeof(u32), GFP_KERNEL);
-		if (!iommu_pmu->cntr_evcap[i]) {
-			ret = -ENOMEM;
-			goto free_pmu_cntr_evcap;
-		}
-		/*
-		 * Set to the global capabilities, will adjust according
-		 * to per-counter capabilities later.
-		 */
-		for (j = 0; j < iommu_pmu->num_eg; j++)
-			iommu_pmu->cntr_evcap[i][j] = (u32)iommu_pmu->evcap[j];
-	}
-
-	iommu_pmu->cfg_reg = get_perf_reg_address(iommu, DMAR_PERFCFGOFF_REG);
-	iommu_pmu->cntr_reg = get_perf_reg_address(iommu, DMAR_PERFCNTROFF_REG);
-	iommu_pmu->overflow = get_perf_reg_address(iommu, DMAR_PERFOVFOFF_REG);
-
-	/*
-	 * Check per-counter capabilities. All counters should have the
-	 * same capabilities on Interrupt on Overflow Support and Counter
-	 * Width.
-	 */
-	for (i = 0; i < iommu_pmu->num_cntr; i++) {
-		cap = dmar_readl(iommu_pmu->cfg_reg +
-				 i * IOMMU_PMU_CFG_OFFSET +
-				 IOMMU_PMU_CFG_CNTRCAP_OFFSET);
-		if (!iommu_cntrcap_pcc(cap))
-			continue;
-
-		/*
-		 * It's possible that some counters have a different
-		 * capability because of e.g., HW bug. Check the corner
-		 * case here and simply drop those counters.
-		 */
-		if ((iommu_cntrcap_cw(cap) != iommu_pmu->cntr_width) ||
-		    !iommu_cntrcap_ios(cap)) {
-			iommu_pmu->num_cntr = i;
-			pr_warn("PMU counter capability inconsistent, counter number reduced to %d\n",
-				iommu_pmu->num_cntr);
-		}
-
-		/* Clear the pre-defined events group */
-		for (j = 0; j < iommu_pmu->num_eg; j++)
-			iommu_pmu->cntr_evcap[i][j] = 0;
-
-		/* Override with per-counter event capabilities */
-		for (j = 0; j < iommu_cntrcap_egcnt(cap); j++) {
-			cap = dmar_readl(iommu_pmu->cfg_reg + i * IOMMU_PMU_CFG_OFFSET +
-					 IOMMU_PMU_CFG_CNTREVCAP_OFFSET +
-					 (j * IOMMU_PMU_OFF_REGS_STEP));
-			iommu_pmu->cntr_evcap[i][iommu_event_group(cap)] = iommu_event_select(cap);
-			/*
-			 * Some events may only be supported by a specific counter.
-			 * Track them in the evcap as well.
-			 */
-			iommu_pmu->evcap[iommu_event_group(cap)] |= iommu_event_select(cap);
-		}
-	}
-
-	iommu_pmu->iommu = iommu;
-	iommu->pmu = iommu_pmu;
-
-	return 0;
-
-free_pmu_cntr_evcap:
-	for (i = 0; i < iommu_pmu->num_cntr; i++)
-		kfree(iommu_pmu->cntr_evcap[i]);
-	kfree(iommu_pmu->cntr_evcap);
-free_pmu_evcap:
-	kfree(iommu_pmu->evcap);
-free_pmu:
-	kfree(iommu_pmu);
-
-	return ret;
-}
-
-void free_iommu_pmu(struct intel_iommu *iommu)
-{
-	struct iommu_pmu *iommu_pmu = iommu->pmu;
-
-	if (!iommu_pmu)
-		return;
-
-	if (iommu_pmu->evcap) {
-		int i;
-
-		for (i = 0; i < iommu_pmu->num_cntr; i++)
-			kfree(iommu_pmu->cntr_evcap[i]);
-		kfree(iommu_pmu->cntr_evcap);
-	}
-	kfree(iommu_pmu->evcap);
-	kfree(iommu_pmu);
-	iommu->pmu = NULL;
-}
Index: drivers/iommu/intel/perfmon.h
===================================================================
--- drivers/iommu/intel/perfmon.h	(revision 55465)
+++ drivers/iommu/intel/perfmon.h	(nonexistent)
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/*
- * PERFCFGOFF_REG, PERFFRZOFF_REG
- * PERFOVFOFF_REG, PERFCNTROFF_REG
- */
-#define IOMMU_PMU_NUM_OFF_REGS			4
-#define IOMMU_PMU_OFF_REGS_STEP			4
-
-#define IOMMU_PMU_CFG_OFFSET			0x100
-#define IOMMU_PMU_CFG_CNTRCAP_OFFSET		0x80
-#define IOMMU_PMU_CFG_CNTREVCAP_OFFSET		0x84
-#define IOMMU_PMU_CFG_SIZE			0x8
-#define IOMMU_PMU_CFG_FILTERS_OFFSET		0x4
-
-#define IOMMU_PMU_CAP_REGS_STEP			8
-
-#define iommu_cntrcap_pcc(p)			((p) & 0x1)
-#define iommu_cntrcap_cw(p)			(((p) >> 8) & 0xff)
-#define iommu_cntrcap_ios(p)			(((p) >> 16) & 0x1)
-#define iommu_cntrcap_egcnt(p)			(((p) >> 28) & 0xf)
-
-#define iommu_event_select(p)			((p) & 0xfffffff)
-#define iommu_event_group(p)			(((p) >> 28) & 0xf)
-
-#ifdef CONFIG_INTEL_IOMMU_PERF_EVENTS
-int alloc_iommu_pmu(struct intel_iommu *iommu);
-void free_iommu_pmu(struct intel_iommu *iommu);
-#else
-static inline int
-alloc_iommu_pmu(struct intel_iommu *iommu)
-{
-	return 0;
-}
-
-static inline void
-free_iommu_pmu(struct intel_iommu *iommu)
-{
-}
-#endif /* CONFIG_INTEL_IOMMU_PERF_EVENTS */
Index: drivers/iommu/intel/dmar.c
===================================================================
--- drivers/iommu/intel/dmar.c	(revision 55465)
+++ drivers/iommu/intel/dmar.c	(revision 55464)
@@ -34,7 +34,6 @@
 #include "../irq_remapping.h"
 #include "perf.h"
 #include "trace.h"
-#include "perfmon.h"
 
 typedef int (*dmar_res_handler_t)(struct acpi_dmar_header *, void *);
 struct dmar_res_callback {
@@ -1105,9 +1104,6 @@
 	if (sts & DMA_GSTS_QIES)
 		iommu->gcmd |= DMA_GCMD_QIE;
 
-	if (alloc_iommu_pmu(iommu))
-		pr_debug("Cannot alloc PMU for iommu (seq_id = %d)\n", iommu->seq_id);
-
 	raw_spin_lock_init(&iommu->register_lock);
 
 	/*
@@ -1135,7 +1131,6 @@
 err_sysfs:
 	iommu_device_sysfs_remove(&iommu->iommu);
 err_unmap:
-	free_iommu_pmu(iommu);
 	unmap_iommu(iommu);
 error_free_seq_id:
 	ida_free(&dmar_seq_ids, iommu->seq_id);
@@ -1151,8 +1146,6 @@
 		iommu_device_sysfs_remove(&iommu->iommu);
 	}
 
-	free_iommu_pmu(iommu);
-
 	if (iommu->irq) {
 		if (iommu->pr_irq) {
 			free_irq(iommu->pr_irq, iommu);
Index: drivers/iommu/intel/iommu.h
===================================================================
--- drivers/iommu/intel/iommu.h	(revision 55465)
+++ drivers/iommu/intel/iommu.h	(revision 55464)
@@ -125,11 +125,6 @@
 #define DMAR_MTRR_PHYSMASK8_REG 0x208
 #define DMAR_MTRR_PHYSBASE9_REG 0x210
 #define DMAR_MTRR_PHYSMASK9_REG 0x218
-#define DMAR_PERFCAP_REG	0x300
-#define DMAR_PERFCFGOFF_REG	0x310
-#define DMAR_PERFOVFOFF_REG	0x318
-#define DMAR_PERFCNTROFF_REG	0x31c
-#define DMAR_PERFEVNTCAP_REG	0x380
 #define DMAR_VCCAP_REG		0xe30 /* Virtual command capability register */
 #define DMAR_VCMD_REG		0xe00 /* Virtual command register */
 #define DMAR_VCRSP_REG		0xe10 /* Virtual command response register */
@@ -153,7 +148,6 @@
  */
 #define cap_esrtps(c)		(((c) >> 63) & 1)
 #define cap_esirtps(c)		(((c) >> 62) & 1)
-#define cap_ecmds(c)		(((c) >> 61) & 1)
 #define cap_fl5lp_support(c)	(((c) >> 60) & 1)
 #define cap_pi_support(c)	(((c) >> 59) & 1)
 #define cap_fl1gp_support(c)	(((c) >> 56) & 1)
@@ -185,8 +179,7 @@
  * Extended Capability Register
  */
 
-#define ecap_pms(e)		(((e) >> 51) & 0x1)
-#define ecap_rps(e)		(((e) >> 49) & 0x1)
+#define	ecap_rps(e)		(((e) >> 49) & 0x1)
 #define ecap_smpwc(e)		(((e) >> 48) & 0x1)
 #define ecap_flts(e)		(((e) >> 47) & 0x1)
 #define ecap_slts(e)		(((e) >> 46) & 0x1)
@@ -217,22 +210,6 @@
 #define ecap_max_handle_mask(e) (((e) >> 20) & 0xf)
 #define ecap_sc_support(e)	(((e) >> 7) & 0x1) /* Snooping Control */
 
-/*
- * Decoding Perf Capability Register
- */
-#define pcap_num_cntr(p)	((p) & 0xffff)
-#define pcap_cntr_width(p)	(((p) >> 16) & 0x7f)
-#define pcap_num_event_group(p)	(((p) >> 24) & 0x1f)
-#define pcap_filters_mask(p)	(((p) >> 32) & 0x1f)
-#define pcap_interrupt(p)	(((p) >> 50) & 0x1)
-/* The counter stride is calculated as 2 ^ (x+10) bytes */
-#define pcap_cntr_stride(p)	(1ULL << ((((p) >> 52) & 0x7) + 10))
-
-/*
- * Decoding Perf Event Capability Register
- */
-#define pecap_es(p)		((p) & 0xfffffff)
-
 /* Virtual command interface capability */
 #define vccap_pasid(v)		(((v) & DMA_VCS_PAS)) /* PASID allocation */
 
@@ -584,22 +561,6 @@
 					   iommu core */
 };
 
-struct iommu_pmu {
-	struct intel_iommu	*iommu;
-	u32			num_cntr;	/* Number of counters */
-	u32			num_eg;		/* Number of event group */
-	u32			cntr_width;	/* Counter width */
-	u32			cntr_stride;	/* Counter Stride */
-	u32			filter;		/* Bitmask of filter support */
-	void __iomem		*base;		/* the PerfMon base address */
-	void __iomem		*cfg_reg;	/* counter configuration base address */
-	void __iomem		*cntr_reg;	/* counter 0 address*/
-	void __iomem		*overflow;	/* overflow status register */
-
-	u64			*evcap;		/* Indicates all supported events */
-	u32			**cntr_evcap;	/* Supported events of each counter. */
-};
-
 struct intel_iommu {
 	void __iomem	*reg; /* Pointer to hardware regs, virtual addr */
 	u64 		reg_phys; /* physical address of hw register set */
@@ -647,8 +608,6 @@
 
 	struct dmar_drhd_unit *drhd;
 	void *perf_statistic;
-
-	struct iommu_pmu *pmu;
 };
 
 /* PCI domain-device relationship */
Index: drivers/iommu/intel/pasid.c
===================================================================
--- drivers/iommu/intel/pasid.c	(revision 55465)
+++ drivers/iommu/intel/pasid.c	(revision 55464)
@@ -435,9 +435,6 @@
 	if (!info || !info->ats_enabled)
 		return;
 
-	if (pci_dev_is_disconnected(to_pci_dev(dev)))
-		return;
-
 	sid = info->bus << 8 | info->devfn;
 	qdep = info->ats_qdep;
 	pfsid = info->pfsid;
Index: drivers/iommu/intel/Kconfig
===================================================================
--- drivers/iommu/intel/Kconfig	(revision 55465)
+++ drivers/iommu/intel/Kconfig	(revision 55464)
@@ -96,15 +96,4 @@
 	  passing intel_iommu=sm_on to the kernel. If not sure, please use
 	  the default value.
 
-config INTEL_IOMMU_PERF_EVENTS
-	def_bool y
-	bool "Intel IOMMU performance events"
-	depends on INTEL_IOMMU && PERF_EVENTS
-	help
-	  Selecting this option will enable the performance monitoring
-	  infrastructure in the Intel IOMMU. It collects information about
-	  key events occurring during operation of the remapping hardware,
-	  to aid performance tuning and debug. These are available on modern
-	  processors which support Intel VT-d 4.0 and later.
-
 endif # INTEL_IOMMU
Index: drivers/iommu/intel/Makefile
===================================================================
--- drivers/iommu/intel/Makefile	(revision 55465)
+++ drivers/iommu/intel/Makefile	(revision 55464)
@@ -5,7 +5,4 @@
 obj-$(CONFIG_DMAR_PERF) += perf.o
 obj-$(CONFIG_INTEL_IOMMU_DEBUGFS) += debugfs.o
 obj-$(CONFIG_INTEL_IOMMU_SVM) += svm.o
-ifdef CONFIG_INTEL_IOMMU
 obj-$(CONFIG_IRQ_REMAP) += irq_remapping.o
-endif
-obj-$(CONFIG_INTEL_IOMMU_PERF_EVENTS) += perfmon.o
Index: drivers/iommu/amd/init.c
===================================================================
--- drivers/iommu/amd/init.c	(revision 55465)
+++ drivers/iommu/amd/init.c	(revision 55464)
@@ -2047,9 +2047,6 @@
 	/* Prevent binding other PCI device drivers to IOMMU devices */
 	iommu->dev->match_driver = false;
 
-	/* ACPI _PRT won't have an IRQ for IOMMU */
-	iommu->dev->irq_managed = 1;
-
 	pci_read_config_dword(iommu->dev, cap_ptr + MMIO_CAP_HDR_OFFSET,
 			      &iommu->cap);
 
Index: drivers/iommu/Kconfig
===================================================================
--- drivers/iommu/Kconfig	(revision 55465)
+++ drivers/iommu/Kconfig	(revision 55464)
@@ -192,7 +192,7 @@
 config IRQ_REMAP
 	bool "Support for Interrupt Remapping"
 	depends on X86_64 && X86_IO_APIC && PCI_MSI && ACPI
-	select DMAR_TABLE if INTEL_IOMMU
+	select DMAR_TABLE
 	help
 	  Supports Interrupt remapping for IO-APIC and MSI devices.
 	  To use x2apic mode in the CPU's which support x2APIC enhancements or
Index: drivers/iommu/irq_remapping.c
===================================================================
--- drivers/iommu/irq_remapping.c	(revision 55465)
+++ drivers/iommu/irq_remapping.c	(revision 55464)
@@ -99,8 +99,7 @@
 	if (disable_irq_remap)
 		return -ENOSYS;
 
-	if (IS_ENABLED(CONFIG_INTEL_IOMMU) &&
-	    intel_irq_remap_ops.prepare() == 0)
+	if (intel_irq_remap_ops.prepare() == 0)
 		remap_ops = &intel_irq_remap_ops;
 	else if (IS_ENABLED(CONFIG_AMD_IOMMU) &&
 		 amd_iommu_irq_ops.prepare() == 0)
Index: drivers/mmc/host/wmt-sdmmc.c
===================================================================
--- drivers/mmc/host/wmt-sdmmc.c	(revision 55465)
+++ drivers/mmc/host/wmt-sdmmc.c	(revision 55464)
@@ -886,6 +886,7 @@
 {
 	struct mmc_host *mmc;
 	struct wmt_mci_priv *priv;
+	struct resource *res;
 	u32 reg_tmp;
 
 	mmc = platform_get_drvdata(pdev);
@@ -913,6 +914,9 @@
 	clk_disable_unprepare(priv->clk_sdmmc);
 	clk_put(priv->clk_sdmmc);
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
 	mmc_free_host(mmc);
 
 	dev_info(&pdev->dev, "WMT MCI device removed\n");
Index: drivers/mtd/nand/raw/lpc32xx_mlc.c
===================================================================
--- drivers/mtd/nand/raw/lpc32xx_mlc.c	(revision 55465)
+++ drivers/mtd/nand/raw/lpc32xx_mlc.c	(revision 55464)
@@ -303,9 +303,8 @@
 	return 0;
 }
 
-static irqreturn_t lpc3xxx_nand_irq(int irq, void *data)
+static irqreturn_t lpc3xxx_nand_irq(int irq, struct lpc32xx_nand_host *host)
 {
-	struct lpc32xx_nand_host *host = data;
 	uint8_t sr;
 
 	/* Clear interrupt flag by reading status */
@@ -780,7 +779,7 @@
 		goto release_dma_chan;
 	}
 
-	if (request_irq(host->irq, &lpc3xxx_nand_irq,
+	if (request_irq(host->irq, (irq_handler_t)&lpc3xxx_nand_irq,
 			IRQF_TRIGGER_HIGH, DRV_NAME, host)) {
 		dev_err(&pdev->dev, "Error requesting NAND IRQ\n");
 		res = -ENXIO;
Index: drivers/mtd/maps/physmap-core.c
===================================================================
--- drivers/mtd/maps/physmap-core.c	(revision 55465)
+++ drivers/mtd/maps/physmap-core.c	(revision 55464)
@@ -524,7 +524,7 @@
 		if (!info->maps[i].phys)
 			info->maps[i].phys = res->start;
 
-		info->win_order = fls64(resource_size(res)) - 1;
+		info->win_order = get_bitmask_order(resource_size(res)) - 1;
 		info->maps[i].size = BIT(info->win_order +
 					 (info->gpios ?
 					  info->gpios->ndescs : 0));
Index: drivers/net/dsa/mt7530.c
===================================================================
--- drivers/net/dsa/mt7530.c	(revision 55465)
+++ drivers/net/dsa/mt7530.c	(revision 55464)
@@ -992,56 +992,20 @@
 	mutex_unlock(&priv->reg_mutex);
 }
 
-/* On page 205, section "8.6.3 Frame filtering" of the active standard, IEEE Std
- * 802.1Q-2022, it is stated that frames with 01:80:C2:00:00:00-0F as MAC DA
- * must only be propagated to C-VLAN and MAC Bridge components. That means
- * VLAN-aware and VLAN-unaware bridges. On the switch designs with CPU ports,
- * these frames are supposed to be processed by the CPU (software). So we make
- * the switch only forward them to the CPU port. And if received from a CPU
- * port, forward to a single port. The software is responsible of making the
- * switch conform to the latter by setting a single port as destination port on
- * the special tag.
- *
- * This switch intellectual property cannot conform to this part of the standard
- * fully. Whilst the REV_UN frame tag covers the remaining :04-0D and :0F MAC
- * DAs, it also includes :22-FF which the scope of propagation is not supposed
- * to be restricted for these MAC DAs.
- */
 static void
 mt753x_trap_frames(struct mt7530_priv *priv)
 {
-	/* Trap 802.1X PAE frames and BPDUs to the CPU port(s) and egress them
-	 * VLAN-untagged.
-	 */
-	mt7530_rmw(priv, MT753X_BPC, MT753X_PAE_EG_TAG_MASK |
-		   MT753X_PAE_PORT_FW_MASK | MT753X_BPDU_EG_TAG_MASK |
-		   MT753X_BPDU_PORT_FW_MASK,
-		   MT753X_PAE_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
-		   MT753X_PAE_PORT_FW(MT753X_BPDU_CPU_ONLY) |
-		   MT753X_BPDU_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
+	/* Trap BPDUs to the CPU port(s) */
+	mt7530_rmw(priv, MT753X_BPC, MT753X_BPDU_PORT_FW_MASK,
 		   MT753X_BPDU_CPU_ONLY);
 
-	/* Trap frames with :01 and :02 MAC DAs to the CPU port(s) and egress
-	 * them VLAN-untagged.
-	 */
-	mt7530_rmw(priv, MT753X_RGAC1, MT753X_R02_EG_TAG_MASK |
-		   MT753X_R02_PORT_FW_MASK | MT753X_R01_EG_TAG_MASK |
-		   MT753X_R01_PORT_FW_MASK,
-		   MT753X_R02_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
-		   MT753X_R02_PORT_FW(MT753X_BPDU_CPU_ONLY) |
-		   MT753X_R01_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
-		   MT753X_BPDU_CPU_ONLY);
+	/* Trap 802.1X PAE frames to the CPU port(s) */
+	mt7530_rmw(priv, MT753X_BPC, MT753X_PAE_PORT_FW_MASK,
+		   MT753X_PAE_PORT_FW(MT753X_BPDU_CPU_ONLY));
 
-	/* Trap frames with :03 and :0E MAC DAs to the CPU port(s) and egress
-	 * them VLAN-untagged.
-	 */
-	mt7530_rmw(priv, MT753X_RGAC2, MT753X_R0E_EG_TAG_MASK |
-		   MT753X_R0E_PORT_FW_MASK | MT753X_R03_EG_TAG_MASK |
-		   MT753X_R03_PORT_FW_MASK,
-		   MT753X_R0E_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
-		   MT753X_R0E_PORT_FW(MT753X_BPDU_CPU_ONLY) |
-		   MT753X_R03_EG_TAG(MT7530_VLAN_EG_UNTAGGED) |
-		   MT753X_BPDU_CPU_ONLY);
+	/* Trap LLDP frames with :0E MAC DA to the CPU port(s) */
+	mt7530_rmw(priv, MT753X_RGAC2, MT753X_R0E_PORT_FW_MASK,
+		   MT753X_R0E_PORT_FW(MT753X_BPDU_CPU_ONLY));
 }
 
 static int
@@ -2269,11 +2233,11 @@
 	 */
 	if (priv->mcm) {
 		reset_control_assert(priv->rstc);
-		usleep_range(5000, 5100);
+		usleep_range(1000, 1100);
 		reset_control_deassert(priv->rstc);
 	} else {
 		gpiod_set_value_cansleep(priv->reset, 0);
-		usleep_range(5000, 5100);
+		usleep_range(1000, 1100);
 		gpiod_set_value_cansleep(priv->reset, 1);
 	}
 
@@ -2487,11 +2451,11 @@
 	 */
 	if (priv->mcm) {
 		reset_control_assert(priv->rstc);
-		usleep_range(5000, 5100);
+		usleep_range(1000, 1100);
 		reset_control_deassert(priv->rstc);
 	} else {
 		gpiod_set_value_cansleep(priv->reset, 0);
-		usleep_range(5000, 5100);
+		usleep_range(1000, 1100);
 		gpiod_set_value_cansleep(priv->reset, 1);
 	}
 
Index: drivers/net/dsa/mt7530.h
===================================================================
--- drivers/net/dsa/mt7530.h	(revision 55465)
+++ drivers/net/dsa/mt7530.h	(revision 55464)
@@ -64,33 +64,14 @@
 
 /* Registers for BPDU and PAE frame control*/
 #define MT753X_BPC			0x24
-#define  MT753X_PAE_EG_TAG_MASK		GENMASK(24, 22)
-#define  MT753X_PAE_EG_TAG(x)		FIELD_PREP(MT753X_PAE_EG_TAG_MASK, x)
+#define  MT753X_BPDU_PORT_FW_MASK	GENMASK(2, 0)
 #define  MT753X_PAE_PORT_FW_MASK	GENMASK(18, 16)
 #define  MT753X_PAE_PORT_FW(x)		FIELD_PREP(MT753X_PAE_PORT_FW_MASK, x)
-#define  MT753X_BPDU_EG_TAG_MASK	GENMASK(8, 6)
-#define  MT753X_BPDU_EG_TAG(x)		FIELD_PREP(MT753X_BPDU_EG_TAG_MASK, x)
-#define  MT753X_BPDU_PORT_FW_MASK	GENMASK(2, 0)
 
-/* Register for :01 and :02 MAC DA frame control */
-#define MT753X_RGAC1			0x28
-#define  MT753X_R02_EG_TAG_MASK		GENMASK(24, 22)
-#define  MT753X_R02_EG_TAG(x)		FIELD_PREP(MT753X_R02_EG_TAG_MASK, x)
-#define  MT753X_R02_PORT_FW_MASK	GENMASK(18, 16)
-#define  MT753X_R02_PORT_FW(x)		FIELD_PREP(MT753X_R02_PORT_FW_MASK, x)
-#define  MT753X_R01_EG_TAG_MASK		GENMASK(8, 6)
-#define  MT753X_R01_EG_TAG(x)		FIELD_PREP(MT753X_R01_EG_TAG_MASK, x)
-#define  MT753X_R01_PORT_FW_MASK	GENMASK(2, 0)
-
 /* Register for :03 and :0E MAC DA frame control */
 #define MT753X_RGAC2			0x2c
-#define  MT753X_R0E_EG_TAG_MASK		GENMASK(24, 22)
-#define  MT753X_R0E_EG_TAG(x)		FIELD_PREP(MT753X_R0E_EG_TAG_MASK, x)
 #define  MT753X_R0E_PORT_FW_MASK	GENMASK(18, 16)
 #define  MT753X_R0E_PORT_FW(x)		FIELD_PREP(MT753X_R0E_PORT_FW_MASK, x)
-#define  MT753X_R03_EG_TAG_MASK		GENMASK(8, 6)
-#define  MT753X_R03_EG_TAG(x)		FIELD_PREP(MT753X_R03_EG_TAG_MASK, x)
-#define  MT753X_R03_PORT_FW_MASK	GENMASK(2, 0)
 
 enum mt753x_bpdu_port_fw {
 	MT753X_BPDU_FOLLOW_MFC,
@@ -271,7 +252,6 @@
 enum mt7530_vlan_port_eg_tag {
 	MT7530_VLAN_EG_DISABLED = 0,
 	MT7530_VLAN_EG_CONSISTENT = 1,
-	MT7530_VLAN_EG_UNTAGGED = 4,
 };
 
 enum mt7530_vlan_port_attr {
Index: drivers/net/ethernet/intel/igb/igb_main.c
===================================================================
--- drivers/net/ethernet/intel/igb/igb_main.c	(revision 55465)
+++ drivers/net/ethernet/intel/igb/igb_main.c	(revision 55464)
@@ -6927,7 +6927,7 @@
 static void igb_tsync_interrupt(struct igb_adapter *adapter)
 {
 	struct e1000_hw *hw = &adapter->hw;
-	u32 tsicr = rd32(E1000_TSICR);
+	u32 ack = 0, tsicr = rd32(E1000_TSICR);
 	struct ptp_clock_event event;
 
 	if (tsicr & TSINTR_SYS_WRAP) {
@@ -6934,24 +6934,37 @@
 		event.type = PTP_CLOCK_PPS;
 		if (adapter->ptp_caps.pps)
 			ptp_clock_event(adapter->ptp_clock, &event);
+		ack |= TSINTR_SYS_WRAP;
 	}
 
 	if (tsicr & E1000_TSICR_TXTS) {
 		/* retrieve hardware timestamp */
 		schedule_work(&adapter->ptp_tx_work);
+		ack |= E1000_TSICR_TXTS;
 	}
 
-	if (tsicr & TSINTR_TT0)
+	if (tsicr & TSINTR_TT0) {
 		igb_perout(adapter, 0);
+		ack |= TSINTR_TT0;
+	}
 
-	if (tsicr & TSINTR_TT1)
+	if (tsicr & TSINTR_TT1) {
 		igb_perout(adapter, 1);
+		ack |= TSINTR_TT1;
+	}
 
-	if (tsicr & TSINTR_AUTT0)
+	if (tsicr & TSINTR_AUTT0) {
 		igb_extts(adapter, 0);
+		ack |= TSINTR_AUTT0;
+	}
 
-	if (tsicr & TSINTR_AUTT1)
+	if (tsicr & TSINTR_AUTT1) {
 		igb_extts(adapter, 1);
+		ack |= TSINTR_AUTT1;
+	}
+
+	/* acknowledge the interrupts */
+	wr32(E1000_TSICR, ack);
 }
 
 static irqreturn_t igb_msix_other(int irq, void *data)
Index: drivers/net/ethernet/netronome/nfp/flower/lag_conf.c
===================================================================
--- drivers/net/ethernet/netronome/nfp/flower/lag_conf.c	(revision 55465)
+++ drivers/net/ethernet/netronome/nfp/flower/lag_conf.c	(revision 55464)
@@ -308,11 +308,6 @@
 
 		acti_netdevs = kmalloc_array(entry->slave_cnt,
 					     sizeof(*acti_netdevs), GFP_KERNEL);
-		if (!acti_netdevs) {
-			schedule_delayed_work(&lag->work,
-					      NFP_FL_LAG_DELAY);
-			continue;
-		}
 
 		/* Include sanity check in the loop. It may be that a bond has
 		 * changed between processing the last notification and the
Index: drivers/net/ethernet/marvell/octeontx2/af/cgx.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/cgx.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/cgx.c	(revision 55464)
@@ -1346,7 +1346,7 @@
 
 		/* Release thread waiting for completion  */
 		lmac->cmd_pend = false;
-		wake_up(&lmac->wq_cmd_cmplt);
+		wake_up_interruptible(&lmac->wq_cmd_cmplt);
 		break;
 	case CGX_EVT_ASYNC:
 		if (cgx_event_is_linkevent(event))
Index: drivers/net/ethernet/marvell/octeontx2/af/rvu.h
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/rvu.h	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/rvu.h	(revision 55464)
@@ -109,8 +109,6 @@
 	u64  lfreset_reg;
 	unsigned char name[NAME_SIZE];
 	struct rvu *rvu;
-	u64 cpt_flt_eng_map[3];
-	u64 cpt_rcvrd_eng_map[3];
 };
 
 struct nix_mcast {
@@ -508,7 +506,6 @@
 	struct ptp		*ptp;
 
 	int			mcs_blk_cnt;
-	int			cpt_pf_num;
 
 #ifdef CONFIG_DEBUG_FS
 	struct rvu_debugfs	rvu_dbg;
@@ -523,10 +520,6 @@
 	struct list_head	mcs_intrq_head;
 	/* mcs interrupt queue lock */
 	spinlock_t		mcs_intrq_lock;
-	/* CPT interrupt lock */
-	spinlock_t		cpt_intr_lock;
-
-	struct mutex		mbox_lock; /* Serialize mbox up and down msgs */
 };
 
 static inline void rvu_write64(struct rvu *rvu, u64 block, u64 offset, u64 val)
@@ -879,7 +872,6 @@
 int rvu_cpt_lf_teardown(struct rvu *rvu, u16 pcifunc, int blkaddr, int lf,
 			int slot);
 int rvu_cpt_ctx_flush(struct rvu *rvu, u16 pcifunc);
-int rvu_cpt_init(struct rvu *rvu);
 
 #define NDC_AF_BANK_MASK       GENMASK_ULL(7, 0)
 #define NDC_AF_BANK_LINE_MASK  GENMASK_ULL(31, 16)
Index: drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c	(revision 55464)
@@ -232,7 +232,7 @@
 	struct cgx_link_user_info *linfo;
 	struct cgx_link_info_msg *msg;
 	unsigned long pfmap;
-	int pfid;
+	int err, pfid;
 
 	linfo = &event->link_uinfo;
 	pfmap = cgxlmac_to_pfmap(rvu, event->cgx_id, event->lmac_id);
@@ -250,22 +250,16 @@
 			continue;
 		}
 
-		mutex_lock(&rvu->mbox_lock);
-
 		/* Send mbox message to PF */
 		msg = otx2_mbox_alloc_msg_cgx_link_event(rvu, pfid);
-		if (!msg) {
-			mutex_unlock(&rvu->mbox_lock);
+		if (!msg)
 			continue;
-		}
-
 		msg->link_info = *linfo;
-
-		otx2_mbox_wait_for_zero(&rvu->afpf_wq_info.mbox_up, pfid);
-
-		otx2_mbox_msg_send_up(&rvu->afpf_wq_info.mbox_up, pfid);
-
-		mutex_unlock(&rvu->mbox_lock);
+		otx2_mbox_msg_send(&rvu->afpf_wq_info.mbox_up, pfid);
+		err = otx2_mbox_wait_for_rsp(&rvu->afpf_wq_info.mbox_up, pfid);
+		if (err)
+			dev_warn(rvu->dev, "notification to pf %d failed\n",
+				 pfid);
 	} while (pfmap);
 }
 
Index: drivers/net/ethernet/marvell/octeontx2/af/mbox.h
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/mbox.h	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/mbox.h	(revision 55464)
@@ -16,9 +16,6 @@
 
 #define MBOX_SIZE		SZ_64K
 
-#define MBOX_DOWN_MSG		1
-#define MBOX_UP_MSG		2
-
 /* AF/PF: PF initiated, PF/VF VF initiated */
 #define MBOX_DOWN_RX_START	0
 #define MBOX_DOWN_RX_SIZE	(46 * SZ_1K)
@@ -104,7 +101,6 @@
 			   struct pci_dev *pdev, void __force *reg_base,
 			   int direction, int ndevs, unsigned long *bmap);
 void otx2_mbox_msg_send(struct otx2_mbox *mbox, int devid);
-void otx2_mbox_msg_send_up(struct otx2_mbox *mbox, int devid);
 int otx2_mbox_wait_for_rsp(struct otx2_mbox *mbox, int devid);
 int otx2_mbox_busy_poll_for_rsp(struct otx2_mbox *mbox, int devid);
 struct mbox_msghdr *otx2_mbox_alloc_msg_rsp(struct otx2_mbox *mbox, int devid,
@@ -122,8 +118,6 @@
 	return otx2_mbox_alloc_msg_rsp(mbox, devid, size, 0);
 }
 
-bool otx2_mbox_wait_for_zero(struct otx2_mbox *mbox, int devid);
-
 /* Mailbox message types */
 #define MBOX_MSG_MASK				0xFFFF
 #define MBOX_MSG_INVALID			0xFFFE
@@ -202,9 +196,6 @@
 M(CPT_RXC_TIME_CFG,     0xA06, cpt_rxc_time_cfg, cpt_rxc_time_cfg_req,  \
 			       msg_rsp)                                 \
 M(CPT_CTX_CACHE_SYNC,   0xA07, cpt_ctx_cache_sync, msg_req, msg_rsp)    \
-M(CPT_LF_RESET,         0xA08, cpt_lf_reset, cpt_lf_rst_req, msg_rsp)	\
-M(CPT_FLT_ENG_INFO,     0xA09, cpt_flt_eng_info, cpt_flt_eng_info_req,	\
-			       cpt_flt_eng_info_rsp)			\
 /* SDP mbox IDs (range 0x1000 - 0x11FF) */				\
 M(SET_SDP_CHAN_INFO, 0x1000, set_sdp_chan_info, sdp_chan_info_msg, msg_rsp) \
 M(GET_SDP_CHAN_INFO, 0x1001, get_sdp_chan_info, msg_req, sdp_get_chan_info_msg) \
@@ -1711,28 +1702,6 @@
 	u64 rsvd;
 };
 
-/* Mailbox message format to request for CPT LF reset */
-struct cpt_lf_rst_req {
-	struct mbox_msghdr hdr;
-	u32 slot;
-	u32 rsvd;
-};
-
-/* Mailbox message format to request for CPT faulted engines */
-struct cpt_flt_eng_info_req {
-	struct mbox_msghdr hdr;
-	int blkaddr;
-	bool reset;
-	u32 rsvd;
-};
-
-struct cpt_flt_eng_info_rsp {
-	struct mbox_msghdr hdr;
-	u64 flt_eng_map[CPT_10K_AF_INT_VEC_RVU];
-	u64 rcvrd_eng_map[CPT_10K_AF_INT_VEC_RVU];
-	u64 rsvd;
-};
-
 struct sdp_node_info {
 	/* Node to which this PF belons to */
 	u8 node_id;
Index: drivers/net/ethernet/marvell/octeontx2/af/rvu.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/rvu.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/rvu.c	(revision 55464)
@@ -1164,16 +1164,8 @@
 		goto nix_err;
 	}
 
-	err = rvu_cpt_init(rvu);
-	if (err) {
-		dev_err(rvu->dev, "%s: Failed to initialize cpt\n", __func__);
-		goto mcs_err;
-	}
-
 	return 0;
 
-mcs_err:
-	rvu_mcs_exit(rvu);
 nix_err:
 	rvu_nix_freemem(rvu);
 npa_err:
@@ -2114,7 +2106,7 @@
 	}
 }
 
-static void __rvu_mbox_handler(struct rvu_work *mwork, int type, bool poll)
+static void __rvu_mbox_handler(struct rvu_work *mwork, int type)
 {
 	struct rvu *rvu = mwork->rvu;
 	int offset, err, id, devid;
@@ -2181,9 +2173,6 @@
 	}
 	mw->mbox_wrk[devid].num_msgs = 0;
 
-	if (poll)
-		otx2_mbox_wait_for_zero(mbox, devid);
-
 	/* Send mbox responses to VF/PF */
 	otx2_mbox_msg_send(mbox, devid);
 }
@@ -2191,11 +2180,8 @@
 static inline void rvu_afpf_mbox_handler(struct work_struct *work)
 {
 	struct rvu_work *mwork = container_of(work, struct rvu_work, work);
-	struct rvu *rvu = mwork->rvu;
 
-	mutex_lock(&rvu->mbox_lock);
-	__rvu_mbox_handler(mwork, TYPE_AFPF, true);
-	mutex_unlock(&rvu->mbox_lock);
+	__rvu_mbox_handler(mwork, TYPE_AFPF);
 }
 
 static inline void rvu_afvf_mbox_handler(struct work_struct *work)
@@ -2202,7 +2188,7 @@
 {
 	struct rvu_work *mwork = container_of(work, struct rvu_work, work);
 
-	__rvu_mbox_handler(mwork, TYPE_AFVF, false);
+	__rvu_mbox_handler(mwork, TYPE_AFVF);
 }
 
 static void __rvu_mbox_up_handler(struct rvu_work *mwork, int type)
@@ -2377,8 +2363,6 @@
 		}
 	}
 
-	mutex_init(&rvu->mbox_lock);
-
 	mbox_regions = kcalloc(num, sizeof(void *), GFP_KERNEL);
 	if (!mbox_regions) {
 		err = -ENOMEM;
@@ -2528,9 +2512,10 @@
 	}
 }
 
-static irqreturn_t rvu_mbox_pf_intr_handler(int irq, void *rvu_irq)
+static irqreturn_t rvu_mbox_intr_handler(int irq, void *rvu_irq)
 {
 	struct rvu *rvu = (struct rvu *)rvu_irq;
+	int vfs = rvu->vfs;
 	u64 intr;
 
 	intr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_PFAF_MBOX_INT);
@@ -2544,18 +2529,6 @@
 
 	rvu_queue_work(&rvu->afpf_wq_info, 0, rvu->hw->total_pfs, intr);
 
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rvu_mbox_intr_handler(int irq, void *rvu_irq)
-{
-	struct rvu *rvu = (struct rvu *)rvu_irq;
-	int vfs = rvu->vfs;
-	u64 intr;
-
-	/* Sync with mbox memory region */
-	rmb();
-
 	/* Handle VF interrupts */
 	if (vfs > 64) {
 		intr = rvupf_read64(rvu, RVU_PF_VFPF_MBOX_INTX(1));
@@ -2892,7 +2865,7 @@
 	/* Register mailbox interrupt handler */
 	sprintf(&rvu->irq_name[RVU_AF_INT_VEC_MBOX * NAME_SIZE], "RVUAF Mbox");
 	ret = request_irq(pci_irq_vector(rvu->pdev, RVU_AF_INT_VEC_MBOX),
-			  rvu_mbox_pf_intr_handler, 0,
+			  rvu_mbox_intr_handler, 0,
 			  &rvu->irq_name[RVU_AF_INT_VEC_MBOX * NAME_SIZE], rvu);
 	if (ret) {
 		dev_err(rvu->dev,
@@ -3066,8 +3039,9 @@
 			    cfg | BIT_ULL(22));
 	}
 
-	rvu->flr_wq = alloc_ordered_workqueue("rvu_afpf_flr",
-					      WQ_HIGHPRI | WQ_MEM_RECLAIM);
+	rvu->flr_wq = alloc_workqueue("rvu_afpf_flr",
+				      WQ_UNBOUND | WQ_HIGHPRI | WQ_MEM_RECLAIM,
+				       1);
 	if (!rvu->flr_wq)
 		return -ENOMEM;
 
Index: drivers/net/ethernet/marvell/octeontx2/af/mbox.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/mbox.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/mbox.c	(revision 55464)
@@ -214,12 +214,11 @@
 }
 EXPORT_SYMBOL(otx2_mbox_busy_poll_for_rsp);
 
-static void otx2_mbox_msg_send_data(struct otx2_mbox *mbox, int devid, u64 data)
+void otx2_mbox_msg_send(struct otx2_mbox *mbox, int devid)
 {
 	struct otx2_mbox_dev *mdev = &mbox->dev[devid];
 	struct mbox_hdr *tx_hdr, *rx_hdr;
 	void *hw_mbase = mdev->hwbase;
-	u64 intr_val;
 
 	tx_hdr = hw_mbase + mbox->tx_start;
 	rx_hdr = hw_mbase + mbox->rx_start;
@@ -255,52 +254,14 @@
 
 	spin_unlock(&mdev->mbox_lock);
 
-	/* Check if interrupt pending */
-	intr_val = readq((void __iomem *)mbox->reg_base +
-		     (mbox->trigger | (devid << mbox->tr_shift)));
-
-	intr_val |= data;
 	/* The interrupt should be fired after num_msgs is written
 	 * to the shared memory
 	 */
-	writeq(intr_val, (void __iomem *)mbox->reg_base +
+	writeq(1, (void __iomem *)mbox->reg_base +
 	       (mbox->trigger | (devid << mbox->tr_shift)));
 }
-
-void otx2_mbox_msg_send(struct otx2_mbox *mbox, int devid)
-{
-	otx2_mbox_msg_send_data(mbox, devid, MBOX_DOWN_MSG);
-}
 EXPORT_SYMBOL(otx2_mbox_msg_send);
 
-void otx2_mbox_msg_send_up(struct otx2_mbox *mbox, int devid)
-{
-	otx2_mbox_msg_send_data(mbox, devid, MBOX_UP_MSG);
-}
-EXPORT_SYMBOL(otx2_mbox_msg_send_up);
-
-bool otx2_mbox_wait_for_zero(struct otx2_mbox *mbox, int devid)
-{
-	u64 data;
-
-	data = readq((void __iomem *)mbox->reg_base +
-		     (mbox->trigger | (devid << mbox->tr_shift)));
-
-	/* If data is non-zero wait for ~1ms and return to caller
-	 * whether data has changed to zero or not after the wait.
-	 */
-	if (!data)
-		return true;
-
-	usleep_range(950, 1000);
-
-	data = readq((void __iomem *)mbox->reg_base +
-		     (mbox->trigger | (devid << mbox->tr_shift)));
-
-	return data == 0;
-}
-EXPORT_SYMBOL(otx2_mbox_wait_for_zero);
-
 struct mbox_msghdr *otx2_mbox_alloc_msg_rsp(struct otx2_mbox *mbox, int devid,
 					    int size, int size_rsp)
 {
Index: drivers/net/ethernet/marvell/octeontx2/af/mcs_rvu_if.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/mcs_rvu_if.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/mcs_rvu_if.c	(revision 55464)
@@ -121,17 +121,13 @@
 static int mcs_notify_pfvf(struct mcs_intr_event *event, struct rvu *rvu)
 {
 	struct mcs_intr_info *req;
-	int pf;
+	int err, pf;
 
 	pf = rvu_get_pf(event->pcifunc);
 
-	mutex_lock(&rvu->mbox_lock);
-
 	req = otx2_mbox_alloc_msg_mcs_intr_notify(rvu, pf);
-	if (!req) {
-		mutex_unlock(&rvu->mbox_lock);
+	if (!req)
 		return -ENOMEM;
-	}
 
 	req->mcs_id = event->mcs_id;
 	req->intr_mask = event->intr_mask;
@@ -139,12 +135,11 @@
 	req->hdr.pcifunc = event->pcifunc;
 	req->lmac_id = event->lmac_id;
 
-	otx2_mbox_wait_for_zero(&rvu->afpf_wq_info.mbox_up, pf);
+	otx2_mbox_msg_send(&rvu->afpf_wq_info.mbox_up, pf);
+	err = otx2_mbox_wait_for_rsp(&rvu->afpf_wq_info.mbox_up, pf);
+	if (err)
+		dev_warn(rvu->dev, "MCS notification to pf %d failed\n", pf);
 
-	otx2_mbox_msg_send_up(&rvu->afpf_wq_info.mbox_up, pf);
-
-	mutex_unlock(&rvu->mbox_lock);
-
 	return 0;
 }
 
Index: drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/af/rvu_cpt.c	(revision 55464)
@@ -37,68 +37,34 @@
 	(_rsp)->free_sts_##etype = free_sts;                        \
 })
 
-static irqreturn_t cpt_af_flt_intr_handler(int vec, void *ptr)
+static irqreturn_t rvu_cpt_af_flt_intr_handler(int irq, void *ptr)
 {
 	struct rvu_block *block = ptr;
 	struct rvu *rvu = block->rvu;
 	int blkaddr = block->addr;
-	u64 reg, val;
-	int i, eng;
-	u8 grp;
+	u64 reg0, reg1, reg2;
 
-	reg = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(vec));
-	dev_err_ratelimited(rvu->dev, "Received CPTAF FLT%d irq : 0x%llx", vec, reg);
+	reg0 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(0));
+	reg1 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(1));
+	if (!is_rvu_otx2(rvu)) {
+		reg2 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(2));
+		dev_err_ratelimited(rvu->dev,
+				    "Received CPTAF FLT irq : 0x%llx, 0x%llx, 0x%llx",
+				     reg0, reg1, reg2);
+	} else {
+		dev_err_ratelimited(rvu->dev,
+				    "Received CPTAF FLT irq : 0x%llx, 0x%llx",
+				     reg0, reg1);
+	}
 
-	i = -1;
-	while ((i = find_next_bit((unsigned long *)&reg, 64, i + 1)) < 64) {
-		switch (vec) {
-		case 0:
-			eng = i;
-			break;
-		case 1:
-			eng = i + 64;
-			break;
-		case 2:
-			eng = i + 128;
-			break;
-		}
-		grp = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_CTL2(eng)) & 0xFF;
-		/* Disable and enable the engine which triggers fault */
-		rvu_write64(rvu, blkaddr, CPT_AF_EXEX_CTL2(eng), 0x0);
-		val = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_CTL(eng));
-		rvu_write64(rvu, blkaddr, CPT_AF_EXEX_CTL(eng), val & ~1ULL);
+	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT(0), reg0);
+	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT(1), reg1);
+	if (!is_rvu_otx2(rvu))
+		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT(2), reg2);
 
-		rvu_write64(rvu, blkaddr, CPT_AF_EXEX_CTL2(eng), grp);
-		rvu_write64(rvu, blkaddr, CPT_AF_EXEX_CTL(eng), val | 1ULL);
-
-		spin_lock(&rvu->cpt_intr_lock);
-		block->cpt_flt_eng_map[vec] |= BIT_ULL(i);
-		val = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_STS(eng));
-		val = val & 0x3;
-		if (val == 0x1 || val == 0x2)
-			block->cpt_rcvrd_eng_map[vec] |= BIT_ULL(i);
-		spin_unlock(&rvu->cpt_intr_lock);
-	}
-	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT(vec), reg);
-
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t rvu_cpt_af_flt0_intr_handler(int irq, void *ptr)
-{
-	return cpt_af_flt_intr_handler(CPT_AF_INT_VEC_FLT0, ptr);
-}
-
-static irqreturn_t rvu_cpt_af_flt1_intr_handler(int irq, void *ptr)
-{
-	return cpt_af_flt_intr_handler(CPT_AF_INT_VEC_FLT1, ptr);
-}
-
-static irqreturn_t rvu_cpt_af_flt2_intr_handler(int irq, void *ptr)
-{
-	return cpt_af_flt_intr_handler(CPT_10K_AF_INT_VEC_FLT2, ptr);
-}
-
 static irqreturn_t rvu_cpt_af_rvu_intr_handler(int irq, void *ptr)
 {
 	struct rvu_block *block = ptr;
@@ -153,10 +119,8 @@
 	int i;
 
 	/* Disable all CPT AF interrupts */
-	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(0), ~0ULL);
-	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(1), ~0ULL);
-	rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(2), 0xFFFF);
-
+	for (i = 0; i < CPT_10K_AF_INT_VEC_RVU; i++)
+		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(i), 0x1);
 	rvu_write64(rvu, blkaddr, CPT_AF_RVU_INT_ENA_W1C, 0x1);
 	rvu_write64(rvu, blkaddr, CPT_AF_RAS_INT_ENA_W1C, 0x1);
 
@@ -187,7 +151,7 @@
 
 	/* Disable all CPT AF interrupts */
 	for (i = 0; i < CPT_AF_INT_VEC_RVU; i++)
-		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(i), ~0ULL);
+		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1C(i), 0x1);
 	rvu_write64(rvu, blkaddr, CPT_AF_RVU_INT_ENA_W1C, 0x1);
 	rvu_write64(rvu, blkaddr, CPT_AF_RAS_INT_ENA_W1C, 0x1);
 
@@ -208,31 +172,16 @@
 {
 	struct rvu *rvu = block->rvu;
 	int blkaddr = block->addr;
-	irq_handler_t flt_fn;
 	int i, ret;
 
 	for (i = CPT_10K_AF_INT_VEC_FLT0; i < CPT_10K_AF_INT_VEC_RVU; i++) {
 		sprintf(&rvu->irq_name[(off + i) * NAME_SIZE], "CPTAF FLT%d", i);
-
-		switch (i) {
-		case CPT_10K_AF_INT_VEC_FLT0:
-			flt_fn = rvu_cpt_af_flt0_intr_handler;
-			break;
-		case CPT_10K_AF_INT_VEC_FLT1:
-			flt_fn = rvu_cpt_af_flt1_intr_handler;
-			break;
-		case CPT_10K_AF_INT_VEC_FLT2:
-			flt_fn = rvu_cpt_af_flt2_intr_handler;
-			break;
-		}
 		ret = rvu_cpt_do_register_interrupt(block, off + i,
-						    flt_fn, &rvu->irq_name[(off + i) * NAME_SIZE]);
+						    rvu_cpt_af_flt_intr_handler,
+						    &rvu->irq_name[(off + i) * NAME_SIZE]);
 		if (ret)
 			goto err;
-		if (i == CPT_10K_AF_INT_VEC_FLT2)
-			rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1S(i), 0xFFFF);
-		else
-			rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1S(i), ~0ULL);
+		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1S(i), 0x1);
 	}
 
 	ret = rvu_cpt_do_register_interrupt(block, off + CPT_10K_AF_INT_VEC_RVU,
@@ -259,8 +208,8 @@
 {
 	struct rvu_hwinfo *hw = rvu->hw;
 	struct rvu_block *block;
-	irq_handler_t flt_fn;
 	int i, offs, ret = 0;
+	char irq_name[16];
 
 	if (!is_block_implemented(rvu->hw, blkaddr))
 		return 0;
@@ -277,20 +226,13 @@
 		return cpt_10k_register_interrupts(block, offs);
 
 	for (i = CPT_AF_INT_VEC_FLT0; i < CPT_AF_INT_VEC_RVU; i++) {
-		sprintf(&rvu->irq_name[(offs + i) * NAME_SIZE], "CPTAF FLT%d", i);
-		switch (i) {
-		case CPT_AF_INT_VEC_FLT0:
-			flt_fn = rvu_cpt_af_flt0_intr_handler;
-			break;
-		case CPT_AF_INT_VEC_FLT1:
-			flt_fn = rvu_cpt_af_flt1_intr_handler;
-			break;
-		}
+		snprintf(irq_name, sizeof(irq_name), "CPTAF FLT%d", i);
 		ret = rvu_cpt_do_register_interrupt(block, offs + i,
-						    flt_fn, &rvu->irq_name[(offs + i) * NAME_SIZE]);
+						    rvu_cpt_af_flt_intr_handler,
+						    irq_name);
 		if (ret)
 			goto err;
-		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1S(i), ~0ULL);
+		rvu_write64(rvu, blkaddr, CPT_AF_FLTX_INT_ENA_W1S(i), 0x1);
 	}
 
 	ret = rvu_cpt_do_register_interrupt(block, offs + CPT_AF_INT_VEC_RVU,
@@ -348,7 +290,7 @@
 
 static bool is_cpt_pf(struct rvu *rvu, u16 pcifunc)
 {
-	int cpt_pf_num = rvu->cpt_pf_num;
+	int cpt_pf_num = get_cpt_pf_num(rvu);
 
 	if (rvu_get_pf(pcifunc) != cpt_pf_num)
 		return false;
@@ -360,7 +302,7 @@
 
 static bool is_cpt_vf(struct rvu *rvu, u16 pcifunc)
 {
-	int cpt_pf_num = rvu->cpt_pf_num;
+	int cpt_pf_num = get_cpt_pf_num(rvu);
 
 	if (rvu_get_pf(pcifunc) != cpt_pf_num)
 		return false;
@@ -859,64 +801,6 @@
 	return rvu_cpt_ctx_flush(rvu, req->hdr.pcifunc);
 }
 
-int rvu_mbox_handler_cpt_lf_reset(struct rvu *rvu, struct cpt_lf_rst_req *req,
-				  struct msg_rsp *rsp)
-{
-	u16 pcifunc = req->hdr.pcifunc;
-	struct rvu_block *block;
-	int cptlf, blkaddr, ret;
-	u16 actual_slot;
-	u64 ctl, ctl2;
-
-	blkaddr = rvu_get_blkaddr_from_slot(rvu, BLKTYPE_CPT, pcifunc,
-					    req->slot, &actual_slot);
-	if (blkaddr < 0)
-		return CPT_AF_ERR_LF_INVALID;
-
-	block = &rvu->hw->block[blkaddr];
-
-	cptlf = rvu_get_lf(rvu, block, pcifunc, actual_slot);
-	if (cptlf < 0)
-		return CPT_AF_ERR_LF_INVALID;
-	ctl = rvu_read64(rvu, blkaddr, CPT_AF_LFX_CTL(cptlf));
-	ctl2 = rvu_read64(rvu, blkaddr, CPT_AF_LFX_CTL2(cptlf));
-
-	ret = rvu_lf_reset(rvu, block, cptlf);
-	if (ret)
-		dev_err(rvu->dev, "Failed to reset blkaddr %d LF%d\n",
-			block->addr, cptlf);
-
-	rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL(cptlf), ctl);
-	rvu_write64(rvu, blkaddr, CPT_AF_LFX_CTL2(cptlf), ctl2);
-
-	return 0;
-}
-
-int rvu_mbox_handler_cpt_flt_eng_info(struct rvu *rvu, struct cpt_flt_eng_info_req *req,
-				      struct cpt_flt_eng_info_rsp *rsp)
-{
-	struct rvu_block *block;
-	unsigned long flags;
-	int blkaddr, vec;
-
-	blkaddr = validate_and_get_cpt_blkaddr(req->blkaddr);
-	if (blkaddr < 0)
-		return blkaddr;
-
-	block = &rvu->hw->block[blkaddr];
-	for (vec = 0; vec < CPT_10K_AF_INT_VEC_RVU; vec++) {
-		spin_lock_irqsave(&rvu->cpt_intr_lock, flags);
-		rsp->flt_eng_map[vec] = block->cpt_flt_eng_map[vec];
-		rsp->rcvrd_eng_map[vec] = block->cpt_rcvrd_eng_map[vec];
-		if (req->reset) {
-			block->cpt_flt_eng_map[vec] = 0x0;
-			block->cpt_rcvrd_eng_map[vec] = 0x0;
-		}
-		spin_unlock_irqrestore(&rvu->cpt_intr_lock, flags);
-	}
-	return 0;
-}
-
 static void cpt_rxc_teardown(struct rvu *rvu, int blkaddr)
 {
 	struct cpt_rxc_time_cfg_req req;
@@ -1056,7 +940,7 @@
 static int cpt_inline_inb_lf_cmd_send(struct rvu *rvu, int blkaddr,
 				      int nix_blkaddr)
 {
-	int cpt_pf_num = rvu->cpt_pf_num;
+	int cpt_pf_num = get_cpt_pf_num(rvu);
 	struct cpt_inst_lmtst_req *req;
 	dma_addr_t res_daddr;
 	int timeout = 3000;
@@ -1200,12 +1084,3 @@
 
 	return 0;
 }
-
-int rvu_cpt_init(struct rvu *rvu)
-{
-	/* Retrieve CPT PF number */
-	rvu->cpt_pf_num = get_cpt_pf_num(rvu);
-	spin_lock_init(&rvu->cpt_intr_lock);
-
-	return 0;
-}
Index: drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c	(revision 55464)
@@ -272,7 +272,8 @@
 {
 	int vf;
 
-	pf->flr_wq = alloc_ordered_workqueue("otx2_pf_flr_wq", WQ_HIGHPRI);
+	pf->flr_wq = alloc_workqueue("otx2_pf_flr_wq",
+				     WQ_UNBOUND | WQ_HIGHPRI, 1);
 	if (!pf->flr_wq)
 		return -ENOMEM;
 
@@ -291,8 +292,8 @@
 	return 0;
 }
 
-static void otx2_queue_vf_work(struct mbox *mw, struct workqueue_struct *mbox_wq,
-			       int first, int mdevs, u64 intr)
+static void otx2_queue_work(struct mbox *mw, struct workqueue_struct *mbox_wq,
+			    int first, int mdevs, u64 intr, int type)
 {
 	struct otx2_mbox_dev *mdev;
 	struct otx2_mbox *mbox;
@@ -306,26 +307,40 @@
 
 		mbox = &mw->mbox;
 		mdev = &mbox->dev[i];
+		if (type == TYPE_PFAF)
+			otx2_sync_mbox_bbuf(mbox, i);
 		hdr = mdev->mbase + mbox->rx_start;
 		/* The hdr->num_msgs is set to zero immediately in the interrupt
-		 * handler to ensure that it holds a correct value next time
-		 * when the interrupt handler is called. pf->mw[i].num_msgs
-		 * holds the data for use in otx2_pfvf_mbox_handler and
-		 * pf->mw[i].up_num_msgs holds the data for use in
-		 * otx2_pfvf_mbox_up_handler.
+		 * handler to  ensure that it holds a correct value next time
+		 * when the interrupt handler is called.
+		 * pf->mbox.num_msgs holds the data for use in pfaf_mbox_handler
+		 * pf>mbox.up_num_msgs holds the data for use in
+		 * pfaf_mbox_up_handler.
 		 */
 		if (hdr->num_msgs) {
 			mw[i].num_msgs = hdr->num_msgs;
 			hdr->num_msgs = 0;
+			if (type == TYPE_PFAF)
+				memset(mbox->hwbase + mbox->rx_start, 0,
+				       ALIGN(sizeof(struct mbox_hdr),
+					     sizeof(u64)));
+
 			queue_work(mbox_wq, &mw[i].mbox_wrk);
 		}
 
 		mbox = &mw->mbox_up;
 		mdev = &mbox->dev[i];
+		if (type == TYPE_PFAF)
+			otx2_sync_mbox_bbuf(mbox, i);
 		hdr = mdev->mbase + mbox->rx_start;
 		if (hdr->num_msgs) {
 			mw[i].up_num_msgs = hdr->num_msgs;
 			hdr->num_msgs = 0;
+			if (type == TYPE_PFAF)
+				memset(mbox->hwbase + mbox->rx_start, 0,
+				       ALIGN(sizeof(struct mbox_hdr),
+					     sizeof(u64)));
+
 			queue_work(mbox_wq, &mw[i].mbox_up_wrk);
 		}
 	}
@@ -341,10 +356,8 @@
 	/* Msgs are already copied, trigger VF's mbox irq */
 	smp_wmb();
 
-	otx2_mbox_wait_for_zero(pfvf_mbox, devid);
-
 	offset = pfvf_mbox->trigger | (devid << pfvf_mbox->tr_shift);
-	writeq(MBOX_DOWN_MSG, (void __iomem *)pfvf_mbox->reg_base + offset);
+	writeq(1, (void __iomem *)pfvf_mbox->reg_base + offset);
 
 	/* Restore VF's mbox bounce buffer region address */
 	src_mdev->mbase = bbuf_base;
@@ -534,7 +547,7 @@
 end:
 		offset = mbox->rx_start + msg->next_msgoff;
 		if (mdev->msgs_acked == (vf_mbox->up_num_msgs - 1))
-			__otx2_mbox_reset(mbox, vf_idx);
+			__otx2_mbox_reset(mbox, 0);
 		mdev->msgs_acked++;
 	}
 }
@@ -551,7 +564,8 @@
 	if (vfs > 64) {
 		intr = otx2_read64(pf, RVU_PF_VFPF_MBOX_INTX(1));
 		otx2_write64(pf, RVU_PF_VFPF_MBOX_INTX(1), intr);
-		otx2_queue_vf_work(mbox, pf->mbox_pfvf_wq, 64, vfs, intr);
+		otx2_queue_work(mbox, pf->mbox_pfvf_wq, 64, vfs, intr,
+				TYPE_PFVF);
 		if (intr)
 			trace_otx2_msg_interrupt(mbox->mbox.pdev, "VF(s) to PF", intr);
 		vfs = 64;
@@ -560,7 +574,7 @@
 	intr = otx2_read64(pf, RVU_PF_VFPF_MBOX_INTX(0));
 	otx2_write64(pf, RVU_PF_VFPF_MBOX_INTX(0), intr);
 
-	otx2_queue_vf_work(mbox, pf->mbox_pfvf_wq, 0, vfs, intr);
+	otx2_queue_work(mbox, pf->mbox_pfvf_wq, 0, vfs, intr, TYPE_PFVF);
 
 	if (intr)
 		trace_otx2_msg_interrupt(mbox->mbox.pdev, "VF(s) to PF", intr);
@@ -585,7 +599,7 @@
 
 	pf->mbox_pfvf_wq = alloc_workqueue("otx2_pfvf_mailbox",
 					   WQ_UNBOUND | WQ_HIGHPRI |
-					   WQ_MEM_RECLAIM, 0);
+					   WQ_MEM_RECLAIM, 1);
 	if (!pf->mbox_pfvf_wq)
 		return -ENOMEM;
 
@@ -808,22 +822,20 @@
 	struct mbox *af_mbox;
 	struct otx2_nic *pf;
 	int offset, id;
-	u16 num_msgs;
 
 	af_mbox = container_of(work, struct mbox, mbox_wrk);
 	mbox = &af_mbox->mbox;
 	mdev = &mbox->dev[0];
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	num_msgs = rsp_hdr->num_msgs;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 	pf = af_mbox->pfvf;
 
-	for (id = 0; id < num_msgs; id++) {
+	for (id = 0; id < af_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		otx2_process_pfaf_mbox_msg(pf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
-		if (mdev->msgs_acked == (num_msgs - 1))
+		if (mdev->msgs_acked == (af_mbox->num_msgs - 1))
 			__otx2_mbox_reset(mbox, 0);
 		mdev->msgs_acked++;
 	}
@@ -934,14 +946,12 @@
 	int offset, id, devid = 0;
 	struct mbox_hdr *rsp_hdr;
 	struct mbox_msghdr *msg;
-	u16 num_msgs;
 
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	num_msgs = rsp_hdr->num_msgs;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < num_msgs; id++) {
+	for (id = 0; id < af_mbox->up_num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 
 		devid = msg->pcifunc & RVU_PFVF_FUNC_MASK;
@@ -950,11 +960,10 @@
 			otx2_process_mbox_msg_up(pf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
 	}
-	/* Forward to VF iff VFs are really present */
-	if (devid && pci_num_vf(pf->pdev)) {
+	if (devid) {
 		otx2_forward_vf_mbox_msgs(pf, &pf->mbox.mbox_up,
 					  MBOX_DIR_PFVF_UP, devid - 1,
-					  num_msgs);
+					  af_mbox->up_num_msgs);
 		return;
 	}
 
@@ -964,50 +973,17 @@
 static irqreturn_t otx2_pfaf_mbox_intr_handler(int irq, void *pf_irq)
 {
 	struct otx2_nic *pf = (struct otx2_nic *)pf_irq;
-	struct mbox *mw = &pf->mbox;
-	struct otx2_mbox_dev *mdev;
-	struct otx2_mbox *mbox;
-	struct mbox_hdr *hdr;
-	u64 mbox_data;
+	struct mbox *mbox;
 
 	/* Clear the IRQ */
 	otx2_write64(pf, RVU_PF_INT, BIT_ULL(0));
 
+	mbox = &pf->mbox;
 
-	mbox_data = otx2_read64(pf, RVU_PF_PFAF_MBOX0);
+	trace_otx2_msg_interrupt(mbox->mbox.pdev, "AF to PF", BIT_ULL(0));
 
-	if (mbox_data & MBOX_UP_MSG) {
-		mbox_data &= ~MBOX_UP_MSG;
-		otx2_write64(pf, RVU_PF_PFAF_MBOX0, mbox_data);
+	otx2_queue_work(mbox, pf->mbox_wq, 0, 1, 1, TYPE_PFAF);
 
-		mbox = &mw->mbox_up;
-		mdev = &mbox->dev[0];
-		otx2_sync_mbox_bbuf(mbox, 0);
-
-		hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-		if (hdr->num_msgs)
-			queue_work(pf->mbox_wq, &mw->mbox_up_wrk);
-
-		trace_otx2_msg_interrupt(pf->pdev, "UP message from AF to PF",
-					 BIT_ULL(0));
-	}
-
-	if (mbox_data & MBOX_DOWN_MSG) {
-		mbox_data &= ~MBOX_DOWN_MSG;
-		otx2_write64(pf, RVU_PF_PFAF_MBOX0, mbox_data);
-
-		mbox = &mw->mbox;
-		mdev = &mbox->dev[0];
-		otx2_sync_mbox_bbuf(mbox, 0);
-
-		hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-		if (hdr->num_msgs)
-			queue_work(pf->mbox_wq, &mw->mbox_wrk);
-
-		trace_otx2_msg_interrupt(pf->pdev, "DOWN reply from AF to PF",
-					 BIT_ULL(0));
-	}
-
 	return IRQ_HANDLED;
 }
 
@@ -1087,8 +1063,9 @@
 	int err;
 
 	mbox->pfvf = pf;
-	pf->mbox_wq = alloc_ordered_workqueue("otx2_pfaf_mailbox",
-					      WQ_HIGHPRI | WQ_MEM_RECLAIM);
+	pf->mbox_wq = alloc_workqueue("otx2_pfaf_mailbox",
+				      WQ_UNBOUND | WQ_HIGHPRI |
+				      WQ_MEM_RECLAIM, 1);
 	if (!pf->mbox_wq)
 		return -ENOMEM;
 
@@ -3053,7 +3030,6 @@
 	struct otx2_vf_config *config;
 	struct cgx_link_info_msg *req;
 	struct mbox_msghdr *msghdr;
-	struct delayed_work *dwork;
 	struct otx2_nic *pf;
 	int vf_idx;
 
@@ -3062,24 +3038,10 @@
 	vf_idx = config - config->pf->vf_configs;
 	pf = config->pf;
 
-	if (config->intf_down)
-		return;
-
-	mutex_lock(&pf->mbox.lock);
-
-	dwork = &config->link_event_work;
-
-	if (!otx2_mbox_wait_for_zero(&pf->mbox_pfvf[0].mbox_up, vf_idx)) {
-		schedule_delayed_work(dwork, msecs_to_jiffies(100));
-		mutex_unlock(&pf->mbox.lock);
-		return;
-	}
-
 	msghdr = otx2_mbox_alloc_msg_rsp(&pf->mbox_pfvf[0].mbox_up, vf_idx,
 					 sizeof(*req), sizeof(struct msg_rsp));
 	if (!msghdr) {
 		dev_err(pf->dev, "Failed to create VF%d link event\n", vf_idx);
-		mutex_unlock(&pf->mbox.lock);
 		return;
 	}
 
@@ -3088,11 +3050,7 @@
 	req->hdr.sig = OTX2_MBOX_REQ_SIG;
 	memcpy(&req->link_info, &pf->linfo, sizeof(req->link_info));
 
-	otx2_mbox_wait_for_zero(&pf->mbox_pfvf[0].mbox_up, vf_idx);
-
 	otx2_sync_mbox_up_msg(&pf->mbox_pfvf[0], vf_idx);
-
-	mutex_unlock(&pf->mbox.lock);
 }
 
 static int otx2_sriov_enable(struct pci_dev *pdev, int numvfs)
Index: drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.h	(revision 55464)
@@ -785,7 +785,7 @@
 
 	if (!otx2_mbox_nonempty(&mbox->mbox_up, devid))
 		return 0;
-	otx2_mbox_msg_send_up(&mbox->mbox_up, devid);
+	otx2_mbox_msg_send(&mbox->mbox_up, devid);
 	err = otx2_mbox_wait_for_rsp(&mbox->mbox_up, devid);
 	if (err)
 		return err;
Index: drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c
===================================================================
--- drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c	(revision 55465)
+++ drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c	(revision 55464)
@@ -89,20 +89,16 @@
 	struct otx2_mbox *mbox;
 	struct mbox *af_mbox;
 	int offset, id;
-	u16 num_msgs;
 
 	af_mbox = container_of(work, struct mbox, mbox_wrk);
 	mbox = &af_mbox->mbox;
 	mdev = &mbox->dev[0];
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	num_msgs = rsp_hdr->num_msgs;
-
-	if (num_msgs == 0)
+	if (af_mbox->num_msgs == 0)
 		return;
-
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < num_msgs; id++) {
+	for (id = 0; id < af_mbox->num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		otx2vf_process_vfaf_mbox_msg(af_mbox->pfvf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
@@ -155,7 +151,6 @@
 	struct mbox *vf_mbox;
 	struct otx2_nic *vf;
 	int offset, id;
-	u16 num_msgs;
 
 	vf_mbox = container_of(work, struct mbox, mbox_up_wrk);
 	vf = vf_mbox->pfvf;
@@ -163,14 +158,12 @@
 	mdev = &mbox->dev[0];
 
 	rsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-	num_msgs = rsp_hdr->num_msgs;
-
-	if (num_msgs == 0)
+	if (vf_mbox->up_num_msgs == 0)
 		return;
 
 	offset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);
 
-	for (id = 0; id < num_msgs; id++) {
+	for (id = 0; id < vf_mbox->up_num_msgs; id++) {
 		msg = (struct mbox_msghdr *)(mdev->mbase + offset);
 		otx2vf_process_mbox_msg_up(vf, msg);
 		offset = mbox->rx_start + msg->next_msgoff;
@@ -185,48 +178,40 @@
 	struct otx2_mbox_dev *mdev;
 	struct otx2_mbox *mbox;
 	struct mbox_hdr *hdr;
-	u64 mbox_data;
 
 	/* Clear the IRQ */
 	otx2_write64(vf, RVU_VF_INT, BIT_ULL(0));
 
-	mbox_data = otx2_read64(vf, RVU_VF_VFPF_MBOX0);
-
 	/* Read latest mbox data */
 	smp_rmb();
 
-	if (mbox_data & MBOX_DOWN_MSG) {
-		mbox_data &= ~MBOX_DOWN_MSG;
-		otx2_write64(vf, RVU_VF_VFPF_MBOX0, mbox_data);
+	/* Check for PF => VF response messages */
+	mbox = &vf->mbox.mbox;
+	mdev = &mbox->dev[0];
+	otx2_sync_mbox_bbuf(mbox, 0);
 
-		/* Check for PF => VF response messages */
-		mbox = &vf->mbox.mbox;
-		mdev = &mbox->dev[0];
-		otx2_sync_mbox_bbuf(mbox, 0);
+	trace_otx2_msg_interrupt(mbox->pdev, "PF to VF", BIT_ULL(0));
 
-		hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-		if (hdr->num_msgs)
-			queue_work(vf->mbox_wq, &vf->mbox.mbox_wrk);
-
-		trace_otx2_msg_interrupt(mbox->pdev, "DOWN reply from PF to VF",
-					 BIT_ULL(0));
+	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (hdr->num_msgs) {
+		vf->mbox.num_msgs = hdr->num_msgs;
+		hdr->num_msgs = 0;
+		memset(mbox->hwbase + mbox->rx_start, 0,
+		       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
+		queue_work(vf->mbox_wq, &vf->mbox.mbox_wrk);
 	}
+	/* Check for PF => VF notification messages */
+	mbox = &vf->mbox.mbox_up;
+	mdev = &mbox->dev[0];
+	otx2_sync_mbox_bbuf(mbox, 0);
 
-	if (mbox_data & MBOX_UP_MSG) {
-		mbox_data &= ~MBOX_UP_MSG;
-		otx2_write64(vf, RVU_VF_VFPF_MBOX0, mbox_data);
-
-		/* Check for PF => VF notification messages */
-		mbox = &vf->mbox.mbox_up;
-		mdev = &mbox->dev[0];
-		otx2_sync_mbox_bbuf(mbox, 0);
-
-		hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
-		if (hdr->num_msgs)
-			queue_work(vf->mbox_wq, &vf->mbox.mbox_up_wrk);
-
-		trace_otx2_msg_interrupt(mbox->pdev, "UP message from PF to VF",
-					 BIT_ULL(0));
+	hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);
+	if (hdr->num_msgs) {
+		vf->mbox.up_num_msgs = hdr->num_msgs;
+		hdr->num_msgs = 0;
+		memset(mbox->hwbase + mbox->rx_start, 0,
+		       ALIGN(sizeof(struct mbox_hdr), sizeof(u64)));
+		queue_work(vf->mbox_wq, &vf->mbox.mbox_up_wrk);
 	}
 
 	return IRQ_HANDLED;
@@ -308,8 +293,9 @@
 	int err;
 
 	mbox->pfvf = vf;
-	vf->mbox_wq = alloc_ordered_workqueue("otx2_vfaf_mailbox",
-					      WQ_HIGHPRI | WQ_MEM_RECLAIM);
+	vf->mbox_wq = alloc_workqueue("otx2_vfaf_mailbox",
+				      WQ_UNBOUND | WQ_HIGHPRI |
+				      WQ_MEM_RECLAIM, 1);
 	if (!vf->mbox_wq)
 		return -ENOMEM;
 
Index: drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
===================================================================
--- drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h	(revision 55465)
+++ drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h	(revision 55464)
@@ -1002,6 +1002,9 @@
 static inline void bnx2x_free_rx_mem_pool(struct bnx2x *bp,
 					  struct bnx2x_alloc_pool *pool)
 {
+	if (!pool->page)
+		return;
+
 	put_page(pool->page);
 
 	pool->page = NULL;
@@ -1012,9 +1015,6 @@
 {
 	int i;
 
-	if (!fp->page_pool.page)
-		return;
-
 	if (fp->mode == TPA_MODE_DISABLED)
 		return;
 
Index: drivers/net/ethernet/amazon/ena/ena_netdev.c
===================================================================
--- drivers/net/ethernet/amazon/ena/ena_netdev.c	(revision 55465)
+++ drivers/net/ethernet/amazon/ena/ena_netdev.c	(revision 55464)
@@ -3174,6 +3174,22 @@
 	return NETDEV_TX_OK;
 }
 
+static u16 ena_select_queue(struct net_device *dev, struct sk_buff *skb,
+			    struct net_device *sb_dev)
+{
+	u16 qid;
+	/* we suspect that this is good for in--kernel network services that
+	 * want to loop incoming skb rx to tx in normal user generated traffic,
+	 * most probably we will not get to this
+	 */
+	if (skb_rx_queue_recorded(skb))
+		qid = skb_get_rx_queue(skb);
+	else
+		qid = netdev_pick_tx(dev, skb, NULL);
+
+	return qid;
+}
+
 static void ena_config_host_info(struct ena_com_dev *ena_dev, struct pci_dev *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -3343,6 +3359,7 @@
 	.ndo_open		= ena_open,
 	.ndo_stop		= ena_close,
 	.ndo_start_xmit		= ena_start_xmit,
+	.ndo_select_queue	= ena_select_queue,
 	.ndo_get_stats64	= ena_get_stats64,
 	.ndo_tx_timeout		= ena_tx_timeout,
 	.ndo_change_mtu		= ena_change_mtu,
Index: drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
===================================================================
--- drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c	(revision 55465)
+++ drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c	(revision 55464)
@@ -2990,10 +2990,7 @@
 	int ret;
 
 	hdev->support_sfp_query = true;
-
-	if (!test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state))
-		hdev->hw.mac.duplex = HCLGE_MAC_FULL;
-
+	hdev->hw.mac.duplex = HCLGE_MAC_FULL;
 	ret = hclge_cfg_mac_speed_dup_hw(hdev, hdev->hw.mac.speed,
 					 hdev->hw.mac.duplex, hdev->hw.mac.lane_num);
 	if (ret)
Index: drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c
===================================================================
--- drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c	(revision 55465)
+++ drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c	(revision 55464)
@@ -120,7 +120,7 @@
 	u64 ns = nsec;
 	u32 sec_h;
 
-	if (!hdev->ptp || !test_bit(HCLGE_PTP_FLAG_RX_EN, &hdev->ptp->flags))
+	if (!test_bit(HCLGE_PTP_FLAG_RX_EN, &hdev->ptp->flags))
 		return;
 
 	/* Since the BD does not have enough space for the higher 16 bits of
Index: drivers/net/ethernet/hisilicon/hns3/hns3_dcbnl.c
===================================================================
--- drivers/net/ethernet/hisilicon/hns3/hns3_dcbnl.c	(revision 55465)
+++ drivers/net/ethernet/hisilicon/hns3/hns3_dcbnl.c	(revision 55464)
@@ -76,7 +76,7 @@
 	if (hns3_nic_resetting(ndev))
 		return -EBUSY;
 
-	if (h->kinfo.dcb_ops->ieee_delapp)
+	if (h->kinfo.dcb_ops->ieee_setapp)
 		return h->kinfo.dcb_ops->ieee_delapp(h, app);
 
 	return -EOPNOTSUPP;
Index: drivers/net/ethernet/mediatek/mtk_eth_soc.c
===================================================================
--- drivers/net/ethernet/mediatek/mtk_eth_soc.c	(revision 55465)
+++ drivers/net/ethernet/mediatek/mtk_eth_soc.c	(revision 55464)
@@ -769,7 +769,8 @@
 	mcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
 	mcr_new = mcr_cur;
 	mcr_new |= MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
-		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_RX_FIFO_CLR_DIS;
+		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK |
+		   MAC_MCR_RX_FIFO_CLR_DIS;
 
 	/* Only update control register when needed! */
 	if (mcr_new != mcr_cur)
@@ -860,7 +861,7 @@
 
 	if (!mtk_interface_mode_is_xgmii(interface)) {
 		mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
-		mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN | MAC_MCR_FORCE_LINK);
+		mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN);
 		mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 	} else if (mac->id != MTK_GMAC1_ID) {
 		mcr = mtk_r32(mac->hw, MTK_XMAC_MCR(mac->id));
@@ -973,7 +974,7 @@
 	if (rx_pause)
 		mcr |= MAC_MCR_FORCE_RX_FC;
 
-	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN | MAC_MCR_FORCE_LINK;
+	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN;
 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
 }
 
Index: drivers/net/ethernet/mediatek/mtk_ppe.c
===================================================================
--- drivers/net/ethernet/mediatek/mtk_ppe.c	(revision 55465)
+++ drivers/net/ethernet/mediatek/mtk_ppe.c	(revision 55464)
@@ -985,7 +985,7 @@
 			 MTK_PPE_KEEPALIVE_DISABLE) |
 	      FIELD_PREP(MTK_PPE_TB_CFG_HASH_MODE, 1) |
 	      FIELD_PREP(MTK_PPE_TB_CFG_SCAN_MODE,
-			 MTK_PPE_SCAN_MODE_CHECK_AGE) |
+			 MTK_PPE_SCAN_MODE_KEEPALIVE_AGE) |
 	      FIELD_PREP(MTK_PPE_TB_CFG_ENTRY_NUM,
 			 MTK_PPE_ENTRIES_SHIFT);
 	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V2))
@@ -1079,21 +1079,17 @@
 
 	mtk_ppe_cache_enable(ppe, false);
 
+	/* disable offload engine */
+	ppe_clear(ppe, MTK_PPE_GLO_CFG, MTK_PPE_GLO_CFG_EN);
+	ppe_w32(ppe, MTK_PPE_FLOW_CFG, 0);
+
 	/* disable aging */
 	val = MTK_PPE_TB_CFG_AGE_NON_L4 |
 	      MTK_PPE_TB_CFG_AGE_UNBIND |
 	      MTK_PPE_TB_CFG_AGE_TCP |
 	      MTK_PPE_TB_CFG_AGE_UDP |
-	      MTK_PPE_TB_CFG_AGE_TCP_FIN |
-		  MTK_PPE_TB_CFG_SCAN_MODE;
+	      MTK_PPE_TB_CFG_AGE_TCP_FIN;
 	ppe_clear(ppe, MTK_PPE_TB_CFG, val);
 
-	if (mtk_ppe_wait_busy(ppe))
-		return -ETIMEDOUT;
-
-	/* disable offload engine */
-	ppe_clear(ppe, MTK_PPE_GLO_CFG, MTK_PPE_GLO_CFG_EN);
-	ppe_w32(ppe, MTK_PPE_FLOW_CFG, 0);
-
-	return 0;
+	return mtk_ppe_wait_busy(ppe);
 }
Index: drivers/net/usb/smsc95xx.c
===================================================================
--- drivers/net/usb/smsc95xx.c	(revision 55465)
+++ drivers/net/usb/smsc95xx.c	(revision 55464)
@@ -2105,11 +2105,6 @@
 		.driver_info = (unsigned long) &smsc95xx_info,
 	},
 	{
-		/* SYSTEC USB-SPEmodule1 10BASE-T1L Ethernet Device */
-		USB_DEVICE(0x0878, 0x1400),
-		.driver_info = (unsigned long)&smsc95xx_info,
-	},
-	{
 		/* Microchip's EVB-LAN8670-USB 10BASE-T1S Ethernet Device */
 		USB_DEVICE(0x184F, 0x0051),
 		.driver_info = (unsigned long)&smsc95xx_info,
Index: drivers/net/usb/sr9800.c
===================================================================
--- drivers/net/usb/sr9800.c	(revision 55465)
+++ drivers/net/usb/sr9800.c	(revision 55464)
@@ -737,9 +737,7 @@
 
 	data->eeprom_len = SR9800_EEPROM_LEN;
 
-	ret = usbnet_get_endpoints(dev, intf);
-	if (ret)
-		goto out;
+	usbnet_get_endpoints(dev, intf);
 
 	/* LED Setting Rule :
 	 * AABB:CCDD
Index: drivers/net/veth.c
===================================================================
--- drivers/net/veth.c	(revision 55465)
+++ drivers/net/veth.c	(revision 55464)
@@ -1444,6 +1444,8 @@
 		if (peer_priv->_xdp_prog)
 			features &= ~NETIF_F_GSO_SOFTWARE;
 	}
+	if (priv->_xdp_prog)
+		features |= NETIF_F_GRO;
 
 	return features;
 }
@@ -1540,6 +1542,14 @@
 		}
 
 		if (!old_prog) {
+			if (!veth_gro_requested(dev)) {
+				/* user-space did not require GRO, but adding
+				 * XDP is supposed to get GRO working
+				 */
+				dev->features |= NETIF_F_GRO;
+				netdev_features_change(dev);
+			}
+
 			peer->hw_features &= ~NETIF_F_GSO_SOFTWARE;
 			peer->max_mtu = max_mtu;
 		}
@@ -1550,6 +1560,14 @@
 			if (dev->flags & IFF_UP)
 				veth_disable_xdp(dev);
 
+			/* if user-space did not require GRO, since adding XDP
+			 * enabled it, clear it now
+			 */
+			if (!veth_gro_requested(dev)) {
+				dev->features &= ~NETIF_F_GRO;
+				netdev_features_change(dev);
+			}
+
 			if (peer) {
 				peer->hw_features |= NETIF_F_GSO_SOFTWARE;
 				peer->max_mtu = ETH_MAX_MTU;
Index: drivers/net/phy/phy_device.c
===================================================================
--- drivers/net/phy/phy_device.c	(revision 55465)
+++ drivers/net/phy/phy_device.c	(revision 55464)
@@ -2646,8 +2646,8 @@
 int genphy_loopback(struct phy_device *phydev, bool enable)
 {
 	if (enable) {
-		u16 ctl = BMCR_LOOPBACK;
-		int ret, val;
+		u16 val, ctl = BMCR_LOOPBACK;
+		int ret;
 
 		ctl |= mii_bmcr_encode_fixed(phydev->speed, phydev->duplex);
 
@@ -2899,7 +2899,7 @@
 	if (delay < 0)
 		return delay;
 
-	if (size == 0)
+	if (delay && size == 0)
 		return delay;
 
 	if (delay < delay_values[0] || delay > delay_values[size - 1]) {
Index: drivers/net/phy/dp83822.c
===================================================================
--- drivers/net/phy/dp83822.c	(revision 55465)
+++ drivers/net/phy/dp83822.c	(revision 55464)
@@ -380,7 +380,7 @@
 {
 	struct dp83822_private *dp83822 = phydev->priv;
 	struct device *dev = &phydev->mdio.dev;
-	int rgmii_delay = 0;
+	int rgmii_delay;
 	s32 rx_int_delay;
 	s32 tx_int_delay;
 	int err = 0;
@@ -390,33 +390,30 @@
 		rx_int_delay = phy_get_internal_delay(phydev, dev, NULL, 0,
 						      true);
 
-		/* Set DP83822_RX_CLK_SHIFT to enable rx clk internal delay */
-		if (rx_int_delay > 0)
-			rgmii_delay |= DP83822_RX_CLK_SHIFT;
+		if (rx_int_delay <= 0)
+			rgmii_delay = 0;
+		else
+			rgmii_delay = DP83822_RX_CLK_SHIFT;
 
 		tx_int_delay = phy_get_internal_delay(phydev, dev, NULL, 0,
 						      false);
-
-		/* Set DP83822_TX_CLK_SHIFT to disable tx clk internal delay */
 		if (tx_int_delay <= 0)
+			rgmii_delay &= ~DP83822_TX_CLK_SHIFT;
+		else
 			rgmii_delay |= DP83822_TX_CLK_SHIFT;
 
-		err = phy_modify_mmd(phydev, DP83822_DEVADDR, MII_DP83822_RCSR,
-				     DP83822_RX_CLK_SHIFT | DP83822_TX_CLK_SHIFT, rgmii_delay);
-		if (err)
-			return err;
+		if (rgmii_delay) {
+			err = phy_set_bits_mmd(phydev, DP83822_DEVADDR,
+					       MII_DP83822_RCSR, rgmii_delay);
+			if (err)
+				return err;
+		}
 
-		err = phy_set_bits_mmd(phydev, DP83822_DEVADDR,
-				       MII_DP83822_RCSR, DP83822_RGMII_MODE_EN);
-
-		if (err)
-			return err;
+		phy_set_bits_mmd(phydev, DP83822_DEVADDR,
+					MII_DP83822_RCSR, DP83822_RGMII_MODE_EN);
 	} else {
-		err = phy_clear_bits_mmd(phydev, DP83822_DEVADDR,
-					 MII_DP83822_RCSR, DP83822_RGMII_MODE_EN);
-
-		if (err)
-			return err;
+		phy_clear_bits_mmd(phydev, DP83822_DEVADDR,
+					MII_DP83822_RCSR, DP83822_RGMII_MODE_EN);
 	}
 
 	if (dp83822->fx_enabled) {
Index: drivers/net/wireless/intel/iwlwifi/fw/acpi.c
===================================================================
--- drivers/net/wireless/intel/iwlwifi/fw/acpi.c	(revision 55465)
+++ drivers/net/wireless/intel/iwlwifi/fw/acpi.c	(revision 55464)
@@ -725,7 +725,7 @@
 	 * from index 1, so the maximum value allowed here is
 	 * ACPI_SAR_PROFILES_NUM - 1.
 	 */
-	if (n_profiles >= ACPI_SAR_PROFILE_NUM) {
+	if (n_profiles <= 0 || n_profiles >= ACPI_SAR_PROFILE_NUM) {
 		ret = -EINVAL;
 		goto out_free;
 	}
Index: drivers/net/wireless/intel/iwlwifi/iwl-dbg-tlv.c
===================================================================
--- drivers/net/wireless/intel/iwlwifi/iwl-dbg-tlv.c	(revision 55465)
+++ drivers/net/wireless/intel/iwlwifi/iwl-dbg-tlv.c	(revision 55464)
@@ -103,12 +103,6 @@
 	if (le32_to_cpu(tlv->length) != sizeof(*debug_info))
 		return -EINVAL;
 
-	/* we use this as a string, ensure input was NUL terminated */
-	if (strnlen(debug_info->debug_cfg_name,
-		    sizeof(debug_info->debug_cfg_name)) ==
-			sizeof(debug_info->debug_cfg_name))
-		return -EINVAL;
-
 	IWL_DEBUG_FW(trans, "WRT: Loading debug cfg: %s\n",
 		     debug_info->debug_cfg_name);
 
Index: drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c
===================================================================
--- drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c	(revision 55465)
+++ drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c	(revision 55464)
@@ -299,7 +299,6 @@
 				u32 status,
 				struct ieee80211_rx_status *stats)
 {
-	struct wireless_dev *wdev;
 	struct iwl_mvm_sta *mvmsta;
 	struct iwl_mvm_vif *mvmvif;
 	u8 keyid;
@@ -321,15 +320,9 @@
 	if (!ieee80211_is_beacon(hdr->frame_control))
 		return 0;
 
-	if (!sta)
-		return -1;
-
-	mvmsta = iwl_mvm_sta_from_mac80211(sta);
-	mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);
-
 	/* key mismatch - will also report !MIC_OK but we shouldn't count it */
 	if (!(status & IWL_RX_MPDU_STATUS_KEY_VALID))
-		goto report;
+		return -1;
 
 	/* good cases */
 	if (likely(status & IWL_RX_MPDU_STATUS_MIC_OK &&
@@ -338,6 +331,13 @@
 		return 0;
 	}
 
+	if (!sta)
+		return -1;
+
+	mvmsta = iwl_mvm_sta_from_mac80211(sta);
+
+	mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);
+
 	/*
 	 * both keys will have the same cipher and MIC length, use
 	 * whichever one is available
@@ -346,11 +346,11 @@
 	if (!key) {
 		key = rcu_dereference(mvmvif->bcn_prot.keys[1]);
 		if (!key)
-			goto report;
+			return -1;
 	}
 
 	if (len < key->icv_len + IEEE80211_GMAC_PN_LEN + 2)
-		goto report;
+		return -1;
 
 	/* get the real key ID */
 	keyid = frame[len - key->icv_len - IEEE80211_GMAC_PN_LEN - 2];
@@ -364,7 +364,7 @@
 			return -1;
 		key = rcu_dereference(mvmvif->bcn_prot.keys[keyid - 6]);
 		if (!key)
-			goto report;
+			return -1;
 	}
 
 	/* Report status to mac80211 */
@@ -372,10 +372,6 @@
 		ieee80211_key_mic_failure(key);
 	else if (status & IWL_RX_MPDU_STATUS_REPLAY_ERROR)
 		ieee80211_key_replay(key);
-report:
-	wdev = ieee80211_vif_to_wdev(mvmsta->vif);
-	if (wdev->netdev)
-		cfg80211_rx_unprot_mlme_mgmt(wdev->netdev, (void *)hdr, len);
 
 	return -1;
 }
Index: drivers/net/wireless/intel/iwlwifi/mvm/d3.c
===================================================================
--- drivers/net/wireless/intel/iwlwifi/mvm/d3.c	(revision 55465)
+++ drivers/net/wireless/intel/iwlwifi/mvm/d3.c	(revision 55464)
@@ -461,10 +461,12 @@
 		struct wowlan_key_rsc_v5_data data = {};
 		int i;
 
-		data.rsc = kzalloc(sizeof(*data.rsc), GFP_KERNEL);
+		data.rsc = kmalloc(sizeof(*data.rsc), GFP_KERNEL);
 		if (!data.rsc)
 			return -ENOMEM;
 
+		memset(data.rsc, 0xff, sizeof(*data.rsc));
+
 		for (i = 0; i < ARRAY_SIZE(data.rsc->mcast_key_id_map); i++)
 			data.rsc->mcast_key_id_map[i] =
 				IWL_MCAST_KEY_MAP_INVALID;
Index: drivers/net/wireless/marvell/mwifiex/debugfs.c
===================================================================
--- drivers/net/wireless/marvell/mwifiex/debugfs.c	(revision 55465)
+++ drivers/net/wireless/marvell/mwifiex/debugfs.c	(revision 55464)
@@ -964,6 +964,9 @@
 	priv->dfs_dev_dir = debugfs_create_dir(priv->netdev->name,
 					       mwifiex_dfs_dir);
 
+	if (!priv->dfs_dev_dir)
+		return;
+
 	MWIFIEX_DFS_ADD_FILE(info);
 	MWIFIEX_DFS_ADD_FILE(debug);
 	MWIFIEX_DFS_ADD_FILE(getlog);
Index: drivers/net/wireless/marvell/libertas/cmd.c
===================================================================
--- drivers/net/wireless/marvell/libertas/cmd.c	(revision 55465)
+++ drivers/net/wireless/marvell/libertas/cmd.c	(revision 55464)
@@ -1132,7 +1132,7 @@
 		if (!cmdarray[i].cmdbuf) {
 			lbs_deb_host("ALLOC_CMD_BUF: ptempvirtualaddr is NULL\n");
 			ret = -1;
-			goto free_cmd_array;
+			goto done;
 		}
 	}
 
@@ -1140,17 +1140,8 @@
 		init_waitqueue_head(&cmdarray[i].cmdwait_q);
 		lbs_cleanup_and_insert_cmd(priv, &cmdarray[i]);
 	}
-	return 0;
+	ret = 0;
 
-free_cmd_array:
-	for (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {
-		if (cmdarray[i].cmdbuf) {
-			kfree(cmdarray[i].cmdbuf);
-			cmdarray[i].cmdbuf = NULL;
-		}
-	}
-	kfree(priv->cmd_array);
-	priv->cmd_array = NULL;
 done:
 	return ret;
 }
Index: drivers/net/wireless/ath/ath11k/mac.c
===================================================================
--- drivers/net/wireless/ath/ath11k/mac.c	(revision 55465)
+++ drivers/net/wireless/ath/ath11k/mac.c	(revision 55464)
@@ -2112,8 +2112,6 @@
 	mcs_160_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);
 	mcs_80_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);
 
-	/* Initialize rx_mcs_160 to 9 which is an invalid value */
-	rx_mcs_160 = 9;
 	if (support_160) {
 		for (i = 7; i >= 0; i--) {
 			u8 mcs_160 = (mcs_160_map >> (2 * i)) & 3;
@@ -2125,8 +2123,6 @@
 		}
 	}
 
-	/* Initialize rx_mcs_80 to 9 which is an invalid value */
-	rx_mcs_80 = 9;
 	for (i = 7; i >= 0; i--) {
 		u8 mcs_80 = (mcs_80_map >> (2 * i)) & 3;
 
Index: drivers/net/wireless/ath/ath9k/htc_drv_txrx.c
===================================================================
--- drivers/net/wireless/ath/ath9k/htc_drv_txrx.c	(revision 55465)
+++ drivers/net/wireless/ath/ath9k/htc_drv_txrx.c	(revision 55464)
@@ -815,6 +815,10 @@
 	skb_queue_head_init(&priv->tx.data_vo_queue);
 	skb_queue_head_init(&priv->tx.tx_failed);
 
+	/* Allow ath9k_wmi_event_tasklet(WMI_TXSTATUS_EVENTID) to operate. */
+	smp_wmb();
+	priv->tx.initialized = true;
+
 	return 0;
 }
 
Index: drivers/net/wireless/ath/ath9k/wmi.c
===================================================================
--- drivers/net/wireless/ath/ath9k/wmi.c	(revision 55465)
+++ drivers/net/wireless/ath/ath9k/wmi.c	(revision 55464)
@@ -155,12 +155,6 @@
 		}
 		spin_unlock_irqrestore(&wmi->wmi_lock, flags);
 
-		/* Check if ath9k_htc_probe_device() completed. */
-		if (!data_race(priv->initialized)) {
-			kfree_skb(skb);
-			continue;
-		}
-
 		hdr = (struct wmi_cmd_hdr *) skb->data;
 		cmd_id = be16_to_cpu(hdr->command_id);
 		wmi_event = skb_pull(skb, sizeof(struct wmi_cmd_hdr));
@@ -175,6 +169,10 @@
 					     &wmi->drv_priv->fatal_work);
 			break;
 		case WMI_TXSTATUS_EVENTID:
+			/* Check if ath9k_tx_init() completed. */
+			if (!data_race(priv->tx.initialized))
+				break;
+
 			spin_lock_bh(&priv->tx.tx_lock);
 			if (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {
 				spin_unlock_bh(&priv->tx.tx_lock);
Index: drivers/net/wireless/ath/ath9k/htc.h
===================================================================
--- drivers/net/wireless/ath/ath9k/htc.h	(revision 55465)
+++ drivers/net/wireless/ath/ath9k/htc.h	(revision 55464)
@@ -306,6 +306,7 @@
 	DECLARE_BITMAP(tx_slot, MAX_TX_BUF_NUM);
 	struct timer_list cleanup_timer;
 	spinlock_t tx_lock;
+	bool initialized;
 };
 
 struct ath9k_htc_tx_ctl {
@@ -514,7 +515,6 @@
 	unsigned long ps_usecount;
 	bool ps_enabled;
 	bool ps_idle;
-	bool initialized;
 
 #ifdef CONFIG_MAC80211_LEDS
 	enum led_brightness brightness;
Index: drivers/net/wireless/ath/ath9k/htc_drv_init.c
===================================================================
--- drivers/net/wireless/ath/ath9k/htc_drv_init.c	(revision 55465)
+++ drivers/net/wireless/ath/ath9k/htc_drv_init.c	(revision 55464)
@@ -966,10 +966,6 @@
 
 	htc_handle->drv_priv = priv;
 
-	/* Allow ath9k_wmi_event_tasklet() to operate. */
-	smp_wmb();
-	priv->initialized = true;
-
 	return 0;
 
 err_init:
Index: drivers/net/wireless/ath/ath10k/wmi-tlv.c
===================================================================
--- drivers/net/wireless/ath/ath10k/wmi-tlv.c	(revision 55465)
+++ drivers/net/wireless/ath/ath10k/wmi-tlv.c	(revision 55464)
@@ -844,10 +844,6 @@
 	}
 
 	ev = tb[WMI_TLV_TAG_STRUCT_MGMT_TX_COMPL_EVENT];
-	if (!ev) {
-		kfree(tb);
-		return -EPROTO;
-	}
 
 	arg->desc_id = ev->desc_id;
 	arg->status = ev->status;
Index: drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
===================================================================
--- drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c	(revision 55465)
+++ drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c	(revision 55464)
@@ -6542,7 +6542,6 @@
 	if (priv->usb_interrupts)
 		rtl8xxxu_write32(priv, REG_USB_HIMR, 0);
 
-	cancel_work_sync(&priv->c2hcmd_work);
 	cancel_delayed_work_sync(&priv->ra_watchdog);
 
 	rtl8xxxu_free_rx_resources(priv);
Index: drivers/net/wireless/realtek/rtw88/main.c
===================================================================
--- drivers/net/wireless/realtek/rtw88/main.c	(revision 55465)
+++ drivers/net/wireless/realtek/rtw88/main.c	(revision 55464)
@@ -1989,6 +1989,8 @@
 	rtw_phy_setup_phy_cond(rtwdev, 0);
 
 	rtw_phy_init_tx_power(rtwdev);
+	if (rfe_def->agc_btg_tbl)
+		rtw_load_table(rtwdev, rfe_def->agc_btg_tbl);
 	rtw_load_table(rtwdev, rfe_def->phy_pg_tbl);
 	rtw_load_table(rtwdev, rfe_def->txpwr_lmt_tbl);
 	rtw_phy_tx_power_by_rate_config(hal);
Index: drivers/net/wireless/realtek/rtw88/phy.c
===================================================================
--- drivers/net/wireless/realtek/rtw88/phy.c	(revision 55465)
+++ drivers/net/wireless/realtek/rtw88/phy.c	(revision 55464)
@@ -1761,7 +1761,6 @@
 
 void rtw_phy_load_tables(struct rtw_dev *rtwdev)
 {
-	const struct rtw_rfe_def *rfe_def = rtw_get_rfe_def(rtwdev);
 	const struct rtw_chip_info *chip = rtwdev->chip;
 	u8 rf_path;
 
@@ -1768,8 +1767,6 @@
 	rtw_load_table(rtwdev, chip->mac_tbl);
 	rtw_load_table(rtwdev, chip->bb_tbl);
 	rtw_load_table(rtwdev, chip->agc_tbl);
-	if (rfe_def->agc_btg_tbl)
-		rtw_load_table(rtwdev, rfe_def->agc_btg_tbl);
 	rtw_load_rfk_table(rtwdev);
 
 	for (rf_path = 0; rf_path < rtwdev->hal.rf_path_num; rf_path++) {
Index: drivers/net/wireless/realtek/rtw88/rtw8821c.c
===================================================================
--- drivers/net/wireless/realtek/rtw88/rtw8821c.c	(revision 55465)
+++ drivers/net/wireless/realtek/rtw88/rtw8821c.c	(revision 55464)
@@ -674,9 +674,9 @@
 
 	dm_info->cck_fa_cnt = cck_fa_cnt;
 	dm_info->ofdm_fa_cnt = ofdm_fa_cnt;
-	dm_info->total_fa_cnt = ofdm_fa_cnt;
 	if (cck_enable)
 		dm_info->total_fa_cnt += cck_fa_cnt;
+	dm_info->total_fa_cnt = ofdm_fa_cnt;
 
 	crc32_cnt = rtw_read32(rtwdev, REG_CRC_CCK);
 	dm_info->cck_ok_cnt = FIELD_GET(GENMASK(15, 0), crc32_cnt);
Index: drivers/net/wireless/silabs/wfx/sta.c
===================================================================
--- drivers/net/wireless/silabs/wfx/sta.c	(revision 55465)
+++ drivers/net/wireless/silabs/wfx/sta.c	(revision 55464)
@@ -362,7 +362,6 @@
 	const int pairwise_cipher_suite_count_offset = 8 / sizeof(u16);
 	const int pairwise_cipher_suite_size = 4 / sizeof(u16);
 	const int akm_suite_size = 4 / sizeof(u16);
-	int ret = -EINVAL;
 	const u16 *ptr;
 
 	if (unlikely(!skb))
@@ -371,26 +370,22 @@
 	ptr = (u16 *)cfg80211_find_ie(WLAN_EID_RSN, skb->data + ieoffset,
 				      skb->len - ieoffset);
 	if (unlikely(!ptr))
-		goto free_skb;
+		return -EINVAL;
 
 	ptr += pairwise_cipher_suite_count_offset;
 	if (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))
-		goto free_skb;
+		return -EINVAL;
 
 	ptr += 1 + pairwise_cipher_suite_size * *ptr;
 	if (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))
-		goto free_skb;
+		return -EINVAL;
 
 	ptr += 1 + akm_suite_size * *ptr;
 	if (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))
-		goto free_skb;
+		return -EINVAL;
 
 	wfx_hif_set_mfp(wvif, *ptr & BIT(7), *ptr & BIT(6));
-	ret = 0;
-
-free_skb:
-	dev_kfree_skb(skb);
-	return ret;
+	return 0;
 }
 
 int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
Index: drivers/net/wireless/microchip/wilc1000/hif.c
===================================================================
--- drivers/net/wireless/microchip/wilc1000/hif.c	(revision 55465)
+++ drivers/net/wireless/microchip/wilc1000/hif.c	(revision 55464)
@@ -374,29 +374,18 @@
 void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
 				struct cfg80211_crypto_settings *crypto)
 {
-	const u8 *ies_data, *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;
+	struct wilc_join_bss_param *param;
+	struct ieee80211_p2p_noa_attr noa_attr;
+	u8 rates_len = 0;
+	const u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;
 	const u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;
-	struct ieee80211_p2p_noa_attr noa_attr;
-	const struct cfg80211_bss_ies *ies;
-	struct wilc_join_bss_param *param;
-	u8 rates_len = 0, ies_len;
 	int ret;
+	const struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);
 
 	param = kzalloc(sizeof(*param), GFP_KERNEL);
 	if (!param)
 		return NULL;
 
-	rcu_read_lock();
-	ies = rcu_dereference(bss->ies);
-	ies_data = kmemdup(ies->data, ies->len, GFP_ATOMIC);
-	if (!ies_data) {
-		rcu_read_unlock();
-		kfree(param);
-		return NULL;
-	}
-	ies_len = ies->len;
-	rcu_read_unlock();
-
 	param->beacon_period = cpu_to_le16(bss->beacon_interval);
 	param->cap_info = cpu_to_le16(bss->capability);
 	param->bss_type = WILC_FW_BSS_TYPE_INFRA;
@@ -403,13 +392,13 @@
 	param->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);
 	ether_addr_copy(param->bssid, bss->bssid);
 
-	ssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies_data, ies_len);
+	ssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
 	if (ssid_elm) {
 		if (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)
 			memcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);
 	}
 
-	tim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies_data, ies_len);
+	tim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
 	if (tim_elm && tim_elm[1] >= 2)
 		param->dtim_period = tim_elm[3];
 
@@ -416,7 +405,7 @@
 	memset(param->p_suites, 0xFF, 3);
 	memset(param->akm_suites, 0xFF, 3);
 
-	rates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies_data, ies_len);
+	rates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);
 	if (rates_ie) {
 		rates_len = rates_ie[1];
 		if (rates_len > WILC_MAX_RATES_SUPPORTED)
@@ -427,7 +416,7 @@
 
 	if (rates_len < WILC_MAX_RATES_SUPPORTED) {
 		supp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,
-						 ies_data, ies_len);
+						 ies->data, ies->len);
 		if (supp_rates_ie) {
 			u8 ext_rates = supp_rates_ie[1];
 
@@ -442,11 +431,11 @@
 		}
 	}
 
-	ht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies_data, ies_len);
+	ht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);
 	if (ht_ie)
 		param->ht_capable = true;
 
-	ret = cfg80211_get_p2p_attr(ies_data, ies_len,
+	ret = cfg80211_get_p2p_attr(ies->data, ies->len,
 				    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 				    (u8 *)&noa_attr, sizeof(noa_attr));
 	if (ret > 0) {
@@ -470,7 +459,7 @@
 	}
 	wmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
 					 WLAN_OUI_TYPE_MICROSOFT_WMM,
-					 ies_data, ies_len);
+					 ies->data, ies->len);
 	if (wmm_ie) {
 		struct ieee80211_wmm_param_ie *ie;
 
@@ -485,13 +474,13 @@
 
 	wpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
 					 WLAN_OUI_TYPE_MICROSOFT_WPA,
-					 ies_data, ies_len);
+					 ies->data, ies->len);
 	if (wpa_ie) {
 		param->mode_802_11i = 1;
 		param->rsn_found = true;
 	}
 
-	rsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies_data, ies_len);
+	rsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);
 	if (rsn_ie) {
 		int rsn_ie_len = sizeof(struct element) + rsn_ie[1];
 		int offset = 8;
@@ -525,7 +514,6 @@
 			param->akm_suites[i] = crypto->akm_suites[i] & 0xFF;
 	}
 
-	kfree(ies_data);
 	return (void *)param;
 }
 
Index: drivers/net/wireless/microchip/wilc1000/cfg80211.c
===================================================================
--- drivers/net/wireless/microchip/wilc1000/cfg80211.c	(revision 55465)
+++ drivers/net/wireless/microchip/wilc1000/cfg80211.c	(revision 55464)
@@ -1615,6 +1615,7 @@
 	cfg80211_unregister_netdevice(vif->ndev);
 	vif->monitor_flag = 0;
 
+	wilc_set_operation_mode(vif, 0, 0, 0);
 	mutex_lock(&wl->vif_mutex);
 	list_del_rcu(&vif->list);
 	wl->vif_num--;
@@ -1809,24 +1810,15 @@
 	INIT_LIST_HEAD(&wl->rxq_head.list);
 	INIT_LIST_HEAD(&wl->vif_list);
 
-	wl->hif_workqueue = alloc_ordered_workqueue("%s", WQ_MEM_RECLAIM,
-						    wiphy_name(wl->wiphy));
-	if (!wl->hif_workqueue) {
-		ret = -ENOMEM;
-		goto free_cfg;
-	}
 	vif = wilc_netdev_ifc_init(wl, "wlan%d", WILC_STATION_MODE,
 				   NL80211_IFTYPE_STATION, false);
 	if (IS_ERR(vif)) {
 		ret = PTR_ERR(vif);
-		goto free_hq;
+		goto free_cfg;
 	}
 
 	return 0;
 
-free_hq:
-	destroy_workqueue(wl->hif_workqueue);
-
 free_cfg:
 	wilc_wlan_cfg_deinit(wl);
 
Index: drivers/net/wireless/microchip/wilc1000/netdev.c
===================================================================
--- drivers/net/wireless/microchip/wilc1000/netdev.c	(revision 55465)
+++ drivers/net/wireless/microchip/wilc1000/netdev.c	(revision 55464)
@@ -878,7 +878,8 @@
 
 void wilc_netdev_cleanup(struct wilc *wilc)
 {
-	struct wilc_vif *vif, *vif_tmp;
+	struct wilc_vif *vif;
+	int srcu_idx, ifc_cnt = 0;
 
 	if (!wilc)
 		return;
@@ -888,19 +889,32 @@
 		wilc->firmware = NULL;
 	}
 
-	list_for_each_entry_safe(vif, vif_tmp, &wilc->vif_list, list) {
-		mutex_lock(&wilc->vif_mutex);
-		list_del_rcu(&vif->list);
-		wilc->vif_num--;
-		mutex_unlock(&wilc->vif_mutex);
-		synchronize_srcu(&wilc->srcu);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
 		if (vif->ndev)
 			unregister_netdev(vif->ndev);
 	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 
 	wilc_wfi_deinit_mon_interface(wilc, false);
 	destroy_workqueue(wilc->hif_workqueue);
 
+	while (ifc_cnt < WILC_NUM_CONCURRENT_IFC) {
+		mutex_lock(&wilc->vif_mutex);
+		if (wilc->vif_num <= 0) {
+			mutex_unlock(&wilc->vif_mutex);
+			break;
+		}
+		vif = wilc_get_wl_to_vif(wilc);
+		if (!IS_ERR(vif))
+			list_del_rcu(&vif->list);
+
+		wilc->vif_num--;
+		mutex_unlock(&wilc->vif_mutex);
+		synchronize_srcu(&wilc->srcu);
+		ifc_cnt++;
+	}
+
 	wilc_wlan_cfg_deinit(wilc);
 	wlan_deinit_locks(wilc);
 	wiphy_unregister(wilc->wiphy);
@@ -963,6 +977,13 @@
 		goto error;
 	}
 
+	wl->hif_workqueue = alloc_ordered_workqueue("%s-wq", WQ_MEM_RECLAIM,
+						    ndev->name);
+	if (!wl->hif_workqueue) {
+		ret = -ENOMEM;
+		goto unregister_netdev;
+	}
+
 	ndev->needs_free_netdev = true;
 	vif->iftype = vif_type;
 	vif->idx = wilc_get_available_idx(wl);
@@ -975,11 +996,12 @@
 
 	return vif;
 
-error:
+unregister_netdev:
 	if (rtnl_locked)
 		cfg80211_unregister_netdevice(ndev);
 	else
 		unregister_netdev(ndev);
+  error:
 	free_netdev(ndev);
 	return ERR_PTR(ret);
 }
Index: drivers/net/wireless/microchip/wilc1000/spi.c
===================================================================
--- drivers/net/wireless/microchip/wilc1000/spi.c	(revision 55465)
+++ drivers/net/wireless/microchip/wilc1000/spi.c	(revision 55464)
@@ -191,11 +191,11 @@
 		/* assert ENABLE: */
 		gpiod_set_value(gpios->enable, 1);
 		mdelay(5);
+		/* assert RESET: */
+		gpiod_set_value(gpios->reset, 1);
+	} else {
 		/* deassert RESET: */
 		gpiod_set_value(gpios->reset, 0);
-	} else {
-		/* assert RESET: */
-		gpiod_set_value(gpios->reset, 1);
 		/* deassert ENABLE: */
 		gpiod_set_value(gpios->enable, 0);
 	}
Index: drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_cmn.c
===================================================================
--- drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_cmn.c	(revision 55465)
+++ drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_cmn.c	(revision 55464)
@@ -383,9 +383,8 @@
 	return sh;
 }
 
-static void wlc_phy_timercb_phycal(void *ptr)
+static void wlc_phy_timercb_phycal(struct brcms_phy *pi)
 {
-	struct brcms_phy *pi = ptr;
 	uint delay = 5;
 
 	if (PHY_PERICAL_MPHASE_PENDING(pi)) {
Index: drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.c
===================================================================
--- drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.c	(revision 55465)
+++ drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.c	(revision 55464)
@@ -57,11 +57,12 @@
 }
 
 struct wlapi_timer *wlapi_init_timer(struct phy_shim_info *physhim,
-				     void (*fn)(void *pi),
+				     void (*fn)(struct brcms_phy *pi),
 				     void *arg, const char *name)
 {
 	return (struct wlapi_timer *)
-			brcms_init_timer(physhim->wl, fn, arg, name);
+			brcms_init_timer(physhim->wl, (void (*)(void *))fn,
+					 arg, name);
 }
 
 void wlapi_free_timer(struct wlapi_timer *t)
Index: drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.h
===================================================================
--- drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.h	(revision 55465)
+++ drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy_shim.h	(revision 55464)
@@ -131,7 +131,7 @@
 
 /* PHY to WL utility functions */
 struct wlapi_timer *wlapi_init_timer(struct phy_shim_info *physhim,
-				     void (*fn)(void *pi),
+				     void (*fn)(struct brcms_phy *pi),
 				     void *arg, const char *name);
 void wlapi_free_timer(struct wlapi_timer *t);
 void wlapi_add_timer(struct wlapi_timer *t, uint ms, int periodic);
Index: drivers/net/wireless/broadcom/b43/b43.h
===================================================================
--- drivers/net/wireless/broadcom/b43/b43.h	(revision 55465)
+++ drivers/net/wireless/broadcom/b43/b43.h	(revision 55464)
@@ -1082,22 +1082,6 @@
 	return dev->__using_pio_transfers;
 }
 
-static inline void b43_wake_queue(struct b43_wldev *dev, int queue_prio)
-{
-	if (dev->qos_enabled)
-		ieee80211_wake_queue(dev->wl->hw, queue_prio);
-	else
-		ieee80211_wake_queue(dev->wl->hw, 0);
-}
-
-static inline void b43_stop_queue(struct b43_wldev *dev, int queue_prio)
-{
-	if (dev->qos_enabled)
-		ieee80211_stop_queue(dev->wl->hw, queue_prio);
-	else
-		ieee80211_stop_queue(dev->wl->hw, 0);
-}
-
 /* Message printing */
 __printf(2, 3) void b43info(struct b43_wl *wl, const char *fmt, ...);
 __printf(2, 3) void b43err(struct b43_wl *wl, const char *fmt, ...);
Index: drivers/net/wireless/broadcom/b43/dma.c
===================================================================
--- drivers/net/wireless/broadcom/b43/dma.c	(revision 55465)
+++ drivers/net/wireless/broadcom/b43/dma.c	(revision 55464)
@@ -1399,7 +1399,7 @@
 	    should_inject_overflow(ring)) {
 		/* This TX ring is full. */
 		unsigned int skb_mapping = skb_get_queue_mapping(skb);
-		b43_stop_queue(dev, skb_mapping);
+		ieee80211_stop_queue(dev->wl->hw, skb_mapping);
 		dev->wl->tx_queue_stopped[skb_mapping] = true;
 		ring->stopped = true;
 		if (b43_debug(dev, B43_DBG_DMAVERBOSE)) {
@@ -1570,7 +1570,7 @@
 	} else {
 		/* If the driver queue is running wake the corresponding
 		 * mac80211 queue. */
-		b43_wake_queue(dev, ring->queue_prio);
+		ieee80211_wake_queue(dev->wl->hw, ring->queue_prio);
 		if (b43_debug(dev, B43_DBG_DMAVERBOSE)) {
 			b43dbg(dev->wl, "Woke up TX ring %d\n", ring->index);
 		}
Index: drivers/net/wireless/broadcom/b43/main.c
===================================================================
--- drivers/net/wireless/broadcom/b43/main.c	(revision 55465)
+++ drivers/net/wireless/broadcom/b43/main.c	(revision 55464)
@@ -2587,8 +2587,7 @@
 
 start_ieee80211:
 	wl->hw->queues = B43_QOS_QUEUE_NUM;
-	if (!modparam_qos || dev->fw.opensource ||
-	    dev->dev->chip_id == BCMA_CHIP_ID_BCM4331)
+	if (!modparam_qos || dev->fw.opensource)
 		wl->hw->queues = 1;
 
 	err = ieee80211_register_hw(wl->hw);
@@ -3604,7 +3603,7 @@
 				err = b43_dma_tx(dev, skb);
 			if (err == -ENOSPC) {
 				wl->tx_queue_stopped[queue_num] = true;
-				b43_stop_queue(dev, queue_num);
+				ieee80211_stop_queue(wl->hw, queue_num);
 				skb_queue_head(&wl->tx_queue[queue_num], skb);
 				break;
 			}
@@ -3628,7 +3627,6 @@
 		      struct sk_buff *skb)
 {
 	struct b43_wl *wl = hw_to_b43_wl(hw);
-	u16 skb_queue_mapping;
 
 	if (unlikely(skb->len < 2 + 2 + 6)) {
 		/* Too short, this can't be a valid frame. */
@@ -3637,12 +3635,12 @@
 	}
 	B43_WARN_ON(skb_shinfo(skb)->nr_frags);
 
-	skb_queue_mapping = skb_get_queue_mapping(skb);
-	skb_queue_tail(&wl->tx_queue[skb_queue_mapping], skb);
-	if (!wl->tx_queue_stopped[skb_queue_mapping])
+	skb_queue_tail(&wl->tx_queue[skb->queue_mapping], skb);
+	if (!wl->tx_queue_stopped[skb->queue_mapping]) {
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
-	else
-		b43_stop_queue(wl->current_dev, skb_queue_mapping);
+	} else {
+		ieee80211_stop_queue(wl->hw, skb->queue_mapping);
+	}
 }
 
 static void b43_qos_params_upload(struct b43_wldev *dev,
Index: drivers/net/wireless/broadcom/b43/pio.c
===================================================================
--- drivers/net/wireless/broadcom/b43/pio.c	(revision 55465)
+++ drivers/net/wireless/broadcom/b43/pio.c	(revision 55464)
@@ -525,7 +525,7 @@
 	if (total_len > (q->buffer_size - q->buffer_used)) {
 		/* Not enough memory on the queue. */
 		err = -EBUSY;
-		b43_stop_queue(dev, skb_get_queue_mapping(skb));
+		ieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));
 		q->stopped = true;
 		goto out;
 	}
@@ -552,7 +552,7 @@
 	if (((q->buffer_size - q->buffer_used) < roundup(2 + 2 + 6, 4)) ||
 	    (q->free_packet_slots == 0)) {
 		/* The queue is full. */
-		b43_stop_queue(dev, skb_get_queue_mapping(skb));
+		ieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));
 		q->stopped = true;
 	}
 
@@ -587,7 +587,7 @@
 	list_add(&pack->list, &q->packets_list);
 
 	if (q->stopped) {
-		b43_wake_queue(dev, q->queue_prio);
+		ieee80211_wake_queue(dev->wl->hw, q->queue_prio);
 		q->stopped = false;
 	}
 }
Index: drivers/net/wireguard/receive.c
===================================================================
--- drivers/net/wireguard/receive.c	(revision 55465)
+++ drivers/net/wireguard/receive.c	(revision 55464)
@@ -251,7 +251,7 @@
 
 	if (unlikely(!READ_ONCE(keypair->receiving.is_valid) ||
 		  wg_birthdate_has_expired(keypair->receiving.birthdate, REJECT_AFTER_TIME) ||
-		  READ_ONCE(keypair->receiving_counter.counter) >= REJECT_AFTER_MESSAGES)) {
+		  keypair->receiving_counter.counter >= REJECT_AFTER_MESSAGES)) {
 		WRITE_ONCE(keypair->receiving.is_valid, false);
 		return false;
 	}
@@ -318,7 +318,7 @@
 		for (i = 1; i <= top; ++i)
 			counter->backtrack[(i + index_current) &
 				((COUNTER_BITS_TOTAL / BITS_PER_LONG) - 1)] = 0;
-		WRITE_ONCE(counter->counter, their_counter);
+		counter->counter = their_counter;
 	}
 
 	index &= (COUNTER_BITS_TOTAL / BITS_PER_LONG) - 1;
@@ -463,7 +463,7 @@
 			net_dbg_ratelimited("%s: Packet has invalid nonce %llu (max %llu)\n",
 					    peer->device->dev->name,
 					    PACKET_CB(skb)->nonce,
-					    READ_ONCE(keypair->receiving_counter.counter));
+					    keypair->receiving_counter.counter);
 			goto next;
 		}
 
Index: drivers/pci/pci.h
===================================================================
--- drivers/pci/pci.h	(revision 55465)
+++ drivers/pci/pci.h	(revision 55464)
@@ -357,6 +357,11 @@
 	return 0;
 }
 
+static inline bool pci_dev_is_disconnected(const struct pci_dev *dev)
+{
+	return dev->error_state == pci_channel_io_perm_failure;
+}
+
 /* pci_dev priv_flags */
 #define PCI_DEV_ADDED 0
 #define PCI_DPC_RECOVERED 1
Index: drivers/pci/pcie/dpc.c
===================================================================
--- drivers/pci/pcie/dpc.c	(revision 55465)
+++ drivers/pci/pcie/dpc.c	(revision 55464)
@@ -231,7 +231,7 @@
 
 	for (i = 0; i < pdev->dpc_rp_log_size - 5; i++) {
 		pci_read_config_dword(pdev,
-			cap + PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG + i * 4, &prefix);
+			cap + PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG, &prefix);
 		pci_err(pdev, "TLP Prefix Header: dw%d, %#010x\n", i, prefix);
 	}
  clear_status:
Index: drivers/pci/quirks.c
===================================================================
--- drivers/pci/quirks.c	(revision 55465)
+++ drivers/pci/quirks.c	(revision 55464)
@@ -5423,7 +5423,6 @@
 
 	pci_walk_bus(bridge->bus, pci_configure_extended_tags, NULL);
 }
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_3WARE, 0x1004, quirk_no_ext_tags);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0132, quirk_no_ext_tags);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0140, quirk_no_ext_tags);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0141, quirk_no_ext_tags);
Index: drivers/pci/switch/switchtec.c
===================================================================
--- drivers/pci/switch/switchtec.c	(revision 55465)
+++ drivers/pci/switch/switchtec.c	(revision 55464)
@@ -1674,7 +1674,7 @@
 	rc = switchtec_init_isr(stdev);
 	if (rc) {
 		dev_err(&stdev->dev, "failed to init isr.\n");
-		goto err_exit_pci;
+		goto err_put;
 	}
 
 	iowrite32(SWITCHTEC_EVENT_CLEAR |
@@ -1695,8 +1695,6 @@
 
 err_devadd:
 	stdev_kill(stdev);
-err_exit_pci:
-	switchtec_exit_pci(stdev);
 err_put:
 	ida_free(&switchtec_minor_ida, MINOR(stdev->dev.devt));
 	put_device(&stdev->dev);
Index: drivers/pci/endpoint/functions/pci-epf-vntb.c
===================================================================
--- drivers/pci/endpoint/functions/pci-epf-vntb.c	(revision 55465)
+++ drivers/pci/endpoint/functions/pci-epf-vntb.c	(revision 55464)
@@ -1281,11 +1281,14 @@
 	ret = ntb_register_device(&ndev->ntb);
 	if (ret) {
 		dev_err(dev, "Failed to register NTB device\n");
-		return ret;
+		goto err_register_dev;
 	}
 
 	dev_dbg(dev, "PCI Virtual NTB driver loaded\n");
 	return 0;
+
+err_register_dev:
+	return -EINVAL;
 }
 
 static struct pci_device_id pci_vntb_table[] = {
Index: drivers/scsi/mpt3sas/mpt3sas_base.c
===================================================================
--- drivers/scsi/mpt3sas/mpt3sas_base.c	(revision 55465)
+++ drivers/scsi/mpt3sas/mpt3sas_base.c	(revision 55464)
@@ -7398,9 +7398,7 @@
 		return -EFAULT;
 	}
 
-	return 0;
-
-issue_diag_reset:
+ issue_diag_reset:
 	rc = _base_diag_reset(ioc);
 	return rc;
 }
Index: drivers/scsi/bfa/bfa.h
===================================================================
--- drivers/scsi/bfa/bfa.h	(revision 55465)
+++ drivers/scsi/bfa/bfa.h	(revision 55464)
@@ -20,6 +20,7 @@
 struct bfa_s;
 
 typedef void (*bfa_isr_func_t) (struct bfa_s *bfa, struct bfi_msg_s *m);
+typedef void (*bfa_cb_cbfn_status_t) (void *cbarg, bfa_status_t status);
 
 /*
  * Interrupt message handlers
@@ -436,12 +437,4 @@
 	(__qe)->data = (__data);				\
 } while (0)
 
-#define bfa_pending_q_init_status(__qe, __cbfn, __cbarg, __data) do {	\
-	bfa_q_qe_init(&((__qe)->hcb_qe.qe));			\
-	(__qe)->hcb_qe.cbfn_status = (__cbfn);			\
-	(__qe)->hcb_qe.cbarg = (__cbarg);			\
-	(__qe)->hcb_qe.pre_rmv = BFA_TRUE;			\
-	(__qe)->data = (__data);				\
-} while (0)
-
 #endif /* __BFA_H__ */
Index: drivers/scsi/bfa/bfa_core.c
===================================================================
--- drivers/scsi/bfa/bfa_core.c	(revision 55465)
+++ drivers/scsi/bfa/bfa_core.c	(revision 55464)
@@ -1907,6 +1907,7 @@
 	struct list_head		*qe;
 	struct list_head		*qen;
 	struct bfa_cb_qe_s	*hcb_qe;
+	bfa_cb_cbfn_status_t	cbfn;
 
 	list_for_each_safe(qe, qen, comp_q) {
 		hcb_qe = (struct bfa_cb_qe_s *) qe;
@@ -1913,7 +1914,8 @@
 		if (hcb_qe->pre_rmv) {
 			/* qe is invalid after return, dequeue before cbfn() */
 			list_del(qe);
-			hcb_qe->cbfn_status(hcb_qe->cbarg, hcb_qe->fw_status);
+			cbfn = (bfa_cb_cbfn_status_t)(hcb_qe->cbfn);
+			cbfn(hcb_qe->cbarg, hcb_qe->fw_status);
 		} else
 			hcb_qe->cbfn(hcb_qe->cbarg, BFA_TRUE);
 	}
Index: drivers/scsi/bfa/bfa_ioc.h
===================================================================
--- drivers/scsi/bfa/bfa_ioc.h	(revision 55465)
+++ drivers/scsi/bfa/bfa_ioc.h	(revision 55464)
@@ -361,8 +361,7 @@
 	void	*cbarg;
 };
 
-typedef void (*bfa_cb_cbfn_t) (void *cbarg, bfa_boolean_t complete);
-typedef void (*bfa_cb_cbfn_status_t) (void *cbarg, bfa_status_t status);
+typedef void	(*bfa_cb_cbfn_t) (void *cbarg, bfa_boolean_t complete);
 
 /*
  * Generic BFA callback element.
@@ -369,10 +368,7 @@
  */
 struct bfa_cb_qe_s {
 	struct list_head	qe;
-	union {
-		bfa_cb_cbfn_status_t	cbfn_status;
-		bfa_cb_cbfn_t		cbfn;
-	};
+	bfa_cb_cbfn_t	cbfn;
 	bfa_boolean_t	once;
 	bfa_boolean_t	pre_rmv;	/* set for stack based qe(s) */
 	bfa_status_t	fw_status;	/* to access fw status in comp proc */
Index: drivers/scsi/bfa/bfad_bsg.c
===================================================================
--- drivers/scsi/bfa/bfad_bsg.c	(revision 55465)
+++ drivers/scsi/bfa/bfad_bsg.c	(revision 55464)
@@ -2135,7 +2135,8 @@
 	struct bfa_cb_pending_q_s cb_qe;
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init_status(&cb_qe, bfad_hcb_comp, &fcomp, &iocmd->stats);
+	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+			   &fcomp, &iocmd->stats);
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	iocmd->status = bfa_fcport_get_stats(&bfad->bfa, &cb_qe);
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
@@ -2158,7 +2159,7 @@
 	struct bfa_cb_pending_q_s cb_qe;
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init_status(&cb_qe, bfad_hcb_comp, &fcomp, NULL);
+	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp, &fcomp, NULL);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	iocmd->status = bfa_fcport_clear_stats(&bfad->bfa, &cb_qe);
@@ -2442,7 +2443,8 @@
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init_status(&cb_qe, bfad_hcb_comp, &fcomp, &iocmd->stats);
+	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+			   &fcomp, &iocmd->stats);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	WARN_ON(!bfa_ioc_get_fcmode(&bfad->bfa.ioc));
@@ -2472,7 +2474,8 @@
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);
 
 	init_completion(&fcomp.comp);
-	bfa_pending_q_init_status(&cb_qe, bfad_hcb_comp, &fcomp, NULL);
+	bfa_pending_q_init(&cb_qe, (bfa_cb_cbfn_t)bfad_hcb_comp,
+			   &fcomp, NULL);
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	WARN_ON(!bfa_ioc_get_fcmode(&bfad->bfa.ioc));
Index: drivers/scsi/csiostor/csio_defs.h
===================================================================
--- drivers/scsi/csiostor/csio_defs.h	(revision 55465)
+++ drivers/scsi/csiostor/csio_defs.h	(revision 55464)
@@ -73,22 +73,8 @@
 #define csio_list_prev(elem)	(((struct list_head *)(elem))->prev)
 
 /* State machine */
-struct csio_lnode;
+typedef void (*csio_sm_state_t)(void *, uint32_t);
 
-/* State machine evets */
-enum csio_ln_ev {
-	CSIO_LNE_NONE = (uint32_t)0,
-	CSIO_LNE_LINKUP,
-	CSIO_LNE_FAB_INIT_DONE,
-	CSIO_LNE_LINK_DOWN,
-	CSIO_LNE_DOWN_LINK,
-	CSIO_LNE_LOGO,
-	CSIO_LNE_CLOSE,
-	CSIO_LNE_MAX_EVENT,
-};
-
-typedef void (*csio_sm_state_t)(struct csio_lnode *ln, enum csio_ln_ev evt);
-
 struct csio_sm {
 	struct list_head	sm_list;
 	csio_sm_state_t		sm_state;
@@ -97,7 +83,7 @@
 static inline void
 csio_set_state(void *smp, void *state)
 {
-	((struct csio_sm *)smp)->sm_state = state;
+	((struct csio_sm *)smp)->sm_state = (csio_sm_state_t)state;
 }
 
 static inline void
Index: drivers/scsi/csiostor/csio_lnode.c
===================================================================
--- drivers/scsi/csiostor/csio_lnode.c	(revision 55465)
+++ drivers/scsi/csiostor/csio_lnode.c	(revision 55464)
@@ -1095,7 +1095,7 @@
 int
 csio_is_lnode_ready(struct csio_lnode *ln)
 {
-	return (csio_get_state(ln) == csio_lns_ready);
+	return (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready));
 }
 
 /*****************************************************************************/
@@ -1366,15 +1366,15 @@
 void
 csio_lnode_state_to_str(struct csio_lnode *ln, int8_t *str)
 {
-	if (csio_get_state(ln) == csio_lns_uninit) {
+	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_uninit)) {
 		strcpy(str, "UNINIT");
 		return;
 	}
-	if (csio_get_state(ln) == csio_lns_ready) {
+	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready)) {
 		strcpy(str, "READY");
 		return;
 	}
-	if (csio_get_state(ln) == csio_lns_offline) {
+	if (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_offline)) {
 		strcpy(str, "OFFLINE");
 		return;
 	}
Index: drivers/scsi/csiostor/csio_lnode.h
===================================================================
--- drivers/scsi/csiostor/csio_lnode.h	(revision 55465)
+++ drivers/scsi/csiostor/csio_lnode.h	(revision 55464)
@@ -53,6 +53,19 @@
 extern int csio_fcoe_rnodes;
 extern int csio_fdmi_enable;
 
+/* State machine evets */
+enum csio_ln_ev {
+	CSIO_LNE_NONE = (uint32_t)0,
+	CSIO_LNE_LINKUP,
+	CSIO_LNE_FAB_INIT_DONE,
+	CSIO_LNE_LINK_DOWN,
+	CSIO_LNE_DOWN_LINK,
+	CSIO_LNE_LOGO,
+	CSIO_LNE_CLOSE,
+	CSIO_LNE_MAX_EVENT,
+};
+
+
 struct csio_fcf_info {
 	struct list_head	list;
 	uint8_t			priority;
Index: drivers/soc/qcom/rpmhpd.c
===================================================================
--- drivers/soc/qcom/rpmhpd.c	(revision 55465)
+++ drivers/soc/qcom/rpmhpd.c	(revision 55464)
@@ -195,6 +195,7 @@
 	[SC8280XP_CX] = &cx,
 	[SC8280XP_CX_AO] = &cx_ao,
 	[SC8280XP_EBI] = &ebi,
+	[SC8280XP_GFX] = &gfx,
 	[SC8280XP_LCX] = &lcx,
 	[SC8280XP_LMX] = &lmx,
 	[SC8280XP_MMCX] = &mmcx,
Index: drivers/soc/fsl/dpio/dpio-service.c
===================================================================
--- drivers/soc/fsl/dpio/dpio-service.c	(revision 55465)
+++ drivers/soc/fsl/dpio/dpio-service.c	(revision 55464)
@@ -523,7 +523,7 @@
 	struct qbman_eq_desc *ed;
 	int i, ret;
 
-	ed = kcalloc(32, sizeof(struct qbman_eq_desc), GFP_KERNEL);
+	ed = kcalloc(sizeof(struct qbman_eq_desc), 32, GFP_KERNEL);
 	if (!ed)
 		return -ENOMEM;
 
Index: drivers/soc/microchip/Kconfig
===================================================================
--- drivers/soc/microchip/Kconfig	(revision 55465)
+++ drivers/soc/microchip/Kconfig	(revision 55464)
@@ -1,5 +1,5 @@
 config POLARFIRE_SOC_SYS_CTRL
-	tristate "Microchip PolarFire SoC (MPFS) system controller support"
+	tristate "POLARFIRE_SOC_SYS_CTRL"
 	depends on POLARFIRE_SOC_MAILBOX
 	help
 	  This driver adds support for the PolarFire SoC (MPFS) system controller.
Index: drivers/usb/gadget/udc/net2272.c
===================================================================
--- drivers/usb/gadget/udc/net2272.c	(revision 55465)
+++ drivers/usb/gadget/udc/net2272.c	(revision 55464)
@@ -2650,7 +2650,7 @@
 		goto err_req;
 	}
 
-	ret = net2272_probe_fin(dev, irqflags);
+	ret = net2272_probe_fin(dev, IRQF_TRIGGER_LOW);
 	if (ret)
 		goto err_io;
 
Index: drivers/usb/phy/phy-generic.c
===================================================================
--- drivers/usb/phy/phy-generic.c	(revision 55465)
+++ drivers/usb/phy/phy-generic.c	(revision 55464)
@@ -272,13 +272,6 @@
 		return dev_err_probe(dev, PTR_ERR(nop->vbus_draw),
 				     "could not get vbus regulator\n");
 
-	nop->vbus_draw = devm_regulator_get_exclusive(dev, "vbus");
-	if (PTR_ERR(nop->vbus_draw) == -ENODEV)
-		nop->vbus_draw = NULL;
-	if (IS_ERR(nop->vbus_draw))
-		return dev_err_probe(dev, PTR_ERR(nop->vbus_draw),
-				     "could not get vbus regulator\n");
-
 	nop->dev		= dev;
 	nop->phy.dev		= nop->dev;
 	nop->phy.label		= "nop-xceiv";
Index: drivers/video/backlight/da9052_bl.c
===================================================================
--- drivers/video/backlight/da9052_bl.c	(revision 55465)
+++ drivers/video/backlight/da9052_bl.c	(revision 55464)
@@ -117,7 +117,6 @@
 	wleds->led_reg = platform_get_device_id(pdev)->driver_data;
 	wleds->state = DA9052_WLEDS_OFF;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = DA9052_MAX_BRIGHTNESS;
 
Index: drivers/video/backlight/lm3630a_bl.c
===================================================================
--- drivers/video/backlight/lm3630a_bl.c	(revision 55465)
+++ drivers/video/backlight/lm3630a_bl.c	(revision 55464)
@@ -231,7 +231,7 @@
 		if (rval < 0)
 			goto out_i2c_err;
 		brightness |= rval;
-		return brightness;
+		goto out;
 	}
 
 	/* disable sleep */
@@ -242,8 +242,11 @@
 	rval = lm3630a_read(pchip, REG_BRT_A);
 	if (rval < 0)
 		goto out_i2c_err;
-	return rval;
+	brightness = rval;
 
+out:
+	bl->props.brightness = brightness;
+	return bl->props.brightness;
 out_i2c_err:
 	dev_err(pchip->dev, "i2c failed to access register\n");
 	return 0;
@@ -303,7 +306,7 @@
 		if (rval < 0)
 			goto out_i2c_err;
 		brightness |= rval;
-		return brightness;
+		goto out;
 	}
 
 	/* disable sleep */
@@ -314,8 +317,11 @@
 	rval = lm3630a_read(pchip, REG_BRT_B);
 	if (rval < 0)
 		goto out_i2c_err;
-	return rval;
+	brightness = rval;
 
+out:
+	bl->props.brightness = brightness;
+	return bl->props.brightness;
 out_i2c_err:
 	dev_err(pchip->dev, "i2c failed to access register\n");
 	return 0;
@@ -333,7 +339,6 @@
 	struct backlight_properties props;
 	const char *label;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	if (pdata->leda_ctrl != LM3630A_LEDA_DISABLE) {
 		props.brightness = pdata->leda_init_brt;
Index: drivers/video/backlight/lm3639_bl.c
===================================================================
--- drivers/video/backlight/lm3639_bl.c	(revision 55465)
+++ drivers/video/backlight/lm3639_bl.c	(revision 55464)
@@ -339,7 +339,6 @@
 	}
 
 	/* backlight */
-	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.brightness = pdata->init_brt_led;
 	props.max_brightness = pdata->max_brt_led;
Index: drivers/video/backlight/lp8788_bl.c
===================================================================
--- drivers/video/backlight/lp8788_bl.c	(revision 55465)
+++ drivers/video/backlight/lp8788_bl.c	(revision 55464)
@@ -191,7 +191,6 @@
 	int init_brt;
 	char *name;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_PLATFORM;
 	props.max_brightness = MAX_BRIGHTNESS;
 
Index: drivers/block/aoe/aoecmd.c
===================================================================
--- drivers/block/aoe/aoecmd.c	(revision 55465)
+++ drivers/block/aoe/aoecmd.c	(revision 55464)
@@ -419,16 +419,13 @@
 	rcu_read_lock();
 	for_each_netdev_rcu(&init_net, ifp) {
 		dev_hold(ifp);
-		if (!is_aoe_netif(ifp)) {
-			dev_put(ifp);
-			continue;
-		}
+		if (!is_aoe_netif(ifp))
+			goto cont;
 
 		skb = new_skb(sizeof *h + sizeof *ch);
 		if (skb == NULL) {
 			printk(KERN_INFO "aoe: skb alloc failure\n");
-			dev_put(ifp);
-			continue;
+			goto cont;
 		}
 		skb_put(skb, sizeof *h + sizeof *ch);
 		skb->dev = ifp;
@@ -443,6 +440,9 @@
 		h->major = cpu_to_be16(aoemajor);
 		h->minor = aoeminor;
 		h->cmd = AOECMD_CFG;
+
+cont:
+		dev_put(ifp);
 	}
 	rcu_read_unlock();
 }
Index: drivers/block/aoe/aoenet.c
===================================================================
--- drivers/block/aoe/aoenet.c	(revision 55465)
+++ drivers/block/aoe/aoenet.c	(revision 55464)
@@ -64,7 +64,6 @@
 			pr_warn("aoe: packet could not be sent on %s.  %s\n",
 				ifp ? ifp->name : "netif",
 				"consider increasing tx_queue_len");
-		dev_put(ifp);
 		spin_lock_irq(&txlock);
 	}
 	return 0;
Index: drivers/block/nbd.c
===================================================================
--- drivers/block/nbd.c	(revision 55465)
+++ drivers/block/nbd.c	(revision 55464)
@@ -2408,12 +2408,6 @@
 	}
 
 	dev_list = nla_nest_start_noflag(reply, NBD_ATTR_DEVICE_LIST);
-	if (!dev_list) {
-		nlmsg_free(reply);
-		ret = -EMSGSIZE;
-		goto out;
-	}
-
 	if (index == -1) {
 		ret = idr_for_each(&nbd_index_idr, &status_cb, reply);
 		if (ret) {
Index: drivers/crypto/xilinx/zynqmp-aes-gcm.c
===================================================================
--- drivers/crypto/xilinx/zynqmp-aes-gcm.c	(revision 55465)
+++ drivers/crypto/xilinx/zynqmp-aes-gcm.c	(revision 55464)
@@ -231,10 +231,7 @@
 		err = zynqmp_aes_aead_cipher(areq);
 	}
 
-	local_bh_disable();
 	crypto_finalize_aead_request(engine, areq, err);
-	local_bh_enable();
-
 	return 0;
 }
 
Index: drivers/firewire/core-card.c
===================================================================
--- drivers/firewire/core-card.c	(revision 55465)
+++ drivers/firewire/core-card.c	(revision 55464)
@@ -500,19 +500,7 @@
 		fw_notice(card, "phy config: new root=%x, gap_count=%d\n",
 			  new_root_id, gap_count);
 		fw_send_phy_config(card, new_root_id, generation, gap_count);
-		/*
-		 * Where possible, use a short bus reset to minimize
-		 * disruption to isochronous transfers. But in the event
-		 * of a gap count inconsistency, use a long bus reset.
-		 *
-		 * As noted in 1394a 8.4.6.2, nodes on a mixed 1394/1394a bus
-		 * may set different gap counts after a bus reset. On a mixed
-		 * 1394/1394a bus, a short bus reset can get doubled. Some
-		 * nodes may treat the double reset as one bus reset and others
-		 * may treat it as two, causing a gap count inconsistency
-		 * again. Using a long bus reset prevents this.
-		 */
-		reset_bus(card, card->gap_count != 0);
+		reset_bus(card, true);
 		/* Will allocate broadcast channel after the reset. */
 		goto out;
 	}
Index: drivers/md/dm-crypt.c
===================================================================
--- drivers/md/dm-crypt.c	(revision 55465)
+++ drivers/md/dm-crypt.c	(revision 55464)
@@ -52,11 +52,11 @@
 struct convert_context {
 	struct completion restart;
 	struct bio *bio_in;
+	struct bio *bio_out;
 	struct bvec_iter iter_in;
-	struct bio *bio_out;
 	struct bvec_iter iter_out;
+	u64 cc_sector;
 	atomic_t cc_pending;
-	u64 cc_sector;
 	union {
 		struct skcipher_request *req;
 		struct aead_request *req_aead;
@@ -2535,7 +2535,7 @@
 		type = &key_type_encrypted;
 		set_key = set_key_encrypted;
 	} else if (IS_ENABLED(CONFIG_TRUSTED_KEYS) &&
-		   !strncmp(key_string, "trusted:", key_desc - key_string + 1)) {
+	           !strncmp(key_string, "trusted:", key_desc - key_string + 1)) {
 		type = &key_type_trusted;
 		set_key = set_key_trusted;
 	} else {
Index: drivers/md/dm-integrity.c
===================================================================
--- drivers/md/dm-integrity.c	(revision 55465)
+++ drivers/md/dm-integrity.c	(revision 55464)
@@ -579,7 +579,7 @@
 		}
 	}
 
-	r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &io_loc, NULL);
 	if (unlikely(r))
 		return r;
 
@@ -1089,7 +1089,7 @@
 	io_loc.sector = ic->start + SB_SECTORS + sector;
 	io_loc.count = n_sectors;
 
-	r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &io_loc, NULL);
 	if (unlikely(r)) {
 		dm_integrity_io_error(ic, (opf & REQ_OP_MASK) == REQ_OP_READ ?
 				      "reading journal" : "writing journal", r);
@@ -1205,7 +1205,7 @@
 	io_loc.sector = target;
 	io_loc.count = n_sectors;
 
-	r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &io_loc, NULL);
 	if (unlikely(r)) {
 		WARN_ONCE(1, "asynchronous dm_io failed: %d", r);
 		fn(-1UL, data);
@@ -1532,7 +1532,7 @@
 		fr.io_reg.count = 0,
 		fr.ic = ic;
 		init_completion(&fr.comp);
-		r = dm_io(&fr.io_req, 1, &fr.io_reg, NULL, IOPRIO_DEFAULT);
+		r = dm_io(&fr.io_req, 1, &fr.io_reg, NULL);
 		BUG_ON(r);
 	}
 
@@ -1709,6 +1709,7 @@
 	struct bio_vec bv;
 	sector_t sector, logical_sector, area, offset;
 	struct page *page;
+	void *buffer;
 
 	get_area_and_offset(ic, dio->range.logical_sector, &area, &offset);
 	dio->metadata_block = get_metadata_sector_and_offset(ic, area, offset,
@@ -1717,14 +1718,13 @@
 	logical_sector = dio->range.logical_sector;
 
 	page = mempool_alloc(&ic->recheck_pool, GFP_NOIO);
+	buffer = page_to_virt(page);
 
 	__bio_for_each_segment(bv, bio, iter, dio->bio_details.bi_iter) {
 		unsigned pos = 0;
 
 		do {
-			sector_t alignment;
 			char *mem;
-			char *buffer = page_to_virt(page);
 			int r;
 			struct dm_io_request io_req;
 			struct dm_io_region io_loc;
@@ -1737,15 +1737,7 @@
 			io_loc.sector = sector;
 			io_loc.count = ic->sectors_per_block;
 
-			/* Align the bio to logical block size */
-			alignment = dio->range.logical_sector | bio_sectors(bio) | (PAGE_SIZE >> SECTOR_SHIFT);
-			alignment &= -alignment;
-			io_loc.sector = round_down(io_loc.sector, alignment);
-			io_loc.count += sector - io_loc.sector;
-			buffer += (sector - io_loc.sector) << SECTOR_SHIFT;
-			io_loc.count = round_up(io_loc.count, alignment);
-
-			r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+			r = dm_io(&io_req, 1, &io_loc, NULL);
 			if (unlikely(r)) {
 				dio->bi_status = errno_to_blk_status(r);
 				goto free_ret;
@@ -1864,12 +1856,12 @@
 			r = dm_integrity_rw_tag(ic, checksums, &dio->metadata_block, &dio->metadata_offset,
 						checksums_ptr - checksums, dio->op == REQ_OP_READ ? TAG_CMP : TAG_WRITE);
 			if (unlikely(r)) {
-				if (likely(checksums != checksums_onstack))
-					kfree(checksums);
 				if (r > 0) {
-					integrity_recheck(dio, checksums_onstack);
+					integrity_recheck(dio, checksums);
 					goto skip_io;
 				}
+				if (likely(checksums != checksums_onstack))
+					kfree(checksums);
 				goto error;
 			}
 
@@ -2375,6 +2367,7 @@
 		else
 skip_check:
 			dec_in_flight(dio);
+
 	} else {
 		INIT_WORK(&dio->work, integrity_metadata);
 		queue_work(ic->metadata_wq, &dio->work);
@@ -2782,7 +2775,7 @@
 	io_loc.sector = get_data_sector(ic, area, offset);
 	io_loc.count = n_sectors;
 
-	r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &io_loc, NULL);
 	if (unlikely(r)) {
 		dm_integrity_io_error(ic, "reading data", r);
 		goto err;
@@ -4158,7 +4151,7 @@
 		} else if (sscanf(opt_string, "block_size:%u%c", &val, &dummy) == 1) {
 			if (val < 1 << SECTOR_SHIFT ||
 			    val > MAX_SECTORS_PER_BLOCK << SECTOR_SHIFT ||
-			    (val & (val - 1))) {
+			    (val & (val -1))) {
 				r = -EINVAL;
 				ti->error = "Invalid block_size argument";
 				goto bad;
@@ -4484,7 +4477,7 @@
 	if (ic->internal_hash) {
 		size_t recalc_tags_size;
 		ic->recalc_wq = alloc_workqueue("dm-integrity-recalc", WQ_MEM_RECLAIM, 1);
-		if (!ic->recalc_wq) {
+		if (!ic->recalc_wq ) {
 			ti->error = "Cannot allocate workqueue";
 			r = -ENOMEM;
 			goto bad;
Index: drivers/md/dm-verity-target.c
===================================================================
--- drivers/md/dm-verity-target.c	(revision 55465)
+++ drivers/md/dm-verity-target.c	(revision 55464)
@@ -503,7 +503,7 @@
 	io_loc.bdev = v->data_dev->bdev;
 	io_loc.sector = cur_block << (v->data_dev_block_bits - SECTOR_SHIFT);
 	io_loc.count = 1 << (v->data_dev_block_bits - SECTOR_SHIFT);
-	r = dm_io(&io_req, 1, &io_loc, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &io_loc, NULL);
 	if (unlikely(r))
 		goto free_ret;
 
Index: drivers/md/dm-verity.h
===================================================================
--- drivers/md/dm-verity.h	(revision 55465)
+++ drivers/md/dm-verity.h	(revision 55464)
@@ -80,12 +80,12 @@
 	/* original value of bio->bi_end_io */
 	bio_end_io_t *orig_bi_end_io;
 
-	struct bvec_iter iter;
-
 	sector_t block;
 	unsigned int n_blocks;
 	bool in_tasklet;
 
+	struct bvec_iter iter;
+
 	struct work_struct work;
 
 	char *recheck_buffer;
Index: drivers/md/md.c
===================================================================
--- drivers/md/md.c	(revision 55465)
+++ drivers/md/md.c	(revision 55464)
@@ -4903,21 +4903,11 @@
 			return -EINVAL;
 		err = mddev_lock(mddev);
 		if (!err) {
-			if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery)) {
+			if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))
 				err =  -EBUSY;
-			} else if (mddev->reshape_position == MaxSector ||
-				   mddev->pers->check_reshape == NULL ||
-				   mddev->pers->check_reshape(mddev)) {
+			else {
 				clear_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
 				err = mddev->pers->start_reshape(mddev);
-			} else {
-				/*
-				 * If reshape is still in progress, and
-				 * md_check_recovery() can continue to reshape,
-				 * don't restart reshape because data can be
-				 * corrupted for raid456.
-				 */
-				clear_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
 			}
 			mddev_unlock(mddev);
 		}
@@ -6243,15 +6233,7 @@
 	mddev->persistent = 0;
 	mddev->level = LEVEL_NONE;
 	mddev->clevel[0] = 0;
-	/*
-	 * Don't clear MD_CLOSING, or mddev can be opened again.
-	 * 'hold_active != 0' means mddev is still in the creation
-	 * process and will be used later.
-	 */
-	if (mddev->hold_active)
-		mddev->flags = 0;
-	else
-		mddev->flags &= BIT_ULL_MASK(MD_CLOSING);
+	mddev->flags = 0;
 	mddev->sb_flags = 0;
 	mddev->ro = MD_RDWR;
 	mddev->metadata_type[0] = 0;
@@ -7579,6 +7561,7 @@
 	int err = 0;
 	void __user *argp = (void __user *)arg;
 	struct mddev *mddev = NULL;
+	bool did_set_md_closing = false;
 
 	if (!md_ioctl_valid(cmd))
 		return -ENOTTY;
@@ -7665,6 +7648,7 @@
 			err = -EBUSY;
 			goto out;
 		}
+		did_set_md_closing = true;
 		mutex_unlock(&mddev->open_mutex);
 		sync_blockdev(bdev);
 	}
@@ -7827,7 +7811,7 @@
 		mddev->hold_active = 0;
 	mddev_unlock(mddev);
 out:
-	if (cmd == STOP_ARRAY_RO || (err && cmd == STOP_ARRAY))
+	if(did_set_md_closing)
 		clear_bit(MD_CLOSING, &mddev->flags);
 	return err;
 }
Index: drivers/md/dm-table.c
===================================================================
--- drivers/md/dm-table.c	(revision 55465)
+++ drivers/md/dm-table.c	(revision 55464)
@@ -72,7 +72,7 @@
 		n = get_child(n, CHILDREN_PER_NODE - 1);
 
 	if (n >= t->counts[l])
-		return (sector_t) -1;
+		return (sector_t) - 1;
 
 	return get_node(t, l, n)[KEYS_PER_NODE - 1];
 }
@@ -1533,7 +1533,7 @@
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, func, data))
 			return true;
-	}
+        }
 
 	return false;
 }
Index: drivers/md/dm-bufio.c
===================================================================
--- drivers/md/dm-bufio.c	(revision 55465)
+++ drivers/md/dm-bufio.c	(revision 55464)
@@ -614,7 +614,7 @@
 		io_req.mem.ptr.vma = (char *)b->data + offset;
 	}
 
-	r = dm_io(&io_req, 1, &region, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&io_req, 1, &region, NULL);
 	if (unlikely(r))
 		b->end_io(b, errno_to_blk_status(r));
 }
@@ -1375,7 +1375,7 @@
 
 	BUG_ON(dm_bufio_in_request());
 
-	return dm_io(&io_req, 1, &io_reg, NULL, IOPRIO_DEFAULT);
+	return dm_io(&io_req, 1, &io_reg, NULL);
 }
 EXPORT_SYMBOL_GPL(dm_bufio_issue_flush);
 
@@ -1398,7 +1398,7 @@
 
 	BUG_ON(dm_bufio_in_request());
 
-	return dm_io(&io_req, 1, &io_reg, NULL, IOPRIO_DEFAULT);
+	return dm_io(&io_req, 1, &io_reg, NULL);
 }
 EXPORT_SYMBOL_GPL(dm_bufio_issue_discard);
 
Index: drivers/md/persistent-data/dm-btree.c
===================================================================
--- drivers/md/persistent-data/dm-btree.c	(revision 55465)
+++ drivers/md/persistent-data/dm-btree.c	(revision 55464)
@@ -726,7 +726,7 @@
  * nodes, so saves metadata space.
  */
 static int split_two_into_three(struct shadow_spine *s, unsigned int parent_index,
-				struct dm_btree_value_type *vt, uint64_t key)
+                                struct dm_btree_value_type *vt, uint64_t key)
 {
 	int r;
 	unsigned int middle_index;
@@ -781,7 +781,7 @@
 		if (shadow_current(s) != right)
 			unlock_block(s->info, right);
 
-		return r;
+	        return r;
 	}
 
 
@@ -1216,7 +1216,7 @@
 static bool need_insert(struct btree_node *node, uint64_t *keys,
 			unsigned int level, unsigned int index)
 {
-	return ((index >= le32_to_cpu(node->header.nr_entries)) ||
+        return ((index >= le32_to_cpu(node->header.nr_entries)) ||
 		(le64_to_cpu(node->keys[index]) != keys[level]));
 }
 
Index: drivers/md/persistent-data/dm-space-map-common.c
===================================================================
--- drivers/md/persistent-data/dm-space-map-common.c	(revision 55465)
+++ drivers/md/persistent-data/dm-space-map-common.c	(revision 55464)
@@ -390,7 +390,7 @@
 }
 
 int sm_ll_find_common_free_block(struct ll_disk *old_ll, struct ll_disk *new_ll,
-				 dm_block_t begin, dm_block_t end, dm_block_t *b)
+	                         dm_block_t begin, dm_block_t end, dm_block_t *b)
 {
 	int r;
 	uint32_t count;
Index: drivers/md/persistent-data/dm-space-map-common.h
===================================================================
--- drivers/md/persistent-data/dm-space-map-common.h	(revision 55465)
+++ drivers/md/persistent-data/dm-space-map-common.h	(revision 55464)
@@ -120,7 +120,7 @@
 int sm_ll_find_free_block(struct ll_disk *ll, dm_block_t begin,
 			  dm_block_t end, dm_block_t *result);
 int sm_ll_find_common_free_block(struct ll_disk *old_ll, struct ll_disk *new_ll,
-				 dm_block_t begin, dm_block_t end, dm_block_t *result);
+	                         dm_block_t begin, dm_block_t end, dm_block_t *result);
 
 /*
  * The next three functions return (via nr_allocations) the net number of
Index: drivers/md/dm.c
===================================================================
--- drivers/md/dm.c	(revision 55465)
+++ drivers/md/dm.c	(revision 55464)
@@ -2897,9 +2897,6 @@
 
 static void __dm_internal_resume(struct mapped_device *md)
 {
-	int r;
-	struct dm_table *map;
-
 	BUG_ON(!md->internal_suspend_count);
 
 	if (--md->internal_suspend_count)
@@ -2908,23 +2905,12 @@
 	if (dm_suspended_md(md))
 		goto done; /* resume from nested suspend */
 
-	map = rcu_dereference_protected(md->map, lockdep_is_held(&md->suspend_lock));
-	r = __dm_resume(md, map);
-	if (r) {
-		/*
-		 * If a preresume method of some target failed, we are in a
-		 * tricky situation. We can't return an error to the caller. We
-		 * can't fake success because then the "resume" and
-		 * "postsuspend" methods would not be paired correctly, and it
-		 * would break various targets, for example it would cause list
-		 * corruption in the "origin" target.
-		 *
-		 * So, we fake normal suspend here, to make sure that the
-		 * "resume" and "postsuspend" methods will be paired correctly.
-		 */
-		DMERR("Preresume method failed: %d", r);
-		set_bit(DMF_SUSPENDED, &md->flags);
-	}
+	/*
+	 * NOTE: existing callers don't need to call dm_table_resume_targets
+	 * (which may fail -- so best to avoid it for now by passing NULL map)
+	 */
+	(void) __dm_resume(md, NULL);
+
 done:
 	clear_bit(DMF_SUSPENDED_INTERNALLY, &md->flags);
 	smp_mb__after_atomic();
Index: drivers/md/raid10.c
===================================================================
--- drivers/md/raid10.c	(revision 55465)
+++ drivers/md/raid10.c	(revision 55464)
@@ -920,7 +920,6 @@
 
 			raid1_submit_write(bio);
 			bio = next;
-			cond_resched();
 		}
 		blk_finish_plug(&plug);
 	} else
@@ -1131,7 +1130,6 @@
 
 		raid1_submit_write(bio);
 		bio = next;
-		cond_resched();
 	}
 	kfree(plug);
 }
Index: drivers/md/dm-raid.c
===================================================================
--- drivers/md/dm-raid.c	(revision 55465)
+++ drivers/md/dm-raid.c	(revision 55464)
@@ -362,8 +362,8 @@
 	const int mode;
 	const char *param;
 } _raid456_journal_mode[] = {
-	{ R5C_JOURNAL_MODE_WRITE_THROUGH, "writethrough" },
-	{ R5C_JOURNAL_MODE_WRITE_BACK,    "writeback" }
+	{ R5C_JOURNAL_MODE_WRITE_THROUGH , "writethrough" },
+	{ R5C_JOURNAL_MODE_WRITE_BACK    , "writeback" }
 };
 
 /* Return MD raid4/5/6 journal mode for dm @journal_mode one */
@@ -1114,7 +1114,7 @@
  *    [stripe_cache <sectors>]		Stripe cache size for higher RAIDs
  *    [region_size <sectors>]		Defines granularity of bitmap
  *    [journal_dev <dev>]		raid4/5/6 journaling deviice
- *					(i.e. write hole closing log)
+ *    					(i.e. write hole closing log)
  *
  * RAID10-only options:
  *    [raid10_copies <# copies>]	Number of copies.  (Default: 2)
@@ -3325,7 +3325,7 @@
 	struct mddev *mddev = &rs->md;
 
 	/*
-	 * If we're reshaping to add disk(s), ti->len and
+	 * If we're reshaping to add disk(s)), ti->len and
 	 * mddev->array_sectors will differ during the process
 	 * (ti->len > mddev->array_sectors), so we have to requeue
 	 * bios with addresses > mddev->array_sectors here or
@@ -3332,7 +3332,7 @@
 	 * there will occur accesses past EOD of the component
 	 * data images thus erroring the raid set.
 	 */
-	if (unlikely(bio_has_data(bio) && bio_end_sector(bio) > mddev->array_sectors))
+	if (unlikely(bio_end_sector(bio) > mddev->array_sectors))
 		return DM_MAPIO_REQUEUE;
 
 	md_handle_request(mddev, bio);
@@ -3999,7 +3999,7 @@
 	}
 
 	/* Resize bitmap to adjust to changed region size (aka MD bitmap chunksize) or grown device size */
-	if (test_bit(RT_FLAG_RS_BITMAP_LOADED, &rs->runtime_flags) && mddev->bitmap &&
+        if (test_bit(RT_FLAG_RS_BITMAP_LOADED, &rs->runtime_flags) && mddev->bitmap &&
 	    (test_bit(RT_FLAG_RS_GROW, &rs->runtime_flags) ||
 	     (rs->requested_bitmap_chunk_sectors &&
 	       mddev->bitmap_info.chunksize != to_bytes(rs->requested_bitmap_chunk_sectors)))) {
Index: drivers/md/dm-log.c
===================================================================
--- drivers/md/dm-log.c	(revision 55465)
+++ drivers/md/dm-log.c	(revision 55464)
@@ -295,7 +295,7 @@
 {
 	lc->io_req.bi_opf = op;
 
-	return dm_io(&lc->io_req, 1, &lc->header_location, NULL, IOPRIO_DEFAULT);
+	return dm_io(&lc->io_req, 1, &lc->header_location, NULL);
 }
 
 static int flush_header(struct log_c *lc)
@@ -308,7 +308,7 @@
 
 	lc->io_req.bi_opf = REQ_OP_WRITE | REQ_PREFLUSH;
 
-	return dm_io(&lc->io_req, 1, &null_location, NULL, IOPRIO_DEFAULT);
+	return dm_io(&lc->io_req, 1, &null_location, NULL);
 }
 
 static int read_header(struct log_c *log)
@@ -756,8 +756,8 @@
 	log_clear_bit(lc, lc->recovering_bits, region);
 	if (in_sync) {
 		log_set_bit(lc, lc->sync_bits, region);
-		lc->sync_count++;
-	} else if (log_test_bit(lc->sync_bits, region)) {
+                lc->sync_count++;
+        } else if (log_test_bit(lc->sync_bits, region)) {
 		lc->sync_count--;
 		log_clear_bit(lc, lc->sync_bits, region);
 	}
@@ -765,9 +765,9 @@
 
 static region_t core_get_sync_count(struct dm_dirty_log *log)
 {
-	struct log_c *lc = (struct log_c *) log->context;
+        struct log_c *lc = (struct log_c *) log->context;
 
-	return lc->sync_count;
+        return lc->sync_count;
 }
 
 #define	DMEMIT_SYNC \
Index: drivers/md/dm-raid1.c
===================================================================
--- drivers/md/dm-raid1.c	(revision 55465)
+++ drivers/md/dm-raid1.c	(revision 55464)
@@ -273,7 +273,7 @@
 	}
 
 	error_bits = -1;
-	dm_io(&io_req, ms->nr_mirrors, io, &error_bits, IOPRIO_DEFAULT);
+	dm_io(&io_req, ms->nr_mirrors, io, &error_bits);
 	if (unlikely(error_bits != 0)) {
 		for (i = 0; i < ms->nr_mirrors; i++)
 			if (test_bit(i, &error_bits))
@@ -543,7 +543,7 @@
 
 	map_region(&io, m, bio);
 	bio_set_m(bio, m);
-	BUG_ON(dm_io(&io_req, 1, &io, NULL, IOPRIO_DEFAULT));
+	BUG_ON(dm_io(&io_req, 1, &io, NULL));
 }
 
 static inline int region_in_sync(struct mirror_set *ms, region_t region,
@@ -670,7 +670,7 @@
 	 */
 	bio_set_m(bio, get_default_mirror(ms));
 
-	BUG_ON(dm_io(&io_req, ms->nr_mirrors, io, NULL, IOPRIO_DEFAULT));
+	BUG_ON(dm_io(&io_req, ms->nr_mirrors, io, NULL));
 }
 
 static void do_writes(struct mirror_set *ms, struct bio_list *writes)
@@ -902,7 +902,7 @@
 	if (IS_ERR(ms->io_client)) {
 		ti->error = "Error creating dm_io client";
 		kfree(ms);
-		return NULL;
+ 		return NULL;
 	}
 
 	ms->rh = dm_region_hash_create(ms, dispatch_bios, wakeup_mirrord,
Index: drivers/md/dm-snap-persistent.c
===================================================================
--- drivers/md/dm-snap-persistent.c	(revision 55465)
+++ drivers/md/dm-snap-persistent.c	(revision 55464)
@@ -220,7 +220,7 @@
 {
 	struct mdata_req *req = container_of(work, struct mdata_req, work);
 
-	req->result = dm_io(req->io_req, 1, req->where, NULL, IOPRIO_DEFAULT);
+	req->result = dm_io(req->io_req, 1, req->where, NULL);
 }
 
 /*
@@ -244,7 +244,7 @@
 	struct mdata_req req;
 
 	if (!metadata)
-		return dm_io(&io_req, 1, &where, NULL, IOPRIO_DEFAULT);
+		return dm_io(&io_req, 1, &where, NULL);
 
 	req.where = &where;
 	req.io_req = &io_req;
Index: drivers/md/dm-writecache.c
===================================================================
--- drivers/md/dm-writecache.c	(revision 55465)
+++ drivers/md/dm-writecache.c	(revision 55464)
@@ -531,7 +531,7 @@
 		req.notify.context = &endio;
 
 		/* writing via async dm-io (implied by notify.fn above) won't return an error */
-		(void) dm_io(&req, 1, &region, NULL, IOPRIO_DEFAULT);
+	        (void) dm_io(&req, 1, &region, NULL);
 		i = j;
 	}
 
@@ -568,7 +568,7 @@
 	req.notify.fn = NULL;
 	req.notify.context = NULL;
 
-	r = dm_io(&req, 1, &region, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&req, 1, &region, NULL);
 	if (unlikely(r))
 		writecache_error(wc, r, "error writing superblock");
 }
@@ -596,7 +596,7 @@
 	req.client = wc->dm_io;
 	req.notify.fn = NULL;
 
-	r = dm_io(&req, 1, &region, NULL, IOPRIO_DEFAULT);
+	r = dm_io(&req, 1, &region, NULL);
 	if (unlikely(r))
 		writecache_error(wc, r, "error flushing metadata: %d", r);
 }
@@ -984,7 +984,7 @@
 	req.client = wc->dm_io;
 	req.notify.fn = NULL;
 
-	return dm_io(&req, 1, &region, NULL, IOPRIO_DEFAULT);
+	return dm_io(&req, 1, &region, NULL);
 }
 
 static void writecache_resume(struct dm_target *ti)
Index: drivers/md/dm-cache-policy.h
===================================================================
--- drivers/md/dm-cache-policy.h	(revision 55465)
+++ drivers/md/dm-cache-policy.h	(revision 55464)
@@ -75,7 +75,7 @@
 	 * background work.
 	 */
 	int (*get_background_work)(struct dm_cache_policy *p, bool idle,
-				   struct policy_work **result);
+			           struct policy_work **result);
 
 	/*
 	 * You must pass in the same work pointer that you were given, not
Index: drivers/md/dm-io.c
===================================================================
--- drivers/md/dm-io.c	(revision 55465)
+++ drivers/md/dm-io.c	(revision 55464)
@@ -295,7 +295,7 @@
  *---------------------------------------------------------------*/
 static void do_region(const blk_opf_t opf, unsigned int region,
 		      struct dm_io_region *where, struct dpages *dp,
-		      struct io *io, unsigned short ioprio)
+		      struct io *io)
 {
 	struct bio *bio;
 	struct page *page;
@@ -344,7 +344,6 @@
 				       &io->client->bios);
 		bio->bi_iter.bi_sector = where->sector + (where->count - remaining);
 		bio->bi_end_io = endio;
-		bio->bi_ioprio = ioprio;
 		store_io_and_region_in_bio(bio, io, region);
 
 		if (op == REQ_OP_DISCARD || op == REQ_OP_WRITE_ZEROES) {
@@ -372,7 +371,7 @@
 
 static void dispatch_io(blk_opf_t opf, unsigned int num_regions,
 			struct dm_io_region *where, struct dpages *dp,
-			struct io *io, int sync, unsigned short ioprio)
+			struct io *io, int sync)
 {
 	int i;
 	struct dpages old_pages = *dp;
@@ -389,7 +388,7 @@
 	for (i = 0; i < num_regions; i++) {
 		*dp = old_pages;
 		if (where[i].count || (opf & REQ_PREFLUSH))
-			do_region(opf, i, where + i, dp, io, ioprio);
+			do_region(opf, i, where + i, dp, io);
 	}
 
 	/*
@@ -414,7 +413,7 @@
 
 static int sync_io(struct dm_io_client *client, unsigned int num_regions,
 		   struct dm_io_region *where, blk_opf_t opf, struct dpages *dp,
-		   unsigned long *error_bits, unsigned short ioprio)
+		   unsigned long *error_bits)
 {
 	struct io *io;
 	struct sync_io sio;
@@ -436,7 +435,7 @@
 	io->vma_invalidate_address = dp->vma_invalidate_address;
 	io->vma_invalidate_size = dp->vma_invalidate_size;
 
-	dispatch_io(opf, num_regions, where, dp, io, 1, ioprio);
+	dispatch_io(opf, num_regions, where, dp, io, 1);
 
 	wait_for_completion_io(&sio.wait);
 
@@ -448,8 +447,7 @@
 
 static int async_io(struct dm_io_client *client, unsigned int num_regions,
 		    struct dm_io_region *where, blk_opf_t opf,
-		    struct dpages *dp, io_notify_fn fn, void *context,
-		    unsigned short ioprio)
+		    struct dpages *dp, io_notify_fn fn, void *context)
 {
 	struct io *io;
 
@@ -469,7 +467,7 @@
 	io->vma_invalidate_address = dp->vma_invalidate_address;
 	io->vma_invalidate_size = dp->vma_invalidate_size;
 
-	dispatch_io(opf, num_regions, where, dp, io, 0, ioprio);
+	dispatch_io(opf, num_regions, where, dp, io, 0);
 	return 0;
 }
 
@@ -511,8 +509,7 @@
 }
 
 int dm_io(struct dm_io_request *io_req, unsigned int num_regions,
-	  struct dm_io_region *where, unsigned long *sync_error_bits,
-	  unsigned short ioprio)
+	  struct dm_io_region *where, unsigned long *sync_error_bits)
 {
 	int r;
 	struct dpages dp;
@@ -523,11 +520,11 @@
 
 	if (!io_req->notify.fn)
 		return sync_io(io_req->client, num_regions, where,
-			       io_req->bi_opf, &dp, sync_error_bits, ioprio);
+			       io_req->bi_opf, &dp, sync_error_bits);
 
 	return async_io(io_req->client, num_regions, where,
 			io_req->bi_opf, &dp, io_req->notify.fn,
-			io_req->notify.context, ioprio);
+			io_req->notify.context);
 }
 EXPORT_SYMBOL(dm_io);
 
Index: drivers/md/dm-kcopyd.c
===================================================================
--- drivers/md/dm-kcopyd.c	(revision 55465)
+++ drivers/md/dm-kcopyd.c	(revision 55464)
@@ -572,9 +572,9 @@
 	io_job_start(job->kc->throttle);
 
 	if (job->op == REQ_OP_READ)
-		r = dm_io(&io_req, 1, &job->source, NULL, IOPRIO_DEFAULT);
+		r = dm_io(&io_req, 1, &job->source, NULL);
 	else
-		r = dm_io(&io_req, job->num_dests, job->dests, NULL, IOPRIO_DEFAULT);
+		r = dm_io(&io_req, job->num_dests, job->dests, NULL);
 
 	return r;
 }
Index: drivers/md/dm-thin.c
===================================================================
--- drivers/md/dm-thin.c	(revision 55465)
+++ drivers/md/dm-thin.c	(revision 55464)
@@ -1179,9 +1179,9 @@
 	discard_parent = bio_alloc(NULL, 1, 0, GFP_NOIO);
 	discard_parent->bi_end_io = passdown_endio;
 	discard_parent->bi_private = m;
-	if (m->maybe_shared)
-		passdown_double_checking_shared_status(m, discard_parent);
-	else {
+ 	if (m->maybe_shared)
+ 		passdown_double_checking_shared_status(m, discard_parent);
+ 	else {
 		struct discard_op op;
 
 		begin_discard(&op, tc, discard_parent);
Index: drivers/nvme/host/core.c
===================================================================
--- drivers/nvme/host/core.c	(revision 55465)
+++ drivers/nvme/host/core.c	(revision 55464)
@@ -4971,8 +4971,7 @@
 	set->ops = ops;
 	set->queue_depth = NVME_AQ_MQ_TAG_DEPTH;
 	if (ctrl->ops->flags & NVME_F_FABRICS)
-		/* Reserved for fabric connect and keep alive */
-		set->reserved_tags = 2;
+		set->reserved_tags = NVMF_RESERVED_TAGS;
 	set->numa_node = ctrl->numa_node;
 	set->flags = BLK_MQ_F_NO_SCHED;
 	if (ctrl->ops->flags & NVME_F_BLOCKING)
@@ -5030,15 +5029,7 @@
 	memset(set, 0, sizeof(*set));
 	set->ops = ops;
 	set->queue_depth = ctrl->sqsize + 1;
-	/*
-	 * Some Apple controllers requires tags to be unique across admin and
-	 * the (only) I/O queue, so reserve the first 32 tags of the I/O queue.
-	 */
-	if (ctrl->quirks & NVME_QUIRK_SHARED_TAGS)
-		set->reserved_tags = NVME_AQ_DEPTH;
-	else if (ctrl->ops->flags & NVME_F_FABRICS)
-		/* Reserved for fabric connect */
-		set->reserved_tags = 1;
+	set->reserved_tags = NVMF_RESERVED_TAGS;
 	set->numa_node = ctrl->numa_node;
 	set->flags = BLK_MQ_F_SHOULD_MERGE;
 	if (ctrl->ops->flags & NVME_F_BLOCKING)
Index: drivers/nvme/host/fabrics.h
===================================================================
--- drivers/nvme/host/fabrics.h	(revision 55465)
+++ drivers/nvme/host/fabrics.h	(revision 55464)
@@ -19,6 +19,13 @@
 #define NVMF_DEF_FAIL_FAST_TMO		-1
 
 /*
+ * Reserved one command for internal usage.  This command is used for sending
+ * the connect command, as well as for the keep alive command on the admin
+ * queue once live.
+ */
+#define NVMF_RESERVED_TAGS	1
+
+/*
  * Define a host as seen by the target.  We allocate one at boot, but also
  * allow the override it when creating controllers.  This is both to provide
  * persistence of the Host NQN over multiple boots, and to allow using
Index: drivers/s390/block/dasd.c
===================================================================
--- drivers/s390/block/dasd.c	(revision 55465)
+++ drivers/s390/block/dasd.c	(revision 55464)
@@ -8,6 +8,9 @@
  * Copyright IBM Corp. 1999, 2009
  */
 
+#define KMSG_COMPONENT "dasd"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
 #include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -70,8 +73,7 @@
 static void dasd_profile_exit(struct dasd_profile *);
 static void dasd_hosts_init(struct dentry *, struct dasd_device *);
 static void dasd_hosts_exit(struct dasd_device *);
-static int dasd_handle_autoquiesce(struct dasd_device *, struct dasd_ccw_req *,
-				   unsigned int);
+
 /*
  * SECTION: Operations on the device structure.
  */
@@ -2325,7 +2327,7 @@
 		/* Non-temporary stop condition will trigger fail fast */
 		if (device->stopped & ~DASD_STOPPED_PENDING &&
 		    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&
-		    !dasd_eer_enabled(device) && device->aq_mask == 0) {
+		    (!dasd_eer_enabled(device))) {
 			cqr->status = DASD_CQR_FAILED;
 			cqr->intrc = -ENOLINK;
 			continue;
@@ -2801,18 +2803,20 @@
 			dasd_log_sense(cqr, &cqr->irb);
 		}
 
-		/*
-		 * First call extended error reporting and check for autoquiesce
-		 */
-		spin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);
-		if (cqr->status == DASD_CQR_FAILED &&
-		    dasd_handle_autoquiesce(base, cqr, DASD_EER_FATALERROR)) {
+		/* First of all call extended error reporting. */
+		if (dasd_eer_enabled(base) &&
+		    cqr->status == DASD_CQR_FAILED) {
+			dasd_eer_write(base, cqr, DASD_EER_FATALERROR);
+
+			/* restart request  */
 			cqr->status = DASD_CQR_FILLED;
 			cqr->retries = 255;
-			spin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);
+			spin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);
+			dasd_device_set_stop_bits(base, DASD_STOPPED_QUIESCE);
+			spin_unlock_irqrestore(get_ccwdev_lock(base->cdev),
+					       flags);
 			goto restart;
 		}
-		spin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);
 
 		/* Process finished ERP request. */
 		if (cqr->refers) {
@@ -2854,7 +2858,7 @@
 		/* Non-temporary stop condition will trigger fail fast */
 		if (block->base->stopped & ~DASD_STOPPED_PENDING &&
 		    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&
-		    !dasd_eer_enabled(block->base) && block->base->aq_mask == 0) {
+		    (!dasd_eer_enabled(block->base))) {
 			cqr->status = DASD_CQR_FAILED;
 			cqr->intrc = -ENOLINK;
 			dasd_schedule_block_bh(block);
@@ -3387,7 +3391,8 @@
 
 	ret = ccw_device_set_online(cdev);
 	if (ret)
-		dev_warn(&cdev->dev, "Setting the DASD online failed with rc=%d\n", ret);
+		pr_warn("%s: Setting the DASD online failed with rc=%d\n",
+			dev_name(&cdev->dev), ret);
 }
 
 /*
@@ -3474,11 +3479,8 @@
 {
 	struct dasd_discipline *discipline;
 	struct dasd_device *device;
-	struct device *dev;
 	int rc;
 
-	dev = &cdev->dev;
-
 	/* first online clears initial online feature flag */
 	dasd_set_feature(cdev, DASD_FEATURE_INITIAL_ONLINE, 0);
 	device = dasd_create_device(cdev);
@@ -3491,10 +3493,11 @@
 			/* Try to load the required module. */
 			rc = request_module(DASD_DIAG_MOD);
 			if (rc) {
-				dev_warn(dev, "Setting the DASD online failed "
-					 "because the required module %s "
-					 "could not be loaded (rc=%d)\n",
-					 DASD_DIAG_MOD, rc);
+				pr_warn("%s Setting the DASD online failed "
+					"because the required module %s "
+					"could not be loaded (rc=%d)\n",
+					dev_name(&cdev->dev), DASD_DIAG_MOD,
+					rc);
 				dasd_delete_device(device);
 				return -ENODEV;
 			}
@@ -3502,7 +3505,8 @@
 		/* Module init could have failed, so check again here after
 		 * request_module(). */
 		if (!dasd_diag_discipline_pointer) {
-			dev_warn(dev, "Setting the DASD online failed because of missing DIAG discipline\n");
+			pr_warn("%s Setting the DASD online failed because of missing DIAG discipline\n",
+				dev_name(&cdev->dev));
 			dasd_delete_device(device);
 			return -ENODEV;
 		}
@@ -3512,18 +3516,21 @@
 		dasd_delete_device(device);
 		return -EINVAL;
 	}
-	device->base_discipline = base_discipline;
 	if (!try_module_get(discipline->owner)) {
+		module_put(base_discipline->owner);
 		dasd_delete_device(device);
 		return -EINVAL;
 	}
+	device->base_discipline = base_discipline;
 	device->discipline = discipline;
 
 	/* check_device will allocate block device if necessary */
 	rc = discipline->check_device(device);
 	if (rc) {
-		dev_warn(dev, "Setting the DASD online with discipline %s failed with rc=%i\n",
-			 discipline->name, rc);
+		pr_warn("%s Setting the DASD online with discipline %s failed with rc=%i\n",
+			dev_name(&cdev->dev), discipline->name, rc);
+		module_put(discipline->owner);
+		module_put(base_discipline->owner);
 		dasd_delete_device(device);
 		return rc;
 	}
@@ -3530,15 +3537,16 @@
 
 	dasd_set_target_state(device, DASD_STATE_ONLINE);
 	if (device->state <= DASD_STATE_KNOWN) {
-		dev_warn(dev, "Setting the DASD online failed because of a missing discipline\n");
+		pr_warn("%s Setting the DASD online failed because of a missing discipline\n",
+			dev_name(&cdev->dev));
 		rc = -ENODEV;
 		dasd_set_target_state(device, DASD_STATE_NEW);
 		if (device->block)
 			dasd_free_block(device->block);
 		dasd_delete_device(device);
-	} else {
-		dev_dbg(dev, "dasd_generic device found\n");
-	}
+	} else
+		pr_debug("dasd_generic device %s found\n",
+				dev_name(&cdev->dev));
 
 	wait_event(dasd_init_waitq, _wait_for_device(device));
 
@@ -3549,14 +3557,11 @@
 
 int dasd_generic_set_offline(struct ccw_device *cdev)
 {
-	int max_count, open_count, rc;
 	struct dasd_device *device;
 	struct dasd_block *block;
+	int max_count, open_count, rc;
 	unsigned long flags;
-	struct device *dev;
 
-	dev = &cdev->dev;
-
 	rc = 0;
 	spin_lock_irqsave(get_ccwdev_lock(cdev), flags);
 	device = dasd_device_from_cdev_locked(cdev);
@@ -3576,10 +3581,11 @@
 		open_count = atomic_read(&device->block->open_count);
 		if (open_count > max_count) {
 			if (open_count > 0)
-				dev_warn(dev, "The DASD cannot be set offline with open count %i\n",
-					 open_count);
+				pr_warn("%s: The DASD cannot be set offline with open count %i\n",
+					dev_name(&cdev->dev), open_count);
 			else
-				dev_warn(dev, "The DASD cannot be set offline while it is in use\n");
+				pr_warn("%s: The DASD cannot be set offline while it is in use\n",
+					dev_name(&cdev->dev));
 			rc = -EBUSY;
 			goto out_err;
 		}
@@ -3676,8 +3682,8 @@
 	dev_warn(&device->cdev->dev, "No operational channel path is left "
 		 "for the device\n");
 	DBF_DEV_EVENT(DBF_WARNING, device, "%s", "last path gone");
-	/* First call extended error reporting and check for autoquiesce. */
-	dasd_handle_autoquiesce(device, NULL, DASD_EER_NOPATH);
+	/* First of all call extended error reporting. */
+	dasd_eer_write(device, NULL, DASD_EER_NOPATH);
 
 	if (device->state < DASD_STATE_BASIC)
 		return 0;
@@ -3809,8 +3815,7 @@
 			 "No verified channel paths remain for the device\n");
 		DBF_DEV_EVENT(DBF_WARNING, device,
 			      "%s", "last verified path gone");
-		/* First call extended error reporting and check for autoquiesce. */
-		dasd_handle_autoquiesce(device, NULL, DASD_EER_NOPATH);
+		dasd_eer_write(device, NULL, DASD_EER_NOPATH);
 		dasd_device_set_stop_bits(device,
 					  DASD_STOPPED_DC_WAIT);
 	}
@@ -3832,8 +3837,7 @@
 void dasd_generic_space_exhaust(struct dasd_device *device,
 				struct dasd_ccw_req *cqr)
 {
-	/* First call extended error reporting and check for autoquiesce. */
-	dasd_handle_autoquiesce(device, NULL, DASD_EER_NOSPC);
+	dasd_eer_write(device, NULL, DASD_EER_NOSPC);
 
 	if (device->state < DASD_STATE_BASIC)
 		return;
@@ -3927,31 +3931,6 @@
 }
 EXPORT_SYMBOL(dasd_schedule_requeue);
 
-static int dasd_handle_autoquiesce(struct dasd_device *device,
-				   struct dasd_ccw_req *cqr,
-				   unsigned int reason)
-{
-	/* in any case write eer message with reason */
-	if (dasd_eer_enabled(device))
-		dasd_eer_write(device, cqr, reason);
-
-	if (!test_bit(reason, &device->aq_mask))
-		return 0;
-
-	/* notify eer about autoquiesce */
-	if (dasd_eer_enabled(device))
-		dasd_eer_write(device, NULL, DASD_EER_AUTOQUIESCE);
-
-	dev_info(&device->cdev->dev,
-		 "The DASD has been put in the quiesce state\n");
-	dasd_device_set_stop_bits(device, DASD_STOPPED_QUIESCE);
-
-	if (device->features & DASD_FEATURE_REQUEUEQUIESCE)
-		dasd_schedule_requeue(device);
-
-	return 1;
-}
-
 static struct dasd_ccw_req *dasd_generic_build_rdc(struct dasd_device *device,
 						   int rdc_buffer_size,
 						   int magic)
Index: drivers/s390/block/dasd_int.h
===================================================================
--- drivers/s390/block/dasd_int.h	(revision 55465)
+++ drivers/s390/block/dasd_int.h	(revision 55464)
@@ -464,7 +464,6 @@
 #define DASD_EER_STATECHANGE 3
 #define DASD_EER_PPRCSUSPEND 4
 #define DASD_EER_NOSPC	     5
-#define DASD_EER_AUTOQUIESCE 31
 
 /* DASD path handling */
 
@@ -642,7 +641,6 @@
 	struct dasd_format_entry format_entry;
 	struct kset *paths_info;
 	struct dasd_copy_relation *copy;
-	unsigned long aq_mask;
 };
 
 struct dasd_block {
Index: drivers/s390/block/dasd_eer.c
===================================================================
--- drivers/s390/block/dasd_eer.c	(revision 55465)
+++ drivers/s390/block/dasd_eer.c	(revision 55464)
@@ -387,7 +387,6 @@
 		break;
 	case DASD_EER_NOPATH:
 	case DASD_EER_NOSPC:
-	case DASD_EER_AUTOQUIESCE:
 		dasd_eer_write_standard_trigger(device, NULL, id);
 		break;
 	case DASD_EER_STATECHANGE:
Index: drivers/spi/spi-mt65xx.c
===================================================================
--- drivers/spi/spi-mt65xx.c	(revision 55465)
+++ drivers/spi/spi-mt65xx.c	(revision 55464)
@@ -787,19 +787,17 @@
 		mdata->xfer_len = min(MTK_SPI_MAX_FIFO_SIZE, len);
 		mtk_spi_setup_packet(master);
 
-		if (trans->tx_buf) {
-			cnt = mdata->xfer_len / 4;
-			iowrite32_rep(mdata->base + SPI_TX_DATA_REG,
-					trans->tx_buf + mdata->num_xfered, cnt);
+		cnt = mdata->xfer_len / 4;
+		iowrite32_rep(mdata->base + SPI_TX_DATA_REG,
+				trans->tx_buf + mdata->num_xfered, cnt);
 
-			remainder = mdata->xfer_len % 4;
-			if (remainder > 0) {
-				reg_val = 0;
-				memcpy(&reg_val,
-					trans->tx_buf + (cnt * 4) + mdata->num_xfered,
-					remainder);
-				writel(reg_val, mdata->base + SPI_TX_DATA_REG);
-			}
+		remainder = mdata->xfer_len % 4;
+		if (remainder > 0) {
+			reg_val = 0;
+			memcpy(&reg_val,
+				trans->tx_buf + (cnt * 4) + mdata->num_xfered,
+				remainder);
+			writel(reg_val, mdata->base + SPI_TX_DATA_REG);
 		}
 
 		mtk_spi_enable_transfer(master);
Index: drivers/tty/serial/max310x.c
===================================================================
--- drivers/tty/serial/max310x.c	(revision 55465)
+++ drivers/tty/serial/max310x.c	(revision 55464)
@@ -1459,7 +1459,7 @@
 	if (!ret)
 		return 0;
 
-	dev_err(dev, "Unable to request IRQ %i\n", irq);
+	dev_err(dev, "Unable to reguest IRQ %i\n", irq);
 
 out_uart:
 	for (i = 0; i < devtype->nr; i++) {
Index: drivers/tty/serial/8250/8250_exar.c
===================================================================
--- drivers/tty/serial/8250/8250_exar.c	(revision 55465)
+++ drivers/tty/serial/8250/8250_exar.c	(revision 55464)
@@ -714,7 +714,6 @@
 	for (i = 0; i < priv->nr; i++)
 		serial8250_unregister_port(priv->line[i]);
 
-	/* Ensure that every init quirk is properly torn down */
 	if (priv->board->exit)
 		priv->board->exit(pcidev);
 }
@@ -729,6 +728,10 @@
 		if (priv->line[i] >= 0)
 			serial8250_suspend_port(priv->line[i]);
 
+	/* Ensure that every init quirk is properly torn down */
+	if (priv->board->exit)
+		priv->board->exit(pcidev);
+
 	return 0;
 }
 
Index: drivers/tty/serial/samsung_tty.c
===================================================================
--- drivers/tty/serial/samsung_tty.c	(revision 55465)
+++ drivers/tty/serial/samsung_tty.c	(revision 55464)
@@ -996,10 +996,11 @@
 		if ((ufstat & info->tx_fifomask) != 0 ||
 		    (ufstat & info->tx_fifofull))
 			return 0;
-		return TIOCSER_TEMT;
+
+		return 1;
 	}
 
-	return s3c24xx_serial_txempty_nofifo(port) ? TIOCSER_TEMT : 0;
+	return s3c24xx_serial_txempty_nofifo(port);
 }
 
 /* no modem control lines */
Index: drivers/tty/vt/vt.c
===================================================================
--- drivers/tty/vt/vt.c	(revision 55465)
+++ drivers/tty/vt/vt.c	(revision 55464)
@@ -2515,7 +2515,7 @@
 		}
 		return;
 	case EScsiignore:
-		if (c >= 0x20 && c <= 0x3f)
+		if (c >= 20 && c <= 0x3f)
 			return;
 		vc->vc_state = ESnormal;
 		return;
Index: drivers/bus/Kconfig
===================================================================
--- drivers/bus/Kconfig	(revision 55465)
+++ drivers/bus/Kconfig	(revision 55464)
@@ -186,12 +186,11 @@
 
 config TEGRA_ACONNECT
 	tristate "Tegra ACONNECT Bus Driver"
-	depends on ARCH_TEGRA
+	depends on ARCH_TEGRA_210_SOC
 	depends on OF && PM
 	help
 	  Driver for the Tegra ACONNECT bus which is used to interface with
-	  the devices inside the Audio Processing Engine (APE) for
-	  Tegra210 and later.
+	  the devices inside the Audio Processing Engine (APE) for Tegra210.
 
 config TEGRA_GMI
 	tristate "Tegra Generic Memory Interface bus driver"
Index: drivers/hid/hid-lenovo.c
===================================================================
--- drivers/hid/hid-lenovo.c	(revision 55465)
+++ drivers/hid/hid-lenovo.c	(revision 55464)
@@ -54,10 +54,10 @@
 	/* 0: Up
 	 * 1: Down (undecided)
 	 * 2: Scrolling
+	 * 3: Patched firmware, disable workaround
 	 */
 	u8 middlebutton_state;
 	bool fn_lock;
-	bool middleclick_workaround_cptkbd;
 };
 
 #define map_key_clear(c) hid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))
@@ -621,37 +621,7 @@
 	return count;
 }
 
-static ssize_t attr_middleclick_workaround_show_cptkbd(struct device *dev,
-		struct device_attribute *attr,
-		char *buf)
-{
-	struct hid_device *hdev = to_hid_device(dev);
-	struct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);
 
-	return snprintf(buf, PAGE_SIZE, "%u\n",
-		cptkbd_data->middleclick_workaround_cptkbd);
-}
-
-static ssize_t attr_middleclick_workaround_store_cptkbd(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf,
-		size_t count)
-{
-	struct hid_device *hdev = to_hid_device(dev);
-	struct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);
-	int value;
-
-	if (kstrtoint(buf, 10, &value))
-		return -EINVAL;
-	if (value < 0 || value > 1)
-		return -EINVAL;
-
-	cptkbd_data->middleclick_workaround_cptkbd = !!value;
-
-	return count;
-}
-
-
 static struct device_attribute dev_attr_fn_lock =
 	__ATTR(fn_lock, S_IWUSR | S_IRUGO,
 			attr_fn_lock_show,
@@ -662,16 +632,10 @@
 			attr_sensitivity_show_cptkbd,
 			attr_sensitivity_store_cptkbd);
 
-static struct device_attribute dev_attr_middleclick_workaround_cptkbd =
-	__ATTR(middleclick_workaround, S_IWUSR | S_IRUGO,
-			attr_middleclick_workaround_show_cptkbd,
-			attr_middleclick_workaround_store_cptkbd);
 
-
 static struct attribute *lenovo_attributes_cptkbd[] = {
 	&dev_attr_fn_lock.attr,
 	&dev_attr_sensitivity_cptkbd.attr,
-	&dev_attr_middleclick_workaround_cptkbd.attr,
 	NULL
 };
 
@@ -722,7 +686,23 @@
 {
 	struct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);
 
-	if (cptkbd_data->middleclick_workaround_cptkbd) {
+	if (cptkbd_data->middlebutton_state != 3) {
+		/* REL_X and REL_Y events during middle button pressed
+		 * are only possible on patched, bug-free firmware
+		 * so set middlebutton_state to 3
+		 * to never apply workaround anymore
+		 */
+		if (hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD &&
+				cptkbd_data->middlebutton_state == 1 &&
+				usage->type == EV_REL &&
+				(usage->code == REL_X || usage->code == REL_Y)) {
+			cptkbd_data->middlebutton_state = 3;
+			/* send middle button press which was hold before */
+			input_event(field->hidinput->input,
+				EV_KEY, BTN_MIDDLE, 1);
+			input_sync(field->hidinput->input);
+		}
+
 		/* "wheel" scroll events */
 		if (usage->type == EV_REL && (usage->code == REL_WHEEL ||
 				usage->code == REL_HWHEEL)) {
@@ -1186,7 +1166,6 @@
 	cptkbd_data->middlebutton_state = 0;
 	cptkbd_data->fn_lock = true;
 	cptkbd_data->sensitivity = 0x05;
-	cptkbd_data->middleclick_workaround_cptkbd = true;
 	lenovo_features_set_cptkbd(hdev);
 
 	ret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_cptkbd);
Index: drivers/hid/hid-multitouch.c
===================================================================
--- drivers/hid/hid-multitouch.c	(revision 55465)
+++ drivers/hid/hid-multitouch.c	(revision 55464)
@@ -2155,10 +2155,6 @@
 
 	{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,
 		HID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,
-			USB_VENDOR_ID_SYNAPTICS, 0xcddc) },
-
-	{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,
-		HID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,
 			USB_VENDOR_ID_SYNAPTICS, 0xce08) },
 
 	{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,
Index: drivers/hid/amd-sfh-hid/amd_sfh_pcie.c
===================================================================
--- drivers/hid/amd-sfh-hid/amd_sfh_pcie.c	(revision 55465)
+++ drivers/hid/amd-sfh-hid/amd_sfh_pcie.c	(revision 55464)
@@ -34,8 +34,6 @@
 module_param_named(sensor_mask, sensor_mask_override, int, 0444);
 MODULE_PARM_DESC(sensor_mask, "override the detected sensors mask");
 
-static bool intr_disable = true;
-
 static int amd_sfh_wait_response_v2(struct amd_mp2_dev *mp2, u8 sid, u32 sensor_sts)
 {
 	union cmd_response cmd_resp;
@@ -56,7 +54,7 @@
 
 	cmd_base.ul = 0;
 	cmd_base.cmd_v2.cmd_id = ENABLE_SENSOR;
-	cmd_base.cmd_v2.intr_disable = intr_disable;
+	cmd_base.cmd_v2.intr_disable = 1;
 	cmd_base.cmd_v2.period = info.period;
 	cmd_base.cmd_v2.sensor_id = info.sensor_idx;
 	cmd_base.cmd_v2.length = 16;
@@ -74,7 +72,7 @@
 
 	cmd_base.ul = 0;
 	cmd_base.cmd_v2.cmd_id = DISABLE_SENSOR;
-	cmd_base.cmd_v2.intr_disable = intr_disable;
+	cmd_base.cmd_v2.intr_disable = 1;
 	cmd_base.cmd_v2.period = 0;
 	cmd_base.cmd_v2.sensor_id = sensor_idx;
 	cmd_base.cmd_v2.length  = 16;
@@ -88,7 +86,7 @@
 	union sfh_cmd_base cmd_base;
 
 	cmd_base.cmd_v2.cmd_id = STOP_ALL_SENSORS;
-	cmd_base.cmd_v2.intr_disable = intr_disable;
+	cmd_base.cmd_v2.intr_disable = 1;
 	cmd_base.cmd_v2.period = 0;
 	cmd_base.cmd_v2.sensor_id = 0;
 
@@ -290,26 +288,6 @@
 	return 0;
 }
 
-static int mp2_disable_intr(const struct dmi_system_id *id)
-{
-	intr_disable = false;
-	return 0;
-}
-
-static const struct dmi_system_id dmi_sfh_table[] = {
-	{
-		/*
-		 * https://bugzilla.kernel.org/show_bug.cgi?id=218104
-		 */
-		.callback = mp2_disable_intr,
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "HP ProBook x360 435 G7"),
-		},
-	},
-	{}
-};
-
 static const struct dmi_system_id dmi_nodevs[] = {
 	{
 		/*
@@ -333,8 +311,6 @@
 	if (dmi_first_match(dmi_nodevs))
 		return -ENODEV;
 
-	dmi_check_system(dmi_sfh_table);
-
 	privdata = devm_kzalloc(&pdev->dev, sizeof(*privdata), GFP_KERNEL);
 	if (!privdata)
 		return -ENOMEM;
Index: drivers/hid/amd-sfh-hid/amd_sfh_pcie.h
===================================================================
--- drivers/hid/amd-sfh-hid/amd_sfh_pcie.h	(revision 55465)
+++ drivers/hid/amd-sfh-hid/amd_sfh_pcie.h	(revision 55464)
@@ -89,10 +89,10 @@
 struct hpd_status {
 	union {
 		struct {
+			u32 human_presence_report : 4;
+			u32 human_presence_actual : 4;
+			u32 probablity		  : 8;
 			u32 object_distance       : 16;
-			u32 probablity		  : 8;
-			u32 human_presence_actual : 4;
-			u32 human_presence_report : 4;
 		} shpd;
 		u32 val;
 	};
Index: drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c
===================================================================
--- drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c	(revision 55465)
+++ drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c	(revision 55464)
@@ -305,24 +305,6 @@
 {
 	struct rkisp1_device *rkisp1 = dev_get_drvdata(dev);
 
-	rkisp1->irqs_enabled = false;
-	/* Make sure the IRQ handler will see the above */
-	mb();
-
-	/*
-	 * Wait until any running IRQ handler has returned. The IRQ handler
-	 * may get called even after this (as it's a shared interrupt line)
-	 * but the 'irqs_enabled' flag will make the handler return immediately.
-	 */
-	for (unsigned int il = 0; il < ARRAY_SIZE(rkisp1->irqs); ++il) {
-		if (rkisp1->irqs[il] == -1)
-			continue;
-
-		/* Skip if the irq line is the same as previous */
-		if (il == 0 || rkisp1->irqs[il - 1] != rkisp1->irqs[il])
-			synchronize_irq(rkisp1->irqs[il]);
-	}
-
 	clk_bulk_disable_unprepare(rkisp1->clk_size, rkisp1->clks);
 	return pinctrl_pm_select_sleep_state(dev);
 }
@@ -339,10 +321,6 @@
 	if (ret)
 		return ret;
 
-	rkisp1->irqs_enabled = true;
-	/* Make sure the IRQ handler will see the above */
-	mb();
-
 	return 0;
 }
 
Index: drivers/media/platform/rockchip/rkisp1/rkisp1-common.h
===================================================================
--- drivers/media/platform/rockchip/rkisp1/rkisp1-common.h	(revision 55465)
+++ drivers/media/platform/rockchip/rkisp1/rkisp1-common.h	(revision 55464)
@@ -467,7 +467,6 @@
  * @debug:	   debug params to be exposed on debugfs
  * @info:	   version-specific ISP information
  * @irqs:          IRQ line numbers
- * @irqs_enabled:  the hardware is enabled and can cause interrupts
  */
 struct rkisp1_device {
 	void __iomem *base_addr;
@@ -489,7 +488,6 @@
 	struct rkisp1_debug debug;
 	const struct rkisp1_info *info;
 	int irqs[RKISP1_NUM_IRQS];
-	bool irqs_enabled;
 };
 
 /*
Index: drivers/media/platform/rockchip/rkisp1/rkisp1-csi.c
===================================================================
--- drivers/media/platform/rockchip/rkisp1/rkisp1-csi.c	(revision 55465)
+++ drivers/media/platform/rockchip/rkisp1/rkisp1-csi.c	(revision 55464)
@@ -211,9 +211,6 @@
 	struct rkisp1_device *rkisp1 = dev_get_drvdata(dev);
 	u32 val, status;
 
-	if (!rkisp1->irqs_enabled)
-		return IRQ_NONE;
-
 	status = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_MIS);
 	if (!status)
 		return IRQ_NONE;
Index: drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c
===================================================================
--- drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c	(revision 55465)
+++ drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c	(revision 55464)
@@ -1023,9 +1023,6 @@
 	struct rkisp1_device *rkisp1 = dev_get_drvdata(dev);
 	u32 status, isp_err;
 
-	if (!rkisp1->irqs_enabled)
-		return IRQ_NONE;
-
 	status = rkisp1_read(rkisp1, RKISP1_CIF_ISP_MIS);
 	if (!status)
 		return IRQ_NONE;
Index: drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c
===================================================================
--- drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c	(revision 55465)
+++ drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c	(revision 55464)
@@ -701,9 +701,6 @@
 	unsigned int i;
 	u32 status;
 
-	if (!rkisp1->irqs_enabled)
-		return IRQ_NONE;
-
 	status = rkisp1_read(rkisp1, RKISP1_CIF_MI_MIS);
 	if (!status)
 		return IRQ_NONE;
Index: drivers/media/platform/mediatek/vcodec/mtk_vcodec_fw_vpu.c
===================================================================
--- drivers/media/platform/mediatek/vcodec/mtk_vcodec_fw_vpu.c	(revision 55465)
+++ drivers/media/platform/mediatek/vcodec/mtk_vcodec_fw_vpu.c	(revision 55464)
@@ -29,7 +29,15 @@
 					   mtk_vcodec_ipi_handler handler,
 					   const char *name, void *priv)
 {
-	return vpu_ipi_register(fw->pdev, id, handler, name, priv);
+	/*
+	 * The handler we receive takes a void * as its first argument. We
+	 * cannot change this because it needs to be passed down to the rproc
+	 * subsystem when SCP is used. VPU takes a const argument, which is
+	 * more constrained, so the conversion below is safe.
+	 */
+	ipi_handler_t handler_const = (ipi_handler_t)handler;
+
+	return vpu_ipi_register(fw->pdev, id, handler_const, name, priv);
 }
 
 static int mtk_vcodec_vpu_ipi_send(struct mtk_vcodec_fw *fw, int id, void *buf,
Index: drivers/media/platform/mediatek/vpu/mtk_vpu.c
===================================================================
--- drivers/media/platform/mediatek/vpu/mtk_vpu.c	(revision 55465)
+++ drivers/media/platform/mediatek/vpu/mtk_vpu.c	(revision 55464)
@@ -635,7 +635,7 @@
 }
 EXPORT_SYMBOL_GPL(vpu_load_firmware);
 
-static void vpu_init_ipi_handler(void *data, unsigned int len, void *priv)
+static void vpu_init_ipi_handler(const void *data, unsigned int len, void *priv)
 {
 	struct mtk_vpu *vpu = priv;
 	const struct vpu_run *run = data;
Index: drivers/media/platform/mediatek/vpu/mtk_vpu.h
===================================================================
--- drivers/media/platform/mediatek/vpu/mtk_vpu.h	(revision 55465)
+++ drivers/media/platform/mediatek/vpu/mtk_vpu.h	(revision 55464)
@@ -17,7 +17,7 @@
  * VPU interfaces with other blocks by share memory and interrupt.
  */
 
-typedef void (*ipi_handler_t) (void *data,
+typedef void (*ipi_handler_t) (const void *data,
 			       unsigned int len,
 			       void *priv);
 
Index: drivers/media/platform/mediatek/mdp/mtk_mdp_vpu.c
===================================================================
--- drivers/media/platform/mediatek/mdp/mtk_mdp_vpu.c	(revision 55465)
+++ drivers/media/platform/mediatek/mdp/mtk_mdp_vpu.c	(revision 55464)
@@ -26,7 +26,7 @@
 	vpu->inst_addr = msg->vpu_inst_addr;
 }
 
-static void mtk_mdp_vpu_ipi_handler(void *data, unsigned int len,
+static void mtk_mdp_vpu_ipi_handler(const void *data, unsigned int len,
 				    void *priv)
 {
 	const struct mdp_ipi_comm_ack *msg = data;
Index: drivers/media/platform/sunxi/sun8i-di/sun8i-di.c
===================================================================
--- drivers/media/platform/sunxi/sun8i-di/sun8i-di.c	(revision 55465)
+++ drivers/media/platform/sunxi/sun8i-di/sun8i-di.c	(revision 55464)
@@ -66,7 +66,6 @@
 	struct vb2_v4l2_buffer *src, *dst;
 	unsigned int hstep, vstep;
 	dma_addr_t addr;
-	int i;
 
 	src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
 	dst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
@@ -161,26 +160,6 @@
 	deinterlace_write(dev, DEINTERLACE_CH1_HORZ_FACT, hstep);
 	deinterlace_write(dev, DEINTERLACE_CH1_VERT_FACT, vstep);
 
-	/* neutral filter coefficients */
-	deinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,
-			     DEINTERLACE_FRM_CTRL_COEF_ACCESS);
-	readl_poll_timeout(dev->base + DEINTERLACE_STATUS, val,
-			   val & DEINTERLACE_STATUS_COEF_STATUS, 2, 40);
-
-	for (i = 0; i < 32; i++) {
-		deinterlace_write(dev, DEINTERLACE_CH0_HORZ_COEF0 + i * 4,
-				  DEINTERLACE_IDENTITY_COEF);
-		deinterlace_write(dev, DEINTERLACE_CH0_VERT_COEF + i * 4,
-				  DEINTERLACE_IDENTITY_COEF);
-		deinterlace_write(dev, DEINTERLACE_CH1_HORZ_COEF0 + i * 4,
-				  DEINTERLACE_IDENTITY_COEF);
-		deinterlace_write(dev, DEINTERLACE_CH1_VERT_COEF + i * 4,
-				  DEINTERLACE_IDENTITY_COEF);
-	}
-
-	deinterlace_clr_set_bits(dev, DEINTERLACE_FRM_CTRL,
-				 DEINTERLACE_FRM_CTRL_COEF_ACCESS, 0);
-
 	deinterlace_clr_set_bits(dev, DEINTERLACE_FIELD_CTRL,
 				 DEINTERLACE_FIELD_CTRL_FIELD_CNT_MSK,
 				 DEINTERLACE_FIELD_CTRL_FIELD_CNT(ctx->field));
@@ -269,6 +248,7 @@
 static void deinterlace_init(struct deinterlace_dev *dev)
 {
 	u32 val;
+	int i;
 
 	deinterlace_write(dev, DEINTERLACE_BYPASS,
 			  DEINTERLACE_BYPASS_CSC);
@@ -304,7 +284,27 @@
 
 	deinterlace_clr_set_bits(dev, DEINTERLACE_CHROMA_DIFF,
 				 DEINTERLACE_CHROMA_DIFF_TH_MSK,
-				 DEINTERLACE_CHROMA_DIFF_TH(31));
+				 DEINTERLACE_CHROMA_DIFF_TH(5));
+
+	/* neutral filter coefficients */
+	deinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,
+			     DEINTERLACE_FRM_CTRL_COEF_ACCESS);
+	readl_poll_timeout(dev->base + DEINTERLACE_STATUS, val,
+			   val & DEINTERLACE_STATUS_COEF_STATUS, 2, 40);
+
+	for (i = 0; i < 32; i++) {
+		deinterlace_write(dev, DEINTERLACE_CH0_HORZ_COEF0 + i * 4,
+				  DEINTERLACE_IDENTITY_COEF);
+		deinterlace_write(dev, DEINTERLACE_CH0_VERT_COEF + i * 4,
+				  DEINTERLACE_IDENTITY_COEF);
+		deinterlace_write(dev, DEINTERLACE_CH1_HORZ_COEF0 + i * 4,
+				  DEINTERLACE_IDENTITY_COEF);
+		deinterlace_write(dev, DEINTERLACE_CH1_VERT_COEF + i * 4,
+				  DEINTERLACE_IDENTITY_COEF);
+	}
+
+	deinterlace_clr_set_bits(dev, DEINTERLACE_FRM_CTRL,
+				 DEINTERLACE_FRM_CTRL_COEF_ACCESS, 0);
 }
 
 static inline struct deinterlace_ctx *deinterlace_file2ctx(struct file *file)
@@ -931,18 +931,11 @@
 		return ret;
 	}
 
-	ret = reset_control_deassert(dev->rstc);
-	if (ret) {
-		dev_err(dev->dev, "Failed to apply reset\n");
-
-		goto err_exclusive_rate;
-	}
-
 	ret = clk_prepare_enable(dev->bus_clk);
 	if (ret) {
 		dev_err(dev->dev, "Failed to enable bus clock\n");
 
-		goto err_rst;
+		goto err_exclusive_rate;
 	}
 
 	ret = clk_prepare_enable(dev->mod_clk);
@@ -959,16 +952,23 @@
 		goto err_mod_clk;
 	}
 
+	ret = reset_control_deassert(dev->rstc);
+	if (ret) {
+		dev_err(dev->dev, "Failed to apply reset\n");
+
+		goto err_ram_clk;
+	}
+
 	deinterlace_init(dev);
 
 	return 0;
 
+err_ram_clk:
+	clk_disable_unprepare(dev->ram_clk);
 err_mod_clk:
 	clk_disable_unprepare(dev->mod_clk);
 err_bus_clk:
 	clk_disable_unprepare(dev->bus_clk);
-err_rst:
-	reset_control_assert(dev->rstc);
 err_exclusive_rate:
 	clk_rate_exclusive_put(dev->mod_clk);
 
@@ -979,12 +979,11 @@
 {
 	struct deinterlace_dev *dev = dev_get_drvdata(device);
 
+	reset_control_assert(dev->rstc);
+
 	clk_disable_unprepare(dev->ram_clk);
 	clk_disable_unprepare(dev->mod_clk);
 	clk_disable_unprepare(dev->bus_clk);
-
-	reset_control_assert(dev->rstc);
-
 	clk_rate_exclusive_put(dev->mod_clk);
 
 	return 0;
Index: drivers/media/i2c/tc358743.c
===================================================================
--- drivers/media/i2c/tc358743.c	(revision 55465)
+++ drivers/media/i2c/tc358743.c	(revision 55464)
@@ -2094,6 +2094,9 @@
 	state->mbus_fmt_code = MEDIA_BUS_FMT_RGB888_1X24;
 
 	sd->dev = &client->dev;
+	err = v4l2_async_register_subdev(sd);
+	if (err < 0)
+		goto err_hdl;
 
 	mutex_init(&state->confctl_mutex);
 
@@ -2151,10 +2154,6 @@
 	if (err)
 		goto err_work_queues;
 
-	err = v4l2_async_register_subdev(sd);
-	if (err < 0)
-		goto err_work_queues;
-
 	v4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,
 		  client->addr << 1, client->adapter->name);
 
Index: drivers/media/usb/pvrusb2/pvrusb2-context.c
===================================================================
--- drivers/media/usb/pvrusb2/pvrusb2-context.c	(revision 55465)
+++ drivers/media/usb/pvrusb2/pvrusb2-context.c	(revision 55464)
@@ -90,10 +90,8 @@
 }
 
 
-static void pvr2_context_notify(void *ptr)
+static void pvr2_context_notify(struct pvr2_context *mp)
 {
-	struct pvr2_context *mp = ptr;
-
 	pvr2_context_set_notify(mp,!0);
 }
 
@@ -108,7 +106,9 @@
 		pvr2_trace(PVR2_TRACE_CTXT,
 			   "pvr2_context %p (initialize)", mp);
 		/* Finish hardware initialization */
-		if (pvr2_hdw_initialize(mp->hdw, pvr2_context_notify, mp)) {
+		if (pvr2_hdw_initialize(mp->hdw,
+					(void (*)(void *))pvr2_context_notify,
+					mp)) {
 			mp->video_stream.stream =
 				pvr2_hdw_get_video_stream(mp->hdw);
 			/* Trigger interface initialization.  By doing this
@@ -267,9 +267,9 @@
 void pvr2_context_disconnect(struct pvr2_context *mp)
 {
 	pvr2_hdw_disconnect(mp->hdw);
+	mp->disconnect_flag = !0;
 	if (!pvr2_context_shutok())
 		pvr2_context_notify(mp);
-	mp->disconnect_flag = !0;
 }
 
 
Index: drivers/media/usb/pvrusb2/pvrusb2-dvb.c
===================================================================
--- drivers/media/usb/pvrusb2/pvrusb2-dvb.c	(revision 55465)
+++ drivers/media/usb/pvrusb2/pvrusb2-dvb.c	(revision 55464)
@@ -88,10 +88,8 @@
 	return stat;
 }
 
-static void pvr2_dvb_notify(void *ptr)
+static void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap)
 {
-	struct pvr2_dvb_adapter *adap = ptr;
-
 	wake_up(&adap->buffer_wait_data);
 }
 
@@ -151,7 +149,7 @@
 	}
 
 	pvr2_stream_set_callback(pvr->video_stream.stream,
-				 pvr2_dvb_notify, adap);
+				 (pvr2_stream_callback) pvr2_dvb_notify, adap);
 
 	ret = pvr2_stream_set_buffer_count(stream, PVR2_DVB_BUFFER_COUNT);
 	if (ret < 0) return ret;
Index: drivers/media/usb/pvrusb2/pvrusb2-v4l2.c
===================================================================
--- drivers/media/usb/pvrusb2/pvrusb2-v4l2.c	(revision 55465)
+++ drivers/media/usb/pvrusb2/pvrusb2-v4l2.c	(revision 55464)
@@ -1033,10 +1033,8 @@
 }
 
 
-static void pvr2_v4l2_notify(void *ptr)
+static void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp)
 {
-	struct pvr2_v4l2_fh *fhp = ptr;
-
 	wake_up(&fhp->wait_data);
 }
 
@@ -1069,7 +1067,7 @@
 
 	hdw = fh->channel.mc_head->hdw;
 	sp = fh->pdi->stream->stream;
-	pvr2_stream_set_callback(sp, pvr2_v4l2_notify, fh);
+	pvr2_stream_set_callback(sp,(pvr2_stream_callback)pvr2_v4l2_notify,fh);
 	pvr2_hdw_set_stream_type(hdw,fh->pdi->config);
 	if ((ret = pvr2_hdw_set_streaming(hdw,!0)) < 0) return ret;
 	return pvr2_ioread_set_enabled(fh->rhp,!0);
@@ -1200,6 +1198,11 @@
 		dip->minor_type = pvr2_v4l_type_video;
 		nr_ptr = video_nr;
 		caps |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_AUDIO;
+		if (!dip->stream) {
+			pr_err(KBUILD_MODNAME
+				": Failed to set up pvrusb2 v4l video dev due to missing stream instance\n");
+			return;
+		}
 		break;
 	case VFL_TYPE_VBI:
 		dip->config = pvr2_config_vbi;
Index: drivers/media/usb/em28xx/em28xx-cards.c
===================================================================
--- drivers/media/usb/em28xx/em28xx-cards.c	(revision 55465)
+++ drivers/media/usb/em28xx/em28xx-cards.c	(revision 55464)
@@ -4094,10 +4094,6 @@
 	 * topology will likely change after the load of the em28xx subdrivers.
 	 */
 #ifdef CONFIG_MEDIA_CONTROLLER
-	/*
-	 * No need to check the return value, the device will still be
-	 * usable without media controller API.
-	 */
 	retval = media_device_register(dev->media_dev);
 #endif
 
Index: drivers/media/usb/go7007/go7007-driver.c
===================================================================
--- drivers/media/usb/go7007/go7007-driver.c	(revision 55465)
+++ drivers/media/usb/go7007/go7007-driver.c	(revision 55464)
@@ -80,7 +80,7 @@
 	const struct firmware *fw_entry;
 	char fw_name[] = "go7007/go7007fw.bin";
 	void *bounce;
-	int fw_len;
+	int fw_len, rv = 0;
 	u16 intr_val, intr_data;
 
 	if (go->boot_fw == NULL) {
@@ -109,11 +109,9 @@
 	    go7007_read_interrupt(go, &intr_val, &intr_data) < 0 ||
 			(intr_val & ~0x1) != 0x5a5a) {
 		v4l2_err(go, "error transferring firmware\n");
-		kfree(go->boot_fw);
-		go->boot_fw = NULL;
-		return -1;
+		rv = -1;
 	}
-	return 0;
+	return rv;
 }
 
 MODULE_FIRMWARE("go7007/go7007fw.bin");
Index: drivers/media/usb/go7007/go7007-usb.c
===================================================================
--- drivers/media/usb/go7007/go7007-usb.c	(revision 55465)
+++ drivers/media/usb/go7007/go7007-usb.c	(revision 55464)
@@ -1201,9 +1201,7 @@
 				u16 channel;
 
 				/* read channel number from GPIO[1:0] */
-				if (go7007_read_addr(go, 0x3c81, &channel))
-					goto allocfail;
-
+				go7007_read_addr(go, 0x3c81, &channel);
 				channel &= 0x3;
 				go->board_id = GO7007_BOARDID_ADLINK_MPG24;
 				usb->board = board = &board_adlink_mpg24;
Index: drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
===================================================================
--- drivers/media/common/v4l2-tpg/v4l2-tpg-core.c	(revision 55465)
+++ drivers/media/common/v4l2-tpg/v4l2-tpg-core.c	(revision 55464)
@@ -113,7 +113,6 @@
 {
 	unsigned pat;
 	unsigned plane;
-	int ret = 0;
 
 	tpg->max_line_width = max_w;
 	for (pat = 0; pat < TPG_MAX_PAT_LINES; pat++) {
@@ -122,18 +121,14 @@
 
 			tpg->lines[pat][plane] =
 				vzalloc(array3_size(max_w, 2, pixelsz));
-			if (!tpg->lines[pat][plane]) {
-				ret = -ENOMEM;
-				goto free_lines;
-			}
+			if (!tpg->lines[pat][plane])
+				return -ENOMEM;
 			if (plane == 0)
 				continue;
 			tpg->downsampled_lines[pat][plane] =
 				vzalloc(array3_size(max_w, 2, pixelsz));
-			if (!tpg->downsampled_lines[pat][plane]) {
-				ret = -ENOMEM;
-				goto free_lines;
-			}
+			if (!tpg->downsampled_lines[pat][plane])
+				return -ENOMEM;
 		}
 	}
 	for (plane = 0; plane < TPG_MAX_PLANES; plane++) {
@@ -141,45 +136,18 @@
 
 		tpg->contrast_line[plane] =
 			vzalloc(array_size(pixelsz, max_w));
-		if (!tpg->contrast_line[plane]) {
-			ret = -ENOMEM;
-			goto free_contrast_line;
-		}
+		if (!tpg->contrast_line[plane])
+			return -ENOMEM;
 		tpg->black_line[plane] =
 			vzalloc(array_size(pixelsz, max_w));
-		if (!tpg->black_line[plane]) {
-			ret = -ENOMEM;
-			goto free_contrast_line;
-		}
+		if (!tpg->black_line[plane])
+			return -ENOMEM;
 		tpg->random_line[plane] =
 			vzalloc(array3_size(max_w, 2, pixelsz));
-		if (!tpg->random_line[plane]) {
-			ret = -ENOMEM;
-			goto free_contrast_line;
-		}
+		if (!tpg->random_line[plane])
+			return -ENOMEM;
 	}
 	return 0;
-
-free_contrast_line:
-	for (plane = 0; plane < TPG_MAX_PLANES; plane++) {
-		vfree(tpg->contrast_line[plane]);
-		vfree(tpg->black_line[plane]);
-		vfree(tpg->random_line[plane]);
-		tpg->contrast_line[plane] = NULL;
-		tpg->black_line[plane] = NULL;
-		tpg->random_line[plane] = NULL;
-	}
-free_lines:
-	for (pat = 0; pat < TPG_MAX_PAT_LINES; pat++)
-		for (plane = 0; plane < TPG_MAX_PLANES; plane++) {
-			vfree(tpg->lines[pat][plane]);
-			tpg->lines[pat][plane] = NULL;
-			if (plane == 0)
-				continue;
-			vfree(tpg->downsampled_lines[pat][plane]);
-			tpg->downsampled_lines[pat][plane] = NULL;
-		}
-	return ret;
 }
 EXPORT_SYMBOL_GPL(tpg_alloc);
 
Index: drivers/media/dvb-core/dvbdev.c
===================================================================
--- drivers/media/dvb-core/dvbdev.c	(revision 55465)
+++ drivers/media/dvb-core/dvbdev.c	(revision 55464)
@@ -494,7 +494,6 @@
 		dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
 		if (!dvbdevfops) {
 			kfree(dvbdev);
-			*pdvbdev = NULL;
 			mutex_unlock(&dvbdev_register_lock);
 			return -ENOMEM;
 		}
@@ -503,7 +502,6 @@
 		if (!new_node) {
 			kfree(dvbdevfops);
 			kfree(dvbdev);
-			*pdvbdev = NULL;
 			mutex_unlock(&dvbdev_register_lock);
 			return -ENOMEM;
 		}
@@ -537,7 +535,6 @@
 		}
 		list_del (&dvbdev->list_head);
 		kfree(dvbdev);
-		*pdvbdev = NULL;
 		up_write(&minor_rwsem);
 		mutex_unlock(&dvbdev_register_lock);
 		return -EINVAL;
@@ -560,7 +557,6 @@
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
 		kfree(dvbdev);
-		*pdvbdev = NULL;
 		mutex_unlock(&dvbdev_register_lock);
 		return ret;
 	}
@@ -579,7 +575,6 @@
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
 		kfree(dvbdev);
-		*pdvbdev = NULL;
 		mutex_unlock(&dvbdev_register_lock);
 		return PTR_ERR(clsdev);
 	}
Index: drivers/media/dvb-frontends/stv0367.c
===================================================================
--- drivers/media/dvb-frontends/stv0367.c	(revision 55465)
+++ drivers/media/dvb-frontends/stv0367.c	(revision 55464)
@@ -118,33 +118,51 @@
 	}
 };
 
-static noinline_for_stack
-int stv0367_writereg(struct stv0367_state *state, u16 reg, u8 data)
+static
+int stv0367_writeregs(struct stv0367_state *state, u16 reg, u8 *data, int len)
 {
-	u8 buf[3] = { MSB(reg), LSB(reg), data };
+	u8 buf[MAX_XFER_SIZE];
 	struct i2c_msg msg = {
 		.addr = state->config->demod_address,
 		.flags = 0,
 		.buf = buf,
-		.len = 3,
+		.len = len + 2
 	};
 	int ret;
 
+	if (2 + len > sizeof(buf)) {
+		printk(KERN_WARNING
+		       "%s: i2c wr reg=%04x: len=%d is too big!\n",
+		       KBUILD_MODNAME, reg, len);
+		return -EINVAL;
+	}
+
+
+	buf[0] = MSB(reg);
+	buf[1] = LSB(reg);
+	memcpy(buf + 2, data, len);
+
 	if (i2cdebug)
 		printk(KERN_DEBUG "%s: [%02x] %02x: %02x\n", __func__,
-			state->config->demod_address, reg, data);
+			state->config->demod_address, reg, buf[2]);
 
 	ret = i2c_transfer(state->i2c, &msg, 1);
 	if (ret != 1)
 		printk(KERN_ERR "%s: i2c write error! ([%02x] %02x: %02x)\n",
-			__func__, state->config->demod_address, reg, data);
+			__func__, state->config->demod_address, reg, buf[2]);
 
 	return (ret != 1) ? -EREMOTEIO : 0;
 }
 
-static noinline_for_stack
-u8 stv0367_readreg(struct stv0367_state *state, u16 reg)
+static int stv0367_writereg(struct stv0367_state *state, u16 reg, u8 data)
 {
+	u8 tmp = data; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */
+
+	return stv0367_writeregs(state, reg, &tmp, 1);
+}
+
+static u8 stv0367_readreg(struct stv0367_state *state, u16 reg)
+{
 	u8 b0[] = { 0, 0 };
 	u8 b1[] = { 0 };
 	struct i2c_msg msg[] = {
Index: drivers/media/v4l2-core/v4l2-mem2mem.c
===================================================================
--- drivers/media/v4l2-core/v4l2-mem2mem.c	(revision 55465)
+++ drivers/media/v4l2-core/v4l2-mem2mem.c	(revision 55464)
@@ -1084,17 +1084,11 @@
 	entity->function = function;
 
 	ret = media_entity_pads_init(entity, num_pads, pads);
-	if (ret) {
-		kfree(entity->name);
-		entity->name = NULL;
+	if (ret)
 		return ret;
-	}
 	ret = media_device_register_entity(mdev, entity);
-	if (ret) {
-		kfree(entity->name);
-		entity->name = NULL;
+	if (ret)
 		return ret;
-	}
 
 	return 0;
 }
Index: drivers/staging/media/sunxi/cedrus/cedrus.h
===================================================================
--- drivers/staging/media/sunxi/cedrus/cedrus.h	(revision 55465)
+++ drivers/staging/media/sunxi/cedrus/cedrus.h	(revision 55464)
@@ -109,11 +109,6 @@
 			unsigned int			position;
 			enum cedrus_h264_pic_type	pic_type;
 		} h264;
-		struct {
-			void		*mv_col_buf;
-			dma_addr_t	mv_col_buf_dma;
-			ssize_t		mv_col_buf_size;
-		} h265;
 	} codec;
 };
 
@@ -147,6 +142,10 @@
 			ssize_t		intra_pred_buf_size;
 		} h264;
 		struct {
+			void		*mv_col_buf;
+			dma_addr_t	mv_col_buf_addr;
+			ssize_t		mv_col_buf_size;
+			ssize_t		mv_col_buf_unit_size;
 			void		*neighbor_info_buf;
 			dma_addr_t	neighbor_info_buf_addr;
 			void		*entry_points_buf;
Index: drivers/staging/media/sunxi/cedrus/cedrus_h265.c
===================================================================
--- drivers/staging/media/sunxi/cedrus/cedrus_h265.c	(revision 55465)
+++ drivers/staging/media/sunxi/cedrus/cedrus_h265.c	(revision 55464)
@@ -90,13 +90,12 @@
 }
 
 static inline dma_addr_t
-cedrus_h265_frame_info_mv_col_buf_addr(struct vb2_buffer *buf,
-				       unsigned int field)
+cedrus_h265_frame_info_mv_col_buf_addr(struct cedrus_ctx *ctx,
+				       unsigned int index, unsigned int field)
 {
-	struct cedrus_buffer *cedrus_buf = vb2_to_cedrus_buffer(buf);
-
-	return cedrus_buf->codec.h265.mv_col_buf_dma +
-	       field * cedrus_buf->codec.h265.mv_col_buf_size / 2;
+	return ctx->codec.h265.mv_col_buf_addr + index *
+	       ctx->codec.h265.mv_col_buf_unit_size +
+	       field * ctx->codec.h265.mv_col_buf_unit_size / 2;
 }
 
 static void cedrus_h265_frame_info_write_single(struct cedrus_ctx *ctx,
@@ -109,8 +108,9 @@
 	dma_addr_t dst_luma_addr = cedrus_dst_buf_addr(ctx, buf, 0);
 	dma_addr_t dst_chroma_addr = cedrus_dst_buf_addr(ctx, buf, 1);
 	dma_addr_t mv_col_buf_addr[2] = {
-		cedrus_h265_frame_info_mv_col_buf_addr(buf, 0),
-		cedrus_h265_frame_info_mv_col_buf_addr(buf, field_pic ? 1 : 0)
+		cedrus_h265_frame_info_mv_col_buf_addr(ctx, buf->index, 0),
+		cedrus_h265_frame_info_mv_col_buf_addr(ctx, buf->index,
+						       field_pic ? 1 : 0)
 	};
 	u32 offset = VE_DEC_H265_SRAM_OFFSET_FRAME_INFO +
 		     VE_DEC_H265_SRAM_OFFSET_FRAME_INFO_UNIT * index;
@@ -412,13 +412,12 @@
 	unsigned int width_in_ctb_luma, ctb_size_luma;
 	unsigned int log2_max_luma_coding_block_size;
 	unsigned int ctb_addr_x, ctb_addr_y;
-	struct cedrus_buffer *cedrus_buf;
 	dma_addr_t src_buf_addr;
+	dma_addr_t src_buf_end_addr;
 	u32 chroma_log2_weight_denom;
 	u32 num_entry_point_offsets;
 	u32 output_pic_list_index;
 	u32 pic_order_cnt[2];
-	size_t slice_bytes;
 	u8 padding;
 	int count;
 	u32 reg;
@@ -429,8 +428,6 @@
 	decode_params = run->h265.decode_params;
 	pred_weight_table = &slice_params->pred_weight_table;
 	num_entry_point_offsets = slice_params->num_entry_point_offsets;
-	cedrus_buf = vb2_to_cedrus_buffer(&run->dst->vb2_buf);
-	slice_bytes = vb2_get_plane_payload(&run->src->vb2_buf, 0);
 
 	/*
 	 * If entry points offsets are present, we should get them
@@ -448,25 +445,31 @@
 		DIV_ROUND_UP(sps->pic_width_in_luma_samples, ctb_size_luma);
 
 	/* MV column buffer size and allocation. */
-	if (!cedrus_buf->codec.h265.mv_col_buf_size) {
+	if (!ctx->codec.h265.mv_col_buf_size) {
+		unsigned int num_buffers =
+			run->dst->vb2_buf.vb2_queue->num_buffers;
+
 		/*
 		 * Each CTB requires a MV col buffer with a specific unit size.
 		 * Since the address is given with missing lsb bits, 1 KiB is
 		 * added to each buffer to ensure proper alignment.
 		 */
-		cedrus_buf->codec.h265.mv_col_buf_size =
+		ctx->codec.h265.mv_col_buf_unit_size =
 			DIV_ROUND_UP(ctx->src_fmt.width, ctb_size_luma) *
 			DIV_ROUND_UP(ctx->src_fmt.height, ctb_size_luma) *
 			CEDRUS_H265_MV_COL_BUF_UNIT_CTB_SIZE + SZ_1K;
 
+		ctx->codec.h265.mv_col_buf_size = num_buffers *
+			ctx->codec.h265.mv_col_buf_unit_size;
+
 		/* Buffer is never accessed by CPU, so we can skip kernel mapping. */
-		cedrus_buf->codec.h265.mv_col_buf =
+		ctx->codec.h265.mv_col_buf =
 			dma_alloc_attrs(dev->dev,
-					cedrus_buf->codec.h265.mv_col_buf_size,
-					&cedrus_buf->codec.h265.mv_col_buf_dma,
+					ctx->codec.h265.mv_col_buf_size,
+					&ctx->codec.h265.mv_col_buf_addr,
 					GFP_KERNEL, DMA_ATTR_NO_KERNEL_MAPPING);
-		if (!cedrus_buf->codec.h265.mv_col_buf) {
-			cedrus_buf->codec.h265.mv_col_buf_size = 0;
+		if (!ctx->codec.h265.mv_col_buf) {
+			ctx->codec.h265.mv_col_buf_size = 0;
 			return -ENOMEM;
 		}
 	}
@@ -478,7 +481,7 @@
 
 	cedrus_write(dev, VE_DEC_H265_BITS_OFFSET, 0);
 
-	reg = slice_bytes * 8;
+	reg = slice_params->bit_size;
 	cedrus_write(dev, VE_DEC_H265_BITS_LEN, reg);
 
 	/* Source beginning and end addresses. */
@@ -492,7 +495,10 @@
 
 	cedrus_write(dev, VE_DEC_H265_BITS_ADDR, reg);
 
-	reg = VE_DEC_H265_BITS_END_ADDR_BASE(src_buf_addr + slice_bytes);
+	src_buf_end_addr = src_buf_addr +
+			   DIV_ROUND_UP(slice_params->bit_size, 8);
+
+	reg = VE_DEC_H265_BITS_END_ADDR_BASE(src_buf_end_addr);
 	cedrus_write(dev, VE_DEC_H265_BITS_END_ADDR, reg);
 
 	/* Coding tree block address */
@@ -810,6 +816,9 @@
 {
 	struct cedrus_dev *dev = ctx->dev;
 
+	/* The buffer size is calculated at setup time. */
+	ctx->codec.h265.mv_col_buf_size = 0;
+
 	/* Buffer is never accessed by CPU, so we can skip kernel mapping. */
 	ctx->codec.h265.neighbor_info_buf =
 		dma_alloc_attrs(dev->dev, CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE,
@@ -836,24 +845,14 @@
 static void cedrus_h265_stop(struct cedrus_ctx *ctx)
 {
 	struct cedrus_dev *dev = ctx->dev;
-	struct cedrus_buffer *buf;
-	struct vb2_queue *vq;
-	unsigned int i;
 
-	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	if (ctx->codec.h265.mv_col_buf_size > 0) {
+		dma_free_attrs(dev->dev, ctx->codec.h265.mv_col_buf_size,
+			       ctx->codec.h265.mv_col_buf,
+			       ctx->codec.h265.mv_col_buf_addr,
+			       DMA_ATTR_NO_KERNEL_MAPPING);
 
-	for (i = 0; i < vq->num_buffers; i++) {
-		buf = vb2_to_cedrus_buffer(vb2_get_buffer(vq, i));
-
-		if (buf->codec.h265.mv_col_buf_size > 0) {
-			dma_free_attrs(dev->dev,
-				       buf->codec.h265.mv_col_buf_size,
-				       buf->codec.h265.mv_col_buf,
-				       buf->codec.h265.mv_col_buf_dma,
-				       DMA_ATTR_NO_KERNEL_MAPPING);
-
-			buf->codec.h265.mv_col_buf_size = 0;
-		}
+		ctx->codec.h265.mv_col_buf_size = 0;
 	}
 
 	dma_free_attrs(dev->dev, CEDRUS_H265_NEIGHBOR_INFO_BUF_SIZE,
Index: drivers/staging/media/deprecated/saa7146/ttpci/budget-av.c
===================================================================
--- drivers/staging/media/deprecated/saa7146/ttpci/budget-av.c	(revision 55465)
+++ drivers/staging/media/deprecated/saa7146/ttpci/budget-av.c	(revision 55464)
@@ -1462,8 +1462,7 @@
 		budget_av->has_saa7113 = 1;
 		err = saa7146_vv_init(dev, &vv_data);
 		if (err != 0) {
-			ttpci_budget_deinit(&budget_av->budget);
-			kfree(budget_av);
+			/* fixme: proper cleanup here */
 			ERR("cannot init vv subsystem\n");
 			return err;
 		}
@@ -1472,10 +1471,9 @@
 		vv_data.vid_ops.vidioc_s_input = vidioc_s_input;
 
 		if ((err = saa7146_register_device(&budget_av->vd, dev, "knc1", VFL_TYPE_VIDEO))) {
+			/* fixme: proper cleanup here */
+			ERR("cannot register capture v4l2 device\n");
 			saa7146_vv_release(dev);
-			ttpci_budget_deinit(&budget_av->budget);
-			kfree(budget_av);
-			ERR("cannot register capture v4l2 device\n");
 			return err;
 		}
 
Index: drivers/staging/media/imx/imx-media-csc-scaler.c
===================================================================
--- drivers/staging/media/imx/imx-media-csc-scaler.c	(revision 55465)
+++ drivers/staging/media/imx/imx-media-csc-scaler.c	(revision 55464)
@@ -803,7 +803,6 @@
 
 	dev_dbg(priv->dev, "Releasing instance %p\n", ctx);
 
-	v4l2_ctrl_handler_free(&ctx->ctrl_hdlr);
 	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
 	v4l2_fh_del(&ctx->fh);
 	v4l2_fh_exit(&ctx->fh);
Index: drivers/staging/greybus/light.c
===================================================================
--- drivers/staging/greybus/light.c	(revision 55465)
+++ drivers/staging/greybus/light.c	(revision 55464)
@@ -100,15 +100,15 @@
 static struct gb_channel *get_channel_from_mode(struct gb_light *light,
 						u32 mode)
 {
-	struct gb_channel *channel;
+	struct gb_channel *channel = NULL;
 	int i;
 
 	for (i = 0; i < light->channels_count; i++) {
 		channel = &light->channels[i];
-		if (channel->mode == mode)
-			return channel;
+		if (channel && channel->mode == mode)
+			break;
 	}
-	return NULL;
+	return channel;
 }
 
 static int __gb_lights_flash_intensity_set(struct gb_channel *channel,
Index: drivers/acpi/resource.c
===================================================================
--- drivers/acpi/resource.c	(revision 55465)
+++ drivers/acpi/resource.c	(revision 55464)
@@ -543,39 +543,6 @@
 			DMI_MATCH(DMI_BOARD_NAME, "17U70P"),
 		},
 	},
-	{
-		/* Infinity E15-5A165-BM */
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GM5RG1E0009COM"),
-		},
-	},
-	{
-		/* Infinity E15-5A305-1M */
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GM5RGEE0016COM"),
-		},
-	},
-	{
-		/* Lunnen Ground 15 / AMD Ryzen 5 5500U */
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Lunnen"),
-			DMI_MATCH(DMI_BOARD_NAME, "LLL5DAW"),
-		},
-	},
-	{
-		/* Lunnen Ground 16 / AMD Ryzen 7 5800U */
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Lunnen"),
-			DMI_MATCH(DMI_BOARD_NAME, "LL6FA"),
-		},
-	},
-	{
-		/* MAIBENBEN X577 */
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "MAIBENBEN"),
-			DMI_MATCH(DMI_BOARD_NAME, "X577"),
-		},
-	},
 	{ }
 };
 
Index: drivers/acpi/scan.c
===================================================================
--- drivers/acpi/scan.c	(revision 55465)
+++ drivers/acpi/scan.c	(revision 55464)
@@ -315,8 +315,8 @@
 		 * again).
 		 */
 		if (adev->handler) {
-			dev_dbg(&adev->dev, "Already enumerated\n");
-			return 0;
+			dev_warn(&adev->dev, "Already enumerated\n");
+			return -EALREADY;
 		}
 		error = acpi_bus_scan(adev->handle);
 		if (error) {
@@ -323,6 +323,10 @@
 			dev_warn(&adev->dev, "Namespace scan failure\n");
 			return error;
 		}
+		if (!adev->handler) {
+			dev_warn(&adev->dev, "Enumeration failure\n");
+			error = -ENODEV;
+		}
 	} else {
 		error = acpi_scan_device_not_present(adev);
 	}
Index: drivers/acpi/processor_idle.c
===================================================================
--- drivers/acpi/processor_idle.c	(revision 55465)
+++ drivers/acpi/processor_idle.c	(revision 55464)
@@ -1431,8 +1431,6 @@
 		acpi_processor_registered--;
 		if (acpi_processor_registered == 0)
 			cpuidle_unregister_driver(&acpi_idle_driver);
-
-		kfree(dev);
 	}
 
 	pr->flags.power_setup_done = 0;
Index: drivers/leds/flash/leds-sgm3140.c
===================================================================
--- drivers/leds/flash/leds-sgm3140.c	(revision 55465)
+++ drivers/leds/flash/leds-sgm3140.c	(revision 55464)
@@ -114,11 +114,8 @@
 				"failed to enable regulator: %d\n", ret);
 			return ret;
 		}
-		gpiod_set_value_cansleep(priv->flash_gpio, 0);
 		gpiod_set_value_cansleep(priv->enable_gpio, 1);
 	} else {
-		del_timer_sync(&priv->powerdown_timer);
-		gpiod_set_value_cansleep(priv->flash_gpio, 0);
 		gpiod_set_value_cansleep(priv->enable_gpio, 0);
 		ret = regulator_disable(priv->vin_regulator);
 		if (ret) {
Index: drivers/leds/leds-aw2013.c
===================================================================
--- drivers/leds/leds-aw2013.c	(revision 55465)
+++ drivers/leds/leds-aw2013.c	(revision 55464)
@@ -397,7 +397,6 @@
 	regulator_disable(chip->vcc_regulator);
 
 error:
-	mutex_unlock(&chip->mutex);
 	mutex_destroy(&chip->mutex);
 	return ret;
 }
Index: drivers/mfd/syscon.c
===================================================================
--- drivers/mfd/syscon.c	(revision 55465)
+++ drivers/mfd/syscon.c	(revision 55464)
@@ -223,10 +223,8 @@
 		return ERR_PTR(-ENODEV);
 
 	regmap = syscon_node_to_regmap(syscon_np);
+	of_node_put(syscon_np);
 
-	if (property)
-		of_node_put(syscon_np);
-
 	return regmap;
 }
 EXPORT_SYMBOL_GPL(syscon_regmap_lookup_by_phandle);
Index: drivers/mfd/altera-sysmgr.c
===================================================================
--- drivers/mfd/altera-sysmgr.c	(revision 55465)
+++ drivers/mfd/altera-sysmgr.c	(revision 55464)
@@ -110,9 +110,7 @@
 
 	dev = driver_find_device_by_of_node(&altr_sysmgr_driver.driver,
 					    (void *)sysmgr_np);
-	if (property)
-		of_node_put(sysmgr_np);
-
+	of_node_put(sysmgr_np);
 	if (!dev)
 		return ERR_PTR(-EPROBE_DEFER);
 
Index: drivers/watchdog/stm32_iwdg.c
===================================================================
--- drivers/watchdog/stm32_iwdg.c	(revision 55465)
+++ drivers/watchdog/stm32_iwdg.c	(revision 55464)
@@ -21,8 +21,6 @@
 #include <linux/platform_device.h>
 #include <linux/watchdog.h>
 
-#define DEFAULT_TIMEOUT 10
-
 /* IWDG registers */
 #define IWDG_KR		0x00 /* Key register */
 #define IWDG_PR		0x04 /* Prescaler Register */
@@ -251,7 +249,6 @@
 	wdd->parent = dev;
 	wdd->info = &stm32_iwdg_info;
 	wdd->ops = &stm32_iwdg_ops;
-	wdd->timeout = DEFAULT_TIMEOUT;
 	wdd->min_timeout = DIV_ROUND_UP((RLR_MIN + 1) * PR_MIN, wdt->rate);
 	wdd->max_hw_heartbeat_ms = ((RLR_MAX + 1) * wdt->data->max_prescaler *
 				    1000) / wdt->rate;
Index: drivers/opp/debugfs.c
===================================================================
--- drivers/opp/debugfs.c	(revision 55465)
+++ drivers/opp/debugfs.c	(revision 55464)
@@ -37,12 +37,10 @@
 			    size_t count, loff_t *ppos)
 {
 	struct icc_path *path = fp->private_data;
-	const char *name = icc_get_name(path);
 	char buf[64];
-	int i = 0;
+	int i;
 
-	if (name)
-		i = scnprintf(buf, sizeof(buf), "%.62s\n", name);
+	i = scnprintf(buf, sizeof(buf), "%.62s\n", icc_get_name(path));
 
 	return simple_read_from_buffer(userbuf, count, ppos, buf, i);
 }
Index: drivers/rtc/Kconfig
===================================================================
--- drivers/rtc/Kconfig	(revision 55465)
+++ drivers/rtc/Kconfig	(revision 55464)
@@ -1843,8 +1843,7 @@
 
 config RTC_DRV_MT6397
 	tristate "MediaTek PMIC based RTC"
-	depends on MFD_MT6397 || COMPILE_TEST
-	select IRQ_DOMAIN
+	depends on MFD_MT6397 || (COMPILE_TEST && IRQ_DOMAIN)
 	help
 	  This selects the MediaTek(R) RTC driver. RTC is part of MediaTek
 	  MT6397 PMIC. You should enable MT6397 PMIC MFD before select
Index: drivers/rtc/lib_test.c
===================================================================
--- drivers/rtc/lib_test.c	(revision 55465)
+++ drivers/rtc/lib_test.c	(revision 55464)
@@ -54,7 +54,7 @@
 
 		days = div_s64(secs, 86400);
 
-		#define FAIL_MSG "%d/%02d/%02d (%2d) : %lld", \
+		#define FAIL_MSG "%d/%02d/%02d (%2d) : %ld", \
 			year, month, mday, yday, days
 
 		KUNIT_ASSERT_EQ_MSG(test, year - 1900, result.tm_year, FAIL_MSG);
Index: drivers/pwm/pwm-sti.c
===================================================================
--- drivers/pwm/pwm-sti.c	(revision 55465)
+++ drivers/pwm/pwm-sti.c	(revision 55464)
@@ -395,17 +395,8 @@
 static int sti_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			 const struct pwm_state *state)
 {
-	struct sti_pwm_chip *pc = to_sti_pwmchip(chip);
-	struct sti_pwm_compat_data *cdata = pc->cdata;
-	struct device *dev = pc->dev;
 	int err;
 
-	if (pwm->hwpwm >= cdata->pwm_num_devs) {
-		dev_err(dev, "device %u is not valid for pwm mode\n",
-			pwm->hwpwm);
-		return -EINVAL;
-	}
-
 	if (state->polarity != PWM_POLARITY_NORMAL)
 		return -EINVAL;
 
@@ -656,7 +647,7 @@
 
 	pc->chip.dev = dev;
 	pc->chip.ops = &sti_pwm_ops;
-	pc->chip.npwm = max(cdata->pwm_num_devs, cdata->cpt_num_devs);
+	pc->chip.npwm = pc->cdata->pwm_num_devs;
 
 	for (i = 0; i < cdata->cpt_num_devs; i++) {
 		struct sti_cpt_ddata *ddata = &cdata->ddata[i];
Index: drivers/pwm/pwm-atmel-hlcdc.c
===================================================================
--- drivers/pwm/pwm-atmel-hlcdc.c	(revision 55465)
+++ drivers/pwm/pwm-atmel-hlcdc.c	(revision 55464)
@@ -38,11 +38,11 @@
 	return container_of(chip, struct atmel_hlcdc_pwm, chip);
 }
 
-static int atmel_hlcdc_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+static int atmel_hlcdc_pwm_apply(struct pwm_chip *c, struct pwm_device *pwm,
 				 const struct pwm_state *state)
 {
-	struct atmel_hlcdc_pwm *atmel = to_atmel_hlcdc_pwm(chip);
-	struct atmel_hlcdc *hlcdc = atmel->hlcdc;
+	struct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);
+	struct atmel_hlcdc *hlcdc = chip->hlcdc;
 	unsigned int status;
 	int ret;
 
@@ -54,7 +54,7 @@
 		u32 pwmcfg;
 		int pres;
 
-		if (!atmel->errata || !atmel->errata->slow_clk_erratum) {
+		if (!chip->errata || !chip->errata->slow_clk_erratum) {
 			clk_freq = clk_get_rate(new_clk);
 			if (!clk_freq)
 				return -EINVAL;
@@ -64,7 +64,7 @@
 		}
 
 		/* Errata: cannot use slow clk on some IP revisions */
-		if ((atmel->errata && atmel->errata->slow_clk_erratum) ||
+		if ((chip->errata && chip->errata->slow_clk_erratum) ||
 		    clk_period_ns > state->period) {
 			new_clk = hlcdc->sys_clk;
 			clk_freq = clk_get_rate(new_clk);
@@ -77,8 +77,8 @@
 
 		for (pres = 0; pres <= ATMEL_HLCDC_PWMPS_MAX; pres++) {
 		/* Errata: cannot divide by 1 on some IP revisions */
-			if (!pres && atmel->errata &&
-			    atmel->errata->div1_clk_erratum)
+			if (!pres && chip->errata &&
+			    chip->errata->div1_clk_erratum)
 				continue;
 
 			if ((clk_period_ns << pres) >= state->period)
@@ -90,7 +90,7 @@
 
 		pwmcfg = ATMEL_HLCDC_PWMPS(pres);
 
-		if (new_clk != atmel->cur_clk) {
+		if (new_clk != chip->cur_clk) {
 			u32 gencfg = 0;
 			int ret;
 
@@ -98,8 +98,8 @@
 			if (ret)
 				return ret;
 
-			clk_disable_unprepare(atmel->cur_clk);
-			atmel->cur_clk = new_clk;
+			clk_disable_unprepare(chip->cur_clk);
+			chip->cur_clk = new_clk;
 
 			if (new_clk == hlcdc->sys_clk)
 				gencfg = ATMEL_HLCDC_CLKPWMSEL;
@@ -160,8 +160,8 @@
 		if (ret)
 			return ret;
 
-		clk_disable_unprepare(atmel->cur_clk);
-		atmel->cur_clk = NULL;
+		clk_disable_unprepare(chip->cur_clk);
+		chip->cur_clk = NULL;
 	}
 
 	return 0;
@@ -183,11 +183,11 @@
 #ifdef CONFIG_PM_SLEEP
 static int atmel_hlcdc_pwm_suspend(struct device *dev)
 {
-	struct atmel_hlcdc_pwm *atmel = dev_get_drvdata(dev);
+	struct atmel_hlcdc_pwm *chip = dev_get_drvdata(dev);
 
 	/* Keep the periph clock enabled if the PWM is still running. */
-	if (!pwm_is_enabled(&atmel->chip.pwms[0]))
-		clk_disable_unprepare(atmel->hlcdc->periph_clk);
+	if (pwm_is_enabled(&chip->chip.pwms[0]))
+		clk_disable_unprepare(chip->hlcdc->periph_clk);
 
 	return 0;
 }
@@ -194,21 +194,20 @@
 
 static int atmel_hlcdc_pwm_resume(struct device *dev)
 {
-	struct atmel_hlcdc_pwm *atmel = dev_get_drvdata(dev);
+	struct atmel_hlcdc_pwm *chip = dev_get_drvdata(dev);
 	struct pwm_state state;
 	int ret;
 
-	pwm_get_state(&atmel->chip.pwms[0], &state);
+	pwm_get_state(&chip->chip.pwms[0], &state);
 
 	/* Re-enable the periph clock it was stopped during suspend. */
 	if (!state.enabled) {
-		ret = clk_prepare_enable(atmel->hlcdc->periph_clk);
+		ret = clk_prepare_enable(chip->hlcdc->periph_clk);
 		if (ret)
 			return ret;
 	}
 
-	return atmel_hlcdc_pwm_apply(&atmel->chip, &atmel->chip.pwms[0],
-				     &state);
+	return atmel_hlcdc_pwm_apply(&chip->chip, &chip->chip.pwms[0], &state);
 }
 #endif
 
@@ -245,14 +244,14 @@
 {
 	const struct of_device_id *match;
 	struct device *dev = &pdev->dev;
-	struct atmel_hlcdc_pwm *atmel;
+	struct atmel_hlcdc_pwm *chip;
 	struct atmel_hlcdc *hlcdc;
 	int ret;
 
 	hlcdc = dev_get_drvdata(dev->parent);
 
-	atmel = devm_kzalloc(dev, sizeof(*atmel), GFP_KERNEL);
-	if (!atmel)
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
 		return -ENOMEM;
 
 	ret = clk_prepare_enable(hlcdc->periph_clk);
@@ -261,31 +260,33 @@
 
 	match = of_match_node(atmel_hlcdc_dt_ids, dev->parent->of_node);
 	if (match)
-		atmel->errata = match->data;
+		chip->errata = match->data;
 
-	atmel->hlcdc = hlcdc;
-	atmel->chip.ops = &atmel_hlcdc_pwm_ops;
-	atmel->chip.dev = dev;
-	atmel->chip.npwm = 1;
+	chip->hlcdc = hlcdc;
+	chip->chip.ops = &atmel_hlcdc_pwm_ops;
+	chip->chip.dev = dev;
+	chip->chip.npwm = 1;
 
-	ret = pwmchip_add(&atmel->chip);
+	ret = pwmchip_add(&chip->chip);
 	if (ret) {
 		clk_disable_unprepare(hlcdc->periph_clk);
 		return ret;
 	}
 
-	platform_set_drvdata(pdev, atmel);
+	platform_set_drvdata(pdev, chip);
 
 	return 0;
 }
 
-static void atmel_hlcdc_pwm_remove(struct platform_device *pdev)
+static int atmel_hlcdc_pwm_remove(struct platform_device *pdev)
 {
-	struct atmel_hlcdc_pwm *atmel = platform_get_drvdata(pdev);
+	struct atmel_hlcdc_pwm *chip = platform_get_drvdata(pdev);
 
-	pwmchip_remove(&atmel->chip);
+	pwmchip_remove(&chip->chip);
 
-	clk_disable_unprepare(atmel->hlcdc->periph_clk);
+	clk_disable_unprepare(chip->hlcdc->periph_clk);
+
+	return 0;
 }
 
 static const struct of_device_id atmel_hlcdc_pwm_dt_ids[] = {
@@ -300,7 +301,7 @@
 		.pm = &atmel_hlcdc_pwm_pm_ops,
 	},
 	.probe = atmel_hlcdc_pwm_probe,
-	.remove_new = atmel_hlcdc_pwm_remove,
+	.remove = atmel_hlcdc_pwm_remove,
 };
 module_platform_driver(atmel_hlcdc_pwm_driver);
 
Index: drivers/vdpa/mlx5/net/mlx5_vnet.c
===================================================================
--- drivers/vdpa/mlx5/net/mlx5_vnet.c	(revision 55465)
+++ drivers/vdpa/mlx5/net/mlx5_vnet.c	(revision 55464)
@@ -185,6 +185,8 @@
 
 static bool mlx5_vdpa_debug;
 
+#define MLX5_CVQ_MAX_ENT 16
+
 #define MLX5_LOG_VIO_FLAG(_feature)                                                                \
 	do {                                                                                       \
 		if (features & BIT_ULL(_feature))                                                  \
@@ -1978,16 +1980,9 @@
 	struct mlx5_vdpa_net *ndev = to_mlx5_vdpa_ndev(mvdev);
 	struct mlx5_vdpa_virtqueue *mvq;
 
-	if (!is_index_valid(mvdev, idx))
+	if (!is_index_valid(mvdev, idx) || is_ctrl_vq_idx(mvdev, idx))
 		return;
 
-        if (is_ctrl_vq_idx(mvdev, idx)) {
-                struct mlx5_control_vq *cvq = &mvdev->cvq;
-
-                cvq->vring.vring.num = num;
-                return;
-        }
-
 	mvq = &ndev->vqs[idx];
 	mvq->num_ent = num;
 }
@@ -2517,7 +2512,7 @@
 		u16 idx = cvq->vring.last_avail_idx;
 
 		err = vringh_init_iotlb(&cvq->vring, mvdev->actual_features,
-					cvq->vring.vring.num, false,
+					MLX5_CVQ_MAX_ENT, false,
 					(struct vring_desc *)(uintptr_t)cvq->desc_addr,
 					(struct vring_avail *)(uintptr_t)cvq->driver_addr,
 					(struct vring_used *)(uintptr_t)cvq->device_addr);
Index: drivers/vdpa/vdpa_sim/vdpa_sim.c
===================================================================
--- drivers/vdpa/vdpa_sim/vdpa_sim.c	(revision 55465)
+++ drivers/vdpa/vdpa_sim/vdpa_sim.c	(revision 55464)
@@ -120,7 +120,7 @@
 	for (i = 0; i < vdpasim->dev_attr.nas; i++)
 		vhost_iotlb_reset(&vdpasim->iommu[i]);
 
-	vdpasim->running = false;
+	vdpasim->running = true;
 	spin_unlock(&vdpasim->iommu_lock);
 
 	vdpasim->features = 0;
@@ -513,7 +513,6 @@
 
 	spin_lock(&vdpasim->lock);
 	vdpasim->status = status;
-	vdpasim->running = (status & VIRTIO_CONFIG_S_DRIVER_OK) != 0;
 	spin_unlock(&vdpasim->lock);
 }
 
Index: drivers/hwtracing/ptt/hisi_ptt.c
===================================================================
--- drivers/hwtracing/ptt/hisi_ptt.c	(revision 55465)
+++ drivers/hwtracing/ptt/hisi_ptt.c	(revision 55464)
@@ -654,9 +654,6 @@
 	int ret;
 	u32 val;
 
-	if (event->attr.type != hisi_ptt->hisi_ptt_pmu.type)
-		return -ENOENT;
-
 	if (event->cpu < 0) {
 		dev_dbg(event->pmu->dev, "Per-task mode not supported\n");
 		return -EOPNOTSUPP;
@@ -665,6 +662,9 @@
 	if (event->attach_state & PERF_ATTACH_TASK)
 		return -EOPNOTSUPP;
 
+	if (event->attr.type != hisi_ptt->hisi_ptt_pmu.type)
+		return -ENOENT;
+
 	ret = hisi_ptt_trace_valid_filter(hisi_ptt, event->attr.config);
 	if (ret < 0)
 		return ret;
Index: drivers/pinctrl/renesas/pfc-r8a779g0.c
===================================================================
--- drivers/pinctrl/renesas/pfc-r8a779g0.c	(revision 55465)
+++ drivers/pinctrl/renesas/pfc-r8a779g0.c	(revision 55464)
@@ -2360,30 +2360,6 @@
 	SCIF_CLK_MARK,
 };
 
-static const unsigned int scif_clk2_pins[] = {
-	/* SCIF_CLK2 */
-	RCAR_GP_PIN(8, 11),
-};
-static const unsigned int scif_clk2_mux[] = {
-	SCIF_CLK2_MARK,
-};
-
-/* - SSI ------------------------------------------------- */
-static const unsigned int ssi_data_pins[] = {
-	/* SSI_SD */
-	RCAR_GP_PIN(1, 20),
-};
-static const unsigned int ssi_data_mux[] = {
-	SSI_SD_MARK,
-};
-static const unsigned int ssi_ctrl_pins[] = {
-	/* SSI_SCK,  SSI_WS */
-	RCAR_GP_PIN(1, 18), RCAR_GP_PIN(1, 19),
-};
-static const unsigned int ssi_ctrl_mux[] = {
-	SSI_SCK_MARK, SSI_WS_MARK,
-};
-
 /* - TPU ------------------------------------------------------------------- */
 static const unsigned int tpu_to0_pins[] = {
 	/* TPU0TO0 */
@@ -2675,11 +2651,7 @@
 	SH_PFC_PIN_GROUP(scif4_clk),
 	SH_PFC_PIN_GROUP(scif4_ctrl),
 	SH_PFC_PIN_GROUP(scif_clk),
-	SH_PFC_PIN_GROUP(scif_clk2),
 
-	SH_PFC_PIN_GROUP(ssi_data),
-	SH_PFC_PIN_GROUP(ssi_ctrl),
-
 	SH_PFC_PIN_GROUP(tpu_to0),		/* suffix might be updated */
 	SH_PFC_PIN_GROUP(tpu_to0_a),		/* suffix might be updated */
 	SH_PFC_PIN_GROUP(tpu_to1),		/* suffix might be updated */
@@ -2992,15 +2964,6 @@
 	"scif_clk",
 };
 
-static const char * const scif_clk2_groups[] = {
-	"scif_clk2",
-};
-
-static const char * const ssi_groups[] = {
-	"ssi_data",
-	"ssi_ctrl",
-};
-
 static const char * const tpu_groups[] = {
 	/* suffix might be updated */
 	"tpu_to0",
@@ -3081,10 +3044,7 @@
 	SH_PFC_FUNCTION(scif3),
 	SH_PFC_FUNCTION(scif4),
 	SH_PFC_FUNCTION(scif_clk),
-	SH_PFC_FUNCTION(scif_clk2),
 
-	SH_PFC_FUNCTION(ssi),
-
 	SH_PFC_FUNCTION(tpu),
 
 	SH_PFC_FUNCTION(tsn0),
Index: drivers/pinctrl/mediatek/pinctrl-mt8186.c
===================================================================
--- drivers/pinctrl/mediatek/pinctrl-mt8186.c	(revision 55465)
+++ drivers/pinctrl/mediatek/pinctrl-mt8186.c	(revision 55464)
@@ -1198,6 +1198,7 @@
 	[PINCTRL_PIN_REG_DIR] = MTK_RANGE(mt8186_pin_dir_range),
 	[PINCTRL_PIN_REG_DI] = MTK_RANGE(mt8186_pin_di_range),
 	[PINCTRL_PIN_REG_DO] = MTK_RANGE(mt8186_pin_do_range),
+	[PINCTRL_PIN_REG_SR] = MTK_RANGE(mt8186_pin_dir_range),
 	[PINCTRL_PIN_REG_SMT] = MTK_RANGE(mt8186_pin_smt_range),
 	[PINCTRL_PIN_REG_IES] = MTK_RANGE(mt8186_pin_ies_range),
 	[PINCTRL_PIN_REG_PU] = MTK_RANGE(mt8186_pin_pu_range),
Index: drivers/pinctrl/mediatek/pinctrl-mt8192.c
===================================================================
--- drivers/pinctrl/mediatek/pinctrl-mt8192.c	(revision 55465)
+++ drivers/pinctrl/mediatek/pinctrl-mt8192.c	(revision 55464)
@@ -1379,6 +1379,7 @@
 	[PINCTRL_PIN_REG_DIR] = MTK_RANGE(mt8192_pin_dir_range),
 	[PINCTRL_PIN_REG_DI] = MTK_RANGE(mt8192_pin_di_range),
 	[PINCTRL_PIN_REG_DO] = MTK_RANGE(mt8192_pin_do_range),
+	[PINCTRL_PIN_REG_SR] = MTK_RANGE(mt8192_pin_dir_range),
 	[PINCTRL_PIN_REG_SMT] = MTK_RANGE(mt8192_pin_smt_range),
 	[PINCTRL_PIN_REG_IES] = MTK_RANGE(mt8192_pin_ies_range),
 	[PINCTRL_PIN_REG_PU] = MTK_RANGE(mt8192_pin_pu_range),
Index: drivers/pinctrl/nomadik/pinctrl-nomadik.c
===================================================================
--- drivers/pinctrl/nomadik/pinctrl-nomadik.c	(revision 55465)
+++ drivers/pinctrl/nomadik/pinctrl-nomadik.c	(revision 55464)
@@ -1571,10 +1571,8 @@
 		 * Then mask the pins that need to be sleeping now when we're
 		 * switching to the ALT C function.
 		 */
-		for (i = 0; i < g->grp.npins; i++) {
-			unsigned int bit = g->grp.pins[i] % NMK_GPIO_PER_CHIP;
-			slpm[g->grp.pins[i] / NMK_GPIO_PER_CHIP] &= ~BIT(bit);
-		}
+		for (i = 0; i < g->grp.npins; i++)
+			slpm[g->grp.pins[i] / NMK_GPIO_PER_CHIP] &= ~BIT(g->grp.pins[i]);
 		nmk_gpio_glitch_slpm_init(slpm);
 	}
 
Index: drivers/powercap/dtpm_cpu.c
===================================================================
--- drivers/powercap/dtpm_cpu.c	(revision 55465)
+++ drivers/powercap/dtpm_cpu.c	(revision 55464)
@@ -219,7 +219,7 @@
 	ret = freq_qos_add_request(&policy->constraints,
 				   &dtpm_cpu->qos_req, FREQ_QOS_MAX,
 				   pd->table[pd->nr_perf_states - 1].frequency);
-	if (ret < 0)
+	if (ret)
 		goto out_dtpm_unregister;
 
 	cpufreq_cpu_put(policy);
Index: drivers/perf/arm-cmn.c
===================================================================
--- drivers/perf/arm-cmn.c	(revision 55465)
+++ drivers/perf/arm-cmn.c	(revision 55464)
@@ -2178,17 +2178,6 @@
 				dev_dbg(cmn->dev, "ignoring external node %llx\n", reg);
 				continue;
 			}
-			/*
-			 * AmpereOneX erratum AC04_MESH_1 makes some XPs report a bogus
-			 * child count larger than the number of valid child pointers.
-			 * A child offset of 0 can only occur on CMN-600; otherwise it
-			 * would imply the root node being its own grandchild, which
-			 * we can safely dismiss in general.
-			 */
-			if (reg == 0 && cmn->part != PART_CMN600) {
-				dev_dbg(cmn->dev, "bogus child pointer?\n");
-				continue;
-			}
 
 			arm_cmn_init_node_info(cmn, reg & CMN_CHILD_NODE_ADDR, dn);
 
Index: drivers/ntb/core.c
===================================================================
--- drivers/ntb/core.c	(revision 55465)
+++ drivers/ntb/core.c	(revision 55464)
@@ -100,8 +100,6 @@
 
 int ntb_register_device(struct ntb_dev *ntb)
 {
-	int ret;
-
 	if (!ntb)
 		return -EINVAL;
 	if (!ntb->pdev)
@@ -122,11 +120,7 @@
 	ntb->ctx_ops = NULL;
 	spin_lock_init(&ntb->ctx_lock);
 
-	ret = device_register(&ntb->dev);
-	if (ret)
-		put_device(&ntb->dev);
-
-	return ret;
+	return device_register(&ntb->dev);
 }
 EXPORT_SYMBOL(ntb_register_device);
 
Index: drivers/remoteproc/Kconfig
===================================================================
--- drivers/remoteproc/Kconfig	(revision 55465)
+++ drivers/remoteproc/Kconfig	(revision 55464)
@@ -313,7 +313,7 @@
 
 config STM32_RPROC
 	tristate "STM32 remoteproc support"
-	depends on ARCH_STM32 || COMPILE_TEST
+	depends on ARCH_STM32
 	depends on REMOTEPROC
 	select MAILBOX
 	help
Index: drivers/remoteproc/stm32_rproc.c
===================================================================
--- drivers/remoteproc/stm32_rproc.c	(revision 55465)
+++ drivers/remoteproc/stm32_rproc.c	(revision 55464)
@@ -118,10 +118,10 @@
 	struct device *dev = rproc->dev.parent;
 	void *va;
 
-	dev_dbg(dev, "map memory: %pad+%zx\n", &mem->dma, mem->len);
-	va = (__force void *)ioremap_wc(mem->dma, mem->len);
+	dev_dbg(dev, "map memory: %pa+%x\n", &mem->dma, mem->len);
+	va = ioremap_wc(mem->dma, mem->len);
 	if (IS_ERR_OR_NULL(va)) {
-		dev_err(dev, "Unable to map memory region: %pad+0x%zx\n",
+		dev_err(dev, "Unable to map memory region: %pa+%x\n",
 			&mem->dma, mem->len);
 		return -ENOMEM;
 	}
@@ -136,7 +136,7 @@
 				   struct rproc_mem_entry *mem)
 {
 	dev_dbg(rproc->dev.parent, "unmap memory: %pa\n", &mem->dma);
-	iounmap((__force __iomem void *)mem->va);
+	iounmap(mem->va);
 
 	return 0;
 }
@@ -627,7 +627,7 @@
 
 	ddata->rsc_va = devm_ioremap_wc(dev, rsc_pa, RSC_TBL_SIZE);
 	if (IS_ERR_OR_NULL(ddata->rsc_va)) {
-		dev_err(dev, "Unable to map memory region: %pa+%x\n",
+		dev_err(dev, "Unable to map memory region: %pa+%zx\n",
 			&rsc_pa, RSC_TBL_SIZE);
 		ddata->rsc_va = NULL;
 		return ERR_PTR(-ENOMEM);
@@ -641,7 +641,7 @@
 	 * entire area by overwriting it with the initial values stored in rproc->clean_table.
 	 */
 	*table_sz = RSC_TBL_SIZE;
-	return (__force struct resource_table *)ddata->rsc_va;
+	return (struct resource_table *)ddata->rsc_va;
 }
 
 static const struct rproc_ops st_rproc_ops = {
@@ -889,7 +889,7 @@
 	return 0;
 }
 
-static int stm32_rproc_suspend(struct device *dev)
+static int __maybe_unused stm32_rproc_suspend(struct device *dev)
 {
 	struct rproc *rproc = dev_get_drvdata(dev);
 	struct stm32_rproc *ddata = rproc->priv;
@@ -900,7 +900,7 @@
 	return 0;
 }
 
-static int stm32_rproc_resume(struct device *dev)
+static int __maybe_unused stm32_rproc_resume(struct device *dev)
 {
 	struct rproc *rproc = dev_get_drvdata(dev);
 	struct stm32_rproc *ddata = rproc->priv;
@@ -911,8 +911,8 @@
 	return 0;
 }
 
-static DEFINE_SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,
-				stm32_rproc_suspend, stm32_rproc_resume);
+static SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,
+			 stm32_rproc_suspend, stm32_rproc_resume);
 
 static struct platform_driver stm32_rproc_driver = {
 	.probe = stm32_rproc_probe,
@@ -919,8 +919,8 @@
 	.remove = stm32_rproc_remove,
 	.driver = {
 		.name = "stm32-rproc",
-		.pm = pm_ptr(&stm32_rproc_pm_ops),
-		.of_match_table = stm32_rproc_match,
+		.pm = &stm32_rproc_pm_ops,
+		.of_match_table = of_match_ptr(stm32_rproc_match),
 	},
 };
 module_platform_driver(stm32_rproc_driver);
Index: drivers/comedi/drivers/comedi_test.c
===================================================================
--- drivers/comedi/drivers/comedi_test.c	(revision 55465)
+++ drivers/comedi/drivers/comedi_test.c	(revision 55464)
@@ -85,8 +85,6 @@
 	struct comedi_device *dev;	/* parent comedi device */
 	u64 ao_last_scan_time;		/* time of previous AO scan in usec */
 	unsigned int ao_scan_period;	/* AO scan period in usec */
-	bool ai_timer_enable:1;		/* should AI timer be running? */
-	bool ao_timer_enable:1;		/* should AO timer be running? */
 	unsigned short ao_loopbacks[N_CHANS];
 };
 
@@ -236,12 +234,8 @@
 			time_increment = devpriv->ai_convert_time - now;
 		else
 			time_increment = 1;
-		spin_lock(&dev->spinlock);
-		if (devpriv->ai_timer_enable) {
-			mod_timer(&devpriv->ai_timer,
-				  jiffies + usecs_to_jiffies(time_increment));
-		}
-		spin_unlock(&dev->spinlock);
+		mod_timer(&devpriv->ai_timer,
+			  jiffies + usecs_to_jiffies(time_increment));
 	}
 
 overrun:
@@ -397,12 +391,9 @@
 	 * Seem to need an extra jiffy here, otherwise timer expires slightly
 	 * early!
 	 */
-	spin_lock_bh(&dev->spinlock);
-	devpriv->ai_timer_enable = true;
 	devpriv->ai_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv->ai_convert_period) + 1;
 	add_timer(&devpriv->ai_timer);
-	spin_unlock_bh(&dev->spinlock);
 	return 0;
 }
 
@@ -411,9 +402,6 @@
 {
 	struct waveform_private *devpriv = dev->private;
 
-	spin_lock_bh(&dev->spinlock);
-	devpriv->ai_timer_enable = false;
-	spin_unlock_bh(&dev->spinlock);
 	if (in_softirq()) {
 		/* Assume we were called from the timer routine itself. */
 		del_timer(&devpriv->ai_timer);
@@ -505,12 +493,8 @@
 		unsigned int time_inc = devpriv->ao_last_scan_time +
 					devpriv->ao_scan_period - now;
 
-		spin_lock(&dev->spinlock);
-		if (devpriv->ao_timer_enable) {
-			mod_timer(&devpriv->ao_timer,
-				  jiffies + usecs_to_jiffies(time_inc));
-		}
-		spin_unlock(&dev->spinlock);
+		mod_timer(&devpriv->ao_timer,
+			  jiffies + usecs_to_jiffies(time_inc));
 	}
 
 underrun:
@@ -531,12 +515,9 @@
 	async->inttrig = NULL;
 
 	devpriv->ao_last_scan_time = ktime_to_us(ktime_get());
-	spin_lock_bh(&dev->spinlock);
-	devpriv->ao_timer_enable = true;
 	devpriv->ao_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv->ao_scan_period);
 	add_timer(&devpriv->ao_timer);
-	spin_unlock_bh(&dev->spinlock);
 
 	return 1;
 }
@@ -621,9 +602,6 @@
 	struct waveform_private *devpriv = dev->private;
 
 	s->async->inttrig = NULL;
-	spin_lock_bh(&dev->spinlock);
-	devpriv->ao_timer_enable = false;
-	spin_unlock_bh(&dev->spinlock);
 	if (in_softirq()) {
 		/* Assume we were called from the timer routine itself. */
 		del_timer(&devpriv->ao_timer);
Index: include/linux/rcupdate.h
===================================================================
--- include/linux/rcupdate.h	(revision 55465)
+++ include/linux/rcupdate.h	(revision 55464)
@@ -268,37 +268,6 @@
 	cond_resched(); \
 } while (0)
 
-/**
- * rcu_softirq_qs_periodic - Report RCU and RCU-Tasks quiescent states
- * @old_ts: jiffies at start of processing.
- *
- * This helper is for long-running softirq handlers, such as NAPI threads in
- * networking. The caller should initialize the variable passed in as @old_ts
- * at the beginning of the softirq handler. When invoked frequently, this macro
- * will invoke rcu_softirq_qs() every 100 milliseconds thereafter, which will
- * provide both RCU and RCU-Tasks quiescent states. Note that this macro
- * modifies its old_ts argument.
- *
- * Because regions of code that have disabled softirq act as RCU read-side
- * critical sections, this macro should be invoked with softirq (and
- * preemption) enabled.
- *
- * The macro is not needed when CONFIG_PREEMPT_RT is defined. RT kernels would
- * have more chance to invoke schedule() calls and provide necessary quiescent
- * states. As a contrast, calling cond_resched() only won't achieve the same
- * effect because cond_resched() does not provide RCU-Tasks quiescent states.
- */
-#define rcu_softirq_qs_periodic(old_ts) \
-do { \
-	if (!IS_ENABLED(CONFIG_PREEMPT_RT) && \
-	    time_after(jiffies, (old_ts) + HZ / 10)) { \
-		preempt_disable(); \
-		rcu_softirq_qs(); \
-		preempt_enable(); \
-		(old_ts) = jiffies; \
-	} \
-} while (0)
-
 /*
  * Infrastructure to implement the synchronize_() primitives in
  * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.
Index: include/linux/mlx5/qp.h
===================================================================
--- include/linux/mlx5/qp.h	(revision 55465)
+++ include/linux/mlx5/qp.h	(revision 55464)
@@ -269,10 +269,7 @@
 	union {
 		struct {
 			__be16 sz;
-			union {
-				u8     start[2];
-				DECLARE_FLEX_ARRAY(u8, data);
-			};
+			u8     start[2];
 		} inline_hdr;
 		struct {
 			__be16 type;
Index: include/linux/pci.h
===================================================================
--- include/linux/pci.h	(revision 55465)
+++ include/linux/pci.h	(revision 55464)
@@ -2355,11 +2355,6 @@
 	return NULL;
 }
 
-static inline bool pci_dev_is_disconnected(const struct pci_dev *dev)
-{
-	return dev->error_state == pci_channel_io_perm_failure;
-}
-
 void pci_request_acs(void);
 bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags);
 bool pci_acs_path_enabled(struct pci_dev *start,
Index: include/linux/moduleloader.h
===================================================================
--- include/linux/moduleloader.h	(revision 55465)
+++ include/linux/moduleloader.h	(revision 55464)
@@ -95,14 +95,6 @@
 		    const Elf_Shdr *sechdrs,
 		    struct module *mod);
 
-#ifdef CONFIG_MODULES
-void flush_module_init_free_work(void);
-#else
-static inline void flush_module_init_free_work(void)
-{
-}
-#endif
-
 /* Any cleanup needed when module leaves. */
 void module_arch_cleanup(struct module *mod);
 
Index: include/linux/dm-io.h
===================================================================
--- include/linux/dm-io.h	(revision 55465)
+++ include/linux/dm-io.h	(revision 55464)
@@ -79,8 +79,7 @@
  * error occurred doing io to the corresponding region.
  */
 int dm_io(struct dm_io_request *io_req, unsigned int num_regions,
-	  struct dm_io_region *region, unsigned int long *sync_error_bits,
-	  unsigned short ioprio);
+	  struct dm_io_region *region, unsigned int long *sync_error_bits);
 
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_DM_IO_H */
Index: include/linux/exportfs.h
===================================================================
--- include/linux/exportfs.h	(revision 55465)
+++ include/linux/exportfs.h	(revision 55464)
@@ -221,7 +221,6 @@
 #define EXPORT_OP_NOATOMIC_ATTR		(0x10) /* Filesystem cannot supply
 						  atomic attribute updates
 						*/
-#define EXPORT_OP_FLUSH_ON_CLOSE	(0x20) /* fs flushes file data on close */
 	unsigned long	flags;
 };
 
Index: include/linux/filter.h
===================================================================
--- include/linux/filter.h	(revision 55465)
+++ include/linux/filter.h	(revision 55464)
@@ -495,12 +495,12 @@
 	__BPF_MAP(n, __BPF_DECL_ARGS, __BPF_N, u64, __ur_1, u64, __ur_2,       \
 		  u64, __ur_3, u64, __ur_4, u64, __ur_5)
 
-#define BPF_CALL_x(x, attr, name, ...)					       \
+#define BPF_CALL_x(x, name, ...)					       \
 	static __always_inline						       \
 	u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__));   \
 	typedef u64 (*btf_##name)(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__)); \
-	attr u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__));    \
-	attr u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__))     \
+	u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__));	       \
+	u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__))	       \
 	{								       \
 		return ((btf_##name)____##name)(__BPF_MAP(x,__BPF_CAST,__BPF_N,__VA_ARGS__));\
 	}								       \
@@ -507,16 +507,13 @@
 	static __always_inline						       \
 	u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__))
 
-#define __NOATTR
-#define BPF_CALL_0(name, ...)	BPF_CALL_x(0, __NOATTR, name, __VA_ARGS__)
-#define BPF_CALL_1(name, ...)	BPF_CALL_x(1, __NOATTR, name, __VA_ARGS__)
-#define BPF_CALL_2(name, ...)	BPF_CALL_x(2, __NOATTR, name, __VA_ARGS__)
-#define BPF_CALL_3(name, ...)	BPF_CALL_x(3, __NOATTR, name, __VA_ARGS__)
-#define BPF_CALL_4(name, ...)	BPF_CALL_x(4, __NOATTR, name, __VA_ARGS__)
-#define BPF_CALL_5(name, ...)	BPF_CALL_x(5, __NOATTR, name, __VA_ARGS__)
+#define BPF_CALL_0(name, ...)	BPF_CALL_x(0, name, __VA_ARGS__)
+#define BPF_CALL_1(name, ...)	BPF_CALL_x(1, name, __VA_ARGS__)
+#define BPF_CALL_2(name, ...)	BPF_CALL_x(2, name, __VA_ARGS__)
+#define BPF_CALL_3(name, ...)	BPF_CALL_x(3, name, __VA_ARGS__)
+#define BPF_CALL_4(name, ...)	BPF_CALL_x(4, name, __VA_ARGS__)
+#define BPF_CALL_5(name, ...)	BPF_CALL_x(5, name, __VA_ARGS__)
 
-#define NOTRACE_BPF_CALL_1(name, ...)	BPF_CALL_x(1, notrace, name, __VA_ARGS__)
-
 #define bpf_ctx_range(TYPE, MEMBER)						\
 	offsetof(TYPE, MEMBER) ... offsetofend(TYPE, MEMBER) - 1
 #define bpf_ctx_range_till(TYPE, MEMBER1, MEMBER2)				\
Index: include/linux/io_uring.h
===================================================================
--- include/linux/io_uring.h	(revision 55465)
+++ include/linux/io_uring.h	(revision 55464)
@@ -42,11 +42,11 @@
 			unsigned issue_flags);
 void io_uring_cmd_complete_in_task(struct io_uring_cmd *ioucmd,
 			void (*task_work_cb)(struct io_uring_cmd *, unsigned));
+struct sock *io_uring_get_socket(struct file *file);
 void __io_uring_cancel(bool cancel_all);
 void __io_uring_free(struct task_struct *tsk);
 void io_uring_unreg_ringfd(void);
 const char *io_uring_get_opcode(u8 opcode);
-bool io_is_uring_fops(struct file *file);
 
 static inline void io_uring_files_cancel(void)
 {
@@ -71,10 +71,6 @@
 {
 	return -EOPNOTSUPP;
 }
-static inline bool io_is_uring_fops(struct file *file)
-{
-	return false;
-}
 static inline void io_uring_cmd_done(struct io_uring_cmd *cmd, ssize_t ret,
 		ssize_t ret2, unsigned issue_flags)
 {
@@ -83,6 +79,10 @@
 			void (*task_work_cb)(struct io_uring_cmd *, unsigned))
 {
 }
+static inline struct sock *io_uring_get_socket(struct file *file)
+{
+	return NULL;
+}
 static inline void io_uring_task_cancel(void)
 {
 }
Index: include/linux/io_uring_types.h
===================================================================
--- include/linux/io_uring_types.h	(revision 55465)
+++ include/linux/io_uring_types.h	(revision 55464)
@@ -330,6 +330,9 @@
 
 	struct list_head		io_buffers_pages;
 
+	#if defined(CONFIG_UNIX)
+		struct socket		*ring_sock;
+	#endif
 	/* hashed buffered write serialization */
 	struct io_wq_hash		*hash_map;
 
Index: include/linux/poll.h
===================================================================
--- include/linux/poll.h	(revision 55465)
+++ include/linux/poll.h	(revision 55464)
@@ -14,7 +14,11 @@
 
 /* ~832 bytes of stack space used max in sys_select/sys_poll before allocating
    additional memory. */
+#ifdef __clang__
+#define MAX_STACK_ALLOC 768
+#else
 #define MAX_STACK_ALLOC 832
+#endif
 #define FRONTEND_STACK_ALLOC	256
 #define SELECT_STACK_ALLOC	FRONTEND_STACK_ALLOC
 #define POLL_STACK_ALLOC	FRONTEND_STACK_ALLOC
Index: include/net/bluetooth/hci_core.h
===================================================================
--- include/net/bluetooth/hci_core.h	(revision 55465)
+++ include/net/bluetooth/hci_core.h	(revision 55464)
@@ -81,7 +81,7 @@
 	u8			last_adv_addr_type;
 	s8			last_adv_rssi;
 	u32			last_adv_flags;
-	u8			last_adv_data[HCI_MAX_EXT_AD_LENGTH];
+	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
 	bool			report_invalid_rssi;
 	bool			result_filtering;
@@ -293,7 +293,7 @@
 	__u8 ad_type;
 	__u8 offset;
 	__u8 length;
-	__u8 value[HCI_MAX_EXT_AD_LENGTH];
+	__u8 value[HCI_MAX_AD_LENGTH];
 };
 
 struct adv_rssi_thresholds {
@@ -549,7 +549,6 @@
 	__u32			req_status;
 	__u32			req_result;
 	struct sk_buff		*req_skb;
-	struct sk_buff		*req_rsp;
 
 	void			*smp_data;
 	void			*smp_bredr_data;
@@ -727,7 +726,7 @@
 	__u16		le_conn_interval;
 	__u16		le_conn_latency;
 	__u16		le_supv_timeout;
-	__u8		le_adv_data[HCI_MAX_EXT_AD_LENGTH];
+	__u8		le_adv_data[HCI_MAX_AD_LENGTH];
 	__u8		le_adv_data_len;
 	__u8		le_per_adv_data[HCI_MAX_PER_AD_LENGTH];
 	__u8		le_per_adv_data_len;
@@ -740,7 +739,6 @@
 	unsigned long	flags;
 
 	enum conn_reasons conn_reason;
-	__u8		abort_reason;
 
 	__u32		clock;
 	__u16		clock_accuracy;
@@ -760,6 +758,7 @@
 	struct delayed_work auto_accept_work;
 	struct delayed_work idle_work;
 	struct delayed_work le_conn_timeout;
+	struct work_struct  le_scan_cleanup;
 
 	struct device	dev;
 	struct dentry	*debugfs;
@@ -1710,10 +1709,6 @@
 /* Extended advertising support */
 #define ext_adv_capable(dev) (((dev)->le_features[1] & HCI_LE_EXT_ADV))
 
-/* Maximum advertising length */
-#define max_adv_len(dev) \
-	(ext_adv_capable(dev) ? HCI_MAX_EXT_AD_LENGTH : HCI_MAX_AD_LENGTH)
-
 /* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 4, Part E page 1789:
  *
  * C24: Mandatory if the LE Controller supports Connection State and either
Index: include/net/bluetooth/hci.h
===================================================================
--- include/net/bluetooth/hci.h	(revision 55465)
+++ include/net/bluetooth/hci.h	(revision 55464)
@@ -416,6 +416,7 @@
 #define HCI_NCMD_TIMEOUT	msecs_to_jiffies(4000)	/* 4 seconds */
 #define HCI_ACL_TX_TIMEOUT	msecs_to_jiffies(45000)	/* 45 seconds */
 #define HCI_AUTO_OFF_TIMEOUT	msecs_to_jiffies(2000)	/* 2 seconds */
+#define HCI_POWER_OFF_TIMEOUT	msecs_to_jiffies(5000)	/* 5 seconds */
 #define HCI_LE_CONN_TIMEOUT	msecs_to_jiffies(20000)	/* 20 seconds */
 #define HCI_LE_AUTOCONN_TIMEOUT	msecs_to_jiffies(4000)	/* 4 seconds */
 
Index: include/net/bluetooth/hci_sync.h
===================================================================
--- include/net/bluetooth/hci_sync.h	(revision 55465)
+++ include/net/bluetooth/hci_sync.h	(revision 55464)
@@ -39,10 +39,8 @@
 void hci_cmd_sync_init(struct hci_dev *hdev);
 void hci_cmd_sync_clear(struct hci_dev *hdev);
 void hci_cmd_sync_cancel(struct hci_dev *hdev, int err);
-void hci_cmd_sync_cancel_sync(struct hci_dev *hdev, int err);
+void __hci_cmd_sync_cancel(struct hci_dev *hdev, int err);
 
-int hci_cmd_sync_submit(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,
-			void *data, hci_cmd_sync_work_destroy_t destroy);
 int hci_cmd_sync_queue(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,
 		       void *data, hci_cmd_sync_work_destroy_t destroy);
 
Index: include/uapi/rdma/irdma-abi.h
===================================================================
--- include/uapi/rdma/irdma-abi.h	(revision 55465)
+++ include/uapi/rdma/irdma-abi.h	(revision 55464)
@@ -22,15 +22,10 @@
 	IRDMA_MEMREG_TYPE_CQ   = 2,
 };
 
-enum {
-	IRDMA_ALLOC_UCTX_USE_RAW_ATTR = 1 << 0,
-};
-
 struct irdma_alloc_ucontext_req {
 	__u32 rsvd32;
 	__u8 userspace_ver;
 	__u8 rsvd8[3];
-	__aligned_u64 comp_mask;
 };
 
 struct irdma_alloc_ucontext_resp {
@@ -51,7 +46,6 @@
 	__u16 max_hw_sq_chunk;
 	__u8 hw_rev;
 	__u8 rsvd2;
-	__aligned_u64 comp_mask;
 };
 
 struct irdma_alloc_pd_resp {
Index: include/drm/drm_fixed.h
===================================================================
--- include/drm/drm_fixed.h	(revision 55465)
+++ include/drm/drm_fixed.h	(revision 55464)
@@ -70,6 +70,7 @@
 }
 
 #define DRM_FIXED_POINT		32
+#define DRM_FIXED_POINT_HALF	16
 #define DRM_FIXED_ONE		(1ULL << DRM_FIXED_POINT)
 #define DRM_FIXED_DECIMAL_MASK	(DRM_FIXED_ONE - 1)
 #define DRM_FIXED_DIGITS_MASK	(~DRM_FIXED_DECIMAL_MASK)
@@ -88,12 +89,12 @@
 
 static inline int drm_fixp2int_round(s64 a)
 {
-	return drm_fixp2int(a + DRM_FIXED_ONE / 2);
+	return drm_fixp2int(a + (1 << (DRM_FIXED_POINT_HALF - 1)));
 }
 
 static inline int drm_fixp2int_ceil(s64 a)
 {
-	if (a >= 0)
+	if (a > 0)
 		return drm_fixp2int(a + DRM_FIXED_ALMOST_ONE);
 	else
 		return drm_fixp2int(a - DRM_FIXED_ALMOST_ONE);
Index: include/dt-bindings/clock/r8a779g0-cpg-mssr.h
===================================================================
--- include/dt-bindings/clock/r8a779g0-cpg-mssr.h	(revision 55465)
+++ include/dt-bindings/clock/r8a779g0-cpg-mssr.h	(revision 55464)
@@ -86,6 +86,5 @@
 #define R8A779G0_CLK_CPEX		74
 #define R8A779G0_CLK_CBFUSA		75
 #define R8A779G0_CLK_R			76
-#define R8A779G0_CLK_CP			77
 
 #endif /* __DT_BINDINGS_CLOCK_R8A779G0_CPG_MSSR_H__ */
Index: Makefile
===================================================================
--- Makefile	(revision 55465)
+++ Makefile	(revision 55464)
@@ -1,8 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 6
 PATCHLEVEL = 1
-SUBLEVEL = 83
-EXTRAVERSION = -rc2
+SUBLEVEL = 82
+EXTRAVERSION =
 NAME = Curry Ramen
 
 # *DOCUMENTATION*
Index: fs/afs/dir.c
===================================================================
--- fs/afs/dir.c	(revision 55465)
+++ fs/afs/dir.c	(revision 55464)
@@ -473,6 +473,16 @@
 			continue;
 		}
 
+		/* Don't expose silly rename entries to userspace. */
+		if (nlen > 6 &&
+		    dire->u.name[0] == '.' &&
+		    ctx->actor != afs_lookup_filldir &&
+		    ctx->actor != afs_lookup_one_filldir &&
+		    memcmp(dire->u.name, ".__afs", 6) == 0) {
+			ctx->pos = blkoff + next * sizeof(union afs_xdr_dirent);
+			continue;
+		}
+
 		/* found the next entry */
 		if (!dir_emit(ctx, dire->u.name, nlen,
 			      ntohl(dire->u.vnode),
Index: fs/btrfs/space-info.c
===================================================================
--- fs/btrfs/space-info.c	(revision 55465)
+++ fs/btrfs/space-info.c	(revision 55464)
@@ -847,7 +847,7 @@
 static bool need_preemptive_reclaim(struct btrfs_fs_info *fs_info,
 				    struct btrfs_space_info *space_info)
 {
-	const u64 global_rsv_size = btrfs_block_rsv_reserved(&fs_info->global_block_rsv);
+	u64 global_rsv_size = fs_info->global_block_rsv.reserved;
 	u64 ordered, delalloc;
 	u64 total = writable_total_bytes(fs_info, space_info);
 	u64 thresh;
@@ -948,8 +948,8 @@
 	ordered = percpu_counter_read_positive(&fs_info->ordered_bytes) >> 1;
 	delalloc = percpu_counter_read_positive(&fs_info->delalloc_bytes);
 	if (ordered >= delalloc)
-		used += btrfs_block_rsv_reserved(&fs_info->delayed_refs_rsv) +
-			btrfs_block_rsv_reserved(&fs_info->delayed_block_rsv);
+		used += fs_info->delayed_refs_rsv.reserved +
+			fs_info->delayed_block_rsv.reserved;
 	else
 		used += space_info->bytes_may_use - global_rsv_size;
 
@@ -1164,7 +1164,7 @@
 		enum btrfs_flush_state flush;
 		u64 delalloc_size = 0;
 		u64 to_reclaim, block_rsv_size;
-		const u64 global_rsv_size = btrfs_block_rsv_reserved(global_rsv);
+		u64 global_rsv_size = global_rsv->reserved;
 
 		loops++;
 
@@ -1176,9 +1176,9 @@
 		 * assume it's tied up in delalloc reservations.
 		 */
 		block_rsv_size = global_rsv_size +
-			btrfs_block_rsv_reserved(delayed_block_rsv) +
-			btrfs_block_rsv_reserved(delayed_refs_rsv) +
-			btrfs_block_rsv_reserved(trans_rsv);
+			delayed_block_rsv->reserved +
+			delayed_refs_rsv->reserved +
+			trans_rsv->reserved;
 		if (block_rsv_size < space_info->bytes_may_use)
 			delalloc_size = space_info->bytes_may_use - block_rsv_size;
 
@@ -1198,16 +1198,16 @@
 			to_reclaim = delalloc_size;
 			flush = FLUSH_DELALLOC;
 		} else if (space_info->bytes_pinned >
-			   (btrfs_block_rsv_reserved(delayed_block_rsv) +
-			    btrfs_block_rsv_reserved(delayed_refs_rsv))) {
+			   (delayed_block_rsv->reserved +
+			    delayed_refs_rsv->reserved)) {
 			to_reclaim = space_info->bytes_pinned;
 			flush = COMMIT_TRANS;
-		} else if (btrfs_block_rsv_reserved(delayed_block_rsv) >
-			   btrfs_block_rsv_reserved(delayed_refs_rsv)) {
-			to_reclaim = btrfs_block_rsv_reserved(delayed_block_rsv);
+		} else if (delayed_block_rsv->reserved >
+			   delayed_refs_rsv->reserved) {
+			to_reclaim = delayed_block_rsv->reserved;
 			flush = FLUSH_DELAYED_ITEMS_NR;
 		} else {
-			to_reclaim = btrfs_block_rsv_reserved(delayed_refs_rsv);
+			to_reclaim = delayed_refs_rsv->reserved;
 			flush = FLUSH_DELAYED_REFS_NR;
 		}
 
Index: fs/btrfs/block-rsv.c
===================================================================
--- fs/btrfs/block-rsv.c	(revision 55465)
+++ fs/btrfs/block-rsv.c	(revision 55464)
@@ -512,7 +512,7 @@
 
 	block_rsv = get_block_rsv(trans, root);
 
-	if (unlikely(btrfs_block_rsv_size(block_rsv) == 0))
+	if (unlikely(block_rsv->size == 0))
 		goto try_reserve;
 again:
 	ret = btrfs_block_rsv_use_bytes(block_rsv, blocksize);
Index: fs/btrfs/block-rsv.h
===================================================================
--- fs/btrfs/block-rsv.h	(revision 55465)
+++ fs/btrfs/block-rsv.h	(revision 55464)
@@ -101,36 +101,4 @@
 	return data_race(rsv->full);
 }
 
-/*
- * Get the reserved mount of a block reserve in a context where getting a stale
- * value is acceptable, instead of accessing it directly and trigger data race
- * warning from KCSAN.
- */
-static inline u64 btrfs_block_rsv_reserved(struct btrfs_block_rsv *rsv)
-{
-	u64 ret;
-
-	spin_lock(&rsv->lock);
-	ret = rsv->reserved;
-	spin_unlock(&rsv->lock);
-
-	return ret;
-}
-
-/*
- * Get the size of a block reserve in a context where getting a stale value is
- * acceptable, instead of accessing it directly and trigger data race warning
- * from KCSAN.
- */
-static inline u64 btrfs_block_rsv_size(struct btrfs_block_rsv *rsv)
-{
-	u64 ret;
-
-	spin_lock(&rsv->lock);
-	ret = rsv->size;
-	spin_unlock(&rsv->lock);
-
-	return ret;
-}
-
 #endif /* BTRFS_BLOCK_RSV_H */
Index: fs/nfs/nfs4proc.c
===================================================================
--- fs/nfs/nfs4proc.c	(revision 55465)
+++ fs/nfs/nfs4proc.c	(revision 55464)
@@ -10592,33 +10592,29 @@
 static ssize_t nfs4_listxattr(struct dentry *dentry, char *list, size_t size)
 {
 	ssize_t error, error2, error3;
-	size_t left = size;
 
-	error = generic_listxattr(dentry, list, left);
+	error = generic_listxattr(dentry, list, size);
 	if (error < 0)
 		return error;
 	if (list) {
 		list += error;
-		left -= error;
+		size -= error;
 	}
 
-	error2 = nfs4_listxattr_nfs4_label(d_inode(dentry), list, left);
+	error2 = nfs4_listxattr_nfs4_label(d_inode(dentry), list, size);
 	if (error2 < 0)
 		return error2;
 
 	if (list) {
 		list += error2;
-		left -= error2;
+		size -= error2;
 	}
 
-	error3 = nfs4_listxattr_nfs4_user(d_inode(dentry), list, left);
+	error3 = nfs4_listxattr_nfs4_user(d_inode(dentry), list, size);
 	if (error3 < 0)
 		return error3;
 
-	error += error2 + error3;
-	if (size && error > size)
-		return -ERANGE;
-	return error;
+	return error + error2 + error3;
 }
 
 static void nfs4_enable_swap(struct inode *inode)
Index: fs/nfs/flexfilelayout/flexfilelayout.c
===================================================================
--- fs/nfs/flexfilelayout/flexfilelayout.c	(revision 55465)
+++ fs/nfs/flexfilelayout/flexfilelayout.c	(revision 55464)
@@ -2016,7 +2016,7 @@
 	for (idx = 0; idx < flseg->mirror_array_cnt; idx++) {
 		mirror = flseg->mirror_array[idx];
 		mirror_ds = mirror->mirror_ds;
-		if (IS_ERR_OR_NULL(mirror_ds))
+		if (!mirror_ds)
 			continue;
 		ds = mirror->mirror_ds->ds;
 		if (!ds)
Index: fs/nfs/nfs42.h
===================================================================
--- fs/nfs/nfs42.h	(revision 55465)
+++ fs/nfs/nfs42.h	(revision 55464)
@@ -55,14 +55,11 @@
  * They would be 7 bytes long in the eventual buffer ("user.x\0"), and
  * 8 bytes long XDR-encoded.
  *
- * Include the trailing eof word as well and make the result a multiple
- * of 4 bytes.
+ * Include the trailing eof word as well.
  */
 static inline u32 nfs42_listxattr_xdrsize(u32 buflen)
 {
-	u32 size = 8 * buflen / (XATTR_USER_PREFIX_LEN + 2) + 4;
-
-	return (size + 3) & ~3;
+	return ((buflen / (XATTR_USER_PREFIX_LEN + 2)) * 8) + 4;
 }
 #endif /* CONFIG_NFS_V4_2 */
 #endif /* __LINUX_FS_NFS_NFS4_2_H */
Index: fs/nfs/export.c
===================================================================
--- fs/nfs/export.c	(revision 55465)
+++ fs/nfs/export.c	(revision 55464)
@@ -156,10 +156,7 @@
 	.fh_to_dentry = nfs_fh_to_dentry,
 	.get_parent = nfs_get_parent,
 	.fetch_iversion = nfs_fetch_iversion,
-	.flags = EXPORT_OP_NOWCC		|
-		 EXPORT_OP_NOSUBTREECHK		|
-		 EXPORT_OP_CLOSE_BEFORE_UNLINK	|
-		 EXPORT_OP_REMOTE_FS		|
-		 EXPORT_OP_NOATOMIC_ATTR	|
-		 EXPORT_OP_FLUSH_ON_CLOSE,
+	.flags = EXPORT_OP_NOWCC|EXPORT_OP_NOSUBTREECHK|
+		EXPORT_OP_CLOSE_BEFORE_UNLINK|EXPORT_OP_REMOTE_FS|
+		EXPORT_OP_NOATOMIC_ATTR,
 };
Index: fs/nfs/nfsroot.c
===================================================================
--- fs/nfs/nfsroot.c	(revision 55465)
+++ fs/nfs/nfsroot.c	(revision 55464)
@@ -175,10 +175,10 @@
 	size_t len = strlen(dest);
 
 	if (len && dest[len - 1] != ',')
-		if (strlcat(dest, ",", destlen) >= destlen)
+		if (strlcat(dest, ",", destlen) > destlen)
 			return -1;
 
-	if (strlcat(dest, src, destlen) >= destlen)
+	if (strlcat(dest, src, destlen) > destlen)
 		return -1;
 	return 0;
 }
Index: fs/nfsd/filecache.c
===================================================================
--- fs/nfsd/filecache.c	(revision 55465)
+++ fs/nfsd/filecache.c	(revision 55464)
@@ -74,9 +74,70 @@
 static unsigned long			nfsd_file_flags;
 static struct fsnotify_group		*nfsd_file_fsnotify_group;
 static struct delayed_work		nfsd_filecache_laundrette;
-static struct rhltable			nfsd_file_rhltable
+static struct rhashtable		nfsd_file_rhash_tbl
 						____cacheline_aligned_in_smp;
 
+enum nfsd_file_lookup_type {
+	NFSD_FILE_KEY_INODE,
+	NFSD_FILE_KEY_FULL,
+};
+
+struct nfsd_file_lookup_key {
+	struct inode			*inode;
+	struct net			*net;
+	const struct cred		*cred;
+	unsigned char			need;
+	bool				gc;
+	enum nfsd_file_lookup_type	type;
+};
+
+/*
+ * The returned hash value is based solely on the address of an in-code
+ * inode, a pointer to a slab-allocated object. The entropy in such a
+ * pointer is concentrated in its middle bits.
+ */
+static u32 nfsd_file_inode_hash(const struct inode *inode, u32 seed)
+{
+	unsigned long ptr = (unsigned long)inode;
+	u32 k;
+
+	k = ptr >> L1_CACHE_SHIFT;
+	k &= 0x00ffffff;
+	return jhash2(&k, 1, seed);
+}
+
+/**
+ * nfsd_file_key_hashfn - Compute the hash value of a lookup key
+ * @data: key on which to compute the hash value
+ * @len: rhash table's key_len parameter (unused)
+ * @seed: rhash table's random seed of the day
+ *
+ * Return value:
+ *   Computed 32-bit hash value
+ */
+static u32 nfsd_file_key_hashfn(const void *data, u32 len, u32 seed)
+{
+	const struct nfsd_file_lookup_key *key = data;
+
+	return nfsd_file_inode_hash(key->inode, seed);
+}
+
+/**
+ * nfsd_file_obj_hashfn - Compute the hash value of an nfsd_file
+ * @data: object on which to compute the hash value
+ * @len: rhash table's key_len parameter (unused)
+ * @seed: rhash table's random seed of the day
+ *
+ * Return value:
+ *   Computed 32-bit hash value
+ */
+static u32 nfsd_file_obj_hashfn(const void *data, u32 len, u32 seed)
+{
+	const struct nfsd_file *nf = data;
+
+	return nfsd_file_inode_hash(nf->nf_inode, seed);
+}
+
 static bool
 nfsd_match_cred(const struct cred *c1, const struct cred *c2)
 {
@@ -97,16 +158,53 @@
 	return true;
 }
 
+/**
+ * nfsd_file_obj_cmpfn - Match a cache item against search criteria
+ * @arg: search criteria
+ * @ptr: cache item to check
+ *
+ * Return values:
+ *   %0 - Item matches search criteria
+ *   %1 - Item does not match search criteria
+ */
+static int nfsd_file_obj_cmpfn(struct rhashtable_compare_arg *arg,
+			       const void *ptr)
+{
+	const struct nfsd_file_lookup_key *key = arg->key;
+	const struct nfsd_file *nf = ptr;
+
+	switch (key->type) {
+	case NFSD_FILE_KEY_INODE:
+		if (nf->nf_inode != key->inode)
+			return 1;
+		break;
+	case NFSD_FILE_KEY_FULL:
+		if (nf->nf_inode != key->inode)
+			return 1;
+		if (nf->nf_may != key->need)
+			return 1;
+		if (nf->nf_net != key->net)
+			return 1;
+		if (!nfsd_match_cred(nf->nf_cred, key->cred))
+			return 1;
+		if (!!test_bit(NFSD_FILE_GC, &nf->nf_flags) != key->gc)
+			return 1;
+		if (test_bit(NFSD_FILE_HASHED, &nf->nf_flags) == 0)
+			return 1;
+		break;
+	}
+	return 0;
+}
+
 static const struct rhashtable_params nfsd_file_rhash_params = {
 	.key_len		= sizeof_field(struct nfsd_file, nf_inode),
 	.key_offset		= offsetof(struct nfsd_file, nf_inode),
-	.head_offset		= offsetof(struct nfsd_file, nf_rlist),
-
-	/*
-	 * Start with a single page hash table to reduce resizing churn
-	 * on light workloads.
-	 */
-	.min_size		= 256,
+	.head_offset		= offsetof(struct nfsd_file, nf_rhash),
+	.hashfn			= nfsd_file_key_hashfn,
+	.obj_hashfn		= nfsd_file_obj_hashfn,
+	.obj_cmpfn		= nfsd_file_obj_cmpfn,
+	/* Reduce resizing churn on light workloads */
+	.min_size		= 512,		/* buckets */
 	.automatic_shrinking	= true,
 };
 
@@ -209,27 +307,27 @@
 }
 
 static struct nfsd_file *
-nfsd_file_alloc(struct net *net, struct inode *inode, unsigned char need,
-		bool want_gc)
+nfsd_file_alloc(struct nfsd_file_lookup_key *key, unsigned int may)
 {
 	struct nfsd_file *nf;
 
 	nf = kmem_cache_alloc(nfsd_file_slab, GFP_KERNEL);
-	if (unlikely(!nf))
-		return NULL;
-
-	INIT_LIST_HEAD(&nf->nf_lru);
-	nf->nf_birthtime = ktime_get();
-	nf->nf_file = NULL;
-	nf->nf_cred = get_current_cred();
-	nf->nf_net = net;
-	nf->nf_flags = want_gc ?
-		BIT(NFSD_FILE_HASHED) | BIT(NFSD_FILE_PENDING) | BIT(NFSD_FILE_GC) :
-		BIT(NFSD_FILE_HASHED) | BIT(NFSD_FILE_PENDING);
-	nf->nf_inode = inode;
-	refcount_set(&nf->nf_ref, 1);
-	nf->nf_may = need;
-	nf->nf_mark = NULL;
+	if (nf) {
+		INIT_LIST_HEAD(&nf->nf_lru);
+		nf->nf_birthtime = ktime_get();
+		nf->nf_file = NULL;
+		nf->nf_cred = get_current_cred();
+		nf->nf_net = key->net;
+		nf->nf_flags = 0;
+		__set_bit(NFSD_FILE_HASHED, &nf->nf_flags);
+		__set_bit(NFSD_FILE_PENDING, &nf->nf_flags);
+		if (key->gc)
+			__set_bit(NFSD_FILE_GC, &nf->nf_flags);
+		nf->nf_inode = key->inode;
+		refcount_set(&nf->nf_ref, 1);
+		nf->nf_may = key->need;
+		nf->nf_mark = NULL;
+	}
 	return nf;
 }
 
@@ -254,8 +352,8 @@
 nfsd_file_hash_remove(struct nfsd_file *nf)
 {
 	trace_nfsd_file_unhash(nf);
-	rhltable_remove(&nfsd_file_rhltable, &nf->nf_rlist,
-			nfsd_file_rhash_params);
+	rhashtable_remove_fast(&nfsd_file_rhash_tbl, &nf->nf_rhash,
+			       nfsd_file_rhash_params);
 }
 
 static bool
@@ -282,8 +380,10 @@
 	if (nf->nf_mark)
 		nfsd_file_mark_put(nf->nf_mark);
 	if (nf->nf_file) {
+		get_file(nf->nf_file);
+		filp_close(nf->nf_file, NULL);
 		nfsd_file_check_write_error(nf);
-		filp_close(nf->nf_file, NULL);
+		fput(nf->nf_file);
 	}
 
 	/*
@@ -302,23 +402,13 @@
 	struct file *file = nf->nf_file;
 	struct address_space *mapping;
 
-	/* File not open for write? */
-	if (!(file->f_mode & FMODE_WRITE))
+	if (!file || !(file->f_mode & FMODE_WRITE))
 		return false;
-
-	/*
-	 * Some filesystems (e.g. NFS) flush all dirty data on close.
-	 * On others, there is no need to wait for writeback.
-	 */
-	if (!(file_inode(file)->i_sb->s_export_op->flags & EXPORT_OP_FLUSH_ON_CLOSE))
-		return false;
-
 	mapping = file->f_mapping;
 	return mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) ||
 		mapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK);
 }
 
-
 static bool nfsd_file_lru_add(struct nfsd_file *nf)
 {
 	set_bit(NFSD_FILE_REFERENCED, &nf->nf_flags);
@@ -341,7 +431,7 @@
 struct nfsd_file *
 nfsd_file_get(struct nfsd_file *nf)
 {
-	if (nf && refcount_inc_not_zero(&nf->nf_ref))
+	if (likely(refcount_inc_not_zero(&nf->nf_ref)))
 		return nf;
 	return NULL;
 }
@@ -402,26 +492,49 @@
 	}
 }
 
-/**
- * nfsd_file_dispose_list_delayed - move list of dead files to net's freeme list
- * @dispose: list of nfsd_files to be disposed
- *
- * Transfers each file to the "freeme" list for its nfsd_net, to eventually
- * be disposed of by the per-net garbage collector.
- */
 static void
+nfsd_file_list_remove_disposal(struct list_head *dst,
+		struct nfsd_fcache_disposal *l)
+{
+	spin_lock(&l->lock);
+	list_splice_init(&l->freeme, dst);
+	spin_unlock(&l->lock);
+}
+
+static void
+nfsd_file_list_add_disposal(struct list_head *files, struct net *net)
+{
+	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
+	struct nfsd_fcache_disposal *l = nn->fcache_disposal;
+
+	spin_lock(&l->lock);
+	list_splice_tail_init(files, &l->freeme);
+	spin_unlock(&l->lock);
+	queue_work(nfsd_filecache_wq, &l->work);
+}
+
+static void
+nfsd_file_list_add_pernet(struct list_head *dst, struct list_head *src,
+		struct net *net)
+{
+	struct nfsd_file *nf, *tmp;
+
+	list_for_each_entry_safe(nf, tmp, src, nf_lru) {
+		if (nf->nf_net == net)
+			list_move_tail(&nf->nf_lru, dst);
+	}
+}
+
+static void
 nfsd_file_dispose_list_delayed(struct list_head *dispose)
 {
+	LIST_HEAD(list);
+	struct nfsd_file *nf;
+
 	while(!list_empty(dispose)) {
-		struct nfsd_file *nf = list_first_entry(dispose,
-						struct nfsd_file, nf_lru);
-		struct nfsd_net *nn = net_generic(nf->nf_net, nfsd_net_id);
-		struct nfsd_fcache_disposal *l = nn->fcache_disposal;
-
-		spin_lock(&l->lock);
-		list_move_tail(&nf->nf_lru, &l->freeme);
-		spin_unlock(&l->lock);
-		queue_work(nfsd_filecache_wq, &l->work);
+		nf = list_first_entry(dispose, struct nfsd_file, nf_lru);
+		nfsd_file_list_add_pernet(&list, dispose, nf->nf_net);
+		nfsd_file_list_add_disposal(&list, nf->nf_net);
 	}
 }
 
@@ -565,8 +678,8 @@
  * @inode:   inode on which to close out nfsd_files
  * @dispose: list on which to gather nfsd_files to close out
  *
- * An nfsd_file represents a struct file being held open on behalf of nfsd.
- * An open file however can block other activity (such as leases), or cause
+ * An nfsd_file represents a struct file being held open on behalf of nfsd. An
+ * open file however can block other activity (such as leases), or cause
  * undesirable behavior (e.g. spurious silly-renames when reexporting NFS).
  *
  * This function is intended to find open nfsd_files when this sort of
@@ -579,17 +692,20 @@
 static void
 nfsd_file_queue_for_close(struct inode *inode, struct list_head *dispose)
 {
-	struct rhlist_head *tmp, *list;
+	struct nfsd_file_lookup_key key = {
+		.type	= NFSD_FILE_KEY_INODE,
+		.inode	= inode,
+	};
 	struct nfsd_file *nf;
 
 	rcu_read_lock();
-	list = rhltable_lookup(&nfsd_file_rhltable, &inode,
-			       nfsd_file_rhash_params);
-	rhl_for_each_entry_rcu(nf, tmp, list, nf_rlist) {
-		if (!test_bit(NFSD_FILE_GC, &nf->nf_flags))
-			continue;
+	do {
+		nf = rhashtable_lookup(&nfsd_file_rhash_tbl, &key,
+				       nfsd_file_rhash_params);
+		if (!nf)
+			break;
 		nfsd_file_cond_queue(nf, dispose);
-	}
+	} while (1);
 	rcu_read_unlock();
 }
 
@@ -642,8 +758,8 @@
  * nfsd_file_delayed_close - close unused nfsd_files
  * @work: dummy
  *
- * Scrape the freeme list for this nfsd_net, and then dispose of them
- * all.
+ * Walk the LRU list and destroy any entries that have not been used since
+ * the last scan.
  */
 static void
 nfsd_file_delayed_close(struct work_struct *work)
@@ -652,10 +768,7 @@
 	struct nfsd_fcache_disposal *l = container_of(work,
 			struct nfsd_fcache_disposal, work);
 
-	spin_lock(&l->lock);
-	list_splice_init(&l->freeme, &head);
-	spin_unlock(&l->lock);
-
+	nfsd_file_list_remove_disposal(&head, l);
 	nfsd_file_dispose_list(&head);
 }
 
@@ -716,7 +829,7 @@
 	if (test_and_set_bit(NFSD_FILE_CACHE_UP, &nfsd_file_flags) == 1)
 		return 0;
 
-	ret = rhltable_init(&nfsd_file_rhltable, &nfsd_file_rhash_params);
+	ret = rhashtable_init(&nfsd_file_rhash_tbl, &nfsd_file_rhash_params);
 	if (ret)
 		return ret;
 
@@ -784,7 +897,7 @@
 	nfsd_file_mark_slab = NULL;
 	destroy_workqueue(nfsd_filecache_wq);
 	nfsd_filecache_wq = NULL;
-	rhltable_destroy(&nfsd_file_rhltable);
+	rhashtable_destroy(&nfsd_file_rhash_tbl);
 	goto out;
 }
 
@@ -793,8 +906,7 @@
  * @net: net-namespace to shut down the cache (may be NULL)
  *
  * Walk the nfsd_file cache and close out any that match @net. If @net is NULL,
- * then close out everything. Called when an nfsd instance is being shut down,
- * and when the exports table is flushed.
+ * then close out everything. Called when an nfsd instance is being shut down.
  */
 static void
 __nfsd_file_cache_purge(struct net *net)
@@ -803,7 +915,7 @@
 	struct nfsd_file *nf;
 	LIST_HEAD(dispose);
 
-	rhltable_walk_enter(&nfsd_file_rhltable, &iter);
+	rhashtable_walk_enter(&nfsd_file_rhash_tbl, &iter);
 	do {
 		rhashtable_walk_start(&iter);
 
@@ -909,7 +1021,7 @@
 	nfsd_file_mark_slab = NULL;
 	destroy_workqueue(nfsd_filecache_wq);
 	nfsd_filecache_wq = NULL;
-	rhltable_destroy(&nfsd_file_rhltable);
+	rhashtable_destroy(&nfsd_file_rhash_tbl);
 
 	for_each_possible_cpu(i) {
 		per_cpu(nfsd_file_cache_hits, i) = 0;
@@ -920,35 +1032,6 @@
 	}
 }
 
-static struct nfsd_file *
-nfsd_file_lookup_locked(const struct net *net, const struct cred *cred,
-			struct inode *inode, unsigned char need,
-			bool want_gc)
-{
-	struct rhlist_head *tmp, *list;
-	struct nfsd_file *nf;
-
-	list = rhltable_lookup(&nfsd_file_rhltable, &inode,
-			       nfsd_file_rhash_params);
-	rhl_for_each_entry_rcu(nf, tmp, list, nf_rlist) {
-		if (nf->nf_may != need)
-			continue;
-		if (nf->nf_net != net)
-			continue;
-		if (!nfsd_match_cred(nf->nf_cred, cred))
-			continue;
-		if (test_bit(NFSD_FILE_GC, &nf->nf_flags) != want_gc)
-			continue;
-		if (test_bit(NFSD_FILE_HASHED, &nf->nf_flags) == 0)
-			continue;
-
-		if (!nfsd_file_get(nf))
-			continue;
-		return nf;
-	}
-	return NULL;
-}
-
 /**
  * nfsd_file_is_cached - are there any cached open files for this inode?
  * @inode: inode to check
@@ -963,20 +1046,15 @@
 bool
 nfsd_file_is_cached(struct inode *inode)
 {
-	struct rhlist_head *tmp, *list;
-	struct nfsd_file *nf;
+	struct nfsd_file_lookup_key key = {
+		.type	= NFSD_FILE_KEY_INODE,
+		.inode	= inode,
+	};
 	bool ret = false;
 
-	rcu_read_lock();
-	list = rhltable_lookup(&nfsd_file_rhltable, &inode,
-			       nfsd_file_rhash_params);
-	rhl_for_each_entry_rcu(nf, tmp, list, nf_rlist)
-		if (test_bit(NFSD_FILE_GC, &nf->nf_flags)) {
-			ret = true;
-			break;
-		}
-	rcu_read_unlock();
-
+	if (rhashtable_lookup_fast(&nfsd_file_rhash_tbl, &key,
+				   nfsd_file_rhash_params) != NULL)
+		ret = true;
 	trace_nfsd_file_is_cached(inode, (int)ret);
 	return ret;
 }
@@ -986,12 +1064,14 @@
 		     unsigned int may_flags, struct file *file,
 		     struct nfsd_file **pnf, bool want_gc)
 {
-	unsigned char need = may_flags & NFSD_FILE_MAY_MASK;
-	struct net *net = SVC_NET(rqstp);
-	struct nfsd_file *new, *nf;
-	const struct cred *cred;
+	struct nfsd_file_lookup_key key = {
+		.type	= NFSD_FILE_KEY_FULL,
+		.need	= may_flags & NFSD_FILE_MAY_MASK,
+		.net	= SVC_NET(rqstp),
+		.gc	= want_gc,
+	};
 	bool open_retry = true;
-	struct inode *inode;
+	struct nfsd_file *nf;
 	__be32 status;
 	int ret;
 
@@ -999,53 +1079,42 @@
 				may_flags|NFSD_MAY_OWNER_OVERRIDE);
 	if (status != nfs_ok)
 		return status;
-	inode = d_inode(fhp->fh_dentry);
-	cred = get_current_cred();
+	key.inode = d_inode(fhp->fh_dentry);
+	key.cred = get_current_cred();
 
 retry:
 	rcu_read_lock();
-	nf = nfsd_file_lookup_locked(net, cred, inode, need, want_gc);
+	nf = rhashtable_lookup(&nfsd_file_rhash_tbl, &key,
+			       nfsd_file_rhash_params);
+	if (nf)
+		nf = nfsd_file_get(nf);
 	rcu_read_unlock();
 
 	if (nf) {
-		/*
-		 * If the nf is on the LRU then it holds an extra reference
-		 * that must be put if it's removed. It had better not be
-		 * the last one however, since we should hold another.
-		 */
 		if (nfsd_file_lru_remove(nf))
 			WARN_ON_ONCE(refcount_dec_and_test(&nf->nf_ref));
 		goto wait_for_construction;
 	}
 
-	new = nfsd_file_alloc(net, inode, need, want_gc);
-	if (!new) {
+	nf = nfsd_file_alloc(&key, may_flags);
+	if (!nf) {
 		status = nfserr_jukebox;
-		goto out;
+		goto out_status;
 	}
 
-	rcu_read_lock();
-	spin_lock(&inode->i_lock);
-	nf = nfsd_file_lookup_locked(net, cred, inode, need, want_gc);
-	if (unlikely(nf)) {
-		spin_unlock(&inode->i_lock);
-		rcu_read_unlock();
-		nfsd_file_slab_free(&new->nf_rcu);
-		goto wait_for_construction;
-	}
-	nf = new;
-	ret = rhltable_insert(&nfsd_file_rhltable, &nf->nf_rlist,
-			      nfsd_file_rhash_params);
-	spin_unlock(&inode->i_lock);
-	rcu_read_unlock();
+	ret = rhashtable_lookup_insert_key(&nfsd_file_rhash_tbl,
+					   &key, &nf->nf_rhash,
+					   nfsd_file_rhash_params);
 	if (likely(ret == 0))
 		goto open_file;
 
+	nfsd_file_slab_free(&nf->nf_rcu);
+	nf = NULL;
 	if (ret == -EEXIST)
 		goto retry;
-	trace_nfsd_file_insert_err(rqstp, inode, may_flags, ret);
+	trace_nfsd_file_insert_err(rqstp, key.inode, may_flags, ret);
 	status = nfserr_jukebox;
-	goto construction_err;
+	goto out_status;
 
 wait_for_construction:
 	wait_on_bit(&nf->nf_flags, NFSD_FILE_PENDING, TASK_UNINTERRUPTIBLE);
@@ -1052,35 +1121,39 @@
 
 	/* Did construction of this file fail? */
 	if (!test_bit(NFSD_FILE_HASHED, &nf->nf_flags)) {
-		trace_nfsd_file_cons_err(rqstp, inode, may_flags, nf);
+		trace_nfsd_file_cons_err(rqstp, key.inode, may_flags, nf);
 		if (!open_retry) {
 			status = nfserr_jukebox;
-			goto construction_err;
+			goto out;
 		}
 		open_retry = false;
+		if (refcount_dec_and_test(&nf->nf_ref))
+			nfsd_file_free(nf);
 		goto retry;
 	}
+
 	this_cpu_inc(nfsd_file_cache_hits);
 
 	status = nfserrno(nfsd_open_break_lease(file_inode(nf->nf_file), may_flags));
-	if (status != nfs_ok) {
-		nfsd_file_put(nf);
-		nf = NULL;
-	}
-
 out:
 	if (status == nfs_ok) {
 		this_cpu_inc(nfsd_file_acquisitions);
 		nfsd_file_check_write_error(nf);
 		*pnf = nf;
+	} else {
+		if (refcount_dec_and_test(&nf->nf_ref))
+			nfsd_file_free(nf);
+		nf = NULL;
 	}
-	put_cred(cred);
-	trace_nfsd_file_acquire(rqstp, inode, may_flags, nf, status);
+
+out_status:
+	put_cred(key.cred);
+	trace_nfsd_file_acquire(rqstp, key.inode, may_flags, nf, status);
 	return status;
 
 open_file:
 	trace_nfsd_file_alloc(nf);
-	nf->nf_mark = nfsd_file_mark_find_or_create(nf, inode);
+	nf->nf_mark = nfsd_file_mark_find_or_create(nf, key.inode);
 	if (nf->nf_mark) {
 		if (file) {
 			get_file(file);
@@ -1098,16 +1171,13 @@
 	 * If construction failed, or we raced with a call to unlink()
 	 * then unhash.
 	 */
-	if (status != nfs_ok || inode->i_nlink == 0)
+	if (status == nfs_ok && key.inode->i_nlink == 0)
+		status = nfserr_jukebox;
+	if (status != nfs_ok)
 		nfsd_file_unhash(nf);
-	clear_and_wake_up_bit(NFSD_FILE_PENDING, &nf->nf_flags);
-	if (status == nfs_ok)
-		goto out;
-
-construction_err:
-	if (refcount_dec_and_test(&nf->nf_ref))
-		nfsd_file_free(nf);
-	nf = NULL;
+	clear_bit_unlock(NFSD_FILE_PENDING, &nf->nf_flags);
+	smp_mb__after_atomic();
+	wake_up_bit(&nf->nf_flags, NFSD_FILE_PENDING);
 	goto out;
 }
 
@@ -1123,11 +1193,8 @@
  * seconds after the final nfsd_file_put() in case the caller
  * wants to re-use it.
  *
- * Return values:
- *   %nfs_ok - @pnf points to an nfsd_file with its reference
- *   count boosted.
- *
- * On error, an nfsstat value in network byte order is returned.
+ * Returns nfs_ok and sets @pnf on success; otherwise an nfsstat in
+ * network byte order is returned.
  */
 __be32
 nfsd_file_acquire_gc(struct svc_rqst *rqstp, struct svc_fh *fhp,
@@ -1147,11 +1214,8 @@
  * but not garbage-collected. The object is unhashed after the
  * final nfsd_file_put().
  *
- * Return values:
- *   %nfs_ok - @pnf points to an nfsd_file with its reference
- *   count boosted.
- *
- * On error, an nfsstat value in network byte order is returned.
+ * Returns nfs_ok and sets @pnf on success; otherwise an nfsstat in
+ * network byte order is returned.
  */
 __be32
 nfsd_file_acquire(struct svc_rqst *rqstp, struct svc_fh *fhp,
@@ -1172,11 +1236,8 @@
  * and @file is non-NULL, use it to instantiate a new nfsd_file instead of
  * opening a new one.
  *
- * Return values:
- *   %nfs_ok - @pnf points to an nfsd_file with its reference
- *   count boosted.
- *
- * On error, an nfsstat value in network byte order is returned.
+ * Returns nfs_ok and sets @pnf on success; otherwise an nfsstat in
+ * network byte order is returned.
  */
 __be32
 nfsd_file_acquire_opened(struct svc_rqst *rqstp, struct svc_fh *fhp,
@@ -1207,7 +1268,7 @@
 		lru = list_lru_count(&nfsd_file_lru);
 
 		rcu_read_lock();
-		ht = &nfsd_file_rhltable.ht;
+		ht = &nfsd_file_rhash_tbl;
 		count = atomic_read(&ht->nelems);
 		tbl = rht_dereference_rcu(ht->tbl, ht);
 		buckets = tbl->size;
@@ -1223,7 +1284,7 @@
 		evictions += per_cpu(nfsd_file_evictions, i);
 	}
 
-	seq_printf(m, "total inodes:  %u\n", count);
+	seq_printf(m, "total entries: %u\n", count);
 	seq_printf(m, "hash buckets:  %u\n", buckets);
 	seq_printf(m, "lru entries:   %lu\n", lru);
 	seq_printf(m, "cache hits:    %lu\n", hits);
Index: fs/nfsd/nfs4state.c
===================================================================
--- fs/nfsd/nfs4state.c	(revision 55465)
+++ fs/nfsd/nfs4state.c	(revision 55464)
@@ -602,7 +602,9 @@
 static struct nfsd_file *
 __nfs4_get_fd(struct nfs4_file *f, int oflag)
 {
-	return nfsd_file_get(f->fi_fds[oflag]);
+	if (f->fi_fds[oflag])
+		return nfsd_file_get(f->fi_fds[oflag]);
+	return NULL;
 }
 
 static struct nfsd_file *
Index: fs/nfsd/nfs4xdr.c
===================================================================
--- fs/nfsd/nfs4xdr.c	(revision 55465)
+++ fs/nfsd/nfs4xdr.c	(revision 55464)
@@ -2541,20 +2541,6 @@
 	return p;
 }
 
-static __be32 nfsd4_encode_nfstime4(struct xdr_stream *xdr,
-				    struct timespec64 *tv)
-{
-	__be32 *p;
-
-	p = xdr_reserve_space(xdr, XDR_UNIT * 3);
-	if (!p)
-		return nfserr_resource;
-
-	p = xdr_encode_hyper(p, (s64)tv->tv_sec);
-	*p = cpu_to_be32(tv->tv_nsec);
-	return nfs_ok;
-}
-
 /*
  * ctime (in NFSv4, time_metadata) is not writeable, and the client
  * doesn't really care what resolution could theoretically be stored by
@@ -3360,15 +3346,12 @@
 		p = xdr_encode_hyper(p, dummy64);
 	}
 	if (bmval1 & FATTR4_WORD1_TIME_ACCESS) {
-		status = nfsd4_encode_nfstime4(xdr, &stat.atime);
-		if (status)
-			goto out;
+		p = xdr_reserve_space(xdr, 12);
+		if (!p)
+			goto out_resource;
+		p = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);
+		*p++ = cpu_to_be32(stat.atime.tv_nsec);
 	}
-	if (bmval1 & FATTR4_WORD1_TIME_CREATE) {
-		status = nfsd4_encode_nfstime4(xdr, &stat.btime);
-		if (status)
-			goto out;
-	}
 	if (bmval1 & FATTR4_WORD1_TIME_DELTA) {
 		p = xdr_reserve_space(xdr, 12);
 		if (!p)
@@ -3376,15 +3359,26 @@
 		p = encode_time_delta(p, d_inode(dentry));
 	}
 	if (bmval1 & FATTR4_WORD1_TIME_METADATA) {
-		status = nfsd4_encode_nfstime4(xdr, &stat.ctime);
-		if (status)
-			goto out;
+		p = xdr_reserve_space(xdr, 12);
+		if (!p)
+			goto out_resource;
+		p = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);
+		*p++ = cpu_to_be32(stat.ctime.tv_nsec);
 	}
 	if (bmval1 & FATTR4_WORD1_TIME_MODIFY) {
-		status = nfsd4_encode_nfstime4(xdr, &stat.mtime);
-		if (status)
-			goto out;
+		p = xdr_reserve_space(xdr, 12);
+		if (!p)
+			goto out_resource;
+		p = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);
+		*p++ = cpu_to_be32(stat.mtime.tv_nsec);
 	}
+	if (bmval1 & FATTR4_WORD1_TIME_CREATE) {
+		p = xdr_reserve_space(xdr, 12);
+		if (!p)
+			goto out_resource;
+		p = xdr_encode_hyper(p, (s64)stat.btime.tv_sec);
+		*p++ = cpu_to_be32(stat.btime.tv_nsec);
+	}
 	if (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {
 		u64 ino = stat.ino;
 
Index: fs/nfsd/filecache.h
===================================================================
--- fs/nfsd/filecache.h	(revision 55465)
+++ fs/nfsd/filecache.h	(revision 55464)
@@ -29,8 +29,9 @@
  * never be dereferenced, only used for comparison.
  */
 struct nfsd_file {
-	struct rhlist_head	nf_rlist;
-	void			*nf_inode;
+	struct rhash_head	nf_rhash;
+	struct list_head	nf_lru;
+	struct rcu_head		nf_rcu;
 	struct file		*nf_file;
 	const struct cred	*nf_cred;
 	struct net		*nf_net;
@@ -39,12 +40,10 @@
 #define NFSD_FILE_REFERENCED	(2)
 #define NFSD_FILE_GC		(3)
 	unsigned long		nf_flags;
+	struct inode		*nf_inode;	/* don't deref */
 	refcount_t		nf_ref;
 	unsigned char		nf_may;
-
 	struct nfsd_file_mark	*nf_mark;
-	struct list_head	nf_lru;
-	struct rcu_head		nf_rcu;
 	ktime_t			nf_birthtime;
 };
 
Index: fs/f2fs/compress.c
===================================================================
--- fs/f2fs/compress.c	(revision 55465)
+++ fs/f2fs/compress.c	(revision 55464)
@@ -1249,11 +1249,10 @@
 		.page = NULL,
 		.encrypted_page = NULL,
 		.compressed_page = NULL,
-		.submitted = 0,
+		.submitted = false,
 		.io_type = io_type,
 		.io_wbc = wbc,
-		.encrypted = fscrypt_inode_uses_fs_layer_crypto(cc->inode) ?
-									1 : 0,
+		.encrypted = fscrypt_inode_uses_fs_layer_crypto(cc->inode),
 	};
 	struct dnode_of_data dn;
 	struct node_info ni;
@@ -1388,6 +1387,8 @@
 	add_compr_block_stat(inode, cc->valid_nr_cpages);
 
 	set_inode_flag(cc->inode, FI_APPEND_WRITE);
+	if (cc->cluster_idx == 0)
+		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
 
 	f2fs_put_dnode(&dn);
 	if (quota_inode)
@@ -1435,8 +1436,6 @@
 	struct f2fs_sb_info *sbi = bio->bi_private;
 	struct compress_io_ctx *cic =
 			(struct compress_io_ctx *)page_private(page);
-	enum count_type type = WB_DATA_TYPE(page,
-				f2fs_is_compressed_page(page));
 	int i;
 
 	if (unlikely(bio->bi_status))
@@ -1444,7 +1443,7 @@
 
 	f2fs_compress_free_page(page);
 
-	dec_page_count(sbi, type);
+	dec_page_count(sbi, F2FS_WB_DATA);
 
 	if (atomic_dec_return(&cic->pending_pages))
 		return;
@@ -1460,14 +1459,12 @@
 }
 
 static int f2fs_write_raw_pages(struct compress_ctx *cc,
-					int *submitted_p,
+					int *submitted,
 					struct writeback_control *wbc,
 					enum iostat_type io_type)
 {
 	struct address_space *mapping = cc->inode->i_mapping;
-	struct f2fs_sb_info *sbi = F2FS_M_SB(mapping);
-	int submitted, compr_blocks, i;
-	int ret = 0;
+	int _submitted, compr_blocks, ret, i;
 
 	compr_blocks = f2fs_compressed_blocks(cc);
 
@@ -1482,10 +1479,6 @@
 	if (compr_blocks < 0)
 		return compr_blocks;
 
-	/* overwrite compressed cluster w/ normal cluster */
-	if (compr_blocks > 0)
-		f2fs_lock_op(sbi);
-
 	for (i = 0; i < cc->cluster_size; i++) {
 		if (!cc->rpages[i])
 			continue;
@@ -1510,7 +1503,7 @@
 		if (!clear_page_dirty_for_io(cc->rpages[i]))
 			goto continue_unlock;
 
-		ret = f2fs_write_single_data_page(cc->rpages[i], &submitted,
+		ret = f2fs_write_single_data_page(cc->rpages[i], &_submitted,
 						NULL, NULL, wbc, io_type,
 						compr_blocks, false);
 		if (ret) {
@@ -1518,7 +1511,6 @@
 				unlock_page(cc->rpages[i]);
 				ret = 0;
 			} else if (ret == -EAGAIN) {
-				ret = 0;
 				/*
 				 * for quota file, just redirty left pages to
 				 * avoid deadlock caused by cluster update race
@@ -1525,22 +1517,20 @@
 				 * from foreground operation.
 				 */
 				if (IS_NOQUOTA(cc->inode))
-					goto out;
+					return 0;
+				ret = 0;
 				f2fs_io_schedule_timeout(DEFAULT_IO_TIMEOUT);
 				goto retry_write;
 			}
-			goto out;
+			return ret;
 		}
 
-		*submitted_p += submitted;
+		*submitted += _submitted;
 	}
 
-out:
-	if (compr_blocks > 0)
-		f2fs_unlock_op(sbi);
+	f2fs_balance_fs(F2FS_M_SB(mapping), true);
 
-	f2fs_balance_fs(sbi, true);
-	return ret;
+	return 0;
 }
 
 int f2fs_write_multi_pages(struct compress_ctx *cc,
@@ -1843,18 +1833,16 @@
  * check whether cluster blocks are contiguous, and add extent cache entry
  * only if cluster blocks are logically and physically contiguous.
  */
-unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn,
-						unsigned int ofs_in_node)
+unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn)
 {
-	bool compressed = data_blkaddr(dn->inode, dn->node_page,
-					ofs_in_node) == COMPRESS_ADDR;
+	bool compressed = f2fs_data_blkaddr(dn) == COMPRESS_ADDR;
 	int i = compressed ? 1 : 0;
 	block_t first_blkaddr = data_blkaddr(dn->inode, dn->node_page,
-							ofs_in_node + i);
+						dn->ofs_in_node + i);
 
 	for (i += 1; i < F2FS_I(dn->inode)->i_cluster_size; i++) {
 		block_t blkaddr = data_blkaddr(dn->inode, dn->node_page,
-							ofs_in_node + i);
+						dn->ofs_in_node + i);
 
 		if (!__is_valid_data_blkaddr(blkaddr))
 			break;
Index: fs/f2fs/f2fs.h
===================================================================
--- fs/f2fs/f2fs.h	(revision 55465)
+++ fs/f2fs/f2fs.h	(revision 55464)
@@ -74,11 +74,6 @@
 
 extern const char *f2fs_fault_name[FAULT_MAX];
 #define IS_FAULT_SET(fi, type) ((fi)->inject_type & BIT(type))
-
-/* maximum retry count for injected failure */
-#define DEFAULT_FAILURE_RETRY_COUNT		8
-#else
-#define DEFAULT_FAILURE_RETRY_COUNT		1
 #endif
 
 /*
@@ -769,6 +764,8 @@
 	FI_UPDATE_WRITE,	/* inode has in-place-update data */
 	FI_NEED_IPU,		/* used for ipu per file */
 	FI_ATOMIC_FILE,		/* indicate atomic file */
+	FI_FIRST_BLOCK_WRITTEN,	/* indicate #0 data block was written */
+	FI_DROP_CACHE,		/* drop dirty page cache */
 	FI_DATA_EXIST,		/* indicate data exists */
 	FI_INLINE_DOTS,		/* indicate inline dot dentries */
 	FI_SKIP_WRITES,		/* should skip data page writeback */
@@ -1070,8 +1067,7 @@
  * f2fs monitors the number of several block types such as on-writeback,
  * dirty dentry blocks, dirty node blocks, and dirty meta blocks.
  */
-#define WB_DATA_TYPE(p, f)			\
-	(f || f2fs_is_cp_guaranteed(p) ? F2FS_WB_CP_DATA : F2FS_WB_DATA)
+#define WB_DATA_TYPE(p)	(__is_cp_guaranteed(p) ? F2FS_WB_CP_DATA : F2FS_WB_DATA)
 enum count_type {
 	F2FS_DIRTY_DENTS,
 	F2FS_DIRTY_DATA,
@@ -1187,19 +1183,19 @@
 	struct page *encrypted_page;	/* encrypted page */
 	struct page *compressed_page;	/* compressed page */
 	struct list_head list;		/* serialize IOs */
-	unsigned int compr_blocks;	/* # of compressed block addresses */
-	unsigned int need_lock:8;	/* indicate we need to lock cp_rwsem */
-	unsigned int version:8;		/* version of the node */
-	unsigned int submitted:1;	/* indicate IO submission */
-	unsigned int in_list:1;		/* indicate fio is in io_list */
-	unsigned int is_por:1;		/* indicate IO is from recovery or not */
-	unsigned int retry:1;		/* need to reallocate block address */
-	unsigned int encrypted:1;	/* indicate file is encrypted */
-	unsigned int post_read:1;	/* require post read */
+	bool submitted;		/* indicate IO submission */
+	int need_lock;		/* indicate we need to lock cp_rwsem */
+	bool in_list;		/* indicate fio is in io_list */
+	bool is_por;		/* indicate IO is from recovery or not */
+	bool retry;		/* need to reallocate block address */
+	int compr_blocks;	/* # of compressed block addresses */
+	bool encrypted;		/* indicate file is encrypted */
+	bool post_read;		/* require post read */
 	enum iostat_type io_type;	/* io type */
 	struct writeback_control *io_wbc; /* writeback control */
 	struct bio **bio;		/* bio for ipu */
 	sector_t *last_block;		/* last block number in bio */
+	unsigned char version;		/* version of the node */
 };
 
 struct bio_entry {
@@ -2291,7 +2287,7 @@
 
 static inline void f2fs_i_blocks_write(struct inode *, block_t, bool, bool);
 static inline int inc_valid_block_count(struct f2fs_sb_info *sbi,
-				 struct inode *inode, blkcnt_t *count, bool partial)
+				 struct inode *inode, blkcnt_t *count)
 {
 	blkcnt_t diff = 0, release = 0;
 	block_t avail_user_block_count;
@@ -2332,11 +2328,6 @@
 			avail_user_block_count = 0;
 	}
 	if (unlikely(sbi->total_valid_block_count > avail_user_block_count)) {
-		if (!partial) {
-			spin_unlock(&sbi->stat_lock);
-			goto enospc;
-		}
-
 		diff = sbi->total_valid_block_count - avail_user_block_count;
 		if (diff > *count)
 			diff = *count;
@@ -3256,13 +3247,22 @@
 	return is_inode_flag_set(inode, FI_COW_FILE);
 }
 
-static inline __le32 *get_dnode_addr(struct inode *inode,
-					struct page *node_page);
+static inline bool f2fs_is_first_block_written(struct inode *inode)
+{
+	return is_inode_flag_set(inode, FI_FIRST_BLOCK_WRITTEN);
+}
+
+static inline bool f2fs_is_drop_cache(struct inode *inode)
+{
+	return is_inode_flag_set(inode, FI_DROP_CACHE);
+}
+
 static inline void *inline_data_addr(struct inode *inode, struct page *page)
 {
-	__le32 *addr = get_dnode_addr(inode, page);
+	struct f2fs_inode *ri = F2FS_INODE(page);
+	int extra_size = get_extra_isize(inode);
 
-	return (void *)(addr + DEF_INLINE_RESERVED_SIZE);
+	return (void *)&(ri->i_addr[extra_size + DEF_INLINE_RESERVED_SIZE]);
 }
 
 static inline int f2fs_has_inline_dentry(struct inode *inode)
@@ -3397,17 +3397,6 @@
 	return F2FS_I(inode)->i_inline_xattr_size;
 }
 
-static inline __le32 *get_dnode_addr(struct inode *inode,
-					struct page *node_page)
-{
-	int base = 0;
-
-	if (IS_INODE(node_page) && f2fs_has_extra_attr(inode))
-		base = get_extra_isize(inode);
-
-	return blkaddr_in_node(F2FS_NODE(node_page)) + base;
-}
-
 #define f2fs_get_inode_mode(i) \
 	((is_inode_flag_set(i, FI_ACL_MODE)) ? \
 	 (F2FS_I(i)->i_acl_mode) : ((i)->i_mode))
@@ -3772,7 +3761,6 @@
  */
 int __init f2fs_init_bioset(void);
 void f2fs_destroy_bioset(void);
-bool f2fs_is_cp_guaranteed(struct page *page);
 int f2fs_init_bio_entry_cache(void);
 void f2fs_destroy_bio_entry_cache(void);
 void f2fs_submit_bio(struct f2fs_sb_info *sbi,
@@ -3791,7 +3779,7 @@
 struct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,
 		block_t blk_addr, sector_t *sector);
 int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr);
-void f2fs_set_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr);
+void f2fs_set_data_blkaddr(struct dnode_of_data *dn);
 void f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr);
 int f2fs_reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count);
 int f2fs_reserve_new_block(struct dnode_of_data *dn);
@@ -4258,8 +4246,7 @@
 void f2fs_decompress_end_io(struct decompress_io_ctx *dic, bool failed,
 				bool in_task);
 void f2fs_put_page_dic(struct page *page, bool in_task);
-unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn,
-						unsigned int ofs_in_node);
+unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn);
 int f2fs_init_compress_ctx(struct compress_ctx *cc);
 void f2fs_destroy_compress_ctx(struct compress_ctx *cc, bool reuse);
 void f2fs_init_compress_info(struct f2fs_sb_info *sbi);
@@ -4316,8 +4303,7 @@
 {
 	WARN_ON_ONCE(1);
 }
-static inline unsigned int f2fs_cluster_blocks_are_contiguous(
-			struct dnode_of_data *dn, unsigned int ofs_in_node) { return 0; }
+static inline unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn) { return 0; }
 static inline bool f2fs_sanity_check_cluster(struct dnode_of_data *dn) { return false; }
 static inline int f2fs_init_compress_inode(struct f2fs_sb_info *sbi) { return 0; }
 static inline void f2fs_destroy_compress_inode(struct f2fs_sb_info *sbi) { }
@@ -4374,24 +4360,15 @@
 {
 	struct f2fs_inode_info *fi = F2FS_I(inode);
 
-	f2fs_down_write(&F2FS_I(inode)->i_sem);
-
-	if (!f2fs_compressed_file(inode)) {
-		f2fs_up_write(&F2FS_I(inode)->i_sem);
+	if (!f2fs_compressed_file(inode))
 		return true;
-	}
-	if (f2fs_is_mmap_file(inode) ||
-		(S_ISREG(inode->i_mode) && F2FS_HAS_BLOCKS(inode))) {
-		f2fs_up_write(&F2FS_I(inode)->i_sem);
+	if (S_ISREG(inode->i_mode) && F2FS_HAS_BLOCKS(inode))
 		return false;
-	}
 
 	fi->i_flags &= ~F2FS_COMPR_FL;
 	stat_dec_compr_inode(inode);
 	clear_inode_flag(inode, FI_COMPRESSED_FILE);
 	f2fs_mark_inode_dirty_sync(inode, true);
-
-	f2fs_up_write(&F2FS_I(inode)->i_sem);
 	return true;
 }
 
Index: fs/f2fs/super.c
===================================================================
--- fs/f2fs/super.c	(revision 55465)
+++ fs/f2fs/super.c	(revision 55464)
@@ -649,7 +649,7 @@
 #ifdef CONFIG_F2FS_FS_ZSTD
 static int f2fs_set_zstd_level(struct f2fs_sb_info *sbi, const char *str)
 {
-	int level;
+	unsigned int level;
 	int len = 4;
 
 	if (strlen(str) == len) {
@@ -663,15 +663,9 @@
 		f2fs_info(sbi, "wrong format, e.g. <alg_name>:<compr_level>");
 		return -EINVAL;
 	}
-	if (kstrtoint(str + 1, 10, &level))
+	if (kstrtouint(str + 1, 10, &level))
 		return -EINVAL;
 
-	/* f2fs does not support negative compress level now */
-	if (level < 0) {
-		f2fs_info(sbi, "do not support negative compress level: %d", level);
-		return -ERANGE;
-	}
-
 	if (!f2fs_is_compress_level_valid(COMPRESS_ZSTD, level)) {
 		f2fs_info(sbi, "invalid zstd compress level: %d", level);
 		return -EINVAL;
Index: fs/f2fs/file.c
===================================================================
--- fs/f2fs/file.c	(revision 55465)
+++ fs/f2fs/file.c	(revision 55464)
@@ -560,15 +560,21 @@
 void f2fs_truncate_data_blocks_range(struct dnode_of_data *dn, int count)
 {
 	struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);
+	struct f2fs_node *raw_node;
 	int nr_free = 0, ofs = dn->ofs_in_node, len = count;
 	__le32 *addr;
+	int base = 0;
 	bool compressed_cluster = false;
 	int cluster_index = 0, valid_blocks = 0;
 	int cluster_size = F2FS_I(dn->inode)->i_cluster_size;
 	bool released = !atomic_read(&F2FS_I(dn->inode)->i_compr_blocks);
 
-	addr = get_dnode_addr(dn->inode, dn->node_page) + ofs;
+	if (IS_INODE(dn->node_page) && f2fs_has_extra_attr(dn->inode))
+		base = get_extra_isize(dn->inode);
 
+	raw_node = F2FS_NODE(dn->node_page);
+	addr = blkaddr_in_node(raw_node) + base + ofs;
+
 	/* Assumption: truncateion starts with cluster */
 	for (; count > 0; count--, addr++, dn->ofs_in_node++, cluster_index++) {
 		block_t blkaddr = le32_to_cpu(*addr);
@@ -585,7 +591,8 @@
 		if (blkaddr == NULL_ADDR)
 			continue;
 
-		f2fs_set_data_blkaddr(dn, NULL_ADDR);
+		dn->data_blkaddr = NULL_ADDR;
+		f2fs_set_data_blkaddr(dn);
 
 		if (__is_valid_data_blkaddr(blkaddr)) {
 			if (!f2fs_is_valid_blkaddr(sbi, blkaddr,
@@ -595,6 +602,9 @@
 				valid_blocks++;
 		}
 
+		if (dn->ofs_in_node == 0 && IS_INODE(dn->node_page))
+			clear_inode_flag(dn->inode, FI_FIRST_BLOCK_WRITTEN);
+
 		f2fs_invalidate_blocks(sbi, blkaddr);
 
 		if (!released || blkaddr != COMPRESS_ADDR)
@@ -1487,7 +1497,8 @@
 		}
 
 		f2fs_invalidate_blocks(sbi, dn->data_blkaddr);
-		f2fs_set_data_blkaddr(dn, NEW_ADDR);
+		dn->data_blkaddr = NEW_ADDR;
+		f2fs_set_data_blkaddr(dn);
 	}
 
 	f2fs_update_read_extent_cache_range(dn, start, 0, index - start);
@@ -3438,7 +3449,8 @@
 			if (blkaddr != NEW_ADDR)
 				continue;
 
-			f2fs_set_data_blkaddr(dn, NULL_ADDR);
+			dn->data_blkaddr = NULL_ADDR;
+			f2fs_set_data_blkaddr(dn);
 		}
 
 		f2fs_i_compr_blocks_update(dn->inode, compr_blocks, false);
@@ -3462,7 +3474,7 @@
 	int ret;
 	int writecount;
 
-	if (!f2fs_sb_has_compression(sbi))
+	if (!f2fs_sb_has_compression(F2FS_I_SB(inode)))
 		return -EOPNOTSUPP;
 
 	if (!f2fs_compressed_file(inode))
@@ -3475,7 +3487,7 @@
 	if (ret)
 		return ret;
 
-	f2fs_balance_fs(sbi, true);
+	f2fs_balance_fs(F2FS_I_SB(inode), true);
 
 	inode_lock(inode);
 
@@ -3561,10 +3573,10 @@
 	return ret;
 }
 
-static int reserve_compress_blocks(struct dnode_of_data *dn, pgoff_t count,
-		unsigned int *reserved_blocks)
+static int reserve_compress_blocks(struct dnode_of_data *dn, pgoff_t count)
 {
 	struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);
+	unsigned int reserved_blocks = 0;
 	int cluster_size = F2FS_I(dn->inode)->i_cluster_size;
 	block_t blkaddr;
 	int i;
@@ -3587,53 +3599,41 @@
 		blkcnt_t reserved;
 		int ret;
 
-		for (i = 0; i < cluster_size; i++) {
-			blkaddr = data_blkaddr(dn->inode, dn->node_page,
-						dn->ofs_in_node + i);
+		for (i = 0; i < cluster_size; i++, dn->ofs_in_node++) {
+			blkaddr = f2fs_data_blkaddr(dn);
 
 			if (i == 0) {
-				if (blkaddr != COMPRESS_ADDR) {
-					dn->ofs_in_node += cluster_size;
-					goto next;
-				}
-				continue;
+				if (blkaddr == COMPRESS_ADDR)
+					continue;
+				dn->ofs_in_node += cluster_size;
+				goto next;
 			}
 
-			/*
-			 * compressed cluster was not released due to it
-			 * fails in release_compress_blocks(), so NEW_ADDR
-			 * is a possible case.
-			 */
-			if (blkaddr == NEW_ADDR ||
-				__is_valid_data_blkaddr(blkaddr)) {
+			if (__is_valid_data_blkaddr(blkaddr)) {
 				compr_blocks++;
 				continue;
 			}
+
+			dn->data_blkaddr = NEW_ADDR;
+			f2fs_set_data_blkaddr(dn);
 		}
 
 		reserved = cluster_size - compr_blocks;
-
-		/* for the case all blocks in cluster were reserved */
-		if (reserved == 1)
-			goto next;
-
-		ret = inc_valid_block_count(sbi, dn->inode, &reserved, false);
-		if (unlikely(ret))
+		ret = inc_valid_block_count(sbi, dn->inode, &reserved);
+		if (ret)
 			return ret;
 
-		for (i = 0; i < cluster_size; i++, dn->ofs_in_node++) {
-			if (f2fs_data_blkaddr(dn) == NULL_ADDR)
-				f2fs_set_data_blkaddr(dn, NEW_ADDR);
-		}
+		if (reserved != cluster_size - compr_blocks)
+			return -ENOSPC;
 
 		f2fs_i_compr_blocks_update(dn->inode, compr_blocks, true);
 
-		*reserved_blocks += reserved;
+		reserved_blocks += reserved;
 next:
 		count -= cluster_size;
 	}
 
-	return 0;
+	return reserved_blocks;
 }
 
 static int f2fs_reserve_compress_blocks(struct file *filp, unsigned long arg)
@@ -3644,7 +3644,7 @@
 	unsigned int reserved_blocks = 0;
 	int ret;
 
-	if (!f2fs_sb_has_compression(sbi))
+	if (!f2fs_sb_has_compression(F2FS_I_SB(inode)))
 		return -EOPNOTSUPP;
 
 	if (!f2fs_compressed_file(inode))
@@ -3657,8 +3657,11 @@
 	if (ret)
 		return ret;
 
-	f2fs_balance_fs(sbi, true);
+	if (atomic_read(&F2FS_I(inode)->i_compr_blocks))
+		goto out;
 
+	f2fs_balance_fs(F2FS_I_SB(inode), true);
+
 	inode_lock(inode);
 
 	if (!is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {
@@ -3666,9 +3669,6 @@
 		goto unlock_inode;
 	}
 
-	if (atomic_read(&F2FS_I(inode)->i_compr_blocks))
-		goto unlock_inode;
-
 	f2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
 	filemap_invalidate_lock(inode->i_mapping);
 
@@ -3694,7 +3694,7 @@
 		count = min(end_offset - dn.ofs_in_node, last_idx - page_idx);
 		count = round_up(count, F2FS_I(inode)->i_cluster_size);
 
-		ret = reserve_compress_blocks(&dn, count, &reserved_blocks);
+		ret = reserve_compress_blocks(&dn, count);
 
 		f2fs_put_dnode(&dn);
 
@@ -3702,12 +3702,13 @@
 			break;
 
 		page_idx += count;
+		reserved_blocks += ret;
 	}
 
 	filemap_invalidate_unlock(inode->i_mapping);
 	f2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
 
-	if (!ret) {
+	if (ret >= 0) {
 		clear_inode_flag(inode, FI_COMPRESS_RELEASED);
 		inode->i_ctime = current_time(inode);
 		f2fs_mark_inode_dirty_sync(inode, true);
@@ -3714,9 +3715,10 @@
 	}
 unlock_inode:
 	inode_unlock(inode);
+out:
 	mnt_drop_write_file(filp);
 
-	if (!ret) {
+	if (ret >= 0) {
 		ret = put_user(reserved_blocks, (u64 __user *)arg);
 	} else if (reserved_blocks &&
 			atomic_read(&F2FS_I(inode)->i_compr_blocks)) {
@@ -3965,9 +3967,10 @@
 				sizeof(option)))
 		return -EFAULT;
 
-	if (option.log_cluster_size < MIN_COMPRESS_LOG_SIZE ||
-		option.log_cluster_size > MAX_COMPRESS_LOG_SIZE ||
-		option.algorithm >= COMPRESS_MAX)
+	if (!f2fs_compressed_file(inode) ||
+			option.log_cluster_size < MIN_COMPRESS_LOG_SIZE ||
+			option.log_cluster_size > MAX_COMPRESS_LOG_SIZE ||
+			option.algorithm >= COMPRESS_MAX)
 		return -EINVAL;
 
 	file_start_write(filp);
@@ -3974,11 +3977,6 @@
 	inode_lock(inode);
 
 	f2fs_down_write(&F2FS_I(inode)->i_sem);
-	if (!f2fs_compressed_file(inode)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
 	if (f2fs_is_mmap_file(inode) || get_dirty_pages(inode)) {
 		ret = -EBUSY;
 		goto out;
@@ -4068,7 +4066,7 @@
 	if (!f2fs_compressed_file(inode))
 		return -EINVAL;
 
-	f2fs_balance_fs(sbi, true);
+	f2fs_balance_fs(F2FS_I_SB(inode), true);
 
 	file_start_write(filp);
 	inode_lock(inode);
@@ -4140,7 +4138,7 @@
 	if (!f2fs_compressed_file(inode))
 		return -EINVAL;
 
-	f2fs_balance_fs(sbi, true);
+	f2fs_balance_fs(F2FS_I_SB(inode), true);
 
 	file_start_write(filp);
 	inode_lock(inode);
Index: fs/f2fs/recovery.c
===================================================================
--- fs/f2fs/recovery.c	(revision 55465)
+++ fs/f2fs/recovery.c	(revision 55464)
@@ -582,19 +582,6 @@
 	return 0;
 }
 
-static int f2fs_reserve_new_block_retry(struct dnode_of_data *dn)
-{
-	int i, err = 0;
-
-	for (i = DEFAULT_FAILURE_RETRY_COUNT; i > 0; i--) {
-		err = f2fs_reserve_new_block(dn);
-		if (!err)
-			break;
-	}
-
-	return err;
-}
-
 static int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,
 					struct page *page)
 {
@@ -696,8 +683,14 @@
 		 */
 		if (dest == NEW_ADDR) {
 			f2fs_truncate_data_blocks_range(&dn, 1);
-
-			err = f2fs_reserve_new_block_retry(&dn);
+			do {
+				err = f2fs_reserve_new_block(&dn);
+				if (err == -ENOSPC) {
+					f2fs_bug_on(sbi, 1);
+					break;
+				}
+			} while (err &&
+				IS_ENABLED(CONFIG_F2FS_FAULT_INJECTION));
 			if (err)
 				goto err;
 			continue;
@@ -705,8 +698,16 @@
 
 		/* dest is valid block, try to recover from src to dest */
 		if (f2fs_is_valid_blkaddr(sbi, dest, META_POR)) {
+
 			if (src == NULL_ADDR) {
-				err = f2fs_reserve_new_block_retry(&dn);
+				do {
+					err = f2fs_reserve_new_block(&dn);
+					if (err == -ENOSPC) {
+						f2fs_bug_on(sbi, 1);
+						break;
+					}
+				} while (err &&
+					IS_ENABLED(CONFIG_F2FS_FAULT_INJECTION));
 				if (err)
 					goto err;
 			}
Index: fs/f2fs/data.c
===================================================================
--- fs/f2fs/data.c	(revision 55465)
+++ fs/f2fs/data.c	(revision 55464)
@@ -50,7 +50,7 @@
 	bioset_exit(&f2fs_bioset);
 }
 
-bool f2fs_is_cp_guaranteed(struct page *page)
+static bool __is_cp_guaranteed(struct page *page)
 {
 	struct address_space *mapping = page->mapping;
 	struct inode *inode;
@@ -67,6 +67,8 @@
 			S_ISDIR(inode->i_mode))
 		return true;
 
+	if (f2fs_is_compressed_page(page))
+		return false;
 	if ((S_ISREG(inode->i_mode) && IS_NOQUOTA(inode)) ||
 			page_private_gcing(page))
 		return true;
@@ -325,7 +327,7 @@
 
 	bio_for_each_segment_all(bvec, bio, iter_all) {
 		struct page *page = bvec->bv_page;
-		enum count_type type = WB_DATA_TYPE(page, false);
+		enum count_type type = WB_DATA_TYPE(page);
 
 		if (page_private_dummy(page)) {
 			clear_page_private_dummy(page);
@@ -731,7 +733,7 @@
 		wbc_account_cgroup_owner(fio->io_wbc, fio->page, PAGE_SIZE);
 
 	inc_page_count(fio->sbi, is_read_io(fio->op) ?
-			__read_io_type(page) : WB_DATA_TYPE(fio->page, false));
+			__read_io_type(page) : WB_DATA_TYPE(fio->page));
 
 	__submit_bio(fio->sbi, bio, fio->type);
 	return 0;
@@ -939,7 +941,7 @@
 	if (fio->io_wbc)
 		wbc_account_cgroup_owner(fio->io_wbc, fio->page, PAGE_SIZE);
 
-	inc_page_count(fio->sbi, WB_DATA_TYPE(page, false));
+	inc_page_count(fio->sbi, WB_DATA_TYPE(page));
 
 	*fio->last_block = fio->new_blkaddr;
 	*fio->bio = bio;
@@ -953,7 +955,6 @@
 	enum page_type btype = PAGE_TYPE_OF_BIO(fio->type);
 	struct f2fs_bio_info *io = sbi->write_io[btype] + fio->temp;
 	struct page *bio_page;
-	enum count_type type;
 
 	f2fs_bug_on(sbi, is_read_io(fio->op));
 
@@ -981,10 +982,9 @@
 		bio_page = fio->page;
 
 	/* set submitted = true as a return value */
-	fio->submitted = 1;
+	fio->submitted = true;
 
-	type = WB_DATA_TYPE(bio_page, fio->compressed_page);
-	inc_page_count(sbi, type);
+	inc_page_count(sbi, WB_DATA_TYPE(bio_page));
 
 	if (io->bio &&
 	    (!io_is_mergeable(sbi, io->bio, io, fio, io->last_block_in_bio,
@@ -997,9 +997,8 @@
 		if (F2FS_IO_ALIGNED(sbi) &&
 				(fio->type == DATA || fio->type == NODE) &&
 				fio->new_blkaddr & F2FS_IO_SIZE_MASK(sbi)) {
-			dec_page_count(sbi, WB_DATA_TYPE(bio_page,
-						fio->compressed_page));
-			fio->retry = 1;
+			dec_page_count(sbi, WB_DATA_TYPE(bio_page));
+			fio->retry = true;
 			goto skip;
 		}
 		io->bio = __bio_alloc(fio, BIO_MAX_VECS);
@@ -1103,12 +1102,18 @@
 	return 0;
 }
 
-static void __set_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr)
+static void __set_data_blkaddr(struct dnode_of_data *dn)
 {
-	__le32 *addr = get_dnode_addr(dn->inode, dn->node_page);
+	struct f2fs_node *rn = F2FS_NODE(dn->node_page);
+	__le32 *addr_array;
+	int base = 0;
 
-	dn->data_blkaddr = blkaddr;
-	addr[dn->ofs_in_node] = cpu_to_le32(dn->data_blkaddr);
+	if (IS_INODE(dn->node_page) && f2fs_has_extra_attr(dn->inode))
+		base = get_extra_isize(dn->inode);
+
+	/* Get physical address of data block */
+	addr_array = blkaddr_in_node(rn);
+	addr_array[base + dn->ofs_in_node] = cpu_to_le32(dn->data_blkaddr);
 }
 
 /*
@@ -1117,10 +1122,10 @@
  *  ->node_page
  *    update block addresses in the node page
  */
-void f2fs_set_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr)
+void f2fs_set_data_blkaddr(struct dnode_of_data *dn)
 {
 	f2fs_wait_on_page_writeback(dn->node_page, NODE, true, true);
-	__set_data_blkaddr(dn, blkaddr);
+	__set_data_blkaddr(dn);
 	if (set_page_dirty(dn->node_page))
 		dn->node_changed = true;
 }
@@ -1127,7 +1132,8 @@
 
 void f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr)
 {
-	f2fs_set_data_blkaddr(dn, blkaddr);
+	dn->data_blkaddr = blkaddr;
+	f2fs_set_data_blkaddr(dn);
 	f2fs_update_read_extent_cache(dn);
 }
 
@@ -1142,8 +1148,7 @@
 
 	if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))
 		return -EPERM;
-	err = inc_valid_block_count(sbi, dn->inode, &count, true);
-	if (unlikely(err))
+	if (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))
 		return err;
 
 	trace_f2fs_reserve_new_blocks(dn->inode, dn->nid,
@@ -1155,7 +1160,8 @@
 		block_t blkaddr = f2fs_data_blkaddr(dn);
 
 		if (blkaddr == NULL_ADDR) {
-			__set_data_blkaddr(dn, NEW_ADDR);
+			dn->data_blkaddr = NEW_ADDR;
+			__set_data_blkaddr(dn);
 			count--;
 		}
 	}
@@ -1413,12 +1419,13 @@
 		return err;
 
 	dn->data_blkaddr = f2fs_data_blkaddr(dn);
-	if (dn->data_blkaddr == NULL_ADDR) {
-		err = inc_valid_block_count(sbi, dn->inode, &count, true);
-		if (unlikely(err))
-			return err;
-	}
+	if (dn->data_blkaddr != NULL_ADDR)
+		goto alloc;
 
+	if (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))
+		return err;
+
+alloc:
 	set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);
 	old_blkaddr = dn->data_blkaddr;
 	f2fs_allocate_data_block(sbi, NULL, old_blkaddr, &dn->data_blkaddr,
@@ -2732,6 +2739,8 @@
 	f2fs_outplace_write_data(&dn, fio);
 	trace_f2fs_do_write_data_page(page, OPU);
 	set_inode_flag(inode, FI_APPEND_WRITE);
+	if (page->index == 0)
+		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
 out_writepage:
 	f2fs_put_dnode(&dn);
 out:
@@ -2767,10 +2776,10 @@
 		.old_blkaddr = NULL_ADDR,
 		.page = page,
 		.encrypted_page = NULL,
-		.submitted = 0,
+		.submitted = false,
 		.compr_blocks = compr_blocks,
-		.need_lock = compr_blocks ? LOCK_DONE : LOCK_RETRY,
-		.post_read = f2fs_post_read_required(inode) ? 1 : 0,
+		.need_lock = LOCK_RETRY,
+		.post_read = f2fs_post_read_required(inode),
 		.io_type = io_type,
 		.io_wbc = wbc,
 		.bio = bio,
@@ -2810,6 +2819,9 @@
 
 	zero_user_segment(page, offset, PAGE_SIZE);
 write:
+	if (f2fs_is_drop_cache(inode))
+		goto out;
+
 	/* Dentry/quota blocks are controlled by checkpoint */
 	if (S_ISDIR(inode->i_mode) || quota_inode) {
 		/*
@@ -2846,7 +2858,6 @@
 	if (err == -EAGAIN) {
 		err = f2fs_do_write_data_page(&fio);
 		if (err == -EAGAIN) {
-			f2fs_bug_on(sbi, compr_blocks);
 			fio.need_lock = LOCK_REQ;
 			err = f2fs_do_write_data_page(&fio);
 		}
@@ -2891,7 +2902,7 @@
 	}
 
 	if (submitted)
-		*submitted = fio.submitted;
+		*submitted = fio.submitted ? 1 : 0;
 
 	return 0;
 
Index: fs/f2fs/node.c
===================================================================
--- fs/f2fs/node.c	(revision 55465)
+++ fs/f2fs/node.c	(revision 55464)
@@ -850,29 +850,21 @@
 
 	if (is_inode_flag_set(dn->inode, FI_COMPRESSED_FILE) &&
 					f2fs_sb_has_readonly(sbi)) {
-		unsigned int cluster_size = F2FS_I(dn->inode)->i_cluster_size;
-		unsigned int ofs_in_node = dn->ofs_in_node;
-		pgoff_t fofs = index;
-		unsigned int c_len;
+		unsigned int c_len = f2fs_cluster_blocks_are_contiguous(dn);
 		block_t blkaddr;
 
-		/* should align fofs and ofs_in_node to cluster_size */
-		if (fofs % cluster_size) {
-			fofs = round_down(fofs, cluster_size);
-			ofs_in_node = round_down(ofs_in_node, cluster_size);
-		}
-
-		c_len = f2fs_cluster_blocks_are_contiguous(dn, ofs_in_node);
 		if (!c_len)
 			goto out;
 
-		blkaddr = data_blkaddr(dn->inode, dn->node_page, ofs_in_node);
+		blkaddr = f2fs_data_blkaddr(dn);
 		if (blkaddr == COMPRESS_ADDR)
 			blkaddr = data_blkaddr(dn->inode, dn->node_page,
-						ofs_in_node + 1);
+						dn->ofs_in_node + 1);
 
 		f2fs_update_read_extent_tree_range_compressed(dn->inode,
-					fofs, blkaddr, cluster_size, c_len);
+					index, blkaddr,
+					F2FS_I(dn->inode)->i_cluster_size,
+					c_len);
 	}
 out:
 	return 0;
@@ -1595,7 +1587,7 @@
 		.op_flags = wbc_to_write_flags(wbc),
 		.page = page,
 		.encrypted_page = NULL,
-		.submitted = 0,
+		.submitted = false,
 		.io_type = io_type,
 		.io_wbc = wbc,
 	};
Index: fs/f2fs/checkpoint.c
===================================================================
--- fs/f2fs/checkpoint.c	(revision 55465)
+++ fs/f2fs/checkpoint.c	(revision 55464)
@@ -70,7 +70,7 @@
 		.old_blkaddr = index,
 		.new_blkaddr = index,
 		.encrypted_page = NULL,
-		.is_por = !is_meta ? 1 : 0,
+		.is_por = !is_meta,
 	};
 	int err;
 
@@ -234,8 +234,8 @@
 		.op = REQ_OP_READ,
 		.op_flags = sync ? (REQ_META | REQ_PRIO) : REQ_RAHEAD,
 		.encrypted_page = NULL,
-		.in_list = 0,
-		.is_por = (type == META_POR) ? 1 : 0,
+		.in_list = false,
+		.is_por = (type == META_POR),
 	};
 	struct blk_plug plug;
 	int err;
Index: fs/f2fs/inode.c
===================================================================
--- fs/f2fs/inode.c	(revision 55465)
+++ fs/f2fs/inode.c	(revision 55464)
@@ -59,31 +59,49 @@
 			S_ENCRYPTED|S_VERITY|S_CASEFOLD);
 }
 
-static void __get_inode_rdev(struct inode *inode, struct page *node_page)
+static void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)
 {
-	__le32 *addr = get_dnode_addr(inode, node_page);
+	int extra_size = get_extra_isize(inode);
 
 	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
 			S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
-		if (addr[0])
-			inode->i_rdev = old_decode_dev(le32_to_cpu(addr[0]));
+		if (ri->i_addr[extra_size])
+			inode->i_rdev = old_decode_dev(
+				le32_to_cpu(ri->i_addr[extra_size]));
 		else
-			inode->i_rdev = new_decode_dev(le32_to_cpu(addr[1]));
+			inode->i_rdev = new_decode_dev(
+				le32_to_cpu(ri->i_addr[extra_size + 1]));
 	}
 }
 
-static void __set_inode_rdev(struct inode *inode, struct page *node_page)
+static int __written_first_block(struct f2fs_sb_info *sbi,
+					struct f2fs_inode *ri)
 {
-	__le32 *addr = get_dnode_addr(inode, node_page);
+	block_t addr = le32_to_cpu(ri->i_addr[offset_in_addr(ri)]);
 
+	if (!__is_valid_data_blkaddr(addr))
+		return 1;
+	if (!f2fs_is_valid_blkaddr(sbi, addr, DATA_GENERIC_ENHANCE)) {
+		f2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);
+		return -EFSCORRUPTED;
+	}
+	return 0;
+}
+
+static void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)
+{
+	int extra_size = get_extra_isize(inode);
+
 	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
 		if (old_valid_dev(inode->i_rdev)) {
-			addr[0] = cpu_to_le32(old_encode_dev(inode->i_rdev));
-			addr[1] = 0;
+			ri->i_addr[extra_size] =
+				cpu_to_le32(old_encode_dev(inode->i_rdev));
+			ri->i_addr[extra_size + 1] = 0;
 		} else {
-			addr[0] = 0;
-			addr[1] = cpu_to_le32(new_encode_dev(inode->i_rdev));
-			addr[2] = 0;
+			ri->i_addr[extra_size] = 0;
+			ri->i_addr[extra_size + 1] =
+				cpu_to_le32(new_encode_dev(inode->i_rdev));
+			ri->i_addr[extra_size + 2] = 0;
 		}
 	}
 }
@@ -318,6 +336,7 @@
 	struct page *node_page;
 	struct f2fs_inode *ri;
 	projid_t i_projid;
+	int err;
 
 	/* Check if ino is within scope */
 	if (f2fs_check_nid_range(sbi, inode->i_ino))
@@ -396,8 +415,18 @@
 	}
 
 	/* get rdev by using inline_info */
-	__get_inode_rdev(inode, node_page);
+	__get_inode_rdev(inode, ri);
 
+	if (S_ISREG(inode->i_mode)) {
+		err = __written_first_block(sbi, ri);
+		if (err < 0) {
+			f2fs_put_page(node_page, 1);
+			return err;
+		}
+		if (!err)
+			set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
+	}
+
 	if (!f2fs_need_inode_block_update(sbi, inode->i_ino))
 		fi->last_disk_size = inode->i_size;
 
@@ -668,7 +697,7 @@
 		}
 	}
 
-	__set_inode_rdev(inode, node_page);
+	__set_inode_rdev(inode, ri);
 
 	/* deleted inode */
 	if (inode->i_nlink == 0)
Index: fs/f2fs/gc.c
===================================================================
--- fs/f2fs/gc.c	(revision 55465)
+++ fs/f2fs/gc.c	(revision 55464)
@@ -1187,8 +1187,8 @@
 		.op = REQ_OP_READ,
 		.op_flags = 0,
 		.encrypted_page = NULL,
-		.in_list = 0,
-		.retry = 0,
+		.in_list = false,
+		.retry = false,
 	};
 	int err;
 
@@ -1276,8 +1276,8 @@
 		.op = REQ_OP_READ,
 		.op_flags = 0,
 		.encrypted_page = NULL,
-		.in_list = 0,
-		.retry = 0,
+		.in_list = false,
+		.retry = false,
 	};
 	struct dnode_of_data dn;
 	struct f2fs_summary sum;
@@ -1410,6 +1410,8 @@
 
 	f2fs_update_data_blkaddr(&dn, newaddr);
 	set_inode_flag(inode, FI_APPEND_WRITE);
+	if (page->index == 0)
+		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
 put_page_out:
 	f2fs_put_page(fio.encrypted_page, 1);
 recover_block:
Index: fs/f2fs/segment.c
===================================================================
--- fs/f2fs/segment.c	(revision 55465)
+++ fs/f2fs/segment.c	(revision 55464)
@@ -247,7 +247,7 @@
 	} else {
 		blkcnt_t count = 1;
 
-		err = inc_valid_block_count(sbi, inode, &count, true);
+		err = inc_valid_block_count(sbi, inode, &count);
 		if (err) {
 			f2fs_put_dnode(&dn);
 			return err;
@@ -3312,10 +3312,10 @@
 		struct f2fs_bio_info *io;
 
 		if (F2FS_IO_ALIGNED(sbi))
-			fio->retry = 0;
+			fio->retry = false;
 
 		INIT_LIST_HEAD(&fio->list);
-		fio->in_list = 1;
+		fio->in_list = true;
 		io = sbi->write_io[fio->type] + fio->temp;
 		spin_lock(&io->io_lock);
 		list_add_tail(&fio->list, &io->io_list);
@@ -3396,7 +3396,7 @@
 		.new_blkaddr = page->index,
 		.page = page,
 		.encrypted_page = NULL,
-		.in_list = 0,
+		.in_list = false,
 	};
 
 	if (unlikely(page->index >= MAIN_BLKADDR(sbi)))
Index: fs/f2fs/segment.h
===================================================================
--- fs/f2fs/segment.h	(revision 55465)
+++ fs/f2fs/segment.h	(revision 55464)
@@ -586,22 +586,23 @@
 			unsigned int node_blocks, unsigned int dent_blocks)
 {
 
-	unsigned segno, left_blocks;
+	unsigned int segno, left_blocks;
 	int i;
 
-	/* check current node sections in the worst case. */
+	/* check current node segment */
 	for (i = CURSEG_HOT_NODE; i <= CURSEG_COLD_NODE; i++) {
 		segno = CURSEG_I(sbi, i)->segno;
-		left_blocks = CAP_BLKS_PER_SEC(sbi) -
-				get_ckpt_valid_blocks(sbi, segno, true);
+		left_blocks = f2fs_usable_blks_in_seg(sbi, segno) -
+				get_seg_entry(sbi, segno)->ckpt_valid_blocks;
+
 		if (node_blocks > left_blocks)
 			return false;
 	}
 
-	/* check current data section for dentry blocks. */
+	/* check current data segment */
 	segno = CURSEG_I(sbi, CURSEG_HOT_DATA)->segno;
-	left_blocks = CAP_BLKS_PER_SEC(sbi) -
-			get_ckpt_valid_blocks(sbi, segno, true);
+	left_blocks = f2fs_usable_blks_in_seg(sbi, segno) -
+			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
 	if (dent_blocks > left_blocks)
 		return false;
 	return true;
@@ -650,7 +651,7 @@
 
 	if (free_secs > upper_secs)
 		return false;
-	if (free_secs <= lower_secs)
+	else if (free_secs <= lower_secs)
 		return true;
 	return !curseg_space;
 }
Index: fs/pstore/inode.c
===================================================================
--- fs/pstore/inode.c	(revision 55465)
+++ fs/pstore/inode.c	(revision 55464)
@@ -182,21 +182,25 @@
 {
 	struct pstore_private *p = d_inode(dentry)->i_private;
 	struct pstore_record *record = p->record;
+	int rc = 0;
 
 	if (!record->psi->erase)
 		return -EPERM;
 
 	/* Make sure we can't race while removing this file. */
-	scoped_guard(mutex, &records_list_lock) {
-		if (!list_empty(&p->list))
-			list_del_init(&p->list);
-		else
-			return -ENOENT;
-		p->dentry = NULL;
-	}
+	mutex_lock(&records_list_lock);
+	if (!list_empty(&p->list))
+		list_del_init(&p->list);
+	else
+		rc = -ENOENT;
+	p->dentry = NULL;
+	mutex_unlock(&records_list_lock);
+	if (rc)
+		return rc;
 
-	scoped_guard(mutex, &record->psi->read_mutex)
-		record->psi->erase(record);
+	mutex_lock(&record->psi->read_mutex);
+	record->psi->erase(record);
+	mutex_unlock(&record->psi->read_mutex);
 
 	return simple_unlink(dir, dentry);
 }
@@ -288,16 +292,19 @@
 {
 	struct dentry *root;
 
-	guard(mutex)(&pstore_sb_lock);
+	mutex_lock(&pstore_sb_lock);
 	/*
 	 * Having no backend is fine -- no records appear.
 	 * Not being mounted is fine -- nothing to do.
 	 */
-	if (!psinfo || !pstore_sb)
+	if (!psinfo || !pstore_sb) {
+		mutex_unlock(&pstore_sb_lock);
 		return NULL;
+	}
 
 	root = pstore_sb->s_root;
 	inode_lock(d_inode(root));
+	mutex_unlock(&pstore_sb_lock);
 
 	return root;
 }
@@ -306,25 +313,29 @@
 {
 	struct pstore_private *pos, *tmp;
 	struct dentry *root;
+	int rc = 0;
 
 	root = psinfo_lock_root();
 	if (!root)
 		return 0;
 
-	scoped_guard(mutex, &records_list_lock) {
-		list_for_each_entry_safe(pos, tmp, &records_list, list) {
-			if (pos->record->psi == psi) {
-				list_del_init(&pos->list);
-				d_invalidate(pos->dentry);
-				simple_unlink(d_inode(root), pos->dentry);
-				pos->dentry = NULL;
-			}
+	mutex_lock(&records_list_lock);
+	list_for_each_entry_safe(pos, tmp, &records_list, list) {
+		if (pos->record->psi == psi) {
+			list_del_init(&pos->list);
+			rc = simple_unlink(d_inode(root), pos->dentry);
+			if (WARN_ON(rc))
+				break;
+			d_drop(pos->dentry);
+			dput(pos->dentry);
+			pos->dentry = NULL;
 		}
 	}
+	mutex_unlock(&records_list_lock);
 
 	inode_unlock(d_inode(root));
 
-	return 0;
+	return rc;
 }
 
 /*
@@ -344,20 +355,20 @@
 	if (WARN_ON(!inode_is_locked(d_inode(root))))
 		return -EINVAL;
 
-	guard(mutex)(&records_list_lock);
-
+	rc = -EEXIST;
 	/* Skip records that are already present in the filesystem. */
+	mutex_lock(&records_list_lock);
 	list_for_each_entry(pos, &records_list, list) {
 		if (pos->record->type == record->type &&
 		    pos->record->id == record->id &&
 		    pos->record->psi == record->psi)
-			return -EEXIST;
+			goto fail;
 	}
 
 	rc = -ENOMEM;
 	inode = pstore_get_inode(root->d_sb);
 	if (!inode)
-		return -ENOMEM;
+		goto fail;
 	inode->i_mode = S_IFREG | 0444;
 	inode->i_fop = &pstore_file_operations;
 	scnprintf(name, sizeof(name), "%s-%s-%llu%s",
@@ -384,6 +395,7 @@
 	d_add(dentry, inode);
 
 	list_add(&private->list, &records_list);
+	mutex_unlock(&records_list_lock);
 
 	return 0;
 
@@ -391,6 +403,8 @@
 	free_pstore_private(private);
 fail_inode:
 	iput(inode);
+fail:
+	mutex_unlock(&records_list_lock);
 	return rc;
 }
 
@@ -436,8 +450,9 @@
 	if (!sb->s_root)
 		return -ENOMEM;
 
-	scoped_guard(mutex, &pstore_sb_lock)
-		pstore_sb = sb;
+	mutex_lock(&pstore_sb_lock);
+	pstore_sb = sb;
+	mutex_unlock(&pstore_sb_lock);
 
 	pstore_get_records(0);
 
@@ -452,14 +467,17 @@
 
 static void pstore_kill_sb(struct super_block *sb)
 {
-	guard(mutex)(&pstore_sb_lock);
+	mutex_lock(&pstore_sb_lock);
 	WARN_ON(pstore_sb && pstore_sb != sb);
 
 	kill_litter_super(sb);
 	pstore_sb = NULL;
 
-	guard(mutex)(&records_list_lock);
+	mutex_lock(&records_list_lock);
 	INIT_LIST_HEAD(&records_list);
+	mutex_unlock(&records_list_lock);
+
+	mutex_unlock(&pstore_sb_lock);
 }
 
 static struct file_system_type pstore_fs_type = {
Index: fs/quota/dquot.c
===================================================================
--- fs/quota/dquot.c	(revision 55465)
+++ fs/quota/dquot.c	(revision 55464)
@@ -399,17 +399,15 @@
 EXPORT_SYMBOL(dquot_mark_dquot_dirty);
 
 /* Dirtify all the dquots - this can block when journalling */
-static inline int mark_all_dquot_dirty(struct dquot __rcu * const *dquots)
+static inline int mark_all_dquot_dirty(struct dquot * const *dquot)
 {
 	int ret, err, cnt;
-	struct dquot *dquot;
 
 	ret = err = 0;
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (dquot)
+		if (dquot[cnt])
 			/* Even in case of error we have to continue */
-			ret = mark_dquot_dirty(dquot);
+			ret = mark_dquot_dirty(dquot[cnt]);
 		if (!err)
 			err = ret;
 	}
@@ -1006,15 +1004,14 @@
 }
 EXPORT_SYMBOL(dqget);
 
-static inline struct dquot __rcu **i_dquot(struct inode *inode)
+static inline struct dquot **i_dquot(struct inode *inode)
 {
-	/* Force __rcu for now until filesystems are fixed */
-	return (struct dquot __rcu **)inode->i_sb->s_op->get_dquots(inode);
+	return inode->i_sb->s_op->get_dquots(inode);
 }
 
 static int dqinit_needed(struct inode *inode, int type)
 {
-	struct dquot __rcu * const *dquots;
+	struct dquot * const *dquots;
 	int cnt;
 
 	if (IS_NOQUOTA(inode))
@@ -1087,8 +1084,60 @@
 	return err;
 }
 
-static void remove_dquot_ref(struct super_block *sb, int type)
+/*
+ * Remove references to dquots from inode and add dquot to list for freeing
+ * if we have the last reference to dquot
+ */
+static void remove_inode_dquot_ref(struct inode *inode, int type,
+				   struct list_head *tofree_head)
 {
+	struct dquot **dquots = i_dquot(inode);
+	struct dquot *dquot = dquots[type];
+
+	if (!dquot)
+		return;
+
+	dquots[type] = NULL;
+	if (list_empty(&dquot->dq_free)) {
+		/*
+		 * The inode still has reference to dquot so it can't be in the
+		 * free list
+		 */
+		spin_lock(&dq_list_lock);
+		list_add(&dquot->dq_free, tofree_head);
+		spin_unlock(&dq_list_lock);
+	} else {
+		/*
+		 * Dquot is already in a list to put so we won't drop the last
+		 * reference here.
+		 */
+		dqput(dquot);
+	}
+}
+
+/*
+ * Free list of dquots
+ * Dquots are removed from inodes and no new references can be got so we are
+ * the only ones holding reference
+ */
+static void put_dquot_list(struct list_head *tofree_head)
+{
+	struct list_head *act_head;
+	struct dquot *dquot;
+
+	act_head = tofree_head->next;
+	while (act_head != tofree_head) {
+		dquot = list_entry(act_head, struct dquot, dq_free);
+		act_head = act_head->next;
+		/* Remove dquot from the list so we won't have problems... */
+		list_del_init(&dquot->dq_free);
+		dqput(dquot);
+	}
+}
+
+static void remove_dquot_ref(struct super_block *sb, int type,
+		struct list_head *tofree_head)
+{
 	struct inode *inode;
 #ifdef CONFIG_QUOTA_DEBUG
 	int reserved = 0;
@@ -1104,18 +1153,11 @@
 		 */
 		spin_lock(&dq_data_lock);
 		if (!IS_NOQUOTA(inode)) {
-			struct dquot __rcu **dquots = i_dquot(inode);
-			struct dquot *dquot = srcu_dereference_check(
-				dquots[type], &dquot_srcu,
-				lockdep_is_held(&dq_data_lock));
-
 #ifdef CONFIG_QUOTA_DEBUG
 			if (unlikely(inode_get_rsv_space(inode) > 0))
 				reserved = 1;
 #endif
-			rcu_assign_pointer(dquots[type], NULL);
-			if (dquot)
-				dqput(dquot);
+			remove_inode_dquot_ref(inode, type, tofree_head);
 		}
 		spin_unlock(&dq_data_lock);
 	}
@@ -1132,8 +1174,13 @@
 /* Gather all references from inodes and drop them */
 static void drop_dquot_ref(struct super_block *sb, int type)
 {
-	if (sb->dq_op)
-		remove_dquot_ref(sb, type);
+	LIST_HEAD(tofree_head);
+
+	if (sb->dq_op) {
+		remove_dquot_ref(sb, type, &tofree_head);
+		synchronize_srcu(&dquot_srcu);
+		put_dquot_list(&tofree_head);
+	}
 }
 
 static inline
@@ -1466,8 +1513,7 @@
 static int __dquot_initialize(struct inode *inode, int type)
 {
 	int cnt, init_needed = 0;
-	struct dquot __rcu **dquots;
-	struct dquot *got[MAXQUOTAS] = {};
+	struct dquot **dquots, *got[MAXQUOTAS] = {};
 	struct super_block *sb = inode->i_sb;
 	qsize_t rsv;
 	int ret = 0;
@@ -1542,7 +1588,7 @@
 		if (!got[cnt])
 			continue;
 		if (!dquots[cnt]) {
-			rcu_assign_pointer(dquots[cnt], got[cnt]);
+			dquots[cnt] = got[cnt];
 			got[cnt] = NULL;
 			/*
 			 * Make quota reservation system happy if someone
@@ -1550,16 +1596,12 @@
 			 */
 			rsv = inode_get_rsv_space(inode);
 			if (unlikely(rsv)) {
-				struct dquot *dquot = srcu_dereference_check(
-					dquots[cnt], &dquot_srcu,
-					lockdep_is_held(&dq_data_lock));
-
 				spin_lock(&inode->i_lock);
 				/* Get reservation again under proper lock */
 				rsv = __inode_get_rsv_space(inode);
-				spin_lock(&dquot->dq_dqb_lock);
-				dquot->dq_dqb.dqb_rsvspace += rsv;
-				spin_unlock(&dquot->dq_dqb_lock);
+				spin_lock(&dquots[cnt]->dq_dqb_lock);
+				dquots[cnt]->dq_dqb.dqb_rsvspace += rsv;
+				spin_unlock(&dquots[cnt]->dq_dqb_lock);
 				spin_unlock(&inode->i_lock);
 			}
 		}
@@ -1581,7 +1623,7 @@
 
 bool dquot_initialize_needed(struct inode *inode)
 {
-	struct dquot __rcu **dquots;
+	struct dquot **dquots;
 	int i;
 
 	if (!inode_quota_active(inode))
@@ -1606,14 +1648,13 @@
 static void __dquot_drop(struct inode *inode)
 {
 	int cnt;
-	struct dquot __rcu **dquots = i_dquot(inode);
+	struct dquot **dquots = i_dquot(inode);
 	struct dquot *put[MAXQUOTAS];
 
 	spin_lock(&dq_data_lock);
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		put[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,
-					lockdep_is_held(&dq_data_lock));
-		rcu_assign_pointer(dquots[cnt], NULL);
+		put[cnt] = dquots[cnt];
+		dquots[cnt] = NULL;
 	}
 	spin_unlock(&dq_data_lock);
 	dqput_all(put);
@@ -1621,7 +1662,7 @@
 
 void dquot_drop(struct inode *inode)
 {
-	struct dquot __rcu * const *dquots;
+	struct dquot * const *dquots;
 	int cnt;
 
 	if (IS_NOQUOTA(inode))
@@ -1694,8 +1735,7 @@
 	int cnt, ret = 0, index;
 	struct dquot_warn warn[MAXQUOTAS];
 	int reserve = flags & DQUOT_SPACE_RESERVE;
-	struct dquot __rcu **dquots;
-	struct dquot *dquot;
+	struct dquot **dquots;
 
 	if (!inode_quota_active(inode)) {
 		if (reserve) {
@@ -1715,26 +1755,27 @@
 	index = srcu_read_lock(&dquot_srcu);
 	spin_lock(&inode->i_lock);
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (!dquot)
+		if (!dquots[cnt])
 			continue;
 		if (reserve) {
-			ret = dquot_add_space(dquot, 0, number, flags, &warn[cnt]);
+			ret = dquot_add_space(dquots[cnt], 0, number, flags,
+					      &warn[cnt]);
 		} else {
-			ret = dquot_add_space(dquot, number, 0, flags, &warn[cnt]);
+			ret = dquot_add_space(dquots[cnt], number, 0, flags,
+					      &warn[cnt]);
 		}
 		if (ret) {
 			/* Back out changes we already did */
 			for (cnt--; cnt >= 0; cnt--) {
-				dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-				if (!dquot)
+				if (!dquots[cnt])
 					continue;
-				spin_lock(&dquot->dq_dqb_lock);
+				spin_lock(&dquots[cnt]->dq_dqb_lock);
 				if (reserve)
-					dquot_free_reserved_space(dquot, number);
+					dquot_free_reserved_space(dquots[cnt],
+								  number);
 				else
-					dquot_decr_space(dquot, number);
-				spin_unlock(&dquot->dq_dqb_lock);
+					dquot_decr_space(dquots[cnt], number);
+				spin_unlock(&dquots[cnt]->dq_dqb_lock);
 			}
 			spin_unlock(&inode->i_lock);
 			goto out_flush_warn;
@@ -1764,8 +1805,7 @@
 {
 	int cnt, ret = 0, index;
 	struct dquot_warn warn[MAXQUOTAS];
-	struct dquot __rcu * const *dquots;
-	struct dquot *dquot;
+	struct dquot * const *dquots;
 
 	if (!inode_quota_active(inode))
 		return 0;
@@ -1776,19 +1816,17 @@
 	index = srcu_read_lock(&dquot_srcu);
 	spin_lock(&inode->i_lock);
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (!dquot)
+		if (!dquots[cnt])
 			continue;
-		ret = dquot_add_inodes(dquot, 1, &warn[cnt]);
+		ret = dquot_add_inodes(dquots[cnt], 1, &warn[cnt]);
 		if (ret) {
 			for (cnt--; cnt >= 0; cnt--) {
-				dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-				if (!dquot)
+				if (!dquots[cnt])
 					continue;
 				/* Back out changes we already did */
-				spin_lock(&dquot->dq_dqb_lock);
-				dquot_decr_inodes(dquot, 1);
-				spin_unlock(&dquot->dq_dqb_lock);
+				spin_lock(&dquots[cnt]->dq_dqb_lock);
+				dquot_decr_inodes(dquots[cnt], 1);
+				spin_unlock(&dquots[cnt]->dq_dqb_lock);
 			}
 			goto warn_put_all;
 		}
@@ -1809,8 +1847,7 @@
  */
 int dquot_claim_space_nodirty(struct inode *inode, qsize_t number)
 {
-	struct dquot __rcu **dquots;
-	struct dquot *dquot;
+	struct dquot **dquots;
 	int cnt, index;
 
 	if (!inode_quota_active(inode)) {
@@ -1826,8 +1863,9 @@
 	spin_lock(&inode->i_lock);
 	/* Claim reserved quotas to allocated quotas */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (dquot) {
+		if (dquots[cnt]) {
+			struct dquot *dquot = dquots[cnt];
+
 			spin_lock(&dquot->dq_dqb_lock);
 			if (WARN_ON_ONCE(dquot->dq_dqb.dqb_rsvspace < number))
 				number = dquot->dq_dqb.dqb_rsvspace;
@@ -1851,8 +1889,7 @@
  */
 void dquot_reclaim_space_nodirty(struct inode *inode, qsize_t number)
 {
-	struct dquot __rcu **dquots;
-	struct dquot *dquot;
+	struct dquot **dquots;
 	int cnt, index;
 
 	if (!inode_quota_active(inode)) {
@@ -1868,8 +1905,9 @@
 	spin_lock(&inode->i_lock);
 	/* Claim reserved quotas to allocated quotas */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (dquot) {
+		if (dquots[cnt]) {
+			struct dquot *dquot = dquots[cnt];
+
 			spin_lock(&dquot->dq_dqb_lock);
 			if (WARN_ON_ONCE(dquot->dq_dqb.dqb_curspace < number))
 				number = dquot->dq_dqb.dqb_curspace;
@@ -1895,8 +1933,7 @@
 {
 	unsigned int cnt;
 	struct dquot_warn warn[MAXQUOTAS];
-	struct dquot __rcu **dquots;
-	struct dquot *dquot;
+	struct dquot **dquots;
 	int reserve = flags & DQUOT_SPACE_RESERVE, index;
 
 	if (!inode_quota_active(inode)) {
@@ -1917,18 +1954,17 @@
 		int wtype;
 
 		warn[cnt].w_type = QUOTA_NL_NOWARN;
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (!dquot)
+		if (!dquots[cnt])
 			continue;
-		spin_lock(&dquot->dq_dqb_lock);
-		wtype = info_bdq_free(dquot, number);
+		spin_lock(&dquots[cnt]->dq_dqb_lock);
+		wtype = info_bdq_free(dquots[cnt], number);
 		if (wtype != QUOTA_NL_NOWARN)
-			prepare_warning(&warn[cnt], dquot, wtype);
+			prepare_warning(&warn[cnt], dquots[cnt], wtype);
 		if (reserve)
-			dquot_free_reserved_space(dquot, number);
+			dquot_free_reserved_space(dquots[cnt], number);
 		else
-			dquot_decr_space(dquot, number);
-		spin_unlock(&dquot->dq_dqb_lock);
+			dquot_decr_space(dquots[cnt], number);
+		spin_unlock(&dquots[cnt]->dq_dqb_lock);
 	}
 	if (reserve)
 		*inode_reserved_space(inode) -= number;
@@ -1952,8 +1988,7 @@
 {
 	unsigned int cnt;
 	struct dquot_warn warn[MAXQUOTAS];
-	struct dquot __rcu * const *dquots;
-	struct dquot *dquot;
+	struct dquot * const *dquots;
 	int index;
 
 	if (!inode_quota_active(inode))
@@ -1964,16 +1999,16 @@
 	spin_lock(&inode->i_lock);
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
 		int wtype;
+
 		warn[cnt].w_type = QUOTA_NL_NOWARN;
-		dquot = srcu_dereference(dquots[cnt], &dquot_srcu);
-		if (!dquot)
+		if (!dquots[cnt])
 			continue;
-		spin_lock(&dquot->dq_dqb_lock);
-		wtype = info_idq_free(dquot, 1);
+		spin_lock(&dquots[cnt]->dq_dqb_lock);
+		wtype = info_idq_free(dquots[cnt], 1);
 		if (wtype != QUOTA_NL_NOWARN)
-			prepare_warning(&warn[cnt], dquot, wtype);
-		dquot_decr_inodes(dquot, 1);
-		spin_unlock(&dquot->dq_dqb_lock);
+			prepare_warning(&warn[cnt], dquots[cnt], wtype);
+		dquot_decr_inodes(dquots[cnt], 1);
+		spin_unlock(&dquots[cnt]->dq_dqb_lock);
 	}
 	spin_unlock(&inode->i_lock);
 	mark_all_dquot_dirty(dquots);
@@ -1999,9 +2034,8 @@
 	qsize_t cur_space;
 	qsize_t rsv_space = 0;
 	qsize_t inode_usage = 1;
-	struct dquot __rcu **dquots;
 	struct dquot *transfer_from[MAXQUOTAS] = {};
-	int cnt, index, ret = 0;
+	int cnt, ret = 0;
 	char is_valid[MAXQUOTAS] = {};
 	struct dquot_warn warn_to[MAXQUOTAS];
 	struct dquot_warn warn_from_inodes[MAXQUOTAS];
@@ -2032,7 +2066,6 @@
 	}
 	cur_space = __inode_get_bytes(inode);
 	rsv_space = __inode_get_rsv_space(inode);
-	dquots = i_dquot(inode);
 	/*
 	 * Build the transfer_from list, check limits, and update usage in
 	 * the target structures.
@@ -2047,8 +2080,7 @@
 		if (!sb_has_quota_active(inode->i_sb, cnt))
 			continue;
 		is_valid[cnt] = 1;
-		transfer_from[cnt] = srcu_dereference_check(dquots[cnt],
-				&dquot_srcu, lockdep_is_held(&dq_data_lock));
+		transfer_from[cnt] = i_dquot(inode)[cnt];
 		ret = dquot_add_inodes(transfer_to[cnt], inode_usage,
 				       &warn_to[cnt]);
 		if (ret)
@@ -2087,21 +2119,13 @@
 						  rsv_space);
 			spin_unlock(&transfer_from[cnt]->dq_dqb_lock);
 		}
-		rcu_assign_pointer(dquots[cnt], transfer_to[cnt]);
+		i_dquot(inode)[cnt] = transfer_to[cnt];
 	}
 	spin_unlock(&inode->i_lock);
 	spin_unlock(&dq_data_lock);
 
-	/*
-	 * These arrays are local and we hold dquot references so we don't need
-	 * the srcu protection but still take dquot_srcu to avoid warning in
-	 * mark_all_dquot_dirty().
-	 */
-	index = srcu_read_lock(&dquot_srcu);
-	mark_all_dquot_dirty((struct dquot __rcu **)transfer_from);
-	mark_all_dquot_dirty((struct dquot __rcu **)transfer_to);
-	srcu_read_unlock(&dquot_srcu, index);
-
+	mark_all_dquot_dirty(transfer_from);
+	mark_all_dquot_dirty(transfer_to);
 	flush_warnings(warn_to);
 	flush_warnings(warn_from_inodes);
 	flush_warnings(warn_from_space);
Index: fs/fcntl.c
===================================================================
--- fs/fcntl.c	(revision 55465)
+++ fs/fcntl.c	(revision 55464)
@@ -267,7 +267,7 @@
 }
 #endif
 
-static bool rw_hint_valid(u64 hint)
+static bool rw_hint_valid(enum rw_hint hint)
 {
 	switch (hint) {
 	case RWH_WRITE_LIFE_NOT_SET:
@@ -287,17 +287,19 @@
 {
 	struct inode *inode = file_inode(file);
 	u64 __user *argp = (u64 __user *)arg;
-	u64 hint;
+	enum rw_hint hint;
+	u64 h;
 
 	switch (cmd) {
 	case F_GET_RW_HINT:
-		hint = inode->i_write_hint;
-		if (copy_to_user(argp, &hint, sizeof(*argp)))
+		h = inode->i_write_hint;
+		if (copy_to_user(argp, &h, sizeof(*argp)))
 			return -EFAULT;
 		return 0;
 	case F_SET_RW_HINT:
-		if (copy_from_user(&hint, argp, sizeof(hint)))
+		if (copy_from_user(&h, argp, sizeof(h)))
 			return -EFAULT;
+		hint = (enum rw_hint) h;
 		if (!rw_hint_valid(hint))
 			return -EINVAL;
 
Index: fs/fhandle.c
===================================================================
--- fs/fhandle.c	(revision 55465)
+++ fs/fhandle.c	(revision 55464)
@@ -37,7 +37,7 @@
 	if (f_handle.handle_bytes > MAX_HANDLE_SZ)
 		return -EINVAL;
 
-	handle = kzalloc(sizeof(struct file_handle) + f_handle.handle_bytes,
+	handle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,
 			 GFP_KERNEL);
 	if (!handle)
 		return -ENOMEM;
Index: fs/select.c
===================================================================
--- fs/select.c	(revision 55465)
+++ fs/select.c	(revision 55464)
@@ -476,7 +476,7 @@
 		wait->_key |= POLLOUT_SET;
 }
 
-static noinline_for_stack int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
+static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
 {
 	ktime_t expire, *to = NULL;
 	struct poll_wqueues table;
Index: kernel/bpf/cpumap.c
===================================================================
--- kernel/bpf/cpumap.c	(revision 55465)
+++ kernel/bpf/cpumap.c	(revision 55464)
@@ -306,7 +306,6 @@
 static int cpu_map_kthread_run(void *data)
 {
 	struct bpf_cpu_map_entry *rcpu = data;
-	unsigned long last_qs = jiffies;
 
 	complete(&rcpu->kthread_running);
 	set_current_state(TASK_INTERRUPTIBLE);
@@ -332,12 +331,10 @@
 			if (__ptr_ring_empty(rcpu->queue)) {
 				schedule();
 				sched = 1;
-				last_qs = jiffies;
 			} else {
 				__set_current_state(TASK_RUNNING);
 			}
 		} else {
-			rcu_softirq_qs_periodic(last_qs);
 			sched = cond_resched();
 		}
 
Index: kernel/bpf/helpers.c
===================================================================
--- kernel/bpf/helpers.c	(revision 55465)
+++ kernel/bpf/helpers.c	(revision 55464)
@@ -328,7 +328,7 @@
 	__this_cpu_write(irqsave_flags, flags);
 }
 
-NOTRACE_BPF_CALL_1(bpf_spin_lock, struct bpf_spin_lock *, lock)
+notrace BPF_CALL_1(bpf_spin_lock, struct bpf_spin_lock *, lock)
 {
 	__bpf_spin_lock_irqsave(lock);
 	return 0;
@@ -350,7 +350,7 @@
 	local_irq_restore(flags);
 }
 
-NOTRACE_BPF_CALL_1(bpf_spin_unlock, struct bpf_spin_lock *, lock)
+notrace BPF_CALL_1(bpf_spin_unlock, struct bpf_spin_lock *, lock)
 {
 	__bpf_spin_unlock_irqrestore(lock);
 	return 0;
Index: kernel/bpf/hashtab.c
===================================================================
--- kernel/bpf/hashtab.c	(revision 55465)
+++ kernel/bpf/hashtab.c	(revision 55464)
@@ -495,13 +495,7 @@
 							  num_possible_cpus());
 	}
 
-	/* hash table size must be power of 2; roundup_pow_of_two() can overflow
-	 * into UB on 32-bit arches, so check that first
-	 */
-	err = -E2BIG;
-	if (htab->map.max_entries > 1UL << 31)
-		goto free_htab;
-
+	/* hash table size must be power of 2 */
 	htab->n_buckets = roundup_pow_of_two(htab->map.max_entries);
 
 	htab->elem_size = sizeof(struct htab_elem) +
@@ -511,8 +505,10 @@
 	else
 		htab->elem_size += round_up(htab->map.value_size, 8);
 
-	/* check for u32 overflow */
-	if (htab->n_buckets > U32_MAX / sizeof(struct bucket))
+	err = -E2BIG;
+	/* prevent zero size kmalloc and check for u32 overflow */
+	if (htab->n_buckets == 0 ||
+	    htab->n_buckets > U32_MAX / sizeof(struct bucket))
 		goto free_htab;
 
 	err = -ENOMEM;
Index: kernel/bpf/stackmap.c
===================================================================
--- kernel/bpf/stackmap.c	(revision 55465)
+++ kernel/bpf/stackmap.c	(revision 55464)
@@ -94,14 +94,11 @@
 	} else if (value_size / 8 > sysctl_perf_event_max_stack)
 		return ERR_PTR(-EINVAL);
 
-	/* hash table size must be power of 2; roundup_pow_of_two() can overflow
-	 * into UB on 32-bit arches, so check that first
-	 */
-	if (attr->max_entries > 1UL << 31)
+	/* hash table size must be power of 2 */
+	n_buckets = roundup_pow_of_two(attr->max_entries);
+	if (!n_buckets)
 		return ERR_PTR(-E2BIG);
 
-	n_buckets = roundup_pow_of_two(attr->max_entries);
-
 	cost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);
 	smap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));
 	if (!smap)
Index: kernel/bpf/core.c
===================================================================
--- kernel/bpf/core.c	(revision 55465)
+++ kernel/bpf/core.c	(revision 55464)
@@ -857,12 +857,7 @@
  * CONFIG_MMU=n. Use PAGE_SIZE in these cases.
  */
 #ifdef PMD_SIZE
-/* PMD_SIZE is really big for some archs. It doesn't make sense to
- * reserve too much memory in one allocation. Hardcode BPF_PROG_PACK_SIZE to
- * 2MiB * num_possible_nodes(). On most architectures PMD_SIZE will be
- * greater than or equal to 2MB.
- */
-#define BPF_PROG_PACK_SIZE (SZ_2M * num_possible_nodes())
+#define BPF_PROG_PACK_SIZE (PMD_SIZE * num_possible_nodes())
 #else
 #define BPF_PROG_PACK_SIZE PAGE_SIZE
 #endif
Index: kernel/bpf/devmap.c
===================================================================
--- kernel/bpf/devmap.c	(revision 55465)
+++ kernel/bpf/devmap.c	(revision 55464)
@@ -131,14 +131,13 @@
 	bpf_map_init_from_attr(&dtab->map, attr);
 
 	if (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {
-		/* hash table size must be power of 2; roundup_pow_of_two() can
-		 * overflow into UB on 32-bit arches, so check that first
-		 */
-		if (dtab->map.max_entries > 1UL << 31)
+		dtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);
+
+		if (!dtab->n_buckets) /* Overflow check */
 			return -EINVAL;
+	}
 
-		dtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);
-
+	if (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {
 		dtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,
 							   dtab->map.numa_node);
 		if (!dtab->dev_index_head)
Index: kernel/sched/fair.c
===================================================================
--- kernel/sched/fair.c	(revision 55465)
+++ kernel/sched/fair.c	(revision 55464)
@@ -6656,7 +6656,7 @@
 		if (!available_idle_cpu(cpu)) {
 			idle = false;
 			if (*idle_cpu == -1) {
-				if (sched_idle_cpu(cpu) && cpumask_test_cpu(cpu, cpus)) {
+				if (sched_idle_cpu(cpu) && cpumask_test_cpu(cpu, p->cpus_ptr)) {
 					*idle_cpu = cpu;
 					break;
 				}
@@ -6664,7 +6664,7 @@
 			}
 			break;
 		}
-		if (*idle_cpu == -1 && cpumask_test_cpu(cpu, cpus))
+		if (*idle_cpu == -1 && cpumask_test_cpu(cpu, p->cpus_ptr))
 			*idle_cpu = cpu;
 	}
 
@@ -6678,7 +6678,7 @@
 /*
  * Scan the local SMT mask for idle CPUs.
  */
-static int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
+static int select_idle_smt(struct task_struct *p, int target)
 {
 	int cpu;
 
@@ -6685,12 +6685,6 @@
 	for_each_cpu_and(cpu, cpu_smt_mask(target), p->cpus_ptr) {
 		if (cpu == target)
 			continue;
-		/*
-		 * Check if the CPU is in the LLC scheduling domain of @target.
-		 * Due to isolcpus, there is no guarantee that all the siblings are in the domain.
-		 */
-		if (!cpumask_test_cpu(cpu, sched_domain_span(sd)))
-			continue;
 		if (available_idle_cpu(cpu) || sched_idle_cpu(cpu))
 			return cpu;
 	}
@@ -6714,7 +6708,7 @@
 	return __select_idle_cpu(core, p);
 }
 
-static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
+static inline int select_idle_smt(struct task_struct *p, int target)
 {
 	return -1;
 }
@@ -6976,7 +6970,7 @@
 		has_idle_core = test_idle_cores(target);
 
 		if (!has_idle_core && cpus_share_cache(prev, target)) {
-			i = select_idle_smt(p, sd, prev);
+			i = select_idle_smt(p, prev);
 			if ((unsigned int)i < nr_cpumask_bits)
 				return i;
 		}
Index: kernel/time/time_test.c
===================================================================
--- kernel/time/time_test.c	(revision 55465)
+++ kernel/time/time_test.c	(revision 55464)
@@ -73,7 +73,7 @@
 
 		days = div_s64(secs, 86400);
 
-		#define FAIL_MSG "%05ld/%02d/%02d (%2d) : %lld", \
+		#define FAIL_MSG "%05ld/%02d/%02d (%2d) : %ld", \
 			year, month, mdday, yday, days
 
 		KUNIT_ASSERT_EQ_MSG(test, year - 1900, result.tm_year, FAIL_MSG);
Index: kernel/time/timekeeping.c
===================================================================
--- kernel/time/timekeeping.c	(revision 55465)
+++ kernel/time/timekeeping.c	(revision 55464)
@@ -1180,15 +1180,13 @@
 }
 
 /*
- * timestamp_in_interval - true if ts is chronologically in [start, end]
- *
- * True if ts occurs chronologically at or after start, and before or at end.
+ * cycle_between - true if test occurs chronologically between before and after
  */
-static bool timestamp_in_interval(u64 start, u64 end, u64 ts)
+static bool cycle_between(u64 before, u64 test, u64 after)
 {
-	if (ts >= start && ts <= end)
+	if (test > before && test < after)
 		return true;
-	if (start > end && (ts >= start || ts <= end))
+	if (test < before && before > after)
 		return true;
 	return false;
 }
@@ -1248,7 +1246,7 @@
 		 */
 		now = tk_clock_read(&tk->tkr_mono);
 		interval_start = tk->tkr_mono.cycle_last;
-		if (!timestamp_in_interval(interval_start, now, cycles)) {
+		if (!cycle_between(interval_start, cycles, now)) {
 			clock_was_set_seq = tk->clock_was_set_seq;
 			cs_was_changed_seq = tk->cs_was_changed_seq;
 			cycles = interval_start;
@@ -1261,8 +1259,10 @@
 				      tk_core.timekeeper.offs_real);
 		base_raw = tk->tkr_raw.base;
 
-		nsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono, cycles);
-		nsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw, cycles);
+		nsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono,
+						     system_counterval.cycles);
+		nsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw,
+						    system_counterval.cycles);
 	} while (read_seqcount_retry(&tk_core.seq, seq));
 
 	xtstamp->sys_realtime = ktime_add_ns(base_real, nsec_real);
@@ -1277,13 +1277,13 @@
 		bool discontinuity;
 
 		/*
-		 * Check that the counter value is not before the provided
+		 * Check that the counter value occurs after the provided
 		 * history reference and that the history doesn't cross a
 		 * clocksource change
 		 */
 		if (!history_begin ||
-		    !timestamp_in_interval(history_begin->cycles,
-					   cycles, system_counterval.cycles) ||
+		    !cycle_between(history_begin->cycles,
+				   system_counterval.cycles, cycles) ||
 		    history_begin->cs_was_changed_seq != cs_was_changed_seq)
 			return -EINVAL;
 		partial_history_cycles = cycles - system_counterval.cycles;
Index: kernel/rcu/tree.c
===================================================================
--- kernel/rcu/tree.c	(revision 55465)
+++ kernel/rcu/tree.c	(revision 55464)
@@ -4465,7 +4465,6 @@
 	rcu_exp_gp_kworker = kthread_create_worker(0, gp_kworker_name);
 	if (IS_ERR_OR_NULL(rcu_exp_gp_kworker)) {
 		pr_err("Failed to create %s!\n", gp_kworker_name);
-		rcu_exp_gp_kworker = NULL;
 		return;
 	}
 
@@ -4472,9 +4471,7 @@
 	rcu_exp_par_gp_kworker = kthread_create_worker(0, par_gp_kworker_name);
 	if (IS_ERR_OR_NULL(rcu_exp_par_gp_kworker)) {
 		pr_err("Failed to create %s!\n", par_gp_kworker_name);
-		rcu_exp_par_gp_kworker = NULL;
 		kthread_destroy_worker(rcu_exp_gp_kworker);
-		rcu_exp_gp_kworker = NULL;
 		return;
 	}
 
Index: kernel/rcu/tree_exp.h
===================================================================
--- kernel/rcu/tree_exp.h	(revision 55465)
+++ kernel/rcu/tree_exp.h	(revision 55464)
@@ -427,13 +427,8 @@
 	__sync_rcu_exp_select_node_cpus(rewp);
 }
 
-static inline bool rcu_exp_worker_started(void)
+static inline bool rcu_gp_par_worker_started(void)
 {
-	return !!READ_ONCE(rcu_exp_gp_kworker);
-}
-
-static inline bool rcu_exp_par_worker_started(void)
-{
 	return !!READ_ONCE(rcu_exp_par_gp_kworker);
 }
 
@@ -482,13 +477,8 @@
 	__sync_rcu_exp_select_node_cpus(rewp);
 }
 
-static inline bool rcu_exp_worker_started(void)
+static inline bool rcu_gp_par_worker_started(void)
 {
-	return !!READ_ONCE(rcu_gp_wq);
-}
-
-static inline bool rcu_exp_par_worker_started(void)
-{
 	return !!READ_ONCE(rcu_par_gp_wq);
 }
 
@@ -550,7 +540,7 @@
 		rnp->exp_need_flush = false;
 		if (!READ_ONCE(rnp->expmask))
 			continue; /* Avoid early boot non-existent wq. */
-		if (!rcu_exp_par_worker_started() ||
+		if (!rcu_gp_par_worker_started() ||
 		    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||
 		    rcu_is_last_leaf_node(rnp)) {
 			/* No worker started yet or last leaf, do direct call. */
@@ -920,7 +910,7 @@
  */
 void synchronize_rcu_expedited(void)
 {
-	bool use_worker;
+	bool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);
 	unsigned long flags;
 	struct rcu_exp_work rew;
 	struct rcu_node *rnp;
@@ -931,9 +921,6 @@
 			 lock_is_held(&rcu_sched_lock_map),
 			 "Illegal synchronize_rcu_expedited() in RCU read-side critical section");
 
-	use_worker = (rcu_scheduler_active != RCU_SCHEDULER_INIT) &&
-		      rcu_exp_worker_started();
-
 	/* Is the state is such that the call is a grace period? */
 	if (rcu_blocking_is_gp()) {
 		// Note well that this code runs with !PREEMPT && !SMP.
@@ -963,7 +950,7 @@
 		return;  /* Someone else did our work for us. */
 
 	/* Ensure that load happens before action based on it. */
-	if (unlikely(!use_worker)) {
+	if (unlikely(boottime)) {
 		/* Direct call during scheduler init and early_initcalls(). */
 		rcu_exp_sel_wait_wake(s);
 	} else {
@@ -981,7 +968,7 @@
 	/* Let the next expedited grace period start. */
 	mutex_unlock(&rcu_state.exp_mutex);
 
-	if (likely(use_worker))
+	if (likely(!boottime))
 		synchronize_rcu_expedited_destroy_work(&rew);
 }
 EXPORT_SYMBOL_GPL(synchronize_rcu_expedited);
Index: kernel/module/main.c
===================================================================
--- kernel/module/main.c	(revision 55465)
+++ kernel/module/main.c	(revision 55464)
@@ -2439,11 +2439,6 @@
 	}
 }
 
-void flush_module_init_free_work(void)
-{
-	flush_work(&init_free_wq);
-}
-
 #undef MODULE_PARAM_PREFIX
 #define MODULE_PARAM_PREFIX "module."
 /* Default value for module->async_probe_requested */
@@ -2534,8 +2529,8 @@
 	 * Note that module_alloc() on most architectures creates W+X page
 	 * mappings which won't be cleaned up until do_free_init() runs.  Any
 	 * code such as mark_rodata_ro() which depends on those mappings to
-	 * be cleaned up needs to sync with the queued work by invoking
-	 * flush_module_init_free_work().
+	 * be cleaned up needs to sync with the queued work - ie
+	 * rcu_barrier()
 	 */
 	if (llist_add(&freeinit->node, &init_free_list))
 		schedule_work(&init_free_wq);
Index: kernel/printk/printk.c
===================================================================
--- kernel/printk/printk.c	(revision 55465)
+++ kernel/printk/printk.c	(revision 55464)
@@ -1797,23 +1797,10 @@
  */
 static void console_lock_spinning_enable(void)
 {
-	/*
-	 * Do not use spinning in panic(). The panic CPU wants to keep the lock.
-	 * Non-panic CPUs abandon the flush anyway.
-	 *
-	 * Just keep the lockdep annotation. The panic-CPU should avoid
-	 * taking console_owner_lock because it might cause a deadlock.
-	 * This looks like the easiest way how to prevent false lockdep
-	 * reports without handling races a lockless way.
-	 */
-	if (panic_in_progress())
-		goto lockdep;
-
 	raw_spin_lock(&console_owner_lock);
 	console_owner = current;
 	raw_spin_unlock(&console_owner_lock);
 
-lockdep:
 	/* The waiter may spin on us after setting console_owner */
 	spin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);
 }
@@ -1837,22 +1824,6 @@
 {
 	int waiter;
 
-	/*
-	 * Ignore spinning waiters during panic() because they might get stopped
-	 * or blocked at any time,
-	 *
-	 * It is safe because nobody is allowed to start spinning during panic
-	 * in the first place. If there has been a waiter then non panic CPUs
-	 * might stay spinning. They would get stopped anyway. The panic context
-	 * will never start spinning and an interrupted spin on panic CPU will
-	 * never continue.
-	 */
-	if (panic_in_progress()) {
-		/* Keep lockdep happy. */
-		spin_release(&console_owner_dep_map, _THIS_IP_);
-		return 0;
-	}
-
 	raw_spin_lock(&console_owner_lock);
 	waiter = READ_ONCE(console_waiter);
 	console_owner = NULL;
Index: lib/cmdline_kunit.c
===================================================================
--- lib/cmdline_kunit.c	(revision 55465)
+++ lib/cmdline_kunit.c	(revision 55464)
@@ -124,7 +124,7 @@
 			    n, e[0], r[0]);
 
 	p = memchr_inv(&r[1], 0, sizeof(r) - sizeof(r[0]));
-	KUNIT_EXPECT_PTR_EQ_MSG(test, p, NULL, "in test %u at %td out of bound", n, p - r);
+	KUNIT_EXPECT_PTR_EQ_MSG(test, p, NULL, "in test %u at %u out of bound", n, p - r);
 }
 
 static void cmdline_test_range(struct kunit *test)
Index: lib/memcpy_kunit.c
===================================================================
--- lib/memcpy_kunit.c	(revision 55465)
+++ lib/memcpy_kunit.c	(revision 55464)
@@ -32,7 +32,7 @@
 	BUILD_BUG_ON(sizeof(instance.data) != 32);	\
 	for (size_t i = 0; i < sizeof(instance.data); i++) {	\
 		KUNIT_ASSERT_EQ_MSG(test, instance.data[i], v, \
-			"line %d: '%s' not initialized to 0x%02x @ %zu (saw 0x%02x)\n", \
+			"line %d: '%s' not initialized to 0x%02x @ %d (saw 0x%02x)\n", \
 			__LINE__, #instance, v, i, instance.data[i]);	\
 	}	\
 } while (0)
@@ -41,7 +41,7 @@
 	BUILD_BUG_ON(sizeof(one) != sizeof(two)); \
 	for (size_t i = 0; i < sizeof(one); i++) {	\
 		KUNIT_EXPECT_EQ_MSG(test, one.data[i], two.data[i], \
-			"line %d: %s.data[%zu] (0x%02x) != %s.data[%zu] (0x%02x)\n", \
+			"line %d: %s.data[%d] (0x%02x) != %s.data[%d] (0x%02x)\n", \
 			__LINE__, #one, i, one.data[i], #two, i, two.data[i]); \
 	}	\
 	kunit_info(test, "ok: " TEST_OP "() " name "\n");	\
Index: lib/test_blackhole_dev.c
===================================================================
--- lib/test_blackhole_dev.c	(revision 55465)
+++ lib/test_blackhole_dev.c	(revision 55464)
@@ -29,6 +29,7 @@
 {
 	struct ipv6hdr *ip6h;
 	struct sk_buff *skb;
+	struct ethhdr *ethh;
 	struct udphdr *uh;
 	int data_len;
 	int ret;
@@ -60,7 +61,7 @@
 	ip6h->saddr = in6addr_loopback;
 	ip6h->daddr = in6addr_loopback;
 	/* Ether */
-	skb_push(skb, sizeof(struct ethhdr));
+	ethh = (struct ethhdr *)skb_push(skb, sizeof(struct ethhdr));
 	skb_set_mac_header(skb, 0);
 
 	skb->protocol = htons(ETH_P_IPV6);
Index: net/bluetooth/hci_core.c
===================================================================
--- net/bluetooth/hci_core.c	(revision 55465)
+++ net/bluetooth/hci_core.c	(revision 55464)
@@ -908,7 +908,7 @@
 	else
 		flags = hdev->flags;
 
-	strscpy(di.name, hdev->name, sizeof(di.name));
+	strcpy(di.name, hdev->name);
 	di.bdaddr   = hdev->bdaddr;
 	di.type     = (hdev->bus & 0x0f) | ((hdev->dev_type & 0x03) << 4);
 	di.flags    = flags;
@@ -1491,12 +1491,11 @@
 	struct hci_dev *hdev = container_of(work, struct hci_dev,
 					    cmd_timer.work);
 
-	if (hdev->req_skb) {
-		u16 opcode = hci_skb_opcode(hdev->req_skb);
+	if (hdev->sent_cmd) {
+		struct hci_command_hdr *sent = (void *) hdev->sent_cmd->data;
+		u16 opcode = __le16_to_cpu(sent->opcode);
 
 		bt_dev_err(hdev, "command 0x%4.4x tx timeout", opcode);
-
-		hci_cmd_sync_cancel_sync(hdev, ETIMEDOUT);
 	} else {
 		bt_dev_err(hdev, "command tx timeout");
 	}
@@ -2792,7 +2791,6 @@
 
 	ida_simple_remove(&hci_index_ida, hdev->id);
 	kfree_skb(hdev->sent_cmd);
-	kfree_skb(hdev->req_skb);
 	kfree_skb(hdev->recv_event);
 	kfree(hdev);
 }
@@ -2824,23 +2822,6 @@
 	return ret;
 }
 
-/* Cancel ongoing command synchronously:
- *
- * - Cancel command timer
- * - Reset command counter
- * - Cancel command request
- */
-static void hci_cancel_cmd_sync(struct hci_dev *hdev, int err)
-{
-	bt_dev_dbg(hdev, "err 0x%2.2x", err);
-
-	cancel_delayed_work_sync(&hdev->cmd_timer);
-	cancel_delayed_work_sync(&hdev->ncmd_timer);
-	atomic_set(&hdev->cmd_cnt, 1);
-
-	hci_cmd_sync_cancel_sync(hdev, -err);
-}
-
 /* Suspend HCI device */
 int hci_suspend_dev(struct hci_dev *hdev)
 {
@@ -2857,9 +2838,6 @@
 	if (mgmt_powering_down(hdev))
 		return 0;
 
-	/* Cancel potentially blocking sync operation before suspend */
-	hci_cancel_cmd_sync(hdev, -EHOSTDOWN);
-
 	hci_req_sync_lock(hdev);
 	ret = hci_suspend_sync(hdev);
 	hci_req_sync_unlock(hdev);
@@ -3122,33 +3100,21 @@
 EXPORT_SYMBOL(__hci_cmd_send);
 
 /* Get data from the previously sent command */
-static void *hci_cmd_data(struct sk_buff *skb, __u16 opcode)
+void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)
 {
 	struct hci_command_hdr *hdr;
 
-	if (!skb || skb->len < HCI_COMMAND_HDR_SIZE)
+	if (!hdev->sent_cmd)
 		return NULL;
 
-	hdr = (void *)skb->data;
+	hdr = (void *) hdev->sent_cmd->data;
 
 	if (hdr->opcode != cpu_to_le16(opcode))
 		return NULL;
 
-	return skb->data + HCI_COMMAND_HDR_SIZE;
-}
+	BT_DBG("%s opcode 0x%4.4x", hdev->name, opcode);
 
-/* Get data from the previously sent command */
-void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)
-{
-	void *data;
-
-	/* Check if opcode matches last sent command */
-	data = hci_cmd_data(hdev->sent_cmd, opcode);
-	if (!data)
-		/* Check if opcode matches last request */
-		data = hci_cmd_data(hdev->req_skb, opcode);
-
-	return data;
+	return hdev->sent_cmd->data + HCI_COMMAND_HDR_SIZE;
 }
 
 /* Get data from last received event */
@@ -4044,19 +4010,17 @@
 	if (!status && !hci_req_is_complete(hdev))
 		return;
 
-	skb = hdev->req_skb;
-
 	/* If this was the last command in a request the complete
-	 * callback would be found in hdev->req_skb instead of the
+	 * callback would be found in hdev->sent_cmd instead of the
 	 * command queue (hdev->cmd_q).
 	 */
-	if (skb && bt_cb(skb)->hci.req_flags & HCI_REQ_SKB) {
-		*req_complete_skb = bt_cb(skb)->hci.req_complete_skb;
+	if (bt_cb(hdev->sent_cmd)->hci.req_flags & HCI_REQ_SKB) {
+		*req_complete_skb = bt_cb(hdev->sent_cmd)->hci.req_complete_skb;
 		return;
 	}
 
-	if (skb && bt_cb(skb)->hci.req_complete) {
-		*req_complete = bt_cb(skb)->hci.req_complete;
+	if (bt_cb(hdev->sent_cmd)->hci.req_complete) {
+		*req_complete = bt_cb(hdev->sent_cmd)->hci.req_complete;
 		return;
 	}
 
@@ -4152,36 +4116,6 @@
 	}
 }
 
-static void hci_send_cmd_sync(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	int err;
-
-	bt_dev_dbg(hdev, "skb %p", skb);
-
-	kfree_skb(hdev->sent_cmd);
-
-	hdev->sent_cmd = skb_clone(skb, GFP_KERNEL);
-	if (!hdev->sent_cmd) {
-		skb_queue_head(&hdev->cmd_q, skb);
-		queue_work(hdev->workqueue, &hdev->cmd_work);
-		return;
-	}
-
-	err = hci_send_frame(hdev, skb);
-	if (err < 0) {
-		hci_cmd_sync_cancel_sync(hdev, err);
-		return;
-	}
-
-	if (hci_req_status_pend(hdev) &&
-	    !hci_dev_test_and_set_flag(hdev, HCI_CMD_PENDING)) {
-		kfree_skb(hdev->req_skb);
-		hdev->req_skb = skb_clone(hdev->sent_cmd, GFP_KERNEL);
-	}
-
-	atomic_dec(&hdev->cmd_cnt);
-}
-
 static void hci_cmd_work(struct work_struct *work)
 {
 	struct hci_dev *hdev = container_of(work, struct hci_dev, cmd_work);
@@ -4196,15 +4130,30 @@
 		if (!skb)
 			return;
 
-		hci_send_cmd_sync(hdev, skb);
+		kfree_skb(hdev->sent_cmd);
 
-		rcu_read_lock();
-		if (test_bit(HCI_RESET, &hdev->flags) ||
-		    hci_dev_test_flag(hdev, HCI_CMD_DRAIN_WORKQUEUE))
-			cancel_delayed_work(&hdev->cmd_timer);
-		else
-			queue_delayed_work(hdev->workqueue, &hdev->cmd_timer,
-					   HCI_CMD_TIMEOUT);
-		rcu_read_unlock();
+		hdev->sent_cmd = skb_clone(skb, GFP_KERNEL);
+		if (hdev->sent_cmd) {
+			int res;
+			if (hci_req_status_pend(hdev))
+				hci_dev_set_flag(hdev, HCI_CMD_PENDING);
+			atomic_dec(&hdev->cmd_cnt);
+
+			res = hci_send_frame(hdev, skb);
+			if (res < 0)
+				__hci_cmd_sync_cancel(hdev, -res);
+
+			rcu_read_lock();
+			if (test_bit(HCI_RESET, &hdev->flags) ||
+			    hci_dev_test_flag(hdev, HCI_CMD_DRAIN_WORKQUEUE))
+				cancel_delayed_work(&hdev->cmd_timer);
+			else
+				queue_delayed_work(hdev->workqueue, &hdev->cmd_timer,
+						   HCI_CMD_TIMEOUT);
+			rcu_read_unlock();
+		} else {
+			skb_queue_head(&hdev->cmd_q, skb);
+			queue_work(hdev->workqueue, &hdev->cmd_work);
+		}
 	}
 }
Index: net/bluetooth/hci_event.c
===================================================================
--- net/bluetooth/hci_event.c	(revision 55465)
+++ net/bluetooth/hci_event.c	(revision 55464)
@@ -1761,7 +1761,7 @@
 {
 	struct discovery_state *d = &hdev->discovery;
 
-	if (len > max_adv_len(hdev))
+	if (len > HCI_MAX_AD_LENGTH)
 		return;
 
 	bacpy(&d->last_adv_addr, bdaddr);
@@ -3567,6 +3567,8 @@
 
 	bt_dev_dbg(hdev, "status 0x%2.2x", ev->status);
 
+	hci_conn_check_pending(hdev);
+
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
@@ -4329,7 +4331,7 @@
 	 * (since for this kind of commands there will not be a command
 	 * complete event).
 	 */
-	if (ev->status || (hdev->req_skb && !hci_skb_event(hdev->req_skb))) {
+	if (ev->status || (hdev->sent_cmd && !hci_skb_event(hdev->sent_cmd))) {
 		hci_req_cmd_complete(hdev, *opcode, ev->status, req_complete,
 				     req_complete_skb);
 		if (hci_dev_test_flag(hdev, HCI_CMD_PENDING)) {
@@ -6240,9 +6242,8 @@
 		return;
 	}
 
-	if (len > max_adv_len(hdev)) {
-		bt_dev_err_ratelimited(hdev,
-				       "adv larger than maximum supported");
+	if (!ext_adv && len > HCI_MAX_AD_LENGTH) {
+		bt_dev_err_ratelimited(hdev, "legacy adv larger than 31 bytes");
 		return;
 	}
 
@@ -6307,8 +6308,7 @@
 	 */
 	conn = check_pending_le_conn(hdev, bdaddr, bdaddr_type, bdaddr_resolved,
 				     type);
-	if (!ext_adv && conn && type == LE_ADV_IND &&
-	    len <= max_adv_len(hdev)) {
+	if (!ext_adv && conn && type == LE_ADV_IND && len <= HCI_MAX_AD_LENGTH) {
 		/* Store report for later inclusion by
 		 * mgmt_device_connected
 		 */
@@ -6449,7 +6449,7 @@
 					info->length + 1))
 			break;
 
-		if (info->length <= max_adv_len(hdev)) {
+		if (info->length <= HCI_MAX_AD_LENGTH) {
 			rssi = info->data[info->length];
 			process_adv_report(hdev, info->type, &info->bdaddr,
 					   info->bdaddr_type, NULL, 0, rssi,
@@ -7149,10 +7149,10 @@
 	bt_dev_dbg(hdev, "subevent 0x%2.2x", ev->subevent);
 
 	/* Only match event if command OGF is for LE */
-	if (hdev->req_skb &&
-	    hci_opcode_ogf(hci_skb_opcode(hdev->req_skb)) == 0x08 &&
-	    hci_skb_event(hdev->req_skb) == ev->subevent) {
-		*opcode = hci_skb_opcode(hdev->req_skb);
+	if (hdev->sent_cmd &&
+	    hci_opcode_ogf(hci_skb_opcode(hdev->sent_cmd)) == 0x08 &&
+	    hci_skb_event(hdev->sent_cmd) == ev->subevent) {
+		*opcode = hci_skb_opcode(hdev->sent_cmd);
 		hci_req_cmd_complete(hdev, *opcode, 0x00, req_complete,
 				     req_complete_skb);
 	}
@@ -7539,10 +7539,10 @@
 	}
 
 	/* Only match event if command OGF is not for LE */
-	if (hdev->req_skb &&
-	    hci_opcode_ogf(hci_skb_opcode(hdev->req_skb)) != 0x08 &&
-	    hci_skb_event(hdev->req_skb) == event) {
-		hci_req_cmd_complete(hdev, hci_skb_opcode(hdev->req_skb),
+	if (hdev->sent_cmd &&
+	    hci_opcode_ogf(hci_skb_opcode(hdev->sent_cmd)) != 0x08 &&
+	    hci_skb_event(hdev->sent_cmd) == event) {
+		hci_req_cmd_complete(hdev, hci_skb_opcode(hdev->sent_cmd),
 				     status, &req_complete, &req_complete_skb);
 		req_evt = event;
 	}
Index: net/bluetooth/hci_sync.c
===================================================================
--- net/bluetooth/hci_sync.c	(revision 55465)
+++ net/bluetooth/hci_sync.c	(revision 55464)
@@ -31,10 +31,6 @@
 	hdev->req_result = result;
 	hdev->req_status = HCI_REQ_DONE;
 
-	/* Free the request command so it is not used as response */
-	kfree_skb(hdev->req_skb);
-	hdev->req_skb = NULL;
-
 	if (skb) {
 		struct sock *sk = hci_skb_sk(skb);
 
@@ -42,7 +38,7 @@
 		if (sk)
 			sock_put(sk);
 
-		hdev->req_rsp = skb_get(skb);
+		hdev->req_skb = skb_get(skb);
 	}
 
 	wake_up_interruptible(&hdev->req_wait_q);
@@ -190,8 +186,8 @@
 
 	hdev->req_status = 0;
 	hdev->req_result = 0;
-	skb = hdev->req_rsp;
-	hdev->req_rsp = NULL;
+	skb = hdev->req_skb;
+	hdev->req_skb = NULL;
 
 	bt_dev_dbg(hdev, "end: err %d", err);
 
@@ -655,7 +651,7 @@
 	mutex_unlock(&hdev->cmd_sync_work_lock);
 }
 
-void hci_cmd_sync_cancel(struct hci_dev *hdev, int err)
+void __hci_cmd_sync_cancel(struct hci_dev *hdev, int err)
 {
 	bt_dev_dbg(hdev, "err 0x%2.2x", err);
 
@@ -663,17 +659,15 @@
 		hdev->req_result = err;
 		hdev->req_status = HCI_REQ_CANCELED;
 
-		queue_work(hdev->workqueue, &hdev->cmd_sync_cancel_work);
+		cancel_delayed_work_sync(&hdev->cmd_timer);
+		cancel_delayed_work_sync(&hdev->ncmd_timer);
+		atomic_set(&hdev->cmd_cnt, 1);
+
+		wake_up_interruptible(&hdev->req_wait_q);
 	}
 }
-EXPORT_SYMBOL(hci_cmd_sync_cancel);
 
-/* Cancel ongoing command request synchronously:
- *
- * - Set result and mark status to HCI_REQ_CANCELED
- * - Wakeup command sync thread
- */
-void hci_cmd_sync_cancel_sync(struct hci_dev *hdev, int err)
+void hci_cmd_sync_cancel(struct hci_dev *hdev, int err)
 {
 	bt_dev_dbg(hdev, "err 0x%2.2x", err);
 
@@ -681,17 +675,13 @@
 		hdev->req_result = err;
 		hdev->req_status = HCI_REQ_CANCELED;
 
-		wake_up_interruptible(&hdev->req_wait_q);
+		queue_work(hdev->workqueue, &hdev->cmd_sync_cancel_work);
 	}
 }
-EXPORT_SYMBOL(hci_cmd_sync_cancel_sync);
+EXPORT_SYMBOL(hci_cmd_sync_cancel);
 
-/* Submit HCI command to be run in as cmd_sync_work:
- *
- * - hdev must _not_ be unregistered
- */
-int hci_cmd_sync_submit(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,
-			void *data, hci_cmd_sync_work_destroy_t destroy)
+int hci_cmd_sync_queue(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,
+		       void *data, hci_cmd_sync_work_destroy_t destroy)
 {
 	struct hci_cmd_sync_work_entry *entry;
 	int err = 0;
@@ -721,23 +711,6 @@
 	mutex_unlock(&hdev->unregister_lock);
 	return err;
 }
-EXPORT_SYMBOL(hci_cmd_sync_submit);
-
-/* Queue HCI command:
- *
- * - hdev must be running
- */
-int hci_cmd_sync_queue(struct hci_dev *hdev, hci_cmd_sync_work_func_t func,
-		       void *data, hci_cmd_sync_work_destroy_t destroy)
-{
-	/* Only queue command if hdev is running which means it had been opened
-	 * and is either on init phase or is already up.
-	 */
-	if (!test_bit(HCI_RUNNING, &hdev->flags))
-		return -ENETDOWN;
-
-	return hci_cmd_sync_submit(hdev, func, data, destroy);
-}
 EXPORT_SYMBOL(hci_cmd_sync_queue);
 
 int hci_update_eir_sync(struct hci_dev *hdev)
@@ -4883,11 +4856,6 @@
 			hdev->sent_cmd = NULL;
 		}
 
-		if (hdev->req_skb) {
-			kfree_skb(hdev->req_skb);
-			hdev->req_skb = NULL;
-		}
-
 		clear_bit(HCI_RUNNING, &hdev->flags);
 		hci_sock_dev_event(hdev, HCI_DEV_CLOSE);
 
@@ -5049,12 +5017,6 @@
 		hdev->sent_cmd = NULL;
 	}
 
-	/* Drop last request */
-	if (hdev->req_skb) {
-		kfree_skb(hdev->req_skb);
-		hdev->req_skb = NULL;
-	}
-
 	clear_bit(HCI_RUNNING, &hdev->flags);
 	hci_sock_dev_event(hdev, HCI_DEV_CLOSE);
 
@@ -5247,16 +5209,12 @@
 }
 
 static int hci_le_connect_cancel_sync(struct hci_dev *hdev,
-				      struct hci_conn *conn, u8 reason)
+				      struct hci_conn *conn)
 {
-	/* Return reason if scanning since the connection shall probably be
-	 * cleanup directly.
-	 */
 	if (test_bit(HCI_CONN_SCANNING, &conn->flags))
-		return reason;
+		return 0;
 
-	if (conn->role == HCI_ROLE_SLAVE ||
-	    test_and_set_bit(HCI_CONN_CANCEL, &conn->flags))
+	if (test_and_set_bit(HCI_CONN_CANCEL, &conn->flags))
 		return 0;
 
 	return __hci_cmd_sync_status(hdev, HCI_OP_LE_CREATE_CONN_CANCEL,
@@ -5263,11 +5221,10 @@
 				     0, NULL, HCI_CMD_TIMEOUT);
 }
 
-static int hci_connect_cancel_sync(struct hci_dev *hdev, struct hci_conn *conn,
-				   u8 reason)
+static int hci_connect_cancel_sync(struct hci_dev *hdev, struct hci_conn *conn)
 {
 	if (conn->type == LE_LINK)
-		return hci_le_connect_cancel_sync(hdev, conn, reason);
+		return hci_le_connect_cancel_sync(hdev, conn);
 
 	if (hdev->hci_ver < BLUETOOTH_VER_1_2)
 		return 0;
@@ -5320,11 +5277,9 @@
 	case BT_CONFIG:
 		return hci_disconnect_sync(hdev, conn, reason);
 	case BT_CONNECT:
-		err = hci_connect_cancel_sync(hdev, conn, reason);
+		err = hci_connect_cancel_sync(hdev, conn);
 		/* Cleanup hci_conn object if it cannot be cancelled as it
-		 * likelly means the controller and host stack are out of sync
-		 * or in case of LE it was still scanning so it can be cleanup
-		 * safely.
+		 * likelly means the controller and host stack are out of sync.
 		 */
 		if (err) {
 			hci_dev_lock(hdev);
@@ -6239,7 +6194,7 @@
 
 done:
 	if (err == -ETIMEDOUT)
-		hci_le_connect_cancel_sync(hdev, conn, 0x00);
+		hci_le_connect_cancel_sync(hdev, conn);
 
 	/* Re-enable advertising after the connection attempt is finished. */
 	hci_resume_advertising_sync(hdev);
Index: net/bluetooth/hci_conn.c
===================================================================
--- net/bluetooth/hci_conn.c	(revision 55465)
+++ net/bluetooth/hci_conn.c	(revision 55464)
@@ -175,6 +175,57 @@
 	hci_dev_put(hdev);
 }
 
+static void le_scan_cleanup(struct work_struct *work)
+{
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+					     le_scan_cleanup);
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *c = NULL;
+
+	BT_DBG("%s hcon %p", hdev->name, conn);
+
+	hci_dev_lock(hdev);
+
+	/* Check that the hci_conn is still around */
+	rcu_read_lock();
+	list_for_each_entry_rcu(c, &hdev->conn_hash.list, list) {
+		if (c == conn)
+			break;
+	}
+	rcu_read_unlock();
+
+	if (c == conn) {
+		hci_connect_le_scan_cleanup(conn, 0x00);
+		hci_conn_cleanup(conn);
+	}
+
+	hci_dev_unlock(hdev);
+	hci_dev_put(hdev);
+	hci_conn_put(conn);
+}
+
+static void hci_connect_le_scan_remove(struct hci_conn *conn)
+{
+	BT_DBG("%s hcon %p", conn->hdev->name, conn);
+
+	/* We can't call hci_conn_del/hci_conn_cleanup here since that
+	 * could deadlock with another hci_conn_del() call that's holding
+	 * hci_dev_lock and doing cancel_delayed_work_sync(&conn->disc_work).
+	 * Instead, grab temporary extra references to the hci_dev and
+	 * hci_conn and perform the necessary cleanup in a separate work
+	 * callback.
+	 */
+
+	hci_dev_hold(conn->hdev);
+	hci_conn_get(conn);
+
+	/* Even though we hold a reference to the hdev, many other
+	 * things might get cleaned up meanwhile, including the hdev's
+	 * own workqueue, so we can't use that for scheduling.
+	 */
+	schedule_work(&conn->le_scan_cleanup);
+}
+
 static void hci_acl_create_connection(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -621,6 +672,13 @@
 	if (refcnt > 0)
 		return;
 
+	/* LE connections in scanning state need special handling */
+	if (conn->state == BT_CONNECT && conn->type == LE_LINK &&
+	    test_bit(HCI_CONN_SCANNING, &conn->flags)) {
+		hci_connect_le_scan_remove(conn);
+		return;
+	}
+
 	hci_abort_conn(conn, hci_proto_disconn_ind(conn));
 }
 
@@ -992,6 +1050,7 @@
 	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
 	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
 	INIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);
+	INIT_WORK(&conn->le_scan_cleanup, le_scan_cleanup);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -2778,46 +2837,81 @@
 	return phys;
 }
 
-static int abort_conn_sync(struct hci_dev *hdev, void *data)
+int hci_abort_conn(struct hci_conn *conn, u8 reason)
 {
-	struct hci_conn *conn;
-	u16 handle = PTR_ERR(data);
+	int r = 0;
 
-	conn = hci_conn_hash_lookup_handle(hdev, handle);
-	if (!conn)
+	if (test_and_set_bit(HCI_CONN_CANCEL, &conn->flags))
 		return 0;
 
-	return hci_abort_conn_sync(hdev, conn, conn->abort_reason);
-}
+	switch (conn->state) {
+	case BT_CONNECTED:
+	case BT_CONFIG:
+		if (conn->type == AMP_LINK) {
+			struct hci_cp_disconn_phy_link cp;
 
-int hci_abort_conn(struct hci_conn *conn, u8 reason)
-{
-	struct hci_dev *hdev = conn->hdev;
+			cp.phy_handle = HCI_PHY_HANDLE(conn->handle);
+			cp.reason = reason;
+			r = hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHY_LINK,
+					 sizeof(cp), &cp);
+		} else {
+			struct hci_cp_disconnect dc;
 
-	/* If abort_reason has already been set it means the connection is
-	 * already being aborted so don't attempt to overwrite it.
-	 */
-	if (conn->abort_reason)
-		return 0;
+			dc.handle = cpu_to_le16(conn->handle);
+			dc.reason = reason;
+			r = hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT,
+					 sizeof(dc), &dc);
+		}
 
-	bt_dev_dbg(hdev, "handle 0x%2.2x reason 0x%2.2x", conn->handle, reason);
+		conn->state = BT_DISCONN;
 
-	conn->abort_reason = reason;
+		break;
+	case BT_CONNECT:
+		if (conn->type == LE_LINK) {
+			if (test_bit(HCI_CONN_SCANNING, &conn->flags))
+				break;
+			r = hci_send_cmd(conn->hdev,
+					 HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
+		} else if (conn->type == ACL_LINK) {
+			if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
+				break;
+			r = hci_send_cmd(conn->hdev,
+					 HCI_OP_CREATE_CONN_CANCEL,
+					 6, &conn->dst);
+		}
+		break;
+	case BT_CONNECT2:
+		if (conn->type == ACL_LINK) {
+			struct hci_cp_reject_conn_req rej;
 
-	/* If the connection is pending check the command opcode since that
-	 * might be blocking on hci_cmd_sync_work while waiting its respective
-	 * event so we need to hci_cmd_sync_cancel to cancel it.
-	 */
-	if (conn->state == BT_CONNECT && hdev->req_status == HCI_REQ_PEND) {
-		switch (hci_skb_event(hdev->sent_cmd)) {
-		case HCI_EV_LE_CONN_COMPLETE:
-		case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
-		case HCI_EVT_LE_CIS_ESTABLISHED:
-			hci_cmd_sync_cancel(hdev, ECANCELED);
-			break;
+			bacpy(&rej.bdaddr, &conn->dst);
+			rej.reason = reason;
+
+			r = hci_send_cmd(conn->hdev,
+					 HCI_OP_REJECT_CONN_REQ,
+					 sizeof(rej), &rej);
+		} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
+			struct hci_cp_reject_sync_conn_req rej;
+
+			bacpy(&rej.bdaddr, &conn->dst);
+
+			/* SCO rejection has its own limited set of
+			 * allowed error values (0x0D-0x0F) which isn't
+			 * compatible with most values passed to this
+			 * function. To be safe hard-code one of the
+			 * values that's suitable for SCO.
+			 */
+			rej.reason = HCI_ERROR_REJ_LIMITED_RESOURCES;
+
+			r = hci_send_cmd(conn->hdev,
+					 HCI_OP_REJECT_SYNC_CONN_REQ,
+					 sizeof(rej), &rej);
 		}
+		break;
+	default:
+		conn->state = BT_CLOSED;
+		break;
 	}
 
-	return hci_cmd_sync_queue(hdev, abort_conn_sync, ERR_PTR(conn->handle),
-				  NULL);
+	return r;
 }
Index: net/bluetooth/af_bluetooth.c
===================================================================
--- net/bluetooth/af_bluetooth.c	(revision 55465)
+++ net/bluetooth/af_bluetooth.c	(revision 55464)
@@ -264,11 +264,14 @@
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
+	lock_sock(sk);
+
 	skb = skb_recv_datagram(sk, flags, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			err = 0;
 
+		release_sock(sk);
 		return err;
 	}
 
@@ -294,6 +297,8 @@
 
 	skb_free_datagram(sk, skb);
 
+	release_sock(sk);
+
 	if (flags & MSG_TRUNC)
 		copied = skblen;
 
@@ -516,11 +521,10 @@
 		if (sk->sk_state == BT_LISTEN)
 			return -EINVAL;
 
-		spin_lock(&sk->sk_receive_queue.lock);
+		lock_sock(sk);
 		skb = skb_peek(&sk->sk_receive_queue);
 		amount = skb ? skb->len : 0;
-		spin_unlock(&sk->sk_receive_queue.lock);
-
+		release_sock(sk);
 		err = put_user(amount, (int __user *)arg);
 		break;
 
Index: net/bluetooth/mgmt.c
===================================================================
--- net/bluetooth/mgmt.c	(revision 55465)
+++ net/bluetooth/mgmt.c	(revision 55464)
@@ -1039,8 +1039,6 @@
 	hci_cmd_sync_queue(hdev, rpa_expired_sync, NULL, NULL);
 }
 
-static int set_discoverable_sync(struct hci_dev *hdev, void *data);
-
 static void discov_off(struct work_struct *work)
 {
 	struct hci_dev *hdev = container_of(work, struct hci_dev,
@@ -1059,7 +1057,7 @@
 	hci_dev_clear_flag(hdev, HCI_DISCOVERABLE);
 	hdev->discov_timeout = 0;
 
-	hci_cmd_sync_queue(hdev, set_discoverable_sync, NULL, NULL);
+	hci_update_discoverable(hdev);
 
 	mgmt_new_settings(hdev);
 
@@ -1401,16 +1399,8 @@
 		goto failed;
 	}
 
-	/* Cancel potentially blocking sync operation before power off */
-	if (cp->val == 0x00) {
-		hci_cmd_sync_cancel_sync(hdev, -EHOSTDOWN);
-		err = hci_cmd_sync_queue(hdev, set_powered_sync, cmd,
-					 mgmt_set_powered_complete);
-	} else {
-		/* Use hci_cmd_sync_submit since hdev might not be running */
-		err = hci_cmd_sync_submit(hdev, set_powered_sync, cmd,
-					  mgmt_set_powered_complete);
-	}
+	err = hci_cmd_sync_queue(hdev, set_powered_sync, cmd,
+				 mgmt_set_powered_complete);
 
 	if (err < 0)
 		mgmt_pending_remove(cmd);
@@ -3583,6 +3573,18 @@
 	return err;
 }
 
+static int abort_conn_sync(struct hci_dev *hdev, void *data)
+{
+	struct hci_conn *conn;
+	u16 handle = PTR_ERR(data);
+
+	conn = hci_conn_hash_lookup_handle(hdev, handle);
+	if (!conn)
+		return 0;
+
+	return hci_abort_conn_sync(hdev, conn, HCI_ERROR_REMOTE_USER_TERM);
+}
+
 static int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,
 			      u16 len)
 {
@@ -3633,7 +3635,8 @@
 					      le_addr_type(addr->type));
 
 	if (conn->conn_reason == CONN_REASON_PAIR_DEVICE)
-		hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);
+		hci_cmd_sync_queue(hdev, abort_conn_sync, ERR_PTR(conn->handle),
+				   NULL);
 
 unlock:
 	hci_dev_unlock(hdev);
@@ -5378,9 +5381,9 @@
 	for (i = 0; i < pattern_count; i++) {
 		offset = patterns[i].offset;
 		length = patterns[i].length;
-		if (offset >= HCI_MAX_EXT_AD_LENGTH ||
-		    length > HCI_MAX_EXT_AD_LENGTH ||
-		    (offset + length) > HCI_MAX_EXT_AD_LENGTH)
+		if (offset >= HCI_MAX_AD_LENGTH ||
+		    length > HCI_MAX_AD_LENGTH ||
+		    (offset + length) > HCI_MAX_AD_LENGTH)
 			return MGMT_STATUS_INVALID_PARAMS;
 
 		p = kmalloc(sizeof(*p), GFP_KERNEL);
@@ -8436,8 +8439,8 @@
 	supported_flags = get_supported_adv_flags(hdev);
 
 	rp->supported_flags = cpu_to_le32(supported_flags);
-	rp->max_adv_data_len = max_adv_len(hdev);
-	rp->max_scan_rsp_len = max_adv_len(hdev);
+	rp->max_adv_data_len = HCI_MAX_AD_LENGTH;
+	rp->max_scan_rsp_len = HCI_MAX_AD_LENGTH;
 	rp->max_instances = hdev->le_num_of_adv_sets;
 	rp->num_instances = hdev->adv_instance_cnt;
 
@@ -8465,7 +8468,7 @@
 
 static u8 calculate_name_len(struct hci_dev *hdev)
 {
-	u8 buf[HCI_MAX_SHORT_NAME_LENGTH + 2]; /* len + type + name */
+	u8 buf[HCI_MAX_SHORT_NAME_LENGTH + 3];
 
 	return eir_append_local_name(hdev, buf, 0);
 }
@@ -8473,7 +8476,7 @@
 static u8 tlv_data_max_len(struct hci_dev *hdev, u32 adv_flags,
 			   bool is_adv_data)
 {
-	u8 max_len = max_adv_len(hdev);
+	u8 max_len = HCI_MAX_AD_LENGTH;
 
 	if (is_adv_data) {
 		if (adv_flags & (MGMT_ADV_FLAG_DISCOV |
@@ -9761,6 +9764,14 @@
 	struct mgmt_ev_device_disconnected ev;
 	struct sock *sk = NULL;
 
+	/* The connection is still in hci_conn_hash so test for 1
+	 * instead of 0 to know if this is the last one.
+	 */
+	if (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {
+		cancel_delayed_work(&hdev->power_off);
+		queue_work(hdev->req_workqueue, &hdev->power_off.work);
+	}
+
 	if (!mgmt_connected)
 		return;
 
@@ -9817,6 +9828,14 @@
 {
 	struct mgmt_ev_connect_failed ev;
 
+	/* The connection is still in hci_conn_hash so test for 1
+	 * instead of 0 to know if this is the last one.
+	 */
+	if (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {
+		cancel_delayed_work(&hdev->power_off);
+		queue_work(hdev->req_workqueue, &hdev->power_off.work);
+	}
+
 	bacpy(&ev.addr.bdaddr, bdaddr);
 	ev.addr.type = link_to_bdaddr(link_type, addr_type);
 	ev.status = mgmt_status(status);
Index: net/bluetooth/eir.c
===================================================================
--- net/bluetooth/eir.c	(revision 55465)
+++ net/bluetooth/eir.c	(revision 55464)
@@ -13,33 +13,48 @@
 
 #define PNP_INFO_SVCLASS_ID		0x1200
 
+static u8 eir_append_name(u8 *eir, u16 eir_len, u8 type, u8 *data, u8 data_len)
+{
+	u8 name[HCI_MAX_SHORT_NAME_LENGTH + 1];
+
+	/* If data is already NULL terminated just pass it directly */
+	if (data[data_len - 1] == '\0')
+		return eir_append_data(eir, eir_len, type, data, data_len);
+
+	memcpy(name, data, HCI_MAX_SHORT_NAME_LENGTH);
+	name[HCI_MAX_SHORT_NAME_LENGTH] = '\0';
+
+	return eir_append_data(eir, eir_len, type, name, sizeof(name));
+}
+
 u8 eir_append_local_name(struct hci_dev *hdev, u8 *ptr, u8 ad_len)
 {
 	size_t short_len;
 	size_t complete_len;
 
-	/* no space left for name (+ type + len) */
-	if ((max_adv_len(hdev) - ad_len) < HCI_MAX_SHORT_NAME_LENGTH + 2)
+	/* no space left for name (+ NULL + type + len) */
+	if ((HCI_MAX_AD_LENGTH - ad_len) < HCI_MAX_SHORT_NAME_LENGTH + 3)
 		return ad_len;
 
 	/* use complete name if present and fits */
 	complete_len = strnlen(hdev->dev_name, sizeof(hdev->dev_name));
 	if (complete_len && complete_len <= HCI_MAX_SHORT_NAME_LENGTH)
-		return eir_append_data(ptr, ad_len, EIR_NAME_COMPLETE,
-				       hdev->dev_name, complete_len);
+		return eir_append_name(ptr, ad_len, EIR_NAME_COMPLETE,
+				       hdev->dev_name, complete_len + 1);
 
 	/* use short name if present */
 	short_len = strnlen(hdev->short_name, sizeof(hdev->short_name));
 	if (short_len)
-		return eir_append_data(ptr, ad_len, EIR_NAME_SHORT,
+		return eir_append_name(ptr, ad_len, EIR_NAME_SHORT,
 				       hdev->short_name,
-				       short_len);
+				       short_len == HCI_MAX_SHORT_NAME_LENGTH ?
+				       short_len : short_len + 1);
 
 	/* use shortened full name if present, we already know that name
 	 * is longer then HCI_MAX_SHORT_NAME_LENGTH
 	 */
 	if (complete_len)
-		return eir_append_data(ptr, ad_len, EIR_NAME_SHORT,
+		return eir_append_name(ptr, ad_len, EIR_NAME_SHORT,
 				       hdev->dev_name,
 				       HCI_MAX_SHORT_NAME_LENGTH);
 
Index: net/bluetooth/hci_request.c
===================================================================
--- net/bluetooth/hci_request.c	(revision 55465)
+++ net/bluetooth/hci_request.c	(revision 55464)
@@ -916,7 +916,7 @@
 
 void hci_request_cancel_all(struct hci_dev *hdev)
 {
-	hci_cmd_sync_cancel_sync(hdev, ENODEV);
+	__hci_cmd_sync_cancel(hdev, ENODEV);
 
 	cancel_interleave_scan(hdev);
 }
Index: net/bluetooth/rfcomm/core.c
===================================================================
--- net/bluetooth/rfcomm/core.c	(revision 55465)
+++ net/bluetooth/rfcomm/core.c	(revision 55464)
@@ -1937,7 +1937,7 @@
 	/* Get data directly from socket receive queue without copying it. */
 	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
 		skb_orphan(skb);
-		if (!skb_linearize(skb) && sk->sk_state != BT_CLOSED) {
+		if (!skb_linearize(skb)) {
 			s = rfcomm_recv_frame(s, skb);
 			if (!s)
 				break;
Index: net/core/dev.c
===================================================================
--- net/core/dev.c	(revision 55465)
+++ net/core/dev.c	(revision 55464)
@@ -2272,7 +2272,7 @@
 	rcu_read_lock();
 again:
 	list_for_each_entry_rcu(ptype, ptype_list, list) {
-		if (READ_ONCE(ptype->ignore_outgoing))
+		if (ptype->ignore_outgoing)
 			continue;
 
 		/* Never send packets back to the socket
@@ -6814,8 +6814,6 @@
 	void *have;
 
 	while (!napi_thread_wait(napi)) {
-		unsigned long last_qs = jiffies;
-
 		for (;;) {
 			bool repoll = false;
 
@@ -6830,7 +6828,6 @@
 			if (!repoll)
 				break;
 
-			rcu_softirq_qs_periodic(last_qs);
 			cond_resched();
 		}
 	}
Index: net/core/skbuff.c
===================================================================
--- net/core/skbuff.c	(revision 55465)
+++ net/core/skbuff.c	(revision 55464)
@@ -6620,14 +6620,6 @@
 			xfrm_state_hold(sp->xvec[i]);
 	}
 #endif
-#ifdef CONFIG_MCTP_FLOWS
-	if (old_active & (1 << SKB_EXT_MCTP)) {
-		struct mctp_flow *flow = skb_ext_get_ptr(old, SKB_EXT_MCTP);
-
-		if (flow->key)
-			refcount_inc(&flow->key->refs);
-	}
-#endif
 	__skb_ext_put(old);
 	return new;
 }
Index: net/core/scm.c
===================================================================
--- net/core/scm.c	(revision 55465)
+++ net/core/scm.c	(revision 55464)
@@ -105,7 +105,7 @@
 		if (fd < 0 || !(file = fget_raw(fd)))
 			return -EBADF;
 		/* don't allow io_uring files */
-		if (io_is_uring_fops(file)) {
+		if (io_uring_get_socket(file)) {
 			fput(file);
 			return -EINVAL;
 		}
Index: net/core/sock_diag.c
===================================================================
--- net/core/sock_diag.c	(revision 55465)
+++ net/core/sock_diag.c	(revision 55464)
@@ -175,7 +175,7 @@
 	if (sock_diag_handlers[hndl->family])
 		err = -EBUSY;
 	else
-		WRITE_ONCE(sock_diag_handlers[hndl->family], hndl);
+		sock_diag_handlers[hndl->family] = hndl;
 	mutex_unlock(&sock_diag_table_mutex);
 
 	return err;
@@ -191,7 +191,7 @@
 
 	mutex_lock(&sock_diag_table_mutex);
 	BUG_ON(sock_diag_handlers[family] != hnld);
-	WRITE_ONCE(sock_diag_handlers[family], NULL);
+	sock_diag_handlers[family] = NULL;
 	mutex_unlock(&sock_diag_table_mutex);
 }
 EXPORT_SYMBOL_GPL(sock_diag_unregister);
@@ -209,7 +209,7 @@
 		return -EINVAL;
 	req->sdiag_family = array_index_nospec(req->sdiag_family, AF_MAX);
 
-	if (READ_ONCE(sock_diag_handlers[req->sdiag_family]) == NULL)
+	if (sock_diag_handlers[req->sdiag_family] == NULL)
 		sock_load_diag_module(req->sdiag_family, 0);
 
 	mutex_lock(&sock_diag_table_mutex);
@@ -268,12 +268,12 @@
 	switch (group) {
 	case SKNLGRP_INET_TCP_DESTROY:
 	case SKNLGRP_INET_UDP_DESTROY:
-		if (!READ_ONCE(sock_diag_handlers[AF_INET]))
+		if (!sock_diag_handlers[AF_INET])
 			sock_load_diag_module(AF_INET, 0);
 		break;
 	case SKNLGRP_INET6_TCP_DESTROY:
 	case SKNLGRP_INET6_UDP_DESTROY:
-		if (!READ_ONCE(sock_diag_handlers[AF_INET6]))
+		if (!sock_diag_handlers[AF_INET6])
 			sock_load_diag_module(AF_INET6, 0);
 		break;
 	}
Index: net/hsr/hsr_framereg.c
===================================================================
--- net/hsr/hsr_framereg.c	(revision 55465)
+++ net/hsr/hsr_framereg.c	(revision 55464)
@@ -235,10 +235,6 @@
 	 */
 	if (ethhdr->h_proto == htons(ETH_P_PRP) ||
 	    ethhdr->h_proto == htons(ETH_P_HSR)) {
-		/* Check if skb contains hsr_ethhdr */
-		if (skb->mac_len < sizeof(struct hsr_ethhdr))
-			return NULL;
-
 		/* Use the existing sequence_nr from the tag as starting point
 		 * for filtering duplicate frames.
 		 */
Index: net/hsr/hsr_main.c
===================================================================
--- net/hsr/hsr_main.c	(revision 55465)
+++ net/hsr/hsr_main.c	(revision 55464)
@@ -148,21 +148,14 @@
 
 static int __init hsr_init(void)
 {
-	int err;
+	int res;
 
 	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);
 
-	err = register_netdevice_notifier(&hsr_nb);
-	if (err)
-		return err;
+	register_netdevice_notifier(&hsr_nb);
+	res = hsr_netlink_init();
 
-	err = hsr_netlink_init();
-	if (err) {
-		unregister_netdevice_notifier(&hsr_nb);
-		return err;
-	}
-
-	return 0;
+	return res;
 }
 
 static void __exit hsr_exit(void)
Index: net/ipv4/ip_tunnel.c
===================================================================
--- net/ipv4/ip_tunnel.c	(revision 55465)
+++ net/ipv4/ip_tunnel.c	(revision 55464)
@@ -364,7 +364,7 @@
 		  bool log_ecn_error)
 {
 	const struct iphdr *iph = ip_hdr(skb);
-	int nh, err;
+	int err;
 
 #ifdef CONFIG_NET_IPGRE_BROADCAST
 	if (ipv4_is_multicast(iph->daddr)) {
@@ -390,21 +390,8 @@
 		tunnel->i_seqno = ntohl(tpi->seq) + 1;
 	}
 
-	/* Save offset of outer header relative to skb->head,
-	 * because we are going to reset the network header to the inner header
-	 * and might change skb->head.
-	 */
-	nh = skb_network_header(skb) - skb->head;
-
 	skb_set_network_header(skb, (tunnel->dev->type == ARPHRD_ETHER) ? ETH_HLEN : 0);
 
-	if (!pskb_inet_may_pull(skb)) {
-		DEV_STATS_INC(tunnel->dev, rx_length_errors);
-		DEV_STATS_INC(tunnel->dev, rx_errors);
-		goto drop;
-	}
-	iph = (struct iphdr *)(skb->head + nh);
-
 	err = IP_ECN_decapsulate(iph, skb);
 	if (unlikely(err)) {
 		if (log_ecn_error)
Index: net/ipv4/inet_hashtables.c
===================================================================
--- net/ipv4/inet_hashtables.c	(revision 55465)
+++ net/ipv4/inet_hashtables.c	(revision 55464)
@@ -1117,7 +1117,7 @@
 		sock_prot_inuse_add(net, sk->sk_prot, -1);
 
 		spin_lock(lock);
-		__sk_nulls_del_node_init_rcu(sk);
+		sk_nulls_del_node_init_rcu(sk);
 		spin_unlock(lock);
 
 		sk->sk_hash = 0;
Index: net/ipv4/ipmr.c
===================================================================
--- net/ipv4/ipmr.c	(revision 55465)
+++ net/ipv4/ipmr.c	(revision 55464)
@@ -1582,11 +1582,9 @@
 
 	if (copy_from_sockptr(&olr, optlen, sizeof(int)))
 		return -EFAULT;
+	olr = min_t(unsigned int, olr, sizeof(int));
 	if (olr < 0)
 		return -EINVAL;
-
-	olr = min_t(unsigned int, olr, sizeof(int));
-
 	if (copy_to_sockptr(optlen, &olr, sizeof(int)))
 		return -EFAULT;
 	if (copy_to_sockptr(optval, &val, olr))
Index: net/ipv4/raw.c
===================================================================
--- net/ipv4/raw.c	(revision 55465)
+++ net/ipv4/raw.c	(revision 55464)
@@ -348,7 +348,6 @@
 		goto error;
 	skb_reserve(skb, hlen);
 
-	skb->protocol = htons(ETH_P_IP);
 	skb->priority = READ_ONCE(sk->sk_priority);
 	skb->mark = sockc->mark;
 	skb->tstamp = sockc->transmit_time;
Index: net/ipv4/tcp.c
===================================================================
--- net/ipv4/tcp.c	(revision 55465)
+++ net/ipv4/tcp.c	(revision 55464)
@@ -4102,11 +4102,11 @@
 	if (copy_from_sockptr(&len, optlen, sizeof(int)))
 		return -EFAULT;
 
+	len = min_t(unsigned int, len, sizeof(int));
+
 	if (len < 0)
 		return -EINVAL;
 
-	len = min_t(unsigned int, len, sizeof(int));
-
 	switch (optname) {
 	case TCP_MAXSEG:
 		val = tp->mss_cache;
Index: net/ipv4/udp.c
===================================================================
--- net/ipv4/udp.c	(revision 55465)
+++ net/ipv4/udp.c	(revision 55464)
@@ -2790,11 +2790,11 @@
 	if (get_user(len, optlen))
 		return -EFAULT;
 
+	len = min_t(unsigned int, len, sizeof(int));
+
 	if (len < 0)
 		return -EINVAL;
 
-	len = min_t(unsigned int, len, sizeof(int));
-
 	switch (optname) {
 	case UDP_CORK:
 		val = udp_test_bit(CORK, sk);
Index: net/ipv4/inet_diag.c
===================================================================
--- net/ipv4/inet_diag.c	(revision 55465)
+++ net/ipv4/inet_diag.c	(revision 55464)
@@ -57,7 +57,7 @@
 		return ERR_PTR(-ENOENT);
 	}
 
-	if (!READ_ONCE(inet_diag_table[proto]))
+	if (!inet_diag_table[proto])
 		sock_load_diag_module(AF_INET, proto);
 
 	mutex_lock(&inet_diag_table_mutex);
@@ -1419,7 +1419,7 @@
 	mutex_lock(&inet_diag_table_mutex);
 	err = -EEXIST;
 	if (!inet_diag_table[type]) {
-		WRITE_ONCE(inet_diag_table[type], h);
+		inet_diag_table[type] = h;
 		err = 0;
 	}
 	mutex_unlock(&inet_diag_table_mutex);
@@ -1436,7 +1436,7 @@
 		return;
 
 	mutex_lock(&inet_diag_table_mutex);
-	WRITE_ONCE(inet_diag_table[type], NULL);
+	inet_diag_table[type] = NULL;
 	mutex_unlock(&inet_diag_table_mutex);
 }
 EXPORT_SYMBOL_GPL(inet_diag_unregister);
Index: net/ipv4/inet_timewait_sock.c
===================================================================
--- net/ipv4/inet_timewait_sock.c	(revision 55465)
+++ net/ipv4/inet_timewait_sock.c	(revision 55464)
@@ -281,12 +281,12 @@
 }
 EXPORT_SYMBOL_GPL(__inet_twsk_schedule);
 
-/* Remove all non full sockets (TIME_WAIT and NEW_SYN_RECV) for dead netns */
 void inet_twsk_purge(struct inet_hashinfo *hashinfo, int family)
 {
+	struct inet_timewait_sock *tw;
+	struct sock *sk;
 	struct hlist_nulls_node *node;
 	unsigned int slot;
-	struct sock *sk;
 
 	for (slot = 0; slot <= hashinfo->ehash_mask; slot++) {
 		struct inet_ehash_bucket *head = &hashinfo->ehash[slot];
@@ -295,35 +295,38 @@
 		rcu_read_lock();
 restart:
 		sk_nulls_for_each_rcu(sk, node, &head->chain) {
-			int state = inet_sk_state_load(sk);
+			if (sk->sk_state != TCP_TIME_WAIT) {
+				/* A kernel listener socket might not hold refcnt for net,
+				 * so reqsk_timer_handler() could be fired after net is
+				 * freed.  Userspace listener and reqsk never exist here.
+				 */
+				if (unlikely(sk->sk_state == TCP_NEW_SYN_RECV &&
+					     hashinfo->pernet)) {
+					struct request_sock *req = inet_reqsk(sk);
 
-			if ((1 << state) & ~(TCPF_TIME_WAIT |
-					     TCPF_NEW_SYN_RECV))
+					inet_csk_reqsk_queue_drop_and_put(req->rsk_listener, req);
+				}
+
 				continue;
+			}
 
-			if (sk->sk_family != family ||
-			    refcount_read(&sock_net(sk)->ns.count))
+			tw = inet_twsk(sk);
+			if ((tw->tw_family != family) ||
+				refcount_read(&twsk_net(tw)->ns.count))
 				continue;
 
-			if (unlikely(!refcount_inc_not_zero(&sk->sk_refcnt)))
+			if (unlikely(!refcount_inc_not_zero(&tw->tw_refcnt)))
 				continue;
 
-			if (unlikely(sk->sk_family != family ||
-				     refcount_read(&sock_net(sk)->ns.count))) {
-				sock_gen_put(sk);
+			if (unlikely((tw->tw_family != family) ||
+				     refcount_read(&twsk_net(tw)->ns.count))) {
+				inet_twsk_put(tw);
 				goto restart;
 			}
 
 			rcu_read_unlock();
 			local_bh_disable();
-			if (state == TCP_TIME_WAIT) {
-				inet_twsk_deschedule_put(inet_twsk(sk));
-			} else {
-				struct request_sock *req = inet_reqsk(sk);
-
-				inet_csk_reqsk_queue_drop_and_put(req->rsk_listener,
-								  req);
-			}
+			inet_twsk_deschedule_put(tw);
 			local_bh_enable();
 			goto restart_rcu;
 		}
Index: net/ipv4/tcp_minisocks.c
===================================================================
--- net/ipv4/tcp_minisocks.c	(revision 55465)
+++ net/ipv4/tcp_minisocks.c	(revision 55464)
@@ -357,6 +357,10 @@
 			/* Even if tw_refcount == 1, we must clean up kernel reqsk */
 			inet_twsk_purge(net->ipv4.tcp_death_row.hashinfo, family);
 		} else if (!purged_once) {
+			/* The last refcount is decremented in tcp_sk_exit_batch() */
+			if (refcount_read(&net->ipv4.tcp_death_row.tw_refcount) == 1)
+				continue;
+
 			inet_twsk_purge(&tcp_hashinfo, family);
 			purged_once = true;
 		}
Index: net/ipv6/mcast.c
===================================================================
--- net/ipv6/mcast.c	(revision 55465)
+++ net/ipv6/mcast.c	(revision 55464)
@@ -2722,6 +2722,7 @@
 	/* Should stop work after group drop. or we will
 	 * start work again in mld_ifc_event()
 	 */
+	synchronize_net();
 	mld_query_stop_work(idev);
 	mld_report_stop_work(idev);
 
Index: net/ipv6/fib6_rules.c
===================================================================
--- net/ipv6/fib6_rules.c	(revision 55465)
+++ net/ipv6/fib6_rules.c	(revision 55464)
@@ -453,11 +453,6 @@
 	       + nla_total_size(16); /* src */
 }
 
-static void fib6_rule_flush_cache(struct fib_rules_ops *ops)
-{
-	rt_genid_bump_ipv6(ops->fro_net);
-}
-
 static const struct fib_rules_ops __net_initconst fib6_rules_ops_template = {
 	.family			= AF_INET6,
 	.rule_size		= sizeof(struct fib6_rule),
@@ -470,7 +465,6 @@
 	.compare		= fib6_rule_compare,
 	.fill			= fib6_rule_fill,
 	.nlmsg_payload		= fib6_rule_nlmsg_payload,
-	.flush_cache		= fib6_rule_flush_cache,
 	.nlgroup		= RTNLGRP_IPV6_RULE,
 	.owner			= THIS_MODULE,
 	.fro_net		= &init_net,
Index: net/mctp/route.c
===================================================================
--- net/mctp/route.c	(revision 55465)
+++ net/mctp/route.c	(revision 55464)
@@ -843,9 +843,6 @@
 		/* copy message payload */
 		skb_copy_bits(skb, pos, skb_transport_header(skb2), size);
 
-		/* we need to copy the extensions, for MCTP flow data */
-		skb_ext_copy(skb2, skb);
-
 		/* do route */
 		rc = rt->output(rt, skb2);
 		if (rc)
Index: net/netfilter/nf_tables_api.c
===================================================================
--- net/netfilter/nf_tables_api.c	(revision 55465)
+++ net/netfilter/nf_tables_api.c	(revision 55464)
@@ -1205,7 +1205,7 @@
 	if (flags & ~NFT_TABLE_F_MASK)
 		return -EOPNOTSUPP;
 
-	if (flags == (ctx->table->flags & NFT_TABLE_F_MASK))
+	if (flags == ctx->table->flags)
 		return 0;
 
 	if ((nft_table_has_owner(ctx->table) &&
Index: net/netfilter/nft_set_pipapo.c
===================================================================
--- net/netfilter/nft_set_pipapo.c	(revision 55465)
+++ net/netfilter/nft_set_pipapo.c	(revision 55464)
@@ -2240,6 +2240,8 @@
 	if (m) {
 		rcu_barrier();
 
+		nft_set_pipapo_match_destroy(ctx, set, m);
+
 		for_each_possible_cpu(cpu)
 			pipapo_free_scratch(m, cpu);
 		free_percpu(m->scratch);
@@ -2251,7 +2253,8 @@
 	if (priv->clone) {
 		m = priv->clone;
 
-		nft_set_pipapo_match_destroy(ctx, set, m);
+		if (priv->dirty)
+			nft_set_pipapo_match_destroy(ctx, set, m);
 
 		for_each_possible_cpu(cpu)
 			pipapo_free_scratch(priv->clone, cpu);
Index: net/rds/send.c
===================================================================
--- net/rds/send.c	(revision 55465)
+++ net/rds/send.c	(revision 55464)
@@ -103,12 +103,13 @@
 
 static int acquire_in_xmit(struct rds_conn_path *cp)
 {
-	return test_and_set_bit_lock(RDS_IN_XMIT, &cp->cp_flags) == 0;
+	return test_and_set_bit(RDS_IN_XMIT, &cp->cp_flags) == 0;
 }
 
 static void release_in_xmit(struct rds_conn_path *cp)
 {
-	clear_bit_unlock(RDS_IN_XMIT, &cp->cp_flags);
+	clear_bit(RDS_IN_XMIT, &cp->cp_flags);
+	smp_mb__after_atomic();
 	/*
 	 * We don't use wait_on_bit()/wake_up_bit() because our waking is in a
 	 * hot path and finding waiters is very rare.  We don't want to walk
Index: net/unix/garbage.c
===================================================================
--- net/unix/garbage.c	(revision 55465)
+++ net/unix/garbage.c	(revision 55464)
@@ -198,7 +198,7 @@
 	if (READ_ONCE(unix_tot_inflight) > UNIX_INFLIGHT_TRIGGER_GC &&
 	    !READ_ONCE(gc_in_progress))
 		unix_gc();
-	wait_event(unix_gc_wait, !READ_ONCE(gc_in_progress));
+	wait_event(unix_gc_wait, gc_in_progress == false);
 }
 
 /* The external entry point: unix_gc() */
Index: net/unix/scm.c
===================================================================
--- net/unix/scm.c	(revision 55465)
+++ net/unix/scm.c	(revision 55464)
@@ -34,8 +34,10 @@
 		/* PF_UNIX ? */
 		if (s && sock->ops && sock->ops->family == PF_UNIX)
 			u_sock = s;
+	} else {
+		/* Could be an io_uring instance */
+		u_sock = io_uring_get_socket(filp);
 	}
-
 	return u_sock;
 }
 EXPORT_SYMBOL(unix_get_socket);
Index: net/sched/sch_taprio.c
===================================================================
--- net/sched/sch_taprio.c	(revision 55465)
+++ net/sched/sch_taprio.c	(revision 55464)
@@ -765,8 +765,7 @@
 };
 
 static const struct nla_policy taprio_tc_policy[TCA_TAPRIO_TC_ENTRY_MAX + 1] = {
-	[TCA_TAPRIO_TC_ENTRY_INDEX]	   = NLA_POLICY_MAX(NLA_U32,
-							    TC_QOPT_MAX_QUEUE),
+	[TCA_TAPRIO_TC_ENTRY_INDEX]	   = { .type = NLA_U32 },
 	[TCA_TAPRIO_TC_ENTRY_MAX_SDU]	   = { .type = NLA_U32 },
 };
 
Index: net/l2tp/l2tp_ppp.c
===================================================================
--- net/l2tp/l2tp_ppp.c	(revision 55465)
+++ net/l2tp/l2tp_ppp.c	(revision 55464)
@@ -1356,11 +1356,11 @@
 	if (get_user(len, optlen))
 		return -EFAULT;
 
+	len = min_t(unsigned int, len, sizeof(int));
+
 	if (len < 0)
 		return -EINVAL;
 
-	len = min_t(unsigned int, len, sizeof(int));
-
 	err = -ENOTCONN;
 	if (!sk->sk_user_data)
 		goto end;
Index: net/mac80211/rate.c
===================================================================
--- net/mac80211/rate.c	(revision 55465)
+++ net/mac80211/rate.c	(revision 55464)
@@ -119,8 +119,7 @@
 		rcu_read_unlock();
 	}
 
-	if (sta->uploaded)
-		drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
+	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
 }
 
 int ieee80211_rate_control_register(const struct rate_control_ops *ops)
Index: net/packet/af_packet.c
===================================================================
--- net/packet/af_packet.c	(revision 55465)
+++ net/packet/af_packet.c	(revision 55464)
@@ -3984,7 +3984,7 @@
 		if (val < 0 || val > 1)
 			return -EINVAL;
 
-		WRITE_ONCE(po->prot_hook.ignore_outgoing, !!val);
+		po->prot_hook.ignore_outgoing = !!val;
 		return 0;
 	}
 	case PACKET_TX_HAS_OFF:
@@ -4130,7 +4130,7 @@
 		       0);
 		break;
 	case PACKET_IGNORE_OUTGOING:
-		val = READ_ONCE(po->prot_hook.ignore_outgoing);
+		val = po->prot_hook.ignore_outgoing;
 		break;
 	case PACKET_ROLLOVER_STATS:
 		if (!po->rollover)
Index: net/sunrpc/addr.c
===================================================================
--- net/sunrpc/addr.c	(revision 55465)
+++ net/sunrpc/addr.c	(revision 55464)
@@ -284,10 +284,10 @@
 	}
 
 	if (snprintf(portbuf, sizeof(portbuf),
-		     ".%u.%u", port >> 8, port & 0xff) >= (int)sizeof(portbuf))
+		     ".%u.%u", port >> 8, port & 0xff) > (int)sizeof(portbuf))
 		return NULL;
 
-	if (strlcat(addrbuf, portbuf, sizeof(addrbuf)) >= sizeof(addrbuf))
+	if (strlcat(addrbuf, portbuf, sizeof(addrbuf)) > sizeof(addrbuf))
 		return NULL;
 
 	return kstrdup(addrbuf, gfp_flags);
Index: net/sunrpc/auth_gss/gss_rpc_xdr.c
===================================================================
--- net/sunrpc/auth_gss/gss_rpc_xdr.c	(revision 55465)
+++ net/sunrpc/auth_gss/gss_rpc_xdr.c	(revision 55464)
@@ -250,8 +250,8 @@
 
 	creds = kzalloc(sizeof(struct svc_cred), GFP_KERNEL);
 	if (!creds) {
-		err = -ENOMEM;
-		goto free_oa;
+		kfree(oa->data);
+		return -ENOMEM;
 	}
 
 	oa->data[0].option.data = CREDS_VALUE;
@@ -265,17 +265,13 @@
 
 		/* option buffer */
 		p = xdr_inline_decode(xdr, 4);
-		if (unlikely(p == NULL)) {
-			err = -ENOSPC;
-			goto free_creds;
-		}
+		if (unlikely(p == NULL))
+			return -ENOSPC;
 
 		length = be32_to_cpup(p);
 		p = xdr_inline_decode(xdr, length);
-		if (unlikely(p == NULL)) {
-			err = -ENOSPC;
-			goto free_creds;
-		}
+		if (unlikely(p == NULL))
+			return -ENOSPC;
 
 		if (length == sizeof(CREDS_VALUE) &&
 		    memcmp(p, CREDS_VALUE, sizeof(CREDS_VALUE)) == 0) {
@@ -282,23 +278,16 @@
 			/* We have creds here. parse them */
 			err = gssx_dec_linux_creds(xdr, creds);
 			if (err)
-				goto free_creds;
+				return err;
 			oa->data[0].value.len = 1; /* presence */
 		} else {
 			/* consume uninteresting buffer */
 			err = gssx_dec_buffer(xdr, &dummy);
 			if (err)
-				goto free_creds;
+				return err;
 		}
 	}
 	return 0;
-
-free_creds:
-	kfree(creds);
-free_oa:
-	kfree(oa->data);
-	oa->data = NULL;
-	return err;
 }
 
 static int gssx_dec_status(struct xdr_stream *xdr,
Index: net/kcm/kcmsock.c
===================================================================
--- net/kcm/kcmsock.c	(revision 55465)
+++ net/kcm/kcmsock.c	(revision 55464)
@@ -1274,11 +1274,10 @@
 	if (get_user(len, optlen))
 		return -EFAULT;
 
+	len = min_t(unsigned int, len, sizeof(int));
 	if (len < 0)
 		return -EINVAL;
 
-	len = min_t(unsigned int, len, sizeof(int));
-
 	switch (optname) {
 	case KCM_RECV_DISABLE:
 		val = kcm->rx_disabled;
Index: net/iucv/iucv.c
===================================================================
--- net/iucv/iucv.c	(revision 55465)
+++ net/iucv/iucv.c	(revision 55464)
@@ -156,7 +156,7 @@
 static LIST_HEAD(iucv_handler_list);
 
 /*
- * iucv_path_table: array of pointers to iucv_path structures.
+ * iucv_path_table: an array of iucv_path structures.
  */
 static struct iucv_path **iucv_path_table;
 static unsigned long iucv_max_pathid;
@@ -544,7 +544,7 @@
 
 	cpus_read_lock();
 	rc = -ENOMEM;
-	alloc_size = iucv_max_pathid * sizeof(*iucv_path_table);
+	alloc_size = iucv_max_pathid * sizeof(struct iucv_path);
 	iucv_path_table = kzalloc(alloc_size, GFP_KERNEL);
 	if (!iucv_path_table)
 		goto out;
Index: net/x25/af_x25.c
===================================================================
--- net/x25/af_x25.c	(revision 55465)
+++ net/x25/af_x25.c	(revision 55464)
@@ -460,12 +460,12 @@
 	if (get_user(len, optlen))
 		goto out;
 
+	len = min_t(unsigned int, len, sizeof(int));
+
 	rc = -EINVAL;
 	if (len < 0)
 		goto out;
 
-	len = min_t(unsigned int, len, sizeof(int));
-
 	rc = -EFAULT;
 	if (put_user(len, optlen))
 		goto out;
Index: sound/core/seq/seq_midi.c
===================================================================
--- sound/core/seq/seq_midi.c	(revision 55465)
+++ sound/core/seq/seq_midi.c	(revision 55464)
@@ -112,12 +112,6 @@
 	return 0;
 }
 
-/* callback for snd_seq_dump_var_event(), bridging to dump_midi() */
-static int __dump_midi(void *ptr, void *buf, int count)
-{
-	return dump_midi(ptr, buf, count);
-}
-
 static int event_process_midi(struct snd_seq_event *ev, int direct,
 			      void *private_data, int atomic, int hop)
 {
@@ -137,7 +131,7 @@
 			pr_debug("ALSA: seq_midi: invalid sysex event flags = 0x%x\n", ev->flags);
 			return 0;
 		}
-		snd_seq_dump_var_event(ev, __dump_midi, substream);
+		snd_seq_dump_var_event(ev, (snd_seq_dump_func_t)dump_midi, substream);
 		snd_midi_event_reset_decode(msynth->parser);
 	} else {
 		if (msynth->parser == NULL)
Index: sound/core/seq/seq_virmidi.c
===================================================================
--- sound/core/seq/seq_virmidi.c	(revision 55465)
+++ sound/core/seq/seq_virmidi.c	(revision 55464)
@@ -62,13 +62,6 @@
 /*
  * decode input event and put to read buffer of each opened file
  */
-
-/* callback for snd_seq_dump_var_event(), bridging to snd_rawmidi_receive() */
-static int dump_to_rawmidi(void *ptr, void *buf, int count)
-{
-	return snd_rawmidi_receive(ptr, buf, count);
-}
-
 static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,
 					 struct snd_seq_event *ev,
 					 bool atomic)
@@ -87,7 +80,7 @@
 		if (ev->type == SNDRV_SEQ_EVENT_SYSEX) {
 			if ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)
 				continue;
-			snd_seq_dump_var_event(ev, dump_to_rawmidi, vmidi->substream);
+			snd_seq_dump_var_event(ev, (snd_seq_dump_func_t)snd_rawmidi_receive, vmidi->substream);
 			snd_midi_event_reset_decode(vmidi->parser);
 		} else {
 			len = snd_midi_event_decode(vmidi->parser, msg, sizeof(msg), ev);
Index: sound/pci/hda/patch_realtek.c
===================================================================
--- sound/pci/hda/patch_realtek.c	(revision 55465)
+++ sound/pci/hda/patch_realtek.c	(revision 55464)
@@ -3681,7 +3681,6 @@
 	int i, val;
 	int coef38, coef0d, coef36;
 
-	alc_write_coefex_idx(codec, 0x58, 0x00, 0x1888); /* write default value */
 	alc_update_coef_idx(codec, 0x4a, 1<<15, 1<<15); /* Reset HP JD */
 	coef38 = alc_read_coef_idx(codec, 0x38); /* Amp control */
 	coef0d = alc_read_coef_idx(codec, 0x0d); /* Digital Misc control */
@@ -6693,60 +6692,6 @@
 	}
 }
 
-static void alc285_fixup_hp_envy_x360(struct hda_codec *codec,
-				      const struct hda_fixup *fix,
-				      int action)
-{
-	static const struct coef_fw coefs[] = {
-		WRITE_COEF(0x08, 0x6a0c), WRITE_COEF(0x0d, 0xa023),
-		WRITE_COEF(0x10, 0x0320), WRITE_COEF(0x1a, 0x8c03),
-		WRITE_COEF(0x25, 0x1800), WRITE_COEF(0x26, 0x003a),
-		WRITE_COEF(0x28, 0x1dfe), WRITE_COEF(0x29, 0xb014),
-		WRITE_COEF(0x2b, 0x1dfe), WRITE_COEF(0x37, 0xfe15),
-		WRITE_COEF(0x38, 0x7909), WRITE_COEF(0x45, 0xd489),
-		WRITE_COEF(0x46, 0x00f4), WRITE_COEF(0x4a, 0x21e0),
-		WRITE_COEF(0x66, 0x03f0), WRITE_COEF(0x67, 0x1000),
-		WRITE_COEF(0x6e, 0x1005), { }
-	};
-
-	static const struct hda_pintbl pincfgs[] = {
-		{ 0x12, 0xb7a60130 },  /* Internal microphone*/
-		{ 0x14, 0x90170150 },  /* B&O soundbar speakers */
-		{ 0x17, 0x90170153 },  /* Side speakers */
-		{ 0x19, 0x03a11040 },  /* Headset microphone */
-		{ }
-	};
-
-	switch (action) {
-	case HDA_FIXUP_ACT_PRE_PROBE:
-		snd_hda_apply_pincfgs(codec, pincfgs);
-
-		/* Fixes volume control problem for side speakers */
-		alc295_fixup_disable_dac3(codec, fix, action);
-
-		/* Fixes no sound from headset speaker */
-		snd_hda_codec_amp_stereo(codec, 0x21, HDA_OUTPUT, 0, -1, 0);
-
-		/* Auto-enable headset mic when plugged */
-		snd_hda_jack_set_gating_jack(codec, 0x19, 0x21);
-
-		/* Headset mic volume enhancement */
-		snd_hda_codec_set_pin_target(codec, 0x19, PIN_VREF50);
-		break;
-	case HDA_FIXUP_ACT_INIT:
-		alc_process_coef_fw(codec, coefs);
-		break;
-	case HDA_FIXUP_ACT_BUILD:
-		rename_ctl(codec, "Bass Speaker Playback Volume",
-			   "B&O-Tuned Playback Volume");
-		rename_ctl(codec, "Front Playback Switch",
-			   "B&O Soundbar Playback Switch");
-		rename_ctl(codec, "Bass Speaker Playback Switch",
-			   "Side Speaker Playback Switch");
-		break;
-	}
-}
-
 /* for hda_fixup_thinkpad_acpi() */
 #include "thinkpad_helper.c"
 
@@ -7185,7 +7130,6 @@
 	ALC280_FIXUP_HP_9480M,
 	ALC245_FIXUP_HP_X360_AMP,
 	ALC285_FIXUP_HP_SPECTRE_X360_EB1,
-	ALC285_FIXUP_HP_ENVY_X360,
 	ALC288_FIXUP_DELL_HEADSET_MODE,
 	ALC288_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC288_FIXUP_DELL_XPS_13,
@@ -9109,12 +9053,6 @@
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc285_fixup_hp_spectre_x360_eb1
 	},
-	[ALC285_FIXUP_HP_ENVY_X360] = {
-		.type = HDA_FIXUP_FUNC,
-		.v.func = alc285_fixup_hp_envy_x360,
-		.chained = true,
-		.chain_id = ALC285_FIXUP_HP_GPIO_AMP_INIT,
-	},
 	[ALC287_FIXUP_IDEAPAD_BASS_SPK_AMP] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc285_fixup_ideapad_s740_coef,
@@ -9656,7 +9594,6 @@
 	SND_PCI_QUIRK(0x103c, 0x84e7, "HP Pavilion 15", ALC269_FIXUP_HP_MUTE_LED_MIC3),
 	SND_PCI_QUIRK(0x103c, 0x8519, "HP Spectre x360 15-df0xxx", ALC285_FIXUP_HP_SPECTRE_X360),
 	SND_PCI_QUIRK(0x103c, 0x8537, "HP ProBook 440 G6", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),
-	SND_PCI_QUIRK(0x103c, 0x85de, "HP Envy x360 13-ar0xxx", ALC285_FIXUP_HP_ENVY_X360),
 	SND_PCI_QUIRK(0x103c, 0x860f, "HP ZBook 15 G6", ALC285_FIXUP_HP_GPIO_AMP_INIT),
 	SND_PCI_QUIRK(0x103c, 0x861f, "HP Elite Dragonfly G1", ALC285_FIXUP_HP_GPIO_AMP_INIT),
 	SND_PCI_QUIRK(0x103c, 0x869d, "HP", ALC236_FIXUP_HP_MUTE_LED),
@@ -10311,7 +10248,6 @@
 	{.id = ALC295_FIXUP_HP_OMEN, .name = "alc295-hp-omen"},
 	{.id = ALC285_FIXUP_HP_SPECTRE_X360, .name = "alc285-hp-spectre-x360"},
 	{.id = ALC285_FIXUP_HP_SPECTRE_X360_EB1, .name = "alc285-hp-spectre-x360-eb1"},
-	{.id = ALC285_FIXUP_HP_ENVY_X360, .name = "alc285-hp-envy-x360"},
 	{.id = ALC287_FIXUP_IDEAPAD_BASS_SPK_AMP, .name = "alc287-ideapad-bass-spk-amp"},
 	{.id = ALC287_FIXUP_YOGA9_14IAP7_BASS_SPK_PIN, .name = "alc287-yoga9-bass-spk-pin"},
 	{.id = ALC623_FIXUP_LENOVO_THINKSTATION_P340, .name = "alc623-lenovo-thinkstation-p340"},
Index: sound/soc/codecs/rt5645.c
===================================================================
--- sound/soc/codecs/rt5645.c	(revision 55465)
+++ sound/soc/codecs/rt5645.c	(revision 55464)
@@ -3802,16 +3802,6 @@
 		  DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
 		  DMI_EXACT_MATCH(DMI_BOARD_NAME, "Cherry Trail CR"),
 		  DMI_EXACT_MATCH(DMI_BOARD_VERSION, "Default string"),
-		  /*
-		   * Above strings are too generic, LattePanda BIOS versions for
-		   * all 4 hw revisions are:
-		   * DF-BI-7-S70CR100-*
-		   * DF-BI-7-S70CR110-*
-		   * DF-BI-7-S70CR200-*
-		   * LP-BS-7-S70CR700-*
-		   * Do a partial match for S70CR to avoid false positive matches.
-		   */
-		  DMI_MATCH(DMI_BIOS_VERSION, "S70CR"),
 		},
 		.driver_data = (void *)&lattepanda_board_platform_data,
 	},
Index: sound/soc/codecs/wm8962.c
===================================================================
--- sound/soc/codecs/wm8962.c	(revision 55465)
+++ sound/soc/codecs/wm8962.c	(revision 55464)
@@ -2229,9 +2229,6 @@
 
 SND_SOC_DAPM_OUTPUT("HPOUTL"),
 SND_SOC_DAPM_OUTPUT("HPOUTR"),
-
-SND_SOC_DAPM_PGA("SPKOUTL Output", WM8962_CLASS_D_CONTROL_1, 6, 0, NULL, 0),
-SND_SOC_DAPM_PGA("SPKOUTR Output", WM8962_CLASS_D_CONTROL_1, 7, 0, NULL, 0),
 };
 
 static const struct snd_soc_dapm_widget wm8962_dapm_spk_mono_widgets[] = {
@@ -2239,6 +2236,7 @@
 		   spkmixl, ARRAY_SIZE(spkmixl)),
 SND_SOC_DAPM_MUX_E("Speaker PGA", WM8962_PWR_MGMT_2, 4, 0, &spkoutl_mux,
 		   out_pga_event, SND_SOC_DAPM_POST_PMU),
+SND_SOC_DAPM_PGA("Speaker Output", WM8962_CLASS_D_CONTROL_1, 7, 0, NULL, 0),
 SND_SOC_DAPM_OUTPUT("SPKOUT"),
 };
 
@@ -2253,6 +2251,9 @@
 SND_SOC_DAPM_MUX_E("SPKOUTR PGA", WM8962_PWR_MGMT_2, 3, 0, &spkoutr_mux,
 		   out_pga_event, SND_SOC_DAPM_POST_PMU),
 
+SND_SOC_DAPM_PGA("SPKOUTR Output", WM8962_CLASS_D_CONTROL_1, 7, 0, NULL, 0),
+SND_SOC_DAPM_PGA("SPKOUTL Output", WM8962_CLASS_D_CONTROL_1, 6, 0, NULL, 0),
+
 SND_SOC_DAPM_OUTPUT("SPKOUTL"),
 SND_SOC_DAPM_OUTPUT("SPKOUTR"),
 };
@@ -2365,18 +2366,12 @@
 	{ "Speaker PGA", "Mixer", "Speaker Mixer" },
 	{ "Speaker PGA", "DAC", "DACL" },
 
-	{ "SPKOUTL Output", NULL, "Speaker PGA" },
-	{ "SPKOUTL Output", NULL, "SYSCLK" },
-	{ "SPKOUTL Output", NULL, "TOCLK" },
-	{ "SPKOUTL Output", NULL, "TEMP_SPK" },
+	{ "Speaker Output", NULL, "Speaker PGA" },
+	{ "Speaker Output", NULL, "SYSCLK" },
+	{ "Speaker Output", NULL, "TOCLK" },
+	{ "Speaker Output", NULL, "TEMP_SPK" },
 
-	{ "SPKOUTR Output", NULL, "Speaker PGA" },
-	{ "SPKOUTR Output", NULL, "SYSCLK" },
-	{ "SPKOUTR Output", NULL, "TOCLK" },
-	{ "SPKOUTR Output", NULL, "TEMP_SPK" },
-
-	{ "SPKOUT", NULL, "SPKOUTL Output" },
-	{ "SPKOUT", NULL, "SPKOUTR Output" },
+	{ "SPKOUT", NULL, "Speaker Output" },
 };
 
 static const struct snd_soc_dapm_route wm8962_spk_stereo_intercon[] = {
@@ -2919,12 +2914,8 @@
 	switch (fll_id) {
 	case WM8962_FLL_MCLK:
 	case WM8962_FLL_BCLK:
-		fll1 |= (fll_id - 1) << WM8962_FLL_REFCLK_SRC_SHIFT;
-		break;
 	case WM8962_FLL_OSC:
 		fll1 |= (fll_id - 1) << WM8962_FLL_REFCLK_SRC_SHIFT;
-		snd_soc_component_update_bits(component, WM8962_PLL2,
-					      WM8962_OSC_ENA, WM8962_OSC_ENA);
 		break;
 	case WM8962_FLL_INT:
 		snd_soc_component_update_bits(component, WM8962_FLL_CONTROL_1,
@@ -2933,7 +2924,7 @@
 				    WM8962_FLL_FRC_NCO, WM8962_FLL_FRC_NCO);
 		break;
 	default:
-		dev_err(component->dev, "Unknown FLL source %d\n", source);
+		dev_err(component->dev, "Unknown FLL source %d\n", ret);
 		return -EINVAL;
 	}
 
Index: sound/soc/amd/yc/acp6x-mach.c
===================================================================
--- sound/soc/amd/yc/acp6x-mach.c	(revision 55465)
+++ sound/soc/amd/yc/acp6x-mach.c	(revision 55464)
@@ -203,20 +203,6 @@
 		.driver_data = &acp6x_card,
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "21J2"),
-		}
-	},
-	{
-		.driver_data = &acp6x_card,
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "21J0"),
-		}
-	},
-	{
-		.driver_data = &acp6x_card,
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "21J5"),
 		}
 	},
@@ -245,13 +231,6 @@
 		.driver_data = &acp6x_card,
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "82UU"),
-		}
-	},
-	{
-		.driver_data = &acp6x_card,
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "82V2"),
 		}
 	},
Index: sound/soc/amd/acp/acp-sof-mach.c
===================================================================
--- sound/soc/amd/acp/acp-sof-mach.c	(revision 55465)
+++ sound/soc/amd/acp/acp-sof-mach.c	(revision 55464)
@@ -114,14 +114,16 @@
 	card->num_controls = ARRAY_SIZE(acp_controls);
 	card->drvdata = (struct acp_card_drvdata *)pdev->id_entry->driver_data;
 
-	ret = acp_sofdsp_dai_links_create(card);
-	if (ret)
-		return dev_err_probe(&pdev->dev, ret, "Failed to create DAI links\n");
+	acp_sofdsp_dai_links_create(card);
 
 	ret = devm_snd_soc_register_card(&pdev->dev, card);
-	if (ret)
-		return dev_err_probe(&pdev->dev, ret,
-				     "Failed to register card(%s)\n", card->name);
+	if (ret) {
+		dev_err(&pdev->dev,
+				"devm_snd_soc_register_card(%s) failed: %d\n",
+				card->name, ret);
+		return ret;
+	}
+
 	return 0;
 }
 
Index: sound/soc/intel/boards/bytcr_rt5640.c
===================================================================
--- sound/soc/intel/boards/bytcr_rt5640.c	(revision 55465)
+++ sound/soc/intel/boards/bytcr_rt5640.c	(revision 55464)
@@ -685,18 +685,6 @@
 					BYT_RT5640_SSP0_AIF1 |
 					BYT_RT5640_MCLK_EN),
 	},
-	{	/* Chuwi Vi8 dual-boot (CWI506) */
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Insyde"),
-			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "i86"),
-			/* The above are too generic, also match BIOS info */
-			DMI_MATCH(DMI_BIOS_VERSION, "CHUWI2.D86JHBNR02"),
-		},
-		.driver_data = (void *)(BYTCR_INPUT_DEFAULTS |
-					BYT_RT5640_MONO_SPEAKER |
-					BYT_RT5640_SSP0_AIF1 |
-					BYT_RT5640_MCLK_EN),
-	},
 	{
 		/* Chuwi Vi10 (CWI505) */
 		.matches = {
Index: sound/soc/sof/ipc3-loader.c
===================================================================
--- sound/soc/sof/ipc3-loader.c	(revision 55465)
+++ sound/soc/sof/ipc3-loader.c	(revision 55464)
@@ -138,7 +138,8 @@
 
 static size_t sof_ipc3_fw_parse_ext_man(struct snd_sof_dev *sdev)
 {
-	const struct firmware *fw = sdev->basefw.fw;
+	struct snd_sof_pdata *plat_data = sdev->pdata;
+	const struct firmware *fw = plat_data->fw;
 	const struct sof_ext_man_elem_header *elem_hdr;
 	const struct sof_ext_man_header *head;
 	ssize_t ext_man_size;
@@ -148,8 +149,6 @@
 
 	head = (struct sof_ext_man_header *)fw->data;
 	remaining = head->full_size - head->header_size;
-	if (remaining < 0 || remaining > sdev->basefw.fw->size)
-		return -EINVAL;
 	ext_man_size = ipc3_fw_ext_man_size(sdev, fw);
 
 	/* Assert firmware starts with extended manifest */
@@ -311,8 +310,8 @@
 
 static int sof_ipc3_load_fw_to_dsp(struct snd_sof_dev *sdev)
 {
-	u32 payload_offset = sdev->basefw.payload_offset;
-	const struct firmware *fw = sdev->basefw.fw;
+	struct snd_sof_pdata *plat_data = sdev->pdata;
+	const struct firmware *fw = plat_data->fw;
 	struct snd_sof_fw_header *header;
 	struct snd_sof_mod_hdr *module;
 	int (*load_module)(struct snd_sof_dev *sof_dev, struct snd_sof_mod_hdr *hdr);
@@ -319,10 +318,10 @@
 	size_t remaining;
 	int ret, count;
 
-	if (!fw)
+	if (!plat_data->fw)
 		return -EINVAL;
 
-	header = (struct snd_sof_fw_header *)(fw->data + payload_offset);
+	header = (struct snd_sof_fw_header *)(fw->data + plat_data->fw_offset);
 	load_module = sof_ops(sdev)->load_module;
 	if (!load_module) {
 		dev_dbg(sdev->dev, "Using generic module loading\n");
@@ -332,8 +331,9 @@
 	}
 
 	/* parse each module */
-	module = (struct snd_sof_mod_hdr *)(fw->data + payload_offset + sizeof(*header));
-	remaining = fw->size - sizeof(*header) - payload_offset;
+	module = (struct snd_sof_mod_hdr *)(fw->data + plat_data->fw_offset +
+					    sizeof(*header));
+	remaining = fw->size - sizeof(*header) - plat_data->fw_offset;
 	/* check for wrap */
 	if (remaining > fw->size) {
 		dev_err(sdev->dev, "%s: fw size smaller than header size\n", __func__);
@@ -374,12 +374,12 @@
 
 static int sof_ipc3_validate_firmware(struct snd_sof_dev *sdev)
 {
-	u32 payload_offset = sdev->basefw.payload_offset;
-	const struct firmware *fw = sdev->basefw.fw;
+	struct snd_sof_pdata *plat_data = sdev->pdata;
+	const struct firmware *fw = plat_data->fw;
 	struct snd_sof_fw_header *header;
-	size_t fw_size = fw->size - payload_offset;
+	size_t fw_size = fw->size - plat_data->fw_offset;
 
-	if (fw->size <= payload_offset) {
+	if (fw->size <= plat_data->fw_offset) {
 		dev_err(sdev->dev,
 			"firmware size must be greater than firmware offset\n");
 		return -EINVAL;
@@ -386,7 +386,7 @@
 	}
 
 	/* Read the header information from the data pointer */
-	header = (struct snd_sof_fw_header *)(fw->data + payload_offset);
+	header = (struct snd_sof_fw_header *)(fw->data + plat_data->fw_offset);
 
 	/* verify FW sig */
 	if (strncmp(header->sig, SND_SOF_FW_SIG, SND_SOF_FW_SIG_SIZE) != 0) {
Index: sound/soc/sof/ipc4-loader.c
===================================================================
--- sound/soc/sof/ipc4-loader.c	(revision 55465)
+++ sound/soc/sof/ipc4-loader.c	(revision 55464)
@@ -17,8 +17,9 @@
 static size_t sof_ipc4_fw_parse_ext_man(struct snd_sof_dev *sdev)
 {
 	struct sof_ipc4_fw_data *ipc4_data = sdev->private;
+	struct snd_sof_pdata *plat_data = sdev->pdata;
 	struct sof_man4_fw_binary_header *fw_header;
-	const struct firmware *fw = sdev->basefw.fw;
+	const struct firmware *fw = plat_data->fw;
 	struct sof_ext_manifest4_hdr *ext_man_hdr;
 	struct sof_man4_module_config *fm_config;
 	struct sof_ipc4_fw_module *fw_module;
@@ -137,8 +138,9 @@
 {
 	struct sof_ipc4_fw_data *ipc4_data = sdev->private;
 	u32 fw_hdr_offset = ipc4_data->manifest_fw_hdr_offset;
+	struct snd_sof_pdata *plat_data = sdev->pdata;
 	struct sof_man4_fw_binary_header *fw_header;
-	const struct firmware *fw = sdev->basefw.fw;
+	const struct firmware *fw = plat_data->fw;
 	struct sof_ext_manifest4_hdr *ext_man_hdr;
 
 	ext_man_hdr = (struct sof_ext_manifest4_hdr *)fw->data;
Index: sound/soc/sof/loader.c
===================================================================
--- sound/soc/sof/loader.c	(revision 55465)
+++ sound/soc/sof/loader.c	(revision 55464)
@@ -22,7 +22,7 @@
 	int ret;
 
 	/* Don't request firmware again if firmware is already requested */
-	if (sdev->basefw.fw)
+	if (plat_data->fw)
 		return 0;
 
 	fw_filename = kasprintf(GFP_KERNEL, "%s/%s",
@@ -31,7 +31,7 @@
 	if (!fw_filename)
 		return -ENOMEM;
 
-	ret = request_firmware(&sdev->basefw.fw, fw_filename, sdev->dev);
+	ret = request_firmware(&plat_data->fw, fw_filename, sdev->dev);
 
 	if (ret < 0) {
 		dev_err(sdev->dev,
@@ -48,7 +48,7 @@
 	ext_man_size = sdev->ipc->ops->fw_loader->parse_ext_manifest(sdev);
 	if (ext_man_size > 0) {
 		/* when no error occurred, drop extended manifest */
-		sdev->basefw.payload_offset = ext_man_size;
+		plat_data->fw_offset = ext_man_size;
 	} else if (!ext_man_size) {
 		/* No extended manifest, so nothing to skip during FW load */
 		dev_dbg(sdev->dev, "firmware doesn't contain extended manifest\n");
@@ -58,12 +58,6 @@
 			fw_filename, ret);
 	}
 
-	/*
-	 * Until the platform code is switched to use the new container the fw
-	 * and payload offset must be set in plat_data
-	 */
-	plat_data->fw = sdev->basefw.fw;
-	plat_data->fw_offset = sdev->basefw.payload_offset;
 err:
 	kfree(fw_filename);
 
@@ -106,8 +100,7 @@
 	return 0;
 
 error:
-	release_firmware(sdev->basefw.fw);
-	sdev->basefw.fw = NULL;
+	release_firmware(plat_data->fw);
 	plat_data->fw = NULL;
 	return ret;
 
@@ -192,8 +185,7 @@
 void snd_sof_fw_unload(struct snd_sof_dev *sdev)
 {
 	/* TODO: support module unloading at runtime */
-	release_firmware(sdev->basefw.fw);
-	sdev->basefw.fw = NULL;
+	release_firmware(sdev->pdata->fw);
 	sdev->pdata->fw = NULL;
 }
 EXPORT_SYMBOL(snd_sof_fw_unload);
Index: sound/soc/sof/sof-priv.h
===================================================================
--- sound/soc/sof/sof-priv.h	(revision 55465)
+++ sound/soc/sof/sof-priv.h	(revision 55464)
@@ -136,17 +136,6 @@
 	bool cont_update_posn;
 };
 
-/**
- * struct sof_firmware - Container struct for SOF firmware
- * @fw:			Pointer to the firmware
- * @payload_offset:	Offset of the data within the loaded firmware image to be
- *			loaded to the DSP (skipping for example ext_manifest section)
- */
-struct sof_firmware {
-	const struct firmware *fw;
-	u32 payload_offset;
-};
-
 /*
  * SOF DSP HW abstraction operations.
  * Used to abstract DSP HW architecture and any IO busses between host CPU
@@ -498,9 +487,6 @@
 	spinlock_t ipc_lock;	/* lock for IPC users */
 	spinlock_t hw_lock;	/* lock for HW IO access */
 
-	/* Main, Base firmware image */
-	struct sof_firmware basefw;
-
 	/*
 	 * ASoC components. plat_drv fields are set dynamically so
 	 * can't use const
Index: sound/soc/meson/aiu.c
===================================================================
--- sound/soc/meson/aiu.c	(revision 55465)
+++ sound/soc/meson/aiu.c	(revision 55464)
@@ -218,12 +218,11 @@
 static int aiu_clk_get(struct device *dev)
 {
 	struct aiu *aiu = dev_get_drvdata(dev);
-	struct clk *pclk;
 	int ret;
 
-	pclk = devm_clk_get_enabled(dev, "pclk");
-	if (IS_ERR(pclk))
-		return dev_err_probe(dev, PTR_ERR(pclk), "Can't get the aiu pclk\n");
+	aiu->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(aiu->pclk))
+		return dev_err_probe(dev, PTR_ERR(aiu->pclk), "Can't get the aiu pclk\n");
 
 	aiu->spdif_mclk = devm_clk_get(dev, "spdif_mclk");
 	if (IS_ERR(aiu->spdif_mclk))
@@ -240,6 +239,18 @@
 	if (ret)
 		return dev_err_probe(dev, ret, "Can't get the spdif clocks\n");
 
+	ret = clk_prepare_enable(aiu->pclk);
+	if (ret) {
+		dev_err(dev, "peripheral clock enable failed\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev,
+				       (void(*)(void *))clk_disable_unprepare,
+				       aiu->pclk);
+	if (ret)
+		dev_err(dev, "failed to add reset action on pclk");
+
 	return ret;
 }
 
Index: sound/soc/meson/aiu.h
===================================================================
--- sound/soc/meson/aiu.h	(revision 55465)
+++ sound/soc/meson/aiu.h	(revision 55464)
@@ -33,6 +33,7 @@
 };
 
 struct aiu {
+	struct clk *pclk;
 	struct clk *spdif_mclk;
 	struct aiu_interface i2s;
 	struct aiu_interface spdif;
Index: sound/soc/meson/axg-tdm-interface.c
===================================================================
--- sound/soc/meson/axg-tdm-interface.c	(revision 55465)
+++ sound/soc/meson/axg-tdm-interface.c	(revision 55464)
@@ -12,9 +12,6 @@
 
 #include "axg-tdm.h"
 
-/* Maximum bit clock frequency according the datasheets */
-#define MAX_SCLK 100000000 /* Hz */
-
 enum {
 	TDM_IFACE_PAD,
 	TDM_IFACE_LOOPBACK,
@@ -158,27 +155,19 @@
 		return -EINVAL;
 	}
 
+	/* Apply component wide rate symmetry */
 	if (snd_soc_component_active(dai->component)) {
-		/* Apply component wide rate symmetry */
 		ret = snd_pcm_hw_constraint_single(substream->runtime,
 						   SNDRV_PCM_HW_PARAM_RATE,
 						   iface->rate);
-
-	} else {
-		/* Limit rate according to the slot number and width */
-		unsigned int max_rate =
-			MAX_SCLK / (iface->slots * iface->slot_width);
-		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
-						   SNDRV_PCM_HW_PARAM_RATE,
-						   0, max_rate);
+		if (ret < 0) {
+			dev_err(dai->dev,
+				"can't set iface rate constraint\n");
+			return ret;
+		}
 	}
 
-	if (ret < 0)
-		dev_err(dai->dev, "can't set iface rate constraint\n");
-	else
-		ret = 0;
-
-	return ret;
+	return 0;
 }
 
 static int axg_tdm_iface_set_stream(struct snd_pcm_substream *substream,
@@ -277,8 +266,8 @@
 	srate = iface->slots * iface->slot_width * params_rate(params);
 
 	if (!iface->mclk_rate) {
-		/* If no specific mclk is requested, default to bit clock * 2 */
-		clk_set_rate(iface->mclk, 2 * srate);
+		/* If no specific mclk is requested, default to bit clock * 4 */
+		clk_set_rate(iface->mclk, 4 * srate);
 	} else {
 		/* Check if we can actually get the bit clock from mclk */
 		if (iface->mclk_rate % srate) {
Index: sound/soc/meson/t9015.c
===================================================================
--- sound/soc/meson/t9015.c	(revision 55465)
+++ sound/soc/meson/t9015.c	(revision 55464)
@@ -48,6 +48,7 @@
 #define POWER_CFG	0x10
 
 struct t9015 {
+	struct clk *pclk;
 	struct regulator *avdd;
 };
 
@@ -248,7 +249,6 @@
 	struct t9015 *priv;
 	void __iomem *regs;
 	struct regmap *regmap;
-	struct clk *pclk;
 	int ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -256,14 +256,26 @@
 		return -ENOMEM;
 	platform_set_drvdata(pdev, priv);
 
-	pclk = devm_clk_get_enabled(dev, "pclk");
-	if (IS_ERR(pclk))
-		return dev_err_probe(dev, PTR_ERR(pclk), "failed to get core clock\n");
+	priv->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(priv->pclk))
+		return dev_err_probe(dev, PTR_ERR(priv->pclk), "failed to get core clock\n");
 
 	priv->avdd = devm_regulator_get(dev, "AVDD");
 	if (IS_ERR(priv->avdd))
 		return dev_err_probe(dev, PTR_ERR(priv->avdd), "failed to AVDD\n");
 
+	ret = clk_prepare_enable(priv->pclk);
+	if (ret) {
+		dev_err(dev, "core clock enable failed\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev,
+			(void(*)(void *))clk_disable_unprepare,
+			priv->pclk);
+	if (ret)
+		return ret;
+
 	ret = device_reset(dev);
 	if (ret) {
 		dev_err(dev, "reset failed\n");
Index: sound/soc/rockchip/rockchip_i2s_tdm.c
===================================================================
--- sound/soc/rockchip/rockchip_i2s_tdm.c	(revision 55465)
+++ sound/soc/rockchip/rockchip_i2s_tdm.c	(revision 55464)
@@ -27,6 +27,8 @@
 #define DEFAULT_MCLK_FS				256
 #define CH_GRP_MAX				4  /* The max channel 8 / 2 */
 #define MULTIPLEX_CH_MAX			10
+#define CLK_PPM_MIN				-1000
+#define CLK_PPM_MAX				1000
 
 #define TRCM_TXRX 0
 #define TRCM_TX 1
@@ -53,6 +55,20 @@
 	struct clk *hclk;
 	struct clk *mclk_tx;
 	struct clk *mclk_rx;
+	/* The mclk_tx_src is parent of mclk_tx */
+	struct clk *mclk_tx_src;
+	/* The mclk_rx_src is parent of mclk_rx */
+	struct clk *mclk_rx_src;
+	/*
+	 * The mclk_root0 and mclk_root1 are root parent and supplies for
+	 * the different FS.
+	 *
+	 * e.g:
+	 * mclk_root0 is VPLL0, used for FS=48000Hz
+	 * mclk_root1 is VPLL1, used for FS=44100Hz
+	 */
+	struct clk *mclk_root0;
+	struct clk *mclk_root1;
 	struct regmap *regmap;
 	struct regmap *grf;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
@@ -62,11 +78,19 @@
 	struct rk_i2s_soc_data *soc_data;
 	bool is_master_mode;
 	bool io_multiplex;
+	bool mclk_calibrate;
 	bool tdm_mode;
+	unsigned int mclk_rx_freq;
+	unsigned int mclk_tx_freq;
+	unsigned int mclk_root0_freq;
+	unsigned int mclk_root1_freq;
+	unsigned int mclk_root0_initial_freq;
+	unsigned int mclk_root1_initial_freq;
 	unsigned int frame_width;
 	unsigned int clk_trcm;
 	unsigned int i2s_sdis[CH_GRP_MAX];
 	unsigned int i2s_sdos[CH_GRP_MAX];
+	int clk_ppm;
 	int refcount;
 	spinlock_t lock; /* xfer lock */
 	bool has_playback;
@@ -92,6 +116,12 @@
 {
 	clk_disable_unprepare(i2s_tdm->mclk_tx);
 	clk_disable_unprepare(i2s_tdm->mclk_rx);
+	if (i2s_tdm->mclk_calibrate) {
+		clk_disable_unprepare(i2s_tdm->mclk_tx_src);
+		clk_disable_unprepare(i2s_tdm->mclk_rx_src);
+		clk_disable_unprepare(i2s_tdm->mclk_root0);
+		clk_disable_unprepare(i2s_tdm->mclk_root1);
+	}
 }
 
 /**
@@ -114,9 +144,29 @@
 	ret = clk_prepare_enable(i2s_tdm->mclk_rx);
 	if (ret)
 		goto err_mclk_rx;
+	if (i2s_tdm->mclk_calibrate) {
+		ret = clk_prepare_enable(i2s_tdm->mclk_tx_src);
+		if (ret)
+			goto err_mclk_rx;
+		ret = clk_prepare_enable(i2s_tdm->mclk_rx_src);
+		if (ret)
+			goto err_mclk_rx_src;
+		ret = clk_prepare_enable(i2s_tdm->mclk_root0);
+		if (ret)
+			goto err_mclk_root0;
+		ret = clk_prepare_enable(i2s_tdm->mclk_root1);
+		if (ret)
+			goto err_mclk_root1;
+	}
 
 	return 0;
 
+err_mclk_root1:
+	clk_disable_unprepare(i2s_tdm->mclk_root0);
+err_mclk_root0:
+	clk_disable_unprepare(i2s_tdm->mclk_rx_src);
+err_mclk_rx_src:
+	clk_disable_unprepare(i2s_tdm->mclk_tx_src);
 err_mclk_rx:
 	clk_disable_unprepare(i2s_tdm->mclk_tx);
 err_mclk_tx:
@@ -516,6 +566,159 @@
 			   I2S_XFER_RXS_START);
 }
 
+static int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,
+					 struct clk *clk, unsigned long rate,
+					 int ppm)
+{
+	unsigned long rate_target;
+	int delta, ret;
+
+	if (ppm == i2s_tdm->clk_ppm)
+		return 0;
+
+	if (ppm < 0)
+		delta = -1;
+	else
+		delta = 1;
+
+	delta *= (int)div64_u64((u64)rate * (u64)abs(ppm) + 500000,
+				1000000);
+
+	rate_target = rate + delta;
+
+	if (!rate_target)
+		return -EINVAL;
+
+	ret = clk_set_rate(clk, rate_target);
+	if (ret)
+		return ret;
+
+	i2s_tdm->clk_ppm = ppm;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+					   struct snd_pcm_substream *substream,
+					   unsigned int lrck_freq)
+{
+	struct clk *mclk_root;
+	struct clk *mclk_parent;
+	unsigned int mclk_root_freq;
+	unsigned int mclk_root_initial_freq;
+	unsigned int mclk_parent_freq;
+	unsigned int div, delta;
+	u64 ppm;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		mclk_parent = i2s_tdm->mclk_tx_src;
+	else
+		mclk_parent = i2s_tdm->mclk_rx_src;
+
+	switch (lrck_freq) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		mclk_root = i2s_tdm->mclk_root0;
+		mclk_root_freq = i2s_tdm->mclk_root0_freq;
+		mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		mclk_root = i2s_tdm->mclk_root1;
+		mclk_root_freq = i2s_tdm->mclk_root1_freq;
+		mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "Invalid LRCK frequency: %u Hz\n",
+			lrck_freq);
+		return -EINVAL;
+	}
+
+	ret = clk_set_parent(mclk_parent, mclk_root);
+	if (ret)
+		return ret;
+
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
+					    mclk_root_freq, 0);
+	if (ret)
+		return ret;
+
+	delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
+	ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
+
+	if (ppm) {
+		div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
+		if (!div)
+			return -EINVAL;
+
+		mclk_root_freq = mclk_parent_freq * round_up(div, 2);
+
+		ret = clk_set_rate(mclk_root, mclk_root_freq);
+		if (ret)
+			return ret;
+
+		i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
+		i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
+	}
+
+	return clk_set_rate(mclk_parent, mclk_parent_freq);
+}
+
+static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+				     struct snd_pcm_substream *substream,
+				     struct clk **mclk)
+{
+	unsigned int mclk_freq;
+	int ret;
+
+	if (i2s_tdm->clk_trcm) {
+		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+			dev_err(i2s_tdm->dev,
+				"clk_trcm, tx: %d and rx: %d should be the same\n",
+				i2s_tdm->mclk_tx_freq,
+				i2s_tdm->mclk_rx_freq);
+			return -EINVAL;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+		if (ret)
+			return ret;
+
+		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+		if (ret)
+			return ret;
+
+		/* mclk_rx is also ok. */
+		*mclk = i2s_tdm->mclk_tx;
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			*mclk = i2s_tdm->mclk_tx;
+			mclk_freq = i2s_tdm->mclk_tx_freq;
+		} else {
+			*mclk = i2s_tdm->mclk_rx;
+			mclk_freq = i2s_tdm->mclk_rx_freq;
+		}
+
+		ret = clk_set_rate(*mclk, mclk_freq);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int rockchip_i2s_ch_to_io(unsigned int ch, bool substream_capture)
 {
 	if (substream_capture) {
@@ -646,17 +849,19 @@
 				      struct snd_soc_dai *dai)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	struct clk *mclk;
+	int ret = 0;
 	unsigned int val = 0;
 	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
-	int err;
 
 	if (i2s_tdm->is_master_mode) {
-		struct clk *mclk = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
-			i2s_tdm->mclk_tx : i2s_tdm->mclk_rx;
+		if (i2s_tdm->mclk_calibrate)
+			rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+							params_rate(params));
 
-		err = clk_set_rate(mclk, DEFAULT_MCLK_FS * params_rate(params));
-		if (err)
-			return err;
+		ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+		if (ret)
+			return ret;
 
 		mclk_rate = clk_get_rate(mclk);
 		bclk_rate = i2s_tdm->frame_width * params_rate(params);
@@ -764,6 +969,96 @@
 	return 0;
 }
 
+static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
+				       unsigned int freq, int dir)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+
+	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+	if (i2s_tdm->clk_trcm) {
+		i2s_tdm->mclk_tx_freq = freq;
+		i2s_tdm->mclk_rx_freq = freq;
+	} else {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			i2s_tdm->mclk_tx_freq = freq;
+		else
+			i2s_tdm->mclk_rx_freq = freq;
+	}
+
+	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
+		stream ? "rx" : "tx", freq);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,
+						  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = CLK_PPM_MIN;
+	uinfo->value.integer.max = CLK_PPM_MAX;
+	uinfo->value.integer.step = 1;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+	ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	int ret = 0, ppm = 0;
+	int changed = 0;
+	unsigned long old_rate;
+
+	if (ucontrol->value.integer.value[0] < CLK_PPM_MIN ||
+	    ucontrol->value.integer.value[0] > CLK_PPM_MAX)
+		return -EINVAL;
+
+	ppm = ucontrol->value.integer.value[0];
+
+	old_rate = clk_get_rate(i2s_tdm->mclk_root0);
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
+					    i2s_tdm->mclk_root0_freq, ppm);
+	if (ret)
+		return ret;
+	if (old_rate != clk_get_rate(i2s_tdm->mclk_root0))
+		changed = 1;
+
+	if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
+		return changed;
+
+	old_rate = clk_get_rate(i2s_tdm->mclk_root1);
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
+					    i2s_tdm->mclk_root1_freq, ppm);
+	if (ret)
+		return ret;
+	if (old_rate != clk_get_rate(i2s_tdm->mclk_root1))
+		changed = 1;
+
+	return changed;
+}
+
+static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Clock Compensation in PPM",
+	.info = rockchip_i2s_tdm_clk_compensation_info,
+	.get = rockchip_i2s_tdm_clk_compensation_get,
+	.put = rockchip_i2s_tdm_clk_compensation_put,
+};
+
 static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
@@ -773,6 +1068,9 @@
 	if (i2s_tdm->has_playback)
 		dai->playback_dma_data = &i2s_tdm->playback_dma_data;
 
+	if (i2s_tdm->mclk_calibrate)
+		snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+
 	return 0;
 }
 
@@ -812,6 +1110,7 @@
 static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
 	.hw_params = rockchip_i2s_tdm_hw_params,
 	.set_bclk_ratio	= rockchip_i2s_tdm_set_bclk_ratio,
+	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
 	.set_fmt = rockchip_i2s_tdm_set_fmt,
 	.set_tdm_slot = rockchip_dai_tdm_slot,
 	.trigger = rockchip_i2s_tdm_trigger,
@@ -1134,6 +1433,35 @@
 		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
 }
 
+static int rockchip_i2s_tdm_get_calibrate_mclks(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int num_mclks = 0;
+
+	i2s_tdm->mclk_tx_src = devm_clk_get(i2s_tdm->dev, "mclk_tx_src");
+	if (!IS_ERR(i2s_tdm->mclk_tx_src))
+		num_mclks++;
+
+	i2s_tdm->mclk_rx_src = devm_clk_get(i2s_tdm->dev, "mclk_rx_src");
+	if (!IS_ERR(i2s_tdm->mclk_rx_src))
+		num_mclks++;
+
+	i2s_tdm->mclk_root0 = devm_clk_get(i2s_tdm->dev, "mclk_root0");
+	if (!IS_ERR(i2s_tdm->mclk_root0))
+		num_mclks++;
+
+	i2s_tdm->mclk_root1 = devm_clk_get(i2s_tdm->dev, "mclk_root1");
+	if (!IS_ERR(i2s_tdm->mclk_root1))
+		num_mclks++;
+
+	if (num_mclks < 4 && num_mclks != 0)
+		return -ENOENT;
+
+	if (num_mclks == 4)
+		i2s_tdm->mclk_calibrate = 1;
+
+	return 0;
+}
+
 static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
 					 struct device_node *np,
 					 bool is_rx_path)
@@ -1281,6 +1609,11 @@
 	i2s_tdm->io_multiplex =
 		of_property_read_bool(node, "rockchip,io-multiplex");
 
+	ret = rockchip_i2s_tdm_get_calibrate_mclks(i2s_tdm);
+	if (ret)
+		return dev_err_probe(i2s_tdm->dev, ret,
+				     "mclk-calibrate clocks missing");
+
 	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs)) {
 		return dev_err_probe(i2s_tdm->dev, PTR_ERR(regs),
@@ -1333,6 +1666,13 @@
 		goto err_disable_hclk;
 	}
 
+	if (i2s_tdm->mclk_calibrate) {
+		i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
+		i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
+		i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
+		i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
+	}
+
 	pm_runtime_enable(&pdev->dev);
 
 	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
Index: sound/usb/stream.c
===================================================================
--- sound/usb/stream.c	(revision 55465)
+++ sound/usb/stream.c	(revision 55464)
@@ -300,12 +300,9 @@
 	c = 0;
 
 	if (bits) {
-		for (; bits && *maps; maps++, bits >>= 1) {
+		for (; bits && *maps; maps++, bits >>= 1)
 			if (bits & 1)
 				chmap->map[c++] = *maps;
-			if (c == chmap->channels)
-				break;
-		}
 	} else {
 		/* If we're missing wChannelConfig, then guess something
 		    to make sure the channel map is not skipped entirely */
Index: tools/include/linux/btf_ids.h
===================================================================
--- tools/include/linux/btf_ids.h	(revision 55465)
+++ tools/include/linux/btf_ids.h	(revision 55464)
@@ -8,15 +8,6 @@
 	u32 ids[];
 };
 
-struct btf_id_set8 {
-	u32 cnt;
-	u32 flags;
-	struct {
-		u32 id;
-		u32 flags;
-	} pairs[];
-};
-
 #ifdef CONFIG_DEBUG_INFO_BTF
 
 #include <linux/compiler.h> /* for __PASTE */
Index: tools/testing/selftests/net/tls.c
===================================================================
--- tools/testing/selftests/net/tls.c	(revision 55465)
+++ tools/testing/selftests/net/tls.c	(revision 55464)
@@ -926,12 +926,12 @@
 
 	memset(recv_mem, 0, sizeof(recv_mem));
 	EXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);
-	EXPECT_EQ(recv(self->cfd, recv_mem, strlen(test_str_first),
-		       MSG_WAITALL), strlen(test_str_first));
+	EXPECT_NE(recv(self->cfd, recv_mem, strlen(test_str_first),
+		       MSG_WAITALL), -1);
 	EXPECT_EQ(memcmp(test_str_first, recv_mem, strlen(test_str_first)), 0);
 	memset(recv_mem, 0, sizeof(recv_mem));
-	EXPECT_EQ(recv(self->cfd, recv_mem, strlen(test_str_second),
-		       MSG_WAITALL), strlen(test_str_second));
+	EXPECT_NE(recv(self->cfd, recv_mem, strlen(test_str_second),
+		       MSG_WAITALL), -1);
 	EXPECT_EQ(memcmp(test_str_second, recv_mem, strlen(test_str_second)),
 		  0);
 }
Index: tools/testing/selftests/net/forwarding/config
===================================================================
--- tools/testing/selftests/net/forwarding/config	(revision 55465)
+++ tools/testing/selftests/net/forwarding/config	(revision 55464)
@@ -6,49 +6,14 @@
 CONFIG_NET_VRF=m
 CONFIG_BPF_SYSCALL=y
 CONFIG_CGROUP_BPF=y
-CONFIG_DUMMY=m
-CONFIG_IPV6=y
-CONFIG_IPV6_GRE=m
-CONFIG_IPV6_MROUTE=y
-CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_MACVLAN=m
 CONFIG_NET_ACT_CT=m
 CONFIG_NET_ACT_MIRRED=m
 CONFIG_NET_ACT_MPLS=m
-CONFIG_NET_ACT_PEDIT=m
-CONFIG_NET_ACT_POLICE=m
-CONFIG_NET_ACT_SAMPLE=m
-CONFIG_NET_ACT_SKBEDIT=m
-CONFIG_NET_ACT_TUNNEL_KEY=m
 CONFIG_NET_ACT_VLAN=m
 CONFIG_NET_CLS_FLOWER=m
 CONFIG_NET_CLS_MATCHALL=m
-CONFIG_NET_CLS_BASIC=m
-CONFIG_NET_EMATCH=y
-CONFIG_NET_EMATCH_META=m
-CONFIG_NET_IPGRE=m
-CONFIG_NET_IPGRE_DEMUX=m
-CONFIG_NET_IPIP=m
-CONFIG_NET_SCH_ETS=m
 CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_ACT_GACT=m
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_TC_SKB_EXT=y
-CONFIG_NET_TEAM=y
-CONFIG_NET_TEAM_MODE_LOADBALANCE=y
-CONFIG_NETFILTER=y
-CONFIG_NF_CONNTRACK=m
-CONFIG_NF_FLOW_TABLE=m
-CONFIG_NF_TABLES=m
 CONFIG_VETH=m
 CONFIG_NAMESPACES=y
 CONFIG_NET_NS=y
-CONFIG_VXLAN=m
-CONFIG_XFRM_USER=m
Index: tools/testing/selftests/net/forwarding/vxlan_bridge_1d_ipv6.sh
===================================================================
--- tools/testing/selftests/net/forwarding/vxlan_bridge_1d_ipv6.sh	(revision 55465)
+++ tools/testing/selftests/net/forwarding/vxlan_bridge_1d_ipv6.sh	(revision 55464)
@@ -354,7 +354,7 @@
 
 	# Send 100 packets and verify that at least 100 packets hit the rule,
 	# to overcome ARP noise.
-	PING_COUNT=100 PING_TIMEOUT=20 ping_do $dev $dst_ip
+	PING_COUNT=100 PING_TIMEOUT=11 ping_do $dev $dst_ip
 	check_err $? "Ping failed"
 
 	tc_check_at_least_x_packets "dev $rp1 egress" 101 10 100
@@ -410,7 +410,7 @@
 
 	# Send 100 packets and verify that at least 100 packets hit the rule,
 	# to overcome neighbor discovery noise.
-	PING_COUNT=100 PING_TIMEOUT=20 ping6_do $dev $dst_ip
+	PING_COUNT=100 PING_TIMEOUT=11 ping6_do $dev $dst_ip
 	check_err $? "Ping failed"
 
 	tc_check_at_least_x_packets "dev $rp1 egress" 101 100
Index: tools/testing/selftests/net/forwarding/vxlan_bridge_1q_ipv6.sh
===================================================================
--- tools/testing/selftests/net/forwarding/vxlan_bridge_1q_ipv6.sh	(revision 55465)
+++ tools/testing/selftests/net/forwarding/vxlan_bridge_1q_ipv6.sh	(revision 55464)
@@ -457,7 +457,7 @@
 
 	# Send 100 packets and verify that at least 100 packets hit the rule,
 	# to overcome ARP noise.
-	PING_COUNT=100 PING_TIMEOUT=20 ping_do $dev $dst_ip
+	PING_COUNT=100 PING_TIMEOUT=11 ping_do $dev $dst_ip
 	check_err $? "Ping failed"
 
 	tc_check_at_least_x_packets "dev $rp1 egress" 101 10 100
@@ -522,7 +522,7 @@
 
 	# Send 100 packets and verify that at least 100 packets hit the rule,
 	# to overcome neighbor discovery noise.
-	PING_COUNT=100 PING_TIMEOUT=20 ping6_do $dev $dst_ip
+	PING_COUNT=100 PING_TIMEOUT=11 ping6_do $dev $dst_ip
 	check_err $? "Ping failed"
 
 	tc_check_at_least_x_packets "dev $rp1 egress" 101 100
Index: tools/testing/selftests/bpf/progs/test_map_in_map.c
===================================================================
--- tools/testing/selftests/bpf/progs/test_map_in_map.c	(revision 55465)
+++ tools/testing/selftests/bpf/progs/test_map_in_map.c	(revision 55464)
@@ -21,32 +21,6 @@
 	__type(value, __u32);
 } mim_hash SEC(".maps");
 
-/* The following three maps are used to test
- * perf_event_array map can be an inner
- * map of hash/array_of_maps.
- */
-struct perf_event_array {
-	__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
-	__type(key, __u32);
-	__type(value, __u32);
-} inner_map0 SEC(".maps");
-
-struct {
-	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
-	__uint(max_entries, 1);
-	__type(key, __u32);
-	__array(values, struct perf_event_array);
-} mim_array_pe SEC(".maps") = {
-	.values = {&inner_map0}};
-
-struct {
-	__uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);
-	__uint(max_entries, 1);
-	__type(key, __u32);
-	__array(values, struct perf_event_array);
-} mim_hash_pe SEC(".maps") = {
-	.values = {&inner_map0}};
-
 SEC("xdp")
 int xdp_mimtest0(struct xdp_md *ctx)
 {
Index: tools/testing/selftests/bpf/test_maps.c
===================================================================
--- tools/testing/selftests/bpf/test_maps.c	(revision 55465)
+++ tools/testing/selftests/bpf/test_maps.c	(revision 55464)
@@ -1190,11 +1190,7 @@
 		goto out_map_in_map;
 	}
 
-	err = bpf_object__load(obj);
-	if (err) {
-		printf("Failed to load test prog\n");
-		goto out_map_in_map;
-	}
+	bpf_object__load(obj);
 
 	map = bpf_object__find_map_by_name(obj, "mim_array");
 	if (!map) {
Index: tools/lib/bpf/libbpf.c
===================================================================
--- tools/lib/bpf/libbpf.c	(revision 55465)
+++ tools/lib/bpf/libbpf.c	(revision 55464)
@@ -70,7 +70,6 @@
 
 static struct bpf_map *bpf_object__add_map(struct bpf_object *obj);
 static bool prog_is_subprog(const struct bpf_object *obj, const struct bpf_program *prog);
-static int map_set_def_max_entries(struct bpf_map *map);
 
 static const char * const attach_type_name[] = {
 	[BPF_CGROUP_INET_INGRESS]	= "cgroup_inet_ingress",
@@ -4993,9 +4992,6 @@
 
 	if (bpf_map_type__is_map_in_map(def->type)) {
 		if (map->inner_map) {
-			err = map_set_def_max_entries(map->inner_map);
-			if (err)
-				return err;
 			err = bpf_object__create_map(obj, map->inner_map, true);
 			if (err) {
 				pr_warn("map '%s': failed to create inner map: %d\n",
Index: tools/lib/bpf/bpf.h
===================================================================
--- tools/lib/bpf/bpf.h	(revision 55465)
+++ tools/lib/bpf/bpf.h	(revision 55464)
@@ -35,7 +35,7 @@
 extern "C" {
 #endif
 
-LIBBPF_API int libbpf_set_memlock_rlim(size_t memlock_bytes);
+int libbpf_set_memlock_rlim(size_t memlock_bytes);
 
 struct bpf_map_create_opts {
 	size_t sz; /* size of this struct for forward/backward compatibility */
Index: tools/lib/bpf/libbpf_internal.h
===================================================================
--- tools/lib/bpf/libbpf_internal.h	(revision 55465)
+++ tools/lib/bpf/libbpf_internal.h	(revision 55464)
@@ -17,20 +17,6 @@
 #include <unistd.h>
 #include "relo_core.h"
 
-/* Android's libc doesn't support AT_EACCESS in faccessat() implementation
- * ([0]), and just returns -EINVAL even if file exists and is accessible.
- * See [1] for issues caused by this.
- *
- * So just redefine it to 0 on Android.
- *
- * [0] https://android.googlesource.com/platform/bionic/+/refs/heads/android13-release/libc/bionic/faccessat.cpp#50
- * [1] https://github.com/libbpf/libbpf-bootstrap/issues/250#issuecomment-1911324250
- */
-#ifdef __ANDROID__
-#undef AT_EACCESS
-#define AT_EACCESS 0
-#endif
-
 /* make sure libbpf doesn't use kernel-only integer typedefs */
 #pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
 
Index: tools/perf/util/evsel.c
===================================================================
--- tools/perf/util/evsel.c	(revision 55465)
+++ tools/perf/util/evsel.c	(revision 55464)
@@ -2375,6 +2375,7 @@
 	data->period = evsel->core.attr.sample_period;
 	data->cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;
 	data->misc    = event->header.misc;
+	data->id = -1ULL;
 	data->data_src = PERF_MEM_DATA_SRC_NONE;
 	data->vcpu = -1;
 
Index: tools/perf/util/stat-display.c
===================================================================
--- tools/perf/util/stat-display.c	(revision 55465)
+++ tools/perf/util/stat-display.c	(revision 55464)
@@ -366,7 +366,7 @@
 	if (color)
 		mlen += strlen(color) + sizeof(PERF_COLOR_RESET) - 1;
 
-	color_snprintf(str, sizeof(str), color ?: "", fmt ?: "", val);
+	color_snprintf(str, sizeof(str), color ?: "", fmt, val);
 	fprintf(out, "%*s ", mlen, str);
 }
 
Index: tools/perf/util/thread_map.c
===================================================================
--- tools/perf/util/thread_map.c	(revision 55465)
+++ tools/perf/util/thread_map.c	(revision 55464)
@@ -279,7 +279,6 @@
 		threads->nr = ntasks;
 	}
 out:
-	strlist__delete(slist);
 	if (threads)
 		refcount_set(&threads->refcnt, 1);
 	return threads;
@@ -286,6 +285,7 @@
 
 out_free_threads:
 	zfree(&threads);
+	strlist__delete(slist);
 	goto out;
 }
 
Index: tools/perf/builtin-record.c
===================================================================
--- tools/perf/builtin-record.c	(revision 55465)
+++ tools/perf/builtin-record.c	(revision 55464)
@@ -1785,8 +1785,8 @@
 record__switch_output(struct record *rec, bool at_exit)
 {
 	struct perf_data *data = &rec->data;
-	char *new_filename = NULL;
 	int fd, err;
+	char *new_filename;
 
 	/* Same Size:      "2015122520103046"*/
 	char timestamp[] = "InvalidTimestamp";
Index: tools/bpf/bpftool/prog.c
===================================================================
--- tools/bpf/bpftool/prog.c	(revision 55465)
+++ tools/bpf/bpftool/prog.c	(revision 55464)
@@ -2200,7 +2200,7 @@
 	int map_fd;
 
 	profile_perf_events = calloc(
-		obj->rodata->num_cpu * obj->rodata->num_metric, sizeof(int));
+		sizeof(int), obj->rodata->num_cpu * obj->rodata->num_metric);
 	if (!profile_perf_events) {
 		p_err("failed to allocate memory for perf_event array: %s",
 		      strerror(errno));
Index: tools/bpf/resolve_btfids/main.c
===================================================================
--- tools/bpf/resolve_btfids/main.c	(revision 55465)
+++ tools/bpf/resolve_btfids/main.c	(revision 55464)
@@ -70,7 +70,6 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <linux/btf_ids.h>
 #include <linux/rbtree.h>
 #include <linux/zalloc.h>
 #include <linux/err.h>
@@ -79,7 +78,7 @@
 #include <subcmd/parse-options.h>
 
 #define BTF_IDS_SECTION	".BTF_ids"
-#define BTF_ID_PREFIX	"__BTF_ID__"
+#define BTF_ID		"__BTF_ID__"
 
 #define BTF_STRUCT	"struct"
 #define BTF_UNION	"union"
@@ -90,14 +89,6 @@
 
 #define ADDR_CNT	100
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-# define ELFDATANATIVE	ELFDATA2LSB
-#elif __BYTE_ORDER == __BIG_ENDIAN
-# define ELFDATANATIVE	ELFDATA2MSB
-#else
-# error "Unknown machine endianness!"
-#endif
-
 struct btf_id {
 	struct rb_node	 rb_node;
 	char		*name;
@@ -125,7 +116,6 @@
 		int		 idlist_shndx;
 		size_t		 strtabidx;
 		unsigned long	 idlist_addr;
-		int		 encoding;
 	} efile;
 
 	struct rb_root	sets;
@@ -171,7 +161,7 @@
 
 static bool is_btf_id(const char *name)
 {
-	return name && !strncmp(name, BTF_ID_PREFIX, sizeof(BTF_ID_PREFIX) - 1);
+	return name && !strncmp(name, BTF_ID, sizeof(BTF_ID) - 1);
 }
 
 static struct btf_id *btf_id__find(struct rb_root *root, const char *name)
@@ -329,7 +319,6 @@
 {
 	Elf_Scn *scn = NULL;
 	size_t shdrstrndx;
-	GElf_Ehdr ehdr;
 	int idx = 0;
 	Elf *elf;
 	int fd;
@@ -361,13 +350,6 @@
 		return -1;
 	}
 
-	if (gelf_getehdr(obj->efile.elf, &ehdr) == NULL) {
-		pr_err("FAILED cannot get ELF header: %s\n",
-			elf_errmsg(-1));
-		return -1;
-	}
-	obj->efile.encoding = ehdr.e_ident[EI_DATA];
-
 	/*
 	 * Scan all the elf sections and look for save data
 	 * from .BTF_ids section and symbols.
@@ -459,7 +441,7 @@
 		 * __BTF_ID__TYPE__vfs_truncate__0
 		 * prefix =  ^
 		 */
-		prefix = name + sizeof(BTF_ID_PREFIX) - 1;
+		prefix = name + sizeof(BTF_ID) - 1;
 
 		/* struct */
 		if (!strncmp(prefix, BTF_STRUCT, sizeof(BTF_STRUCT) - 1)) {
@@ -667,18 +649,19 @@
 static int sets_patch(struct object *obj)
 {
 	Elf_Data *data = obj->efile.idlist;
+	int *ptr = data->d_buf;
 	struct rb_node *next;
 
 	next = rb_first(&obj->sets);
 	while (next) {
-		struct btf_id_set8 *set8;
-		struct btf_id_set *set;
-		unsigned long addr, off;
+		unsigned long addr, idx;
 		struct btf_id *id;
+		int *base;
+		int cnt;
 
 		id   = rb_entry(next, struct btf_id, rb_node);
 		addr = id->addr[0];
-		off = addr - obj->efile.idlist_addr;
+		idx  = addr - obj->efile.idlist_addr;
 
 		/* sets are unique */
 		if (id->addr_cnt != 1) {
@@ -687,40 +670,15 @@
 			return -1;
 		}
 
-		if (id->is_set) {
-			set = data->d_buf + off;
-			qsort(set->ids, set->cnt, sizeof(set->ids[0]), cmp_id);
-		} else {
-			set8 = data->d_buf + off;
-			/*
-			 * Make sure id is at the beginning of the pairs
-			 * struct, otherwise the below qsort would not work.
-			 */
-			BUILD_BUG_ON(set8->pairs != &set8->pairs[0].id);
-			qsort(set8->pairs, set8->cnt, sizeof(set8->pairs[0]), cmp_id);
+		idx = idx / sizeof(int);
+		base = &ptr[idx] + (id->is_set8 ? 2 : 1);
+		cnt = ptr[idx];
 
-			/*
-			 * When ELF endianness does not match endianness of the
-			 * host, libelf will do the translation when updating
-			 * the ELF. This, however, corrupts SET8 flags which are
-			 * already in the target endianness. So, let's bswap
-			 * them to the host endianness and libelf will then
-			 * correctly translate everything.
-			 */
-			if (obj->efile.encoding != ELFDATANATIVE) {
-				int i;
+		pr_debug("sorting  addr %5lu: cnt %6d [%s]\n",
+			 (idx + 1) * sizeof(int), cnt, id->name);
 
-				set8->flags = bswap_32(set8->flags);
-				for (i = 0; i < set8->cnt; i++) {
-					set8->pairs[i].flags =
-						bswap_32(set8->pairs[i].flags);
-				}
-			}
-		}
+		qsort(base, cnt, id->is_set8 ? sizeof(uint64_t) : sizeof(int), cmp_id);
 
-		pr_debug("sorting  addr %5lu: cnt %6d [%s]\n",
-			 off, id->is_set ? set->cnt : set8->cnt, id->name);
-
 		next = rb_next(next);
 	}
 	return 0;
Index: block/opal_proto.h
===================================================================
--- block/opal_proto.h	(revision 55465)
+++ block/opal_proto.h	(revision 55464)
@@ -71,7 +71,6 @@
 #define SHORT_ATOM_BYTE  0xBF
 #define MEDIUM_ATOM_BYTE 0xDF
 #define LONG_ATOM_BYTE   0xE3
-#define EMPTY_ATOM_BYTE  0xFF
 
 #define OPAL_INVAL_PARAM 12
 #define OPAL_MANUFACTURED_INACTIVE 0x08
Index: block/sed-opal.c
===================================================================
--- block/sed-opal.c	(revision 55465)
+++ block/sed-opal.c	(revision 55464)
@@ -935,8 +935,6 @@
 			token_length = response_parse_medium(iter, pos);
 		else if (pos[0] <= LONG_ATOM_BYTE) /* long atom */
 			token_length = response_parse_long(iter, pos);
-		else if (pos[0] == EMPTY_ATOM_BYTE) /* empty atom */
-			token_length = 1;
 		else /* TOKEN */
 			token_length = response_parse_token(iter, pos);
 
@@ -943,12 +941,10 @@
 		if (token_length < 0)
 			return token_length;
 
-		if (pos[0] != EMPTY_ATOM_BYTE)
-			num_entries++;
-
 		pos += token_length;
 		total -= token_length;
 		iter++;
+		num_entries++;
 	}
 
 	resp->num = num_entries;
Index: scripts/kconfig/lexer.l
===================================================================
--- scripts/kconfig/lexer.l	(revision 55465)
+++ scripts/kconfig/lexer.l	(revision 55464)
@@ -302,11 +302,8 @@
 	new_string();
 	append_string(in, n);
 
-	/*
-	 * get the whole line because we do not know the end of token.
-	 * input() returns 0 (not EOF!) when it reachs the end of file.
-	 */
-	while ((c = input()) != 0) {
+	/* get the whole line because we do not know the end of token. */
+	while ((c = input()) != EOF) {
 		if (c == '\n') {
 			unput(c);
 			break;
Index: scripts/clang-tools/gen_compile_commands.py
===================================================================
--- scripts/clang-tools/gen_compile_commands.py	(revision 55465)
+++ scripts/clang-tools/gen_compile_commands.py	(revision 55464)
@@ -170,7 +170,7 @@
     # escape the pound sign '#', either as '\#' or '$(pound)' (depending on the
     # kernel version). The compile_commands.json file is not interepreted
     # by Make, so this code replaces the escaped version with '#'.
-    prefix = command_prefix.replace(r'\#', '#').replace('$(pound)', '#')
+    prefix = command_prefix.replace('\#', '#').replace('$(pound)', '#')
 
     # Use os.path.abspath() to normalize the path resolving '.' and '..' .
     abs_path = os.path.abspath(os.path.join(root_directory, file_path))
Index: init/main.c
===================================================================
--- init/main.c	(revision 55465)
+++ init/main.c	(revision 55464)
@@ -89,7 +89,6 @@
 #include <linux/sched/task_stack.h>
 #include <linux/context_tracking.h>
 #include <linux/random.h>
-#include <linux/moduleloader.h>
 #include <linux/list.h>
 #include <linux/integrity.h>
 #include <linux/proc_ns.h>
@@ -1518,11 +1517,11 @@
 	if (rodata_enabled) {
 		/*
 		 * load_module() results in W+X mappings, which are cleaned
-		 * up with init_free_wq. Let's make sure that queued work is
+		 * up with call_rcu().  Let's make sure that queued work is
 		 * flushed so that we don't hit false positives looking for
 		 * insecure pages which are W+X.
 		 */
-		flush_module_init_free_work();
+		rcu_barrier();
 		mark_rodata_ro();
 		rodata_test();
 	} else
Index: io_uring/net.c
===================================================================
--- io_uring/net.c	(revision 55465)
+++ io_uring/net.c	(revision 55464)
@@ -183,115 +183,16 @@
 	return -EAGAIN;
 }
 
-#ifdef CONFIG_COMPAT
-static int io_compat_msg_copy_hdr(struct io_kiocb *req,
-				  struct io_async_msghdr *iomsg,
-				  struct compat_msghdr *msg, int ddir)
-{
-	struct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);
-	struct compat_iovec __user *uiov;
-	int ret;
-
-	if (copy_from_user(msg, sr->umsg_compat, sizeof(*msg)))
-		return -EFAULT;
-
-	uiov = compat_ptr(msg->msg_iov);
-	if (req->flags & REQ_F_BUFFER_SELECT) {
-		compat_ssize_t clen;
-
-		iomsg->free_iov = NULL;
-		if (msg->msg_iovlen == 0) {
-			sr->len = 0;
-		} else if (msg->msg_iovlen > 1) {
-			return -EINVAL;
-		} else {
-			if (!access_ok(uiov, sizeof(*uiov)))
-				return -EFAULT;
-			if (__get_user(clen, &uiov->iov_len))
-				return -EFAULT;
-			if (clen < 0)
-				return -EINVAL;
-			sr->len = clen;
-		}
-
-		return 0;
-	}
-
-	iomsg->free_iov = iomsg->fast_iov;
-	ret = __import_iovec(ddir, (struct iovec __user *)uiov, msg->msg_iovlen,
-				UIO_FASTIOV, &iomsg->free_iov,
-				&iomsg->msg.msg_iter, true);
-	if (unlikely(ret < 0))
-		return ret;
-
-	return 0;
-}
-#endif
-
-static int io_msg_copy_hdr(struct io_kiocb *req, struct io_async_msghdr *iomsg,
-			   struct user_msghdr *msg, int ddir)
-{
-	struct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);
-	int ret;
-
-	if (copy_from_user(msg, sr->umsg, sizeof(*sr->umsg)))
-		return -EFAULT;
-
-	if (req->flags & REQ_F_BUFFER_SELECT) {
-		if (msg->msg_iovlen == 0) {
-			sr->len = iomsg->fast_iov[0].iov_len = 0;
-			iomsg->fast_iov[0].iov_base = NULL;
-			iomsg->free_iov = NULL;
-		} else if (msg->msg_iovlen > 1) {
-			return -EINVAL;
-		} else {
-			if (copy_from_user(iomsg->fast_iov, msg->msg_iov,
-					   sizeof(*msg->msg_iov)))
-				return -EFAULT;
-			sr->len = iomsg->fast_iov[0].iov_len;
-			iomsg->free_iov = NULL;
-		}
-
-		return 0;
-	}
-
-	iomsg->free_iov = iomsg->fast_iov;
-	ret = __import_iovec(ddir, msg->msg_iov, msg->msg_iovlen, UIO_FASTIOV,
-				&iomsg->free_iov, &iomsg->msg.msg_iter, false);
-	if (unlikely(ret < 0))
-		return ret;
-
-	return 0;
-}
-
 static int io_sendmsg_copy_hdr(struct io_kiocb *req,
 			       struct io_async_msghdr *iomsg)
 {
 	struct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);
-	struct user_msghdr msg;
 	int ret;
 
 	iomsg->msg.msg_name = &iomsg->addr;
-	iomsg->msg.msg_iter.nr_segs = 0;
-
-#ifdef CONFIG_COMPAT
-	if (unlikely(req->ctx->compat)) {
-		struct compat_msghdr cmsg;
-
-		ret = io_compat_msg_copy_hdr(req, iomsg, &cmsg, ITER_SOURCE);
-		if (unlikely(ret))
-			return ret;
-
-		return __get_compat_msghdr(&iomsg->msg, &cmsg, NULL);
-	}
-#endif
-
-	ret = io_msg_copy_hdr(req, iomsg, &msg, ITER_SOURCE);
-	if (unlikely(ret))
-		return ret;
-
-	ret = __copy_msghdr(&iomsg->msg, &msg, NULL);
-
+	iomsg->free_iov = iomsg->fast_iov;
+	ret = sendmsg_copy_msghdr(&iomsg->msg, sr->umsg, sr->msg_flags,
+					&iomsg->free_iov);
 	/* save msg_control as sys_sendmsg() overwrites it */
 	sr->msg_control = iomsg->msg.msg_control_user;
 	return ret;
@@ -514,77 +415,142 @@
 	return IOU_OK;
 }
 
-static int io_recvmsg_mshot_prep(struct io_kiocb *req,
-				 struct io_async_msghdr *iomsg,
-				 int namelen, size_t controllen)
+static bool io_recvmsg_multishot_overflow(struct io_async_msghdr *iomsg)
 {
-	if ((req->flags & (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT)) ==
-			  (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT)) {
-		int hdr;
+	int hdr;
 
-		if (unlikely(namelen < 0))
-			return -EOVERFLOW;
-		if (check_add_overflow(sizeof(struct io_uring_recvmsg_out),
-					namelen, &hdr))
-			return -EOVERFLOW;
-		if (check_add_overflow(hdr, controllen, &hdr))
-			return -EOVERFLOW;
+	if (iomsg->namelen < 0)
+		return true;
+	if (check_add_overflow((int)sizeof(struct io_uring_recvmsg_out),
+			       iomsg->namelen, &hdr))
+		return true;
+	if (check_add_overflow(hdr, (int)iomsg->controllen, &hdr))
+		return true;
 
-		iomsg->namelen = namelen;
-		iomsg->controllen = controllen;
-		return 0;
-	}
-
-	return 0;
+	return false;
 }
 
-static int io_recvmsg_copy_hdr(struct io_kiocb *req,
-			       struct io_async_msghdr *iomsg)
+static int __io_recvmsg_copy_hdr(struct io_kiocb *req,
+				 struct io_async_msghdr *iomsg)
 {
+	struct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);
 	struct user_msghdr msg;
 	int ret;
 
-	iomsg->msg.msg_name = &iomsg->addr;
-	iomsg->msg.msg_iter.nr_segs = 0;
+	if (copy_from_user(&msg, sr->umsg, sizeof(*sr->umsg)))
+		return -EFAULT;
 
+	ret = __copy_msghdr(&iomsg->msg, &msg, &iomsg->uaddr);
+	if (ret)
+		return ret;
+
+	if (req->flags & REQ_F_BUFFER_SELECT) {
+		if (msg.msg_iovlen == 0) {
+			sr->len = iomsg->fast_iov[0].iov_len = 0;
+			iomsg->fast_iov[0].iov_base = NULL;
+			iomsg->free_iov = NULL;
+		} else if (msg.msg_iovlen > 1) {
+			return -EINVAL;
+		} else {
+			if (copy_from_user(iomsg->fast_iov, msg.msg_iov, sizeof(*msg.msg_iov)))
+				return -EFAULT;
+			sr->len = iomsg->fast_iov[0].iov_len;
+			iomsg->free_iov = NULL;
+		}
+
+		if (req->flags & REQ_F_APOLL_MULTISHOT) {
+			iomsg->namelen = msg.msg_namelen;
+			iomsg->controllen = msg.msg_controllen;
+			if (io_recvmsg_multishot_overflow(iomsg))
+				return -EOVERFLOW;
+		}
+	} else {
+		iomsg->free_iov = iomsg->fast_iov;
+		ret = __import_iovec(ITER_DEST, msg.msg_iov, msg.msg_iovlen, UIO_FASTIOV,
+				     &iomsg->free_iov, &iomsg->msg.msg_iter,
+				     false);
+		if (ret > 0)
+			ret = 0;
+	}
+
+	return ret;
+}
+
 #ifdef CONFIG_COMPAT
-	if (unlikely(req->ctx->compat)) {
-		struct compat_msghdr cmsg;
+static int __io_compat_recvmsg_copy_hdr(struct io_kiocb *req,
+					struct io_async_msghdr *iomsg)
+{
+	struct io_sr_msg *sr = io_kiocb_to_cmd(req, struct io_sr_msg);
+	struct compat_msghdr msg;
+	struct compat_iovec __user *uiov;
+	int ret;
 
-		ret = io_compat_msg_copy_hdr(req, iomsg, &cmsg, ITER_DEST);
-		if (unlikely(ret))
-			return ret;
+	if (copy_from_user(&msg, sr->umsg_compat, sizeof(msg)))
+		return -EFAULT;
 
-		ret = __get_compat_msghdr(&iomsg->msg, &cmsg, &iomsg->uaddr);
-		if (unlikely(ret))
+	ret = __get_compat_msghdr(&iomsg->msg, &msg, &iomsg->uaddr);
+	if (ret)
+		return ret;
+
+	uiov = compat_ptr(msg.msg_iov);
+	if (req->flags & REQ_F_BUFFER_SELECT) {
+		compat_ssize_t clen;
+
+		iomsg->free_iov = NULL;
+		if (msg.msg_iovlen == 0) {
+			sr->len = 0;
+		} else if (msg.msg_iovlen > 1) {
+			return -EINVAL;
+		} else {
+			if (!access_ok(uiov, sizeof(*uiov)))
+				return -EFAULT;
+			if (__get_user(clen, &uiov->iov_len))
+				return -EFAULT;
+			if (clen < 0)
+				return -EINVAL;
+			sr->len = clen;
+		}
+
+		if (req->flags & REQ_F_APOLL_MULTISHOT) {
+			iomsg->namelen = msg.msg_namelen;
+			iomsg->controllen = msg.msg_controllen;
+			if (io_recvmsg_multishot_overflow(iomsg))
+				return -EOVERFLOW;
+		}
+	} else {
+		iomsg->free_iov = iomsg->fast_iov;
+		ret = __import_iovec(ITER_DEST, (struct iovec __user *)uiov, msg.msg_iovlen,
+				   UIO_FASTIOV, &iomsg->free_iov,
+				   &iomsg->msg.msg_iter, true);
+		if (ret < 0)
 			return ret;
+	}
 
-		return io_recvmsg_mshot_prep(req, iomsg, cmsg.msg_namelen,
-						cmsg.msg_controllen);
-	}
+	return 0;
+}
 #endif
 
-	ret = io_msg_copy_hdr(req, iomsg, &msg, ITER_DEST);
-	if (unlikely(ret))
-		return ret;
+static int io_recvmsg_copy_hdr(struct io_kiocb *req,
+			       struct io_async_msghdr *iomsg)
+{
+	iomsg->msg.msg_name = &iomsg->addr;
+	iomsg->msg.msg_iter.nr_segs = 0;
 
-	ret = __copy_msghdr(&iomsg->msg, &msg, &iomsg->uaddr);
-	if (unlikely(ret))
-		return ret;
+#ifdef CONFIG_COMPAT
+	if (req->ctx->compat)
+		return __io_compat_recvmsg_copy_hdr(req, iomsg);
+#endif
 
-	return io_recvmsg_mshot_prep(req, iomsg, msg.msg_namelen,
-					msg.msg_controllen);
+	return __io_recvmsg_copy_hdr(req, iomsg);
 }
 
 int io_recvmsg_prep_async(struct io_kiocb *req)
 {
-	struct io_async_msghdr *iomsg;
 	int ret;
 
 	if (!io_msg_alloc_async_prep(req))
 		return -ENOMEM;
-	iomsg = req->async_data;
-	ret = io_recvmsg_copy_hdr(req, iomsg);
+	ret = io_recvmsg_copy_hdr(req, req->async_data);
 	if (!ret)
 		req->flags |= REQ_F_NEED_CLEANUP;
 	return ret;
Index: io_uring/io_uring.c
===================================================================
--- io_uring/io_uring.c	(revision 55465)
+++ io_uring/io_uring.c	(revision 55464)
@@ -60,6 +60,7 @@
 #include <linux/net.h>
 #include <net/sock.h>
 #include <net/af_unix.h>
+#include <net/scm.h>
 #include <linux/anon_inodes.h>
 #include <linux/sched/mm.h>
 #include <linux/uaccess.h>
@@ -152,6 +153,19 @@
 
 static struct kmem_cache *req_cachep;
 
+struct sock *io_uring_get_socket(struct file *file)
+{
+#if defined(CONFIG_UNIX)
+	if (io_is_uring_fops(file)) {
+		struct io_ring_ctx *ctx = file->private_data;
+
+		return ctx->ring_sock->sk;
+	}
+#endif
+	return NULL;
+}
+EXPORT_SYMBOL(io_uring_get_socket);
+
 static inline void io_submit_flush_completions(struct io_ring_ctx *ctx)
 {
 	if (!wq_list_empty(&ctx->submit_state.compl_reqs))
@@ -2627,6 +2641,12 @@
 	WARN_ON_ONCE(!list_empty(&ctx->rsrc_ref_list));
 	WARN_ON_ONCE(!llist_empty(&ctx->rsrc_put_llist));
 
+#if defined(CONFIG_UNIX)
+	if (ctx->ring_sock) {
+		ctx->ring_sock->file = NULL; /* so that iput() is called */
+		sock_release(ctx->ring_sock);
+	}
+#endif
 	WARN_ON_ONCE(!list_empty(&ctx->ltimeout_list));
 
 	if (ctx->mm_account) {
@@ -3431,12 +3451,32 @@
 /*
  * Allocate an anonymous fd, this is what constitutes the application
  * visible backing of an io_uring instance. The application mmaps this
- * fd to gain access to the SQ/CQ ring details.
+ * fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,
+ * we have to tie this fd to a socket for file garbage collection purposes.
  */
 static struct file *io_uring_get_file(struct io_ring_ctx *ctx)
 {
-	return anon_inode_getfile_secure("[io_uring]", &io_uring_fops, ctx,
+	struct file *file;
+#if defined(CONFIG_UNIX)
+	int ret;
+
+	ret = sock_create_kern(&init_net, PF_UNIX, SOCK_RAW, IPPROTO_IP,
+				&ctx->ring_sock);
+	if (ret)
+		return ERR_PTR(ret);
+#endif
+
+	file = anon_inode_getfile_secure("[io_uring]", &io_uring_fops, ctx,
 					 O_RDWR | O_CLOEXEC, NULL);
+#if defined(CONFIG_UNIX)
+	if (IS_ERR(file)) {
+		sock_release(ctx->ring_sock);
+		ctx->ring_sock = NULL;
+	} else {
+		ctx->ring_sock->file = file;
+	}
+#endif
+	return file;
 }
 
 static __cold int io_uring_create(unsigned entries, struct io_uring_params *p,
Index: io_uring/rsrc.h
===================================================================
--- io_uring/rsrc.h	(revision 55465)
+++ io_uring/rsrc.h	(revision 55464)
@@ -77,6 +77,21 @@
 int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,
 			  unsigned nr_args, u64 __user *tags);
 
+int __io_scm_file_account(struct io_ring_ctx *ctx, struct file *file);
+
+static inline bool io_file_need_scm(struct file *filp)
+{
+	return false;
+}
+
+static inline int io_scm_file_account(struct io_ring_ctx *ctx,
+				      struct file *file)
+{
+	if (likely(!io_file_need_scm(file)))
+		return 0;
+	return __io_scm_file_account(ctx, file);
+}
+
 int io_register_files_update(struct io_ring_ctx *ctx, void __user *arg,
 			     unsigned nr_args);
 int io_register_rsrc_update(struct io_ring_ctx *ctx, void __user *arg,
Index: io_uring/rsrc.c
===================================================================
--- io_uring/rsrc.c	(revision 55465)
+++ io_uring/rsrc.c	(revision 55464)
@@ -494,6 +494,11 @@
 				err = -EBADF;
 				break;
 			}
+			err = io_scm_file_account(ctx, file);
+			if (err) {
+				fput(file);
+				break;
+			}
 			*io_get_tag_slot(data, i) = tag;
 			io_fixed_file_set(file_slot, file);
 			io_file_bitmap_set(&ctx->file_table, i);
@@ -757,12 +762,22 @@
 	for (i = 0; i < ctx->nr_user_files; i++) {
 		struct file *file = io_file_from_index(&ctx->file_table, i);
 
-		if (!file)
+		/* skip scm accounted files, they'll be freed by ->ring_sock */
+		if (!file || io_file_need_scm(file))
 			continue;
 		io_file_bitmap_clear(&ctx->file_table, i);
 		fput(file);
 	}
 
+#if defined(CONFIG_UNIX)
+	if (ctx->ring_sock) {
+		struct sock *sock = ctx->ring_sock->sk;
+		struct sk_buff *skb;
+
+		while ((skb = skb_dequeue(&sock->sk_receive_queue)) != NULL)
+			kfree_skb(skb);
+	}
+#endif
 	io_free_file_tables(&ctx->file_table);
 	io_file_table_set_alloc_range(ctx, 0, 0);
 	io_rsrc_data_free(ctx->file_data);
@@ -790,11 +805,134 @@
 	return ret;
 }
 
+/*
+ * Ensure the UNIX gc is aware of our file set, so we are certain that
+ * the io_uring can be safely unregistered on process exit, even if we have
+ * loops in the file referencing. We account only files that can hold other
+ * files because otherwise they can't form a loop and so are not interesting
+ * for GC.
+ */
+int __io_scm_file_account(struct io_ring_ctx *ctx, struct file *file)
+{
+#if defined(CONFIG_UNIX)
+	struct sock *sk = ctx->ring_sock->sk;
+	struct sk_buff_head *head = &sk->sk_receive_queue;
+	struct scm_fp_list *fpl;
+	struct sk_buff *skb;
+
+	if (likely(!io_file_need_scm(file)))
+		return 0;
+
+	/*
+	 * See if we can merge this file into an existing skb SCM_RIGHTS
+	 * file set. If there's no room, fall back to allocating a new skb
+	 * and filling it in.
+	 */
+	spin_lock_irq(&head->lock);
+	skb = skb_peek(head);
+	if (skb && UNIXCB(skb).fp->count < SCM_MAX_FD)
+		__skb_unlink(skb, head);
+	else
+		skb = NULL;
+	spin_unlock_irq(&head->lock);
+
+	if (!skb) {
+		fpl = kzalloc(sizeof(*fpl), GFP_KERNEL);
+		if (!fpl)
+			return -ENOMEM;
+
+		skb = alloc_skb(0, GFP_KERNEL);
+		if (!skb) {
+			kfree(fpl);
+			return -ENOMEM;
+		}
+
+		fpl->user = get_uid(current_user());
+		fpl->max = SCM_MAX_FD;
+		fpl->count = 0;
+
+		UNIXCB(skb).fp = fpl;
+		skb->sk = sk;
+		skb->scm_io_uring = 1;
+		skb->destructor = unix_destruct_scm;
+		refcount_add(skb->truesize, &sk->sk_wmem_alloc);
+	}
+
+	fpl = UNIXCB(skb).fp;
+	fpl->fp[fpl->count++] = get_file(file);
+	unix_inflight(fpl->user, file);
+	skb_queue_head(head, skb);
+	fput(file);
+#endif
+	return 0;
+}
+
 static void io_rsrc_file_put(struct io_ring_ctx *ctx, struct io_rsrc_put *prsrc)
 {
 	struct file *file = prsrc->file;
+#if defined(CONFIG_UNIX)
+	struct sock *sock = ctx->ring_sock->sk;
+	struct sk_buff_head list, *head = &sock->sk_receive_queue;
+	struct sk_buff *skb;
+	int i;
 
+	if (!io_file_need_scm(file)) {
+		fput(file);
+		return;
+	}
+
+	__skb_queue_head_init(&list);
+
+	/*
+	 * Find the skb that holds this file in its SCM_RIGHTS. When found,
+	 * remove this entry and rearrange the file array.
+	 */
+	skb = skb_dequeue(head);
+	while (skb) {
+		struct scm_fp_list *fp;
+
+		fp = UNIXCB(skb).fp;
+		for (i = 0; i < fp->count; i++) {
+			int left;
+
+			if (fp->fp[i] != file)
+				continue;
+
+			unix_notinflight(fp->user, fp->fp[i]);
+			left = fp->count - 1 - i;
+			if (left) {
+				memmove(&fp->fp[i], &fp->fp[i + 1],
+						left * sizeof(struct file *));
+			}
+			fp->count--;
+			if (!fp->count) {
+				kfree_skb(skb);
+				skb = NULL;
+			} else {
+				__skb_queue_tail(&list, skb);
+			}
+			fput(file);
+			file = NULL;
+			break;
+		}
+
+		if (!file)
+			break;
+
+		__skb_queue_tail(&list, skb);
+
+		skb = skb_dequeue(head);
+	}
+
+	if (skb_peek(&list)) {
+		spin_lock_irq(&head->lock);
+		while ((skb = __skb_dequeue(&list)) != NULL)
+			__skb_queue_tail(head, skb);
+		spin_unlock_irq(&head->lock);
+	}
+#else
 	fput(file);
+#endif
 }
 
 int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,
@@ -848,12 +986,21 @@
 			goto fail;
 
 		/*
-		 * Don't allow io_uring instances to be registered.
+		 * Don't allow io_uring instances to be registered. If UNIX
+		 * isn't enabled, then this causes a reference cycle and this
+		 * instance can never get freed. If UNIX is enabled we'll
+		 * handle it just fine, but there's still no point in allowing
+		 * a ring fd as it doesn't support regular read/write anyway.
 		 */
 		if (io_is_uring_fops(file)) {
 			fput(file);
 			goto fail;
 		}
+		ret = io_scm_file_account(ctx, file);
+		if (ret) {
+			fput(file);
+			goto fail;
+		}
 		file_slot = io_fixed_file_slot(&ctx->file_table, i);
 		io_fixed_file_set(file_slot, file);
 		io_file_bitmap_set(&ctx->file_table, i);
Index: io_uring/filetable.c
===================================================================
--- io_uring/filetable.c	(revision 55465)
+++ io_uring/filetable.c	(revision 55464)
@@ -95,10 +95,12 @@
 		needs_switch = true;
 	}
 
-	*io_get_tag_slot(ctx->file_data, slot_index) = 0;
-	io_fixed_file_set(file_slot, file);
-	io_file_bitmap_set(&ctx->file_table, slot_index);
-	return 0;
+	ret = io_scm_file_account(ctx, file);
+	if (!ret) {
+		*io_get_tag_slot(ctx->file_data, slot_index) = 0;
+		io_fixed_file_set(file_slot, file);
+		io_file_bitmap_set(&ctx->file_table, slot_index);
+	}
 err:
 	if (needs_switch)
 		io_rsrc_node_switch(ctx, ctx->file_data);
Index: io_uring/io_uring.h
===================================================================
--- io_uring/io_uring.h	(revision 55465)
+++ io_uring/io_uring.h	(revision 55464)
@@ -52,6 +52,7 @@
 }
 
 void __io_req_task_work_add(struct io_kiocb *req, bool allow_local);
+bool io_is_uring_fops(struct file *file);
 bool io_alloc_async_data(struct io_kiocb *req);
 void io_req_task_queue(struct io_kiocb *req);
 void io_queue_iowq(struct io_kiocb *req, bool *dont_use);
Index: crypto/Kconfig
===================================================================
--- crypto/Kconfig	(revision 55465)
+++ crypto/Kconfig	(revision 55464)
@@ -1285,11 +1285,10 @@
 
 	  A non-physical non-deterministic ("true") RNG (e.g., an entropy source
 	  compliant with NIST SP800-90B) intended to provide a seed to a
-	  deterministic RNG (e.g., per NIST SP800-90C).
+	  deterministic RNG (e.g.  per NIST SP800-90C).
 	  This RNG does not perform any cryptographic whitening of the generated
-	  random numbers.
 
-	  See https://www.chronox.de/jent/
+	  See https://www.chronox.de/jent.html
 
 config CRYPTO_KDF800108_CTR
 	tristate

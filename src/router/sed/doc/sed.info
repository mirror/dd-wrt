This is sed.info, produced by makeinfo version 6.8dev from sed.texi.

This file documents version 4.9 of GNU ‘sed’, a stream editor.

   Copyright © 1998–2022 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled “GNU Free Documentation License”.
INFO-DIR-SECTION Text creation and manipulation
START-INFO-DIR-ENTRY
* sed: (sed).                   Stream EDitor.

END-INFO-DIR-ENTRY


File: sed.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU ‘sed’
*********

This file documents version 4.9 of GNU ‘sed’, a stream editor.

   Copyright © 1998–2022 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled “GNU Free Documentation License”.

* Menu:

* Introduction::               Introduction
* Invoking sed::               Invocation
* sed scripts::                ‘sed’ scripts
* sed addresses::              Addresses: selecting lines
* sed regular expressions::    Regular expressions: selecting text
* advanced sed::               Advanced ‘sed’: cycles and buffers
* Examples::                   Some sample scripts
* Limitations::                Limitations and (non-)limitations of GNU ‘sed’
* Other Resources::            Other resources for learning about ‘sed’
* Reporting Bugs::             Reporting bugs
* GNU Free Documentation License:: Copying and sharing this manual
* Concept Index::              A menu with all the topics in this manual.
* Command and Option Index::   A menu with all ‘sed’ commands and
                               command-line options.


File: sed.info,  Node: Introduction,  Next: Invoking sed,  Prev: Top,  Up: Top

1 Introduction
**************

‘sed’ is a stream editor.  A stream editor is used to perform basic text
transformations on an input stream (a file or input from a pipeline).
While in some ways similar to an editor which permits scripted edits
(such as ‘ed’), ‘sed’ works by making only one pass over the input(s),
and is consequently more efficient.  But it is ‘sed’’s ability to filter
text in a pipeline which particularly distinguishes it from other types
of editors.


File: sed.info,  Node: Invoking sed,  Next: sed scripts,  Prev: Introduction,  Up: Top

2 Running sed
*************

This chapter covers how to run ‘sed’.  Details of ‘sed’ scripts and
individual ‘sed’ commands are discussed in the next chapter.

* Menu:

* Overview::
* Command-Line Options::
* Exit status::


File: sed.info,  Node: Overview,  Next: Command-Line Options,  Up: Invoking sed

2.1 Overview
============

Normally ‘sed’ is invoked like this:

     sed SCRIPT INPUTFILE...

   For example, to change every ‘hello’ to ‘world’ in the file
‘input.txt’:

     sed 's/hello/world/g' input.txt > output.txt

   Without the ‘g’ (global) modifier, ‘sed’ affects only the first
instance per line.

   If you do not specify INPUTFILE, or if INPUTFILE is ‘-’, ‘sed’
filters the contents of the standard input.  The following commands are
equivalent:

     sed 's/hello/world/g' input.txt > output.txt
     sed 's/hello/world/g' < input.txt > output.txt
     cat input.txt | sed 's/hello/world/g' - > output.txt

   ‘sed’ writes output to standard output.  Use ‘-i’ to edit files
in-place instead of printing to standard output.  See also the ‘W’ and
‘s///w’ commands for writing output to other files.  The following
command modifies ‘file.txt’ and does not produce any output:

     sed -i 's/hello/world/' file.txt

   By default ‘sed’ prints all processed input (except input that has
been modified/deleted by commands such as ‘d’).  Use ‘-n’ to suppress
output, and the ‘p’ command to print specific lines.  The following
command prints only line 45 of the input file:

     sed -n '45p' file.txt

   ‘sed’ treats multiple input files as one long stream.  The following
example prints the first line of the first file (‘one.txt’) and the last
line of the last file (‘three.txt’).  Use ‘-s’ to reverse this behavior.

     sed -n  '1p ; $p' one.txt two.txt three.txt

   Without ‘-e’ or ‘-f’ options, ‘sed’ uses the first non-option
parameter as the SCRIPT, and the following non-option parameters as
input files.  If ‘-e’ or ‘-f’ options are used to specify a SCRIPT, all
non-option parameters are taken as input files.  Options ‘-e’ and ‘-f’
can be combined, and can appear multiple times (in which case the final
effective SCRIPT will be concatenation of all the individual SCRIPTs).

   The following examples are equivalent:

     sed 's/hello/world/' input.txt > output.txt

     sed -e 's/hello/world/' input.txt > output.txt
     sed --expression='s/hello/world/' input.txt > output.txt

     echo 's/hello/world/' > myscript.sed
     sed -f myscript.sed input.txt > output.txt
     sed --file=myscript.sed input.txt > output.txt


File: sed.info,  Node: Command-Line Options,  Next: Exit status,  Prev: Overview,  Up: Invoking sed

2.2 Command-Line Options
========================

The full format for invoking ‘sed’ is:

     sed OPTIONS... [SCRIPT] [INPUTFILE...]

   ‘sed’ may be invoked with the following command-line options:

‘--version’
     Print out the version of ‘sed’ that is being run and a copyright
     notice, then exit.

‘--help’
     Print a usage message briefly summarizing these command-line
     options and the bug-reporting address, then exit.

‘-n’
‘--quiet’
‘--silent’
     By default, ‘sed’ prints out the pattern space at the end of each
     cycle through the script (*note How ‘sed’ works: Execution Cycle.).
     These options disable this automatic printing, and ‘sed’ only
     produces output when explicitly told to via the ‘p’ command.

‘--debug’
     Print the input sed program in canonical form, and annotate program
     execution.
          $ echo 1 | sed '\%1%s21232'
          3

          $ echo 1 | sed --debug '\%1%s21232'
          SED PROGRAM:
            /1/ s/1/3/
          INPUT:   'STDIN' line 1
          PATTERN: 1
          COMMAND: /1/ s/1/3/
          PATTERN: 3
          END-OF-CYCLE:
          3

‘-e SCRIPT’
‘--expression=SCRIPT’
     Add the commands in SCRIPT to the set of commands to be run while
     processing the input.

‘-f SCRIPT-FILE’
‘--file=SCRIPT-FILE’
     Add the commands contained in the file SCRIPT-FILE to the set of
     commands to be run while processing the input.

‘-i[SUFFIX]’
‘--in-place[=SUFFIX]’
     This option specifies that files are to be edited in-place.  GNU
     ‘sed’ does this by creating a temporary file and sending output to
     this file rather than to the standard output.(1).

     This option implies ‘-s’.

     When the end of the file is reached, the temporary file is renamed
     to the output file’s original name.  The extension, if supplied, is
     used to modify the name of the old file before renaming the
     temporary file, thereby making a backup copy(2)).

     This rule is followed: if the extension doesn’t contain a ‘*’, then
     it is appended to the end of the current filename as a suffix; if
     the extension does contain one or more ‘*’ characters, then _each_
     asterisk is replaced with the current filename.  This allows you to
     add a prefix to the backup file, instead of (or in addition to) a
     suffix, or even to place backup copies of the original files into
     another directory (provided the directory already exists).

     If no extension is supplied, the original file is overwritten
     without making a backup.

     Because ‘-i’ takes an optional argument, it should not be followed
     by other short options:
     ‘sed -Ei '...' FILE’
          Same as ‘-E -i’ with no backup suffix - ‘FILE’ will be edited
          in-place without creating a backup.

     ‘sed -iE '...' FILE’
          This is equivalent to ‘--in-place=E’, creating ‘FILEE’ as
          backup of ‘FILE’

     Be cautious of using ‘-n’ with ‘-i’: the former disables automatic
     printing of lines and the latter changes the file in-place without
     a backup.  Used carelessly (and without an explicit ‘p’ command),
     the output file will be empty:
          # WRONG USAGE: 'FILE' will be truncated.
          sed -ni 's/foo/bar/' FILE

‘-l N’
‘--line-length=N’
     Specify the default line-wrap length for the ‘l’ command.  A length
     of 0 (zero) means to never wrap long lines.  If not specified, it
     is taken to be 70.

‘--posix’
     GNU ‘sed’ includes several extensions to POSIX sed.  In order to
     simplify writing portable scripts, this option disables all the
     extensions that this manual documents, including additional
     commands.  Most of the extensions accept ‘sed’ programs that are
     outside the syntax mandated by POSIX, but some of them (such as the
     behavior of the ‘N’ command described in *note Reporting Bugs::)
     actually violate the standard.  If you want to disable only the
     latter kind of extension, you can set the ‘POSIXLY_CORRECT’
     variable to a non-empty value.

‘-b’
‘--binary’
     This option is available on every platform, but is only effective
     where the operating system makes a distinction between text files
     and binary files.  When such a distinction is made—as is the case
     for MS-DOS, Windows, Cygwin—text files are composed of lines
     separated by a carriage return _and_ a line feed character, and
     ‘sed’ does not see the ending CR. When this option is specified,
     ‘sed’ will open input files in binary mode, thus not requesting
     this special processing and considering lines to end at a line
     feed.

‘--follow-symlinks’
     This option is available only on platforms that support symbolic
     links and has an effect only if option ‘-i’ is specified.  In this
     case, if the file that is specified on the command line is a
     symbolic link, ‘sed’ will follow the link and edit the ultimate
     destination of the link.  The default behavior is to break the
     symbolic link, so that the link destination will not be modified.

‘-E’
‘-r’
‘--regexp-extended’
     Use extended regular expressions rather than basic regular
     expressions.  Extended regexps are those that ‘egrep’ accepts; they
     can be clearer because they usually have fewer backslashes.
     Historically this was a GNU extension, but the ‘-E’ extension has
     since been added to the POSIX standard
     (http://austingroupbugs.net/view.php?id=528), so use ‘-E’ for
     portability.  GNU sed has accepted ‘-E’ as an undocumented option
     for years, and *BSD seds have accepted ‘-E’ for years as well, but
     scripts that use ‘-E’ might not port to other older systems.  *Note
     Extended regular expressions: ERE syntax.

‘-s’
‘--separate’
     By default, ‘sed’ will consider the files specified on the command
     line as a single continuous long stream.  This GNU ‘sed’ extension
     allows the user to consider them as separate files: range addresses
     (such as ‘/abc/,/def/’) are not allowed to span several files, line
     numbers are relative to the start of each file, ‘$’ refers to the
     last line of each file, and files invoked from the ‘R’ commands are
     rewound at the start of each file.

‘--sandbox’
     In sandbox mode, ‘e/w/r’ commands are rejected - programs
     containing them will be aborted without being run.  Sandbox mode
     ensures ‘sed’ operates only on the input files designated on the
     command line, and cannot run external programs.

‘-u’
‘--unbuffered’
     Buffer both input and output as minimally as practical.  (This is
     particularly useful if the input is coming from the likes of ‘tail
     -f’, and you wish to see the transformed output as soon as
     possible.)

‘-z’
‘--null-data’
‘--zero-terminated’
     Treat the input as a set of lines, each terminated by a zero byte
     (the ASCII ‘NUL’ character) instead of a newline.  This option can
     be used with commands like ‘sort -z’ and ‘find -print0’ to process
     arbitrary file names.

   If no ‘-e’, ‘-f’, ‘--expression’, or ‘--file’ options are given on
the command-line, then the first non-option argument on the command line
is taken to be the SCRIPT to be executed.

   If any command-line parameters remain after processing the above,
these parameters are interpreted as the names of input files to be
processed.  A file name of ‘-’ refers to the standard input stream.  The
standard input will be processed if no file names are specified.

   ---------- Footnotes ----------

   (1) This applies to commands such as ‘=’, ‘a’, ‘c’, ‘i’, ‘l’, ‘p’.
You can still write to the standard output by using the ‘w’ or ‘W’
commands together with the ‘/dev/stdout’ special file

   (2) Note that GNU ‘sed’ creates the backup file whether or not any
output is actually changed.


File: sed.info,  Node: Exit status,  Prev: Command-Line Options,  Up: Invoking sed

2.3 Exit status
===============

An exit status of zero indicates success, and a nonzero value indicates
failure.  GNU ‘sed’ returns the following exit status error values:

0
     Successful completion.

1
     Invalid command, invalid syntax, invalid regular expression or a
     GNU ‘sed’ extension command used with ‘--posix’.

2
     One or more of the input file specified on the command line could
     not be opened (e.g.  if a file is not found, or read permission is
     denied).  Processing continued with other files.

4
     An I/O error, or a serious processing error during runtime, GNU
     ‘sed’ aborted immediately.

   Additionally, the commands ‘q’ and ‘Q’ can be used to terminate ‘sed’
with a custom exit code value (this is a GNU ‘sed’ extension):

     $ echo | sed 'Q42' ; echo $?
     42


File: sed.info,  Node: sed scripts,  Next: sed addresses,  Prev: Invoking sed,  Up: Top

3 ‘sed’ scripts
***************

* Menu:

* sed script overview::      ‘sed’ script overview
* sed commands list::        ‘sed’ commands summary
* The "s" Command::          ‘sed’’s Swiss Army Knife
* Common Commands::          Often used commands
* Other Commands::           Less frequently used commands
* Programming Commands::     Commands for ‘sed’ gurus
* Extended Commands::        Commands specific of GNU ‘sed’
* Multiple commands syntax:: Extension for easier scripting


File: sed.info,  Node: sed script overview,  Next: sed commands list,  Up: sed scripts

3.1 ‘sed’ script overview
=========================

A ‘sed’ program consists of one or more ‘sed’ commands, passed in by one
or more of the ‘-e’, ‘-f’, ‘--expression’, and ‘--file’ options, or the
first non-option argument if zero of these options are used.  This
document will refer to “the” ‘sed’ script; this is understood to mean
the in-order concatenation of all of the SCRIPTs and SCRIPT-FILEs passed
in.  *Note Overview::.

   ‘sed’ commands follow this syntax:

     [addr]X[options]

   X is a single-letter ‘sed’ command.  ‘[addr]’ is an optional line
address.  If ‘[addr]’ is specified, the command X will be executed only
on the matched lines.  ‘[addr]’ can be a single line number, a regular
expression, or a range of lines (*note sed addresses::).  Additional
‘[options]’ are used for some ‘sed’ commands.

   The following example deletes lines 30 to 35 in the input.  ‘30,35’
is an address range.  ‘d’ is the delete command:

     sed '30,35d' input.txt > output.txt

   The following example prints all input until a line starting with the
string ‘foo’ is found.  If such line is found, ‘sed’ will terminate with
exit status 42.  If such line was not found (and no other error
occurred), ‘sed’ will exit with status 0.  ‘/^foo/’ is a
regular-expression address.  ‘q’ is the quit command.  ‘42’ is the
command option.

     sed '/^foo/q42' input.txt > output.txt

   Commands within a SCRIPT or SCRIPT-FILE can be separated by
semicolons (‘;’) or newlines (ASCII 10).  Multiple scripts can be
specified with ‘-e’ or ‘-f’ options.

   The following examples are all equivalent.  They perform two ‘sed’
operations: deleting any lines matching the regular expression ‘/^foo/’,
and replacing all occurrences of the string ‘hello’ with ‘world’:

     sed '/^foo/d ; s/hello/world/g' input.txt > output.txt

     sed -e '/^foo/d' -e 's/hello/world/g' input.txt > output.txt

     echo '/^foo/d' > script.sed
     echo 's/hello/world/g' >> script.sed
     sed -f script.sed input.txt > output.txt

     echo 's/hello/world/g' > script2.sed
     sed -e '/^foo/d' -f script2.sed input.txt > output.txt

   Commands ‘a’, ‘c’, ‘i’, due to their syntax, cannot be followed by
semicolons working as command separators and thus should be terminated
with newlines or be placed at the end of a SCRIPT or SCRIPT-FILE.
Commands can also be preceded with optional non-significant whitespace
characters.  *Note Multiple commands syntax::.


File: sed.info,  Node: sed commands list,  Next: The "s" Command,  Prev: sed script overview,  Up: sed scripts

3.2 ‘sed’ commands summary
==========================

The following commands are supported in GNU ‘sed’.  Some are standard
POSIX commands, while other are GNU extensions.  Details and examples
for each command are in the following sections.  (Mnemonics) are shown
in parentheses.

‘a\’
‘TEXT’
     Append TEXT after a line.

‘a TEXT’
     Append TEXT after a line (alternative syntax).

‘b LABEL’
     Branch unconditionally to LABEL.  The LABEL may be omitted, in
     which case the next cycle is started.

‘c\’
‘TEXT’
     Replace (change) lines with TEXT.

‘c TEXT’
     Replace (change) lines with TEXT (alternative syntax).

‘d’
     Delete the pattern space; immediately start next cycle.

‘D’
     If pattern space contains newlines, delete text in the pattern
     space up to the first newline, and restart cycle with the resultant
     pattern space, without reading a new line of input.

     If pattern space contains no newline, start a normal new cycle as
     if the ‘d’ command was issued.

‘e’
     Executes the command that is found in pattern space and replaces
     the pattern space with the output; a trailing newline is
     suppressed.

‘e COMMAND’
     Executes COMMAND and sends its output to the output stream.  The
     command can run across multiple lines, all but the last ending with
     a back-slash.

‘F’
     (filename) Print the file name of the current input file (with a
     trailing newline).

‘g’
     Replace the contents of the pattern space with the contents of the
     hold space.

‘G’
     Append a newline to the contents of the pattern space, and then
     append the contents of the hold space to that of the pattern space.

‘h’
     (hold) Replace the contents of the hold space with the contents of
     the pattern space.

‘H’
     Append a newline to the contents of the hold space, and then append
     the contents of the pattern space to that of the hold space.

‘i\’
‘TEXT’
     insert TEXT before a line.

‘i TEXT’
     insert TEXT before a line (alternative syntax).

‘l’
     Print the pattern space in an unambiguous form.

‘n’
     (next) If auto-print is not disabled, print the pattern space,
     then, regardless, replace the pattern space with the next line of
     input.  If there is no more input then ‘sed’ exits without
     processing any more commands.

‘N’
     Add a newline to the pattern space, then append the next line of
     input to the pattern space.  If there is no more input then ‘sed’
     exits without processing any more commands.

‘p’
     Print the pattern space.

‘P’
     Print the pattern space, up to the first <newline>.

‘q[EXIT-CODE]’
     (quit) Exit ‘sed’ without processing any more commands or input.

‘Q[EXIT-CODE]’
     (quit) This command is the same as ‘q’, but will not print the
     contents of pattern space.  Like ‘q’, it provides the ability to
     return an exit code to the caller.

‘r filename’
     Reads file FILENAME.

‘R filename’
     Queue a line of FILENAME to be read and inserted into the output
     stream at the end of the current cycle, or when the next input line
     is read.

‘s/REGEXP/REPLACEMENT/[FLAGS]’
     (substitute) Match the regular-expression against the content of
     the pattern space.  If found, replace matched string with
     REPLACEMENT.

‘t LABEL’
     (test) Branch to LABEL only if there has been a successful
     ‘s’ubstitution since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

‘T LABEL’
     (test) Branch to LABEL only if there have been no successful
     ‘s’ubstitutions since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

‘v [VERSION]’
     (version) This command does nothing, but makes ‘sed’ fail if GNU
     ‘sed’ extensions are not supported, or if the requested version is
     not available.

‘w filename’
     Write the pattern space to FILENAME.

‘W filename’
     Write to the given filename the portion of the pattern space up to
     the first newline

‘x’
     Exchange the contents of the hold and pattern spaces.

‘y/src/dst/’
     Transliterate any characters in the pattern space which match any
     of the SOURCE-CHARS with the corresponding character in DEST-CHARS.

‘z’
     (zap) This command empties the content of pattern space.

‘#’
     A comment, until the next newline.

‘{ CMD ; CMD ... }’
     Group several commands together.

‘=’
     Print the current input line number (with a trailing newline).

‘: LABEL’
     Specify the location of LABEL for branch commands (‘b’, ‘t’, ‘T’).


File: sed.info,  Node: The "s" Command,  Next: Common Commands,  Prev: sed commands list,  Up: sed scripts

3.3 The ‘s’ Command
===================

The ‘s’ command (as in substitute) is probably the most important in
‘sed’ and has a lot of different options.  The syntax of the ‘s’ command
is ‘s/REGEXP/REPLACEMENT/FLAGS’.

   Its basic concept is simple: the ‘s’ command attempts to match the
pattern space against the supplied regular expression REGEXP; if the
match is successful, then that portion of the pattern space which was
matched is replaced with REPLACEMENT.

   For details about REGEXP syntax *note Regular Expression Addresses:
Regexp Addresses.

   The REPLACEMENT can contain ‘\N’ (N being a number from 1 to 9,
inclusive) references, which refer to the portion of the match which is
contained between the Nth ‘\(’ and its matching ‘\)’.  Also, the
REPLACEMENT can contain unescaped ‘&’ characters which reference the
whole matched portion of the pattern space.

   The ‘/’ characters may be uniformly replaced by any other single
character within any given ‘s’ command.  The ‘/’ character (or whatever
other character is used in its stead) can appear in the REGEXP or
REPLACEMENT only if it is preceded by a ‘\’ character.

   Finally, as a GNU ‘sed’ extension, you can include a special sequence
made of a backslash and one of the letters ‘L’, ‘l’, ‘U’, ‘u’, or ‘E’.
The meaning is as follows:

‘\L’
     Turn the replacement to lowercase until a ‘\U’ or ‘\E’ is found,

‘\l’
     Turn the next character to lowercase,

‘\U’
     Turn the replacement to uppercase until a ‘\L’ or ‘\E’ is found,

‘\u’
     Turn the next character to uppercase,

‘\E’
     Stop case conversion started by ‘\L’ or ‘\U’.

   When the ‘g’ flag is being used, case conversion does not propagate
from one occurrence of the regular expression to another.  For example,
when the following command is executed with ‘a-b-’ in pattern space:
     s/\(b\?\)-/x\u\1/g

the output is ‘axxB’.  When replacing the first ‘-’, the ‘\u’ sequence
only affects the empty replacement of ‘\1’.  It does not affect the ‘x’
character that is added to pattern space when replacing ‘b-’ with ‘xB’.

   On the other hand, ‘\l’ and ‘\u’ do affect the remainder of the
replacement text if they are followed by an empty substitution.  With
‘a-b-’ in pattern space, the following command:
     s/\(b\?\)-/\u\1x/g

will replace ‘-’ with ‘X’ (uppercase) and ‘b-’ with ‘Bx’.  If this
behavior is undesirable, you can prevent it by adding a ‘\E’
sequence—after ‘\1’ in this case.

   To include a literal ‘\’, ‘&’, or newline in the final replacement,
be sure to precede the desired ‘\’, ‘&’, or newline in the REPLACEMENT
with a ‘\’.

   The ‘s’ command can be followed by zero or more of the following
FLAGS:

‘g’
     Apply the replacement to _all_ matches to the REGEXP, not just the
     first.

‘NUMBER’
     Only replace the NUMBERth match of the REGEXP.

     interaction in ‘s’ command Note: the POSIX standard does not
     specify what should happen when you mix the ‘g’ and NUMBER
     modifiers, and currently there is no widely agreed upon meaning
     across ‘sed’ implementations.  For GNU ‘sed’, the interaction is
     defined to be: ignore matches before the NUMBERth, and then match
     and replace all matches from the NUMBERth on.

‘p’
     If the substitution was made, then print the new pattern space.

     Note: when both the ‘p’ and ‘e’ options are specified, the relative
     ordering of the two produces very different results.  In general,
     ‘ep’ (evaluate then print) is what you want, but operating the
     other way round can be useful for debugging.  For this reason, the
     current version of GNU ‘sed’ interprets specially the presence of
     ‘p’ options both before and after ‘e’, printing the pattern space
     before and after evaluation, while in general flags for the ‘s’
     command show their effect just once.  This behavior, although
     documented, might change in future versions.

‘w FILENAME’
     If the substitution was made, then write out the result to the
     named file.  As a GNU ‘sed’ extension, two special values of
     FILENAME are supported: ‘/dev/stderr’, which writes the result to
     the standard error, and ‘/dev/stdout’, which writes to the standard
     output.(1)

‘e’
     This command allows one to pipe input from a shell command into
     pattern space.  If a substitution was made, the command that is
     found in pattern space is executed and pattern space is replaced
     with its output.  A trailing newline is suppressed; results are
     undefined if the command to be executed contains a NUL character.
     This is a GNU ‘sed’ extension.

‘I’
‘i’
     The ‘I’ modifier to regular-expression matching is a GNU extension
     which makes ‘sed’ match REGEXP in a case-insensitive manner.

‘M’
‘m’
     The ‘M’ modifier to regular-expression matching is a GNU ‘sed’
     extension which directs GNU ‘sed’ to match the regular expression
     in ‘multi-line’ mode.  The modifier causes ‘^’ and ‘$’ to match
     respectively (in addition to the normal behavior) the empty string
     after a newline, and the empty string before a newline.  There are
     special character sequences (‘\`’ and ‘\'’) which always match the
     beginning or the end of the buffer.  In addition, the period
     character does not match a new-line character in multi-line mode.

   ---------- Footnotes ----------

   (1) This is equivalent to ‘p’ unless the ‘-i’ option is being used.


File: sed.info,  Node: Common Commands,  Next: Other Commands,  Prev: The "s" Command,  Up: sed scripts

3.4 Often-Used Commands
=======================

If you use ‘sed’ at all, you will quite likely want to know these
commands.

‘#’
     [No addresses allowed.]

     The ‘#’ character begins a comment; the comment continues until the
     next newline.

     If you are concerned about portability, be aware that some
     implementations of ‘sed’ (which are not POSIX conforming) may only
     support a single one-line comment, and then only when the very
     first character of the script is a ‘#’.

     Warning: if the first two characters of the ‘sed’ script are ‘#n’,
     then the ‘-n’ (no-autoprint) option is forced.  If you want to put
     a comment in the first line of your script and that comment begins
     with the letter ‘n’ and you do not want this behavior, then be sure
     to either use a capital ‘N’, or place at least one space before the
     ‘n’.

‘q [EXIT-CODE]’
     Exit ‘sed’ without processing any more commands or input.

     Example: stop after printing the second line:
          $ seq 3 | sed 2q
          1
          2

     This command accepts only one address.  Note that the current
     pattern space is printed if auto-print is not disabled with the
     ‘-n’ options.  The ability to return an exit code from the ‘sed’
     script is a GNU ‘sed’ extension.

     See also the GNU ‘sed’ extension ‘Q’ command which quits silently
     without printing the current pattern space.

‘d’
     Delete the pattern space; immediately start next cycle.

     Example: delete the second input line:
          $ seq 3 | sed 2d
          1
          3

‘p’
     Print out the pattern space (to the standard output).  This command
     is usually only used in conjunction with the ‘-n’ command-line
     option.

     Example: print only the second input line:
          $ seq 3 | sed -n 2p
          2

‘n’
     If auto-print is not disabled, print the pattern space, then,
     regardless, replace the pattern space with the next line of input.
     If there is no more input then ‘sed’ exits without processing any
     more commands.

     This command is useful to skip lines (e.g.  process every Nth
     line).

     Example: perform substitution on every 3rd line (i.e.  two ‘n’
     commands skip two lines):
          $ seq 6 | sed 'n;n;s/./x/'
          1
          2
          x
          4
          5
          x

     GNU ‘sed’ provides an extension address syntax of FIRST~STEP to
     achieve the same result:

          $ seq 6 | sed '0~3s/./x/'
          1
          2
          x
          4
          5
          x

‘{ COMMANDS }’
     A group of commands may be enclosed between ‘{’ and ‘}’ characters.
     This is particularly useful when you want a group of commands to be
     triggered by a single address (or address-range) match.

     Example: perform substitution then print the second input line:
          $ seq 3 | sed -n '2{s/2/X/ ; p}'
          X


File: sed.info,  Node: Other Commands,  Next: Programming Commands,  Prev: Common Commands,  Up: sed scripts

3.5 Less Frequently-Used Commands
=================================

Though perhaps less frequently used than those in the previous section,
some very small yet useful ‘sed’ scripts can be built with these
commands.

‘y/SOURCE-CHARS/DEST-CHARS/’
     Transliterate any characters in the pattern space which match any
     of the SOURCE-CHARS with the corresponding character in DEST-CHARS.

     Example: transliterate ‘a-j’ into ‘0-9’:
          $ echo hello world | sed 'y/abcdefghij/0123456789/'
          74llo worl3

     (The ‘/’ characters may be uniformly replaced by any other single
     character within any given ‘y’ command.)

     Instances of the ‘/’ (or whatever other character is used in its
     stead), ‘\’, or newlines can appear in the SOURCE-CHARS or
     DEST-CHARS lists, provide that each instance is escaped by a ‘\’.
     The SOURCE-CHARS and DEST-CHARS lists _must_ contain the same
     number of characters (after de-escaping).

     See the ‘tr’ command from GNU coreutils for similar functionality.

‘a TEXT’
     Appending TEXT after a line.  This is a GNU extension to the
     standard ‘a’ command - see below for details.

     Example: Add ‘hello’ after the second line:
          $ seq 3 | sed '2a hello'
          1
          2
          hello
          3

     Leading whitespace after the ‘a’ command is ignored.  The text to
     add is read until the end of the line.

‘a\’
‘TEXT’
     Appending TEXT after a line.

     Example: Add ‘hello’ after the second line (⊣ indicates printed
     output lines):
          $ seq 3 | sed '2a\
          hello'
          ⊣1
          ⊣2
          ⊣hello
          ⊣3

     The ‘a’ command queues the lines of text which follow this command
     (each but the last ending with a ‘\’, which are removed from the
     output) to be output at the end of the current cycle, or when the
     next input line is read.

     As a GNU extension, this command accepts two addresses.

     Escape sequences in TEXT are processed, so you should use ‘\\’ in
     TEXT to print a single backslash.

     The commands resume after the last line without a backslash (‘\’) -
     ‘world’ in the following example:
          $ seq 3 | sed '2a\
          hello\
          world
          3s/./X/'
          ⊣1
          ⊣2
          ⊣hello
          ⊣world
          ⊣X

     As a GNU extension, the ‘a’ command and TEXT can be separated into
     two ‘-e’ parameters, enabling easier scripting:
          $ seq 3 | sed -e '2a\' -e hello
          1
          2
          hello
          3

          $ sed -e '2a\' -e "$VAR"

‘i TEXT’
     insert TEXT before a line.  This is a GNU extension to the standard
     ‘i’ command - see below for details.

     Example: Insert ‘hello’ before the second line:
          $ seq 3 | sed '2i hello'
          1
          hello
          2
          3

     Leading whitespace after the ‘i’ command is ignored.  The text to
     add is read until the end of the line.

‘i\’
‘TEXT’
     Immediately output the lines of text which follow this command.

     Example: Insert ‘hello’ before the second line (⊣ indicates printed
     output lines):
          $ seq 3 | sed '2i\
          hello'
          ⊣1
          ⊣hello
          ⊣2
          ⊣3

     As a GNU extension, this command accepts two addresses.

     Escape sequences in TEXT are processed, so you should use ‘\\’ in
     TEXT to print a single backslash.

     The commands resume after the last line without a backslash (‘\’) -
     ‘world’ in the following example:
          $ seq 3 | sed '2i\
          hello\
          world
          s/./X/'
          ⊣X
          ⊣hello
          ⊣world
          ⊣X
          ⊣X

     As a GNU extension, the ‘i’ command and TEXT can be separated into
     two ‘-e’ parameters, enabling easier scripting:
          $ seq 3 | sed -e '2i\' -e hello
          1
          hello
          2
          3

          $ sed -e '2i\' -e "$VAR"

‘c TEXT’
     Replaces the line(s) with TEXT.  This is a GNU extension to the
     standard ‘c’ command - see below for details.

     Example: Replace the 2nd to 9th lines with the word ‘hello’:
          $ seq 10 | sed '2,9c hello'
          1
          hello
          10

     Leading whitespace after the ‘c’ command is ignored.  The text to
     add is read until the end of the line.

‘c\’
‘TEXT’
     Delete the lines matching the address or address-range, and output
     the lines of text which follow this command.

     Example: Replace 2nd to 4th lines with the words ‘hello’ and
     ‘world’ (⊣ indicates printed output lines):
          $ seq 5 | sed '2,4c\
          hello\
          world'
          ⊣1
          ⊣hello
          ⊣world
          ⊣5

     If no addresses are given, each line is replaced.

     A new cycle is started after this command is done, since the
     pattern space will have been deleted.  In the following example,
     the ‘c’ starts a new cycle and the substitution command is not
     performed on the replaced text:

          $ seq 3 | sed '2c\
          hello
          s/./X/'
          ⊣X
          ⊣hello
          ⊣X

     As a GNU extension, the ‘c’ command and TEXT can be separated into
     two ‘-e’ parameters, enabling easier scripting:
          $ seq 3 | sed -e '2c\' -e hello
          1
          hello
          3

          $ sed -e '2c\' -e "$VAR"

‘=’
     Print out the current input line number (with a trailing newline).

          $ printf '%s\n' aaa bbb ccc | sed =
          1
          aaa
          2
          bbb
          3
          ccc

     As a GNU extension, this command accepts two addresses.

‘l N’
     Print the pattern space in an unambiguous form: non-printable
     characters (and the ‘\’ character) are printed in C-style escaped
     form; long lines are split, with a trailing ‘\’ character to
     indicate the split; the end of each line is marked with a ‘$’.

     N specifies the desired line-wrap length; a length of 0 (zero)
     means to never wrap long lines.  If omitted, the default as
     specified on the command line is used.  The N parameter is a GNU
     ‘sed’ extension.

‘r FILENAME’

     Reads file FILENAME.  Example:

          $ seq 3 | sed '2r/etc/hostname'
          1
          2
          fencepost.gnu.org
          3

     Queue the contents of FILENAME to be read and inserted into the
     output stream at the end of the current cycle, or when the next
     input line is read.  Note that if FILENAME cannot be read, it is
     treated as if it were an empty file, without any error indication.

     As a GNU ‘sed’ extension, the special value ‘/dev/stdin’ is
     supported for the file name, which reads the contents of the
     standard input.

     As a GNU extension, this command accepts two addresses.  The file
     will then be reread and inserted on each of the addressed lines.

     As a GNU ‘sed’ extension, the ‘r’ command accepts a zero address,
     inserting a file _before_ the first line of the input *note Adding
     a header to multiple files::.

‘w FILENAME’
     Write the pattern space to FILENAME.  As a GNU ‘sed’ extension, two
     special values of FILENAME are supported: ‘/dev/stderr’, which
     writes the result to the standard error, and ‘/dev/stdout’, which
     writes to the standard output.(1)

     The file will be created (or truncated) before the first input line
     is read; all ‘w’ commands (including instances of the ‘w’ flag on
     successful ‘s’ commands) which refer to the same FILENAME are
     output without closing and reopening the file.

‘D’
     If pattern space contains no newline, start a normal new cycle as
     if the ‘d’ command was issued.  Otherwise, delete text in the
     pattern space up to the first newline, and restart cycle with the
     resultant pattern space, without reading a new line of input.

‘N’
     Add a newline to the pattern space, then append the next line of
     input to the pattern space.  If there is no more input then ‘sed’
     exits without processing any more commands.

     When ‘-z’ is used, a zero byte (the ascii ‘NUL’ character) is added
     between the lines (instead of a new line).

     By default ‘sed’ does not terminate if there is no ’next’ input
     line.  This is a GNU extension which can be disabled with
     ‘--posix’.  *Note N command on the last line: N_command_last_line.

‘P’
     Print out the portion of the pattern space up to the first newline.

‘h’
     Replace the contents of the hold space with the contents of the
     pattern space.

‘H’
     Append a newline to the contents of the hold space, and then append
     the contents of the pattern space to that of the hold space.

‘g’
     Replace the contents of the pattern space with the contents of the
     hold space.

‘G’
     Append a newline to the contents of the pattern space, and then
     append the contents of the hold space to that of the pattern space.

‘x’
     Exchange the contents of the hold and pattern spaces.

   ---------- Footnotes ----------

   (1) This is equivalent to ‘p’ unless the ‘-i’ option is being used.


File: sed.info,  Node: Programming Commands,  Next: Extended Commands,  Prev: Other Commands,  Up: sed scripts

3.6 Commands for ‘sed’ gurus
============================

In most cases, use of these commands indicates that you are probably
better off programming in something like ‘awk’ or Perl.  But
occasionally one is committed to sticking with ‘sed’, and these commands
can enable one to write quite convoluted scripts.

‘: LABEL’
     [No addresses allowed.]

     Specify the location of LABEL for branch commands.  In all other
     respects, a no-op.

‘b LABEL’
     Unconditionally branch to LABEL.  The LABEL may be omitted, in
     which case the next cycle is started.

‘t LABEL’
     Branch to LABEL only if there has been a successful ‘s’ubstitution
     since the last input line was read or conditional branch was taken.
     The LABEL may be omitted, in which case the next cycle is started.


File: sed.info,  Node: Extended Commands,  Next: Multiple commands syntax,  Prev: Programming Commands,  Up: sed scripts

3.7 Commands Specific to GNU ‘sed’
==================================

These commands are specific to GNU ‘sed’, so you must use them with care
and only when you are sure that hindering portability is not evil.  They
allow you to check for GNU ‘sed’ extensions or to do tasks that are
required quite often, yet are unsupported by standard ‘sed’s.

‘e [COMMAND]’
     This command allows one to pipe input from a shell command into
     pattern space.  Without parameters, the ‘e’ command executes the
     command that is found in pattern space and replaces the pattern
     space with the output; a trailing newline is suppressed.

     If a parameter is specified, instead, the ‘e’ command interprets it
     as a command and sends its output to the output stream.  The
     command can run across multiple lines, all but the last ending with
     a back-slash.

     In both cases, the results are undefined if the command to be
     executed contains a NUL character.

     Note that, unlike the ‘r’ command, the output of the command will
     be printed immediately; the ‘r’ command instead delays the output
     to the end of the current cycle.

‘F’
     Print out the file name of the current input file (with a trailing
     newline).

‘Q [EXIT-CODE]’
     This command accepts only one address.

     This command is the same as ‘q’, but will not print the contents of
     pattern space.  Like ‘q’, it provides the ability to return an exit
     code to the caller.

     This command can be useful because the only alternative ways to
     accomplish this apparently trivial function are to use the ‘-n’
     option (which can unnecessarily complicate your script) or
     resorting to the following snippet, which wastes time by reading
     the whole file without any visible effect:

          :eat
          $d       Quit silently on the last line
          N        Read another line, silently
          g        Overwrite pattern space each time to save memory
          b eat

‘R FILENAME’
     Queue a line of FILENAME to be read and inserted into the output
     stream at the end of the current cycle, or when the next input line
     is read.  Note that if FILENAME cannot be read, or if its end is
     reached, no line is appended, without any error indication.

     As with the ‘r’ command, the special value ‘/dev/stdin’ is
     supported for the file name, which reads a line from the standard
     input.

‘T LABEL’
     Branch to LABEL only if there have been no successful
     ‘s’ubstitutions since the last input line was read or conditional
     branch was taken.  The LABEL may be omitted, in which case the next
     cycle is started.

‘v VERSION’
     This command does nothing, but makes ‘sed’ fail if GNU ‘sed’
     extensions are not supported, simply because other versions of
     ‘sed’ do not implement it.  In addition, you can specify the
     version of ‘sed’ that your script requires, such as ‘4.0.5’.  The
     default is ‘4.0’ because that is the first version that implemented
     this command.

     This command enables all GNU extensions even if ‘POSIXLY_CORRECT’
     is set in the environment.

‘W FILENAME’
     Write to the given filename the portion of the pattern space up to
     the first newline.  Everything said under the ‘w’ command about
     file handling holds here too.

‘z’
     This command empties the content of pattern space.  It is usually
     the same as ‘s/.*//’, but is more efficient and works in the
     presence of invalid multibyte sequences in the input stream.  POSIX
     mandates that such sequences are _not_ matched by ‘.’, so that
     there is no portable way to clear ‘sed’’s buffers in the middle of
     the script in most multibyte locales (including UTF-8 locales).


File: sed.info,  Node: Multiple commands syntax,  Prev: Extended Commands,  Up: sed scripts

3.8 Multiple commands syntax
============================

There are several methods to specify multiple commands in a ‘sed’
program.

   Using newlines is most natural when running a sed script from a file
(using the ‘-f’ option).

   On the command line, all ‘sed’ commands may be separated by newlines.
Alternatively, you may specify each command as an argument to an ‘-e’
option:

     $ seq 6 | sed '1d
     3d
     5d'
     2
     4
     6

     $ seq 6 | sed -e 1d -e 3d -e 5d
     2
     4
     6

   A semicolon (‘;’) may be used to separate most simple commands:

     $ seq 6 | sed '1d;3d;5d'
     2
     4
     6

   The ‘{’,‘}’,‘b’,‘t’,‘T’,‘:’ commands can be separated with a
semicolon (this is a non-portable GNU ‘sed’ extension).

     $ seq 4 | sed '{1d;3d}'
     2
     4

     $ seq 6 | sed '{1d;3d};5d'
     2
     4
     6

   Labels used in ‘b’,‘t’,‘T’,‘:’ commands are read until a semicolon.
Leading and trailing whitespace is ignored.  In the examples below the
label is ‘x’.  The first example works with GNU ‘sed’.  The second is a
portable equivalent.  For more information about branching and labels
*note Branching and flow control::.

     $ seq 3 | sed '/1/b x ; s/^/=/ ; :x ; 3d'
     1
     =2

     $ seq 3 | sed -e '/1/bx' -e 's/^/=/' -e ':x' -e '3d'
     1
     =2

3.8.1 Commands Requiring a newline
----------------------------------

The following commands cannot be separated by a semicolon and require a
newline:

‘a’,‘c’,‘i’ (append/change/insert)

     All characters following ‘a’,‘c’,‘i’ commands are taken as the text
     to append/change/insert.  Using a semicolon leads to undesirable
     results:

          $ seq 2 | sed '1aHello ; 2d'
          1
          Hello ; 2d
          2

     Separate the commands using ‘-e’ or a newline:

          $ seq 2 | sed -e 1aHello -e 2d
          1
          Hello

          $ seq 2 | sed '1aHello
          2d'
          1
          Hello

     Note that specifying the text to add (‘Hello’) immediately after
     ‘a’,‘c’,‘i’ is itself a GNU ‘sed’ extension.  A portable,
     POSIX-compliant alternative is:

          $ seq 2 | sed '1a\
          Hello
          2d'
          1
          Hello

‘#’ (comment)

     All characters following ‘#’ until the next newline are ignored.

          $ seq 3 | sed '# this is a comment ; 2d'
          1
          2
          3


          $ seq 3 | sed '# this is a comment
          2d'
          1
          3

‘r’,‘R’,‘w’,‘W’ (reading and writing files)

     The ‘r’,‘R’,‘w’,‘W’ commands parse the filename until end of the
     line.  If whitespace, comments or semicolons are found, they will
     be included in the filename, leading to unexpected results:

          $ seq 2 | sed '1w hello.txt ; 2d'
          1
          2

          $ ls -log
          total 4
          -rw-rw-r-- 1 2 Jan 23 23:03 hello.txt ; 2d

          $ cat 'hello.txt ; 2d'
          1

     Note that ‘sed’ silently ignores read/write errors in
     ‘r’,‘R’,‘w’,‘W’ commands (such as missing files).  In the following
     example, ‘sed’ tries to read a file named ‘‘hello.txt ; N’’.  The
     file is missing, and the error is silently ignored:

          $ echo x | sed '1rhello.txt ; N'
          x

‘e’ (command execution)

     Any characters following the ‘e’ command until the end of the line
     will be sent to the shell.  If whitespace, comments or semicolons
     are found, they will be included in the shell command, leading to
     unexpected results:

          $ echo a | sed '1e touch foo#bar'
          a

          $ ls -1
          foo#bar

          $ echo a | sed '1e touch foo ; s/a/b/'
          sh: 1: s/a/b/: not found
          a

‘s///[we]’ (substitute with ‘e’ or ‘w’ flags)

     In a substitution command, the ‘w’ flag writes the substitution
     result to a file, and the ‘e’ flag executes the substitution result
     as a shell command.  As with the ‘r/R/w/W/e’ commands, these must
     be terminated with a newline.  If whitespace, comments or
     semicolons are found, they will be included in the shell command or
     filename, leading to unexpected results:

          $ echo a | sed 's/a/b/w1.txt#foo'
          b

          $ ls -1
          1.txt#foo


File: sed.info,  Node: sed addresses,  Next: sed regular expressions,  Prev: sed scripts,  Up: Top

4 Addresses: selecting lines
****************************

* Menu:

* Addresses overview::                Addresses overview
* Numeric Addresses::                 selecting lines by numbers
* Regexp Addresses::                  selecting lines by text matching
* Range Addresses::                   selecting a range of lines
* Zero Address::                      Using address ‘0’


File: sed.info,  Node: Addresses overview,  Next: Numeric Addresses,  Up: sed addresses

4.1 Addresses overview
======================

Addresses determine on which line(s) the ‘sed’ command will be executed.
The following command replaces any first occurrence of ‘hello’ with
‘world’ only on line 144:

     sed '144s/hello/world/' input.txt > output.txt

   If no address is specified, the command is performed on all lines.
The following command replaces ‘hello’ with ‘world’, targeting every
line of the input file.  However, note that it modifies only the first
instance of ‘hello’ on each line.  Use the ‘g’ modifier to affect every
instance on each affected line.

     sed 's/hello/world/' input.txt > output.txt

   Addresses can contain regular expressions to match lines based on
content instead of line numbers.  The following command replaces ‘hello’
with ‘world’ only on lines containing the string ‘apple’:

     sed '/apple/s/hello/world/' input.txt > output.txt

   An address range is specified with two addresses separated by a comma
(‘,’).  Addresses can be numeric, regular expressions, or a mix of both.
The following command replaces ‘hello’ with ‘world’ only on lines 4 to
17 (inclusive):

     sed '4,17s/hello/world/' input.txt > output.txt

   Appending the ‘!’ character to the end of an address specification
(before the command letter) negates the sense of the match.  That is, if
the ‘!’ character follows an address or an address range, then only
lines which do _not_ match the addresses will be selected.  The
following command replaces ‘hello’ with ‘world’ only on lines _not_
containing the string ‘apple’:

     sed '/apple/!s/hello/world/' input.txt > output.txt

   The following command replaces ‘hello’ with ‘world’ only on lines 1
to 3 and from line 18 to the last line of the input file (i.e.
excluding lines 4 to 17):

     sed '4,17!s/hello/world/' input.txt > output.txt


File: sed.info,  Node: Numeric Addresses,  Next: Regexp Addresses,  Prev: Addresses overview,  Up: sed addresses

4.2 Selecting lines by numbers
==============================

Addresses in a ‘sed’ script can be in any of the following forms:
‘NUMBER’
     Specifying a line number will match only that line in the input.
     (Note that ‘sed’ counts lines continuously across all input files
     unless ‘-i’ or ‘-s’ options are specified.)

‘$’
     This address matches the last line of the last file of input, or
     the last line of each file when the ‘-i’ or ‘-s’ options are
     specified.

‘FIRST~STEP’
     This GNU extension matches every STEPth line starting with line
     FIRST.  In particular, lines will be selected when there exists a
     non-negative N such that the current line-number equals FIRST + (N
     * STEP).  Thus, one would use ‘1~2’ to select the odd-numbered
     lines and ‘0~2’ for even-numbered lines; to pick every third line
     starting with the second, ‘2~3’ would be used; to pick every fifth
     line starting with the tenth, use ‘10~5’; and ‘50~0’ is just an
     obscure way of saying ‘50’.

     The following commands demonstrate the step address usage:

          $ seq 10 | sed -n '0~4p'
          4
          8

          $ seq 10 | sed -n '1~3p'
          1
          4
          7
          10


File: sed.info,  Node: Regexp Addresses,  Next: Range Addresses,  Prev: Numeric Addresses,  Up: sed addresses

4.3 selecting lines by text matching
====================================

GNU ‘sed’ supports the following regular expression addresses.  The
default regular expression is *note Basic Regular Expression (BRE): BRE
syntax.  If ‘-E’ or ‘-r’ options are used, The regular expression should
be in *note Extended Regular Expression (ERE): ERE syntax. syntax.
*Note BRE vs ERE::.

‘/REGEXP/’
     This will select any line which matches the regular expression
     REGEXP.  If REGEXP itself includes any ‘/’ characters, each must be
     escaped by a backslash (‘\’).

     The following command prints lines in ‘/etc/passwd’ which end with
     ‘bash’(1):

          sed -n '/bash$/p' /etc/passwd

     The empty regular expression ‘//’ repeats the last regular
     expression match (the same holds if the empty regular expression is
     passed to the ‘s’ command).  Note that modifiers to regular
     expressions are evaluated when the regular expression is compiled,
     thus it is invalid to specify them together with the empty regular
     expression.

‘\%REGEXP%’
     (The ‘%’ may be replaced by any other single character.)

     This also matches the regular expression REGEXP, but allows one to
     use a different delimiter than ‘/’.  This is particularly useful if
     the REGEXP itself contains a lot of slashes, since it avoids the
     tedious escaping of every ‘/’.  If REGEXP itself includes any
     delimiter characters, each must be escaped by a backslash (‘\’).

     The following commands are equivalent.  They print lines which
     start with ‘/home/alice/documents/’:

          sed -n '/^\/home\/alice\/documents\//p'
          sed -n '\%^/home/alice/documents/%p'
          sed -n '\;^/home/alice/documents/;p'

‘/REGEXP/I’
‘\%REGEXP%I’
     The ‘I’ modifier to regular-expression matching is a GNU extension
     which causes the REGEXP to be matched in a case-insensitive manner.

     In many other programming languages, a lower case ‘i’ is used for
     case-insensitive regular expression matching.  However, in ‘sed’
     the ‘i’ is used for the insert command (*note insert command::).

     Observe the difference between the following examples.

     In this example, ‘/b/I’ is the address: regular expression with ‘I’
     modifier.  ‘d’ is the delete command:

          $ printf "%s\n" a b c | sed '/b/Id'
          a
          c

     Here, ‘/b/’ is the address: a regular expression.  ‘i’ is the
     insert command.  ‘d’ is the value to insert.  A line with ‘d’ is
     then inserted above the matched line:

          $ printf "%s\n" a b c | sed '/b/id'
          a
          d
          b
          c

‘/REGEXP/M’
‘\%REGEXP%M’
     The ‘M’ modifier to regular-expression matching is a GNU ‘sed’
     extension which directs GNU ‘sed’ to match the regular expression
     in ‘multi-line’ mode.  The modifier causes ‘^’ and ‘$’ to match
     respectively (in addition to the normal behavior) the empty string
     after a newline, and the empty string before a newline.  There are
     special character sequences (‘\`’ and ‘\'’) which always match the
     beginning or the end of the buffer.  In addition, the period
     character does not match a new-line character in multi-line mode.

   Regex addresses operate on the content of the current pattern space.
If the pattern space is changed (for example with ‘s///’ command) the
regular expression matching will operate on the changed text.

   In the following example, automatic printing is disabled with ‘-n’.
The ‘s/2/X/’ command changes lines containing ‘2’ to ‘X’.  The command
‘/[0-9]/p’ matches lines with digits and prints them.  Because the
second line is changed before the ‘/[0-9]/’ regex, it will not match and
will not be printed:

     $ seq 3 | sed -n 's/2/X/ ; /[0-9]/p'
     1
     3

   ---------- Footnotes ----------

   (1) There are of course many other ways to do the same, e.g.
     grep 'bash$' /etc/passwd
     awk -F: '$7 == "/bin/bash"' /etc/passwd


File: sed.info,  Node: Range Addresses,  Next: Zero Address,  Prev: Regexp Addresses,  Up: sed addresses

4.4 Range Addresses
===================

An address range can be specified by specifying two addresses separated
by a comma (‘,’).  An address range matches lines starting from where
the first address matches, and continues until the second address
matches (inclusively):

     $ seq 10 | sed -n '4,6p'
     4
     5
     6

   If the second address is a REGEXP, then checking for the ending match
will start with the line _following_ the line which matched the first
address: a range will always span at least two lines (except of course
if the input stream ends).

     $ seq 10 | sed -n '4,/[0-9]/p'
     4
     5

   If the second address is a NUMBER less than (or equal to) the line
matching the first address, then only the one line is matched:

     $ seq 10 | sed -n '4,1p'
     4

   GNU ‘sed’ also supports some special two-address forms; all these are
GNU extensions:
‘0,/REGEXP/’
     A line number of ‘0’ can be used in an address specification like
     ‘0,/REGEXP/’ so that ‘sed’ will try to match REGEXP in the first
     input line too.  In other words, ‘0,/REGEXP/’ is similar to
     ‘1,/REGEXP/’, except that if ADDR2 matches the very first line of
     input the ‘0,/REGEXP/’ form will consider it to end the range,
     whereas the ‘1,/REGEXP/’ form will match the beginning of its range
     and hence make the range span up to the _second_ occurrence of the
     regular expression.

     The following examples demonstrate the difference between starting
     with address 1 and 0:

          $ seq 10 | sed -n '1,/[0-9]/p'
          1
          2

          $ seq 10 | sed -n '0,/[0-9]/p'
          1

‘ADDR1,+N’
     Matches ADDR1 and the N lines following ADDR1.

          $ seq 10 | sed -n '6,+2p'
          6
          7
          8

     ADDR1 can be a line number or a regular expression.

‘ADDR1,~N’
     Matches ADDR1 and the lines following ADDR1 until the next line
     whose input line number is a multiple of N.  The following command
     prints starting at line 6, until the next line which is a multiple
     of 4 (i.e.  line 8):

          $ seq 10 | sed -n '6,~4p'
          6
          7
          8

     ADDR1 can be a line number or a regular expression.


File: sed.info,  Node: Zero Address,  Prev: Range Addresses,  Up: sed addresses

4.5 Zero Address
================

As a GNU ‘sed’ extension, ‘0’ address can be used in two cases:
  1. In a regex range addresses as ‘0,/REGEXP/’ (*note Zero Address
     Regex Range::).
  2. With the ‘r’ command, inserting a file before the first line (*note
     Adding a header to multiple files::).

   Note that these are the only places where the ‘0’ address makes
sense; Commands which are given the ‘0’ address in any other way will
give an error.


File: sed.info,  Node: sed regular expressions,  Next: advanced sed,  Prev: sed addresses,  Up: Top

5 Regular Expressions: selecting text
*************************************

* Menu:

* Regular Expressions Overview:: Overview of Regular expression in ‘sed’
* BRE vs ERE::               Basic (BRE) and extended (ERE) regular expression
                             syntax
* BRE syntax::               Overview of basic regular expression syntax
* ERE syntax::               Overview of extended regular expression syntax
* Character Classes and Bracket Expressions::
* regexp extensions::        Additional regular expression commands
* Back-references and Subexpressions:: Back-references and Subexpressions
* Escapes::                  Specifying special characters
* Locale Considerations::    Multibyte characters and locale considerations


File: sed.info,  Node: Regular Expressions Overview,  Next: BRE vs ERE,  Up: sed regular expressions

5.1 Overview of regular expression in ‘sed’
===========================================

To know how to use ‘sed’, people should understand regular expressions
(“regexp” for short).  A regular expression is a pattern that is matched
against a subject string from left to right.  Most characters are
“ordinary”: they stand for themselves in a pattern, and match the
corresponding characters.  Regular expressions in ‘sed’ are specified
between two slashes.

   The following command prints lines containing the string ‘hello’:

     sed -n '/hello/p'

   The above example is equivalent to this ‘grep’ command:

     grep 'hello'

   The power of regular expressions comes from the ability to include
alternatives and repetitions in the pattern.  These are encoded in the
pattern by the use of “special characters”, which do not stand for
themselves but instead are interpreted in some special way.

   The character ‘^’ (caret) in a regular expression matches the
beginning of the line.  The character ‘.’ (dot) matches any single
character.  The following ‘sed’ command matches and prints lines which
start with the letter ‘b’, followed by any single character, followed by
the letter ‘d’:

     $ printf "%s\n" abode bad bed bit bid byte body | sed -n '/^b.d/p'
     bad
     bed
     bid
     body

   The following sections explain the meaning and usage of special
characters in regular expressions.


File: sed.info,  Node: BRE vs ERE,  Next: BRE syntax,  Prev: Regular Expressions Overview,  Up: sed regular expressions

5.2 Basic (BRE) and extended (ERE) regular expression
=====================================================

Basic and extended regular expressions are two variations on the syntax
of the specified pattern.  Basic Regular Expression (BRE) syntax is the
default in ‘sed’ (and similarly in ‘grep’).  Use the POSIX-specified
‘-E’ option (‘-r’, ‘--regexp-extended’) to enable Extended Regular
Expression (ERE) syntax.

   In GNU ‘sed’, the only difference between basic and extended regular
expressions is in the behavior of a few special characters: ‘?’, ‘+’,
parentheses, braces (‘{}’), and ‘|’.

   With basic (BRE) syntax, these characters do not have special meaning
unless prefixed with a backslash (‘\’); While with extended (ERE) syntax
it is reversed: these characters are special unless they are prefixed
with backslash (‘\’).

Desired pattern      Basic (BRE) Syntax         Extended (ERE) Syntax
                                                
--------------------------------------------------------------------------
literal ‘+’ (plus         $ echo 'a+b=c' > foo       $ echo 'a+b=c' > foo
sign)                     $ sed -n '/a+b/p' foo      $ sed -E -n '/a\+b/p' foo
                          a+b=c                      a+b=c
                                                
One or more ‘a’           $ echo aab > foo           $ echo aab > foo
characters                $ sed -n '/a\+b/p' foo     $ sed -E -n '/a+b/p' foo
followed by ‘b’           aab                        aab
(plus sign as                                   
special
meta-character)


File: sed.info,  Node: BRE syntax,  Next: ERE syntax,  Prev: BRE vs ERE,  Up: sed regular expressions

5.3 Overview of basic regular expression syntax
===============================================

Here is a brief description of regular expression syntax as used in
‘sed’.

‘CHAR’
     A single ordinary character matches itself.

‘*’
     Matches a sequence of zero or more instances of matches for the
     preceding regular expression, which must be an ordinary character,
     a special character preceded by ‘\’, a ‘.’, a grouped regexp (see
     below), or a bracket expression.  As a GNU extension, a postfixed
     regular expression can also be followed by ‘*’; for example, ‘a**’
     is equivalent to ‘a*’.  POSIX 1003.1-2001 says that ‘*’ stands for
     itself when it appears at the start of a regular expression or
     subexpression, but many non-GNU implementations do not support this
     and portable scripts should instead use ‘\*’ in these contexts.
‘.’
     Matches any character, including newline.

‘^’
     Matches the null string at beginning of the pattern space, i.e.
     what appears after the circumflex must appear at the beginning of
     the pattern space.

     In most scripts, pattern space is initialized to the content of
     each line (*note How ‘sed’ works: Execution Cycle.).  So, it is a
     useful simplification to think of ‘^#include’ as matching only
     lines where ‘#include’ is the first thing on the line—if there is
     any preceding space, for example, the match fails.  This
     simplification is valid as long as the original content of pattern
     space is not modified, for example with an ‘s’ command.

     ‘^’ acts as a special character only at the beginning of the
     regular expression or subexpression (that is, after ‘\(’ or ‘\|’).
     Portable scripts should avoid ‘^’ at the beginning of a
     subexpression, though, as POSIX allows implementations that treat
     ‘^’ as an ordinary character in that context.

‘$’
     It is the same as ‘^’, but refers to end of pattern space.  ‘$’
     also acts as a special character only at the end of the regular
     expression or subexpression (that is, before ‘\)’ or ‘\|’), and its
     use at the end of a subexpression is not portable.

‘[LIST]’
‘[^LIST]’
     Matches any single character in LIST: for example, ‘[aeiou]’
     matches all vowels.  A list may include sequences like
     ‘CHAR1-CHAR2’, which matches any character between (inclusive)
     CHAR1 and CHAR2.  *Note Character Classes and Bracket
     Expressions::.

‘\+’
     As ‘*’, but matches one or more.  It is a GNU extension.

‘\?’
     As ‘*’, but only matches zero or one.  It is a GNU extension.

‘\{I\}’
     As ‘*’, but matches exactly I sequences (I is a decimal integer;
     for portability, keep it between 0 and 255 inclusive).

‘\{I,J\}’
     Matches between I and J, inclusive, sequences.

‘\{I,\}’
     Matches more than or equal to I sequences.

‘\(REGEXP\)’
     Groups the inner REGEXP as a whole, this is used to:

        • Apply postfix operators, like ‘\(abcd\)*’: this will search
          for zero or more whole sequences of ‘abcd’, while ‘abcd*’
          would search for ‘abc’ followed by zero or more occurrences of
          ‘d’.  Note that support for ‘\(abcd\)*’ is required by POSIX
          1003.1-2001, but many non-GNU implementations do not support
          it and hence it is not universally portable.

        • Use back references (see below).

‘REGEXP1\|REGEXP2’
     Matches either REGEXP1 or REGEXP2.  Use parentheses to use complex
     alternative regular expressions.  The matching process tries each
     alternative in turn, from left to right, and the first one that
     succeeds is used.  It is a GNU extension.

‘REGEXP1REGEXP2’
     Matches the concatenation of REGEXP1 and REGEXP2.  Concatenation
     binds more tightly than ‘\|’, ‘^’, and ‘$’, but less tightly than
     the other regular expression operators.

‘\DIGIT’
     Matches the DIGIT-th ‘\(...\)’ parenthesized subexpression in the
     regular expression.  This is called a “back reference”.
     Subexpressions are implicitly numbered by counting occurrences of
     ‘\(’ left-to-right.

‘\n’
     Matches the newline character.

‘\CHAR’
     Matches CHAR, where CHAR is one of ‘$’, ‘*’, ‘.’, ‘[’, ‘\’, or ‘^’.
     Note that the only C-like backslash sequences that you can portably
     assume to be interpreted are ‘\n’ and ‘\\’; in particular ‘\t’ is
     not portable, and matches a ‘t’ under most implementations of
     ‘sed’, rather than a tab character.

   Note that the regular expression matcher is greedy, i.e., matches are
attempted from left to right and, if two or more matches are possible
starting at the same character, it selects the longest.

Examples:
‘abcdef’
     Matches ‘abcdef’.

‘a*b’
     Matches zero or more ‘a’s followed by a single ‘b’.  For example,
     ‘b’ or ‘aaaaab’.

‘a\?b’
     Matches ‘b’ or ‘ab’.

‘a\+b\+’
     Matches one or more ‘a’s followed by one or more ‘b’s: ‘ab’ is the
     shortest possible match, but other examples are ‘aaaab’ or ‘abbbbb’
     or ‘aaaaaabbbbbbb’.

‘.*’
‘.\+’
     These two both match all the characters in a string; however, the
     first matches every string (including the empty string), while the
     second matches only strings containing at least one character.

‘^main.*(.*)’
     This matches a string starting with ‘main’, followed by an opening
     and closing parenthesis.  The ‘n’, ‘(’ and ‘)’ need not be
     adjacent.

‘^#’
     This matches a string beginning with ‘#’.

‘\\$’
     This matches a string ending with a single backslash.  The regexp
     contains two backslashes for escaping.

‘\$’
     Instead, this matches a string consisting of a single dollar sign,
     because it is escaped.

‘[a-zA-Z0-9]’
     In the C locale, this matches any ASCII letters or digits.

‘[^ ‘<TAB>’]\+’
     (Here ‘<TAB>’ stands for a single tab character.)  This matches a
     string of one or more characters, none of which is a space or a
     tab.  Usually this means a word.

‘^\(.*\)\n\1$’
     This matches a string consisting of two equal substrings separated
     by a newline.

‘.\{9\}A$’
     This matches nine characters followed by an ‘A’ at the end of a
     line.

‘^.\{15\}A’
     This matches the start of a string that contains 16 characters, the
     last of which is an ‘A’.


File: sed.info,  Node: ERE syntax,  Next: Character Classes and Bracket Expressions,  Prev: BRE syntax,  Up: sed regular expressions

5.4 Overview of extended regular expression syntax
==================================================

The only difference between basic and extended regular expressions is in
the behavior of a few characters: ‘?’, ‘+’, parentheses, braces (‘{}’),
and ‘|’.  While basic regular expressions require these to be escaped if
you want them to behave as special characters, when using extended
regular expressions you must escape them if you want them _to match a
literal character_.  ‘|’ is special here because ‘\|’ is a GNU extension
– standard basic regular expressions do not provide its functionality.

Examples:
‘abc?’
     becomes ‘abc\?’ when using extended regular expressions.  It
     matches the literal string ‘abc?’.

‘c\+’
     becomes ‘c+’ when using extended regular expressions.  It matches
     one or more ‘c’s.

‘a\{3,\}’
     becomes ‘a{3,}’ when using extended regular expressions.  It
     matches three or more ‘a’s.

‘\(abc\)\{2,3\}’
     becomes ‘(abc){2,3}’ when using extended regular expressions.  It
     matches either ‘abcabc’ or ‘abcabcabc’.

‘\(abc*\)\1’
     becomes ‘(abc*)\1’ when using extended regular expressions.
     Backreferences must still be escaped when using extended regular
     expressions.

‘a\|b’
     becomes ‘a|b’ when using extended regular expressions.  It matches
     ‘a’ or ‘b’.


File: sed.info,  Node: Character Classes and Bracket Expressions,  Next: regexp extensions,  Prev: ERE syntax,  Up: sed regular expressions

5.5 Character Classes and Bracket Expressions
=============================================

A “bracket expression” is a list of characters enclosed by ‘[’ and ‘]’.
It matches any single character in that list; if the first character of
the list is the caret ‘^’, then it matches any character *not* in the
list.  For example, the following command replaces the strings ‘gray’ or
‘grey’ with ‘blue’:

     sed  's/gr[ae]y/blue/'

   Bracket expressions can be used in both *note basic: BRE syntax. and
*note extended: ERE syntax. regular expressions (that is, with or
without the ‘-E’/‘-r’ options).

   Within a bracket expression, a “range expression” consists of two
characters separated by a hyphen.  It matches any single character that
sorts between the two characters, inclusive.  In the default C locale,
the sorting sequence is the native character order; for example, ‘[a-d]’
is equivalent to ‘[abcd]’.

   Finally, certain named classes of characters are predefined within
bracket expressions, as follows.

   These named classes must be used _inside_ brackets themselves.
Correct usage:
     $ echo 1 | sed 's/[[:digit:]]/X/'
     X

   Incorrect usage is rejected by newer ‘sed’ versions.  Older versions
accepted it but treated it as a single bracket expression (which is
equivalent to ‘[dgit:]’, that is, only the characters D/G/I/T/:):
     # current GNU sed versions - incorrect usage rejected
     $ echo 1 | sed 's/[:digit:]/X/'
     sed: character class syntax is [[:space:]], not [:space:]

     # older GNU sed versions
     $ echo 1 | sed 's/[:digit:]/X/'
     1

‘[:alnum:]’
     Alphanumeric characters: ‘[:alpha:]’ and ‘[:digit:]’; in the ‘C’
     locale and ASCII character encoding, this is the same as
     ‘[0-9A-Za-z]’.

‘[:alpha:]’
     Alphabetic characters: ‘[:lower:]’ and ‘[:upper:]’; in the ‘C’
     locale and ASCII character encoding, this is the same as
     ‘[A-Za-z]’.

‘[:blank:]’
     Blank characters: space and tab.

‘[:cntrl:]’
     Control characters.  In ASCII, these characters have octal codes
     000 through 037, and 177 (DEL). In other character sets, these are
     the equivalent characters, if any.

‘[:digit:]’
     Digits: ‘0 1 2 3 4 5 6 7 8 9’.

‘[:graph:]’
     Graphical characters: ‘[:alnum:]’ and ‘[:punct:]’.

‘[:lower:]’
     Lower-case letters; in the ‘C’ locale and ASCII character encoding,
     this is ‘a b c d e f g h i j k l m n o p q r s t u v w x y z’.

‘[:print:]’
     Printable characters: ‘[:alnum:]’, ‘[:punct:]’, and space.

‘[:punct:]’
     Punctuation characters; in the ‘C’ locale and ASCII character
     encoding, this is ‘! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \
     ] ^ _ ` { | } ~’.

‘[:space:]’
     Space characters: in the ‘C’ locale, this is tab, newline, vertical
     tab, form feed, carriage return, and space.

‘[:upper:]’
     Upper-case letters: in the ‘C’ locale and ASCII character encoding,
     this is ‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’.

‘[:xdigit:]’
     Hexadecimal digits: ‘0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f’.

   Note that the brackets in these class names are part of the symbolic
names, and must be included in addition to the brackets delimiting the
bracket expression.

   Most meta-characters lose their special meaning inside bracket
expressions:

‘]’
     ends the bracket expression if it’s not the first list item.  So,
     if you want to make the ‘]’ character a list item, you must put it
     first.

‘-’
     represents the range if it’s not first or last in a list or the
     ending point of a range.

‘^’
     represents the characters not in the list.  If you want to make the
     ‘^’ character a list item, place it anywhere but first.

   TODO: incorporate this paragraph (copied verbatim from BRE section).

   The characters ‘$’, ‘*’, ‘.’, ‘[’, and ‘\’ are normally not special
within LIST.  For example, ‘[\*]’ matches either ‘\’ or ‘*’, because the
‘\’ is not special here.  However, strings like ‘[.ch.]’, ‘[=a=]’, and
‘[:space:]’ are special within LIST and represent collating symbols,
equivalence classes, and character classes, respectively, and ‘[’ is
therefore special within LIST when it is followed by ‘.’, ‘=’, or ‘:’.
Also, when not in ‘POSIXLY_CORRECT’ mode, special escapes like ‘\n’ and
‘\t’ are recognized within LIST.  *Note Escapes::.

‘[.’
     represents the open collating symbol.

‘.]’
     represents the close collating symbol.

‘[=’
     represents the open equivalence class.

‘=]’
     represents the close equivalence class.

‘[:’
     represents the open character class symbol, and should be followed
     by a valid character class name.

‘:]’
     represents the close character class symbol.


File: sed.info,  Node: regexp extensions,  Next: Back-references and Subexpressions,  Prev: Character Classes and Bracket Expressions,  Up: sed regular expressions

5.6 regular expression extensions
=================================

The following sequences have special meaning inside regular expressions
(used in *note addresses: Regexp Addresses. and the ‘s’ command).

   These can be used in both *note basic: BRE syntax. and *note
extended: ERE syntax. regular expressions (that is, with or without the
‘-E’/‘-r’ options).

‘\w’
     Matches any “word” character.  A “word” character is any letter or
     digit or the underscore character.

          $ echo "abc %-= def." | sed 's/\w/X/g'
          XXX %-= XXX.

‘\W’
     Matches any “non-word” character.

          $ echo "abc %-= def." | sed 's/\W/X/g'
          abcXXXXXdefX

‘\b’
     Matches a word boundary; that is it matches if the character to the
     left is a “word” character and the character to the right is a
     “non-word” character, or vice-versa.

          $ echo "abc %-= def." | sed 's/\b/X/g'
          XabcX %-= XdefX.

‘\B’
     Matches everywhere but on a word boundary; that is it matches if
     the character to the left and the character to the right are either
     both “word” characters or both “non-word” characters.

          $ echo "abc %-= def." | sed 's/\B/X/g'
          aXbXc X%X-X=X dXeXf.X

‘\s’
     Matches whitespace characters (spaces and tabs).  Newlines embedded
     in the pattern/hold spaces will also match:

          $ echo "abc %-= def." | sed 's/\s/X/g'
          abcX%-=Xdef.

‘\S’
     Matches non-whitespace characters.

          $ echo "abc %-= def." | sed 's/\S/X/g'
          XXX XXX XXXX

‘\<’
     Matches the beginning of a word.

          $ echo "abc %-= def." | sed 's/\</X/g'
          Xabc %-= Xdef.

‘\>’
     Matches the end of a word.

          $ echo "abc %-= def." | sed 's/\>/X/g'
          abcX %-= defX.

‘\`’
     Matches only at the start of pattern space.  This is different from
     ‘^’ in multi-line mode.

     Compare the following two examples:

          $ printf "a\nb\nc\n" | sed 'N;N;s/^/X/gm'
          Xa
          Xb
          Xc

          $ printf "a\nb\nc\n" | sed 'N;N;s/\`/X/gm'
          Xa
          b
          c

‘\'’
     Matches only at the end of pattern space.  This is different from
     ‘$’ in multi-line mode.


File: sed.info,  Node: Back-references and Subexpressions,  Next: Escapes,  Prev: regexp extensions,  Up: sed regular expressions

5.7 Back-references and Subexpressions
======================================

“back-references” are regular expression commands which refer to a
previous part of the matched regular expression.  Back-references are
specified with backslash and a single digit (e.g.  ‘\1’).  The part of
the regular expression they refer to is called a “subexpression”, and is
designated with parentheses.

   Back-references and subexpressions are used in two cases: in the
regular expression search pattern, and in the REPLACEMENT part of the
‘s’ command (*note Regular Expression Addresses: Regexp Addresses. and
*note The "s" Command::).

   In a regular expression pattern, back-references are used to match
the same content as a previously matched subexpression.  In the
following example, the subexpression is ‘.’ - any single character
(being surrounded by parentheses makes it a subexpression).  The
back-reference ‘\1’ asks to match the same content (same character) as
the sub-expression.

   The command below matches words starting with any character, followed
by the letter ‘o’, followed by the same character as the first.

     $ sed -E -n '/^(.)o\1$/p' /usr/share/dict/words
     bob
     mom
     non
     pop
     sos
     tot
     wow

   Multiple subexpressions are automatically numbered from
left-to-right.  This command searches for 6-letter palindromes (the
first three letters are 3 subexpressions, followed by 3 back-references
in reverse order):

     $ sed -E -n '/^(.)(.)(.)\3\2\1$/p' /usr/share/dict/words
     redder

   In the ‘s’ command, back-references can be used in the REPLACEMENT
part to refer back to subexpressions in the REGEXP part.

   The following example uses two subexpressions in the regular
expression to match two space-separated words.  The back-references in
the REPLACEMENT part prints the words in a different order:

     $ echo "James Bond" | sed -E 's/(.*) (.*)/The name is \2, \1 \2./'
     The name is Bond, James Bond.

   When used with alternation, if the group does not participate in the
match then the back-reference makes the whole match fail.  For example,
‘a(.)|b\1’ will not match ‘ba’.  When multiple regular expressions are
given with ‘-e’ or from a file (‘-f FILE’), back-references are local to
each expression.


File: sed.info,  Node: Escapes,  Next: Locale Considerations,  Prev: Back-references and Subexpressions,  Up: sed regular expressions

5.8 Escape Sequences - specifying special characters
====================================================

Until this chapter, we have only encountered escapes of the form ‘\^’,
which tell ‘sed’ not to interpret the circumflex as a special character,
but rather to take it literally.  For example, ‘\*’ matches a single
asterisk rather than zero or more backslashes.

   This chapter introduces another kind of escape(1)—that is, escapes
that are applied to a character or sequence of characters that
ordinarily are taken literally, and that ‘sed’ replaces with a special
character.  This provides a way of encoding non-printable characters in
patterns in a visible manner.  There is no restriction on the appearance
of non-printing characters in a ‘sed’ script but when a script is being
prepared in the shell or by text editing, it is usually easier to use
one of the following escape sequences than the binary character it
represents:

   The list of these escapes is:

‘\a’
     Produces or matches a BEL character, that is an “alert” (ASCII 7).

‘\f’
     Produces or matches a form feed (ASCII 12).

‘\n’
     Produces or matches a newline (ASCII 10).

‘\r’
     Produces or matches a carriage return (ASCII 13).

‘\t’
     Produces or matches a horizontal tab (ASCII 9).

‘\v’
     Produces or matches a so called “vertical tab” (ASCII 11).

‘\cX’
     Produces or matches ‘CONTROL-X’, where X is any character.  The
     precise effect of ‘\cX’ is as follows: if X is a lower case letter,
     it is converted to upper case.  Then bit 6 of the character (hex
     40) is inverted.  Thus ‘\cz’ becomes hex 1A, but ‘\c{’ becomes hex
     3B, while ‘\c;’ becomes hex 7B.

‘\dXXX’
     Produces or matches a character whose decimal ASCII value is XXX.

‘\oXXX’
     Produces or matches a character whose octal ASCII value is XXX.

‘\xXX’
     Produces or matches a character whose hexadecimal ASCII value is
     XX.

   ‘\b’ (backspace) was omitted because of the conflict with the
existing “word boundary” meaning.

5.8.1 Escaping Precedence
-------------------------

GNU ‘sed’ processes escape sequences _before_ passing the text onto the
regular-expression matching of the ‘s///’ command and Address matching.
Thus the following two commands are equivalent (‘0x5e’ is the
hexadecimal ASCII value of the character ‘^’):

     $ echo 'a^c' | sed 's/^/b/'
     ba^c

     $ echo 'a^c' | sed 's/\x5e/b/'
     ba^c

   As are the following (‘0x5b’,‘0x5d’ are the hexadecimal ASCII values
of ‘[’,‘]’, respectively):

     $ echo abc | sed 's/[a]/x/'
     Xbc
     $ echo abc | sed 's/\x5ba\x5d/x/'
     Xbc

   However it is recommended to avoid such special characters due to
unexpected edge-cases.  For example, the following are not equivalent:

     $ echo 'a^c' | sed 's/\^/b/'
     abc

     $ echo 'a^c' | sed 's/\\\x5e/b/'
     a^c

   ---------- Footnotes ----------

   (1) All the escapes introduced here are GNU extensions, with the
exception of ‘\n’.  In basic regular expression mode, setting
‘POSIXLY_CORRECT’ disables them inside bracket expressions.


File: sed.info,  Node: Locale Considerations,  Prev: Escapes,  Up: sed regular expressions

5.9 Multibyte characters and Locale Considerations
==================================================

GNU ‘sed’ processes valid multibyte characters in multibyte locales
(e.g.  ‘UTF-8’).  (1)

The following example uses the Greek letter Capital Sigma (Σ, Unicode
code point ‘0x03A3’).  In a ‘UTF-8’ locale, ‘sed’ correctly processes
the Sigma as one character despite it being 2 octets (bytes):

     $ locale | grep LANG
     LANG=en_US.UTF-8

     $ printf 'a\u03A3b'
     aΣb

     $ printf 'a\u03A3b' | sed 's/./X/g'
     XXX

     $ printf 'a\u03A3b' | od -tx1 -An
      61 ce a3 62

To force ‘sed’ to process octets separately, use the ‘C’ locale (also
known as the ‘POSIX’ locale):

     $ printf 'a\u03A3b' | LC_ALL=C sed 's/./X/g'
     XXXX

5.9.1 Invalid multibyte characters
----------------------------------

‘sed’’s regular expressions _do not_ match invalid multibyte sequences
in a multibyte locale.

In the following examples, the ascii value ‘0xCE’ is an incomplete
multibyte character (shown here as �).  The regular expression ‘.’ does
not match it:

     $ printf 'a\xCEb\n'
     a�e

     $ printf 'a\xCEb\n' | sed 's/./X/g'
     X�X

     $ printf 'a\xCEc\n' | sed 's/./X/g' | od -tx1c -An
       58  ce  58  0a
        X      X   \n

Similarly, the ’catch-all’ regular expression ‘.*’ does not match the
entire line:

     $ printf 'a\xCEc\n' | sed 's/.*//' | od -tx1c -An
       ce  63  0a
            c  \n

GNU ‘sed’ offers the special ‘z’ command to clear the current pattern
space regardless of invalid multibyte characters (i.e.  it works like
‘s/.*//’ but also removes invalid multibyte characters):

     $ printf 'a\xCEc\n' | sed 'z' | od -tx1c -An
        0a
        \n

Alternatively, force the ‘C’ locale to process each octet separately
(every octet is a valid character in the ‘C’ locale):

     $ printf 'a\xCEc\n' | LC_ALL=C sed 's/.*//' | od -tx1c -An
       0a
       \n

   ‘sed’’s inability to process invalid multibyte characters can be used
to detect such invalid sequences in a file.  In the following examples,
the ‘\xCE\xCE’ is an invalid multibyte sequence, while ‘\xCE\A3’ is a
valid multibyte sequence (of the Greek Sigma character).

The following ‘sed’ program removes all valid characters using ‘s/.//g’.
Any content left in the pattern space (the invalid characters) are added
to the hold space using the ‘H’ command.  On the last line (‘$’), the
hold space is retrieved (‘x’), newlines are removed (‘s/\n//g’), and any
remaining octets are printed unambiguously (‘l’).  Thus, any invalid
multibyte sequences are printed as octal values:

     $ printf 'ab\nc\n\xCE\xCEde\n\xCE\xA3f\n' > invalid.txt

     $ cat invalid.txt
     ab
     c
     ��de
     Σf

     $ sed -n 's/.//g ; H ; ${x;s/\n//g;l}' invalid.txt
     \316\316$

With a few more commands, ‘sed’ can print the exact line number
corresponding to each invalid characters (line 3).  These characters can
then be removed by forcing the ‘C’ locale and using octal escape
sequences:

     $ sed -n 's/.//g;=;l' invalid.txt | paste - -  | awk '$2!="$"'
     3       \316\316$

     $ LC_ALL=C sed '3s/\o316\o316//' invalid.txt > fixed.txt

5.9.2 Upper/Lower case conversion
---------------------------------

GNU ‘sed’’s substitute command (‘s’) supports upper/lower case
conversions using ‘\U’,‘\L’ codes.  These conversions support multibyte
characters:

     $ printf 'ABC\u03a3\n'
     ABCΣ

     $ printf 'ABC\u03a3\n' | sed 's/.*/\L&/'
     abcσ

*Note The "s" Command::.

5.9.3 Multibyte regexp character classes
----------------------------------------

In other locales, the sorting sequence is not specified, and ‘[a-d]’
might be equivalent to ‘[abcd]’ or to ‘[aBbCcDd]’, or it might fail to
match any character, or the set of characters that it matches might even
be erratic.  To obtain the traditional interpretation of bracket
expressions, you can use the ‘C’ locale by setting the ‘LC_ALL’
environment variable to the value ‘C’.

     # TODO: is there any real-world system/locale where 'A'
     #       is replaced by '-' ?
     $ echo A | sed 's/[a-z]/-/'
     A

   Their interpretation depends on the ‘LC_CTYPE’ locale; for example,
‘[[:alnum:]]’ means the character class of numbers and letters in the
current locale.

   TODO: show example of collation

     # TODO: this works on glibc systems, not on musl-libc/freebsd/macosx.
     $ printf 'cliché\n' | LC_ALL=fr_FR.utf8 sed 's/[[=e=]]/X/g'
     clichX

   ---------- Footnotes ----------

   (1) Some regexp edge-cases depends on the operating system and libc
implementation.  The examples shown are known to work as-expected on
GNU/Linux systems using glibc.


File: sed.info,  Node: advanced sed,  Next: Examples,  Prev: sed regular expressions,  Up: Top

6 Advanced ‘sed’: cycles and buffers
************************************

* Menu:

* Execution Cycle::          How ‘sed’ works
* Hold and Pattern Buffers::
* Multiline techniques::     Using D,G,H,N,P to process multiple lines
* Branching and flow control::


File: sed.info,  Node: Execution Cycle,  Next: Hold and Pattern Buffers,  Up: advanced sed

6.1 How ‘sed’ Works
===================

‘sed’ maintains two data buffers: the active _pattern_ space, and the
auxiliary _hold_ space.  Both are initially empty.

   ‘sed’ operates by performing the following cycle on each line of
input: first, ‘sed’ reads one line from the input stream, removes any
trailing newline, and places it in the pattern space.  Then commands are
executed; each command can have an address associated to it: addresses
are a kind of condition code, and a command is only executed if the
condition is verified before the command is to be executed.

   When the end of the script is reached, unless the ‘-n’ option is in
use, the contents of pattern space are printed out to the output stream,
adding back the trailing newline if it was removed.(1)  Then the next
cycle starts for the next input line.

   Unless special commands (like ‘D’) are used, the pattern space is
deleted between two cycles.  The hold space, on the other hand, keeps
its data between cycles (see commands ‘h’, ‘H’, ‘x’, ‘g’, ‘G’ to move
data between both buffers).

   ---------- Footnotes ----------

   (1) Actually, if ‘sed’ prints a line without the terminating newline,
it will nevertheless print the missing newline as soon as more text is
sent to the same output stream, which gives the “least expected
surprise” even though it does not make commands like ‘sed -n p’ exactly
identical to ‘cat’.


File: sed.info,  Node: Hold and Pattern Buffers,  Next: Multiline techniques,  Prev: Execution Cycle,  Up: advanced sed

6.2 Hold and Pattern Buffers
============================

TODO


File: sed.info,  Node: Multiline techniques,  Next: Branching and flow control,  Prev: Hold and Pattern Buffers,  Up: advanced sed

6.3 Multiline techniques - using D,G,H,N,P to process multiple lines
====================================================================

Multiple lines can be processed as one buffer using the
‘D’,‘G’,‘H’,‘N’,‘P’.  They are similar to their lowercase counterparts
(‘d’,‘g’, ‘h’,‘n’,‘p’), except that these commands append or subtract
data while respecting embedded newlines - allowing adding and removing
lines from the pattern and hold spaces.

   They operate as follows:
‘D’
     _deletes_ line from the pattern space until the first newline, and
     restarts the cycle.

‘G’
     _appends_ line from the hold space to the pattern space, with a
     newline before it.

‘H’
     _appends_ line from the pattern space to the hold space, with a
     newline before it.

‘N’
     _appends_ line from the input file to the pattern space.

‘P’
     _prints_ line from the pattern space until the first newline.

   The following example illustrates the operation of ‘N’ and ‘D’
commands:

     $ seq 6 | sed -n 'N;l;D'
     1\n2$
     2\n3$
     3\n4$
     4\n5$
     5\n6$

  1. ‘sed’ starts by reading the first line into the pattern space (i.e.
     ‘1’).
  2. At the beginning of every cycle, the ‘N’ command appends a newline
     and the next line to the pattern space (i.e.  ‘1’, ‘\n’, ‘2’ in the
     first cycle).
  3. The ‘l’ command prints the content of the pattern space
     unambiguously.
  4. The ‘D’ command then removes the content of pattern space up to the
     first newline (leaving ‘2’ at the end of the first cycle).
  5. At the next cycle the ‘N’ command appends a newline and the next
     input line to the pattern space (e.g.  ‘2’, ‘\n’, ‘3’).

   A common technique to process blocks of text such as paragraphs
(instead of line-by-line) is using the following construct:

     sed '/./{H;$!d} ; x ; s/REGEXP/REPLACEMENT/'

  1. The first expression, ‘/./{H;$!d}’ operates on all non-empty lines,
     and adds the current line (in the pattern space) to the hold space.
     On all lines except the last, the pattern space is deleted and the
     cycle is restarted.

  2. The other expressions ‘x’ and ‘s’ are executed only on empty lines
     (i.e.  paragraph separators).  The ‘x’ command fetches the
     accumulated lines from the hold space back to the pattern space.
     The ‘s///’ command then operates on all the text in the paragraph
     (including the embedded newlines).

   The following example demonstrates this technique:
     $ cat input.txt
     a a a aa aaa
     aaaa aaaa aa
     aaaa aaa aaa

     bbbb bbb bbb
     bb bb bbb bb
     bbbbbbbb bbb

     ccc ccc cccc
     cccc ccccc c
     cc cc cc cc

     $ sed '/./{H;$!d} ; x ; s/^/\nSTART-->/ ; s/$/\n<--END/' input.txt

     START-->
     a a a aa aaa
     aaaa aaaa aa
     aaaa aaa aaa
     <--END

     START-->
     bbbb bbb bbb
     bb bb bbb bb
     bbbbbbbb bbb
     <--END

     START-->
     ccc ccc cccc
     cccc ccccc c
     cc cc cc cc
     <--END

   For more annotated examples, *note Text search across multiple
lines:: and *note Line length adjustment::.


File: sed.info,  Node: Branching and flow control,  Prev: Multiline techniques,  Up: advanced sed

6.4 Branching and Flow Control
==============================

The branching commands ‘b’, ‘t’, and ‘T’ enable changing the flow of
‘sed’ programs.

   By default, ‘sed’ reads an input line into the pattern buffer, then
continues to processes all commands in order.  Commands without
addresses affect all lines.  Commands with addresses affect only
matching lines.  *Note Execution Cycle:: and *note Addresses overview::.

   ‘sed’ does not support a typical ‘if/then’ construct.  Instead, some
commands can be used as conditionals or to change the default flow
control:

‘d’
     delete (clears) the current pattern space, and restart the program
     cycle without processing the rest of the commands and without
     printing the pattern space.

‘D’
     delete the contents of the pattern space _up to the first newline_,
     and restart the program cycle without processing the rest of the
     commands and without printing the pattern space.

‘[addr]X’
‘[addr]{ X ; X ; X }’
‘/regexp/X’
‘/regexp/{ X ; X ; X }’
     Addresses and regular expressions can be used as an ‘if/then’
     conditional: If [ADDR] matches the current pattern space, execute
     the command(s).  For example: The command ‘/^#/d’ means: _if_ the
     current pattern matches the regular expression ‘^#’ (a line
     starting with a hash), _then_ execute the ‘d’ command: delete the
     line without printing it, and restart the program cycle
     immediately.

‘b’
     branch unconditionally (that is: always jump to a label, skipping
     or repeating other commands, without restarting a new cycle).
     Combined with an address, the branch can be conditionally executed
     on matched lines.

‘t’
     branch conditionally (that is: jump to a label) _only if_ a ‘s///’
     command has succeeded since the last input line was read or another
     conditional branch was taken.

‘T’
     similar but opposite to the ‘t’ command: branch only if there has
     been _no_ successful substitutions since the last input line was
     read.

   The following two ‘sed’ programs are equivalent.  The first
(contrived) example uses the ‘b’ command to skip the ‘s///’ command on
lines containing ‘1’.  The second example uses an address with negation
(‘!’) to perform substitution only on desired lines.  The ‘y///’ command
is still executed on all lines:

     $ printf '%s\n' a1 a2 a3 | sed -E '/1/bx ; s/a/z/ ; :x ; y/123/456/'
     a4
     z5
     z6

     $ printf '%s\n' a1 a2 a3 | sed -E '/1/!s/a/z/ ; y/123/456/'
     a4
     z5
     z6

6.4.1 Branching and Cycles
--------------------------

The ‘b’,‘t’ and ‘T’ commands can be followed by a label (typically a
single letter).  Labels are defined with a colon followed by one or more
letters (e.g.  ‘:x’).  If the label is omitted the branch commands
restart the cycle.  Note the difference between branching to a label and
restarting the cycle: when a cycle is restarted, ‘sed’ first prints the
current content of the pattern space, then reads the next input line
into the pattern space; Jumping to a label (even if it is at the
beginning of the program) does not print the pattern space and does not
read the next input line.

   The following program is a no-op.  The ‘b’ command (the only command
in the program) does not have a label, and thus simply restarts the
cycle.  On each cycle, the pattern space is printed and the next input
line is read:

     $ seq 3 | sed b
     1
     2
     3

   The following example is an infinite-loop - it doesn’t terminate and
doesn’t print anything.  The ‘b’ command jumps to the ‘x’ label, and a
new cycle is never started:

     $ seq 3 | sed ':x ; bx'

     # The above command requires gnu sed (which supports additional
     # commands following a label, without a newline). A portable equivalent:
     #     sed -e ':x' -e bx

   Branching is often complemented with the ‘n’ or ‘N’ commands: both
commands read the next input line into the pattern space without waiting
for the cycle to restart.  Before reading the next input line, ‘n’
prints the current pattern space then empties it, while ‘N’ appends a
newline and the next input line to the pattern space.

   Consider the following two examples:

     $ seq 3 | sed ':x ; n ; bx'
     1
     2
     3

     $ seq 3 | sed ':x ; N ; bx'
     1
     2
     3

   • Both examples do not inf-loop, despite never starting a new cycle.

   • In the first example, the ‘n’ commands first prints the content of
     the pattern space, empties the pattern space then reads the next
     input line.

   • In the second example, the ‘N’ commands appends the next input line
     to the pattern space (with a newline).  Lines are accumulated in
     the pattern space until there are no more input lines to read, then
     the ‘N’ command terminates the ‘sed’ program.  When the program
     terminates, the end-of-cycle actions are performed, and the entire
     pattern space is printed.

   • The second example requires GNU ‘sed’, because it uses the
     non-POSIX-standard behavior of ‘N’.  See the “‘N’ command on the
     last line” paragraph in *note Reporting Bugs::.

   • To further examine the difference between the two examples, try the
     following commands:
          printf '%s\n' aa bb cc dd | sed ':x ; n ; = ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; N ; = ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; n ; s/\n/***/ ; bx'
          printf '%s\n' aa bb cc dd | sed ':x ; N ; s/\n/***/ ; bx'

6.4.2 Branching example: joining lines
--------------------------------------

As a real-world example of using branching, consider the case of
quoted-printable (https://en.wikipedia.org/wiki/Quoted-printable) files,
typically used to encode email messages.  In these files long lines are
split and marked with a “soft line break” consisting of a single ‘=’
character at the end of the line:

     $ cat jaques.txt
     All the wor=
     ld's a stag=
     e,
     And all the=
      men and wo=
     men merely =
     players:
     They have t=
     heir exits =
     and their e=
     ntrances;
     And one man=
      in his tim=
     e plays man=
     y parts.

   The following program uses an address match ‘/=$/’ as a conditional:
If the current pattern space ends with a ‘=’, it reads the next input
line using ‘N’, replaces all ‘=’ characters which are followed by a
newline, and unconditionally branches (‘b’) to the beginning of the
program without restarting a new cycle.  If the pattern space does not
ends with ‘=’, the default action is performed: the pattern space is
printed and a new cycle is started:

     $ sed ':x ; /=$/ { N ; s/=\n//g ; bx }' jaques.txt
     All the world's a stage,
     And all the men and women merely players:
     They have their exits and their entrances;
     And one man in his time plays many parts.

   Here’s an alternative program with a slightly different approach: On
all lines except the last, ‘N’ appends the line to the pattern space.  A
substitution command then removes soft line breaks (‘=’ at the end of a
line, i.e.  followed by a newline) by replacing them with an empty
string.  _if_ the substitution was successful (meaning the pattern space
contained a line which should be joined), The conditional branch command
‘t’ jumps to the beginning of the program without completing or
restarting the cycle.  If the substitution failed (meaning there were no
soft line breaks), The ‘t’ command will _not_ branch.  Then, ‘P’ will
print the pattern space content until the first newline, and ‘D’ will
delete the pattern space content until the first new line.  (To learn
more about ‘N’, ‘P’ and ‘D’ commands *note Multiline techniques::).

     $ sed ':x ; $!N ; s/=\n// ; tx ; P ; D' jaques.txt
     All the world's a stage,
     And all the men and women merely players:
     They have their exits and their entrances;
     And one man in his time plays many parts.

   For more line-joining examples *note Joining lines::.


File: sed.info,  Node: Examples,  Next: Limitations,  Prev: advanced sed,  Up: Top

7 Some Sample Scripts
*********************

Here are some ‘sed’ scripts to guide you in the art of mastering ‘sed’.

* Menu:


Useful one-liners:
* Joining lines::

Some exotic examples:
* Centering lines::
* Increment a number::
* Rename files to lower case::
* Print bash environment::
* Reverse chars of lines::
* Text search across multiple lines::
* Line length adjustment::
* Adding a header to multiple files::

Emulating standard utilities:
* tac::                             Reverse lines of files
* cat -n::                          Numbering lines
* cat -b::                          Numbering non-blank lines
* wc -c::                           Counting chars
* wc -w::                           Counting words
* wc -l::                           Counting lines
* head::                            Printing the first lines
* tail::                            Printing the last lines
* uniq::                            Make duplicate lines unique
* uniq -d::                         Print duplicated lines of input
* uniq -u::                         Remove all duplicated lines
* cat -s::                          Squeezing blank lines


File: sed.info,  Node: Joining lines,  Next: Centering lines,  Up: Examples

7.1 Joining lines
=================

This section uses ‘N’, ‘D’ and ‘P’ commands to process multiple lines,
and the ‘b’ and ‘t’ commands for branching.  *Note Multiline
techniques:: and *note Branching and flow control::.

   Join specific lines (e.g.  if lines 2 and 3 need to be joined):

     $ cat lines.txt
     hello
     hel
     lo
     hello

     $ sed '2{N;s/\n//;}' lines.txt
     hello
     hello
     hello

   Join backslash-continued lines:

     $ cat 1.txt
     this \
     is \
     a \
     long \
     line
     and another \
     line

     $ sed -e ':x /\\$/ { N; s/\\\n//g ; bx }'  1.txt
     this is a long line
     and another line


     #TODO: The above requires gnu sed.
     #      non-gnu seds need newlines after ':' and 'b'

   Join lines that start with whitespace (e.g SMTP headers):

     $ cat 2.txt
     Subject: Hello
         World
     Content-Type: multipart/alternative;
         boundary=94eb2c190cc6370f06054535da6a
     Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
     Authentication-Results: mx.gnu.org;
            dkim=pass header.i=@gnu.org;
            spf=pass
     Message-ID: <abcdef@gnu.org>
     From: John Doe <jdoe@gnu.org>
     To: Jane Smith <jsmith@gnu.org>

     $ sed -E ':a ; $!N ; s/\n\s+/ / ; ta ; P ; D' 2.txt
     Subject: Hello World
     Content-Type: multipart/alternative; boundary=94eb2c190cc6370f06054535da6a
     Date: Tue, 3 Jan 2017 19:41:16 +0000 (GMT)
     Authentication-Results: mx.gnu.org; dkim=pass header.i=@gnu.org; spf=pass
     Message-ID: <abcdef@gnu.org>
     From: John Doe <jdoe@gnu.org>
     To: Jane Smith <jsmith@gnu.org>

     # A portable (non-gnu) variation:
     #   sed -e :a -e '$!N;s/\n  */ /;ta' -e 'P;D'


File: sed.info,  Node: Centering lines,  Next: Increment a number,  Prev: Joining lines,  Up: Examples

7.2 Centering Lines
===================

This script centers all lines of a file on a 80 columns width.  To
change that width, the number in ‘\{...\}’ must be replaced, and the
number of added spaces also must be changed.

   Note how the buffer commands are used to separate parts in the
regular expressions to be matched—this is a common technique.

     #!/usr/bin/sed -f

     # Put 80 spaces in the buffer
     1 {
       x
       s/^$/          /
       s/^.*$/&&&&&&&&/
       x
     }

     # delete leading and trailing spaces
     y/<TAB>/ /
     s/^ *//
     s/ *$//

     # add a newline and 80 spaces to end of line
     G

     # keep first 81 chars (80 + a newline)
     s/^\(.\{81\}\).*$/\1/

     # \2 matches half of the spaces, which are moved to the beginning
     s/^\(.*\)\n\(.*\)\2/\2\1/


File: sed.info,  Node: Increment a number,  Next: Rename files to lower case,  Prev: Centering lines,  Up: Examples

7.3 Increment a Number
======================

This script is one of a few that demonstrate how to do arithmetic in
‘sed’.  This is indeed possible,(1) but must be done manually.

   To increment one number you just add 1 to last digit, replacing it by
the following digit.  There is one exception: when the digit is a nine
the previous digits must be also incremented until you don’t have a
nine.

   This solution by Bruno Haible is very clever and smart because it
uses a single buffer; if you don’t have this limitation, the algorithm
used in *note Numbering lines: cat -n, is faster.  It works by replacing
trailing nines with an underscore, then using multiple ‘s’ commands to
increment the last digit, and then again substituting underscores with
zeros.

     #!/usr/bin/sed -f

     /[^0-9]/ d

     # replace all trailing 9s by _ (any other character except digits, could
     # be used)
     :d
     s/9\(_*\)$/_\1/
     td

     # incr last digit only.  The first line adds a most-significant
     # digit of 1 if we have to add a digit.

     s/^\(_*\)$/1\1/; tn
     s/8\(_*\)$/9\1/; tn
     s/7\(_*\)$/8\1/; tn
     s/6\(_*\)$/7\1/; tn
     s/5\(_*\)$/6\1/; tn
     s/4\(_*\)$/5\1/; tn
     s/3\(_*\)$/4\1/; tn
     s/2\(_*\)$/3\1/; tn
     s/1\(_*\)$/2\1/; tn
     s/0\(_*\)$/1\1/; tn

     :n
     y/_/0/

   ---------- Footnotes ----------

   (1) ‘sed’ guru Greg Ubben wrote an implementation of the ‘dc’ RPN
calculator!  It is distributed together with sed.


File: sed.info,  Node: Rename files to lower case,  Next: Print bash environment,  Prev: Increment a number,  Up: Examples

7.4 Rename Files to Lower Case
==============================

This is a pretty strange use of ‘sed’.  We transform text, and transform
it to be shell commands, then just feed them to shell.  Don’t worry,
even worse hacks are done when using ‘sed’; I have seen a script
converting the output of ‘date’ into a ‘bc’ program!

   The main body of this is the ‘sed’ script, which remaps the name from
lower to upper (or vice-versa) and even checks out if the remapped name
is the same as the original name.  Note how the script is parameterized
using shell variables and proper quoting.

     #! /bin/sh
     # rename files to lower/upper case...
     #
     # usage:
     #    move-to-lower *
     #    move-to-upper *
     # or
     #    move-to-lower -R .
     #    move-to-upper -R .
     #

     help()
     {
             cat << eof
     Usage: $0 [-n] [-r] [-h] files...

     -n      do nothing, only see what would be done
     -R      recursive (use find)
     -h      this message
     files   files to remap to lower case

     Examples:
            $0 -n *        (see if everything is ok, then...)
            $0 *

            $0 -R .

     eof
     }

     apply_cmd='sh'
     finder='echo "$@" | tr " " "\n"'
     files_only=

     while :
     do
         case "$1" in
             -n) apply_cmd='cat' ;;
             -R) finder='find "$@" -type f';;
             -h) help ; exit 1 ;;
             *) break ;;
         esac
         shift
     done

     if [ -z "$1" ]; then
             echo Usage: $0 [-h] [-n] [-r] files...
             exit 1
     fi

     LOWER='abcdefghijklmnopqrstuvwxyz'
     UPPER='ABCDEFGHIJKLMNOPQRSTUVWXYZ'

     case `basename $0` in
             *upper*) TO=$UPPER; FROM=$LOWER ;;
             *)       FROM=$UPPER; TO=$LOWER ;;
     esac

     eval $finder | sed -n '

     # remove all trailing slashes
     s/\/*$//

     # add ./ if there is no path, only a filename
     /\//! s/^/.\//

     # save path+filename
     h

     # remove path
     s/.*\///

     # do conversion only on filename
     y/'$FROM'/'$TO'/

     # now line contains original path+file, while
     # hold space contains the new filename
     x

     # add converted file name to line, which now contains
     # path/file-name\nconverted-file-name
     G

     # check if converted file name is equal to original file name,
     # if it is, do not print anything
     /^.*\/\(.*\)\n\1/b

     # escape special characters for the shell
     s/["$`\\]/\\&/g

     # now, transform path/fromfile\n, into
     # mv path/fromfile path/tofile and print it
     s/^\(.*\/\)\(.*\)\n\(.*\)$/mv "\1\2" "\1\3"/p

     ' | $apply_cmd


File: sed.info,  Node: Print bash environment,  Next: Reverse chars of lines,  Prev: Rename files to lower case,  Up: Examples

7.5 Print ‘bash’ Environment
============================

This script strips the definition of the shell functions from the output
of the ‘set’ Bourne-shell command.

     #!/bin/sh

     set | sed -n '
     :x

     # if no occurrence of "=()" print and load next line
     /=()/! { p; b; }
     / () $/! { p; b; }

     # possible start of functions section
     # save the line in case this is a var like FOO="() "
     h

     # if the next line has a brace, we quit because
     # nothing comes after functions
     n
     /^{/ q

     # print the old line
     x; p

     # work on the new line now
     x; bx
     '


File: sed.info,  Node: Reverse chars of lines,  Next: Text search across multiple lines,  Prev: Print bash environment,  Up: Examples

7.6 Reverse Characters of Lines
===============================

This script can be used to reverse the position of characters in lines.
The technique moves two characters at a time, hence it is faster than
more intuitive implementations.

   Note the ‘tx’ command before the definition of the label.  This is
often needed to reset the flag that is tested by the ‘t’ command.

   Imaginative readers will find uses for this script.  An example is
reversing the output of ‘banner’.(1)

     #!/usr/bin/sed -f

     /../! b

     # Reverse a line.  Begin embedding the line between two newlines
     s/^.*$/\
     &\
     /

     # Move first character at the end.  The regexp matches until
     # there are zero or one characters between the markers
     tx
     :x
     s/\(\n.\)\(.*\)\(.\n\)/\3\2\1/
     tx

     # Remove the newline markers
     s/\n//g

   ---------- Footnotes ----------

   (1) This requires another script to pad the output of banner; for
example

     #! /bin/sh

     banner -w $1 $2 $3 $4 |
       sed -e :a -e '/^.\{0,'$1'\}$/ { s/$/ /; ba; }' |
       ~/sedscripts/reverseline.sed


File: sed.info,  Node: Text search across multiple lines,  Next: Line length adjustment,  Prev: Reverse chars of lines,  Up: Examples

7.7 Text search across multiple lines
=====================================

This section uses ‘N’ and ‘D’ commands to search for consecutive words
spanning multiple lines.  *Note Multiline techniques::.

   These examples deal with finding doubled occurrences of words in a
document.

   Finding doubled words in a single line is easy using GNU ‘grep’ and
similarly with GNU ‘sed’:

     $ cat two-cities-dup1.txt
     It was the best of times,
     it was the worst of times,
     it was the the age of wisdom,
     it was the age of foolishness,

     $ grep -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
     it was the the age of wisdom,

     $ grep -n -E '\b(\w+)\s+\1\b' two-cities-dup1.txt
     3:it was the the age of wisdom,

     $ sed -En '/\b(\w+)\s+\1\b/p' two-cities-dup1.txt
     it was the the age of wisdom,

     $ sed -En '/\b(\w+)\s+\1\b/{=;p}' two-cities-dup1.txt
     3
     it was the the age of wisdom,

   • The regular expression ‘\b\w+\s+’ searches for word-boundary
     (‘\b’), followed by one-or-more word-characters (‘\w+’), followed
     by whitespace (‘\s+’).  *Note regexp extensions::.

   • Adding parentheses around the ‘(\w+)’ expression creates a
     subexpression.  The regular expression pattern ‘(PATTERN)\s+\1’
     defines a subexpression (in the parentheses) followed by a
     back-reference, separated by whitespace.  A successful match means
     the PATTERN was repeated twice in succession.  *Note
     Back-references and Subexpressions::.

   • The word-boundery expression (‘\b’) at both ends ensures partial
     words are not matched (e.g.  ‘the then’ is not a desired match).

   • The ‘-E’ option enables extended regular expression syntax,
     alleviating the need to add backslashes before the parenthesis.
     *Note ERE syntax::.

   When the doubled word span two lines the above regular expression
will not find them as ‘grep’ and ‘sed’ operate line-by-line.

   By using ‘N’ and ‘D’ commands, ‘sed’ can apply regular expressions on
multiple lines (that is, multiple lines are stored in the pattern space,
and the regular expression works on it):

     $ cat two-cities-dup2.txt
     It was the best of times, it was the
     worst of times, it was the
     the age of wisdom,
     it was the age of foolishness,

     $ sed -En '{N; /\b(\w+)\s+\1\b/{=;p} ; D}'  two-cities-dup2.txt
     3
     worst of times, it was the
     the age of wisdom,

   • The ‘N’ command appends the next line to the pattern space (thus
     ensuring it contains two consecutive lines in every cycle).

   • The regular expression uses ‘\s+’ for word separator which matches
     both spaces and newlines.

   • The regular expression matches, the entire pattern space is printed
     with ‘p’.  No lines are printed by default due to the ‘-n’ option.

   • The ‘D’ removes the first line from the pattern space (up until the
     first newline), readying it for the next cycle.

   See the GNU ‘coreutils’ manual for an alternative solution using ‘tr
-s’ and ‘uniq’ at
<https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html>.


File: sed.info,  Node: Line length adjustment,  Next: Adding a header to multiple files,  Prev: Text search across multiple lines,  Up: Examples

7.8 Line length adjustment
==========================

This section uses ‘N’ and ‘P’ commands to read and write lines, and the
‘b’ command for branching.  *Note Multiline techniques:: and *note
Branching and flow control::.

   This (somewhat contrived) example deal with formatting and wrapping
lines of text of the following input file:

     $ cat two-cities-mix.txt
     It was the best of times, it was
     the worst of times, it
     was the age of
     wisdom,
     it
     was
     the age
     of foolishness,

The following sed program wraps lines at 40 characters:
     $ cat wrap40.sed
     # outer loop
     :x

     # Append a newline followed by the next input line to the pattern buffer
     N

     # Remove all newlines from the pattern buffer
     s/\n/ /g


     # Inner loop
     :y

     # Add a newline after the first 40 characters
     s/(.{40,40})/\1\n/

     # If there is a newline in the pattern buffer
     # (i.e. the previous substitution added a newline)
     /\n/ {
         # There are newlines in the pattern buffer -
         # print the content until the first newline.
         P

        # Remove the printed characters and the first newline
        s/.*\n//

        # branch to label 'y' - repeat inner loop
        by
      }

     # No newlines in the pattern buffer - Branch to label 'x' (outer loop)
     # and read the next input line
     bx

The wrapped output:
     $ sed -E -f wrap40.sed two-cities-mix.txt
     It was the best of times, it was the wor
     st of times, it was the age of wisdom, i
     t was the age of foolishness,


File: sed.info,  Node: Adding a header to multiple files,  Next: tac,  Prev: Line length adjustment,  Up: Examples

7.9 Adding a header to multiple files
=====================================

GNU ‘sed’ can be used to safely modify multiple files at once.

Add a single line to the beginning of source code files:

     sed -i '1i/* Copyright (C) FOO BAR */' *.c

Adding a few lines is possible using ‘\n’ in the text:

     sed -i '1i/*\n * Copyright (C) FOO BAR\n * Created by Jane Doe\n */' *.c

   To add multiple lines from another file, use ‘0rFILE’.  A typical use
case is adding a license notice header to all files:

     ## Create the header file:
     $ cat<<'EOF'>LIC.TXT
     /*
         Copyright (C) 1989-2021 FOO BAR

         This program is free software; you can redistribute it and/or modify
         it under the terms of the GNU General Public License as published by
         the Free Software Foundation; either version 3, or (at your option)
         any later version.

         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
         GNU General Public License for more details.

         You should have received a copy of the GNU General Public License
         along with this program; If not, see <https://www.gnu.org/licenses/>.
     */
     EOF

     ## Add the file at the beginning of all source code files:
     $ sed -i '0rLIC.TXT' *.cpp *.h

   With script files (e.g.  ‘.sh’,‘.py’,‘.pl’ files) the license notice
typically appears _after_ the first line (the ’shebang’ ‘#!’ line).  The
‘1rFILE’ command will add ‘FILE’ _after_ the first line:

     ## Create the header file:
     $ cat<<'EOF'>LIC.TXT
     ##
     ## Copyright (C) 1989-2021 FOO BAR
     ##
     ## This program is free software; you can redistribute it and/or modify
     ## it under the terms of the GNU General Public License as published by
     ## the Free Software Foundation; either version 3, or (at your option)
     ## any later version.
     ##
     ## This program is distributed in the hope that it will be useful,
     ## but WITHOUT ANY WARRANTY; without even the implied warranty of
     ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ## GNU General Public License for more details.
     ##
     ## You should have received a copy of the GNU General Public License
     ## along with this program; If not, see <https://www.gnu.org/licenses/>.
     ##
     ##
     EOF

     ## Add the file at the beginning of all source code files:
     $ sed -i '1rLIC.TXT' *.py *.sh

   The above ‘sed’ commands can be combined with ‘find’ to locate files
in all subdirectories, ‘xargs’ to run additional commands on selected
files and ‘grep’ to filter out files that already contain a copyright
notice:

     find \( -iname '*.cpp' -o -iname '*.c' -o -iname '*.h' \) \
         | xargs grep -Li copyright \
         | xargs -r sed -i '0rLIC.TXT'

Or a slightly safe version (handling files with spaces and newlines):

     find \( -iname '*.cpp' -o -iname '*.c' -o -iname '*.h' \) -print0 \
         | xargs -0 grep -Z -Li copyright \
         | xargs -0 -r sed -i '0rLIC.TXT'

   Note: using the ‘0’ address with ‘r’ command requires GNU ‘sed’
version 4.9 or later.  *Note Zero Address::.


File: sed.info,  Node: tac,  Next: cat -n,  Prev: Adding a header to multiple files,  Up: Examples

7.10 Reverse Lines of Files
===========================

This one begins a series of totally useless (yet interesting) scripts
emulating various Unix commands.  This, in particular, is a ‘tac’
workalike.

   Note that on implementations other than GNU ‘sed’ this script might
easily overflow internal buffers.

     #!/usr/bin/sed -nf

     # reverse all lines of input, i.e. first line became last, ...

     # from the second line, the buffer (which contains all previous lines)
     # is *appended* to current line, so, the order will be reversed
     1! G

     # on the last line we're done -- print everything
     $ p

     # store everything on the buffer again
     h


File: sed.info,  Node: cat -n,  Next: cat -b,  Prev: tac,  Up: Examples

7.11 Numbering Lines
====================

This script replaces ‘cat -n’; in fact it formats its output exactly
like GNU ‘cat’ does.

   Of course this is completely useless and for two reasons: first,
because somebody else did it in C, second, because the following
Bourne-shell script could be used for the same purpose and would be much
faster:

     #! /bin/sh
     sed -e "=" $@ | sed -e '
       s/^/      /
       N
       s/^ *\(......\)\n/\1  /
     '

   It uses ‘sed’ to print the line number, then groups lines two by two
using ‘N’.  Of course, this script does not teach as much as the one
presented below.

   The algorithm used for incrementing uses both buffers, so the line is
printed as soon as possible and then discarded.  The number is split so
that changing digits go in a buffer and unchanged ones go in the other;
the changed digits are modified in a single step (using a ‘y’ command).
The line number for the next line is then composed and stored in the
hold space, to be used in the next iteration.

     #!/usr/bin/sed -nf

     # Prime the pump on the first line
     x
     /^$/ s/^.*$/1/

     # Add the correct line number before the pattern
     G
     h

     # Format it and print it
     s/^/      /
     s/^ *\(......\)\n/\1  /p

     # Get the line number from hold space; add a zero
     # if we're going to add a digit on the next line
     g
     s/\n.*$//
     /^9*$/ s/^/0/

     # separate changing/unchanged digits with an x
     s/.9*$/x&/

     # keep changing digits in hold space
     h
     s/^.*x//
     y/0123456789/1234567890/
     x

     # keep unchanged digits in pattern space
     s/x.*$//

     # compose the new number, remove the newline implicitly added by G
     G
     s/\n//
     h


File: sed.info,  Node: cat -b,  Next: wc -c,  Prev: cat -n,  Up: Examples

7.12 Numbering Non-blank Lines
==============================

Emulating ‘cat -b’ is almost the same as ‘cat -n’—we only have to select
which lines are to be numbered and which are not.

   The part that is common to this script and the previous one is not
commented to show how important it is to comment ‘sed’ scripts
properly...

     #!/usr/bin/sed -nf

     /^$/ {
       p
       b
     }

     # Same as cat -n from now
     x
     /^$/ s/^.*$/1/
     G
     h
     s/^/      /
     s/^ *\(......\)\n/\1  /p
     x
     s/\n.*$//
     /^9*$/ s/^/0/
     s/.9*$/x&/
     h
     s/^.*x//
     y/0123456789/1234567890/
     x
     s/x.*$//
     G
     s/\n//
     h


File: sed.info,  Node: wc -c,  Next: wc -w,  Prev: cat -b,  Up: Examples

7.13 Counting Characters
========================

This script shows another way to do arithmetic with ‘sed’.  In this case
we have to add possibly large numbers, so implementing this by
successive increments would not be feasible (and possibly even more
complicated to contrive than this script).

   The approach is to map numbers to letters, kind of an abacus
implemented with ‘sed’.  ‘a’s are units, ‘b’s are tens and so on: we
simply add the number of characters on the current line as units, and
then propagate the carry to tens, hundreds, and so on.

   As usual, running totals are kept in hold space.

   On the last line, we convert the abacus form back to decimal.  For
the sake of variety, this is done with a loop rather than with some 80
‘s’ commands(1): first we convert units, removing ‘a’s from the number;
then we rotate letters so that tens become ‘a’s, and so on until no more
letters remain.

     #!/usr/bin/sed -nf

     # Add n+1 a's to hold space (+1 is for the newline)
     s/./a/g
     H
     x
     s/\n/a/

     # Do the carry.  The t's and b's are not necessary,
     # but they do speed up the thing
     t a
     : a;  s/aaaaaaaaaa/b/g; t b; b done
     : b;  s/bbbbbbbbbb/c/g; t c; b done
     : c;  s/cccccccccc/d/g; t d; b done
     : d;  s/dddddddddd/e/g; t e; b done
     : e;  s/eeeeeeeeee/f/g; t f; b done
     : f;  s/ffffffffff/g/g; t g; b done
     : g;  s/gggggggggg/h/g; t h; b done
     : h;  s/hhhhhhhhhh//g

     : done
     $! {
       h
       b
     }

     # On the last line, convert back to decimal

     : loop
     /a/! s/[b-h]*/&0/
     s/aaaaaaaaa/9/
     s/aaaaaaaa/8/
     s/aaaaaaa/7/
     s/aaaaaa/6/
     s/aaaaa/5/
     s/aaaa/4/
     s/aaa/3/
     s/aa/2/
     s/a/1/

     : next
     y/bcdefgh/abcdefg/
     /[a-h]/ b loop
     p

   ---------- Footnotes ----------

   (1) Some implementations have a limit of 199 commands per script


File: sed.info,  Node: wc -w,  Next: wc -l,  Prev: wc -c,  Up: Examples

7.14 Counting Words
===================

This script is almost the same as the previous one, once each of the
words on the line is converted to a single ‘a’ (in the previous script
each letter was changed to an ‘a’).

   It is interesting that real ‘wc’ programs have optimized loops for
‘wc -c’, so they are much slower at counting words rather than
characters.  This script’s bottleneck, instead, is arithmetic, and hence
the word-counting one is faster (it has to manage smaller numbers).

   Again, the common parts are not commented to show the importance of
commenting ‘sed’ scripts.

     #!/usr/bin/sed -nf

     # Convert words to a's
     s/[ <TAB>][ <TAB>]*/ /g
     s/^/ /
     s/ [^ ][^ ]*/a /g
     s/ //g

     # Append them to hold space
     H
     x
     s/\n//

     # From here on it is the same as in wc -c.
     /aaaaaaaaaa/! bx;   s/aaaaaaaaaa/b/g
     /bbbbbbbbbb/! bx;   s/bbbbbbbbbb/c/g
     /cccccccccc/! bx;   s/cccccccccc/d/g
     /dddddddddd/! bx;   s/dddddddddd/e/g
     /eeeeeeeeee/! bx;   s/eeeeeeeeee/f/g
     /ffffffffff/! bx;   s/ffffffffff/g/g
     /gggggggggg/! bx;   s/gggggggggg/h/g
     s/hhhhhhhhhh//g
     :x
     $! { h; b; }
     :y
     /a/! s/[b-h]*/&0/
     s/aaaaaaaaa/9/
     s/aaaaaaaa/8/
     s/aaaaaaa/7/
     s/aaaaaa/6/
     s/aaaaa/5/
     s/aaaa/4/
     s/aaa/3/
     s/aa/2/
     s/a/1/
     y/bcdefgh/abcdefg/
     /[a-h]/ by
     p


File: sed.info,  Node: wc -l,  Next: head,  Prev: wc -w,  Up: Examples

7.15 Counting Lines
===================

No strange things are done now, because ‘sed’ gives us ‘wc -l’
functionality for free!!!  Look:

     #!/usr/bin/sed -nf
     $=


File: sed.info,  Node: head,  Next: tail,  Prev: wc -l,  Up: Examples

7.16 Printing the First Lines
=============================

This script is probably the simplest useful ‘sed’ script.  It displays
the first 10 lines of input; the number of displayed lines is right
before the ‘q’ command.

     #!/usr/bin/sed -f
     10q


File: sed.info,  Node: tail,  Next: uniq,  Prev: head,  Up: Examples

7.17 Printing the Last Lines
============================

Printing the last N lines rather than the first is more complex but
indeed possible.  N is encoded in the second line, before the bang
character.

   This script is similar to the ‘tac’ script in that it keeps the final
output in the hold space and prints it at the end:

     #!/usr/bin/sed -nf

     1! {; H; g; }
     1,10 !s/[^\n]*\n//
     $p
     h

   Mainly, the scripts keeps a window of 10 lines and slides it by
adding a line and deleting the oldest (the substitution command on the
second line works like a ‘D’ command but does not restart the loop).

   The “sliding window” technique is a very powerful way to write
efficient and complex ‘sed’ scripts, because commands like ‘P’ would
require a lot of work if implemented manually.

   To introduce the technique, which is fully demonstrated in the rest
of this chapter and is based on the ‘N’, ‘P’ and ‘D’ commands, here is
an implementation of ‘tail’ using a simple “sliding window.”

   This looks complicated but in fact the working is the same as the
last script: after we have kicked in the appropriate number of lines,
however, we stop using the hold space to keep inter-line state, and
instead use ‘N’ and ‘D’ to slide pattern space by one line:

     #!/usr/bin/sed -f

     1h
     2,10 {; H; g; }
     $q
     1,9d
     N
     D

   Note how the first, second and fourth line are inactive after the
first ten lines of input.  After that, all the script does is: exiting
on the last line of input, appending the next input line to pattern
space, and removing the first line.


File: sed.info,  Node: uniq,  Next: uniq -d,  Prev: tail,  Up: Examples

7.18 Make Duplicate Lines Unique
================================

This is an example of the art of using the ‘N’, ‘P’ and ‘D’ commands,
probably the most difficult to master.

     #!/usr/bin/sed -f
     h

     :b
     # On the last line, print and exit
     $b
     N
     /^\(.*\)\n\1$/ {
         # The two lines are identical.  Undo the effect of
         # the n command.
         g
         bb
     }

     # If the N command had added the last line, print and exit
     $b

     # The lines are different; print the first and go
     # back working on the second.
     P
     D

   As you can see, we maintain a 2-line window using ‘P’ and ‘D’.  This
technique is often used in advanced ‘sed’ scripts.


File: sed.info,  Node: uniq -d,  Next: uniq -u,  Prev: uniq,  Up: Examples

7.19 Print Duplicated Lines of Input
====================================

This script prints only duplicated lines, like ‘uniq -d’.

     #!/usr/bin/sed -nf

     $b
     N
     /^\(.*\)\n\1$/ {
         # Print the first of the duplicated lines
         s/.*\n//
         p

         # Loop until we get a different line
         :b
         $b
         N
         /^\(.*\)\n\1$/ {
             s/.*\n//
             bb
         }
     }

     # The last line cannot be followed by duplicates
     $b

     # Found a different one.  Leave it alone in the pattern space
     # and go back to the top, hunting its duplicates
     D


File: sed.info,  Node: uniq -u,  Next: cat -s,  Prev: uniq -d,  Up: Examples

7.20 Remove All Duplicated Lines
================================

This script prints only unique lines, like ‘uniq -u’.

     #!/usr/bin/sed -f

     # Search for a duplicate line --- until that, print what you find.
     $b
     N
     /^\(.*\)\n\1$/ ! {
         P
         D
     }

     :c
     # Got two equal lines in pattern space.  At the
     # end of the file we simply exit
     $d

     # Else, we keep reading lines with N until we
     # find a different one
     s/.*\n//
     N
     /^\(.*\)\n\1$/ {
         bc
     }

     # Remove the last instance of the duplicate line
     # and go back to the top
     D


File: sed.info,  Node: cat -s,  Prev: uniq -u,  Up: Examples

7.21 Squeezing Blank Lines
==========================

As a final example, here are three scripts, of increasing complexity and
speed, that implement the same function as ‘cat -s’, that is squeezing
blank lines.

   The first leaves a blank line at the beginning and end if there are
some already.

     #!/usr/bin/sed -f

     # on empty lines, join with next
     # Note there is a star in the regexp
     :x
     /^\n*$/ {
     N
     bx
     }

     # now, squeeze all '\n', this can be also done by:
     # s/^\(\n\)*/\1/
     s/\n*/\
     /

   This one is a bit more complex and removes all empty lines at the
beginning.  It does leave a single blank line at end if one was there.

     #!/usr/bin/sed -f

     # delete all leading empty lines
     1,/^./{
     /./!d
     }

     # on an empty line we remove it and all the following
     # empty lines, but one
     :x
     /./!{
     N
     s/^\n$//
     tx
     }

   This removes leading and trailing blank lines.  It is also the
fastest.  Note that loops are completely done with ‘n’ and ‘b’, without
relying on ‘sed’ to restart the script automatically at the end of a
line.

     #!/usr/bin/sed -nf

     # delete all (leading) blanks
     /./!d

     # get here: so there is a non empty
     :x
     # print it
     p
     # get next
     n
     # got chars? print it again, etc...
     /./bx

     # no, don't have chars: got an empty line
     :z
     # get next, if last line we finish here so no trailing
     # empty lines are written
     n
     # also empty? then ignore it, and get next... this will
     # remove ALL empty lines
     /./!bz

     # all empty lines were deleted/ignored, but we have a non empty.  As
     # what we want to do is to squeeze, insert a blank line artificially
     i\

     bx


File: sed.info,  Node: Limitations,  Next: Other Resources,  Prev: Examples,  Up: Top

8 GNU ‘sed’’s Limitations and Non-limitations
*********************************************

For those who want to write portable ‘sed’ scripts, be aware that some
implementations have been known to limit line lengths (for the pattern
and hold spaces) to be no more than 4000 bytes.  The POSIX standard
specifies that conforming ‘sed’ implementations shall support at least
8192 byte line lengths.  GNU ‘sed’ has no built-in limit on line length;
as long as it can ‘malloc()’ more (virtual) memory, you can feed or
construct lines as long as you like.

   However, recursion is used to handle subpatterns and indefinite
repetition.  This means that the available stack space may limit the
size of the buffer that can be processed by certain patterns.


File: sed.info,  Node: Other Resources,  Next: Reporting Bugs,  Prev: Limitations,  Up: Top

9 Other Resources for Learning About ‘sed’
******************************************

For up to date information about GNU ‘sed’ please visit
<https://www.gnu.org/software/sed/>.

   Send general questions and suggestions to <sed-devel@gnu.org>.  Visit
the mailing list archives for past discussions at
<https://lists.gnu.org/archive/html/sed-devel/>.

   The following resources provide information about ‘sed’ (both GNU
‘sed’ and other variations).  Note these not maintained by GNU ‘sed’
developers.

   • sed ‘$HOME’: <http://sed.sf.net>

   • sed FAQ: <http://sed.sf.net/sedfaq.html>

   • seder’s grabbag: <http://sed.sf.net/grabbag>

   • The ‘sed-users’ mailing list maintained by Sven Guckes:
     <http://groups.yahoo.com/group/sed-users/> (note this is _not_ the
     GNU ‘sed’ mailing list).


File: sed.info,  Node: Reporting Bugs,  Next: GNU Free Documentation License,  Prev: Other Resources,  Up: Top

10 Reporting Bugs
*****************

Email bug reports to <bug-sed@gnu.org>.  Also, please include the output
of ‘sed --version’ in the body of your report if at all possible.

   Please do not send a bug report like this:

     while building frobme-1.3.4
     $ configure
     error→ sed: file sedscr line 1: Unknown option to 's'

   If GNU ‘sed’ doesn’t configure your favorite package, take a few
extra minutes to identify the specific problem and make a stand-alone
test case.  Unlike other programs such as C compilers, making such test
cases for ‘sed’ is quite simple.

   A stand-alone test case includes all the data necessary to perform
the test, and the specific invocation of ‘sed’ that causes the problem.
The smaller a stand-alone test case is, the better.  A test case should
not involve something as far removed from ‘sed’ as “try to configure
frobme-1.3.4”.  Yes, that is in principle enough information to look for
the bug, but that is not a very practical prospect.

   Here are a few commonly reported bugs that are not bugs.

‘N’ command on the last line

     Most versions of ‘sed’ exit without printing anything when the ‘N’
     command is issued on the last line of a file.  GNU ‘sed’ prints
     pattern space before exiting unless of course the ‘-n’ command
     switch has been specified.  This choice is by design.

     Default behavior (gnu extension, non-POSIX conforming):
          $ seq 3 | sed N
          1
          2
          3
     To force POSIX-conforming behavior:
          $ seq 3 | sed --posix N
          1
          2

     For example, the behavior of
          sed N foo bar
     would depend on whether foo has an even or an odd number of
     lines(1).  Or, when writing a script to read the next few lines
     following a pattern match, traditional implementations of ‘sed’
     would force you to write something like
          /foo/{ $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N }
     instead of just
          /foo/{ N;N;N;N;N;N;N;N;N; }

     In any case, the simplest workaround is to use ‘$d;N’ in scripts
     that rely on the traditional behavior, or to set the
     ‘POSIXLY_CORRECT’ variable to a non-empty value.

Regex syntax clashes (problems with backslashes)
     ‘sed’ uses the POSIX basic regular expression syntax.  According to
     the standard, the meaning of some escape sequences is undefined in
     this syntax; notable in the case of ‘sed’ are ‘\|’, ‘\+’, ‘\?’,
     ‘\`’, ‘\'’, ‘\<’, ‘\>’, ‘\b’, ‘\B’, ‘\w’, and ‘\W’.

     As in all GNU programs that use POSIX basic regular expressions,
     ‘sed’ interprets these escape sequences as special characters.  So,
     ‘x\+’ matches one or more occurrences of ‘x’.  ‘abc\|def’ matches
     either ‘abc’ or ‘def’.

     This syntax may cause problems when running scripts written for
     other ‘sed’s.  Some ‘sed’ programs have been written with the
     assumption that ‘\|’ and ‘\+’ match the literal characters ‘|’ and
     ‘+’.  Such scripts must be modified by removing the spurious
     backslashes if they are to be used with modern implementations of
     ‘sed’, like GNU ‘sed’.

     On the other hand, some scripts use s|abc\|def||g to remove
     occurrences of _either_ ‘abc’ or ‘def’.  While this worked until
     ‘sed’ 4.0.x, newer versions interpret this as removing the string
     ‘abc|def’.  This is again undefined behavior according to POSIX,
     and this interpretation is arguably more robust: older ‘sed’s, for
     example, required that the regex matcher parsed ‘\/’ as ‘/’ in the
     common case of escaping a slash, which is again undefined behavior;
     the new behavior avoids this, and this is good because the regex
     matcher is only partially under our control.

     In addition, this version of ‘sed’ supports several escape
     characters (some of which are multi-character) to insert
     non-printable characters in scripts (‘\a’, ‘\c’, ‘\d’, ‘\o’, ‘\r’,
     ‘\t’, ‘\v’, ‘\x’).  These can cause similar problems with scripts
     written for other ‘sed’s.

‘-i’ clobbers read-only files

     In short, ‘sed -i’ will let you delete the contents of a read-only
     file, and in general the ‘-i’ option (*note Invocation: Invoking
     sed.) lets you clobber protected files.  This is not a bug, but
     rather a consequence of how the Unix file system works.

     The permissions on a file say what can happen to the data in that
     file, while the permissions on a directory say what can happen to
     the list of files in that directory.  ‘sed -i’ will not ever open
     for writing a file that is already on disk.  Rather, it will work
     on a temporary file that is finally renamed to the original name:
     if you rename or delete files, you’re actually modifying the
     contents of the directory, so the operation depends on the
     permissions of the directory, not of the file.  For this same
     reason, ‘sed’ does not let you use ‘-i’ on a writable file in a
     read-only directory, and will break hard or symbolic links when
     ‘-i’ is used on such a file.

‘0a’ does not work (gives an error)

     There is no line 0.  0 is a special address that is only used to
     treat addresses like ‘0,/RE/’ as active when the script starts: if
     you write ‘1,/abc/d’ and the first line includes the string ‘abc’,
     then that match would be ignored because address ranges must span
     at least two lines (barring the end of the file); but what you
     probably wanted is to delete every line up to the first one
     including ‘abc’, and this is obtained with ‘0,/abc/d’.

‘[a-z]’ is case insensitive

     You are encountering problems with locales.  POSIX mandates that
     ‘[a-z]’ uses the current locale’s collation order – in C parlance,
     that means using ‘strcoll(3)’ instead of ‘strcmp(3)’.  Some locales
     have a case-insensitive collation order, others don’t.

     Another problem is that ‘[a-z]’ tries to use collation symbols.
     This only happens if you are on the GNU system, using GNU libc’s
     regular expression matcher instead of compiling the one supplied
     with GNU sed.  In a Danish locale, for example, the regular
     expression ‘^[a-z]$’ matches the string ‘aa’, because this is a
     single collating symbol that comes after ‘a’ and before ‘b’; ‘ll’
     behaves similarly in Spanish locales, or ‘ij’ in Dutch locales.

     To work around these problems, which may cause bugs in shell
     scripts, set the ‘LC_COLLATE’ and ‘LC_CTYPE’ environment variables
     to ‘C’.

‘s/.*//’ does not clear pattern space

     This happens if your input stream includes invalid multibyte
     sequences.  POSIX mandates that such sequences are _not_ matched by
     ‘.’, so that ‘s/.*//’ will not clear pattern space as you would
     expect.  In fact, there is no way to clear sed’s buffers in the
     middle of the script in most multibyte locales (including UTF-8
     locales).  For this reason, GNU ‘sed’ provides a ‘z’ command (for
     ‘zap’) as an extension.

     To work around these problems, which may cause bugs in shell
     scripts, set the ‘LC_COLLATE’ and ‘LC_CTYPE’ environment variables
     to ‘C’.

   ---------- Footnotes ----------

   (1) which is the actual “bug” that prompted the change in behavior


File: sed.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: Reporting Bugs,  Up: Top

Appendix A GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <https://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <https://www.gnu.org/licenses/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: sed.info,  Node: Concept Index,  Next: Command and Option Index,  Prev: GNU Free Documentation License,  Up: Top

Concept Index
*************

This is a general index of all issues discussed in this manual, with the
exception of the ‘sed’ commands and command-line options.

 [index ]
* Menu:

* -e, example:                           Overview.            (line  46)
* -e, example <1>:                       sed script overview. (line  37)
* –expression, example:                  Overview.            (line  46)
* -f, example:                           Overview.            (line  46)
* -f, example <1>:                       sed script overview. (line  37)
* –file, example:                        Overview.            (line  46)
* -i, example:                           Overview.            (line  26)
* -n, example:                           Overview.            (line  33)
* -s, example:                           Overview.            (line  40)
* 0 address:                             Reporting Bugs.      (line 114)
* ;, command separator:                  sed script overview. (line  37)
* a, and semicolons:                     sed script overview. (line  56)
* Additional reading about sed:          Other Resources.     (line  13)
* ADDR1,+N:                              Range Addresses.     (line  31)
* ADDR1,~N:                              Range Addresses.     (line  31)
* address range, example:                sed script overview. (line  23)
* Address, as a regular expression:      Regexp Addresses.    (line  13)
* Address, last line:                    Numeric Addresses.   (line  13)
* Address, numeric:                      Numeric Addresses.   (line   8)
* addresses, excluding:                  Addresses overview.  (line  33)
* Addresses, in sed scripts:             Numeric Addresses.   (line   6)
* addresses, negating:                   Addresses overview.  (line  33)
* addresses, numeric:                    Addresses overview.  (line   6)
* addresses, range:                      Addresses overview.  (line  26)
* addresses, regular expression:         Addresses overview.  (line  20)
* addresses, syntax:                     sed script overview. (line  13)
* alphabetic characters:                 Character Classes and Bracket Expressions.
                                                              (line  49)
* alphanumeric characters:               Character Classes and Bracket Expressions.
                                                              (line  44)
* Append hold space to pattern space:    Other Commands.      (line 288)
* Append next input line to pattern space: Other Commands.    (line 261)
* Append pattern space to hold space:    Other Commands.      (line 280)
* Appending text after a line:           Other Commands.      (line  45)
* b, joining lines with:                 Branching and flow control.
                                                              (line 150)
* b, versus t:                           Branching and flow control.
                                                              (line 150)
* back-reference:                        Back-references and Subexpressions.
                                                              (line   6)
* Backreferences, in regular expressions: The "s" Command.    (line  18)
* blank characters:                      Character Classes and Bracket Expressions.
                                                              (line  54)
* bracket expression:                    Character Classes and Bracket Expressions.
                                                              (line   6)
* Branch to a label, if s/// failed:     Extended Commands.   (line  63)
* Branch to a label, if s/// succeeded:  Programming Commands.
                                                              (line  22)
* Branch to a label, unconditionally:    Programming Commands.
                                                              (line  18)
* branching and n, N:                    Branching and flow control.
                                                              (line 105)
* branching, infinite loop:              Branching and flow control.
                                                              (line  95)
* branching, joining lines:              Branching and flow control.
                                                              (line 150)
* Buffer spaces, pattern and hold:       Execution Cycle.     (line   6)
* Bugs, reporting:                       Reporting Bugs.      (line   6)
* c, and semicolons:                     sed script overview. (line  56)
* case insensitive, regular expression:  Regexp Addresses.    (line  47)
* Case-insensitive matching:             The "s" Command.     (line 117)
* Caveat — #n on first line:             Common Commands.     (line  20)
* character class:                       Character Classes and Bracket Expressions.
                                                              (line   6)
* character classes:                     Character Classes and Bracket Expressions.
                                                              (line  43)
* classes of characters:                 Character Classes and Bracket Expressions.
                                                              (line  43)
* Command groups:                        Common Commands.     (line  91)
* Comments, in scripts:                  Common Commands.     (line  12)
* Conditional branch:                    Programming Commands.
                                                              (line  22)
* Conditional branch <1>:                Extended Commands.   (line  63)
* control characters:                    Character Classes and Bracket Expressions.
                                                              (line  57)
* Copy hold space into pattern space:    Other Commands.      (line 284)
* Copy pattern space into hold space:    Other Commands.      (line 276)
* cycle, restarting:                     Branching and flow control.
                                                              (line  75)
* d, example:                            sed script overview. (line  23)
* Delete first line from pattern space:  Other Commands.      (line 255)
* digit characters:                      Character Classes and Bracket Expressions.
                                                              (line  62)
* Disabling autoprint, from command line: Command-Line Options.
                                                              (line  23)
* empty regular expression:              Regexp Addresses.    (line  22)
* Emptying pattern space:                Extended Commands.   (line  85)
* Emptying pattern space <1>:            Reporting Bugs.      (line 143)
* Evaluate Bourne-shell commands:        Extended Commands.   (line  12)
* Evaluate Bourne-shell commands, after substitution: The "s" Command.
                                                              (line 108)
* example, address range:                sed script overview. (line  23)
* example, regular expression:           sed script overview. (line  28)
* Exchange hold space with pattern space: Other Commands.     (line 292)
* Excluding lines:                       Addresses overview.  (line  33)
* exit status:                           Exit status.         (line   6)
* exit status, example:                  Exit status.         (line  25)
* Extended regular expressions, choosing: Command-Line Options.
                                                              (line 135)
* Extended regular expressions, syntax:  ERE syntax.          (line   6)
* File name, printing:                   Extended Commands.   (line  30)
* Files to be processed as input:        Command-Line Options.
                                                              (line 181)
* Flow of control in scripts:            Programming Commands.
                                                              (line  11)
* Global substitution:                   The "s" Command.     (line  74)
* GNU extensions, /dev/stderr file:      The "s" Command.     (line 101)
* GNU extensions, /dev/stderr file <1>:  Other Commands.      (line 244)
* GNU extensions, /dev/stdin file:       Other Commands.      (line 227)
* GNU extensions, /dev/stdin file <1>:   Extended Commands.   (line  53)
* GNU extensions, /dev/stdout file:      Command-Line Options.
                                                              (line 189)
* GNU extensions, /dev/stdout file <1>:  The "s" Command.     (line 101)
* GNU extensions, /dev/stdout file <2>:  Other Commands.      (line 244)
* GNU extensions, 0 address:             Range Addresses.     (line  31)
* GNU extensions, 0 address <1>:         Reporting Bugs.      (line 114)
* GNU extensions, 0,ADDR2 addressing:    Range Addresses.     (line  31)
* GNU extensions, ADDR1,+N addressing:   Range Addresses.     (line  31)
* GNU extensions, ADDR1,~N addressing:   Range Addresses.     (line  31)
* GNU extensions, branch if s/// failed: Extended Commands.   (line  63)
* GNU extensions, case modifiers in s commands: The "s" Command.
                                                              (line  29)
* GNU extensions, checking for their presence: Extended Commands.
                                                              (line  69)
* GNU extensions, debug:                 Command-Line Options.
                                                              (line  29)
* GNU extensions, disabling:             Command-Line Options.
                                                              (line 102)
* GNU extensions, emptying pattern space: Extended Commands.  (line  85)
* GNU extensions, emptying pattern space <1>: Reporting Bugs. (line 143)
* GNU extensions, evaluating Bourne-shell commands: The "s" Command.
                                                              (line 108)
* GNU extensions, evaluating Bourne-shell commands <1>: Extended Commands.
                                                              (line  12)
* GNU extensions, extended regular expressions: Command-Line Options.
                                                              (line 135)
* GNU extensions, g and NUMBER modifier: The "s" Command.     (line  80)
* GNU extensions, I modifier:            The "s" Command.     (line 117)
* GNU extensions, I modifier <1>:        Regexp Addresses.    (line  47)
* GNU extensions, in-place editing:      Command-Line Options.
                                                              (line  56)
* GNU extensions, in-place editing <1>:  Reporting Bugs.      (line  95)
* GNU extensions, M modifier:            The "s" Command.     (line 122)
* GNU extensions, M modifier <1>:        Regexp Addresses.    (line  75)
* GNU extensions, modifiers and the empty regular expression: Regexp Addresses.
                                                              (line  22)
* GNU extensions, N~M addresses:         Numeric Addresses.   (line  18)
* GNU extensions, quitting silently:     Extended Commands.   (line  36)
* GNU extensions, R command:             Extended Commands.   (line  53)
* GNU extensions, reading a file a line at a time: Extended Commands.
                                                              (line  53)
* GNU extensions, returning an exit code: Common Commands.    (line  28)
* GNU extensions, returning an exit code <1>: Extended Commands.
                                                              (line  36)
* GNU extensions, setting line length:   Other Commands.      (line 207)
* GNU extensions, special escapes:       Escapes.             (line   6)
* GNU extensions, special escapes <1>:   Reporting Bugs.      (line  88)
* GNU extensions, special two-address forms: Range Addresses. (line  31)
* GNU extensions, subprocesses:          The "s" Command.     (line 108)
* GNU extensions, subprocesses <1>:      Extended Commands.   (line  12)
* GNU extensions, to basic regular expressions: BRE syntax.   (line  13)
* GNU extensions, to basic regular expressions <1>: BRE syntax.
                                                              (line  59)
* GNU extensions, to basic regular expressions <2>: BRE syntax.
                                                              (line  62)
* GNU extensions, to basic regular expressions <3>: BRE syntax.
                                                              (line  77)
* GNU extensions, to basic regular expressions <4>: BRE syntax.
                                                              (line  87)
* GNU extensions, to basic regular expressions <5>: Reporting Bugs.
                                                              (line  61)
* GNU extensions, two addresses supported by most commands: Other Commands.
                                                              (line  61)
* GNU extensions, two addresses supported by most commands <1>: Other Commands.
                                                              (line 115)
* GNU extensions, two addresses supported by most commands <2>: Other Commands.
                                                              (line 204)
* GNU extensions, two addresses supported by most commands <3>: Other Commands.
                                                              (line 236)
* GNU extensions, unlimited line length: Limitations.         (line   6)
* GNU extensions, writing first line to a file: Extended Commands.
                                                              (line  80)
* Goto, in scripts:                      Programming Commands.
                                                              (line  18)
* graphic characters:                    Character Classes and Bracket Expressions.
                                                              (line  65)
* Greedy regular expression matching:    BRE syntax.          (line 113)
* Grouping commands:                     Common Commands.     (line  91)
* hexadecimal digits:                    Character Classes and Bracket Expressions.
                                                              (line  88)
* Hold space, appending from pattern space: Other Commands.   (line 280)
* Hold space, appending to pattern space: Other Commands.     (line 288)
* Hold space, copy into pattern space:   Other Commands.      (line 284)
* Hold space, copying pattern space into: Other Commands.     (line 276)
* Hold space, definition:                Execution Cycle.     (line   6)
* Hold space, exchange with pattern space: Other Commands.    (line 292)
* i, and semicolons:                     sed script overview. (line  56)
* In-place editing:                      Reporting Bugs.      (line  95)
* In-place editing, activating:          Command-Line Options.
                                                              (line  56)
* In-place editing, Perl-style backup file names: Command-Line Options.
                                                              (line  67)
* infinite loop, branching:              Branching and flow control.
                                                              (line  95)
* Inserting text before a line:          Other Commands.      (line 104)
* joining lines with branching:          Branching and flow control.
                                                              (line 150)
* joining quoted-printable lines:        Branching and flow control.
                                                              (line 150)
* labels:                                Branching and flow control.
                                                              (line  75)
* Labels, in scripts:                    Programming Commands.
                                                              (line  14)
* Last line, selecting:                  Numeric Addresses.   (line  13)
* Line length, setting:                  Command-Line Options.
                                                              (line  97)
* Line length, setting <1>:              Other Commands.      (line 207)
* Line number, printing:                 Other Commands.      (line 194)
* Line selection:                        Numeric Addresses.   (line   6)
* Line, selecting by number:             Numeric Addresses.   (line   8)
* Line, selecting by regular expression match: Regexp Addresses.
                                                              (line  13)
* Line, selecting last:                  Numeric Addresses.   (line  13)
* List pattern space:                    Other Commands.      (line 207)
* lower-case letters:                    Character Classes and Bracket Expressions.
                                                              (line  68)
* Mixing g and NUMBER modifiers in the s command: The "s" Command.
                                                              (line  80)
* multiple files:                        Overview.            (line  40)
* multiple sed commands:                 sed script overview. (line  37)
* n, and branching:                      Branching and flow control.
                                                              (line 105)
* N, and branching:                      Branching and flow control.
                                                              (line 105)
* named character classes:               Character Classes and Bracket Expressions.
                                                              (line  43)
* newline, command separator:            sed script overview. (line  37)
* Next input line, append to pattern space: Other Commands.   (line 261)
* Next input line, replace pattern space with: Common Commands.
                                                              (line  61)
* Non-bugs, 0 address:                   Reporting Bugs.      (line 114)
* Non-bugs, in-place editing:            Reporting Bugs.      (line  95)
* Non-bugs, localization-related:        Reporting Bugs.      (line 124)
* Non-bugs, localization-related <1>:    Reporting Bugs.      (line 143)
* Non-bugs, N command on the last line:  Reporting Bugs.      (line  30)
* Non-bugs, regex syntax clashes:        Reporting Bugs.      (line  61)
* numeric addresses:                     Addresses overview.  (line   6)
* numeric characters:                    Character Classes and Bracket Expressions.
                                                              (line  62)
* omitting labels:                       Branching and flow control.
                                                              (line  75)
* output:                                Overview.            (line  26)
* output, suppressing:                   Overview.            (line  33)
* p, example:                            Overview.            (line  33)
* paragraphs, processing:                Multiline techniques.
                                                              (line  53)
* parameters, script:                    Overview.            (line  46)
* Parenthesized substrings:              The "s" Command.     (line  18)
* Pattern space, definition:             Execution Cycle.     (line   6)
* Portability, comments:                 Common Commands.     (line  15)
* Portability, line length limitations:  Limitations.         (line   6)
* Portability, N command on the last line: Reporting Bugs.    (line  30)
* POSIXLY_CORRECT behavior, bracket expressions: Character Classes and Bracket Expressions.
                                                              (line 112)
* POSIXLY_CORRECT behavior, enabling:    Command-Line Options.
                                                              (line 105)
* POSIXLY_CORRECT behavior, escapes:     Escapes.             (line  11)
* POSIXLY_CORRECT behavior, N command:   Reporting Bugs.      (line  56)
* Print first line from pattern space:   Other Commands.      (line 273)
* printable characters:                  Character Classes and Bracket Expressions.
                                                              (line  72)
* Printing file name:                    Extended Commands.   (line  30)
* Printing line number:                  Other Commands.      (line 194)
* Printing text unambiguously:           Other Commands.      (line 207)
* processing paragraphs:                 Multiline techniques.
                                                              (line  53)
* punctuation characters:                Character Classes and Bracket Expressions.
                                                              (line  75)
* Q, example:                            Exit status.         (line  25)
* q, example:                            sed script overview. (line  28)
* Quitting:                              Common Commands.     (line  28)
* Quitting <1>:                          Extended Commands.   (line  36)
* quoted-printable lines, joining:       Branching and flow control.
                                                              (line 150)
* range addresses:                       Addresses overview.  (line  26)
* range expression:                      Character Classes and Bracket Expressions.
                                                              (line  18)
* Range of lines:                        Range Addresses.     (line   6)
* Range with start address of zero:      Range Addresses.     (line  31)
* Read next input line:                  Common Commands.     (line  61)
* Read text from a file:                 Other Commands.      (line 219)
* Read text from a file <1>:             Extended Commands.   (line  53)
* regex addresses and input lines:       Regexp Addresses.    (line  84)
* regex addresses and pattern space:     Regexp Addresses.    (line  84)
* regular expression addresses:          Addresses overview.  (line  20)
* regular expression, example:           sed script overview. (line  28)
* Replace hold space with copy of pattern space: Other Commands.
                                                              (line 276)
* Replace pattern space with copy of hold space: Other Commands.
                                                              (line 284)
* Replacing all text matching regexp in a line: The "s" Command.
                                                              (line  74)
* Replacing only Nth match of regexp in a line: The "s" Command.
                                                              (line  78)
* Replacing selected lines with other text: Other Commands.   (line 157)
* Requiring GNU sed:                     Extended Commands.   (line  69)
* restarting a cycle:                    Branching and flow control.
                                                              (line  75)
* Sandbox mode:                          Command-Line Options.
                                                              (line 157)
* script parameter:                      Overview.            (line  46)
* Script structure:                      sed script overview. (line   6)
* Script, from a file:                   Command-Line Options.
                                                              (line  51)
* Script, from command line:             Command-Line Options.
                                                              (line  46)
* sed commands syntax:                   sed script overview. (line  13)
* sed commands, multiple:                sed script overview. (line  37)
* sed script structure:                  sed script overview. (line   6)
* Selecting lines to process:            Numeric Addresses.   (line   6)
* Selecting non-matching lines:          Addresses overview.  (line  33)
* semicolons, command separator:         sed script overview. (line  37)
* Several lines, selecting:              Range Addresses.     (line   6)
* Slash character, in regular expressions: Regexp Addresses.  (line  32)
* space characters:                      Character Classes and Bracket Expressions.
                                                              (line  80)
* Spaces, pattern and hold:              Execution Cycle.     (line   6)
* Special addressing forms:              Range Addresses.     (line  31)
* standard input:                        Overview.            (line  18)
* Standard input, processing as input:   Command-Line Options.
                                                              (line 183)
* standard output:                       Overview.            (line  26)
* stdin:                                 Overview.            (line  18)
* stdout:                                Overview.            (line  26)
* Stream editor:                         Introduction.        (line   6)
* subexpression:                         Back-references and Subexpressions.
                                                              (line   6)
* Subprocesses:                          The "s" Command.     (line 108)
* Subprocesses <1>:                      Extended Commands.   (line  12)
* Substitution of text, options:         The "s" Command.     (line  70)
* suppressing output:                    Overview.            (line  33)
* syntax, addresses:                     sed script overview. (line  13)
* syntax, sed commands:                  sed script overview. (line  13)
* t, joining lines with:                 Branching and flow control.
                                                              (line 150)
* t, versus b:                           Branching and flow control.
                                                              (line 150)
* Text, appending:                       Other Commands.      (line  45)
* Text, deleting:                        Common Commands.     (line  44)
* Text, insertion:                       Other Commands.      (line 104)
* Text, printing:                        Common Commands.     (line  52)
* Text, printing after substitution:     The "s" Command.     (line  88)
* Text, writing to a file after substitution: The "s" Command.
                                                              (line 101)
* Transliteration:                       Other Commands.      (line  11)
* Unbuffered I/O, choosing:              Command-Line Options.
                                                              (line 164)
* upper-case letters:                    Character Classes and Bracket Expressions.
                                                              (line  84)
* Usage summary, printing:               Command-Line Options.
                                                              (line  17)
* Version, printing:                     Command-Line Options.
                                                              (line  13)
* whitespace characters:                 Character Classes and Bracket Expressions.
                                                              (line  80)
* Working on separate files:             Command-Line Options.
                                                              (line 148)
* Write first line to a file:            Extended Commands.   (line  80)
* Write to a file:                       Other Commands.      (line 244)
* xdigit class:                          Character Classes and Bracket Expressions.
                                                              (line  88)
* Zero Address:                          Zero Address.        (line   6)
* Zero, as range start address:          Range Addresses.     (line  31)


File: sed.info,  Node: Command and Option Index,  Prev: Concept Index,  Up: Top

Command and Option Index
************************

This is an alphabetical list of all ‘sed’ commands and command-line
options.

 [index ]
* Menu:

* # (comments):                          Common Commands.     (line  12)
* --binary:                              Command-Line Options.
                                                              (line 114)
* --debug:                               Command-Line Options.
                                                              (line  29)
* --expression:                          Command-Line Options.
                                                              (line  46)
* --file:                                Command-Line Options.
                                                              (line  51)
* --follow-symlinks:                     Command-Line Options.
                                                              (line 125)
* --help:                                Command-Line Options.
                                                              (line  17)
* --in-place:                            Command-Line Options.
                                                              (line  56)
* --line-length:                         Command-Line Options.
                                                              (line  97)
* --null-data:                           Command-Line Options.
                                                              (line 172)
* --posix:                               Command-Line Options.
                                                              (line 102)
* --quiet:                               Command-Line Options.
                                                              (line  23)
* --regexp-extended:                     Command-Line Options.
                                                              (line 135)
* --sandbox:                             Command-Line Options.
                                                              (line 157)
* --separate:                            Command-Line Options.
                                                              (line 148)
* --silent:                              Command-Line Options.
                                                              (line  23)
* --unbuffered:                          Command-Line Options.
                                                              (line 164)
* --version:                             Command-Line Options.
                                                              (line  13)
* --zero-terminated:                     Command-Line Options.
                                                              (line 172)
* -b:                                    Command-Line Options.
                                                              (line 114)
* -e:                                    Command-Line Options.
                                                              (line  46)
* -E:                                    Command-Line Options.
                                                              (line 135)
* -f:                                    Command-Line Options.
                                                              (line  51)
* -i:                                    Command-Line Options.
                                                              (line  56)
* -l:                                    Command-Line Options.
                                                              (line  97)
* -n:                                    Command-Line Options.
                                                              (line  23)
* -n, forcing from within a script:      Common Commands.     (line  20)
* -r:                                    Command-Line Options.
                                                              (line 135)
* -s:                                    Command-Line Options.
                                                              (line 148)
* -u:                                    Command-Line Options.
                                                              (line 164)
* -z:                                    Command-Line Options.
                                                              (line 172)
* : (label) command:                     Programming Commands.
                                                              (line  14)
* = (print line number) command:         Other Commands.      (line 194)
* {} command grouping:                   Common Commands.     (line  91)
* a (append text lines) command:         Other Commands.      (line  45)
* alnum character class:                 Character Classes and Bracket Expressions.
                                                              (line  44)
* alpha character class:                 Character Classes and Bracket Expressions.
                                                              (line  49)
* b (branch) command:                    Programming Commands.
                                                              (line  18)
* blank character class:                 Character Classes and Bracket Expressions.
                                                              (line  54)
* c (change to text lines) command:      Other Commands.      (line 157)
* cntrl character class:                 Character Classes and Bracket Expressions.
                                                              (line  57)
* D (delete first line) command:         Other Commands.      (line 255)
* d (delete) command:                    Common Commands.     (line  44)
* digit character class:                 Character Classes and Bracket Expressions.
                                                              (line  62)
* e (evaluate) command:                  Extended Commands.   (line  12)
* F (File name) command:                 Extended Commands.   (line  30)
* G (appending Get) command:             Other Commands.      (line 288)
* g (get) command:                       Other Commands.      (line 284)
* graph character class:                 Character Classes and Bracket Expressions.
                                                              (line  65)
* H (append Hold) command:               Other Commands.      (line 280)
* h (hold) command:                      Other Commands.      (line 276)
* i (insert text lines) command:         Other Commands.      (line 104)
* l (list unambiguously) command:        Other Commands.      (line 207)
* lower character class:                 Character Classes and Bracket Expressions.
                                                              (line  68)
* N (append Next line) command:          Other Commands.      (line 261)
* n (next-line) command:                 Common Commands.     (line  61)
* P (print first line) command:          Other Commands.      (line 273)
* p (print) command:                     Common Commands.     (line  52)
* print character class:                 Character Classes and Bracket Expressions.
                                                              (line  72)
* punct character class:                 Character Classes and Bracket Expressions.
                                                              (line  75)
* q (quit) command:                      Common Commands.     (line  28)
* Q (silent Quit) command:               Extended Commands.   (line  36)
* r (read file) command:                 Other Commands.      (line 219)
* R (read line) command:                 Extended Commands.   (line  53)
* s command, option flags:               The "s" Command.     (line  70)
* space character class:                 Character Classes and Bracket Expressions.
                                                              (line  80)
* T (test and branch if failed) command: Extended Commands.   (line  63)
* t (test and branch if successful) command: Programming Commands.
                                                              (line  22)
* upper character class:                 Character Classes and Bracket Expressions.
                                                              (line  84)
* v (version) command:                   Extended Commands.   (line  69)
* w (write file) command:                Other Commands.      (line 244)
* W (write first line) command:          Extended Commands.   (line  80)
* x (eXchange) command:                  Other Commands.      (line 292)
* xdigit character class:                Character Classes and Bracket Expressions.
                                                              (line  88)
* y (transliterate) command:             Other Commands.      (line  11)
* z (Zap) command:                       Extended Commands.   (line  85)



Tag Table:
Node: Top738
Node: Introduction2217
Node: Invoking sed2789
Node: Overview3114
Node: Command-Line Options5561
Ref: Command-Line Options-Footnote-113530
Ref: Command-Line Options-Footnote-213758
Node: Exit status13861
Node: sed scripts14795
Node: sed script overview15394
Node: sed commands list18057
Node: The "s" Command23070
Ref: The "s" Command-Footnote-128889
Node: Common Commands28969
Node: Other Commands32106
Ref: insert command35324
Ref: Other Commands-Footnote-141629
Node: Programming Commands41709
Node: Extended Commands42649
Node: Multiple commands syntax46675
Node: sed addresses51217
Node: Addresses overview51706
Node: Numeric Addresses53705
Node: Regexp Addresses55116
Ref: Regexp Addresses-Footnote-159252
Node: Range Addresses59392
Ref: Zero Address Regex Range60294
Node: Zero Address61753
Node: sed regular expressions62318
Node: Regular Expressions Overview63172
Node: BRE vs ERE64733
Node: BRE syntax66484
Node: ERE syntax73304
Node: Character Classes and Bracket Expressions74878
Node: regexp extensions80030
Node: Back-references and Subexpressions82506
Node: Escapes84958
Ref: Escapes-Footnote-188105
Node: Locale Considerations88304
Ref: Locale Considerations-Footnote-193067
Node: advanced sed93239
Node: Execution Cycle93606
Ref: Execution Cycle-Footnote-194845
Node: Hold and Pattern Buffers95162
Node: Multiline techniques95350
Node: Branching and flow control98704
Node: Examples107029
Node: Joining lines108275
Node: Centering lines110082
Node: Increment a number111006
Ref: Increment a number-Footnote-1112495
Node: Rename files to lower case112623
Node: Print bash environment115418
Node: Reverse chars of lines116181
Ref: Reverse chars of lines-Footnote-1117224
Node: Text search across multiple lines117441
Node: Line length adjustment120786
Node: Adding a header to multiple files122533
Node: tac125986
Node: cat -n126774
Node: cat -b128616
Node: wc -c129378
Ref: wc -c-Footnote-1131316
Node: wc -w131385
Node: wc -l132875
Node: head133128
Node: tail133467
Node: uniq135196
Node: uniq -d136007
Node: uniq -u136722
Node: cat -s137435
Node: Limitations139298
Node: Other Resources140161
Node: Reporting Bugs141104
Ref: N_command_last_line142294
Ref: Reporting Bugs-Footnote-1148805
Node: GNU Free Documentation License148880
Node: Concept Index174239
Node: Command and Option Index201600

End Tag Table


Local Variables:
coding: utf-8
End:

Index: src/crypto.c
===================================================================
--- src/crypto.c	(revision 41436)
+++ src/crypto.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -19,10 +19,12 @@
 #ifdef HAVE_DNSSEC
 
 #include <nettle/rsa.h>
-#include <nettle/dsa.h>
 #include <nettle/ecdsa.h>
 #include <nettle/ecc-curve.h>
 #include <nettle/eddsa.h>
+#if NETTLE_VERSION_MAJOR == 3 && NETTLE_VERSION_MINOR >= 6
+#  include <nettle/gostdsa.h>
+#endif
 #include <nettle/nettle-meta.h>
 #include <nettle/bignum.h>
 
@@ -207,8 +209,6 @@
   
   switch (algo)
     {
-    case 1:
-      return nettle_rsa_md5_verify_digest(key, digest, sig_mpz);
     case 5: case 7:
       return nettle_rsa_sha1_verify_digest(key, digest, sig_mpz);
     case 8:
@@ -220,50 +220,6 @@
   return 0;
 }  
 
-static int dnsmasq_dsa_verify(struct blockdata *key_data, unsigned int key_len, unsigned char *sig, size_t sig_len,
-			      unsigned char *digest, size_t digest_len, int algo)
-{
-  unsigned char *p;
-  unsigned int t;
-
-  static mpz_t y;
-  static struct dsa_params *params = NULL;
-  static struct dsa_signature *sig_struct;
-  
-  (void)digest_len;
-
-  if (params == NULL)
-    {
-      if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))) || 
-	  !(params = whine_malloc(sizeof(struct dsa_params)))) 
-	return 0;
-      
-      mpz_init(y);
-      nettle_dsa_params_init(params);
-      nettle_dsa_signature_init(sig_struct);
-    }
-  
-  if ((sig_len < 41) || !(p = blockdata_retrieve(key_data, key_len, NULL)))
-    return 0;
-  
-  t = *p++;
-  
-  if (key_len < (213 + (t * 24)))
-    return 0;
-  
-  mpz_import(params->q, 20, 1, 1, 0, 0, p); p += 20;
-  mpz_import(params->p, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  mpz_import(params->g, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  mpz_import(y, 64 + (t*8), 1, 1, 0, 0, p); p += 64 + (t*8);
-  
-  mpz_import(sig_struct->r, 20, 1, 1, 0, 0, sig+1);
-  mpz_import(sig_struct->s, 20, 1, 1, 0, 0, sig+21);
-  
-  (void)algo;
-  
-  return nettle_dsa_verify(params, y, digest_len, digest, sig_struct);
-} 
- 
 static int dnsmasq_ecdsa_verify(struct blockdata *key_data, unsigned int key_len, 
 				unsigned char *sig, size_t sig_len,
 				unsigned char *digest, size_t digest_len, int algo)
@@ -275,6 +231,10 @@
   static struct ecc_point *key_256 = NULL, *key_384 = NULL;
   static mpz_t x, y;
   static struct dsa_signature *sig_struct;
+#if NETTLE_VERSION_MAJOR == 3 && NETTLE_VERSION_MINOR < 4
+#define nettle_get_secp_256r1() (&nettle_secp_256r1)
+#define nettle_get_secp_384r1() (&nettle_secp_384r1)
+#endif
   
   if (!sig_struct)
     {
@@ -334,6 +294,47 @@
   return nettle_ecdsa_verify(key, digest_len, digest, sig_struct);
 }
 
+#if NETTLE_VERSION_MAJOR == 3 && NETTLE_VERSION_MINOR >= 6
+static int dnsmasq_gostdsa_verify(struct blockdata *key_data, unsigned int key_len, 
+				  unsigned char *sig, size_t sig_len,
+				  unsigned char *digest, size_t digest_len, int algo)
+{
+  unsigned char *p;
+  
+  static struct ecc_point *gost_key = NULL;
+  static mpz_t x, y;
+  static struct dsa_signature *sig_struct;
+
+  if (algo != 12 ||
+      sig_len != 64 || key_len != 64 ||
+      !(p = blockdata_retrieve(key_data, key_len, NULL)))
+    return 0;
+  
+  if (!sig_struct)
+    {
+      if (!(sig_struct = whine_malloc(sizeof(struct dsa_signature))) ||
+	  !(gost_key = whine_malloc(sizeof(struct ecc_point))))
+	return 0;
+      
+      nettle_dsa_signature_init(sig_struct);
+      nettle_ecc_point_init(gost_key, nettle_get_gost_gc256b());
+      mpz_init(x);
+      mpz_init(y);
+    }
+    
+  mpz_import(x, 32 , 1, 1, 0, 0, p);
+  mpz_import(y, 32 , 1, 1, 0, 0, p + 32);
+
+  if (!ecc_point_set(gost_key, x, y))
+    return 0;
+  
+  mpz_import(sig_struct->r, 32, 1, 1, 0, 0, sig);
+  mpz_import(sig_struct->s, 32, 1, 1, 0, 0, sig + 32);
+  
+  return nettle_gostdsa_verify(gost_key, digest_len, digest, sig_struct);
+}
+#endif
+
 static int dnsmasq_eddsa_verify(struct blockdata *key_data, unsigned int key_len, 
 				unsigned char *sig, size_t sig_len,
 				unsigned char *digest, size_t digest_len, int algo)
@@ -340,9 +341,7 @@
 {
   unsigned char *p;
    
-  if (key_len != ED25519_KEY_SIZE ||
-      sig_len != ED25519_SIGNATURE_SIZE ||
-      digest_len != sizeof(struct null_hash_digest) ||
+  if (digest_len != sizeof(struct null_hash_digest) ||
       !(p = blockdata_retrieve(key_data, key_len, NULL)))
     return 0;
   
@@ -353,13 +352,27 @@
   switch (algo)
     {
     case 15:
+      if (key_len != ED25519_KEY_SIZE ||
+	  sig_len != ED25519_SIGNATURE_SIZE)
+	return 0;
+
       return ed25519_sha512_verify(p,
 				   ((struct null_hash_digest *)digest)->len,
 				   ((struct null_hash_digest *)digest)->buff,
 				   sig);
+      
+#if NETTLE_VERSION_MAJOR == 3 && NETTLE_VERSION_MINOR >= 6
     case 16:
-      /* Ed448 when available */
-      return 0;
+      if (key_len != ED448_KEY_SIZE ||
+	  sig_len != ED448_SIGNATURE_SIZE)
+	return 0;
+
+      return ed448_shake256_verify(p,
+				   ((struct null_hash_digest *)digest)->len,
+				   ((struct null_hash_digest *)digest)->buff,
+				   sig);
+#endif
+
     }
 
   return 0;
@@ -369,7 +382,7 @@
 			     unsigned char *digest, size_t digest_len, int algo)
 {
     
-  /* Enure at runtime that we have support for this digest */
+  /* Ensure at runtime that we have support for this digest */
   if (!hash_find(algo_digest_name(algo)))
     return NULL;
   
@@ -376,12 +389,14 @@
   /* This switch defines which sig algorithms we support, can't introspect Nettle for that. */
   switch (algo)
     {
-    case 1: case 5: case 7: case 8: case 10:
+    case 5: case 7: case 8: case 10:
       return dnsmasq_rsa_verify;
+
+#if NETTLE_VERSION_MAJOR == 3 && NETTLE_VERSION_MINOR >= 6
+    case 12:
+      return dnsmasq_gostdsa_verify;
+#endif
       
-    case 3: case 6: 
-      return dnsmasq_dsa_verify;
-    
     case 13: case 14:
       return dnsmasq_ecdsa_verify;
 
@@ -432,17 +447,17 @@
     {
     case 1: return NULL;          /* RSA/MD5 - Must Not Implement.  RFC 6944 para 2.3. */
     case 2: return NULL;          /* Diffie-Hellman */
-    case 3: return "sha1";        /* DSA/SHA1 */ 
+    case 3: return NULL; ;        /* DSA/SHA1 - Must Not Implement. RFC 8624 section 3.1 */ 
     case 5: return "sha1";        /* RSA/SHA1 */
-    case 6: return "sha1";        /* DSA-NSEC3-SHA1 */
+    case 6: return NULL;          /* DSA-NSEC3-SHA1 - Must Not Implement. RFC 8624 section 3.1 */
     case 7: return "sha1";        /* RSASHA1-NSEC3-SHA1 */
     case 8: return "sha256";      /* RSA/SHA-256 */
     case 10: return "sha512";     /* RSA/SHA-512 */
-    case 12: return NULL;         /* ECC-GOST */
+    case 12: return "gosthash94"; /* ECC-GOST */
     case 13: return "sha256";     /* ECDSAP256SHA256 */
     case 14: return "sha384";     /* ECDSAP384SHA384 */ 	
     case 15: return "null_hash";  /* ED25519 */
-    case 16: return NULL;         /* ED448 */
+    case 16: return "null_hash";  /* ED448 */
     default: return NULL;
     }
 }
Index: src/dnssec.c
===================================================================
--- src/dnssec.c	(revision 41436)
+++ src/dnssec.c	(working copy)
@@ -1,5 +1,5 @@
 /* dnssec.c is Copyright (c) 2012 Giovanni Bajo <rasky@develer.com>
-           and Copyright (c) 2012-2018 Simon Kelley
+           and Copyright (c) 2012-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -193,10 +193,8 @@
 }
 
 /* Check whether today/now is between date_start and date_end */
-static int check_date_range(u32 date_start, u32 date_end)
+static int is_check_date(unsigned long curtime)
 {
-  unsigned long curtime = time(0);
- 
   /* Checking timestamps may be temporarily disabled */
     
   /* If the current time if _before_ the timestamp
@@ -218,12 +216,15 @@
 	  queue_event(EVENT_RELOAD); /* purge cache */
 	} 
 
-      if (daemon->back_to_the_future == 0)
-	return 1;
+      return daemon->back_to_the_future;
     }
-  else if (daemon->dnssec_no_time_check)
-    return 1;
-  
+  else
+    return !daemon->dnssec_no_time_check;
+}
+
+/* Check whether today/now is between date_start and date_end */
+static int check_date_range(unsigned long curtime, u32 date_start, u32 date_end)
+{
   /* We must explicitly check against wanted values, because of SERIAL_UNDEF */
   return serial_compare_32(curtime, date_start) == SERIAL_GT
     && serial_compare_32(curtime, date_end) == SERIAL_LT;
@@ -381,7 +382,7 @@
   int gotkey = 0;
 
   if (!(p = skip_questions(header, plen)))
-    return STAT_BOGUS;
+    return 0;
 
    /* look for RRSIGs for this RRset and get pointers to each RR in the set. */
   for (rrsetidx = 0, sigidx = 0, j = ntohs(header->ancount) + ntohs(header->nscount); 
@@ -393,14 +394,14 @@
       pstart = p;
       
       if (!(res = extract_name(header, plen, &p, name, 0, 10)))
-	return STAT_BOGUS; /* bad packet */
+	return 0; /* bad packet */
       
       GETSHORT(stype, p);
       GETSHORT(sclass, p);
-      p += 4; /* TTL */
-      
+           
       pdata = p;
 
+      p += 4; /* TTL */
       GETSHORT(rdlen, p);
       
       if (!CHECK_LEN(header, p, plen, rdlen))
@@ -463,7 +464,7 @@
 		  sigs[sigidx++] = pdata;
 		} 
 	      
-	      p = pdata + 2; /* restore for ADD_RDLEN */
+	      p = pdata + 6; /* restore for ADD_RDLEN */
 	    }
 	}
       
@@ -492,16 +493,22 @@
    Name is unchanged on exit. keyname is used as workspace and trashed.
 
    Call explore_rrset first to find and count RRs and sigs.
+
+   ttl_out is the floor on TTL, based on TTL and orig_ttl and expiration of sig used to validate.
 */
 static int validate_rrset(time_t now, struct dns_header *header, size_t plen, int class, int type, int sigidx, int rrsetidx, 
-			  char *name, char *keyname, char **wildcard_out, struct blockdata *key, int keylen, int algo_in, int keytag_in)
+			  char *name, char *keyname, char **wildcard_out, struct blockdata *key, int keylen,
+			  int algo_in, int keytag_in, unsigned long *ttl_out)
 {
   unsigned char *p;
-  int rdlen, j, name_labels, algo, labels, orig_ttl, key_tag;
+  int rdlen, j, name_labels, algo, labels, key_tag;
   struct crec *crecp = NULL;
   u16 *rr_desc = rrfilter_desc(type);
-  u32 sig_expiration, sig_inception
-;
+  u32 sig_expiration, sig_inception;
+
+  unsigned long curtime = time(0);
+  int time_check = is_check_date(curtime);
+  
   if (wildcard_out)
     *wildcard_out = NULL;
   
@@ -520,9 +527,10 @@
       const struct nettle_hash *hash;
       void *ctx;
       char *name_start;
-      u32 nsigttl;
+      u32 nsigttl, ttl, orig_ttl;
       
       p = sigs[j];
+      GETLONG(ttl, p);
       GETSHORT(rdlen, p); /* rdlen >= 18 checked previously */
       psav = p;
       
@@ -537,16 +545,28 @@
       if (!extract_name(header, plen, &p, keyname, 1, 0))
 	return STAT_BOGUS;
 
-      if (!check_date_range(sig_inception, sig_expiration) ||
+      if ((time_check && !check_date_range(curtime, sig_inception, sig_expiration)) ||
 	  labels > name_labels ||
 	  !(hash = hash_find(algo_digest_name(algo))) ||
 	  !hash_init(hash, &ctx, &digest))
 	continue;
-      
+
       /* OK, we have the signature record, see if the relevant DNSKEY is in the cache. */
       if (!key && !(crecp = cache_find_by_name(NULL, keyname, now, F_DNSKEY)))
 	return STAT_NEED_KEY;
-      
+
+       if (ttl_out)
+	 {
+	   /* 4035 5.3.3 rules on TTLs */
+	   if (orig_ttl < ttl)
+	     ttl = orig_ttl;
+	   
+	   if (time_check && difftime(sig_expiration, curtime) < ttl)
+	     ttl = difftime(sig_expiration, curtime);
+
+	   *ttl_out = ttl;
+	 }
+       
       sig = p;
       sig_len = rdlen - (p - psav);
               
@@ -660,11 +680,13 @@
 {
   unsigned char *psave, *p = (unsigned char *)(header+1);
   struct crec *crecp, *recp1;
-  int rc, j, qtype, qclass, ttl, rdlen, flags, algo, valid, keytag;
+  int rc, j, qtype, qclass, rdlen, flags, algo, valid, keytag;
+  unsigned long ttl, sig_ttl;
   struct blockdata *key;
-  struct all_addr a;
+  union all_addr a;
 
   if (ntohs(header->qdcount) != 1 ||
+      RCODE(header) == SERVFAIL || RCODE(header) == REFUSED ||
       !extract_name(header, plen, &p, name, 1, 4))
     return STAT_BOGUS;
 
@@ -754,12 +776,12 @@
 	      
 	      if (!(recp1->flags & F_NEG) &&
 		  recp1->addr.ds.keylen == (int)hash->digest_size &&
-		  (ds_digest = blockdata_retrieve(recp1->addr.key.keydata, recp1->addr.ds.keylen, NULL)) &&
+		  (ds_digest = blockdata_retrieve(recp1->addr.ds.keydata, recp1->addr.ds.keylen, NULL)) &&
 		  memcmp(ds_digest, digest, recp1->addr.ds.keylen) == 0 &&
 		  explore_rrset(header, plen, class, T_DNSKEY, name, keyname, &sigcnt, &rrcnt) &&
 		  sigcnt != 0 && rrcnt != 0 &&
 		  validate_rrset(now, header, plen, class, T_DNSKEY, sigcnt, rrcnt, name, keyname, 
-				 NULL, key, rdlen - 4, algo, keytag) == STAT_SECURE)
+				 NULL, key, rdlen - 4, algo, keytag, &sig_ttl) == STAT_SECURE)
 		{
 		  valid = 1;
 		  break;
@@ -786,6 +808,10 @@
 	  GETSHORT(qclass, p);
 	  GETLONG(ttl, p);
 	  GETSHORT(rdlen, p);
+
+	  /* TTL may be limited by sig. */
+	  if (sig_ttl < ttl)
+	    ttl = sig_ttl;
 	    
 	  if (!CHECK_LEN(header, p, plen, rdlen))
 	    return STAT_BOGUS; /* bad packet */
@@ -805,12 +831,15 @@
 		  algo = *p++;
 		  keytag = dnskey_keytag(algo, flags, p, rdlen - 4);
 		  
-		  /* Cache needs to known class for DNSSEC stuff */
-		  a.addr.dnssec.class = class;
-		  
 		  if ((key = blockdata_alloc((char*)p, rdlen - 4)))
 		    {
-		      if (!(recp1 = cache_insert(name, &a, now, ttl, F_FORWARD | F_DNSKEY | F_DNSSECOK)))
+		      a.key.keylen = rdlen - 4;
+		      a.key.keydata = key;
+		      a.key.algo = algo;
+		      a.key.keytag = keytag;
+		      a.key.flags = flags;
+		      
+		      if (!cache_insert(name, &a, class, now, ttl, F_FORWARD | F_DNSKEY | F_DNSSECOK))
 			{
 			  blockdata_free(key);
 			  return STAT_BOGUS;
@@ -817,18 +846,12 @@
 			}
 		      else
 			{
-			  a.addr.log.keytag = keytag;
-			  a.addr.log.algo = algo;
+			  a.log.keytag = keytag;
+			  a.log.algo = algo;
 			  if (algo_digest_name(algo))
 			    log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DNSKEY keytag %hu, algo %hu");
 			  else
 			    log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DNSKEY keytag %hu, algo %hu (not supported)");
-			  
-			  recp1->addr.key.keylen = rdlen - 4;
-			  recp1->addr.key.keydata = key;
-			  recp1->addr.key.algo = algo;
-			  recp1->addr.key.keytag = keytag;
-			  recp1->addr.key.flags = flags;
 			}
 		    }
 		}
@@ -864,10 +887,10 @@
 int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class)
 {
   unsigned char *p = (unsigned char *)(header+1);
-  int qtype, qclass, rc, i, neganswer, nons;
+  int qtype, qclass, rc, i, neganswer, nons, neg_ttl = 0;
   int aclass, atype, rdlen;
   unsigned long ttl;
-  struct all_addr a;
+  union all_addr a;
 
   if (ntohs(header->qdcount) != 1 ||
       !(p = skip_name(p, header, plen, 4)))
@@ -879,11 +902,11 @@
   if (qtype != T_DS || qclass != class)
     rc = STAT_BOGUS;
   else
-    rc = dnssec_validate_reply(now, header, plen, name, keyname, NULL, 0, &neganswer, &nons);
+    rc = dnssec_validate_reply(now, header, plen, name, keyname, NULL, 0, &neganswer, &nons, &neg_ttl);
   
   if (rc == STAT_INSECURE)
     {
-      my_syslog(LOG_WARNING, _("Insecure DS reply received, do upstream DNS servers support DNSSEC?"));
+      my_syslog(LOG_WARNING, _("Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"), name);
       rc = STAT_BOGUS;
     }
   
@@ -925,8 +948,7 @@
 	      int algo, digest, keytag;
 	      unsigned char *psave = p;
 	      struct blockdata *key;
-	      struct crec *crecp;
-
+	   
 	      if (rdlen < 4)
 		return STAT_BOGUS; /* bad packet */
 	      
@@ -934,12 +956,15 @@
 	      algo = *p++;
 	      digest = *p++;
 	      
-	      /* Cache needs to known class for DNSSEC stuff */
-	      a.addr.dnssec.class = class;
-	      
 	      if ((key = blockdata_alloc((char*)p, rdlen - 4)))
 		{
-		  if (!(crecp = cache_insert(name, &a, now, ttl, F_FORWARD | F_DS | F_DNSSECOK)))
+		  a.ds.digest = digest;
+		  a.ds.keydata = key;
+		  a.ds.algo = algo;
+		  a.ds.keytag = keytag;
+		  a.ds.keylen = rdlen - 4;
+
+		  if (!cache_insert(name, &a, class, now, ttl, F_FORWARD | F_DS | F_DNSSECOK))
 		    {
 		      blockdata_free(key);
 		      return STAT_BOGUS;
@@ -946,19 +971,13 @@
 		    }
 		  else
 		    {
-		      a.addr.log.keytag = keytag;
-		      a.addr.log.algo = algo;
-		      a.addr.log.digest = digest;
+		      a.log.keytag = keytag;
+		      a.log.algo = algo;
+		      a.log.digest = digest;
 		      if (ds_digest_name(digest) && algo_digest_name(algo))
 			log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DS keytag %hu, algo %hu, digest %hu");
 		      else
 			log_query(F_NOEXTRA | F_KEYTAG | F_UPSTREAM, name, &a, "DS keytag %hu, algo %hu, digest %hu (not supported)");
-		      
-		      crecp->addr.ds.digest = digest;
-		      crecp->addr.ds.keydata = key;
-		      crecp->addr.ds.algo = algo;
-		      crecp->addr.ds.keytag = keytag;
-		      crecp->addr.ds.keylen = rdlen - 4; 
 		    } 
 		}
 	      
@@ -974,11 +993,7 @@
   else
     {
       int flags = F_FORWARD | F_DS | F_NEG | F_DNSSECOK;
-      unsigned long minttl = ULONG_MAX;
-      
-      if (!(p = skip_section(p, ntohs(header->ancount), header, plen)))
-	return STAT_BOGUS;
-      
+            
       if (RCODE(header) == NXDOMAIN)
 	flags |= F_NXDOMAIN;
       
@@ -987,55 +1002,15 @@
       if (nons)
 	flags &= ~F_DNSSECOK;
       
-      for (i = ntohs(header->nscount); i != 0; i--)
-	{
-	  if (!(p = skip_name(p, header, plen, 0)))
-	    return STAT_BOGUS;
+      cache_start_insert();
 	  
-	  GETSHORT(atype, p); 
-	  GETSHORT(aclass, p);
-	  GETLONG(ttl, p);
-	  GETSHORT(rdlen, p);
-	  
-	  if (!CHECK_LEN(header, p, plen, rdlen))
-	    return STAT_BOGUS; /* bad packet */
-	  
-	  if (aclass != class || atype != T_SOA)
-	    {
-	      p += rdlen;
-	      continue;
-	    }
-	  
-	  if (ttl < minttl)
-	    minttl = ttl;
-	  
-	  /* MNAME */
-	  if (!(p = skip_name(p, header, plen, 0)))
-	    return STAT_BOGUS;
-	  /* RNAME */
-	  if (!(p = skip_name(p, header, plen, 20)))
-	    return STAT_BOGUS;
-	  p += 16; /* SERIAL REFRESH RETRY EXPIRE */
-	  
-	  GETLONG(ttl, p); /* minTTL */
-	  if (ttl < minttl)
-	    minttl = ttl;
-	  
-	  break;
-	}
+      /* Use TTL from NSEC for negative cache entries */
+      if (!cache_insert(name, NULL, class, now, neg_ttl, flags))
+	return STAT_BOGUS;
       
-      if (i != 0)
-	{
-	  cache_start_insert();
-	  
-	  a.addr.dnssec.class = class;
-	  if (!cache_insert(name, &a, now, ttl, flags))
-	    return STAT_BOGUS;
-	  
-	  cache_end_insert();  
-	  
-	  log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "no DS");
-	}
+      cache_end_insert();  
+      
+      log_query(F_NOEXTRA | F_UPSTREAM, name, NULL, "no DS");
     }
       
   return STAT_OK;
@@ -1549,7 +1524,7 @@
   return 1;
 }
 
-static int prove_non_existence(struct dns_header *header, size_t plen, char *keyname, char *name, int qtype, int qclass, char *wildname, int *nons)
+static int prove_non_existence(struct dns_header *header, size_t plen, char *keyname, char *name, int qtype, int qclass, char *wildname, int *nons, int *nsec_ttl)
 {
   static unsigned char **nsecset = NULL, **rrsig_labels = NULL;
   static int nsecset_sz = 0, rrsig_labels_sz = 0;
@@ -1557,6 +1532,7 @@
   int type_found = 0;
   unsigned char *auth_start, *p = skip_questions(header, plen);
   int type, class, rdlen, i, nsecs_found;
+  unsigned long ttl;
   
   /* Move to NS section */
   if (!p || !(p = skip_section(p, ntohs(header->ancount), header, plen)))
@@ -1564,7 +1540,7 @@
 
   auth_start = p;
   
-  for (nsecs_found = 0, i = ntohs(header->nscount); i != 0; i--)
+  for (nsecs_found = 0, i = 0; i < ntohs(header->nscount); i++)
     {
       unsigned char *pstart = p;
       
@@ -1573,11 +1549,19 @@
 	  
       GETSHORT(type, p); 
       GETSHORT(class, p);
-      p += 4; /* TTL */
+      GETLONG(ttl, p);
       GETSHORT(rdlen, p);
 
       if (class == qclass && (type == T_NSEC || type == T_NSEC3))
 	{
+	  if (nsec_ttl)
+	    {
+	      /* Limit TTL with sig TTL */
+	      if (daemon->rr_status[ntohs(header->ancount) + i] < ttl)
+		ttl = daemon->rr_status[ntohs(header->ancount) + i];
+	      *nsec_ttl = ttl;
+	    }
+	  
 	  /* No mixed NSECing 'round here, thankyouverymuch */
 	  if (type_found != 0 && type_found != type)
 	    return 0;
@@ -1758,10 +1742,14 @@
    STAT_NEED_DS  need DS to complete validation (name is returned in keyname)
 
    daemon->rr_status points to a char array which corressponds to the RRs in the 
-   answer section (only). This is set to 1 for each RR which is validated, and 0 for any which aren't.
+   answer and auth sections. This is set to 1 for each RR which is validated, and 0 for any which aren't.
+
+   When validating replies to DS records, we're only interested in the NSEC{3} RRs in the auth section.
+   Other RRs in that section missing sigs will not cause am INSECURE reply. We determine this mode
+   is the nons argument is non-NULL.
 */
 int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, 
-			  int *class, int check_unsigned, int *neganswer, int *nons)
+			  int *class, int check_unsigned, int *neganswer, int *nons, int *nsec_ttl)
 {
   static unsigned char **targets = NULL;
   static int target_sz = 0;
@@ -1772,9 +1760,9 @@
   int secure = STAT_SECURE;
 
   /* extend rr_status if necessary */
-  if (daemon->rr_status_sz < ntohs(header->ancount))
+  if (daemon->rr_status_sz < ntohs(header->ancount) + ntohs(header->nscount))
     {
-      char *new = whine_malloc(ntohs(header->ancount) + 64);
+      unsigned long *new = whine_malloc(sizeof(*daemon->rr_status) * (ntohs(header->ancount) + ntohs(header->nscount) + 64));
 
       if (!new)
 	return STAT_BOGUS;
@@ -1781,10 +1769,10 @@
 
       free(daemon->rr_status);
       daemon->rr_status = new;
-      daemon->rr_status_sz = ntohs(header->ancount) + 64;
+      daemon->rr_status_sz = ntohs(header->ancount) + ntohs(header->nscount) + 64;
     }
   
-  memset(daemon->rr_status, 0, ntohs(header->ancount));
+  memset(daemon->rr_status, 0, sizeof(*daemon->rr_status) * daemon->rr_status_sz);
   
   if (neganswer)
     *neganswer = 0;
@@ -1875,12 +1863,9 @@
 	    return STAT_BOGUS;
 	}
       
+      /* Done already: copy the validation status */
       if (j != i)
-	{
-	  /* Done already: copy the validation status */
-	  if (i < ntohs(header->ancount))
-	    daemon->rr_status[i] = daemon->rr_status[j];
-	}
+	daemon->rr_status[i] = daemon->rr_status[j];
       else
 	{
 	  /* Not done, validate now */
@@ -1893,19 +1878,31 @@
 	  /* No signatures for RRset. We can be configured to assume this is OK and return an INSECURE result. */
 	  if (sigcnt == 0)
 	    {
-	      if (check_unsigned)
+	      /* NSEC and NSEC3 records must be signed. We make this assumption elsewhere. */
+	      if (type1 == T_NSEC || type1 == T_NSEC3)
+		rc = STAT_INSECURE;
+	      else if (nons && i >= ntohs(header->ancount))
+		/* If we're validating a DS reply, rather than looking for the value of AD bit,
+		   we only care that NSEC and NSEC3 RRs in the auth section are signed. 
+		   Return SECURE even if others (SOA....) are not. */
+		rc = STAT_SECURE;
+	      else
 		{
-		  rc = zone_status(name, class1, keyname, now);
-		  if (rc == STAT_SECURE)
-		    rc = STAT_BOGUS;
-		  if (class)
-		    *class = class1; /* Class for NEED_DS or NEED_KEY */
+		  /* unsigned RRsets in auth section are not BOGUS, but do make reply insecure. */
+		  if (check_unsigned && i < ntohs(header->ancount))
+		    {
+		      rc = zone_status(name, class1, keyname, now);
+		      if (rc == STAT_SECURE)
+			rc = STAT_BOGUS;
+		      if (class)
+			*class = class1; /* Class for NEED_DS or NEED_KEY */
+		    }
+		  else 
+		    rc = STAT_INSECURE; 
+		  
+		  if (rc != STAT_INSECURE)
+		    return rc;
 		}
-	      else 
-		rc = STAT_INSECURE; 
-	      
-	      if (rc != STAT_INSECURE)
-		return rc;
 	    }
 	  else
 	    {
@@ -1924,8 +1921,9 @@
 	      /* Zone is insecure, don't need to validate RRset */
 	      if (rc == STAT_SECURE)
 		{
+		  unsigned long sig_ttl;
 		  rc = validate_rrset(now, header, plen, class1, type1, sigcnt,
-				      rrcnt, name, keyname, &wildname, NULL, 0, 0, 0);
+				      rrcnt, name, keyname, &wildname, NULL, 0, 0, 0, &sig_ttl);
 		  
 		  if (rc == STAT_BOGUS || rc == STAT_NEED_KEY || rc == STAT_NEED_DS)
 		    {
@@ -1937,8 +1935,7 @@
 		  /* rc is now STAT_SECURE or STAT_SECURE_WILDCARD */
 		  
 		  /* Note that RR is validated */
-		   if (i < ntohs(header->ancount))
-		     daemon->rr_status[i] = 1;
+		  daemon->rr_status[i] = sig_ttl;
 		   
 		  /* Note if we've validated either the answer to the question
 		     or the target of a CNAME. Any not noted will need NSEC or
@@ -1962,7 +1959,7 @@
 		     That's not a problem since if the RRsets later fail
 		     we'll return BOGUS then. */
 		  if (rc == STAT_SECURE_WILDCARD &&
-		      !prove_non_existence(header, plen, keyname, name, type1, class1, wildname, NULL))
+		      !prove_non_existence(header, plen, keyname, name, type1, class1, wildname, NULL, NULL))
 		    return STAT_BOGUS;
 
 		  rc = STAT_SECURE;
@@ -1989,7 +1986,7 @@
 	  
 	  /* For anything other than a DS record, this situation is OK if either
 	     the answer is in an unsigned zone, or there's a NSEC records. */
-	  if (!prove_non_existence(header, plen, keyname, name, qtype, qclass, NULL, nons))
+	  if (!prove_non_existence(header, plen, keyname, name, qtype, qclass, NULL, nons, nsec_ttl))
 	    {
 	      /* Empty DS without NSECS */
 	      if (qtype == T_DS)
Index: src/dnsmasq.c
===================================================================
--- src/dnsmasq.c	(revision 41436)
+++ src/dnsmasq.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -52,8 +52,12 @@
 #if defined(HAVE_LINUX_NETWORK)
   cap_user_header_t hdr = NULL;
   cap_user_data_t data = NULL;
+  int need_cap_net_admin = 0;
+  int need_cap_net_raw = 0;
+  int need_cap_net_bind_service = 0;
   char *bound_device = NULL;
   int did_bind = 0;
+  struct server *serv;
 #endif 
 #if defined(HAVE_DHCP) || defined(HAVE_DHCP6)
   struct dhcp_context *context;
@@ -122,7 +126,7 @@
       daemon->workspacename = safe_malloc(MAXDNAME * 2);
       /* one char flag per possible RR in answer section (may get extended). */
       daemon->rr_status_sz = 64;
-      daemon->rr_status = safe_malloc(daemon->rr_status_sz);
+      daemon->rr_status = safe_malloc(sizeof(*daemon->rr_status) * daemon->rr_status_sz);
     }
 #endif
 
@@ -134,20 +138,18 @@
     }
 #endif
   
-  /* Close any file descriptors we inherited apart from std{in|out|err} 
-     
-     Ensure that at least stdin, stdout and stderr (fd 0, 1, 2) exist,
+  /* Ensure that at least stdin, stdout and stderr (fd 0, 1, 2) exist,
      otherwise file descriptors we create can end up being 0, 1, or 2 
      and then get accidentally closed later when we make 0, 1, and 2 
      open to /dev/null. Normally we'll be started with 0, 1 and 2 open, 
      but it's not guaranteed. By opening /dev/null three times, we 
      ensure that we're not using those fds for real stuff. */
-  for (i = 0; i < max_fd; i++)
-    if (i != STDOUT_FILENO && i != STDERR_FILENO && i != STDIN_FILENO)
-      close(i);
-    else
-      open("/dev/null", O_RDWR); 
-
+  for (i = 0; i < 3; i++)
+    open("/dev/null", O_RDWR); 
+  
+  /* Close any file descriptors we inherited apart from std{in|out|err} */
+  close_fds(max_fd, -1, -1, -1);
+  
 #ifndef HAVE_LINUX_NETWORK
 #  if !(defined(IP_RECVDSTADDR) && defined(IP_RECVIF) && defined(IP_SENDSRCADDR))
   if (!option_bool(OPT_NOWILD))
@@ -285,11 +287,24 @@
     }
   
   if (daemon->dhcp || daemon->relay4)
-    dhcp_init();
+    {
+      dhcp_init();
+#   ifdef HAVE_LINUX_NETWORK
+      if (!option_bool(OPT_NO_PING))
+	need_cap_net_raw = 1;
+      need_cap_net_admin = 1;
+#   endif
+    }
   
 #  ifdef HAVE_DHCP6
   if (daemon->doing_ra || daemon->doing_dhcp6 || daemon->relay6)
-    ra_init(now);
+    {
+      ra_init(now);
+#   ifdef HAVE_LINUX_NETWORK
+      need_cap_net_raw = 1;
+      need_cap_net_admin = 1;
+#   endif
+    }
   
   if (daemon->doing_dhcp6 || daemon->relay6)
     dhcp6_init();
@@ -299,7 +314,12 @@
 
 #ifdef HAVE_IPSET
   if (daemon->ipsets)
-    ipset_init();
+    {
+      ipset_init();
+#  ifdef HAVE_LINUX_NETWORK
+      need_cap_net_admin = 1;
+#  endif
+    }
 #endif
 
 #if  defined(HAVE_LINUX_NETWORK)
@@ -366,9 +386,7 @@
     {
       cache_init();
 
-#ifdef HAVE_DNSSEC
       blockdata_init();
-#endif
     }
 
 #ifdef HAVE_INOTIFY
@@ -401,6 +419,16 @@
   die(_("DBus not available: set HAVE_DBUS in src/config.h"), NULL, EC_BADCONF);
 #endif
 
+  if (option_bool(OPT_UBUS))
+#ifdef HAVE_UBUS
+    {
+      daemon->ubus = NULL;
+      ubus_init();
+    }
+#else
+  die(_("UBus not available: set HAVE_UBUS in src/config.h"), NULL, EC_BADCONF);
+#endif
+
   if (daemon->port != 0)
     pre_allocate_sfds();
 
@@ -442,28 +470,81 @@
     }
 
 #if defined(HAVE_LINUX_NETWORK)
+  /* We keep CAP_NETADMIN (for ARP-injection) and
+     CAP_NET_RAW (for icmp) if we're doing dhcp,
+     if we have yet to bind ports because of DAD, 
+     or we're doing it dynamically, we need CAP_NET_BIND_SERVICE. */
+  if ((is_dad_listeners() || option_bool(OPT_CLEVERBIND)) &&
+      (option_bool(OPT_TFTP) || (daemon->port != 0 && daemon->port <= 1024)))
+    need_cap_net_bind_service = 1;
+
+  /* usptream servers which bind to an interface call SO_BINDTODEVICE
+     for each TCP connection, so need CAP_NET_RAW */
+  for (serv = daemon->servers; serv; serv = serv->next)
+    if (serv->interface[0] != 0)
+      need_cap_net_raw = 1;
+
+  /* If we're doing Dbus or UBus, the above can be set dynamically,
+     (as can ports) so always (potentially) needed. */
+#ifdef HAVE_DBUS
+  if (option_bool(OPT_DBUS))
+    {
+      need_cap_net_bind_service = 1;
+      need_cap_net_raw = 1;
+    }
+#endif
+
+#ifdef HAVE_UBUS
+  if (option_bool(OPT_UBUS))
+    {
+      need_cap_net_bind_service = 1;
+      need_cap_net_raw = 1;
+    }
+#endif
+  
   /* determine capability API version here, while we can still
      call safe_malloc */
-  if (ent_pw && ent_pw->pw_uid != 0)
+  int capsize = 1; /* for header version 1 */
+  char *fail = NULL;
+  
+  hdr = safe_malloc(sizeof(*hdr));
+  
+  /* find version supported by kernel */
+  memset(hdr, 0, sizeof(*hdr));
+  capget(hdr, NULL);
+  
+  if (hdr->version != LINUX_CAPABILITY_VERSION_1)
     {
-      int capsize = 1; /* for header version 1 */
-      hdr = safe_malloc(sizeof(*hdr));
+      /* if unknown version, use largest supported version (3) */
+      if (hdr->version != LINUX_CAPABILITY_VERSION_2)
+	hdr->version = LINUX_CAPABILITY_VERSION_3;
+      capsize = 2;
+    }
+  
+  data = safe_malloc(sizeof(*data) * capsize);
+  capget(hdr, data); /* Get current values, for verification */
 
-      /* find version supported by kernel */
-      memset(hdr, 0, sizeof(*hdr));
-      capget(hdr, NULL);
-      
-      if (hdr->version != LINUX_CAPABILITY_VERSION_1)
-	{
-	  /* if unknown version, use largest supported version (3) */
-	  if (hdr->version != LINUX_CAPABILITY_VERSION_2)
-	    hdr->version = LINUX_CAPABILITY_VERSION_3;
-	  capsize = 2;
-	}
-      
-      data = safe_malloc(sizeof(*data) * capsize);
-      memset(data, 0, sizeof(*data) * capsize);
-    }
+  if (need_cap_net_admin && !(data->permitted & (1 << CAP_NET_ADMIN)))
+    fail = "NET_ADMIN";
+  else if (need_cap_net_raw && !(data->permitted & (1 << CAP_NET_RAW)))
+    fail = "NET_RAW";
+  else if (need_cap_net_bind_service && !(data->permitted & (1 << CAP_NET_BIND_SERVICE)))
+    fail = "NET_BIND_SERVICE";
+  
+  if (fail)
+    die(_("process is missing required capability %s"), fail, EC_MISC);
+
+  /* Now set bitmaps to set caps after daemonising */
+  memset(data, 0, sizeof(*data) * capsize);
+  
+  if (need_cap_net_admin)
+    data->effective |= (1 << CAP_NET_ADMIN);
+  if (need_cap_net_raw)
+    data->effective |= (1 << CAP_NET_RAW);
+  if (need_cap_net_bind_service)
+    data->effective |= (1 << CAP_NET_BIND_SERVICE);
+  
+  data->permitted = data->effective;  
 #endif
 
   /* Use a pipe to carry signals and other events back to the event loop 
@@ -485,7 +566,6 @@
       if (chdir("/") != 0)
 	die(_("cannot chdir to filesystem root: %s"), NULL, EC_MISC); 
 
-#ifndef NO_FORK      
       if (!option_bool(OPT_NO_FORK))
 	{
 	  pid_t pid;
@@ -504,7 +584,7 @@
 	      char *msg;
 
 	      /* close our copy of write-end */
-	      while (retry_send(close(err_pipe[1])));
+	      close(err_pipe[1]);
 	      
 	      /* check for errors after the fork */
 	      if (read_event(err_pipe[0], &ev, &msg))
@@ -513,7 +593,7 @@
 	      _exit(EC_GOOD);
 	    } 
 	  
-	  while (retry_send(close(err_pipe[0])));
+	  close(err_pipe[0]);
 
 	  /* NO calls to die() from here on. */
 	  
@@ -525,7 +605,6 @@
 	  if (pid != 0)
 	    _exit(0);
 	}
-#endif
             
       /* write pidfile _after_ forking ! */
       if (daemon->runfile)
@@ -576,8 +655,7 @@
 		err = 1;
 	      else
 		{
-		  while (retry_send(close(fd)));
-		  if (errno != 0)
+		  if (close(fd) == -1)
 		    err = 1;
 		}
 	    }
@@ -630,18 +708,9 @@
       if (ent_pw && ent_pw->pw_uid != 0)
 	{     
 #if defined(HAVE_LINUX_NETWORK)	  
-	  /* On linux, we keep CAP_NETADMIN (for ARP-injection) and
-	     CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind 
-	     ports because of DAD, or we're doing it dynamically,
-	     we need CAP_NET_BIND_SERVICE too. */
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | 
-	      (1 << CAP_SETUID) | (1 << CAP_NET_BIND_SERVICE);
-	  else
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_SETUID);
-	  
+	  /* Need to be able to drop root. */
+	  data->effective |= (1 << CAP_SETUID);
+	  data->permitted |= (1 << CAP_SETUID);
 	  /* Tell kernel to not clear capabilities when dropping root */
 	  if (capset(hdr, data) == -1 || prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1)
 	    bad_capabilities = errno;
@@ -682,15 +751,10 @@
 	    }     
 
 #ifdef HAVE_LINUX_NETWORK
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	   data->effective = data->permitted =
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_NET_BIND_SERVICE);
-	 else
-	   data->effective = data->permitted = 
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
-	  data->inheritable = 0;
+	  data->effective &= ~(1 << CAP_SETUID);
+	  data->permitted &= ~(1 << CAP_SETUID);
 	  
-	  /* lose the setuid and setgid capabilities */
+	  /* lose the setuid capability */
 	  if (capset(hdr, data) == -1)
 	    {
 	      send_event(err_pipe[1], EVENT_CAP_ERR, errno, NULL);
@@ -779,6 +843,16 @@
     }
 #endif
 
+#ifdef HAVE_UBUS
+  if (option_bool(OPT_UBUS))
+    {
+      if (daemon->ubus)
+        my_syslog(LOG_INFO, _("UBus support enabled: connected to system bus"));
+      else
+        my_syslog(LOG_INFO, _("UBus support enabled: bus connection pending"));
+    }
+#endif
+
 #ifdef HAVE_DNSSEC
   if (option_bool(OPT_DNSSEC_VALID))
     {
@@ -880,10 +954,11 @@
     {
       struct tftp_prefix *p;
 
-      my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s", 
+      my_syslog(MS_TFTP | LOG_INFO, "TFTP %s%s %s %s", 
 		daemon->tftp_prefix ? _("root is ") : _("enabled"),
-		daemon->tftp_prefix ? daemon->tftp_prefix: "",
-		option_bool(OPT_TFTP_SECURE) ? _("secure mode") : "");
+		daemon->tftp_prefix ? daemon->tftp_prefix : "",
+		option_bool(OPT_TFTP_SECURE) ? _("secure mode") : "",
+		option_bool(OPT_SINGLE_PORT) ? _("single port mode") : "");
 
       if (tftp_prefix_missing)
 	my_syslog(MS_TFTP | LOG_WARNING, _("warning: %s inaccessible"), daemon->tftp_prefix);
@@ -901,7 +976,7 @@
       
       if (max_fd < 0)
 	max_fd = 5;
-      else if (max_fd < 100)
+      else if (max_fd < 100 && !option_bool(OPT_SINGLE_PORT))
 	max_fd = max_fd/2;
       else
 	max_fd = max_fd - 20;
@@ -924,12 +999,16 @@
 
   /* finished start-up - release original process */
   if (err_pipe[1] != -1)
-    while (retry_send(close(err_pipe[1])));
+    close(err_pipe[1]);
   
   if (daemon->port != 0)
     check_servers();
   
   pid = getpid();
+
+  daemon->pipe_to_parent = -1;
+  for (i = 0; i < MAX_PROCS; i++)
+    daemon->tcp_pipes[i] = -1;
   
 #ifdef HAVE_INOTIFY
   /* Using inotify, have to select a resolv file at startup */
@@ -963,7 +1042,7 @@
 
 #ifdef HAVE_UBUS
       if (option_bool(OPT_UBUS))
-	  set_ubus_listeners();
+        set_ubus_listeners();
 #endif
 	  
 #ifdef HAVE_DHCP
@@ -1027,7 +1106,7 @@
 #endif
 
    
-      /* must do this just before select(), when we know no
+      /* must do this just before do_poll(), when we know no
 	 more calls to my_syslog() can occur */
       set_log_writer();
       
@@ -1098,7 +1177,15 @@
 
 #ifdef HAVE_UBUS
       if (option_bool(OPT_UBUS))
-        check_ubus_listeners();
+        {
+          /* if we didn't create a UBus connection, retry now. */
+          if (!daemon->ubus)
+            {
+              ubus_init();
+            }
+
+          check_ubus_listeners();
+        }
 #endif
 
       check_dns_listeners(now);
@@ -1446,7 +1533,7 @@
 	    do {
 	      helper_write();
 	    } while (!helper_buf_empty() || do_script_run(now));
-	    while (retry_send(close(daemon->helperfd)));
+	    close(daemon->helperfd);
 	  }
 #endif
 	
@@ -1582,11 +1669,12 @@
 #ifdef HAVE_TFTP
   int  tftp = 0;
   struct tftp_transfer *transfer;
-  for (transfer = daemon->tftp_trans; transfer; transfer = transfer->next)
-    {
-      tftp++;
-      poll_listen(transfer->sockfd, POLLIN);
-    }
+  if (!option_bool(OPT_SINGLE_PORT))
+    for (transfer = daemon->tftp_trans; transfer; transfer = transfer->next)
+      {
+	tftp++;
+	poll_listen(transfer->sockfd, POLLIN);
+      }
 #endif
   
   /* will we be able to get memory? */
@@ -1611,7 +1699,7 @@
 	 we don't need to explicitly arrange to wake up here */
       if  (listener->tcpfd != -1)
 	for (i = 0; i < MAX_PROCS; i++)
-	  if (daemon->tcp_pids[i] == 0)
+	  if (daemon->tcp_pids[i] == 0 && daemon->tcp_pipes[i] == -1)
 	    {
 	      poll_listen(listener->tcpfd, POLLIN);
 	      break;
@@ -1618,6 +1706,7 @@
 	    }
 
 #ifdef HAVE_TFTP
+      /* tftp == 0 in single-port mode. */
       if (tftp <= daemon->tftp_max && listener->tftpfd != -1)
 	poll_listen(listener->tftpfd, POLLIN);
 #endif
@@ -1624,6 +1713,11 @@
 
     }
   
+  if (!option_bool(OPT_DEBUG))
+    for (i = 0; i < MAX_PROCS; i++)
+      if (daemon->tcp_pipes[i] != -1)
+	poll_listen(daemon->tcp_pipes[i], POLLIN);
+  
   return wait;
 }
 
@@ -1632,7 +1726,8 @@
   struct serverfd *serverfdp;
   struct listener *listener;
   int i;
-
+  int pipefd[2];
+  
   for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)
     if (poll_check(serverfdp->fd, POLLIN))
       reply_query(serverfdp->fd, serverfdp->source_addr.sa.sa_family, now);
@@ -1642,7 +1737,24 @@
       if (daemon->randomsocks[i].refcount != 0 && 
 	  poll_check(daemon->randomsocks[i].fd, POLLIN))
 	reply_query(daemon->randomsocks[i].fd, daemon->randomsocks[i].family, now);
-  
+
+  /* Races. The child process can die before we read all of the data from the
+     pipe, or vice versa. Therefore send tcp_pids to zero when we wait() the 
+     process, and tcp_pipes to -1 and close the FD when we read the last
+     of the data - indicated by cache_recv_insert returning zero.
+     The order of these events is indeterminate, and both are needed
+     to free the process slot. Once the child process has gone, poll()
+     returns POLLHUP, not POLLIN, so have to check for both here. */
+  if (!option_bool(OPT_DEBUG))
+    for (i = 0; i < MAX_PROCS; i++)
+      if (daemon->tcp_pipes[i] != -1 &&
+	  poll_check(daemon->tcp_pipes[i], POLLIN | POLLHUP) &&
+	  !cache_recv_insert(now, daemon->tcp_pipes[i]))
+	{
+	  close(daemon->tcp_pipes[i]);
+	  daemon->tcp_pipes[i] = -1;	
+	}
+	
   for (listener = daemon->listeners; listener; listener = listener->next)
     {
       if (listener->fd != -1 && poll_check(listener->fd, POLLIN))
@@ -1668,7 +1780,7 @@
 	  
 	  if (getsockname(confd, (struct sockaddr *)&tcp_addr, &tcp_len) == -1)
 	    {
-	      while (retry_send(close(confd)));
+	      close(confd);
 	      continue;
 	    }
 	  
@@ -1696,12 +1808,12 @@
 	      if ((if_index = tcp_interface(confd, tcp_addr.sa.sa_family)) != 0 &&
 		  indextoname(listener->tcpfd, if_index, intr_name))
 		{
-		  struct all_addr addr;
-		  addr.addr.addr4 = tcp_addr.in.sin_addr;
-#ifdef HAVE_IPV6
+		  union all_addr addr;
+		  
 		  if (tcp_addr.sa.sa_family == AF_INET6)
-		    addr.addr.addr6 = tcp_addr.in6.sin6_addr;
-#endif
+		    addr.addr6 = tcp_addr.in6.sin6_addr;
+		  else
+		    addr.addr4 = tcp_addr.in.sin_addr;
 		  
 		  for (iface = daemon->interfaces; iface; iface = iface->next)
 		    if (iface->index == if_index)
@@ -1733,27 +1845,49 @@
 	  if (!client_ok)
 	    {
 	      shutdown(confd, SHUT_RDWR);
-	      while (retry_send(close(confd)));
+	      close(confd);
 	    }
-#ifndef NO_FORK
-	  else if (!option_bool(OPT_DEBUG) && (p = fork()) != 0)
+	  else if (!option_bool(OPT_DEBUG) && pipe(pipefd) == 0 && (p = fork()) != 0)
 	    {
-	      if (p != -1)
+	      close(pipefd[1]); /* parent needs read pipe end. */
+	      if (p == -1)
+		close(pipefd[0]);
+	      else
 		{
 		  int i;
+
 		  for (i = 0; i < MAX_PROCS; i++)
-		    if (daemon->tcp_pids[i] == 0)
+		    if (daemon->tcp_pids[i] == 0 && daemon->tcp_pipes[i] == -1)
 		      {
+			char a;
+			(void)a; /* suppress potential unused warning */
+
 			daemon->tcp_pids[i] = p;
+			daemon->tcp_pipes[i] = pipefd[0];
+#ifdef HAVE_LINUX_NETWORK
+			/* The child process inherits the netlink socket, 
+			   which it never uses, but when the parent (us) 
+			   uses it in the future, the answer may go to the 
+			   child, resulting in the parent blocking
+			   forever awaiting the result. To avoid this
+			   the child closes the netlink socket, but there's
+			   a nasty race, since the parent may use netlink
+			   before the child has done the close.
+
+			   To avoid this, the parent blocks here until a 
+			   single byte comes back up the pipe, which
+			   is sent by the child after it has closed the
+			   netlink socket. */
+			retry_send(read(pipefd[0], &a, 1));
+#endif
 			break;
 		      }
 		}
-	      while (retry_send(close(confd)));
+	      close(confd);
 
 	      /* The child can use up to TCP_MAX_QUERIES ids, so skip that many. */
 	      daemon->log_id += TCP_MAX_QUERIES;
 	    }
-#endif
 	  else
 	    {
 	      unsigned char *buff;
@@ -1761,7 +1895,7 @@
 	      int flags;
 	      struct in_addr netmask;
 	      int auth_dns;
-
+	   
 	      if (iface)
 		{
 		  netmask = iface->netmask;
@@ -1773,12 +1907,21 @@
 		  auth_dns = 0;
 		}
 
-#ifndef NO_FORK
 	      /* Arrange for SIGALRM after CHILD_LIFETIME seconds to
 		 terminate the process. */
 	      if (!option_bool(OPT_DEBUG))
-		alarm(CHILD_LIFETIME);
+		{
+		  char a = 0;
+		  (void)a; /* suppress potential unused warning */
+		  alarm(CHILD_LIFETIME);
+		  close(pipefd[0]); /* close read end in child. */
+		  daemon->pipe_to_parent = pipefd[1];
+#ifdef HAVE_LINUX_NETWORK
+		  /* See comment above re netlink socket. */
+		  close(daemon->netlinkfd);
+		  retry_send(write(pipefd[1], &a, 1));
 #endif
+		}
 
 	      /* start with no upstream connections. */
 	      for (s = daemon->servers; s; s = s->next)
@@ -1793,7 +1936,7 @@
 	      buff = tcp_request(confd, now, &tcp_addr, netmask, auth_dns);
 	       
 	      shutdown(confd, SHUT_RDWR);
-	      while (retry_send(close(confd)));
+	      close(confd);
 	      
 	      if (buff)
 		free(buff);
@@ -1802,15 +1945,13 @@
 		if (s->tcpfd != -1)
 		  {
 		    shutdown(s->tcpfd, SHUT_RDWR);
-		    while (retry_send(close(s->tcpfd)));
+		    close(s->tcpfd);
 		  }
-#ifndef NO_FORK		   
 	      if (!option_bool(OPT_DEBUG))
 		{
 		  flush_log();
 		  _exit(0);
 		}
-#endif
 	    }
 	}
     }
@@ -1880,7 +2021,7 @@
   gotreply = delay_dhcp(dnsmasq_time(), PING_WAIT, fd, addr.s_addr, id);
 
 #if defined(HAVE_LINUX_NETWORK) || defined(HAVE_SOLARIS_NETWORK)
-  while (retry_send(close(fd)));
+  close(fd);
 #else
   opt = 1;
   setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &opt, sizeof(opt));
Index: src/cache.c
===================================================================
--- src/cache.c	(revision 41436)
+++ src/cache.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,6 +26,8 @@
 static int bignames_left, hash_size;
 
 static void make_non_terminals(struct crec *source);
+static struct crec *really_insert(char *name, union all_addr *addr, unsigned short class,
+				  time_t now,  unsigned long ttl, unsigned int flags);
 
 /* type->string mapping: this is also used by the name-hash function as a mixing table. */
 static const struct {
@@ -196,15 +198,20 @@
   *up = crecp;
 }
 
-#ifdef HAVE_DNSSEC
 static void cache_blockdata_free(struct crec *crecp)
 {
-  if (crecp->flags & F_DNSKEY)
-    blockdata_free(crecp->addr.key.keydata);
-  else if ((crecp->flags & F_DS) && !(crecp->flags & F_NEG))
-    blockdata_free(crecp->addr.ds.keydata);
+  if (!(crecp->flags & F_NEG))
+    {
+      if (crecp->flags & F_SRV)
+	blockdata_free(crecp->addr.srv.target);
+#ifdef HAVE_DNSSEC
+      else if (crecp->flags & F_DNSKEY)
+	blockdata_free(crecp->addr.key.keydata);
+      else if (crecp->flags & F_DS)
+	blockdata_free(crecp->addr.ds.keydata);
+#endif
+    }
 }
-#endif
 
 static void cache_free(struct crec *crecp)
 {
@@ -228,9 +235,7 @@
       crecp->flags &= ~F_BIGNAME;
     }
 
-#ifdef HAVE_DNSSEC
   cache_blockdata_free(crecp);
-#endif
 }    
 
 /* insert a new cache entry at the head of the list (youngest entry) */
@@ -271,10 +276,10 @@
 
 char *cache_get_cname_target(struct crec *crecp)
 {
-  if (crecp->addr.cname.uid != SRC_INTERFACE)
+  if (crecp->addr.cname.is_name_ptr)
+     return crecp->addr.cname.target.name;
+  else
     return cache_get_name(crecp->addr.cname.target.cache);
-
-  return crecp->addr.cname.target.int_name->name;
 }
 
 
@@ -304,13 +309,13 @@
 
 static int is_outdated_cname_pointer(struct crec *crecp)
 {
-  if (!(crecp->flags & F_CNAME) || crecp->addr.cname.uid == SRC_INTERFACE)
+  if (!(crecp->flags & F_CNAME) || crecp->addr.cname.is_name_ptr)
     return 0;
   
   /* NB. record may be reused as DS or DNSKEY, where uid is 
      overloaded for something completely different */
   if (crecp->addr.cname.target.cache && 
-      (crecp->addr.cname.target.cache->flags & (F_IPV4 | F_IPV6 | F_CNAME)) &&
+      !(crecp->addr.cname.target.cache->flags & (F_DNSKEY | F_DS)) &&
       crecp->addr.cname.uid == crecp->addr.cname.target.cache->uid)
     return 0;
   
@@ -328,8 +333,8 @@
   return 1;
 }
 
-static struct crec *cache_scan_free(char *name, struct all_addr *addr, time_t now, unsigned short flags,
-				    struct crec **target_crec, unsigned int *target_uid)
+static struct crec *cache_scan_free(char *name, union all_addr *addr, unsigned short class, time_t now,
+				    unsigned int flags, struct crec **target_crec, unsigned int *target_uid)
 {
   /* Scan and remove old entries.
      If (flags & F_FORWARD) then remove any forward entries for name and any expired
@@ -348,6 +353,8 @@
      This entry will get re-used with the same name, to preserve CNAMEs. */
  
   struct crec *crecp, **up;
+
+  (void)class;
   
   if (flags & F_FORWARD)
     {
@@ -356,7 +363,7 @@
 	  if ((crecp->flags & F_FORWARD) && hostname_isequal(cache_get_name(crecp), name))
 	    {
 	      /* Don't delete DNSSEC in favour of a CNAME, they can co-exist */
-	      if ((flags & crecp->flags & (F_IPV4 | F_IPV6)) || 
+	      if ((flags & crecp->flags & (F_IPV4 | F_IPV6 | F_SRV)) || 
 		  (((crecp->flags | flags) & F_CNAME) && !(crecp->flags & (F_DNSKEY | F_DS))))
 		{
 		  if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
@@ -379,7 +386,7 @@
 	      
 #ifdef HAVE_DNSSEC
 	      /* Deletion has to be class-sensitive for DS and DNSKEY */
-	      if ((flags & crecp->flags & (F_DNSKEY | F_DS)) && crecp->uid == addr->addr.dnssec.class)
+	      if ((flags & crecp->flags & (F_DNSKEY | F_DS)) && crecp->uid == class)
 		{
 		  if (crecp->flags & F_CONFIG)
 		    return crecp;
@@ -408,11 +415,8 @@
   else
     {
       int i;
-#ifdef HAVE_IPV6
       int addrlen = (flags & F_IPV6) ? IN6ADDRSZ : INADDRSZ;
-#else
-      int addrlen = INADDRSZ;
-#endif 
+
       for (i = 0; i < hash_size; i++)
 	for (crecp = hash_table[i], up = &hash_table[i]; 
 	     crecp && ((crecp->flags & F_REVERSE) || !(crecp->flags & F_IMMORTAL));
@@ -429,7 +433,7 @@
 	  else if (!(crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) &&
 		   (flags & crecp->flags & F_REVERSE) && 
 		   (flags & crecp->flags & (F_IPV4 | F_IPV6)) &&
-		   memcmp(&crecp->addr.addr, addr, addrlen) == 0)
+		   memcmp(&crecp->addr, addr, addrlen) == 0)
 	    {
 	      *up = crecp->hash_next;
 	      cache_unlink(crecp);
@@ -464,18 +468,12 @@
   new_chain = NULL;
   insert_error = 0;
 }
- 
-struct crec *cache_insert(char *name, struct all_addr *addr, 
-			  time_t now,  unsigned long ttl, unsigned short flags)
+
+struct crec *cache_insert(char *name, union all_addr *addr, unsigned short class,
+			  time_t now,  unsigned long ttl, unsigned int flags)
 {
-  struct crec *new, *target_crec = NULL;
-  union bigname *big_name = NULL;
-  int freed_all = flags & F_REVERSE;
-  int free_avail = 0;
-  unsigned int target_uid;
-  
   /* Don't log DNSSEC records here, done elsewhere */
-  if (flags & (F_IPV4 | F_IPV6 | F_CNAME))
+  if (flags & (F_IPV4 | F_IPV6 | F_CNAME | F_SRV))
     {
       log_query(flags | F_UPSTREAM, name, addr, NULL);
       /* Don't mess with TTL for DNSSEC records. */
@@ -484,32 +482,50 @@
       if (daemon->min_cache_ttl != 0 && daemon->min_cache_ttl > ttl)
 	ttl = daemon->min_cache_ttl;
     }
+  
+  return really_insert(name, addr, class, now, ttl, flags);
+}
 
+
+static struct crec *really_insert(char *name, union all_addr *addr, unsigned short class,
+				  time_t now,  unsigned long ttl, unsigned int flags)
+{
+  struct crec *new, *target_crec = NULL;
+  union bigname *big_name = NULL;
+  int freed_all = flags & F_REVERSE;
+  int free_avail = 0;
+  unsigned int target_uid;
+  
   /* if previous insertion failed give up now. */
   if (insert_error)
     return NULL;
+
+  /* we don't cache zero-TTL records. */
+  if (ttl == 0)
+    {
+      insert_error = 1;
+      return NULL;
+    }
   
   /* First remove any expired entries and entries for the name/address we
      are currently inserting. */
-  if ((new = cache_scan_free(name, addr, now, flags, &target_crec, &target_uid)))
+  if ((new = cache_scan_free(name, addr, class, now, flags, &target_crec, &target_uid)))
     {
       /* We're trying to insert a record over one from 
 	 /etc/hosts or DHCP, or other config. If the 
-	 existing record is for an A or AAAA and
+	 existing record is for an A or AAAA or CNAME and
 	 the record we're trying to insert is the same, 
 	 just drop the insert, but don't error the whole process. */
       if ((flags & (F_IPV4 | F_IPV6)) && (flags & F_FORWARD) && addr)
 	{
 	  if ((flags & F_IPV4) && (new->flags & F_IPV4) &&
-	      new->addr.addr.addr.addr4.s_addr == addr->addr.addr4.s_addr)
+	      new->addr.addr4.s_addr == addr->addr4.s_addr)
 	    return new;
-#ifdef HAVE_IPV6
 	  else if ((flags & F_IPV6) && (new->flags & F_IPV6) &&
-		   IN6_ARE_ADDR_EQUAL(&new->addr.addr.addr.addr6, &addr->addr.addr6))
+		   IN6_ARE_ADDR_EQUAL(&new->addr.addr6, &addr->addr6))
 	    return new;
-#endif
 	}
-      
+
       insert_error = 1;
       return NULL;
     }
@@ -549,21 +565,14 @@
       
       if (freed_all)
 	{
-	  struct all_addr free_addr = new->addr.addr;;
-	  
-#ifdef HAVE_DNSSEC
-	  /* For DNSSEC records, addr holds class. */
-	  if (new->flags & (F_DS | F_DNSKEY))
-	    free_addr.addr.dnssec.class = new->uid;
-#endif
-	  
+	  /* For DNSSEC records, uid holds class. */
 	  free_avail = 1; /* Must be free space now. */
-	  cache_scan_free(cache_get_name(new), &free_addr, now, new->flags, NULL, NULL);
+	  cache_scan_free(cache_get_name(new), &new->addr, new->uid, now, new->flags, NULL, NULL);
 	  daemon->metrics[METRIC_DNS_CACHE_LIVE_FREED]++;
 	}
       else
 	{
-	  cache_scan_free(NULL, NULL, now, 0, NULL, NULL);
+	  cache_scan_free(NULL, NULL, class, now, 0, NULL, NULL);
 	  freed_all = 1;
 	}
     }
@@ -611,16 +620,14 @@
   else
     *cache_get_name(new) = 0;
 
-  if (addr)
-    {
 #ifdef HAVE_DNSSEC
-      if (flags & (F_DS | F_DNSKEY))
-	new->uid = addr->addr.dnssec.class;
-      else
+  if (flags & (F_DS | F_DNSKEY))
+    new->uid = class;
 #endif
-	new->addr.addr = *addr;	
-    }
 
+  if (addr)
+    new->addr = *addr;	
+
   new->ttd = now + (time_t)ttl;
   new->next = new_chain;
   new_chain = new;
@@ -645,12 +652,145 @@
 	  cache_hash(new_chain);
 	  cache_link(new_chain);
 	  daemon->metrics[METRIC_DNS_CACHE_INSERTED]++;
+
+	  /* If we're a child process, send this cache entry up the pipe to the master.
+	     The marshalling process is rather nasty. */
+	  if (daemon->pipe_to_parent != -1)
+	    {
+	      char *name = cache_get_name(new_chain);
+	      ssize_t m = strlen(name);
+	      unsigned int flags = new_chain->flags;
+#ifdef HAVE_DNSSEC
+	      u16 class = new_chain->uid;
+#endif
+	      
+	      read_write(daemon->pipe_to_parent, (unsigned char *)&m, sizeof(m), 0);
+	      read_write(daemon->pipe_to_parent, (unsigned char *)name, m, 0);
+	      read_write(daemon->pipe_to_parent, (unsigned char *)&new_chain->ttd, sizeof(new_chain->ttd), 0);
+	      read_write(daemon->pipe_to_parent, (unsigned  char *)&flags, sizeof(flags), 0);
+
+	      if (flags & (F_IPV4 | F_IPV6 | F_DNSKEY | F_DS | F_SRV))
+		read_write(daemon->pipe_to_parent, (unsigned char *)&new_chain->addr, sizeof(new_chain->addr), 0);
+	      if (flags & F_SRV)
+		{
+		  /* A negative SRV entry is possible and has no data, obviously. */
+		  if (!(flags & F_NEG))
+		    blockdata_write(new_chain->addr.srv.target, new_chain->addr.srv.targetlen, daemon->pipe_to_parent);
+		}
+#ifdef HAVE_DNSSEC
+	      if (flags & F_DNSKEY)
+		{
+		  read_write(daemon->pipe_to_parent, (unsigned char *)&class, sizeof(class), 0);
+		  blockdata_write(new_chain->addr.key.keydata, new_chain->addr.key.keylen, daemon->pipe_to_parent);
+		}
+	      else if (flags & F_DS)
+		{
+		  read_write(daemon->pipe_to_parent, (unsigned char *)&class, sizeof(class), 0);
+		  /* A negative DS entry is possible and has no data, obviously. */
+		  if (!(flags & F_NEG))
+		    blockdata_write(new_chain->addr.ds.keydata, new_chain->addr.ds.keylen, daemon->pipe_to_parent);
+		}
+#endif
+	    }
 	}
+      
       new_chain = tmp;
     }
+
+  /* signal end of cache insert in master process */
+  if (daemon->pipe_to_parent != -1)
+    {
+      ssize_t m = -1;
+      read_write(daemon->pipe_to_parent, (unsigned char *)&m, sizeof(m), 0);
+    }
+      
   new_chain = NULL;
 }
 
+
+/* A marshalled cache entry arrives on fd, read, unmarshall and insert into cache of master process. */
+int cache_recv_insert(time_t now, int fd)
+{
+  ssize_t m;
+  union all_addr addr;
+  unsigned long ttl;
+  time_t ttd;
+  unsigned int flags;
+  struct crec *crecp = NULL;
+  
+  cache_start_insert();
+  
+  while(1)
+    {
+ 
+      if (!read_write(fd, (unsigned char *)&m, sizeof(m), 1))
+	return 0;
+      
+      if (m == -1)
+	{
+	  cache_end_insert();
+	  return 1;
+	}
+
+      if (!read_write(fd, (unsigned char *)daemon->namebuff, m, 1) ||
+	  !read_write(fd, (unsigned char *)&ttd, sizeof(ttd), 1) ||
+	  !read_write(fd, (unsigned char *)&flags, sizeof(flags), 1))
+	return 0;
+
+      daemon->namebuff[m] = 0;
+
+      ttl = difftime(ttd, now);
+      
+      if (flags & (F_IPV4 | F_IPV6 | F_DNSKEY | F_DS | F_SRV))
+	{
+	  unsigned short class = C_IN;
+
+	  if (!read_write(fd, (unsigned char *)&addr, sizeof(addr), 1))
+	    return 0;
+
+	  if ((flags & F_SRV) && !(flags & F_NEG) && !(addr.srv.target = blockdata_read(fd, addr.srv.targetlen)))
+	    return 0;
+	
+#ifdef HAVE_DNSSEC
+	   if (flags & F_DNSKEY)
+	     {
+	       if (!read_write(fd, (unsigned char *)&class, sizeof(class), 1) ||
+		   !(addr.key.keydata = blockdata_read(fd, addr.key.keylen)))
+		 return 0;
+	     }
+	   else  if (flags & F_DS)
+	     {
+	        if (!read_write(fd, (unsigned char *)&class, sizeof(class), 1) ||
+		    (!(flags & F_NEG) && !(addr.key.keydata = blockdata_read(fd, addr.key.keylen))))
+		  return 0;
+	     }
+#endif
+	       
+	  crecp = really_insert(daemon->namebuff, &addr, class, now, ttl, flags);
+	}
+      else if (flags & F_CNAME)
+	{
+	  struct crec *newc = really_insert(daemon->namebuff, NULL, C_IN, now, ttl, flags);
+	  /* This relies on the fact that the target of a CNAME immediately precedes
+	     it because of the order of extraction in extract_addresses, and
+	     the order reversal on the new_chain. */
+	  if (newc)
+	    {
+	       newc->addr.cname.is_name_ptr = 0;
+	       
+	       if (!crecp)
+		 newc->addr.cname.target.cache = NULL;
+	       else
+		{
+		  next_uid(crecp);
+		  newc->addr.cname.target.cache = crecp;
+		  newc->addr.cname.uid = crecp->uid;
+		}
+	    }
+	}
+    }
+}
+	
 int cache_find_non_terminal(char *name, time_t now)
 {
   struct crec *crecp;
@@ -659,6 +799,7 @@
     if (!is_outdated_cname_pointer(crecp) &&
 	!is_expired(now, crecp) &&
 	(crecp->flags & F_FORWARD) &&
+	!(crecp->flags & F_NXDOMAIN) && 
 	hostname_isequal(name, cache_get_name(crecp)))
       return 1;
 
@@ -679,7 +820,7 @@
       /* first search, look for relevant entries and push to top of list
 	 also free anything which has expired */
       struct crec *next, **up, **insert = NULL, **chainp = &ans;
-      unsigned short ins_flags = 0;
+      unsigned int ins_flags = 0;
       
       for (up = hash_bucket(name), crecp = *up; crecp; crecp = next)
 	{
@@ -752,15 +893,11 @@
   return NULL;
 }
 
-struct crec *cache_find_by_addr(struct crec *crecp, struct all_addr *addr, 
+struct crec *cache_find_by_addr(struct crec *crecp, union all_addr *addr, 
 				time_t now, unsigned int prot)
 {
   struct crec *ans;
-#ifdef HAVE_IPV6
   int addrlen = (prot == F_IPV6) ? IN6ADDRSZ : INADDRSZ;
-#else
-  int addrlen = INADDRSZ;
-#endif
   
   if (crecp) /* iterating */
     ans = crecp->next;
@@ -780,7 +917,7 @@
 	   if (!is_expired(now, crecp))
 	     {      
 	       if ((crecp->flags & prot) &&
-		   memcmp(&crecp->addr.addr, addr, addrlen) == 0)
+		   memcmp(&crecp->addr, addr, addrlen) == 0)
 		 {	    
 		   if (crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG))
 		     {
@@ -811,54 +948,26 @@
   if (ans && 
       (ans->flags & F_REVERSE) &&
       (ans->flags & prot) &&
-      memcmp(&ans->addr.addr, addr, addrlen) == 0)
+      memcmp(&ans->addr, addr, addrlen) == 0)
     return ans;
   
   return NULL;
 }
 
-static void add_hosts_cname(struct crec *target)
-{
-  struct crec *crec;
-  struct cname *a;
-  
-  for (a = daemon->cnames; a; a = a->next)
-    if (a->alias[1] != '*' &&
-	hostname_isequal(cache_get_name(target), a->target) &&
-	(crec = whine_malloc(SIZEOF_POINTER_CREC)))
-      {
-	crec->flags = F_FORWARD | F_IMMORTAL | F_NAMEP | F_CONFIG | F_CNAME;
-	crec->ttd = a->ttl;
-	crec->name.namep = a->alias;
-	crec->addr.cname.target.cache = target;
-	next_uid(target);
-	crec->addr.cname.uid = target->uid;
-	crec->uid = UID_NONE;
-	cache_hash(crec);
-	make_non_terminals(crec);
-	
-	add_hosts_cname(crec); /* handle chains */
-      }
-}
-  
-static void add_hosts_entry(struct crec *cache, struct all_addr *addr, int addrlen, 
+static void add_hosts_entry(struct crec *cache, union all_addr *addr, int addrlen, 
 			    unsigned int index, struct crec **rhash, int hashsz)
 {
   struct crec *lookup = cache_find_by_name(NULL, cache_get_name(cache), 0, cache->flags & (F_IPV4 | F_IPV6));
-  int i, nameexists = 0;
+  int i;
   unsigned int j; 
 
   /* Remove duplicates in hosts files. */
-  if (lookup && (lookup->flags & F_HOSTS))
+  if (lookup && (lookup->flags & F_HOSTS) && memcmp(&lookup->addr, addr, addrlen) == 0)
     {
-      nameexists = 1;
-      if (memcmp(&lookup->addr.addr, addr, addrlen) == 0)
-	{
-	  free(cache);
-	  return;
-	}
+      free(cache);
+      return;
     }
-  
+    
   /* Ensure there is only one address -> name mapping (first one trumps) 
      We do this by steam here, The entries are kept in hash chains, linked
      by ->next (which is unused at this point) held in hash buckets in
@@ -884,7 +993,7 @@
       
       for (lookup = rhash[j]; lookup; lookup = lookup->next)
 	if ((lookup->flags & cache->flags & (F_IPV4 | F_IPV6)) &&
-	    memcmp(&lookup->addr.addr, addr, addrlen) == 0)
+	    memcmp(&lookup->addr, addr, addrlen) == 0)
 	  {
 	    cache->flags &= ~F_REVERSE;
 	    break;
@@ -906,13 +1015,9 @@
     }
 
   cache->uid = index;
-  memcpy(&cache->addr.addr, addr, addrlen);  
+  memcpy(&cache->addr, addr, addrlen);  
   cache_hash(cache);
   make_non_terminals(cache);
-  
-  /* don't need to do alias stuff for second and subsequent addresses. */
-  if (!nameexists)
-    add_hosts_cname(cache);
 }
 
 static int eatspace(FILE *f)
@@ -935,7 +1040,7 @@
 	}
 
       if (c == '\n')
-	nl = 1;
+	nl++;
     }
 }
 	 
@@ -946,7 +1051,7 @@
   while (1)
     {
       if ((c = getc(f)) == EOF)
-	return (count == 0) ? EOF : 1;
+	return (count == 0) ? -1 : 1;
 
       if (isspace(c) || c == '#')
 	{
@@ -966,9 +1071,9 @@
 {  
   FILE *f = fopen(filename, "r");
   char *token = daemon->namebuff, *domain_suffix = NULL;
-  int addr_count = 0, name_count = cache_size, lineno = 0;
-  unsigned short flags = 0;
-  struct all_addr addr;
+  int addr_count = 0, name_count = cache_size, lineno = 1;
+  unsigned int flags = 0;
+  union all_addr addr;
   int atnl, addrlen = 0;
 
   if (!f)
@@ -977,31 +1082,28 @@
       return cache_size;
     }
   
-  eatspace(f);
+  lineno += eatspace(f);
   
-  while ((atnl = gettok(f, token)) != EOF)
+  while ((atnl = gettok(f, token)) != -1)
     {
-      lineno++;
-      
       if (inet_pton(AF_INET, token, &addr) > 0)
 	{
 	  flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4;
 	  addrlen = INADDRSZ;
-	  domain_suffix = get_domain(addr.addr.addr4);
+	  domain_suffix = get_domain(addr.addr4);
 	}
-#ifdef HAVE_IPV6
       else if (inet_pton(AF_INET6, token, &addr) > 0)
 	{
 	  flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6;
 	  addrlen = IN6ADDRSZ;
-	  domain_suffix = get_domain6(&addr.addr.addr6);
+	  domain_suffix = get_domain6(&addr.addr6);
 	}
-#endif
       else
 	{
 	  my_syslog(LOG_ERR, _("bad address at %s line %d"), filename, lineno); 
 	  while (atnl == 0)
 	    atnl = gettok(f, token);
+	  lineno += atnl;
 	  continue;
 	}
       
@@ -1020,7 +1122,7 @@
 	  int fqdn, nomem;
 	  char *canon;
 	  
-	  if ((atnl = gettok(f, token)) == EOF)
+	  if ((atnl = gettok(f, token)) == -1)
 	    break;
 
 	  fqdn = !!strchr(token, '.');
@@ -1053,6 +1155,8 @@
 	  else if (!nomem)
 	    my_syslog(LOG_ERR, _("bad name at %s line %d"), filename, lineno); 
 	}
+
+      lineno += atnl;
     } 
 
   fclose(f);
@@ -1073,7 +1177,12 @@
   struct host_record *hr;
   struct name_list *nl;
   struct cname *a;
+  struct crec lrec;
+  struct mx_srv_record *mx;
+  struct txt_record *txt;
   struct interface_name *intr;
+  struct ptr_record *ptr;
+  struct naptr *naptr;
 #ifdef HAVE_DNSSEC
   struct ds_config *ds;
 #endif
@@ -1084,9 +1193,8 @@
   for (i=0; i<hash_size; i++)
     for (cache = hash_table[i], up = &hash_table[i]; cache; cache = tmp)
       {
-#ifdef HAVE_DNSSEC
 	cache_blockdata_free(cache);
-#endif
+
 	tmp = cache->hash_next;
 	if (cache->flags & (F_HOSTS | F_CONFIG))
 	  {
@@ -1107,24 +1215,21 @@
 	  up = &cache->hash_next;
       }
   
-  /* Add CNAMEs to interface_names to the cache */
+  /* Add locally-configured CNAMEs to the cache */
   for (a = daemon->cnames; a; a = a->next)
-    for (intr = daemon->int_names; intr; intr = intr->next)
-      if (a->alias[1] != '*' &&
-	  hostname_isequal(a->target, intr->name) &&
-	  ((cache = whine_malloc(SIZEOF_POINTER_CREC))))
-	{
-	  cache->flags = F_FORWARD | F_NAMEP | F_CNAME | F_IMMORTAL | F_CONFIG;
-	  cache->ttd = a->ttl;
-	  cache->name.namep = a->alias;
-	  cache->addr.cname.target.int_name = intr;
-	  cache->addr.cname.uid = SRC_INTERFACE;
-	  cache->uid = UID_NONE;
-	  cache_hash(cache);
-	  make_non_terminals(cache);
-	  add_hosts_cname(cache); /* handle chains */
-	}
-
+    if (a->alias[1] != '*' &&
+	((cache = whine_malloc(SIZEOF_POINTER_CREC))))
+      {
+	cache->flags = F_FORWARD | F_NAMEP | F_CNAME | F_IMMORTAL | F_CONFIG;
+	cache->ttd = a->ttl;
+	cache->name.namep = a->alias;
+	cache->addr.cname.target.name = a->target;
+	cache->addr.cname.is_name_ptr = 1;
+	cache->uid = UID_NONE;
+	cache_hash(cache);
+	make_non_terminals(cache);
+      }
+  
 #ifdef HAVE_DNSSEC
   for (ds = daemon->ds; ds; ds = ds->next)
     if ((cache = whine_malloc(SIZEOF_POINTER_CREC)) &&
@@ -1153,24 +1258,23 @@
   for (hr = daemon->host_records; hr; hr = hr->next)
     for (nl = hr->names; nl; nl = nl->next)
       {
-	if (hr->addr.s_addr != 0 &&
+	if ((hr->flags & HR_4) &&
 	    (cache = whine_malloc(SIZEOF_POINTER_CREC)))
 	  {
 	    cache->name.namep = nl->name;
 	    cache->ttd = hr->ttl;
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV4 | F_NAMEP | F_CONFIG;
-	    add_hosts_entry(cache, (struct all_addr *)&hr->addr, INADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
+	    add_hosts_entry(cache, (union all_addr *)&hr->addr, INADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
-#ifdef HAVE_IPV6
-	if (!IN6_IS_ADDR_UNSPECIFIED(&hr->addr6) &&
+
+	if ((hr->flags & HR_6) &&
 	    (cache = whine_malloc(SIZEOF_POINTER_CREC)))
 	  {
 	    cache->name.namep = nl->name;
 	    cache->ttd = hr->ttl;
 	    cache->flags = F_HOSTS | F_IMMORTAL | F_FORWARD | F_REVERSE | F_IPV6 | F_NAMEP | F_CONFIG;
-	    add_hosts_entry(cache, (struct all_addr *)&hr->addr6, IN6ADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
+	    add_hosts_entry(cache, (union all_addr *)&hr->addr6, IN6ADDRSZ, SRC_CONFIG, (struct crec **)daemon->packet, revhashsz);
 	  }
-#endif
       }
 	
   if (option_bool(OPT_NO_HOSTS) && !daemon->addn_hosts)
@@ -1188,7 +1292,40 @@
 	if (!(ah->flags & AH_INACTIVE))
 	  total_size = read_hostsfile(ah->fname, ah->index, total_size, (struct crec **)daemon->packet, revhashsz);
     }
+  
+  /* Make non-terminal records for all locally-define RRs */
+  lrec.flags = F_FORWARD | F_CONFIG | F_NAMEP | F_IMMORTAL;
+  
+  for (txt = daemon->txt; txt; txt = txt->next)
+    {
+      lrec.name.namep = txt->name;
+      make_non_terminals(&lrec);
+    }
 
+  for (naptr = daemon->naptr; naptr; naptr = naptr->next)
+    {
+      lrec.name.namep = naptr->name;
+      make_non_terminals(&lrec);
+    }
+
+  for (mx = daemon->mxnames; mx; mx = mx->next)
+    {
+      lrec.name.namep = mx->name;
+      make_non_terminals(&lrec);
+    }
+
+  for (intr = daemon->int_names; intr; intr = intr->next)
+    {
+      lrec.name.namep = intr->name;
+      make_non_terminals(&lrec);
+    }
+  
+  for (ptr = daemon->ptr; ptr; ptr = ptr->next)
+    {
+      lrec.name.namep = ptr->name;
+      make_non_terminals(&lrec);
+    }
+  
 #ifdef HAVE_INOTIFY
   set_dynamic_inotify(AH_HOSTS, total_size, (struct crec **)daemon->packet, revhashsz);
 #endif
@@ -1203,7 +1340,7 @@
   
   while ((crecp = cache_find_by_name(crecp, name, now, F_IPV4)))
     if (crecp->flags & F_HOSTS)
-      return *(struct in_addr *)&crecp->addr;
+      return crecp->addr.addr4;
 
   my_syslog(MS_DHCP | LOG_WARNING, _("No IPv4 address found for %s"), name);
   
@@ -1228,54 +1365,19 @@
 	up = &cache->hash_next;
 }
 
-static void add_dhcp_cname(struct crec *target, time_t ttd)
-{
-  struct crec *aliasc;
-  struct cname *a;
-  
-  for (a = daemon->cnames; a; a = a->next)
-    if (a->alias[1] != '*' &&
-	hostname_isequal(cache_get_name(target), a->target))
-      {
-	if ((aliasc = dhcp_spare))
-	  dhcp_spare = dhcp_spare->next;
-	else /* need new one */
-	  aliasc = whine_malloc(SIZEOF_POINTER_CREC);
-	
-	if (aliasc)
-	  {
-	    aliasc->flags = F_FORWARD | F_NAMEP | F_DHCP | F_CNAME | F_CONFIG;
-	    if (ttd == 0)
-	      aliasc->flags |= F_IMMORTAL;
-	    else
-	      aliasc->ttd = ttd;
-	    aliasc->name.namep = a->alias;
-	    aliasc->addr.cname.target.cache = target;
-	    next_uid(target);
-	    aliasc->addr.cname.uid = target->uid;
-	    aliasc->uid = UID_NONE;
-	    cache_hash(aliasc);
-	    make_non_terminals(aliasc);
-	    add_dhcp_cname(aliasc, ttd);
-	  }
-      }
-}
-
 void cache_add_dhcp_entry(char *host_name, int prot,
-			  struct all_addr *host_address, time_t ttd) 
+			  union all_addr *host_address, time_t ttd) 
 {
   struct crec *crec = NULL, *fail_crec = NULL;
-  unsigned short flags = F_IPV4;
+  unsigned int flags = F_IPV4;
   int in_hosts = 0;
   size_t addrlen = sizeof(struct in_addr);
 
-#ifdef HAVE_IPV6
   if (prot == AF_INET6)
     {
       flags = F_IPV6;
       addrlen = sizeof(struct in6_addr);
     }
-#endif
   
   inet_ntop(prot, host_address, daemon->addrbuff, ADDRSTRLEN);
   
@@ -1288,7 +1390,7 @@
 	    my_syslog(MS_DHCP | LOG_WARNING, 
 		      _("%s is a CNAME, not giving it to the DHCP lease of %s"),
 		      host_name, daemon->addrbuff);
-	  else if (memcmp(&crec->addr.addr, host_address, addrlen) == 0)
+	  else if (memcmp(&crec->addr, host_address, addrlen) == 0)
 	    in_hosts = 1;
 	  else
 	    fail_crec = crec;
@@ -1295,7 +1397,7 @@
 	}
       else if (!(crec->flags & F_DHCP))
 	{
-	  cache_scan_free(host_name, NULL, 0, crec->flags & (flags | F_CNAME | F_FORWARD), NULL, NULL);
+	  cache_scan_free(host_name, NULL, C_IN, 0, crec->flags & (flags | F_CNAME | F_FORWARD), NULL, NULL);
 	  /* scan_free deletes all addresses associated with name */
 	  break;
 	}
@@ -1308,7 +1410,7 @@
   /* Name in hosts, address doesn't match */
   if (fail_crec)
     {
-      inet_ntop(prot, &fail_crec->addr.addr, daemon->namebuff, MAXDNAME);
+      inet_ntop(prot, &fail_crec->addr, daemon->namebuff, MAXDNAME);
       my_syslog(MS_DHCP | LOG_WARNING, 
 		_("not giving name %s to the DHCP lease of %s because "
 		  "the name exists in %s with address %s"), 
@@ -1317,12 +1419,12 @@
       return;
     }	  
   
-  if ((crec = cache_find_by_addr(NULL, (struct all_addr *)host_address, 0, flags)))
+  if ((crec = cache_find_by_addr(NULL, (union all_addr *)host_address, 0, flags)))
     {
       if (crec->flags & F_NEG)
 	{
 	  flags |= F_REVERSE;
-	  cache_scan_free(NULL, (struct all_addr *)host_address, 0, flags, NULL, NULL);
+	  cache_scan_free(NULL, (union all_addr *)host_address, C_IN, 0, flags, NULL, NULL);
 	}
     }
   else
@@ -1340,13 +1442,11 @@
 	crec->flags |= F_IMMORTAL;
       else
 	crec->ttd = ttd;
-      crec->addr.addr = *host_address;
+      crec->addr = *host_address;
       crec->name.namep = host_name;
       crec->uid = UID_NONE;
       cache_hash(crec);
       make_non_terminals(crec);
-
-      add_dhcp_cname(crec, ttd);
     }
 }
 #endif
@@ -1378,7 +1478,7 @@
       if (!is_outdated_cname_pointer(crecp) &&
 	  (crecp->flags & F_FORWARD) &&
 	  (crecp->flags & type) &&
-	  !(crecp->flags & (F_IPV4 | F_IPV6 | F_CNAME | F_DNSKEY | F_DS)) && 
+	  !(crecp->flags & (F_IPV4 | F_IPV6 | F_CNAME | F_SRV | F_DNSKEY | F_DS)) && 
 	  hostname_isequal(name, cache_get_name(crecp)))
 	{
 	  *up = crecp->hash_next;
@@ -1435,7 +1535,7 @@
 
       if (crecp)
 	{
-	  crecp->flags = (source->flags | F_NAMEP) & ~(F_IPV4 | F_IPV6 | F_CNAME | F_DNSKEY | F_DS | F_REVERSE);
+	  crecp->flags = (source->flags | F_NAMEP) & ~(F_IPV4 | F_IPV6 | F_CNAME | F_SRV | F_DNSKEY | F_DS | F_REVERSE);
 	  crecp->ttd = source->ttd;
 	  crecp->name.namep = name;
 	  
@@ -1568,9 +1668,8 @@
 #ifdef HAVE_AUTH
   my_syslog(LOG_INFO, _("queries for authoritative zones %u"), daemon->metrics[METRIC_DNS_AUTH_ANSWERED]);
 #endif
-#ifdef HAVE_DNSSEC
+
   blockdata_report();
-#endif
 
   /* sum counts from different records for same server */
   for (serv = daemon->servers; serv; serv = serv->next)
@@ -1612,6 +1711,17 @@
 	    p += sprintf(p, "%-30.30s ", sanitise(n));
 	    if ((cache->flags & F_CNAME) && !is_outdated_cname_pointer(cache))
 	      a = sanitise(cache_get_cname_target(cache));
+	    else if ((cache->flags & F_SRV) && !(cache->flags & F_NEG))
+	      {
+		int targetlen = cache->addr.srv.targetlen;
+		ssize_t len = sprintf(a, "%u %u %u ", cache->addr.srv.priority,
+				      cache->addr.srv.weight, cache->addr.srv.srvport);
+
+		if (targetlen > (40 - len))
+		  targetlen = 40 - len;
+		blockdata_retrieve(cache->addr.srv.target, targetlen, a + len);
+		a[len + targetlen] = 0;		
+	      }
 #ifdef HAVE_DNSSEC
 	    else if (cache->flags & F_DS)
 	      {
@@ -1627,11 +1737,9 @@
 	      { 
 		a = daemon->addrbuff;
 		if (cache->flags & F_IPV4)
-		  inet_ntop(AF_INET, &cache->addr.addr, a, ADDRSTRLEN);
-#ifdef HAVE_IPV6
+		  inet_ntop(AF_INET, &cache->addr, a, ADDRSTRLEN);
 		else if (cache->flags & F_IPV6)
-		  inet_ntop(AF_INET6, &cache->addr.addr, a, ADDRSTRLEN);
-#endif
+		  inet_ntop(AF_INET6, &cache->addr, a, ADDRSTRLEN);
 	      }
 
 	    if (cache->flags & F_IPV4)
@@ -1640,6 +1748,8 @@
 	      t = "6";
 	    else if (cache->flags & F_CNAME)
 	      t = "C";
+	    else if (cache->flags & F_SRV)
+	      t = "V";
 #ifdef HAVE_DNSSEC
 	    else if (cache->flags & F_DS)
 	      t = "S";
@@ -1744,7 +1854,7 @@
   return buff ? buff : "";
 }
 
-void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg)
+void log_query(unsigned int flags, char *name, union all_addr *addr, char *arg)
 {
   char *source, *dest = daemon->addrbuff;
   char *verb = "is";
@@ -1757,10 +1867,10 @@
   if (addr)
     {
       if (flags & F_KEYTAG)
-	sprintf(daemon->addrbuff, arg, addr->addr.log.keytag, addr->addr.log.algo, addr->addr.log.digest);
+	sprintf(daemon->addrbuff, arg, addr->log.keytag, addr->log.algo, addr->log.digest);
       else if (flags & F_RCODE)
 	{
-	  unsigned int rcode = addr->addr.rcode.rcode;
+	  unsigned int rcode = addr->log.rcode;
 
 	   if (rcode == SERVFAIL)
 	     dest = "SERVFAIL";
@@ -1772,14 +1882,9 @@
 	     sprintf(daemon->addrbuff, "%u", rcode);
 	}
       else
-	{
-#ifdef HAVE_IPV6
-	  inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
-		    addr, daemon->addrbuff, ADDRSTRLEN);
-#else
-	  strncpy(daemon->addrbuff, inet_ntoa(addr->addr.addr4), ADDRSTRLEN);  
-#endif
-	}
+	inet_ntop(flags & F_IPV4 ? AF_INET : AF_INET6,
+		  addr, daemon->addrbuff, ADDRSTRLEN);
+      
     }
   else
     dest = arg;
@@ -1806,6 +1911,8 @@
     }
   else if (flags & F_CNAME)
     dest = "<CNAME>";
+  else if (flags & F_SRV)
+    dest = "<SRV>";
   else if (flags & F_RRNAME)
     dest = arg;
     
Index: src/dnsmasq.h
===================================================================
--- src/dnsmasq.h	(revision 41436)
+++ src/dnsmasq.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
  
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -14,7 +14,7 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-#define COPYRIGHT "Copyright (c) 2000-2018 Simon Kelley"
+#define COPYRIGHT "Copyright (c) 2000-2020 Simon Kelley"
 
 /* We do defines that influence behavior of stdio.h, so complain
    if included too early. */
@@ -95,7 +95,11 @@
 #if defined(HAVE_SOLARIS_NETWORK)
 #  include <sys/sockio.h>
 #endif
-#include <poll.h>
+#if defined(HAVE_POLL_H)
+#  include <poll.h>
+#else
+#  include <sys/poll.h>
+#endif
 #include <sys/wait.h>
 #include <sys/time.h>
 #include <sys/un.h>
@@ -126,10 +130,9 @@
 #include <net/if_arp.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
-#ifdef HAVE_IPV6
 #include <netinet/ip6.h>
-#endif
 #include <netinet/ip_icmp.h>
+#include <netinet/tcp.h>
 #include <sys/uio.h>
 #include <syslog.h>
 #include <dirent.h>
@@ -138,6 +141,7 @@
 #endif
 
 #if defined(HAVE_LINUX_NETWORK)
+#include <linux/sockios.h>
 #include <linux/capability.h>
 /* There doesn't seem to be a universally-available 
    userspace header for these. */
@@ -159,6 +163,8 @@
 /* daemon is function in the C library.... */
 #define daemon dnsmasq_daemon
 
+#define ADDRSTRLEN INET6_ADDRSTRLEN
+
 /* Async event queue */
 struct event_desc {
   int event, data, msg_sz;
@@ -200,9 +206,6 @@
 #define EC_MISC        5
 #define EC_INIT_OFFSET 10
 
-/* Trust the compiler dead-code eliminator.... */
-#define option_bool(x) (((x) < 32) ? daemon->options & (1u << (x)) : daemon->options2 & (1u << ((x) - 32)))
-
 #define OPT_BOGUSPRIV      0
 #define OPT_FILTER         1
 #define OPT_LOG            2
@@ -262,8 +265,17 @@
 #define OPT_TFTP_APREF_MAC 56
 #define OPT_RAPID_COMMIT   57
 #define OPT_UBUS           58
-#define OPT_LAST           59
+#define OPT_IGNORE_CLID    59
+#define OPT_SINGLE_PORT    60
+#define OPT_LEASE_RENEW    61
+#define OPT_LAST           62
 
+#define OPTION_BITS (sizeof(unsigned int)*8)
+#define OPTION_SIZE ( (OPT_LAST/OPTION_BITS)+((OPT_LAST%OPTION_BITS)!=0) )
+#define option_var(x) (daemon->options[(x) / OPTION_BITS])
+#define option_val(x) ((1u) << ((x) % OPTION_BITS))
+#define option_bool(x) (option_var(x) & option_val(x))
+
 /* extra flags for my_syslog, we use a couple of facilities since they are known 
    not to occupy the same bits as priorities, no matter how syslog.h is set up. */
 #define MS_TFTP   LOG_USER
@@ -270,27 +282,44 @@
 #define MS_DHCP   LOG_DAEMON
 #define MS_SCRIPT LOG_MAIL
 
-struct all_addr {
-  union {
-    struct in_addr addr4;
-#ifdef HAVE_IPV6
-    struct in6_addr addr6;
-#endif
-    /* for log_query */
-    struct {
-      unsigned short keytag, algo, digest;
-    } log;
-    /* for log_query */
-    struct {
-      unsigned int rcode;
-    } rcode;
-    /* for cache_insert of DNSKEY, DS */
-    struct {
-      unsigned short class, type;
-    } dnssec;      
-  } addr;
+/* Note that this is used widely as a container for IPv4/IPv6 addresses,
+   so for that reason, was well as to avoid wasting memory in almost every
+   cache entry, the other variants should not be larger than
+   sizeof(struct in6_addr) - 16 bytes.
+*/
+union all_addr {
+  struct in_addr addr4;
+  struct in6_addr addr6;
+  struct {
+    union {
+      struct crec *cache;
+      char *name;
+    } target;
+    unsigned int uid;
+    int is_name_ptr;  /* disciminates target union */
+  } cname;
+  struct {
+    struct blockdata *keydata;
+    unsigned short keylen, flags, keytag;
+    unsigned char algo;
+  } key; 
+  struct {
+    struct blockdata *keydata;
+    unsigned short keylen, keytag;
+    unsigned char algo;
+    unsigned char digest; 
+  } ds;
+  struct {
+    struct blockdata *target;
+    unsigned short targetlen, srvport, priority, weight;
+  } srv;
+  /* for log_query */
+  struct {
+    unsigned short keytag, algo, digest, rcode;
+  } log;
 };
 
+
 struct bogus_addr {
   struct in_addr addr;
   struct bogus_addr *next;
@@ -350,13 +379,17 @@
   struct ds_config *next;
 };
 
-#define ADDRLIST_LITERAL 1
-#define ADDRLIST_IPV6    2
-#define ADDRLIST_REVONLY 4
+#define ADDRLIST_LITERAL  1
+#define ADDRLIST_IPV6     2
+#define ADDRLIST_REVONLY  4
+#define ADDRLIST_PREFIX   8
+#define ADDRLIST_WILDCARD 16
+#define ADDRLIST_DECLINED 32
 
 struct addrlist {
-  struct all_addr addr;
-  int flags, prefixlen; 
+  union all_addr addr;
+  int flags, prefixlen;
+  time_t decline_time;
   struct addrlist *next;
 };
 
@@ -375,17 +408,17 @@
   struct auth_zone *next;
 };
 
+#define HR_6 1
+#define HR_4 2
 
 struct host_record {
-  int ttl;
+  int ttl, flags;
   struct name_list {
     char *name;
     struct name_list *next;
   } *names;
   struct in_addr addr;
-#ifdef HAVE_IPV6
   struct in6_addr addr6;
-#endif
   struct host_record *next;
 };
 
@@ -409,32 +442,11 @@
 
 struct crec { 
   struct crec *next, *prev, *hash_next;
-  /* union is 16 bytes when doing IPv6, 8 bytes on 32 bit machines without IPv6 */
-  union {
-    struct all_addr addr;
-    struct {
-      union {
-	struct crec *cache;
-	struct interface_name *int_name;
-      } target;
-      unsigned int uid; /* 0 if union is interface-name */
-    } cname;
-    struct {
-      struct blockdata *keydata;
-      unsigned short keylen, flags, keytag;
-      unsigned char algo;
-    } key; 
-    struct {
-      struct blockdata *keydata;
-      unsigned short keylen, keytag;
-      unsigned char algo;
-      unsigned char digest; 
-    } ds; 
-  } addr;
+  union all_addr addr;
   time_t ttd; /* time to die */
   /* used as class if DNSKEY/DS, index to source for F_HOSTS */
   unsigned int uid; 
-  unsigned short flags;
+  unsigned int flags;
   union {
     char sname[SMALLDNAME+1];
     union bigname *bname;
@@ -461,9 +473,6 @@
 #define F_CONFIG    (1u<<13)
 #define F_DS        (1u<<14)
 #define F_DNSSECOK  (1u<<15)
-
-/* below here are only valid as args to log_query: cache
-   entries are limited to 16 bits */
 #define F_UPSTREAM  (1u<<16)
 #define F_RRNAME    (1u<<17)
 #define F_SERVER    (1u<<18)
@@ -476,15 +485,12 @@
 #define F_NO_RR     (1u<<25)
 #define F_IPSET     (1u<<26)
 #define F_NOEXTRA   (1u<<27)
-#define F_SERVFAIL  (1u<<28)
+#define F_SERVFAIL  (1u<<28) /* currently unused. */
 #define F_RCODE     (1u<<29)
+#define F_SRV       (1u<<30)
 
 #define UID_NONE      0
 /* Values of uid in crecs with F_CONFIG bit set. */
-/* cname to uid SRC_INTERFACE are to interface names,
-   so use UID_NONE for that to eliminate clashes with
-   any other uid */
-#define SRC_INTERFACE UID_NONE
 #define SRC_CONFIG    1
 #define SRC_HOSTS     2
 #define SRC_AH        3
@@ -496,9 +502,7 @@
 union mysockaddr {
   struct sockaddr sa;
   struct sockaddr_in in;
-#if defined(HAVE_IPV6)
   struct sockaddr_in6 in6;
-#endif
 };
 
 /* bits in flag param to IPv6 callbacks from iface_enumerate() */
@@ -657,12 +661,10 @@
 
 struct frec {
   union mysockaddr source;
-  struct all_addr dest;
+  union all_addr dest;
   struct server *sentto; /* NULL means free */
   struct randfd *rfd4;
-#ifdef HAVE_IPV6
   struct randfd *rfd6;
-#endif
   unsigned int iface;
   unsigned short orig_id, new_id;
   int log_id, fd, forwardall, flags;
@@ -704,6 +706,7 @@
 #define LEASE_NA            32  /* IPv6 no-temporary lease */
 #define LEASE_TA            64  /* IPv6 temporary lease */
 #define LEASE_HAVE_HWADDR  128  /* Have set hwaddress */
+#define LEASE_EXP_CHANGED  256  /* Lease expiry time changed */
 
 struct dhcp_lease {
   int clid_len;          /* length of client identifier */
@@ -725,7 +728,7 @@
   int new_prefixlen;     /* and its prefix length */
 #ifdef HAVE_DHCP6
   struct in6_addr addr6;
-  int iaid;
+  unsigned int iaid;
   struct slaac_address {
     struct in6_addr addr;
     time_t ping_time;
@@ -772,8 +775,9 @@
   unsigned char *clid;   /* clientid */
   char *hostname, *domain;
   struct dhcp_netid_list *netid;
+  struct dhcp_netid *filter;
 #ifdef HAVE_DHCP6
-  struct in6_addr addr6;
+  struct addrlist *addr6;
 #endif
   struct in_addr addr;
   time_t decline_time;
@@ -795,7 +799,7 @@
 #define CONFIG_DECLINED       1024    /* address declined by client */
 #define CONFIG_BANK           2048    /* from dhcp hosts file */
 #define CONFIG_ADDR6          4096
-#define CONFIG_WILDCARD       8192
+#define CONFIG_ADDR6_HOSTS   16384    /* address added by from /etc/hosts */
 
 struct dhcp_opt {
   int opt, len, flags;
@@ -877,21 +881,11 @@
 struct cond_domain {
   char *domain, *prefix;
   struct in_addr start, end;
-#ifdef HAVE_IPV6
   struct in6_addr start6, end6;
-#endif
   int is6, indexed;
   struct cond_domain *next;
 }; 
 
-#ifdef OPTION6_PREFIX_CLASS 
-struct prefix_class {
-  int class;
-  struct dhcp_netid tag;
-  struct prefix_class *next;
-};
-#endif
-
 struct ra_interface {
   char *name;
   char *mtu_name;
@@ -917,6 +911,16 @@
   struct dhcp_context *next, *current;
 };
 
+struct shared_network {
+  int if_index;
+  struct in_addr match_addr, shared_addr;
+#ifdef HAVE_DHCP6
+  /* shared_addr == 0 for IP6 entries. */
+  struct in6_addr match_addr6, shared_addr6;
+#endif
+  struct shared_network *next;
+};
+
 #define CONTEXT_STATIC         (1u<<0)
 #define CONTEXT_NETMASK        (1u<<1)
 #define CONTEXT_BRDCAST        (1u<<2)
@@ -959,6 +963,8 @@
   unsigned int block, blocksize, expansion;
   off_t offset;
   union mysockaddr peer;
+  union all_addr source;
+  int if_index;
   char opt_blocksize, opt_transize, netascii, carrylf;
   struct tftp_file *file;
   struct tftp_transfer *next;
@@ -977,7 +983,7 @@
 };
 
 struct dhcp_relay {
-  struct all_addr local, server;
+  union all_addr local, server;
   char *interface; /* Allowable interface for replies from server, and dest for IPv6 multicast */
   int iface_index; /* working - interface in which requests arrived, for return */
   struct dhcp_relay *current, *next;
@@ -988,7 +994,7 @@
      config file arguments. All set (including defaults)
      in option.c */
 
-  unsigned int options, options2;
+  unsigned int options[OPTION_SIZE];
   struct resolvc default_resolv, *resolv_files;
   time_t last_resolv;
   char *servers_file;
@@ -1060,9 +1066,6 @@
   int dump_mask;
   unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
   u32 metrics[__METRIC_MAX];
-#ifdef OPTION6_PREFIX_CLASS 
-  struct prefix_class *prefix_classes;
-#endif
 #ifdef HAVE_DNSSEC
   struct ds_config *ds;
   char *timestamp_file;
@@ -1075,7 +1078,7 @@
 #ifdef HAVE_DNSSEC
   char *keyname; /* MAXDNAME size buffer */
   char *workspacename; /* ditto */
-  char *rr_status; /* flags for individual RRs */
+  unsigned long *rr_status; /* ceiling in TTL from DNSSEC or zero for insecure */
   int rr_status_sz;
   int dnssec_no_time_check;
   int back_to_the_future;
@@ -1091,6 +1094,8 @@
   size_t packet_len;       /*      "        "        */
   struct randfd *rfd_save; /*      "        "        */
   pid_t tcp_pids[MAX_PROCS];
+  int tcp_pipes[MAX_PROCS];
+  int pipe_to_parent;
   struct randfd randomsocks[RANDOM_SOCKS];
   int v6pktinfo; 
   struct addrlist *interface_addrs; /* list of all addresses/prefix lengths associated with all local interfaces */
@@ -1112,6 +1117,7 @@
   struct ping_result *ping_results;
   FILE *lease_stream;
   struct dhcp_bridge *bridges;
+  struct shared_network *shared_networks;
 #ifdef HAVE_DHCP6
   int duid_len;
   unsigned char *duid;
@@ -1124,6 +1130,11 @@
 #ifdef HAVE_DBUS
   struct watch *watches;
 #endif
+  /* UBus stuff */
+#ifdef HAVE_UBUS
+  /* void * here to avoid depending on ubus headers outside ubus.c */
+  void *ubus;
+#endif
 
   /* TFTP stuff */
   struct tftp_transfer *tftp_trans, *tftp_done_trans;
@@ -1141,21 +1152,22 @@
 /* cache.c */
 void cache_init(void);
 void next_uid(struct crec *crecp);
-void log_query(unsigned int flags, char *name, struct all_addr *addr, char *arg); 
+void log_query(unsigned int flags, char *name, union all_addr *addr, char *arg); 
 char *record_source(unsigned int index);
 char *querystr(char *desc, unsigned short type);
 int cache_find_non_terminal(char *name, time_t now);
 struct crec *cache_find_by_addr(struct crec *crecp,
-				struct all_addr *addr, time_t now, 
+				union all_addr *addr, time_t now, 
 				unsigned int prot);
 struct crec *cache_find_by_name(struct crec *crecp, 
 				char *name, time_t now, unsigned int prot);
 void cache_end_insert(void);
 void cache_start_insert(void);
-struct crec *cache_insert(char *name, struct all_addr *addr,
-			  time_t now, unsigned long ttl, unsigned short flags);
+int cache_recv_insert(time_t now, int fd);
+struct crec *cache_insert(char *name, union all_addr *addr, unsigned short class, 
+			  time_t now, unsigned long ttl, unsigned int flags);
 void cache_reload(void);
-void cache_add_dhcp_entry(char *host_name, int prot, struct all_addr *host_address, time_t ttd);
+void cache_add_dhcp_entry(char *host_name, int prot, union all_addr *host_address, time_t ttd);
 struct in_addr a_record_from_hosts(char *name, time_t now);
 void cache_unhash_dhcp(void);
 void dump_cache(time_t now);
@@ -1169,21 +1181,19 @@
 		   struct crec **rhash, int hashsz);
 
 /* blockdata.c */
-#ifdef HAVE_DNSSEC
 void blockdata_init(void);
 void blockdata_report(void);
 struct blockdata *blockdata_alloc(char *data, size_t len);
 void *blockdata_retrieve(struct blockdata *block, size_t len, void *data);
+struct blockdata *blockdata_read(int fd, size_t len);
+void blockdata_write(struct blockdata *block, size_t len, int fd);
 void blockdata_free(struct blockdata *blocks);
-#endif
 
 /* domain.c */
 char *get_domain(struct in_addr addr);
-#ifdef HAVE_IPV6
 char *get_domain6(struct in6_addr *addr);
-#endif
-int is_name_synthetic(int flags, char *name, struct all_addr *addr);
-int is_rev_synth(int flag, struct all_addr *addr, char *name);
+int is_name_synthetic(int flags, char *name, union all_addr *addr);
+int is_rev_synth(int flag, union all_addr *addr, char *name);
 
 /* rfc1035.c */
 int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
@@ -1194,7 +1204,7 @@
 unsigned int extract_request(struct dns_header *header, size_t qlen, 
 			       char *name, unsigned short *typep);
 size_t setup_reply(struct dns_header *header, size_t  qlen,
-		   struct all_addr *addrp, unsigned int flags,
+		   union all_addr *addrp, unsigned int flags,
 		   unsigned long ttl);
 int extract_addresses(struct dns_header *header, size_t qlen, char *name,
 		      time_t now, char **ipsets, int is_sign, int check_rebind,
@@ -1212,10 +1222,7 @@
 int add_resource_record(struct dns_header *header, char *limit, int *truncp,
 			int nameoffset, unsigned char **pp, unsigned long ttl, 
 			int *offset, unsigned short type, unsigned short class, char *format, ...);
-unsigned char *skip_questions(struct dns_header *header, size_t plen);
-int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
-		 char *name, int isExtract, int extrabytes);
-int in_arpa_name_2_addr(char *namein, struct all_addr *addrp);
+int in_arpa_name_2_addr(char *namein, union all_addr *addrp);
 int private_net(struct in_addr addr, int ban_localhost);
 
 /* auth.c */
@@ -1231,7 +1238,7 @@
 int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
 int dnssec_validate_ds(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int class);
 int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, int *class,
-			  int check_unsigned, int *neganswer, int *nons);
+			  int check_unsigned, int *neganswer, int *nons, int *nsec_ttl);
 int dnskey_keytag(int alg, int flags, unsigned char *key, int keylen);
 size_t filter_rrsigs(struct dns_header *header, size_t plen);
 unsigned char* hash_questions(struct dns_header *header, size_t plen, char *name);
@@ -1265,11 +1272,9 @@
 time_t dnsmasq_time(void);
 int netmask_length(struct in_addr mask);
 int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask);
-#ifdef HAVE_IPV6
 int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen);
 u64 addr6part(struct in6_addr *addr);
 void setaddr6part(struct in6_addr *addr, u64 host);
-#endif
 int retry_send(ssize_t rc);
 void prettyprint_time(char *buf, unsigned int t);
 int prettyprint_addr(union mysockaddr *addr, char *buf);
@@ -1280,7 +1285,7 @@
 int expand_buf(struct iovec *iov, size_t size);
 char *print_mac(char *buff, unsigned char *mac, int len);
 int read_write(int fd, unsigned char *packet, int size, int rw);
-
+void close_fds(long max_fd, int spare1, int spare2, int spare3);
 int wildcard_match(const char* wildcard, const char* match);
 int wildcard_matchn(const char* wildcard, const char* match, int num);
 
@@ -1327,7 +1332,7 @@
 void server_gone(struct server *server);
 struct frec *get_new_frec(time_t now, int *wait, int force);
 int send_from(int fd, int nowild, char *packet, size_t len, 
-	       union mysockaddr *to, struct all_addr *source,
+	       union mysockaddr *to, union all_addr *source,
 	       unsigned int iface);
 void resend_query(void);
 struct randfd *allocate_rfd(int family);
@@ -1354,14 +1359,12 @@
 void warn_wild_labels(void);
 void warn_int_names(void);
 int is_dad_listeners(void);
-int iface_check(int family, struct all_addr *addr, char *name, int *auth);
-int loopback_exception(int fd, int family, struct all_addr *addr, char *name);
-int label_exception(int index, int family, struct all_addr *addr);
+int iface_check(int family, union all_addr *addr, char *name, int *auth);
+int loopback_exception(int fd, int family, union all_addr *addr, char *name);
+int label_exception(int index, int family, union all_addr *addr);
 int fix_fd(int fd);
 int tcp_interface(int fd, int af);
-#ifdef HAVE_IPV6
 int set_ipv6pktinfo(int fd);
-#endif
 #ifdef HAVE_DHCP6
 void join_multicast(int dienow);
 #endif
@@ -1399,14 +1402,15 @@
 #ifdef HAVE_DHCP6
 struct dhcp_lease *lease6_allocate(struct in6_addr *addrp, int lease_type);
 struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
-			       int lease_type, int iaid, struct in6_addr *addr);
+			       int lease_type, unsigned int iaid, struct in6_addr *addr);
 void lease6_reset(void);
-struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid);
+struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type,
+					 unsigned char *clid, int clid_len, unsigned int iaid);
 struct dhcp_lease *lease6_find_by_addr(struct in6_addr *net, int prefix, u64 addr);
 u64 lease_find_max_addr6(struct dhcp_context *context);
 void lease_ping_reply(struct in6_addr *sender, unsigned char *packet, char *interface);
 void lease_update_slaac(time_t now);
-void lease_set_iaid(struct dhcp_lease *lease, int iaid);
+void lease_set_iaid(struct dhcp_lease *lease, unsigned int iaid);
 void lease_make_duid(time_t now);
 #endif
 void lease_set_hwaddr(struct dhcp_lease *lease, const unsigned char *hwaddr,
@@ -1480,6 +1484,7 @@
 
 /* ubus.c */
 #ifdef HAVE_UBUS
+void ubus_init(void);
 void set_ubus_listeners(void);
 void check_ubus_listeners(void);
 void ubus_event_bcast(const char *type, const char *mac, const char *ip, const char *name, const char *interface);
@@ -1488,7 +1493,7 @@
 /* ipset.c */
 #ifdef HAVE_IPSET
 void ipset_init(void);
-int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags, int remove);
+int add_to_ipset(const char *setname, const union all_addr *ipaddr, int flags, int remove);
 #endif
 
 /* helper.c */
@@ -1501,7 +1506,7 @@
 void queue_tftp(off_t file_len, char *filename, union mysockaddr *peer);
 #endif
 void queue_arp(int action, unsigned char *mac, int maclen,
-	       int family, struct all_addr *addr);
+	       int family, union all_addr *addr);
 int helper_buf_empty(void);
 #endif
 
@@ -1514,7 +1519,7 @@
 
 /* conntrack.c */
 #ifdef HAVE_CONNTRACK
-int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr,
+int get_incoming_mark(union mysockaddr *peer_addr, union all_addr *local_addr,
 		      int istcp, unsigned int *markp);
 #endif
 
@@ -1523,8 +1528,7 @@
 void dhcp6_init(void);
 void dhcp6_packet(time_t now);
 struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
-				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans);
-int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr);
+				       unsigned int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans);
 struct dhcp_context *address6_available(struct dhcp_context *context, 
 					struct in6_addr *taddr,
 					struct dhcp_netid *netids,
@@ -1534,7 +1538,7 @@
 				    struct dhcp_netid *netids,
 				    int plain_range);
 struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, 
-					    int prefix, u64 addr);
+					    int prefix, struct in6_addr *addr);
 void make_duid(time_t now);
 void dhcp_construct_contexts(time_t now);
 void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, 
@@ -1567,13 +1571,12 @@
 void display_opts(void);
 int lookup_dhcp_opt(int prot, char *name);
 int lookup_dhcp_len(int prot, int val);
-char *option_string(int prot, unsigned int opt, unsigned char *val, 
-		    int opt_len, char *buf, int buf_len);
 struct dhcp_config *find_config(struct dhcp_config *configs,
 				struct dhcp_context *context,
 				unsigned char *clid, int clid_len,
 				unsigned char *hwaddr, int hw_len, 
-				int hw_type, char *hostname);
+				int hw_type, char *hostname,
+				struct dhcp_netid *filter);
 int config_has_mac(struct dhcp_config *config, unsigned char *hwaddr, int len, int type);
 #ifdef HAVE_LINUX_NETWORK
 char *whichdevice(void);
Index: src/forward.c
===================================================================
--- src/forward.c	(revision 41436)
+++ src/forward.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 /* Send a UDP packet with its source address set as "source" 
    unless nowild is true, when we just send it with the kernel default */
 int send_from(int fd, int nowild, char *packet, size_t len, 
-	      union mysockaddr *to, struct all_addr *source,
+	      union mysockaddr *to, union all_addr *source,
 	      unsigned int iface)
 {
   struct msghdr msg;
@@ -38,9 +38,7 @@
 #elif defined(IP_SENDSRCADDR)
     char control[CMSG_SPACE(sizeof(struct in_addr))];
 #endif
-#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
-#endif
   } control_u;
   
   iov[0].iov_base = packet;
@@ -66,40 +64,42 @@
 #if defined(HAVE_LINUX_NETWORK)
 	  struct in_pktinfo p;
 	  p.ipi_ifindex = 0;
-	  p.ipi_spec_dst = source->addr.addr4;
+	  p.ipi_spec_dst = source->addr4;
+	  msg.msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
 	  memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+	  cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
 	  cmptr->cmsg_level = IPPROTO_IP;
 	  cmptr->cmsg_type = IP_PKTINFO;
 #elif defined(IP_SENDSRCADDR)
-	  memcpy(CMSG_DATA(cmptr), &(source->addr.addr4), sizeof(source->addr.addr4));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_addr));
+	  msg.msg_controllen = CMSG_SPACE(sizeof(struct in_addr));
+	  memcpy(CMSG_DATA(cmptr), &(source->addr4), sizeof(source->addr4));
+	  cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_addr));
 	  cmptr->cmsg_level = IPPROTO_IP;
 	  cmptr->cmsg_type = IP_SENDSRCADDR;
 #endif
 	}
       else
-#ifdef HAVE_IPV6
 	{
 	  struct in6_pktinfo p;
 	  p.ipi6_ifindex = iface; /* Need iface for IPv6 to handle link-local addrs */
-	  p.ipi6_addr = source->addr.addr6;
+	  p.ipi6_addr = source->addr6;
+	  msg.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));
 	  memcpy(CMSG_DATA(cmptr), &p, sizeof(p));
-	  msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+	  cmptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
 	  cmptr->cmsg_type = daemon->v6pktinfo;
 	  cmptr->cmsg_level = IPPROTO_IPV6;
 	}
-#else
-      (void)iface; /* eliminate warning */
-#endif
     }
   
   while (retry_send(sendmsg(fd, &msg, 0)));
 
-  /* If interface is still in DAD, EINVAL results - ignore that. */
-  if (errno != 0 && errno != EINVAL)
+  if (errno != 0)
     {
-      my_syslog(LOG_ERR, _("failed to send packet: %s"), strerror(errno));
+#ifdef HAVE_LINUX_NETWORK
+      /* If interface is still in DAD, EINVAL results - ignore that. */
+      if (errno != EINVAL)
+	my_syslog(LOG_ERR, _("failed to send packet: %s"), strerror(errno));
+#endif
       return 0;
     }
   
@@ -106,7 +106,7 @@
   return 1;
 }
           
-static unsigned int search_servers(time_t now, struct all_addr **addrpp, unsigned int qtype,
+static unsigned int search_servers(time_t now, union all_addr **addrpp, unsigned int qtype,
 				   char *qdomain, int *type, char **domain, int *norebind)
 			      
 {
@@ -118,7 +118,7 @@
   unsigned int matchlen = 0;
   struct server *serv;
   unsigned int flags = 0;
-  static struct all_addr zero;
+  static union all_addr zero;
   
   for (serv = daemon->servers; serv; serv=serv->next)
     if (qtype == F_DNSSECOK && !(serv->flags & SERV_DO_DNSSEC))
@@ -128,7 +128,9 @@
       {
 	unsigned int sflag = serv->addr.sa.sa_family == AF_INET ? F_IPV4 : F_IPV6; 
 	*type = SERV_FOR_NODOTS;
-	if (serv->flags & SERV_NO_ADDR)
+	if ((serv->flags & SERV_NO_REBIND) && norebind)
+	  *norebind = 1;
+	else if (serv->flags & SERV_NO_ADDR)
 	  flags = F_NXDOMAIN;
 	else if (serv->flags & SERV_LITERAL_ADDRESS)
 	  { 
@@ -143,11 +145,9 @@
 	      {
 		flags = sflag;
 		if (serv->addr.sa.sa_family == AF_INET) 
-		  *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
-#ifdef HAVE_IPV6
+		  *addrpp = (union all_addr *)&serv->addr.in.sin_addr;
 		else
-		  *addrpp = (struct all_addr *)&serv->addr.in6.sin6_addr;
-#endif 
+		  *addrpp = (union all_addr *)&serv->addr.in6.sin6_addr;
 	      }
 	    else if (!flags || (flags & F_NXDOMAIN))
 	      flags = F_NOERR;
@@ -203,11 +203,9 @@
 			  {
 			    flags = sflag;
 			    if (serv->addr.sa.sa_family == AF_INET) 
-			      *addrpp = (struct all_addr *)&serv->addr.in.sin_addr;
-#ifdef HAVE_IPV6
+			      *addrpp = (union all_addr *)&serv->addr.in.sin_addr;
 			    else
-			      *addrpp = (struct all_addr *)&serv->addr.in6.sin6_addr;
-#endif
+			      *addrpp = (union all_addr *)&serv->addr.in6.sin6_addr;
 			  }
 			else if (!flags || (flags & F_NXDOMAIN))
 			  flags = F_NOERR;
@@ -236,10 +234,8 @@
 	   /* handle F_IPV4 and F_IPV6 set on ANY query to 0.0.0.0/:: domain. */
 	   if (flags & F_IPV4)
 	     log_query((flags | F_CONFIG | F_FORWARD) & ~F_IPV6, qdomain, *addrpp, NULL);
-#ifdef HAVE_IPV6
 	   if (flags & F_IPV6)
 	     log_query((flags | F_CONFIG | F_FORWARD) & ~F_IPV4, qdomain, *addrpp, NULL);
-#endif
 	 }
     }
   else if ((*type) & SERV_USE_RESOLV)
@@ -251,13 +247,13 @@
 }
 
 static int forward_query(int udpfd, union mysockaddr *udpaddr,
-			 struct all_addr *dst_addr, unsigned int dst_iface,
+			 union all_addr *dst_addr, unsigned int dst_iface,
 			 struct dns_header *header, size_t plen, time_t now, 
 			 struct frec *forward, int ad_reqd, int do_bit)
 {
   char *domain = NULL;
   int type = SERV_DO_DNSSEC, norebind = 0;
-  struct all_addr *addrp = NULL;
+  union all_addr *addrp = NULL;
   unsigned int flags = 0;
   struct server *start = NULL;
 #ifdef HAVE_DNSSEC
@@ -301,21 +297,18 @@
 	    PUTSHORT(SAFE_PKTSZ, pheader);
 	  
 	  if (forward->sentto->addr.sa.sa_family == AF_INET) 
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (struct all_addr *)&forward->sentto->addr.in.sin_addr, "dnssec");
-#ifdef HAVE_IPV6
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (union all_addr *)&forward->sentto->addr.in.sin_addr, "dnssec");
 	  else
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (struct all_addr *)&forward->sentto->addr.in6.sin6_addr, "dnssec");
-#endif
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (union all_addr *)&forward->sentto->addr.in6.sin6_addr, "dnssec");
+
   
 	  if (forward->sentto->sfd)
 	    fd = forward->sentto->sfd->fd;
 	  else
 	    {
-#ifdef HAVE_IPV6
 	      if (forward->sentto->addr.sa.sa_family == AF_INET6)
 		fd = forward->rfd6->fd;
 	      else
-#endif
 		fd = forward->rfd4->fd;
 	    }
 	  
@@ -475,7 +468,6 @@
 		fd = start->sfd->fd;
 	      else 
 		{
-#ifdef HAVE_IPV6
 		  if (start->addr.sa.sa_family == AF_INET6)
 		    {
 		      if (!forward->rfd6 &&
@@ -485,7 +477,6 @@
 		      fd = forward->rfd6->fd;
 		    }
 		  else
-#endif
 		    {
 		      if (!forward->rfd4 &&
 			  !(forward->rfd4 = allocate_rfd(AF_INET)))
@@ -540,12 +531,10 @@
 		    strcpy(daemon->namebuff, "query");
 		  if (start->addr.sa.sa_family == AF_INET)
 		    log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-			      (struct all_addr *)&start->addr.in.sin_addr, NULL); 
-#ifdef HAVE_IPV6
+			      (union all_addr *)&start->addr.in.sin_addr, NULL); 
 		  else
 		    log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
-			      (struct all_addr *)&start->addr.in6.sin6_addr, NULL);
-#endif 
+			      (union  all_addr *)&start->addr.in6.sin6_addr, NULL);
 		  start->queries++;
 		  forwarded = 1;
 		  forward->sentto = start;
@@ -676,8 +665,8 @@
 
   if (rcode != NOERROR && rcode != NXDOMAIN)
     {
-      struct all_addr a;
-      a.addr.rcode.rcode = rcode;
+      union all_addr a;
+      a.log.rcode = rcode;
       log_query(F_UPSTREAM | F_RCODE, "error", &a, NULL);
       
       return resize_packet(header, n, pheader, plen);
@@ -788,11 +777,8 @@
   daemon->srv_save = NULL;
   
   /* Determine the address of the server replying  so that we can mark that as good */
-  serveraddr.sa.sa_family = family;
-#ifdef HAVE_IPV6
-  if (serveraddr.sa.sa_family == AF_INET6)
+  if ((serveraddr.sa.sa_family = family) == AF_INET6)
     serveraddr.in6.sin6_flowinfo = 0;
-#endif
   
   header = (struct dns_header *)daemon->packet;
 
@@ -878,7 +864,6 @@
 	    fd = start->sfd->fd;
 	  else
 	    {
-#ifdef HAVE_IPV6
 	      if (start->addr.sa.sa_family == AF_INET6)
 		{
 		  /* may have changed family */
@@ -887,7 +872,6 @@
 		  fd = forward->rfd6->fd;
 		}
 	      else
-#endif
 		{
 		  /* may have changed family */
 		  if (!forward->rfd4)
@@ -895,17 +879,19 @@
 		  fd = forward->rfd4->fd;
 		}
 	    }
-	
+
+#ifdef HAVE_DUMPFILE
+	  dump_packet(DUMP_SEC_QUERY, (void *)header, (size_t)plen, NULL, &start->addr);
+#endif
+
 	  while (retry_send(sendto(fd, (char *)header, plen, 0,
 				   &start->addr.sa,
 				   sa_len(&start->addr))));
 	  
 	  if (start->addr.sa.sa_family == AF_INET) 
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (struct all_addr *)&start->addr.in.sin_addr, "dnssec");
-#ifdef HAVE_IPV6
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, "retry", (union all_addr *)&start->addr.in.sin_addr, "dnssec");
 	  else
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (struct all_addr *)&start->addr.in6.sin6_addr, "dnssec");
-#endif
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, "retry", (union all_addr *)&start->addr.in6.sin6_addr, "dnssec");
 	  
 	  return;
 	}
@@ -969,12 +955,12 @@
   /* We tried resending to this server with a smaller maximum size and got an answer.
      Make that permanent. To avoid reduxing the packet size for a single dropped packet,
      only do this when we get a truncated answer, or one larger than the safe size. */
-  if (server && server->edns_pktsz > SAFE_PKTSZ && (forward->flags & FREC_TEST_PKTSZ) && 
+  if (forward->sentto->edns_pktsz > SAFE_PKTSZ && (forward->flags & FREC_TEST_PKTSZ) && 
       ((header->hb3 & HB3_TC) || n >= SAFE_PKTSZ))
     {
-      server->edns_pktsz = SAFE_PKTSZ;
-      server->pktsz_reduced = now;
-      prettyprint_addr(&server->addr, daemon->addrbuff);
+      forward->sentto->edns_pktsz = SAFE_PKTSZ;
+      forward->sentto->pktsz_reduced = now;
+      prettyprint_addr(&forward->sentto->addr, daemon->addrbuff);
       my_syslog(LOG_WARNING, _("reducing DNS packet size for nameserver %s to %d"), daemon->addrbuff, SAFE_PKTSZ);
     }
 
@@ -983,8 +969,7 @@
      we get a good reply from another server. Kill it when we've
      had replies from all to avoid filling the forwarding table when
      everything is broken */
-  if (forward->forwardall == 0 || --forward->forwardall == 1 ||
-      (RCODE(header) != REFUSED && RCODE(header) != SERVFAIL))
+  if (forward->forwardall == 0 || --forward->forwardall == 1 || RCODE(header) != REFUSED)
     {
       int check_rebind = 0, no_cache_dnssec = 0, cache_secure = 0, bogusanswer = 0;
       
@@ -997,7 +982,7 @@
 	no_cache_dnssec = 1;
       
 #ifdef HAVE_DNSSEC
-      if (server && (server->flags & SERV_DO_DNSSEC) && 
+      if ((forward->sentto->flags & SERV_DO_DNSSEC) && 
 	  option_bool(OPT_DNSSEC_VALID) && !(forward->flags & FREC_CHECKING_DISABLED))
 	{
 	  int status = 0;
@@ -1027,8 +1012,8 @@
 		    status = dnssec_validate_ds(now, header, n, daemon->namebuff, daemon->keyname, forward->class);
 		  else
 		    status = dnssec_validate_reply(now, header, n, daemon->namebuff, daemon->keyname, &forward->class, 
-						   !option_bool(OPT_DNSSEC_IGN_NS) && (server->flags & SERV_DO_DNSSEC),
-						   NULL, NULL);
+						   !option_bool(OPT_DNSSEC_IGN_NS) && (forward->sentto->flags & SERV_DO_DNSSEC),
+						   NULL, NULL, NULL);
 #ifdef HAVE_DUMPFILE
 		  if (status == STAT_BOGUS)
 		    dump_packet((forward->flags & (FREC_DNSKEY_QUERY | FREC_DS_QUERY)) ? DUMP_SEC_BOGUS : DUMP_BOGUS,
@@ -1071,7 +1056,8 @@
 			 servers for domains are involved. */		      
 		      if (search_servers(now, NULL, F_DNSSECOK, daemon->keyname, &type, &domain, NULL) == 0)
 			{
-			  struct server *start = server, *new_server = NULL;
+			  struct server *start, *new_server = NULL;
+			  start = server = forward->sentto;
 			  
 			  while (1)
 			    {
@@ -1099,9 +1085,7 @@
 		      
 		      new->sentto = server;
 		      new->rfd4 = NULL;
-#ifdef HAVE_IPV6
 		      new->rfd6 = NULL;
-#endif
 		      new->flags &= ~(FREC_DNSKEY_QUERY | FREC_DS_QUERY | FREC_HAS_EXTRADATA);
 		      new->forwardall = 0;
 		      
@@ -1123,13 +1107,11 @@
 						 daemon->keyname, forward->class, querytype, server->edns_pktsz);
 
 		      if (server->addr.sa.sa_family == AF_INET) 
-			log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, daemon->keyname, (struct all_addr *)&(server->addr.in.sin_addr),
+			log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, daemon->keyname, (union all_addr *)&(server->addr.in.sin_addr),
 				  querystr("dnssec-query", querytype));
-#ifdef HAVE_IPV6
 		      else
-			log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, daemon->keyname, (struct all_addr *)&(server->addr.in6.sin6_addr),
+			log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, daemon->keyname, (union all_addr *)&(server->addr.in6.sin6_addr),
 				  querystr("dnssec-query", querytype));
-#endif
   
 		      if ((hash = hash_questions(header, nn, daemon->namebuff)))
 			memcpy(new->hash, hash, HASH_SIZE);
@@ -1147,7 +1129,6 @@
 		      else
 			{
 			  fd = -1;
-#ifdef HAVE_IPV6
 			  if (server->addr.sa.sa_family == AF_INET6)
 			    {
 			      if (new->rfd6 || (new->rfd6 = allocate_rfd(AF_INET6)))
@@ -1154,7 +1135,6 @@
 				fd = new->rfd6->fd;
 			    }
 			  else
-#endif
 			    {
 			      if (new->rfd4 || (new->rfd4 = allocate_rfd(AF_INET)))
 				fd = new->rfd4->fd;
@@ -1231,6 +1211,7 @@
 	      bogusanswer = 1;
 	    }
 	}
+
 #endif
 
       /* restore CD bit to the value in the query */
@@ -1277,7 +1258,7 @@
   union mysockaddr source_addr;
   unsigned char *pheader;
   unsigned short type, udp_size = PACKETSZ; /* default if no EDNS0 */
-  struct all_addr dst_addr;
+  union all_addr dst_addr;
   struct in_addr netmask, dst_addr_4;
   size_t m;
   ssize_t n;
@@ -1290,9 +1271,7 @@
   struct cmsghdr *cmptr;
   union {
     struct cmsghdr align; /* this ensures alignment */
-#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
-#endif
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(IP_RECVDSTADDR) && defined(HAVE_SOLARIS_NETWORK)
@@ -1303,17 +1282,13 @@
 		 CMSG_SPACE(sizeof(struct sockaddr_dl))];
 #endif
   } control_u;
-#ifdef HAVE_IPV6
    /* Can always get recvd interface for IPv6 */
   int check_dst = !option_bool(OPT_NOWILD) || listen->family == AF_INET6;
-#else
-  int check_dst = !option_bool(OPT_NOWILD);
-#endif
 
   /* packet buffer overwritten */
   daemon->srv_save = NULL;
   
-  dst_addr_4.s_addr = dst_addr.addr.addr4.s_addr = 0;
+  dst_addr_4.s_addr = dst_addr.addr4.s_addr = 0;
   netmask.s_addr = 0;
   
   if (option_bool(OPT_NOWILD) && listen->iface)
@@ -1322,7 +1297,7 @@
      
       if (listen->family == AF_INET)
 	{
-	  dst_addr_4 = dst_addr.addr.addr4 = listen->iface->addr.in.sin_addr;
+	  dst_addr_4 = dst_addr.addr4 = listen->iface->addr.in.sin_addr;
 	  netmask = listen->iface->netmask;
 	}
     }
@@ -1359,7 +1334,6 @@
       if (source_addr.in.sin_port == 0)
 	return;
     }
-#ifdef HAVE_IPV6
   else
     {
       /* Source-port == 0 is an error, we can't send back to that. */
@@ -1367,22 +1341,20 @@
 	return;
       source_addr.in6.sin6_flowinfo = 0;
     }
-#endif
   
   /* We can be configured to only accept queries from at-most-one-hop-away addresses. */
   if (option_bool(OPT_LOCAL_SERVICE))
     {
       struct addrlist *addr;
-#ifdef HAVE_IPV6
+
       if (listen->family == AF_INET6) 
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
 	    if ((addr->flags & ADDRLIST_IPV6) &&
-		is_same_net6(&addr->addr.addr.addr6, &source_addr.in6.sin6_addr, addr->prefixlen))
+		is_same_net6(&addr->addr.addr6, &source_addr.in6.sin6_addr, addr->prefixlen))
 	      break;
 	}
       else
-#endif
 	{
 	  struct in_addr netmask;
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1389,7 +1361,7 @@
 	    {
 	      netmask.s_addr = htonl(~(in_addr_t)0 << (32 - addr->prefixlen));
 	      if (!(addr->flags & ADDRLIST_IPV6) &&
-		  is_same_net(addr->addr.addr.addr4, source_addr.in.sin_addr, netmask))
+		  is_same_net(addr->addr.addr4, source_addr.in.sin_addr, netmask))
 		break;
 	    }
 	}
@@ -1422,7 +1394,7 @@
 		struct in_pktinfo *p;
 	      } p;
 	      p.c = CMSG_DATA(cmptr);
-	      dst_addr_4 = dst_addr.addr.addr4 = p.p->ipi_spec_dst;
+	      dst_addr_4 = dst_addr.addr4 = p.p->ipi_spec_dst;
 	      if_index = p.p->ipi_ifindex;
 	    }
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
@@ -1440,7 +1412,7 @@
 	      } p;
 	       p.c = CMSG_DATA(cmptr);
 	       if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVDSTADDR)
-		 dst_addr_4 = dst_addr.addr.addr4 = *(p.a);
+		 dst_addr_4 = dst_addr.addr4 = *(p.a);
 	       else if (cmptr->cmsg_level == IPPROTO_IP && cmptr->cmsg_type == IP_RECVIF)
 #ifdef HAVE_SOLARIS_NETWORK
 		 if_index = *(p.i);
@@ -1451,7 +1423,6 @@
 	}
 #endif
       
-#ifdef HAVE_IPV6
       if (listen->family == AF_INET6)
 	{
 	  for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
@@ -1463,11 +1434,10 @@
 		} p;
 		p.c = CMSG_DATA(cmptr);
 		  
-		dst_addr.addr.addr6 = p.p->ipi6_addr;
+		dst_addr.addr6 = p.p->ipi6_addr;
 		if_index = p.p->ipi6_ifindex;
 	      }
 	}
-#endif
       
       /* enforce available interface configuration */
       
@@ -1530,12 +1500,10 @@
       
       if (listen->family == AF_INET) 
 	log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
-		  (struct all_addr *)&source_addr.in.sin_addr, types);
-#ifdef HAVE_IPV6
+		  (union all_addr *)&source_addr.in.sin_addr, types);
       else
 	log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
-		  (struct all_addr *)&source_addr.in6.sin6_addr, types);
-#endif
+		  (union all_addr *)&source_addr.in6.sin6_addr, types);
 
 #ifdef HAVE_AUTH
       /* find queries for zones we're authoritative for, and answer them directly */
@@ -1644,7 +1612,7 @@
       else 
 	new_status = dnssec_validate_reply(now, header, n, name, keyname, &class,
 					   !option_bool(OPT_DNSSEC_IGN_NS) && (server->flags & SERV_DO_DNSSEC),
-					   NULL, NULL);
+					   NULL, NULL, NULL);
       
       if (new_status != STAT_NEED_DS && new_status != STAT_NEED_KEY)
 	break;
@@ -1681,6 +1649,8 @@
 	
       while (1)
 	{
+	  int data_sent = 0;
+	  
 	  if (!firstsendto)
 	    firstsendto = server;
 	  else
@@ -1713,8 +1683,7 @@
 		setsockopt(server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
 #endif	
 	      
-	      if (!local_bind(server->tcpfd,  &server->source_addr, server->interface, 0, 1) ||
-		  connect(server->tcpfd, &server->addr.sa, sa_len(&server->addr)) == -1)
+	      if (!local_bind(server->tcpfd,  &server->source_addr, server->interface, 0, 1))
 		{
 		  close(server->tcpfd);
 		  server->tcpfd = -1;
@@ -1721,10 +1690,25 @@
 		  continue; /* No good, next server */
 		}
 	      
+#ifdef MSG_FASTOPEN
+	      while(retry_send(sendto(server->tcpfd, packet, m + sizeof(u16),
+				      MSG_FASTOPEN, &server->addr.sa, sa_len(&server->addr))));
+	      
+	      if (errno == 0)
+		data_sent = 1;
+#endif
+	      
+	      if (!data_sent && connect(server->tcpfd, &server->addr.sa, sa_len(&server->addr)) == -1)
+		{
+		  close(server->tcpfd);
+		  server->tcpfd = -1;
+		  continue; /* No good, next server */
+		}
+	      
 	      server->flags &= ~SERV_GOT_TCP;
 	    }
 	  
-	  if (!read_write(server->tcpfd, packet, m + sizeof(u16), 0) ||
+	  if ((!data_sent && !read_write(server->tcpfd, packet, m + sizeof(u16), 0)) ||
 	      !read_write(server->tcpfd, &c1, 1, 1) ||
 	      !read_write(server->tcpfd, &c2, 1, 1) ||
 	      !read_write(server->tcpfd, payload, (c1 << 8) | c2, 1))
@@ -1742,13 +1726,11 @@
 
 
 	  if (server->addr.sa.sa_family == AF_INET) 
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, keyname, (struct all_addr *)&(server->addr.in.sin_addr),
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV4, keyname, (union all_addr *)&(server->addr.in.sin_addr),
 		      querystr("dnssec-query", new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS));
-#ifdef HAVE_IPV6
 	  else
-	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, keyname, (struct all_addr *)&(server->addr.in6.sin6_addr),
+	    log_query(F_NOEXTRA | F_DNSSEC | F_IPV6, keyname, (union all_addr *)&(server->addr.in6.sin6_addr),
 		      querystr("dnssec-query", new_status == STAT_NEED_KEY ? T_DNSKEY : T_DS));
-#endif
 	  
 	  server->flags |= SERV_GOT_TCP;
 	  
@@ -1812,13 +1794,12 @@
   /* Get connection mark of incoming query to set on outgoing connections. */
   if (option_bool(OPT_CONNTRACK))
     {
-      struct all_addr local;
-#ifdef HAVE_IPV6		      
+      union all_addr local;
+		      
       if (local_addr->sa.sa_family == AF_INET6)
-	local.addr.addr6 = local_addr->in6.sin6_addr;
+	local.addr6 = local_addr->in6.sin6_addr;
       else
-#endif
-	local.addr.addr4 = local_addr->in.sin_addr;
+	local.addr4 = local_addr->in.sin_addr;
       
       have_mark = get_incoming_mark(&peer_addr, &local, 1, &mark);
     }
@@ -1828,16 +1809,15 @@
   if (option_bool(OPT_LOCAL_SERVICE))
     {
       struct addrlist *addr;
-#ifdef HAVE_IPV6
+
       if (peer_addr.sa.sa_family == AF_INET6) 
 	{
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
 	    if ((addr->flags & ADDRLIST_IPV6) &&
-		is_same_net6(&addr->addr.addr.addr6, &peer_addr.in6.sin6_addr, addr->prefixlen))
+		is_same_net6(&addr->addr.addr6, &peer_addr.in6.sin6_addr, addr->prefixlen))
 	      break;
 	}
       else
-#endif
 	{
 	  struct in_addr netmask;
 	  for (addr = daemon->interface_addrs; addr; addr = addr->next)
@@ -1844,7 +1824,7 @@
 	    {
 	      netmask.s_addr = htonl(~(in_addr_t)0 << (32 - addr->prefixlen));
 	      if (!(addr->flags & ADDRLIST_IPV6) && 
-		  is_same_net(addr->addr.addr.addr4, peer_addr.in.sin_addr, netmask))
+		  is_same_net(addr->addr.addr4, peer_addr.in.sin_addr, netmask))
 		break;
 	    }
 	}
@@ -1891,12 +1871,10 @@
 	  
 	  if (peer_addr.sa.sa_family == AF_INET) 
 	    log_query(F_QUERY | F_IPV4 | F_FORWARD, daemon->namebuff, 
-		      (struct all_addr *)&peer_addr.in.sin_addr, types);
-#ifdef HAVE_IPV6
+		      (union all_addr *)&peer_addr.in.sin_addr, types);
 	  else
 	    log_query(F_QUERY | F_IPV6 | F_FORWARD, daemon->namebuff, 
-		      (struct all_addr *)&peer_addr.in6.sin6_addr, types);
-#endif
+		      (union all_addr *)&peer_addr.in6.sin6_addr, types);
 	  
 #ifdef HAVE_AUTH
 	  /* find queries for zones we're authoritative for, and answer them directly */
@@ -1952,7 +1930,7 @@
 	  if (m == 0)
 	    {
 	      unsigned int flags = 0;
-	      struct all_addr *addrp = NULL;
+	      union all_addr *addrp = NULL;
 	      int type = SERV_DO_DNSSEC;
 	      char *domain = NULL;
 	      unsigned char *oph = find_pseudoheader(header, size, NULL, NULL, NULL, NULL);
@@ -2003,6 +1981,8 @@
 		     which can go to the same server, do so. */
 		  while (1) 
 		    {
+		      int data_sent = 0;
+
 		      if (!firstsendto)
 			firstsendto = last_server;
 		      else
@@ -2021,6 +2001,8 @@
 			continue;
 
 		    retry:
+		      *length = htons(size);
+
 		      if (last_server->tcpfd == -1)
 			{
 			  if ((last_server->tcpfd = socket(last_server->addr.sa.sa_family, SOCK_STREAM, 0)) == -1)
@@ -2030,10 +2012,9 @@
 			  /* Copy connection mark of incoming query to outgoing connection. */
 			  if (have_mark)
 			    setsockopt(last_server->tcpfd, SOL_SOCKET, SO_MARK, &mark, sizeof(unsigned int));
-#endif	
+#endif			  
 		      
-			  if ((!local_bind(last_server->tcpfd,  &last_server->source_addr, last_server->interface, 0, 1) ||
-			       connect(last_server->tcpfd, &last_server->addr.sa, sa_len(&last_server->addr)) == -1))
+			  if ((!local_bind(last_server->tcpfd,  &last_server->source_addr, last_server->interface, 0, 1)))
 			    {
 			      close(last_server->tcpfd);
 			      last_server->tcpfd = -1;
@@ -2040,16 +2021,29 @@
 			      continue;
 			    }
 			  
+#ifdef MSG_FASTOPEN
+			    while(retry_send(sendto(last_server->tcpfd, packet, size + sizeof(u16),
+						    MSG_FASTOPEN, &last_server->addr.sa, sa_len(&last_server->addr))));
+			    
+			    if (errno == 0)
+			      data_sent = 1;
+#endif
+			    
+			    if (!data_sent && connect(last_server->tcpfd, &last_server->addr.sa, sa_len(&last_server->addr)) == -1)
+			    {
+			      close(last_server->tcpfd);
+			      last_server->tcpfd = -1;
+			      continue;
+			    }
+			  
 			  last_server->flags &= ~SERV_GOT_TCP;
 			}
 		      
-		      *length = htons(size);
-
 		      /* get query name again for logging - may have been overwritten */
 		      if (!(gotname = extract_request(header, (unsigned int)size, daemon->namebuff, &qtype)))
 			strcpy(daemon->namebuff, "query");
 		      
-		      if (!read_write(last_server->tcpfd, packet, size + sizeof(u16), 0) ||
+		      if ((!data_sent && !read_write(last_server->tcpfd, packet, size + sizeof(u16), 0)) ||
 			  !read_write(last_server->tcpfd, &c1, 1, 1) ||
 			  !read_write(last_server->tcpfd, &c2, 1, 1) ||
 			  !read_write(last_server->tcpfd, payload, (c1 << 8) | c2, 1))
@@ -2071,12 +2065,10 @@
 		      
 		      if (last_server->addr.sa.sa_family == AF_INET)
 			log_query(F_SERVER | F_IPV4 | F_FORWARD, daemon->namebuff, 
-				  (struct all_addr *)&last_server->addr.in.sin_addr, NULL); 
-#ifdef HAVE_IPV6
+				  (union all_addr *)&last_server->addr.in.sin_addr, NULL); 
 		      else
 			log_query(F_SERVER | F_IPV6 | F_FORWARD, daemon->namebuff, 
-				  (struct all_addr *)&last_server->addr.in6.sin6_addr, NULL);
-#endif 
+				  (union all_addr *)&last_server->addr.in6.sin6_addr, NULL);
 
 #ifdef HAVE_DNSSEC
 		      if (option_bool(OPT_DNSSEC_VALID) && !checking_disabled && (last_server->flags & SERV_DO_DNSSEC))
@@ -2175,9 +2167,7 @@
       f->sentto = NULL;
       f->rfd4 = NULL;
       f->flags = 0;
-#ifdef HAVE_IPV6
       f->rfd6 = NULL;
-#endif
 #ifdef HAVE_DNSSEC
       f->dependent = NULL;
       f->blocking_query = NULL;
@@ -2237,11 +2227,8 @@
   f->rfd4 = NULL;
   f->sentto = NULL;
   f->flags = 0;
-  
-#ifdef HAVE_IPV6
   free_rfd(f->rfd6);
   f->rfd6 = NULL;
-#endif
 
 #ifdef HAVE_DNSSEC
   if (f->stash)
Index: src/option.c
===================================================================
--- src/option.c	(revision 41436)
+++ src/option.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -129,9 +129,6 @@
 #define LOPT_AUTHPEER      318
 #define LOPT_IPSET         319
 #define LOPT_SYNTH         320
-#ifdef OPTION6_PREFIX_CLASS 
-#define LOPT_PREF_CLSS     321
-#endif
 #define LOPT_RELAY         323
 #define LOPT_RA_PARAM      324
 #define LOPT_ADD_SBNET     325
@@ -166,6 +163,10 @@
 #define LOPT_UBUS          354
 #define LOPT_NAME_MATCH    355
 #define LOPT_CAA           356
+#define LOPT_SHARED_NET    357
+#define LOPT_IGNORE_CLID   358
+#define LOPT_SINGLE_PORT   359
+#define LOPT_SCRIPT_TIME   360
  
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -245,6 +246,7 @@
     { "conf-dir", 1, 0, '7' },
     { "log-facility", 1, 0 ,'8' },
     { "leasefile-ro", 0, 0, '9' },
+    { "script-on-renewal", 0, 0, LOPT_SCRIPT_TIME},
     { "dns-forward-max", 1, 0, '0' },
     { "clear-on-reload", 0, 0, LOPT_RELOAD },
     { "dhcp-ignore-names", 2, 0, LOPT_NO_NAMES },
@@ -256,9 +258,11 @@
     { "tftp-max", 1, 0, LOPT_TFTP_MAX },
     { "tftp-mtu", 1, 0, LOPT_TFTP_MTU },
     { "tftp-lowercase", 0, 0, LOPT_TFTP_LC },
+    { "tftp-single-port", 0, 0, LOPT_SINGLE_PORT },
     { "ptr-record", 1, 0, LOPT_PTR },
     { "naptr-record", 1, 0, LOPT_NAPTR },
     { "bridge-interface", 1, 0 , LOPT_BRIDGE },
+    { "shared-network", 1, 0, LOPT_SHARED_NET },
     { "dhcp-option-force", 1, 0, LOPT_FORCE },
     { "tftp-no-blocksize", 0, 0, LOPT_NOBLOCK },
     { "log-dhcp", 0, 0, LOPT_LOG_OPTS },
@@ -322,9 +326,6 @@
     { "dnssec-check-unsigned", 2, 0, LOPT_DNSSEC_CHECK },
     { "dnssec-no-timecheck", 0, 0, LOPT_DNSSEC_TIME },
     { "dnssec-timestamp", 1, 0, LOPT_DNSSEC_STAMP },
-#ifdef OPTION6_PREFIX_CLASS 
-    { "dhcp-prefix-class", 1, 0, LOPT_PREF_CLSS },
-#endif
     { "dhcp-relay", 1, 0, LOPT_RELAY },
     { "ra-param", 1, 0, LOPT_RA_PARAM },
     { "quiet-dhcp", 0, 0, LOPT_QUIET_DHCP },
@@ -337,6 +338,7 @@
     { "dhcp-rapid-commit", 0, 0, LOPT_RAPID_COMMIT },
     { "dumpfile", 1, 0, LOPT_DUMPFILE },
     { "dumpmask", 1, 0, LOPT_DUMPMASK },
+    { "dhcp-ignore-clid", 0, 0,  LOPT_IGNORE_CLID },
     { NULL, 0, 0, 0 }
   };
 
@@ -431,6 +433,7 @@
   { '3', ARG_DUP, "[=tag:<tag>]...", gettext_noop("Enable dynamic address allocation for bootp."), NULL },
   { '4', ARG_DUP, "set:<tag>,<mac address>", gettext_noop("Map MAC address (with wildcards) to option set."), NULL },
   { LOPT_BRIDGE, ARG_DUP, "<iface>,<alias>..", gettext_noop("Treat DHCP requests on aliases as arriving from interface."), NULL },
+  { LOPT_SHARED_NET, ARG_DUP, "<iface>|<addr>,<addr>", gettext_noop("Specify extra networks sharing a broadcast domain for DHCP"), NULL},
   { '5', OPT_NO_PING, NULL, gettext_noop("Disable ICMP echo address checking in the DHCP server."), NULL },
   { '6', ARG_ONE, "<path>", gettext_noop("Shell script to run on DHCP lease creation and destruction."), NULL },
   { LOPT_LUASCRIPT, ARG_DUP, "path", gettext_noop("Lua script to run on DHCP lease creation and destruction."), NULL },
@@ -453,6 +456,7 @@
   { LOPT_NOBLOCK, OPT_TFTP_NOBLOCK, NULL, gettext_noop("Disable the TFTP blocksize extension."), NULL },
   { LOPT_TFTP_LC, OPT_TFTP_LC, NULL, gettext_noop("Convert TFTP filenames to lowercase"), NULL },
   { LOPT_TFTPPORTS, ARG_ONE, "<start>,<end>", gettext_noop("Ephemeral port range for use by TFTP transfers."), NULL },
+  { LOPT_SINGLE_PORT, OPT_SINGLE_PORT, NULL, gettext_noop("Use only one port for TFTP server."), NULL },
   { LOPT_LOG_OPTS, OPT_LOG_OPTS, NULL, gettext_noop("Extra logging for DHCP."), NULL },
   { LOPT_MAX_LOGS, ARG_ONE, "[=<integer>]", gettext_noop("Enable async. logging; optionally set queue length."), NULL },
   { LOPT_REBIND, OPT_NO_REBIND, NULL, gettext_noop("Stop DNS rebinding. Filter private IP ranges when resolving."), NULL },
@@ -478,6 +482,7 @@
   { LOPT_CPE_ID, ARG_ONE, "<text>", gettext_noop("Add client identification to forwarded DNS queries."), NULL },
   { LOPT_DNSSEC, OPT_DNSSEC_PROXY, NULL, gettext_noop("Proxy DNSSEC validation results from upstream nameservers."), NULL },
   { LOPT_INCR_ADDR, OPT_CONSEC_ADDR, NULL, gettext_noop("Attempt to allocate sequential IP addresses to DHCP clients."), NULL },
+  { LOPT_IGNORE_CLID, OPT_IGNORE_CLID, NULL, gettext_noop("Ignore client identifier option sent by DHCP clients."), NULL },
   { LOPT_CONNTRACK, OPT_CONNTRACK, NULL, gettext_noop("Copy connection-track mark from queries to upstream connections."), NULL },
   { LOPT_FQDN, OPT_FQDN_UPDATE, NULL, gettext_noop("Allow DHCP clients to do their own DDNS updates."), NULL },
   { LOPT_RA, OPT_RA, NULL, gettext_noop("Send router-advertisements for interfaces doing DHCPv6"), NULL },
@@ -500,9 +505,6 @@
   { LOPT_DNSSEC_CHECK, ARG_DUP, NULL, gettext_noop("Ensure answers without DNSSEC are in unsigned zones."), NULL },
   { LOPT_DNSSEC_TIME, OPT_DNSSEC_TIME, NULL, gettext_noop("Don't check DNSSEC signature timestamps until first cache-reload"), NULL },
   { LOPT_DNSSEC_STAMP, ARG_ONE, "<path>", gettext_noop("Timestamp file to verify system clock for DNSSEC"), NULL },
-#ifdef OPTION6_PREFIX_CLASS 
-  { LOPT_PREF_CLSS, ARG_DUP, "set:tag,<class>", gettext_noop("Specify DHCPv6 prefix class"), NULL },
-#endif
   { LOPT_RA_PARAM, ARG_DUP, "<iface>,[mtu:<value>|<interface>|off,][<prio>,]<intval>[,<lifetime>]", gettext_noop("Set MTU, priority, resend-interval and router-lifetime"), NULL },
   { LOPT_QUIET_DHCP, OPT_QUIET_DHCP, NULL, gettext_noop("Do not log routine DHCP."), NULL },
   { LOPT_QUIET_DHCP6, OPT_QUIET_DHCP6, NULL, gettext_noop("Do not log routine DHCPv6."), NULL },
@@ -515,6 +517,7 @@
   { LOPT_RAPID_COMMIT, OPT_RAPID_COMMIT, NULL, gettext_noop("Enables DHCPv4 Rapid Commit option."), NULL },
   { LOPT_DUMPFILE, ARG_ONE, "<path>", gettext_noop("Path to debug packet dump file"), NULL },
   { LOPT_DUMPMASK, ARG_ONE, "<hex>", gettext_noop("Mask which packets to dump"), NULL },
+  { LOPT_SCRIPT_TIME, OPT_LEASE_RENEW, NULL, gettext_noop("Call dhcp-script when lease expiry changes."), NULL },
   { 0, 0, NULL, NULL, NULL }
 }; 
 
@@ -577,14 +580,15 @@
   return ret;
 }
 
-static char *opt_string_alloc(char *cp)
+static char *opt_string_alloc(const char *cp)
 {
   char *ret = NULL;
+  size_t len;
   
-  if (cp && strlen(cp) != 0)
+  if (cp && (len = strlen(cp)) != 0)
     {
-      ret = opt_malloc(strlen(cp)+1);
-      strcpy(ret, cp); 
+      ret = opt_malloc(len+1);
+      memcpy(ret, cp, len+1); 
       
       /* restore hidden metachars */
       unhide_metas(ret);
@@ -759,15 +763,15 @@
 }
 
 #define ret_err(x) do { strcpy(errstr, (x)); return 0; } while (0)
+#define ret_err_free(x,m) do { strcpy(errstr, (x)); free((m)); return 0; } while (0)
+#define goto_err(x) do { strcpy(errstr, (x)); goto on_error; } while (0)
 
 static char *parse_mysockaddr(char *arg, union mysockaddr *addr) 
 {
   if (inet_pton(AF_INET, arg, &addr->in.sin_addr) > 0)
     addr->sa.sa_family = AF_INET;
-#ifdef HAVE_IPV6
   else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0)
     addr->sa.sa_family = AF_INET6;
-#endif
   else
     return _("bad address");
    
@@ -779,10 +783,8 @@
   int source_port = 0, serv_port = NAMESERVER_PORT;
   char *portno, *source;
   char *interface_opt = NULL;
-#ifdef HAVE_IPV6
   int scope_index = 0;
   char *scope_id;
-#endif
   
   if (!arg || strlen(arg) == 0)
     {
@@ -800,9 +802,7 @@
       !atoi_check16(portno, &serv_port))
     return _("bad port");
   
-#ifdef HAVE_IPV6
   scope_id = split_chr(arg, '%');
-#endif
   
   if (source) {
     interface_opt = split_chr(source, '@');
@@ -846,7 +846,6 @@
 	    }
 	}
     }
-#ifdef HAVE_IPV6
   else if (inet_pton(AF_INET6, arg, &addr->in6.sin6_addr) > 0)
     {
       if (scope_id && (scope_index = if_nametoindex(scope_id)) == 0)
@@ -881,7 +880,6 @@
 	    }
 	}
     }
-#endif
   else
     return _("bad address");
 
@@ -912,6 +910,8 @@
       p += sprintf(p, "%d.", (a >> 24) & 0xff);
       break;
     default:
+      free(serv->domain);
+      free(serv);
       return NULL;
     }
 
@@ -966,6 +966,116 @@
    return arg;
 }
 
+static struct dhcp_netid *dhcp_netid_create(const char *net, struct dhcp_netid *next)
+{
+  struct dhcp_netid *tt;
+  tt = opt_malloc(sizeof (struct dhcp_netid));
+  tt->net = opt_string_alloc(net);
+  tt->next = next;
+  return tt;
+}
+
+static void dhcp_netid_free(struct dhcp_netid *nid)
+{
+  while (nid)
+    {
+      struct dhcp_netid *tmp = nid;
+      nid = nid->next;
+      free(tmp->net);
+      free(tmp);
+    }
+}
+
+/* Parse one or more tag:s before parameters.
+ * Moves arg to the end of tags. */
+static struct dhcp_netid * dhcp_tags(char **arg)
+{
+  struct dhcp_netid *id = NULL;
+
+  while (is_tag_prefix(*arg))
+    {
+      char *comma = split(*arg);
+      id = dhcp_netid_create((*arg)+4, id);
+      *arg = comma;
+    };
+  if (!*arg)
+    {
+      dhcp_netid_free(id);
+      id = NULL;
+    }
+  return id;
+}
+
+static void dhcp_netid_list_free(struct dhcp_netid_list *netid)
+{
+  while (netid)
+    {
+      struct dhcp_netid_list *tmplist = netid;
+      netid = netid->next;
+      dhcp_netid_free(tmplist->list);
+      free(tmplist);
+    }
+}
+
+static void dhcp_config_free(struct dhcp_config *config)
+{
+  if (config)
+    {
+      struct hwaddr_config *hwaddr = config->hwaddr;
+      
+      while (hwaddr)
+        {
+	  struct hwaddr_config *tmp = hwaddr;
+          hwaddr = hwaddr->next;
+	  free(tmp);
+        }
+      
+      dhcp_netid_list_free(config->netid);
+      dhcp_netid_free(config->filter);
+      
+      if (config->flags & CONFIG_CLID)
+        free(config->clid);
+
+#ifdef HAVE_DHCP6
+      if (config->flags & CONFIG_ADDR6)
+	{
+	  struct addrlist *addr, *tmp;
+	  
+	  for (addr = config->addr6; addr; addr = tmp)
+	    {
+	      tmp = addr->next;
+	      free(addr);
+	    }
+	}
+#endif
+
+      free(config);
+    }
+}
+
+static void dhcp_context_free(struct dhcp_context *ctx)
+{
+  if (ctx)
+    {
+      dhcp_netid_free(ctx->filter);
+      free(ctx->netid.net);
+#ifdef HAVE_DHCP6
+      free(ctx->template_interface);
+#endif
+      free(ctx);
+    }
+}
+
+static void dhcp_opt_free(struct dhcp_opt *opt)
+{
+  if (opt->flags & DHOPT_VENDOR)
+    free(opt->u.vendor_class);
+  dhcp_netid_free(opt->netid);
+  free(opt->val);
+  free(opt);
+}
+
+
 /* This is too insanely large to keep in-line in the switch */
 static int parse_dhcp_opt(char *errstr, char *arg, int flags)
 {
@@ -973,7 +1083,6 @@
   char lenchar = 0, *cp;
   int addrs, digs, is_addr, is_addr6, is_hex, is_dec, is_string, dots;
   char *comma = NULL;
-  struct dhcp_netid *np = NULL;
   u16 opt_len = 0;
   int is6 = 0;
   int option_ok = 0;
@@ -1060,14 +1169,9 @@
 	}
       else
 	{
-	  new->netid = opt_malloc(sizeof (struct dhcp_netid));
 	  /* allow optional "net:" or "tag:" for consistency */
-	  if (is_tag_prefix(arg))
-	    new->netid->net = opt_string_alloc(arg+4);
-	  else
-	    new->netid->net = opt_string_alloc(set_prefix(arg));
-	  new->netid->next = np;
-	  np = new->netid;
+	  const char *name = (is_tag_prefix(arg)) ? arg+4 : set_prefix(arg);
+	  new->netid = dhcp_netid_create(name, new->netid);
 	}
       
       arg = comma; 
@@ -1077,7 +1181,7 @@
   if (is6)
     {
       if (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))
-	ret_err(_("unsupported encapsulation for IPv6 option"));
+	goto_err(_("unsupported encapsulation for IPv6 option"));
       
       if (opt_len == 0 &&
 	  !(new->flags & DHOPT_RFC3925))
@@ -1091,13 +1195,13 @@
   
   /* option may be missing with rfc3925 match */
   if (!option_ok)
-    ret_err(_("bad dhcp-option"));
+    goto_err(_("bad dhcp-option"));
   
   if (comma)
     {
       /* characterise the value */
       char c;
-      int found_dig = 0;
+      int found_dig = 0, found_colon = 0;
       is_addr = is_addr6 = is_hex = is_dec = is_string = 1;
       addrs = digs = 1;
       dots = 0;
@@ -1111,6 +1215,7 @@
 	  {
 	    digs++;
 	    is_dec = is_addr = 0;
+	    found_colon = 1;
 	  }
 	else if (c == '/') 
 	  {
@@ -1152,6 +1257,15 @@
      
       if (!found_dig)
 	is_dec = is_addr = 0;
+
+      if (!found_colon)
+	is_addr6 = 0;
+
+#ifdef HAVE_DHCP6
+      /* NTP server option takes hex, addresses or FQDN */
+      if (is6 && new->opt == OPTION6_NTP_SERVER && !is_hex)
+	opt_len |= is_addr6 ? OT_ADDR_LIST : OT_RFC1035_NAME;
+#endif
      
       /* We know that some options take addresses */
       if (opt_len & OT_ADDR_LIST)
@@ -1159,10 +1273,10 @@
 	  is_string = is_dec = is_hex = 0;
 	  
 	  if (!is6 && (!is_addr || dots == 0))
-	    ret_err(_("bad IP address"));
+	    goto_err(_("bad IP address"));
 
 	   if (is6 && !is_addr6)
-	     ret_err(_("bad IPv6 address"));
+	     goto_err(_("bad IPv6 address"));
 	}
       /* or names */
       else if (opt_len & (OT_NAME | OT_RFC1035_NAME | OT_CSTRING))
@@ -1255,7 +1369,7 @@
 	      comma = split(cp);
 	      slash = split_chr(cp, '/');
 	      if (!inet_pton(AF_INET, cp, &in))
-		ret_err(_("bad IPv4 address"));
+		goto_err(_("bad IPv4 address"));
 	      if (!slash)
 		{
 		  memcpy(op, &in, INADDRSZ);
@@ -1300,8 +1414,8 @@
 		  op += IN6ADDRSZ;
 		  continue;
 		}
-	  
-	      ret_err(_("bad IPv6 address"));
+
+	      goto_err(_("bad IPv6 address"));
 	    } 
 	  new->len = op - new->val;
 	}
@@ -1328,7 +1442,7 @@
 		  if (strcmp (arg, ".") != 0)
 		    {
 		      if (!(dom = canonicalise_opt(arg)))
-			ret_err(_("bad domain in dhcp-option"));
+			goto_err(_("bad domain in dhcp-option"));
 			
 		      domlen = strlen(dom) + 2;
 		    }
@@ -1375,7 +1489,7 @@
 		}
       
 	      /* RFC 3361, enc byte is zero for names */
-	      if (new->opt == OPTION_SIP_SERVER)
+	      if (new->opt == OPTION_SIP_SERVER && m)
 		m[0] = 0;
 	      new->len = (int) len + header_size;
 	      new->val = m;
@@ -1413,8 +1527,9 @@
 	    }
 	  else if (comma && (opt_len & OT_RFC1035_NAME))
 	    {
-	      unsigned char *p = NULL, *newp, *end;
+	      unsigned char *p = NULL, *q, *newp, *end;
 	      int len = 0;
+	      int header_size = (is6 && new->opt == OPTION6_NTP_SERVER) ? 4 : 0;
 	      arg = comma;
 	      comma = split(arg);
 	      
@@ -1422,9 +1537,9 @@
 		{
 		  char *dom = canonicalise_opt(arg);
 		  if (!dom)
-		    ret_err(_("bad domain in dhcp-option"));
+		    goto_err(_("bad domain in dhcp-option"));
 		    		  
-		  newp = opt_malloc(len + strlen(dom) + 2);
+		  newp = opt_malloc(len + header_size + strlen(dom) + 2);
 		  
 		  if (p)
 		    {
@@ -1433,8 +1548,14 @@
 		    }
 		  
 		  p = newp;
-		  end = do_rfc1035_name(p + len, dom, NULL);
+		  q = p + len;
+		  end = do_rfc1035_name(q + header_size, dom, NULL);
 		  *end++ = 0;
+		  if (is6 && new->opt == OPTION6_NTP_SERVER)
+		    {
+		      PUTSHORT(NTP_SUBOPTION_SRV_FQDN, q);
+		      PUTSHORT(end - q - 2, q);
+		    }
 		  len = end - p;
 		  free(dom);
 
@@ -1460,7 +1581,7 @@
       ((new->len > 255) || 
       (new->len > 253 && (new->flags & (DHOPT_VENDOR | DHOPT_ENCAPSULATE))) ||
        (new->len > 250 && (new->flags & DHOPT_RFC3925))))
-    ret_err(_("dhcp-option too long"));
+    goto_err(_("dhcp-option too long"));
   
   if (flags == DHOPT_MATCH)
     {
@@ -1467,7 +1588,7 @@
       if ((new->flags & (DHOPT_ENCAPSULATE | DHOPT_VENDOR)) ||
 	  !new->netid ||
 	  new->netid->next)
-	ret_err(_("illegal dhcp-match"));
+	goto_err(_("illegal dhcp-match"));
        
       if (is6)
 	{
@@ -1492,6 +1613,9 @@
     }
     
   return 1;
+on_error:
+  dhcp_opt_free(new);
+  return 0;
 }
 
 #endif
@@ -1498,20 +1622,24 @@
 
 void set_option_bool(unsigned int opt)
 {
-  if (opt < 32)
-    daemon->options |= 1u << opt;
-  else
-    daemon->options2 |= 1u << (opt - 32);
+  option_var(opt) |= option_val(opt);
 }
 
 void reset_option_bool(unsigned int opt)
 {
-  if (opt < 32)
-    daemon->options &= ~(1u << opt);
-  else
-    daemon->options2 &= ~(1u << (opt - 32));
+  option_var(opt) &= ~(option_val(opt));
 }
 
+static void server_list_free(struct server *list)
+{
+  while (list)
+    {
+      struct server *tmp = list;
+      list = list->next;
+      free(tmp);
+    }
+}
+
 static int one_opt(int option, char *arg, char *errstr, char *gen_err, int command_line, int servers_only)
 {      
   int i;
@@ -1570,9 +1698,9 @@
 	struct dirent *ent;
 	char *directory, *path;
 	struct list {
-	  char *suffix;
+	  char *name;
 	  struct list *next;
-	} *ignore_suffix = NULL, *match_suffix = NULL, *li;
+	} *ignore_suffix = NULL, *match_suffix = NULL, *files = NULL, *li;
 	
 	comma = split(arg);
 	if (!(directory = opt_string_alloc(arg)))
@@ -1594,7 +1722,7 @@
 			li->next = match_suffix;
 			match_suffix = li;
 			/* Have to copy: buffer is overwritten */
-			li->suffix = opt_string_alloc(arg+1);
+			li->name = opt_string_alloc(arg+1);
 		      }
 		  }
 		else
@@ -1602,7 +1730,7 @@
 		    li->next = ignore_suffix;
 		    ignore_suffix = li;
 		    /* Have to copy: buffer is overwritten */
-		    li->suffix = opt_string_alloc(arg);
+		    li->name = opt_string_alloc(arg);
 		  }
 	      }
 	  }
@@ -1627,9 +1755,9 @@
 		for (li = match_suffix; li; li = li->next)
 		  {
 		    /* check for required suffices */
-		    size_t ls = strlen(li->suffix);
+		    size_t ls = strlen(li->name);
 		    if (len > ls &&
-			strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
+			strcmp(li->name, &ent->d_name[len - ls]) == 0)
 		      break;
 		  }
 		if (!li)
@@ -1639,9 +1767,9 @@
 	    for (li = ignore_suffix; li; li = li->next)
 	      {
 		/* check for proscribed suffices */
-		size_t ls = strlen(li->suffix);
+		size_t ls = strlen(li->name);
 		if (len > ls &&
-		    strcmp(li->suffix, &ent->d_name[len - ls]) == 0)
+		    strcmp(li->name, &ent->d_name[len - ls]) == 0)
 		  break;
 	      }
 	    if (li)
@@ -1658,25 +1786,44 @@
 	    
 	    /* only reg files allowed. */
 	    if (S_ISREG(buf.st_mode))
-	      one_file(path, 0);
-	    
-	    free(path);
+	      {
+		/* sort files into order. */
+		struct list **up, *new = opt_malloc(sizeof(struct list));
+		new->name = path;
+		
+		for (up = &files, li = files; li; up = &li->next, li = li->next)
+		  if (strcmp(li->name, path) >=0)
+		    break;
+
+		new->next = li;
+		*up = new;
+	      }
+
 	  }
-     
+
+	for (li = files; li; li = li->next)
+	  one_file(li->name, 0);
+      	
 	closedir(dir_stream);
 	free(directory);
 	for(; ignore_suffix; ignore_suffix = li)
 	  {
 	    li = ignore_suffix->next;
-	    free(ignore_suffix->suffix);
+	    free(ignore_suffix->name);
 	    free(ignore_suffix);
 	  }
 	for(; match_suffix; match_suffix = li)
 	  {
 	    li = match_suffix->next;
-	    free(match_suffix->suffix);
+	    free(match_suffix->name);
 	    free(match_suffix);
 	  }
+	for(; files; files = li)
+	  {
+	    li = files->next;
+	    free(files->name);
+	    free(files);
+	  }
 	break;
       }
 
@@ -1693,13 +1840,13 @@
 	      /* has subnet+len */
 	      err = parse_mysockaddr(arg, &new->addr);
 	      if (err)
-		ret_err(err);
+		ret_err_free(err, new);
 	      if (!atoi_check(end, &new->mask))
-		ret_err(gen_err);
+		ret_err_free(gen_err, new);
 	      new->addr_used = 1;
 	    } 
 	  else if (!atoi_check(arg, &new->mask))
-	    ret_err(gen_err);
+	    ret_err_free(gen_err, new);
 	    
           daemon->add_subnet4 = new;
 
@@ -1711,15 +1858,15 @@
 		  /* has subnet+len */
                   err = parse_mysockaddr(comma, &new->addr);
                   if (err)
-                    ret_err(err);
+                    ret_err_free(err, new);
                   if (!atoi_check(end, &new->mask))
-                    ret_err(gen_err);
+                    ret_err_free(gen_err, new);
                   new->addr_used = 1;
                 }
               else
                 {
                   if (!atoi_check(comma, &new->mask))
-                    ret_err(gen_err);
+                    ret_err_free(gen_err, new);
                 }
           
 	      daemon->add_subnet6 = new;
@@ -1842,9 +1989,7 @@
       /* Sorry about the gross pre-processor abuse */
     case '6':             /* --dhcp-script */
     case LOPT_LUASCRIPT:  /* --dhcp-luascript */
-#  if defined(NO_FORK)
-      ret_err(_("cannot run scripts under uClinux"));
-#  elif !defined(HAVE_SCRIPT)
+#  if !defined(HAVE_SCRIPT)
       ret_err(_("recompile with HAVE_SCRIPT defined to enable lease-change scripts"));
 #  else
       if (option == LOPT_LUASCRIPT)
@@ -1914,10 +2059,8 @@
 	  unhide_metas(arg);
 	  if (inet_pton(AF_INET, arg, &new->addr.in.sin_addr) > 0)
 	    new->addr.sa.sa_family = AF_INET;
-#ifdef HAVE_IPV6
 	  else if (inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
 	    new->addr.sa.sa_family = AF_INET6;
-#endif
 	  else
 	    {
 	      char *fam = split_chr(arg, '/');
@@ -1927,12 +2070,13 @@
 		{
 		  if (strcmp(fam, "4") == 0)
 		    new->addr.sa.sa_family = AF_INET;
-#ifdef HAVE_IPV6
 		  else if (strcmp(fam, "6") == 0)
 		    new->addr.sa.sa_family = AF_INET6;
-#endif
 		  else
-		    ret_err(gen_err);
+		  {
+		    free(new->name);
+		    ret_err_free(gen_err, new);
+		  }
 		} 
 	    }
 	  new->next = daemon->authinterface;
@@ -1976,7 +2120,7 @@
 	    int is_exclude = 0;
 	    char *prefix;
 	    struct addrlist *subnet =  NULL;
-	    struct all_addr addr;
+	    union all_addr addr;
 
 	    comma = split(arg);
 	    prefix = split_chr(arg, '/');
@@ -1990,20 +2134,18 @@
 		    arg = arg+8;
 	      }
 
-	    if (inet_pton(AF_INET, arg, &addr.addr.addr4))
+	    if (inet_pton(AF_INET, arg, &addr.addr4))
 	      {
 		subnet = opt_malloc(sizeof(struct addrlist));
 		subnet->prefixlen = (prefixlen == 0) ? 24 : prefixlen;
 		subnet->flags = ADDRLIST_LITERAL;
 	      }
-#ifdef HAVE_IPV6
-	    else if (inet_pton(AF_INET6, arg, &addr.addr.addr6))
+	    else if (inet_pton(AF_INET6, arg, &addr.addr6))
 	      {
 		subnet = opt_malloc(sizeof(struct addrlist));
 		subnet->prefixlen = (prefixlen == 0) ? 64 : prefixlen;
 		subnet->flags = ADDRLIST_LITERAL | ADDRLIST_IPV6;
 	      }
-#endif
 	    else 
 	      {
 		struct auth_name_list *name =  opt_malloc(sizeof(struct auth_name_list));
@@ -2015,10 +2157,8 @@
 		  {
 		    if (prefixlen == 4)
 		      name->flags &= ~AUTH6;
-#ifdef HAVE_IPV6
 		    else if (prefixlen == 6)
 		      name->flags &= ~AUTH4;
-#endif
 		    else
 		      ret_err(gen_err);
 		  }
@@ -2101,7 +2241,7 @@
 
 		      arg = split(netpart);
 		      if (!atoi_check(netpart, &msize))
-			ret_err(gen_err);
+			ret_err_free(gen_err, new);
 		      else if (inet_pton(AF_INET, comma, &new->start))
 			{
 			  int mask = (1 << (32 - msize)) - 1;
@@ -2114,11 +2254,11 @@
 				{
 				  if (!(new->prefix = canonicalise_opt(arg)) ||
 				      strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
-				    ret_err(_("bad prefix"));
+				    ret_err_free(_("bad prefix"), new);
 				}
 			      else if (strcmp(arg, "local") != 0 ||
 				       (msize != 8 && msize != 16 && msize != 24))
-				ret_err(gen_err);
+				ret_err_free(gen_err, new);
 			      else
 				{
 				   /* generate the equivalent of
@@ -2125,7 +2265,7 @@
 				      local=/xxx.yyy.zzz.in-addr.arpa/ */
 				  struct server *serv = add_rev4(new->start, msize);
 				  if (!serv)
-				    ret_err(_("bad prefix"));
+				    ret_err_free(_("bad prefix"), new);
 
 				  serv->flags |= SERV_NO_ADDR;
 
@@ -2139,7 +2279,6 @@
 				}
 			    }
 			}
-#ifdef HAVE_IPV6
 		      else if (inet_pton(AF_INET6, comma, &new->start6))
 			{
 			  u64 mask = (1LLU << (128 - msize)) - 1LLU;
@@ -2155,7 +2294,7 @@
 			  setaddr6part(&new->end6, addrpart | mask);
 			  
 			  if (msize < 64)
-			    ret_err(gen_err);
+			    ret_err_free(gen_err, new);
 			  else if (arg)
 			    {
 			      if (option != 's')
@@ -2162,10 +2301,10 @@
 				{
 				  if (!(new->prefix = canonicalise_opt(arg)) ||
 				      strlen(new->prefix) > MAXLABEL - INET6_ADDRSTRLEN)
-				    ret_err(_("bad prefix"));
+				    ret_err_free(_("bad prefix"), new);
 				}	
 			      else if (strcmp(arg, "local") != 0 || ((msize & 4) != 0))
-				ret_err(gen_err);
+				ret_err_free(gen_err, new);
 			      else 
 				{
 				  /* generate the equivalent of
@@ -2183,9 +2322,8 @@
 				}
 			    }
 			}
-#endif
 		      else
-			ret_err(gen_err);
+			ret_err_free(gen_err, new);
 		    }
 		  else
 		    {
@@ -2199,9 +2337,8 @@
 			  if (!arg)
 			    new->end.s_addr = new->start.s_addr;
 			  else if (!inet_pton(AF_INET, arg, &new->end))
-			    ret_err(gen_err);
+			    ret_err_free(gen_err, new);
 			}
-#ifdef HAVE_IPV6
 		      else if (inet_pton(AF_INET6, comma, &new->start6))
 			{
 			  new->is6 = 1;
@@ -2208,17 +2345,16 @@
 			  if (!arg)
 			    memcpy(&new->end6, &new->start6, IN6ADDRSZ);
 			  else if (!inet_pton(AF_INET6, arg, &new->end6))
-			    ret_err(gen_err);
+			    ret_err_free(gen_err, new);
 			}
-#endif
 		      else 
-			ret_err(gen_err);
+			ret_err_free(gen_err, new);
 
 		      if (option != 's' && prefstr)
 			{
 			  if (!(new->prefix = canonicalise_opt(prefstr)) ||
 			      strlen(new->prefix) > MAXLABEL - INET_ADDRSTRLEN)
-			    ret_err(_("bad prefix"));
+			    ret_err_free(_("bad prefix"), new);
 			}
 		    }
 
@@ -2369,7 +2505,6 @@
 	    new->addr.in.sin_len = sizeof(new->addr.in);
 #endif
 	  }
-#ifdef HAVE_IPV6
 	else if (arg && inet_pton(AF_INET6, arg, &new->addr.in6.sin6_addr) > 0)
 	  {
 	    new->addr.sa.sa_family = AF_INET6;
@@ -2380,9 +2515,8 @@
 	    new->addr.in6.sin6_len = sizeof(new->addr.in6);
 #endif
 	  }
-#endif
 	else
-	  ret_err(gen_err);
+	  ret_err_free(gen_err, new);
 
 	new->used = 0;
 	if (option == 'a')
@@ -2453,7 +2587,10 @@
 	  {
 	    newlist->flags |= SERV_LITERAL_ADDRESS;
 	    if (!(newlist->flags & SERV_TYPE))
-	      ret_err(gen_err);
+	      {
+	        server_list_free(newlist);
+	        ret_err(gen_err);
+	      }
 	  }
 	else if (option == LOPT_NO_REBIND)
 	  newlist->flags |= SERV_NO_REBIND;
@@ -2470,13 +2607,16 @@
 	  {
 	    char *err = parse_server(arg, &newlist->addr, &newlist->source_addr, newlist->interface, &newlist->flags);
 	    if (err)
-	      ret_err(err);
+	      {
+	        server_list_free(newlist);
+	        ret_err(err);
+	      }
 	  }
 	
 	serv = newlist;
 	while (serv->next)
 	  {
-	    serv->next->flags = serv->flags;
+	    serv->next->flags |= serv->flags & ~(SERV_HAS_DOMAIN | SERV_FOR_NODOTS);
 	    serv->next->addr = serv->addr;
 	    serv->next->source_addr = serv->source_addr;
 	    strcpy(serv->next->interface, serv->interface);
@@ -2493,14 +2633,17 @@
 	int size;
 	struct server *serv;
 	struct in_addr addr4;
-#ifdef HAVE_IPV6
 	struct in6_addr addr6;
-#endif
  
 	unhide_metas(arg);
-	if (!arg || !(comma=split(arg)) || !(string = split_chr(arg, '/')) || !atoi_check(string, &size))
+	if (!arg)
 	  ret_err(gen_err);
+	
+	comma=split(arg);
 
+	if (!(string = split_chr(arg, '/')) || !atoi_check(string, &size))
+	  ret_err(gen_err);
+	
 	if (inet_pton(AF_INET, arg, &addr4))
 	  {
 	    serv = add_rev4(addr4, size);
@@ -2507,10 +2650,8 @@
 	    if (!serv)
 	      ret_err(_("bad prefix"));
 	  }
-#ifdef HAVE_IPV6
 	else if (inet_pton(AF_INET6, arg, &addr6))
 	  serv = add_rev6(&addr6, size);
-#endif
 	else
 	  ret_err(gen_err);
  
@@ -2603,6 +2744,14 @@
 	    
 	    if (size < 0)
 	      size = 0;
+
+	    /* Note that for very large cache sizes, the malloc()
+	       will overflow. For the size of the cache record
+	       at the time this was noted, the value of "very large"
+               was 46684428. Limit to an order of magnitude less than
+	       that to be safe from changes to the cache record. */
+	    if (size > 5000000)
+	      size = 5000000;
 	    
 	    daemon->cachesize = size;
 	  }
@@ -2789,6 +2938,44 @@
       }
 
 #ifdef HAVE_DHCP
+    case LOPT_SHARED_NET: /* --shared-network */
+      {
+	struct shared_network *new = opt_malloc(sizeof(struct shared_network));
+
+#ifdef HAVE_DHCP6
+	new->shared_addr.s_addr = 0;
+#endif
+	new->if_index = 0;
+	
+	if (!(comma = split(arg)))
+	  {
+	  snerr:
+	    free(new);
+	    ret_err(_("bad shared-network"));
+	  }
+	
+	if (inet_pton(AF_INET, comma, &new->shared_addr))
+	  {
+	    if (!inet_pton(AF_INET, arg, &new->match_addr) &&
+		!(new->if_index = if_nametoindex(arg)))
+	      goto snerr;
+	  }
+#ifdef HAVE_DHCP6
+	else if (inet_pton(AF_INET6, comma, &new->shared_addr6))
+	  {
+	    if (!inet_pton(AF_INET6, arg, &new->match_addr6) &&
+		!(new->if_index = if_nametoindex(arg)))
+	      goto snerr;
+	  }
+#endif
+	else
+	  goto snerr;
+
+	new->next = daemon->shared_networks;
+	daemon->shared_networks = new;
+	break;
+      }
+	  
     case 'F':  /* --dhcp-range */
       {
 	int k, leasepos = 2;
@@ -2810,21 +2997,19 @@
 	      {
 		if (is_tag_prefix(arg))
 		  {
-		    struct dhcp_netid *tt = opt_malloc(sizeof (struct dhcp_netid));
-		    tt->net = opt_string_alloc(arg+4);
-		    tt->next = new->filter;
 		    /* ignore empty tag */
-		    if (tt->net)
-		      new->filter = tt;
+		    if (arg[4])
+		      new->filter = dhcp_netid_create(arg+4, new->filter);
 		  }
 		else
 		  {
 		    if (new->netid.net)
-		      ret_err(_("only one tag allowed"));
-		    else if (strstr(arg, "set:") == arg)
-		      new->netid.net = opt_string_alloc(arg+4);
+		      {
+			dhcp_context_free(new);
+			ret_err(_("only one tag allowed"));
+		      }
 		    else
-		      new->netid.net = opt_string_alloc(arg);
+		      new->netid.net = opt_string_alloc(set_prefix(arg));
 		  }
 		arg = comma;
 	      }
@@ -2840,7 +3025,10 @@
 	    break;
 	
 	if (k < 2)
-	  ret_err(_("bad dhcp-range"));
+	  {
+	    dhcp_context_free(new);
+	    ret_err(_("bad dhcp-range"));
+	  }
 	
 	if (inet_pton(AF_INET, a[0], &new->start))
 	  {
@@ -2852,7 +3040,10 @@
 	    else if (strcmp(a[1], "proxy") == 0)
 	      new->flags |= CONTEXT_PROXY;
 	    else if (!inet_pton(AF_INET, a[1], &new->end))
-	      ret_err(_("bad dhcp-range"));
+	      {
+		dhcp_context_free(new);
+		ret_err(_("bad dhcp-range"));
+	      }
 	    
 	    if (ntohl(new->start.s_addr) > ntohl(new->end.s_addr))
 	      {
@@ -2867,7 +3058,10 @@
 		new->flags |= CONTEXT_NETMASK;
 		leasepos = 3;
 		if (!is_same_net(new->start, new->end, new->netmask))
-		  ret_err(_("inconsistent DHCP range"));
+		  {
+		    dhcp_context_free(new);
+		    ret_err(_("inconsistent DHCP range"));
+		  }
 		
 	    
 		if (k >= 4 && strchr(a[3], '.') &&  
@@ -2881,6 +3075,8 @@
 #ifdef HAVE_DHCP6
 	else if (inet_pton(AF_INET6, a[0], &new->start6))
 	  {
+	    const char *err = NULL;
+
 	    new->flags |= CONTEXT_V6; 
 	    new->prefix = 64; /* default */
 	    new->end6 = new->start6;
@@ -2926,20 +3122,25 @@
 		  }
 	      }
 	    
-	    if (new->prefix != 64)
+	    if (new->prefix > 64)
 	      {
 		if (new->flags & CONTEXT_RA)
-		  ret_err(_("prefix length must be exactly 64 for RA subnets"));
+		  err=(_("prefix length must be exactly 64 for RA subnets"));
 		else if (new->flags & CONTEXT_TEMPLATE)
-		  ret_err(_("prefix length must be exactly 64 for subnet constructors"));
+		  err=(_("prefix length must be exactly 64 for subnet constructors"));
 	      }
-
-	    if (new->prefix < 64)
-	      ret_err(_("prefix length must be at least 64"));
+	    else if (new->prefix < 64)
+	      err=(_("prefix length must be at least 64"));
 	    
-	    if (!is_same_net6(&new->start6, &new->end6, new->prefix))
-	      ret_err(_("inconsistent DHCPv6 range"));
+	    if (!err && !is_same_net6(&new->start6, &new->end6, new->prefix))
+	      err=(_("inconsistent DHCPv6 range"));
 
+	    if (err)
+	      {
+		dhcp_context_free(new);
+		ret_err(err);
+	      }
+
 	    /* dhcp-range=:: enables DHCP stateless on any interface */
 	    if (IN6_IS_ADDR_UNSPECIFIED(&new->start6) && !(new->flags & CONTEXT_TEMPLATE))
 	      new->prefix = 0;
@@ -2949,7 +3150,10 @@
 		struct in6_addr zero;
 		memset(&zero, 0, sizeof(zero));
 		if (!is_same_net6(&zero, &new->start6, new->prefix))
-		  ret_err(_("prefix must be zero with \"constructor:\" argument"));
+		  {
+		    dhcp_context_free(new);
+		    ret_err(_("prefix must be zero with \"constructor:\" argument"));
+		  }
 	      }
 	    
 	    if (addr6part(&new->start6) > addr6part(&new->end6))
@@ -2961,12 +3165,18 @@
 	  }
 #endif
 	else
-	  ret_err(_("bad dhcp-range"));
+	  {
+	    dhcp_context_free(new);
+	    ret_err(_("bad dhcp-range"));
+	  }
 	
 	if (leasepos < k)
 	  {
 	    if (leasepos != k-1)
-	      ret_err(_("bad dhcp-range"));
+	      {
+		dhcp_context_free(new);
+		ret_err(_("bad dhcp-range"));
+	      }
 	    
 	    if (strcmp(a[leasepos], "infinite") == 0)
 	      new->lease_time = 0xffffffff;
@@ -3005,7 +3215,7 @@
 			break;
 
 		    if (*cp || (leasepos+1 < k))
-		      ret_err(_("bad dhcp-range"));
+		      ret_err_free(_("bad dhcp-range"), new);
 		    
 		    new->lease_time = atoi(a[leasepos]) * fac;
 		    /* Leases of a minute or less confuse
@@ -3021,8 +3231,6 @@
     case LOPT_BANK:
     case 'G':  /* --dhcp-host */
       {
-	int j, k = 0;
-	char *a[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
 	struct dhcp_config *new;
 	struct in_addr in;
 	
@@ -3032,185 +3240,223 @@
 	new->flags = (option == LOPT_BANK) ? CONFIG_BANK : 0;
 	new->hwaddr = NULL;
 	new->netid = NULL;
+	new->filter = NULL;
+	new->clid = NULL;
+#ifdef HAVE_DHCP6
+	new->addr6 = NULL;
+#endif
 
-	if ((a[0] = arg))
-	  for (k = 1; k < 7; k++)
-	    if (!(a[k] = split(a[k-1])))
-	      break;
-	
-	for (j = 0; j < k; j++)
-	  if (strchr(a[j], ':')) /* ethernet address, netid or binary CLID */
-	    {
-	      char *arg = a[j];
-	      
-	      if ((arg[0] == 'i' || arg[0] == 'I') &&
-		  (arg[1] == 'd' || arg[1] == 'D') &&
-		  arg[2] == ':')
-		{
-		  if (arg[3] == '*')
-		    new->flags |= CONFIG_NOCLID;
-		  else
-		    {
-		      int len;
-		      arg += 3; /* dump id: */
-		      if (strchr(arg, ':'))
-			len = parse_hex(arg, (unsigned char *)arg, -1, NULL, NULL);
-		      else
-			{
-			  unhide_metas(arg);
-			  len = (int) strlen(arg);
-			}
-
-		      if (len == -1)
-			ret_err(_("bad hex constant"));
-		      else if ((new->clid = opt_malloc(len)))
-			{
-			  new->flags |= CONFIG_CLID;
-			  new->clid_len = len;
-			  memcpy(new->clid, arg, len);
-			}
-		    }
-		}
-	      /* dhcp-host has strange backwards-compat needs. */
-	      else if (strstr(arg, "net:") == arg || strstr(arg, "set:") == arg)
-		{
-		  struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
-		  struct dhcp_netid_list *newlist = opt_malloc(sizeof(struct dhcp_netid_list));
-		  newtag->net = opt_malloc(strlen(arg + 4) + 1);
-		  newlist->next = new->netid;
-		  new->netid = newlist;
-		  newlist->list = newtag;
-		  strcpy(newtag->net, arg+4);
-		  unhide_metas(newtag->net);
-		}
-	      else if (strstr(arg, "tag:") == arg)
-		ret_err(_("cannot match tags in --dhcp-host"));
+	while (arg)
+	  {
+	    comma = split(arg);
+	    if (strchr(arg, ':')) /* ethernet address, netid or binary CLID */
+	      {
+		if ((arg[0] == 'i' || arg[0] == 'I') &&
+		    (arg[1] == 'd' || arg[1] == 'D') &&
+		    arg[2] == ':')
+		  {
+		    if (arg[3] == '*')
+		      new->flags |= CONFIG_NOCLID;
+		    else
+		      {
+			int len;
+			arg += 3; /* dump id: */
+			if (strchr(arg, ':'))
+			  len = parse_hex(arg, (unsigned char *)arg, -1, NULL, NULL);
+			else
+			  {
+			    unhide_metas(arg);
+			    len = (int) strlen(arg);
+			  }
+			
+			if (len == -1)
+			  {
+			    dhcp_config_free(new);
+			    ret_err(_("bad hex constant"));
+			  }
+			else if ((new->clid = opt_malloc(len)))
+			  {
+			    new->flags |= CONFIG_CLID;
+			    new->clid_len = len;
+			    memcpy(new->clid, arg, len);
+			  }
+		      }
+		  }
+		/* dhcp-host has strange backwards-compat needs. */
+		else if (strstr(arg, "net:") == arg || strstr(arg, "set:") == arg)
+		  {
+		    struct dhcp_netid_list *newlist = opt_malloc(sizeof(struct dhcp_netid_list));
+		    newlist->next = new->netid;
+		    new->netid = newlist;
+		    newlist->list = dhcp_netid_create(arg+4, NULL);
+		  }
+		else if (strstr(arg, "tag:") == arg)
+		  new->filter = dhcp_netid_create(arg+4, new->filter);
+		  
 #ifdef HAVE_DHCP6
-	      else if (arg[0] == '[' && arg[strlen(arg)-1] == ']')
-		{
-		  arg[strlen(arg)-1] = 0;
-		  arg++;
-		  
-		  if (!inet_pton(AF_INET6, arg, &new->addr6))
-		    ret_err(_("bad IPv6 address"));
+		else if (arg[0] == '[' && arg[strlen(arg)-1] == ']')
+		  {
+		    char *pref;
+		    struct in6_addr in6;
+		    struct addrlist *new_addr;
+		    
+		    arg[strlen(arg)-1] = 0;
+		    arg++;
+		    pref = split_chr(arg, '/');
+		    
+		    if (!inet_pton(AF_INET6, arg, &in6))
+		      {
+			dhcp_config_free(new);
+			ret_err(_("bad IPv6 address"));
+		      }
 
-		  for (i= 0; i < 8; i++)
-		    if (new->addr6.s6_addr[i] != 0)
-		      break;
-
-		  /* set WILDCARD if network part all zeros */
-		  if (i == 8)
-		    new->flags |= CONFIG_WILDCARD;
+		    new_addr = opt_malloc(sizeof(struct addrlist));
+		    new_addr->next = new->addr6;
+		    new_addr->flags = 0;
+		    new_addr->addr.addr6 = in6;
+		    new->addr6 = new_addr;
+		    
+		    if (pref)
+		      {
+			u64 addrpart = addr6part(&in6);
+			
+			if (!atoi_check(pref, &new_addr->prefixlen) ||
+			    new_addr->prefixlen > 128 ||
+			    ((((u64)1<<(128-new_addr->prefixlen))-1) & addrpart) != 0)
+			  {
+			    dhcp_config_free(new);
+			    ret_err(_("bad IPv6 prefix"));
+			  }
+			
+			new_addr->flags |= ADDRLIST_PREFIX;
+		      }
 		  
-		  new->flags |= CONFIG_ADDR6;
-		}
+		    for (i= 0; i < 8; i++)
+		      if (in6.s6_addr[i] != 0)
+			break;
+		    
+		    /* set WILDCARD if network part all zeros */
+		    if (i == 8)
+		      new_addr->flags |= ADDRLIST_WILDCARD;
+		    
+		    new->flags |= CONFIG_ADDR6;
+		  }
 #endif
-	      else
-		{
-		  struct hwaddr_config *newhw = opt_malloc(sizeof(struct hwaddr_config));
-		  if ((newhw->hwaddr_len = parse_hex(a[j], newhw->hwaddr, DHCP_CHADDR_MAX, 
-						     &newhw->wildcard_mask, &newhw->hwaddr_type)) == -1)
-		    ret_err(_("bad hex constant"));
-		  else
+		else
+		  {
+		    struct hwaddr_config *newhw = opt_malloc(sizeof(struct hwaddr_config));
+		    if ((newhw->hwaddr_len = parse_hex(arg, newhw->hwaddr, DHCP_CHADDR_MAX, 
+						       &newhw->wildcard_mask, &newhw->hwaddr_type)) == -1)
+		      {
+			free(newhw);
+			dhcp_config_free(new);
+			ret_err(_("bad hex constant"));
+		      }
+		    else
+		      {
+			newhw->next = new->hwaddr;
+			new->hwaddr = newhw;
+		      }		    
+		  }
+	      }
+	    else if (strchr(arg, '.') && (inet_pton(AF_INET, arg, &in) > 0))
+	      {
+		struct dhcp_config *configs;
+		
+		new->addr = in;
+		new->flags |= CONFIG_ADDR;
+		
+		/* If the same IP appears in more than one host config, then DISCOVER
+		   for one of the hosts will get the address, but REQUEST will be NAKed,
+		   since the address is reserved by the other one -> protocol loop. */
+		for (configs = daemon->dhcp_conf; configs; configs = configs->next) 
+		  if ((configs->flags & CONFIG_ADDR) && configs->addr.s_addr == in.s_addr)
 		    {
-		      
-		      newhw->next = new->hwaddr;
-		      new->hwaddr = newhw;
-		    }		    
-		}
-	    }
-	  else if (strchr(a[j], '.') && (inet_pton(AF_INET, a[j], &in) > 0))
-	    {
-	      struct dhcp_config *configs;
-	      
-	      new->addr = in;
-	      new->flags |= CONFIG_ADDR;
+		      sprintf(errstr, _("duplicate dhcp-host IP address %s"),  inet_ntoa(in));
+		      return 0;
+		    }	      
+	      }
+	    else
+	      {
+		char *cp, *lastp = NULL, last = 0;
+		int fac = 1, isdig = 0;
+		
+		if (strlen(arg) > 1)
+		  {
+		    lastp = arg + strlen(arg) - 1;
+		    last = *lastp;
+		    switch (last)
+		      {
+		      case 'w':
+		      case 'W':
+			fac *= 7;
+			/* fall through */
+		      case 'd':
+		      case 'D':
+			fac *= 24;
+			/* fall through */
+		      case 'h':
+		      case 'H':
+			fac *= 60;
+			/* fall through */
+		      case 'm':
+		      case 'M':
+			fac *= 60;
+			/* fall through */
+		      case 's':
+		      case 'S':
+			*lastp = 0;
+		      }
+		  }
+		
+		for (cp = arg; *cp; cp++)
+		  if (isdigit((unsigned char)*cp))
+		    isdig = 1;
+		  else if (*cp != ' ')
+		    break;
 
-	      /* If the same IP appears in more than one host config, then DISCOVER
-		 for one of the hosts will get the address, but REQUEST will be NAKed,
-		 since the address is reserved by the other one -> protocol loop. */
-	      for (configs = daemon->dhcp_conf; configs; configs = configs->next) 
-		if ((configs->flags & CONFIG_ADDR) && configs->addr.s_addr == in.s_addr)
+		if (*cp)
 		  {
-		    sprintf(errstr, _("duplicate dhcp-host IP address %s"),  inet_ntoa(in));
-		    return 0;
-		  }	      
-	    }
-	  else
-	    {
-	      char *cp, *lastp = NULL, last = 0;
-	      int fac = 1, isdig = 0;
-	      
-	      if (strlen(a[j]) > 1)
-		{
-		  lastp = a[j] + strlen(a[j]) - 1;
-		  last = *lastp;
-		  switch (last)
-		    {
-		    case 'w':
-		    case 'W':
-		      fac *= 7;
-		      /* fall through */
-		    case 'd':
-		    case 'D':
-		      fac *= 24;
-		      /* fall through */
-		    case 'h':
-		    case 'H':
-		      fac *= 60;
-		      /* fall through */
-		    case 'm':
-		    case 'M':
-		      fac *= 60;
-		      /* fall through */
-		    case 's':
-		    case 'S':
-		      *lastp = 0;
-		    }
-		}
-	      
-	      for (cp = a[j]; *cp; cp++)
-		if (isdigit((unsigned char)*cp))
-		  isdig = 1;
-		else if (*cp != ' ')
-		  break;
+		    if (lastp)
+		      *lastp = last;
+		    if (strcmp(arg, "infinite") == 0)
+		      {
+			new->lease_time = 0xffffffff;
+			new->flags |= CONFIG_TIME;
+		      }
+		    else if (strcmp(arg, "ignore") == 0)
+		      new->flags |= CONFIG_DISABLE;
+		    else
+		      {
+			if (!(new->hostname = canonicalise_opt(arg)) ||
+			    !legal_hostname(new->hostname))
+			  {
+			    dhcp_config_free(new);
+			    ret_err(_("bad DHCP host name"));
+			  }
+			
+			new->flags |= CONFIG_NAME;
+			new->domain = strip_hostname(new->hostname);			
+		      }
+		  }
+		else if (isdig)
+		  {
+		    new->lease_time = atoi(arg) * fac; 
+		    /* Leases of a minute or less confuse
+		       some clients, notably Apple's */
+		    if (new->lease_time < 120)
+		      new->lease_time = 120;
+		    new->flags |= CONFIG_TIME;
+		  }
+	      }
 
-	      if (*cp)
-		{
-		  if (lastp)
-		    *lastp = last;
-		  if (strcmp(a[j], "infinite") == 0)
-		    {
-		      new->lease_time = 0xffffffff;
-		      new->flags |= CONFIG_TIME;
-		    }
-		  else if (strcmp(a[j], "ignore") == 0)
-		    new->flags |= CONFIG_DISABLE;
-		  else
-		    {
-		      if (!(new->hostname = canonicalise_opt(a[j])) ||
-			  !legal_hostname(new->hostname))
-			ret_err(_("bad DHCP host name"));
-		     
-		      new->flags |= CONFIG_NAME;
-		      new->domain = strip_hostname(new->hostname);			
-		    }
-		}
-	      else if (isdig)
-		{
-		  new->lease_time = atoi(a[j]) * fac; 
-		  /* Leases of a minute or less confuse
-		     some clients, notably Apple's */
-		  if (new->lease_time < 120)
-		    new->lease_time = 120;
-		  new->flags |= CONFIG_TIME;
-		}
-	    }
-	
+	    arg = comma;
+	  }
+
 	daemon->dhcp_conf = new;
 	break;
       }
-
+      
     case LOPT_TAG_IF:  /* --tag-if */
       {
 	struct tag_if *new = opt_malloc(sizeof(struct tag_if));
@@ -3243,10 +3489,7 @@
 	      }
 	    else
 	      {
-		struct dhcp_netid *newtag = opt_malloc(sizeof(struct dhcp_netid));
-		newtag->net = opt_malloc(len - 3);
-		strcpy(newtag->net, arg+4);
-		unhide_metas(newtag->net);
+		struct dhcp_netid *newtag = dhcp_netid_create(arg+4, NULL);
 
 		if (strstr(arg, "set:") == arg)
 		  {
@@ -3263,7 +3506,7 @@
 		else 
 		  {
 		    new->set = NULL;
-		    free(newtag);
+		    dhcp_netid_free(newtag);
 		    break;
 		  }
 	      }
@@ -3272,7 +3515,11 @@
 	  }
 
 	if (!new->set)
-	  ret_err(_("bad tag-if"));
+	  {
+	    dhcp_netid_free(new->tag);
+	    dhcp_netid_list_free(new->set);
+	    ret_err_free(_("bad tag-if"), new);
+	  }
 	  
 	break;
       }
@@ -3315,19 +3562,12 @@
       
     case 'M': /* --dhcp-boot */
       {
-	struct dhcp_netid *id = NULL;
-	while (is_tag_prefix(arg))
-	  {
-	    struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
-	    newid->next = id;
-	    id = newid;
-	    comma = split(arg);
-	    newid->net = opt_string_alloc(arg+4);
-	    arg = comma;
-	  };
+	struct dhcp_netid *id = dhcp_tags(&arg);
 	
 	if (!arg)
-	  ret_err(gen_err);
+	  {
+	    ret_err(gen_err);
+	  }
 	else 
 	  {
 	    char *dhcp_file, *dhcp_sname = NULL, *tftp_sname = NULL;
@@ -3373,19 +3613,12 @@
 
     case LOPT_REPLY_DELAY: /* --dhcp-reply-delay */
       {
-	struct dhcp_netid *id = NULL;
-	while (is_tag_prefix(arg))
-	  {
-	    struct dhcp_netid *newid = opt_malloc(sizeof(struct dhcp_netid));
-	    newid->next = id;
-	    id = newid;
-	    comma = split(arg);
-	    newid->net = opt_string_alloc(arg+4);
-	    arg = comma;
-	  };
+	struct dhcp_netid *id = dhcp_tags(&arg);
 	
 	if (!arg)
-	  ret_err(gen_err);
+	  {
+	    ret_err(gen_err);
+	  }
 	else
 	  {
 	    struct delay_config *new;
@@ -3410,19 +3643,13 @@
 	 
 	 new->netid = NULL;
 	 new->opt = 10; /* PXE_MENU_PROMPT */
-
-	 while (is_tag_prefix(arg))
-	  {
-	     struct dhcp_netid *nn = opt_malloc(sizeof (struct dhcp_netid));
-	     comma = split(arg);
-	     nn->next = new->netid;
-	     new->netid = nn;
-	     nn->net = opt_string_alloc(arg+4);
-	     arg = comma;
-	   }
+	 new->netid = dhcp_tags(&arg);
 	 
 	 if (!arg)
-	   ret_err(gen_err);
+	   {
+	     dhcp_opt_free(new);
+	     ret_err(gen_err);
+	   }
 	 else
 	   {
 	     comma = split(arg);
@@ -3458,17 +3685,8 @@
 	 new->netid = NULL;
 	 new->sname = NULL;
 	 new->server.s_addr = 0;
+	 new->netid = dhcp_tags(&arg);
 
-	 while (is_tag_prefix(arg))
-	   {
-	     struct dhcp_netid *nn = opt_malloc(sizeof (struct dhcp_netid));
-	     comma = split(arg);
-	     nn->next = new->netid;
-	     new->netid = nn;
-	     nn->net = opt_string_alloc(arg+4);
-	     arg = comma;
-	   }
-       
 	 if (arg && (comma = split(arg)))
 	   {
 	     for (i = 0; CSA[i]; i++)
@@ -3545,7 +3763,10 @@
 	    unhide_metas(comma);
 	    new->hwaddr_len = parse_hex(comma, new->hwaddr, DHCP_CHADDR_MAX, &new->mask, &new->hwaddr_type);
 	    if (new->hwaddr_len == -1)
-	      ret_err(gen_err);
+	      {
+		free(new->netid.net);
+		ret_err_free(gen_err, new);
+	      }
 	    else
 	      {
 		new->next = daemon->dhcp_macs;
@@ -3555,24 +3776,6 @@
       }
       break;
 
-#ifdef OPTION6_PREFIX_CLASS 
-    case LOPT_PREF_CLSS: /* --dhcp-prefix-class */
-      {
-	struct prefix_class *new = opt_malloc(sizeof(struct prefix_class));
-	
-	if (!(comma = split(arg)) ||
-	    !atoi_check16(comma, &new->class))
-	  ret_err(gen_err);
-	
-	new->tag.net = opt_string_alloc(set_prefix(arg));
-	new->next = daemon->prefix_classes;
-	daemon->prefix_classes = new;
-	
-	break;
-      }
-#endif
-			      
-
     case 'U':           /* --dhcp-vendorclass */
     case 'j':           /* --dhcp-userclass */
     case LOPT_CIRCUIT:  /* --dhcp-circuitid */
@@ -3584,7 +3787,7 @@
 	 struct dhcp_vendor *new = opt_malloc(sizeof(struct dhcp_vendor));
 	 
 	 if (!(comma = split(arg)))
-	   ret_err(gen_err);
+	   ret_err_free(gen_err, new);
 	
 	 new->netid.net = opt_string_alloc(set_prefix(arg));
 	 /* check for hex string - must digits may include : must not have nothing else, 
@@ -3594,7 +3797,10 @@
 	 if ((comma = split(arg)))
 	   {
 	     if (option  != 'U' || strstr(arg, "enterprise:") != arg)
-	       ret_err(gen_err);
+	       {
+	         free(new->netid.net);
+	         ret_err_free(gen_err, new);
+	       }
 	     else
 	       new->enterprise = atoi(arg+11);
 	   }
@@ -3696,14 +3902,8 @@
 	  }
 	
 	while (arg) {
-	  struct dhcp_netid *member = opt_malloc(sizeof(struct dhcp_netid));
 	  comma = split(arg);
-	  member->next = list;
-	  list = member;
-	  if (is_tag_prefix(arg))
-	    member->net = opt_string_alloc(arg+4);
-	  else
-	    member->net = opt_string_alloc(arg);
+	  list = dhcp_netid_create(is_tag_prefix(arg) ? arg+4 :arg, list);
 	  arg = comma;
 	}
 	
@@ -3717,7 +3917,7 @@
 	struct addr_list *new = opt_malloc(sizeof(struct addr_list));
 	comma = split(arg);
 	if (!(inet_pton(AF_INET, arg, &new->addr) > 0))
-	  ret_err(_("bad dhcp-proxy address"));
+	  ret_err_free(_("bad dhcp-proxy address"), new);
 	new->next = daemon->override_relays;
 	daemon->override_relays = new;
 	arg = comma;
@@ -3743,7 +3943,10 @@
 	  }
 #endif
 	else
-	  ret_err(_("Bad dhcp-relay"));
+	  {
+	    free(new->interface);
+	    ret_err_free(_("Bad dhcp-relay"), new);
+	  }
 	
 	break;
       }
@@ -3783,8 +3986,11 @@
 	   arg = split(comma);
 	   if (!atoi_check(comma, &new->interval) || 
 	      (arg && !atoi_check(arg, &new->lifetime)))
+             {
 err:
-	    ret_err(_("bad RA-params"));
+	       free(new->name);
+	       ret_err_free(_("bad RA-params"), new);
+             }
 	  
 	  new->next = daemon->ra_interfaces;
 	  daemon->ra_interfaces = new;
@@ -3833,7 +4039,7 @@
 	    (!(inet_pton(AF_INET, dash, &new->end) > 0) ||
 	     !is_same_net(new->in, new->end, new->mask) ||
 	     ntohl(new->in.s_addr) > ntohl(new->end.s_addr)))
-	  ret_err(_("invalid alias range"));
+	  ret_err_free(_("invalid alias range"), new);
 	
 	break;
       }
@@ -3863,12 +4069,10 @@
 	  {
 	    if (strcmp(arg, "4") == 0)
 	      new->family = AF_INET;
-#ifdef HAVE_IPV6
 	    else if (strcmp(arg, "6") == 0)
 	      new->family = AF_INET6;
-#endif
 	    else
-	      ret_err(gen_err);
+	      ret_err_free(gen_err, new);
 	  } 
 	new->intr = opt_string_alloc(comma);
 	break;
@@ -3900,11 +4104,19 @@
 	    alias = canonicalise_opt(arg);
 
 	    if (!alias || !target)
-	      ret_err(_("bad CNAME"));
+	      {
+		free(target);
+		free(alias);
+		ret_err(_("bad CNAME"));
+	      }
 	    
 	    for (new = daemon->cnames; new; new = new->next)
 	      if (hostname_isequal(new->alias, alias))
-		ret_err(_("duplicate CNAME"));
+		{
+		  free(target);
+		  free(alias);
+		  ret_err(_("duplicate CNAME"));
+		}
 	    new = opt_malloc(sizeof(struct cname));
 	    new->next = daemon->cnames;
 	    daemon->cnames = new;
@@ -3927,7 +4139,11 @@
 	
 	if (!(dom = canonicalise_opt(arg)) ||
 	    (comma && !(target = canonicalise_opt(comma))))
-	  ret_err(_("bad PTR record"));
+	  {
+	    free(dom);
+	    free(target);
+	    ret_err(_("bad PTR record"));
+	  }
 	else
 	  {
 	    new = opt_malloc(sizeof(struct ptr_record));
@@ -3945,7 +4161,7 @@
 	int k = 0;
 	struct naptr *new;
 	int order, pref;
-	char *name, *replace = NULL;
+	char *name=NULL, *replace = NULL;
 
 	if ((a[0] = arg))
 	  for (k = 1; k < 7; k++)
@@ -3958,7 +4174,11 @@
 	    !atoi_check16(a[1], &order) || 
 	    !atoi_check16(a[2], &pref) ||
 	    (k == 7 && !(replace = canonicalise_opt(a[6]))))
-	  ret_err(_("bad NAPTR record"));
+          {
+	    free(name);
+	    free(replace);
+	    ret_err(_("bad NAPTR record"));
+          }
 	else
 	  {
 	    new = opt_malloc(sizeof(struct naptr));
@@ -3980,22 +4200,26 @@
        	struct txt_record *new;
 	size_t len = 0;
 	char *data;
-	int val;
+	int class;
 
 	comma = split(arg);
 	data = split(comma);
 		
 	new = opt_malloc(sizeof(struct txt_record));
-	new->next = daemon->rr;
-	daemon->rr = new;
+	new->name = NULL;
 	
-	if (!atoi_check(comma, &val) || 
+	if (!atoi_check(comma, &class) || 
 	    !(new->name = canonicalise_opt(arg)) ||
 	    (data && (len = parse_hex(data, (unsigned char *)data, -1, NULL, NULL)) == -1U))
-	  ret_err(_("bad RR record"));
-	   	
-	new->class = val;
+          {
+            free(new->name);
+	    ret_err_free(_("bad RR record"), new);
+          }
+
 	new->len = 0;
+	new->class = class;
+	new->next = daemon->rr;
+	daemon->rr = new;
 	
 	if (data)
 	  {
@@ -4047,14 +4271,14 @@
 	comma = split(arg);
 		
 	new = opt_malloc(sizeof(struct txt_record));
-	new->next = daemon->txt;
-	daemon->txt = new;
 	new->class = C_IN;
 	new->stat = 0;
 
 	if (!(new->name = canonicalise_opt(arg)))
-	  ret_err(_("bad TXT record"));
+	  ret_err_free(_("bad TXT record"), new);
 	
+	new->next = daemon->txt;
+	daemon->txt = new;
 	len = comma ? strlen(comma) : 0;
 	len += (len/255) + 1; /* room for extra counts */
 	new->txt = p = opt_malloc(len);
@@ -4101,7 +4325,7 @@
 	    arg = comma;
 	    comma = split(arg);
 	    if (!(target = canonicalise_opt(arg)))
-	      ret_err(_("bad SRV target"));
+	      ret_err_free(_("bad SRV target"), name);
 		
 	    if (comma)
 	      {
@@ -4108,7 +4332,10 @@
 		arg = comma;
 		comma = split(arg);
 		if (!atoi_check16(arg, &port))
-		  ret_err(_("invalid port number"));
+                  {
+                    free(name);
+		    ret_err_free(_("invalid port number"), target);
+                  }
 		
 		if (comma)
 		  {
@@ -4115,10 +4342,15 @@
 		    arg = comma;
 		    comma = split(arg);
 		    if (!atoi_check16(arg, &priority))
-		      ret_err(_("invalid priority"));
-			
+                      {
+                        free(name);
+		        ret_err_free(_("invalid priority"), target);
+		      }
 		    if (comma && !atoi_check16(comma, &weight))
-		      ret_err(_("invalid weight"));
+                      {
+                        free(name);
+		        ret_err_free(_("invalid weight"), target);
+                      }
 		  }
 	      }
 	  }
@@ -4137,16 +4369,19 @@
       
     case LOPT_HOST_REC: /* --host-record */
       {
-	struct host_record *new = opt_malloc(sizeof(struct host_record));
-	memset(new, 0, sizeof(struct host_record));
-	new->ttl = -1;
+	struct host_record *new;
 
 	if (!arg || !(comma = split(arg)))
 	  ret_err(_("Bad host-record"));
 	
+	new = opt_malloc(sizeof(struct host_record));
+	memset(new, 0, sizeof(struct host_record));
+	new->ttl = -1;
+	new->flags = 0;
+
 	while (arg)
 	  {
-	    struct all_addr addr;
+	    union all_addr addr;
 	    char *dig;
 
 	    for (dig = arg; *dig != 0; dig++)
@@ -4154,20 +4389,33 @@
 		break;
 	    if (*dig == 0)
 	      new->ttl = atoi(arg);
-	    else if (inet_pton(AF_INET, arg, &addr))
-	      new->addr = addr.addr.addr4;
-#ifdef HAVE_IPV6
-	    else if (inet_pton(AF_INET6, arg, &addr))
-	      new->addr6 = addr.addr.addr6;
-#endif
+	    else if (inet_pton(AF_INET, arg, &addr.addr4))
+	      {
+		new->addr = addr.addr4;
+		new->flags |= HR_4;
+	      }
+	    else if (inet_pton(AF_INET6, arg, &addr.addr6))
+	      {
+		new->addr6 = addr.addr6;
+		new->flags |= HR_6;
+	      }
 	    else
 	      {
 		int nomem;
 		char *canon = canonicalise(arg, &nomem);
-		struct name_list *nl = opt_malloc(sizeof(struct name_list));
+		struct name_list *nl;
 		if (!canon)
-		  ret_err(_("Bad name in host-record"));
+                  {
+		    struct name_list *tmp = new->names, *next;
+		    for (tmp = new->names; tmp; tmp = next)
+		      {
+			next = tmp->next;
+			free(tmp);
+		      }
+		    ret_err_free(_("Bad name in host-record"), new);
+                  }
 
+		nl = opt_malloc(sizeof(struct name_list));
 		nl->name = canon;
 		/* keep order, so that PTR record goes to first name */
 		nl->next = NULL;
@@ -4217,6 +4465,7 @@
 	int len;
 	
 	new->class = C_IN;
+	new->name = NULL;
 
 	if ((comma = split(arg)) && (algo = split(comma)))
 	  {
@@ -4241,7 +4490,7 @@
 	    !atoi_check8(algo, &new->algo) ||
 	    !atoi_check8(digest, &new->digest_type) ||
 	    !(new->name = canonicalise_opt(arg)))
-	  ret_err(_("bad trust anchor"));
+	  ret_err_free(_("bad trust anchor"), new);
 	    
 	/* Upper bound on length */
 	len = (2*strlen(keyhex))+1;
@@ -4255,7 +4504,10 @@
 	  else
 	    cp++;
 	if ((new->digestlen = parse_hex(keyhex, (unsigned char *)new->digest, len, NULL, NULL)) == -1)
-	  ret_err(_("bad HEX in trust anchor"));
+	  {
+	    free(new->name);
+	    ret_err_free(_("bad HEX in trust anchor"), new);
+	  }
 	
 	new->next = daemon->ds;
 	daemon->ds = new;
@@ -4724,8 +4976,8 @@
   size_t argbuf_size = MAXDNAME;
   char *argbuf = opt_malloc(argbuf_size);
   char *buff = opt_malloc(MAXDNAME);
-  int option, conffile_opt = '7', testmode = 0;
-  char *arg, *conffile = CONFFILE;
+  int option, testmode = 0;
+  char *arg, *conffile = NULL;
       
   opterr = 0;
 
@@ -4834,8 +5086,14 @@
         }
       else if (option == 'C')
 	{
-	  conffile_opt = 0; /* file must exist */
-	  conffile = opt_string_alloc(arg);
+          if (!conffile)
+	    conffile = opt_string_alloc(arg);
+	  else
+	    {
+	      char *extra = opt_string_alloc(arg);
+	      one_file(extra, 0);
+	      free(extra);
+	    }
 	}
       else
 	{
@@ -4852,10 +5110,11 @@
 
   if (conffile)
     {
-      one_file(conffile, conffile_opt);
-      if (conffile_opt == 0)
-	free(conffile);
+      one_file(conffile, 0);
+      free(conffile);
     }
+  else
+    one_file(CONFFILE, '7');
 
   /* port might not be known when the address is parsed - fill in here */
   if (daemon->servers)
@@ -4866,10 +5125,8 @@
 	  {
 	    if (tmp->source_addr.sa.sa_family == AF_INET)
 	      tmp->source_addr.in.sin_port = htons(daemon->query_port);
-#ifdef HAVE_IPV6
 	    else if (tmp->source_addr.sa.sa_family == AF_INET6)
 	      tmp->source_addr.in6.sin6_port = htons(daemon->query_port);
-#endif 
 	  }
     } 
   
@@ -4889,7 +5146,7 @@
 #define NOLOOP 1
 #define TESTLOOP 2      
 
-      /* Fill in TTL for CNAMES noe we have local_ttl.
+      /* Fill in TTL for CNAMES now we have local_ttl.
 	 Also prepare to do loop detection. */
       for (cn = daemon->cnames; cn; cn = cn->next)
 	{
@@ -4930,10 +5187,8 @@
       for(tmp = daemon->if_addrs; tmp; tmp = tmp->next)
 	if (tmp->addr.sa.sa_family == AF_INET)
 	  tmp->addr.in.sin_port = htons(daemon->port);
-#ifdef HAVE_IPV6
 	else if (tmp->addr.sa.sa_family == AF_INET6)
 	  tmp->addr.in6.sin6_port = htons(daemon->port);
-#endif /* IPv6 */
     }
 	
   /* create default, if not specified */
Index: src/rfc1035.c
===================================================================
--- src/rfc1035.c	(revision 41436)
+++ src/rfc1035.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -143,7 +143,7 @@
  
 /* Max size of input string (for IPv6) is 75 chars.) */
 #define MAXARPANAME 75
-int in_arpa_name_2_addr(char *namein, struct all_addr *addrp)
+int in_arpa_name_2_addr(char *namein, union all_addr *addrp)
 {
   int j;
   char name[MAXARPANAME+1], *cp1;
@@ -153,7 +153,7 @@
   if (strlen(namein) > MAXARPANAME)
     return 0;
 
-  memset(addrp, 0, sizeof(struct all_addr));
+  memset(addrp, 0, sizeof(union all_addr));
 
   /* turn name into a series of asciiz strings */
   /* j counts no. of labels */
@@ -198,7 +198,6 @@
 
       return F_IPV4;
     }
-#ifdef HAVE_IPV6
   else if (hostname_isequal(penchunk, "ip6") && 
 	   (hostname_isequal(lastchunk, "int") || hostname_isequal(lastchunk, "arpa")))
     {
@@ -235,7 +234,7 @@
 	      if (*(cp1+1) || !isxdigit((unsigned char)*cp1))
 		return 0;
 	      
-	      for (j = sizeof(struct all_addr)-1; j>0; j--)
+	      for (j = sizeof(struct in6_addr)-1; j>0; j--)
 		addr[j] = (addr[j] >> 4) | (addr[j-1] << 4);
 	      addr[0] = (addr[0] >> 4) | (strtol(cp1, NULL, 16) << 4);
 	    }
@@ -243,7 +242,6 @@
 	  return F_IPV6;
 	}
     }
-#endif
   
   return 0;
 }
@@ -426,7 +424,6 @@
     ((ip_addr & 0xFFFFFFFF) == 0xFFFFFFFF)  /* 255.255.255.255/32 (broadcast)*/ ;
 }
 
-#ifdef HAVE_IPV6
 static int private_net6(struct in6_addr *a)
 {
   return 
@@ -436,9 +433,7 @@
     ((unsigned char *)a)[0] == 0xfd ||   /* RFC 6303 4.4 */
     ((u32 *)a)[0] == htonl(0x20010db8); /* RFC 6303 4.6 */
 }
-#endif
 
-
 static unsigned char *do_doctor(unsigned char *p, int count, struct dns_header *header, size_t qlen, char *name, int *doctored)
 {
   int i, qtype, qclass, rdlen;
@@ -590,7 +585,7 @@
   unsigned char *p, *p1, *endrr, *namep;
   int i, j, qtype, qclass, aqtype, aqclass, ardlen, res, searched_soa = 0;
   unsigned long ttl = 0;
-  struct all_addr addr;
+  union all_addr addr;
 #ifdef HAVE_IPSET
   char **ipsets_cur;
 #else
@@ -613,7 +608,7 @@
 #ifdef HAVE_DNSSEC
 	  if (option_bool(OPT_DNSSEC_VALID))
 	    for (i = 0; i < ntohs(header->ancount); i++)
-	      if (daemon->rr_status[i])
+	      if (daemon->rr_status[i] != 0)
 		return 0;
 #endif
 	}
@@ -686,7 +681,7 @@
 		      if (!extract_name(header, qlen, &p1, name, 1, 0))
 			return 0;
 #ifdef HAVE_DNSSEC
-		      if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j])
+		      if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)
 			{
 			  /* validated RR anywhere in CNAME chain, don't cache. */
 			  if (cname_short || aqtype == T_CNAME)
@@ -693,6 +688,9 @@
 			    return 0;
 
 			  secflag = F_DNSSECOK;
+			  /* limit TTL based on signature. */
+			  if (daemon->rr_status[j] < cttl)
+			    cttl = daemon->rr_status[j];
 			}
 #endif
 
@@ -706,7 +704,7 @@
 			  goto cname_loop;
 			}
 		      
-		      cache_insert(name, &addr, now, cttl, name_encoding | secflag | F_REVERSE);
+		      cache_insert(name, &addr, C_IN, now, cttl, name_encoding | secflag | F_REVERSE);
 		      found = 1; 
 		    }
 		  
@@ -724,7 +722,7 @@
 		  ttl = find_soa(header, qlen, NULL, doctored);
 		}
 	      if (ttl)
-		cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | (secure ?  F_DNSSECOK : 0));	
+		cache_insert(NULL, &addr, C_IN, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | (secure ?  F_DNSSECOK : 0));	
 	    }
 	}
       else
@@ -731,7 +729,7 @@
 	{
 	  /* everything other than PTR */
 	  struct crec *newc;
-	  int addrlen;
+	  int addrlen = 0;
 
 	  if (qtype == T_A)
 	    {
@@ -738,14 +736,14 @@
 	      addrlen = INADDRSZ;
 	      flags |= F_IPV4;
 	    }
-#ifdef HAVE_IPV6
 	  else if (qtype == T_AAAA)
 	    {
 	      addrlen = IN6ADDRSZ;
 	      flags |= F_IPV6;
 	    }
-#endif
-	  else 
+	  else if (qtype == T_SRV)
+	    flags |= F_SRV;
+	  else
 	    continue;
 	    
 	cname_loop1:
@@ -773,19 +771,24 @@
 	      if (aqclass == C_IN && res != 2 && (aqtype == T_CNAME || aqtype == qtype))
 		{
 #ifdef HAVE_DNSSEC
-		  if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j])
+		  if (option_bool(OPT_DNSSEC_VALID) && daemon->rr_status[j] != 0)
+		    {
 		      secflag = F_DNSSECOK;
+
+		      /* limit TTl based on sig. */
+		      if (daemon->rr_status[j] < attl)
+			attl = daemon->rr_status[j];
+		    }
 #endif		  
 		  if (aqtype == T_CNAME)
 		    {
 		      if (!cname_count--)
 			return 0; /* looped CNAMES */
-		      newc = cache_insert(name, NULL, now, attl, F_CNAME | F_FORWARD | secflag);
-		      if (newc)
+
+		      if ((newc = cache_insert(name, NULL, C_IN, now, attl, F_CNAME | F_FORWARD | secflag)))
 			{
 			  newc->addr.cname.target.cache = NULL;
-			  /* anything other than zero, to avoid being mistaken for CNAME to interface-name */ 
-			  newc->addr.cname.uid = 1; 
+			  newc->addr.cname.is_name_ptr = 0; 
 			  if (cpp)
 			    {
 			      next_uid(newc);
@@ -798,8 +801,10 @@
 		      if (attl < cttl)
 			cttl = attl;
 		      
+		      namep = p1;
 		      if (!extract_name(header, qlen, &p1, name, 1, 0))
 			return 0;
+		      
 		      goto cname_loop1;
 		    }
 		  else if (!(flags & F_NXDOMAIN))
@@ -806,43 +811,63 @@
 		    {
 		      found = 1;
 		      
-		      /* copy address into aligned storage */
-		      if (!CHECK_LEN(header, p1, qlen, addrlen))
-			return 0; /* bad packet */
-		      memcpy(&addr, p1, addrlen);
+		      if (flags & F_SRV)
+			{
+			   unsigned char *tmp = namep;
+
+			   if (!CHECK_LEN(header, p1, qlen, 6))
+			     return 0; /* bad packet */
+			   GETSHORT(addr.srv.priority, p1);
+			   GETSHORT(addr.srv.weight, p1);
+			   GETSHORT(addr.srv.srvport, p1);
+			   if (!extract_name(header, qlen, &p1, name, 1, 0))
+			     return 0;
+			   addr.srv.targetlen = strlen(name) + 1; /* include terminating zero */
+			   if (!(addr.srv.target = blockdata_alloc(name, addr.srv.targetlen)))
+			     return 0;
+			   
+			   /* we overwrote the original name, so get it back here. */
+			   if (!extract_name(header, qlen, &tmp, name, 1, 0))
+			     return 0;
+			}
+		      else
+			{
+			  /* copy address into aligned storage */
+			  if (!CHECK_LEN(header, p1, qlen, addrlen))
+			    return 0; /* bad packet */
+			  memcpy(&addr, p1, addrlen);
 		      
-		      /* check for returned address in private space */
-		      if (check_rebind)
-			{
-			  if ((flags & F_IPV4) &&
-			      private_net(addr.addr.addr4, !option_bool(OPT_LOCAL_REBIND)))
-			    return 1;
-			  
-#ifdef HAVE_IPV6
-			  if ((flags & F_IPV6) &&
-			      IN6_IS_ADDR_V4MAPPED(&addr.addr.addr6))
+			  /* check for returned address in private space */
+			  if (check_rebind)
 			    {
-			      struct in_addr v4;
-			      v4.s_addr = ((const uint32_t *) (&addr.addr.addr6))[3];
-			      if (private_net(v4, !option_bool(OPT_LOCAL_REBIND)))
+			      if ((flags & F_IPV4) &&
+				  private_net(addr.addr4, !option_bool(OPT_LOCAL_REBIND)))
 				return 1;
+			      
+			      if ((flags & F_IPV6) &&
+				  IN6_IS_ADDR_V4MAPPED(&addr.addr6))
+				{
+				  struct in_addr v4;
+				  v4.s_addr = ((const uint32_t *) (&addr.addr6))[3];
+				  if (private_net(v4, !option_bool(OPT_LOCAL_REBIND)))
+				    return 1;
+				}
 			    }
-#endif
-			}
-		      
+			  
 #ifdef HAVE_IPSET
-		      if (ipsets && (flags & (F_IPV4 | F_IPV6)))
-			{
-			  ipsets_cur = ipsets;
-			  while (*ipsets_cur)
+			  if (ipsets && (flags & (F_IPV4 | F_IPV6)))
 			    {
-			      log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr, *ipsets_cur);
-			      add_to_ipset(*ipsets_cur++, &addr, flags, 0);
+			      ipsets_cur = ipsets;
+			      while (*ipsets_cur)
+				{
+				  log_query((flags & (F_IPV4 | F_IPV6)) | F_IPSET, name, &addr, *ipsets_cur);
+				  add_to_ipset(*ipsets_cur++, &addr, flags, 0);
+				}
 			    }
+#endif
 			}
-#endif
 		      
-		      newc = cache_insert(name, &addr, now, attl, flags | F_FORWARD | secflag);
+		      newc = cache_insert(name, &addr, C_IN, now, attl, flags | F_FORWARD | secflag);
 		      if (newc && cpp)
 			{
 			  next_uid(newc);
@@ -869,7 +894,7 @@
 		 pointing at this, inherit its TTL */
 	      if (ttl || cpp)
 		{
-		  newc = cache_insert(name, NULL, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | (secure ? F_DNSSECOK : 0));	
+		  newc = cache_insert(name, NULL, C_IN, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | (secure ? F_DNSSECOK : 0));	
 		  if (newc && cpp)
 		    {
 		      next_uid(newc);
@@ -925,12 +950,19 @@
       if (qtype == T_ANY)
 	return  F_IPV4 | F_IPV6;
     }
+
+  /* F_DNSSECOK as agument to search_servers() inhibits forwarding
+     to servers for domains without a trust anchor. This make the
+     behaviour for DS and DNSKEY queries we forward the same
+     as for DS and DNSKEY queries we originate. */
+  if (qtype == T_DS || qtype == T_DNSKEY)
+    return F_DNSSECOK;
   
   return F_QUERY;
 }
 
 size_t setup_reply(struct dns_header *header, size_t qlen,
-		struct all_addr *addrp, unsigned int flags, unsigned long ttl)
+		   union all_addr *addrp, unsigned int flags, unsigned long ttl)
 {
   unsigned char *p;
   
@@ -938,9 +970,9 @@
     return 0;
   
   /* clear authoritative and truncated flags, set QR flag */
-  header->hb3 = (header->hb3 & ~(HB3_AA | HB3_TC)) | HB3_QR;
-  /* set RA flag */
-  header->hb4 |= HB4_RA;
+  header->hb3 = (header->hb3 & ~(HB3_AA | HB3_TC )) | HB3_QR;
+  /* clear AD flag, set RA flag */
+  header->hb4 = (header->hb4 & ~HB4_AD) | HB4_RA;
 
   header->nscount = htons(0);
   header->arcount = htons(0);
@@ -951,8 +983,8 @@
     SET_RCODE(header, NXDOMAIN);
   else if (flags == F_SERVFAIL)
     {
-      struct all_addr a;
-      a.addr.rcode.rcode = SERVFAIL;
+      union all_addr a;
+      a.log.rcode = SERVFAIL;
       log_query(F_CONFIG | F_RCODE, "error", &a, NULL);
       SET_RCODE(header, SERVFAIL);
     }
@@ -966,7 +998,6 @@
 	  add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_A, C_IN, "4", addrp);
 	}
       
-#ifdef HAVE_IPV6
       if (flags & F_IPV6)
 	{
 	  SET_RCODE(header, NOERROR);
@@ -974,12 +1005,11 @@
 	  header->hb3 |= HB3_AA;
 	  add_resource_record(header, NULL, NULL, sizeof(struct dns_header), &p, ttl, NULL, T_AAAA, C_IN, "6", addrp);
 	}
-#endif
     }
   else /* nowhere to forward to */
     {
-      struct all_addr a;
-      a.addr.rcode.rcode = REFUSED;
+      union all_addr a;
+      a.log.rcode = REFUSED;
       log_query(F_CONFIG | F_RCODE, "error", &a, NULL);
       SET_RCODE(header, REFUSED);
     }
@@ -1058,7 +1088,7 @@
 		/* Found a bogus address. Insert that info here, since there no SOA record
 		   to get the ttl from in the normal processing */
 		cache_start_insert();
-		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
+		cache_insert(name, NULL, C_IN, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
 		cache_end_insert();
 		
 		return 1;
@@ -1164,7 +1194,6 @@
   for (; *format; format++)
     switch (*format)
       {
-#ifdef HAVE_IPV6
       case '6':
         CHECK_LIMIT(IN6ADDRSZ);
 	sval = va_arg(ap, char *); 
@@ -1171,7 +1200,6 @@
 	memcpy(p, sval, IN6ADDRSZ);
 	p += IN6ADDRSZ;
 	break;
-#endif
 	
       case '4':
         CHECK_LIMIT(INADDRSZ);
@@ -1273,8 +1301,12 @@
   else
     return daemon->max_ttl;
 }
-  
 
+static int cache_validated(const struct crec *crecp)
+{
+  return (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK));
+}
+
 /* return zero if we can't answer from cache, or packet size if we can */
 size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
 		      struct in_addr local_addr, struct in_addr local_netmask, 
@@ -1283,21 +1315,21 @@
   char *name = daemon->namebuff;
   unsigned char *p, *ansp;
   unsigned int qtype, qclass;
-  struct all_addr addr;
+  union all_addr addr;
   int nameoffset;
   unsigned short flag;
   int q, ans, anscount = 0, addncount = 0;
   int dryrun = 0;
   struct crec *crecp;
-  int nxdomain = 0, auth = 1, trunc = 0, sec_data = 1;
+  int nxdomain = 0, notimp = 0, auth = 1, trunc = 0, sec_data = 1;
   struct mx_srv_record *rec;
   size_t len;
+  int rd_bit = (header->hb3 & HB3_RD);
 
   /* never answer queries with RD unset, to avoid cache snooping. */
-  if (!(header->hb3 & HB3_RD) ||
-      ntohs(header->ancount) != 0 ||
+  if (ntohs(header->ancount) != 0 ||
       ntohs(header->nscount) != 0 ||
-      ntohs(header->qdcount) == 0 || 
+      ntohs(header->qdcount) == 0 ||
       OPCODE(header) != QUERY )
     return 0;
 
@@ -1324,6 +1356,8 @@
 
   for (q = ntohs(header->qdcount); q != 0; q--)
     {
+      int count = 255; /* catch loops */
+      
       /* save pointer to name for copying into answers */
       nameoffset = p - (unsigned char *)header;
 
@@ -1335,7 +1369,35 @@
       GETSHORT(qclass, p);
 
       ans = 0; /* have we answered this question */
-      
+
+      while (--count != 0 && (crecp = cache_find_by_name(NULL, name, now, F_CNAME)))
+	{
+	  char *cname_target = cache_get_cname_target(crecp);
+
+	  /* If the client asked for DNSSEC  don't use cached data. */
+	  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) ||
+	      (rd_bit && (!do_bit || cache_validated(crecp))))
+	    {
+	      if (crecp->flags & F_CONFIG || qtype == T_CNAME)
+		ans = 1;
+
+	      if (!(crecp->flags & F_DNSSECOK))
+		sec_data = 0;
+
+	      if (!dryrun)
+		{
+		  log_query(crecp->flags, name, NULL, record_source(crecp->uid));
+		  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
+					  crec_ttl(crecp, now), &nameoffset,
+					  T_CNAME, C_IN, "d", cname_target))
+		    anscount++;
+		}
+
+	    }
+
+	  strcpy(name, cname_target);
+	}
+	  
       if (qtype == T_TXT || qtype == T_ANY)
 	{
 	  struct txt_record *t;
@@ -1343,12 +1405,11 @@
 	    {
 	      if (t->class == qclass && hostname_isequal(name, t->name))
 		{
-		  ans = 1;
+		  ans = 1, sec_data = 0;
 		  if (!dryrun)
 		    {
 		      unsigned long ttl = daemon->local_ttl;
 		      int ok = 1;
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>");
 #ifndef NO_ID
 		      /* Dynamically generate stat record */
 		      if (t->stat != 0)
@@ -1358,12 +1419,33 @@
 			    ok = 0;
 			}
 #endif
-		      if (ok && add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-						    ttl, NULL,
-						    T_TXT, t->class, "t", t->len, t->txt))
-			anscount++;
+		      if (ok)
+			{
+			  log_query(F_CONFIG | F_RRNAME, name, NULL, "<TXT>");
+			  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
+						  ttl, NULL,
+						  T_TXT, t->class, "t", t->len, t->txt))
+			    anscount++;
+			}
+		    }
+		}
+	    }
+	}
 
+      if (qclass == C_CHAOS)
+	{
+	  /* don't forward *.bind and *.server chaos queries - always reply with NOTIMP */
+	  if (hostname_issubdomain("bind", name) || hostname_issubdomain("server", name))
+	    {
+	      if (!ans)
+		{
+		  notimp = 1, auth = 0;
+		  if (!dryrun)
+		    {
+		       addr.log.rcode = NOTIMP;
+		       log_query(F_CONFIG | F_RCODE, name, &addr, NULL);
 		    }
+		  ans = 1, sec_data = 0;
 		}
 	    }
 	}
@@ -1404,7 +1486,7 @@
 		    struct addrlist *addrlist;
 		    
 		    for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		      if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
+		      if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr4.s_addr == addrlist->addr.addr4.s_addr)
 			break;
 		    
 		    if (addrlist)
@@ -1413,7 +1495,6 @@
 		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 			intr = intr->next;
 		  }
-#ifdef HAVE_IPV6
 	      else if (is_arpa == F_IPV6)
 		for (intr = daemon->int_names; intr; intr = intr->next)
 		  {
@@ -1420,7 +1501,7 @@
 		    struct addrlist *addrlist;
 		    
 		    for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		      if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6, &addrlist->addr.addr.addr6))
+		      if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr6, &addrlist->addr.addr6))
 			break;
 		    
 		    if (addrlist)
@@ -1429,7 +1510,6 @@
 		      while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 			intr = intr->next;
 		  }
-#endif
 	      
 	      if (intr)
 		{
@@ -1465,9 +1545,8 @@
 		  /* Don't use cache when DNSSEC data required, unless we know that
 		     the zone is unsigned, which implies that we're doing
 		     validation. */
-		  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) || 
-		      !do_bit || 
-		      (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK)))
+		  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) ||
+		      (rd_bit && (!do_bit || cache_validated(crecp)) ))
 		    {
 		      do 
 			{ 
@@ -1521,10 +1600,8 @@
 		    }
 		}
 	      else if (option_bool(OPT_BOGUSPRIV) && (
-#ifdef HAVE_IPV6
-		       (is_arpa == F_IPV6 && private_net6(&addr.addr.addr6)) ||
-#endif
-		       (is_arpa == F_IPV4 && private_net(addr.addr.addr4, 1))))
+		       (is_arpa == F_IPV6 && private_net6(&addr.addr6)) ||
+		       (is_arpa == F_IPV4 && private_net(addr.addr4, 1))))
 		{
 		  struct server *serv;
 		  unsigned int namelen = strlen(name);
@@ -1561,24 +1638,16 @@
 		    }
 		}
 	    }
-	  
+
 	  for (flag = F_IPV4; flag; flag = (flag == F_IPV4) ? F_IPV6 : 0)
 	    {
-	      unsigned short type = T_A;
+	      unsigned short type = (flag == F_IPV6) ? T_AAAA : T_A;
 	      struct interface_name *intr;
 
-	      if (flag == F_IPV6)
-#ifdef HAVE_IPV6
-		type = T_AAAA;
-#else
-	        break;
-#endif
-	      
 	      if (qtype != type && qtype != T_ANY)
 		continue;
 	      
 	      /* interface name stuff */
-	    intname_restart:
 	      for (intr = daemon->int_names; intr; intr = intr->next)
 		if (hostname_isequal(name, intr->name))
 		  break;
@@ -1596,31 +1665,26 @@
 		    for (intr = daemon->int_names; intr; intr = intr->next)
 		      if (hostname_isequal(name, intr->name))
 			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-#ifdef HAVE_IPV6
-			  if (!(addrlist->flags & ADDRLIST_IPV6))
-#endif
-			    if (is_same_net(*((struct in_addr *)&addrlist->addr), local_addr, local_netmask))
-			      {
-				localise = 1;
-				break;
-			      }
+			  if (!(addrlist->flags & ADDRLIST_IPV6) && 
+			      is_same_net(addrlist->addr.addr4, local_addr, local_netmask))
+			    {
+			      localise = 1;
+			      break;
+			    }
 		  
 		  for (intr = daemon->int_names; intr; intr = intr->next)
 		    if (hostname_isequal(name, intr->name))
 		      {
 			for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-#ifdef HAVE_IPV6
 			  if (((addrlist->flags & ADDRLIST_IPV6) ? T_AAAA : T_A) == type)
-#endif
 			    {
 			      if (localise && 
-				  !is_same_net(*((struct in_addr *)&addrlist->addr), local_addr, local_netmask))
+				  !is_same_net(addrlist->addr.addr4, local_addr, local_netmask))
 				continue;
 
-#ifdef HAVE_IPV6
 			      if (addrlist->flags & ADDRLIST_REVONLY)
 				continue;
-#endif	
+
 			      ans = 1;	
 			      sec_data = 0;
 			      if (!dryrun)
@@ -1641,8 +1705,7 @@
 		  continue;
 		}
 
-	    cname_restart:
-	      if ((crecp = cache_find_by_name(NULL, name, now, flag | F_CNAME | (dryrun ? F_NO_RR : 0))))
+	      if ((crecp = cache_find_by_name(NULL, name, now, flag | (dryrun ? F_NO_RR : 0))))
 		{
 		  int localise = 0;
 		  
@@ -1653,19 +1716,18 @@
 		      struct crec *save = crecp;
 		      do {
 			if ((crecp->flags & F_HOSTS) &&
-			    is_same_net(*((struct in_addr *)&crecp->addr), local_addr, local_netmask))
+			    is_same_net(crecp->addr.addr4, local_addr, local_netmask))
 			  {
 			    localise = 1;
 			    break;
 			  } 
-			} while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+			} while ((crecp = cache_find_by_name(crecp, name, now, flag)));
 		      crecp = save;
 		    }
 
 		  /* If the client asked for DNSSEC  don't use cached data. */
 		  if ((crecp->flags & (F_HOSTS | F_DHCP | F_CONFIG)) ||
-		      !do_bit ||
-		      (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK)))
+		      (rd_bit && (!do_bit || cache_validated(crecp)) ))
 		    do
 		      { 
 			/* don't answer wildcard queries with data not from /etc/hosts
@@ -1676,27 +1738,6 @@
 			if (!(crecp->flags & F_DNSSECOK))
 			  sec_data = 0;
 			
-			if (crecp->flags & F_CNAME)
-			  {
-			    char *cname_target = cache_get_cname_target(crecp);
-			    
-			    if (!dryrun)
-			      {
-				log_query(crecp->flags, name, NULL, record_source(crecp->uid));
-				if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-							crec_ttl(crecp, now), &nameoffset,
-							T_CNAME, C_IN, "d", cname_target))
-				  anscount++;
-			      }
-			    
-			    strcpy(name, cname_target);
-			    /* check if target interface_name */
-			    if (crecp->addr.cname.uid == SRC_INTERFACE)
-			      goto intname_restart;
-			    else
-			      goto cname_restart;
-			  }
-			
 			if (crecp->flags & F_NEG)
 			  {
 			    ans = 1;
@@ -1712,7 +1753,7 @@
 			       filter here. */
 			    if (localise && 
 				(crecp->flags & F_HOSTS) &&
-				!is_same_net(*((struct in_addr *)&crecp->addr), local_addr, local_netmask))
+				!is_same_net(crecp->addr.addr4, local_addr, local_netmask))
 			      continue;
 			    
 			    if (!(crecp->flags & (F_HOSTS | F_DHCP)))
@@ -1721,7 +1762,7 @@
 			    ans = 1;
 			    if (!dryrun)
 			      {
-				log_query(crecp->flags & ~F_REVERSE, name, &crecp->addr.addr,
+				log_query(crecp->flags & ~F_REVERSE, name, &crecp->addr,
 					  record_source(crecp->uid));
 				
 				if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
@@ -1730,11 +1771,11 @@
 				  anscount++;
 			      }
 			  }
-		      } while ((crecp = cache_find_by_name(crecp, name, now, flag | F_CNAME)));
+		      } while ((crecp = cache_find_by_name(crecp, name, now, flag)));
 		}
 	      else if (is_name_synthetic(flag, name, &addr))
 		{
-		  ans = 1;
+		  ans = 1, sec_data = 0;
 		  if (!dryrun)
 		    {
 		      log_query(F_FORWARD | F_CONFIG | flag, name, &addr, NULL);
@@ -1745,27 +1786,6 @@
 		}
 	    }
 
-	  if (qtype == T_CNAME || qtype == T_ANY)
-	    {
-	      if ((crecp = cache_find_by_name(NULL, name, now, F_CNAME | (dryrun ? F_NO_RR : 0))) &&
-		  (qtype == T_CNAME || (crecp->flags & F_CONFIG)) &&
-		  ((crecp->flags & F_CONFIG) || !do_bit || (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK))))
-		{
-		  if (!(crecp->flags & F_DNSSECOK))
-		    sec_data = 0;
-		  
-		  ans = 1;
-		  if (!dryrun)
-		    {
-		      log_query(crecp->flags, name, NULL, record_source(crecp->uid));
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
-					      crec_ttl(crecp, now), &nameoffset,
-					      T_CNAME, C_IN, "d", cache_get_cname_target(crecp)))
-			anscount++;
-		    }
-		}
-	    }
-
 	  if (qtype == T_MX || qtype == T_ANY)
 	    {
 	      int found = 0;
@@ -1772,25 +1792,27 @@
 	      for (rec = daemon->mxnames; rec; rec = rec->next)
 		if (!rec->issrv && hostname_isequal(name, rec->name))
 		  {
-		  ans = found = 1;
-		  if (!dryrun)
-		    {
-		      int offset;
-		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
-		      if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
-					      &offset, T_MX, C_IN, "sd", rec->weight, rec->target))
-			{
-			  anscount++;
-			  if (rec->target)
-			    rec->offset = offset;
-			}
-		    }
+		    ans = found = 1;
+		    sec_data = 0;
+		    if (!dryrun)
+		      {
+			int offset;
+			log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
+			if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, daemon->local_ttl,
+						&offset, T_MX, C_IN, "sd", rec->weight, rec->target))
+			  {
+			    anscount++;
+			    if (rec->target)
+			      rec->offset = offset;
+			  }
+		      }
 		  }
 	      
-	      if (!found && (option_bool(OPT_SELFMX) || option_bool(OPT_LOCALMX)) && 
+	      if (!found && (option_bool(OPT_SELFMX) || option_bool(OPT_LOCALMX)) &&
 		  cache_find_by_name(NULL, name, now, F_HOSTS | F_DHCP | F_NO_RR))
 		{ 
 		  ans = 1;
+		  sec_data = 0;
 		  if (!dryrun)
 		    {
 		      log_query(F_CONFIG | F_RRNAME, name, NULL, "<MX>");
@@ -1811,6 +1833,7 @@
 		if (rec->issrv && hostname_isequal(name, rec->name))
 		  {
 		    found = ans = 1;
+		    sec_data = 0;
 		    if (!dryrun)
 		      {
 			int offset;
@@ -1843,10 +1866,45 @@
 		  *up = move;
 		  move->next = NULL;
 		}
-	      
+
+	      if (!found)
+		{
+		  if ((crecp = cache_find_by_name(NULL, name, now, F_SRV | (dryrun ? F_NO_RR : 0))) &&
+		      rd_bit && (!do_bit || (option_bool(OPT_DNSSEC_VALID) && !(crecp->flags & F_DNSSECOK))))
+		    {
+		      if (!(crecp->flags & F_DNSSECOK))
+			sec_data = 0;
+		      
+		      auth = 0;
+		      found = ans = 1;
+		      
+		      do {
+			if (crecp->flags & F_NEG)
+			  {
+			    if (crecp->flags & F_NXDOMAIN)
+			      nxdomain = 1;
+			    if (!dryrun)
+			      log_query(crecp->flags, name, NULL, NULL);
+			  }
+			else if (!dryrun)
+			  {
+			    char *target = blockdata_retrieve(crecp->addr.srv.target, crecp->addr.srv.targetlen, NULL);
+			    log_query(crecp->flags, name, NULL, 0);
+			    
+			    if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
+						    crec_ttl(crecp, now), NULL, T_SRV, C_IN, "sssd",
+						    crecp->addr.srv.priority, crecp->addr.srv.weight, crecp->addr.srv.srvport,
+						    target))
+			      anscount++;
+			  }
+		      } while ((crecp = cache_find_by_name(crecp, name, now, F_SRV)));
+		    }
+		}
+
 	      if (!found && option_bool(OPT_FILTER) && (qtype == T_SRV || (qtype == T_ANY && strchr(name, '_'))))
 		{
 		  ans = 1;
+		  sec_data = 0;
 		  if (!dryrun)
 		    log_query(F_CONFIG | F_NEG, name, NULL, NULL);
 		}
@@ -1859,6 +1917,7 @@
 		if (hostname_isequal(name, na->name))
 		  {
 		    ans = 1;
+		    sec_data = 0;
 		    if (!dryrun)
 		      {
 			log_query(F_CONFIG | F_RRNAME, name, NULL, "<NAPTR>");
@@ -1871,11 +1930,12 @@
 	    }
 	  
 	  if (qtype == T_MAILB)
-	    ans = 1, nxdomain = 1;
+	    ans = 1, nxdomain = 1, sec_data = 0;
 
 	  if (qtype == T_SOA && option_bool(OPT_FILTER))
 	    {
-	      ans = 1; 
+	      ans = 1;
+	      sec_data = 0;
 	      if (!dryrun)
 		log_query(F_CONFIG | F_NEG, name, &addr, NULL);
 	    }
@@ -1904,11 +1964,8 @@
 	crecp = NULL;
 	while ((crecp = cache_find_by_name(crecp, rec->target, now, F_IPV4 | F_IPV6)))
 	  {
-#ifdef HAVE_IPV6
 	    int type =  crecp->flags & F_IPV4 ? T_A : T_AAAA;
-#else
-	    int type = T_A;
-#endif
+
 	    if (crecp->flags & F_NEG)
 	      continue;
 
@@ -1935,6 +1992,8 @@
   
   if (nxdomain)
     SET_RCODE(header, NXDOMAIN);
+  else if (notimp)
+    SET_RCODE(header, NOTIMP);
   else
     SET_RCODE(header, NOERROR); /* no error */
   header->ancount = htons(anscount);
Index: src/rfc2131.c
===================================================================
--- src/rfc2131.c	(revision 41436)
+++ src/rfc2131.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -241,7 +241,7 @@
 	subnet_addr = option_addr(opt);
       
       /* If there is no client identifier option, use the hardware address */
-      if ((opt = option_find(mess, sz, OPTION_CLIENT_ID, 1)))
+      if (!option_bool(OPT_IGNORE_CLID) && (opt = option_find(mess, sz, OPTION_CLIENT_ID, 1)))
 	{
 	  clid_len = option_len(opt);
 	  clid = option_ptr(opt, 0);
@@ -281,8 +281,9 @@
   if (mess->giaddr.s_addr || subnet_addr.s_addr || mess->ciaddr.s_addr)
     {
       struct dhcp_context *context_tmp, *context_new = NULL;
+      struct shared_network *share = NULL;
       struct in_addr addr;
-      int force = 0;
+      int force = 0, via_relay = 0;
       
       if (subnet_addr.s_addr)
 	{
@@ -293,6 +294,7 @@
 	{
 	  addr = mess->giaddr;
 	  force = 1;
+	  via_relay = 1;
 	}
       else
 	{
@@ -309,42 +311,65 @@
 	} 
 		
       if (!context_new)
-	for (context_tmp = daemon->dhcp; context_tmp; context_tmp = context_tmp->next)
-	  {
-	    struct in_addr netmask = context_tmp->netmask;
+	{
+	  for (context_tmp = daemon->dhcp; context_tmp; context_tmp = context_tmp->next)
+	    {
+	      struct in_addr netmask = context_tmp->netmask;
+	      
+	      /* guess the netmask for relayed networks */
+	      if (!(context_tmp->flags & CONTEXT_NETMASK) && context_tmp->netmask.s_addr == 0)
+		{
+		  if (IN_CLASSA(ntohl(context_tmp->start.s_addr)) && IN_CLASSA(ntohl(context_tmp->end.s_addr)))
+		    netmask.s_addr = htonl(0xff000000);
+		  else if (IN_CLASSB(ntohl(context_tmp->start.s_addr)) && IN_CLASSB(ntohl(context_tmp->end.s_addr)))
+		    netmask.s_addr = htonl(0xffff0000);
+		  else if (IN_CLASSC(ntohl(context_tmp->start.s_addr)) && IN_CLASSC(ntohl(context_tmp->end.s_addr)))
+		    netmask.s_addr = htonl(0xffffff00); 
+		}
 
-	    /* guess the netmask for relayed networks */
-	    if (!(context_tmp->flags & CONTEXT_NETMASK) && context_tmp->netmask.s_addr == 0)
-	      {
-		if (IN_CLASSA(ntohl(context_tmp->start.s_addr)) && IN_CLASSA(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xff000000);
-		else if (IN_CLASSB(ntohl(context_tmp->start.s_addr)) && IN_CLASSB(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xffff0000);
-		else if (IN_CLASSC(ntohl(context_tmp->start.s_addr)) && IN_CLASSC(ntohl(context_tmp->end.s_addr)))
-		  netmask.s_addr = htonl(0xffffff00); 
-	      }
-	    
-	    /* This section fills in context mainly when a client which is on a remote (relayed)
-	       network renews a lease without using the relay, after dnsmasq has restarted. */
-	    if (netmask.s_addr != 0  && 
-		is_same_net(addr, context_tmp->start, netmask) &&
-		is_same_net(addr, context_tmp->end, netmask))
-	      {
-		context_tmp->netmask = netmask;
-		if (context_tmp->local.s_addr == 0)
-		  context_tmp->local = fallback;
-		if (context_tmp->router.s_addr == 0)
-		  context_tmp->router = mess->giaddr;
-	   
-		/* fill in missing broadcast addresses for relayed ranges */
-		if (!(context_tmp->flags & CONTEXT_BRDCAST) && context_tmp->broadcast.s_addr == 0 )
-		  context_tmp->broadcast.s_addr = context_tmp->start.s_addr | ~context_tmp->netmask.s_addr;
-		
-		context_tmp->current = context_new;
-		context_new = context_tmp;
-	      }
-	  }
-      
+	      /* check to see is a context is OK because of a shared address on
+		 the relayed subnet. */
+	      if (via_relay)
+		for (share = daemon->shared_networks; share; share = share->next)
+		  {
+#ifdef HAVE_DHCP6
+		    if (share->shared_addr.s_addr == 0)
+		      continue;
+#endif
+		    if (share->if_index != 0 ||
+			share->match_addr.s_addr != mess->giaddr.s_addr)
+		      continue;
+		    
+		    if (netmask.s_addr != 0  && 
+			is_same_net(share->shared_addr, context_tmp->start, netmask) &&
+			is_same_net(share->shared_addr, context_tmp->end, netmask))
+		      break;
+		  }
+	      
+	      /* This section fills in context mainly when a client which is on a remote (relayed)
+		 network renews a lease without using the relay, after dnsmasq has restarted. */
+	      if (share ||
+		  (netmask.s_addr != 0  && 
+		   is_same_net(addr, context_tmp->start, netmask) &&
+		   is_same_net(addr, context_tmp->end, netmask)))
+		{
+		  context_tmp->netmask = netmask;
+		  if (context_tmp->local.s_addr == 0)
+		    context_tmp->local = fallback;
+		  if (context_tmp->router.s_addr == 0 && !share)
+		    context_tmp->router = mess->giaddr;
+		  
+		  /* fill in missing broadcast addresses for relayed ranges */
+		  if (!(context_tmp->flags & CONTEXT_BRDCAST) && context_tmp->broadcast.s_addr == 0 )
+		    context_tmp->broadcast.s_addr = context_tmp->start.s_addr | ~context_tmp->netmask.s_addr;
+		  
+		  context_tmp->current = context_new;
+		  context_new = context_tmp;
+		}
+	      
+	    }
+	}
+	  
       if (context_new || force)
 	context = context_new; 
     }
@@ -395,7 +420,7 @@
 		for (o2 = offset + 5; o2 < offset + len + 5; o2 += elen + 1)
 		  { 
 		    elen = option_uint(opt, o2, 1);
-		    if ((o2 + elen + 1 <= option_len(opt)) &&
+		    if ((o2 + elen + 1 <= (unsigned)option_len(opt)) &&
 			(match = match_bytes(o, option_ptr(opt, o2 + 1), elen)))
 		      break;
 		  }
@@ -486,7 +511,7 @@
   mess->op = BOOTREPLY;
   
   config = find_config(daemon->dhcp_conf, context, clid, clid_len, 
-		       mess->chaddr, mess->hlen, mess->htype, NULL);
+		       mess->chaddr, mess->hlen, mess->htype, NULL, run_tag_if(netid));
 
   /* set "known" tag for known hosts */
   if (config)
@@ -496,7 +521,7 @@
       netid = &known_id;
     }
   else if (find_config(daemon->dhcp_conf, NULL, clid, clid_len, 
-		       mess->chaddr, mess->hlen, mess->htype, NULL))
+		       mess->chaddr, mess->hlen, mess->htype, NULL, run_tag_if(netid)))
     {
       known_id.net = "known-othernet";
       known_id.next = netid;
@@ -707,9 +732,37 @@
 	client_hostname = daemon->dhcp_buff;
     }
 
-  if (client_hostname && option_bool(OPT_LOG_OPTS))
-    my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), ntohl(mess->xid), client_hostname);
-
+  if (client_hostname)
+    {
+      struct dhcp_match_name *m;
+      size_t nl = strlen(client_hostname);
+      
+      if (option_bool(OPT_LOG_OPTS))
+	my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), ntohl(mess->xid), client_hostname);
+      for (m = daemon->dhcp_name_match; m; m = m->next)
+	{
+	  size_t ml = strlen(m->name);
+	  char save = 0;
+	  
+	  if (nl < ml)
+	    continue;
+	  if (nl > ml)
+	    {
+	      save = client_hostname[ml];
+	      client_hostname[ml] = 0;
+	    }
+	  
+	  if (hostname_isequal(client_hostname, m->name) &&
+	      (save == 0 || m->wildcard))
+	    {
+	      m->netid->next = netid;
+	      netid = m->netid;
+	    }
+	  
+	  if (save != 0)
+	    client_hostname[ml] = save;
+	}
+    }
   
   if (have_config(config, CONFIG_NAME))
     {
@@ -722,12 +775,9 @@
     }
   else if (client_hostname)
     {
-      struct dhcp_match_name *m;
-      size_t nl;
-
       domain = strip_hostname(client_hostname);
       
-      if ((nl = strlen(client_hostname)) != 0)
+      if (strlen(client_hostname) != 0)
 	{
 	  hostname = client_hostname;
 	  
@@ -738,7 +788,7 @@
 		 to avoid impersonation by name. */
 	      struct dhcp_config *new = find_config(daemon->dhcp_conf, context, NULL, 0,
 						    mess->chaddr, mess->hlen, 
-						    mess->htype, hostname);
+						    mess->htype, hostname, run_tag_if(netid));
 	      if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
 		{
 		  config = new;
@@ -748,30 +798,6 @@
 		  netid = &known_id;
 		}
 	    }
-
-	  for (m = daemon->dhcp_name_match; m; m = m->next)
-	    {
-	      size_t ml = strlen(m->name);
-	      char save = 0;
-	      
-	      if (nl < ml)
-		continue;
-	      if (nl > ml)
-		{
-		  save = client_hostname[ml];
-		  client_hostname[ml] = 0;
-		}
-	      
-	      if (hostname_isequal(client_hostname, m->name) &&
-		  (save == 0 || m->wildcard))
-		{
-		  m->netid->next = netid;
-		  netid = m->netid;
-	    }
-	      
-	      if (save != 0)
-		client_hostname[ml] = save;
-	    }
 	}
     }
   
Index: src/rfc3315.c
===================================================================
--- src/rfc3315.c	(revision 41436)
+++ src/rfc3315.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -21,19 +21,16 @@
 
 struct state {
   unsigned char *clid;
-  int clid_len, iaid, ia_type, interface, hostname_auth, lease_allocate;
+  int clid_len, ia_type, interface, hostname_auth, lease_allocate;
   char *client_hostname, *hostname, *domain, *send_domain;
   struct dhcp_context *context;
   struct in6_addr *link_address, *fallback, *ll_addr, *ula_addr;
-  unsigned int xid, fqdn_flags;
+  unsigned int xid, fqdn_flags, iaid;
   char *iface_name;
   void *packet_options, *end;
   struct dhcp_netid *tags, *context_tags;
   unsigned char mac[DHCP_CHADDR_MAX];
   unsigned int mac_len, mac_type;
-#ifdef OPTION6_PREFIX_CLASS
-  struct prefix_class *send_prefix_class;
-#endif
 };
 
 static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz, 
@@ -49,12 +46,11 @@
 static int check_ia(struct state *state, void *opt, void **endp, void **ia_option);
 static int build_ia(struct state *state, int *t1cntr);
 static void end_ia(int t1cntr, unsigned int min_time, int do_fuzz);
-#ifdef OPTION6_PREFIX_CLASS
-static struct prefix_class *prefix_class_from_context(struct dhcp_context *context);
-#endif
 static void mark_context_used(struct state *state, struct in6_addr *addr);
 static void mark_config_used(struct dhcp_context *context, struct in6_addr *addr);
 static int check_address(struct state *state, struct in6_addr *addr);
+static int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr, struct state *state, time_t now);
+static struct addrlist *config_implies(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr);
 static void add_address(struct state *state, struct dhcp_context *context, unsigned int lease_time, void *ia_option, 
 			unsigned int *min_time, struct in6_addr *addr, time_t now);
 static void update_leases(struct state *state, struct dhcp_context *context, struct in6_addr *addr, unsigned int lease_time, time_t now);
@@ -134,21 +130,41 @@
       else
 	{
 	  struct dhcp_context *c;
+	  struct shared_network *share = NULL;
 	  state->context = NULL;
-	   
+
 	  if (!IN6_IS_ADDR_LOOPBACK(state->link_address) &&
 	      !IN6_IS_ADDR_LINKLOCAL(state->link_address) &&
 	      !IN6_IS_ADDR_MULTICAST(state->link_address))
 	    for (c = daemon->dhcp6; c; c = c->next)
-	      if ((c->flags & CONTEXT_DHCP) &&
-		  !(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-		  is_same_net6(state->link_address, &c->start6, c->prefix) &&
-		  is_same_net6(state->link_address, &c->end6, c->prefix))
-		{
-		  c->preferred = c->valid = 0xffffffff;
-		  c->current = state->context;
-		  state->context = c;
-		}
+	      {
+		for (share = daemon->shared_networks; share; share = share->next)
+		  {
+		    if (share->shared_addr.s_addr != 0)
+		      continue;
+		    
+		    if (share->if_index != 0 ||
+			!IN6_ARE_ADDR_EQUAL(state->link_address, &share->match_addr6))
+		      continue;
+		    
+		    if ((c->flags & CONTEXT_DHCP) &&
+			!(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+			is_same_net6(&share->shared_addr6, &c->start6, c->prefix) &&
+			is_same_net6(&share->shared_addr6, &c->end6, c->prefix))
+		      break;
+		  }
+		
+		if (share ||
+		    ((c->flags & CONTEXT_DHCP) &&
+		     !(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+		     is_same_net6(state->link_address, &c->start6, c->prefix) &&
+		     is_same_net6(state->link_address, &c->end6, c->prefix)))
+		  {
+		    c->preferred = c->valid = 0xffffffff;
+		    c->current = state->context;
+		    state->context = c;
+		  }
+	      }
 	  
 	  if (!state->context)
 	    {
@@ -219,21 +235,25 @@
       if (opt6_ptr(opt, 0) + opt6_len(opt) > end) 
         return 0;
      
-      int o = new_opt6(opt6_type(opt));
-      if (opt6_type(opt) == OPTION6_RELAY_MSG)
+      /* Don't copy MAC address into reply. */
+      if (opt6_type(opt) != OPTION6_CLIENT_MAC)
 	{
-	  struct in6_addr align;
-	  /* the packet data is unaligned, copy to aligned storage */
-	  memcpy(&align, inbuff + 2, IN6ADDRSZ); 
-	  state->link_address = &align;
-	  /* zero is_unicast since that is now known to refer to the 
-	     relayed packet, not the original sent by the client */
-	  if (!dhcp6_maybe_relay(state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now))
-	    return 0;
+	  int o = new_opt6(opt6_type(opt));
+	  if (opt6_type(opt) == OPTION6_RELAY_MSG)
+	    {
+	      struct in6_addr align;
+	      /* the packet data is unaligned, copy to aligned storage */
+	      memcpy(&align, inbuff + 2, IN6ADDRSZ); 
+	      state->link_address = &align;
+	      /* zero is_unicast since that is now known to refer to the 
+		 relayed packet, not the original sent by the client */
+	      if (!dhcp6_maybe_relay(state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now))
+		return 0;
+	    }
+	  else
+	    put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
+	  end_opt6(o);
 	}
-      else if (opt6_type(opt) != OPTION6_CLIENT_MAC)
-	put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
-      end_opt6(o);	    
     }
   
   return 1;
@@ -252,10 +272,6 @@
   struct dhcp_context *context_tmp;
   struct dhcp_mac *mac_opt;
   unsigned int ignore = 0;
-#ifdef OPTION6_PREFIX_CLASS
-  struct prefix_class *p;
-  int dump_all_prefix_classes = 0;
-#endif
 
   state->packet_options = inbuff + 4;
   state->end = inbuff + sz;
@@ -269,9 +285,6 @@
   state->hostname = NULL;
   state->client_hostname = NULL;
   state->fqdn_flags = 0x01; /* default to send if we receive no FQDN option */
-#ifdef OPTION6_PREFIX_CLASS
-  state->send_prefix_class = NULL;
-#endif
 
   /* set tag with name == interface */
   iface_id.net = state->iface_name;
@@ -477,68 +490,66 @@
 	   
 	   if (legal_hostname(daemon->dhcp_buff))
 	     {
+	       struct dhcp_match_name *m;
+	       size_t nl = strlen(daemon->dhcp_buff);
+	       
 	       state->client_hostname = daemon->dhcp_buff;
+	       
 	       if (option_bool(OPT_LOG_OPTS))
-		 my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), state->xid, state->client_hostname); 
+		 my_syslog(MS_DHCP | LOG_INFO, _("%u client provides name: %s"), state->xid, state->client_hostname);
+	       
+	       for (m = daemon->dhcp_name_match; m; m = m->next)
+		 {
+		   size_t ml = strlen(m->name);
+		   char save = 0;
+		   
+		   if (nl < ml)
+		     continue;
+		   if (nl > ml)
+		     {
+		       save = state->client_hostname[ml];
+		       state->client_hostname[ml] = 0;
+		     }
+		   
+		   if (hostname_isequal(state->client_hostname, m->name) &&
+		       (save == 0 || m->wildcard))
+		     {
+		       m->netid->next = state->tags;
+		       state->tags = m->netid;
+		     }
+		   
+		   if (save != 0)
+		     state->client_hostname[ml] = save;
+		 }
 	     }
 	 }
     }	 
   
-  if (state->clid)
+  if (state->clid &&
+      (config = find_config(daemon->dhcp_conf, state->context, state->clid, state->clid_len,
+			    state->mac, state->mac_len, state->mac_type, NULL, run_tag_if(state->tags))) &&
+      have_config(config, CONFIG_NAME))
     {
-      config = find_config(daemon->dhcp_conf, state->context, state->clid, state->clid_len, state->mac, state->mac_len, state->mac_type, NULL);
+      state->hostname = config->hostname;
+      state->domain = config->domain;
+      state->hostname_auth = 1;
+    }
+  else if (state->client_hostname)
+    {
+      state->domain = strip_hostname(state->client_hostname);
       
-      if (have_config(config, CONFIG_NAME))
+      if (strlen(state->client_hostname) != 0)
 	{
-	  state->hostname = config->hostname;
-	  state->domain = config->domain;
-	  state->hostname_auth = 1;
-	}
-      else if (state->client_hostname)
-	{
-	  struct dhcp_match_name *m;
-	  size_t nl;
-
-	  state->domain = strip_hostname(state->client_hostname);
-	  nl = strlen(state->client_hostname);
+	  state->hostname = state->client_hostname;
 	  
-	  if (strlen(state->client_hostname) != 0)
+	  if (!config)
 	    {
-	      state->hostname = state->client_hostname;
-	      
-	      if (!config)
-		{
-		  /* Search again now we have a hostname. 
-		     Only accept configs without CLID here, (it won't match)
-		     to avoid impersonation by name. */
-		  struct dhcp_config *new = find_config(daemon->dhcp_conf, state->context, NULL, 0, NULL, 0, 0, state->hostname);
-		  if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
-		    config = new;
-		}
-	      
-	      for (m = daemon->dhcp_name_match; m; m = m->next)
-		{
-		  size_t ml = strlen(m->name);
-		  char save = 0;
-		  
-		  if (nl < ml)
-		    continue;
-		  if (nl > ml)
-		    {
-		      save = state->client_hostname[ml];
-		      state->client_hostname[ml] = 0;
-		    }
-		  
-		  if (hostname_isequal(state->client_hostname, m->name) &&
-		      (save == 0 || m->wildcard))
-		    {
-		      m->netid->next = state->tags;
-		      state->tags = m->netid;
-		    }
-		  
-		  if (save != 0)
-		    state->client_hostname[ml] = save;
-		}
+	      /* Search again now we have a hostname. 
+		 Only accept configs without CLID here, (it won't match)
+		 to avoid impersonation by name. */
+	      struct dhcp_config *new = find_config(daemon->dhcp_conf, state->context, NULL, 0, NULL, 0, 0, state->hostname, run_tag_if(state->tags));
+	      if (new && !have_config(new, CONFIG_CLID) && !new->hwaddr)
+		config = new;
 	    }
 	}
     }
@@ -562,7 +573,8 @@
 	ignore = 1;
     }
   else if (state->clid &&
-	   find_config(daemon->dhcp_conf, NULL, state->clid, state->clid_len, state->mac, state->mac_len, state->mac_type, NULL))
+	   find_config(daemon->dhcp_conf, NULL, state->clid, state->clid_len,
+		       state->mac, state->mac_len, state->mac_type, NULL, run_tag_if(state->tags)))
     {
       known_id.net = "known-othernet";
       known_id.next = state->tags;
@@ -569,31 +581,6 @@
       state->tags = &known_id;
     }
   
-#ifdef OPTION6_PREFIX_CLASS
-  /* OPTION_PREFIX_CLASS in ORO, send addresses in all prefix classes */
-  if (daemon->prefix_classes && (msg_type == DHCP6SOLICIT || msg_type == DHCP6REQUEST))
-    {
-      void *oro;
-      
-      if ((oro = opt6_find(state->packet_options, state->end, OPTION6_ORO, 0)))
-	for (i = 0; i <  opt6_len(oro) - 1; i += 2)
-	  if (opt6_uint(oro, i, 2) == OPTION6_PREFIX_CLASS)
-	    {
-	      dump_all_prefix_classes = 1;
-	      break;
-	    }
-      
-      if (msg_type != DHCP6SOLICIT || dump_all_prefix_classes)
-	/* Add the tags associated with prefix classes so we can use the DHCP ranges.
-	   Not done for SOLICIT as we add them  one-at-time. */
-	for (p = daemon->prefix_classes; p ; p = p->next)
-	  {
-	    p->tag.next = state->tags;
-	    state->tags = &p->tag;
-	  }
-    }    
-#endif
-
   tagif = run_tag_if(state->tags);
   
   /* if all the netids in the ignore list are present, ignore this client */
@@ -677,60 +664,6 @@
 	    for (c = state->context; c; c = c->current)
 	      c->flags &= ~CONTEXT_USED;
 
-#ifdef OPTION6_PREFIX_CLASS
-	    if (daemon->prefix_classes && state->ia_type == OPTION6_IA_NA)
-	      {
-		void *prefix_opt;
-		int prefix_class;
-		
-		if (dump_all_prefix_classes)
-		  /* OPTION_PREFIX_CLASS in ORO, send addresses in all prefix classes */
-		  plain_range = 0;
-		else 
-		  { 
-		    if ((prefix_opt = opt6_find(opt6_ptr(opt, 12), ia_end, OPTION6_PREFIX_CLASS, 2)))
-		      {
-			
-			prefix_class = opt6_uint(prefix_opt, 0, 2);
-			
-			for (p = daemon->prefix_classes; p ; p = p->next)
-			  if (p->class == prefix_class)
-			    break;
-			
-			if (!p)
-			  my_syslog(MS_DHCP | LOG_WARNING, _("unknown prefix-class %d"), prefix_class);
-			else
-			  {
-			    /* add tag to list, and exclude undecorated dhcp-ranges */
-			    p->tag.next = state->tags;
-			    solicit_tags = run_tag_if(&p->tag);
-			    plain_range = 0;
-			    state->send_prefix_class = p;
-			  }
-		      }
-		    else
-		      {
-			/* client didn't ask for a prefix class, lets see if we can find one. */
-			for (p = daemon->prefix_classes; p ; p = p->next)
-			  {
-			    p->tag.next = NULL;
-			    if (match_netid(&p->tag, solicit_tags, 1))
-			      break;
-			  }
-			
-			if (p)
-			  {
-			    plain_range = 0;
-			    state->send_prefix_class = p;
-			  }
-		      }
-
-		    if (p && option_bool(OPT_LOG_OPTS))
-		      my_syslog(MS_DHCP | LOG_INFO, "%u prefix class %d tag:%s", state->xid, p->class, p->tag.net); 
-		  }
-	      }
-#endif
-
 	    o = build_ia(state, &t1cntr);
 	    if (address_assigned)
 		address_assigned = 2;
@@ -746,7 +679,7 @@
 		    /* If the client asks for an address on the same network as a configured address, 
 		       offer the configured address instead, to make moving to newly-configured
 		       addresses automatic. */
-		    if (!(c->flags & CONTEXT_CONF_USED) && config_valid(config, c, &addr) && check_address(state, &addr))
+		    if (!(c->flags & CONTEXT_CONF_USED) && config_valid(config, c, &addr, state, now))
 		      {
 			req_addr = addr;
 			mark_config_used(c, &addr);
@@ -759,10 +692,6 @@
 		      continue; /* address leased elsewhere */
 		    
 		    /* add address to output packet */
-#ifdef OPTION6_PREFIX_CLASS
-		    if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		      state->send_prefix_class = prefix_class_from_context(c);
-#endif		    
 		    add_address(state, c, lease_time, ia_option, &min_time, &req_addr, now);
 		    mark_context_used(state, &req_addr);
 		    get_context_tag(state, c);
@@ -774,8 +703,7 @@
 	    for (c = state->context; c; c = c->current) 
 	      if (!(c->flags & CONTEXT_CONF_USED) &&
 		  match_netid(c->filter, solicit_tags, plain_range) &&
-		  config_valid(config, c, &addr) && 
-		  check_address(state, &addr))
+		  config_valid(config, c, &addr, state, now))
 		{
 		  mark_config_used(state->context, &addr);
 		  if (have_config(config, CONFIG_TIME))
@@ -782,11 +710,8 @@
 		    lease_time = config->lease_time;
 		  else
 		    lease_time = c->lease_time;
+
 		  /* add address to output packet */
-#ifdef OPTION6_PREFIX_CLASS
-		  if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		    state->send_prefix_class = prefix_class_from_context(c);
-#endif
 		  add_address(state, c, lease_time, NULL, &min_time, &addr, now);
 		  mark_context_used(state, &addr);
 		  get_context_tag(state, c);
@@ -800,10 +725,6 @@
 		req_addr = ltmp->addr6;
 		if ((c = address6_available(state->context, &req_addr, solicit_tags, plain_range)))
 		  {
-#ifdef OPTION6_PREFIX_CLASS
-		    if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		      state->send_prefix_class = prefix_class_from_context(c);
-#endif
 		    add_address(state, c, c->lease_time, NULL, &min_time, &req_addr, now);
 		    mark_context_used(state, &req_addr);
 		    get_context_tag(state, c);
@@ -815,10 +736,6 @@
 	    while ((c = address6_allocate(state->context, state->clid, state->clid_len, state->ia_type == OPTION6_IA_TA,
 					  state->iaid, ia_counter, solicit_tags, plain_range, &addr)))
 	      {
-#ifdef OPTION6_PREFIX_CLASS
-		if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-		  state->send_prefix_class = prefix_class_from_context(c);
-#endif
 		add_address(state, c, c->lease_time, NULL, &min_time, &addr, now);
 		mark_context_used(state, &addr);
 		get_context_tag(state, c);
@@ -924,7 +841,6 @@
 		struct in6_addr req_addr;
 		struct dhcp_context *dynamic, *c;
 		unsigned int lease_time;
-		struct in6_addr addr;
 		int config_ok = 0;
 
 		/* align. */
@@ -931,7 +847,7 @@
 		memcpy(&req_addr, opt6_ptr(ia_option, 0), IN6ADDRSZ);
 		
 		if ((c = address6_valid(state->context, &req_addr, tagif, 1)))
-		  config_ok = config_valid(config, c, &addr) && IN6_ARE_ADDR_EQUAL(&addr, &req_addr);
+		  config_ok = (config_implies(config, c, &req_addr) != NULL);
 		
 		if ((dynamic = address6_available(state->context, &req_addr, tagif, 1)) || c)
 		  {
@@ -961,10 +877,6 @@
 			if (config_ok && have_config(config, CONFIG_TIME))
 			  lease_time = config->lease_time;
 
-#ifdef OPTION6_PREFIX_CLASS
-			if (dump_all_prefix_classes && state->ia_type == OPTION6_IA_NA)
-			  state->send_prefix_class = prefix_class_from_context(c);
-#endif
 			add_address(state, dynamic, lease_time, ia_option, &min_time, &req_addr, now);
 			get_context_tag(state, dynamic);
 			address_assigned = 1;
@@ -1061,12 +973,11 @@
 		if ((this_context = address6_available(state->context, &req_addr, tagif, 1)) ||
 		    (this_context = address6_valid(state->context, &req_addr, tagif, 1)))
 		  {
-		    struct in6_addr addr;
 		    unsigned int lease_time;
 
 		    get_context_tag(state, this_context);
 		    
-		    if (config_valid(config, this_context, &addr) && IN6_ARE_ADDR_EQUAL(&addr, &req_addr) && have_config(config, CONFIG_TIME))
+		    if (config_implies(config, this_context, &req_addr) && have_config(config, CONFIG_TIME))
 		      lease_time = config->lease_time;
 		    else 
 		      lease_time = this_context->lease_time;
@@ -1275,18 +1186,19 @@
 	      {
 		struct dhcp_lease *lease;
 		struct in6_addr addr;
-
+		struct addrlist *addr_list;
+		
 		/* align */
 		memcpy(&addr, opt6_ptr(ia_option, 0), IN6ADDRSZ);
 
-		if (have_config(config, CONFIG_ADDR6) && IN6_ARE_ADDR_EQUAL(&config->addr6, &addr))
+		if ((addr_list = config_implies(config, state->context, &addr)))
 		  {
 		    prettyprint_time(daemon->dhcp_buff3, DECLINE_BACKOFF);
 		    inet_ntop(AF_INET6, &addr, daemon->addrbuff, ADDRSTRLEN);
 		    my_syslog(MS_DHCP | LOG_WARNING, _("disabling DHCP static address %s for %s"), 
 			      daemon->addrbuff, daemon->dhcp_buff3);
-		    config->flags |= CONFIG_DECLINED;
-		    config->decline_time = now;
+		    addr_list->flags |= ADDRLIST_DECLINED;
+		    addr_list->decline_time = now;
 		  }
 		else
 		  /* make sure this host gets a different address next time. */
@@ -1399,23 +1311,39 @@
 	      	  
 	      for (a = (struct in6_addr *)opt_cfg->val, j = 0; j < opt_cfg->len; j+=IN6ADDRSZ, a++)
 		{
+		  struct in6_addr *p = NULL;
+
 		  if (IN6_IS_ADDR_UNSPECIFIED(a))
 		    {
 		      if (!add_local_addrs(state->context))
-			put_opt6(state->fallback, IN6ADDRSZ);
+			p = state->fallback;
 		    }
 		  else if (IN6_IS_ADDR_ULA_ZERO(a))
 		    {
 		      if (!IN6_IS_ADDR_UNSPECIFIED(state->ula_addr))
-			put_opt6(state->ula_addr, IN6ADDRSZ);
+			p = state->ula_addr;
 		    }
 		  else if (IN6_IS_ADDR_LINK_LOCAL_ZERO(a))
 		    {
 		      if (!IN6_IS_ADDR_UNSPECIFIED(state->ll_addr))
-			put_opt6(state->ll_addr, IN6ADDRSZ);
+			p = state->ll_addr;
 		    }
 		  else
-		    put_opt6(a, IN6ADDRSZ);
+		    p = a;
+
+		  if (!p)
+		    continue;
+		  else if (opt_cfg->opt == OPTION6_NTP_SERVER)
+		    {
+		      if (IN6_IS_ADDR_MULTICAST(p))
+			o1 = new_opt6(NTP_SUBOPTION_MC_ADDR);
+		      else
+			o1 = new_opt6(NTP_SUBOPTION_SRV_ADDR);
+		      put_opt6(p, IN6ADDRSZ);
+		      end_opt6(o1);
+		    }
+		  else
+		    put_opt6(p, IN6ADDRSZ);
 		}
 
 	      end_opt6(o);
@@ -1609,21 +1537,6 @@
     }
 } 
 
-#ifdef OPTION6_PREFIX_CLASS
-static struct prefix_class *prefix_class_from_context(struct dhcp_context *context)
-{
-  struct prefix_class *p;
-  struct dhcp_netid *t;
-  
-  for (p = daemon->prefix_classes; p ; p = p->next)
-    for (t = context->filter; t; t = t->next)
-      if (strcmp(p->tag.net, t->net) == 0)
-	return p;
-  
- return NULL;
-}
-#endif
-
 static int check_ia(struct state *state, void *opt, void **endp, void **ia_option)
 {
   state->ia_type = opt6_type(opt);
@@ -1708,16 +1621,6 @@
   put_opt6(addr, sizeof(*addr));
   put_opt6_long(preferred_time);
   put_opt6_long(valid_time); 		    
-  
-#ifdef OPTION6_PREFIX_CLASS
-  if (state->send_prefix_class)
-    {
-      int o1 = new_opt6(OPTION6_PREFIX_CLASS);
-      put_opt6_short(state->send_prefix_class->class);
-      end_opt6(o1);
-    }
-#endif
-
   end_opt6(o);
   
   if (state->lease_allocate)
@@ -1753,16 +1656,9 @@
   struct dhcp_context *context;
 
   /* Mark that we have an address for this prefix. */
-#ifdef OPTION6_PREFIX_CLASS
   for (context = state->context; context; context = context->current)
-    if (is_same_net6(addr, &context->start6, context->prefix) &&
-	(!state->send_prefix_class || state->send_prefix_class == prefix_class_from_context(context)))
-      context->flags |= CONTEXT_USED;
-#else
-  for (context = state->context; context; context = context->current)
     if (is_same_net6(addr, &context->start6, context->prefix))
       context->flags |= CONTEXT_USED;
-#endif
 }
 
 static void mark_config_used(struct dhcp_context *context, struct in6_addr *addr)
@@ -1789,6 +1685,78 @@
 }
 
 
+/* return true of *addr could have been generated from config. */
+static struct addrlist *config_implies(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr)
+{
+  int prefix;
+  struct in6_addr wild_addr;
+  struct addrlist *addr_list;
+  
+  if (!config || !(config->flags & CONFIG_ADDR6))
+    return NULL;
+  
+  for (addr_list = config->addr6; addr_list; addr_list = addr_list->next)
+    {
+      prefix = (addr_list->flags & ADDRLIST_PREFIX) ? addr_list->prefixlen : 128;
+      wild_addr = addr_list->addr.addr6;
+      
+      if ((addr_list->flags & ADDRLIST_WILDCARD) && context->prefix == 64)
+	{
+	  wild_addr = context->start6;
+	  setaddr6part(&wild_addr, addr6part(&addr_list->addr.addr6));
+	}
+      else if (!is_same_net6(&context->start6, addr, context->prefix))
+	continue;
+      
+      if (is_same_net6(&wild_addr, addr, prefix))
+	return addr_list;
+    }
+  
+  return NULL;
+}
+
+static int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr, struct state *state, time_t now)
+{
+  u64 addrpart, i, addresses;
+  struct addrlist *addr_list;
+  
+  if (!config || !(config->flags & CONFIG_ADDR6))
+    return 0;
+
+  for (addr_list = config->addr6; addr_list; addr_list = addr_list->next)
+    if (!(addr_list->flags & ADDRLIST_DECLINED) ||
+	difftime(now, addr_list->decline_time) >= (float)DECLINE_BACKOFF)
+      {
+	addrpart = addr6part(&addr_list->addr.addr6);
+	addresses = 1;
+	
+	if (addr_list->flags & ADDRLIST_PREFIX)
+	  addresses = (u64)1<<(128-addr_list->prefixlen);
+	
+	if ((addr_list->flags & ADDRLIST_WILDCARD))
+	  {
+	    if (context->prefix != 64)
+	      continue;
+	    
+	    *addr = context->start6;
+	  }
+	else if (is_same_net6(&context->start6, &addr_list->addr.addr6, context->prefix))
+	  *addr = addr_list->addr.addr6;
+	else
+	  continue;
+	
+	for (i = 0 ; i < addresses; i++)
+	  {
+	    setaddr6part(addr, addrpart+i);
+	    
+	    if (check_address(state, addr))
+	      return 1;
+	  }
+      }
+  
+  return 0;
+}
+
 /* Calculate valid and preferred times to send in leases/renewals. 
 
    Inputs are:
@@ -1989,13 +1957,6 @@
 	  optname = "iaaddr";
 	  ia_options = opt6_ptr(opt, 24);
 	}
-#ifdef OPTION6_PREFIX_CLASS
-      else if (type == OPTION6_PREFIX_CLASS)
-	{
-	  optname = "prefix-class";
-	  sprintf(daemon->namebuff, "class=%u", opt6_uint(opt, 0, 2));
-	}
-#endif
       else if (type == OPTION6_STATUS_CODE)
 	{
 	  int len = sprintf(daemon->namebuff, "%u ", opt6_uint(opt, 0, 2));
@@ -2120,7 +2081,7 @@
 {
   /* ->local is same value for all relays on ->current chain */
   
-  struct all_addr from;
+  union all_addr from;
   unsigned char *header;
   unsigned char *inbuff = daemon->dhcp_packet.iov_base;
   int msg_type = *inbuff;
@@ -2133,7 +2094,7 @@
   get_client_mac(peer_address, scope_id, mac, &maclen, &mactype, now);
 
   /* source address == relay address */
-  from.addr.addr6 = relay->local.addr.addr6;
+  from.addr6 = relay->local.addr6;
     
   /* Get hop count from nested relayed message */ 
   if (msg_type == DHCP6RELAYFORW)
@@ -2153,7 +2114,7 @@
 
       header[0] = DHCP6RELAYFORW;
       header[1] = hopcount;
-      memcpy(&header[2],  &relay->local.addr.addr6, IN6ADDRSZ);
+      memcpy(&header[2],  &relay->local.addr6, IN6ADDRSZ);
       memcpy(&header[18], peer_address, IN6ADDRSZ);
  
       /* RFC-6939 */
@@ -2174,12 +2135,12 @@
 	  union mysockaddr to;
 	  
 	  to.sa.sa_family = AF_INET6;
-	  to.in6.sin6_addr = relay->server.addr.addr6;
+	  to.in6.sin6_addr = relay->server.addr6;
 	  to.in6.sin6_port = htons(DHCPV6_SERVER_PORT);
 	  to.in6.sin6_flowinfo = 0;
 	  to.in6.sin6_scope_id = 0;
 
-	  if (IN6_ARE_ADDR_EQUAL(&relay->server.addr.addr6, &multicast))
+	  if (IN6_ARE_ADDR_EQUAL(&relay->server.addr6, &multicast))
 	    {
 	      int multicast_iface;
 	      if (!relay->interface || strchr(relay->interface, '*') ||
@@ -2218,7 +2179,7 @@
   memcpy(&link, &inbuff[2], IN6ADDRSZ); 
   
   for (relay = daemon->relay6; relay; relay = relay->next)
-    if (IN6_ARE_ADDR_EQUAL(&link, &relay->local.addr.addr6) &&
+    if (IN6_ARE_ADDR_EQUAL(&link, &relay->local.addr6) &&
 	(!relay->interface || wildcard_match(relay->interface, arrival_interface)))
       break;
       
Index: src/slaac.c
===================================================================
--- src/slaac.c	(revision 41436)
+++ src/slaac.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/metrics.c
===================================================================
--- src/metrics.c	(revision 41436)
+++ src/metrics.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/metrics.h
===================================================================
--- src/metrics.h	(revision 41436)
+++ src/metrics.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/ubus.c
===================================================================
--- src/ubus.c	(revision 41436)
+++ src/ubus.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,17 +20,22 @@
 
 #include <libubus.h>
 
-static struct ubus_context *ubus = NULL;
 static struct blob_buf b;
+static int notify;
+static int error_logged = 0;
 
 static int ubus_handle_metrics(struct ubus_context *ctx, struct ubus_object *obj,
 			       struct ubus_request_data *req, const char *method,
 			       struct blob_attr *msg);
-static struct ubus_method ubus_object_methods[] = {
-  {.name = "metrics", .handler = ubus_handle_metrics},
+
+static void ubus_subscribe_cb(struct ubus_context *ctx, struct ubus_object *obj);
+
+static const struct ubus_method ubus_object_methods[] = {
+  UBUS_METHOD_NOARG("metrics", ubus_handle_metrics),
 };
 
-static struct ubus_object_type ubus_object_type = UBUS_OBJECT_TYPE("dnsmasq", ubus_object_methods);
+static struct ubus_object_type ubus_object_type =
+  UBUS_OBJECT_TYPE("dnsmasq", ubus_object_methods);
 
 static struct ubus_object ubus_object = {
   .name = "dnsmasq",
@@ -37,13 +42,91 @@
   .type = &ubus_object_type,
   .methods = ubus_object_methods,
   .n_methods = ARRAY_SIZE(ubus_object_methods),
+  .subscribe_cb = ubus_subscribe_cb,
 };
 
+static void ubus_subscribe_cb(struct ubus_context *ctx, struct ubus_object *obj)
+{
+  (void)ctx;
+
+  my_syslog(LOG_DEBUG, _("UBus subscription callback: %s subscriber(s)"), obj->has_subscribers ? "1" : "0");
+  notify = obj->has_subscribers;
+}
+
+static void ubus_destroy(struct ubus_context *ubus)
+{
+  // Forces re-initialization when we're reusing the same definitions later on.
+  ubus_object.id = 0;
+  ubus_object_type.id = 0;
+
+  ubus_free(ubus);
+  daemon->ubus = NULL;
+}
+
+static void ubus_disconnect_cb(struct ubus_context *ubus)
+{
+  int ret;
+
+  ret = ubus_reconnect(ubus, NULL);
+  if (ret)
+    {
+      my_syslog(LOG_ERR, _("Cannot reconnect to UBus: %s"), ubus_strerror(ret));
+
+      ubus_destroy(ubus);
+    }
+}
+
+void ubus_init()
+{
+  struct ubus_context *ubus = NULL;
+  int ret = 0;
+
+  ubus = ubus_connect(NULL);
+  if (!ubus)
+    {
+      if (!error_logged)
+        {
+          my_syslog(LOG_ERR, _("Cannot initialize UBus: connection failed"));
+          error_logged = 1;
+        }
+
+      ubus_destroy(ubus);
+      return;
+    }
+
+  ret = ubus_add_object(ubus, &ubus_object);
+  if (ret)
+    {
+      if (!error_logged)
+        {
+          my_syslog(LOG_ERR, _("Cannot add object to UBus: %s"), ubus_strerror(ret));
+          error_logged = 1;
+        }
+      return;
+    }
+
+  ubus->connection_lost = ubus_disconnect_cb;
+  daemon->ubus = ubus;
+  error_logged = 0;
+
+  my_syslog(LOG_INFO, _("Connected to system UBus"));
+}
+
 void set_ubus_listeners()
 {
+  struct ubus_context *ubus = (struct ubus_context *)daemon->ubus;
   if (!ubus)
-    return;
+    {
+      if (!error_logged)
+        {
+          my_syslog(LOG_ERR, _("Cannot set UBus listeners: no connection"));
+          error_logged = 1;
+        }
+      return;
+    }
 
+  error_logged = 0;
+
   poll_listen(ubus->sock.fd, POLLIN);
   poll_listen(ubus->sock.fd, POLLERR);
   poll_listen(ubus->sock.fd, POLLHUP);
@@ -51,46 +134,57 @@
 
 void check_ubus_listeners()
 {
+  struct ubus_context *ubus = (struct ubus_context *)daemon->ubus;
   if (!ubus)
     {
-      ubus = ubus_connect(NULL);
-      if (!ubus)
-	return;
-      ubus_add_object(ubus, &ubus_object);
+      if (!error_logged)
+        {
+          my_syslog(LOG_ERR, _("Cannot poll UBus listeners: no connection"));
+          error_logged = 1;
+        }
+      return;
     }
   
+  error_logged = 0;
+
   if (poll_check(ubus->sock.fd, POLLIN))
     ubus_handle_event(ubus);
   
-  if (poll_check(ubus->sock.fd, POLLHUP))
+  if (poll_check(ubus->sock.fd, POLLHUP | POLLERR))
     {
-      ubus_free(ubus);
-      ubus = NULL;
+      my_syslog(LOG_INFO, _("Disconnecting from UBus"));
+
+      ubus_destroy(ubus);
     }
 }
 
-
 static int ubus_handle_metrics(struct ubus_context *ctx, struct ubus_object *obj,
 			       struct ubus_request_data *req, const char *method,
 			       struct blob_attr *msg)
 {
   int i;
-  blob_buf_init(&b, 0);
 
-  for(i=0; i < __METRIC_MAX; i++)
+  (void)obj;
+  (void)method;
+  (void)msg;
+
+  blob_buf_init(&b, BLOBMSG_TYPE_TABLE);
+
+  for (i=0; i < __METRIC_MAX; i++)
     blobmsg_add_u32(&b, get_metric_name(i), daemon->metrics[i]);
   
-  ubus_send_reply(ctx, req, b.head);
-  
-  return 0;
+  return ubus_send_reply(ctx, req, b.head);
 }
 
 void ubus_event_bcast(const char *type, const char *mac, const char *ip, const char *name, const char *interface)
 {
-  if (!ubus || !ubus_object.has_subscribers)
+  struct ubus_context *ubus = (struct ubus_context *)daemon->ubus;
+  int ret;
+
+  if (!ubus || !notify)
     return;
 
-  blob_buf_init(&b, 0);
+  blob_buf_init(&b, BLOBMSG_TYPE_TABLE);
   if (mac)
     blobmsg_add_string(&b, "mac", mac);
   if (ip)
@@ -100,7 +194,9 @@
   if (interface)
     blobmsg_add_string(&b, "interface", interface);
   
-  ubus_notify(ubus, &ubus_object, type, b.head, -1);
+  ret = ubus_notify(ubus, &ubus_object, type, b.head, -1);
+  if (!ret)
+    my_syslog(LOG_ERR, _("Failed to send UBus event: %s"), ubus_strerror(ret));
 }
 
 
Index: src/auth.c
===================================================================
--- src/auth.c	(revision 41436)
+++ src/auth.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -18,12 +18,12 @@
 
 #ifdef HAVE_AUTH
 
-static struct addrlist *find_addrlist(struct addrlist *list, int flag, struct all_addr *addr_u)
+static struct addrlist *find_addrlist(struct addrlist *list, int flag, union all_addr *addr_u)
 {
   do {
     if (!(list->flags & ADDRLIST_IPV6))
       {
-	struct in_addr netmask, addr = addr_u->addr.addr4;
+	struct in_addr netmask, addr = addr_u->addr4;
 	
 	if (!(flag & F_IPV4))
 	  continue;
@@ -30,13 +30,11 @@
 	
 	netmask.s_addr = htonl(~(in_addr_t)0 << (32 - list->prefixlen));
 	
-	if  (is_same_net(addr, list->addr.addr.addr4, netmask))
+	if  (is_same_net(addr, list->addr.addr4, netmask))
 	  return list;
       }
-#ifdef HAVE_IPV6
-    else if (is_same_net6(&(addr_u->addr.addr6), &list->addr.addr.addr6, list->prefixlen))
+    else if (is_same_net6(&(addr_u->addr6), &list->addr.addr6, list->prefixlen))
       return list;
-#endif
     
   } while ((list = list->next));
   
@@ -43,7 +41,7 @@
   return NULL;
 }
 
-static struct addrlist *find_subnet(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static struct addrlist *find_subnet(struct auth_zone *zone, int flag, union all_addr *addr_u)
 {
   if (!zone->subnet)
     return NULL;
@@ -51,7 +49,7 @@
   return find_addrlist(zone->subnet, flag, addr_u);
 }
 
-static struct addrlist *find_exclude(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static struct addrlist *find_exclude(struct auth_zone *zone, int flag, union all_addr *addr_u)
 {
   if (!zone->exclude)
     return NULL;
@@ -59,7 +57,7 @@
   return find_addrlist(zone->exclude, flag, addr_u);
 }
 
-static int filter_zone(struct auth_zone *zone, int flag, struct all_addr *addr_u)
+static int filter_zone(struct auth_zone *zone, int flag, union all_addr *addr_u)
 {
   if (find_exclude(zone, flag, addr_u))
     return 0;
@@ -115,7 +113,7 @@
   struct txt_record *txt;
   struct interface_name *intr;
   struct naptr *na;
-  struct all_addr addr;
+  union all_addr addr;
   struct cname *a, *candidate;
   unsigned int wclen;
   
@@ -131,7 +129,7 @@
 
   for (q = ntohs(header->qdcount); q != 0; q--)
     {
-      unsigned short flag = 0;
+      unsigned int flag = 0;
       int found = 0;
       int cname_wildcard = 0;
   
@@ -180,7 +178,7 @@
 		struct addrlist *addrlist;
 		
 		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		  if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr.addr4.s_addr == addrlist->addr.addr.addr4.s_addr)
+		  if (!(addrlist->flags & ADDRLIST_IPV6) && addr.addr4.s_addr == addrlist->addr.addr4.s_addr)
 		    break;
 		
 		if (addrlist)
@@ -189,7 +187,6 @@
 		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 		    intr = intr->next;
 	      }
-#ifdef HAVE_IPV6
 	  else if (flag == F_IPV6)
 	    for (intr = daemon->int_names; intr; intr = intr->next)
 	      {
@@ -196,7 +193,7 @@
 		struct addrlist *addrlist;
 		
 		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next)
-		  if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr.addr6, &addrlist->addr.addr.addr6))
+		  if ((addrlist->flags & ADDRLIST_IPV6) && IN6_ARE_ADDR_EQUAL(&addr.addr6, &addrlist->addr.addr6))
 		    break;
 		
 		if (addrlist)
@@ -205,7 +202,6 @@
 		  while (intr->next && strcmp(intr->intr, intr->next->intr) == 0)
 		    intr = intr->next;
 	      }
-#endif
 	  
 	  if (intr)
 	    {
@@ -378,10 +374,8 @@
        if (qtype == T_A)
 	 flag = F_IPV4;
        
-#ifdef HAVE_IPV6
        if (qtype == T_AAAA)
 	 flag = F_IPV6;
-#endif
        
        for (intr = daemon->int_names; intr; intr = intr->next)
 	 if ((rc = hostname_issubdomain(name, intr->name)))
@@ -395,10 +389,9 @@
 		 if (((addrlist->flags & ADDRLIST_IPV6)  ? T_AAAA : T_A) == qtype &&
 		     (local_query || filter_zone(zone, flag, &addrlist->addr)))
 		   {
-#ifdef HAVE_IPV6
 		     if (addrlist->flags & ADDRLIST_REVONLY)
 		       continue;
-#endif
+
 		     found = 1;
 		     log_query(F_FORWARD | F_CONFIG | flag, name, &addrlist->addr, NULL);
 		     if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
@@ -424,13 +417,11 @@
 	      
 	      if (peer_addr->sa.sa_family == AF_INET)
 		peer_addr->in.sin_port = 0;
-#ifdef HAVE_IPV6
 	      else
 		{
 		  peer_addr->in6.sin6_port = 0; 
 		  peer_addr->in6.sin6_scope_id = 0;
 		}
-#endif
 	      
 	      for (peers = daemon->auth_peers; peers; peers = peers->next)
 		if (sockaddr_isequal(peer_addr, &peers->addr))
@@ -442,10 +433,8 @@
 		{
 		  if (peer_addr->sa.sa_family == AF_INET)
 		    inet_ntop(AF_INET, &peer_addr->in.sin_addr, daemon->addrbuff, ADDRSTRLEN);
-#ifdef HAVE_IPV6
 		  else
 		    inet_ntop(AF_INET6, &peer_addr->in6.sin6_addr, daemon->addrbuff, ADDRSTRLEN); 
-#endif
 		  
 		  my_syslog(LOG_WARNING, _("ignoring zone transfer request from %s"), daemon->addrbuff);
 		  return 0;
@@ -479,10 +468,10 @@
 		  { 
 		    nxdomain = 0;
 		    if ((crecp->flags & flag) && 
-			(local_query || filter_zone(zone, flag, &(crecp->addr.addr))))
+			(local_query || filter_zone(zone, flag, &(crecp->addr))))
 		      {
 			*cut = '.'; /* restore domain part */
-			log_query(crecp->flags, name, &crecp->addr.addr, record_source(crecp->uid));
+			log_query(crecp->flags, name, &crecp->addr, record_source(crecp->uid));
 			*cut  = 0; /* remove domain part */
 			found = 1;
 			if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
@@ -502,9 +491,9 @@
 	    do
 	      { 
 		 nxdomain = 0;
-		 if ((crecp->flags & flag) && (local_query || filter_zone(zone, flag, &(crecp->addr.addr))))
+		 if ((crecp->flags & flag) && (local_query || filter_zone(zone, flag, &(crecp->addr))))
 		   {
-		     log_query(crecp->flags, name, &crecp->addr.addr, record_source(crecp->uid));
+		     log_query(crecp->flags, name, &crecp->addr, record_source(crecp->uid));
 		     found = 1;
 		     if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
 					     daemon->auth_ttl, NULL, qtype, C_IN, 
@@ -591,7 +580,7 @@
 
 	  if (!(subnet->flags & ADDRLIST_IPV6))
 	    {
-	      in_addr_t a = ntohl(subnet->addr.addr.addr4.s_addr) >> 8;
+	      in_addr_t a = ntohl(subnet->addr.addr4.s_addr) >> 8;
 	      char *p = name;
 	      
 	      if (subnet->prefixlen >= 24)
@@ -603,7 +592,6 @@
 	      p += sprintf(p, "%u.in-addr.arpa", a & 0xff);
 	      
 	    }
-#ifdef HAVE_IPV6
 	  else
 	    {
 	      char *p = name;
@@ -611,13 +599,12 @@
 	      
 	      for (i = subnet->prefixlen-1; i >= 0; i -= 4)
 		{ 
-		  int dig = ((unsigned char *)&subnet->addr.addr.addr6)[i>>3];
+		  int dig = ((unsigned char *)&subnet->addr.addr6)[i>>3];
 		  p += sprintf(p, "%.1x.", (i>>2) & 1 ? dig & 15 : dig >> 4);
 		}
 	      p += sprintf(p, "ip6.arpa");
 	      
 	    }
-#endif
 	}
       
       /* handle NS and SOA in auth section or for explicit queries */
@@ -754,7 +741,6 @@
 					  daemon->auth_ttl, NULL, T_A, C_IN, "4", cut ? intr->name : NULL, &addrlist->addr))
 		    anscount++;
 		
-#ifdef HAVE_IPV6
 		for (addrlist = intr->addr; addrlist; addrlist = addrlist->next) 
 		  if ((addrlist->flags & ADDRLIST_IPV6) && 
 		      (local_query || filter_zone(zone, F_IPV6, &addrlist->addr)) &&
@@ -761,7 +747,6 @@
 		      add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
 					  daemon->auth_ttl, NULL, T_AAAA, C_IN, "6", cut ? intr->name : NULL, &addrlist->addr))
 		    anscount++;
-#endif		    
 		
 		/* restore config data */
 		if (cut)
@@ -798,18 +783,11 @@
 		    {
 		      char *cache_name = cache_get_name(crecp);
 		      if (!strchr(cache_name, '.') && 
-			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr.addr))))
-			{
-			  qtype = T_A;
-#ifdef HAVE_IPV6
-			  if (crecp->flags & F_IPV6)
-			    qtype = T_AAAA;
-#endif
-			  if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-						  daemon->auth_ttl, NULL, qtype, C_IN, 
-						  (crecp->flags & F_IPV4) ? "4" : "6", cache_name, &crecp->addr))
-			    anscount++;
-			}
+			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr))) &&
+			  add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
+					      daemon->auth_ttl, NULL, (crecp->flags & F_IPV6) ? T_AAAA : T_A, C_IN, 
+					      (crecp->flags & F_IPV4) ? "4" : "6", cache_name, &crecp->addr))
+			anscount++;
 		    }
 		  
 		  if ((crecp->flags & F_HOSTS) || (((crecp->flags & F_DHCP) && option_bool(OPT_DHCP_FQDN))))
@@ -816,20 +794,15 @@
 		    {
 		      strcpy(name, cache_get_name(crecp));
 		      if (in_zone(zone, name, &cut) && 
-			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr.addr))))
+			  (local_query || filter_zone(zone, (crecp->flags & (F_IPV6 | F_IPV4)), &(crecp->addr))))
 			{
-			  qtype = T_A;
-#ifdef HAVE_IPV6
-			  if (crecp->flags & F_IPV6)
-			    qtype = T_AAAA;
-#endif
-			   if (cut)
-			     *cut = 0;
+			  if (cut)
+			    *cut = 0;
 
-			   if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
-						   daemon->auth_ttl, NULL, qtype, C_IN, 
-						   (crecp->flags & F_IPV4) ? "4" : "6", cut ? name : NULL, &crecp->addr))
-			     anscount++;
+			  if (add_resource_record(header, limit, &trunc, -axfroffset, &ansp, 
+						  daemon->auth_ttl, NULL, (crecp->flags & F_IPV6) ? T_AAAA : T_A, C_IN, 
+						  (crecp->flags & F_IPV4) ? "4" : "6", cut ? name : NULL, &crecp->addr))
+			    anscount++;
 			}
 		    }
 		}
@@ -863,6 +836,9 @@
       header->hb4 &= ~HB4_RA;
     }
 
+  /* data is never DNSSEC signed. */
+  header->hb4 &= ~HB4_AD;
+
   /* authoritative */
   if (auth)
     header->hb3 |= HB3_AA;
Index: src/bpf.c
===================================================================
--- src/bpf.c	(revision 41436)
+++ src/bpf.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -31,9 +31,7 @@
 #  include <net/if_var.h> 
 #endif
 #include <netinet/in_var.h>
-#ifdef HAVE_IPV6
-#  include <netinet6/in6_var.h>
-#endif
+#include <netinet6/in6_var.h>
 
 #ifndef SA_SIZE
 #define SA_SIZE(sa)                                             \
@@ -44,7 +42,7 @@
 
 #ifdef HAVE_BSD_NETWORK
 static int del_family = 0;
-static struct all_addr del_addr;
+static union all_addr del_addr;
 #endif
 
 #if defined(HAVE_BSD_NETWORK) && !defined(__APPLE__)
@@ -121,7 +119,7 @@
   if (getifaddrs(&head) == -1)
     return 0;
 
-#if defined(HAVE_BSD_NETWORK) && defined(HAVE_IPV6)
+#if defined(HAVE_BSD_NETWORK)
   if (family == AF_INET6)
     fd = socket(PF_INET6, SOCK_DGRAM, 0);
 #endif
@@ -141,7 +139,7 @@
 	      struct in_addr addr, netmask, broadcast;
 	      addr = ((struct sockaddr_in *) addrs->ifa_addr)->sin_addr;
 #ifdef HAVE_BSD_NETWORK
-	      if (del_family == AF_INET && del_addr.addr.addr4.s_addr == addr.s_addr)
+	      if (del_family == AF_INET && del_addr.addr4.s_addr == addr.s_addr)
 		continue;
 #endif
 	      netmask = ((struct sockaddr_in *) addrs->ifa_netmask)->sin_addr;
@@ -152,7 +150,6 @@
 	      if (!((*callback)(addr, iface_index, NULL, netmask, broadcast, parm)))
 		goto err;
 	    }
-#ifdef HAVE_IPV6
 	  else if (family == AF_INET6)
 	    {
 	      struct in6_addr *addr = &((struct sockaddr_in6 *) addrs->ifa_addr)->sin6_addr;
@@ -162,7 +159,7 @@
 	      u32 valid = 0xffffffff, preferred = 0xffffffff;
 	      int flags = 0;
 #ifdef HAVE_BSD_NETWORK
-	      if (del_family == AF_INET6 && IN6_ARE_ADDR_EQUAL(&del_addr.addr.addr6, addr))
+	      if (del_family == AF_INET6 && IN6_ARE_ADDR_EQUAL(&del_addr.addr6, addr))
 		continue;
 #endif
 #if defined(HAVE_BSD_NETWORK) && !defined(__APPLE__)
@@ -219,7 +216,6 @@
 				(int) preferred, (int)valid, parm)))
 		goto err;	      
 	    }
-#endif /* HAVE_IPV6 */
 
 #ifdef HAVE_DHCP6      
 	  else if (family == AF_LINK)
@@ -426,11 +422,9 @@
 	       {
 		 del_family = sa->sa_family;
 		 if (del_family == AF_INET)
-		   del_addr.addr.addr4 = ((struct sockaddr_in *)sa)->sin_addr;
-#ifdef HAVE_IPV6
+		   del_addr.addr4 = ((struct sockaddr_in *)sa)->sin_addr;
 		 else if (del_family == AF_INET6)
-		   del_addr.addr.addr6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
-#endif
+		   del_addr.addr6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
 		 else
 		   del_family = 0;
 	       }
Index: src/config.h
===================================================================
--- src/config.h	(revision 41436)
+++ src/config.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -131,7 +131,6 @@
 
 NO_ID
    Don't report *.bind CHAOS info to clients, forward such requests upstream instead.
-NO_IPV6
 NO_TFTP
 NO_DHCP
 NO_DHCP6
@@ -141,8 +140,8 @@
 NO_DUMPFILE
 NO_INOTIFY
    these are avilable to explicitly disable compile time options which would 
-   otherwise be enabled automatically (HAVE_IPV6, >2Gb file sizes) or 
-   which are enabled  by default in the distributed source tree. Building dnsmasq
+   otherwise be enabled automatically or which are enabled  by default 
+   in the distributed source tree. Building dnsmasq
    with something like "make COPTS=-DNO_SCRIPT" will do the trick.
 NO_GMP
    Don't use and link against libgmp, Useful if nettle is built with --enable-mini-gmp.
@@ -248,27 +247,13 @@
    defined if struct sockaddr has sa_len field (*BSD) 
 */
 
-/* Must precede __linux__ since uClinux defines __linux__ too. */
-#if defined(__uClinux__)
+#if defined(__UCLIBC__)
 #define HAVE_LINUX_NETWORK
-#define HAVE_GETOPT_LONG
-#undef HAVE_SOCKADDR_SA_LEN
-/* Never use fork() on uClinux. Note that this is subtly different from the
-   --keep-in-foreground option, since it also  suppresses forking new 
-   processes for TCP connections and disables the call-a-script on leasechange
-   system. It's intended for use on MMU-less kernels. */
-#define NO_FORK
-
-#elif defined(__UCLIBC__)
-#define HAVE_LINUX_NETWORK
 #if defined(__UCLIBC_HAS_GNU_GETOPT__) || \
    ((__UCLIBC_MAJOR__==0) && (__UCLIBC_MINOR__==9) && (__UCLIBC_SUBLEVEL__<21))
 #    define HAVE_GETOPT_LONG
 #endif
 #undef HAVE_SOCKADDR_SA_LEN
-#if !defined(__ARCH_HAS_MMU__) && !defined(__UCLIBC_HAS_MMU__)
-#  define NO_FORK
-#endif
 #if defined(__UCLIBC_HAS_IPV6__)
 #  ifndef IPV6_V6ONLY
 #    define IPV6_V6ONLY 26
@@ -296,11 +281,16 @@
 #define HAVE_BSD_NETWORK
 #define HAVE_GETOPT_LONG
 #define HAVE_SOCKADDR_SA_LEN
+#define NO_IPSET
 /* Define before sys/socket.h is included so we get socklen_t */
 #define _BSD_SOCKLEN_T_
 /* Select the RFC_3542 version of the IPv6 socket API. 
    Define before netinet6/in6.h is included. */
-#define __APPLE_USE_RFC_3542 
+#define __APPLE_USE_RFC_3542
+/* Required for Mojave. */
+#ifndef SOL_TCP
+#  define SOL_TCP IPPROTO_TCP
+#endif
 #define NO_IPSET
 
 #elif defined(__NetBSD__)
@@ -316,29 +306,9 @@
  
 #endif
 
-/* Decide if we're going to support IPv6 */
-/* We assume that systems which don't have IPv6
-   headers don't have ntop and pton either */
-
-#if defined(INET6_ADDRSTRLEN) && defined(IPV6_V6ONLY)
-#  define HAVE_IPV6
-#  define ADDRSTRLEN INET6_ADDRSTRLEN
-#else
-#  if !defined(INET_ADDRSTRLEN)
-#      define INET_ADDRSTRLEN 16 /* 4*3 + 3 dots + NULL */
-#  endif
-#  undef HAVE_IPV6
-#  define ADDRSTRLEN INET_ADDRSTRLEN
-#endif
-
-
 /* rules to implement compile-time option dependencies and 
    the NO_XXX flags */
 
-#ifdef NO_IPV6
-#undef HAVE_IPV6
-#endif
-
 #ifdef NO_TFTP
 #undef HAVE_TFTP
 #endif
@@ -348,7 +318,7 @@
 #undef HAVE_DHCP6
 #endif
 
-#if defined(NO_DHCP6) || !defined(HAVE_IPV6)
+#if defined(NO_DHCP6)
 #undef HAVE_DHCP6
 #endif
 
@@ -357,7 +327,7 @@
 #define HAVE_DHCP
 #endif
 
-#if defined(NO_SCRIPT) || defined(NO_FORK)
+#if defined(NO_SCRIPT)
 #undef HAVE_SCRIPT
 #undef HAVE_LUASCRIPT
 #endif
@@ -389,9 +359,6 @@
 #ifdef DNSMASQ_COMPILE_OPTS
 
 static char *compile_opts = 
-#ifndef HAVE_IPV6
-"no-"
-#endif
 "IPv6 "
 #ifndef HAVE_GETOPT_LONG
 "no-"
@@ -400,13 +367,14 @@
 #ifdef HAVE_BROKEN_RTC
 "no-RTC "
 #endif
-#ifdef NO_FORK
-"no-MMU "
-#endif
 #ifndef HAVE_DBUS
 "no-"
 #endif
 "DBus "
+#ifndef HAVE_UBUS
+"no-"
+#endif
+"UBus "
 #ifndef LOCALEDIR
 "no-"
 #endif
Index: src/dbus.c
===================================================================
--- src/dbus.c	(revision 41436)
+++ src/dbus.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -185,9 +185,6 @@
 		}
 	    }
 
-#ifndef HAVE_IPV6
-	  my_syslog(LOG_WARNING, _("attempt to set an IPv6 server address via DBus - no IPv6 support"));
-#else
 	  if (i == sizeof(struct in6_addr))
 	    {
 	      memcpy(&addr.in6.sin6_addr, p, sizeof(struct in6_addr));
@@ -202,7 +199,6 @@
               source_addr.in6.sin6_port = htons(daemon->query_port);
 	      skip = 0;
 	    }
-#endif
 	}
       else
 	/* At the end */
@@ -460,7 +456,7 @@
   int clid_len, hostname_len, hw_len, hw_type;
   dbus_uint32_t expires, ia_id;
   dbus_bool_t is_temporary;
-  struct all_addr addr;
+  union all_addr addr;
   time_t now = dnsmasq_time();
   unsigned char dhcp_chaddr[DHCP_CHADDR_MAX];
 
@@ -530,20 +526,20 @@
 
   dbus_message_iter_get_basic(&iter, &is_temporary);
 
-  if (inet_pton(AF_INET, ipaddr, &addr.addr.addr4))
+  if (inet_pton(AF_INET, ipaddr, &addr.addr4))
     {
       if (ia_id != 0 || is_temporary)
 	return dbus_message_new_error(message, DBUS_ERROR_INVALID_ARGS,
 				      "ia_id and is_temporary must be zero for IPv4 lease");
       
-      if (!(lease = lease_find_by_addr(addr.addr.addr4)))
-    	lease = lease4_allocate(addr.addr.addr4);
+      if (!(lease = lease_find_by_addr(addr.addr4)))
+    	lease = lease4_allocate(addr.addr4);
     }
 #ifdef HAVE_DHCP6
-  else if (inet_pton(AF_INET6, ipaddr, &addr.addr.addr6))
+  else if (inet_pton(AF_INET6, ipaddr, &addr.addr6))
     {
-      if (!(lease = lease6_find_by_addr(&addr.addr.addr6, 128, 0)))
-	lease = lease6_allocate(&addr.addr.addr6,
+      if (!(lease = lease6_find_by_addr(&addr.addr6, 128, 0)))
+	lease = lease6_allocate(&addr.addr6,
 				is_temporary ? LEASE_TA : LEASE_NA);
       lease_set_iaid(lease, ia_id);
     }
@@ -574,7 +570,7 @@
   DBusMessageIter iter;
   const char *ipaddr;
   DBusMessage *reply;
-  struct all_addr addr;
+  union all_addr addr;
   dbus_bool_t ret = 1;
   time_t now = dnsmasq_time();
 
@@ -588,11 +584,11 @@
    
   dbus_message_iter_get_basic(&iter, &ipaddr);
 
-  if (inet_pton(AF_INET, ipaddr, &addr.addr.addr4))
-    lease = lease_find_by_addr(addr.addr.addr4);
+  if (inet_pton(AF_INET, ipaddr, &addr.addr4))
+    lease = lease_find_by_addr(addr.addr4);
 #ifdef HAVE_DHCP6
-  else if (inet_pton(AF_INET6, ipaddr, &addr.addr.addr6))
-    lease = lease6_find_by_addr(&addr.addr.addr6, 128, 0);
+  else if (inet_pton(AF_INET6, ipaddr, &addr.addr6))
+    lease = lease6_find_by_addr(&addr.addr6, 128, 0);
 #endif
   else
     return dbus_message_new_error_printf(message, DBUS_ERROR_INVALID_ARGS,
Index: src/dhcp-common.c
===================================================================
--- src/dhcp-common.c	(revision 41436)
+++ src/dhcp-common.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -271,35 +271,45 @@
 {
   if (!context) /* called via find_config() from lease_update_from_configs() */
     return 1; 
-
-  if (!(config->flags & (CONFIG_ADDR | CONFIG_ADDR6)))
-    return 1;
   
 #ifdef HAVE_DHCP6
-  if ((context->flags & CONTEXT_V6) && (config->flags & CONFIG_WILDCARD))
-    return 1;
-#endif
+  if (context->flags & CONTEXT_V6)
+    {
+       struct addrlist *addr_list;
 
-  for (; context; context = context->current)
-#ifdef HAVE_DHCP6
-    if (context->flags & CONTEXT_V6) 
-      {
-	if ((config->flags & CONFIG_ADDR6) && is_same_net6(&config->addr6, &context->start6, context->prefix))
-	  return 1;
-      }
-    else 
+       if (!(config->flags & CONFIG_ADDR6))
+	 return 1;
+       
+        for (; context; context = context->current)
+	  for (addr_list = config->addr6; addr_list; addr_list = addr_list->next)
+	    {
+	      if ((addr_list->flags & ADDRLIST_WILDCARD) && context->prefix == 64)
+		return 1;
+	      
+	      if (is_same_net6(&addr_list->addr.addr6, &context->start6, context->prefix))
+		return 1;
+	    }
+    }
+  else
 #endif
-      if ((config->flags & CONFIG_ADDR) && is_same_net(config->addr, context->start, context->netmask))
+    {
+      if (!(config->flags & CONFIG_ADDR))
 	return 1;
+      
+      for (; context; context = context->current)
+	if ((config->flags & CONFIG_ADDR) && is_same_net(config->addr, context->start, context->netmask))
+	  return 1;
+    }
 
   return 0;
 }
 
-struct dhcp_config *find_config(struct dhcp_config *configs,
-				struct dhcp_context *context,
-				unsigned char *clid, int clid_len,
-				unsigned char *hwaddr, int hw_len, 
-				int hw_type, char *hostname)
+static struct dhcp_config *find_config_match(struct dhcp_config *configs,
+					     struct dhcp_context *context,
+					     unsigned char *clid, int clid_len,
+					     unsigned char *hwaddr, int hw_len, 
+					     int hw_type, char *hostname,
+					     struct dhcp_netid *tags, int tag_not_needed)
 {
   int count, new;
   struct dhcp_config *config, *candidate; 
@@ -311,7 +321,9 @@
 	{
 	  if (config->clid_len == clid_len && 
 	      memcmp(config->clid, clid, clid_len) == 0 &&
-	      is_config_in_context(context, config))
+	      is_config_in_context(context, config) &&
+	      match_netid(config->filter, tags, tag_not_needed))
+	    
 	    return config;
 	  
 	  /* dhcpcd prefixes ASCII client IDs by zero which is wrong, but we try and
@@ -319,7 +331,8 @@
 	     see lease_update_from_configs() */
 	  if ((!context || !(context->flags & CONTEXT_V6)) && *clid == 0 && config->clid_len == clid_len-1  &&
 	      memcmp(config->clid, clid+1, clid_len-1) == 0 &&
-	      is_config_in_context(context, config))
+	      is_config_in_context(context, config) &&
+	      match_netid(config->filter, tags, tag_not_needed))
 	    return config;
 	}
   
@@ -327,7 +340,8 @@
   if (hwaddr)
     for (config = configs; config; config = config->next)
       if (config_has_mac(config, hwaddr, hw_len, hw_type) &&
-	  is_config_in_context(context, config))
+	  is_config_in_context(context, config) &&
+	  match_netid(config->filter, tags, tag_not_needed))
 	return config;
   
   if (hostname && context)
@@ -334,7 +348,8 @@
     for (config = configs; config; config = config->next)
       if ((config->flags & CONFIG_NAME) && 
 	  hostname_isequal(config->hostname, hostname) &&
-	  is_config_in_context(context, config))
+	  is_config_in_context(context, config) &&
+	  match_netid(config->filter, tags, tag_not_needed))
 	return config;
 
   
@@ -343,7 +358,8 @@
 
   /* use match with fewest wildcard octets */
   for (candidate = NULL, count = 0, config = configs; config; config = config->next)
-    if (is_config_in_context(context, config))
+    if (is_config_in_context(context, config) &&
+	match_netid(config->filter, tags, tag_not_needed))
       for (conf_addr = config->hwaddr; conf_addr; conf_addr = conf_addr->next)
 	if (conf_addr->wildcard_mask != 0 &&
 	    conf_addr->hwaddr_len == hw_len &&	
@@ -357,6 +373,21 @@
   return candidate;
 }
 
+/* Find tagged configs first. */
+struct dhcp_config *find_config(struct dhcp_config *configs,
+				struct dhcp_context *context,
+				unsigned char *clid, int clid_len,
+				unsigned char *hwaddr, int hw_len, 
+				int hw_type, char *hostname, struct dhcp_netid *tags)
+{
+  struct dhcp_config *ret = find_config_match(configs, context, clid, clid_len, hwaddr, hw_len, hw_type, hostname, tags, 0);
+
+  if (!ret)
+    ret = find_config_match(configs, context, clid, clid_len, hwaddr, hw_len, hw_type, hostname, tags, 1);
+
+  return ret;
+}
+
 void dhcp_update_configs(struct dhcp_config *configs)
 {
   /* Some people like to keep all static IP addresses in /etc/hosts.
@@ -371,8 +402,14 @@
   int prot = AF_INET;
 
   for (config = configs; config; config = config->next)
+  {
     if (config->flags & CONFIG_ADDR_HOSTS)
-      config->flags &= ~(CONFIG_ADDR | CONFIG_ADDR6 | CONFIG_ADDR_HOSTS);
+      config->flags &= ~(CONFIG_ADDR | CONFIG_ADDR_HOSTS);
+#ifdef HAVE_DHCP6
+    if (config->flags & CONFIG_ADDR6_HOSTS)
+      config->flags &= ~(CONFIG_ADDR6 | CONFIG_ADDR6_HOSTS);
+#endif
+  }
 
 #ifdef HAVE_DHCP6 
  again:  
@@ -403,15 +440,15 @@
 		  crec = cache_find_by_name(crec, config->hostname, 0, cacheflags);
 		if (!crec)
 		  continue; /* should be never */
-		inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
+		inet_ntop(prot, &crec->addr, daemon->addrbuff, ADDRSTRLEN);
 		my_syslog(MS_DHCP | LOG_WARNING, _("%s has more than one address in hostsfile, using %s for DHCP"), 
 			  config->hostname, daemon->addrbuff);
 	      }
 	    
 	    if (prot == AF_INET && 
-		(!(conf_tmp = config_find_by_address(configs, crec->addr.addr.addr.addr4)) || conf_tmp == config))
+		(!(conf_tmp = config_find_by_address(configs, crec->addr.addr4)) || conf_tmp == config))
 	      {
-		config->addr = crec->addr.addr.addr.addr4;
+		config->addr = crec->addr.addr4;
 		config->flags |= CONFIG_ADDR | CONFIG_ADDR_HOSTS;
 		continue;
 	      }
@@ -418,15 +455,26 @@
 
 #ifdef HAVE_DHCP6
 	    if (prot == AF_INET6 && 
-		(!(conf_tmp = config_find_by_address6(configs, &crec->addr.addr.addr.addr6, 128, 0)) || conf_tmp == config))
+		(!(conf_tmp = config_find_by_address6(configs, NULL, 0, &crec->addr.addr6)) || conf_tmp == config))
 	      {
-		memcpy(&config->addr6, &crec->addr.addr.addr.addr6, IN6ADDRSZ);
-		config->flags |= CONFIG_ADDR6 | CONFIG_ADDR_HOSTS;
+		/* host must have exactly one address if comming from /etc/hosts. */
+		if (!config->addr6 && (config->addr6 = whine_malloc(sizeof(struct addrlist))))
+		  {
+		    config->addr6->next = NULL;
+		    config->addr6->flags = 0;
+		  }
+
+		if (config->addr6 && !config->addr6->next && !(config->addr6->flags & (ADDRLIST_WILDCARD|ADDRLIST_PREFIX)))
+		  {
+		    memcpy(&config->addr6->addr.addr6, &crec->addr.addr6, IN6ADDRSZ);
+		    config->flags |= CONFIG_ADDR6 | CONFIG_ADDR6_HOSTS;
+		  }
+	    
 		continue;
 	      }
 #endif
 
-	    inet_ntop(prot, &crec->addr.addr, daemon->addrbuff, ADDRSTRLEN);
+	    inet_ntop(prot, &crec->addr, daemon->addrbuff, ADDRSTRLEN);
 	    my_syslog(MS_DHCP | LOG_WARNING, _("duplicate IP address %s (%s) in dhcp-config directive"), 
 		      daemon->addrbuff, config->hostname);
 	    
@@ -570,6 +618,7 @@
   { "sip-server", 120, 0 },
   { "classless-static-route", 121, 0 },
   { "vendor-id-encap", 125, 0 },
+  { "tftp-server-address", 150, OT_ADDR_LIST },
   { "server-ip-address", 255, OT_ADDR_LIST }, /* special, internal only, sets siaddr */
   { NULL, 0, 0 }
 };
@@ -600,7 +649,7 @@
   { "sntp-server", 31,  OT_ADDR_LIST },
   { "information-refresh-time", 32, OT_TIME },
   { "FQDN", 39, OT_INTERNAL | OT_RFC1035_NAME },
-  { "ntp-server", 56,  0 },
+  { "ntp-server", 56, 0 /* OT_ADDR_LIST | OT_RFC1035_NAME */ },
   { "bootfile-url", 59, OT_NAME },
   { "bootfile-param", 60, OT_CSTRING },
   { NULL, 0, 0 }
@@ -693,7 +742,7 @@
 	    
 	    if (ot[o].size & OT_ADDR_LIST) 
 	      {
-		struct all_addr addr;
+		union all_addr addr;
 		int addr_len = INADDRSZ;
 
 #ifdef HAVE_DHCP6
Index: src/dhcp.c
===================================================================
--- src/dhcp.c	(revision 41436)
+++ src/dhcp.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -310,7 +310,7 @@
       parm.relay_local.s_addr = 0;
       parm.ind = iface_index;
       
-      if (!iface_check(AF_INET, (struct all_addr *)&iface_addr, ifr.ifr_name, NULL))
+      if (!iface_check(AF_INET, (union all_addr *)&iface_addr, ifr.ifr_name, NULL))
 	{
 	  /* If we failed to match the primary address of the interface, see if we've got a --listen-address
 	     for a secondary */
@@ -401,7 +401,8 @@
       pkt = (struct in_pktinfo *)CMSG_DATA(cmptr);
       pkt->ipi_ifindex = rcvd_iface_index;
       pkt->ipi_spec_dst.s_addr = 0;
-      msg.msg_controllen = cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+      msg.msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
+      cmptr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
       cmptr->cmsg_level = IPPROTO_IP;
       cmptr->cmsg_type = IP_PKTINFO;
 
@@ -507,24 +508,18 @@
 
    Note that the current chain may be superseded later for configured hosts or those coming via gateways. */
 
-static int complete_context(struct in_addr local, int if_index, char *label,
-			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
+static void guess_range_netmask(struct in_addr addr, struct in_addr netmask)
 {
   struct dhcp_context *context;
-  struct dhcp_relay *relay;
-  struct iface_param *param = vparam;
 
-  (void)label;
-  
   for (context = daemon->dhcp; context; context = context->next)
-    {
-      if (!(context->flags & CONTEXT_NETMASK) &&
-	  (is_same_net(local, context->start, netmask) ||
-	   is_same_net(local, context->end, netmask)))
+    if (!(context->flags & CONTEXT_NETMASK) &&
+	(is_same_net(addr, context->start, netmask) ||
+	 is_same_net(addr, context->end, netmask)))
       { 
 	if (context->netmask.s_addr != netmask.s_addr &&
-	    !(is_same_net(local, context->start, netmask) &&
-	      is_same_net(local, context->end, netmask)))
+	    !(is_same_net(addr, context->start, netmask) &&
+	      is_same_net(addr, context->end, netmask)))
 	  {
 	    strcpy(daemon->dhcp_buff, inet_ntoa(context->start));
 	    strcpy(daemon->dhcp_buff2, inet_ntoa(context->end));
@@ -531,9 +526,65 @@
 	    my_syslog(MS_DHCP | LOG_WARNING, _("DHCP range %s -- %s is not consistent with netmask %s"),
 		      daemon->dhcp_buff, daemon->dhcp_buff2, inet_ntoa(netmask));
 	  }	
- 	context->netmask = netmask;
+	context->netmask = netmask;
       }
+}
+
+static int complete_context(struct in_addr local, int if_index, char *label,
+			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
+{
+  struct dhcp_context *context;
+  struct dhcp_relay *relay;
+  struct iface_param *param = vparam;
+  struct shared_network *share;
+  
+  (void)label;
+
+  for (share = daemon->shared_networks; share; share = share->next)
+    {
       
+#ifdef HAVE_DHCP6
+      if (share->shared_addr.s_addr == 0)
+	continue;
+#endif
+      
+      if (share->if_index != 0)
+	{
+	  if (share->if_index != if_index)
+	    continue;
+	}
+      else
+	{
+	  if (share->match_addr.s_addr != local.s_addr)
+	    continue;
+	}
+
+      for (context = daemon->dhcp; context; context = context->next)
+	{
+	  if (context->netmask.s_addr != 0 &&
+	      is_same_net(share->shared_addr, context->start, context->netmask) &&
+	      is_same_net(share->shared_addr, context->end, context->netmask))
+	    {
+	      /* link it onto the current chain if we've not seen it before */
+	      if (context->current == context)
+		{
+		  /* For a shared network, we have no way to guess what the default route should be. */
+		  context->router.s_addr = 0;
+		  context->local = local; /* Use configured address for Server Identifier */
+		  context->current = param->current;
+		  param->current = context;
+		}
+	      
+	      if (!(context->flags & CONTEXT_BRDCAST))
+		context->broadcast.s_addr  = context->start.s_addr | ~context->netmask.s_addr;
+	    }		
+	}
+    }
+
+  guess_range_netmask(local, netmask);
+  
+  for (context = daemon->dhcp; context; context = context->next)
+    {
       if (context->netmask.s_addr != 0 &&
 	  is_same_net(local, context->start, context->netmask) &&
 	  is_same_net(local, context->end, context->netmask))
@@ -558,7 +609,7 @@
     }
 
   for (relay = daemon->relay4; relay; relay = relay->next)
-    if (if_index == param->ind && relay->local.addr.addr4.s_addr == local.s_addr && relay->current == relay &&
+    if (if_index == param->ind && relay->local.addr4.s_addr == local.s_addr && relay->current == relay &&
 	(param->relay_local.s_addr == 0 || param->relay_local.s_addr == local.s_addr))
       {
 	relay->current = param->relay;
@@ -765,25 +816,34 @@
 		(!IN_CLASSC(ntohl(addr.s_addr)) || 
 		 ((ntohl(addr.s_addr) & 0xff) != 0xff && ((ntohl(addr.s_addr) & 0xff) != 0x0))))
 	      {
-		struct ping_result *r;
-		
-		if ((r = do_icmp_ping(now, addr, j, loopback)))
- 		  {
-		    /* consec-ip mode: we offered this address for another client
-		       (different hash) recently, don't offer it to this one. */
-		    if (!option_bool(OPT_CONSEC_ADDR) || r->hash == j)
+		/* in consec-ip mode, skip addresses equal to
+		   the number of addresses rejected by clients. This
+		   should avoid the same client being offered the same
+		   address after it has rjected it. */
+		if (option_bool(OPT_CONSEC_ADDR) && c->addr_epoch)
+		  c->addr_epoch--;
+		else
+		  {
+		    struct ping_result *r;
+		    
+		    if ((r = do_icmp_ping(now, addr, j, loopback)))
 		      {
-			*addrp = addr;
-			return 1;
+			/* consec-ip mode: we offered this address for another client
+			   (different hash) recently, don't offer it to this one. */
+			if (!option_bool(OPT_CONSEC_ADDR) || r->hash == j)
+			  {
+			    *addrp = addr;
+			    return 1;
+			  }
 		      }
+		    else
+		      {
+			/* address in use: perturb address selection so that we are
+			   less likely to try this address again. */
+			if (!option_bool(OPT_CONSEC_ADDR))
+			  c->addr_epoch++;
+		      }
 		  }
-		else
-		  {
-		    /* address in use: perturb address selection so that we are
-		       less likely to try this address again. */
-		    if (!option_bool(OPT_CONSEC_ADDR))
-		      c->addr_epoch++;
-		  }
 	      }
 	    
 	    addr.s_addr = htonl(ntohl(addr.s_addr) + 1);
@@ -971,7 +1031,7 @@
   if (daemon->port == 0)
     return NULL; /* DNS disabled. */
   
-  lookup = cache_find_by_addr(NULL, (struct all_addr *)&addr, 0, F_IPV4);
+  lookup = cache_find_by_addr(NULL, (union all_addr *)&addr, 0, F_IPV4);
 
   if (lookup && (lookup->flags & F_HOSTS))
     {
@@ -1000,25 +1060,25 @@
 static int  relay_upstream4(struct dhcp_relay *relay, struct dhcp_packet *mess, size_t sz, int iface_index)
 {
   /* ->local is same value for all relays on ->current chain */
-  struct all_addr from;
+  union all_addr from;
   
   if (mess->op != BOOTREQUEST)
     return 0;
 
   /* source address == relay address */
-  from.addr.addr4 = relay->local.addr.addr4;
+  from.addr4 = relay->local.addr4;
   
   /* already gatewayed ? */
   if (mess->giaddr.s_addr)
     {
       /* if so check if by us, to stomp on loops. */
-      if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr)
+      if (mess->giaddr.s_addr == relay->local.addr4.s_addr)
 	return 1;
     }
   else
     {
       /* plug in our address */
-      mess->giaddr.s_addr = relay->local.addr.addr4.s_addr;
+      mess->giaddr.s_addr = relay->local.addr4.s_addr;
     }
 
   if ((mess->hops++) > 20)
@@ -1029,7 +1089,7 @@
       union mysockaddr to;
       
       to.sa.sa_family = AF_INET;
-      to.in.sin_addr = relay->server.addr.addr4;
+      to.in.sin_addr = relay->server.addr4;
       to.in.sin_port = htons(daemon->dhcp_server_port);
       
       send_from(daemon->dhcpfd, 0, (char *)mess, sz, &to, &from, 0);
@@ -1037,7 +1097,7 @@
       if (option_bool(OPT_LOG_OPTS))
 	{
 	  inet_ntop(AF_INET, &relay->local, daemon->addrbuff, ADDRSTRLEN);
-	  my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"), daemon->addrbuff, inet_ntoa(relay->server.addr.addr4));
+	  my_syslog(MS_DHCP | LOG_INFO, _("DHCP relay %s -> %s"), daemon->addrbuff, inet_ntoa(relay->server.addr4));
 	}
       
       /* Save this for replies */
@@ -1057,7 +1117,7 @@
 
   for (relay = daemon->relay4; relay; relay = relay->next)
     {
-      if (mess->giaddr.s_addr == relay->local.addr.addr4.s_addr)
+      if (mess->giaddr.s_addr == relay->local.addr4.s_addr)
 	{
 	  if (!relay->interface || wildcard_match(relay->interface, arrival_interface))
 	    return relay->iface_index != 0 ? relay : NULL;
Index: src/dns-protocol.h
===================================================================
--- src/dns-protocol.h	(revision 41436)
+++ src/dns-protocol.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/lease.c
===================================================================
--- src/lease.c	(revision 41436)
+++ src/lease.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 static int read_leases(time_t now, FILE *leasestream)
 {
   unsigned long ei;
-  struct all_addr addr;
+  union all_addr addr;
   struct dhcp_lease *lease;
   int clid_len, hw_len, hw_type;
   int items;
@@ -62,11 +62,16 @@
 	
 	if (fscanf(leasestream, " %64s %255s %764s",
 		   daemon->namebuff, daemon->dhcp_buff, daemon->packet) != 3)
-	  return 0;
-	
-	if (inet_pton(AF_INET, daemon->namebuff, &addr.addr.addr4))
 	  {
-	    if ((lease = lease4_allocate(addr.addr.addr4)))
+	    my_syslog(MS_DHCP | LOG_WARNING, _("ignoring invalid line in lease database: %s %s %s %s ..."),
+		      daemon->dhcp_buff3, daemon->dhcp_buff2,
+		      daemon->namebuff, daemon->dhcp_buff);
+	    continue;
+	  }
+		
+	if (inet_pton(AF_INET, daemon->namebuff, &addr.addr4))
+	  {
+	    if ((lease = lease4_allocate(addr.addr4)))
 	      domain = get_domain(lease->addr);
 	    
 	    hw_len = parse_hex(daemon->dhcp_buff2, (unsigned char *)daemon->dhcp_buff2, DHCP_CHADDR_MAX, NULL, &hw_type);
@@ -75,7 +80,7 @@
 	      hw_type = ARPHRD_ETHER; 
 	  }
 #ifdef HAVE_DHCP6
-	else if (inet_pton(AF_INET6, daemon->namebuff, &addr.addr.addr6))
+	else if (inet_pton(AF_INET6, daemon->namebuff, &addr.addr6))
 	  {
 	    char *s = daemon->dhcp_buff2;
 	    int lease_type = LEASE_NA;
@@ -86,7 +91,7 @@
 		s++;
 	      }
 	    
-	    if ((lease = lease6_allocate(&addr.addr.addr6, lease_type)))
+	    if ((lease = lease6_allocate(&addr.addr6, lease_type)))
 	      {
 		lease_set_iaid(lease, strtoul(s, NULL, 10));
 		domain = get_domain6(&lease->addr6);
@@ -94,7 +99,12 @@
 	  }
 #endif
 	else
-	  return 0;
+	  {
+	    my_syslog(MS_DHCP | LOG_WARNING, _("ignoring invalid line in lease database, bad address: %s"),
+		      daemon->namebuff);
+	    continue;
+	  }
+	
 
 	if (!lease)
 	  die (_("too many stored leases"), NULL, EC_MISC);
@@ -174,10 +184,8 @@
   if (leasestream)
     {
       if (!read_leases(now, leasestream))
-	my_syslog(MS_DHCP | LOG_ERR, _("failed to parse lease database, invalid line: %s %s %s %s ..."),
-		  daemon->dhcp_buff3, daemon->dhcp_buff2,
-		  daemon->namebuff, daemon->dhcp_buff);
-
+	my_syslog(MS_DHCP | LOG_ERR, _("failed to parse lease database cleanly"));
+      
       if (ferror(leasestream))
 	die(_("failed to read lease file %s: %s"), daemon->lease_file, EC_FILE);
     }
@@ -224,7 +232,7 @@
     if (lease->flags & (LEASE_TA | LEASE_NA))
       continue;
     else if ((config = find_config(daemon->dhcp_conf, NULL, lease->clid, lease->clid_len, 
-				   lease->hwaddr, lease->hwaddr_len, lease->hwaddr_type, NULL)) && 
+				   lease->hwaddr, lease->hwaddr_len, lease->hwaddr_type, NULL, NULL)) && 
 	     (config->flags & CONFIG_NAME) &&
 	     (!(config->flags & CONFIG_ADDR) || config->addr.s_addr == lease->addr.s_addr))
       lease_set_hostname(lease, config->hostname, 1, get_domain(lease->addr), NULL);
@@ -522,28 +530,28 @@
 		if (slaac->backoff == 0)
 		  {
 		    if (lease->fqdn)
-		      cache_add_dhcp_entry(lease->fqdn, AF_INET6, (struct all_addr *)&slaac->addr, lease->expires);
+		      cache_add_dhcp_entry(lease->fqdn, AF_INET6, (union all_addr *)&slaac->addr, lease->expires);
 		    if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
-		      cache_add_dhcp_entry(lease->hostname, AF_INET6, (struct all_addr *)&slaac->addr, lease->expires);
+		      cache_add_dhcp_entry(lease->hostname, AF_INET6, (union all_addr *)&slaac->addr, lease->expires);
 		  }
 	    }
 	  
 	  if (lease->fqdn)
 	    cache_add_dhcp_entry(lease->fqdn, prot, 
-				 prot == AF_INET ? (struct all_addr *)&lease->addr : (struct all_addr *)&lease->addr6,
+				 prot == AF_INET ? (union all_addr *)&lease->addr : (union all_addr *)&lease->addr6,
 				 lease->expires);
 	     
 	  if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
 	    cache_add_dhcp_entry(lease->hostname, prot, 
-				 prot == AF_INET ? (struct all_addr *)&lease->addr : (struct all_addr *)&lease->addr6, 
+				 prot == AF_INET ? (union all_addr *)&lease->addr : (union all_addr *)&lease->addr6, 
 				 lease->expires);
        
 #else
 	  if (lease->fqdn)
-	    cache_add_dhcp_entry(lease->fqdn, prot, (struct all_addr *)&lease->addr, lease->expires);
+	    cache_add_dhcp_entry(lease->fqdn, prot, (union all_addr *)&lease->addr, lease->expires);
 	  
 	  if (!option_bool(OPT_DHCP_FQDN) && lease->hostname)
-	    cache_add_dhcp_entry(lease->hostname, prot, (struct all_addr *)&lease->addr, lease->expires);
+	    cache_add_dhcp_entry(lease->hostname, prot, (union all_addr *)&lease->addr, lease->expires);
 #endif
 	}
       
@@ -558,7 +566,7 @@
   for (lease = leases, up = &leases; lease; lease = tmp)
     {
       tmp = lease->next;
-      if ((lease->expires != 0 && difftime(now, lease->expires) > 0) || lease == target)
+      if ((lease->expires != 0 && difftime(now, lease->expires) >= 0) || lease == target)
 	{
 	  file_dirty = 1;
 	  if (lease->hostname)
@@ -635,7 +643,8 @@
 #ifdef HAVE_DHCP6
 /* find address for {CLID, IAID, address} */
 struct dhcp_lease *lease6_find(unsigned char *clid, int clid_len, 
-			       int lease_type, int iaid, struct in6_addr *addr)
+			       int lease_type, unsigned int iaid,
+			       struct in6_addr *addr)
 {
   struct dhcp_lease *lease;
   
@@ -667,7 +676,9 @@
 }
 
 /* enumerate all leases belonging to {CLID, IAID} */
-struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type, unsigned char *clid, int clid_len, int iaid)
+struct dhcp_lease *lease6_find_by_client(struct dhcp_lease *first, int lease_type,
+					 unsigned char *clid, int clid_len,
+					 unsigned int iaid)
 {
   struct dhcp_lease *lease;
 
@@ -833,7 +844,7 @@
       dns_dirty = 1;
       lease->expires = exp;
 #ifndef HAVE_BROKEN_RTC
-      lease->flags |= LEASE_AUX_CHANGED;
+      lease->flags |= LEASE_AUX_CHANGED | LEASE_EXP_CHANGED;
       file_dirty = 1;
 #endif
     }
@@ -849,7 +860,7 @@
 } 
 
 #ifdef HAVE_DHCP6
-void lease_set_iaid(struct dhcp_lease *lease, int iaid)
+void lease_set_iaid(struct dhcp_lease *lease, unsigned int iaid)
 {
   if (lease->iaid != iaid)
     {
@@ -1133,7 +1144,8 @@
   
   for (lease = leases; lease; lease = lease->next)
     if ((lease->flags & (LEASE_NEW | LEASE_CHANGED)) || 
-	((lease->flags & LEASE_AUX_CHANGED) && option_bool(OPT_LEASE_RO)))
+	((lease->flags & LEASE_AUX_CHANGED) && option_bool(OPT_LEASE_RO)) ||
+	((lease->flags & LEASE_EXP_CHANGED) && option_bool(OPT_LEASE_RENEW)))
       {
 #ifdef HAVE_SCRIPT
 	queue_script((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD, lease, 
@@ -1143,7 +1155,7 @@
 	emit_dbus_signal((lease->flags & LEASE_NEW) ? ACTION_ADD : ACTION_OLD, lease,
 			 lease->fqdn ? lease->fqdn : lease->hostname);
 #endif
-	lease->flags &= ~(LEASE_NEW | LEASE_CHANGED | LEASE_AUX_CHANGED);
+	lease->flags &= ~(LEASE_NEW | LEASE_CHANGED | LEASE_AUX_CHANGED | LEASE_EXP_CHANGED);
 	
 	/* this is used for the "add" call, then junked, since they're not in the database */
 	free(lease->extradata);
Index: src/log.c
===================================================================
--- src/log.c	(revision 41436)
+++ src/log.c	(working copy)
@@ -1,5 +1,5 @@
 #ifdef NEED_PRINTF
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/netlink.c
===================================================================
--- src/netlink.c	(revision 41436)
+++ src/netlink.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -22,6 +22,12 @@
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 
+/* Blergh. Radv does this, so that's our excuse. */
+#ifndef SOL_NETLINK
+#define SOL_NETLINK 270
+#endif
+
+
 /* linux 2.6.19 buggers up the headers, patch it up here. */ 
 #ifndef IFA_RTA
 #  define IFA_RTA(r)  \
@@ -44,6 +50,7 @@
 {
   struct sockaddr_nl addr;
   socklen_t slen = sizeof(addr);
+  int opt = 1;
 
   addr.nl_family = AF_NETLINK;
   addr.nl_pad = 0;
@@ -51,11 +58,10 @@
   addr.nl_groups = RTMGRP_IPV4_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
     addr.nl_groups |= RTMGRP_IPV4_IFADDR;  
-#ifdef HAVE_IPV6
   addr.nl_groups |= RTMGRP_IPV6_ROUTE;
   if (option_bool(OPT_CLEVERBIND))
     addr.nl_groups |= RTMGRP_IPV6_IFADDR;
-#endif
+
 #ifdef HAVE_DHCP6
   if (daemon->doing_ra || daemon->doing_dhcp6)
     addr.nl_groups |= RTMGRP_IPV6_IFADDR;
@@ -73,6 +79,7 @@
     }
   
   if (daemon->netlinkfd == -1 || 
+      setsockopt(daemon->netlinkfd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &opt, sizeof(opt)) == -1 ||
       getsockname(daemon->netlinkfd, (struct sockaddr *)&addr, &slen) == -1)
     die(_("cannot create netlink socket: %s"), NULL, EC_MISC);
    
@@ -235,7 +242,6 @@
 		      if (!((*callback)(addr, ifa->ifa_index, label,  netmask, broadcast, parm)))
 			callback_ok = 0;
 		  }
-#ifdef HAVE_IPV6
 		else if (ifa->ifa_family == AF_INET6)
 		  {
 		    struct in6_addr *addrp = NULL;
@@ -272,7 +278,6 @@
 					(int) preferred, (int)valid, parm)))
 			callback_ok = 0;
 		  }
-#endif
 	      }
 	  }
 	else if (h->nlmsg_type == RTM_NEWNEIGH && family == AF_UNSPEC)
@@ -365,7 +370,9 @@
 	 failing. */ 
       struct rtmsg *rtm = NLMSG_DATA(h);
       
-      if (rtm->rtm_type == RTN_UNICAST && rtm->rtm_scope == RT_SCOPE_LINK)
+      if (rtm->rtm_type == RTN_UNICAST && rtm->rtm_scope == RT_SCOPE_LINK &&
+	  (rtm->rtm_table == RT_TABLE_MAIN ||
+	   rtm->rtm_table == RT_TABLE_LOCAL))
 	queue_event(EVENT_NEWROUTE);
     }
   else if (h->nlmsg_type == RTM_NEWADDR || h->nlmsg_type == RTM_DELADDR) 
Index: src/network.c
===================================================================
--- src/network.c	(revision 41436)
+++ src/network.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -109,7 +109,7 @@
 
 #endif
 
-int iface_check(int family, struct all_addr *addr, char *name, int *auth)
+int iface_check(int family, union all_addr *addr, char *name, int *auth)
 {
   struct iname *tmp;
   int ret = 1, match_addr = 0;
@@ -135,14 +135,12 @@
 	  if (tmp->addr.sa.sa_family == family)
 	    {
 	      if (family == AF_INET &&
-		  tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+		  tmp->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
 		ret = match_addr = tmp->used = 1;
-#ifdef HAVE_IPV6
 	      else if (family == AF_INET6 &&
 		       IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, 
-					  &addr->addr.addr6))
+					  &addr->addr6))
 		ret = match_addr = tmp->used = 1;
-#endif
 	    }          
     }
   
@@ -160,13 +158,11 @@
 	  break;
       }
     else if (addr && tmp->addr.sa.sa_family == AF_INET && family == AF_INET &&
-	     tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+	     tmp->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
       break;
-#ifdef HAVE_IPV6
     else if (addr && tmp->addr.sa.sa_family == AF_INET6 && family == AF_INET6 &&
-	     IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr.addr6))
+	     IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr6))
       break;
-#endif      
 
   if (tmp && auth) 
     {
@@ -183,7 +179,7 @@
    an interface other than the loopback. Accept packet if it arrived via a loopback 
    interface, even when we're not accepting packets that way, as long as the destination
    address is one we're believing. Interface list must be up-to-date before calling. */
-int loopback_exception(int fd, int family, struct all_addr *addr, char *name)    
+int loopback_exception(int fd, int family, union all_addr *addr, char *name)    
 {
   struct ifreq ifr;
   struct irec *iface;
@@ -197,14 +193,11 @@
 	  {
 	    if (family == AF_INET)
 	      {
-		if (iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+		if (iface->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
 		  return 1;
 	      }
-#ifdef HAVE_IPV6
-	    else if (IN6_ARE_ADDR_EQUAL(&iface->addr.in6.sin6_addr, &addr->addr.addr6))
+	    else if (IN6_ARE_ADDR_EQUAL(&iface->addr.in6.sin6_addr, &addr->addr6))
 	      return 1;
-#endif
-	    
 	  }
     }
   return 0;
@@ -214,7 +207,7 @@
    on the relevant address, but the name of the arrival interface, derived from the
    index won't match the config. Check that we found an interface address for the arrival 
    interface: daemon->interfaces must be up-to-date. */
-int label_exception(int index, int family, struct all_addr *addr)
+int label_exception(int index, int family, union all_addr *addr)
 {
   struct irec *iface;
 
@@ -224,7 +217,7 @@
 
   for (iface = daemon->interfaces; iface; iface = iface->next)
     if (iface->index == index && iface->addr.sa.sa_family == AF_INET &&
-	iface->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)
+	iface->addr.in.sin_addr.s_addr == addr->addr4.s_addr)
       return 1;
 
   return 0;
@@ -289,22 +282,18 @@
 	  
 	  if (addr->sa.sa_family == AF_INET)
 	    {
-	      al->addr.addr.addr4 = addr->in.sin_addr;
+	      al->addr.addr4 = addr->in.sin_addr;
 	      al->flags = 0;
 	    }
-#ifdef HAVE_IPV6
 	  else
 	    {
-	      al->addr.addr.addr6 = addr->in6.sin6_addr;
+	      al->addr.addr6 = addr->in6.sin6_addr;
 	      al->flags = ADDRLIST_IPV6;
 	    } 
-#endif
 	}
     }
   
-#ifdef HAVE_IPV6
   if (addr->sa.sa_family != AF_INET6 || !IN6_IS_ADDR_LINKLOCAL(&addr->in6.sin6_addr))
-#endif
     {
       struct interface_name *int_name;
       struct addrlist *al;
@@ -332,12 +321,11 @@
 		      al->next = zone->subnet;
 		      zone->subnet = al;
 		      al->prefixlen = prefixlen;
-		      al->addr.addr.addr4 = addr->in.sin_addr;
+		      al->addr.addr4 = addr->in.sin_addr;
 		      al->flags = 0;
 		    }
 		}
 	      
-#ifdef HAVE_IPV6
 	      if (addr->sa.sa_family == AF_INET6 && (name->flags & AUTH6))
 		{
 		  if (param->spare)
@@ -353,12 +341,10 @@
 		      al->next = zone->subnet;
 		      zone->subnet = al;
 		      al->prefixlen = prefixlen;
-		      al->addr.addr.addr6 = addr->in6.sin6_addr;
+		      al->addr.addr6 = addr->in6.sin6_addr;
 		      al->flags = ADDRLIST_IPV6;
 		    }
 		} 
-#endif
-	      
 	    }
 #endif
        
@@ -383,13 +369,12 @@
 		
 		if (addr->sa.sa_family == AF_INET)
 		  {
-		    al->addr.addr.addr4 = addr->in.sin_addr;
+		    al->addr.addr4 = addr->in.sin_addr;
 		    al->flags = 0;
 		  }
-#ifdef HAVE_IPV6
 		else
 		 {
-		    al->addr.addr.addr6 = addr->in6.sin6_addr;
+		    al->addr.addr6 = addr->in6.sin6_addr;
 		    al->flags = ADDRLIST_IPV6;
 		    /* Privacy addresses and addresses still undergoing DAD and deprecated addresses
 		       don't appear in forward queries, but will in reverse ones. */
@@ -396,7 +381,6 @@
 		    if (!(iface_flags & IFACE_PERMANENT) || (iface_flags & (IFACE_DEPRECATED | IFACE_TENTATIVE)))
 		      al->flags |= ADDRLIST_REVONLY;
 		 } 
-#endif
 	      }
 	  }
     }
@@ -435,14 +419,12 @@
     }
   
   if (addr->sa.sa_family == AF_INET &&
-      !iface_check(AF_INET, (struct all_addr *)&addr->in.sin_addr, label, &auth_dns))
+      !iface_check(AF_INET, (union all_addr *)&addr->in.sin_addr, label, &auth_dns))
     return 1;
 
-#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET6 &&
-      !iface_check(AF_INET6, (struct all_addr *)&addr->in6.sin6_addr, label, &auth_dns))
+      !iface_check(AF_INET6, (union all_addr *)&addr->in6.sin6_addr, label, &auth_dns))
     return 1;
-#endif
     
 #ifdef HAVE_DHCP
   /* No DHCP where we're doing auth DNS. */
@@ -501,7 +483,6 @@
   return 0;
 }
 
-#ifdef HAVE_IPV6
 static int iface_allowed_v6(struct in6_addr *local, int prefix, 
 			    int scope, int if_index, int flags, 
 			    int preferred, int valid, void *vparam)
@@ -529,7 +510,6 @@
   
   return iface_allowed((struct iface_param *)vparam, if_index, NULL, &addr, netmask, prefix, flags);
 }
-#endif
 
 static int iface_allowed_v4(struct in_addr local, int if_index, char *label,
 			    struct in_addr netmask, struct in_addr broadcast, void *vparam)
@@ -633,9 +613,7 @@
 
   param.spare = spare;
   
-#ifdef HAVE_IPV6
   ret = iface_enumerate(AF_INET6, &param, iface_allowed_v6);
-#endif
 
   if (ret)
     ret = iface_enumerate(AF_INET, &param, iface_allowed_v4); 
@@ -740,10 +718,8 @@
   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1 || !fix_fd(fd))
     goto err;
   
-#ifdef HAVE_IPV6
   if (family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)) == -1)
     goto err;
-#endif
   
   if ((rc = bind(fd, (struct sockaddr *)addr, sa_len(addr))) == -1)
     goto err;
@@ -750,6 +726,11 @@
   
   if (type == SOCK_STREAM)
     {
+#ifdef TCP_FASTOPEN
+      int qlen = 5;                           
+      setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen));
+#endif
+      
       if (listen(fd, TCP_BACKLOG) == -1)
 	goto err;
     }
@@ -767,15 +748,12 @@
 #endif
 	}
     }
-#ifdef HAVE_IPV6
   else if (!set_ipv6pktinfo(fd))
     goto err;
-#endif
   
   return fd;
 }
 
-#ifdef HAVE_IPV6  
 int set_ipv6pktinfo(int fd)
 {
   int opt = 1;
@@ -802,12 +780,13 @@
 
   return 0;
 }
-#endif
 
 
 /* Find the interface on which a TCP connection arrived, if possible, or zero otherwise. */
 int tcp_interface(int fd, int af)
 { 
+  (void)fd; /* suppress potential unused warning */
+  (void)af; /* suppress potential unused warning */
   int if_index = 0;
 
 #ifdef HAVE_LINUX_NETWORK
@@ -842,7 +821,6 @@
 	      }
 	}
     }
-#ifdef HAVE_IPV6
   else
     {
       /* Only the RFC-2292 API has the ability to find the interface for TCP connections,
@@ -874,7 +852,6 @@
               }
 	}
     }
-#endif /* IPV6 */
 #endif /* Linux */
  
   return if_index;
@@ -904,7 +881,6 @@
 	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
 	  addr->in.sin_port = save;
 	}
-#  ifdef HAVE_IPV6
       else
 	{
 	  short save = addr->in6.sin6_port;
@@ -912,7 +888,6 @@
 	  tftpfd = make_sock(addr, SOCK_DGRAM, dienow);
 	  addr->in6.sin6_port = save;
 	}  
-#  endif
     }
 #endif
 
@@ -945,11 +920,10 @@
 
   l = create_listeners(&addr, !!option_bool(OPT_TFTP), 1);
 
-#ifdef HAVE_IPV6
   memset(&addr, 0, sizeof(addr));
-#  ifdef HAVE_SOCKADDR_SA_LEN
+#ifdef HAVE_SOCKADDR_SA_LEN
   addr.in6.sin6_len = sizeof(addr.in6);
-#  endif
+#endif
   addr.in6.sin6_family = AF_INET6;
   addr.in6.sin6_addr = in6addr_any;
   addr.in6.sin6_port = htons(daemon->port);
@@ -959,7 +933,6 @@
     l->next = l6;
   else 
     l = l6;
-#endif
 
   daemon->listeners = l;
 }
@@ -1159,7 +1132,6 @@
 		addr.in.sin_len = sizeof(struct sockaddr_in);
 #endif
 	      }
-#ifdef HAVE_IPV6
 	    else
 	      {
 		addr.in6.sin6_addr = in6addr_any; 
@@ -1168,7 +1140,6 @@
 		addr.in6.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 	      }
-#endif
 	    
 	    if (bind(fd, (struct sockaddr *)&addr, sa_len(&addr)) == 0)
 	      return fd;
@@ -1193,10 +1164,8 @@
     {
       if (addr_copy.sa.sa_family == AF_INET)
 	addr_copy.in.sin_port = 0;
-#ifdef HAVE_IPV6
       else
 	addr_copy.in6.sin6_port = 0;
-#endif
     }
   
   if (bind(fd, (struct sockaddr *)&addr_copy, sa_len(&addr_copy)) == -1)
@@ -1211,7 +1180,7 @@
           return setsockopt(fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex_opt, sizeof(ifindex_opt)) == 0;
         }
 #endif
-#if defined(HAVE_IPV6) && defined (IPV6_UNICAST_IF)
+#if defined (IPV6_UNICAST_IF)
       if (addr_copy.sa.sa_family == AF_INET6)
         {
           uint32_t ifindex_opt = htonl(ifindex);
@@ -1220,6 +1189,7 @@
 #endif
     }
 
+  (void)intname; /* suppress potential unused warning */
 #if defined(SO_BINDTODEVICE)
   if (intname[0] != 0 &&
       setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, intname, IF_NAMESIZE) == -1)
@@ -1247,12 +1217,10 @@
 	  addr->in.sin_port == htons(0)) 
 	return NULL;
 
-#ifdef HAVE_IPV6
       if (addr->sa.sa_family == AF_INET6 &&
 	  memcmp(&addr->in6.sin6_addr, &in6addr_any, sizeof(in6addr_any)) == 0 &&
 	  addr->in6.sin6_port == htons(0)) 
 	return NULL;
-#endif
     }
 
   if (intname && strlen(intname) != 0)
@@ -1315,7 +1283,7 @@
 #endif
       if ((sfd = allocate_sfd(&addr, "")))
 	sfd->preallocated = 1;
-#ifdef HAVE_IPV6
+
       memset(&addr, 0, sizeof(addr));
       addr.in6.sin6_family = AF_INET6;
       addr.in6.sin6_addr = in6addr_any;
@@ -1325,7 +1293,6 @@
 #endif
       if ((sfd = allocate_sfd(&addr, "")))
 	sfd->preallocated = 1;
-#endif
     }
   
   for (srv = daemon->servers; srv; srv = srv->next)
@@ -1576,7 +1543,7 @@
 		{
 		  count--;
 		  if (++locals <= LOCALS_LOGGED)
-			my_syslog(LOG_INFO, _("using local addresses only for %s %s"), s1, s2);
+			my_syslog(LOG_INFO, _("using only locally-known addresses for %s %s"), s1, s2);
 	        }
 	      else if (serv->flags & SERV_USE_RESOLV)
 		my_syslog(LOG_INFO, _("using standard nameservers for %s %s"), s1, s2);
@@ -1658,7 +1625,6 @@
 	  source_addr.in.sin_addr.s_addr = INADDR_ANY;
 	  source_addr.in.sin_port = htons(daemon->query_port);
 	}
-#ifdef HAVE_IPV6
       else 
 	{	
 	  int scope_index = 0;
@@ -1686,10 +1652,6 @@
 	  else
 	    continue;
 	}
-#else /* IPV6 */
-      else
-	continue;
-#endif 
 
       add_update_server(SERV_FROM_RESOLV, &addr, &source_addr, NULL, NULL);
       gotone = 1;
Index: src/tftp.c
===================================================================
--- src/tftp.c	(revision 41436)
+++ src/tftp.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -18,6 +18,7 @@
 
 #ifdef HAVE_TFTP
 
+static void handle_tftp(time_t now, struct tftp_transfer *transfer, ssize_t len);
 static struct tftp_file *check_tftp_fileperm(ssize_t *len, char *prefix);
 static void free_transfer(struct tftp_transfer *transfer);
 static ssize_t tftp_err(int err, char *packet, char *message, char *file);
@@ -50,7 +51,7 @@
   struct ifreq ifr;
   int is_err = 1, if_index = 0, mtu = 0;
   struct iname *tmp;
-  struct tftp_transfer *transfer;
+  struct tftp_transfer *transfer = NULL, **up;
   int port = daemon->start_tftp_port; /* may be zero to use ephemeral port */
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
   int mtuflag = IP_PMTUDISC_DONT;
@@ -59,24 +60,20 @@
   char *name = NULL;
   char *prefix = daemon->tftp_prefix;
   struct tftp_prefix *pref;
-  struct all_addr addra;
-#ifdef HAVE_IPV6
+  union all_addr addra;
   /* Can always get recvd interface for IPv6 */
   int check_dest = !option_bool(OPT_NOWILD) || listen->family == AF_INET6;
-#else
-  int check_dest = !option_bool(OPT_NOWILD);
-#endif
   union {
     struct cmsghdr align; /* this ensures alignment */
-#ifdef HAVE_IPV6
     char control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];
-#endif
 #if defined(HAVE_LINUX_NETWORK)
     char control[CMSG_SPACE(sizeof(struct in_pktinfo))];
 #elif defined(HAVE_SOLARIS_NETWORK)
-    char control[CMSG_SPACE(sizeof(unsigned int))];
+    char control[CMSG_SPACE(sizeof(struct in_addr)) +
+		 CMSG_SPACE(sizeof(unsigned int))];
 #elif defined(IP_RECVDSTADDR) && defined(IP_RECVIF)
-    char control[CMSG_SPACE(sizeof(struct sockaddr_dl))];
+    char control[CMSG_SPACE(sizeof(struct in_addr)) +
+		 CMSG_SPACE(sizeof(struct sockaddr_dl))];
 #endif
   } control_u; 
 
@@ -174,7 +171,6 @@
 	  
 #endif
 
-#ifdef HAVE_IPV6
       if (listen->family == AF_INET6)
         {
           for (cmptr = CMSG_FIRSTHDR(&msg); cmptr; cmptr = CMSG_NXTHDR(&msg, cmptr))
@@ -190,7 +186,6 @@
                 if_index = p.p->ipi6_ifindex;
               }
         }
-#endif
       
       if (!indextoname(listen->tftpfd, if_index, namebuff))
 	return;
@@ -197,12 +192,10 @@
 
       name = namebuff;
       
-      addra.addr.addr4 = addr.in.sin_addr;
+      addra.addr4 = addr.in.sin_addr;
 
-#ifdef HAVE_IPV6
       if (listen->family == AF_INET6)
-	addra.addr.addr6 = addr.in6.sin6_addr;
-#endif
+	addra.addr6 = addr.in6.sin6_addr;
 
       if (daemon->tftp_interfaces)
 	{
@@ -222,7 +215,7 @@
 	      if (!option_bool(OPT_CLEVERBIND))
 		enumerate_interfaces(0); 
 	      if (!loopback_exception(listen->tftpfd, listen->family, &addra, name) &&
-		  !label_exception(if_index, listen->family, &addra) )
+		  !label_exception(if_index, listen->family, &addra))
 		return;
 	    }
 	  
@@ -247,6 +240,39 @@
   if (mtu == 0)
     mtu = daemon->tftp_mtu;
 
+  /* data transfer via server listening socket */
+  if (option_bool(OPT_SINGLE_PORT))
+    {
+      int tftp_cnt;
+
+      for (tftp_cnt = 0, transfer = daemon->tftp_trans, up = &daemon->tftp_trans; transfer; up = &transfer->next, transfer = transfer->next)
+	{
+	  tftp_cnt++;
+
+	  if (sockaddr_isequal(&peer, &transfer->peer))
+	    {
+	      if (ntohs(*((unsigned short *)packet)) == OP_RRQ)
+		{
+		  /* Handle repeated RRQ or abandoned transfer from same host and port 
+		     by unlinking and reusing the struct transfer. */
+		  *up = transfer->next;
+		  break;
+		}
+	      else
+		{
+		  handle_tftp(now, transfer, len);
+		  return;
+		}
+	    }
+	}
+      
+      /* Enforce simultaneous transfer limit. In non-single-port mode
+	 this is doene by not listening on the server socket when
+	 too many transfers are in progress. */
+      if (!transfer && tftp_cnt >= daemon->tftp_max)
+	return;
+    }
+  
   if (name)
     {
       /* check for per-interface prefix */ 
@@ -262,7 +288,6 @@
       addr.in.sin_len = sizeof(addr.in);
 #endif
     }
-#ifdef HAVE_IPV6
   else
     {
       addr.in6.sin6_port = htons(port);
@@ -272,12 +297,14 @@
       addr.in6.sin6_len = sizeof(addr.in6);
 #endif
     }
-#endif
 
-  if (!(transfer = whine_malloc(sizeof(struct tftp_transfer))))
+  /* May reuse struct transfer from abandoned transfer in single port mode. */
+  if (!transfer && !(transfer = whine_malloc(sizeof(struct tftp_transfer))))
     return;
   
-  if ((transfer->sockfd = socket(listen->family, SOCK_DGRAM, 0)) == -1)
+  if (option_bool(OPT_SINGLE_PORT))
+    transfer->sockfd = listen->tftpfd;
+  else if ((transfer->sockfd = socket(listen->family, SOCK_DGRAM, 0)) == -1)
     {
       free(transfer);
       return;
@@ -284,6 +311,8 @@
     }
   
   transfer->peer = peer;
+  transfer->source = addra;
+  transfer->if_index = if_index;
   transfer->timeout = now + 2;
   transfer->backoff = 1;
   transfer->block = 1;
@@ -296,7 +325,7 @@
   prettyprint_addr(&peer, daemon->addrbuff);
   
   /* if we have a nailed-down range, iterate until we find a free one. */
-  while (1)
+  while (!option_bool(OPT_SINGLE_PORT))
     {
       if (bind(transfer->sockfd, &addr.sa, sa_len(&addr)) == -1 ||
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
@@ -310,10 +339,9 @@
 		{ 
 		  if (listen->family == AF_INET)
 		    addr.in.sin_port = htons(port);
-#ifdef HAVE_IPV6
 		  else
-		     addr.in6.sin6_port = htons(port);
-#endif
+		    addr.in6.sin6_port = htons(port);
+		  
 		  continue;
 		}
 	      my_syslog(MS_TFTP | LOG_ERR, _("unable to get free port for TFTP"));
@@ -326,7 +354,7 @@
   
   p = packet + 2;
   end = packet + len;
-
+  
   if (ntohs(*((unsigned short *)packet)) != OP_RRQ ||
       !(filename = next(&p, end)) ||
       !(mode = next(&p, end)) ||
@@ -450,10 +478,9 @@
 	    is_err = 0;
 	}
     }
+
+  send_from(transfer->sockfd, !option_bool(OPT_SINGLE_PORT), packet, len, &peer, &addra, if_index);
   
-  while (sendto(transfer->sockfd, packet, len, 0, 
-		(struct sockaddr *)&peer, sa_len(&peer)) == -1 && errno == EINTR);
-  
   if (is_err)
     free_transfer(transfer);
   else
@@ -549,63 +576,28 @@
 void check_tftp_listeners(time_t now)
 {
   struct tftp_transfer *transfer, *tmp, **up;
-  ssize_t len;
   
-  struct ack {
-    unsigned short op, block;
-  } *mess = (struct ack *)daemon->packet;
-  
-  /* Check for activity on any existing transfers */
-  for (transfer = daemon->tftp_trans, up = &daemon->tftp_trans; transfer; transfer = tmp)
-    {
-      tmp = transfer->next;
-      
-      prettyprint_addr(&transfer->peer, daemon->addrbuff);
-     
+  /* In single port mode, all packets come via port 69 and tftp_request() */
+  if (!option_bool(OPT_SINGLE_PORT))
+    for (transfer = daemon->tftp_trans; transfer; transfer = transfer->next)
       if (poll_check(transfer->sockfd, POLLIN))
 	{
 	  /* we overwrote the buffer... */
 	  daemon->srv_save = NULL;
-	  
-	  if ((len = recv(transfer->sockfd, daemon->packet, daemon->packet_buff_sz, 0)) >= (ssize_t)sizeof(struct ack))
-	    {
-	      if (ntohs(mess->op) == OP_ACK && ntohs(mess->block) == (unsigned short)transfer->block) 
-		{
-		  /* Got ack, ensure we take the (re)transmit path */
-		  transfer->timeout = now;
-		  transfer->backoff = 0;
-		  if (transfer->block++ != 0)
-		    transfer->offset += transfer->blocksize - transfer->expansion;
-		}
-	      else if (ntohs(mess->op) == OP_ERR)
-		{
-		  char *p = daemon->packet + sizeof(struct ack);
-		  char *end = daemon->packet + len;
-		  char *err = next(&p, end);
-		  
-		  /* Sanitise error message */
-		  if (!err)
-		    err = "";
-		  else
-		    sanitise(err);
-		  
-		  my_syslog(MS_TFTP | LOG_ERR, _("error %d %s received from %s"),
-			    (int)ntohs(mess->block), err, 
-			    daemon->addrbuff);	
-		  
-		  /* Got err, ensure we take abort */
-		  transfer->timeout = now;
-		  transfer->backoff = 100;
-		}
-	    }
+	  handle_tftp(now, transfer, recv(transfer->sockfd, daemon->packet, daemon->packet_buff_sz, 0));
 	}
+
+  for (transfer = daemon->tftp_trans, up = &daemon->tftp_trans; transfer; transfer = tmp)
+    {
+      tmp = transfer->next;
       
       if (difftime(now, transfer->timeout) >= 0.0)
 	{
 	  int endcon = 0;
+	  ssize_t len;
 
 	  /* timeout, retransmit */
-	  transfer->timeout += 1 + (1<<transfer->backoff);
+	  transfer->timeout += 1 + (1<<(transfer->backoff/2));
 	  	  
 	  /* we overwrote the buffer... */
 	  daemon->srv_save = NULL;
@@ -615,22 +607,24 @@
 	      len = tftp_err_oops(daemon->packet, transfer->file->filename);
 	      endcon = 1;
 	    }
-	  /* don't complain about timeout when we're awaiting the last
-	     ACK, some clients never send it */
-	  else if (++transfer->backoff > 7 && len != 0)
+	  else if (++transfer->backoff > 7)
 	    {
-	      endcon = 1;
+	      /* don't complain about timeout when we're awaiting the last
+		 ACK, some clients never send it */
+	      if ((unsigned)len == transfer->blocksize + 4)
+		endcon = 1;
 	      len = 0;
 	    }
 
 	  if (len != 0)
-	    while(sendto(transfer->sockfd, daemon->packet, len, 0, 
-			 (struct sockaddr *)&transfer->peer, sa_len(&transfer->peer)) == -1 && errno == EINTR);
-	  
+	    send_from(transfer->sockfd, !option_bool(OPT_SINGLE_PORT), daemon->packet, len,
+		      &transfer->peer, &transfer->source, transfer->if_index);
+	  	  
 	  if (endcon || len == 0)
 	    {
 	      strcpy(daemon->namebuff, transfer->file->filename);
 	      sanitise(daemon->namebuff);
+	      prettyprint_addr(&transfer->peer, daemon->addrbuff);
 	      my_syslog(MS_TFTP | LOG_INFO, endcon ? _("failed sending %s to %s") : _("sent %s to %s"), daemon->namebuff, daemon->addrbuff);
 	      /* unlink */
 	      *up = tmp;
@@ -649,15 +643,60 @@
       up = &transfer->next;
     }    
 }
+	  
+/* packet in daemon->packet as this is called. */
+static void handle_tftp(time_t now, struct tftp_transfer *transfer, ssize_t len)
+{
+  struct ack {
+    unsigned short op, block;
+  } *mess = (struct ack *)daemon->packet;
+  
+  if (len >= (ssize_t)sizeof(struct ack))
+    {
+      if (ntohs(mess->op) == OP_ACK && ntohs(mess->block) == (unsigned short)transfer->block) 
+	{
+	  /* Got ack, ensure we take the (re)transmit path */
+	  transfer->timeout = now;
+	  transfer->backoff = 0;
+	  if (transfer->block++ != 0)
+	    transfer->offset += transfer->blocksize - transfer->expansion;
+	}
+      else if (ntohs(mess->op) == OP_ERR)
+	{
+	  char *p = daemon->packet + sizeof(struct ack);
+	  char *end = daemon->packet + len;
+	  char *err = next(&p, end);
+	  
+	  prettyprint_addr(&transfer->peer, daemon->addrbuff);
+	  
+	  /* Sanitise error message */
+	  if (!err)
+	    err = "";
+	  else
+	    sanitise(err);
+	  
+	  my_syslog(MS_TFTP | LOG_ERR, _("error %d %s received from %s"),
+		    (int)ntohs(mess->block), err, 
+		    daemon->addrbuff);	
+	  
+	  /* Got err, ensure we take abort */
+	  transfer->timeout = now;
+	  transfer->backoff = 100;
+	}
+    }
+}
 
 static void free_transfer(struct tftp_transfer *transfer)
 {
-  close(transfer->sockfd);
+  if (!option_bool(OPT_SINGLE_PORT))
+    close(transfer->sockfd);
+
   if (transfer->file && (--transfer->file->refcount) == 0)
     {
       close(transfer->file->fd);
       free(transfer->file);
     }
+  
   free(transfer);
 }
 
Index: src/util.c
===================================================================
--- src/util.c	(revision 41436)
+++ src/util.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -320,13 +320,12 @@
 	  s1->in.sin_port == s2->in.sin_port &&
 	  s1->in.sin_addr.s_addr == s2->in.sin_addr.s_addr)
 	return 1;
-#ifdef HAVE_IPV6      
+      
       if (s1->sa.sa_family == AF_INET6 &&
 	  s1->in6.sin6_port == s2->in6.sin6_port &&
 	  s1->in6.sin6_scope_id == s2->in6.sin6_scope_id &&
 	  IN6_ARE_ADDR_EQUAL(&s1->in6.sin6_addr, &s2->in6.sin6_addr))
 	return 1;
-#endif
     }
   return 0;
 }
@@ -336,11 +335,9 @@
 #ifdef HAVE_SOCKADDR_SA_LEN
   return addr->sa.sa_len;
 #else
-#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET6)
     return sizeof(addr->in6);
   else
-#endif
     return sizeof(addr->in); 
 #endif
 }
@@ -437,7 +434,6 @@
   return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);
 } 
 
-#ifdef HAVE_IPV6
 int is_same_net6(struct in6_addr *a, struct in6_addr *b, int prefixlen)
 {
   int pfbytes = prefixlen >> 3;
@@ -476,8 +472,6 @@
     }
 }
 
-#endif
- 
 
 /* returns port number from address */
 int prettyprint_addr(union mysockaddr *addr, char *buf)
@@ -484,7 +478,6 @@
 {
   int port = 0;
   
-#ifdef HAVE_IPV6
   if (addr->sa.sa_family == AF_INET)
     {
       inet_ntop(AF_INET, &addr->in.sin_addr, buf, ADDRSTRLEN);
@@ -503,10 +496,6 @@
 	}
       port = ntohs(addr->in6.sin6_port);
     }
-#else
-  strcpy(buf, inet_ntoa(addr->in.sin_addr));
-  port = ntohs(addr->in.sin_port); 
-#endif
   
   return port;
 }
@@ -535,13 +524,13 @@
 int parse_hex(char *in, unsigned char *out, int maxlen, 
 	      unsigned int *wildcard_mask, int *mac_type)
 {
-  int mask = 0, i = 0;
+  int done = 0, mask = 0, i = 0;
   char *r;
     
   if (mac_type)
     *mac_type = 0;
   
-  while (maxlen == -1 || i < maxlen)
+  while (!done && (maxlen == -1 || i < maxlen))
     {
       for (r = in; *r != 0 && *r != ':' && *r != '-' && *r != ' '; r++)
 	if (*r != '*' && !isxdigit((unsigned char)*r))
@@ -548,7 +537,7 @@
 	  return -1;
       
       if (*r == 0)
-	maxlen = i;
+	done = 1;
       
       if (r != in )
 	{
@@ -716,6 +705,47 @@
   return 1;
 }
 
+/* close all fds except STDIN, STDOUT and STDERR, spare1, spare2 and spare3 */
+void close_fds(long max_fd, int spare1, int spare2, int spare3) 
+{
+  /* On Linux, use the /proc/ filesystem to find which files
+     are actually open, rather than iterate over the whole space,
+     for efficiency reasons. If this fails we drop back to the dumb code. */
+#ifdef HAVE_LINUX_NETWORK 
+  DIR *d;
+  
+  if ((d = opendir("/proc/self/fd")))
+    {
+      struct dirent *de;
+
+      while ((de = readdir(d)))
+	{
+	  long fd;
+	  char *e = NULL;
+	  
+	  errno = 0;
+	  fd = strtol(de->d_name, &e, 10);
+	  	  
+      	  if (errno != 0 || !e || *e || fd == dirfd(d) ||
+	      fd == STDOUT_FILENO || fd == STDERR_FILENO || fd == STDIN_FILENO ||
+	      fd == spare1 || fd == spare2 || fd == spare3)
+	    continue;
+	  
+	  close(fd);
+	}
+      
+      closedir(d);
+      return;
+  }
+#endif
+
+  /* fallback, dumb code. */
+  for (max_fd--; max_fd >= 0; max_fd--)
+    if (max_fd != STDOUT_FILENO && max_fd != STDERR_FILENO && max_fd != STDIN_FILENO &&
+	max_fd != spare1 && max_fd != spare2 && max_fd != spare3)
+      close(max_fd);
+}
+
 /* Basically match a string value against a wildcard pattern.  */
 int wildcard_match(const char* wildcard, const char* match)
 {
Index: src/dump.c
===================================================================
--- src/dump.c	(revision 41436)
+++ src/dump.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -82,10 +82,8 @@
 void dump_packet(int mask, void *packet, size_t len, union mysockaddr *src, union mysockaddr *dst)
 {
   struct ip ip;
-#ifdef HAVE_IPV6
   struct ip6_hdr ip6;
   int family;
-#endif
   struct udphdr {
     u16 uh_sport;               /* source port */
     u16 uh_dport;               /* destination port */
@@ -105,7 +103,6 @@
   /* So wireshark can Id the packet. */
   udp.uh_sport = udp.uh_dport = htons(NAMESERVER_PORT);
 
-#ifdef HAVE_IPV6
   if (src)
     family = src->sa.sa_family;
   else
@@ -135,11 +132,14 @@
 	}
             
       /* start UDP checksum */
-      for (sum = 0, i = 0; i < IN6ADDRSZ; i++)
-	sum += ((u16 *)&ip6.ip6_src)[i];
+      for (sum = 0, i = 0; i < IN6ADDRSZ; i+=2)
+	{
+	  sum += ip6.ip6_src.s6_addr[i] + (ip6.ip6_src.s6_addr[i+1] << 8) ;
+	  sum += ip6.ip6_dst.s6_addr[i] + (ip6.ip6_dst.s6_addr[i+1] << 8) ;
+	  
+	}
     }
   else
-#endif
     {
       iphdr = &ip;
       ipsz = sizeof(ip);
Index: src/dhcp6.c
===================================================================
--- src/dhcp6.c	(revision 41436)
+++ src/dhcp6.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -135,8 +135,15 @@
   if (!indextoname(daemon->dhcp6fd, if_index, ifr.ifr_name))
     return;
 
-  if ((port = relay_reply6(&from, sz, ifr.ifr_name)) == 0)
+  if ((port = relay_reply6(&from, sz, ifr.ifr_name)) != 0)
     {
+      from.sin6_port = htons(port);
+      while (retry_send(sendto(daemon->dhcp6fd, daemon->outpacket.iov_base, 
+			       save_counter(-1), 0, (struct sockaddr *)&from, 
+			       sizeof(from))));
+    }
+  else
+    {
       struct dhcp_bridge *bridge, *alias;
 
       for (tmp = daemon->if_except; tmp; tmp = tmp->next)
@@ -233,21 +240,23 @@
       port = dhcp6_reply(parm.current, if_index, ifr.ifr_name, &parm.fallback, 
 			 &parm.ll_addr, &parm.ula_addr, sz, &from.sin6_addr, now);
       
+      /* The port in the source address of the original request should
+	 be correct, but at least once client sends from the server port,
+	 so we explicitly send to the client port to a client, and the
+	 server port to a relay. */
+      if (port != 0)
+	{
+	  from.sin6_port = htons(port);
+	  while (retry_send(sendto(daemon->dhcp6fd, daemon->outpacket.iov_base, 
+				   save_counter(-1), 0, (struct sockaddr *)&from, 
+				   sizeof(from))));
+	}
+
+      /* These need to be called _after_ we send DHCPv6 packet, since lease_update_file()
+	 may trigger sending an RA packet, which overwrites our buffer. */
       lease_update_file(now);
       lease_update_dns(0);
     }
-			  
-  /* The port in the source address of the original request should
-     be correct, but at least once client sends from the server port,
-     so we explicitly send to the client port to a client, and the
-     server port to a relay. */
-  if (port != 0)
-    {
-      from.sin6_port = htons(port);
-      while (retry_send(sendto(daemon->dhcp6fd, daemon->outpacket.iov_base, 
-			       save_counter(0), 0, (struct sockaddr *)&from, 
-			       sizeof(from))));
-    }
 }
 
 void get_client_mac(struct in6_addr *client, int iface, unsigned char *mac, unsigned int *maclenp, unsigned int *mactypep, time_t now)
@@ -299,6 +308,7 @@
 			     unsigned int valid, void *vparam)
 {
   struct dhcp_context *context;
+  struct shared_network *share;
   struct dhcp_relay *relay;
   struct iface_param *param = vparam;
   struct iname *tmp;
@@ -305,100 +315,129 @@
  
   (void)scope; /* warning */
   
-  if (if_index == param->ind)
-    {
-      if (IN6_IS_ADDR_LINKLOCAL(local))
-	param->ll_addr = *local;
-      else if (IN6_IS_ADDR_ULA(local))
-	param->ula_addr = *local;
-
-      if (!IN6_IS_ADDR_LOOPBACK(local) &&
-	  !IN6_IS_ADDR_LINKLOCAL(local) &&
-	  !IN6_IS_ADDR_MULTICAST(local))
-	{
-	  /* if we have --listen-address config, see if the 
-	     arrival interface has a matching address. */
-	  for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
-	    if (tmp->addr.sa.sa_family == AF_INET6 &&
-		IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, local))
-	      param->addr_match = 1;
-	  
-	  /* Determine a globally address on the arrival interface, even
-	     if we have no matching dhcp-context, because we're only
-	     allocating on remote subnets via relays. This
-	     is used as a default for the DNS server option. */
-	  param->fallback = *local;
-	  
-	  for (context = daemon->dhcp6; context; context = context->next)
-	    {
-	      if ((context->flags & CONTEXT_DHCP) &&
-		  !(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
-		  prefix <= context->prefix &&
-		  is_same_net6(local, &context->start6, context->prefix) &&
-		  is_same_net6(local, &context->end6, context->prefix))
-		{
-		  
-		  
-		  /* link it onto the current chain if we've not seen it before */
-		  if (context->current == context)
-		    {
-		      struct dhcp_context *tmp, **up;
-		      
-		      /* use interface values only for constructed contexts */
-		      if (!(context->flags & CONTEXT_CONSTRUCTED))
-			preferred = valid = 0xffffffff;
-		      else if (flags & IFACE_DEPRECATED)
-			preferred = 0;
-		      
-		      if (context->flags & CONTEXT_DEPRECATE)
-			preferred = 0;
-		      
-		      /* order chain, longest preferred time first */
-		      for (up = &param->current, tmp = param->current; tmp; tmp = tmp->current)
-			if (tmp->preferred <= preferred)
-			  break;
-			else
-			  up = &tmp->current;
-		      
-		      context->current = *up;
-		      *up = context;
-		      context->local6 = *local;
-		      context->preferred = preferred;
-		      context->valid = valid;
-		    }
-		}
-	    }
-	}
-
-      for (relay = daemon->relay6; relay; relay = relay->next)
-	if (IN6_ARE_ADDR_EQUAL(local, &relay->local.addr.addr6) && relay->current == relay &&
-	    (IN6_IS_ADDR_UNSPECIFIED(&param->relay_local) || IN6_ARE_ADDR_EQUAL(local, &param->relay_local)))
+  if (if_index != param->ind)
+    return 1;
+  
+  if (IN6_IS_ADDR_LINKLOCAL(local))
+    param->ll_addr = *local;
+  else if (IN6_IS_ADDR_ULA(local))
+    param->ula_addr = *local;
+      
+  if (IN6_IS_ADDR_LOOPBACK(local) ||
+      IN6_IS_ADDR_LINKLOCAL(local) ||
+      IN6_IS_ADDR_MULTICAST(local))
+    return 1;
+  
+  /* if we have --listen-address config, see if the 
+     arrival interface has a matching address. */
+  for (tmp = daemon->if_addrs; tmp; tmp = tmp->next)
+    if (tmp->addr.sa.sa_family == AF_INET6 &&
+	IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, local))
+      param->addr_match = 1;
+  
+  /* Determine a globally address on the arrival interface, even
+     if we have no matching dhcp-context, because we're only
+     allocating on remote subnets via relays. This
+     is used as a default for the DNS server option. */
+  param->fallback = *local;
+  
+  for (context = daemon->dhcp6; context; context = context->next)
+    if ((context->flags & CONTEXT_DHCP) &&
+	!(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
+	prefix <= context->prefix &&
+	context->current == context)
+      {
+	if (is_same_net6(local, &context->start6, context->prefix) &&
+	    is_same_net6(local, &context->end6, context->prefix))
 	  {
-	    relay->current = param->relay;
-	    param->relay = relay;
-	    param->relay_local = *local;
+	    struct dhcp_context *tmp, **up;
+	    
+	    /* use interface values only for constructed contexts */
+	    if (!(context->flags & CONTEXT_CONSTRUCTED))
+	      preferred = valid = 0xffffffff;
+	    else if (flags & IFACE_DEPRECATED)
+	      preferred = 0;
+		    
+	    if (context->flags & CONTEXT_DEPRECATE)
+	      preferred = 0;
+	    
+	    /* order chain, longest preferred time first */
+	    for (up = &param->current, tmp = param->current; tmp; tmp = tmp->current)
+	      if (tmp->preferred <= preferred)
+		break;
+	      else
+		up = &tmp->current;
+	    
+	    context->current = *up;
+	    *up = context;
+	    context->local6 = *local;
+	    context->preferred = preferred;
+	    context->valid = valid;
 	  }
-      
-    }          
- 
- return 1;
+	else
+	  {
+	    for (share = daemon->shared_networks; share; share = share->next)
+	      {
+		/* IPv4 shared_address - ignore */
+		if (share->shared_addr.s_addr != 0)
+		  continue;
+			
+		if (share->if_index != 0)
+		  {
+		    if (share->if_index != if_index)
+		      continue;
+		  }
+		else
+		  {
+		    if (!IN6_ARE_ADDR_EQUAL(&share->match_addr6, local))
+		      continue;
+		  }
+		
+		if (is_same_net6(&share->shared_addr6, &context->start6, context->prefix) &&
+		    is_same_net6(&share->shared_addr6, &context->end6, context->prefix))
+		  {
+		    context->current = param->current;
+		    param->current = context;
+		    context->local6 = *local;
+		    context->preferred = context->flags & CONTEXT_DEPRECATE ? 0 :0xffffffff;
+		    context->valid = 0xffffffff;
+		  }
+	      }
+	  }      
+      }
+
+  for (relay = daemon->relay6; relay; relay = relay->next)
+    if (IN6_ARE_ADDR_EQUAL(local, &relay->local.addr6) && relay->current == relay &&
+	(IN6_IS_ADDR_UNSPECIFIED(&param->relay_local) || IN6_ARE_ADDR_EQUAL(local, &param->relay_local)))
+      {
+	relay->current = param->relay;
+	param->relay = relay;
+	param->relay_local = *local;
+      }
+     
+  return 1;
 }
 
-struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, int prefix, u64 addr)
+struct dhcp_config *config_find_by_address6(struct dhcp_config *configs, struct in6_addr *net, int prefix,  struct in6_addr *addr)
 {
   struct dhcp_config *config;
   
   for (config = configs; config; config = config->next)
-    if ((config->flags & CONFIG_ADDR6) &&
-	is_same_net6(&config->addr6, net, prefix) &&
-	(prefix == 128 || addr6part(&config->addr6) == addr))
-      return config;
+    if (config->flags & CONFIG_ADDR6)
+      {
+	struct addrlist *addr_list;
+	
+	for (addr_list = config->addr6; addr_list; addr_list = addr_list->next)
+	  if ((!net || is_same_net6(&addr_list->addr.addr6, net, prefix) || ((addr_list->flags & ADDRLIST_WILDCARD) && prefix == 64)) &&
+	      is_same_net6(&addr_list->addr.addr6, addr, (addr_list->flags & ADDRLIST_PREFIX) ? addr_list->prefixlen : 128))
+	    return config;
+      }
   
   return NULL;
 }
 
 struct dhcp_context *address6_allocate(struct dhcp_context *context,  unsigned char *clid, int clid_len, int temp_addr,
-				       int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans)   
+				       unsigned int iaid, int serial, struct dhcp_netid *netids, int plain_range, struct in6_addr *ans)
 {
   /* Find a free address: exclude anything in use and anything allocated to
      a particular hwaddr/clientid/hostname in our configuration.
@@ -431,8 +470,15 @@
       else
 	{ 
 	  if (!temp_addr && option_bool(OPT_CONSEC_ADDR))
-	    /* seed is largest extant lease addr in this context */
-	    start = lease_find_max_addr6(c) + serial;
+	    {
+	      /* seed is largest extant lease addr in this context,
+		 skip addresses equal to the number of addresses rejected
+		 by clients. This should avoid the same client being offered the same
+		 address after it has rjected it. */
+	      start = lease_find_max_addr6(c) + 1 + serial + c->addr_epoch;
+	      if (c->addr_epoch)
+		c->addr_epoch--;
+	    }
 	  else
 	    {
 	      u64 range = 1 + addr6part(&c->end6) - addr6part(&c->start6);
@@ -453,16 +499,15 @@
 	    for (d = context; d; d = d->current)
 	      if (addr == addr6part(&d->local6))
 		break;
+	    
+	    *ans = c->start6;
+	    setaddr6part (ans, addr);
 
 	    if (!d &&
 		!lease6_find_by_addr(&c->start6, c->prefix, addr) && 
-		!config_find_by_address6(daemon->dhcp_conf, &c->start6, c->prefix, addr))
-	      {
-		*ans = c->start6;
-		setaddr6part (ans, addr);
-		return c;
-	      }
-	
+		!config_find_by_address6(daemon->dhcp_conf, &c->start6, c->prefix, ans))
+	      return c;
+	    
 	    addr++;
 	    
 	    if (addr  == addr6part(&c->end6) + 1)
@@ -516,27 +561,6 @@
   return NULL;
 }
 
-int config_valid(struct dhcp_config *config, struct dhcp_context *context, struct in6_addr *addr)
-{
-  if (!config || !(config->flags & CONFIG_ADDR6))
-    return 0;
-
-  if ((config->flags & CONFIG_WILDCARD) && context->prefix == 64)
-    {
-      *addr = context->start6;
-      setaddr6part(addr, addr6part(&config->addr6));
-      return 1;
-    }
-  
-  if (is_same_net6(&context->start6, &config->addr6, context->prefix))
-    {
-      *addr = config->addr6;
-      return 1;
-    }
-  
-  return 0;
-}
-
 void make_duid(time_t now)
 {
   (void)now;
@@ -617,7 +641,8 @@
   char ifrn_name[IFNAMSIZ];
   struct in6_addr start6, end6;
   struct dhcp_context *template, *context;
-
+  struct iname *tmp;
+  
   (void)scope;
   (void)flags;
   (void)valid;
@@ -636,9 +661,15 @@
   if (flags & IFACE_DEPRECATED)
     return 1;
 
-  if (!indextoname(daemon->icmp6fd, if_index, ifrn_name))
-    return 0;
+  /* Ignore interfaces where we're not doing RA/DHCP6 */
+  if (!indextoname(daemon->icmp6fd, if_index, ifrn_name) ||
+      !iface_check(AF_LOCAL, NULL, ifrn_name, NULL))
+    return 1;
   
+  for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+    if (tmp->name && wildcard_match(tmp->name, ifrn_name))
+      return 1;
+
   for (template = daemon->dhcp6; template; template = template->next)
     if (!(template->flags & (CONTEXT_TEMPLATE | CONTEXT_CONSTRUCTED)))
       {
@@ -648,7 +679,7 @@
 	    is_same_net6(local, &template->end6, template->prefix))
 	  {
 	    /* First time found, do fast RA. */
-	    if (template->if_index != if_index || !IN6_ARE_ADDR_EQUAL(&template->local6, local))
+	    if (template->if_index == 0)
 	      {
 		ra_start_unsolicited(param->now, template);
 		param->newone = 1;
Index: src/dhcp-protocol.h
===================================================================
--- src/dhcp-protocol.h	(revision 41436)
+++ src/dhcp-protocol.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/domain.c
===================================================================
--- src/domain.c	(revision 41436)
+++ src/domain.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -18,22 +18,15 @@
 
 
 static struct cond_domain *search_domain(struct in_addr addr, struct cond_domain *c);
-#ifdef HAVE_IPV6
 static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c);
-#endif
 
 
-int is_name_synthetic(int flags, char *name, struct all_addr *addr)
+int is_name_synthetic(int flags, char *name, union all_addr *addr)
 {
   char *p;
   struct cond_domain *c = NULL;
-  int prot = AF_INET;
+  int prot = (flags & F_IPV6) ? AF_INET6 : AF_INET;
 
-#ifdef HAVE_IPV6
-  if (flags & F_IPV6)
-    prot = AF_INET6;
-#endif
-
   for (c = daemon->synth_domains; c; c = c->next)
     {
       int found = 0;
@@ -80,11 +73,10 @@
 		   if (!c->is6 &&
 		      index <= ntohl(c->end.s_addr) - ntohl(c->start.s_addr))
 		    {
-		      addr->addr.addr4.s_addr = htonl(ntohl(c->start.s_addr) + index);
+		      addr->addr4.s_addr = htonl(ntohl(c->start.s_addr) + index);
 		      found = 1;
 		    }
-		}
-#ifdef HAVE_IPV6 
+		} 
 	      else
 		{
 		  u64 index = atoll(tail);
@@ -93,12 +85,11 @@
 		      index <= addr6part(&c->end6) - addr6part(&c->start6))
 		    {
 		      u64 start = addr6part(&c->start6);
-		      addr->addr.addr6 = c->start6;
-		      setaddr6part(&addr->addr.addr6, start + index);
+		      addr->addr6 = c->start6;
+		      setaddr6part(&addr->addr6, start + index);
 		      found = 1;
 		    }
 		}
-#endif
 	    }
 	}
       else
@@ -111,10 +102,8 @@
 	      if ((c >='0' && c <= '9') || c == '-')
 		continue;
 	      
-#ifdef HAVE_IPV6
 	      if (prot == AF_INET6 && ((c >='A' && c <= 'F') || (c >='a' && c <= 'f'))) 
 		continue;
-#endif
 	      
 	      break;
 	    }
@@ -124,7 +113,6 @@
 	  
 	  *p = 0;	
 	  
-#ifdef HAVE_IPV6
 	  if (prot == AF_INET6 && strstr(tail, "--ffff-") == tail)
 	    {
 	      /* special hack for v4-mapped. */
@@ -134,7 +122,6 @@
 		  *p = '.';
 	    }
 	  else
-#endif
 	    {
 	      /* swap . or : for - */
 	      for (p = tail; *p; p++)
@@ -142,10 +129,8 @@
 		  {
 		    if (prot == AF_INET)
 		      *p = '.';
-#ifdef HAVE_IPV6
 		    else
 		      *p = ':';
-#endif
 		  }
 	    }
 	  
@@ -154,22 +139,20 @@
 	      if (prot == AF_INET)
 		{
 		  if (!c->is6 &&
-		      ntohl(addr->addr.addr4.s_addr) >= ntohl(c->start.s_addr) &&
-		      ntohl(addr->addr.addr4.s_addr) <= ntohl(c->end.s_addr))
+		      ntohl(addr->addr4.s_addr) >= ntohl(c->start.s_addr) &&
+		      ntohl(addr->addr4.s_addr) <= ntohl(c->end.s_addr))
 		    found = 1;
 		}
-#ifdef HAVE_IPV6
 	      else
 		{
-		  u64 addrpart = addr6part(&addr->addr.addr6);
+		  u64 addrpart = addr6part(&addr->addr6);
 		  
 		  if (c->is6 &&
-		      is_same_net6(&addr->addr.addr6, &c->start6, 64) &&
+		      is_same_net6(&addr->addr6, &c->start6, 64) &&
 		      addrpart >= addr6part(&c->start6) &&
 		      addrpart <= addr6part(&c->end6))
 		    found = 1;
 		}
-#endif
 	    }
 
 	}
@@ -190,11 +173,11 @@
 }
 
 
-int is_rev_synth(int flag, struct all_addr *addr, char *name)
+int is_rev_synth(int flag, union all_addr *addr, char *name)
 {
    struct cond_domain *c;
 
-   if (flag & F_IPV4 && (c = search_domain(addr->addr.addr4, daemon->synth_domains))) 
+   if (flag & F_IPV4 && (c = search_domain(addr->addr4, daemon->synth_domains))) 
      {
        char *p;
        
@@ -201,7 +184,7 @@
        *name = 0;
        if (c->indexed)
 	 {
-	   unsigned int index = ntohl(addr->addr.addr4.s_addr) - ntohl(c->start.s_addr);
+	   unsigned int index = ntohl(addr->addr4.s_addr) - ntohl(c->start.s_addr);
 	   snprintf(name, MAXDNAME, "%s%u", c->prefix ? c->prefix : "", index);
 	 }
        else
@@ -209,7 +192,7 @@
 	   if (c->prefix)
 	     strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
        
-       	   inet_ntop(AF_INET, &addr->addr.addr4, name + strlen(name), ADDRSTRLEN);
+       	   inet_ntop(AF_INET, &addr->addr4, name + strlen(name), ADDRSTRLEN);
 	   for (p = name; *p; p++)
 	     if (*p == '.')
 	       *p = '-';
@@ -221,8 +204,7 @@
        return 1;
      }
 
-#ifdef HAVE_IPV6
-   if (flag & F_IPV6 && (c = search_domain6(&addr->addr.addr6, daemon->synth_domains))) 
+   if ((flag & F_IPV6) && (c = search_domain6(&addr->addr6, daemon->synth_domains))) 
      {
        char *p;
        
@@ -229,7 +211,7 @@
        *name = 0;
        if (c->indexed)
 	 {
-	   u64 index = addr6part(&addr->addr.addr6) - addr6part(&c->start6);
+	   u64 index = addr6part(&addr->addr6) - addr6part(&c->start6);
 	   snprintf(name, MAXDNAME, "%s%llu", c->prefix ? c->prefix : "", index);
 	 }
        else
@@ -237,7 +219,7 @@
 	   if (c->prefix)
 	     strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);
        
-	   inet_ntop(AF_INET6, &addr->addr.addr6, name + strlen(name), ADDRSTRLEN);
+	   inet_ntop(AF_INET6, &addr->addr6, name + strlen(name), ADDRSTRLEN);
 
 	   /* IPv6 presentation address can start with ":", but valid domain names
 	      cannot start with "-" so prepend a zero in that case. */
@@ -244,7 +226,7 @@
 	   if (!c->prefix && *name == ':')
 	     {
 	       *name = '0';
-	       inet_ntop(AF_INET6, &addr->addr.addr6, name+1, ADDRSTRLEN);
+	       inet_ntop(AF_INET6, &addr->addr6, name+1, ADDRSTRLEN);
 	     }
 	   
 	   /* V4-mapped have periods.... */
@@ -259,7 +241,6 @@
        
        return 1;
      }
-#endif
    
    return 0;
 }
@@ -286,7 +267,7 @@
   return daemon->domain_suffix;
 } 
 
-#ifdef HAVE_IPV6
+
 static struct cond_domain *search_domain6(struct in6_addr *addr, struct cond_domain *c)
 {
   u64 addrpart = addr6part(addr);
@@ -310,4 +291,3 @@
 
   return daemon->domain_suffix;
 } 
-#endif
Index: src/arp.c
===================================================================
--- src/arp.c	(revision 41436)
+++ src/arp.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -28,7 +28,7 @@
   unsigned short hwlen, status;
   int family;
   unsigned char hwaddr[DHCP_CHADDR_MAX]; 
-  struct all_addr addr;
+  union all_addr addr;
   struct arp_record *next;
 };
 
@@ -44,11 +44,6 @@
   if (maclen > DHCP_CHADDR_MAX)
     return 1;
 
-#ifndef HAVE_IPV6
-  if (family != AF_INET)
-    return 1;
-#endif
-
   /* Look for existing entry */
   for (arp = arps; arp; arp = arp->next)
     {
@@ -57,16 +52,14 @@
       
       if (family == AF_INET)
 	{
-	  if (arp->addr.addr.addr4.s_addr != ((struct in_addr *)addrp)->s_addr)
+	  if (arp->addr.addr4.s_addr != ((struct in_addr *)addrp)->s_addr)
 	    continue;
 	}
-#ifdef HAVE_IPV6
       else
 	{
-	  if (!IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, (struct in6_addr *)addrp))
+	  if (!IN6_ARE_ADDR_EQUAL(&arp->addr.addr6, (struct in6_addr *)addrp))
 	    continue;
 	}
-#endif
 
       if (arp->status == ARP_EMPTY)
 	{
@@ -102,11 +95,9 @@
       arp->family = family;
       memcpy(arp->hwaddr, mac, maclen);
       if (family == AF_INET)
-	arp->addr.addr.addr4.s_addr = ((struct in_addr *)addrp)->s_addr;
-#ifdef HAVE_IPV6
+	arp->addr.addr4.s_addr = ((struct in_addr *)addrp)->s_addr;
       else
-	memcpy(&arp->addr.addr.addr6, addrp, IN6ADDRSZ);
-#endif
+	memcpy(&arp->addr.addr6, addrp, IN6ADDRSZ);
     }
   
   return 1;
@@ -133,14 +124,12 @@
 	    continue;
 	    
 	  if (arp->family == AF_INET &&
-	      arp->addr.addr.addr4.s_addr != addr->in.sin_addr.s_addr)
+	      arp->addr.addr4.s_addr != addr->in.sin_addr.s_addr)
 	    continue;
 	    
-#ifdef HAVE_IPV6
 	  if (arp->family == AF_INET6 && 
-	      !IN6_ARE_ADDR_EQUAL(&arp->addr.addr.addr6, &addr->in6.sin6_addr))
+	      !IN6_ARE_ADDR_EQUAL(&arp->addr.addr6, &addr->in6.sin6_addr))
 	    continue;
-#endif
 	  
 	  /* Only accept positive entries unless in lazy mode. */
 	  if (arp->status != ARP_EMPTY || lazy || updated)
@@ -202,11 +191,9 @@
       arp->hwlen = 0;
 
       if (addr->sa.sa_family == AF_INET)
-	arp->addr.addr.addr4.s_addr = addr->in.sin_addr.s_addr;
-#ifdef HAVE_IPV6
+	arp->addr.addr4.s_addr = addr->in.sin_addr.s_addr;
       else
-	memcpy(&arp->addr.addr.addr6, &addr->in6.sin6_addr, IN6ADDRSZ);
-#endif
+	memcpy(&arp->addr.addr6, &addr->in6.sin6_addr, IN6ADDRSZ);
     }
 	  
    return 0;
Index: src/blockdata.c
===================================================================
--- src/blockdata.c	(revision 41436)
+++ src/blockdata.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -16,8 +16,6 @@
 
 #include "dnsmasq.h"
 
-#ifdef HAVE_DNSSEC
-
 static struct blockdata *keyblock_free;
 static unsigned int blockdata_count, blockdata_hwm, blockdata_alloced;
 
@@ -54,14 +52,13 @@
 
 void blockdata_report(void)
 {
-  if (option_bool(OPT_DNSSEC_VALID))
-    my_syslog(LOG_INFO, _("DNSSEC memory in use %u, max %u, allocated %u"), 
-	      blockdata_count * sizeof(struct blockdata),  
-	      blockdata_hwm * sizeof(struct blockdata),  
-	      blockdata_alloced * sizeof(struct blockdata));
+  my_syslog(LOG_INFO, _("pool memory in use %u, max %u, allocated %u"), 
+	    blockdata_count * sizeof(struct blockdata),  
+	    blockdata_hwm * sizeof(struct blockdata),  
+	    blockdata_alloced * sizeof(struct blockdata));
 } 
 
-struct blockdata *blockdata_alloc(char *data, size_t len)
+static struct blockdata *blockdata_alloc_real(int fd, char *data, size_t len)
 {
   struct blockdata *block, *ret = NULL;
   struct blockdata **prev = &ret;
@@ -89,8 +86,17 @@
 	blockdata_hwm = blockdata_count; 
       
       blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
-      memcpy(block->key, data, blen);
-      data += blen;
+      if (data)
+	{
+	  memcpy(block->key, data, blen);
+	  data += blen;
+	}
+      else if (!read_write(fd, block->key, blen, 1))
+	{
+	  /* failed read free partial chain */
+	  blockdata_free(ret);
+	  return NULL;
+	}
       len -= blen;
       *prev = block;
       prev = &block->next;
@@ -100,6 +106,10 @@
   return ret;
 }
 
+struct blockdata *blockdata_alloc(char *data, size_t len)
+{
+  return blockdata_alloc_real(0, data, len);
+}
 
 void blockdata_free(struct blockdata *blocks)
 {
@@ -148,5 +158,20 @@
 
   return data;
 }
- 
-#endif
+
+
+void blockdata_write(struct blockdata *block, size_t len, int fd)
+{
+  for (; len > 0 && block; block = block->next)
+    {
+      size_t blen = len > KEYBLOCK_LEN ? KEYBLOCK_LEN : len;
+      read_write(fd, block->key, blen, 0);
+      len -= blen;
+    }
+}
+
+struct blockdata *blockdata_read(int fd, size_t len)
+{
+  return blockdata_alloc_real(fd, NULL, len);
+}
+
Index: src/conntrack.c
===================================================================
--- src/conntrack.c	(revision 41436)
+++ src/conntrack.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
 
 static int callback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct, void *data);
 
-int get_incoming_mark(union mysockaddr *peer_addr, struct all_addr *local_addr, int istcp, unsigned int *markp)
+int get_incoming_mark(union mysockaddr *peer_addr, union all_addr *local_addr, int istcp, unsigned int *markp)
 {
   struct nf_conntrack *ct;
   struct nfct_handle *h;
@@ -36,21 +36,19 @@
       nfct_set_attr_u8(ct, ATTR_L4PROTO, istcp ? IPPROTO_TCP : IPPROTO_UDP);
       nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(daemon->port));
       
-#ifdef HAVE_IPV6
       if (peer_addr->sa.sa_family == AF_INET6)
 	{
 	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
 	  nfct_set_attr(ct, ATTR_IPV6_SRC, peer_addr->in6.sin6_addr.s6_addr);
 	  nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in6.sin6_port);
-	  nfct_set_attr(ct, ATTR_IPV6_DST, local_addr->addr.addr6.s6_addr);
+	  nfct_set_attr(ct, ATTR_IPV6_DST, local_addr->addr6.s6_addr);
 	}
       else
-#endif
 	{
 	  nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
 	  nfct_set_attr_u32(ct, ATTR_IPV4_SRC, peer_addr->in.sin_addr.s_addr);
 	  nfct_set_attr_u16(ct, ATTR_PORT_SRC, peer_addr->in.sin_port);
-	  nfct_set_attr_u32(ct, ATTR_IPV4_DST, local_addr->addr.addr4.s_addr);
+	  nfct_set_attr_u32(ct, ATTR_IPV4_DST, local_addr->addr4.s_addr);
 	}
       
       
Index: src/dhcp6-protocol.h
===================================================================
--- src/dhcp6-protocol.h	(revision 41436)
+++ src/dhcp6-protocol.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -59,13 +59,13 @@
 #define OPTION6_REMOTE_ID       37
 #define OPTION6_SUBSCRIBER_ID   38
 #define OPTION6_FQDN            39
+#define OPTION6_NTP_SERVER      56
 #define OPTION6_CLIENT_MAC      79
 
-/* replace this with the real number when allocated.
-   defining this also enables the relevant code. */ 
-/* #define OPTION6_PREFIX_CLASS    99 */
+#define NTP_SUBOPTION_SRV_ADDR  1
+#define NTP_SUBOPTION_MC_ADDR   2
+#define NTP_SUBOPTION_SRV_FQDN  3
 
-
 #define DHCP6SUCCESS     0
 #define DHCP6UNSPEC      1
 #define DHCP6NOADDRS     2
Index: src/edns0.c
===================================================================
--- src/edns0.c	(revision 41436)
+++ src/edns0.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -301,20 +301,14 @@
 
 struct subnet_opt {
   u16 family;
-  u8 source_netmask, scope_netmask;
-#ifdef HAVE_IPV6 
+  u8 source_netmask, scope_netmask; 
   u8 addr[IN6ADDRSZ];
-#else
-  u8 addr[INADDRSZ];
-#endif
 };
 
 static void *get_addrp(union mysockaddr *addr, const short family) 
 {
-#ifdef HAVE_IPV6
   if (family == AF_INET6)
     return &addr->in6.sin6_addr;
-#endif
 
   return &addr->in.sin_addr;
 }
@@ -330,7 +324,6 @@
   opt->source_netmask = 0;
   opt->scope_netmask = 0;
 
-#ifdef HAVE_IPV6
   if (source->sa.sa_family == AF_INET6 && daemon->add_subnet6)
     {
       opt->source_netmask = daemon->add_subnet6->mask;
@@ -342,7 +335,6 @@
       else 
 	addrp = &source->in6.sin6_addr;
     }
-#endif
 
   if (source->sa.sa_family == AF_INET && daemon->add_subnet4)
     {
@@ -356,11 +348,7 @@
 	  addrp = &source->in.sin_addr;
     }
   
-#ifdef HAVE_IPV6
   opt->family = htons(sa_family == AF_INET6 ? 2 : 1);
-#else
-  opt->family = htons(1);
-#endif
   
   len = 0;
   
Index: src/helper.c
===================================================================
--- src/helper.c	(revision 41436)
+++ src/helper.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -64,11 +64,10 @@
 #ifdef HAVE_TFTP
   off_t file_len;
 #endif
-#ifdef HAVE_IPV6
   struct in6_addr addr6;
-#endif
 #ifdef HAVE_DHCP6
-  int iaid, vendorclass_count;
+  int vendorclass_count;
+  unsigned int iaid;
 #endif
   unsigned char hwaddr[DHCP_CHADDR_MAX];
   char interface[IF_NAMESIZE];
@@ -82,7 +81,8 @@
   pid_t pid;
   int i, pipefd[2];
   struct sigaction sigact;
-
+  unsigned char *alloc_buff = NULL;
+  
   /* create the pipe through which the main program sends us commands,
      then fork our process. */
   if (pipe(pipefd) == -1 || !fix_fd(pipefd[1]) || (pid = fork()) == -1)
@@ -131,12 +131,8 @@
      Don't close err_fd, in case the lua-init fails.
      Note that we have to do this before lua init
      so we don't close any lua fds. */
-  for (max_fd--; max_fd >= 0; max_fd--)
-    if (max_fd != STDOUT_FILENO && max_fd != STDERR_FILENO && 
-	max_fd != STDIN_FILENO && max_fd != pipefd[0] && 
-	max_fd != event_fd && max_fd != err_fd)
-      close(max_fd);
-
+  close_fds(max_fd, pipefd[0], event_fd, err_fd);
+  
 #ifdef HAVE_LUASCRIPT
   if (daemon->luascript)
     {
@@ -188,11 +184,16 @@
       struct script_data data;
       char *p, *action_str, *hostname = NULL, *domain = NULL;
       unsigned char *buf = (unsigned char *)daemon->namebuff;
-      unsigned char *end, *extradata, *alloc_buff = NULL;
+      unsigned char *end, *extradata;
       int is6, err = 0;
       int pipeout[2];
 
-      free(alloc_buff);
+      /* Free rarely-allocated memory from previous iteration. */
+      if (alloc_buff)
+	{
+	  free(alloc_buff);
+	  alloc_buff = NULL;
+	}
       
       /* we read zero bytes when pipe closed: this is our signal to exit */ 
       if (!read_write(pipefd[0], (unsigned char *)&data, sizeof(data), 1))
@@ -302,10 +303,8 @@
     
       if (!is6)
 	inet_ntop(AF_INET, &data.addr, daemon->addrbuff, ADDRSTRLEN);
-#ifdef HAVE_IPV6
       else
 	inet_ntop(AF_INET6, &data.addr6, daemon->addrbuff, ADDRSTRLEN);
-#endif
 
 #ifdef HAVE_TFTP
       /* file length */
@@ -826,10 +825,8 @@
 
   if ((buf->flags = peer->sa.sa_family) == AF_INET)
     buf->addr = peer->in.sin_addr;
-#ifdef HAVE_IPV6
   else
     buf->addr6 = peer->in6.sin6_addr;
-#endif
 
   memcpy((unsigned char *)(buf+1), filename, filename_len);
   
@@ -837,7 +834,7 @@
 }
 #endif
 
-void queue_arp(int action, unsigned char *mac, int maclen, int family, struct all_addr *addr)
+void queue_arp(int action, unsigned char *mac, int maclen, int family, union all_addr *addr)
 {
   /* no script */
   if (daemon->helperfd == -1)
@@ -850,11 +847,9 @@
   buf->hwaddr_len = maclen;
   buf->hwaddr_type =  ARPHRD_ETHER; 
   if ((buf->flags = family) == AF_INET)
-    buf->addr = addr->addr.addr4;
-#ifdef HAVE_IPV6
+    buf->addr = addr->addr4;
   else
-    buf->addr6 = addr->addr.addr6;
-#endif
+    buf->addr6 = addr->addr6;
   
   memcpy(buf->hwaddr, mac, maclen);
   
Index: src/inotify.c
===================================================================
--- src/inotify.c	(revision 41436)
+++ src/inotify.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
  
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/ip6addr.h
===================================================================
--- src/ip6addr.h	(revision 41436)
+++ src/ip6addr.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/loop.c
===================================================================
--- src/loop.c	(revision 41436)
+++ src/loop.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/outpacket.c
===================================================================
--- src/outpacket.c	(revision 41436)
+++ src/outpacket.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/poll.c
===================================================================
--- src/poll.c	(revision 41436)
+++ src/poll.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/radv-protocol.h
===================================================================
--- src/radv-protocol.h	(revision 41436)
+++ src/radv-protocol.h	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/radv.c
===================================================================
--- src/radv.c	(revision 41436)
+++ src/radv.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -288,7 +288,10 @@
       context->netid.next = &context->netid;
     }
 
-  if (!iface_enumerate(AF_INET6, &parm, add_prefixes))
+  /* If no link-local address then we can't advertise since source address of
+     advertisement must be link local address: RFC 4861 para 6.1.2. */
+  if (!iface_enumerate(AF_INET6, &parm, add_prefixes) ||
+      parm.link_pref_time == 0)
     return;
 
   /* Find smallest preferred time within address classes,
@@ -412,7 +415,7 @@
   if (mtu == 0)
     {
       char *mtu_name = ra_param ? ra_param->mtu_name : NULL;
-      sprintf(daemon->namebuff, "/proc/sys/net/ipv6/conf/%s/mtu", mtu_name ? : iface_name);
+      sprintf(daemon->namebuff, "/proc/sys/net/ipv6/conf/%s/mtu", mtu_name ? mtu_name : iface_name);
       if ((f = fopen(daemon->namebuff, "r")))
         {
           if (fgets(daemon->namebuff, MAXDNAME, f))
@@ -888,11 +891,21 @@
 {
   struct search_param *param = vparam;
   struct dhcp_context *context;
-
+  struct iname *tmp;
+  
   (void)scope;
   (void)preferred;
   (void)valid;
- 
+
+  /* ignore interfaces we're not doing DHCP on. */
+  if (!indextoname(daemon->icmp6fd, if_index, param->name) ||
+      !iface_check(AF_LOCAL, NULL, param->name, NULL))
+    return 1;
+
+  for (tmp = daemon->dhcp_except; tmp; tmp = tmp->next)
+    if (tmp->name && wildcard_match(tmp->name, param->name))
+      return 1;
+
   for (context = daemon->dhcp6; context; context = context->next)
     if (!(context->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
 	prefix <= context->prefix &&
@@ -904,17 +917,9 @@
 	/* found an interface that's overdue for RA determine new 
 	   timeout value and arrange for RA to be sent unless interface is
 	   still doing DAD.*/
-	
 	if (!(flags & IFACE_TENTATIVE))
 	  param->iface = if_index;
 	
-	/* should never fail */
-	if (!indextoname(daemon->icmp6fd, if_index, param->name))
-	  {
-	    param->iface = 0;
-	    return 0;
-	  }
-	
 	new_timeout(context, param->name, param->now);
 	
 	/* zero timers for other contexts on the same subnet, so they don't timeout 
Index: src/rrfilter.c
===================================================================
--- src/rrfilter.c	(revision 41436)
+++ src/rrfilter.c	(working copy)
@@ -1,4 +1,4 @@
-/* dnsmasq is Copyright (c) 2000-2018 Simon Kelley
+/* dnsmasq is Copyright (c) 2000-2020 Simon Kelley
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
Index: src/tables.c
===================================================================
--- src/tables.c	(revision 41436)
+++ src/tables.c	(working copy)
@@ -62,7 +62,7 @@
     }
 }
 
-int add_to_ipset(const char *setname, const struct all_addr *ipaddr,
+int add_to_ipset(const char *setname, const union all_addr *ipaddr,
 		 int flags, int remove)
 {
   struct pfr_addr addr;
@@ -108,19 +108,18 @@
     my_syslog(LOG_INFO, _("info: table created"));
  
   bzero(&addr, sizeof(addr));
-#ifdef HAVE_IPV6
+
   if (flags & F_IPV6) 
     {
       addr.pfra_af = AF_INET6;
       addr.pfra_net = 0x80;
-      memcpy(&(addr.pfra_ip6addr), &(ipaddr->addr), sizeof(struct in6_addr));
+      memcpy(&(addr.pfra_ip6addr), ipaddr, sizeof(struct in6_addr));
     } 
   else 
-#endif
     {
       addr.pfra_af = AF_INET;
       addr.pfra_net = 0x20;
-      addr.pfra_ip4addr.s_addr = ipaddr->addr.addr4.s_addr;
+      addr.pfra_ip4addr.s_addr = ipaddr->addr4.s_addr;
     }
 
   bzero(&io, sizeof(io));
Index: src/ipset.c
===================================================================
--- src/ipset.c	(revision 41436)
+++ src/ipset.c	(working copy)
@@ -114,19 +114,14 @@
   die (_("failed to create IPset control socket: %s"), NULL, EC_MISC);
 }
 
-static int new_add_to_ipset(const char *setname, const struct all_addr *ipaddr, int af, int remove)
+static int new_add_to_ipset(const char *setname, const union all_addr *ipaddr, int af, int remove)
 {
   struct nlmsghdr *nlh;
   struct my_nfgenmsg *nfg;
   struct my_nlattr *nested[2];
   uint8_t proto;
-  int addrsz = INADDRSZ;
+  int addrsz = (af == AF_INET6) ? IN6ADDRSZ : INADDRSZ;
 
-#ifdef HAVE_IPV6
-  if (af == AF_INET6)
-    addrsz = IN6ADDRSZ;
-#endif
-    
   if (strlen(setname) >= IPSET_MAXNAMELEN) 
     {
       errno = ENAMETOOLONG;
@@ -157,7 +152,7 @@
   nested[1]->nla_type = NLA_F_NESTED | IPSET_ATTR_IP;
   add_attr(nlh, 
 	   (af == AF_INET ? IPSET_ATTR_IPADDR_IPV4 : IPSET_ATTR_IPADDR_IPV6) | NLA_F_NET_BYTEORDER,
-	   addrsz, &ipaddr->addr);
+	   addrsz, ipaddr);
   nested[1]->nla_len = (void *)buffer + NL_ALIGN(nlh->nlmsg_len) - (void *)nested[1];
   nested[0]->nla_len = (void *)buffer + NL_ALIGN(nlh->nlmsg_len) - (void *)nested[0];
 	
@@ -168,7 +163,7 @@
 }
 
 
-static int old_add_to_ipset(const char *setname, const struct all_addr *ipaddr, int remove)
+static int old_add_to_ipset(const char *setname, const union all_addr *ipaddr, int remove)
 {
   socklen_t size;
   struct ip_set_req_adt_get {
@@ -200,7 +195,7 @@
     return -1;
   req_adt.op = remove ? 0x102 : 0x101;
   req_adt.index = req_adt_get.set.index;
-  req_adt.ip = ntohl(ipaddr->addr.addr4.s_addr);
+  req_adt.ip = ntohl(ipaddr->addr4.s_addr);
   if (setsockopt(ipset_sock, SOL_IP, 83, &req_adt, sizeof(req_adt)) < 0)
     return -1;
   
@@ -209,11 +204,10 @@
 
 
 
-int add_to_ipset(const char *setname, const struct all_addr *ipaddr, int flags, int remove)
+int add_to_ipset(const char *setname, const union all_addr *ipaddr, int flags, int remove)
 {
   int ret = 0, af = AF_INET;
 
-#ifdef HAVE_IPV6
   if (flags & F_IPV6)
     {
       af = AF_INET6;
@@ -224,7 +218,6 @@
 	  ret = -1;
 	}
     }
-#endif
   
   if (ret != -1) 
     ret = old_kernel ? old_add_to_ipset(setname, ipaddr, remove) : new_add_to_ipset(setname, ipaddr, af, remove);
Index: VERSION
===================================================================
--- VERSION	(revision 41436)
+++ VERSION	(working copy)
@@ -1 +1 @@
- (HEAD -> master, tag: v2.80)
+ (HEAD, v2.81rc4, origin/master, origin/HEAD, master)
Index: po/de.po
===================================================================
--- po/de.po	(revision 41436)
+++ po/de.po	(working copy)
@@ -9,10 +9,10 @@
 # Simon Kelley <simon@thekelleys.org.uk>, 2005.
 msgid ""
 msgstr ""
-"Project-Id-Version: dnsmasq 2.80\n"
+"Project-Id-Version: dnsmasq 2.81\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2009-06-18 12:24+0100\n"
-"PO-Revision-Date: 2018-09-29 00:13+0200\n"
+"PO-Revision-Date: 2020-03-08 20:25+0100\n"
 "Last-Translator: Conrad Kostecki <conrad@kostecki.com>\n"
 "Language-Team: German <de@li.org>\n"
 "Language: de\n"
@@ -20,73 +20,73 @@
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Poedit 2.1.1\n"
+"X-Generator: Poedit 2.3\n"
 "X-Poedit-SourceCharset: UTF-8\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr "Interner Fehler im Cache."
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr "Fehler beim Laden der Namen von %s: %s"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr "Fehlerhafte Adresse in %s Zeile %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "Fehlerhafter Name in %s Zeile %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "%s gelesen - %d Adressen"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "Cache geleert"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr "Keine IPv4-Adresse fr %s gefunden"
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr "%s ist ein CNAME, weise es der DHCP-Lease von %s nicht zu"
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "Name %s wurde dem DHCP-Lease von %s nicht zugewiesen, da der Name in %s bereits mit Adresse %s existiert"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr "Zeit %lu"
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "Cache Gre %d, %d/%d Cache-Einfgungen verwendeten nicht abgelaufene Cache-Eintrge wieder."
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr "%u weitergeleitete Anfragen, %u lokal beantwortete Anfragen"
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr "Anfragen nach autoritativen Zonen %u"
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr "Server %s#%d: %u Anfragen gesendet, %u erneut versucht oder fehlgeschlagen"
@@ -100,664 +100,700 @@
 msgid "failed to allocate memory"
 msgstr "Konnte Speicher nicht belegen"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "Speicher nicht verfgbar"
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr "Konnte Pipe nicht erzeugen: %s"
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr "Konnte %d Bytes nicht belegen"
 
 # @Simon: not perfect but I cannot get nearer right now.
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "unendlich"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Lokale abzuhrende Adresse(n) angeben."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "IP-Adresse fr alle Hosts in angegebenen Domnen festlegen."
 
 # FIXME: the English test is not to the point. Just use a shortened description
 # from the manpage instead. -- MA
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Fr private Adressbereiche nach RFC1918 \"keine solche Domain\" liefern."
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Diese IP-Adresse als NXDOMAIN interpretieren (wehrt \"Suchhilfen\" ab)."
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Gre des Caches (Zahl der Eintrge) festlegen (Voreinstellung: %s)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Konfigurationsdatei festlegen (Voreinstellung: %s)."
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "NICHT in den Hintergrund gehen: Betrieb im Debug-Modus."
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "Anfragen ohne Domnen-Teil NICHT weiterschicken."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Fr lokale Eintrge MX-Eintrge liefern, die auf sich selbst zeigen."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Erweitere einfache Namen in /etc/hosts mit der Domnen-Endung."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "'unechte' DNS-Anfragen von Windows-Rechnern nicht weiterleiten."
 
 # @Simon: I'm a bit unsure about "spurious"
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "DHCP fr angegebenen Bereich und Dauer einschalten."
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Nach dem Start in diese Benutzergruppe wechseln (Voreinstellung %s)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Adresse oder Hostnamen fr einen angegebenen Computer setzen."
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr "DHCP-Host-Angaben aus Datei lesen."
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr "DHCP-Optionen aus Datei lesen."
 
-#: option.c:360
+#: option.c:374
 msgid "Read DHCP host specs from a directory."
 msgstr "DHCP-Host-Angaben aus einem Verzeichnis lesen."
 
-#: option.c:361
+#: option.c:375
 msgid "Read DHCP options from a directory."
 msgstr "DHCP-Optionen aus einem Verzeichnis lesen."
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr "Auswertung eines Ausdrucks bedingter Marken."
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "%s-Datei NICHT laden."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Hosts-Datei festlegen, die zustzlich zu %s gelesen wird."
 
-#: option.c:365
+#: option.c:379
 msgid "Read hosts files from a directory."
 msgstr "DHCP-Host-Dateien aus einem Verzeichnis lesen."
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Schnittstelle(n) zum Empfang festlegen."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Schnittstelle(n) festlegen, die NICHT empfangen sollen."
 
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr "DHCP-Benutzerklasse auf Marke abbilden."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr "RFC3046 \"circuit-id\" auf Marke abbilden."
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr "RFC3046 \"remote-id\" auf Marke abbilden."
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr "RFC3993 \"subscriber-id\" auf Marke abbilden."
 
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Kein DHCP fr Hosts mit gesetzter Marke verwenden."
 
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Rundsendung fr Hosts mit gesetzter Marke erzwingen."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "NICHT in den Hintergrund wechseln, NICHT im Debug-Modus laufen."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Voraussetzen, dass wir der einzige DHCP-Server im lokalen Netz sind."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Festlegen, wo DHCP-Leases gespeichert werden (Voreinstellung %s)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "MX-Eintrge fr lokale Hosts liefern."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Einen MX-Eintrag festlegen."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "BOOTP-Optionen fr DHCP-Server festlegen."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "%s-Datei NICHT abfragen, nur bei SIGHUP neu laden."
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "Fehlerhafte Suchergebnisse NICHT zwischenspeichern."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Namensserver streng in der in %s angegebenen Reihenfolge verwenden."
 
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Optionen festlegen, die an DHCP-Klienten gesendet werden."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr "DHCP-Option, die selbst ohne Klientenanfrage gesendet wird."
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Port zum Abhren der DNS-Anfragen festlegen (53 voreingestellt)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Maximale untersttzte UDP-Paketgre fr EDNS.0 (Voreinstellung %s)."
 
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr "DNS-Anfragen protokollieren."
 
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Ausgehenden Port erzwingen fr DNS-Anfragen an vorgelagerte Server."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "Die resolv.conf NICHT lesen."
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Pfad zu resolv.conf festlegen (%s voreingestellt)."
 
-#: option.c:391
+#: option.c:405
 msgid "Specify path to file with server= options"
 msgstr "Dateipfad mit der Option server= angeben"
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Adresse(n) vorgelagerter Server festlegen, optional mit Domnen."
 
-#: option.c:393
+#: option.c:407
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Adresse(n) vorgelagerter Server festlegen, fr reverse Adressanfragen"
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Anfragen fr angegebene Domnen niemals weiterleiten."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Domne festlegen, die fr DHCP-Leases zugewiesen wird."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Voreingestelltes Ziel fr MX-Eintrge festlegen."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Gltigkeitsdauer fr Antworten aus /etc/hosts festlegen."
 
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Gltigkeitsdauer in Sekunden fr Caching negativer Ergebnisse festlegen."
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Gltigkeitsdauer in Sekunden fr Caching negativer Ergebnisse festlegen."
 
-#: option.c:400
+#: option.c:414
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Spezifiziere time-to-live ceiling fr Cache."
 
-#: option.c:401
+#: option.c:415
 msgid "Specify time-to-live floor for cache."
 msgstr "Spezifiziere time-to-live floor fr Cache."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Nach dem Start diese Benutzerrechte annehmen (%s voreingestellt)."
 
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr "DHCP-\"vendor class\" auf Marke abbilden."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "DNSMasq-Version und Urheberrecht anzeigen."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "IPv4-Adressen von vorgelagerten Servern bersetzen."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "SRV-Eintrag festlegen."
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr "Diese Hilfe anzeigen. Benutzen Sie --help dhcp oder --help dhcp6 fr bekannte DHCP-Optionen."
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Dateipfad fr Prozesskennung (PID) festlegen (Voreinstellung: %s)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Hchstzahl der DHCP-Leases festlegen (%s voreingestellt)."
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "DNS-Anfragen abhngig der Emfpangsschnittstelle beantworten."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "DNS-TXT-Eintrag festlegen."
 
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr "DNS-PTR-Eintrag festlegen."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr "Schnittstellennamen zur IPv4-Adresse des Interfaces auflsen."
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Nur an verwendete Schnittstellen binden."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Statische DHCP-Host-Information aus %s lesen."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "DBus-Schnittstelle zum Festlegen vorgelagerter Server usw. festlegen."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr "UBus-Schnittstelle aktivieren."
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "Auf dieser Schnittstelle kein DHCP anbieten, sondern nur DNS."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Dynamische Adressbelegung fr bootp einschalten."
 
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "MAC-Adresse (mit Jokerzeichen) auf Netzmarke abbilden."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr "DHCP-Anfragen von Alias-Schnittstellen fr die Hauptschnittstelle beantworten."
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr "Geben Sie zustzliche Netzwerke an, die eine Broadcast-Domne fr DHCP gemeinsam nutzen"
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr "ICMP-Echo-Adressprfung im DHCP-Server abschalten."
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr "Skript, das bei Erzeugung/Lschung einer DHCP-Lease laufen soll."
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr "Lua-Skript, welches bei Erzeugung/Lschung eines DHCP-Leases laufen soll."
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr "Lease-nderungs-Skript mit den Rechten dieses Nutzers ausfhren."
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr "Rufe dhcp-script mit nderungen an der lokalen ARP-Tabelle auf."
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr "Konfiguration aus allen Dateien in diesem Verzeichnis lesen."
 
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Fr diese Syslog-Anlage oder in Datei loggen (Voreinstellung DAEMON)."
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr "Keine Lease-Datei bentzen."
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Hchstzahl nebenlufiger DNS-Anfragen (%s voreingestellt)."
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr "DNS-Cache beim Neuladen von %s lschen."
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr "Von DHCP-Clients gelieferte Hostnamen ignorieren."
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr "Dateinamen und Server-Datenfehler fr zustzliche DHCP-Optionen NICHT wiederverwenden."
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr "Eingebauten Nur-Lese-TFTP-Server einschalten."
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr "Nur vom festgelegten Unterbaum Dateien per TFTP exportieren."
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr "IP-Adresse oder Hardware-Adresse des Klienten an tftp-root anhngen."
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr "Zugriff nur auf Dateien gestatten, die dem dnsmasq aufrufenden Benutzer gehren."
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr "Der Dienst sollte nicht beendet werden, wenn die TFTP-Verzeichnisse nicht zugreifbar sind."
 
-#: option.c:438
+#: option.c:454
 #, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Maximale Anzahl gleichzeitiger TFTP-bertragungen (%s voreingestellt)."
 
-#: option.c:439
+#: option.c:455
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Maximale MTU fr TFTP-bertragungen erreicht."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr "TFTP-Blockgren-Erweiterung abschalten."
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr "Konvertiere TFTP Dateinamen in Kleinschreibung"
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr "Bereich fr vorbergehende Ports fr TFTP-bertragungen."
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr "Bitte nur einen Port fr den TFTP-Server nutzen."
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr "Erweiterte DHCP-Protokollierung."
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr "Asynchrone Protokollierung einschalten, opt. Warteschlangenlnge festlegen."
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr "DNS-Rebinding unterbinden, private IP-Bereiche bei der Auflsung ausfiltern."
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr "Auflsung zu 127.0.0.0/8 erlauben, fr RBL-Server."
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr "DNS-Rebind-Schutz fr diese Domne sperren."
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr "DNS-Anfragen immer an alle Server weiterleiten."
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr "Marke setzen, wenn Klient eine entsprechende Option anfragt."
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr "Setzt das Tag, wenn der Client diesen Namen anbietet."
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr "Alternative Ports fr DHCP verwenden."
 
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr "DNS-NAPTR-Eintrag festlegen."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr "Niedrigsten verfgbaren Port fr bertragung von DNS-Anfragen festlegen."
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr "Hchsten verfgbaren Port fr bertragung von DNS-Anfragen festlegen."
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr "Fr DHCP-Klienten nur vollstndig bestimmte Domnennamen benutzen."
 
 # FIXME: probably typo in original message. -- MA
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr "Generiere Hostnamen auf Basis der MAC-Adresse fr namenlose Klienten."
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr "Diese DHCP-Relais als vollwertige Proxies verwenden."
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr "Leute DHCP Anfragen an entfernten Server weiter"
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr "Alias fr LOKALEN DNS-Namen festlegen."
 
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr "Aufforderung, die an PXE-Klienten geschickt wird."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr "Boot-Dienst fr PXE-Men."
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr "Konfigurationssyntax prfen."
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr "Anfragende MAC-Adresse in die weiterleitende DNS-Anfrage einfgen."
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr "Fge spezifiziertes IP-Subnetz an weitergeleiteten DNS-Anfragen hinzu."
 
-#: option.c:464
+#: option.c:482
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Fge Klient Identifikationan weitergeleiteten DNS-Anfragen hinzu."
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Proxy-DNSSEC-Validierung-Ergebnisse von Upstream-Namensservern."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr "Versuche sequenzielle IP-Adressen an DHCP-Klienten zu vergeben."
 
-#: option.c:467
+#: option.c:485
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Ignorieren Sie die von DHCP-Clients gesendete Client-ID-Option."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr "Kopiere \"connection-track mark\" von Anfragen nach Upstream-Verbindungen."
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr "Erlaube DHCP-Klienten ihre eigenen DDNS-Updates durchzufhren."
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr "Sende \"Router-Advertisments\" fr Netzwerkschnittstellen, welche DHCPv6 nutzen"
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr "Spezifiziere DUID_EN-type DHCPv6 Server DUID"
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Spezifiziere Host (A/AAAA und PTR) Eintrge"
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr "Geben Sie den Autorisierungsdatensatz der Zertifizierungsstelle an"
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr "Spezifiziere einen beliebiegen DNS Eintrag"
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "Bindung zu Schnittstellen in Benutzung - prfe auf neue Schnittstellen"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr "Exportiere lokale Namen in das globale DNS"
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr "Domain fr das Exportieren des globalen DNS"
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr "Setzte TTL fr autoritative Antworten"
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr "Setze autoritative Zoneninformationen"
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr "Sekundrer autoritativer Nameserver fr weitergeleitete Domains"
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr "Peers welche einen Zonentransfer durchfhren drfen"
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr "Spezifiziere IPSets zu welcher passende Domains hinzugefgt werden sollen"
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr "Spezifiziere eine Domain und Adressbereich fr synthetisierte Namen"
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr "Aktiviere DNSSEC-Validierung"
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr "Spezifiziere Vertrauensursprung (Trust Anchor) der Schlssel-Prfdaten (Key Digest)."
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr "Deaktiviere die berprfung vorgelagerter Server fr DNSSEC-Debugging."
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr "Stellt sicher, dass Antworten ohne DNSSEC sich in einer unsignierten Zone befinden."
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr "DNSSEC Signatur-Zeitstempel nicht prfen, bis erstmalig der Cache neugeladen wird"
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr "Zeitstempel-Datei fr die Verifizierung der Systemuhrzeit fr DNSSEC"
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr "Spezifiziere DHCPv6 Prefix Klasse"
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr "Setze MTU, Prioritt, Sendewiederholungsintervall und Router-Lebensdauer"
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr "Protokolliere kein DHCP."
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr "Protokolliere kein DHCPv6."
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr "RA nicht protokollieren."
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr "Akzeptiere nur Anfragen von direkt verbundenen Netzwerken."
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr "Erkennen und Entfernen von DNS-Weiterleitungsschleifen."
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr "Ignoriere DNS-Antworten, welche ipaddr enthalten."
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr "Setzte TTL in DNS-Antworten mit DHCP-abgeleiteten Adressen."
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr "Verzgere DHCP-Antworten fr mindestens Anzahl von Sekunden."
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr "Aktiviert die Option DHCPv4 Rapid Commit."
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr "Pfad zur Debug-Paketdatei, wohin gedumpt werden soll"
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr "Maskiere Pakete, welche gedumpt werden sollen"
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr "Rufe dhcp-script auf, wenn der Ablauf des Leases sich ndert."
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -766,320 +802,332 @@
 "Verwendung: dnsmasq [Optionen]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Auf der Befehlszeile nur kurze Optionen verwenden!\n"
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr "Gltige Optionen sind:\n"
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr "Fehlerhafte Adresse"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "unzulssiger Port"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr "Schnittstellenbindung nicht untersttzt"
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr "Schnittstelle kann nur einmal angegeben werden"
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr "unzulssiger Schnittestellenname"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr "Nicht untersttzte Verkapselung fr eine IPv6-Option"
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "Fehlerhafte DHCP-Option"
 
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr "Fehlerhafte IP-Adresse"
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr "Fehlerhafte IPv6-Adresse"
 
-#: option.c:1240
+#: option.c:1366
 msgid "bad IPv4 address"
 msgstr "Fehlerhafte IPv4-Adresse"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "Fehlerhafte Domne in DHCP-Option"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "DHCP-Option zu lang"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr "Unzulssige dhcp-match-Option"
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr "unzulssig wiederholte Markierung"
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr "unzulssig wiederholtes Schlsselwort"
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr "Kann auf Verzeichnis %s nicht zugreifen: %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr "Kann auf %s nicht zugreifen: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr "Die Einstellung Protokolliereinrichtung kann unter Android nicht gesetzt werden"
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr "Falsche Protokolliereinrichtung"
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "unzulssige MX-Prferenz-Angabe"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "unzulssiger MX-Name"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "unzulssiges MX-Ziel"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr "unter uClinux ist die Skriptausfhrung nicht mglich"
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr "Neubersetzung mit HAVE_SCRIPT ntig, um Lease-nderungs-Skripte auszufhren"
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr "Um Benutzerdefinierte Lua-Skripte zu ermglichen, muss mit HAVE_LUASCRIPT neu kompiliert werden"
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr "unzulssiger Prfix"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr "Um IPSet-Direktiven zu aktivieren, muss mit HAVE_IPSET neu bersetzt werden"
 
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr "unzulssiger Portbereich"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr "unzulssige Brcken-Schnittstelle"
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr "unzulssiger geteiltes Netz"
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr "nur eine Marke zulssig"
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "unzulssiger DHCP-Bereich"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "inkonsistenter DHCP-Bereich"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr "Die Prfixlenge muss genau 64 fr RA Subnetze sein"
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr "Die Prfixlenge muss genau 64 fr Subnet Konstruktoren sein"
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr "Die Prfixlnge muss mindestens 64 sein"
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr "Inkonsistenter DHCPv6-Bereich"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr "Prefix muss mit dem \"constructor:\" Argument Null sein"
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr "Falscher Hexwert"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr "Kann die Tags in --dhcp-host nicht abgleichen"
+#: option.c:3315
+msgid "bad IPv6 prefix"
+msgstr "unzulssiger IPv6-Prfix"
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "doppelte dhcp-host IP-Adresse %s"
 
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr "unzulssiger DHCP-Hostname"
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr "unzulssige bedingte Marke (tag-if)"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "unzulssige Portnummer"
 
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr "Fehlerhafte DHCP-Proxy-Adresse"
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr "Uunzulssiger dhcp-relay"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr "unzulssige RA-Parameter"
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr "unzulssige DUID"
 
-#: option.c:3796
+#: option.c:4023
+msgid "missing address in alias"
+msgstr "Adresse fehlt in Alias"
+
+#: option.c:4029
 msgid "invalid alias range"
 msgstr "unzulssiger Alias-Bereich"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr "unzulssiger CNAME"
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr "doppelter CNAME"
 
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr "unzulssiger PTR-Eintrag"
 
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr "unzulssiger NAPTR-Eintrag"
 
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr "unzulssiger RR-Eintrag"
 
-#: option.c:3984
+#: option.c:4236
+msgid "bad CAA record"
+msgstr "unzulssiger CAA-Eintrag"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "unzulssiger TXT-Eintrag"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "unzulssiger SRV-Eintrag"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "unzulssiges SRV-Ziel"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "unzulssige Prioritt"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "unzulssige Wichtung"
 
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr "Unzulssiger host-record"
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr "Unzulssiger Name in host-record"
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr "Ungltiger Wert fr dnssec-check-unsigned"
+
+#: option.c:4480
 msgid "bad trust anchor"
 msgstr "unzulssiger Vertrauensursprung (Trust Anchor)"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr "unzulssiger Hexwert in Vertrauensursprung (Trust Anchor)"
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr "Nicht untersttzte Option (prfen Sie, ob DNSMasq mit DHCP/TFTP/DNSSEC/DBus-Untersttzung bersetzt wurde)"
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "fehlende \\\""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "unzulssige Option"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "berschssiger Parameter"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "fehler Parameter"
 
-#: option.c:4309
+#: option.c:4630
 msgid "illegal option"
 msgstr "unzulssige Option"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "Fehler"
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr " in Zeile %d von %s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr "%s gelesen"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "kann %s nicht lesen: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr "Mist in der Kommandozeile gefunden"
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Dnsmasq Version %s  %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1088,504 +1136,550 @@
 "Kompilierungs-Optionen %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Fr diese Software wird ABSOLUT KEINE GARANTIE gewhrt.\n"
 
 # FIXME: this must be one long string! -- MA
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsmasq ist freie Software, und du bist willkommen es weiter zu verteilen\n"
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "unter den Bedingungen der GNU General Public Lizenz, Version 2 oder 3.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr "versuchen Sie --help"
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr "versuchen Sie -w"
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr "unzulssige Optionen auf der Befehlszeile: %s"
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr "CNAME-Schleife mit %s"
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "kann Hostnamen nicht ermitteln: %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "mit -n/--no-poll ist nur eine resolv.conf-Datei zulssig."
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "Um die Domne zu lesen, muss genau eine resolv.conf-Datei verwendet werden."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr "konnte %s nicht lesen: %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "keine \"search\"-Anweisung in %s gefunden"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr "Es muss eine standard Domain gesetzt sein, wenn --dhcp-fqdn gesetzt ist"
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr "Syntaxprfung OK"
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr "Fehlgeschlagen, folgendes Paket zu senden: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr "Verwerfe DNS Antwort: Subnetoption stimmt nicht berrein"
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "Namensserver %s hat eine rekursive Anfrage verweigert"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr "mglichen DNS-Rebind-Angriff entdeckt: %s"
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr "Reduziere der DNS-Paketgre fr Nameserver %s auf %d"
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr "Ignoriere Anfragen vom nicht lokalen Netzwerk"
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Maximale Anzahl an nebenlufiger DNS-Anfragen erreicht (Max: %d)"
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "Konnte Empfangs-Socket fr %s: %s nicht erzeugen"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr "LOUD WARNING: Das Abhren von %s kann die Anfragen auf der Schnittstelle akzeptieren anders als %s"
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr "LOUD WARNING: Es sollte --bind-dynamic anstatt --bind-interfaces benutzt werden, um DNS-Verstrkungsangriffe auf diesen Schnittstellen zu unterbinden"
 
-#: network.c:1047
+#: network.c:1018
 #, c-format
 msgid "warning: using interface %s instead"
 msgstr "Warnung: Benutzer stattdessen Schnittstelle %s"
 
-#: network.c:1056
+#: network.c:1027
 #, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "Warnung: Keine Adresse fr die Schnittstelle %s gefunden"
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "Schnittstelle %s konnte DHCPv6-Multicast-Gruppe nicht beitreten: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr "Versuche /proc/sys/net/core/optmem_max zu erhhen"
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "konnte nicht an Server-Socket fr %s binden: %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignoriere Namensserver %s - lokale Schnittstelle"
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignoriere Namensserver %s - kann Socket nicht erzeugen/binden: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr "(kein DNSSEC)"
 
 # FIXME: this isn't translatable - always provide full strings, do not assemble yourself! -- MA
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "unqualifiziert"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr "Namen"
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr "Standard"
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "Domain"
 
-#: network.c:1572
+#: network.c:1543
 #, c-format
-msgid "using local addresses only for %s %s"
-msgstr "Benutze lokale Adressen nur fr %s %s"
+msgid "using only locally-known addresses for %s %s"
+msgstr "Benutze nur lokal-bekannte Adressen fr %s %s"
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "Benutze standard Namensserver fr %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "Benutze Namensserver %s#%d fr %s %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "Benutze Namensserver %s#%d NICHT - Anfragenschleife festgetellt"
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "Benutze Namensserver %s#%d(via %s)"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "Benutze Namensserver %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, c-format
 msgid "using %d more local addresses"
 msgstr "Benutze %d mehr lokale Adressen"
 
-#: network.c:1593
+#: network.c:1564
 #, c-format
 msgid "using %d more nameservers"
 msgstr "Benutze %d mehr Namensserver"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr "dhcp-hostsdir, dhcp-optsdir und hostsdir sind auf dieser Plattform nicht unterstzt"
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr "Keine Root-Vertrauensursprnge (Root Trust Anchor) fr DNSSEC verfgbar"
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr "Kann die Standard Cachegre nicht verkleinern, wenn DNSSEC aktiviert ist"
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DNSSEC nicht verfgbar: setzen Sie HAVE_DNSSEC in src/config.h"
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "TFTP-Server nicht verfgbar, setzen Sie HAVE_TFTP in src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr "Kann nicht --conntrack UND --query-port einsetzen"
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "Conntrack-Untersttzung nicht verfgbar: Aktiviere HAVE_CONNTRACK in src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr "asynchrone Protokollierung unter Solaris nicht verfgbar"
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr "Asynchrone Protokollierung unter Android nicht verfgbar"
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "Authoritatives DNS nicht verfgbar: Es muss HAVE_AUTH in src/config.h gesetzt sein"
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "Loop-Erkennung nicht verfgbar, Aktiviere HAVE_LOOP in src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "UBus nicht verfgbar: setzen Sie HAVE_UBUS in src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr "max_port darf nicht kleiner als min_port sein"
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr "--Auth-Server ist notwendig, wenn eine Auth-Zone definiert ist."
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr "Zonen Seriennummer muss mit --auth-soa konfiguriert werden"
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr "dhcp-range Konstruktor ist auf dieser Plattform nicht verfbar"
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr "Kann nicht --bind-interfaces und --bind-dynamic setzen"
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "konnte Schnitstellenliste nicht beziehen: %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "unbekannte Schnittstelle %s"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "Paketdump nicht verfgbar: setzen Sie HAVE_DUMP in src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "DBus-Fehler: %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus nicht verfgbar: setzen Sie HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "UBus nicht verfgbar: setzen Sie HAVE_UBUS in src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr "Unbekannter Benutzer oder Gruppe: %s"
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr "Prozess bentigt nicht vorhandene Fhigkeit %s"
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr "kann nicht ins Wurzelverzeichnis des Dateisystems wechseln: %s"
 
 # FIXME: this and the next would need commas after the version
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr "gestartet, Version %s, DNS abgeschaltet"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "gestartet, Version %s, Cachegre %d"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr "Die Cachegre grer als 10000 kann Performanceprobleme verursachen und der positive Nutzen ist zudem unwahrscheinlich."
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "Gestartet, Version %s Cache deaktiviert"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr "DNS-Dienst auf lokale Subnetze eingeschrnkt"
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "bersetzungsoptionen: %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "DBus-Untersttzung eingeschaltet: mit Systembus verbunden"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "DBus-Untersttzung eingeschaltet: warte auf Systembus-Verbindung"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+msgid "UBus support enabled: connected to system bus"
+msgstr "UBus-Untersttzung aktiviert: Mit Systembus verbunden"
+
+#: dnsmasq.c:852
+msgid "UBus support enabled: bus connection pending"
+msgstr "UBus-Untersttzung aktiviert: BUS-Verbindung wird hergestellt"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr "DNSSEC-Validierung aktiviert, jedoch wird allen unsignierten Antworten vertraut"
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr "DNSSEC-Validierung aktiviert"
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr "DNSSEC-Signatur-Zeitstempel werden erst nach Empfang von SIGINT berprft"
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr "DNSSEC Signatur-Zeitstempel werden erst berprft, sobald die Systemuhrzeit gltig ist"
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr "konfiguriert mit Vertrauensanker fr% s Schlsselwort % u"
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "Warnung: konnte den Besitzer von %s nicht ndern: %s"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "Aktiviere --bind-interfaces wegen Einschrnkungen des Betriebssystems"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "Warnung: Schnittstelle %s existiert derzeit nicht"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr "Warnung: Ignoriere \"resolv-file\", weil \"no-resolv\" aktiv ist"
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr "Warnung: keine vorgelagerten (Upstream) Server konfiguriert"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr "asynchrone Protokollierung eingeschaltet, Warteschlange fasst %d Nachrichten"
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr "IPv6-Router-Advertisement aktiviert"
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr "DHCP, Sockets exklusiv an das Interface %s gebunden"
 
 # FIXME: this and the next few must be full strings to be translatable - do not assemble in code"
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr "Wurzel ist "
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr "Aktiviert"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr "sicherer Modus"
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+msgid "single port mode"
+msgstr "Einzelport-Modus"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr "Warnung: %s nicht zugreifbar"
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr "Warnung: Das TFTP-Verzeichnis %s ist nicht zugreifbar"
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr "Begrenze gleichzeitige TFTP-bertragungen auf maximal %d"
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "Mit System-DBus verbunden"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr "kann nicht in den Hintergrund abspalten: %s"
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr "kann Helfer nicht erzeugen: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr "kann \"capabilities\" nicht setzen: %s"
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "Kann nicht Benutzerrechte %s annehmen: %s"
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "Kann nicht Gruppenrechte %s annehmen: %s"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "kann die Prozessidentifikations-(PID)-Datei %s nicht ffnen: %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr "Kann Logdatei %s nicht ffnen: %s"
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr "Konnte Lua-Script nicht laden: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr "Das TFTP-Verzeichnis %s ist nicht zugreifbar: %s"
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "Kann keine Zeitstempel-Datei %s erzeugen: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr "Scriptprozess durch Signal %d gettet"
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr "Scriptprozess hat sich mit Status %d beendet"
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr "konnte %s nicht ausfhren: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr "Prfe jetzt DNSSEC Signatur-Zeitstempel"
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "kann die mtime nicht auf %s aktualisieren: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "beende nach Empfang von SIGTERM"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr "konnte auf %s nicht zugreifen: %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "lese %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr "keine Server in %s gefunden, werde es spter neu versuchen"
@@ -1615,7 +1709,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "kann ICMP-Rohdaten-Socket nicht erzeugen: %s."
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "unbekannte Schnittstelle %s in bridge-interface"
@@ -1625,72 +1719,81 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr "DHCP-Paket ohne Adresse an Schnittstelle %s empfangen"
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr "APR-Cache Injektion fehlgeschlagen: %s"
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr "Fehler beim Senden des DHCP-Pakets an %s: %s"
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "DHCP-Bereich %s - %s passt nicht zur Netzmaske %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr "ungltige Zeile %2$d in Datei %1$s"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr "ignoriere %s Zeile %d, doppelter Name oder doppelte IP-Adresse"
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr "DHCP Weiterleitung %s -> %s"
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr "ignoriere fehlerhafte Zeile in Lease-Datenbank: %s %s %s %s ..."
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr "ignoriere fehlerhafte Zeile in Lease-Datenbank, ungltige Adresse: %s"
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "zu viele Leases gespeichert"
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "kann Lease-Datei %s nicht ffnen: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr "Fehler beim Parsen der Lease-Datenbank, ungltige Zeile: %s %s %s %s ..."
+#: lease.c:185
+msgid "failed to parse lease database cleanly"
+msgstr "Fehler beim korrekten Parsen der Lease-Datenbank"
 
-#: lease.c:180
+#: lease.c:188
 #, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "konnte Lease-Datei %s nicht lesen: %s"
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "kann Lease-Start-Skript %s nicht ausfhren: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr "Lease-Start-Skript beendete sich mit Code %s"
 
 # FIXME: This should be %u s also in English according to NIST and SI rules. -- MA
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "Konnte %s nicht schreiben: %s (Neuversuch in %u s)"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr "Ignoriere Domne %s fr DHCP-Hostnamen %s"
@@ -1697,265 +1800,261 @@
 
 # FIXME: this and the next few are not translatable. Please provide full
 # strings, do not programmatically assemble them.
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "Kein verfgbarer DHCP-Bereich fr Anfrage %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "mit Subnetz-Whler"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "via"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "%u verfgbare(s) DHCP-Subnetz: %s/%s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr "%u verfgbare(r) DHCP-Bereich: %s - %s"
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr "%u \"Vendor class\": %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr "%u Benutzerklasse: %s"
 
 # FIXME: do not programmatically assemble strings - untranslatable
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "deaktiviert"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "ignoriert"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "Adresse in Nutzung"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "Keine Adresse verfgbar"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "Falsches Netzwerk"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "Keine Adresse konfiguriert"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "Keine Leases brig"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr "%u Klient stellt Name bereit: %s"
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr "PXE BIS nicht untersttzt"
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "schalte statische DHCP-Adresse %s fr %s ab"
 
 # FIXME: do not assemble
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "Unbekannter Lease"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr "benutze konfigurierte Adresse %s nicht, weil sie an %s verleast ist"
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr "benutze konfigurierte Adresse %s nicht, weil sie von Server/Relais verwendet wird"
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr "benutze konfigurierte Adresse %s nicht, weil sie zuvor abgelehnt wurde"
 
 # FIXME: do not assemble
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr "Keine eindeutige ID"
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr "Falsche Server-ID"
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "Falsche Adresse"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "Lease nicht gefunden"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "Adresse nicht verfgbar"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "Statischer Lease verfgbar"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "Adresse reserviert"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr "Gebe Lease von %2$s an %1$s auf"
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr "%u Name der Bootdatei: %s"
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr "%u Servername: %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr "%u nchster Server: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr "%u Antwort per Rundsendung"
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "kann DHCP/BOOTP-Opition %d nicht setzen: kein Platz mehr im Paket"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr "PXE-Meneintrag zu gro"
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr "%u angeforderte Optionen: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr "Kann RFC3925-Option nicht senden: zu viele Optionen fr Unternehmen Nr. %d"
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr "%u Antwortverzgerung: %d"
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "kann Netlink-Socket nicht erzeugen: %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr "Netlink liefert Fehler %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "Versuch, via DBus eine IPv6-Serveradresse zu setzen: keine IPv6-Untersttzung"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr "Aktiviere --%s Option von D-Bus"
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr "Deaktiviere --%s Option von D-Bus"
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "vorgelagerte Server von DBus gesetzt"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "konnte Steuerungsprogramm fr DBus-Nachrichten nicht anmelden"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "konnte DHCP-BPF-Socket nicht einrichten: %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "DHCP-Anfrage fr nicht untersttzen Hardwaretyp (%d) auf %s empfangen"
 
-#: bpf.c:378
+#: bpf.c:374
 #, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "Kann PF_ROUTE socket nicht erzeugen: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr "Unbekannte Protokollversion vom Route Socket"
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr "Die Funktion lease() fehlt im Lua-Script"
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr "konnte keinen freien Port fr TFTP bekommen"
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr "nicht untersttzte Anfrage von %s"
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr "Datei %s nicht gefunden"
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
-msgstr "Fehler %d %s von %s empfangen"
-
-#: tftp.c:634
-#, c-format
 msgid "failed sending %s to %s"
 msgstr "konnte %s nicht an %s senden"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr "%s an %s verschickt"
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr "Fehler %d %s von %s empfangen"
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -1970,7 +2069,7 @@
 msgid "FAILED to start up"
 msgstr "Start fehlgeschlagen"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr "\"Conntrack connection mark\"-Abruf fehlgeschlagen: %s"
@@ -1990,78 +2089,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "Kann nicht an DHCPv6-Server-Socket binden: %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "Kein Adressbereich verfgbar fr die DHCPv6-Anfrage vom Relay bei %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "Kein Adressbereich verfgbar fr die DHCPv6-Anfrage via %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "%u verfgbare(s) DHCPv6-Subnetz: %s/%d"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr "%u Herstellerklasse: %u"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr "%u Klient MAC-Adresse: %s"
 
-# FIXME: do not assemble
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr "unbekannte Prfixklasse %d"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr "Adresse nicht verfgbar"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr "Erfolg"
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr "Keine Adressen verfgbar"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr "nicht on link"
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr "Keine Bindung gefunden"
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr "veraltet"
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr "Adresse ungltig"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr "Besttigung fehlgeschlagen"
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr "Alle Adressen immer noch on link"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr "Freigabe empfangen"
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr "Kann nicht zum DHCPv6 Server multicasten ohne korrekte Schnittstelle"
 
@@ -2075,76 +2168,76 @@
 msgid "%u tags: %s"
 msgstr "%u Marken: %s"
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr "%s hat mehr als eine Adresse in hosts-Datei, benutze %s fr DHCP"
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "doppelte IP-Adresse %s (%s) in \"dhcp-config\"-Anweisung"
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "kann SO_BINDTODEVICE fr DHCP-Socket nicht aktivieren: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr "Bekannte DHCP-Optionen:\n"
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr "Bekannte DHCPv6-Optionen:\n"
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ", Prefix veraltet"
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ", Lease Zeit "
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr "%s stateless auf %s%.0s%.0s%s"
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "%s, nur statische Leases auf %.0s%s%s%.0s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr "%s, Proxy im Subnetz %.0s%s%.0s%.0s"
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "%s, IP-Bereich %s -- %s%s%.0s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr "DHCPv4-abgeleitete IPv6 Namen auf %s%s"
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr "Router-Advertisment auf %s%s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr "DHCP Weiterleitung von %s nach %s ber %s"
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr "DHCP Weiterleitung von %s nach %s"
@@ -2154,7 +2247,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "Kann ICMPv6-Socket nicht erzeugen: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr "ignoriere Zonentransfer-Anfrage von %s"
@@ -2169,20 +2262,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "konnte IPset-Kontroll-Socket nicht erzeugen: %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "Aktualisierung von ipset %s fehlgeschlagen: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr "Prfe jetzt DNSSEC Signatur-Zeitstempel."
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
-msgstr "DNSSEC Speicher in Benutzung %u, Max %u, zugewiesen %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
+msgstr "Unsichere DS-Antwort fr %s, bitte Domainkonfiguration und Upstream DNS-Server fr DNSSEC-Untersttzung berprfen"
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr "Pool Speicher in Benutzung %u, Max %u, zugewiesen %u"
+
 #: tables.c:61
 #, c-format
 msgid "failed to access pf devices: %s"
@@ -2212,12 +2310,12 @@
 msgid "info: table created"
 msgstr "Info: Tabelle erstellt"
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr "Warnung: DIOCR%sADDRS: %s"
 
-#: tables.c:138
+#: tables.c:137
 #, c-format
 msgid "%d addresses %s"
 msgstr "%d Adressen %s"
@@ -2257,6 +2355,81 @@
 msgid "inotify, new or changed file %s"
 msgstr "inotify, neue oder genderte Datei %s"
 
+#: dump.c:64
+#, c-format
+msgid "cannot create %s: %s"
+msgstr "kann %s nicht erstellen: %s"
+
+#: dump.c:70
+#, c-format
+msgid "bad header in %s"
+msgstr "Unzulssiger Header in %s"
+
+#: dump.c:201
+msgid "failed to write packet dump"
+msgstr "schreiben des Paketmitschnitt fehlgeschlagen"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr "Dumpe UDP Paket %u Maske 0x%04x"
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr "UBus-Subskription Rckruf: %s Teilnehmer"
+
+#: ubus.c:73
+#, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "Kann mit UBus nicht erneut verbinden: %s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr "Kann UBus nicht initialisieren: Verbindung fehlgeschlagen"
+
+#: ubus.c:102
+#, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "Kann Objekt zu UBus nicht hinzufgen: %s"
+
+#: ubus.c:112
+msgid "Connected to system UBus"
+msgstr "Mit System-UBus verbunden"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr "Kann UBus-Zuhrer nicht setzen: Keine Verbindung"
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr "Kann UBus-Zuhrer nicht abfragen: Keine Verbindung"
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr "Mit System-UBus trennen"
+
+#: ubus.c:199
+#, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "Fehlgeschlagen, folgendes UBus-Event zu senden: %s"
+
+#~ msgid "Specify DHCPv6 prefix class"
+#~ msgstr "Spezifiziere DHCPv6 Prefix Klasse"
+
+#~ msgid "cannot run scripts under uClinux"
+#~ msgstr "unter uClinux ist die Skriptausfhrung nicht mglich"
+
+#~ msgid "cannot match tags in --dhcp-host"
+#~ msgstr "Kann die Tags in --dhcp-host nicht abgleichen"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "Versuch, via DBus eine IPv6-Serveradresse zu setzen: keine IPv6-Untersttzung"
+
+# FIXME: do not assemble
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "unbekannte Prfixklasse %d"
+
 #~ msgid "bad TTL"
 #~ msgstr "unzulssige TTL"
 
Index: po/es.po
===================================================================
--- po/es.po	(revision 41436)
+++ po/es.po	(working copy)
@@ -16,70 +16,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, fuzzy, c-format
 msgid "failed to load names from %s: %s"
 msgstr "no se pudo cargar nombres desde %s: %s"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, fuzzy, c-format
 msgid "bad address at %s line %d"
 msgstr "direccin errnea en %s lnea %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "nombre errneo en %s lnea %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "direccines %s - %d ledas"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "el cach fue liberado"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr "%s es un CNAME, no se le est dando concesin DHCP de %s"
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "no otorgando nombre %s a concesin DHCP de %s porque el nombre existe en %s con direccin %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr "tiempo %lu"
 
-#: cache.c:1419
+#: cache.c:1664
 #, fuzzy, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "tamao de cach %d, %d/%d insercines de cach reutilizaron objetos no vencidos."
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr "bsquedas reenviadas %u, bsquedas respondidas localmente %u"
 
-#: cache.c:1424
+#: cache.c:1669
 #, fuzzy, c-format
 msgid "queries for authoritative zones %u"
 msgstr "Fijar TTL para respuestas autoritarias"
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr "servidor %s#%d: bsquedas enviadas %u, reintentadas o fallidas %u"
@@ -94,698 +94,736 @@
 msgid "failed to allocate memory"
 msgstr "no se pudo asignar memoria"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "no se pudo adquirir memoria"
 
-#: util.c:291
+#: util.c:302
 #, fuzzy, c-format
 msgid "cannot create pipe: %s"
 msgstr "no se puede crear pipe: %s"
 
-#: util.c:299
+#: util.c:310
 #, fuzzy, c-format
 msgid "failed to allocate %d bytes"
 msgstr "no se pudo asignar %d bytes"
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "infinito"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Especificar direccin(es) locales dnde escuchar."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Retornar ipaddr (direccin IP) para todos los hosts en los dominios especificados."
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Falsificar bsquedas reversas para rangos de direccin privados RFC1918."
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Tratar ipaddr (direccin IP) como NXDOMAIN (derrota comodn Verisign)."
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Especificar tamao de cach en cuanto a cantidad de objetos (%s por predeterminado)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Especificar archivo de configuracin (%s por predeterminado)."
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "NO hacer un fork hacia el fondo: correr en modo debug."
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "NO reenviar bsquedas sin parte de dominio."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Retornar expedientes MX auto-sealadores para hosts locales."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Expandir nombres simples en /etc/hosts con domain-suffix (sufijo de dominio)."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "No reenviar pedidos DNS falsos desde mquinas Windows."
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Habilitar DHCP dentro del rango brindado con duracin de concesin."
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Cambiar a este grupo despus del inicio (%s por predeterminado)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Fijar direccin o nombre de host para una mquina especificada."
 
-#: option.c:358
+#: option.c:372
 #, fuzzy
 msgid "Read DHCP host specs from file."
 msgstr "Leer especificaciones DHCP de host desde archivo"
 
-#: option.c:359
+#: option.c:373
 #, fuzzy
 msgid "Read DHCP option specs from file."
 msgstr "Leer opciones DHCP de host desde archivo"
 
-#: option.c:360
+#: option.c:374
 #, fuzzy
 msgid "Read DHCP host specs from a directory."
 msgstr "Leer especificaciones DHCP de host desde archivo"
 
-#: option.c:361
+#: option.c:375
 #, fuzzy
 msgid "Read DHCP options from a directory."
 msgstr "Leer opciones DHCP de host desde archivo"
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr "Evaluar expresin condicional de etiqueta."
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "NO cargar archivo %s."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Especificar un archivo de hosts para ser ledo adicionalmente a %s."
 
-#: option.c:365
+#: option.c:379
 #, fuzzy
 msgid "Read hosts files from a directory."
 msgstr "Leer especificaciones DHCP de host desde archivo"
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Especificar interfase(s) donde escuchar."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Especificar interfase(s) donde NO escuchar."
 
-#: option.c:368
+#: option.c:382
 #, fuzzy
 msgid "Map DHCP user class to tag."
 msgstr "Trazar clase de usuario DHCP a etiqueta."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr "Trazar circuit-id (identificacin de circuito) RFC3046 a etiqueta."
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr "Trazar remote-id (identificacin remota) RFC3046 a etiqueta."
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr "Trazar subscriber-id (identificacin de suscritor) RFC3993 a etiqueta."
 
-#: option.c:372
+#: option.c:386
 #, fuzzy
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "No hacer DHCP para hosts con etiqueta fijada."
 
-#: option.c:373
+#: option.c:387
 #, fuzzy
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Forzar respuestas broadcast para hosts con etiqueta fijada."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "NO hacer un fork hacia el fondo, NO correr en modo debug."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Asumir que somos el nico servidor DHCP en la red local."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Especificar donde almacenar concesin DHCP (%s por predeterminado)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Retornar expedientes MX para hosts locales."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Especificar un expediente MX."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Especificar opciones BOOTP a servidor DHCP."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "NO revisar archivo %s peridicamente, recargar solo con SIGHUP."
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "NO almacenar en cach resultados de bsquedas fallidas."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Usar servidores DNS estrictamente en el rden brindado en %s."
 
-#: option.c:383
+#: option.c:397
 #, fuzzy
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Especificar opciones para ser enviadas a clientes DHCP."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr "Opcin DHCP enviada an si el cliente no la pide."
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Especificar puerto donde escuchar por bsquedas DNS (53 por predeterminado)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Tamao mximo de paquetes UDP soportado para EDNS.0 (%s por predeterminado)."
 
-#: option.c:387
+#: option.c:401
 #, fuzzy
 msgid "Log DNS queries."
 msgstr "Bitacorear bsquedas DNS."
 
-#: option.c:388
+#: option.c:402
 #, fuzzy
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Enforzar el puerto original para bsquedas DNS subida."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "NO leer resolv.conf."
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Especificar el path hacia resolv.conf (%s por predeterminado)."
 
-#: option.c:391
+#: option.c:405
 #, fuzzy
 msgid "Specify path to file with server= options"
 msgstr "Especificar path de archivo PID (%s por predeterminado)."
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Especificar direccin(es) de servidores subida con dominios opcionales."
 
-#: option.c:393
+#: option.c:407
 #, fuzzy
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Especificar direccin(es) de servidores subida con dominios opcionales."
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Nunca reenviar bsquedas a dominios especificados."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Especificar el dominio para ser asignado en concesin DHCP."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Especificar destino predeterminado en un expediente MX."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Especificar tiempo de vida en segundos para respuestas desde /etc/hosts."
 
-#: option.c:398
+#: option.c:412
 #, fuzzy
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Especificar tiempo de vida en segundos para cach negativo."
 
-#: option.c:399
+#: option.c:413
 #, fuzzy
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Especificar tiempo de vida en segundos para respuestas desde /etc/hosts."
 
-#: option.c:400
+#: option.c:414
 #, fuzzy
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Especificar tiempo de vida en segundos para cach negativo."
 
-#: option.c:401
+#: option.c:415
 #, fuzzy
 msgid "Specify time-to-live floor for cache."
 msgstr "Especificar tiempo de vida en segundos para cach negativo."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Cambiar a este usuario despues del inicio (%s por predeterminado)."
 
-#: option.c:403
+#: option.c:417
 #, fuzzy
 msgid "Map DHCP vendor class to tag."
 msgstr "Trazar clase de vendedor DHCP a etiqueta."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Mostrar informacin sobre la versin y copyright de dnsmasq."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Traducir direcciones IPv4 desde servidores subida."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Especificar un expediente SRV."
 
-#: option.c:407
+#: option.c:421
 #, fuzzy
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr "Mostrar este mensaje. Usar --help dhcp para opciones DHCP conocidas."
 
-#: option.c:408
+#: option.c:422
 #, fuzzy, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Especificar path de archivo PID (%s por predeterminado)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Especificar nmero mximo de concesin DHCP (%s por predeterminado)."
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Responder a bsquedas DNS en base a la interfase a la cul fueron enviadas."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Especificar expediente DNS TXT."
 
-#: option.c:412
+#: option.c:426
 #, fuzzy
 msgid "Specify PTR DNS record."
 msgstr "Especificar expediente DNS PTR."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr "Otorgar nombre DNS a direccin IPv4 de interfase."
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Acoplar solo a interfases en uso."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Leer informacin sobre hosts DHCP estticos desde %s."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Habilitar la interfase DBus para fijar servidores subida, etc."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "No proveer DHCP en esta interfase, slo proveer DNS."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Habilitar alocacin dinmica de direccines para BOOTP."
 
-#: option.c:419
+#: option.c:434
 #, fuzzy
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Trazar direccin MAC (con comodnes) a opcin fijada."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr "Tratar pedidos DHCP en alias como si llegaran de la interfase."
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr "Deshabilitar verificacin de direccines para echo ICMP en el servidor DHCP."
 
-#: option.c:422
+#: option.c:438
 #, fuzzy
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr "Archivo guin para ejecutar cuando se crea o destruye una concesin DHCP."
 
-#: option.c:423
+#: option.c:439
 #, fuzzy
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr "Archivo guin para ejecutar cuando se crea o destruye una concesin DHCP."
 
-#: option.c:424
+#: option.c:440
 #, fuzzy
 msgid "Run lease-change scripts as this user."
 msgstr "Correr archivo guin de cambio de concesin como este usuario."
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr "Leer configuracin desde todos los archivos en este directorio."
 
-#: option.c:427
+#: option.c:443
 #, fuzzy
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Bitacorear a esta facilidad syslog o archivo. (DAEMON por predeterminado)"
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr "No usar archivo de concesin."
 
-#: option.c:429
+#: option.c:445
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Nmero mximo de bsquedas DNS simultneas. (%s por predeterminado)"
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr "Liberar cach DNS al recargar %s."
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr "Ignorar nombres de host brindados por clientes DHCP."
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr "NO reutilizar campos de nombre de archivo y servidor para opciones DHCP extra."
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr "Habilitar servidor integrado TFTP solo-lectura."
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr "Exportar archivos va TFTP solo del sub-rbol especificado."
 
-#: option.c:435
+#: option.c:451
 #, fuzzy
 msgid "Add client IP or hardware address to tftp-root."
 msgstr "Agregar IP de cliente a tftp-root."
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr "Permitir acceso solo a archivos pertenecientes al usuario que corre dnsmasq."
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Nmero mximo de transferencias TFTP simultneas (%s por predeterminado)."
 
-#: option.c:439
+#: option.c:455
 #, fuzzy
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Nmero mximo de transferencias TFTP simultneas (%s por predeterminado)."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr "Deshabilitar la extensin TFTP blocksize (tamao de bloque)."
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr "Convertir a minsculas los nombres de archivos TFTP"
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr "Rango de puertos efmeros para ser usados en transferencias TFTP."
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr "Log extra para DHCP."
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr "Habilitar registro asncrono; opcionalmente fijar tamao de cola."
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr "Detener revinculacin DNS. Filtrar rangos de IP privados al resolver."
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr "Permitir revinculacin de 127.0.0.0/8, para servidores RBL."
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr "Inhibir proteccin de revinculacin DNS en este dominio."
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr "Siempre realizar bsquedas DNS a todos los servidores."
 
-#: option.c:449
+#: option.c:466
 #, fuzzy
 msgid "Set tag if client includes matching option in request."
 msgstr "Fijar etiqueta si cliente incluye opcin coincidente en pedido."
 
-#: option.c:450
+#: option.c:467
+#, fuzzy
+msgid "Set tag if client provides given name."
+msgstr "Fijar etiqueta si cliente incluye opcin coincidente en pedido."
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr "Usar puertos alternativos para DHCP."
 
-#: option.c:451
+#: option.c:469
 #, fuzzy
 msgid "Specify NAPTR DNS record."
 msgstr "Especificar expediente DNS NAPTR."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr "Especificar puerto ms bajo disponible para transmisin de bsquedas DNS."
 
-#: option.c:453
+#: option.c:471
 #, fuzzy
 msgid "Specify highest port available for DNS query transmission."
 msgstr "Especificar puerto ms bajo disponible para transmisin de bsquedas DNS."
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr "Usar solo nombres de dominio completamente calificados para clientes DHCP."
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr "Generar hostnames basados en direcciones MAC para clientes sin nombre."
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr "Usar estos relays DHCP como proxies completos."
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr "Especificar nombre alias para nombre DNS LOCAL."
 
-#: option.c:459
+#: option.c:477
 #, fuzzy
 msgid "Prompt to send to PXE clients."
 msgstr "Aviso a ser enviado a clientes PXE."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr "Servicio de arranque para men PXE."
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr "Revisar sintaxis de configuracin."
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr "Aadir direcciones MAC de los peticionarios a los filtros DNS enviados"
 
-#: option.c:463
+#: option.c:481
 #, fuzzy
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr "Aadir direcciones MAC de los peticionarios a los filtros DNS enviados"
 
-#: option.c:464
+#: option.c:482
 #, fuzzy
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Aadir direcciones MAC de los peticionarios a los filtros DNS enviados"
 
-#: option.c:465
+#: option.c:483
 #, fuzzy
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Traducir direcciones IPv4 desde servidores subida."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr "Intento de instaurar direcciones IP secuenciales a cliente DHCP"
 
-#: option.c:467
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Ignorar nombres de host brindados por clientes DHCP."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr "Copiar la marca de connection-track desde los filtros a las conexiones salientes"
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr "Permite a clientes DHCP realizar sus propias actualizaciones DDNS"
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr "Enviar anuncios del router a los interfases realizando DHCPv6"
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 #, fuzzy
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Especificar un expediente MX."
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 #, fuzzy
 msgid "Specify arbitrary DNS resource record"
 msgstr "Especificar expediente DNS TXT."
 
-#: option.c:473
+#: option.c:493
 #, fuzzy
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "interfase desconocida %s en bridge-interfase"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr "Exportar nombres DNS locales a globales"
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr "Dominio a exportar a DNS global"
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr "Fijar TTL para respuestas autoritarias"
 
-#: option.c:477
+#: option.c:497
 #, fuzzy
 msgid "Set authoritative zone information"
 msgstr "Fijar informacin de zona autoritaria"
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr "Nombres de servidor secundario autoritatorios para dominios enviados"
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr "Colegas autorizados a la zona de transferencia (transfer)"
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr "Especificar los ipsets coincidentes en dominio que debran ser aadidos"
 
-#: option.c:481
+#: option.c:501
 #, fuzzy
 msgid "Specify a domain and address range for synthesised names"
 msgstr "Especificar dominio y rango de direcciones para los nombres acrnimos"
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr "Especificar prefijo de clase DHCPv6"
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -794,344 +832,359 @@
 "Modo de uso: dnsmasq [opciones]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Usar opciones cortas solo en la lnea de comandos.\n"
 
-#: option.c:707
+#: option.c:729
 #, fuzzy, c-format
 msgid "Valid options are:\n"
 msgstr "Opciones vlidas son :\n"
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 #, fuzzy
 msgid "bad address"
 msgstr "direccin IP errnea"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "puerto errneo"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr "vinculacin de interfase no est soportado"
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 #, fuzzy
 msgid "bad interface name"
 msgstr "nombre de interfase errneo"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr "Encapsulacin no soportada para opcin IPv6"
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "opcin dhcp-option errnea"
 
-#: option.c:1144
+#: option.c:1270
 #, fuzzy
 msgid "bad IP address"
 msgstr "direccin IP errnea"
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 #, fuzzy
 msgid "bad IPv6 address"
 msgstr "direccin IP errnea"
 
-#: option.c:1240
+#: option.c:1366
 #, fuzzy
 msgid "bad IPv4 address"
 msgstr "direccin IP errnea"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "dominio errneo en dhcp-option"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "opcin dhcp-option demasiado larga"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr "dhcp-match ilegal"
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr "opcin repetida ilegal"
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr "palabra clave repetida ilegal"
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, fuzzy, c-format
 msgid "cannot access directory %s: %s"
 msgstr "no se puede acceder a directorio %s: %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, fuzzy, c-format
 msgid "cannot access %s: %s"
 msgstr "no se puede acceder %s: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr "la creacin de un registro no es posible en Android"
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr "ubicacin del registro errnea"
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "preferencia MX errnea"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "nombre MX errneo"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "destino MX errneo"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr "no se pueden correr archivos 'script' bajo uClinux"
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr "recompilar con HAVE_SCRIPT definido para habilitar guines de cambio de concesin"
 
-#: option.c:1826
+#: option.c:1984
 #, fuzzy
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr "recompilar con HAVE_SCRIPT definido para habilitar 'scripts' en Lua"
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 #, fuzzy
 msgid "bad prefix"
 msgstr "prefijo errneo"
 
-#: option.c:2504
+#: option.c:2658
 #, fuzzy
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr "recompilar con HAVE_SCRIPT definido para habilitar directivas ipset"
 
-#: option.c:2713
+#: option.c:2871
 #, fuzzy
 msgid "bad port range"
 msgstr "rango de puertos errneo"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr "opcin bridge-interface (interfase puente) errnea"
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr "solo una etiqueta permitida"
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "opcin dhcp-range (rango DHCP) errnea"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "rango DHCP inconsistente"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr "la longitud del prefijo debe ser 64 exacto para subredes RA"
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr "la longitud del prefijo debe ser 64 exacto para subredes constructoras"
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr "la longitud del prefijo debe ser al menos 64"
 
-#: option.c:2925
+#: option.c:3123
 #, fuzzy
 msgid "inconsistent DHCPv6 range"
 msgstr "rango DHCP inconsistente"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr "prefijo debe ser cero con argumento \"constructor:\""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 #, fuzzy
 msgid "bad hex constant"
 msgstr "constante hexadecimal errnea"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr "no coinciden etiquetas en --dhcp-host"
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "prefijo errneo"
 
-#: option.c:3119
+#: option.c:3362
 #, fuzzy, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "direccin IP duplicada %s en %s."
 
-#: option.c:3177
+#: option.c:3422
 #, fuzzy
 msgid "bad DHCP host name"
 msgstr "nombre de host DHCP errneo"
 
-#: option.c:3259
+#: option.c:3508
 #, fuzzy
 msgid "bad tag-if"
 msgstr "etiqueta tag-if errnea"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "nmero de puerto invlido"
 
-#: option.c:3678
+#: option.c:3907
 #, fuzzy
 msgid "bad dhcp-proxy address"
 msgstr "direccin IP errnea"
 
-#: option.c:3704
+#: option.c:3935
 #, fuzzy
 msgid "Bad dhcp-relay"
 msgstr "opcin dhcp-range (rango DHCP) errnea"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr "DUID errneo"
 
-#: option.c:3796
+#: option.c:4023
 #, fuzzy
+msgid "missing address in alias"
+msgstr "direccin en uso"
+
+#: option.c:4029
+#, fuzzy
 msgid "invalid alias range"
 msgstr "rango alias invlido"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr "CNAME errneo"
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr "CNAME duplicado"
 
-#: option.c:3889
+#: option.c:4132
 #, fuzzy
 msgid "bad PTR record"
 msgstr "registro PTR errneo"
 
-#: option.c:3920
+#: option.c:4167
 #, fuzzy
 msgid "bad NAPTR record"
 msgstr "registro NAPTR errneo"
 
-#: option.c:3954
+#: option.c:4203
 #, fuzzy
 msgid "bad RR record"
 msgstr "registro PTR errneo"
 
-#: option.c:3984
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "registro PTR errneo"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "registro TXT errneo"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "registro SRV errneo"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "destino SRV errneo"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "prioridad invlida"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "peso invlido"
 
-#: option.c:4073
+#: option.c:4362
 #, fuzzy
 msgid "Bad host-record"
 msgstr "registro PTR errneo"
 
-#: option.c:4097
+#: option.c:4402
 #, fuzzy
 msgid "Bad name in host-record"
 msgstr "nombre errneo en %s"
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 #, fuzzy
 msgid "bad trust anchor"
 msgstr "rango de puertos errneo"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 #, fuzzy
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr "opcin no soportada (verificar que dnsmasq fue compilado con soporte para DHCP/TFTP/DBus)"
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "falta \""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "opcin errnea"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "parmetro extrao"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "parmetro ausente"
 
-#: option.c:4309
+#: option.c:4630
 #, fuzzy
 msgid "illegal option"
 msgstr "opcin errnea"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "error"
 
-#: option.c:4318
+#: option.c:4639
 #, fuzzy, c-format
 msgid " at line %d of %s"
 msgstr "%s en lnea %d de %%s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, fuzzy, c-format
 msgid "read %s"
 msgstr "lee %s"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "no se puede leer %s: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr "basura encontrada en linea de comando"
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Versin dnsmasq %s  %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, fuzzy, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1140,511 +1193,563 @@
 "Opciones de compilacin %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Este software viene SIN NINGUNA GARANTIA.\n"
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsmasq es software libre, y usted est autorizado a redistribuirlo\n"
 
-#: option.c:4733
+#: option.c:5071
 #, fuzzy, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "bajo los trminos de la GNU General Public License, versin 2 o 3.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr "pruebe --help"
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr "pruebe -w"
 
-#: option.c:4748
+#: option.c:5092
 #, fuzzy, c-format
 msgid "bad command line options: %s"
 msgstr "opciones de lnea de comandos errneas: %s"
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "no se puede obtener host-name (nombre de host): %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "solo un archivo resolv.conf est permitido en modo no-poll."
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "debe haber exctamente un resolv.conf desde donde leer dominio."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, fuzzy, c-format
 msgid "failed to read %s: %s"
 msgstr "no se pudo leer %s: %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "ninguna directiva de bsqueda encontrada en %s"
 
-#: option.c:4933
+#: option.c:5274
 #, fuzzy
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr "debe haber un dominio predeterminado cuando --dhcp-fqdn est fijado"
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr "revisin de sintaxis OK"
 
-#: forward.c:102
+#: forward.c:99
 #, fuzzy, c-format
 msgid "failed to send packet: %s"
 msgstr "no se pudo escuchar en socket: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "servidor DNS %s rechaz realizar una bsqueda recursiva"
 
-#: forward.c:684
+#: forward.c:709
 #, fuzzy, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr "posible ataque de revinculacin DNS detectado"
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Nmero mximo de bsquedas DNS simultneas alcanzado. (%s por predeterminado)"
 
-#: network.c:720
+#: network.c:698
 #, fuzzy, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "no se pudo crear un zcalo de escucha: %s"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "advertencia: interfase %s no existe actualmente"
 
-#: network.c:1056
+#: network.c:1027
 #, fuzzy, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "usando direcciones locales solo para %s %s"
 
-#: network.c:1114
+#: network.c:1085
 #, fuzzy, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "el interfase % fall al unirse al grupo multicast DHCPv6: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, fuzzy, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "no se pudo acoplar al zcalo del servidor para %s: %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignorando servidor DNS %s - interfase local"
 
-#: network.c:1539
+#: network.c:1510
 #, fuzzy, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignorando servidor DNS %s - no se puede crear/acoplar zcalo: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "no cualificado"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr "nombres"
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr "predeterminado"
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "dominio"
 
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "usando direcciones locales solo para %s %s"
 
-#: network.c:1575
+#: network.c:1546
 #, fuzzy, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "usando nombres estndar %s#%d para %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, fuzzy, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "usando nombre de servidor %s#%d para %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, fuzzy, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "usando nombre de servidor %s#%d para %s %s"
 
-#: network.c:1584
+#: network.c:1555
 #, fuzzy, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "usando nombre de servidor %s#%d(va %s)"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "usando nombre de servidor %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "usando nombre de servidor %s#%d"
 
-#: network.c:1593
+#: network.c:1564
 #, fuzzy, c-format
 msgid "using %d more nameservers"
 msgstr "usando nombre de servidor %s#%d"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 #, fuzzy
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 #, fuzzy
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "servidor TFTP no disponible: fijar HAVE_TFTP en src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 #, fuzzy
 msgid "cannot use --conntrack AND --query-port"
 msgstr "No puede usar --conntrack AND --query-port"
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 #, fuzzy
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "servidor TFTP no disponible: fijar HAVE_TFTP en src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 #, fuzzy
 msgid "asynchronous logging is not available under Solaris"
 msgstr "registro asncrono no est disponible bajo Solaris"
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 #, fuzzy
 msgid "asynchronous logging is not available under Android"
 msgstr "registro asncrono no est disponible bajo Solaris"
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 #, fuzzy
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 #, fuzzy
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "servidor TFTP no disponible: fijar HAVE_TFTP en src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr "zona serie debe ser configurada en --auth-soa"
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr "constructor rango dhcp no disponible en esta plataforma"
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr "no puede usar --bind-interfases y --bind-dynamic"
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "no se pudo encontrar lista de interfases: %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "interfase desconocida %s"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "error DBus: %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus no disponible: fijar HAVE_DBUS en src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr "usuario o grupo desconocido: %s"
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr "no se puede cambiar directorio a raz de sistema de archivos: %s"
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, fuzzy, c-format
 msgid "started, version %s DNS disabled"
 msgstr "iniciado, versin %s DNS deshabilitado"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "iniciado, versin %s tamao de cach %d"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "iniciado, versin %s cach deshabilitado"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "opciones de compilacin: %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "soporte DBus habilitado: conectado a bus de sistema"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "soporte DBus habilitado: conexin a bus pendiente"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "soporte DBus habilitado: conectado a bus de sistema"
+
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "soporte DBus habilitado: conexin a bus pendiente"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
+#, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
 #, fuzzy, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "advertencia: no se pudo cambiar propietario de %s: %s"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "fijando opcin --bind-interfases debido a limitaciones de sistema operativo"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "advertencia: interfase %s no existe actualmente"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr "advertencia: ignorando opcin resolv-file porque no-resolv est fijado"
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 #, fuzzy
 msgid "warning: no upstream servers configured"
 msgstr "advertencia: ningn servidor de subida configurado"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr "registro asncrono habilitado, el lmite de la cola es %d mensajes"
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr "Anuncio de router IPv6 habilitado"
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr "root est "
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 #, fuzzy
 msgid "enabled"
 msgstr "habilitado"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr "modo seguro"
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "nmero de puerto invlido"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, fuzzy, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr "directorio TFTP % inaccesible: %s"
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr "limitando nmero mximo de transferencias TFTP simultneas a %d"
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "conectado a DBus de sistema"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr "no se puede hacer fork en background: %s"
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, fuzzy, c-format
 msgid "failed to create helper: %s"
 msgstr "no se pudo crear ayudante: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, fuzzy, c-format
 msgid "setting capabilities failed: %s"
 msgstr "configuracin de capacidades ha fallado: %s"
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, fuzzy, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "no se pudo cambiar user-id a %s: %s"
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, fuzzy, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "no se pudo cambiar group-id a %s: %s"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, fuzzy, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "no se pudo abrir archivo PID %s: %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, fuzzy, c-format
 msgid "cannot open log %s: %s"
 msgstr "no se puede abrir registro %s: %s"
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, fuzzy, c-format
 msgid "failed to load Lua script: %s"
 msgstr "no se pudo cargar script Lua %s: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr "directorio TFTP % inaccesible: %s"
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, fuzzy, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "no se puede abrir o crear archivo de concesin %s: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, fuzzy, c-format
 msgid "script process killed by signal %d"
 msgstr "proceso script eliminado por seal %d"
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, fuzzy, c-format
 msgid "script process exited with status %d"
 msgstr "proceso script sali con con estado %d"
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, fuzzy, c-format
 msgid "failed to execute %s: %s"
 msgstr "no se pudo ejecutar %s: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, fuzzy, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "no se pudo abrir archivo PID %s: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "saliendo al recibir SIGTERM"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, fuzzy, c-format
 msgid "failed to access %s: %s"
 msgstr "no se pudo acceder %s: %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "leyendo %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, fuzzy, c-format
 msgid "no servers found in %s, will retry"
 msgstr "ningn servidor encontrado en %s, se reintentar"
@@ -1674,7 +1779,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "no se puede crear zcalo puro ICMP: %s."
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, fuzzy, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "interfase desconocida %s en bridge-interface"
@@ -1684,331 +1789,337 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr "Paquete DHCP recibido en %s que no tiene direccin"
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "rango DHCP %s -- %s no coincide con mscara de subred %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, fuzzy, c-format
 msgid "bad line at %s line %d"
 msgstr "lnea errnea en %s lnea %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr "ignorando %s lnea %d, nombre o direccin IP duplicada"
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr "DHCP relay %s -> %s"
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "demasiadas concesiones almacenadas"
 
-#: lease.c:166
+#: lease.c:176
 #, fuzzy, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "no se puede abrir o crear archivo de concesin %s: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "no se pudo leer %s: %s"
 
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "no se pudo leer %s: %s"
 
-#: lease.c:196
+#: lease.c:204
 #, fuzzy, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "no se puede ejecutar archivo script lease-init %s: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr "archivo guin lease-init retorn cdigo de salida %s"
 
-#: lease.c:373
+#: lease.c:381
 #, fuzzy, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "error al escribir %s: %s (reintentar en %us)"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr "Ignorando dominio %s para nombre de host DHCP %s"
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "ningn rango de direccines disponible para pedido DHCP %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "con selector de subred"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "va"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, fuzzy, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "%u Subred DHCP disponible: %s/%s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, fuzzy, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr "%u Rango DHCP disponible: %s -- %s"
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, fuzzy, c-format
 msgid "%u vendor class: %s"
 msgstr "%u Clase de vendedor: %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, fuzzy, c-format
 msgid "%u user class: %s"
 msgstr "%u Clase de usuario: %s"
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "deshabilitado"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "ignorado"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "direccin en uso"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "ninguna direccin disponible"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "red equivocada"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "ninguna direccin configurada"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "no sobra ninguna concesin"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, fuzzy, c-format
 msgid "%u client provides name: %s"
 msgstr "%u cliente provee nombre: %s"
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr "no hay soporte para BIS PXE"
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, fuzzy, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "deshabilitando direccin DHCP esttica %s para %s"
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "concesin desconocida"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr "no usando direccin configurada %s porque est concedida a %s"
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, fuzzy, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr "no usando direccin configurada %s porque est en uso por el servidor o relay"
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, fuzzy, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr "no usando direccin configurada %s porque fu previamente denegada"
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr "ningn unique-id (identificacin nica)"
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr "ID de servidor equivocada"
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "direccin equivocada"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "concesin no encontrada"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "direccin no disponible"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "concesin esttica disponible"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "direccin reservada"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr "abandonando concesin a %s de %s"
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr "%u nombre de bootfile: %s"
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr "%u nombre de servidor: %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, fuzzy, c-format
 msgid "%u next server: %s"
 msgstr "%u siguiente servidor: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr "%u respuesta broadcast"
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, fuzzy, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "no se puede enviar opcin DHCP/BOOTP %d: no queda espacio en el paquete"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr "men PXE demasiado largo"
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, fuzzy, c-format
 msgid "%u requested options: %s"
 msgstr "%u opciones solicitadas: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr "no se puede enviar opcin RFC3925: demasiadas opciones para nmero enterprise %d"
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, fuzzy, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "no se puede crear zcalo netlink: %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, fuzzy, c-format
 msgid "netlink returns error: %s"
 msgstr "netlink retorna error: %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "intento de fijar direccin de servidor IPv6 va DBus - no hay soporte IPv6"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "fijando servidores subida desde DBus"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "no se pudo registrar un manejador de mensajes DBus"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "no se puede crear zcalo BPF DHCP: %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, fuzzy, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "pedido DHCP por tipo de hardware no-soportado (%d) recibido en %s"
 
-#: bpf.c:378
+#: bpf.c:374
 #, fuzzy, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "no se puede crear zcalo DHCP: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr "la funcin lease() no se encuentra en el script Lua"
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr "incapaz de conseguir puerto libre para TFTP"
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr "pedido no-soportado desde %s"
 
-#: tftp.c:483
+#: tftp.c:510
 #, fuzzy, c-format
 msgid "file %s not found"
 msgstr "archivo %s no encontrado"
 
-#: tftp.c:592
+#: tftp.c:628
 #, fuzzy, c-format
-msgid "error %d %s received from %s"
-msgstr "error TFTP %d %s recibido de %s"
-
-#: tftp.c:634
-#, fuzzy, c-format
 msgid "failed sending %s to %s"
 msgstr "TFTP no pudo enviar %s a %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, fuzzy, c-format
 msgid "sent %s to %s"
 msgstr "TFTP envi %s a %s"
 
+#: tftp.c:678
+#, fuzzy, c-format
+msgid "error %d %s received from %s"
+msgstr "error TFTP %d %s recibido de %s"
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -2023,7 +2134,7 @@
 msgid "FAILED to start up"
 msgstr "el inicio ha FALLADO"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr "Conexin conntrack con marca recuperacin fall"
@@ -2043,81 +2154,76 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "no se pudo acoplar zcalo de servidor DHCP: %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "ningn rango de direccines disponible para pedido DHCP %s %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "ningn rango de direccines disponible para pedido DHCP %s %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, fuzzy, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "%u Subred DHCP disponible: %s/%s"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, fuzzy, c-format
 msgid "%u vendor class: %u"
 msgstr "%u Clase de vendedor: %s"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, fuzzy, c-format
 msgid "%u client MAC address: %s"
 msgstr "%u cliente provee nombre: %s"
 
-#: rfc3315.c:673
-#, fuzzy, c-format
-msgid "unknown prefix-class %d"
-msgstr "clase de prefijo desconocida"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 #, fuzzy
 msgid "address unavailable"
 msgstr "direccin no disponible"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 #, fuzzy
 msgid "no addresses available"
 msgstr "ninguna direccin disponible"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr "no en el enlace"
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr "uniones no encontradas"
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr "descartado"
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 #, fuzzy
 msgid "address invalid"
 msgstr "direccin en uso"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr "confirmacin fall"
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 #, fuzzy
 msgid "all addresses still on link"
 msgstr "direccin errnea en %s lnea %d"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr "concesin recibida"
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr "No puede hacer multicast DHCPv6 sin el interfase correcto"
 
@@ -2131,76 +2237,76 @@
 msgid "%u tags: %s"
 msgstr "%u etiquetas: %s"
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr "%s tiene ms de una direccin en hostsfile, usando %s para DHCP"
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "direccin IP duplicada %s (%s) en directiva dhcp-config"
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, fuzzy, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "no se pudo fijar SO_REUSE{ADDR|PORT} en socket DHCP: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr "Opciones DHCP conocidas:\n"
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, fuzzy, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr "Opciones DHCP conocidas:\n"
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ", prefijo descartado"
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ", tiempo de concesin"
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr "%s aptrida en %s%.0s%.0s%s"
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, fuzzy, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "DHCP, concesin esttica solo en %.0s%s, tiempo de concesin %s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, fuzzy, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr "DHCP, proxy en subred %.0s%s%.0s"
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, fuzzy, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "DHCP, rango de IPs %s -- %s, tiempo de concesin %s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, fuzzy, c-format
 msgid "router advertisement on %s%s"
 msgstr "DHCP, concesin estticos solo en %.0s%s, tiempo de concesin %s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2210,7 +2316,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "no se puede crear socket DHCP: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, fuzzy, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr "pedido no-soportado desde %s"
@@ -2225,20 +2331,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "no se pudo crear socket TFTP: %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "no se pudo abrir archivo PID %s: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, fuzzy, c-format
 msgid "failed to access pf devices: %s"
@@ -2268,12 +2379,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, fuzzy, c-format
 msgid "%d addresses %s"
 msgstr "direccin IP errnea"
@@ -2313,7 +2424,84 @@
 msgid "inotify, new or changed file %s"
 msgstr ""
 
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "no se puede leer %s: %s"
+
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "direccin en uso"
+
+#: dump.c:201
 #, fuzzy
+msgid "failed to write packet dump"
+msgstr "no se pudo escuchar en socket: %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "no se puede abrir registro %s: %s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "no se puede abrir registro %s: %s"
+
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "conectado a DBus de sistema"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "no se pudo escuchar en socket: %s"
+
+#~ msgid "Specify DHCPv6 prefix class"
+#~ msgstr "Especificar prefijo de clase DHCPv6"
+
+#~ msgid "cannot run scripts under uClinux"
+#~ msgstr "no se pueden correr archivos 'script' bajo uClinux"
+
+#~ msgid "cannot match tags in --dhcp-host"
+#~ msgstr "no coinciden etiquetas en --dhcp-host"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "intento de fijar direccin de servidor IPv6 va DBus - no hay soporte IPv6"
+
+#, fuzzy
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "clase de prefijo desconocida"
+
+#, fuzzy
 #~ msgid "cannot cannonicalise resolv-file %s: %s"
 #~ msgstr "no se puede abrir o crear archivo de concesin %s: %s"
 
Index: po/fi.po
===================================================================
--- po/fi.po	(revision 41436)
+++ po/fi.po	(working copy)
@@ -16,70 +16,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr ""
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr ""
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr ""
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr ""
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr ""
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr ""
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr ""
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -93,659 +93,695 @@
 msgid "failed to allocate memory"
 msgstr ""
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr ""
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr ""
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr ""
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr ""
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr ""
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr ""
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr ""
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr ""
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr ""
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr ""
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr ""
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr ""
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr ""
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr ""
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr ""
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr ""
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr ""
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr ""
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr ""
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
-#: option.c:360
+#: option.c:374
 msgid "Read DHCP host specs from a directory."
 msgstr ""
 
-#: option.c:361
+#: option.c:375
 msgid "Read DHCP options from a directory."
 msgstr ""
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr ""
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr ""
 
-#: option.c:365
+#: option.c:379
 msgid "Read hosts files from a directory."
 msgstr ""
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr ""
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr ""
 
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr ""
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr ""
 
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr ""
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr ""
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr ""
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr ""
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr ""
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr ""
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr ""
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr ""
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr ""
 
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr ""
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr ""
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr ""
 
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr ""
 
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr ""
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr ""
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr ""
 
-#: option.c:391
+#: option.c:405
 msgid "Specify path to file with server= options"
 msgstr ""
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr ""
 
-#: option.c:393
+#: option.c:407
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr ""
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr ""
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr ""
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr ""
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr ""
 
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr ""
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr ""
 
-#: option.c:400
+#: option.c:414
 msgid "Specify time-to-live ceiling for cache."
 msgstr ""
 
-#: option.c:401
+#: option.c:415
 msgid "Specify time-to-live floor for cache."
 msgstr ""
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr ""
 
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr ""
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr ""
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr ""
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr ""
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr ""
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr ""
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr ""
 
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr ""
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr ""
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr ""
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr ""
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr ""
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr ""
 
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr ""
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr ""
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr ""
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr ""
 
-#: option.c:439
+#: option.c:455
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr ""
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr ""
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr ""
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
-#: option.c:464
+#: option.c:482
 msgid "Add client identification to forwarded DNS queries."
 msgstr ""
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr ""
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+#: option.c:485
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr ""
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr ""
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr ""
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr ""
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -752,320 +788,332 @@
 "\n"
 msgstr ""
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr ""
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr ""
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr ""
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr ""
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr ""
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr ""
 
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr ""
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr ""
 
-#: option.c:1240
+#: option.c:1366
 msgid "bad IPv4 address"
 msgstr ""
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr ""
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr ""
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr ""
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr ""
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr ""
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr ""
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr ""
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr ""
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr ""
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr ""
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr ""
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr ""
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr ""
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
+#: option.c:3315
+msgid "bad IPv6 prefix"
 msgstr ""
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr ""
 
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr ""
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr ""
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr ""
 
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr ""
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr ""
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
-#: option.c:3796
+#: option.c:4023
+msgid "missing address in alias"
+msgstr ""
+
+#: option.c:4029
 msgid "invalid alias range"
 msgstr ""
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr ""
 
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr ""
 
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr ""
 
-#: option.c:3984
+#: option.c:4236
+msgid "bad CAA record"
+msgstr ""
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr ""
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr ""
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr ""
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr ""
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr ""
 
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr ""
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr ""
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 msgid "bad trust anchor"
 msgstr ""
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr ""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr ""
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr ""
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr ""
 
-#: option.c:4309
+#: option.c:4630
 msgid "illegal option"
 msgstr ""
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr ""
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr ""
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr ""
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr ""
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr ""
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1072,500 +1120,546 @@
 "\n"
 msgstr ""
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr ""
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr ""
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr ""
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr ""
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr ""
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr ""
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr ""
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr ""
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr ""
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr ""
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr ""
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr ""
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr ""
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, c-format
 msgid "warning: using interface %s instead"
 msgstr ""
 
-#: network.c:1056
+#: network.c:1027
 #, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr ""
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr ""
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr ""
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr ""
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr ""
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr ""
 
-#: network.c:1572
+#: network.c:1543
 #, c-format
-msgid "using local addresses only for %s %s"
+msgid "using only locally-known addresses for %s %s"
 msgstr ""
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr ""
 
-#: network.c:1577
+#: network.c:1548
 #, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr ""
 
-#: network.c:1581
+#: network.c:1552
 #, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr ""
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr ""
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr ""
 
-#: network.c:1591
+#: network.c:1562
 #, c-format
 msgid "using %d more local addresses"
 msgstr ""
 
-#: network.c:1593
+#: network.c:1564
 #, c-format
 msgid "using %d more nameservers"
 msgstr ""
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr ""
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr ""
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr ""
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr ""
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr ""
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr ""
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr ""
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr ""
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr ""
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+msgid "UBus support enabled: connected to system bus"
+msgstr ""
+
+#: dnsmasq.c:852
+msgid "UBus support enabled: bus connection pending"
+msgstr ""
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr ""
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr ""
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr ""
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr ""
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr ""
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+msgid "single port mode"
+msgstr ""
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr ""
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr ""
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr ""
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr ""
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr ""
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr ""
@@ -1595,7 +1689,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr ""
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr ""
@@ -1605,329 +1699,334 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr ""
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr ""
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr ""
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr ""
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
+#: lease.c:185
+msgid "failed to parse lease database cleanly"
 msgstr ""
 
-#: lease.c:180
+#: lease.c:188
 #, c-format
 msgid "failed to read lease file %s: %s"
 msgstr ""
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr ""
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr ""
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr ""
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr ""
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr ""
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr ""
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr ""
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr ""
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr ""
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr ""
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr ""
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr ""
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr ""
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr ""
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr ""
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr ""
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr ""
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr ""
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr ""
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr ""
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr ""
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr ""
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr ""
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr ""
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr ""
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr ""
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr ""
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr ""
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr ""
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr ""
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr ""
 
-#: bpf.c:378
+#: bpf.c:374
 #, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr ""
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr ""
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
+msgid "failed sending %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
-msgid "failed sending %s to %s"
+msgid "sent %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:678
 #, c-format
-msgid "sent %s to %s"
+msgid "error %d %s received from %s"
 msgstr ""
 
 #: log.c:190
@@ -1944,7 +2043,7 @@
 msgid "FAILED to start up"
 msgstr ""
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -1964,77 +2063,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr ""
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr ""
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr ""
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr ""
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr ""
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr ""
 
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr ""
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr ""
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr ""
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr ""
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr ""
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2048,76 +2142,76 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr ""
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr ""
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr ""
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2127,7 +2221,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr ""
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2142,20 +2236,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr ""
 
-#: ipset.c:233
+#: ipset.c:226
 #, c-format
 msgid "failed to update ipset %s: %s"
 msgstr ""
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, c-format
 msgid "failed to access pf devices: %s"
@@ -2185,12 +2284,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, c-format
 msgid "%d addresses %s"
 msgstr ""
@@ -2229,3 +2328,62 @@
 #, c-format
 msgid "inotify, new or changed file %s"
 msgstr ""
+
+#: dump.c:64
+#, c-format
+msgid "cannot create %s: %s"
+msgstr ""
+
+#: dump.c:70
+#, c-format
+msgid "bad header in %s"
+msgstr ""
+
+#: dump.c:201
+msgid "failed to write packet dump"
+msgstr ""
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr ""
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr ""
+
+#: ubus.c:112
+msgid "Connected to system UBus"
+msgstr ""
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, c-format
+msgid "Failed to send UBus event: %s"
+msgstr ""
Index: po/fr.po
===================================================================
--- po/fr.po	(revision 41436)
+++ po/fr.po	(working copy)
@@ -14,70 +14,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n > 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr "Impossible de charger les noms  partir de %s : %s"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr "mauvaise adresse dans %s ligne %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "mauvais nom dans %s ligne %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "lecture %s - %d adresses"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "cache vid"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr "Aucune adresse IPv4 trouve pour %s"
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr "%s est un CNAME, il ne sera pas donn au bail DHCP de %s"
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "ne donne pas de nom %s au bail DHCP de %s parce-que le nom existe dans %s avec l'adresse %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr "horodatage %lu"
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "taille de cache %d, %d/%d insertions dans le cache entres non-expires rutilises"
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr "requtes transmises %u, requtes rsolues localement %u"
 
-#: cache.c:1424
+#: cache.c:1669
 #, fuzzy, c-format
 msgid "queries for authoritative zones %u"
 msgstr "Configure la dure de vie (Time To Live) pour les rponses faisant autorit"
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr "serveur %s#%d: requtes envoyes %u, requtes ressayes ou choues %u"
@@ -91,690 +91,729 @@
 msgid "failed to allocate memory"
 msgstr "impossible d'allouer la mmoire"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "impossible d'allouer de la mmoire"
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr "Ne peut pas crer le tube %s : %s"
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr "impossible d'allouer %d octets"
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "illimit(e)"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Spcifie la ou les adresse(s) locales o le dmon doit se mettre  l'coute."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Retourne les adresses IP pour toutes les machines prsentes dans les domaines spcifis"
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Traduction inverse truque pour la plage d'adresse prive RFC1918"
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Traite l'adresse IP comme un domaine inexistant NXDOMAIN (contourne le systeme de redirection de Verisign)"
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Spcifie le nombre d'entres que contiendra le cache (par dfaut : %s)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Spcifie le nom du fichier de configuration (par dfaut : %s)"
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "Ne passe pas en tche de fond : dmarre en mode debug"
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "Ne retransmet pas les requtes qui n'ont pas de domaine."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Retourne les champs MX pour les machines locales."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Etend les noms uniques des machines dans /etc/hosts avec le suffixe du domaine."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "Ne retransmet pas les fausses requtes DNS en provenance des machines Windows."
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Autorise DHCP dans la plage d'adresses donne sur la dure de validit du bail."
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "On change pour ce groupe aprs le dmarrage (par dfaut : %s)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "On assigne une adresse ou un nom pour une machine spcifie."
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr "Lecture des spcifications d'htes DHCP  partir du fichier"
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr "Lecture des options DHCP  partir du fichier"
 
-#: option.c:360
+#: option.c:374
 #, fuzzy
 msgid "Read DHCP host specs from a directory."
 msgstr "Lecture des spcifications d'htes DHCP  partir du fichier"
 
-#: option.c:361
+#: option.c:375
 #, fuzzy
 msgid "Read DHCP options from a directory."
 msgstr "Lecture des options DHCP  partir du fichier"
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr "Expression d'valuation conditionnelle d'tiquette"
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "Ne charge PAS le fichier %s."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Spcifie un nom de fichier hosts  lire en complment de %s"
 
-#: option.c:365
+#: option.c:379
 #, fuzzy
 msgid "Read hosts files from a directory."
 msgstr "Lecture des spcifications d'htes DHCP  partir du fichier"
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Spcifie la ou les interface(s) o le dmon doit se mettre  l'coute."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Spcifie la ou les interface(s) que le dmon ne doit PAS traiter."
 
 #
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr "Associe les classes d'utilisateurs ('user class') DHCP aux options."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr "Associe les identifiants de circuits RFC3046 ('circuit-id') aux options"
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr "Associe les identifiants distants RFC3046 ('remote-id') aux options"
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr "Associe les identifiants de souscripteurs RFC3993 ('subscriber-id') aux options"
 
 #
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Ne pas autoriser DHCP pour les machines numeres dans les options."
 
 #
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Forcer les rponses par 'broadcast' pour les machines numeres dans les options."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "Ne passe pas en tche de fond, ne pas s'excuter en mode debug."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "On considre que l'on est le seul serveur DHCP sur le rseau local."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Spcifie o il faut sauvegarder les baux DHCP (par dfaut : %s)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Retourne les champs MX pour les machines locales."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Spcifie un champ MX."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Spcifie les options BOOTP pour le serveur DHCP."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "Ne pas scruter le fichier %s, ne recharger les modifications que sur rception du signal SIGHUP."
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "Ne place pas en cache le rsultat des requtes qui ont choues."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Utilise les serveurs de noms dans l'ordre donn dans %s."
 
 #
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Options supplmentaires  associer aux clients DHCP."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr "Option DHCP envoye mme si le client de la demande pas."
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Spcifie le port o il faut couter les requtes DNS (par dfaut : 53)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Taille maximale des paquets UDP supports pour EDNS.0 (par dfaut : %s)."
 
 #
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr "Enregistre les requtes DNS dans un journal d'activit."
 
 #
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Force le port d'origine pour les requtes vers les serveurs amonts."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "Ne pas lire le fichier resolv.conf."
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Spcifie le chemin pour le fichier resolv.conf (par dfaut : %s)."
 
-#: option.c:391
+#: option.c:405
 #, fuzzy
 msgid "Specify path to file with server= options"
 msgstr "Spcifie un chemin pour le fichier PID (par dfaut : %s)."
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Spcifie la ou les adresses des serveurs amonts avec des domaines optionels."
 
-#: option.c:393
+#: option.c:407
 #, fuzzy
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Spcifie la ou les adresses des serveurs amonts avec des domaines optionels."
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Ne jamais retransmettre les requtes pour les domaines spcifis."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Spcifie le domaine qui doit etre assign aux baux DHCP."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Spcifie la cible par dfaut dans un champ MX."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Spcifie le TTL en secondes pour les rponses qui utilisent /etc/hosts."
 
 #
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Spcifie le TTL en secondes pour les rponses qui utilisent /etc/hosts."
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Spcifie, en secondes, la valeur maximum de TTL  renvoyer aux clients."
 
 #
-#: option.c:400
+#: option.c:414
 #, fuzzy
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Spcifie le TTL en secondes pour les rponses qui utilisent /etc/hosts."
 
 #
-#: option.c:401
+#: option.c:415
 #, fuzzy
 msgid "Specify time-to-live floor for cache."
 msgstr "Spcifie le TTL en secondes pour les rponses qui utilisent /etc/hosts."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Change pour cet utilisateur aprs le dmarrage (par dfaut : %s)."
 
 #
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr "Associe les classes de fournisseurs ('vendor class') DHCP aux options."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Affiche la version de Dnsmasq et les informations lies au copyright."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Traduit les adresses IPV4 des serveurs amonts."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Spcifie un champ SRV."
 
-#: option.c:407
+#: option.c:421
 #, fuzzy
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr "Afficher ce message. Utiliser --help dhcp pour obtenir la liste des options DHCP connues."
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Spcifie un chemin pour le fichier PID (par dfaut : %s)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Spcifie le nombre maximum de baux DHCP (par dfaut : %s)."
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Repond aux requtes DNS en se basant sur l'interface ou a t envoye la requte."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Spcifie un champ DNS TXT"
 
 #
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr "Spcifie un champ DNS PTR"
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr "Donne le nom DNS pour l'adresse IPv4 de l'interface."
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Association uniquement aux interfaces rseau actuellement actives."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Lecture des informations de DHCP statique  partir de %s."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Autorise l'interface DBus pour la configuration des serveurs amonts, etc."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "Ne pas assurer de fonction DHCP sur cette interface, mais seulement la fonction DNS."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Autorise l'allocation dynamique d'adresse pour bootp."
 
 #
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Associe l'adresse MAC (avec les jokers) aux options."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr "Traiter les requtes DHCP sur les alias comme arrivant de l'interface."
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr "Supprime la vrification d'adresse sur le serveur au moyen de paquets ICMP echo"
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr "Script shell  excuter lors de la cration ou destruction de bail DHCP."
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr "Script Lua  excuter lors de la cration ou destruction de bail DHCP."
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr "Lancer le script 'lease-change' avec cet utilisateur."
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr "Lecture de la configuration dans tous les fichiers de ce rpertoire."
 
 #
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Enregistrer les journaux d'activit dans cette facilit syslog. (dfaut : DAEMON)"
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr "Ne pas utiliser de fichier de baux."
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Spcifie le nombre maximum de requtes DHCP concurrentes (par dfaut : %s)."
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr "Vider le cache DNS lors du rechargement de %s."
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr "Ignorer les noms d'htes fournis par les clients DHCP"
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr "Ne pas rutiliser les champs nom de fichier et serveur dans les options DHCP supplmentaires."
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr "Activer le server TFTP intgr (fonctionnant en lecture seulement)"
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr "N'exporter par TFTP que les fichiers de l'arborescence de fichier spcifie"
 
-#: option.c:435
+#: option.c:451
 #, fuzzy
 msgid "Add client IP or hardware address to tftp-root."
 msgstr "Ajouter les adresses IP clientes  la racine tftp ('tftp-root')."
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr "Accs aux seuls fichiers appartenants  l'utilisateur sous lequel tourne dnsmasq"
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Spcifie le nombre maximum de transfert TFTP concurrents (dfaut : %s)."
 
-#: option.c:439
+#: option.c:455
 #, fuzzy
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Spcifie le nombre maximum de transfert TFTP concurrents (dfaut : %s)."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr "Dsactivation de l'extension TFTP  taille de bloc "
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr "Convertis les noms de fichiers TFTP en minuscule"
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr "Gamme de ports dans laquelle seront choisis les ports temporaires utiliss dans les transferts TFTP."
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr "Traces supplmentaires pour le DHCP."
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr "Active l'criture de traces en mode asynchrone. Peut prendre en option la valeur de la longueur de la queue."
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr "Stopper la rassociation DNS ('DNS rebinding'). Filtre les gammes d'adresses IP prives lors de la rsolution."
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr "Autorise la rassociation de 127.0.0/8, pour les serveurs RBL (Realtime Blackhole List)"
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr "Dsactive la protection contre les rassociation DNS pour ce domaine"
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr "Toujours effectuer les requtes DNS  tous les serveurs."
 
 #
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr "Spcifie le label si le client inclus l'option dans la requte."
 
-#: option.c:450
+#
+#: option.c:467
+#, fuzzy
+msgid "Set tag if client provides given name."
+msgstr "Spcifie le label si le client inclus l'option dans la requte."
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr "Utiliser des ports alternatifs pour le DHCP."
 
 #
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr "Spcifie un champ DNS NAPTR."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr "Dfinie le plus petit port utilis pour la transmission d'une requte DNS."
 
-#: option.c:453
+#: option.c:471
 #, fuzzy
 msgid "Specify highest port available for DNS query transmission."
 msgstr "Dfinie le plus petit port utilis pour la transmission d'une requte DNS."
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr "Utilise seulement les noms de domaine pleinement qualifis pour les clients DHCP."
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr "Gnre les noms d'htes  partir de l'adresse MAC pour les clients sans nom."
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr "Utilise ces relais DHCP en temps que proxy complets."
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr "Requtes de relais DHCP  un serveur distant"
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr "Spcifie un alias pour un nom DNS local."
 
 #
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr "Invite  envoyer aux clients PXE."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr "Service de dmarrage pour menu PXE."
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr "vrification de la syntaxe de la configuration."
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr "Ajoute l'adresse MAC du requteur aux requtes DNS transmises"
 
-#: option.c:463
+#: option.c:481
 #, fuzzy
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr "Ajoute l'adresse MAC du requteur aux requtes DNS transmises"
 
-#: option.c:464
+#: option.c:482
 #, fuzzy
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Ajoute l'adresse MAC du requteur aux requtes DNS transmises"
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Copie dans la rponse DNS le rsultat de la validation DNSSEC effectue par les serveurs DNS amonts."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr "Essaie d'allouer des adresses IP squentielles aux clients DHCP."
 
-#: option.c:467
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Ignorer les noms d'htes fournis par les clients DHCP"
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr "Copie les marques de suivi de connexion pour les requtes amont."
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr "Autoriser les clients DHCP  faire leurs propres mises  jour DDNS (Dynamic DNS)"
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr "Envoyer des annonces de routeurs pour toutes les interfaces faisant du DHCPv6"
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr "Spcifie pour le serveur DHCPv6 un identifiant unique DHCP (DUID) bas sur un numro unique de vendeur (DUID_EN)"
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Spcifie les enregistrements (A/AAAA et PTR) d'un hte."
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr "Dfinie une resource DNS d'un type spcifique"
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "Se lie aux interfaces prexistantes - vrifie l'apparition de nouvelles interfaces"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr "Exporte les noms locaux dans le DNS global"
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr "Domaine  exporter dans le DNS global"
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr "Configure la dure de vie (Time To Live) pour les rponses faisant autorit"
 
-#: option.c:477
+#: option.c:497
 #, fuzzy
 msgid "Set authoritative zone information"
 msgstr "Configure les informations pour une zone de nom faisant autorit"
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr "Serveurs de noms secondaires faisant autorit pour les domaines dlgus"
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr "Pairs autoriss  faire des transferts de zone"
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr "Spcifie les ipsets auxquels les domaines correspondants doivent-tre ajouts"
 
-#: option.c:481
+#: option.c:501
 #, fuzzy
 msgid "Specify a domain and address range for synthesised names"
 msgstr "Spcifie un domaine et une plage d'adresses pour les noms auto-gnrs"
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr "Spcifie le prfixe de classe DHCPv6"
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -783,338 +822,354 @@
 "Usage : dnsmasq [options]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Utilisez les options courtes uniquement sur la ligne de commande.\n"
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr "Les options valides sont :\n"
 
 #
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr "mauvaise adresse"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "numro de port incorrect"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr "association d'interface non supporte"
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
 #
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr "nom d'interface invalide"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr "encapsulation d'option non supporte pour IPv6"
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "mauvaise valeur de 'dhcp-option'"
 
 #
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr "mauvaise adresse IP"
 
 #
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr "mauvaise adresse IPv6"
 
 #
-#: option.c:1240
+#: option.c:1366
 #, fuzzy
 msgid "bad IPv4 address"
 msgstr "mauvaise adresse IPv6"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "mauvais domaine dans dhcp-option"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "dhcp-option trop long"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr "valeur illgale pour 'dhcp-match'"
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr "Une option ne pouvant tre spcifi qu'une seule fois  t donne plusieurs fois"
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr "Mot-clef ne pouvant tre rpt"
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr "Ne peut pas lire le rpertoire %s : %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr "Ne peut pas lire %s : %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr "Sous android, impossible de positionner la cible (facility) pour les traces (logs)."
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr "Mauvaise cible (facility) pour les traces."
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "prference MX incorrecte"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "nom MX incorrect"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "valeur MX cible incorrecte"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr "ne peut excuter de script sous uClinux"
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr "recompiler en dfinissant HAVE_SCRIPT pour permettre l'excution de scripts shell au changement de bail (lease-change)"
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr "recompiler en dfinissant HAVE_LUASCRIPT pour permettre l'excution de scripts LUA au changement de bail (lease-change)"
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr "mauvais prfixe"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr "recompiler en dfinissant HAVE_IPSET pour permettre l'utilisation de directives de groupes d'IP (IPset)"
 
 #
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr "gamme de ports incorrecte"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr "interface-pont incorrecte"
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr "une seule tiquette est autorise"
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "plage d'adresses DHCP (dhcp-range) incorrecte"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "plage d'adresses DHCP incohrente"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr "la taille du prfixe doit tre exactement 64 pour les sous-rseaux d'annonces de routeurs (RA)"
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr "la taille du prfixe doit tre exactement 64 pour le constructeur de sous-rseaux"
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr "la taille de prfixe doit tre au minimum 64"
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr "plage d'adresses DHCPv6 incohrente"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr "le prfixe doit avoir une taille de 0 lorsque l'argument \"constructor:\" est utilis"
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr "mauvaise constante hexadecimale"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr "L'utilisation de labels est prohibe dans --dhcp-host"
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "mauvais prfixe"
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "adresse IP dhcp-host duplique dans %s."
 
 #
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr "nom d'hte DHCP incorrect"
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr "mauvaise tiquette tag-if"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "numro de port invalide"
 
 #
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr "adresse dhcp-proxy incorrecte"
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr "valeur incorrecte pour le relais DHCP (dhcp-relay)"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr "mauvais identifiant unique DHCP (DUID)"
 
+#: option.c:4023
+#, fuzzy
+msgid "missing address in alias"
+msgstr "adresse non valide"
+
 #
-#: option.c:3796
+#: option.c:4029
 msgid "invalid alias range"
 msgstr "poids invalide"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr "mauvais CNAME"
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr "ce CNAME existe dja"
 
 #
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr "mauvais champ PTR"
 
 #
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr "mauvais champ NAPTR"
 
 #
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr "mauvais enregistrement RR"
 
-#: option.c:3984
+#
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "mauvais enregistrement RR"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "champ TXT invalide"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "champ SRV invalide"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "cible SRV invalide"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "priorit invalide"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "poids invalide"
 
 #
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr "mauvais champ host-record"
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr "mauvais nom dans le champ host-record"
 
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
 #
-#: option.c:4162
+#: option.c:4480
 #, fuzzy
 msgid "bad trust anchor"
 msgstr "gamme de ports incorrecte"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 #, fuzzy
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr "option non supporte (vrifier que Dnsmasq a t compil avec le support DHCP/TFTP/DBus)"
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "il manque \""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "mauvaise option"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "paramtre en trop"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "paramtre manquant"
 
-#: option.c:4309
+#: option.c:4630
 #, fuzzy
 msgid "illegal option"
 msgstr "mauvaise option"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "erreur"
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr " la ligne %d de %s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr "Lecture de %s"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "Ne peut pas lire %s : %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr "la ligne de commande contient des lments indsirables ou incomprhensibles"
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Version de Dnsmasq %s  %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1123,510 +1178,562 @@
 "Options  la compilation %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Ce logiciel est fourni sans AUCUNE GARANTIE.\n"
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsmasq est un logiciel libre, il vous est permis de le redistribuer\n"
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "sous les termes de la licence GPL (GNU General Public License), version 2 ou 3.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr "essayez avec --help"
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr "essayez avec -w"
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr "mauvaises options en ligne de commande : %s."
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "ne peut pas obtenir le nom de la machine : %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "seul un fichier resolv.conf est autoris dans le mode no-poll"
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "un fichier resolv.conf (et un seul) est ncessaire pour y rcuperer le nom de domaine."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr "impossible de lire %s : %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "pas de directive de recherche trouve dans %s"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr "un domaine par dfaut doit tre spcifi lorsque l'option --dhcp-fqdn est utilise"
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr "vrification de syntaxe OK"
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr "impossible d'envoyer le paquet : %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "le serveur de nom %s a refus de faire une recherche rcursive"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr "dtection d'une possible attaque de type DNS-rebind: %s"
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Nombre maximum de requtes DNS concurrentes atteint (maximum : %d)."
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "impossible de crer une socket d'coute pour %s : %s"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "attention : l'interface %s n'existe pas actuellement"
 
-#: network.c:1056
+#: network.c:1027
 #, fuzzy, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "utilise les adresses locales seulement pour %s %s"
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "impossible de faire rejoindre l'interface %s dans le groupe multicast DHCPv6 %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "impossible de lier la socket de serveur pour %s : %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignore le serveur de nom %s - interface locale"
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignore le serveur de nom %s - ne peut construire/lier la socket : %m"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "non-qualifi(e)"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr "noms"
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr "dfaut"
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "domaine"
 
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "utilise les adresses locales seulement pour %s %s"
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "utilisation des serveurs de nom standards pour %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, fuzzy, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "utilise le serveur de nom %s#%d pour %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, fuzzy, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "utilise le serveur de nom %s#%d pour %s %s"
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "utilise le serveur de nom %s#%d (via %s)"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "utilise le serveur de nom %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "utilise le serveur de nom %s#%d"
 
-#: network.c:1593
+#: network.c:1564
 #, fuzzy, c-format
 msgid "using %d more nameservers"
 msgstr "utilise le serveur de nom %s#%d"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 #, fuzzy
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DBus n'est pas disponible : activez HAVE_DBUS dans src/config.h"
 
 #
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "TFTP n'est pas disponible : activez HAVE_TFTP dans src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 #, fuzzy
 msgid "cannot use --conntrack AND --query-port"
 msgstr "impossible d'utiliser conjointement --conntrack et --query-port"
 
 #
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 #, fuzzy
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "Support de suivi de connexion non disponible : activez HAVE_CONNTRACK dans src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr "l'criture de traces en mode asynchrone n'est pas disponible sous Solaris."
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr "l'criture de traces en mode asynchrone n'est pas disponible sous Android."
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "le mode  autorit DNS  n'est pas disponible : activez HAVE_AUTH dans src/config.h"
 
 #
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 #, fuzzy
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "TFTP n'est pas disponible : activez HAVE_TFTP dans src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus n'est pas disponible : activez HAVE_DBUS dans src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr "le numro de srie de la zone doit tre configur dans --auth-soa"
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr "le constructeur de plage dhcp n'est pas disponible sur cette plate-forme"
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr "--bind-interfaces et --bind-dynamic sont mutuellement exclusives"
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "impossible de trouver la liste des interfaces : %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "interface %s inconnue"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "DBus n'est pas disponible : activez HAVE_DBUS dans src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "Erreur DBus : %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus n'est pas disponible : activez HAVE_DBUS dans src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus n'est pas disponible : activez HAVE_DBUS dans src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr "utilisateur ou groupe inconnu : %s"
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr "Ne peut effectuer un 'chdir'  la racine du systme de fichier : %s"
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr "dmarrage avec le DNS dsactiv (version %s)"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "demarr, version %s (taille de cache %d)"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "dmarrage avec le cache dsactiv (version %s)"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "options  la compilation : %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "Support DBus autoris : connect au bus systme"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "Support DBus autoris : connexion au bus en attente"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "Support DBus autoris : connect au bus systme"
+
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "Support DBus autoris : connexion au bus en attente"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "Impossible de changer pour l'utilisateur %s : %s"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "active l'option --bind-interfaces  cause de limitations dans le systme d'exploitation"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "attention : l'interface %s n'existe pas actuellement"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr "attention : l'option  resolv-file  sera ignore car  no-resolv  a t spcifi"
 
 #
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr "attention : aucun serveur amont n'est configur"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr "mode asynchrone d'criture de traces, la taille maximum de la queue est de %d messages."
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr "annonces de routeur IPv6 actives"
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr "root est"
 
 #
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr "activ"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr "mode scuris"
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "numro de port invalide"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, fuzzy, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr "rpertoire TFTP %s inaccessible : %s"
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr "le nombre maximum de transferts TFTP simultans sera restreint  %d"
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "connect au systeme DBus"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr "Ne peut se lancer en tche de fond : %s"
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr "impossible de crer le 'helper' : %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr "impossible de configurer la capacit %s"
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "Impossible de changer l'identifiant utilisateur pour %s : %s"
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "Impossible de changer l'identifiant de groupe pour %s : %s"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "impossible de lire le fichier de PID %s : %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr "Ne peut ouvrir le fichier de log %s : %s"
 
 #
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr "impossible de charger le script Lua : %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr "rpertoire TFTP %s inaccessible : %s"
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, fuzzy, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "ne peut ouvrir ou crer le fichiers de baux %s : %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr "Le script a t termin par le signal %d"
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr "Le script s'est termin avec le statut %d"
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr "impossible d'excuter  %s : %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, fuzzy, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "impossible de lire le fichier de PID %s : %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "sortie sur rception du signal SIGTERM"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr "impossible d'accder  %s : %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "Lecture de %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr "aucun serveur trouv dans %s, va ressayer"
@@ -1656,7 +1763,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "ne peut crer de socket en mode raw pour ICMP : %s."
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "interface %s inconnue spcifie comme interface de pont"
@@ -1666,331 +1773,337 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr "Paquet DHCP reu sur %s qui n'a pas d'adresse"
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "La plage d'adresses DHCP %s -- %s n'est pas cohrente avec le masque de rseau %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr "mauvaise ligne dans %s ligne %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr "ignore %s  la ligne %d : duplication de nom ou d'adresse IP"
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr "Relais DHCP %s -> %s"
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "beaucoup trop de baux enregistrs"
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "ne peut ouvrir ou crer le fichiers de baux %s : %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "impossible de lire %s : %s"
 
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "impossible de lire %s : %s"
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "Ne peut pas excuter le script lease-init %s : %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr "le script lease-init a retourn le code %s"
 
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "impossible de lire %s : %s (prochain essai dans %us)"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr "Le domaine %s est ignor pour l'hte DHCP %s"
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "pas de plage d'adresse disponible pour la requte DHCP %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "avec slecteur de sous-reseau"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "par l'intermdiaire de"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "%u sous-rseaux DHCP disponibles : %s/%s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr "%u la gamme DHCP disponible est : %s -- %s"
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr "%u Classe de vendeur ('Vendor Class') : %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr "%u Classe d'utilisateur : %s"
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "dsactiv"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "ignor"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "adresse dj utilise"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "pas d'adresse disponible"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "mauvais rseau"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "pas d'adresse configure"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "plus aucun bail disponible"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr "le client %u fourni le nom : %s"
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr "Service PXE BIS (Boot Integrity Services) non support"
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "dsactive l'adresse statique DHCP %s pour %s"
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "bail inconnu"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr "L'adresse statique %s ne sera pas utilise car un bail est dj attribu  %s"
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr "L'adresse statique %s ne sera pas utilise car elle est utilise par le serveur ou un relai"
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr "L'adresse statique %s ne sera pas utilise car elle a pralablement t refuse"
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr "pas d'identifiant unique"
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr "mauvais identifiant de serveur"
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "mauvaise adresse"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "bail non trouv"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "adresse non disponible"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "bail statique disponible"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "adresse reserve"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr "abandon du bail de %s pour %s"
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr "%u nom de fichier 'bootfile' : %s"
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr "%u nom du serveur : %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr "%u serveur suivant : %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr "%u rponse broadcast"
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "Impossible d'envoyer l'option DHCP/BOOTP %d : pas assez d'espace dans le paquet"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr "menu PXE trop grand"
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr "%u options demandes : %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr "ne peux envoyer l'option RFC3925 : trop d'options pour le numro d'entreprise %d"
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "ne peux lier une socket netlink : %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr "Erreur netlink : %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "tentative de lier une adresse serveur IPV6 via DBus - pas de support IPV6"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "configuration des serveurs amonts  partir de DBus"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "ne peut enregistrer une routine de traitement des messages DBus"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "impossible de crer une socket BPF pour DHCP : %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "requte DHCP pour un type de matriel non support (%d) reue sur %s"
 
-#: bpf.c:378
+#: bpf.c:374
 #, fuzzy, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "ne peut crer la socket DHCP: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr "la fonction lease() est absente du script Lua"
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr "impossible d'obtenir un port libre pour TFTP"
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr "requte de %s non supporte"
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr "fichier %s non trouv"
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
-msgstr "erreur %d %s reu de %s"
-
-#: tftp.c:634
-#, c-format
 msgid "failed sending %s to %s"
 msgstr "impossible d'envoyer %s  %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr "envoy %s  %s"
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr "erreur %d %s reu de %s"
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -2005,7 +2118,7 @@
 msgid "FAILED to start up"
 msgstr "IMPOSSIBLE de dmarrer"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr "La rcupration de la marque de suivi de connexion a chou : %s"
@@ -2025,77 +2138,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "impossible de lier la socket serveur DHCPv6 : %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "pas de plage d'adresse disponible pour la requte DHCPv6 transmise via le relai %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "pas de plage d'adresse disponible pour la requte DHCPv6 via %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "%u sous-rseaux DHCPv6 disponibles : %s/%d"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr "%u Classe de vendeur ('Vendor Class') : %u"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr "%u MAC adresse du client : %s"
 
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr "prfixe de classe inconnu %d"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr "adresse non disponible"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr "russi"
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr "pas d'adresse disponible"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr "pas sur ce lien"
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr "aucune liaison trouve"
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr "obsolte"
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr "adresse non valide"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr "confirmation d'chec"
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr "toutes les adresses sont toujours sur le lien"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr "libration reue"
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr "Impossible de faire du multicast au server DHCPv6 sans interface valide"
 
@@ -2109,76 +2217,76 @@
 msgid "%u tags: %s"
 msgstr "%u options: %s"
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr "%s a plus d'une adresse dans le fichier d'hte, utilisation de %s pour le DHCP."
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "adresse IP %s (%s) duplique dans la directive dhcp-config."
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "impossible de dclarer SO_BINDTODEVICE sur la socket DHCP : %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr "Options DHCP connues :\n"
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr "Options DHCPv6 connues :\n"
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ", prfixe obsolte"
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ", dure de bail "
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr "%s sans tat (stateless) sur %s%.0s%.0s%s"
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "%s, baux statiques seulement sur %.0s%s%s%.0s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr "%s, proxy sur le sous-rseau %.0s%s%.0s"
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "%s, plage d'adresses IP %s -- %s%s%.0s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr "noms IPv6 drivs de DHCPv4 sur %s%s"
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr "annonces de routeurs sur %s%s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr "Relais DHCP de %s  %s via %s"
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr "Relais DHCP de %s  %s"
@@ -2188,7 +2296,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "ne peut crer la socket ICMPv6: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr "la requte de transfert de zone en provenance de %s est ignore"
@@ -2203,20 +2311,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "impossible de crer une socket de contrle IPset : %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "impossible de lire le fichier de PID %s : %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, fuzzy, c-format
 msgid "failed to access pf devices: %s"
@@ -2246,13 +2359,13 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
 #
-#: tables.c:138
+#: tables.c:137
 #, fuzzy, c-format
 msgid "%d addresses %s"
 msgstr "mauvaise adresse"
@@ -2292,7 +2405,83 @@
 msgid "inotify, new or changed file %s"
 msgstr ""
 
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "Ne peut pas lire %s : %s"
+
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "adresse dj utilise"
+
+#: dump.c:201
 #, fuzzy
+msgid "failed to write packet dump"
+msgstr "impossible d'envoyer le paquet : %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "Ne peut ouvrir le fichier de log %s : %s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "Ne peut ouvrir le fichier de log %s : %s"
+
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "connect au systeme DBus"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "impossible d'envoyer le paquet : %s"
+
+#~ msgid "Specify DHCPv6 prefix class"
+#~ msgstr "Spcifie le prfixe de classe DHCPv6"
+
+#~ msgid "cannot run scripts under uClinux"
+#~ msgstr "ne peut excuter de script sous uClinux"
+
+#~ msgid "cannot match tags in --dhcp-host"
+#~ msgstr "L'utilisation de labels est prohibe dans --dhcp-host"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "tentative de lier une adresse serveur IPV6 via DBus - pas de support IPV6"
+
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "prfixe de classe inconnu %d"
+
+#, fuzzy
 #~ msgid "cannot cannonicalise resolv-file %s: %s"
 #~ msgstr "ne peut ouvrir ou crer le fichiers de baux %s : %s"
 
Index: po/id.po
===================================================================
--- po/id.po	(revision 41436)
+++ po/id.po	(working copy)
@@ -15,77 +15,77 @@
 "Content-Type: text/plain; charset=ASCII\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
 # OK
-#: cache.c:928
+#: cache.c:1081
 #, fuzzy, c-format
 msgid "failed to load names from %s: %s"
 msgstr "gagal memuat nama-nama dari %s: %s"
 
 # OK
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, fuzzy, c-format
 msgid "bad address at %s line %d"
 msgstr "kesalahan nama pada %s baris %d"
 
 # OK
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "kesalahan nama pada %s baris %d"
 
 # OK
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "cache telah dihapus"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
 # OK
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "tidak memberikan nama %s kepada lease DHCP %s karena nama telah ada dalam %sdengan alamat %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
 # OK
-#: cache.c:1419
+#: cache.c:1664
 #, fuzzy, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "ukuran cache %d, %d/%d penyisipan cache menimpa cache yang belum kadaluwarsa"
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -103,769 +103,807 @@
 msgstr "gagal memuat %S: %m"
 
 # OK
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "tidak bisa mendapatkan memory"
 
 # OK
-#: util.c:291
+#: util.c:302
 #, fuzzy, c-format
 msgid "cannot create pipe: %s"
 msgstr "tidak bisa membaca %s: %s"
 
 # OK
-#: util.c:299
+#: util.c:310
 #, fuzzy, c-format
 msgid "failed to allocate %d bytes"
 msgstr "gagal memuat %S: %m"
 
 # OK
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "tak terbatas"
 
 # OK
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Tentukan alamat lokal untuk mendengarkan."
 
 # OK
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Menghasilkan ipaddr untuk semua host dalam domain yang dipilih."
 
 # OK
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Fake pencarian balik untuk alamat private sesuai dengan RFC1918."
 
 # OK
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Perlakukan ipaddr sebagai NXDOMAIN (mengalahkan wildcard Verisign)."
 
 # OK
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Tentukan ukuran cache, dalam jumlah isian (default %s)."
 
 # OK
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Tentukan file konfigurasi (default %s)."
 
 # OK
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "JANGAN berjalan di background: berjalan dalam modus debug."
 
 # OK
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "JANGAN teruskan permintaan tanpa bagian domain."
 
 # OK
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Mengembalikan record MX untuk diri sendiri host-host lokal."
 
 # OK
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Melengkapi nama-nama di /etc/hosts dengan akhiran domain."
 
 # OK
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "Jangan meneruskan permintaan DNS spurious dari host-host Windows."
 
 # OK
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Bolehkan DHCP dalam jangkauan yang diberikan dengan durasi lease."
 
 # OK
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Ubah ke group ini setelah mulai (default %s)."
 
 # OK
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Setel alamat atau nama host untuk mesin yang disebutkan."
 
 # OK
-#: option.c:358
+#: option.c:372
 #, fuzzy
 msgid "Read DHCP host specs from file."
 msgstr "nama MX salah"
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
 # OK
-#: option.c:360
+#: option.c:374
 #, fuzzy
 msgid "Read DHCP host specs from a directory."
 msgstr "nama MX salah"
 
 # OK
-#: option.c:361
+#: option.c:375
 #, fuzzy
 msgid "Read DHCP options from a directory."
 msgstr "nama MX salah"
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
 # OK
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "JANGAN muat file %s."
 
 # OK
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Sebutkan sebuah file hosts yang harus dibaca sebagai tambahan untuk %s."
 
 # OK
-#: option.c:365
+#: option.c:379
 #, fuzzy
 msgid "Read hosts files from a directory."
 msgstr "nama MX salah"
 
 # OK
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Sebutkan antarmuka untuk mendengarkan."
 
 # OK
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Sebutkan antarmuka untuk TIDAK mendengarkan."
 
 # OK
-#: option.c:368
+#: option.c:382
 #, fuzzy
 msgid "Map DHCP user class to tag."
 msgstr "Petakan kelas user DHCP ke setelan yang dipilih."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
 # OK
-#: option.c:372
+#: option.c:386
 #, fuzzy
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Jangan menggunakan DHCP untuk host-host yang dipilih."
 
 # OK
-#: option.c:373
+#: option.c:387
 #, fuzzy
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Jangan menggunakan DHCP untuk host-host yang dipilih."
 
 # OK
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "JANGAN berjalan di background, jangan berjalan dalam modus debug."
 
 # OK
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Berpikir bahwa kita satu-satunya DHCP server dalam jaringan."
 
 # OK
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Sebutkan lokasi untuk menyimpan lease DHCP (default %s)."
 
 # OK
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Kembalikan rekord MX untuk host-host lokal."
 
 # OK
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Sebutkan sebuah rekord MX."
 
 # OK
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Sebutkan pilihan-pilihan BOOTP untuk DHCP server."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "Jangan kumpulkan file %s, muat kembali saat SIGHUP."
 
 # OK
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "JANGAN menyimpan hasil pencarian yang gagal."
 
 # OK
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Gunakan secara ketat namaserver yang disebutkan sesuai urutan di %s."
 
 # OK
-#: option.c:383
+#: option.c:397
 #, fuzzy
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Setel pilihan-pilihan tambahan yang akan disetel untuk klien-klien DHCP."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
 # OK
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Sebutkan port untuk mendengarkan permintaan DNS (default port 53)."
 
 # OK
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Ukuran maksimum paket UDP yang didukung untuk EDNS.0 (default %s)."
 
 # OK
-#: option.c:387
+#: option.c:401
 #, fuzzy
 msgid "Log DNS queries."
 msgstr "Permintaan log."
 
 # OK
-#: option.c:388
+#: option.c:402
 #, fuzzy
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Paksa port asal untuk permintaan ke atas."
 
 # OK
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "JANGAN baca resolv.conf."
 
 # OK
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Sebutkan path ke resolv.conf (default %s)."
 
 # OK
-#: option.c:391
+#: option.c:405
 #, fuzzy
 msgid "Specify path to file with server= options"
 msgstr "Sebutkan path file PID. (default %s)."
 
 # OK
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Sebutkan alamat-alamat server di atas, boleh dilengkapi dengan nama domain."
 
 # OK
-#: option.c:393
+#: option.c:407
 #, fuzzy
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Sebutkan alamat-alamat server di atas, boleh dilengkapi dengan nama domain."
 
 # OK
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "JANGAN pernah meneruskan permintaan ke domain yang disebutkan."
 
 # OK
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Sebutkan domain yang digunakan dalam lease DHCP."
 
 # OK
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Sebutkan tujuan default dalam rekord MX."
 
 # OK
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Sebutkan time-to-live dalam detik untuk jawaban dari /etc/hosts."
 
 # OK
-#: option.c:398
+#: option.c:412
 #, fuzzy
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Sebutkan time-to-live dalam detik untuk jawaban dari /etc/hosts."
 
 # OK
-#: option.c:399
+#: option.c:413
 #, fuzzy
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Sebutkan time-to-live dalam detik untuk jawaban dari /etc/hosts."
 
 # OK
-#: option.c:400
+#: option.c:414
 #, fuzzy
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Sebutkan time-to-live dalam detik untuk jawaban dari /etc/hosts."
 
 # OK
-#: option.c:401
+#: option.c:415
 #, fuzzy
 msgid "Specify time-to-live floor for cache."
 msgstr "Sebutkan time-to-live dalam detik untuk jawaban dari /etc/hosts."
 
 # OK
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Ubah ke user ini setelah mulai. (default %s)."
 
 # OK
-#: option.c:403
+#: option.c:417
 #, fuzzy
 msgid "Map DHCP vendor class to tag."
 msgstr "Memetakan kelas vendor DHCP ke daftar pilihan."
 
 # OK
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Menampilkan versi dan informasi hak cipta dnsmasq."
 
 # OK
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Terjemahkan alamat-alamat IPv4 dari server-server di atas."
 
 # OK
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Sebutkan rekord SRV."
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
 # OK
-#: option.c:408
+#: option.c:422
 #, fuzzy, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Sebutkan path file PID. (default %s)."
 
 # OK
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Sebutkan jumlah maksimum lease DHCP (default %s)."
 
 # OK
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Jawab permintaan DNS berdasarkan antarmuka dimana permintaan dikirimkan."
 
 # OK
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Sebutkan rekord TXT DNS."
 
 # OK
-#: option.c:412
+#: option.c:426
 #, fuzzy
 msgid "Specify PTR DNS record."
 msgstr "Sebutkan rekord TXT DNS."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
 # OK
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Hanya kaitkan ke antarmuka yang sedang digunakan saja."
 
 # OK
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Baca informasi statik host DHCP dari %s."
 
 # OK
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Mungkinkan antar muka DBus untuk menyetel server-server di atas, dsb."
 
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
 # OK
-#: option.c:417
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "JANGAN menyediakan DHCP pada antarmuka ini, hanya menyediakan DNS."
 
 # OK
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Mungkinkan alokasi alamat dinamis untuk bootp."
 
 # OK
-#: option.c:419
+#: option.c:434
 #, fuzzy
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Memetakan kelas vendor DHCP ke daftar pilihan."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
 # OK
-#: option.c:427
+#: option.c:443
 #, fuzzy
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Ubah ke user ini setelah mulai. (default %s)."
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
 # OK
-#: option.c:429
+#: option.c:445
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Sebutkan jumlah maksimum lease DHCP (default %s)."
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
 # OK
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Sebutkan jumlah maksimum lease DHCP (default %s)."
 
 # OK
-#: option.c:439
+#: option.c:455
 #, fuzzy
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Sebutkan jumlah maksimum lease DHCP (default %s)."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
 # OK
-#: option.c:451
+#: option.c:469
 #, fuzzy
 msgid "Specify NAPTR DNS record."
 msgstr "Sebutkan rekord TXT DNS."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
 # OK
-#: option.c:459
+#: option.c:477
 #, fuzzy
 msgid "Prompt to send to PXE clients."
 msgstr "Setel pilihan-pilihan tambahan yang akan disetel untuk klien-klien DHCP."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
 # OK
-#: option.c:464
+#: option.c:482
 #, fuzzy
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Paksa port asal untuk permintaan ke atas."
 
 # OK
-#: option.c:465
+#: option.c:483
 #, fuzzy
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Terjemahkan alamat-alamat IPv4 dari server-server di atas."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+# OK
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Setel pilihan-pilihan tambahan yang akan disetel untuk klien-klien DHCP."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
 # OK
-#: option.c:471
+#: option.c:490
 #, fuzzy
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Sebutkan sebuah rekord MX."
 
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
 # OK
-#: option.c:472
+#: option.c:492
 #, fuzzy
 msgid "Specify arbitrary DNS resource record"
 msgstr "Sebutkan rekord TXT DNS."
 
 # OK
-#: option.c:473
+#: option.c:493
 #, fuzzy
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "antarmuka tidak dikenal %s"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
 # OK
-#: option.c:703
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -875,391 +913,409 @@
 "\n"
 
 # OK
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Gunakan pilihan pendek saja pada perintah baris.\n"
 
 # OK
-#: option.c:707
+#: option.c:729
 #, fuzzy, c-format
 msgid "Valid options are:\n"
 msgstr "Pilihan yang boleh adalah:\n"
 
 # OK
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 #, fuzzy
 msgid "bad address"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "port salah"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
 # OK
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 #, fuzzy
 msgid "bad interface name"
 msgstr "nama MX salah"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
 # OK
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "dhcp-option salah"
 
 # OK
-#: option.c:1144
+#: option.c:1270
 #, fuzzy
 msgid "bad IP address"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 #, fuzzy
 msgid "bad IPv6 address"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: option.c:1240
+#: option.c:1366
 #, fuzzy
 msgid "bad IPv4 address"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "domain dalam dhcp-option salah"
 
 # OK
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "dhcp-option terlalu panjang"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
 # OK
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, fuzzy, c-format
 msgid "cannot access directory %s: %s"
 msgstr "tidak bisa membaca %s: %s"
 
 # OK
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, fuzzy, c-format
 msgid "cannot access %s: %s"
 msgstr "tidak bisa membaca %s: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
 # OK
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "kesukaan MX salah"
 
 # OK
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "nama MX salah"
 
 # OK
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "target MX salah"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
 # OK
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 #, fuzzy
 msgid "bad prefix"
 msgstr "port salah"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
 # OK
-#: option.c:2713
+#: option.c:2871
 #, fuzzy
 msgid "bad port range"
 msgstr "port salah"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
 # OK
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "dhcp-range salah"
 
 # OK
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "jangkauan DHCP tidak konsisten"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
 # OK
-#: option.c:2925
+#: option.c:3123
 #, fuzzy
 msgid "inconsistent DHCPv6 range"
 msgstr "jangkauan DHCP tidak konsisten"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
 # OK
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 #, fuzzy
 msgid "bad hex constant"
 msgstr "dhcp-host salah"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr ""
+# OK
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "port salah"
 
 # OK
-#: option.c:3119
+#: option.c:3362
 #, fuzzy, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "alamat IP kembar %s dalam direktif dhcp-config"
 
 # OK
-#: option.c:3177
+#: option.c:3422
 #, fuzzy
 msgid "bad DHCP host name"
 msgstr "nama MX salah"
 
 # OK
-#: option.c:3259
+#: option.c:3508
 #, fuzzy
 msgid "bad tag-if"
 msgstr "target MX salah"
 
 # OK
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "nomor port tidak benar"
 
 # OK
-#: option.c:3678
+#: option.c:3907
 #, fuzzy
 msgid "bad dhcp-proxy address"
 msgstr "membaca %s - %d alamat"
 
 # OK
-#: option.c:3704
+#: option.c:3935
 #, fuzzy
 msgid "Bad dhcp-relay"
 msgstr "dhcp-range salah"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
 # OK
-#: option.c:3796
+#: option.c:4023
 #, fuzzy
+msgid "missing address in alias"
+msgstr "alamat telah digunakan"
+
+# OK
+#: option.c:4029
+#, fuzzy
 msgid "invalid alias range"
 msgstr "weight tidak benar"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
 # OK
-#: option.c:3889
+#: option.c:4132
 #, fuzzy
 msgid "bad PTR record"
 msgstr "rekord SRV salah"
 
 # OK
-#: option.c:3920
+#: option.c:4167
 #, fuzzy
 msgid "bad NAPTR record"
 msgstr "rekord SRV salah"
 
 # OK
-#: option.c:3954
+#: option.c:4203
 #, fuzzy
 msgid "bad RR record"
 msgstr "rekord SRV salah"
 
 # OK
-#: option.c:3984
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "rekord SRV salah"
+
+# OK
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "rekord TXT salah"
 
 # OK
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "rekord SRV salah"
 
 # OK
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "target SRV salah"
 
 # OK
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "prioritas tidak benar"
 
 # OK
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "weight tidak benar"
 
 # OK
-#: option.c:4073
+#: option.c:4362
 #, fuzzy
 msgid "Bad host-record"
 msgstr "rekord SRV salah"
 
 # OK
-#: option.c:4097
+#: option.c:4402
 #, fuzzy
 msgid "Bad name in host-record"
 msgstr "kesalahan nama di %s"
 
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
 # OK
-#: option.c:4162
+#: option.c:4480
 #, fuzzy
 msgid "bad trust anchor"
 msgstr "port salah"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
 # OK
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "kurang \""
 
 # OK
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "pilihan salah"
 
 # OK
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "parameter berlebihan"
 
 # OK
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "parameter kurang"
 
 # OK
-#: option.c:4309
+#: option.c:4630
 #, fuzzy
 msgid "illegal option"
 msgstr "pilihan salah"
 
 # OK
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "kesalahan"
 
 # OK
-#: option.c:4318
+#: option.c:4639
 #, fuzzy, c-format
 msgid " at line %d of %s"
 msgstr "%s pada baris %d dari %%s"
 
 # OK
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, fuzzy, c-format
 msgid "read %s"
 msgstr "membaca %s"
 
 # OK
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "tidak bisa membaca %s: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
 # OK
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Dnsmasq versi %s  %s\n"
 
 # OK
-#: option.c:4730
+#: option.c:5068
 #, fuzzy, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1269,567 +1325,625 @@
 "\n"
 
 # OK
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Perangkat lunak ini tersedia TANPA JAMINAN SEDIKITPUN.\n"
 
 # OK
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsdmasq adalah perangkat lunak bebas, dan Anda dipersilahkan untuk membagikannya\n"
 
 # OK
-#: option.c:4733
+#: option.c:5071
 #, fuzzy, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "dengan aturan GNU General Public License, versi 2.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
 # OK
-#: option.c:4748
+#: option.c:5092
 #, fuzzy, c-format
 msgid "bad command line options: %s"
 msgstr "pilihan baris perintah salah: %s."
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
 # OK
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "tidak bisa mendapatkan host-name: %s"
 
 # OK
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "hanya satu file resolv.conf yang diperbolehkan dalam modus no-poll."
 
 # OK
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "harus mempunyai tepat satu resolv.conf untuk mendapatkan nama domain."
 
 # OK
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, fuzzy, c-format
 msgid "failed to read %s: %s"
 msgstr "gagal membaca %s: %s"
 
 # OK
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "tidak ditemukan direktif search di %s"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
 # OK
-#: forward.c:102
+#: forward.c:99
 #, fuzzy, c-format
 msgid "failed to send packet: %s"
 msgstr "gagal mendengarkan di socket: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
 # OK
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "nameserver %s menolak melakukan resolusi rekursif"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
 # OK
-#: forward.c:2184
+#: forward.c:2321
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Sebutkan jumlah maksimum lease DHCP (default %s)."
 
 # OK
-#: network.c:720
+#: network.c:698
 #, fuzzy, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "gagal membuat socket: %s "
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
 # OK
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "peringatan: antarmuka %s tidak ada"
 
 # OK
-#: network.c:1056
+#: network.c:1027
 #, fuzzy, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "menggunakan alamat lokal saja untuk %s %s"
 
 # OK
-#: network.c:1114
+#: network.c:1085
 #, fuzzy, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "gagal mem-bind socket server DHCP: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, fuzzy, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "gagal mem-bind socket untuk mendengarkan %s: %s"
 
 # OK
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "mengabaikan nameserver %s - antarmuka lokal"
 
 # OK
-#: network.c:1539
+#: network.c:1510
 #, fuzzy, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "mengabaikan nameserver %s - tak dapat membuat/mem-bind socket: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
 # OK
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "tidak memenuhi syarat"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
 # OK
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "domain"
 
 # OK
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "menggunakan alamat lokal saja untuk %s %s"
 
 # OK
-#: network.c:1575
+#: network.c:1546
 #, fuzzy, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "menggunakan nameserver %s#%d untuk %s %s"
 
 # OK
-#: network.c:1577
+#: network.c:1548
 #, fuzzy, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "menggunakan nameserver %s#%d untuk %s %s"
 
 # OK
-#: network.c:1581
+#: network.c:1552
 #, fuzzy, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "menggunakan nameserver %s#%d untuk %s %s"
 
 # OK
-#: network.c:1584
+#: network.c:1555
 #, fuzzy, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "menggunakan nameserver %s#%d"
 
 # OK
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "menggunakan nameserver %s#%d"
 
 # OK
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "menggunakan nameserver %s#%d"
 
 # OK
-#: network.c:1593
+#: network.c:1564
 #, fuzzy, c-format
 msgid "using %d more nameservers"
 msgstr "menggunakan nameserver %s#%d"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
 # OK
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 #, fuzzy
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
 # OK
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 #, fuzzy
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
 # OK
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 #, fuzzy
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
 # OK
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 #, fuzzy
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
 # OK
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 #, fuzzy
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
-#: dnsmasq.c:229
+# OK
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
 # OK
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "gagal mendapatkan daftar antarmuka: %s"
 
 # OK
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "antarmuka tidak dikenal %s"
 
 # OK
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
+
+# OK
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "DBus error: %s"
 
 # OK
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
 
-#: dnsmasq.c:410
+# OK
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus tidak tersedia: setel HAVE_DBUS dalam src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
 # OK
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, fuzzy, c-format
 msgid "started, version %s DNS disabled"
 msgstr "dimulai, cache versi %s di disable"
 
 # OK
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "dimulai, versi %s ukuran cache %d"
 
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
 # OK
-#: dnsmasq.c:736
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "dimulai, cache versi %s di disable"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
 # OK
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "pilihan-pilihan saat kompilasi: %s"
 
 # OK
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "dukungan DBus dimungkinkan: terkoneksi pada bus sistem"
 
 # OK
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "dukungan DBus dimungkinkan: koneksi bus ditunda"
 
-#: dnsmasq.c:771
+# OK
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "dukungan DBus dimungkinkan: terkoneksi pada bus sistem"
+
+# OK
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "dukungan DBus dimungkinkan: koneksi bus ditunda"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
+#: dnsmasq.c:884
+#, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
 # OK
-#: dnsmasq.c:783
+#: dnsmasq.c:890
 #, fuzzy, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "gagal memuat nama-nama dari %s: %s"
 
 # OK
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "setelan opsi --bind-interfaces disebabkan keterbatasan OS"
 
 # OK
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "peringatan: antarmuka %s tidak ada"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
 # OK
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 #, fuzzy
 msgid "warning: no upstream servers configured"
 msgstr "menyetel server-server di atas dengan DBus"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
 # OK
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 #, fuzzy
 msgid "enabled"
 msgstr "di disable"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+# OK
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "nomor port tidak benar"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "terhubung ke sistem DBus"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, fuzzy, c-format
 msgid "failed to create helper: %s"
 msgstr "gagal membaca %s: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, fuzzy, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "gagal memuat nama-nama dari %s: %s"
 
 # OK
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, fuzzy, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "gagal memuat nama-nama dari %s: %s"
 
 # OK
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, fuzzy, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "gagal membaca %s: %s"
 
 # OK
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, fuzzy, c-format
 msgid "cannot open log %s: %s"
 msgstr "tidak bisa membuka %s:%s"
 
 # OK
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, fuzzy, c-format
 msgid "failed to load Lua script: %s"
 msgstr "gagal memuat %S: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, fuzzy, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "tidak dapat membuka atau membuat file lease: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, fuzzy, c-format
 msgid "failed to execute %s: %s"
 msgstr "gagal mengakses %s: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
 # OK
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, fuzzy, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "gagal membaca %s: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "keluar karena menerima SIGTERM"
 
 # OK
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, fuzzy, c-format
 msgid "failed to access %s: %s"
 msgstr "gagal mengakses %s: %s"
 
 # OK
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "membaca %s"
 
 # OK
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, fuzzy, c-format
 msgid "no servers found in %s, will retry"
 msgstr "tidak ditemukan direktif search di %s"
@@ -1865,7 +1979,7 @@
 msgstr "tidak dapat membuat socket ICMP raw: %s"
 
 # OK
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, fuzzy, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "antarmuka tidak dikenal %s"
@@ -1875,371 +1989,377 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
 # OK
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "jangkauan DHCP %s -- %s tidak konsisten dengan netmask %s"
 
 # OK
-#: dhcp.c:854
+#: dhcp.c:914
 #, fuzzy, c-format
 msgid "bad line at %s line %d"
 msgstr "kesalahan nama pada %s baris %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
 # OK
-#: lease.c:98
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "terlalu banyak lease yang disimpan"
 
 # OK
-#: lease.c:166
+#: lease.c:176
 #, fuzzy, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "tidak dapat membuka atau membuat file lease: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+# OK
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "gagal membaca %s: %s"
 
 # OK
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "gagal membaca %s: %s"
 
 # OK
-#: lease.c:196
+#: lease.c:204
 #, fuzzy, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "tidak bisa membaca %s: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
 # OK
-#: lease.c:373
+#: lease.c:381
 #, fuzzy, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "gagal membaca %s: %s"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
 # OK
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "tidak ada alamat yang bisa dipakai untuk permintaan DHCP %s %s"
 
 # OK
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "dengan pemilih subnet"
 
 # OK
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "lewat"
 
 # OK
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, fuzzy, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "tidak ada alamat yang bisa dipakai untuk permintaan DHCP %s %s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
 # OK
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, fuzzy, c-format
 msgid "%u vendor class: %s"
 msgstr "DBus error: %s"
 
 # OK
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, fuzzy, c-format
 msgid "%u user class: %s"
 msgstr "DBus error: %s"
 
 # OK
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "di disable"
 
 # OK
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "diabaikan"
 
 # OK
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "alamat telah digunakan"
 
 # OK
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "tak ada alamat yang tersedia"
 
 # OK
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "jaringan yang salah"
 
 # OK
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "tak ada alamat yang disetel"
 
 # OK
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "tak ada lease yang tersisa"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
 # OK
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, fuzzy, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "men-disable alamat statik DHCP %s"
 
 # OK
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "lease tidak diketahui"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
 # OK
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "alamat salah"
 
 # OK
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "lease tak ditemukan"
 
 # OK
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "alamat tak tersedia"
 
 # OK
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "lease statik tak tersedia"
 
 # OK
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "alamat telah dipesan"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
 # OK
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, fuzzy, c-format
 msgid "%u server name: %s"
 msgstr "DBus error: %s"
 
 # OK
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, fuzzy, c-format
 msgid "%u next server: %s"
 msgstr "DBus error: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr ""
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
 # OK
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, fuzzy, c-format
 msgid "%u requested options: %s"
 msgstr "pilihan-pilihan saat kompilasi: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
 # OK
-#: netlink.c:77
+#: netlink.c:76
 #, fuzzy, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "tidak bisa mem-bind netlink socket: %s"
 
 # OK
-#: netlink.c:355
+#: netlink.c:352
 #, fuzzy, c-format
 msgid "netlink returns error: %s"
 msgstr "DBus error: %s"
 
-# OK
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "mencoba menyetel sebuah alamat IPv6 server lewat DBus - tidak ada dukungan untuk IPv6"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
 # OK
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "menyetel server-server di atas dengan DBus"
 
 # OK
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "tidak bisa mendaftar sebuah DBus message handler"
 
 # OK
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "tidak dapat membuat socket DHCP BPF: %s"
 
 # OK
-#: bpf.c:293
+#: bpf.c:289
 #, fuzzy, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "permintaan DHCP untuk tipe hardware yang tidak didukung (%d) diterima pada %s"
 
 # OK
-#: bpf.c:378
+#: bpf.c:374
 #, fuzzy, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "tidak bisa membuat socket DHCP: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
 # OK
-#: tftp.c:483
+#: tftp.c:510
 #, fuzzy, c-format
 msgid "file %s not found"
 msgstr "lease tak ditemukan"
 
-#: tftp.c:592
-#, c-format
-msgid "error %d %s received from %s"
-msgstr ""
-
 # OK
-#: tftp.c:634
+#: tftp.c:628
 #, fuzzy, c-format
 msgid "failed sending %s to %s"
 msgstr "gagal membaca %s: %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr ""
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr ""
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -2255,7 +2375,7 @@
 msgid "FAILED to start up"
 msgstr "GAGAL untuk memulai"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -2279,90 +2399,84 @@
 msgstr "gagal mem-bind socket server DHCP: %s"
 
 # OK
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "tidak ada alamat yang bisa dipakai untuk permintaan DHCP %s %s"
 
 # OK
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "tidak ada alamat yang bisa dipakai untuk permintaan DHCP %s %s"
 
 # OK
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, fuzzy, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "tidak ada alamat yang bisa dipakai untuk permintaan DHCP %s %s"
 
 # OK
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, fuzzy, c-format
 msgid "%u vendor class: %u"
 msgstr "DBus error: %s"
 
 # OK
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, fuzzy, c-format
 msgid "%u client MAC address: %s"
 msgstr "tidak ada antarmuka dengan alamat %s"
 
 # OK
-#: rfc3315.c:673
-#, fuzzy, c-format
-msgid "unknown prefix-class %d"
-msgstr "lease tidak diketahui"
-
-# OK
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 #, fuzzy
 msgid "address unavailable"
 msgstr "alamat tak tersedia"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
 # OK
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 #, fuzzy
 msgid "no addresses available"
 msgstr "tak ada alamat yang tersedia"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
 # OK
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 #, fuzzy
 msgid "address invalid"
 msgstr "alamat telah digunakan"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
 # OK
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 #, fuzzy
 msgid "all addresses still on link"
 msgstr "kesalahan nama pada %s baris %d"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2376,81 +2490,81 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
 # OK
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "alamat IP kembar %s (%s) dalam direktif dhcp-config"
 
 # OK
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, fuzzy, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "gagal menyetel SO_REUSEADDR pada socket DHCP: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
 # OK
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, fuzzy, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "DHCP, lease static pada %.0s%s, waktu lease %s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
 # OK
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, fuzzy, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "DHCP, jangkaun IP %s -- %s, waktu lease %s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
 # OK
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, fuzzy, c-format
 msgid "router advertisement on %s%s"
 msgstr "DHCP, lease static pada %.0s%s, waktu lease %s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2461,7 +2575,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "tidak bisa membuat socket DHCP: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2479,20 +2593,25 @@
 msgstr "gagal membuat socket: %s "
 
 # OK
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "gagal membaca %s: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 # OK
 #: tables.c:61
 #, fuzzy, c-format
@@ -2526,13 +2645,13 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
 # OK
-#: tables.c:138
+#: tables.c:137
 #, fuzzy, c-format
 msgid "%d addresses %s"
 msgstr "membaca %s - %d alamat"
@@ -2577,7 +2696,84 @@
 msgstr ""
 
 # OK
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "tidak bisa membaca %s: %s"
+
+# OK
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "alamat telah digunakan"
+
+# OK
+#: dump.c:201
 #, fuzzy
+msgid "failed to write packet dump"
+msgstr "gagal mendengarkan di socket: %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+# OK
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "tidak bisa membuka %s:%s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+# OK
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "tidak bisa membuka %s:%s"
+
+# OK
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "terhubung ke sistem DBus"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+# OK
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "gagal mendengarkan di socket: %s"
+
+# OK
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "mencoba menyetel sebuah alamat IPv6 server lewat DBus - tidak ada dukungan untuk IPv6"
+
+# OK
+#, fuzzy
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "lease tidak diketahui"
+
+# OK
+#, fuzzy
 #~ msgid "cannot cannonicalise resolv-file %s: %s"
 #~ msgstr "tidak dapat membuka atau membuat file lease: %s"
 
Index: po/it.po
===================================================================
--- po/it.po	(revision 41436)
+++ po/it.po	(working copy)
@@ -16,70 +16,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr ""
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr ""
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr ""
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr ""
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr ""
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr ""
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr ""
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -93,659 +93,695 @@
 msgid "failed to allocate memory"
 msgstr ""
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr ""
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr ""
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr ""
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr ""
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr ""
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr ""
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr ""
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr ""
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr ""
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr ""
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr ""
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr ""
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr ""
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr ""
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr ""
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr ""
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr ""
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr ""
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr ""
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
-#: option.c:360
+#: option.c:374
 msgid "Read DHCP host specs from a directory."
 msgstr ""
 
-#: option.c:361
+#: option.c:375
 msgid "Read DHCP options from a directory."
 msgstr ""
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr ""
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr ""
 
-#: option.c:365
+#: option.c:379
 msgid "Read hosts files from a directory."
 msgstr ""
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr ""
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr ""
 
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr ""
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr ""
 
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr ""
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr ""
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr ""
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr ""
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr ""
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr ""
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr ""
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr ""
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr ""
 
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr ""
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr ""
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr ""
 
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr ""
 
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr ""
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr ""
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr ""
 
-#: option.c:391
+#: option.c:405
 msgid "Specify path to file with server= options"
 msgstr ""
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr ""
 
-#: option.c:393
+#: option.c:407
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr ""
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr ""
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr ""
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr ""
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr ""
 
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr ""
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr ""
 
-#: option.c:400
+#: option.c:414
 msgid "Specify time-to-live ceiling for cache."
 msgstr ""
 
-#: option.c:401
+#: option.c:415
 msgid "Specify time-to-live floor for cache."
 msgstr ""
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr ""
 
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr ""
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr ""
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr ""
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr ""
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr ""
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr ""
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr ""
 
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr ""
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr ""
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr ""
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr ""
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr ""
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr ""
 
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr ""
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr ""
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr ""
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr ""
 
-#: option.c:439
+#: option.c:455
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr ""
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr ""
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr ""
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
-#: option.c:464
+#: option.c:482
 msgid "Add client identification to forwarded DNS queries."
 msgstr ""
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr ""
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+#: option.c:485
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr ""
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr ""
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr ""
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr ""
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -752,320 +788,332 @@
 "\n"
 msgstr ""
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr ""
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr ""
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr ""
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr ""
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr ""
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr ""
 
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr ""
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr ""
 
-#: option.c:1240
+#: option.c:1366
 msgid "bad IPv4 address"
 msgstr ""
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr ""
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr ""
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr ""
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr ""
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr ""
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr ""
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr ""
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr ""
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr ""
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr ""
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr ""
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr ""
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr ""
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
+#: option.c:3315
+msgid "bad IPv6 prefix"
 msgstr ""
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr ""
 
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr ""
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr ""
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr ""
 
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr ""
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr ""
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
-#: option.c:3796
+#: option.c:4023
+msgid "missing address in alias"
+msgstr ""
+
+#: option.c:4029
 msgid "invalid alias range"
 msgstr ""
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr ""
 
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr ""
 
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr ""
 
-#: option.c:3984
+#: option.c:4236
+msgid "bad CAA record"
+msgstr ""
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr ""
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr ""
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr ""
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr ""
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr ""
 
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr ""
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr ""
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 msgid "bad trust anchor"
 msgstr ""
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr ""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr ""
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr ""
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr ""
 
-#: option.c:4309
+#: option.c:4630
 msgid "illegal option"
 msgstr ""
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr ""
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr ""
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr ""
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr ""
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr ""
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1072,500 +1120,546 @@
 "\n"
 msgstr ""
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr ""
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr ""
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr ""
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr ""
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr ""
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr ""
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr ""
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr ""
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr ""
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr ""
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr ""
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr ""
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr ""
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, c-format
 msgid "warning: using interface %s instead"
 msgstr ""
 
-#: network.c:1056
+#: network.c:1027
 #, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr ""
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr ""
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr ""
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr ""
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr ""
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr ""
 
-#: network.c:1572
+#: network.c:1543
 #, c-format
-msgid "using local addresses only for %s %s"
+msgid "using only locally-known addresses for %s %s"
 msgstr ""
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr ""
 
-#: network.c:1577
+#: network.c:1548
 #, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr ""
 
-#: network.c:1581
+#: network.c:1552
 #, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr ""
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr ""
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr ""
 
-#: network.c:1591
+#: network.c:1562
 #, c-format
 msgid "using %d more local addresses"
 msgstr ""
 
-#: network.c:1593
+#: network.c:1564
 #, c-format
 msgid "using %d more nameservers"
 msgstr ""
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr ""
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr ""
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr ""
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr ""
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr ""
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr ""
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr ""
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr ""
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr ""
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+msgid "UBus support enabled: connected to system bus"
+msgstr ""
+
+#: dnsmasq.c:852
+msgid "UBus support enabled: bus connection pending"
+msgstr ""
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr ""
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr ""
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr ""
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr ""
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr ""
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+msgid "single port mode"
+msgstr ""
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr ""
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr ""
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr ""
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr ""
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr ""
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr ""
@@ -1595,7 +1689,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr ""
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr ""
@@ -1605,329 +1699,334 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr ""
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr ""
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr ""
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr ""
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
+#: lease.c:185
+msgid "failed to parse lease database cleanly"
 msgstr ""
 
-#: lease.c:180
+#: lease.c:188
 #, c-format
 msgid "failed to read lease file %s: %s"
 msgstr ""
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr ""
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr ""
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr ""
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr ""
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr ""
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr ""
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr ""
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr ""
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr ""
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr ""
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr ""
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr ""
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr ""
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr ""
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr ""
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr ""
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr ""
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr ""
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr ""
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr ""
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr ""
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr ""
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr ""
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr ""
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr ""
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr ""
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr ""
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr ""
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr ""
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr ""
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr ""
 
-#: bpf.c:378
+#: bpf.c:374
 #, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr ""
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr ""
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
+msgid "failed sending %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
-msgid "failed sending %s to %s"
+msgid "sent %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:678
 #, c-format
-msgid "sent %s to %s"
+msgid "error %d %s received from %s"
 msgstr ""
 
 #: log.c:190
@@ -1944,7 +2043,7 @@
 msgid "FAILED to start up"
 msgstr ""
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -1964,77 +2063,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr ""
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr ""
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr ""
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr ""
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr ""
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr ""
 
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr ""
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr ""
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr ""
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr ""
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr ""
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2048,76 +2142,76 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr ""
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr ""
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr ""
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2127,7 +2221,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr ""
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2142,20 +2236,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr ""
 
-#: ipset.c:233
+#: ipset.c:226
 #, c-format
 msgid "failed to update ipset %s: %s"
 msgstr ""
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, c-format
 msgid "failed to access pf devices: %s"
@@ -2185,12 +2284,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, c-format
 msgid "%d addresses %s"
 msgstr ""
@@ -2229,3 +2328,62 @@
 #, c-format
 msgid "inotify, new or changed file %s"
 msgstr ""
+
+#: dump.c:64
+#, c-format
+msgid "cannot create %s: %s"
+msgstr ""
+
+#: dump.c:70
+#, c-format
+msgid "bad header in %s"
+msgstr ""
+
+#: dump.c:201
+msgid "failed to write packet dump"
+msgstr ""
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr ""
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr ""
+
+#: ubus.c:112
+msgid "Connected to system UBus"
+msgstr ""
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, c-format
+msgid "Failed to send UBus event: %s"
+msgstr ""
Index: po/no.po
===================================================================
--- po/no.po	(revision 41436)
+++ po/no.po	(working copy)
@@ -18,70 +18,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, fuzzy, c-format
 msgid "failed to load names from %s: %s"
 msgstr "feilet  laste navn fra %s: %s"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr "drlig adresse ved %s linje %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "drlig navn ved %s linje %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "les %s - %d adresser"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "mellomlager tmt"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "gir ikke navnet %s til DHCP leien for %s fordi navnet eksisterer i %s med adressen %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
-#: cache.c:1419
+#: cache.c:1664
 #, fuzzy, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "mellomlager strrelse %d, %d/%d mellomlager innsettinger re-bruker mellomlager plasser som ikke er utlpt"
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -96,687 +96,724 @@
 msgid "failed to allocate memory"
 msgstr "feilet  laste %d bytes"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "kunne ikke f minne"
 
-#: util.c:291
+#: util.c:302
 #, fuzzy, c-format
 msgid "cannot create pipe: %s"
 msgstr "kan ikke lese %s: %s"
 
-#: util.c:299
+#: util.c:310
 #, fuzzy, c-format
 msgid "failed to allocate %d bytes"
 msgstr "feilet  laste %d bytes"
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "uendelig"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Spesifiser lokal(e) adresse(r)  lytte p."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Returner ipaddr for alle verter i det spesifiserte domenet."
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Forfalsk revers oppslag for RFC1918 private adresse omrder."
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Behandle ipaddr som NXDOMAIN (omgr Verisign wildcard)."
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Spesifiser strrelsen p mellomlager plassene (standard er %s)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Spesifiser konfigurasjonsfil (standard er %s)."
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "IKKE legg (fork) som bakgrunnsprosess: kjr i debug modus."
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "IKKE videresend oppslag som mangler domene del."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Returner selv-pekende MX post for lokale verter."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Utvid enkle navn i /etc/hosts med domene-suffiks."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "Ikke videresend falske/uekte DNS foresprsler fra Windows verter."
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Aktiver DHCP i det gitte omrdet med leie varighet"
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Skift til denne gruppen etter oppstart (standard er %s)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Sett adresse eller vertsnavn for en spesifikk maskin."
 
-#: option.c:358
+#: option.c:372
 #, fuzzy
 msgid "Read DHCP host specs from file."
 msgstr "drlig MX navn"
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
-#: option.c:360
+#: option.c:374
 #, fuzzy
 msgid "Read DHCP host specs from a directory."
 msgstr "drlig MX navn"
 
-#: option.c:361
+#: option.c:375
 #, fuzzy
 msgid "Read DHCP options from a directory."
 msgstr "drlig MX navn"
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "IKKE last %s filen."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Spesifiser en verts (hosts) fil som skal leses i tilleg til %s."
 
-#: option.c:365
+#: option.c:379
 #, fuzzy
 msgid "Read hosts files from a directory."
 msgstr "drlig MX navn"
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Spesifiser nettverkskort det skal lyttes p."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Spesifiser nettverkskort det IKKE skal lyttes p."
 
-#: option.c:368
+#: option.c:382
 #, fuzzy
 msgid "Map DHCP user class to tag."
 msgstr "Map DHCP bruker klasse til opsjon sett."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
-#: option.c:372
+#: option.c:386
 #, fuzzy
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Ikke utfr DHCP for klienter i opsjon sett."
 
-#: option.c:373
+#: option.c:387
 #, fuzzy
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Ikke utfr DHCP for klienter i opsjon sett."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "IKKE last (fork) som bakgrunnsprosess, IKKE kjr i debug modus."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Anta at vi er den eneste DHCP tjeneren p det lokale nettverket."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Spesifiser hvor DHCP leiene skal lagres (standard er %s)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Returner MX records for lokale verter."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Spesifiser en MX post."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Spesifiser BOOTP opsjoner til DHCP tjener."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "IKKE spr (poll) %s fil, les p nytt kun ved SIGHUP"
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "IKKE mellomlagre skeresultater som feiler."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Bruk navnetjenere kun som bestemt i rekkeflgen gitt i %s."
 
-#: option.c:383
+#: option.c:397
 #, fuzzy
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Sett ekstra opsjoner som skal fordeles til DHCP klientene."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Spesifiser lytteport for DNS oppslag (standard er 53)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Maksimal stttet UDP pakkestrrelse for EDNS.0 (standard er %s)."
 
-#: option.c:387
+#: option.c:401
 #, fuzzy
 msgid "Log DNS queries."
 msgstr "Logg oppslag."
 
-#: option.c:388
+#: option.c:402
 #, fuzzy
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Tving bruk av opprinnelig port for oppstrms oppslag."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "IKKE les resolv.conf."
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Spesifiser stien til resolv.conf (standard er %s)."
 
-#: option.c:391
+#: option.c:405
 #, fuzzy
 msgid "Specify path to file with server= options"
 msgstr "Spesifiser stien til PID fil. (standard er %s)."
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Spesifiser adressen(e) til oppstrms tjenere med valgfrie domener."
 
-#: option.c:393
+#: option.c:407
 #, fuzzy
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Spesifiser adressen(e) til oppstrms tjenere med valgfrie domener."
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Aldri videresend oppslag til spesifiserte domener."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Spesifiser domenet som skal tildeles i DHCP leien."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Spesifiser default ml i en MX post."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Spesifiser time-to-live i sekunder for svar fra /etc/hosts."
 
-#: option.c:398
+#: option.c:412
 #, fuzzy
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Spesifiser time-to-live i sekunder for svar fra /etc/hosts."
 
-#: option.c:399
+#: option.c:413
 #, fuzzy
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Spesifiser time-to-live i sekunder for svar fra /etc/hosts."
 
-#: option.c:400
+#: option.c:414
 #, fuzzy
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Spesifiser time-to-live i sekunder for svar fra /etc/hosts."
 
-#: option.c:401
+#: option.c:415
 #, fuzzy
 msgid "Specify time-to-live floor for cache."
 msgstr "Spesifiser time-to-live i sekunder for svar fra /etc/hosts."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Skift til denne bruker etter oppstart (standard er %s)."
 
-#: option.c:403
+#: option.c:417
 #, fuzzy
 msgid "Map DHCP vendor class to tag."
 msgstr "Map DHCP produsent klasse til opsjon sett."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Vis dnsmasq versjon og copyright informasjon."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Oversett IPv4 adresser fra oppstrms tjenere."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Spesifiser en SRV post."
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
-#: option.c:408
+#: option.c:422
 #, fuzzy, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Spesifiser stien til PID fil. (standard er %s)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Spesifiser maksimum antall DHCP leier (standard er %s)"
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Svar DNS oppslag basert p nettverkskortet oppslaget ble sendt til."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Spesifiser TXT DNS post."
 
-#: option.c:412
+#: option.c:426
 #, fuzzy
 msgid "Specify PTR DNS record."
 msgstr "Spesifiser TXT DNS post."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Bind kun til nettverkskort som er i bruk."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Les DHCP statisk vert informasjon fra %s."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Aktiver DBus interface for  sette oppstrms tjenere, osv."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "Ikke lever DHCP p dette nettverkskortet, kun lever DNS."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Aktiver dynamisk adresse allokering for bootp."
 
-#: option.c:419
+#: option.c:434
 #, fuzzy
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Map DHCP produsent klasse til opsjon sett."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
-#: option.c:427
+#: option.c:443
 #, fuzzy
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Skift til denne bruker etter oppstart (standard er %s)."
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
-#: option.c:429
+#: option.c:445
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Spesifiser maksimum antall DHCP leier (standard er %s)"
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Spesifiser maksimum antall DHCP leier (standard er %s)"
 
-#: option.c:439
+#: option.c:455
 #, fuzzy
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Spesifiser maksimum antall DHCP leier (standard er %s)"
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
-#: option.c:451
+#: option.c:469
 #, fuzzy
 msgid "Specify NAPTR DNS record."
 msgstr "Spesifiser TXT DNS post."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
-#: option.c:459
+#: option.c:477
 #, fuzzy
 msgid "Prompt to send to PXE clients."
 msgstr "Sett ekstra opsjoner som skal fordeles til DHCP klientene."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
-#: option.c:464
+#: option.c:482
 #, fuzzy
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Tving bruk av opprinnelig port for oppstrms oppslag."
 
-#: option.c:465
+#: option.c:483
 #, fuzzy
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Oversett IPv4 adresser fra oppstrms tjenere."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Sett ekstra opsjoner som skal fordeles til DHCP klientene."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 #, fuzzy
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Spesifiser en MX post."
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 #, fuzzy
 msgid "Specify arbitrary DNS resource record"
 msgstr "Spesifiser TXT DNS post."
 
-#: option.c:473
+#: option.c:493
 #, fuzzy
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "ukjent tilknytning (interface) %s"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -785,341 +822,356 @@
 "Bruk: dnsmasq [opsjoner]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Bruk korte opsjoner kun p kommandolinjen.\n"
 
-#: option.c:707
+#: option.c:729
 #, fuzzy, c-format
 msgid "Valid options are:\n"
 msgstr "Gyldige opsjoner er :\n"
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 #, fuzzy
 msgid "bad address"
 msgstr "les %s - %d adresser"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "drlig port"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 #, fuzzy
 msgid "bad interface name"
 msgstr "drlig MX navn"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "drlig dhcp-opsjon"
 
-#: option.c:1144
+#: option.c:1270
 #, fuzzy
 msgid "bad IP address"
 msgstr "les %s - %d adresser"
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 #, fuzzy
 msgid "bad IPv6 address"
 msgstr "les %s - %d adresser"
 
-#: option.c:1240
+#: option.c:1366
 #, fuzzy
 msgid "bad IPv4 address"
 msgstr "les %s - %d adresser"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "drlig domene i dhcp-opsjon"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "dhcp-opsjon for lang"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, fuzzy, c-format
 msgid "cannot access directory %s: %s"
 msgstr "kan ikke lese %s: %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, fuzzy, c-format
 msgid "cannot access %s: %s"
 msgstr "kan ikke lese %s: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "drlig MX preferanse"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "drlig MX navn"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "drlig MX ml"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 #, fuzzy
 msgid "bad prefix"
 msgstr "drlig port"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
-#: option.c:2713
+#: option.c:2871
 #, fuzzy
 msgid "bad port range"
 msgstr "drlig port"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "drlig dhcp-omrde"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "ikke konsistent DHCP omrde"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
-#: option.c:2925
+#: option.c:3123
 #, fuzzy
 msgid "inconsistent DHCPv6 range"
 msgstr "ikke konsistent DHCP omrde"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 #, fuzzy
 msgid "bad hex constant"
 msgstr "drlig dhcp-vert"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr ""
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "drlig port"
 
-#: option.c:3119
+#: option.c:3362
 #, fuzzy, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "dubliserte IP adresser i %s dhcp-config direktiv."
 
-#: option.c:3177
+#: option.c:3422
 #, fuzzy
 msgid "bad DHCP host name"
 msgstr "drlig MX navn"
 
-#: option.c:3259
+#: option.c:3508
 #, fuzzy
 msgid "bad tag-if"
 msgstr "drlig MX ml"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "ugyldig portnummer"
 
-#: option.c:3678
+#: option.c:3907
 #, fuzzy
 msgid "bad dhcp-proxy address"
 msgstr "les %s - %d adresser"
 
-#: option.c:3704
+#: option.c:3935
 #, fuzzy
 msgid "Bad dhcp-relay"
 msgstr "drlig dhcp-omrde"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
-#: option.c:3796
+#: option.c:4023
 #, fuzzy
+msgid "missing address in alias"
+msgstr "adresse i bruk"
+
+#: option.c:4029
+#, fuzzy
 msgid "invalid alias range"
 msgstr "ugyldig vekt"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
-#: option.c:3889
+#: option.c:4132
 #, fuzzy
 msgid "bad PTR record"
 msgstr "drlig SRV post"
 
-#: option.c:3920
+#: option.c:4167
 #, fuzzy
 msgid "bad NAPTR record"
 msgstr "drlig SRV post"
 
-#: option.c:3954
+#: option.c:4203
 #, fuzzy
 msgid "bad RR record"
 msgstr "drlig SRV post"
 
-#: option.c:3984
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "drlig SRV post"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "drlig TXT post"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "drlig SRV post"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "drlig SRV ml"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "ugyldig prioritet"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "ugyldig vekt"
 
-#: option.c:4073
+#: option.c:4362
 #, fuzzy
 msgid "Bad host-record"
 msgstr "drlig SRV post"
 
-#: option.c:4097
+#: option.c:4402
 #, fuzzy
 msgid "Bad name in host-record"
 msgstr "drlig navn i %s"
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 #, fuzzy
 msgid "bad trust anchor"
 msgstr "drlig port"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "mangler \""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "drlig opsjon"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "overfldig parameter"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "mangler parameter"
 
-#: option.c:4309
+#: option.c:4630
 #, fuzzy
 msgid "illegal option"
 msgstr "drlig opsjon"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "feil"
 
-#: option.c:4318
+#: option.c:4639
 #, fuzzy, c-format
 msgid " at line %d of %s"
 msgstr "%s p linje %d av %%s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, fuzzy, c-format
 msgid "read %s"
 msgstr "leser %s"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "kan ikke lese %s: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Dnsmasq versjon %s %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, fuzzy, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1128,507 +1180,559 @@
 "Kompileringsopsjoner %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Denne programvaren kommer med ABSOLUTT INGEN GARANTI.\n"
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "DNsmasq er fri programvare, du er velkommen til  redistribuere den\n"
 
-#: option.c:4733
+#: option.c:5071
 #, fuzzy, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "under vilkrene gitt i GNU General Public License, versjon 2.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
-#: option.c:4748
+#: option.c:5092
 #, fuzzy, c-format
 msgid "bad command line options: %s"
 msgstr "drlige kommandlinje opsjoner: %s."
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "klarer ikke  f vertsnavn: %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "kun en resolv.conf fil tillat i no-poll modus."
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "m ha nyaktig en resolv.conf  lese domene fra."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, fuzzy, c-format
 msgid "failed to read %s: %s"
 msgstr "feilet  lese %s: %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "intet ske direktiv funnet i %s"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
-#: forward.c:102
+#: forward.c:99
 #, fuzzy, c-format
 msgid "failed to send packet: %s"
 msgstr "feilet  lytte p socket: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "navnetjener %s nektet  gjre et rekursivt oppslag"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Spesifiser maksimum antall DHCP leier (standard er %s)"
 
-#: network.c:720
+#: network.c:698
 #, fuzzy, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "feilet  lage lytte socket: %s"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "advarsel: nettverkskort %s eksisterer ikke for tiden"
 
-#: network.c:1056
+#: network.c:1027
 #, fuzzy, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "benytter lokale adresser kun for %s %s"
 
-#: network.c:1114
+#: network.c:1085
 #, fuzzy, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "feilet  binde DHCP tjener socket: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, fuzzy, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "feilet  binde lytte socket for %s: %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignorerer navnetjener %s - lokal tilknytning"
 
-#: network.c:1539
+#: network.c:1510
 #, fuzzy, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignorerer navnetjener %s - kan ikke lage/dinde socket: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "ikke kvalifisert"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "domene"
 
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "benytter lokale adresser kun for %s %s"
 
-#: network.c:1575
+#: network.c:1546
 #, fuzzy, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "benytter navnetjener %s#%d for %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, fuzzy, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "benytter navnetjener %s#%d for %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, fuzzy, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "benytter navnetjener %s#%d for %s %s"
 
-#: network.c:1584
+#: network.c:1555
 #, fuzzy, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "benytter navnetjener %s#%d"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "benytter navnetjener %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "benytter navnetjener %s#%d"
 
-#: network.c:1593
+#: network.c:1564
 #, fuzzy, c-format
 msgid "using %d more nameservers"
 msgstr "benytter navnetjener %s#%d"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 #, fuzzy
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 #, fuzzy
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 #, fuzzy
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 #, fuzzy
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 #, fuzzy
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "feilet  finne liste av tilknytninger (interfaces): %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "ukjent tilknytning (interface) %s"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "DBus feil: %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus ikke tilgjengelig: sett HAVE_DBUS i src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, fuzzy, c-format
 msgid "started, version %s DNS disabled"
 msgstr "startet, versjon %s mellomlager deaktivert"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "startet, versjon %s mellomlager strrelse %d"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "startet, versjon %s mellomlager deaktivert"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "kompilerings opsjoner: %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "DBus sttte aktivert: koblet til system buss"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "DBus sttte aktivert: avventer buss tilkobling"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "DBus sttte aktivert: koblet til system buss"
+
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "DBus sttte aktivert: avventer buss tilkobling"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
+#, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
 #, fuzzy, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "feilet  laste navn fra %s: %s"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "setter --bind-interfaces opsjon p grunn av OS begrensninger"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "advarsel: nettverkskort %s eksisterer ikke for tiden"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 #, fuzzy
 msgid "warning: no upstream servers configured"
 msgstr "setter oppstrms tjener fra DBus"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 #, fuzzy
 msgid "enabled"
 msgstr "deaktivert"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "ugyldig portnummer"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "tilkoblet til system DBus"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, fuzzy, c-format
 msgid "failed to create helper: %s"
 msgstr "feilet  lese %s: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, fuzzy, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "feilet  laste navn fra %s: %s"
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, fuzzy, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "feilet  laste navn fra %s: %s"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, fuzzy, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "feilet  lese %s: %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, fuzzy, c-format
 msgid "cannot open log %s: %s"
 msgstr "kan ikke pne %s:%s"
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, fuzzy, c-format
 msgid "failed to load Lua script: %s"
 msgstr "feilet  laste %s: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, fuzzy, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "kan ikke pne eller lage leie fil: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, fuzzy, c-format
 msgid "failed to execute %s: %s"
 msgstr "feilet  f tilgang til %s: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, fuzzy, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "feilet  lese %s: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "avslutter etter mottak av SIGTERM"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, fuzzy, c-format
 msgid "failed to access %s: %s"
 msgstr "feilet  f tilgang til %s: %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "leser %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, fuzzy, c-format
 msgid "no servers found in %s, will retry"
 msgstr "intet ske direktiv funnet i %s"
@@ -1658,7 +1762,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "kan ikke lage ICMP raw socket: %s"
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, fuzzy, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "ukjent tilknytning (interface) %s"
@@ -1668,331 +1772,337 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "DHCP omrde %s -- %s er ikke konsistent med nettmaske %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr "drlig linje ved %s linje %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "for mange lagrede leier"
 
-#: lease.c:166
+#: lease.c:176
 #, fuzzy, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "kan ikke pne eller lage leie fil: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "feilet  lese %s: %s"
 
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "feilet  lese %s: %s"
 
-#: lease.c:196
+#: lease.c:204
 #, fuzzy, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "kan ikke lese %s: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
-#: lease.c:373
+#: lease.c:381
 #, fuzzy, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "feilet  lese %s: %s"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "ingen adresse omrde tilgjengelig for DHCP krav %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "med subnet velger"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "via"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, fuzzy, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "ingen adresse omrde tilgjengelig for DHCP krav %s %s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, fuzzy, c-format
 msgid "%u vendor class: %s"
 msgstr "DBus feil: %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, fuzzy, c-format
 msgid "%u user class: %s"
 msgstr "DBus feil: %s"
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "deaktivert"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "oversett"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "adresse i bruk"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "ingen adresse tilgjengelig"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "galt nettverk"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "ingen adresse konfigurert"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "ingen leier igjen"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, fuzzy, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "deaktiverer DHCP statisk adresse %s"
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "ukjent leie"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "gal adresse"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "leie ikke funnet"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "adresse ikke tilgjengelig"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "statisk leie tilgjengelig"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "adresse reservert"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, fuzzy, c-format
 msgid "%u server name: %s"
 msgstr "DBus feil: %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, fuzzy, c-format
 msgid "%u next server: %s"
 msgstr "DBus feil: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, fuzzy, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "kan ikke sende DHCP opsjon %d: ikke mer plass i pakken"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, fuzzy, c-format
 msgid "%u requested options: %s"
 msgstr "kompilerings opsjoner: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, fuzzy, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "kan ikke binde netlink socket: %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, fuzzy, c-format
 msgid "netlink returns error: %s"
 msgstr "DBus feil: %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "forsk p  sette en IPv6 tjener adresse via DBus - ingen IPv6 sttte"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "setter oppstrms tjener fra DBus"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "kunne ikke registrere en DBus meldingshndterer"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "kan ikke lage DHCP BPF socket: %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, fuzzy, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "DHCP krav for ikke stttet maskinvare type (%d) mottatt p %s"
 
-#: bpf.c:378
+#: bpf.c:374
 #, fuzzy, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "kan ikke lage DHCP socket: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
-#: tftp.c:483
+#: tftp.c:510
 #, fuzzy, c-format
 msgid "file %s not found"
 msgstr "leie ikke funnet"
 
-#: tftp.c:592
-#, c-format
-msgid "error %d %s received from %s"
-msgstr ""
-
-#: tftp.c:634
+#: tftp.c:628
 #, fuzzy, c-format
 msgid "failed sending %s to %s"
 msgstr "feilet  lese %s: %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr ""
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr ""
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -2007,7 +2117,7 @@
 msgid "FAILED to start up"
 msgstr "FEILET  starte opp"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -2027,81 +2137,76 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "feilet  binde DHCP tjener socket: %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "ingen adresse omrde tilgjengelig for DHCP krav %s %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "ingen adresse omrde tilgjengelig for DHCP krav %s %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, fuzzy, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "ingen adresse omrde tilgjengelig for DHCP krav %s %s"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, fuzzy, c-format
 msgid "%u vendor class: %u"
 msgstr "DBus feil: %s"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, fuzzy, c-format
 msgid "%u client MAC address: %s"
 msgstr "ingen tilknytning (interface) med adresse %s"
 
-#: rfc3315.c:673
-#, fuzzy, c-format
-msgid "unknown prefix-class %d"
-msgstr "ukjent leie"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 #, fuzzy
 msgid "address unavailable"
 msgstr "adresse ikke tilgjengelig"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 #, fuzzy
 msgid "no addresses available"
 msgstr "ingen adresse tilgjengelig"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 #, fuzzy
 msgid "address invalid"
 msgstr "adresse i bruk"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 #, fuzzy
 msgid "all addresses still on link"
 msgstr "drlig adresse ved %s linje %d"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2115,76 +2220,76 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "dubliserte IP adresser i %s (%s) i dhcp-config direktiv"
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, fuzzy, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "feilet  sette SO_REUSEADDR p DHCP socket: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, fuzzy, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "DHCP, statisk leie kun p %.0s%s, leie tid %s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, fuzzy, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "DHCP, IP omrde %s -- %s, leie tid %s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, fuzzy, c-format
 msgid "router advertisement on %s%s"
 msgstr "DHCP, statisk leie kun p %.0s%s, leie tid %s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2194,7 +2299,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "kan ikke lage DHCP socket: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2209,20 +2314,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "feilet  lage lytte socket: %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "feilet  lese %s: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, fuzzy, c-format
 msgid "failed to access pf devices: %s"
@@ -2252,12 +2362,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, fuzzy, c-format
 msgid "%d addresses %s"
 msgstr "les %s - %d adresser"
@@ -2297,7 +2407,75 @@
 msgid "inotify, new or changed file %s"
 msgstr ""
 
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "kan ikke lese %s: %s"
+
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "adresse i bruk"
+
+#: dump.c:201
 #, fuzzy
+msgid "failed to write packet dump"
+msgstr "feilet  lytte p socket: %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "kan ikke pne %s:%s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "kan ikke pne %s:%s"
+
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "tilkoblet til system DBus"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "feilet  lytte p socket: %s"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "forsk p  sette en IPv6 tjener adresse via DBus - ingen IPv6 sttte"
+
+#, fuzzy
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "ukjent leie"
+
+#, fuzzy
 #~ msgid "cannot cannonicalise resolv-file %s: %s"
 #~ msgstr "kan ikke pne eller lage leie fil: %s"
 
Index: po/pl.po
===================================================================
--- po/pl.po	(revision 41436)
+++ po/pl.po	(working copy)
@@ -21,70 +21,70 @@
 "X-Generator: Poedit 1.8.7\n"
 "X-Language: pl_PL\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr "Wewntrzny bd w pamici podrcznej."
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr "nie potrafi wczyta nazw z %s: %s"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr "bdny adres w pliku %s, w linii %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "bdna nazwa w pliku %s, w linii %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "wczytaem %s - %d adresw"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "wyczyszczono pami podrczn"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr "Nie znalazem adresu IPv4 komputera %s"
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr "%s to nazwa CNAME, nie przypisuj jej dzierawie DHCP %s"
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "nazwa %s nie zostaa nadana dzierawie DHCP %s, poniewa nazwa istnieje w %s i ma ju adres %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr "czas %lu"
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "wielko pamici podrcznej: %d; %d z %d miejsc aktualnych wpisw uyto ponownie."
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr "%u zapyta przesanych dalej, %u odpowiedzi udzielonych samodzielnie"
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr "zapyta do stref autorytatywnych %u"
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr "serwer %s#%d: %u zapyta wysanych, %u ponowionych lub nieudanych"
@@ -98,662 +98,701 @@
 msgid "failed to allocate memory"
 msgstr "nie udao si przydzieli pamici"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "nie mona dosta pamici"
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr "bd podczas prby utworzenia potoku: %s"
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr "niemoliwo przydzielenia %d bajtw pamici"
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "nieskoczona"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Wskazanie adresw, na ktrych naley nasuchiwa."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Zwracanie adresu IP dla wszystkich hostw we wskazanych domenach."
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Wyczenie przekazywania zapyta odwrotnych dla prywatnych zakresw IP."
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Traktowanie adresu IP jako NXDOMAIN (uniewania ,,Verisign wildcard'')."
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Wskazanie wielkoci pamici podrcznej (domylnie: %s miejsc)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Wskazanie pliku konfiguracyjnego (domylnie: %s)."
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "NIE twrz procesu potomnego w tle: dziaanie w trybie debugowania."
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "Wyczenie przekazywania zapyta bez podanej czci domenowej."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Zwracanie samowskazujcego rekordu MX dla lokalnych hostw."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Rozwijanie prostych nazw z /etc/hosts przyrostkiem domenowym."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "Wyczenie przekazywania pozornych zapyta DNS z komputerw dziaajcych pod Windows."
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Wczenie serwera DHCP dla wskazanego zakresu adresw."
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Po uruchomieniu zmiana grupy procesu na podan (domylnie: %s)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Ustawienie adresu lub nazwy dla wskazanego komputera."
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr "Wskazanie pliku z wartociami 'dhcp-host='."
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr "Wskazanie pliku z wartociami 'dhcp-option='."
 
-#: option.c:360
+#: option.c:374
 msgid "Read DHCP host specs from a directory."
 msgstr "Odczyt specyfikacji hostw dla DHCP z katalogu."
 
-#: option.c:361
+#: option.c:375
 msgid "Read DHCP options from a directory."
 msgstr "Odczyt opcji DHCP z katalogu."
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr "Warunkowe ustawianie znacznikw."
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "NIE wczytywanie pliku %s."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Wskazanie dodatkowego pliku 'hosts' oprcz %s."
 
-#: option.c:365
+#: option.c:379
 msgid "Read hosts files from a directory."
 msgstr "Odczyt pliku hostw z katalogu."
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Interfejsy, na ktrych nasuchiwa."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Interfejsy, na ktrych NIE nasuchiwa."
 
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr "Przyporzdkowanie znacznika w zalenoci od klasy uytkownika DHCP."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr "Przyporzdkowanie znacznika w zalenoci od numeru obwodu (w rozumieniu RFC3046)."
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr "Przyporzdkowanie znacznika w zalenoci od numeru agenta (w rozumieniu RFC3046)."
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr "Przyporzdkowanie znacznika w zalenoci od numeru subskrybenta (w rozumieniu RFC3993)."
 
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Wyczenie DHCP dla hostw z okrelonym znacznikiem."
 
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Wymuszenie odpowiedzi w trybie rozgoszeniowym dla hostw z okrelonym znacznikiem."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "NIE twrz procesu potomnego w tle i NIE wczaj trybu debugowania."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Zakadanie, e jestemy jedynym serwerem DHCP w sieci lokalnej."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "cieka przechowywania pliku dzieraw DHCP (domylnie: %s)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Wczenie zwracania rekordu MX dla hostw lokalnych."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Specyfikacja rekordu MX."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Okrelenie opcji BOOTP serwera DHCP."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "Wyczenie obserwowania pliku %s; ponowne odczytywanie tylko po odebraniu sygnau SIGHUP."
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "Wyczenie przechowywania w pamici podrcznej wynikw nieudanych wyszukiwa."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Odpytywanie serwerw nazw w kolejnoci ich wystpienia w %s."
 
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Specyfikacja opcji wysyanej do klientw DHCP."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr "Opcja DHCP wysyana nawet jeeli klient o ni nie prosi."
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Wskazanie portu do nasuchiwania zapyta DNS (domylnie: 53)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Maksymalna obsugiwana wielko pakietu EDNS.0 (domylnie: %s)."
 
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr "Wczenie spisywania zapyta DNS do logu."
 
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Wymuszenie uycia wskazanego portu UDP do odpytywania nadrzdnych serwerw DNS i odbierania od nich odpowiedzi."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "Wyczenie czytania pliku resolv.conf."
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Wskazanie pooenia pliku resolv.conf (domylnie: %s)."
 
-#: option.c:391
+#: option.c:405
 msgid "Specify path to file with server= options"
 msgstr "Wskazanie pooenia pliku z opcjami server="
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Wskazywanie adresw serwerw nazw, opcjonalnie z przypisaniem do domeny."
 
-#: option.c:393
+#: option.c:407
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Wskazanie serwerw nazw do odwrotnej translacji adresw."
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Wyczenie przekazywania zapyta do wskazanych domen."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Wskazanie domeny dla serwera DHCP."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Okrelenie domylnego celu w rekordzie MX."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Okrelenie (w sekundach) czasu wanoci odpowiedzi udzielonych na podstawie /etc/hosts (domylnie 0)."
 
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Okrelenie (w sekundach) czasu wanoci negatywnych odpowiedzi."
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Ograniczenie maksymalnego czasu wanoci odpowiedzi (TTL) podawanego klientom [w sekundach]."
 
-#: option.c:400
+#: option.c:414
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Okrelenie grnej granicy czasu wanoci dla wpisw w pamici podrcznej."
 
-#: option.c:401
+#: option.c:415
 msgid "Specify time-to-live floor for cache."
 msgstr "Okrelenie dolnej granicy czasu wanoci dla wpisw w pamici podrcznej."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Zmiana uytkownika procesu na wskazanego (po uruchomieniu, domylnie: %s)."
 
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr "Przyporzdkowanie znacznika w zalenoci od typu klienta DHCP."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Wydrukowanie informacji o programie i ochronie praw autorskich."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Tumaczenie adresw IPv4 z serwerw nadrzdnych."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Okrelenie rekordu SRV."
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr "Wywietla ten komunikat. Chcc przejrze list dostpnych opcji DHCP uyj '--help dhcp' lub '--help dhcp6' ."
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Okrelenie cieki do pliku PID (domylnie: %s)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Maksymalna liczba dzieraw DHCP (domylnie: %s)."
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Uzalenienie odpowiedzi DNS od interfejsu, na ktrym odebrano zapytanie (wygodne dla serwerw kilku podsieci z rnymi adresami w /etc/hosts)."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Specyfikacja rekordu DNS TXT."
 
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr "Specyfikacja rekordu DNS PTR."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr "Zwraca nazw domenow powizan z adresem interfejsu sieciowego."
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Nasuchiwanie tylko na wykorzystywanych interfejsach (umoliwia uruchomienie osobnych serwerw dla rnych kart)."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Wczytanie przyporzdkowa adresw z %s."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Wczenie uywania interfejsu DBus do informowania o zmianach konfiguracji."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "Uruchomienie na wskazanym interfejsie tylko DNS-a, bez usug DHCP i TFTP."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Wczenie dynamicznego przydzielania adresw dla klientw BOOTP."
 
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Przyporzdkowanie znacznika w zalenoci od adresu MAC (mona uywa uoglnie: *)."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr "Traktowanie da DHCP odebranych na interfejsach alias, ..., jako odebranych na iface."
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr "Pominicie sprawdzania za pomoc ICMP niezajtoci adresu przed jego wydzierawieniem."
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr "Skrypt powoki uruchamiany po przyznaniu lub zwolnieniu adresu."
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr "Skrypt Lua uruchamiany po przyznaniu lub zwolnieniu adresu."
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr "Wskazanie uytkownika z ktrego uprawnieniami bd uruchamiane skrypty."
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr "Wywoywanie dhcp-script w reakcji na zmiany w tablicy ARP."
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr "Wczytanie wszystkich plikw ze wskazanego katalogu jako konfiguracyjnych."
 
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Wskazanie kanau syslog-a do ktrego maj trafia komunikaty (domylnie: DAEMON)"
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr "Nieuywanie bazy dzieraw."
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Maksymalna liczba jednoczenie obsugiwanych zapyta DNS (domylnie: %s)"
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr "Czyszczenie pamici podrcznej serwera nazw w przypadku ponownego odczytu %s."
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr "Nie zwracanie uwagi na nazw podawan przez klienta w przypadku dopasowania wszystkich wymienionych znacznikw."
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr "Wyczenie oszczdzania miejsca w pakiecie DHCP przez przesuwanie pl servername i filename do opcji DHCP. Wymusza prostszy tryb budowy pakietu rozwizujc problemy z nieprzystosowanymi klientami DHCP."
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr "Wczenie wbudowanego serwera TFTP (tylko do wysyania)."
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr "Ograniczenie dziaania serwera TFTP do wskazanego katalogu i podkatalogw. Nazwy z .. s odrzucane, / odnosi si do wskazanego katalogu."
 
-#: option.c:435
+#: option.c:451
 #, fuzzy
 msgid "Add client IP or hardware address to tftp-root."
 msgstr "Doklejanie adresu IP klienta do gwnego katalogu TFTP. Jeeli wynikowy katalog nie istnieje, nadal wykorzystuje si tftp-root."
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr "Ograniczenie dostpu do plikw przez TFTP do tych, ktrych wacicielem jest uytkownik uruchamiajcy dnsmasq-a."
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr "Nieprzerywanie dziaania serwisu mimo braku dostpu do katalogw TFTP."
 
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Maksymalna liczba jednoczenie obsugiwanych pocze TFTP (domylnie %s)."
 
-#: option.c:439
+#: option.c:455
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Ograniczenie MTU w komunikacji TFTP."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr "Wyczenie moliwoci negocjowania wielkoci bloku dla przesyw przez TFTP."
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr "Konwertowanie nazw plikw danych przez TFTP do maych liter"
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr "Wskazanie zakresu portw do uytku TFTP."
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr "Wczenie spisywania w logu operacji DHCP."
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr "Wczenie asynchronicznego zapisywania do logu z ewentualnym wskazaniem dugoci kolejki."
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr "Odfiltrowywanie adresw wskazujcych na komputery w sieciach wewntrznych spord odpowiedzi od zewntrznych serwerw DNS."
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr "Zezwolenie na przekazywanie odpowiedzi w klasie 127.0.0.0/8. Dla serwerw RBL."
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr "Dezaktywacja zabezpieczenia przed atakami DNS-rebind dla wskazanych domen."
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr "Jednoczesne odpytywanie wszystkich serwerw nadrzdnych; klientowi przekazywana jest pierwsza odpowied."
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr "Ustawienie znacznika jeeli w daniu DHCP pojawi si wskazana opcja, ewentualnie o konkretnej wartoci."
 
-#: option.c:450
+#: option.c:467
+#, fuzzy
+msgid "Set tag if client provides given name."
+msgstr "Ustawienie znacznika jeeli w daniu DHCP pojawi si wskazana opcja, ewentualnie o konkretnej wartoci."
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr "Uycie alternatywnych portw dla usugi DHCP."
 
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr "Specyfikacja rekordu DNS NAPTR."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr "Ustawienie dolnej granicy numerw portw do przesyania zapyta DNS."
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr "Ograniczenie najwyszego numeru portu dla transmisji zapyta DNS."
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr "Przechowywanie w serwerze DNS dnsmasq-a tylko w peni kwalifikowanych nazw zgaszanych przez klientw DHCP."
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr "Generowanie nazw na podstawie MAC-adresw dla klientw bez nazwy."
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr "Traktowanie wskazanych serwerw poredniczcych DHCP jako dziaajcych w trybie \"penomocnika\" (full-proxy)."
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr "Przekazywanie da DHCP do zdalnego serwera"
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr "Wskazanie synonimu nazwy komputera lokalnego - znanego z /etc/hosts albo z DHCP."
 
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr "Zgoszenie wysyane klientom PXE."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr "Skadnik menu PXE (--> man)."
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr "Sprawdzenie skadni."
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr "Przekazywanie MAC-adresu komputera pytajcego w ruchu wychodzcym DNS."
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr "Zamieszczanie wskazanego adresu podsieci w przekazywanych zapytaniach DNS."
 
-#: option.c:464
+#: option.c:482
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Zamieszczanie identyfikacji pytajcego w przekazywanych zapytaniach DNS."
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Przekazywanie wynikw weryfikacji DNSSEC z serwerw nadrzdnych."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr "Zmiana sposobu przydzielania adresw IP na sekwencyjny."
 
-#: option.c:467
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Nie zwracanie uwagi na nazw podawan przez klienta w przypadku dopasowania wszystkich wymienionych znacznikw."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr "Zachowanie znacznika poczenia z odebranego zapytania DNS w ruchu zewntrznym."
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr "Zezwolenie klientom DHCP na uaktualnianie DDNS-w."
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr "Zaczenie anonsowania (RA) na interfejsach serwujcych DHCPv6"
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr "Okrelenie DHCPv6 DUID"
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Okrelenie rekordw A/AAAA i PTR"
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr "Okrelenie rekordu TXT"
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "Dynamiczne podpinanie do interfejsw sieciowych"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr "Eksportowanie lokalnych nazw hostw do globalnego DNS-a"
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr "Domena pod ktr bd eksportowane lokalne nazwy"
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr "Okrelenie TTL dla odpowiedzi autorytatywnych"
 
-#: option.c:477
+#: option.c:497
 #, fuzzy
 msgid "Set authoritative zone information"
 msgstr "Okrelenie danych strefy autorytatywnej (SOA)"
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr "Pomocnicze serwery autorytatywne dla forwardowanych domen"
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr "Wskazanie serwerw uprawnionych do transferu stref"
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr "Wyszczeglnienie ipset-w, do ktrych bd dopisywane adresy IP lece we wskazanych domenach"
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr "Wskazanie domeny i zakresu adresw dla generowanych nazw"
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr "Uaktywnienie walidacji DNSSEC"
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr "Wskazanie punktu zaufania dla uwierzytelniania DNSSEC."
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr "Akceptowanie nieuwiarygodnionych odpowiedzi DNSSEC (ustawienie bitu CD w zapytaniach)."
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr "Upewnianie si, e odpowiedzi bez DNSSEC pochodz ze stref niepodpisanych."
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr "Wyczenie sprawdzania sygnatur czasowych DNSSEC do pierwszego przeadowania pamici podrcznej."
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr "Plik znacznika czasu do weryfikacji zegara systemowego dla potrzeb DNSSEC."
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr "Okrelenie prefiksu klasy DHCPv6"
-
-#: option.c:491
+#: option.c:508
 #, fuzzy
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr "Ustawianie priorytetu, okresu rozsyania oraz czasu ycia rutera (RA)."
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr "Wyczenie logowania zwyczajnego DHCP."
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr "Wyczenie logowania zwyczajnego DHCPv6."
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr "Wyczenie logowania RA."
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr "Akceptowanie zapyta wycznie z sieci podpitych bezporednio."
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr "Wykrywanie i usuwanie ptli zapyta DNS."
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr "Ignorowanie odpowiedzi DNS zawierajcych ipaddr."
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr "Ustawienie TTL w odpowiedziach DNS dla adresw przydzielonych przez DHCP."
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+#, fuzzy
+msgid "Call dhcp-script when lease expiry changes."
+msgstr "Wywoywanie dhcp-script w reakcji na zmiany w tablicy ARP."
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -762,320 +801,335 @@
 "Uycie: dnsmasq [opcje]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "W tym systemie w linii polece mona uywa wycznie jednoliterowych opcji.\n"
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr "Dostpne opcje:\n"
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr "zy adres"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "nieprawidowy numer portu"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr "nie ma moliwoci dowizywania do interfejsu"
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr "nieprawidowa nazwa interfejsu"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr "nieobsugiwany rodzaj enkapsulacji opcji IPv6"
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "bd w dhcp-option"
 
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr "zy adres IP"
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr "zy adres IPv6"
 
-#: option.c:1240
+#: option.c:1366
 msgid "bad IPv4 address"
 msgstr "nieprawidowy adres IPv4"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "nieprawidowa nazwa domeny w dhcp-option"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "zbyt duga dhcp-option (>255 znakw)"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr "niedopuszczalne dhcp-match"
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr "wielokrotne uycie opcji niedozwolone (pojawia si wczeniej w linii polece)"
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr "wielokrotne uycie opcji niedozwolone (pojawia si wszeniej w pliku konfiguracyjnym)"
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr "brak dostpu do katalogu %s: %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr "brak dostpu do %s: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr "zmiana log-facility w systemie Android nie jest moliwa"
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr "nierozpoznany znacznik logw"
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "nieprawidowa warto preferencji MX"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "nieprawidowa nazwa MX"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "nieprawidowa warto celu MX"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr "w uClinuksie nie ma moliwoci uruchamiania skryptw"
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr "eby mie moliwo uywania skryptw wywoywanych przy zmianie dzierawy, przekompiluj dnsmasq-a z wczon flag HAVE_SCRIPT"
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr "uywanie skryptw Lua, wymaga skompilowania dnsmasq-a z flag HAVE_LUASCRIPT"
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr "za maska"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr "chcc korzysta z ipsets przekompiluj dnsmasq-a z HAVE_IPSET"
 
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr "nieprawidowy zakres numerw portw"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr "nieprawidowa nazwa urzdzenia w bridge-interface"
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr "mona wskaza tylko jeden znacznik sieci"
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "nieprawidowy zakres dhcp-range"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "niespjny zakres adresw DHCP"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr "dugo prefiksu musi wynosi dokadnie 64 dla podsieci RA"
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr "dugo prefiksu musi wynosi dokadnie 64 dla konstruktorw podsieci"
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr "dugo prefiksu musi wynosi co najmniej 64"
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr "niespjny zakres adresw DHCPv6"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr "prefiks musi wynosi zero z argumentem \"constructor:\""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr "zapis niezgodny z formatem szesnastkowym"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr "--dhcp-host nie dopuszcza dopasowywania na podstawie znacznikw"
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "za maska"
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "powtrzony adres IP %s w specyfikacji dhcp-host"
 
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr "niedopuszczalna nazwa komputera w dhcp-host"
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr "nieprawidowa skadnia 'tag-if'"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "nieprawidowy numer portu"
 
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr "zy adres dhcp-proxy"
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr "zy dhcp-relay"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr "nieprawidowe argumenty RA"
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr "zy DUID"
 
-#: option.c:3796
+#: option.c:4023
+#, fuzzy
+msgid "missing address in alias"
+msgstr "niepoprawny adres"
+
+#: option.c:4029
 msgid "invalid alias range"
 msgstr "nieprawidowy zakres adresw w --alias"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr "za CNAME"
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr "powtrzona CNAME"
 
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr "nieprawidowy zapis rekordu PTR"
 
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr "nieprawidowy zapis rekordu NAPTR"
 
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr "nieprawidowy zapis rekordu RR"
 
-#: option.c:3984
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "nieprawidowy zapis rekordu RR"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "nieprawidowy zapis rekordu TXT"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "nieprawidowy zapis rekordu SRV"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "nieprawidowa warto celu SRV"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "nieprawidowy priorytet"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "nieprawidowa waga"
 
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr "nieprawidowy zapis host-record"
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr "niedopuszczalna nazwa w host-record"
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 msgid "bad trust anchor"
 msgstr "nieprawidowa specyfikacja punktu zaufania"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr "zy zapis szesnastkowy"
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr "nieobsugiwana opcja (sprawd, czy obsuga DHCP/TFTP/DNSSEC/DBus zostaa wkompilowana)"
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "brakuje \""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "nieprawidowa opcja"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "nadwykowy parametr"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "brak parametru"
 
-#: option.c:4309
+#: option.c:4630
 msgid "illegal option"
 msgstr "niedopuszczalna opcja"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "bd"
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr " w linii %d pliku %s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr "przeczytaem %s"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "bd odczytu z pliku %s: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr "jakie mieci w linii polece"
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "Dnsmasq, wersja %s  %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1084,501 +1138,553 @@
 "Wkompilowane opcje %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Autor nie daje ADNYCH GWARANCJI egzekwowalnych prawnie.\n"
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsmasq jest wolnym oprogramowaniem, moesz go rozprowadza\n"
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "na warunkach okrelonych w GNU General Public Licence, w wersji 2 lub 3.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr "sprbuj: --help"
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr "sprbuj: -w"
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr "nieprawidowa opcja w linii polece %s"
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "nie mona pobra nazwy hosta: %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "w trybie no-poll mona wskaza najwyej jeden plik resolv.conf."
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "musisz mie dokadnie jeden plik resolv.conf do odczytu domen."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr "nie udao si odczyta %s: %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "brak wytycznych wyszukiwania w %s"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr "w przypadku uywania --dhcp-fqdn trzeba wskaza domyln domen"
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr "skadnia sprawdzona, jest prawidowa"
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr "wysyanie pakietu nie powiodo si: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr "odrzucam odpowied DNS: nie zgadza si specyfikacja podsieci"
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "serwer nazw %s odmawia wykonania zapytania rekurencyjnego"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr "prawdopodobnie wykryto atak DNS-rebind: %s"
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr "Ignorowanie zapyta z sieci pozalokalnych."
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Osignito graniczn ilo jednoczenie obsugiwanych zapyta DNS (maks: %d)"
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "nie udao si otworzy gniazda %s: %s"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr "UWAGA: nasuchiwanie na %s moe przyjmowa dania przychodzce przez interfejsy inne ni %s"
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr "UWAGA: zastosowanie --bind-dynamic zamiast --bind-interfaces daje ochron przed atakami wzmocnienia DNS"
 
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "uwaga: %s niedostpny"
 
-#: network.c:1056
+#: network.c:1027
 #, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "uwaga: nie znaleziono adresu interfejsu %s"
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "interfejs %s nie pozwoli si przyczy do grupy rozgoszeniowej DHCPv6: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr "sprbuj podwyszy /proc/sys/net/core/optmem_max"
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "bd przy przyznawaniu nazwy gniazdu serwera %s: %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignorowanie serwera nazw %s - interfejs lokalny"
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignorowanie serwera nazw %s - nie mona utworzy/dowiza gniazda: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr "(brak obsugi DNSSEC)"
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "niekwalifikowane(-a)"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr "nazwy"
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr "domylne"
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "domeny"
 
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "uywam adresw lokalnych tylko dla %s %s"
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "uywam standardowych serwerw nazw dla %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "uywam serwera nazw %s#%d dla %s %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "NIE uywam serwera nazw %s#%d - wykryto ptl zapyta"
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "uywam serwera nazw %s#%d (przez %s)"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "uywam serwera nazw %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "uywam o %d serwerw nazw wicej"
 
-#: network.c:1593
+#: network.c:1564
 #, c-format
 msgid "using %d more nameservers"
 msgstr "uywam o %d serwerw nazw wicej"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr "dhcp-hostsdir, dhcp-optsdir i hostsdir nie znajduj zastosowania na tej platformie"
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr "nie wskazano punktw zaufania dla DNSSEC"
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr "brak moliwoci zmniejszenia pamici podrcznej poniej wielkoci domylnej w przypadku uywania DNSSEC"
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "obsuga DNSSEC niedostpna - ustaw HAVE_DNSSEC w src/config.h"
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "Serwer TFTP nie zosta wkompilowany -- ustaw HAVE_TFTP w src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr "--conntrack i --query-port wzajemnie si wykluczaj"
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "wsparcie przekazywania znacznikw pocze (conntrack) nie zostao wkompilowane - ustaw HAVE_CONNTRACK w src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr "zapis do logw w trybie asynchronicznym nie jest dostpny w Solarisie"
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr "zapis do logw w trybie asynchronicznym nie jest dostpny w Androidzie"
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "tryb autorytatywny DNS-a niedostpny - ustaw HAVE_AUTH w src/config.h"
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "wykrywanie ptli zapyta nie zostao wkompilowane - ustaw HAVE_LOOP w src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "Obsuga DBus nie zostaa wkompilowana -- ustaw HAVE_DBUS w src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr "max_port nie moe by niszy ni min_port"
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr "za pomoc --auth-soa musi zosta ustawiony numer seryjny strefy"
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr "konstrukcja dhcp-range nie jest dostpna w tym systemie"
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr "--bind-interfaces i --bind-dynamic wzajemnie si wykluczaj"
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "bd podczas tworzenia listy interfejsw sieciowych: %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "nieznany interfejs %s"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "Obsuga DBus nie zostaa wkompilowana -- ustaw HAVE_DBUS w src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "bd DBus: %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "Obsuga DBus nie zostaa wkompilowana -- ustaw HAVE_DBUS w src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "Obsuga DBus nie zostaa wkompilowana -- ustaw HAVE_DBUS w src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr "nieznany uytkownik lub grupa: %s"
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr "nie potrafi wej do gwnego katalogu: %s"
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr "uruchomiony, wersja %s, DNS wyczony"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "uruchomiony, wersja %s, %d miejsc w pamici podrcznej"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "uruchomiony, wersja %s, pami podrczna wyczona"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr "usuga DNS ograniczona do lokalnych podsieci"
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "opcje kompilacji: %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "obsuga DBus wczona, podczono do serwera DBus"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "obsuga DBus wczona, trwa podczanie do serwera DBus"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "obsuga DBus wczona, podczono do serwera DBus"
+
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "obsuga DBus wczona, trwa podczanie do serwera DBus"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr "walidacja DNSSEC wczona"
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 #, fuzzy
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr "sprawdzanie sygnatur czasowych DNSSEC wyczone do czasu przeadowania pamici podrcznej"
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr "sprawdzanie sygnatur czasowych DNSSEC wyczone do czasu zsynchronizowania si zegara systemowego"
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "uwaga: nie udao si zmieni uytkownika pliku %s: %s"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "ustawiam --bind-interfaces z powodu ogranicze systemu operacyjnego"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "uwaga: interfejs %s nie jest wczony"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr "uwaga: ignoruj opcj resolv-file, poniewa wybrano tryb no-resolv"
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr "uwaga: nie wskazano nadrzdnych serwerw DNS"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr "wczono asynchroniczny tryb zapisu do logw z kolejk na %d komunikatw"
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr "anonsowanie rutera IPv6 wczone"
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr "DHCP, gniazda dowizane na wyczno interfejsowi %s"
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr "z gwnym katalogiem w "
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr "wczony"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr "w trybie bezpiecznym"
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "nieprawidowy numer portu"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr "uwaga: %s niedostpny"
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr "uwaga: katalog TFTP %s nie jest dostpny"
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr "ograniczam ilo jednoczesnych przesa TFTP do %d"
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "podczono do DBus-a"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr "nie potrafi przeczy si do pracy w tle: %s"
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr "nie udao si utworzy procesu pomocniczego: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr "nie powiodo si ustawianie ogranicze (capabilities): %s"
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "nie udao si zmieni uytkownika procesu na %s: %s"
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "nie udao si zmieni grupy procesu na %s: %s"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "nie udao si otworzy pliku z PID-em %s: %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr "nie udao si otworzy logu %s: %s"
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr "nie udao si wczyta skryptu Lua: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr "katalog TFTP %s nie jest dostpny: %s"
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "nie potrafi utworzy pliku znacznika czasu %s: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr "skrypt zosta zabity sygnaem %d"
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr "skrypt zakoczy si z kodem powrotu %d"
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr "nie udao si uruchomi %s: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr "trwa sprawdzanie sygnatur czasowych podpisw DNSSEC"
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "nie udao si uaktualni znacznika czasu pliku %s: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "zakoczyem dziaanie z powodu odebrania SIGTERM"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr "brak dostpu do %s: %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "czytanie %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr "w %s nie znalazem serwerw, sprbuj ponownie pniej"
@@ -1608,7 +1714,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "nie udao si utworzy surowego gniazda ICMP: %s."
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "nieznany interfejs %s w bridge-u"
@@ -1618,331 +1724,337 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr "danie DHCP odebrano na interfejsie %s, ktry nie ma adresu"
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr "uzupenienie pamici podrcznej ARP nie powiodo si: %s"
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr "Bd wysyania pakietu DHCP do %s: %s"
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "zakres adresw DHCP %s -- %s jest niespjny z mask sieci %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr "za zawarto pliku %s, w linii %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr "w %s pomijam lini %d -- powtrzona nazwa lub adres IP"
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr "przekazywanie DHCP %s -> %s"
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "zbyt dua ilo zapisanych dzieraw"
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "nie potrafi otworzy albo utworzy pliku dzieraw %s: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "nie udao si odczyta %s: %s"
 
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "nie udao si odczyta %s: %s"
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "nie potrafi uruchomi skryptu %s: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr "skrypt zakoczy si z kodem powrotu %s"
 
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "bd zapisu do %s: %s (sprbuj ponownie za %us)"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr "Nie uwzgldniam czci domenowej (%s) dla komputera %s"
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "nie zdefiniowano zakresu adresw odpowiedniego dla dania %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "z wyborem podsieci"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "przez"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "%u dostpna podsie DHCP: %s/%s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr "%u dostpny zakres adresw DHCP: %s -- %s"
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr "%u klasa dostawcy: %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr "%u klasa uytkownika: %s"
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "wyczony(a)"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "ignoruj"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "adres jest w uyciu"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "brak dostpnego adresu"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "nieprawidowa sie"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "brak skonfigurowanego adresu"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "brak wolnych dzieraw"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr "klient %u przedstawia si jako %s"
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr "PXE BIS nie jest obsugiwane"
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "wyczam statyczne przypisanie adresu %s dla %s"
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "nieznana dzierawa"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr "nie proponuj zakadanego w konfiguracji adresu %s, bo jest on ju wydzierawiony komputerowi %s"
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr "nie proponuj zakadanego w konfiguracji adresu %s, bo uywa go ktry z serwerw"
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr "nie proponuj zakadanego w konfiguracji adresu %s, bo ju poprzednio zosta odrzucony"
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr "brak unikalnego id"
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr "nieprawidowy identyfikator serwera (server-ID)"
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "bdny adres"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "dzierawa nieznaleziona"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "adres niedostpny"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "dostpna statyczna dzierawa"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "adres zarezerwowany"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr "porzucam przypisanie do %s nazwy %s"
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr "%u nazwa pliku bootowania: %s"
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr "%u nazwa serwera: %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr "%u nastpny serwer: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr "%u odpowied rozgoszeniowa"
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "nie mam moliwoci wysania opcji %d DHCP/BOOTP: niedostateczna ilo miejsca w pakiecie"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr "menu PXE zbyt due"
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr "%u zadano: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr "nie mog wysa opcji RFC3925: za dugi acuch opcji przy numerze %d"
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "nie potrafi utworzy poczenia netlink %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr "wystpi bd w poczeniu netlink %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "prba ustawienia adresu IPv6 serwera przez DBus, ale brak obsugi IPv6"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr "opcja --%s zostaa wanie aktywowana za pomoc D-Bus"
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr "opcja --%s zostaa wanie dezaktywowana za pomoc D-Bus"
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "ustawiam adresy serwerw nadrzdnych na podstawie informacji odebranych z DBus"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "nie mona zarejestrowa uchwytu DBus"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "nie potrafi utworzy gniazda DHCP BPF: %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "danie DHCP od urzdzenia nieobsugiwanego typu (%d) odebrano na %s"
 
-#: bpf.c:378
+#: bpf.c:374
 #, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "nie udao si utworzy gniazda PF_ROUTE: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr "Nieznana wersja protokou."
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr "w skrypcie Lua brak funkcji lease()"
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr "brak wolnego portu dla usugi TFTP"
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr "nieobsugiwane danie od komputera %s"
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr "plik %s nie zosta znaleziony"
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
-msgstr "bd %d %s odebrano od %s"
-
-#: tftp.c:634
-#, c-format
 msgid "failed sending %s to %s"
 msgstr "bd wysyania pliku %s do komputera %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr "plik %s przesano do %s"
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr "bd %d %s odebrano od %s"
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -1957,7 +2069,7 @@
 msgid "FAILED to start up"
 msgstr "BD: nie udao si uruchomi dnsmasq-a"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr "Nie udao si odczta znacznika poczenia (conntrack): %s"
@@ -1977,77 +2089,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "dowizywanie gniazda serwera DHCPv6 zakoczone niepowodzeniem: %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "nie zdefiniowano zakresu adresw odpowiedniego dla dania DHCPv6 przekazanego przez %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "nie zdefiniowano zakresu adresw odpowiedniego dla dania DHCPv6 od %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "%u dostpna podsie DHCPv6: %s/%d"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr "%u klasa dostawcy: %u"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr "adres MAC klienta %u: %s"
 
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr "nieznana klasa sieci %d"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr "adres niedostpny"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr "udane"
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr "brak wolnych adresw"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr "poza zasigiem"
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr "brak powizania"
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr "przestarzay"
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr "niepoprawny adres"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr "brak potwierdzenia"
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr "wszystkie adresy cigle w uyciu"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr "adres zosta zwolniony"
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr "Nie mog rozesa do serwerw DHCPv6 nie majc prawidowego interfejsu"
 
@@ -2061,76 +2168,76 @@
 msgid "%u tags: %s"
 msgstr "%u cechy: %s"
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr "do komputera o nazwie %s pasuje wicej ni jeden adres, w odpowiedzi DHCP wysyam %s"
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "powtrzenie adresu IP %s (%s) w opcji dhcp-config"
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "nie udao si ustawi SO_BINDTODEVICE gniazda DHCP: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr "Znane opcje DHCP:\n"
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr "Rozpoznawane opcje DHCPv6:\n"
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ", przestarzay prefiks"
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ", czas dzierawy "
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr "%s bezstanowy na %s%.0s%.0s%s"
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "%s, wycznie statyczne dzierawy na %.0s%s%s%.0s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr "%s, wykryto porednika na podsieci %.0s%s%.0s%.0s"
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "%s, zakres IP %s -- %s%s%.0s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr "pochodzce z DHCPv4 nazwy IPv6 na %s%s"
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr "anonsowanie rutera na %s%s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr "przekazywanie DHCP z %s do %s za pomoc %s"
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr "przekazywanie DHCP z %s do %s"
@@ -2140,7 +2247,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "nie udao si utworzy gniazda dla ICMPv6: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr "ignoruj danie transferu strefy od %s"
@@ -2155,19 +2262,24 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "nie powiodo si otwieranie gniazda sterujcego IPset: %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "nie udao si uaktualni znacznika czasu pliku %s: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 #, fuzzy
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr "trwa sprawdzanie sygnatur czasowych podpisw DNSSEC"
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
+msgstr ""
+
+#: blockdata.c:55
+#, fuzzy, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
 msgstr "DNSSEC: zuycie pamici %u, maks. %u, przydzielona %u"
 
 #: tables.c:61
@@ -2199,12 +2311,12 @@
 msgid "info: table created"
 msgstr "info: tablica utworzona"
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr "uwaga: DIOCR%sADDRS: %s"
 
-#: tables.c:138
+#: tables.c:137
 #, c-format
 msgid "%d addresses %s"
 msgstr "%d adresw %s"
@@ -2244,6 +2356,82 @@
 msgid "inotify, new or changed file %s"
 msgstr "inotify: pojawi si lub uleg zmianie plik %s"
 
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "bd odczytu z pliku %s: %s"
+
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "adres jest w uyciu"
+
+#: dump.c:201
+#, fuzzy
+msgid "failed to write packet dump"
+msgstr "wysyanie pakietu nie powiodo si: %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "nie udao si otworzy logu %s: %s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "nie udao si otworzy logu %s: %s"
+
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "podczono do DBus-a"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "wysyanie pakietu nie powiodo si: %s"
+
+#~ msgid "Specify DHCPv6 prefix class"
+#~ msgstr "Okrelenie prefiksu klasy DHCPv6"
+
+#~ msgid "cannot run scripts under uClinux"
+#~ msgstr "w uClinuksie nie ma moliwoci uruchamiania skryptw"
+
+#~ msgid "cannot match tags in --dhcp-host"
+#~ msgstr "--dhcp-host nie dopuszcza dopasowywania na podstawie znacznikw"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "prba ustawienia adresu IPv6 serwera przez DBus, ale brak obsugi IPv6"
+
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "nieznana klasa sieci %d"
+
 #~ msgid "bad TTL"
 #~ msgstr "zy TTL"
 
Index: po/pt_BR.po
===================================================================
--- po/pt_BR.po	(revision 41436)
+++ po/pt_BR.po	(working copy)
@@ -16,70 +16,70 @@
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n > 1);\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
-#: cache.c:928
+#: cache.c:1081
 #, c-format
 msgid "failed to load names from %s: %s"
 msgstr ""
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr ""
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr ""
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr ""
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr ""
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr ""
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
-#: cache.c:1419
+#: cache.c:1664
 #, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr ""
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -93,659 +93,695 @@
 msgid "failed to allocate memory"
 msgstr ""
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr ""
 
-#: util.c:291
+#: util.c:302
 #, c-format
 msgid "cannot create pipe: %s"
 msgstr ""
 
-#: util.c:299
+#: util.c:310
 #, c-format
 msgid "failed to allocate %d bytes"
 msgstr ""
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr ""
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr ""
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr ""
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr ""
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr ""
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr ""
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr ""
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr ""
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr ""
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr ""
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr ""
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr ""
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr ""
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr ""
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr ""
 
-#: option.c:358
+#: option.c:372
 msgid "Read DHCP host specs from file."
 msgstr ""
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
-#: option.c:360
+#: option.c:374
 msgid "Read DHCP host specs from a directory."
 msgstr ""
 
-#: option.c:361
+#: option.c:375
 msgid "Read DHCP options from a directory."
 msgstr ""
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr ""
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr ""
 
-#: option.c:365
+#: option.c:379
 msgid "Read hosts files from a directory."
 msgstr ""
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr ""
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr ""
 
-#: option.c:368
+#: option.c:382
 msgid "Map DHCP user class to tag."
 msgstr ""
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
-#: option.c:372
+#: option.c:386
 msgid "Don't do DHCP for hosts with tag set."
 msgstr ""
 
-#: option.c:373
+#: option.c:387
 msgid "Force broadcast replies for hosts with tag set."
 msgstr ""
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr ""
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr ""
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr ""
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr ""
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr ""
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr ""
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr ""
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr ""
 
-#: option.c:383
+#: option.c:397
 msgid "Specify options to be sent to DHCP clients."
 msgstr ""
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr ""
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr ""
 
-#: option.c:387
+#: option.c:401
 msgid "Log DNS queries."
 msgstr ""
 
-#: option.c:388
+#: option.c:402
 msgid "Force the originating port for upstream DNS queries."
 msgstr ""
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr ""
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr ""
 
-#: option.c:391
+#: option.c:405
 msgid "Specify path to file with server= options"
 msgstr ""
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr ""
 
-#: option.c:393
+#: option.c:407
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr ""
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr ""
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr ""
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr ""
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr ""
 
-#: option.c:398
+#: option.c:412
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr ""
 
-#: option.c:399
+#: option.c:413
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr ""
 
-#: option.c:400
+#: option.c:414
 msgid "Specify time-to-live ceiling for cache."
 msgstr ""
 
-#: option.c:401
+#: option.c:415
 msgid "Specify time-to-live floor for cache."
 msgstr ""
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr ""
 
-#: option.c:403
+#: option.c:417
 msgid "Map DHCP vendor class to tag."
 msgstr ""
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr ""
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr ""
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr ""
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
-#: option.c:408
+#: option.c:422
 #, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr ""
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr ""
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr ""
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr ""
 
-#: option.c:412
+#: option.c:426
 msgid "Specify PTR DNS record."
 msgstr ""
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr ""
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr ""
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr ""
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr ""
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr ""
 
-#: option.c:419
+#: option.c:434
 msgid "Map MAC address (with wildcards) to option set."
 msgstr ""
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
-#: option.c:427
+#: option.c:443
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr ""
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
-#: option.c:429
+#: option.c:445
 #, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr ""
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr ""
 
-#: option.c:439
+#: option.c:455
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr ""
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
-#: option.c:451
+#: option.c:469
 msgid "Specify NAPTR DNS record."
 msgstr ""
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
-#: option.c:459
+#: option.c:477
 msgid "Prompt to send to PXE clients."
 msgstr ""
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
-#: option.c:464
+#: option.c:482
 msgid "Add client identification to forwarded DNS queries."
 msgstr ""
 
-#: option.c:465
+#: option.c:483
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr ""
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+#: option.c:485
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr ""
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr ""
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 msgid "Specify arbitrary DNS resource record"
 msgstr ""
 
-#: option.c:473
+#: option.c:493
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr ""
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -752,320 +788,332 @@
 "\n"
 msgstr ""
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr ""
 
-#: option.c:707
+#: option.c:729
 #, c-format
 msgid "Valid options are:\n"
 msgstr ""
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 msgid "bad address"
 msgstr ""
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr ""
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 msgid "bad interface name"
 msgstr ""
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr ""
 
-#: option.c:1144
+#: option.c:1270
 msgid "bad IP address"
 msgstr ""
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 msgid "bad IPv6 address"
 msgstr ""
 
-#: option.c:1240
+#: option.c:1366
 msgid "bad IPv4 address"
 msgstr ""
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr ""
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr ""
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, c-format
 msgid "cannot access directory %s: %s"
 msgstr ""
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, c-format
 msgid "cannot access %s: %s"
 msgstr ""
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr ""
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr ""
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr ""
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 msgid "bad prefix"
 msgstr ""
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
-#: option.c:2713
+#: option.c:2871
 msgid "bad port range"
 msgstr ""
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr ""
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr ""
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
-#: option.c:2925
+#: option.c:3123
 msgid "inconsistent DHCPv6 range"
 msgstr ""
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 msgid "bad hex constant"
 msgstr ""
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
+#: option.c:3315
+msgid "bad IPv6 prefix"
 msgstr ""
 
-#: option.c:3119
+#: option.c:3362
 #, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr ""
 
-#: option.c:3177
+#: option.c:3422
 msgid "bad DHCP host name"
 msgstr ""
 
-#: option.c:3259
+#: option.c:3508
 msgid "bad tag-if"
 msgstr ""
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr ""
 
-#: option.c:3678
+#: option.c:3907
 msgid "bad dhcp-proxy address"
 msgstr ""
 
-#: option.c:3704
+#: option.c:3935
 msgid "Bad dhcp-relay"
 msgstr ""
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
-#: option.c:3796
+#: option.c:4023
+msgid "missing address in alias"
+msgstr ""
+
+#: option.c:4029
 msgid "invalid alias range"
 msgstr ""
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
-#: option.c:3889
+#: option.c:4132
 msgid "bad PTR record"
 msgstr ""
 
-#: option.c:3920
+#: option.c:4167
 msgid "bad NAPTR record"
 msgstr ""
 
-#: option.c:3954
+#: option.c:4203
 msgid "bad RR record"
 msgstr ""
 
-#: option.c:3984
+#: option.c:4236
+msgid "bad CAA record"
+msgstr ""
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr ""
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr ""
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr ""
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr ""
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr ""
 
-#: option.c:4073
+#: option.c:4362
 msgid "Bad host-record"
 msgstr ""
 
-#: option.c:4097
+#: option.c:4402
 msgid "Bad name in host-record"
 msgstr ""
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 msgid "bad trust anchor"
 msgstr ""
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr ""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr ""
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr ""
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr ""
 
-#: option.c:4309
+#: option.c:4630
 msgid "illegal option"
 msgstr ""
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr ""
 
-#: option.c:4318
+#: option.c:4639
 #, c-format
 msgid " at line %d of %s"
 msgstr ""
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, c-format
 msgid "read %s"
 msgstr ""
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr ""
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr ""
 
-#: option.c:4730
+#: option.c:5068
 #, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1072,500 +1120,546 @@
 "\n"
 msgstr ""
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr ""
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr ""
 
-#: option.c:4733
+#: option.c:5071
 #, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr ""
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
-#: option.c:4748
+#: option.c:5092
 #, c-format
 msgid "bad command line options: %s"
 msgstr ""
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr ""
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr ""
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr ""
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, c-format
 msgid "failed to read %s: %s"
 msgstr ""
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr ""
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
-#: forward.c:102
+#: forward.c:99
 #, c-format
 msgid "failed to send packet: %s"
 msgstr ""
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr ""
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr ""
 
-#: network.c:720
+#: network.c:698
 #, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr ""
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, c-format
 msgid "warning: using interface %s instead"
 msgstr ""
 
-#: network.c:1056
+#: network.c:1027
 #, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr ""
 
-#: network.c:1114
+#: network.c:1085
 #, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr ""
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr ""
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr ""
 
-#: network.c:1539
+#: network.c:1510
 #, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr ""
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr ""
 
-#: network.c:1572
+#: network.c:1543
 #, c-format
-msgid "using local addresses only for %s %s"
+msgid "using only locally-known addresses for %s %s"
 msgstr ""
 
-#: network.c:1575
+#: network.c:1546
 #, c-format
 msgid "using standard nameservers for %s %s"
 msgstr ""
 
-#: network.c:1577
+#: network.c:1548
 #, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr ""
 
-#: network.c:1581
+#: network.c:1552
 #, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr ""
 
-#: network.c:1584
+#: network.c:1555
 #, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr ""
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr ""
 
-#: network.c:1591
+#: network.c:1562
 #, c-format
 msgid "using %d more local addresses"
 msgstr ""
 
-#: network.c:1593
+#: network.c:1564
 #, c-format
 msgid "using %d more nameservers"
 msgstr ""
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr ""
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr ""
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr ""
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr ""
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr ""
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, c-format
 msgid "started, version %s DNS disabled"
 msgstr ""
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr ""
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr ""
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr ""
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr ""
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr ""
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+msgid "UBus support enabled: connected to system bus"
+msgstr ""
+
+#: dnsmasq.c:852
+msgid "UBus support enabled: bus connection pending"
+msgstr ""
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
-#: dnsmasq.c:783
+#: dnsmasq.c:884
 #, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
+#: dnsmasq.c:890
+#, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr ""
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr ""
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr ""
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 msgid "warning: no upstream servers configured"
 msgstr ""
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "enabled"
 msgstr ""
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+msgid "single port mode"
+msgstr ""
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr ""
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, c-format
 msgid "failed to create helper: %s"
 msgstr ""
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, c-format
 msgid "cannot open log %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, c-format
 msgid "failed to load Lua script: %s"
 msgstr ""
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, c-format
 msgid "failed to execute %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr ""
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, c-format
 msgid "failed to access %s: %s"
 msgstr ""
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr ""
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, c-format
 msgid "no servers found in %s, will retry"
 msgstr ""
@@ -1595,7 +1689,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr ""
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr ""
@@ -1605,329 +1699,334 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr ""
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr ""
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr ""
 
-#: lease.c:166
+#: lease.c:176
 #, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr ""
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
+#: lease.c:185
+msgid "failed to parse lease database cleanly"
 msgstr ""
 
-#: lease.c:180
+#: lease.c:188
 #, c-format
 msgid "failed to read lease file %s: %s"
 msgstr ""
 
-#: lease.c:196
+#: lease.c:204
 #, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr ""
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
-#: lease.c:373
+#: lease.c:381
 #, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr ""
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr ""
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr ""
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr ""
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, c-format
 msgid "%u vendor class: %s"
 msgstr ""
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, c-format
 msgid "%u user class: %s"
 msgstr ""
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr ""
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr ""
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr ""
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr ""
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr ""
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr ""
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr ""
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr ""
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr ""
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr ""
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr ""
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr ""
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr ""
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr ""
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, c-format
 msgid "%u server name: %s"
 msgstr ""
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, c-format
 msgid "%u next server: %s"
 msgstr ""
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr ""
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, c-format
 msgid "%u requested options: %s"
 msgstr ""
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, c-format
 msgid "cannot create netlink socket: %s"
 msgstr ""
 
-#: netlink.c:355
+#: netlink.c:352
 #, c-format
 msgid "netlink returns error: %s"
 msgstr ""
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr ""
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr ""
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr ""
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr ""
 
-#: bpf.c:293
+#: bpf.c:289
 #, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr ""
 
-#: bpf.c:378
+#: bpf.c:374
 #, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr ""
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
-#: tftp.c:483
+#: tftp.c:510
 #, c-format
 msgid "file %s not found"
 msgstr ""
 
-#: tftp.c:592
+#: tftp.c:628
 #, c-format
-msgid "error %d %s received from %s"
+msgid "failed sending %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
-msgid "failed sending %s to %s"
+msgid "sent %s to %s"
 msgstr ""
 
-#: tftp.c:634
+#: tftp.c:678
 #, c-format
-msgid "sent %s to %s"
+msgid "error %d %s received from %s"
 msgstr ""
 
 #: log.c:190
@@ -1944,7 +2043,7 @@
 msgid "FAILED to start up"
 msgstr ""
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -1964,77 +2063,72 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr ""
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr ""
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr ""
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr ""
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, c-format
 msgid "%u vendor class: %u"
 msgstr ""
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, c-format
 msgid "%u client MAC address: %s"
 msgstr ""
 
-#: rfc3315.c:673
-#, c-format
-msgid "unknown prefix-class %d"
-msgstr ""
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 msgid "address unavailable"
 msgstr ""
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 msgid "no addresses available"
 msgstr ""
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 msgid "address invalid"
 msgstr ""
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 msgid "all addresses still on link"
 msgstr ""
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2048,76 +2142,76 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr ""
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr ""
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr ""
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, c-format
 msgid "router advertisement on %s%s"
 msgstr ""
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2127,7 +2221,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr ""
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2142,20 +2236,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr ""
 
-#: ipset.c:233
+#: ipset.c:226
 #, c-format
 msgid "failed to update ipset %s: %s"
 msgstr ""
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, c-format
 msgid "failed to access pf devices: %s"
@@ -2185,12 +2284,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, c-format
 msgid "%d addresses %s"
 msgstr ""
@@ -2229,3 +2328,62 @@
 #, c-format
 msgid "inotify, new or changed file %s"
 msgstr ""
+
+#: dump.c:64
+#, c-format
+msgid "cannot create %s: %s"
+msgstr ""
+
+#: dump.c:70
+#, c-format
+msgid "bad header in %s"
+msgstr ""
+
+#: dump.c:201
+msgid "failed to write packet dump"
+msgstr ""
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr ""
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr ""
+
+#: ubus.c:112
+msgid "Connected to system UBus"
+msgstr ""
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, c-format
+msgid "Failed to send UBus event: %s"
+msgstr ""
Index: po/ro.po
===================================================================
--- po/ro.po	(revision 41436)
+++ po/ro.po	(working copy)
@@ -15,71 +15,71 @@
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: cache.c:518
+#: cache.c:559
 msgid "Internal error in cache."
 msgstr ""
 
 # for compatibility purposes the letters , , ,  and  can be written as their look-alike correspondent.
-#: cache.c:928
+#: cache.c:1081
 #, fuzzy, c-format
 msgid "failed to load names from %s: %s"
 msgstr "ncrcarea numelor din %s: %s a euat"
 
-#: cache.c:954 dhcp.c:867
+#: cache.c:1103 dhcp.c:927
 #, c-format
 msgid "bad address at %s line %d"
 msgstr "adres greit n %s, linia %d"
 
-#: cache.c:1007 dhcp.c:883
+#: cache.c:1156 dhcp.c:943
 #, c-format
 msgid "bad name at %s line %d"
 msgstr "nume greit n %s linia %d"
 
-#: cache.c:1016 dhcp.c:958
+#: cache.c:1167 dhcp.c:1018
 #, c-format
 msgid "read %s - %d addresses"
 msgstr "citesc %s - %d adrese"
 
-#: cache.c:1129
+#: cache.c:1283
 msgid "cleared cache"
 msgstr "memoria temporar a fost tears"
 
-#: cache.c:1158
+#: cache.c:1345
 #, c-format
 msgid "No IPv4 address found for %s"
 msgstr ""
 
-#: cache.c:1237
+#: cache.c:1391
 #, c-format
 msgid "%s is a CNAME, not giving it to the DHCP lease of %s"
 msgstr ""
 
-#: cache.c:1261
+#: cache.c:1415
 #, c-format
 msgid "not giving name %s to the DHCP lease of %s because the name exists in %s with address %s"
 msgstr "nu pot da numele %s mprumutului de adres DHCP a lui %s deoarece numeleexist n %s cu adresa %s"
 
-#: cache.c:1418
+#: cache.c:1663
 #, c-format
 msgid "time %lu"
 msgstr ""
 
-#: cache.c:1419
+#: cache.c:1664
 #, fuzzy, c-format
 msgid "cache size %d, %d/%d cache insertions re-used unexpired cache entries."
 msgstr "cantitate de memorie temporar %d, %d/%d stocri temporare aureutilizat locaii neexpirate."
 
-#: cache.c:1421
+#: cache.c:1666
 #, c-format
 msgid "queries forwarded %u, queries answered locally %u"
 msgstr ""
 
-#: cache.c:1424
+#: cache.c:1669
 #, c-format
 msgid "queries for authoritative zones %u"
 msgstr ""
 
-#: cache.c:1450
+#: cache.c:1694
 #, c-format
 msgid "server %s#%d: queries sent %u, retried or failed %u"
 msgstr ""
@@ -94,687 +94,724 @@
 msgid "failed to allocate memory"
 msgstr "nu pot ncrca %d bytes"
 
-#: util.c:281 option.c:619
+#: util.c:281 option.c:641
 msgid "could not get memory"
 msgstr "nu am putut aloca memorie"
 
-#: util.c:291
+#: util.c:302
 #, fuzzy, c-format
 msgid "cannot create pipe: %s"
 msgstr "nu pot citi %s: %s"
 
-#: util.c:299
+#: util.c:310
 #, fuzzy, c-format
 msgid "failed to allocate %d bytes"
 msgstr "nu pot ncrca %d bytes"
 
-#: util.c:468
+#: util.c:506
 #, c-format
 msgid "infinite"
 msgstr "infinit"
 
-#: option.c:344
+#: option.c:358
 msgid "Specify local address(es) to listen on."
 msgstr "Specificai adresele locale deservite."
 
-#: option.c:345
+#: option.c:359
 msgid "Return ipaddr for all hosts in specified domains."
 msgstr "Afieaz adresele IP ale mainilor n domeniul dat."
 
-#: option.c:346
+#: option.c:360
 msgid "Fake reverse lookups for RFC1918 private address ranges."
 msgstr "Simuleaz cutri dup adres pentru domenii de adres private (RFC1918)."
 
-#: option.c:347
+#: option.c:361
 msgid "Treat ipaddr as NXDOMAIN (defeats Verisign wildcard)."
 msgstr "Interpreteaz adresa IP ca NXDOMAIN (mpotriva manipulrilor Verisign)"
 
-#: option.c:348
+#: option.c:362
 #, c-format
 msgid "Specify the size of the cache in entries (defaults to %s)."
 msgstr "Specific mrimea nregistrrilor temporare (implicit e %s)."
 
-#: option.c:349
+#: option.c:363
 #, c-format
 msgid "Specify configuration file (defaults to %s)."
 msgstr "Specific fiier de configurare (implicit e %s)."
 
-#: option.c:350
+#: option.c:364
 msgid "Do NOT fork into the background: run in debug mode."
 msgstr "NU pornete n fundal: ruleaz n modul depanare."
 
-#: option.c:351
+#: option.c:365
 msgid "Do NOT forward queries with no domain part."
 msgstr "NU nainta cererile ce nu conin domeniu DNS."
 
-#: option.c:352
+#: option.c:366
 msgid "Return self-pointing MX records for local hosts."
 msgstr "Rspunde cu nregistrri MX spre el nsui pentru maini locale."
 
-#: option.c:353
+#: option.c:367
 msgid "Expand simple names in /etc/hosts with domain-suffix."
 msgstr "Adaug numelor simple din /etc/hosts numele domeniului ca sufix."
 
-#: option.c:354
+#: option.c:368
 msgid "Don't forward spurious DNS requests from Windows hosts."
 msgstr "Nu inainta cereri DNS defecte provenite de la maini Windows."
 
-#: option.c:355
+#: option.c:369
 msgid "Enable DHCP in the range given with lease duration."
 msgstr "Activeaz DHCP n domeniul dat cu durat limitat de mprumut."
 
-#: option.c:356
+#: option.c:370
 #, c-format
 msgid "Change to this group after startup (defaults to %s)."
 msgstr "Ruleaz sub acest grup dup pornire (implicit e %s)."
 
-#: option.c:357
+#: option.c:371
 msgid "Set address or hostname for a specified machine."
 msgstr "Schimb adresa sau numele mainii specificate."
 
-#: option.c:358
+#: option.c:372
 #, fuzzy
 msgid "Read DHCP host specs from file."
 msgstr "nume MX invalid"
 
-#: option.c:359
+#: option.c:373
 msgid "Read DHCP option specs from file."
 msgstr ""
 
-#: option.c:360
+#: option.c:374
 #, fuzzy
 msgid "Read DHCP host specs from a directory."
 msgstr "nume MX invalid"
 
-#: option.c:361
+#: option.c:375
 #, fuzzy
 msgid "Read DHCP options from a directory."
 msgstr "nume MX invalid"
 
-#: option.c:362
+#: option.c:376
 msgid "Evaluate conditional tag expression."
 msgstr ""
 
-#: option.c:363
+#: option.c:377
 #, c-format
 msgid "Do NOT load %s file."
 msgstr "Nu ncarc fiierul %s."
 
-#: option.c:364
+#: option.c:378
 #, c-format
 msgid "Specify a hosts file to be read in addition to %s."
 msgstr "Specific spre citire un fiier hosts adiional la %s."
 
-#: option.c:365
+#: option.c:379
 #, fuzzy
 msgid "Read hosts files from a directory."
 msgstr "nume MX invalid"
 
-#: option.c:366
+#: option.c:380
 msgid "Specify interface(s) to listen on."
 msgstr "Specific interfeele deservite."
 
-#: option.c:367
+#: option.c:381
 msgid "Specify interface(s) NOT to listen on."
 msgstr "Specific interfeele NE-deservite."
 
-#: option.c:368
+#: option.c:382
 #, fuzzy
 msgid "Map DHCP user class to tag."
 msgstr "Leag clasa de utilizator DHCP cu grup de opiuni."
 
-#: option.c:369
+#: option.c:383
 msgid "Map RFC3046 circuit-id to tag."
 msgstr ""
 
-#: option.c:370
+#: option.c:384
 msgid "Map RFC3046 remote-id to tag."
 msgstr ""
 
-#: option.c:371
+#: option.c:385
 msgid "Map RFC3993 subscriber-id to tag."
 msgstr ""
 
-#: option.c:372
+#: option.c:386
 #, fuzzy
 msgid "Don't do DHCP for hosts with tag set."
 msgstr "Nu furniza DHCP mainilor din grupul de opiuni."
 
-#: option.c:373
+#: option.c:387
 #, fuzzy
 msgid "Force broadcast replies for hosts with tag set."
 msgstr "Nu furniza DHCP mainilor din grupul de opiuni."
 
-#: option.c:374
+#: option.c:388
 msgid "Do NOT fork into the background, do NOT run in debug mode."
 msgstr "NU pornete n fundal, NU ruleaz n modul depanare."
 
-#: option.c:375
+#: option.c:389
 msgid "Assume we are the only DHCP server on the local network."
 msgstr "Presupune c suntem singurul server DHCP din reeaua local."
 
-#: option.c:376
+#: option.c:390
 #, c-format
 msgid "Specify where to store DHCP leases (defaults to %s)."
 msgstr "Specific fiierul de stocare a mprumuturilor DHCP (implicit e %s)."
 
-#: option.c:377
+#: option.c:391
 msgid "Return MX records for local hosts."
 msgstr "Rspunde cu ntregistrri MX pentru maini locale."
 
-#: option.c:378
+#: option.c:392
 msgid "Specify an MX record."
 msgstr "Specific o nregistrare MX."
 
-#: option.c:379
+#: option.c:393
 msgid "Specify BOOTP options to DHCP server."
 msgstr "Specific opiuni BOOTP serverului DHCP."
 
-#: option.c:380
+#: option.c:394
 #, c-format
 msgid "Do NOT poll %s file, reload only on SIGHUP."
 msgstr "Nu ncrca fiierul %s, citete-l doar la SIGHUP."
 
-#: option.c:381
+#: option.c:395
 msgid "Do NOT cache failed search results."
 msgstr "NU memora rezultatele de cutare DNS euatat."
 
-#: option.c:382
+#: option.c:396
 #, c-format
 msgid "Use nameservers strictly in the order given in %s."
 msgstr "Folosete servere DNS strict n ordinea dat n %s."
 
-#: option.c:383
+#: option.c:397
 #, fuzzy
 msgid "Specify options to be sent to DHCP clients."
 msgstr "Configureaz opiuni n plusce trebuie trimise clienilor DHCP."
 
-#: option.c:384
+#: option.c:398
 msgid "DHCP option sent even if the client does not request it."
 msgstr ""
 
-#: option.c:385
+#: option.c:399
 msgid "Specify port to listen for DNS requests on (defaults to 53)."
 msgstr "Specific numrul portului pentru cereri DNS (implicit e 53)."
 
-#: option.c:386
+#: option.c:400
 #, c-format
 msgid "Maximum supported UDP packet size for EDNS.0 (defaults to %s)."
 msgstr "Marimea maxim a pachetului UDP pentru EDNS.0 (implicit e %s)."
 
-#: option.c:387
+#: option.c:401
 #, fuzzy
 msgid "Log DNS queries."
 msgstr "nregistreaz tranzaciile."
 
-#: option.c:388
+#: option.c:402
 #, fuzzy
 msgid "Force the originating port for upstream DNS queries."
 msgstr "Foreaz acest port pentru datele ce pleac."
 
-#: option.c:389
+#: option.c:403
 msgid "Do NOT read resolv.conf."
 msgstr "NU citi fiierul resolv.conf"
 
-#: option.c:390
+#: option.c:404
 #, c-format
 msgid "Specify path to resolv.conf (defaults to %s)."
 msgstr "Specific calea ctre resolv.conf (implicit e %s)."
 
-#: option.c:391
+#: option.c:405
 #, fuzzy
 msgid "Specify path to file with server= options"
 msgstr "Specific o cale pentru fiierul PID. (implicit %s)."
 
-#: option.c:392
+#: option.c:406
 msgid "Specify address(es) of upstream servers with optional domains."
 msgstr "Specific adresele server(elor) superioare cu domenii opionale."
 
-#: option.c:393
+#: option.c:407
 #, fuzzy
 msgid "Specify address of upstream servers for reverse address queries"
 msgstr "Specific adresele server(elor) superioare cu domenii opionale."
 
-#: option.c:394
+#: option.c:408
 msgid "Never forward queries to specified domains."
 msgstr "Nu nainteaz cererile spre domeniile specificate."
 
-#: option.c:395
+#: option.c:409
 msgid "Specify the domain to be assigned in DHCP leases."
 msgstr "Specific domeniul de transmis prin DHCP."
 
-#: option.c:396
+#: option.c:410
 msgid "Specify default target in an MX record."
 msgstr "Specific o int ntr-o nregistrare MX."
 
-#: option.c:397
+#: option.c:411
 msgid "Specify time-to-live in seconds for replies from /etc/hosts."
 msgstr "Specific TTL n secunde pentru rspunsurile din /etc/hosts."
 
-#: option.c:398
+#: option.c:412
 #, fuzzy
 msgid "Specify time-to-live in seconds for negative caching."
 msgstr "Specific TTL n secunde pentru rspunsurile din /etc/hosts."
 
-#: option.c:399
+#: option.c:413
 #, fuzzy
 msgid "Specify time-to-live in seconds for maximum TTL to send to clients."
 msgstr "Specific TTL n secunde pentru rspunsurile din /etc/hosts."
 
-#: option.c:400
+#: option.c:414
 #, fuzzy
 msgid "Specify time-to-live ceiling for cache."
 msgstr "Specific TTL n secunde pentru rspunsurile din /etc/hosts."
 
-#: option.c:401
+#: option.c:415
 #, fuzzy
 msgid "Specify time-to-live floor for cache."
 msgstr "Specific TTL n secunde pentru rspunsurile din /etc/hosts."
 
-#: option.c:402
+#: option.c:416
 #, c-format
 msgid "Change to this user after startup. (defaults to %s)."
 msgstr "Ruleaz sub acest utilizator dup pornire. (implicit e %s)."
 
-#: option.c:403
+#: option.c:417
 #, fuzzy
 msgid "Map DHCP vendor class to tag."
 msgstr "Trimite opiuni DHCP n funcie de marca plcii de reea."
 
-#: option.c:404
+#: option.c:418
 msgid "Display dnsmasq version and copyright information."
 msgstr "Afieaz versiunea dnsmasq i drepturile de autor."
 
-#: option.c:405
+#: option.c:419
 msgid "Translate IPv4 addresses from upstream servers."
 msgstr "Traduce adresele IPv4 de la serverele DNS superioare."
 
-#: option.c:406
+#: option.c:420
 msgid "Specify a SRV record."
 msgstr "Specific o nregistrare SRV."
 
-#: option.c:407
+#: option.c:421
 msgid "Display this message. Use --help dhcp or --help dhcp6 for known DHCP options."
 msgstr ""
 
-#: option.c:408
+#: option.c:422
 #, fuzzy, c-format
 msgid "Specify path of PID file (defaults to %s)."
 msgstr "Specific o cale pentru fiierul PID. (implicit %s)."
 
-#: option.c:409
+#: option.c:423
 #, c-format
 msgid "Specify maximum number of DHCP leases (defaults to %s)."
 msgstr "Specific numrul maxim de mprumuturi DHCP (implicit %s)."
 
-#: option.c:410
+#: option.c:424
 msgid "Answer DNS queries based on the interface a query was sent to."
 msgstr "Rspunde cererilor DNS n funcie de interfaa pe care a venit cererea."
 
-#: option.c:411
+#: option.c:425
 msgid "Specify TXT DNS record."
 msgstr "Specific o nregistrare TXT."
 
-#: option.c:412
+#: option.c:426
 #, fuzzy
 msgid "Specify PTR DNS record."
 msgstr "Specific o nregistrare TXT."
 
-#: option.c:413
+#: option.c:427
 msgid "Give DNS name to IPv4 address of interface."
 msgstr ""
 
-#: option.c:414
+#: option.c:428
 msgid "Bind only to interfaces in use."
 msgstr "Ascult doar pe interfeele active."
 
-#: option.c:415
+#: option.c:429
 #, c-format
 msgid "Read DHCP static host information from %s."
 msgstr "Citete informaii DHCP statice despre main din %s."
 
-#: option.c:416
+#: option.c:430
 msgid "Enable the DBus interface for setting upstream servers, etc."
 msgstr "Activeaza interfaa DBus pentru configurarea serverelor superioare."
 
-#: option.c:417
+#: option.c:431
+msgid "Enable the UBus interface."
+msgstr ""
+
+#: option.c:432
 msgid "Do not provide DHCP on this interface, only provide DNS."
 msgstr "Nu activeaz DHCP ci doar DNS pe aceast interfa."
 
-#: option.c:418
+#: option.c:433
 msgid "Enable dynamic address allocation for bootp."
 msgstr "Activeaz alocarea dinamic a adreselor pentru BOOTP."
 
-#: option.c:419
+#: option.c:434
 #, fuzzy
 msgid "Map MAC address (with wildcards) to option set."
 msgstr "Trimite opiuni DHCP n funcie de marca plcii de reea."
 
-#: option.c:420
+#: option.c:435
 msgid "Treat DHCP requests on aliases as arriving from interface."
 msgstr ""
 
-#: option.c:421
+#: option.c:436
+msgid "Specify extra networks sharing a broadcast domain for DHCP"
+msgstr ""
+
+#: option.c:437
 msgid "Disable ICMP echo address checking in the DHCP server."
 msgstr ""
 
-#: option.c:422
+#: option.c:438
 msgid "Shell script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:423
+#: option.c:439
 msgid "Lua script to run on DHCP lease creation and destruction."
 msgstr ""
 
-#: option.c:424
+#: option.c:440
 msgid "Run lease-change scripts as this user."
 msgstr ""
 
-#: option.c:425
+#: option.c:441
 msgid "Call dhcp-script with changes to local ARP table."
 msgstr ""
 
-#: option.c:426
+#: option.c:442
 msgid "Read configuration from all the files in this directory."
 msgstr ""
 
-#: option.c:427
+#: option.c:443
 #, fuzzy
 msgid "Log to this syslog facility or file. (defaults to DAEMON)"
 msgstr "Ruleaz sub acest utilizator dup pornire. (implicit e %s)."
 
-#: option.c:428
+#: option.c:444
 msgid "Do not use leasefile."
 msgstr ""
 
-#: option.c:429
+#: option.c:445
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries. (defaults to %s)"
 msgstr "Specific numrul maxim de mprumuturi DHCP (implicit %s)."
 
-#: option.c:430
+#: option.c:446
 #, c-format
 msgid "Clear DNS cache when reloading %s."
 msgstr ""
 
-#: option.c:431
+#: option.c:447
 msgid "Ignore hostnames provided by DHCP clients."
 msgstr ""
 
-#: option.c:432
+#: option.c:448
 msgid "Do NOT reuse filename and server fields for extra DHCP options."
 msgstr ""
 
-#: option.c:433
+#: option.c:449
 msgid "Enable integrated read-only TFTP server."
 msgstr ""
 
-#: option.c:434
+#: option.c:450
 msgid "Export files by TFTP only from the specified subtree."
 msgstr ""
 
-#: option.c:435
+#: option.c:451
 msgid "Add client IP or hardware address to tftp-root."
 msgstr ""
 
-#: option.c:436
+#: option.c:452
 msgid "Allow access only to files owned by the user running dnsmasq."
 msgstr ""
 
-#: option.c:437
+#: option.c:453
 msgid "Do not terminate the service if TFTP directories are inaccessible."
 msgstr ""
 
-#: option.c:438
+#: option.c:454
 #, fuzzy, c-format
 msgid "Maximum number of concurrent TFTP transfers (defaults to %s)."
 msgstr "Specific numrul maxim de mprumuturi DHCP (implicit %s)."
 
-#: option.c:439
+#: option.c:455
 #, fuzzy
 msgid "Maximum MTU to use for TFTP transfers."
 msgstr "Specific numrul maxim de mprumuturi DHCP (implicit %s)."
 
-#: option.c:440
+#: option.c:456
 msgid "Disable the TFTP blocksize extension."
 msgstr ""
 
-#: option.c:441
+#: option.c:457
 msgid "Convert TFTP filenames to lowercase"
 msgstr ""
 
-#: option.c:442
+#: option.c:458
 msgid "Ephemeral port range for use by TFTP transfers."
 msgstr ""
 
-#: option.c:443
+#: option.c:459
+msgid "Use only one port for TFTP server."
+msgstr ""
+
+#: option.c:460
 msgid "Extra logging for DHCP."
 msgstr ""
 
-#: option.c:444
+#: option.c:461
 msgid "Enable async. logging; optionally set queue length."
 msgstr ""
 
-#: option.c:445
+#: option.c:462
 msgid "Stop DNS rebinding. Filter private IP ranges when resolving."
 msgstr ""
 
-#: option.c:446
+#: option.c:463
 msgid "Allow rebinding of 127.0.0.0/8, for RBL servers."
 msgstr ""
 
-#: option.c:447
+#: option.c:464
 msgid "Inhibit DNS-rebind protection on this domain."
 msgstr ""
 
-#: option.c:448
+#: option.c:465
 msgid "Always perform DNS queries to all servers."
 msgstr ""
 
-#: option.c:449
+#: option.c:466
 msgid "Set tag if client includes matching option in request."
 msgstr ""
 
-#: option.c:450
+#: option.c:467
+msgid "Set tag if client provides given name."
+msgstr ""
+
+#: option.c:468
 msgid "Use alternative ports for DHCP."
 msgstr ""
 
-#: option.c:451
+#: option.c:469
 #, fuzzy
 msgid "Specify NAPTR DNS record."
 msgstr "Specific o nregistrare TXT."
 
-#: option.c:452
+#: option.c:470
 msgid "Specify lowest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:453
+#: option.c:471
 msgid "Specify highest port available for DNS query transmission."
 msgstr ""
 
-#: option.c:454
+#: option.c:472
 msgid "Use only fully qualified domain names for DHCP clients."
 msgstr ""
 
-#: option.c:455
+#: option.c:473
 msgid "Generate hostnames based on MAC address for nameless clients."
 msgstr ""
 
-#: option.c:456
+#: option.c:474
 msgid "Use these DHCP relays as full proxies."
 msgstr ""
 
-#: option.c:457
+#: option.c:475
 msgid "Relay DHCP requests to a remote server"
 msgstr ""
 
-#: option.c:458
+#: option.c:476
 msgid "Specify alias name for LOCAL DNS name."
 msgstr ""
 
-#: option.c:459
+#: option.c:477
 #, fuzzy
 msgid "Prompt to send to PXE clients."
 msgstr "Configureaz opiuni n plusce trebuie trimise clienilor DHCP."
 
-#: option.c:460
+#: option.c:478
 msgid "Boot service for PXE menu."
 msgstr ""
 
-#: option.c:461
+#: option.c:479
 msgid "Check configuration syntax."
 msgstr ""
 
-#: option.c:462
+#: option.c:480
 msgid "Add requestor's MAC address to forwarded DNS queries."
 msgstr ""
 
-#: option.c:463
+#: option.c:481
 msgid "Add specified IP subnet to forwarded DNS queries."
 msgstr ""
 
-#: option.c:464
+#: option.c:482
 #, fuzzy
 msgid "Add client identification to forwarded DNS queries."
 msgstr "Foreaz acest port pentru datele ce pleac."
 
-#: option.c:465
+#: option.c:483
 #, fuzzy
 msgid "Proxy DNSSEC validation results from upstream nameservers."
 msgstr "Traduce adresele IPv4 de la serverele DNS superioare."
 
-#: option.c:466
+#: option.c:484
 msgid "Attempt to allocate sequential IP addresses to DHCP clients."
 msgstr ""
 
-#: option.c:467
+#: option.c:485
+#, fuzzy
+msgid "Ignore client identifier option sent by DHCP clients."
+msgstr "Configureaz opiuni n plusce trebuie trimise clienilor DHCP."
+
+#: option.c:486
 msgid "Copy connection-track mark from queries to upstream connections."
 msgstr ""
 
-#: option.c:468
+#: option.c:487
 msgid "Allow DHCP clients to do their own DDNS updates."
 msgstr ""
 
-#: option.c:469
+#: option.c:488
 msgid "Send router-advertisements for interfaces doing DHCPv6"
 msgstr ""
 
-#: option.c:470
+#: option.c:489
 msgid "Specify DUID_EN-type DHCPv6 server DUID"
 msgstr ""
 
-#: option.c:471
+#: option.c:490
 #, fuzzy
 msgid "Specify host (A/AAAA and PTR) records"
 msgstr "Specific o nregistrare MX."
 
-#: option.c:472
+#: option.c:491
+msgid "Specify certification authority authorization record"
+msgstr ""
+
+#: option.c:492
 #, fuzzy
 msgid "Specify arbitrary DNS resource record"
 msgstr "Specific o nregistrare TXT."
 
-#: option.c:473
+#: option.c:493
 #, fuzzy
 msgid "Bind to interfaces in use - check for new interfaces"
 msgstr "interfa necunoscut %s"
 
-#: option.c:474
+#: option.c:494
 msgid "Export local names to global DNS"
 msgstr ""
 
-#: option.c:475
+#: option.c:495
 msgid "Domain to export to global DNS"
 msgstr ""
 
-#: option.c:476
+#: option.c:496
 msgid "Set TTL for authoritative replies"
 msgstr ""
 
-#: option.c:477
+#: option.c:497
 msgid "Set authoritative zone information"
 msgstr ""
 
-#: option.c:478
+#: option.c:498
 msgid "Secondary authoritative nameservers for forward domains"
 msgstr ""
 
-#: option.c:479
+#: option.c:499
 msgid "Peers which are allowed to do zone transfer"
 msgstr ""
 
-#: option.c:480
+#: option.c:500
 msgid "Specify ipsets to which matching domains should be added"
 msgstr ""
 
-#: option.c:481
+#: option.c:501
 msgid "Specify a domain and address range for synthesised names"
 msgstr ""
 
-#: option.c:482
+#: option.c:502
 msgid "Activate DNSSEC validation"
 msgstr ""
 
-#: option.c:483
+#: option.c:503
 msgid "Specify trust anchor key digest."
 msgstr ""
 
-#: option.c:484
+#: option.c:504
 msgid "Disable upstream checking for DNSSEC debugging."
 msgstr ""
 
-#: option.c:485
+#: option.c:505
 msgid "Ensure answers without DNSSEC are in unsigned zones."
 msgstr ""
 
-#: option.c:486
+#: option.c:506
 msgid "Don't check DNSSEC signature timestamps until first cache-reload"
 msgstr ""
 
-#: option.c:487
+#: option.c:507
 msgid "Timestamp file to verify system clock for DNSSEC"
 msgstr ""
 
-#: option.c:489
-msgid "Specify DHCPv6 prefix class"
-msgstr ""
-
-#: option.c:491
+#: option.c:508
 msgid "Set MTU, priority, resend-interval and router-lifetime"
 msgstr ""
 
-#: option.c:492
+#: option.c:509
 msgid "Do not log routine DHCP."
 msgstr ""
 
-#: option.c:493
+#: option.c:510
 msgid "Do not log routine DHCPv6."
 msgstr ""
 
-#: option.c:494
+#: option.c:511
 msgid "Do not log RA."
 msgstr ""
 
-#: option.c:495
+#: option.c:512
 msgid "Accept queries only from directly-connected networks."
 msgstr ""
 
-#: option.c:496
+#: option.c:513
 msgid "Detect and remove DNS forwarding loops."
 msgstr ""
 
-#: option.c:497
+#: option.c:514
 msgid "Ignore DNS responses containing ipaddr."
 msgstr ""
 
-#: option.c:498
+#: option.c:515
 msgid "Set TTL in DNS responses with DHCP-derived addresses."
 msgstr ""
 
-#: option.c:499
+#: option.c:516
 msgid "Delay DHCP replies for at least number of seconds."
 msgstr ""
 
-#: option.c:703
+#: option.c:517
+msgid "Enables DHCPv4 Rapid Commit option."
+msgstr ""
+
+#: option.c:518
+msgid "Path to debug packet dump file"
+msgstr ""
+
+#: option.c:519
+msgid "Mask which packets to dump"
+msgstr ""
+
+#: option.c:520
+msgid "Call dhcp-script when lease expiry changes."
+msgstr ""
+
+#: option.c:725
 #, c-format
 msgid ""
 "Usage: dnsmasq [options]\n"
@@ -783,341 +820,356 @@
 "Utilizare: dnsmasq [opiuni]\n"
 "\n"
 
-#: option.c:705
+#: option.c:727
 #, c-format
 msgid "Use short options only on the command line.\n"
 msgstr "Folosii opiunile prescurtate doar n linie de comand.\n"
 
-#: option.c:707
+#: option.c:729
 #, fuzzy, c-format
 msgid "Valid options are:\n"
 msgstr "Opiunile valide sunt:\n"
 
-#: option.c:754 option.c:868
+#: option.c:776 option.c:884
 #, fuzzy
 msgid "bad address"
 msgstr "citesc %s - %d adrese"
 
-#: option.c:779 option.c:783
+#: option.c:799 option.c:803
 msgid "bad port"
 msgstr "port invalid"
 
-#: option.c:797 option.c:826 option.c:861
+#: option.c:815 option.c:844 option.c:878
 msgid "interface binding not supported"
 msgstr ""
 
-#: option.c:821 option.c:856
+#: option.c:839 option.c:873
 msgid "interface can only be specified once"
 msgstr ""
 
-#: option.c:835 option.c:3809
+#: option.c:852 option.c:4042
 #, fuzzy
 msgid "bad interface name"
 msgstr "nume MX invalid"
 
-#: option.c:1062
+#: option.c:1184
 msgid "unsupported encapsulation for IPv6 option"
 msgstr ""
 
-#: option.c:1076
+#: option.c:1198
 msgid "bad dhcp-option"
 msgstr "dhcp-option invalid"
 
-#: option.c:1144
+#: option.c:1270
 #, fuzzy
 msgid "bad IP address"
 msgstr "citesc %s - %d adrese"
 
-#: option.c:1147 option.c:1286 option.c:3079
+#: option.c:1273 option.c:1412 option.c:3297
 #, fuzzy
 msgid "bad IPv6 address"
 msgstr "citesc %s - %d adrese"
 
-#: option.c:1240
+#: option.c:1366
 #, fuzzy
 msgid "bad IPv4 address"
 msgstr "citesc %s - %d adrese"
 
-#: option.c:1313 option.c:1407
+#: option.c:1439 option.c:1533
 msgid "bad domain in dhcp-option"
 msgstr "domeniu DNS invalid n declaraia dhcp-option"
 
-#: option.c:1445
+#: option.c:1571
 msgid "dhcp-option too long"
 msgstr "declararea dhcp-option este prea lung"
 
-#: option.c:1452
+#: option.c:1578
 msgid "illegal dhcp-match"
 msgstr ""
 
-#: option.c:1514
+#: option.c:1647
 msgid "illegal repeated flag"
 msgstr ""
 
-#: option.c:1522
+#: option.c:1655
 msgid "illegal repeated keyword"
 msgstr ""
 
-#: option.c:1593 option.c:4443
+#: option.c:1726 option.c:4764
 #, fuzzy, c-format
 msgid "cannot access directory %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: option.c:1639 tftp.c:537
+#: option.c:1772 tftp.c:564 dump.c:68
 #, fuzzy, c-format
 msgid "cannot access %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: option.c:1727
+#: option.c:1879
 msgid "setting log facility is not possible under Android"
 msgstr ""
 
-#: option.c:1736
+#: option.c:1888
 msgid "bad log facility"
 msgstr ""
 
-#: option.c:1789
+#: option.c:1941
 msgid "bad MX preference"
 msgstr "preferin MX invalid"
 
-#: option.c:1794
+#: option.c:1946
 msgid "bad MX name"
 msgstr "nume MX invalid"
 
-#: option.c:1808
+#: option.c:1960
 msgid "bad MX target"
 msgstr "int MX invalid"
 
-#: option.c:1820
-msgid "cannot run scripts under uClinux"
-msgstr ""
-
-#: option.c:1822
+#: option.c:1980
 msgid "recompile with HAVE_SCRIPT defined to enable lease-change scripts"
 msgstr ""
 
-#: option.c:1826
+#: option.c:1984
 msgid "recompile with HAVE_LUASCRIPT defined to enable Lua scripts"
 msgstr ""
 
-#: option.c:2095 option.c:2106 option.c:2143 option.c:2199 option.c:2482
+#: option.c:2244 option.c:2255 option.c:2291 option.c:2344 option.c:2638
 #, fuzzy
 msgid "bad prefix"
 msgstr "port invalid"
 
-#: option.c:2504
+#: option.c:2658
 msgid "recompile with HAVE_IPSET defined to enable ipset directives"
 msgstr ""
 
-#: option.c:2713
+#: option.c:2871
 #, fuzzy
 msgid "bad port range"
 msgstr "port invalid"
 
-#: option.c:2739
+#: option.c:2897
 msgid "bad bridge-interface"
 msgstr ""
 
-#: option.c:2807
+#: option.c:2941
+msgid "bad shared-network"
+msgstr ""
+
+#: option.c:2996
 msgid "only one tag allowed"
 msgstr ""
 
-#: option.c:2827 option.c:2839 option.c:2948 option.c:2953 option.c:2992
+#: option.c:3017 option.c:3032 option.c:3157 option.c:3165 option.c:3205
 msgid "bad dhcp-range"
 msgstr "dhcp-range invalid"
 
-#: option.c:2854
+#: option.c:3050
 msgid "inconsistent DHCP range"
 msgstr "domeniu DHCP inconsistent"
 
-#: option.c:2916
+#: option.c:3115
 msgid "prefix length must be exactly 64 for RA subnets"
 msgstr ""
 
-#: option.c:2918
+#: option.c:3117
 msgid "prefix length must be exactly 64 for subnet constructors"
 msgstr ""
 
-#: option.c:2922
+#: option.c:3120
 msgid "prefix length must be at least 64"
 msgstr ""
 
-#: option.c:2925
+#: option.c:3123
 #, fuzzy
 msgid "inconsistent DHCPv6 range"
 msgstr "domeniu DHCP inconsistent"
 
-#: option.c:2936
+#: option.c:3142
 msgid "prefix must be zero with \"constructor:\" argument"
 msgstr ""
 
-#: option.c:3049 option.c:3097
+#: option.c:3262 option.c:3340
 #, fuzzy
 msgid "bad hex constant"
 msgstr "dhcp-host invalid"
 
-#: option.c:3071
-msgid "cannot match tags in --dhcp-host"
-msgstr ""
+#: option.c:3315
+#, fuzzy
+msgid "bad IPv6 prefix"
+msgstr "port invalid"
 
-#: option.c:3119
+#: option.c:3362
 #, fuzzy, c-format
 msgid "duplicate dhcp-host IP address %s"
 msgstr "adres IP duplicat %s n declaraia dhcp-config."
 
-#: option.c:3177
+#: option.c:3422
 #, fuzzy
 msgid "bad DHCP host name"
 msgstr "nume MX invalid"
 
-#: option.c:3259
+#: option.c:3508
 #, fuzzy
 msgid "bad tag-if"
 msgstr "int MX invalid"
 
-#: option.c:3616 option.c:4039
+#: option.c:3851 option.c:4324
 msgid "invalid port number"
 msgstr "numr de port invalid"
 
-#: option.c:3678
+#: option.c:3907
 #, fuzzy
 msgid "bad dhcp-proxy address"
 msgstr "citesc %s - %d adrese"
 
-#: option.c:3704
+#: option.c:3935
 #, fuzzy
 msgid "Bad dhcp-relay"
 msgstr "dhcp-range invalid"
 
-#: option.c:3745
+#: option.c:3979
 msgid "bad RA-params"
 msgstr ""
 
-#: option.c:3754
+#: option.c:3989
 msgid "bad DUID"
 msgstr ""
 
-#: option.c:3796
+#: option.c:4023
 #, fuzzy
+msgid "missing address in alias"
+msgstr "adresa este folosit"
+
+#: option.c:4029
+#, fuzzy
 msgid "invalid alias range"
 msgstr "pondere invalid"
 
-#: option.c:3850 option.c:3862
+#: option.c:4081 option.c:4097
 msgid "bad CNAME"
 msgstr ""
 
-#: option.c:3866
+#: option.c:4105
 msgid "duplicate CNAME"
 msgstr ""
 
-#: option.c:3889
+#: option.c:4132
 #, fuzzy
 msgid "bad PTR record"
 msgstr "nregistrare SRV invalid"
 
-#: option.c:3920
+#: option.c:4167
 #, fuzzy
 msgid "bad NAPTR record"
 msgstr "nregistrare SRV invalid"
 
-#: option.c:3954
+#: option.c:4203
 #, fuzzy
 msgid "bad RR record"
 msgstr "nregistrare SRV invalid"
 
-#: option.c:3984
+#: option.c:4236
+#, fuzzy
+msgid "bad CAA record"
+msgstr "nregistrare SRV invalid"
+
+#: option.c:4265
 msgid "bad TXT record"
 msgstr "nregistrare TXT invalid"
 
-#: option.c:4025
+#: option.c:4308
 msgid "bad SRV record"
 msgstr "nregistrare SRV invalid"
 
-#: option.c:4032
+#: option.c:4315
 msgid "bad SRV target"
 msgstr "int SRV invalid"
 
-#: option.c:4046
+#: option.c:4334
 msgid "invalid priority"
 msgstr "prioritate invalid"
 
-#: option.c:4049
+#: option.c:4339
 msgid "invalid weight"
 msgstr "pondere invalid"
 
-#: option.c:4073
+#: option.c:4362
 #, fuzzy
 msgid "Bad host-record"
 msgstr "nregistrare SRV invalid"
 
-#: option.c:4097
+#: option.c:4402
 #, fuzzy
 msgid "Bad name in host-record"
 msgstr "nume invalid n %s"
 
-#: option.c:4162
+#: option.c:4444
+msgid "bad value for dnssec-check-unsigned"
+msgstr ""
+
+#: option.c:4480
 #, fuzzy
 msgid "bad trust anchor"
 msgstr "port invalid"
 
-#: option.c:4176
+#: option.c:4496
 msgid "bad HEX in trust anchor"
 msgstr ""
 
-#: option.c:4186
+#: option.c:4507
 msgid "unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"
 msgstr ""
 
-#: option.c:4246
+#: option.c:4567
 msgid "missing \""
 msgstr "lipsete \""
 
-#: option.c:4303
+#: option.c:4624
 msgid "bad option"
 msgstr "opiune invalid"
 
-#: option.c:4305
+#: option.c:4626
 msgid "extraneous parameter"
 msgstr "parametru nerecunoscut"
 
-#: option.c:4307
+#: option.c:4628
 msgid "missing parameter"
 msgstr "parametru lipsa"
 
-#: option.c:4309
+#: option.c:4630
 #, fuzzy
 msgid "illegal option"
 msgstr "opiune invalid"
 
-#: option.c:4316
+#: option.c:4637
 msgid "error"
 msgstr "eroare"
 
-#: option.c:4318
+#: option.c:4639
 #, fuzzy, c-format
 msgid " at line %d of %s"
 msgstr "%s la linia %d din %%s"
 
-#: option.c:4333 option.c:4580 option.c:4616
+#: option.c:4654 option.c:4939 option.c:4950
 #, fuzzy, c-format
 msgid "read %s"
 msgstr "citesc %s"
 
-#: option.c:4396 option.c:4519 tftp.c:715
+#: option.c:4717 option.c:4840 tftp.c:754
 #, c-format
 msgid "cannot read %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: option.c:4688
+#: option.c:5027
 msgid "junk found in command line"
 msgstr ""
 
-#: option.c:4729
+#: option.c:5067
 #, c-format
 msgid "Dnsmasq version %s  %s\n"
 msgstr "dnsmasq versiunea %s  %s\n"
 
-#: option.c:4730
+#: option.c:5068
 #, fuzzy, c-format
 msgid ""
 "Compile time options: %s\n"
@@ -1126,510 +1178,562 @@
 "Opiuni cu care a fost compilat %s\n"
 "\n"
 
-#: option.c:4731
+#: option.c:5069
 #, c-format
 msgid "This software comes with ABSOLUTELY NO WARRANTY.\n"
 msgstr "Acest program vine FR NICI O GARANIE.\n"
 
-#: option.c:4732
+#: option.c:5070
 #, c-format
 msgid "Dnsmasq is free software, and you are welcome to redistribute it\n"
 msgstr "Dnsmasq este un program gratuit, suntei invitai s-l redistribuii\n"
 
-#: option.c:4733
+#: option.c:5071
 #, fuzzy, c-format
 msgid "under the terms of the GNU General Public License, version 2 or 3.\n"
 msgstr "n termenii Licenei publice generale GNU, versiunea 2.\n"
 
-#: option.c:4744
+#: option.c:5088
 msgid "try --help"
 msgstr ""
 
-#: option.c:4746
+#: option.c:5090
 msgid "try -w"
 msgstr ""
 
-#: option.c:4748
+#: option.c:5092
 #, fuzzy, c-format
 msgid "bad command line options: %s"
 msgstr "opiuni n linie de comand invalide: %s."
 
-#: option.c:4818
+#: option.c:5161
 #, c-format
 msgid "CNAME loop involving %s"
 msgstr ""
 
-#: option.c:4854
+#: option.c:5195
 #, c-format
 msgid "cannot get host-name: %s"
 msgstr "nu pot citi numele mainii: %s"
 
-#: option.c:4882
+#: option.c:5223
 msgid "only one resolv.conf file allowed in no-poll mode."
 msgstr "se permite un singur fiier resolv.conf n modul no-poll"
 
-#: option.c:4892
+#: option.c:5233
 msgid "must have exactly one resolv.conf to read domain from."
 msgstr "am nevoie de un singur resolv.conf din care s citesc numele domeniului."
 
-#: option.c:4895 network.c:1623 dhcp.c:816
+#: option.c:5236 network.c:1594 dhcp.c:876
 #, fuzzy, c-format
 msgid "failed to read %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: option.c:4912
+#: option.c:5253
 #, c-format
 msgid "no search directive found in %s"
 msgstr "nu s-a gsit nici un criteriu de cutare n %s"
 
-#: option.c:4933
+#: option.c:5274
 msgid "there must be a default domain when --dhcp-fqdn is set"
 msgstr ""
 
-#: option.c:4942
+#: option.c:5283
 msgid "syntax check OK"
 msgstr ""
 
-#: forward.c:102
+#: forward.c:99
 #, fuzzy, c-format
 msgid "failed to send packet: %s"
 msgstr "ascultarea pe socket a euat: %s"
 
-#: forward.c:598
+#: forward.c:614
 msgid "discarding DNS reply: subnet option mismatch"
 msgstr ""
 
-#: forward.c:652
+#: forward.c:677
 #, c-format
 msgid "nameserver %s refused to do a recursive query"
 msgstr "serverul DNS %s refuz interogrile recursive"
 
-#: forward.c:684
+#: forward.c:709
 #, c-format
 msgid "possible DNS-rebind attack detected: %s"
 msgstr ""
 
-#: forward.c:870
+#: forward.c:961
 #, c-format
 msgid "reducing DNS packet size for nameserver %s to %d"
 msgstr ""
 
-#: forward.c:1266 forward.c:1704
+#: forward.c:1370 forward.c:1830
 msgid "Ignoring query from non-local network"
 msgstr ""
 
-#: forward.c:2184
+#: forward.c:2321
 #, fuzzy, c-format
 msgid "Maximum number of concurrent DNS queries reached (max: %d)"
 msgstr "Specific numrul maxim de mprumuturi DHCP (implicit %s)."
 
-#: network.c:720
+#: network.c:698
 #, fuzzy, c-format
 msgid "failed to create listening socket for %s: %s"
 msgstr "creearea socket-ului de ascultare a euat: %s"
 
-#: network.c:1031
+#: network.c:1002
 #, c-format
 msgid "LOUD WARNING: listening on %s may accept requests via interfaces other than %s"
 msgstr ""
 
-#: network.c:1038
+#: network.c:1009
 msgid "LOUD WARNING: use --bind-dynamic rather than --bind-interfaces to avoid DNS amplification attacks via these interface(s)"
 msgstr ""
 
-#: network.c:1047
+#: network.c:1018
 #, fuzzy, c-format
 msgid "warning: using interface %s instead"
 msgstr "atenie: interfaa %s nu exist momentan"
 
-#: network.c:1056
+#: network.c:1027
 #, fuzzy, c-format
 msgid "warning: no addresses found for interface %s"
 msgstr "folosim adresele locale doar pentru %S %s"
 
-#: network.c:1114
+#: network.c:1085
 #, fuzzy, c-format
 msgid "interface %s failed to join DHCPv6 multicast group: %s"
 msgstr "activarea socket-ului server-ului DHCP a euat: %s"
 
-#: network.c:1119
+#: network.c:1090
 msgid "try increasing /proc/sys/net/core/optmem_max"
 msgstr ""
 
-#: network.c:1337
+#: network.c:1307
 #, fuzzy, c-format
 msgid "failed to bind server socket for %s: %s"
 msgstr "activarea socket-ului de ascultare pentru %s a euat: %s"
 
-#: network.c:1528
+#: network.c:1499
 #, c-format
 msgid "ignoring nameserver %s - local interface"
 msgstr "ignorm serverul DNS %s - interfa local"
 
-#: network.c:1539
+#: network.c:1510
 #, fuzzy, c-format
 msgid "ignoring nameserver %s - cannot make/bind socket: %s"
 msgstr "ignorm serverul DNS %s - nu pot creea/activa socket-ul: %s"
 
-#: network.c:1559
+#: network.c:1530
 msgid "(no DNSSEC)"
 msgstr ""
 
-#: network.c:1562
+#: network.c:1533
 msgid "unqualified"
 msgstr "invalid"
 
-#: network.c:1562
+#: network.c:1533
 msgid "names"
 msgstr ""
 
-#: network.c:1564
+#: network.c:1535
 msgid "default"
 msgstr ""
 
-#: network.c:1566
+#: network.c:1537
 msgid "domain"
 msgstr "domeniu"
 
-#: network.c:1572
-#, c-format
-msgid "using local addresses only for %s %s"
+#: network.c:1543
+#, fuzzy, c-format
+msgid "using only locally-known addresses for %s %s"
 msgstr "folosim adresele locale doar pentru %S %s"
 
-#: network.c:1575
+#: network.c:1546
 #, fuzzy, c-format
 msgid "using standard nameservers for %s %s"
 msgstr "folosim serverul DNS %s#%d pentru %s %s"
 
-#: network.c:1577
+#: network.c:1548
 #, fuzzy, c-format
 msgid "using nameserver %s#%d for %s %s %s"
 msgstr "folosim serverul DNS %s#%d pentru %s %s"
 
-#: network.c:1581
+#: network.c:1552
 #, fuzzy, c-format
 msgid "NOT using nameserver %s#%d - query loop detected"
 msgstr "folosim serverul DNS %s#%d pentru %s %s"
 
-#: network.c:1584
+#: network.c:1555
 #, fuzzy, c-format
 msgid "using nameserver %s#%d(via %s)"
 msgstr "folosim serverul DNS %s#%d"
 
-#: network.c:1586
+#: network.c:1557
 #, c-format
 msgid "using nameserver %s#%d"
 msgstr "folosim serverul DNS %s#%d"
 
-#: network.c:1591
+#: network.c:1562
 #, fuzzy, c-format
 msgid "using %d more local addresses"
 msgstr "folosim serverul DNS %s#%d"
 
-#: network.c:1593
+#: network.c:1564
 #, fuzzy, c-format
 msgid "using %d more nameservers"
 msgstr "folosim serverul DNS %s#%d"
 
-#: dnsmasq.c:171
+#: dnsmasq.c:173
 msgid "dhcp-hostsdir, dhcp-optsdir and hostsdir are not supported on this platform"
 msgstr ""
 
-#: dnsmasq.c:186
+#: dnsmasq.c:188
 msgid "no root trust anchor provided for DNSSEC"
 msgstr ""
 
-#: dnsmasq.c:189
+#: dnsmasq.c:191
 msgid "cannot reduce cache size from default when DNSSEC enabled"
 msgstr ""
 
-#: dnsmasq.c:191
+#: dnsmasq.c:193
 #, fuzzy
 msgid "DNSSEC not available: set HAVE_DNSSEC in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:197
+#: dnsmasq.c:199
 #, fuzzy
 msgid "TFTP server not available: set HAVE_TFTP in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:202
+#: dnsmasq.c:204
 msgid "cannot use --conntrack AND --query-port"
 msgstr ""
 
-#: dnsmasq.c:205
+#: dnsmasq.c:207
 #, fuzzy
 msgid "conntrack support not available: set HAVE_CONNTRACK in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:210
+#: dnsmasq.c:212
 msgid "asynchronous logging is not available under Solaris"
 msgstr ""
 
-#: dnsmasq.c:215
+#: dnsmasq.c:217
 msgid "asynchronous logging is not available under Android"
 msgstr ""
 
-#: dnsmasq.c:220
+#: dnsmasq.c:222
 #, fuzzy
 msgid "authoritative DNS not available: set HAVE_AUTH in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:225
+#: dnsmasq.c:227
 #, fuzzy
 msgid "loop detection not available: set HAVE_LOOP in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:229
+#: dnsmasq.c:232
+#, fuzzy
+msgid "Ubus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
+
+#: dnsmasq.c:236
 msgid "max_port cannot be smaller than min_port"
 msgstr ""
 
-#: dnsmasq.c:236
+#: dnsmasq.c:243
+msgid "--auth-server required when an auth zone is defined."
+msgstr ""
+
+#: dnsmasq.c:248
 msgid "zone serial must be configured in --auth-soa"
 msgstr ""
 
-#: dnsmasq.c:254
+#: dnsmasq.c:268
 msgid "dhcp-range constructor not available on this platform"
 msgstr ""
 
-#: dnsmasq.c:300
+#: dnsmasq.c:332
 msgid "cannot set --bind-interfaces and --bind-dynamic"
 msgstr ""
 
-#: dnsmasq.c:303
+#: dnsmasq.c:335
 #, c-format
 msgid "failed to find list of interfaces: %s"
 msgstr "enumerarea interfeelor a euat: %s"
 
-#: dnsmasq.c:312
+#: dnsmasq.c:344
 #, c-format
 msgid "unknown interface %s"
 msgstr "interfa necunoscut %s"
 
-#: dnsmasq.c:377 dnsmasq.c:1054
+#: dnsmasq.c:406
+#, fuzzy
+msgid "Packet dumps not available: set HAVE_DUMP in src/config.h"
+msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
+
+#: dnsmasq.c:416 dnsmasq.c:1171
 #, c-format
 msgid "DBus error: %s"
 msgstr "eroare DBus: %s"
 
-#: dnsmasq.c:380
+#: dnsmasq.c:419
 msgid "DBus not available: set HAVE_DBUS in src/config.h"
 msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
 
-#: dnsmasq.c:410
+#: dnsmasq.c:429
+#, fuzzy
+msgid "UBus not available: set HAVE_UBUS in src/config.h"
+msgstr "DBus nu este disponibil: punei HAVE_DBUS in src/config.h"
+
+#: dnsmasq.c:459
 #, c-format
 msgid "unknown user or group: %s"
 msgstr ""
 
-#: dnsmasq.c:465
+#: dnsmasq.c:535
 #, c-format
+msgid "process is missing required capability %s"
+msgstr ""
+
+#: dnsmasq.c:567
+#, c-format
 msgid "cannot chdir to filesystem root: %s"
 msgstr ""
 
-#: dnsmasq.c:730
+#: dnsmasq.c:815
 #, fuzzy, c-format
 msgid "started, version %s DNS disabled"
 msgstr "am pornit, versiunea %s memorie temporar dezactivat"
 
-#: dnsmasq.c:734
+#: dnsmasq.c:820
 #, c-format
 msgid "started, version %s cachesize %d"
 msgstr "am ponit, versiunea %s memorie temporar %d"
 
-#: dnsmasq.c:736
+#: dnsmasq.c:822
+msgid "cache size greater than 10000 may cause performance issues, and is unlikely to be useful."
+msgstr ""
+
+#: dnsmasq.c:825
 #, c-format
 msgid "started, version %s cache disabled"
 msgstr "am pornit, versiunea %s memorie temporar dezactivat"
 
-#: dnsmasq.c:739
+#: dnsmasq.c:828
 msgid "DNS service limited to local subnets"
 msgstr ""
 
-#: dnsmasq.c:742
+#: dnsmasq.c:831
 #, c-format
 msgid "compile time options: %s"
 msgstr "compilat cu opiunile: %s"
 
-#: dnsmasq.c:751
+#: dnsmasq.c:840
 msgid "DBus support enabled: connected to system bus"
 msgstr "suportul DBus activ: sunt conectat la magistrala sistem"
 
-#: dnsmasq.c:753
+#: dnsmasq.c:842
 msgid "DBus support enabled: bus connection pending"
 msgstr "suportul DBus activ: atept conexiunea la magistral"
 
-#: dnsmasq.c:771
+#: dnsmasq.c:850
+#, fuzzy
+msgid "UBus support enabled: connected to system bus"
+msgstr "suportul DBus activ: sunt conectat la magistrala sistem"
+
+#: dnsmasq.c:852
+#, fuzzy
+msgid "UBus support enabled: bus connection pending"
+msgstr "suportul DBus activ: atept conexiunea la magistral"
+
+#: dnsmasq.c:872
+msgid "DNSSEC validation enabled but all unsigned answers are trusted"
+msgstr ""
+
+#: dnsmasq.c:874
 msgid "DNSSEC validation enabled"
 msgstr ""
 
-#: dnsmasq.c:775
+#: dnsmasq.c:878
 msgid "DNSSEC signature timestamps not checked until receipt of SIGINT"
 msgstr ""
 
-#: dnsmasq.c:778
+#: dnsmasq.c:881
 msgid "DNSSEC signature timestamps not checked until system time valid"
 msgstr ""
 
+#: dnsmasq.c:884
+#, c-format
+msgid "configured with trust anchor for %s keytag %u"
+msgstr ""
+
 # for compatibility purposes the letters , , ,  and  can be written as their look-alike correspondent.
-#: dnsmasq.c:783
+#: dnsmasq.c:890
 #, fuzzy, c-format
 msgid "warning: failed to change owner of %s: %s"
 msgstr "ncrcarea numelor din %s: %s a euat"
 
-#: dnsmasq.c:787
+#: dnsmasq.c:894
 msgid "setting --bind-interfaces option because of OS limitations"
 msgstr "specific opiunea --bind-interfaces din cauza limitrilor SO"
 
-#: dnsmasq.c:799
+#: dnsmasq.c:906
 #, c-format
 msgid "warning: interface %s does not currently exist"
 msgstr "atenie: interfaa %s nu exist momentan"
 
-#: dnsmasq.c:804
+#: dnsmasq.c:911
 msgid "warning: ignoring resolv-file flag because no-resolv is set"
 msgstr ""
 
-#: dnsmasq.c:807
+#: dnsmasq.c:914
 #, fuzzy
 msgid "warning: no upstream servers configured"
 msgstr "configurm serverele superioare prin Dbus"
 
-#: dnsmasq.c:811
+#: dnsmasq.c:918
 #, c-format
 msgid "asynchronous logging enabled, queue limit is %d messages"
 msgstr ""
 
-#: dnsmasq.c:832
+#: dnsmasq.c:939
 msgid "IPv6 router advertisement enabled"
 msgstr ""
 
-#: dnsmasq.c:837
+#: dnsmasq.c:944
 #, c-format
 msgid "DHCP, sockets bound exclusively to interface %s"
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 msgid "root is "
 msgstr ""
 
-#: dnsmasq.c:851
+#: dnsmasq.c:958
 #, fuzzy
 msgid "enabled"
 msgstr "dezactivat"
 
-#: dnsmasq.c:853
+#: dnsmasq.c:960
 msgid "secure mode"
 msgstr ""
 
-#: dnsmasq.c:856
+#: dnsmasq.c:961
+#, fuzzy
+msgid "single port mode"
+msgstr "numr de port invalid"
+
+#: dnsmasq.c:964
 #, c-format
 msgid "warning: %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:860
+#: dnsmasq.c:968
 #, c-format
 msgid "warning: TFTP directory %s inaccessible"
 msgstr ""
 
-#: dnsmasq.c:886
+#: dnsmasq.c:994
 #, c-format
 msgid "restricting maximum simultaneous TFTP transfers to %d"
 msgstr ""
 
-#: dnsmasq.c:1056
+#: dnsmasq.c:1173
 msgid "connected to system DBus"
 msgstr "magistrala sistem Dbus conectat"
 
-#: dnsmasq.c:1215
+#: dnsmasq.c:1345
 #, c-format
 msgid "cannot fork into background: %s"
 msgstr ""
 
-#: dnsmasq.c:1218
+#: dnsmasq.c:1349
 #, fuzzy, c-format
 msgid "failed to create helper: %s"
 msgstr "nu pot citi %s: %s"
 
-#: dnsmasq.c:1221
+#: dnsmasq.c:1353
 #, c-format
 msgid "setting capabilities failed: %s"
 msgstr ""
 
 # for compatibility purposes the letters , , ,  and  can be written as their look-alike correspondent.
-#: dnsmasq.c:1224
+#: dnsmasq.c:1357
 #, fuzzy, c-format
 msgid "failed to change user-id to %s: %s"
 msgstr "ncrcarea numelor din %s: %s a euat"
 
 # for compatibility purposes the letters , , ,  and  can be written as their look-alike correspondent.
-#: dnsmasq.c:1227
+#: dnsmasq.c:1361
 #, fuzzy, c-format
 msgid "failed to change group-id to %s: %s"
 msgstr "ncrcarea numelor din %s: %s a euat"
 
-#: dnsmasq.c:1230
+#: dnsmasq.c:1365
 #, fuzzy, c-format
 msgid "failed to open pidfile %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: dnsmasq.c:1233
+#: dnsmasq.c:1369
 #, fuzzy, c-format
 msgid "cannot open log %s: %s"
 msgstr "nu pot deschide %s:%s"
 
-#: dnsmasq.c:1236
+#: dnsmasq.c:1373
 #, fuzzy, c-format
 msgid "failed to load Lua script: %s"
 msgstr "nu pot ncrca %s: %s"
 
-#: dnsmasq.c:1239
+#: dnsmasq.c:1377
 #, c-format
 msgid "TFTP directory %s inaccessible: %s"
 msgstr ""
 
-#: dnsmasq.c:1242
+#: dnsmasq.c:1381
 #, fuzzy, c-format
 msgid "cannot create timestamp file %s: %s"
 msgstr "nu pot creea sau deschide fiierul cu mprumuturi: %s"
 
-#: dnsmasq.c:1326
+#: dnsmasq.c:1465
 #, c-format
 msgid "script process killed by signal %d"
 msgstr ""
 
-#: dnsmasq.c:1330
+#: dnsmasq.c:1469
 #, c-format
 msgid "script process exited with status %d"
 msgstr ""
 
-#: dnsmasq.c:1334
+#: dnsmasq.c:1473
 #, fuzzy, c-format
 msgid "failed to execute %s: %s"
 msgstr "accesarea serverului %s a euat: %s"
 
-#: dnsmasq.c:1374
+#: dnsmasq.c:1513
 msgid "now checking DNSSEC signature timestamps"
 msgstr ""
 
-#: dnsmasq.c:1409 dnssec.c:160 dnssec.c:206
+#: dnsmasq.c:1548 dnssec.c:160 dnssec.c:204
 #, fuzzy, c-format
 msgid "failed to update mtime on %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: dnsmasq.c:1416
+#: dnsmasq.c:1560
 msgid "exiting on receipt of SIGTERM"
 msgstr "am primit SIGTERM, am terminat"
 
-#: dnsmasq.c:1444
+#: dnsmasq.c:1588
 #, fuzzy, c-format
 msgid "failed to access %s: %s"
 msgstr "accesarea serverului %s a euat: %s"
 
-#: dnsmasq.c:1474
+#: dnsmasq.c:1618
 #, c-format
 msgid "reading %s"
 msgstr "citesc %s"
 
-#: dnsmasq.c:1485
+#: dnsmasq.c:1629
 #, fuzzy, c-format
 msgid "no servers found in %s, will retry"
 msgstr "nu s-a gsit nici un criteriu de cutare n %s"
@@ -1659,7 +1763,7 @@
 msgid "cannot create ICMP raw socket: %s."
 msgstr "nu pot creea socket ICMP raw: %s."
 
-#: dhcp.c:252 dhcp6.c:173
+#: dhcp.c:252 dhcp6.c:180
 #, fuzzy, c-format
 msgid "unknown interface %s in bridge-interface"
 msgstr "interfa necunoscut %s"
@@ -1669,331 +1773,337 @@
 msgid "DHCP packet received on %s which has no address"
 msgstr ""
 
-#: dhcp.c:427
+#: dhcp.c:428
 #, c-format
 msgid "ARP-cache injection failed: %s"
 msgstr ""
 
-#: dhcp.c:470
+#: dhcp.c:471
 #, c-format
 msgid "Error sending DHCP packet to %s: %s"
 msgstr ""
 
-#: dhcp.c:531
+#: dhcp.c:526
 #, c-format
 msgid "DHCP range %s -- %s is not consistent with netmask %s"
 msgstr "domeniu DHCP %s -- %s nu este consistent cu masca de reea %s"
 
-#: dhcp.c:854
+#: dhcp.c:914
 #, c-format
 msgid "bad line at %s line %d"
 msgstr "linie invalid n %s rndul %d"
 
-#: dhcp.c:897
+#: dhcp.c:957
 #, c-format
 msgid "ignoring %s line %d, duplicate name or IP address"
 msgstr ""
 
-#: dhcp.c:1041 rfc3315.c:2149
+#: dhcp.c:1100 rfc3315.c:2139
 #, c-format
 msgid "DHCP relay %s -> %s"
 msgstr ""
 
-#: lease.c:98
+#: lease.c:64
+#, c-format
+msgid "ignoring invalid line in lease database: %s %s %s %s ..."
+msgstr ""
+
+#: lease.c:101
+#, c-format
+msgid "ignoring invalid line in lease database, bad address: %s"
+msgstr ""
+
+#: lease.c:108
 msgid "too many stored leases"
 msgstr "prea multe mprumuturi stocate"
 
-#: lease.c:166
+#: lease.c:176
 #, fuzzy, c-format
 msgid "cannot open or create lease file %s: %s"
 msgstr "nu pot creea sau deschide fiierul cu mprumuturi: %s"
 
-#: lease.c:175
-#, c-format
-msgid "failed to parse lease database, invalid line: %s %s %s %s ..."
-msgstr ""
+#: lease.c:185
+#, fuzzy
+msgid "failed to parse lease database cleanly"
+msgstr "nu pot citi %s: %s"
 
-#: lease.c:180
+#: lease.c:188
 #, fuzzy, c-format
 msgid "failed to read lease file %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: lease.c:196
+#: lease.c:204
 #, fuzzy, c-format
 msgid "cannot run lease-init script %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: lease.c:202
+#: lease.c:210
 #, c-format
 msgid "lease-init script returned exit code %s"
 msgstr ""
 
-#: lease.c:373
+#: lease.c:381
 #, fuzzy, c-format
 msgid "failed to write %s: %s (retry in %us)"
 msgstr "nu pot citi %s: %s"
 
-#: lease.c:937
+#: lease.c:955
 #, c-format
 msgid "Ignoring domain %s for DHCP host name %s"
 msgstr ""
 
-#: rfc2131.c:347
+#: rfc2131.c:372
 #, c-format
 msgid "no address range available for DHCP request %s %s"
 msgstr "nici un domeniu de adrese disponibil pentru cererea DHCP %s %s"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "with subnet selector"
 msgstr "cu selectorul de subreea"
 
-#: rfc2131.c:348
+#: rfc2131.c:373
 msgid "via"
 msgstr "prin"
 
-#: rfc2131.c:360
+#: rfc2131.c:385
 #, fuzzy, c-format
 msgid "%u available DHCP subnet: %s/%s"
 msgstr "nici un domeniu de adrese disponibil pentru cererea DHCP %s %s"
 
-#: rfc2131.c:363 rfc3315.c:306
+#: rfc2131.c:388 rfc3315.c:319
 #, c-format
 msgid "%u available DHCP range: %s -- %s"
 msgstr ""
 
-#: rfc2131.c:474
+#: rfc2131.c:499
 #, fuzzy, c-format
 msgid "%u vendor class: %s"
 msgstr "eroare DBus: %s"
 
-#: rfc2131.c:476
+#: rfc2131.c:501
 #, fuzzy, c-format
 msgid "%u user class: %s"
 msgstr "eroare DBus: %s"
 
-#: rfc2131.c:510
+#: rfc2131.c:535
 msgid "disabled"
 msgstr "dezactivat"
 
-#: rfc2131.c:551 rfc2131.c:1006 rfc2131.c:1430 rfc3315.c:616 rfc3315.c:869
-#: rfc3315.c:1148
+#: rfc2131.c:576 rfc2131.c:1065 rfc2131.c:1509 rfc3315.c:632 rfc3315.c:815
+#: rfc3315.c:1097
 msgid "ignored"
 msgstr "ignorat"
 
-#: rfc2131.c:566 rfc2131.c:1239 rfc3315.c:919
+#: rfc2131.c:591 rfc2131.c:1310 rfc3315.c:867
 msgid "address in use"
 msgstr "adresa este folosit"
 
-#: rfc2131.c:580 rfc2131.c:1060
+#: rfc2131.c:605 rfc2131.c:1119
 msgid "no address available"
 msgstr "nici o adres disponibil"
 
-#: rfc2131.c:587 rfc2131.c:1202
+#: rfc2131.c:612 rfc2131.c:1273
 msgid "wrong network"
 msgstr "reea greit"
 
-#: rfc2131.c:602
+#: rfc2131.c:627
 msgid "no address configured"
 msgstr "adres lips"
 
-#: rfc2131.c:608 rfc2131.c:1252
+#: rfc2131.c:633 rfc2131.c:1323
 msgid "no leases left"
 msgstr "nu mai am de unde s mprumut"
 
-#: rfc2131.c:703 rfc3315.c:482
+#: rfc2131.c:734 rfc3315.c:499
 #, c-format
 msgid "%u client provides name: %s"
 msgstr ""
 
-#: rfc2131.c:808
+#: rfc2131.c:864
 msgid "PXE BIS not supported"
 msgstr ""
 
-#: rfc2131.c:974 rfc3315.c:1242
+#: rfc2131.c:1032 rfc3315.c:1197
 #, fuzzy, c-format
 msgid "disabling DHCP static address %s for %s"
 msgstr "dezactivm adresele DHCP statice %s"
 
-#: rfc2131.c:995
+#: rfc2131.c:1053
 msgid "unknown lease"
 msgstr "mprumut necunoscut"
 
-#: rfc2131.c:1029
+#: rfc2131.c:1088
 #, c-format
 msgid "not using configured address %s because it is leased to %s"
 msgstr ""
 
-#: rfc2131.c:1039
+#: rfc2131.c:1098
 #, c-format
 msgid "not using configured address %s because it is in use by the server or relay"
 msgstr ""
 
-#: rfc2131.c:1042
+#: rfc2131.c:1101
 #, c-format
 msgid "not using configured address %s because it was previously declined"
 msgstr ""
 
-#: rfc2131.c:1058 rfc2131.c:1245
+#: rfc2131.c:1117 rfc2131.c:1316
 msgid "no unique-id"
 msgstr ""
 
-#: rfc2131.c:1140
+#: rfc2131.c:1209
 msgid "wrong server-ID"
 msgstr ""
 
-#: rfc2131.c:1159
+#: rfc2131.c:1228
 msgid "wrong address"
 msgstr "adres greit"
 
-#: rfc2131.c:1177 rfc3315.c:1015
+#: rfc2131.c:1246 rfc3315.c:961
 msgid "lease not found"
 msgstr "mprumutul nu a fost gsit"
 
-#: rfc2131.c:1210
+#: rfc2131.c:1281
 msgid "address not available"
 msgstr "adres indisponibil"
 
-#: rfc2131.c:1221
+#: rfc2131.c:1292
 msgid "static lease available"
 msgstr "mprumut static este disponibil"
 
-#: rfc2131.c:1225
+#: rfc2131.c:1296
 msgid "address reserved"
 msgstr "adres rezervat"
 
-#: rfc2131.c:1233
+#: rfc2131.c:1304
 #, c-format
 msgid "abandoning lease to %s of %s"
 msgstr ""
 
-#: rfc2131.c:1757
+#: rfc2131.c:1845
 #, c-format
 msgid "%u bootfile name: %s"
 msgstr ""
 
-#: rfc2131.c:1766
+#: rfc2131.c:1854
 #, fuzzy, c-format
 msgid "%u server name: %s"
 msgstr "eroare DBus: %s"
 
-#: rfc2131.c:1774
+#: rfc2131.c:1862
 #, fuzzy, c-format
 msgid "%u next server: %s"
 msgstr "eroare DBus: %s"
 
-#: rfc2131.c:1777
+#: rfc2131.c:1865
 #, c-format
 msgid "%u broadcast response"
 msgstr ""
 
-#: rfc2131.c:1840
+#: rfc2131.c:1928
 #, fuzzy, c-format
 msgid "cannot send DHCP/BOOTP option %d: no space left in packet"
 msgstr "nu pot trimite opiunea DHCP %d: nu mai este loc n pachet"
 
-#: rfc2131.c:2131
+#: rfc2131.c:2219
 msgid "PXE menu too large"
 msgstr ""
 
-#: rfc2131.c:2270 rfc3315.c:1515
+#: rfc2131.c:2358 rfc3315.c:1470
 #, fuzzy, c-format
 msgid "%u requested options: %s"
 msgstr "compilat cu opiunile: %s"
 
-#: rfc2131.c:2587
+#: rfc2131.c:2675
 #, c-format
 msgid "cannot send RFC3925 option: too many options for enterprise number %d"
 msgstr ""
 
-#: rfc2131.c:2650
+#: rfc2131.c:2738
 #, c-format
 msgid "%u reply delay: %d"
 msgstr ""
 
-#: netlink.c:77
+#: netlink.c:76
 #, fuzzy, c-format
 msgid "cannot create netlink socket: %s"
 msgstr "nu pot s activez socket-ul netlink: %s"
 
-#: netlink.c:355
+#: netlink.c:352
 #, fuzzy, c-format
 msgid "netlink returns error: %s"
 msgstr "eroare DBus: %s"
 
-#: dbus.c:186
-msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
-msgstr "incerc s configurez un server IPv6 prin Dbus - nu este suport IPv6"
-
-#: dbus.c:439
+#: dbus.c:438
 #, c-format
 msgid "Enabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:444
+#: dbus.c:443
 #, c-format
 msgid "Disabling --%s option from D-Bus"
 msgstr ""
 
-#: dbus.c:690
+#: dbus.c:717
 msgid "setting upstream servers from DBus"
 msgstr "configurm serverele superioare prin Dbus"
 
-#: dbus.c:737
+#: dbus.c:764
 msgid "could not register a DBus message handler"
 msgstr "nu pot activa o interfa de mesaje DBus"
 
-#: bpf.c:265
+#: bpf.c:261
 #, c-format
 msgid "cannot create DHCP BPF socket: %s"
 msgstr "nu pot creea socket DHCP BPF: %s"
 
-#: bpf.c:293
+#: bpf.c:289
 #, fuzzy, c-format
 msgid "DHCP request for unsupported hardware type (%d) received on %s"
 msgstr "cerere DHCP pentru dispozitiv nesuportat (%d) recepionat prin %s"
 
-#: bpf.c:378
+#: bpf.c:374
 #, fuzzy, c-format
 msgid "cannot create PF_ROUTE socket: %s"
 msgstr "nu pot creea socket DHCP: %s"
 
-#: bpf.c:399
+#: bpf.c:395
 msgid "Unknown protocol version from route socket"
 msgstr ""
 
-#: helper.c:154
+#: helper.c:150
 msgid "lease() function missing in Lua script"
 msgstr ""
 
-#: tftp.c:319
+#: tftp.c:347
 msgid "unable to get free port for TFTP"
 msgstr ""
 
-#: tftp.c:335
+#: tftp.c:363
 #, c-format
 msgid "unsupported request from %s"
 msgstr ""
 
-#: tftp.c:483
+#: tftp.c:510
 #, fuzzy, c-format
 msgid "file %s not found"
 msgstr "mprumutul nu a fost gsit"
 
-#: tftp.c:592
-#, c-format
-msgid "error %d %s received from %s"
-msgstr ""
-
-#: tftp.c:634
+#: tftp.c:628
 #, fuzzy, c-format
 msgid "failed sending %s to %s"
 msgstr "nu pot citi %s: %s"
 
-#: tftp.c:634
+#: tftp.c:628
 #, c-format
 msgid "sent %s to %s"
 msgstr ""
 
+#: tftp.c:678
+#, c-format
+msgid "error %d %s received from %s"
+msgstr ""
+
 #: log.c:190
 #, c-format
 msgid "overflow: %d log entries lost"
@@ -2008,7 +2118,7 @@
 msgid "FAILED to start up"
 msgstr "pornirea A EUAT"
 
-#: conntrack.c:65
+#: conntrack.c:63
 #, c-format
 msgid "Conntrack connection mark retrieval failed: %s"
 msgstr ""
@@ -2028,81 +2138,76 @@
 msgid "failed to bind DHCPv6 server socket: %s"
 msgstr "activarea socket-ului server-ului DHCP a euat: %s"
 
-#: rfc3315.c:157
+#: rfc3315.c:173
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request from relay at %s"
 msgstr "nici un domeniu de adrese disponibil pentru cererea DHCP %s %s"
 
-#: rfc3315.c:166
+#: rfc3315.c:182
 #, fuzzy, c-format
 msgid "no address range available for DHCPv6 request via %s"
 msgstr "nici un domeniu de adrese disponibil pentru cererea DHCP %s %s"
 
-#: rfc3315.c:303
+#: rfc3315.c:316
 #, fuzzy, c-format
 msgid "%u available DHCPv6 subnet: %s/%d"
 msgstr "nici un domeniu de adrese disponibil pentru cererea DHCP %s %s"
 
-#: rfc3315.c:386
+#: rfc3315.c:399
 #, fuzzy, c-format
 msgid "%u vendor class: %u"
 msgstr "eroare DBus: %s"
 
-#: rfc3315.c:434
+#: rfc3315.c:447
 #, fuzzy, c-format
 msgid "%u client MAC address: %s"
 msgstr "nu exista interfa pentru adresa %s"
 
-#: rfc3315.c:673
-#, fuzzy, c-format
-msgid "unknown prefix-class %d"
-msgstr "mprumut necunoscut"
-
-#: rfc3315.c:816 rfc3315.c:911
+#: rfc3315.c:762 rfc3315.c:859
 #, fuzzy
 msgid "address unavailable"
 msgstr "adres indisponibil"
 
-#: rfc3315.c:828 rfc3315.c:959 rfc3315.c:1292
+#: rfc3315.c:774 rfc3315.c:903 rfc3315.c:1247
 msgid "success"
 msgstr ""
 
-#: rfc3315.c:843 rfc3315.c:852 rfc3315.c:967 rfc3315.c:969
+#: rfc3315.c:789 rfc3315.c:798 rfc3315.c:911 rfc3315.c:913
 #, fuzzy
 msgid "no addresses available"
 msgstr "nici o adres disponibil"
 
-#: rfc3315.c:946
+#: rfc3315.c:890
 msgid "not on link"
 msgstr ""
 
-#: rfc3315.c:1019 rfc3315.c:1204 rfc3315.c:1281
+#: rfc3315.c:965 rfc3315.c:1156 rfc3315.c:1236
 msgid "no binding found"
 msgstr ""
 
-#: rfc3315.c:1057
+#: rfc3315.c:1002
 msgid "deprecated"
 msgstr ""
 
-#: rfc3315.c:1062
+#: rfc3315.c:1007
 #, fuzzy
 msgid "address invalid"
 msgstr "adresa este folosit"
 
-#: rfc3315.c:1109
+#: rfc3315.c:1057 rfc3315.c:1059
 msgid "confirm failed"
 msgstr ""
 
-#: rfc3315.c:1125
+#: rfc3315.c:1074
 #, fuzzy
 msgid "all addresses still on link"
 msgstr "adres greit n %s, linia %d"
 
-#: rfc3315.c:1213
+#: rfc3315.c:1165
 msgid "release received"
 msgstr ""
 
-#: rfc3315.c:2140
+#: rfc3315.c:2130
 msgid "Cannot multicast to DHCPv6 server without correct interface"
 msgstr ""
 
@@ -2116,76 +2221,76 @@
 msgid "%u tags: %s"
 msgstr ""
 
-#: dhcp-common.c:407
+#: dhcp-common.c:444
 #, c-format
 msgid "%s has more than one address in hostsfile, using %s for DHCP"
 msgstr ""
 
-#: dhcp-common.c:430
+#: dhcp-common.c:478
 #, c-format
 msgid "duplicate IP address %s (%s) in dhcp-config directive"
 msgstr "adres IP duplicat %s (%s) n declaraia dhcp-config."
 
-#: dhcp-common.c:491
+#: dhcp-common.c:542
 #, fuzzy, c-format
 msgid "failed to set SO_BINDTODEVICE on DHCP socket: %s"
 msgstr "configurarea SO_REUSEADDR pe socket-ul DHCP a euat: %s"
 
-#: dhcp-common.c:612
+#: dhcp-common.c:665
 #, c-format
 msgid "Known DHCP options:\n"
 msgstr ""
 
-#: dhcp-common.c:623
+#: dhcp-common.c:676
 #, c-format
 msgid "Known DHCPv6 options:\n"
 msgstr ""
 
-#: dhcp-common.c:820
+#: dhcp-common.c:873
 msgid ", prefix deprecated"
 msgstr ""
 
-#: dhcp-common.c:823
+#: dhcp-common.c:876
 #, c-format
 msgid ", lease time "
 msgstr ""
 
-#: dhcp-common.c:865
+#: dhcp-common.c:918
 #, c-format
 msgid "%s stateless on %s%.0s%.0s%s"
 msgstr ""
 
-#: dhcp-common.c:867
+#: dhcp-common.c:920
 #, fuzzy, c-format
 msgid "%s, static leases only on %.0s%s%s%.0s"
 msgstr "DHCP, mprumuturi statice doar ctre  %.0s%s, timpul renoirii %s"
 
-#: dhcp-common.c:869
+#: dhcp-common.c:922
 #, c-format
 msgid "%s, proxy on subnet %.0s%s%.0s%.0s"
 msgstr ""
 
-#: dhcp-common.c:870
+#: dhcp-common.c:923
 #, fuzzy, c-format
 msgid "%s, IP range %s -- %s%s%.0s"
 msgstr "DHCP, domeniu IP %s -- %s, timpul renoirii %s"
 
-#: dhcp-common.c:883
+#: dhcp-common.c:936
 #, c-format
 msgid "DHCPv4-derived IPv6 names on %s%s"
 msgstr ""
 
-#: dhcp-common.c:886
+#: dhcp-common.c:939
 #, fuzzy, c-format
 msgid "router advertisement on %s%s"
 msgstr "DHCP, mprumuturi statice doar ctre  %.0s%s, timpul renoirii %s"
 
-#: dhcp-common.c:897
+#: dhcp-common.c:950
 #, c-format
 msgid "DHCP relay from %s to %s via %s"
 msgstr ""
 
-#: dhcp-common.c:899
+#: dhcp-common.c:952
 #, c-format
 msgid "DHCP relay from %s to %s"
 msgstr ""
@@ -2195,7 +2300,7 @@
 msgid "cannot create ICMPv6 socket: %s"
 msgstr "nu pot creea socket DHCP: %s"
 
-#: auth.c:449
+#: auth.c:439
 #, c-format
 msgid "ignoring zone transfer request from %s"
 msgstr ""
@@ -2210,20 +2315,25 @@
 msgid "failed to create IPset control socket: %s"
 msgstr "creearea socket-ului de ascultare a euat: %s"
 
-#: ipset.c:233
+#: ipset.c:226
 #, fuzzy, c-format
 msgid "failed to update ipset %s: %s"
 msgstr "nu pot citi %s: %s"
 
-#: dnssec.c:208
+#: dnssec.c:206
 msgid "system time considered valid, now checking DNSSEC signature timestamps."
 msgstr ""
 
-#: blockdata.c:58
+#: dnssec.c:902
 #, c-format
-msgid "DNSSEC memory in use %u, max %u, allocated %u"
+msgid "Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"
 msgstr ""
 
+#: blockdata.c:55
+#, c-format
+msgid "pool memory in use %u, max %u, allocated %u"
+msgstr ""
+
 #: tables.c:61
 #, fuzzy, c-format
 msgid "failed to access pf devices: %s"
@@ -2253,12 +2363,12 @@
 msgid "info: table created"
 msgstr ""
 
-#: tables.c:134
+#: tables.c:133
 #, c-format
 msgid "warning: DIOCR%sADDRS: %s"
 msgstr ""
 
-#: tables.c:138
+#: tables.c:137
 #, fuzzy, c-format
 msgid "%d addresses %s"
 msgstr "citesc %s - %d adrese"
@@ -2298,7 +2408,75 @@
 msgid "inotify, new or changed file %s"
 msgstr ""
 
+#: dump.c:64
+#, fuzzy, c-format
+msgid "cannot create %s: %s"
+msgstr "nu pot citi %s: %s"
+
+#: dump.c:70
+#, fuzzy, c-format
+msgid "bad header in %s"
+msgstr "adresa este folosit"
+
+#: dump.c:201
 #, fuzzy
+msgid "failed to write packet dump"
+msgstr "ascultarea pe socket a euat: %s"
+
+#: dump.c:203
+#, c-format
+msgid "dumping UDP packet %u mask 0x%04x"
+msgstr ""
+
+#: ubus.c:52
+#, c-format
+msgid "UBus subscription callback: %s subscriber(s)"
+msgstr ""
+
+#: ubus.c:73
+#, fuzzy, c-format
+msgid "Cannot reconnect to UBus: %s"
+msgstr "nu pot deschide %s:%s"
+
+#: ubus.c:89
+msgid "Cannot initialize UBus: connection failed"
+msgstr ""
+
+#: ubus.c:102
+#, fuzzy, c-format
+msgid "Cannot add object to UBus: %s"
+msgstr "nu pot deschide %s:%s"
+
+#: ubus.c:112
+#, fuzzy
+msgid "Connected to system UBus"
+msgstr "magistrala sistem Dbus conectat"
+
+#: ubus.c:122
+msgid "Cannot set UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:142
+msgid "Cannot poll UBus listeners: no connection"
+msgstr ""
+
+#: ubus.c:155
+msgid "Disconnecting from UBus"
+msgstr ""
+
+#: ubus.c:199
+#, fuzzy, c-format
+msgid "Failed to send UBus event: %s"
+msgstr "ascultarea pe socket a euat: %s"
+
+#~ msgid "attempt to set an IPv6 server address via DBus - no IPv6 support"
+#~ msgstr "incerc s configurez un server IPv6 prin Dbus - nu este suport IPv6"
+
+#, fuzzy
+#~ msgid "unknown prefix-class %d"
+#~ msgstr "mprumut necunoscut"
+
+#, fuzzy
 #~ msgid "cannot cannonicalise resolv-file %s: %s"
 #~ msgstr "nu pot creea sau deschide fiierul cu mprumuturi: %s"
 
Index: CHANGELOG
===================================================================
--- CHANGELOG	(revision 41436)
+++ CHANGELOG	(working copy)
@@ -1,3 +1,94 @@
+version 2.81
+	Impove cache behaviour for TCP connections. For ease of
+	implementaion, dnsmasq has always forked a new process to handle
+	each incoming TCP connection. A side-effect of this is that
+	any DNS queries answered from TCP connections are not cached:
+	when TCP connections were rare, this was not a problem.
+	With the coming of DNSSEC, it's now the case that some
+	DNSSEC queries have answers which spill to TCP, and if,
+	for instance, this applies to the keys for the root then
+	those never get cached, and performance is very bad.
+	This fix passes cache entries back from the TCP child process to
+	the main server process, and fixes the problem.
+
+	Remove the NO_FORK compile-time option, and support for uclinux.
+	In an era where everything has an MMU, this looks like
+	an anachronism, and it adds to (Ok, multiplies!) the
+	combinatorial explosion of compile-time options. Thanks to
+	Kevin Darbyshire-Bryant for the patch.
+
+	Fix line-counting when reading /etc/hosts and friends; for
+	correct error messages. Thanks to Christian Rosentreter
+	for reporting this.
+
+	Fix bug in DNS non-terminal code, added in 2.80, which could
+	sometimes cause a NODATA rather than an NXDOMAIN reply.
+	Thanks to Norman Rasmussen, Sven Mueller and Maciej enczykowski
+	for spotting and diagnosing the bug and providing patches.
+
+	Support TCP-fastopen (RFC-7413) on both incoming and
+	outgoing TCP connections, if supported and enabled in the OS.
+
+	Improve kernel-capability manipulation code under Linux. Dnsmasq
+	now fails early if a required capability is not available, and
+	tries not to request capabilities not required by its
+	configuration.
+
+	Add --shared-network config. This enables allocation of addresses
+	the DHCP server in subnets where the server (or relay) doesn't
+	have an interface on the network in that subnet. Many thanks to
+	kamp.de for sponsoring this feature.
+	
+	Fix broken contrib/lease_tools/dhcp_lease_time.c. A packet
+	validation check got borked in commit 2b38e382 and release 2.80.
+	Thanks to Tomasz Szajner for spotting this.
+
+	Fix compilation against nettle version 3.5 and later.
+
+	Fix spurious DNSSEC validation failures when the auth section
+	of a reply contains unsigned RRs from a signed zone, 
+	with the exception that NSEC and NSEC3 RRs must always be signed.
+        Thanks to Tore Anderson for spotting and diagnosing the bug.
+
+	Add --dhcp-ignore-clid. This disables reading of DHCP client
+	identifier option (option 61), so clients are only identified by
+	MAC addresses.
+
+	Fix a bug which stopped --dhcp-name-match from working when a hostname
+	is supplied in --dhcp-host. Thanks to James Feeney for spotting this.
+
+	Fix bug which caused very rarely caused zero-length DHCPv6 packets.
+	Thanks to Dereck Higgins for spotting this.
+
+	Add --tftp-single-port option.
+
+	Enhance --conf-dir to load files in a deterministic order. Thanks to
+	Evgenii Seliavka for the suggestion and initial patch.
+
+	In the router advert code, handle case where we have two
+	different interfaces on the same IPv6 net, and we're doing
+	RA/DHCP service on only one of them. Thanks to NIIBE Yutaka
+	for spotting this case and making the initial patch.
+
+	Support prefixed ranges of ipv6 addresses in dhcp-host.
+	This eases problems chain-netbooting, where each link in the
+	chain requests an address using a different UID. With a single
+	address, only one gets the "static" address, but with this
+	fix, enough addresses can be reserved for all the stages of the
+	boot. Many thanks to Harald Jenss for his work on this idea and
+	earlier patches.
+
+	Add filtering by tag of --dhcp-host directives. Based on a patch
+	by Harald Jenss.
+
+	Allow empty server spec in --rev-server, to match --server.
+	
+	Remove DSA signature verification from DNSSEC, as specified in
+	RFC 8624. Thanks to Loganaden Velvindron for the original patch.
+
+	Add --script-on-renewal option.
+
+	
 version 2.80
 	Add support for RFC 4039 DHCP rapid commit. Thanks to Ashram Method
 	for the initial patch and motivation.
Index: man/dnsmasq.8
===================================================================
--- man/dnsmasq.8	(revision 41436)
+++ man/dnsmasq.8	(working copy)
@@ -484,7 +484,7 @@
 part of the source address. Forcing queries to an interface is not
 implemented on all platforms supported by dnsmasq.
 .TP
-.B --rev-server=<ip-address>/<prefix-len>,<ipaddr>[#<port>][@<source-ip>|<interface>[#<port>]]
+.B --rev-server=<ip-address>/<prefix-len>[,<ipaddr>][#<port>][@<source-ip>|<interface>[#<port>]]
 This is functionally the same as 
 .B --server, 
 but provides some syntactic sugar to make specifying address-to-name queries easier. For example
@@ -515,7 +515,7 @@
 \fB--address=/example.com/#\fP will return NULL addresses for example.com and
 its subdomains. This is partly syntactic sugar for \fB--address=/example.com/0.0.0.0\fP
 and \fB--address=/example.com/::\fP but is also more efficient than including both
-as seperate configuration lines. Note that NULL addresses normally work in the same way as localhost, so beware that clients looking up these names are likely to end up talking to themselves.
+as separate configuration lines. Note that NULL addresses normally work in the same way as localhost, so beware that clients looking up these names are likely to end up talking to themselves.
 .TP
 .B --ipset=/<domain>[/<domain>...]/<ipset>[,<ipset>...]
 Places the resolved IP addresses of queries for one or more domains in
@@ -603,12 +603,9 @@
 .TP
 .B --cname=<cname>,[<cname>,]<target>[,<TTL>]
 Return a CNAME record which indicates that <cname> is really
-<target>. There are significant limitations on the target; it must be a
-DNS name which is known to dnsmasq from /etc/hosts (or additional
-hosts files), from DHCP, from \fB--interface-name\fP or from another
-.B --cname.
-If the target does not satisfy this
-criteria, the whole cname is ignored. The cname must be unique, but it
+<target>. There is a significant limitation on the target; it must be a
+DNS record which is known to dnsmasq and NOT a DNS record which comes from
+an upstream server. The cname must be unique, but it
 is permissible to have more than one cname pointing to the same target. Indeed
 it's possible to declare multiple cnames to a target in a single line, like so:
 .B --cname=cname1,cname2,target
@@ -677,7 +674,7 @@
 MAC, as base64, is enabled by adding the "base64" parameter and a human-readable encoding of hex-and-colons is enabled by added the "text" parameter.
 .TP
 .B --add-cpe-id=<string>
-Add an arbitrary identifying string to o DNS queries which are
+Add an arbitrary identifying string to DNS queries which are
 forwarded upstream.
 .TP 
 .B --add-subnet[[=[<IPv4 address>/]<IPv4 prefix length>][,[<IPv6 address>/]<IPv6 prefix length>]]
@@ -751,7 +748,7 @@
 
 Versions of dnsmasq prior to 2.80 defaulted to not checking unsigned replies, and used 
 .B --dnssec-check-unsigned
-to switch this on. Such configurations will continue to work as before, but those which used the default of no checking will need to be altered to explicitly select no checking. The new default is because switching off checking for unsigned replies is inherently dangerous. Not only does it open the possiblity of forged replies, but it allows everything to appear to be working even when the upstream namesevers do not support DNSSEC, and in this case no DNSSEC validation at all is occuring.
+to switch this on. Such configurations will continue to work as before, but those which used the default of no checking will need to be altered to explicitly select no checking. The new default is because switching off checking for unsigned replies is inherently dangerous. Not only does it open the possiblity of forged replies, but it allows everything to appear to be working even when the upstream namesevers do not support DNSSEC, and in this case no DNSSEC validation at all is occurring.
 .TP
 .B --dnssec-no-timecheck
 DNSSEC signatures are only valid for specified time windows, and should be rejected outside those windows. This generates an
@@ -774,9 +771,12 @@
 unprivileged user that dnsmasq runs as.
 .TP
 .B --proxy-dnssec
-Copy the DNSSEC Authenticated Data bit from upstream servers to downstream clients and cache it.  This is an 
+Copy the DNSSEC Authenticated Data bit from upstream servers to downstream clients.  This is an 
 alternative to having dnsmasq validate DNSSEC, but it depends on the security of the network between 
-dnsmasq and the upstream servers, and the trustworthiness of the upstream servers.
+dnsmasq and the upstream servers, and the trustworthiness of the upstream servers. Note that caching the
+Authenticated Data bit correctly in all cases is not technically possible. If the AD bit is to be relied upon
+when using this option, then the cache should be disabled using --cache-size=0. In most cases, enabling DNSSEC validation
+within dnsmasq is a better option. See --dnssec for details.
 .TP
 .B --dnssec-debug
 Set debugging mode for the DNSSEC validation, set the Checking Disabled bit on upstream queries, 
@@ -975,7 +975,7 @@
 tells dnsmasq to advertise the prefix without the on-link (aka L) bit set.
 
 .TP
-.B \-G, --dhcp-host=[<hwaddr>][,id:<client_id>|*][,set:<tag>][,<ipaddr>][,<hostname>][,<lease_time>][,ignore]
+.B \-G, --dhcp-host=[<hwaddr>][,id:<client_id>|*][,set:<tag>][tag:<tag>][,<ipaddr>][,<hostname>][,<lease_time>][,ignore]
 Specify per host parameters for the DHCP server. This allows a machine
 with a particular hardware address to be always allocated the same
 hostname, IP address and lease time. A hostname specified like this
@@ -1008,12 +1008,19 @@
 
 A single
 .B --dhcp-host
-may contain an IPv4 address or an IPv6 address, or both. IPv6 addresses must be bracketed by square brackets thus:
+may contain an IPv4 address or one or more IPv6 addresses, or both. IPv6 addresses must be bracketed by square brackets thus:
 .B --dhcp-host=laptop,[1234::56]
 IPv6 addresses may contain only the host-identifier part:
 .B --dhcp-host=laptop,[::56]
 in which case they act as wildcards in constructed dhcp ranges, with
-the appropriate network part inserted. 
+the appropriate network part inserted. For IPv6, an address may include a prefix length:
+.B --dhcp-host=laptop,[1234:50/126]
+which (in this case) specifies four addresses, 1234::50 to 1234::53. This (an the ability
+to specify multiple addresses) is useful
+when a host presents either a consistent name or hardware-ID, but varying DUIDs, since it allows
+dnsmasq to honour the static address allocation but assign a different adddress for each DUID. This
+typically occurs when chain netbooting, as each stage of the chain gets in turn allocates an address.
+
 Note that in IPv6 DHCP, the hardware address may not be
 available, though it normally is for direct-connected clients, or
 clients using DHCP relays which support RFC 6939.
@@ -1053,6 +1060,9 @@
 .B --dhcp-ignore=tag:!known
 If the host matches only a \fB--dhcp-host\fP directive which cannot
 be used because it specifies an address on different subnet, the tag "known-othernet" is set.
+
+The tag:<tag> construct filters which dhcp-host directives are used. Tagged directives are used in preference to untagged ones.
+
 Ethernet addresses (but not client-ids) may have
 wildcard bytes, so for example 
 .B --dhcp-host=00:20:e0:3b:13:*,ignore 
@@ -1405,6 +1415,12 @@
 sequential mode, clients which allow a lease to expire are much more
 likely to move IP address; for this reason it should not be generally used.
 .TP
+.B --dhcp-ignore-clid
+Dnsmasq is reading 'client identifier' (RFC 2131) option sent by clients
+(if available) to identify clients. This allow to serve same IP address
+for a host using several interfaces. Use this option to disable 'client identifier'
+reading, i.e. to always identify a host using the MAC address.
+.TP
 .B --pxe-service=[tag:<tag>,]<CSA>,<menu text>[,<basename>|<bootservicetype>][,<server address>|<server_name>]
 Most uses of PXE boot-ROMS simply allow the PXE
 system to obtain an IP address and then download the file specified by
@@ -1538,7 +1554,8 @@
 if known. "add" means a lease has been created, "del" means it has
 been destroyed, "old" is a notification of an existing lease when
 dnsmasq starts or a change to MAC address or hostname of an existing
-lease (also, lease length or expiry and client-id, if \fB--leasefile-ro\fP is set).
+lease (also, lease length or expiry and client-id, if \fB--leasefile-ro\fP is set
+and lease expiry if \fB--script-on-renewal\fP is set).
 If the MAC address is from a network type other than ethernet,
 it will have the network type prepended, eg "06-01:23:45:67:89:ab" for
 token ring. The process is run as root (assuming that dnsmasq was originally run as
@@ -1728,6 +1745,10 @@
 option also forces the leasechange script to be called on changes
 to the client-id and lease length and expiry time.
 .TP
+.B --script-on-renewal
+Call the dhcp script when the lease expiry time changes, for instance when the
+lease is renewed.
+.TP
 .B --bridge-interface=<interface>,<alias>[,<alias>]
 Treat DHCP (v4 and v6) requests and IPv6 Router Solicit packets
 arriving at any of the <alias> interfaces as if they had arrived at
@@ -1741,6 +1762,27 @@
 \fB--bridge-interface=int1,alias1,alias2\fP is exactly equivalent to
 \fB--bridge-interface=int1,alias1 --bridge-interface=int1,alias2\fP
 .TP
+.B --shared-network=<interface>|<addr>,<addr>
+The DHCP server determines which dhcp ranges are useable for allocating and
+address to a DHCP client based on the network from which the DHCP request arrives,
+and the IP configuration of the server's interface on that network. The shared-network
+option extends the available subnets (and therefore dhcp ranges) beyond the
+subnets configured on the arrival interface. The first argument is either the
+name of an interface or an address which is configured on a local interface, and the
+second argument is an address which defines another subnet on which addresses can be allocated.
+To be useful, there must be suitable dhcp-range which allows address allocation on this subnet
+and this dhcp-range MUST include the netmask. Use shared-network also needs extra
+consideration of routing. Dnsmasq doesn't have the usual information which it uses to
+determine the default route, so the default route option (or other routing) MUST be
+manually configured. The client must have a route to the server: if the two-address form
+of shared-network is used, this will be to the first specified address. If the interface,address
+form is used, there must be a route to all of the addresses configured on the interface.
+
+The two-address form of shared-network is also usable with a DHCP relay: the first address
+is the address of the relay and the second, as before, specifies an extra subnet which
+may be allocated.
+
+.TP
 .B \-s, --domain=<domain>[,<address range>[,local]]
 Specifies DNS domains for the DHCP server. Domains may be be given 
 unconditionally (without the IP range) or for limited IP ranges. This has two effects;
@@ -1829,7 +1871,7 @@
 .B --ra-param=eth0,60.
 The lifetime of the route may be changed or set to zero, which allows
 a router to advertise prefixes but not a route via itself. 
-.B --ra-parm=eth0,0,0
+.B --ra-param=eth0,0,0
 (A value of zero for the interval means the default value.) All four parameters may be set at once.
 .B --ra-param=eth0,mtu:1280,low,60,1200
 
@@ -1919,10 +1961,16 @@
 useful when TFTP has to traverse a firewall. The start of the range
 cannot be lower than 1025 unless dnsmasq is running as root. The number
 of concurrent TFTP connections is limited by the size of the port range. 
-.TP  
+.TP
+.B --tftp-single-port
+Run in a mode where the TFTP server uses ONLY the well-known port (69) for its end
+of the TFTP transfer. This allows TFTP to work when there in NAT is the path between client and server. Note that
+this is not strictly compliant with the RFCs specifying the TFTP protocol: use at your own risk.
+.TP
 .B \-C, --conf-file=<file>
-Specify a different configuration file. The \fB--conf-file\fP option is also allowed in
-configuration files, to include multiple configuration files. A
+Specify a configuration file. The presence of this option stops dnsmasq from reading the default configuration
+file (normally /etc/dnsmasq.conf). Multiple files may be specified by repeating the option
+either on the command line or in configuration files. A
 filename of "-" causes dnsmasq to read configuration from stdin.
 .TP
 .B \-7, --conf-dir=<directory>[,<file-extension>......],
@@ -1934,7 +1982,7 @@
 .B --conf-dir=/path/to/dir,*.conf
 loads all files with the suffix .conf in /path/to/dir. This flag may be given on the command
 line or in a configuration file. If giving it on the command line, be sure to
-escape * characters.
+escape * characters. Files are loaded in alphabetical order of filename.
 .TP
 .B --servers-file=<file>
 A special case of 
Index: man/fr/dnsmasq.8
===================================================================
--- man/fr/dnsmasq.8	(revision 41436)
+++ man/fr/dnsmasq.8	(working copy)
@@ -1354,6 +1354,13 @@
 leur bail ont beaucoup plus de chance de voir leur adresse IP changer, aussi
 cette option ne devrait pas tre utilise dans un cas gnral.
 .TP
+.B --dhcp-ignore-clid
+Dnsmasq lit l'option 'client identifier' (RFC 2131) envoye par les clients
+(si disponible) afin d'identifier les clients. Cela permet de distribuer la
+mme adresse IP  un client utilisant plusieurs interfaces. Activer cette option
+dsactive la lecture du 'client identifier', afin de toujours identifier un client
+en utilisant l'adresse MAC.
+.TP
 .B --pxe-service=[tag:<label>,]<CSA>,<entre de menu>[,<nom de fichier>|<type de service de dmarrage>][,<adresse de serveur>|<nom de serveur>]
 La plupart des ROMS de dmarrage PXE ne permettent au systme PXE que la simple
 obtention d'une adresse IP, le tlchargement du fichier spcifi dans
@@ -1774,7 +1781,7 @@
 .B --ra-param=eth0,60.
 La dure de vie de la route peut tre change ou mise  zro, auquel cas
 le routeur peut annoncer les prfixes mais pas de route :
-.B --ra-parm=eth0,0,0
+.B --ra-param=eth0,0,0
 (une valeur de zro pour l'intervalle signifie qu'il garde la valeur par dfaut).
 Ces quatre paramtres peuvent tre configurs en une fois :
 .B --ra-param=eth0,mtu:1280,low,60,1200
Index: Makefile
===================================================================
--- Makefile	(revision 41436)
+++ Makefile	(working copy)
@@ -53,7 +53,7 @@
 
 dbus_cflags =   `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DBUS $(PKG_CONFIG) --cflags dbus-1` 
 dbus_libs =     `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DBUS $(PKG_CONFIG) --libs dbus-1` 
-ubus_libs =     `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_UBUS $(PKG_CONFIG) --copy -lubox -lubus`
+ubus_libs =     `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_UBUS "" --copy -lubox -lubus`
 idn_cflags =    `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_IDN $(PKG_CONFIG) --cflags libidn` 
 idn_libs =      `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_IDN $(PKG_CONFIG) --libs libidn` 
 idn2_cflags =   `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_LIBIDN2 $(PKG_CONFIG) --cflags libidn2`
@@ -111,7 +111,7 @@
  top="$(top)" \
  i18n=-DLOCALEDIR=\'\"$(LOCALEDIR)\"\' \
  build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs)"  \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs)"  \
  -f $(top)/Makefile dnsmasq
 	for f in `cd $(PO); echo *.po`; do \
 		cd $(top) && cd $(BUILDDIR) && $(MAKE) top="$(top)" -f $(top)/Makefile $${f%.po}.mo; \
Index: bld/pkg-wrapper
===================================================================
--- bld/pkg-wrapper	(revision 41436)
+++ bld/pkg-wrapper	(working copy)
@@ -11,23 +11,25 @@
 
 if grep "^\#[[:space:]]*define[[:space:]]*$search" config.h >/dev/null 2>&1 || \
     echo $in | grep $search >/dev/null 2>&1; then
-# Nasty, nasty, in --copy, arg 2 is another config to search for, use with NO_GMP
+# Nasty, nasty, in --copy, arg 2 (if non-empty) is another config to search for, used with NO_GMP
     if [ $op = "--copy" ]; then
-	if grep "^\#[[:space:]]*define[[:space:]]*$pkg" config.h >/dev/null 2>&1 || \
-            echo $in | grep $pkg >/dev/null 2>&1; then
+	if [ -z "$pkg" ]; then
+	    pkg="$*"
+	elif grep "^\#[[:space:]]*define[[:space:]]*$pkg" config.h >/dev/null 2>&1 || \
+		 echo $in | grep $pkg >/dev/null 2>&1; then
 	    pkg=""
 	else 
 	    pkg="$*"
 	fi
     elif grep "^\#[[:space:]]*define[[:space:]]*${search}_STATIC" config.h >/dev/null 2>&1 || \
-	      echo $in | grep ${search}_STATIC >/dev/null 2>&1; then
+	     echo $in | grep ${search}_STATIC >/dev/null 2>&1; then
 	pkg=`$pkg  --static $op $*`
     else
 	pkg=`$pkg $op $*`
     fi
-
+    
     if grep "^\#[[:space:]]*define[[:space:]]*${search}_STATIC" config.h >/dev/null 2>&1 || \
-	echo $in | grep ${search}_STATIC >/dev/null 2>&1; then
+	   echo $in | grep ${search}_STATIC >/dev/null 2>&1; then
 	if [ $op = "--libs" ] || [ $op = "--copy" ]; then
 	    echo "-Wl,-Bstatic $pkg -Wl,-Bdynamic"
 	else
Index: contrib/lease-tools/dhcp_lease_time.c
===================================================================
--- contrib/lease-tools/dhcp_lease_time.c	(revision 41436)
+++ contrib/lease-tools/dhcp_lease_time.c	(working copy)
@@ -83,7 +83,7 @@
           if (p >= end - 2)
             return NULL; /* malformed packet */
           opt_len = option_len(p);
-          if (end - p >= (2 + opt_len))
+          if (end - p < (2 + opt_len))
             return NULL; /* malformed packet */
           if (*p == opt && opt_len >= minsize)
             return p;
Index: contrib/lease-tools/dhcp_release.c
===================================================================
--- contrib/lease-tools/dhcp_release.c	(revision 41436)
+++ contrib/lease-tools/dhcp_release.c	(working copy)
@@ -178,7 +178,7 @@
   return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);
 }
 
-static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index)
+static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index, int ifrfd, struct ifreq *ifr)
 {
   struct sockaddr_nl addr;
   struct nlmsghdr *h;
@@ -218,7 +218,17 @@
 
       for (h = (struct nlmsghdr *)iov.iov_base; NLMSG_OK(h, (size_t)len); h = NLMSG_NEXT(h, len))
 	if (h->nlmsg_type == NLMSG_DONE)
-	  exit(0);
+          {
+	    /* No match found, return first address as src/dhcp.c code does */
+	    ifr->ifr_addr.sa_family = AF_INET;
+	    if (ioctl(ifrfd, SIOCGIFADDR, ifr) != -1)
+	      return ((struct sockaddr_in *)&ifr->ifr_addr)->sin_addr;
+	    else
+	      {
+		fprintf(stderr, "error: local IPv4 address not found\n");
+		exit(1);
+	      }
+          }
 	else if (h->nlmsg_type == RTM_NEWADDR)
           {
             struct ifaddrmsg *ifa = NLMSG_DATA(h);  
@@ -285,7 +295,7 @@
     }
   
   lease.s_addr = inet_addr(argv[2]);
-  server = find_interface(lease, nl, if_nametoindex(argv[1]));
+  server = find_interface(lease, nl, if_nametoindex(argv[1]), fd, &ifr);
   
   memset(&packet, 0, sizeof(packet));
  
Index: contrib/reverse-dns/README
===================================================================
--- contrib/reverse-dns/README	(revision 41436)
+++ contrib/reverse-dns/README	(working copy)
@@ -14,5 +14,5 @@
 
 in the dnsmasq configuration.
 
-The script runs on debian (with ash installed) and on busybox.
+The script runs on debian (with dash installed) and on busybox.
 
Index: contrib/reverse-dns/reverse_replace.sh
===================================================================
--- contrib/reverse-dns/reverse_replace.sh	(revision 41436)
+++ contrib/reverse-dns/reverse_replace.sh	(working copy)
@@ -1,4 +1,4 @@
-#!/bin/ash
+#!/bin/dash
 # $Id: reverse_replace.sh 18 2015-03-01 16:12:35Z jo $
 #
 # Usage e.g.: netstat -n -4 | reverse_replace.sh 
Index: contrib/systemd/dnsmasq.service
===================================================================
--- contrib/systemd/dnsmasq.service	(revision 41436)
+++ contrib/systemd/dnsmasq.service	(working copy)
@@ -1,5 +1,8 @@
 [Unit]
 Description=dnsmasq - A lightweight DHCP and caching DNS server
+After=network.target
+Before=network-online.target nss-lookup.target
+Wants=nss-lookup.target
 
 [Service]
 Type=dbus
Index: trust-anchors.conf
===================================================================
--- trust-anchors.conf	(revision 41436)
+++ trust-anchors.conf	(working copy)
@@ -1,9 +1,8 @@
-# The root DNSSEC trust anchor, valid as at 10/02/2017
+# The root DNSSEC trust anchor, valid as at 11/01/2019
 
 # Note that this is a DS record (ie a hash of the root Zone Signing Key) 
 # If was downloaded from https://data.iana.org/root-anchors/root-anchors.xml
 
-trust-anchor=.,19036,8,2,49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5
 trust-anchor=.,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
 
 
Index: debian/changelog
===================================================================
--- debian/changelog	(nonexistent)
+++ debian/changelog	(revision 42741)
@@ -0,0 +1,1370 @@
+dnsmasq (2.81-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix nodocs/nodoc confusion in rules. (closes: #922758)
+   * Add Vcs-* fields to control. (closes: #922422)
+   * Add systemd support for multiple daemon instances. (closes: #914305)
+   * Add note explaining that ENABLED is SYSV-init only. (closes: #914755)
+   * Replace ash with dash in contrib/reverse-dns. (closes: #920224)
+   * Move to libidn2. (closes: #932695)
+   * Fix RA problem with two interfaces on same net, but RA service on
+     only one of the interfaces. (closes: #949565)
+   * Fix breakage of dig +trace. (closes: #942363)
+   * Fix build faliure with newer Nettle libraries. (closes: #940985)
+   * Support runscript init-system (closes: #929884)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 27 Jan 2020 22:31:15 +0000
+
+dnsmasq (2.80-1) unstable; urgency=low
+
+   * New upstream. (closes: #837602) (closes: #794640) (closes: #794636)
+   * Close old bugs, long agp fixed. (closes: #802845) (closes: #754299)
+   * Provide usr/lib/tmpfiles.d/dnsmasq.conf. (closes: #872396)
+   * Run restorecon on /run/dnsmasq for SE Linux. (closes: #872397)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 17 Sep 2018 23:11:25 +0000
+
+dnsmasq (2.79-1) unstable; urgency=low
+
+   * New upstream. (closes: #888200)
+   * Fix trust-anchor regex in init script. (closes: #884347)
+   * Fix exit code for dhcp_release6 (closes: #883596)
+   * Add project homepage to control file. (closes: #887764)
+   * New binary package dnsmasq-base-lua, includes Lua support.
+   * Remove hardwired shlibs dependency for libnettle 3.3 and
+     fix code to avoid ABI breakage as long as compiled against
+     libnettle 3.4 or later. (closes: #891315)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 16 Feb 2018 19:54:22 +0000
+
+dnsmasq (2.78-3) unstable; urgency=high
+
+   * Make failure of pidfile chown a warning. (closes: #889857)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 8 Feb 2018 21:26:30 +0000
+
+dnsmasq (2.78-2) unstable; urgency=high
+
+   * Change ownership of pid file, to keep systemd happy. (closes: #889336)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 6 Feb 2018 17:21:30 +0000
+
+dnsmasq (2.78-1) unstable; urgency=high
+
+   * New upstream.
+     Security fixes for CVE-2017-13704  (closes: #877102)
+     Security fixes for CVE-2017-14491 - CVE-2017-14496 inclusive.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 29 Sep 2017 21:34:00 +0000
+
+dnsmasq (2.77-2) unstable; urgency=low
+
+   * Improve sed regexp for parsing root.ds.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 5 Jun 2017 20:46:32 +0000
+
+dnsmasq (2.77-1) unstable; urgency=low
+
+   * New upstream.
+   * Don't register as a resolvconf source when config file
+     includes port=0 to disable DNS.
+   * Handle gratuitous format change in /usr/share/dns/root.ds
+     (closes: #858506) (closes: #860064)
+   * Add lsb-base dependency.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 11 Apr 2017 14:19:20 +0000
+
+dnsmasq (2.76-5) unstable; urgency=medium
+
+  * Nail libnettle dependency to avoid ABI incompatibility.
+    (closes: #846642)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 14 Dec 2016 17:58:10 +0000
+
+dnsmasq (2.76-4.1) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * Add two upstream patches to fix binding to an interface being
+    destroyed and recreated. Closes: #834722.
+      + 2675f2061525bc954be14988d64384b74aa7bf8b
+      + 16800ea072dd0cdf14d951c4bb8d2808b3dfe53d
+
+ -- Vincent Bernat <bernat@debian.org>  Sat, 26 Nov 2016 20:15:34 +0100
+
+dnsmasq (2.76-4) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * Fix FTCBFS: Use triplet-prefixed tools. (closes: #836072)
+
+ -- Helmut Grohne <helmut@subdivi.de>  Tue, 30 Aug 2016 13:59:12 +0200
+
+dnsmasq (2.76-3) unstable; urgency=medium
+
+   * Bump auth zone serial on SIGHUP. (closes: #833733)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 13 Aug 2016 21:43:10 +0000
+
+dnsmasq (2.76-2) unstable; urgency=medium
+
+   * Fix to systemd to fix failure to start with bridge interface.
+     (Closes: #831372)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 16 Jul 2016 22:09:10 +0000
+
+dnsmasq (2.76-1.2) unstable; urgency=medium
+
+  * Non-maintainer upload.
+  * dnsmasq: Install marker file to determine package installed state,
+    for the benefit of the init script. (Closes: #819856)
+
+ -- Christian Hofstaedtler <zeha@debian.org>  Sat, 16 Jul 2016 00:17:57 +0000
+
+dnsmasq (2.76-1.1) unstable; urgency=medium
+
+   * Non-maintainer upload.
+   * Provide nss-lookup.target for systemd, without relying on insserv.
+     Patch from Michael Biebl <biebl@debian.org>. (Closes: #826242)
+
+ -- Christian Hofstaedtler <zeha@debian.org>  Fri, 01 Jul 2016 13:41:11 +0000
+
+dnsmasq (2.76-1) unstable; urgency=low
+
+   * New upstream. (closes: #798586)
+   * Use /run/dnsmasq directly, rather than relying on link from /var/run
+     to avoid problems before /var is mounted. (closes: #800351)
+   * Test for the existence of /usr/share/doc/dnsmasq rather then
+     /etc/dnsmasq.d/README in the daemon startup script. (closes: #819856)
+   * Add --help to manpage and mention dhcp6 in summary. (closes: #821226)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 10 Sep 2015 23:07:21 +0000
+
+dnsmasq (2.75-1) unstable; urgency=low
+
+   * New upstream. (closes: #794095)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 30 Jul 2015 20:58:31 +0000
+
+dnsmasq (2.74-1) unstable; urgency=low
+
+   * New upstream. (LP: #1468611)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 15 Jul 2015 21:54:11 +0000
+
+dnsmasq (2.73-2) unstable; urgency=low
+
+   * Fix behaviour of empty --conf-file (closes: #790341)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 7 Jul 2015 21:46:42 +0000
+
+dnsmasq (2.73-1) unstable; urgency=low
+
+   * New upstream. (closes: #786996)
+   * Tweak field width in cache dump to avoid truncating IPv6
+     addresses. (closes: #771557)
+   * Add newline at the end of example config file. (LP: #1416895)
+   * Make Debian package build reproducible. (closes: #777323)
+   * Add Requires=network.target to systemd unit.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 4 Jun 2015 22:31:42 +0000
+
+dnsmasq (2.72-3) unstable; urgency=medium
+
+   * debian/systemd.service: switch from Type=dbus to Type=forking.
+     dnsmasq does not depend on dbus, but Type=dbus systemd services cannot
+     work without it. (Closes: #769486, #776530)
+     - debian/init: when called with systemd-exec argument, let dnsmasq
+       go into the background, so Type=forking can detect when it is ready
+   * Remove line containing only whitespace in debian/control.
+     (closes: #777571)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 11 Feb 2015 21:56:12 +0000
+
+dnsmasq (2.72-2) unstable; urgency=low
+
+   * Fix build in Debian-kFreeBSD. (closes: #763693)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 02 Oct 2014 22:34:12 +0000
+
+dnsmasq (2.72-1) unstable; urgency=low
+
+   * New upstream.
+   * If dns-root-data package is installed, use it to set the DNSSEC
+     trust anchor(s). Recommend dns-root-data. (closes: #760460)
+   * Handle AD bit correctly in replies from cache. (closes: #761654)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 20 May 2014 21:01:11 +0000
+
+dnsmasq (2.71-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix 100% CPU-usage bug when dnsmasq started with cachesize
+     set to zero. (LP: #1314697)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 16 May 2014 20:17:10 +0000
+
+dnsmasq (2.70-3) unstable; urgency=medium
+
+   * Write a pid-file, even when being started using systemd, since
+     other components may wish to signal dnsmasq.
+   * Enable dnsmasq systemd unit on install. Otherwise dnsmasq does not run on
+     fresh installations (without administrator handholding) and even worse it
+     is disabled on systems switching from sysv to systemd. Modify
+     postinst/postrm exactly as dh_systemd would, add dependency on
+     init-system-helpers. Closes: #724602
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 11 May 2014 17:45:21 +0000
+
+dnsmasq (2.70-2) unstable; urgency=low
+
+   * Ensure daemon not stared if dnsmasq package has been removed,
+     even if dnsmasq-base is still installed. (closes: #746941)
+   * Tidy cruft in initscript. (closes: #746940)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 04 May 2014 21:34:11 +0000
+
+dnsmasq (2.70-1) unstable; urgency=low
+
+   * New upstream.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 23 Apr 2014 15:14:42 +0000
+
+dnsmasq (2.69-1) unstable; urgency=low
+
+   * New upstream.
+   * Set --local-service. (closes: #732610)
+     This tells dnsmasq to ignore DNS requests that don't come
+     from a local network. It's automatically ignored if
+     --interface --except-interface, --listen-address or
+     --auth-server exist in the configuration, so for most
+     installations, it will have no effect, but for
+     otherwise-unconfigured installations, it stops dnsmasq
+     from being vulnerable to DNS-reflection attacks.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 4 Feb 2014 16:28:12 +0000
+
+dnsmasq (2.68-1) unstable; urgency=low
+
+   * New upstream. (closes: #730553)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 8 Dec 2013 15:57:32 +0000
+
+dnsmasq (2.67-1) unstable; urgency=low
+
+   * New upstream.
+   * Update resolvconf script. (closes: #720732)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 4 Aug 2013 14:53:22 +0000
+
+dnsmasq (2.66-4) unstable; urgency=low
+
+   * Update resolvconf script. (closes: #716908)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 4 Aug 2013 14:48:21 +0000
+
+dnsmasq (2.66-3) unstable; urgency=low
+
+   * Update resolvconf script for dnscrypt-proxy integration. (closes: #709179)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 28 May 2013 14:39:51 +0000
+
+dnsmasq (2.66-2) unstable; urgency=low
+
+   * Fix error on startup with some configs. (closes: #709010)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 20 May 2013 11:46:11 +0000
+
+dnsmasq (2.66-1) unstable; urgency=low
+
+   * New upstream.
+   * Add support for noipset in DEB_BUILD_OPTIONS.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 22 Feb 2013 21:52:13 +0000
+
+dnsmasq (2.65-1) unstable; urgency=low
+
+   * New upstream.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 14 Dec 2012 11:34:12 +0000
+
+dnsmasq (2.64-1) unstable; urgency=low
+
+   * New upstream.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 21 Sep 2012 17:17:22 +0000
+
+dnsmasq (2.63-4) unstable; urgency=low
+
+   * Make pid-file creation immune to symlink attacks. (closes: #686484)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 21 Sep 2012 17:16:34 +0000
+
+dnsmasq (2.63-3) unstable; urgency=low
+
+   * Move adduser dependency to dnsmasq-base. (closes: #686694)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 4 Sep 2012 21:44:15 +0000
+
+dnsmasq (2.63-2) unstable; urgency=low
+
+   * Fix version script to report correct version.
+   * Unbotch move of dbus config file by using correct versions in
+     Replaces: and Breaks: lines. (closes: #685204)
+   * Create dnsmasq user in dnsmasq-base so that Dbus doesn't complain if
+     only dnsmasq-base is installed. (closes: #685987)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 28 Aug 2012 16:18:35 +0000
+
+dnsmasq (2.63-1) unstable; urgency=low
+
+   * New upstream.
+   * Move /etc/dbus-1/system.d/dnsmasq.conf from dnsmasq to dnsmasq-base.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 11 Jun 2012 21:55:35 +0000
+
+dnsmasq (2.62-3) unstable; urgency=low
+
+   * Do resolvconf and /etc/default startup logic when
+     starting with systemd. (closes: #675854)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 11 Jun 2012 21:50:11 +0000
+
+dnsmasq (2.62-2) unstable; urgency=low
+
+   * Pass LDFLAGS to make to get hardening in linker.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 7 Jun 2012 09:53:43 +0000
+
+dnsmasq (2.62-1) unstable; urgency=low
+
+   * New upstream.
+   * Use dpkg-buildflags. (Enables hardening).
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 12 May 2012 15:25:23 +0000
+
+dnsmasq (2.61-1) unstable; urgency=low
+
+   * New upstream.
+   * Provide "dump-stats" initscript method. (closes: #654656)
+   * Add (empty) build-indep and build-arch rules targets.
+   * Bump standards-version to 3.9.3
+   * Add port option to example dnsmasq.conf (closes: #668386)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 6 Mar 2012 19:45:43 +0000
+
+dnsmasq (2.60-2) unstable; urgency=high
+
+   * Fix DHCPv4 segfault. (closes: #665008)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 23 Mar 2012 09:37:23 +0000
+
+dnsmasq (2.60-1) unstable; urgency=low
+
+   * New upstream.
+   * Bump standards-version to 3.9.2
+   * Fix typo in example config file. (closes: #654897)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 1 Dec 2011 15:49:33 +0000
+
+dnsmasq (2.59-4) unstable; urgency=low
+
+   * Supply /etc/insserv.conf.d/dnsmasq (closes: #650540)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 1 Dec 2011 11:35:13 +0000
+
+dnsmasq (2.59-3) unstable; urgency=low
+
+   * Stop daemon at runlevels 0, 1 and 6. (closes: #647726)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 26 Nov 2011 15:28:33 +0000
+
+dnsmasq (2.59-2) unstable; urgency=low
+
+   * Fix reported version number.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 19 Oct 2011 09:25:53 +0000
+
+dnsmasq (2.59-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix IPv6 bind problem (closes: #644345)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 8 Oct 2011 16:34:13 +0000
+
+dnsmasq (2.58-3) unstable; urgency=low
+
+   * Fix resolvconf script location. (closes: #641717)
+   * Update systemd service file. (closes: #640095)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 15 Sep 2011 16:33:23 +0000
+
+dnsmasq (2.58-2) unstable; urgency=low
+
+   * Fix resolvconf script. (closes: #639963)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 1 Sep 2011 10:05:23 +0000
+
+dnsmasq (2.58-1) unstable; urgency=low
+
+   * New upstream.
+   * Add noconntrack DEB_BUILD_OPTIONS flag.
+   * Improve error message when tag:xxx appears
+     in --dhcp-host (closes: #627986)
+   * Add /usr/lib/resolvconf/packaging-event.d/dnsmasq (closes: #628003)
+   * Update resolvconf hook script to sleep only
+     when necessary. (closes: #627789)
+   * Tweak behaviour of --domain-needed to avoid problems with recursive
+     nameservers _downstream_ of dnsmasq. (closes: #630637)
+   * Allow processes running as uid dnsmasq to send messages on the DBus,
+     so that dnsmasq can return errors. (closes: #635017)
+   * Add /lib/systemd/system/dnsmasq.service (closes: #635753)
+   * New binary package, dnsmasq-utils, containing dhcp_release and
+     dhcp_lease_time from contrib/wrt. Note that these are Linux-specific
+     so this package is Architecture: linux-any (closes: #638136)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 22 Aug 2011 14:57:03 +0000
+
+dnsmasq (2.57-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix typos in example config file. (closes: #606615)
+   * Bump standards-version to 3.9.1
+   * Add noidn DEB_BUILD_OPTIONS flag.
+   * Don't complain about extra command line arguments if
+     they are empty, as this breaks libvirt. (closes: #613915)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 18 Feb 2011 09:54:13 +0000
+
+dnsmasq (2.56-1) unstable; urgency=low
+
+   * New upstream.
+   * Die if non-option args present on the command-line. (closes: #589885)
+   * Tighten up use of IGNORE_RESOLVCONF in initscript. (closes: #575345)
+   * Update URL of ISC's explanation of dhcp-authoritative in the example
+     configuration file. (closes: #604870)
+   * Cosmetic changes to dnsmasq.conf.example. (closes: #598790)
+   * More dnsmasq.conf.example fixes. (closes: #606615)
+   * Add other resolv.conf locations to FILES section of the manual
+     page. (closes: #603505)
+   * Clarify configuration for static IP addresses in the absence of
+     resolvconf in the Debian readme file. (closes: #604035)
+   * Fix handling of obsolete DNSMASQ_INTERFACE and DNSMASQ_EXCEPT
+     variables in /etc/default/dnsmasq. (LP: #691329)
+   * Provide debian/source/format.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 17 Dec 2010 13:17:33 +0000
+
+dnsmasq (2.55-2) unstable; urgency=high
+
+   * Fix crash on double free. (closes: #597205)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 19 Sep 2010 21:45:33 +0000
+
+dnsmasq (2.55-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix crash when /etc/ethers in use. (closes: #584754)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 6 Jun 2010 20:33:13 +0000
+
+dnsmasq (2.53-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix FTBFS on kFreeBSD. (closes: #566334)
+   * Teach initscript to check the config file syntax before
+     restarting dnsmasq. An error will leave the old dnsmasq still
+     running, rather than killing the old daemon and then failing to start
+     a new one.
+   * Tweak DHCP behaviour when a physical interface has two addresses on
+     the same subnet. (closes: #581064)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 20 May 2010 11:41:23 +0000
+
+dnsmasq (2.52-1) unstable; urgency=low
+
+   * New upstream.
+   * Be more conservative with "A for A" processing. (closes: #553337)
+   * Add README file in /etc/dnsmasq.d to explain what's going on.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 14 Jan 2010 09:53:13 +0000
+
+dnsmasq (2.51-1) unstable; urgency=low
+
+   * New upstream.
+   * Bump standards-version to 3.8.2 (no changes needed).
+   * Ignore files named *.dpkg-old, *.dpkg-new and *.dpkg-dist 
+     in /etc/dnsmasq.d
+   * Provide a facility in /etc/default/dnsmasq to disable dnsmasq's
+     interaction with the resolvconf package. This is needed because
+     setting "resolv-file" in /etc/dnsmasq.conf won't override a
+     file given on the command line from resolvconf. (closes: #528762)
+   * Check for duplicate names/addresses in /etc/ethers. (closes: #523787)
+   * Set the system locale in the environment before invoking dnsmasq,
+     so that translated messages work, and IDN uses the correct charset.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 4 Oct 2009 14:01:14 +0000
+
+
+dnsmasq (2.50-1) unstable; urgency=high
+   
+   * New upstream, fixes remote vulns in TFTP server.
+     Bugtraq id: 36120,36121 CVE: 2009-2957,2009-2958	
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 21 Aug 2009 10:25:13 +0000
+
+	
+dnsmasq (2.49-1) unstable; urgency=low
+   
+   * New upstream.
+   * Log TFTP "file not found" errors. (closes: #532201)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 8 Jun 2009 22:03:23 +0000
+	
+dnsmasq (2.48-2) unstable; urgency=low
+   
+   * Change dnsmasq -> dnsmasq-base dependency to >= to allow binNMU,
+     fixes Lintian error.
+   * Bump standards-version to 3.8.1
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 5 Jun 2009 10:58:33 +0000
+
+dnsmasq (2.48-1) unstable; urgency=low
+
+   * New upstream.
+   * Detect and ignore duplicate configuration files. (closes: #516234)
+   * Add 2 second sleep between stop and start during initscript restart.
+   * Make dependency on dnsmasq-base in dnsmasq package versioned, so that
+     installing the latest dnsmasq will install the latest dnsmasq-base
+     too. (closes: #523955)
+   * Add nodhcp DEB_BUILD_OPTIONS option.
+		
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 29 May 2009 10:20:23 +0000
+
+dnsmasq (2.47-3) unstable; urgency=low
+
+   * Fix bashism in init script. (closes: #514397)
+   * Tweak logging in init script.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 7 Feb 2009 19:25:23 +0000
+
+dnsmasq (2.47-2) unstable; urgency=low
+
+   * Check that /etc/init.d/dnsmasq is executable in postinst in case
+     the daemon has been  disabled that way. (closes: #514314)
+   * Ensure that /var/run/dnsmasq exists and has the right permissions
+     before running dnsmasq. On some systems /var/run is cleared over 
+     reboot. (closes: #514317)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 6 Feb 2009 09:38:21 +0000
+	
+dnsmasq (2.47-1) unstable; urgency=low
+
+   * New upstream.
+   * Handle the "ENABLED" flag in the init script a bit more 
+     intelligently. The "stop" and "status" functions continue
+     to work even when disabled, but a failed "stop" becomes 
+     silent and returns zero exit code.
+   * Don't explicitly kill dnsmasq at system shutdown, rely on the 
+     sendsigs script instead which is quicker. (closes: #506734)
+   * Store the PID-file in /var/run/dnsmasq. This directory is owned by
+     user "dnsmasq", so that dnsmasq can delete the PID-file on
+     shutdown. This ensures that the the PID-file goes even when dnsmasq 
+     is stopped by sendsigs. (closes: #508560) 
+   * Bump standards-version to 3.8.0 (no changes required.)
+   * /usr/sbin/adduser -> adduser in postinst. Lintian fix.
+   * Handle IPv6 addresses in "tentative" state better. (closes: #507646) 
+   * Add DBus introspection support. (closes: #508774)
+   * Fix Dbus configuration. (closes: #510649)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 2 Feb 2009 13:39:11 +0000
+
+dnsmasq (2.46-1) unstable; urgency=low
+
+   * New upstream. (closes: #499162) (closes: #499007)
+   * Remove from init script start-stop-daemon call to kill
+     child processes. This is not needed since dnsmasq is 
+     carefully written to kill child processes, and it interacts
+     badly with "private" instances of dnsmasq. (closes: #505523)
+   * Provide /etc/dnsmasq.d and alter the installed /etc/default/dnsmasq
+     so that /etc/dnsmasq.d is read. This provides a drop-directory where
+     libvirt can add options to make the system dnsmasq automatically 
+     play nice with libvirt's private instances. (closes: #505522)
+	        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 13 Nov 2008 20:15:31 +0000
+
+dnsmasq (2.45-1) unstable; urgency=high
+
+   * New upstream - fixes regression when min-port not set.
+	        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 20 Jul 2008 19:27:11 +0000
+	
+dnsmasq (2.44-1) unstable; urgency=high
+
+   * New upstream - bugfix release for 2.43.
+   * Fix crash in netlink code. (closes: #491289)
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 11 Jul 2008 19:39:10 +0000
+
+dnsmasq (2.43-1) unstable; urgency=high
+
+   * New upstream.
+   * Implement source-port randomisation and better random
+     number generator as defence against CVE-2008-1447 (closes: #490123)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 17 Jun 2008 11:55:38 +0000
+
+dnsmasq (2.42-4) unstable; urgency=low
+
+   * Fix botch in postinst introduced in 2.42-2. (closes: #486616)
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 17 Jun 2008 11:39:10 +0000
+
+dnsmasq (2.42-3) unstable; urgency=low
+
+   * Fix thinko in init script, breaks status command. (closes: #486455)
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 16 Jun 2008 11:26:20 +0000
+
+dnsmasq (2.42-2) unstable; urgency=low
+
+   * Error check in postinst file (closes: #485645)
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 10 Jun 2008 20:25:10 +0000
+
+dnsmasq (2.42-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix manpage typos. (closes: #468762)
+   * Use LSB log_*_msg rather than echo in init script. (closes: #473117)
+   * Fix agent-id echo problem. (closes: #473015)
+   * Fixup changing /usr/share/doc/dnsmasq to symlink. (closes: #468763)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 27 Feb 2008 21:15:28 +0000
+
+dnsmasq (2.41-2) unstable; urgency=low
+
+   * Fix rules to build binary-arch and binary-indep correctly.
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 27 Feb 2008 19:57:10 +0000
+
+dnsmasq (2.41-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix typo. (closes: #448038)
+   * Fix DHCP problem interoperating with Sony Ericsson K610i (closes: #451871)
+   * Split binary packages into dnsmasq and dnsmasq-base (closes: #463407)
+   * Add warnings about bad effects of --filterwin2k to default config
+     file. (closes: #464357) 
+   * Don't declare Provides: $named in LSB header. (closes: #464512)
+   * Remove conflict with pdnsd. (closes: #464691)
+   * Add ability to disable dnsmasq in /etc/default/dnsmasq. (closes: #465062)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 31 Jan 2008 20:25:28 +0000
+
+dnsmasq (2.40-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix manpage typo. (closes: #429412)
+   * Fix dnsmasq.conf typos (closes: #429929)
+   * Handle DEB_BUILD_OPTIONS nostrip and noopt (closes: #436784)
+   * Add DEB_BUILD_OPTIONS for nodocs, notftp, noipv6, 
+     nodbus, noi18n and nortc.
+   * Create DEBIAN/md5sums file in package.
+   * Add status function to init script. (closes: #439316)
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 9 Aug 2007 10:24:18 +0000
+
+dnsmasq (2.39-1) unstable; urgency=low
+
+   * New upstream.
+   * Provide example config file in /usr/share/doc/dnsmasq/examples
+     as well as /etc/dnsmasq.conf, so it's available for reference.
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 13 Feb 2007 10:02:38 +0000
+
+dnsmasq (2.38-1) unstable; urgency=low
+
+   * New upstream (closes: #410185)
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 6 Feb 2007 21:14:58 +0000
+
+dnsmasq (2.37-1) unstable; urgency=low
+
+   * New upstream.
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 25 Jan 2007 10:44:18 +0000
+
+dnsmasq (2.36-1) unstable; urgency=low
+
+   * New upstream. (closes: #400037)
+   * Don't fail to purge if deluser command is not available.
+   * Add one second sleep to resolvconf script. (closes: #398961)
+   * Fix dnsmasq.conf typo (closes: #405314) 
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 31 Oct 2006 10:24:58 +0000
+
+dnsmasq (2.35-1) unstable; urgency=low
+
+   * New upstream.
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 18 Oct 2006 09:23:28 +0000
+
+dnsmasq (2.34-1) unstable; urgency=low
+
+   * New upstream.
+   * Includes --clear-on-reload flag. (loses: #391654)
+   * Don't any longer set the "domain-needed" and "bogus-priv" flags in the
+   * the default-installed dnsmasq.conf. These can generate puzzling 
+   * behaviour for people who get them without asking.
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 9 Aug 2006 09:23:28 +0000
+
+dnsmasq (2.33-1) unstable; urgency=low
+
+   * New upstream.
+   * Remove bashism from Makefile (closes: #375409)
+   * Added Provides: $named to LSB header in init script.
+   * Add --dns-forward-max flag. (closes: #377506)
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 25 June 2006 18:03:13 +0000
+
+dnsmasq (2.32-2) unstable; urgency=low
+
+   * Added LSB tags to init.d startup script. (closes: #374650)
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 25 June 2006 17:55:11 +0000
+
+dnsmasq (2.32-1) unstable; urgency=low
+
+   * New upstream.
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 8 May 2006 09:23:28 +0000
+
+dnsmasq (2.31-1) unstable; urgency=high
+
+   * New upstream. (closes: #364800)
+   * Compile in Dbus support now that suitable Dbus packages exist.
+   * Don't stop an old dnsmasq process, until a new one is ready, 
+     when upgrading. (closes: #366224)
+   * Move to standards-version 3.7.2 (no changes needed).
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 6 May 2006 11:58:22 +0000
+
+dnsmasq (2.30-1) unstable; urgency=low
+
+   * New upstream, fixes crash with DHCP broadcast replies.
+				
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 23 Apr 2006 14:58:22 +0000
+
+dnsmasq (2.29-1) unstable; urgency=low
+
+   * New upstream. (closes: #363244) (closes: #363340)
+   * Made config options clearer in src/config.h and 
+     clarify ISC integration status in Debian readme. (closes: #364250)
+			
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 18 Apr 2006 10:26:12 +0000
+
+dnsmasq (2.28-1) unstable; urgency=low
+
+   * New upstream. (closes: #359956) (closes: #362499)
+   * Added firestarter info to FAQ. (closes: #359139)
+		
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 14 Mar 2006 19:20:12 +0000
+
+dnsmasq (2.27-1) unstable; urgency=low
+
+   * New upstream.
+   * Workaround buggy Microsoft DHCP clients. (closes: #355008)
+		
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 1 Feb 2006 17:05:12 +0000
+
+dnsmasq (2.26-1) unstable; urgency=high
+
+   * New upstream. (Fixes possible crash in 2.25, hence urgency).
+		
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 22 Jan 2006 11:05:22 +0000
+
+dnsmasq (2.25-1) unstable; urgency=low
+
+   * Remove bashisms in postinst and prerm scripts.
+   * Remove misconceived dependency on locales.	
+   * Depend on adduser.
+		
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thu, 01 Dec 2005 21:02:12 +0000
+
+dnsmasq (2.24-1) unstable; urgency=low
+
+   * New upstream. (closes: #330422)
+   * Fix typo and clean up dnsmasq.conf (closes: #326057) (closes: #304446)
+   * Add build support for I18N and gettext.
+   * Fixed manpage typos. (closes: #336413)
+   * Create a dnsmasq-unique userid for the daemon to run as. (closes: #338353)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 03 Sep 2005 20:02:32 +0000
+
+dnsmasq (2.23-1) unstable; urgency=low
+
+   * New upstream. (closes: #302501) (closes: #315794)
+   * Fix manpage typos. (closes: #304984)
+   * Add support for DNSMASQ_EXCEPT in /etc/defaults/dnsmasq.
+     putting "lo" in this also disables resolvconf support.
+   * No longer delete pre-existing /etc/init.d symlinks. The 
+     change in default runlevels which necessitated this 
+     is now ancient history and anyway the startup script now 
+     behaves when called twice. (closes: #312111)
+   * Tightened config-file parser. (closes: #317030)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 02 Aug 2005 13:17:22 +0000
+
+dnsmasq (2.22-2) unstable; urgency=low
+
+   * Make the resolv.conf polling code resistant to 
+     backwards-moving system clocks. (closes: #306117) (closes: #300694)
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 04 May 2005 13:25:23 +0000
+
+dnsmasq (2.22-1) unstable; urgency=low
+
+   * New upstream.
+   * Fixed broken-ness when read /etc/ethers. (closes: #301999)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thur, 24 Mar 2005 17:10:13 +0000
+
+dnsmasq (2.21-1) unstable; urgency=low
+
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 29 Jan 2005 16:05:13 +0000
+
+dnsmasq (2.20-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix shadowed CNAME-target problem. (closes: #286654)
+   * Add --localise-queries option. (closes: #291367)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 17 Dec 2004 17:35:23 +0000
+
+dnsmasq (2.19-1) unstable; urgency=high
+
+   * New upstream.
+   * Fix another IPv6 interface enumeration problem. (closes: #285182)
+   * Uploading at high priority since 285182 is really RC.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 11 Dec 2004 20:39:33 +0000
+
+dnsmasq (2.18-2) unstable; urgency=low
+
+   * Revert startup to not start from rcS. Starting in rcS
+   * causes problems if interfaces are not available at that
+   * point. Users who need this facility should  manually 
+   * make rcS.d symlinks. (closes: #283239)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 27 Nov 2004 16:33:12 +0000
+	
+dnsmasq (2.18-1) unstable; urgency=low
+
+   * New upstream.
+   * Reset cache statistics when clearing the cache. (closes: #281817)
+   * Fix problems with bind-interfaces and IPv6. (closes: #282192)
+   * Fix problems upgrading when restarting dnsmasq fails.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 16 Nov 2004 17:33:32 +0000
+
+dnsmasq (2.17-1) unstable; urgency=high
+
+   * New upstream - fixes crash, hence high urgency. 
+   * Clarified log message when a record in /etc/hosts 
+     and a DHCP name clash. (closes: #275420)
+   * Start dnsmasq just before portmap and nfs mounts from rcS.d
+     DNS is required at this stage to use the net. (closes: #280434)
+   * Make "bind-interfaces" apply to IPv6 interfaces. (closes: #278492)
+   * Allow a list if interfaces as arg to the --interface and
+     --except-interface options. (closes: #279063) 
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 26 Oct 2004 20:39:33 +0000
+
+dnsmasq (2.16-2) unstable; urgency=high
+
+   * Rename variable in cache.c which clashes with C headers
+     under gcc-3.4 (closes: #277893)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 25 Oct 2004 16:03:24 +0000
+
+dnsmasq (2.16-1) unstable; urgency=high
+
+   * New upstream.
+   * Fixes interaction with Linux 2.4.x and 2.6.x not-quite-POSIX
+     select behavior, which can cause hangs when receiving UDP
+     packets with bad checksum.
+   * Fix bad interaction with polipo. (closes: #275754)
+   * Cache CNAMEs better. (closes: #276289)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 04 Oct 2004 15:25:44 +0000
+
+dnsmasq (2.15-1) unstable; urgency=low
+
+   * New upstream.
+   * Fix NXDOMAIN/NODATA confusion for locally known names. (closes: #271564)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 15 Sep 2004 15:01:44 +0000
+
+dnsmasq (2.14-1) unstable; urgency=low
+
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 28 Aug 2004 20:39:33 +0000
+
+dnsmasq (2.13-1) unstable; urgency=high
+
+   * New upstream - fixes crash. (closes #265313)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thur, 12 Aug 2004 12:45:23 +0000
+
+dnsmasq (2.12-1) unstable; urgency=low
+
+   * New upstream.
+   * Log types of incoming queries (closes: #230123).
+   * Don't set "filterwin2k" by default in the included
+     config file - it breaks SRV lookups and Kerberos.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 8 Aug 2004 19:58:13 +0000
+
+dnsmasq (2.11-1) unstable; urgency=low
+
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 28 July 2004 21:59:33 +0000
+
+dnsmasq (2.10-1) unstable; urgency=low
+
+   * New upstream.
+   * Allow query-port less than 1024 (closes: #236586)
+   * Change behaviour of --bogus-priv (closes: #254711)
+   * Match existing leases by MAC address when a client stops
+     using client-id or they get suppressed by dnsmasq. (closes: #258519)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thur, 24 June 2004 20:55:42 +0000
+
+dnsmasq (2.9-2) unstable; urgency=low
+
+   * Fix typo in debian/control (closes: #255762)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 23 Jun 2004 20:40:13 +0000
+
+dnsmasq (2.9-1) unstable; urgency=low
+
+   * New upstream.
+   * New version has improved server selection logic (closes: #251097)
+   * Improved initscript (closes: #252229)
+   * Conflict with old resolvconf versions to maintain compatibility.
+   * Updated README.debian (closes: #253429)
+   * Changed startup message to mention DHCP as well as DNS.
+   * New resolvconf update script (closes: #254765)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed, 26 May 2004 12:35:23 +0000
+
+dnsmasq (2.8-1) unstable; urgency=low
+
+   * New upstream.
+   * Fixes problem with zero-length hostnames which can lose
+     DHCP leases over a restart. (closes: #248829)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thur, 13 May 2004 18:40:12 +0000
+	
+dnsmasq (2.7-2) unstable; urgency=low
+
+   * New version of resolvconf script from Thomas Hood with the 
+     following changes: (closes: #247695)
+   * Doesn't include nameservers listed in the lo.inet or lo.inet6 interface
+     records created by "ifup lo"
+   * Lists addresses in a specified order (by interface name)
+   * Eliminates duplicate nameserver addresses
+   * Updates /var/run/dnsmasq/resolv.conf atomically
+   * Doesn't generate empty lines
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tue, 11 May 2004 22:35:12 +0000
+
+dnsmasq (2.7-1) unstable; urgency=low
+
+   * New upstream.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 18 Apr 2004 20:00:23 +0000
+
+dnsmasq (2.6-3) unstable; urgency=low
+
+   * Removed reload command from start script and moved force-reload
+     to be equivalent to restart. This is needed to be policy compliant
+     since SIGHUP doesn't cause dnsmasq to reload its configuration file,
+     only the /etc/hosts, /etc/resolv.conf etc. (closes: #244208)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 18 Apr 2004 14:40:51 +0000
+
+dnsmasq (2.6-2) unstable; urgency=low
+
+   * Added Conflict with pdnsd (closes: #242731).
+     Rationale: dnsmasq used to conflict with all the DNS servers
+     in Debian, but that was removed because some people wished
+     to run with dnsmasq listening on one interface and another DNS
+     server listening on another interface. However AFAIK it is not
+     possible to make pdnsd listen on a subset of a hosts interfaces,
+     so there is no scenario where running pdnsd and dnsmasq on the same
+     host would be useful, hence the conflict goes back.
+   * Added note about the --bind-interfaces option to
+     readme.Debian (closes: #241700)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 13 Apr 2004 18:37:55 +0000
+      
+dnsmasq (2.6-1) unstable; urgency=low
+
+   * New upstream.
+   * New version adds back ability to read ISC dhcpd lease files
+     for backwards compatibility. (closes: #229684) (closes: #236421)
+   * Fix parsing of # characters in options file. (closes: #241199)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 21 Mar 2004 19:59:25 +0000
+      
+dnsmasq (2.5-1) unstable; urgency=low
+
+   * New upstream, includes fix for IP-alias related 
+     problem. (closes: #238268)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 14 Mar 2004 08:32:43 +0000
+
+dnsmasq (2.4-3) unstable; urgency=low
+
+   * Fixed "bind-interfaces" option, even when
+     an "interface" option is given also.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 12 Mar 2004 08:14:23 +0000
+
+dnsmasq (2.4-2) unstable; urgency=low
+
+   * Fixed "bind-interfaces" option (closes: #237543).
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 12 Mar 2004 07:30:25 +0000
+
+dnsmasq (2.4-1) unstable; urgency=low
+
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thurs, 11 Mar 2004 07:59:55 +0000
+
+dnsmasq (2.3-1) unstable; urgency=low
+
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 03 Feb 2004 20:33:10 +0000
+
+dnsmasq (2.2-1) unstable; urgency=low
+
+   * New upstream. (fixes no DHCP with IPv6 problem)
+   * Restart (old) daemon on abort-upgrade. (closes: #230286)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 30 Jan 2004 10:23:00 +0000
+
+dnsmasq (2.1-1) unstable; urgency=low
+
+   * New upstream.
+   * Allow addresses in /etc/hosts to be used for 
+     DHCP leases (closes: #229681)
+   * Fix lease time processing. (closes: #229682) (closes: #229687)
+   * Fix example conf file. (closes: #229683) (closes: #229701)
+   * Allow address 0.0.0.0 to mean "self" in dhcp-option. (closes: #229685)
+   * Cope with ENODEV return from bind of 
+     IPv6 server socket (closes: #229607) 
+   * Document the strict-order option in dnsmasq.conf (closes: #229272)
+   * Fix local-only domain setting. (closes: #229846)
+   * Updates Debian readme to mention resolvconf and point at the
+     local copy of RFC2132.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri,  23 Jan 2004 14:38:29 +0000
+
+dnsmasq (2.0-1) unstable; urgency=low
+
+   * New upstream: This removes the ability to read the 
+     the leases file of ISC DHCP and replaces it with a built-in 
+     DHCP server. Apologies in advance for breaking backwards 
+     compatibility, but this replaces a bit of a hack (the ISC stuff)
+     with a nicely engineered and much more appropriate solution.
+     Wearing my upstream-maintainer hat, I want to lose the hack now,
+     rather than have to support it into Sarge.
+   * New upstream closes some bugs since they become 
+     irrelevant. (closes: #197295)
+   * Ensure that /var/run and /var/lib/misc exist.
+   * Remove sed dependency, which was a mistake.
+   * Remove extraneous "build" file. (closes: #226994)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun,  16 Jan 2004 19:35:49 +0000
+
+dnsmasq (1.18-2) unstable; urgency=low
+        
+   * Fixed manpage typo (closes: #220961)
+   * Added dependency for sed. (closes: #222401)
+   * Check for complete resolvconf installation before 
+     calling it. (closes: #223442)
+   * Added Links section to doc.html
+        
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 27 Dec 2003 20:21:15 +0000
+   
+dnsmasq (1.18-1) unstable; urgency=low
+
+   * New upstream which does round-robin. (closes: #215460)
+   * Removed conflicts with other dns servers since it is now
+     possible to control exactly where dnsmasq listens on multi-homed 
+     hosts, making co-existence with another nameserver 
+     a viable proposition. (closes #176163)
+   * New upstream allows _ in hostnames and check for illegal
+     names in /etc/hosts. (closes: #218842)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 17 Oct 2003 16:23:14 +0000
+
+dnsmasq (1.17-1) unstable; urgency=high
+
+   * New upstream (closes: #212680)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Wed,  8 Oct 2003 14:38:29 +0000
+
+dnsmasq (1.16-1) unstable; urgency=low
+  
+   * New upstream.
+   * Renamed Debian README to the standard README.Debian. (closes: #211577)
+   * Updated the installed /etc/dnsmasq.conf to reflect new options.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 16 Sep 2003 23:18:59 +0000
+
+dnsmasq (1.15-1) unstable; urgency=low
+  
+   * New upstream.
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 16 Sep 2003 21:48:49 +0000
+
+dnsmasq (1.14-1) unstable; urgency=low
+  
+   * New upstream.
+   * Use invoke-rc.d in postinst and prerm scripts when available.
+   * Stop dnsmasq later (at priority 85). (closes: #200625)
+   * Updated /etc/resolvconf/update.d/dnsmasq. (closes: #202609)
+   * Suggest resolvconf. (closes: #208093)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues,  2 Sep 2003 16:43:29 +0000
+
+dnsmasq (1.13-4) unstable; urgency=high
+  
+   * Ignore failures in stopping existing dnsmasq 
+     processes. (closes: #204127) (closes: #204129)
+   * Added download source to copyright. (closes: #206647)
+	
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 2 Sep 2003 15:28:28 +0000
+
+dnsmasq (1.13-3) unstable; urgency=low
+  
+   * Moved /etc/resolvconf/update.d/dnsmasq script into this package.
+   * Don't call resolvconf from /etc/init.d/dnsmasq if dnsmasq fails
+     to start. (Patch from Thomas Hood.)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon,  7 Jul 2003 20:55:29 +0000
+
+dnsmasq (1.13-2) unstable; urgency=low
+  
+   * Added support for the resolvconf nameserver configuration package.
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 22 Jun 2003 20:30:19 +0000
+
+dnsmasq (1.13-1) unstable; urgency=low
+
+   * New upstream.
+   * Added new options to the default dnsmasq.conf.
+   * Default config now reads /var/lib/dhcp/dhcp.leases (closes: #195185)
+   * Added option to disable negative caching. (closes: #194274)
+   * Added David Coe's query port patch. (closes: #196578)
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 31 May 2003 18:10:29 +0000
+
+dnsmasq (1.12-1) unstable; urgency=low
+
+   * New upstream.
+   * Added examples of "local" and "address" options to dnsmasq.conf.
+   * Remove /usr/doc symlink code.
+   * Remove period from end of description field.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 8 Mar 2003 12:16:09 +0000
+
+dnsmasq (1.11-2) unstable; urgency=low
+
+   * Fixed thinko in example dnsmasq.conf. (closes: #180410)
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 24 Feb 2003 20:06:19 +0000
+
+dnsmasq (1.11-1) unstable; urgency=low
+
+   * New upstream.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Tues, 12 Jan 2003 22:25:17 -0100
+
+dnsmasq (1.10-1) unstable; urgency=low
+
+   * New upstream.
+   * Force service to stop in postinst before restarting. I don't
+     understand the circumstances under which it would still be running at
+     this point, but this is the correct fix anyway. (closes: #169718) 
+   * Add /etc/dnsmasq.conf as a conffile and add a comment to 
+     /etc/default/dnsmasq deprecating its use and recommending 
+     /etc/dnsmasq.conf instead, since upstream now supports this.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 9 Oct 2002 19:05:34 -0100
+
+dnsmasq (1.9-1) unstable; urgency=low
+
+   * New upstream.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 23 Sept 2002 21:35:07 -0100
+
+dnsmasq (1.8-1) unstable; urgency=low
+  
+   * New upstream.
+    
+ -- Simon Kelley <simon@thekelleys.org.uk>  Mon, 12 Aug 2002 21:56:17 -0100
+
+dnsmasq (1.7-1) unstable; urgency=low
+  
+   * New upstream including better group-id manipulation. (closes: #152212)
+   * Conflict with bind9 (closes: #151812)
+   * Added more options to startup script. (closes: #148535)
+    
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 14 July 2002 20:23:14 -0100
+
+dnsmasq (1.6-1) unstable; urgency=low
+  
+   * New upstream.
+   * Fixed documentation typos. (closes: #144637)
+   * Fixed failure to remove package if daemon not running. (closes: #147083)
+   * Changed upload to tarball-and-diff. (closes: #144638)
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 19 May 2002 22:30:17 -0100
+
+dnsmasq (1.5-1) unstable; urgency=medium
+  
+   * New upstream (includes hotmail.com fix).
+   * Fixed DHCP lease file bug. (closes: #143778)
+   * Fixed failure of "reload" command in startup script (closes: #141021)
+   * Allow more than one interface name in the DNSMASQ_INTERFACE variable.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 14 Apr 2002 16:39:13 -0100
+  
+dnsmasq (1.4-2) unstable; urgency=low
+  
+    * Fixed snafu in startup script (closes: #139760)
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sun, 24 Mar 2002 23:06:18 +0000
+  
+dnsmasq (1.4-1) unstable; urgency=low
+  
+  * New upstream
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thurs, 7 Mar 2002 21:02:05 +0000
+  
+dnsmasq (1.3-1) unstable; urgency=low
+  
+  * New upstream
+
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 15 Feb 2002 20:45:01 +0000
+  
+dnsmasq (1.2-4) unstable; urgency=low
+  
+  * Updated standards-version.
+  * More aggressive strip of binaries.
+  * Added depends: netbase.
+  * distribution->unstable for upload.
+  * Updated readme.Debian since config in /etc/default/dnsmasq now.
+  * Updated readme.Debian to reflect fact that this package is official now!
+ 
+ -- Simon Kelley <simon@thekelleys.org.uk>  Fri, 15 Feb 2002 20:45:01 +0000
+  
+dnsmasq (1.2-3) stable; urgency=low
+  
+  * Added Suggests: and Conflicts: fields to control file.
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Thurs, 14 Feb 2002 20:33:47 +0000
+  
+dnsmasq (1.2-2) stable; urgency=low
+ 
+  * Many packaging fixes, to please lintian
+  * Added extended description.
+  * Fixed copyright file.
+  * Compressed everything in /usr/share/doc/dnsmasq.
+  * Added code to remove /usr/doc/dnsmasq to prerm script.
+  * Moved configuration from /etc/init.d/dnsmasq to /etc/default/dnsmasq
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 02 Feb 2002 18:54:37 +0000
+  
+dnsmasq (1.2-1) stable; urgency=low
+ 
+  * New upstream
+  * Added more options to startup script
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 20 Dec 2001 21:15:07 +0000
+
+dnsmasq (1.1-2) stable; urgency=low
+ 
+  * New upstream
+  * Strip binary
+  * Moved manpage from section 1 to section 8
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 21 Oct 2001 17:32:04 -0100
+
+dnsmasq (1.0-1) unstable; urgency=low
+ 
+  * New upstream
+  
+ -- Simon Kelley <simon@thekelleys.org.uk>  Sat, 10 Oct 2001 15:52:06 -0100
+  
+dnsmasq (0.996-1) unstable; urgency=low
+  
+  * New upstream
+  
+ -- Simon Kelley <simon@thkelleys.org.uk>  Fri, 26 Oct 2001 10:32:06 -0100
+
+dnsmasq (0.995-1) unstable; urgency=low
+  
+  * New upstream
+  
+ -- Simon Kelley <simon@thkelleys.org.uk>  Tue, 09 Oct 2001 16:39:07 -0100
+
+dnsmasq (0.994-1) unstable; urgency=low
+  
+  * New upstream
+  
+ -- Simon Kelley <simon@thkelleys.org.uk>  Sat, 07 Oct 2001 15:45:04 -0100
+
+dnsmasq (0.992-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Simon Kelley <simon@thkelleys.org.uk>  Fri, 31 Aug 2001 16:17:00 -0100
+
+dnsmasq (0.98-1) unstable; urgency=low
+
+  * New upstream
+
+ -- Simon Kelley <simon@thkelleys.org.uk>  Wed, 11 Jul 2001 11:31:00 -0100
+
+dnsmasq (0.96-1) unstable; urgency=low
+
+  * Fixed thinko in cache code..
+
+ -- Simon Kelley <simon@thkelleys.org.uk>  Sat, 07 Jul 2001 18:52:00 -0100
+
+dnsmasq (0.95-1) unstable; urgency=low
+
+  * Initial Release.
+
+ -- Simon Kelley <simon@thkelleys.org.uk>  Sat, 29 Aug 1998 20:27:27 -0400
+
+
+  
+  
+  
+  
+  
+  
+  
+  
Index: debian/conffiles
===================================================================
--- debian/conffiles	(nonexistent)
+++ debian/conffiles	(revision 42741)
@@ -0,0 +1,5 @@
+/etc/init.d/dnsmasq
+/etc/default/dnsmasq
+/etc/dnsmasq.conf
+/etc/resolvconf/update.d/dnsmasq
+/etc/insserv.conf.d/dnsmasq
Index: debian/control
===================================================================
--- debian/control	(nonexistent)
+++ debian/control	(revision 42741)
@@ -0,0 +1,65 @@
+Source: dnsmasq
+Section: net
+Priority: optional
+Build-depends: gettext, libnetfilter-conntrack-dev [linux-any],
+               libidn2-dev, libdbus-1-dev (>=0.61), libgmp-dev, 
+               nettle-dev (>=2.4-3), libbsd-dev [!linux-any],
+	       liblua5.2-dev, dh-runit, debhelper-compat (= 10)
+Maintainer: Simon Kelley <simon@thekelleys.org.uk>
+Homepage: http://www.thekelleys.org.uk/dnsmasq/doc.html
+Vcs-Git: http://thekelleys.org.uk/git/dnsmasq.git
+Vcs-Browser: http://thekelleys.org.uk/gitweb/?p=dnsmasq.git
+Standards-Version: 3.9.8
+
+Package: dnsmasq
+Architecture: all
+Depends: netbase, dnsmasq-base,
+         init-system-helpers (>= 1.18~), lsb-base (>= 3.0-6), ${misc:Depends}
+Suggests: resolvconf
+Breaks: ${runit:Breaks}
+Conflicts: resolvconf (<<1.15), ${runit:Conflicts}
+Description: Small caching DNS proxy and DHCP/TFTP server
+ Dnsmasq is a lightweight, easy to configure, DNS forwarder and DHCP
+ server. It is designed to provide DNS and optionally, DHCP, to a 
+ small network. It can serve the names of local machines which are 
+ not in the global DNS. The DHCP server integrates with the DNS 
+ server and allows machines with DHCP-allocated addresses
+ to appear in the DNS with names configured either in each host or
+ in a central configuration file. Dnsmasq supports static and dynamic 
+ DHCP leases and BOOTP/TFTP for network booting of diskless machines.
+
+Package: dnsmasq-base
+Architecture: any
+Depends: adduser, ${shlibs:Depends}
+Breaks: dnsmasq (<< 2.63-1~)
+Replaces: dnsmasq (<< 2.63-1~), dnsmasq-base
+Recommends: dns-root-data
+Provides: dnsmasq-base
+Conflicts: dnsmasq-base-lua
+Description: Small caching DNS proxy and DHCP/TFTP server
+ This package contains the dnsmasq executable and documentation, but
+ not the infrastructure required to run it as a system daemon. For
+ that, install the dnsmasq package.
+
+Package: dnsmasq-base-lua
+Architecture: any
+Depends: adduser, ${shlibs:Depends}
+Breaks: dnsmasq (<< 2.63-1~)
+Replaces: dnsmasq (<< 2.63-1~), dnsmasq-base
+Recommends: dns-root-data
+Provides: dnsmasq-base
+Conflicts: dnsmasq-base
+Description: Small caching DNS proxy and DHCP/TFTP server
+ This package contains the dnsmasq executable and documentation, but
+ not the infrastructure required to run it as a system daemon. For
+ that, install the dnsmasq package. This package is an alternative
+ to dnsmasq-base which includes the LUA interpreter.
+ 
+Package: dnsmasq-utils
+Architecture: linux-any
+Depends: ${shlibs:Depends}
+Conflicts: dnsmasq (<<2.40)
+Description: Utilities for manipulating DHCP leases
+ Small utilities to query a DHCP server's lease database and
+ remove leases from it. These programs are distributed with dnsmasq
+ and may not work correctly with other DHCP servers.
Index: debian/copyright
===================================================================
--- debian/copyright	(nonexistent)
+++ debian/copyright	(revision 42741)
@@ -0,0 +1,21 @@
+dnsmasq is Copyright (c) 2000-2020 Simon Kelley
+
+It was downloaded from: http://www.thekelleys.org.uk/dnsmasq/
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+On Debian GNU/Linux systems, the text of the GNU general public license is 
+available in the file /usr/share/common-licenses/GPL-2 or 
+/usr/share/common-licenses/GPL-3
+
+The Debian package of dnsmasq was created by Simon Kelley with assistance 
+from Lars Bahner.
+
Index: debian/dbus.conf
===================================================================
--- debian/dbus.conf	(nonexistent)
+++ debian/dbus.conf	(revision 42741)
@@ -0,0 +1,18 @@
+<!DOCTYPE busconfig PUBLIC
+ "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+	<policy user="root">
+		<allow own="uk.org.thekelleys.dnsmasq"/>
+		<allow send_destination="uk.org.thekelleys.dnsmasq"/>
+	</policy>
+        <policy user="dnsmasq">
+                <allow own="uk.org.thekelleys.dnsmasq"/>
+                <allow send_destination="uk.org.thekelleys.dnsmasq"/>
+        </policy>
+	<policy context="default">
+                <deny own="uk.org.thekelleys.dnsmasq"/>
+                <deny send_destination="uk.org.thekelleys.dnsmasq"/>
+        </policy>
+</busconfig>
+
Index: debian/default
===================================================================
--- debian/default	(nonexistent)
+++ debian/default	(revision 42741)
@@ -0,0 +1,42 @@
+# This file has six functions:
+# 1) to completely disable starting this dnsmasq instance
+# 2) to set DOMAIN_SUFFIX by running `dnsdomainname`
+# 3) to select an alternative config file
+#    by setting DNSMASQ_OPTS to --conf-file=<file>
+# 4) to tell dnsmasq to read the files in /etc/dnsmasq.d for
+#    more configuration variables.
+# 5) to stop the resolvconf package from controlling dnsmasq's
+#    idea of which upstream nameservers to use.
+# 6) to avoid using this dnsmasq instance as the system's default resolver
+#    by setting DNSMASQ_EXCEPT="lo"
+# For upgraders from very old versions, all the shell variables set
+# here in previous versions are still honored by the init script
+# so if you just keep your old version of this file nothing will break.
+
+#DOMAIN_SUFFIX=`dnsdomainname`
+#DNSMASQ_OPTS="--conf-file=/etc/dnsmasq.alt"
+
+# Whether or not to run the dnsmasq daemon; set to 0 to disable.
+# Note that this is only valid when using SYSV init. For systemd,
+# use "systemctl disable dnsmasq"
+ENABLED=1
+
+# By default search this drop directory for configuration options.
+# Libvirt leaves a file here to make the system dnsmasq play nice.
+# Comment out this line if you don't want this. The dpkg-* are file
+# endings which cause dnsmasq to skip that file. This avoids pulling
+# in backups made by dpkg.
+CONFIG_DIR=/etc/dnsmasq.d,.dpkg-dist,.dpkg-old,.dpkg-new
+
+# If the resolvconf package is installed, dnsmasq will use its output
+# rather than the contents of /etc/resolv.conf to find upstream
+# nameservers. Uncommenting this line inhibits this behaviour.
+# Note that including a "resolv-file=<filename>" line in
+# /etc/dnsmasq.conf is not enough to override resolvconf if it is
+# installed: the line below must be uncommented.
+#IGNORE_RESOLVCONF=yes
+
+# If the resolvconf package is installed, dnsmasq will tell resolvconf
+# to use dnsmasq under 127.0.0.1 as the system's default resolver.
+# Uncommenting this line inhibits this behaviour.
+#DNSMASQ_EXCEPT="lo"
Index: debian/dnsmasq-base.conffiles
===================================================================
--- debian/dnsmasq-base.conffiles	(nonexistent)
+++ debian/dnsmasq-base.conffiles	(revision 42741)
@@ -0,0 +1 @@
+/etc/dbus-1/system.d/dnsmasq.conf
Index: debian/dnsmasq-base.postinst
===================================================================
--- debian/dnsmasq-base.postinst	(nonexistent)
+++ debian/dnsmasq-base.postinst	(revision 42741)
@@ -0,0 +1,24 @@
+#!/bin/sh
+set -e
+
+# Create the dnsmasq user in dnsmasq-base, so that Dbus doesn't complain.
+      
+# create a user to run as (code stolen from dovecot-common)
+if [ "$1" = "configure" ]; then
+  if [ -z "`id -u dnsmasq 2> /dev/null`" ]; then
+    adduser --system  --home /var/lib/misc --gecos "dnsmasq" \
+            --no-create-home --disabled-password \
+            --quiet dnsmasq || true
+  fi
+
+  # Make the directory where we keep the pid file - this
+  # has to be owned by "dnsmasq" so that the file can be unlinked.
+  # This is only actually used by the dnsmasq binary package, not
+  # dnsmasq-base, but it's much easier to create it here so that
+  # we don't have synchronisation issues with the creation of the
+  # dnsmasq user. 
+  if [ ! -d /run/dnsmasq ]; then
+    mkdir /run/dnsmasq
+    chown dnsmasq:nogroup /run/dnsmasq
+  fi
+fi
Index: debian/dnsmasq-base.postrm
===================================================================
--- debian/dnsmasq-base.postrm	(nonexistent)
+++ debian/dnsmasq-base.postrm	(revision 42741)
@@ -0,0 +1,11 @@
+#!/bin/sh
+set -e
+
+if [ purge = "$1" ]; then
+   if [ -x "$(command -v deluser)" ]; then
+     deluser --quiet --system dnsmasq > /dev/null || true
+  else
+     echo >&2 "not removing dnsmasq system account because deluser command was not found"
+  fi
+  rm -rf /run/dnsmasq
+fi
Index: debian/dnsmasq.runit
===================================================================
--- debian/dnsmasq.runit	(nonexistent)
+++ debian/dnsmasq.runit	(revision 42741)
@@ -0,0 +1 @@
+debian/dnsmasq.runscript name=dnsmasq,logscript,presubj
Index: debian/dnsmasq.runscript/finish
===================================================================
--- debian/dnsmasq.runscript/finish	(nonexistent)
+++ debian/dnsmasq.runscript/finish	(revision 42741)
@@ -0,0 +1,5 @@
+#!/bin/sh -eu
+if [ -x /sbin/resolvconf ] ; then
+	/sbin/resolvconf -d lo.dnsmasq
+fi
+
Index: debian/dnsmasq.runscript/run
===================================================================
--- debian/dnsmasq.runscript/run	(nonexistent)
+++ debian/dnsmasq.runscript/run	(revision 42741)
@@ -0,0 +1,43 @@
+#!/lib/runit/invoke-run
+
+readonly name=dnsmasq
+readonly daemon=/usr/sbin/dnsmasq
+readonly marker=/usr/share/dnsmasq/installed-marker
+
+test -e "${marker}" || exec sv down "${name}"
+test -x "${daemon}" || exec sv down "${name}"
+
+if [ ! "${RESOLV_CONF:-}" ] &&
+   [ "${IGNORE_RESOLVCONF:-}" != "yes" ] &&
+   [ -x /sbin/resolvconf ]
+then
+	RESOLV_CONF=/run/dnsmasq/resolv.conf
+fi
+
+# This tells dnsmasq to ignore DNS requests that don't come from a local network.
+# It's automatically ignored if  --interface --except-interface, --listen-address 
+# or --auth-server exist in the configuration, so for most installations, it will
+# have no effect, but for otherwise-unconfigured installations, it stops dnsmasq
+# from being vulnerable to DNS-reflection attacks.
+
+DNSMASQ_OPTS="${DNSMASQ_OPTS:-} --local-service"
+
+# If the dns-root-data package is installed, then the trust anchors will be 
+# available in $ROOT_DS, in BIND zone-file format. Reformat as dnsmasq
+# --trust-anchor options.
+
+ROOT_DS="/usr/share/dns/root.ds"
+
+if [ -f $ROOT_DS ]; then
+    DNSMASQ_OPTS="$DNSMASQ_OPTS `env LC_ALL=C sed -rne "s/^([.a-zA-Z0-9]+)([[:space:]]+[0-9]+)*([[:space:]]+IN)*[[:space:]]+DS[[:space:]]+/--trust-anchor=\1,/;s/[[:space:]]+/,/gp" $ROOT_DS | tr '\n' ' '`"
+fi
+
+mkdir -p /run/dnsmasq
+chown dnsmasq:nogroup /run/dnsmasq
+[ -x /sbin/restorecon ] && /sbin/restorecon /run/dnsmasq
+exec "${daemon}" \
+	--keep-in-foreground \
+	--log-facility=/dev/stdout \
+	${RESOLV_CONF:+ -r $RESOLV_CONF} \
+	${DNSMASQ_OPTS} \
+	-u dnsmasq
Index: debian/init
===================================================================
--- debian/init	(nonexistent)
+++ debian/init	(revision 42741)
@@ -0,0 +1,325 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:       dnsmasq
+# Required-Start: $network $remote_fs $syslog
+# Required-Stop:  $network $remote_fs $syslog
+# Default-Start:  2 3 4 5
+# Default-Stop:   0 1 6
+# Description:    DHCP and DNS server
+### END INIT INFO
+
+# Don't exit on error status
+set +e
+
+PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
+DAEMON=/usr/sbin/dnsmasq
+NAME=dnsmasq
+DESC="DNS forwarder and DHCP server"
+INSTANCE="${2}"
+
+# Most configuration options in /etc/default/dnsmasq are deprecated
+# but still honoured.
+ENABLED=1
+if [ -r /etc/default/${NAME}${INSTANCE:+.${INSTANCE}} ]; then
+    . /etc/default/${NAME}${INSTANCE:+.${INSTANCE}}
+fi
+
+# Get the system locale, so that messages are in the correct language, and the
+# charset for IDN is correct
+if [ -r /etc/default/locale ]; then
+    . /etc/default/locale
+    export LANG
+fi
+
+# The following test ensures the dnsmasq service is not started, when the
+# package 'dnsmasq' is removed but not purged, even if the dnsmasq-base
+# package is still in place.
+test -e /usr/share/dnsmasq/installed-marker || exit 0
+
+test -x ${DAEMON} || exit 0
+
+# Provide skeleton LSB log functions for backports which don't have LSB functions.
+if [ -f /lib/lsb/init-functions ]; then
+    . /lib/lsb/init-functions
+else
+    log_warning_msg () {
+        echo "${@}."
+    }
+
+    log_success_msg () {
+        echo "${@}."
+    }
+
+    log_daemon_msg () {
+        echo -n "${1}: ${2}"
+    }
+
+    log_end_msg () {
+        if [ "${1}" -eq 0 ]; then
+            echo "."
+        elif [ "${1}" -eq 255 ]; then
+            /bin/echo -e " (warning)."
+        else
+            /bin/echo -e " failed!"
+        fi
+    }
+fi
+
+# RESOLV_CONF:
+# If the resolvconf package is installed then use the resolv conf file
+# that it provides as the default.  Otherwise use /etc/resolv.conf as
+# the default.
+#
+# If IGNORE_RESOLVCONF is set in /etc/default/dnsmasq or an explicit
+# filename is set there then this inhibits the use of the resolvconf-provided
+# information.
+#
+# Note that if the resolvconf package is installed it is not possible to
+# override it just by configuration in /etc/dnsmasq.conf, it is necessary
+# to set IGNORE_RESOLVCONF=yes in /etc/default/dnsmasq.
+
+if [ ! "${RESOLV_CONF}" ] &&
+   [ "${IGNORE_RESOLVCONF}" != "yes" ] &&
+   [ -x /sbin/resolvconf ]
+then
+    RESOLV_CONF=/run/dnsmasq/resolv.conf
+fi
+
+for INTERFACE in ${DNSMASQ_INTERFACE}; do
+    DNSMASQ_INTERFACES="${DNSMASQ_INTERFACES} -i ${INTERFACE}"
+done
+
+for INTERFACE in ${DNSMASQ_EXCEPT}; do
+    DNSMASQ_INTERFACES="${DNSMASQ_INTERFACES} -I ${INTERFACE}"
+done
+
+if [ ! "${DNSMASQ_USER}" ]; then
+   DNSMASQ_USER="dnsmasq"
+fi
+
+# This tells dnsmasq to ignore DNS requests that don't come from a local network.
+# It's automatically ignored if --interface --except-interface, --listen-address
+# or --auth-server exist in the configuration, so for most installations, it will
+# have no effect, but for otherwise-unconfigured installations, it stops dnsmasq
+# from being vulnerable to DNS-reflection attacks.
+
+DNSMASQ_OPTS="${DNSMASQ_OPTS} --local-service"
+
+# If the dns-root-data package is installed, then the trust anchors will be
+# available in ROOT_DS, in BIND zone-file format. Reformat as dnsmasq
+# --trust-anchor options.
+
+ROOT_DS="/usr/share/dns/root.ds"
+
+if [ -f ${ROOT_DS} ]; then
+    DNSMASQ_OPTS="$DNSMASQ_OPTS `env LC_ALL=C sed -rne "s/^([.a-zA-Z0-9]+)([[:space:]]+[0-9]+)*([[:space:]]+IN)*[[:space:]]+DS[[:space:]]+/--trust-anchor=\1,/;s/[[:space:]]+/,/gp" $ROOT_DS | tr '\n' ' '`"
+fi
+
+start()
+{
+    # Return
+    #   0 if daemon has been started
+    #   1 if daemon was already running
+    #   2 if daemon could not be started
+
+    # /run may be volatile, so we need to ensure that
+    # /run/dnsmasq exists here as well as in postinst
+    if [ ! -d /run/dnsmasq ]; then
+        mkdir /run/dnsmasq || { [ -d /run/dnsmasq ] || return 2 ; }
+        chown dnsmasq:nogroup /run/dnsmasq || return 2
+    fi
+    [ -x /sbin/restorecon ] && /sbin/restorecon /run/dnsmasq
+
+    start-stop-daemon --start --quiet --pidfile /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid --exec ${DAEMON} --test > /dev/null || return 1
+    start-stop-daemon --start --quiet --pidfile /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid --exec ${DAEMON} -- \
+        -x /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid \
+        ${MAILHOSTNAME:+ -m ${MAILHOSTNAME}} \
+        ${MAILTARGET:+ -t ${MAILTARGET}} \
+        ${DNSMASQ_USER:+ -u ${DNSMASQ_USER}} \
+        ${DNSMASQ_INTERFACES:+ ${DNSMASQ_INTERFACES}} \
+        ${DHCP_LEASE:+ -l ${DHCP_LEASE}} \
+        ${DOMAIN_SUFFIX:+ -s ${DOMAIN_SUFFIX}} \
+        ${RESOLV_CONF:+ -r ${RESOLV_CONF}} \
+        ${CACHESIZE:+ -c ${CACHESIZE}} \
+        ${CONFIG_DIR:+ -7 ${CONFIG_DIR}} \
+        ${DNSMASQ_OPTS:+ ${DNSMASQ_OPTS}} \
+        || return 2
+}
+
+start_resolvconf()
+{
+# If interface "lo" is explicitly disabled in /etc/default/dnsmasq
+# Then dnsmasq won't be providing local DNS, so don't add it to
+# the resolvconf server set.
+    for interface in ${DNSMASQ_EXCEPT}; do
+        [ ${interface} = lo ] && return
+    done
+
+    # Also skip this if DNS functionality is disabled in /etc/dnsmasq.conf
+    if grep -qs '^port=0' /etc/dnsmasq.conf; then
+        return
+    fi
+
+    if [ -x /sbin/resolvconf ] ; then
+        echo "nameserver 127.0.0.1" | /sbin/resolvconf -a lo.${NAME}${INSTANCE:+.${INSTANCE}}
+    fi
+    return 0
+}
+
+stop()
+{
+    # Return
+    #   0 if daemon has been stopped
+    #   1 if daemon was already stopped
+    #   2 if daemon could not be stopped
+    #   other if a failure occurred
+    start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid --name ${NAME}
+}
+
+stop_resolvconf()
+{
+    if [ -x /sbin/resolvconf ] ; then
+        /sbin/resolvconf -d lo.${NAME}${INSTANCE:+.${INSTANCE}}
+    fi
+    return 0
+}
+
+status()
+{
+    # Return
+    #   0 if daemon is running
+    #   1 if daemon is dead and pid file exists
+    #   3 if daemon is not running
+    #   4 if daemon status is unknown
+    start-stop-daemon --start --quiet --pidfile /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid --exec ${DAEMON} --test > /dev/null
+    case "${?}" in
+      0) [ -e "/run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid" ] && return 1 ; return 3 ;;
+      1) return 0 ;;
+      *) return 4 ;;
+    esac
+}
+
+case "${1}" in
+  start)
+    test "${ENABLED}" != "0" || exit 0
+    log_daemon_msg "Starting ${DESC}" "${NAME}${INSTANCE:+.${INSTANCE}}"
+    start
+    case "${?}" in
+      0)
+        log_end_msg 0
+        start_resolvconf
+        exit 0
+        ;;
+      1)
+        log_success_msg "(already running)"
+        exit 0
+        ;;
+      *)
+        log_end_msg 1
+        exit 1
+        ;;
+    esac
+    ;;
+  stop)
+    stop_resolvconf
+    if [ "${ENABLED}" != "0" ]; then
+        log_daemon_msg "Stopping ${DESC}" "${NAME}${INSTANCE:+.${INSTANCE}}"
+    fi
+    stop
+    RETVAL="${?}"
+    if [ "${ENABLED}" = "0" ]; then
+        case "${RETVAL}" in
+          0) log_daemon_msg "Stopping ${DESC}" "${NAME}${INSTANCE:+.${INSTANCE}}"; log_end_msg 0 ;;
+        esac
+        exit 0
+    fi
+    case "${RETVAL}" in
+      0) log_end_msg 0 ; exit 0 ;;
+      1) log_warning_msg "(not running)" ; exit 0 ;;
+      *) log_end_msg 1; exit 1 ;;
+    esac
+    ;;
+  checkconfig)
+    ${DAEMON} --test ${CONFIG_DIR:+ -7 ${CONFIG_DIR}} ${DNSMASQ_OPTS:+ ${DNSMASQ_OPTS}} >/dev/null 2>&1
+    RETVAL="${?}"
+    exit ${RETVAL}
+    ;;
+  restart|force-reload)
+    test "${ENABLED}" != "0" || exit 1
+    ${DAEMON} --test ${CONFIG_DIR:+ -7 ${CONFIG_DIR}} ${DNSMASQ_OPTS:+ ${DNSMASQ_OPTS}} >/dev/null 2>&1
+    if [ ${?} -ne 0 ]; then
+        NAME="configuration syntax check"
+        RETVAL="2"
+    else
+        stop_resolvconf
+        stop
+        RETVAL="${?}"
+    fi
+    log_daemon_msg "Restarting ${DESC}" "${NAME}${INSTANCE:+.${INSTANCE}}"
+    case "${RETVAL}" in
+      0|1)
+        sleep 2
+        start
+        case "${?}" in
+          0)
+            log_end_msg 0
+            start_resolvconf
+            exit 0
+            ;;
+          *)
+            log_end_msg 1
+            exit 1
+            ;;
+        esac
+        ;;
+      *)
+        log_end_msg 1
+        exit 1
+        ;;
+    esac
+    ;;
+  status)
+    log_daemon_msg "Checking ${DESC}" "${NAME}${INSTANCE:+.${INSTANCE}}"
+    status
+    case "${?}" in
+      0) log_success_msg "(running)" ; exit 0 ;;
+      1) log_success_msg "(dead, pid file exists)" ; exit 1 ;;
+      3) log_success_msg "(not running)" ; exit 3 ;;
+      *) log_success_msg "(unknown)" ; exit 4 ;;
+    esac
+    ;;
+  dump-stats)
+    kill -s USR1 `cat /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid`
+    ;;
+  systemd-start-resolvconf)
+    start_resolvconf
+    ;;
+  systemd-stop-resolvconf)
+    stop_resolvconf
+    ;;
+  systemd-exec)
+    # /run may be volatile, so we need to ensure that
+    # /run/dnsmasq exists here as well as in postinst
+    if [ ! -d /run/dnsmasq ]; then
+        mkdir /run/dnsmasq || { [ -d /run/dnsmasq ] || return 2 ; }
+        chown dnsmasq:nogroup /run/dnsmasq || return 2
+    fi
+    exec ${DAEMON} -x /run/dnsmasq/${NAME}${INSTANCE:+.${INSTANCE}}.pid \
+        ${MAILHOSTNAME:+ -m ${MAILHOSTNAME}} \
+        ${MAILTARGET:+ -t ${MAILTARGET}} \
+        ${DNSMASQ_USER:+ -u ${DNSMASQ_USER}} \
+        ${DNSMASQ_INTERFACES:+ ${DNSMASQ_INTERFACES}} \
+        ${DHCP_LEASE:+ -l ${DHCP_LEASE}} \
+        ${DOMAIN_SUFFIX:+ -s ${DOMAIN_SUFFIX}} \
+        ${RESOLV_CONF:+ -r ${RESOLV_CONF}} \
+        ${CACHESIZE:+ -c ${CACHESIZE}} \
+        ${CONFIG_DIR:+ -7 ${CONFIG_DIR}} \
+        ${DNSMASQ_OPTS:+ ${DNSMASQ_OPTS}}
+    ;;
+  *)
+    echo "Usage: /etc/init.d/${NAME} {start|stop|restart|force-reload|dump-stats|status}" >&2
+    exit 3
+    ;;
+esac
+
+exit 0
Index: debian/insserv
===================================================================
--- debian/insserv	(nonexistent)
+++ debian/insserv	(revision 42741)
@@ -0,0 +1 @@
+$named dnsmasq
Index: debian/installed-marker
===================================================================
--- debian/installed-marker	(nonexistent)
+++ debian/installed-marker	(revision 42741)
@@ -0,0 +1,2 @@
+# This file indicates dnsmasq (and not just dnsmasq-base) is installed.
+# It is an implementation detail of the dnsmasq init script.
Index: debian/lintian-override
===================================================================
--- debian/lintian-override	(nonexistent)
+++ debian/lintian-override	(revision 42741)
@@ -0,0 +1,3 @@
+# dnsmasq-base and dnsmasq-base-lua are mutually exclusive and both
+# provide /usr/share/doc/dnsmasq-base
+dnsmasq-base-lua binary: usr-share-doc-symlink-without-dependency dnsmasq-base
Index: debian/postinst
===================================================================
--- debian/postinst	(nonexistent)
+++ debian/postinst	(revision 42741)
@@ -0,0 +1,38 @@
+#!/bin/sh
+set -e
+
+# Code copied from dh_systemd_enable ----------------------
+# This will only remove masks created by d-s-h on package removal.
+deb-systemd-helper unmask dnsmasq.service >/dev/null || true
+
+# was-enabled defaults to true, so new installations run enable.
+if deb-systemd-helper --quiet was-enabled dnsmasq.service; then
+	# Enables the unit on first installation, creates new
+	# symlinks on upgrades if the unit file has changed.
+	deb-systemd-helper enable dnsmasq.service >/dev/null || true
+else
+	# Update the statefile to add new symlinks (if any), which need to be
+	# cleaned up on purge. Also remove old symlinks.
+	deb-systemd-helper update-state dnsmasq.service >/dev/null || true
+fi
+# End code copied from dh_systemd_enable ------------------
+
+if [ -x /etc/init.d/dnsmasq ]; then
+   update-rc.d dnsmasq defaults 15 85 >/dev/null
+
+   if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ]; then
+      if [ -e /run/dnsmasq/dnsmasq.pid ]; then
+          ACTION=restart
+      else
+          ACTION=start
+      fi
+
+      if [ -x /usr/sbin/invoke-rc.d ] ; then
+         invoke-rc.d dnsmasq $ACTION || true
+      else
+         /etc/init.d/dnsmasq $ACTION || true
+      fi
+   fi
+fi
+
+
Index: debian/postrm
===================================================================
--- debian/postrm	(nonexistent)
+++ debian/postrm	(revision 42741)
@@ -0,0 +1,22 @@
+#!/bin/sh
+set -e
+
+if [ purge = "$1" ]; then
+   update-rc.d dnsmasq remove >/dev/null
+fi
+
+# Code copied from dh_systemd_enable ----------------------
+if [ "$1" = "remove" ]; then
+	if [ -x "/usr/bin/deb-systemd-helper" ]; then
+		deb-systemd-helper mask dnsmasq.service >/dev/null
+	fi
+fi
+
+if [ "$1" = "purge" ]; then
+	if [ -x "/usr/bin/deb-systemd-helper" ]; then
+		deb-systemd-helper purge dnsmasq.service >/dev/null
+		deb-systemd-helper unmask dnsmasq.service >/dev/null
+	fi
+fi
+# End code copied from dh_systemd_enable ------------------
+
Index: debian/prerm
===================================================================
--- debian/prerm	(nonexistent)
+++ debian/prerm	(revision 42741)
@@ -0,0 +1,14 @@
+#!/bin/sh
+set -e
+
+if [ "$1" = "remove" ]; then
+  if [ -x /usr/sbin/invoke-rc.d ] ; then
+      invoke-rc.d dnsmasq stop || true
+  else
+      /etc/init.d/dnsmasq stop || true
+  fi
+fi
+
+exit 0
+
+
Index: debian/readme
===================================================================
--- debian/readme	(nonexistent)
+++ debian/readme	(revision 42741)
@@ -0,0 +1,79 @@
+Notes on configuring dnsmasq as packaged for Debian.
+
+(1) To configure dnsmasq edit /etc/dnsmasq.conf. The file is well
+    commented; see also the dnsmasq.8 man page for explanation of
+    the options. The file /etc/default/dnsmasq also exists but it
+    shouldn't need to be touched in most cases. To set up DHCP
+    options you might need to refer to a copy of RFC 2132. This is 
+    available on Debian systems in the package doc-rfc-std as the file
+    /usr/share/doc/RFC/draft-standard/rfc2132.txt.gz .
+
+(2) Installing the dnsmasq package also creates the directory
+    /etc/dnsmasq.d which is searched by dnsmasq for configuration file
+    fragments. This behaviour can be disabled by editing 
+    /etc/default/dnsmasq.
+
+(3) If the Debian resolvconf package is installed then, regardless
+    of what interface configuration daemons are employed, the list of
+    nameservers to which dnsmasq should forward queries can be found
+    in /var/run/dnsmasq/resolv.conf; also, 127.0.0.1 is listed as the
+    first nameserver address in /etc/resolv.conf. This works using the
+    default configurations of resolvconf and dnsmasq.
+
+(4) In the absence of resolvconf, if you are using dhcpcd then
+    dnsmasq should read the list of nameservers from the automatically
+    generated file /etc/dhcpc/resolv.conf.  You should list 127.0.0.1
+    as the first nameserver address in /etc/resolv.conf.
+
+(5) In the absence of resolvconf, if you are using pppd then
+    dnsmasq should read the list of nameservers from the automatically
+    generated file /etc/ppp/resolv.conf.  You should list 127.0.0.1
+    as the first nameserver address in /etc/resolv.conf.
+
+(6) In the absence of resolvconf, dns-nameservers lines in 
+    /etc/network/interfaces are ignored. If you do not use
+    resolvconf, list 127.0.0.1 as the first nameserver address
+    in /etc/resolv.conf and configure your nameservers using
+    "server=<IP-address>" lines in /etc/dnsmasq.conf.
+
+(7) If you run multiple DNS servers on a single machine, each
+    listening on a different interface, then it is necessary to use 
+    the bind-interfaces option by uncommenting "bind-interfaces" in 
+    /etc/dnsmasq.conf. This option stops dnsmasq from binding the 
+    wildcard address and allows servers listening on port 53 on
+    interfaces not in use by dnsmasq to work. The Debian 
+    libvirt package will add a configuration file in /etc/dnsmasq.d
+    which does this so that the "system" dnsmasq and "private" dnsmasq
+    instances started by libvirt do not clash.
+
+(8) The following options are supported in DEB_BUILD_OPTIONS
+      noopt       : compile without optimisation.
+      nostrip     : don't remove symbols from binary. 
+      nodocs      : omit documentation.
+      notftp      : omit TFTP support.
+      nodhcp      : omit DHCP support.
+      nodhcp6     : omit DHCPv6 support.
+      noscript    : omit lease-change script support.
+      uselua      : provide support for lease-change scripts written
+                    in Lua.
+      noipv6      : omit IPv6 support.
+      nodbus      : omit DBus support.
+      noconntrack : omit connection tracking support. 
+      noipset     : omit IPset support.
+      nortc       : compile alternate mode suitable for systems without an RTC.
+      noi18n      : omit translations and internationalisation support.
+      noidn       : omit international domain name support, must be
+                    combined with noi18n to be effective.
+      gitversion  : set the version of the produced packages from the
+                    git-derived versioning information on the source,
+                    rather than the debian changelog. 
+
+(9) Dnsmasq comes as three packages - dnsmasq-utils, dnsmasq-base and
+    dnsmasq. Dnsmasq-base provides the dnsmasq executable and
+    documentation (including this file). Dnsmasq, which depends on
+    dnsmasq-base, provides the init script and configuration
+    infrastructure. This file assumes that both are installed. It is
+    possible to install only dnsmasq-base and use dnsmasq as a
+    non-"system" daemon. Libvirt, for instance, does this.
+    Dnsmasq-utils provides the utilities dhcp_release and 
+    dhcp_lease_time.
Index: debian/readme.dnsmasq.d
===================================================================
--- debian/readme.dnsmasq.d	(nonexistent)
+++ debian/readme.dnsmasq.d	(revision 42741)
@@ -0,0 +1,7 @@
+# All files in this directory will be read by dnsmasq as 
+# configuration files, except if their names end in 
+# ".dpkg-dist",".dpkg-old" or ".dpkg-new"
+#
+# This can be changed by editing /etc/default/dnsmasq
+
+
Index: debian/resolvconf
===================================================================
--- debian/resolvconf	(nonexistent)
+++ debian/resolvconf	(revision 42741)
@@ -0,0 +1,84 @@
+#!/bin/sh
+#
+# Script to update the resolver list for dnsmasq
+#
+# N.B. Resolvconf may run us even if dnsmasq is not (yet) running.
+# If dnsmasq is installed then we go ahead and update the resolver list
+# in case dnsmasq is started later.
+#
+# Assumption: On entry, PWD contains the resolv.conf-type files.
+#
+# This file is part of the dnsmasq package.
+#
+
+set -e
+
+RUN_DIR="/run/dnsmasq"
+RSLVRLIST_FILE="${RUN_DIR}/resolv.conf"
+TMP_FILE="${RSLVRLIST_FILE}_new.$$"
+MY_NAME_FOR_RESOLVCONF="dnsmasq"
+
+[ -x /usr/sbin/dnsmasq ] || exit 0
+[ -x /lib/resolvconf/list-records ] || exit 1
+
+PATH=/bin:/sbin
+
+report_err() { echo "$0: Error: $*" >&2 ; }
+
+# Stores arguments (minus duplicates) in RSLT, separated by spaces
+# Doesn't work properly if an argument itself contains whitespace
+uniquify()
+{
+	RSLT=""
+	while [ "$1" ] ; do
+		for E in $RSLT ; do
+			[ "$1" = "$E" ] && { shift ; continue 2 ; }
+		done
+		RSLT="${RSLT:+$RSLT }$1"
+		shift
+	done
+}
+
+if [ ! -d "$RUN_DIR" ] && ! mkdir --parents --mode=0755 "$RUN_DIR" ; then
+	report_err "Failed trying to create directory $RUN_DIR"
+	exit 1
+fi
+
+RSLVCNFFILES=""
+for F in $(/lib/resolvconf/list-records --after "lo.$MY_NAME_FOR_RESOLVCONF") ; do
+	case "$F" in
+	    "lo.$MY_NAME_FOR_RESOLVCONF")
+		# Omit own record	 
+		;;
+	    lo.*)
+		# Include no more records after one for a local nameserver
+		RSLVCNFFILES="${RSLVCNFFILES:+$RSLVCNFFILES }$F"
+		break
+		;;
+	  *)
+		RSLVCNFFILES="${RSLVCNFFILES:+$RSLVCNFFILES }$F"
+		;;
+	esac
+done
+
+NMSRVRS=""
+if [ "$RSLVCNFFILES" ] ; then
+	uniquify $(sed -n -e 's/^[[:space:]]*nameserver[[:space:]]\+//p' $RSLVCNFFILES)
+	NMSRVRS="$RSLT"
+fi
+
+# Dnsmasq uses the mtime of $RSLVRLIST_FILE, with a resolution of one second,
+# to detect changes in the file. This means that if a resolvconf update occurs
+# within one second of the previous one then dnsmasq may fail to notice the
+# more recent change. To work around this problem we sleep one second here
+# if necessary in order to ensure that the new mtime is different.
+if [ -f "$RSLVRLIST_FILE" ] && [ "$(ls -go --time-style='+%s' "$RSLVRLIST_FILE" | { read p h s t n ; echo "$t" ; })" = "$(date +%s)" ] ; then
+	sleep 1
+fi
+
+clean_up() { rm -f "$TMP_FILE" ; }
+trap clean_up EXIT
+: >| "$TMP_FILE"
+for N in $NMSRVRS ; do echo "nameserver $N" >> "$TMP_FILE" ; done
+mv -f "$TMP_FILE" "$RSLVRLIST_FILE"
+
Index: debian/resolvconf-package
===================================================================
--- debian/resolvconf-package	(nonexistent)
+++ debian/resolvconf-package	(revision 42741)
@@ -0,0 +1,13 @@
+#!/bin/sh
+# Resolvconf packaging event hook script for the dnsmasq package
+restart_dnsmasq() {
+    if which invoke-rc.d >/dev/null 2>&1 ; then
+        invoke-rc.d dnsmasq restart
+    elif [ -x /etc/init.d/dnsmasq ] ; then
+        /etc/init.d/dnsmasq restart
+    fi
+}
+
+case "$1" in
+  install) restart_dnsmasq ;;
+esac
Index: debian/rules
===================================================================
--- debian/rules	(nonexistent)
+++ debian/rules	(revision 42741)
@@ -0,0 +1,298 @@
+#!/usr/bin/make -f
+# debian/rules file - for dnsmasq.
+# Copyright 2001-2020 by Simon Kelley
+# Based on the sample in the debian hello package which carries the following:
+# Copyright 1994,1995 by Ian Jackson.
+# I hereby give you perpetual unlimited permission to copy,
+# modify and relicense this file, provided that you do not remove
+# my name from the file itself.  (I assert my moral right of
+# paternity under the Copyright, Designs and Patents Act 1988.)
+# This file may have to be extensively modified
+
+package=dnsmasq-base
+
+dpkg_buildflags := DEB_BUILD_MAINT_OPTIONS="hardening=+all,+pie,+bindnow" dpkg-buildflags
+
+CFLAGS = $(shell $(dpkg_buildflags) --get CFLAGS)
+CFLAGS += $(shell $(dpkg_buildflags) --get CPPFLAGS)
+CFLAGS += -Wall -W
+
+LDFLAGS = $(shell $(dpkg_buildflags) --get LDFLAGS)
+
+DEB_COPTS = $(COPTS)
+
+TARGET = install-i18n
+
+DEB_HOST_ARCH_OS := $(shell dpkg-architecture -qDEB_HOST_ARCH_OS)
+DEB_HOST_GNU_TYPE := $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+DEB_BUILD_GNU_TYPE := $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+BUILD_DATE := $(shell dpkg-parsechangelog --show-field Date)
+
+ifeq ($(origin CC),default)
+     CC = $(DEB_HOST_GNU_TYPE)-gcc
+endif
+
+# Support non-cross-builds on systems without gnu-triplet-binaries for pkg-config.
+ifeq ($(DEB_BUILD_GNU_TYPE),$(DEB_HOST_GNU_TYPE))
+     PKG_CONFIG=pkg-config
+else
+     PKG_CONFIG=$(DEB_HOST_GNU_TYPE)-pkg-config	
+endif
+
+# Force package version based on git tags.
+ifneq (,$(filter gitversion,$(DEB_BUILD_OPTIONS)))
+     PACKAGE_VERSION = $(shell bld/get-version `pwd` |  sed 's/test/~&/; s/[a-z]/~&/;  s/-/./g; s/$$/-1/; s/^/-v/';)
+endif
+
+ifeq (,$(filter nodbus,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DHAVE_DBUS
+endif
+
+ifeq (,$(filter noidn, $(DEB_BUILD_OPTIONS)))
+	DEB_COPTS += -DHAVE_LIBIDN2
+endif
+
+ifeq (,$(filter noconntrack,$(DEB_BUILD_OPTIONS)))
+ifeq ($(DEB_HOST_ARCH_OS),linux)
+     DEB_COPTS += -DHAVE_CONNTRACK
+endif
+endif
+
+ifneq (,$(filter noipset,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_IPSET
+endif
+
+ifneq (,$(filter nodhcp6,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_DHCP6
+endif
+
+ifneq (,$(filter noipv6,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_IPV6
+endif
+
+ifneq (,$(filter notftp,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_TFTP
+endif
+
+ifneq (,$(filter nodhcp,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_DHCP
+endif
+
+ifneq (,$(filter noscript,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DNO_SCRIPT
+endif
+
+ifneq (,$(filter nortc,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DHAVE_BROKEN_RTC
+endif
+
+ifneq (,$(filter noi18n,$(DEB_BUILD_OPTIONS)))
+     TARGET = install
+endif
+
+ifneq (,$(filter uselua,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DHAVE_LUASCRIPT
+endif
+
+ifeq (,$(filter nodnssec,$(DEB_BUILD_OPTIONS)))
+     DEB_COPTS += -DHAVE_DNSSEC
+endif
+
+ifneq ($(DEB_HOST_ARCH_OS),linux)
+     # For strlcpy in FreeBSD
+     LDFLAGS += -lbsd
+endif
+
+define build_tree
+	rm -rf $1
+	install -m 755 \
+		-d $1/DEBIAN \
+		-d $1/etc/dbus-1/system.d \
+	        -d $1/usr/share/doc/$(package) \
+		-d $1/usr/share/doc/$(package)/examples \
+		-d $1/usr/share/$(package) \
+	        -d $1/var/lib/misc
+
+endef
+
+define add_docs
+# Need to remove paypal links in Debian Package for policy reasons.
+	sed -e /\<H2\>Donations/Q -e /icon.png/d doc.html -e /favicon.ico/d >$1/usr/share/doc/$(package)/doc.html
+	echo "</BODY>" >>$1/usr/share/doc/$(package)/doc.html 
+	install -m 644 setup.html $1/usr/share/doc/$(package)/.
+	install -m 644 dnsmasq.conf.example $1/usr/share/doc/$(package)/examples/.
+	install -m 644 FAQ $1/usr/share/doc/$(package)/.
+	gzip -9n $1/usr/share/doc/$(package)/FAQ
+	install -m 644 CHANGELOG $1/usr/share/doc/$(package)/changelog
+	gzip -9n $1/usr/share/doc/$(package)/changelog
+	install -m 644 CHANGELOG.archive $1/usr/share/doc/$(package)/changelog.archive
+	gzip -9n $1/usr/share/doc/$(package)/changelog.archive
+	install -m 644 dbus/DBus-interface $1/usr/share/doc/$(package)/.
+	gzip -9n $1/usr/share/doc/$(package)/DBus-interface	
+	install -m 644 debian/systemd_howto $1/usr/share/doc/$(package)/.
+	gzip -9n $1/usr/share/doc/$(package)/systemd_howto
+	gzip -9n $1/usr/share/man/man8/dnsmasq.8
+	for f in $1/usr/share/man/*; do \
+		if [ -f $$f/man8/dnsmasq.8 ]; then \
+                       gzip -9n $$f/man8/dnsmasq.8 ; \
+                fi \
+	done
+endef
+
+define add_files
+	install -m 644 trust-anchors.conf $1/usr/share/$(package)/.
+	install -m 644 debian/dnsmasq-base.conffiles $1/DEBIAN/conffiles
+	install -m 755 debian/dnsmasq-base.postinst $1/DEBIAN/postinst
+	install -m 755 debian/dnsmasq-base.postrm  $1/DEBIAN/postrm
+	install -m 644 debian/changelog $1/usr/share/doc/$(package)/changelog.Debian
+	gzip -9n $1/usr/share/doc/$(package)/changelog.Debian
+	install -m 644 debian/readme $1/usr/share/doc/$(package)/README.Debian
+	install -m 644 debian/copyright $1/usr/share/doc/$(package)/copyright
+	install -m 644 debian/dbus.conf $1/etc/dbus-1/system.d/dnsmasq.conf
+endef
+
+clean:
+	$(checkdir)
+	make BUILDDIR=debian/build/no-lua clean
+	make BUILDDIR=debian/build/lua clean
+	make -C contrib/lease-tools clean
+	rm -rf debian/build debian/trees debian/*~ debian/files debian/substvars debian/utils-substvars
+
+binary-indep:	checkroot
+	$(checkdir)
+	rm -rf debian/trees/daemon
+	install -m 755 \
+	        -d debian/trees/daemon/DEBIAN \
+		-d debian/trees/daemon/usr/share/doc/dnsmasq \
+	        -d debian/trees/daemon/etc/init.d \
+		-d debian/trees/daemon/etc/dnsmasq.d \
+	        -d debian/trees/daemon/etc/resolvconf/update.d \
+		-d debian/trees/daemon/usr/lib/resolvconf/dpkg-event.d \
+		-d debian/trees/daemon/usr/share/dnsmasq \
+	        -d debian/trees/daemon/etc/default \
+		-d debian/trees/daemon/lib/systemd/system \
+		-d debian/trees/daemon/usr/lib/tmpfiles.d \
+                -d debian/trees/daemon/etc/insserv.conf.d
+	install -m 644 debian/conffiles debian/trees/daemon/DEBIAN
+	install -m 755 debian/postinst debian/postrm debian/prerm debian/trees/daemon/DEBIAN
+	rm -f debian/dnsmasq.postinst.debhelper debian/dnsmasq.postrm.debhelper
+	dh_runit -pdnsmasq -Pdebian/trees/daemon
+	cat debian/dnsmasq.postinst.debhelper >> debian/trees/daemon/DEBIAN/postinst
+	cat debian/dnsmasq.postrm.debhelper   >> debian/trees/daemon/DEBIAN/postrm
+	install -m 755 debian/init debian/trees/daemon/etc/init.d/dnsmasq
+	install -m 755 debian/resolvconf debian/trees/daemon/etc/resolvconf/update.d/dnsmasq
+	install -m 755 debian/resolvconf-package debian/trees/daemon/usr/lib/resolvconf/dpkg-event.d/dnsmasq
+	install -m 644 debian/installed-marker debian/trees/daemon/usr/share/dnsmasq
+	install -m 644 debian/default debian/trees/daemon/etc/default/dnsmasq
+	install -m 644 dnsmasq.conf.example debian/trees/daemon/etc/dnsmasq.conf
+	install -m 644 debian/readme.dnsmasq.d debian/trees/daemon/etc/dnsmasq.d/README
+	install -m 644 debian/systemd.service debian/trees/daemon/lib/systemd/system/dnsmasq.service
+	install -m 644 debian/systemd@.service debian/trees/daemon/lib/systemd/system/dnsmasq@.service
+	install -m 644 debian/tmpfiles.conf debian/trees/daemon/usr/lib/tmpfiles.d/dnsmasq.conf
+	install -m 644 debian/insserv debian/trees/daemon/etc/insserv.conf.d/dnsmasq
+	ln -s $(package) debian/trees/daemon/usr/share/doc/dnsmasq
+	cd debian/trees/daemon && find . -type f ! -regex '.*DEBIAN/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -r0 md5sum > DEBIAN/md5sums	
+	dpkg-gencontrol $(PACKAGE_VERSION) -Tdebian/dnsmasq.substvars -pdnsmasq -Pdebian/trees/daemon
+	find debian/trees/daemon -depth -newermt '$(BUILD_DATE)' -print0 | xargs -0r touch --no-dereference --date='$(BUILD_DATE)'
+	chown -R root.root debian/trees/daemon
+	chmod -R g-ws debian/trees/daemon
+	dpkg --build debian/trees/daemon ..
+
+binary-arch:	checkroot 
+	$(call build_tree,debian/trees/base)
+	make $(TARGET) BUILDDIR=debian/build/no-lua PREFIX=/usr DESTDIR=`pwd`/debian/trees/base CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" COPTS="$(DEB_COPTS)" CC=$(CC) PKG_CONFIG=$(PKG_CONFIG)
+ifeq (,$(findstring nodoc,$(DEB_BUILD_OPTIONS)))
+	$(call add_docs,debian/trees/base)
+else	
+	rm -rf debian/trees/base/usr/share/man
+endif
+	$(call add_files,debian/trees/base)
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+	$(DEB_HOST_GNU_TYPE)-strip -R .note -R .comment debian/trees/base/usr/sbin/dnsmasq
+endif
+	cd debian/trees/base && find . -type f ! -regex '.*DEBIAN/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -r0 md5sum > DEBIAN/md5sums
+	dpkg-shlibdeps --warnings=1 debian/trees/base/usr/sbin/dnsmasq
+	dpkg-gencontrol $(PACKAGE_VERSION) -pdnsmasq-base -Pdebian/trees/base
+	find debian/trees/base -depth -newermt '$(BUILD_DATE)' -print0 | xargs -0r touch --no-dereference --date='$(BUILD_DATE)'
+	chown -R root.root debian/trees/base
+	chmod -R g-ws debian/trees/base 
+	dpkg --build debian/trees/base ..
+
+	$(call build_tree,debian/trees/lua-base)
+	make $(TARGET) BUILDDIR=debian/build/lua PREFIX=/usr DESTDIR=`pwd`/debian/trees/lua-base CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" COPTS="-DHAVE_LUASCRIPT $(DEB_COPTS)" CC=$(CC) PKG_CONFIG=$(PKG_CONFIG)
+ifeq (,$(findstring nodoc,$(DEB_BUILD_OPTIONS)))
+	$(call add_docs,debian/trees/lua-base)
+else	
+	rm -rf debian/trees/lua-base/usr/share/man
+endif
+	$(call add_files,debian/trees/lua-base)
+	install -m 755 -d debian/trees/lua-base/usr/share/lintian/overrides
+	install -m 644 debian/lintian-override debian/trees/lua-base/usr/share/lintian/overrides/dnsmasq-base-lua
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+	$(DEB_HOST_GNU_TYPE)-strip -R .note -R .comment debian/trees/lua-base/usr/sbin/dnsmasq
+endif
+	ln -s $(package) debian/trees/lua-base/usr/share/doc/dnsmasq-base-lua
+	cd debian/trees/lua-base && find . -type f ! -regex '.*DEBIAN/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -r0 md5sum > DEBIAN/md5sums
+	dpkg-shlibdeps --warnings=1 debian/trees/lua-base/usr/sbin/dnsmasq
+	dpkg-gencontrol $(PACKAGE_VERSION) -pdnsmasq-base-lua -Pdebian/trees/lua-base
+	find debian/trees/lua-base -depth -newermt '$(BUILD_DATE)' -print0 | xargs -0r touch --no-dereference --date='$(BUILD_DATE)'
+	chown -R root.root debian/trees/lua-base
+	chmod -R g-ws debian/trees/lua-base 
+	dpkg --build debian/trees/lua-base ..
+
+
+ifeq ($(DEB_HOST_ARCH_OS),linux)
+	rm -rf debian/trees/utils
+	install -m 755 -d debian/trees/utils/DEBIAN \
+	               -d debian/trees/utils/usr/bin \
+                       -d debian/trees/utils/usr/share/doc/dnsmasq-utils
+ifeq (,$(findstring nodoc,$(DEB_BUILD_OPTIONS)))
+	install -m 755 -d debian/trees/utils/usr/share/man/man1
+endif
+	make -C contrib/lease-tools PREFIX=/usr DESTDIR=`pwd`/debian/trees/utils CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" COPTS="$(DEB_COPTS)" CC=$(CC) PKG_CONFIG=$(PKG_CONFIG)
+	install -m 755 contrib/lease-tools/dhcp_release debian/trees/utils/usr/bin/dhcp_release
+	install -m 755 contrib/lease-tools/dhcp_release6 debian/trees/utils/usr/bin/dhcp_release6
+	install -m 755 contrib/lease-tools/dhcp_lease_time debian/trees/utils/usr/bin/dhcp_lease_time
+ifeq (,$(findstring nodoc,$(DEB_BUILD_OPTIONS)))
+	install -m 644 contrib/lease-tools/dhcp_release.1 debian/trees/utils/usr/share/man/man1/dhcp_release.1
+	gzip -9n debian/trees/utils/usr/share/man/man1/dhcp_release.1
+	install -m 644 contrib/lease-tools/dhcp_release6.1 debian/trees/utils/usr/share/man/man1/dhcp_release6.1
+	gzip -9n debian/trees/utils/usr/share/man/man1/dhcp_release6.1
+	install -m 644 contrib/lease-tools/dhcp_lease_time.1 debian/trees/utils/usr/share/man/man1/dhcp_lease_time.1
+	gzip -9n debian/trees/utils/usr/share/man/man1/dhcp_lease_time.1
+endif
+	install -m 644 debian/copyright debian/trees/utils/usr/share/doc/dnsmasq-utils/copyright
+	install -m 644 debian/changelog debian/trees/utils/usr/share/doc/dnsmasq-utils/changelog.Debian
+	gzip -9n debian/trees/utils/usr/share/doc/dnsmasq-utils/changelog.Debian
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+	$(DEB_HOST_GNU_TYPE)-strip -R .note -R .comment debian/trees/utils/usr/bin/dhcp_release
+	$(DEB_HOST_GNU_TYPE)-strip -R .note -R .comment debian/trees/utils/usr/bin/dhcp_release6
+	$(DEB_HOST_GNU_TYPE)-strip -R .note -R .comment debian/trees/utils/usr/bin/dhcp_lease_time
+endif	
+	cd debian/trees/utils && find . -type f ! -regex '.*DEBIAN/.*' -printf '%P\0' | LC_ALL=C sort -z | xargs -r0 md5sum > DEBIAN/md5sums
+	dpkg-shlibdeps -Tdebian/utils-substvars debian/trees/utils/usr/bin/dhcp_release debian/trees/utils/usr/bin/dhcp_release6 debian/trees/utils/usr/bin/dhcp_lease_time 
+	dpkg-gencontrol $(PACKAGE_VERSION) -Tdebian/utils-substvars -pdnsmasq-utils -Pdebian/trees/utils
+	find debian/trees/utils -depth -newermt '$(BUILD_DATE)' -print0 | xargs -0r touch --no-dereference --date='$(BUILD_DATE)'
+	chown -R root.root debian/trees/utils
+	chmod -R g-ws debian/trees/utils 
+	dpkg --build debian/trees/utils ..
+endif
+
+define checkdir
+	test -f Makefile -a -f debian/rules
+endef
+
+# Below here is fairly generic really
+
+binary:		binary-arch binary-indep
+
+build:		
+build-arch:
+build-indep:
+
+checkroot:
+	test root = "`whoami`"
+
+.PHONY: binary binary-arch binary-indep clean checkroot
+
+
Index: debian/source/format
===================================================================
--- debian/source/format	(nonexistent)
+++ debian/source/format	(revision 42741)
@@ -0,0 +1 @@
+1.0
Index: debian/systemd.service
===================================================================
--- debian/systemd.service	(nonexistent)
+++ debian/systemd.service	(revision 42741)
@@ -0,0 +1,31 @@
+[Unit]
+Description=dnsmasq - A lightweight DHCP and caching DNS server
+Requires=network.target
+Wants=nss-lookup.target
+Before=nss-lookup.target
+After=network.target
+
+[Service]
+Type=forking
+PIDFile=/run/dnsmasq/dnsmasq.pid
+
+# Test the config file and refuse starting if it is not valid.
+ExecStartPre=/etc/init.d/dnsmasq checkconfig
+
+# We run dnsmasq via the /etc/init.d/dnsmasq script which acts as a
+# wrapper picking up extra configuration files and then execs dnsmasq
+# itself, when called with the "systemd-exec" function.
+ExecStart=/etc/init.d/dnsmasq systemd-exec
+
+# The systemd-*-resolvconf functions configure (and deconfigure)
+# resolvconf to work with the dnsmasq DNS server. They're called like
+# this to get correct error handling (ie don't start-resolvconf if the
+# dnsmasq daemon fails to start).
+ExecStartPost=/etc/init.d/dnsmasq systemd-start-resolvconf
+ExecStop=/etc/init.d/dnsmasq systemd-stop-resolvconf
+
+
+ExecReload=/bin/kill -HUP $MAINPID
+
+[Install]
+WantedBy=multi-user.target
Index: debian/systemd@.service
===================================================================
--- debian/systemd@.service	(nonexistent)
+++ debian/systemd@.service	(revision 42741)
@@ -0,0 +1,31 @@
+[Unit]
+Description=dnsmasq (%i) - A lightweight DHCP and caching DNS server
+Requires=network.target
+Wants=nss-lookup.target
+Before=nss-lookup.target
+After=network.target
+
+[Service]
+Type=forking
+PIDFile=/run/dnsmasq/dnsmasq.%i.pid
+
+# Test the config file and refuse starting if it is not valid.
+ExecStartPre=/etc/init.d/dnsmasq checkconfig "%i"
+
+# We run dnsmasq via the /etc/init.d/dnsmasq script which acts as a
+# wrapper picking up extra configuration files and then execs dnsmasq
+# itself, when called with the "systemd-exec" function.
+ExecStart=/etc/init.d/dnsmasq systemd-exec "%i"
+
+# The systemd-*-resolvconf functions configure (and deconfigure)
+# resolvconf to work with the dnsmasq DNS server. They're called like
+# this to get correct error handling (ie don't start-resolvconf if the
+# dnsmasq daemon fails to start).
+ExecStartPost=/etc/init.d/dnsmasq systemd-start-resolvconf "%i"
+ExecStop=/etc/init.d/dnsmasq systemd-stop-resolvconf "%i"
+
+
+ExecReload=/bin/kill -HUP $MAINPID
+
+[Install]
+WantedBy=multi-user.target
Index: debian/systemd_howto
===================================================================
--- debian/systemd_howto	(nonexistent)
+++ debian/systemd_howto	(revision 42741)
@@ -0,0 +1,41 @@
+HOWTO
+=====
+dnsmasq comes with the possibility to run multiple systemd service instances on the same machine.
+There is the main service which is enabled by default via `systemctl enable dnsmasq.service` and uses the configuration from `/etc/default/dnsmasq`.
+
+Additional service instances can be enabled via `systemctl enable dnsmasq@<instance name>.service` that use the configuration from `/etc/default/dnsmasq.<instance name>`.
+It is recommended to use a separate configuration file and directory for each instance.
+Additionally make sure that all instances use either different ports and/or ip addresses to avoid binding collisions.
+
+Example setup for an instance called "alt"
+#1 File `/etc/dnsmasq.alt.conf` copied from `/etc/dnsmasq.conf`
+#2 Directory `/etc/dnsmasq.alt.d`
+#3 File `/etc/default/dnsmasq.alt` copied from `/etc/default/dnsmasq` with following adaptions:
+   * The options DNSMASQ_OPTS and CONFIG_DIR point to the correct configuration file and directory.
+     DNSMASQ_OPTS="... --conf-file=/etc/dnsmasq.alt.conf ..."
+     CONFIG_DIR=/etc/dnsmasq.alt.d,.dpkg-dist,.dpkg-old,.dpkg-new
+   * The option DNSMASQ_EXCEPT must contain "lo" to avoid that an instance becomes the machine's DNS resolver.
+     DNSMASQ_EXCEPT="lo"
+  * If the additional instance should bind to all IP addresses of a specific interface, e.g. "dnsalt01", then the following addition could be used:
+    DNSMASQ_OPTS="... --bind-dynamic --interface=dnsalt01 ..."
+    Additionally the main instance must be stopped from binding to interfaces that are used by other instances:
+    DNSMASQ_OPTS="... --bind-dynamic --except-interface=dnsalt* ..."
+  * If the additional instance should not use the machine's DNS resolver, normally that's the dnsmasq main instance, as upstream server, then the following addition could be used:
+    IGNORE_RESOLVCONF=yes
+#4 Enable additional instance via `systemctl enable dnsmasq@alt.service`
+#5 Start additional instance without reboot via `systemctl start dnsmasq@alt.service`
+
+
+
+TODO
+====
+#1 - Found shortcoming on 2019-03-10
+Only the option DNSMASQ_EXCEPT="lo" avoids that an DNS instance will be set as the machine's DNS resolver.
+This may interfere with the wish to run an additional instance on a different port on the localhost addresses.
+My suggestion in the initial Debian report [1] was to specify an explicit variable for this.
+
+[1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=914305#5
+
+
+#2 - Preferred configuration way
+Should the variables DNSMASQ_INTERFACE and DNSMASQ_EXCEPT be used instead of --interface and --except-interface?  (while "lo" still has to be in DNSMASQ_EXCEPT as of now)
Index: debian/tmpfiles.conf
===================================================================
--- debian/tmpfiles.conf	(nonexistent)
+++ debian/tmpfiles.conf	(revision 42741)
@@ -0,0 +1 @@
+d /run/dnsmasq 755 dnsmasq nogroup

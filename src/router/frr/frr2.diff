diff -urpN frr-frr-5.0.1/.clang-format frr-frr-6.0/.clang-format
--- frr-frr-5.0.1/.clang-format	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/.clang-format	2018-10-08 14:32:57.000000000 +0200
@@ -43,6 +43,7 @@ ForEachMacros:
   - SPLAY_FOREACH
   - FOR_ALL_INTERFACES
   - FOR_ALL_INTERFACES_ADDRESSES
+  - JSON_FOREACH
   # zebra
   - RE_DEST_FOREACH_ROUTE
   - RE_DEST_FOREACH_ROUTE_SAFE
diff -urpN frr-frr-5.0.1/COMMUNITY.md frr-frr-6.0/COMMUNITY.md
--- frr-frr-5.0.1/COMMUNITY.md	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/COMMUNITY.md	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-Moved to doc/developer/workflow.rst
diff -urpN frr-frr-5.0.1/Makefile.am frr-frr-6.0/Makefile.am
--- frr-frr-5.0.1/Makefile.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -3,11 +3,9 @@
 AUTOMAKE_OPTIONS = subdir-objects 1.12
 include common.am
 
-AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
+AM_CPPFLAGS += -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	      -I$(top_builddir) -I$(top_builddir)/include -I$(top_builddir)/lib
-AM_CFLAGS = $(WERROR)
-VERSION_TYPE := $(shell if echo $(VERSION) | grep -q '^[0-9\.]*$$'; then echo RELEASE ; else echo DEV ; fi)
-DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\" -DCONFDATE=$(CONFDATE) -DVERSION_TYPE_$(VERSION_TYPE)
+DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\" -DCONFDATE=$(CONFDATE)
 LIBCAP = @LIBCAP@
 
 EXTRA_DIST =
@@ -57,6 +55,8 @@ include eigrpd/subdir.am
 include sharpd/subdir.am
 include pimd/subdir.am
 include pbrd/subdir.am
+include staticd/subdir.am
+include bfdd/subdir.am
 
 SUBDIRS = . @LIBRFP@ @RFPTEST@ \
 	 @BGPD@ \
@@ -83,10 +83,7 @@ rc_SCRIPTS = \
 endif
 
 EXTRA_DIST += \
-	REPORTING-BUGS \
-	SERVICES \
 	aclocal.m4 \
-	update-autotools \
 	m4/README.txt \
 	\
 	python/clidef.py \
@@ -119,3 +116,23 @@ noinst_HEADERS += defaults.h
 
 indent:
 	tools/indent.py `find sharpd bgpd eigrpd include isisd lib nhrpd ospf6d ospfd pimd qpb ripd vtysh zebra -name '*.[ch]' | grep -v include/linux`
+
+if HAVE_GCOV
+
+coverage: check
+	@ find . -name '*.o' -exec gcov {} \;
+
+yorn:
+	@ echo "OK to upload coverage to https://coverage.io [y/N]:"
+	@ read yn; test "$$yn" = "y"
+
+upload-check-coverage:
+	@ if [ "x${COMMIT}" = "x" ]; then echo "COMMIT required"; exit 1; fi
+	@ if [ "x${TOKEN}" = "x" ]; then echo "TOKEN required"; exit 1; fi
+	curl -s https://codecov.io/bash | bash -s - -C ${COMMIT} -t ${TOKEN}
+
+force-check-coverage: coverage upload-check-coverage
+
+check-coverage: coverage yorn upload-check-coverage
+
+endif
diff -urpN frr-frr-5.0.1/README frr-frr-6.0/README
--- frr-frr-5.0.1/README	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/README	2018-10-08 14:32:57.000000000 +0200
@@ -5,11 +5,11 @@ Currently FRRouting supports BGP4, BGP4+
 IS-IS, PIM-SM/MSDP, LDP and Babel as well as very early support for EIGRP and
 NHRP.
 
-See the file REPORTING-BUGS to report bugs.
+See doc/user/bugs.rst for information on how to report bugs.
 
-See COMMUNITY.md for information on contributing.
+See doc/developer/workflow.rst for information on contributing.
 
-Free RRRouting is free software. See the file COPYING for copying conditions.
+See the file COPYING for copying conditions.
 
 Public email discussion can be found at https://lists.frrouting.org/listinfo
 
diff -urpN frr-frr-5.0.1/README.NetBSD frr-frr-6.0/README.NetBSD
--- frr-frr-5.0.1/README.NetBSD	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/README.NetBSD	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-#!/bin/sh
-
-# This file is helpful for building FRR from cvs on NetBSD, and
-# probably on any system using pkgsrc.  
-# One should have readline installed already (pkgsrc/devel/readline).
-
-MAKE=make
-# FRR is currently documented not to require GNU make, but sometimes
-# BSD make fails.  Enable this if statement as a workaround.
-if false; then
-    MAKE=gmake
-    echo "WARNING: using gmake to work around nonportable makefiles"
-fi
-
-# Use /usr/frr to be independent, and /usr/pkg to overwrite pkgsrc.
-PREFIX=/usr/pkg
-
-case $1 in
-
-    build)
-	# Omitted because it is now default:
-	#   --enable-opaque-lsa
-	./bootstrap.sh
-	LDFLAGS="-L/usr/pkg/lib -R/usr/pkg/lib" CPPFLAGS="-I/usr/pkg/include" \
-    	./configure --prefix=${PREFIX} \
-	    --sysconfdir=/etc/zebra --localstatedir=/var/run/zebra \
-	    --enable-exampledir=${PREFIX}/share/examples/zebra \
-	    --enable-pkgsrcrcdir=${PREFIX}/etc/rc.d \
-	    --enable-vtysh
-	${MAKE}
-	;;
-
-    install)
-    	${MAKE} install
-	;;
-
-    clean)
-    	${MAKE} clean
-	;;
-
-    *)
-	echo "Usage: README.NetBSD (build|install|clean)"
-	exit 1
-	;;
-
-esac
diff -urpN frr-frr-5.0.1/REPORTING-BUGS frr-frr-6.0/REPORTING-BUGS
--- frr-frr-5.0.1/REPORTING-BUGS	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/REPORTING-BUGS	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-This file describes the procedure for reporting FRRouting bugs. You are not
-obliged to follow this format, but it would be great help for FRRouting developers
-if you report a bug as described below.
-
-Bugs submitted with woefully incomplete information may be summarily
-closed.  Submitters of bugs against old versions may be asked to
-retest against the latest release.  Submitters may be asked for
-additional information.  Bugs may be closed after 30 days of
-non-response to requests to reconfirm or supply additional
-information.
-
-Report bugs on Github Issue Tracker at 
-    https://github.com/frrouting/frr/issues
-
-Please supply the following information:
-1. Your FRRouting version or if it is from git then the  commit reference.
-   Please try to report bugs against git master or the latest release.
-2. FRR daemons you run e.g. bgpd or ripd and full name of your OS. Any
-   specific options you compiled FRR with. 
-3. Problem description. Copy and paste relative commands and their output to
-   describe your network setup e.g. "zebra>show ip route".
-   Please, also give your simple network layout and output of relative OS
-   commands (e.g., ifconfig (BSD) or ip (Linux)).
-4. All FRR configuration files you use. If you don't want to publish your
-   network numbers change 2 middle bytes in IPv4 address to be XXX (e.g.
-   192.XXX.XXX.32/24). Similar could be done with IPv6.
-5. If any FRR daemon core dumped, please, supply stack trace using the
-   following commands: host> gdb exec_file core_file , (gdb) bt .
-6. Run all FRR daemons with full debugging on (see documentation on
-   debugging) and send _only_ part of logs which are relative to your problem.
-7. If the problem is difficult to reproduce please send a shell script to
-   reproduce it.
-8. Patches, workarounds, fixes are always welcome.
-
-Thank You.
diff -urpN frr-frr-5.0.1/SERVICES frr-frr-6.0/SERVICES
--- frr-frr-5.0.1/SERVICES	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/SERVICES	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-# As long as this software is in alpha testing it is not yet included
-# in /etc/services files. This means that you may need to add the following
-# lines into your /etc/services file on your hosts.
-# 
-# --- Please add this to your /etc/services ---
-
-#
-# GNU Zebra services
-#
-
-zebrasrv	2600/tcp
-zebra		2601/tcp
-ripd		2602/tcp
-ripng		2603/tcp
-ospfd		2604/tcp
-bgpd		2605/tcp
-ospf6d		2606/tcp
-ospfapi		2607/tcp
-isisd		2608/tcp
-babeld		2609/tcp
-nhrpd		2610/tcp
-pimd		2611/tcp
-ldpd		2612/tcp
-eigrpd		2613/tcp
diff -urpN frr-frr-5.0.1/alpine/APKBUILD.in frr-frr-6.0/alpine/APKBUILD.in
--- frr-frr-5.0.1/alpine/APKBUILD.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/alpine/APKBUILD.in	2018-10-08 14:32:57.000000000 +0200
@@ -20,6 +20,7 @@ makedepends="ncurses-dev net-snmp-dev ga
     patch pax-utils pcre perl pkgconf python2 python2-dev readline
     readline-dev sqlite-libs squashfs-tools sudo tar texinfo xorriso xz-libs
     py-sphinx"
+checkdepends="pytest py-setuptools"
 install="$pkgname.pre-install $pkgname.pre-deinstall $pkgname.post-deinstall"
 subpackages="$pkgname-dev $pkgname-doc $pkgname-dbg"
 source="$pkgname-$pkgver.tar.gz docker-start daemons daemons.conf"
@@ -45,13 +46,19 @@ build() {
 		--enable-multipath=64 \
 		--enable-vty-group=frrvty \
 		--enable-user=$_user \
-		--enable-group=$_user || return 1
-	make || return 1
+		--enable-group=$_user
+	make
+}
+
+check() {
+	cd "$builddir"
+
+	make -j 1 check
 }
 
 package() {
 	cd "$builddir"
-	make DESTDIR="$pkgdir" install || return 1
+	make DESTDIR="$pkgdir" install
 
 	install -Dm755 "$srcdir"/docker-start "$pkgdir"$_sbindir
 	install -Dm644 "$srcdir"/daemons "$pkgdir"$_sysconfdir
diff -urpN frr-frr-5.0.1/babeld/babel_errors.c frr-frr-6.0/babeld/babel_errors.c
--- frr-frr-5.0.1/babeld/babel_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/babeld/babel_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,61 @@
+/*
+ * Babel-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "babel_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_babel_err[] = {
+	{
+		.code = BABEL_ERR_MEMORY,
+		.title = "BABEL Memory Errors",
+		.description = "Babel has failed to allocate memory, the system is about to run out of memory",
+		.suggestion = "Find the process that is causing memory shortages, remediate that process and restart FRR"
+	},
+	{
+		.code = BABEL_ERR_PACKET,
+		.title = "BABEL Packet Error",
+		.description = "Babel has detected a packet encode/decode problem",
+		.suggestion = "Collect relevant log files and file an Issue"
+	},
+	{
+		.code = BABEL_ERR_CONFIG,
+		.title = "BABEL Configuration Error",
+		.description = "Babel has detected a configuration error of some sort",
+		.suggestion = "Ensure that the configuration is correct"
+	},
+	{
+		.code = BABEL_ERR_ROUTE,
+		.title = "BABEL Route Error",
+		.description = "Babel has detected a routing error and has an inconsistent state",
+		.suggestion = "Gather data for filing an Issue and then restart FRR"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void babel_error_init(void)
+{
+	log_ref_add(ferr_babel_err);
+}
diff -urpN frr-frr-5.0.1/babeld/babel_errors.h frr-frr-6.0/babeld/babel_errors.h
--- frr-frr-5.0.1/babeld/babel_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/babeld/babel_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Babel-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __BABEL_ERRORS_H__
+#define __BABEL_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum babel_log_refs {
+	BABEL_ERR_MEMORY = BABEL_FERR_START,
+	BABEL_ERR_PACKET,
+	BABEL_ERR_CONFIG,
+	BABEL_ERR_ROUTE,
+};
+
+extern void babel_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/babeld/babel_interface.c frr-frr-6.0/babeld/babel_interface.c
--- frr-frr-5.0.1/babeld/babel_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/babel_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@ THE SOFTWARE.
 #include "prefix.h"
 #include "vector.h"
 #include "distribute.h"
+#include "lib_errors.h"
 
 #include "babel_main.h"
 #include "util.h"
@@ -39,6 +40,7 @@ THE SOFTWARE.
 #include "route.h"
 #include "xroute.h"
 #include "babel_memory.h"
+#include "babel_errors.h"
 
 #define IS_ENABLE(ifp) (babel_enable_if_lookup(ifp->name) >= 0)
 
@@ -167,7 +169,7 @@ babel_interface_address_add (int cmd, st
         if (babel_ifp->ipv4 == NULL) {
             babel_ifp->ipv4 = malloc(4);
             if (babel_ifp->ipv4 == NULL) {
-                zlog_err("not einough memory");
+                flog_err(BABEL_ERR_MEMORY, "not enough memory");
             } else {
                 memcpy(babel_ifp->ipv4, &prefix->u.prefix4, 4);
             }
@@ -707,7 +709,7 @@ interface_recalculate(struct interface *
     tmp = babel_ifp->sendbuf;
     babel_ifp->sendbuf = realloc(babel_ifp->sendbuf, babel_ifp->bufsize);
     if(babel_ifp->sendbuf == NULL) {
-        zlog_err("Couldn't reallocate sendbuf.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't reallocate sendbuf.");
         free(tmp);
         babel_ifp->bufsize = 0;
         return -1;
@@ -727,8 +729,9 @@ interface_recalculate(struct interface *
     rc = setsockopt(protocol_socket, IPPROTO_IPV6, IPV6_JOIN_GROUP,
                     (char*)&mreq, sizeof(mreq));
     if(rc < 0) {
-        zlog_err("setsockopt(IPV6_JOIN_GROUP) on interface '%s': %s",
-                 ifp->name, safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SOCKET,
+		  "setsockopt(IPV6_JOIN_GROUP) on interface '%s': %s",
+                  ifp->name, safe_strerror(errno));
         /* This is probably due to a missing link-local address,
          so down this interface, and wait until the main loop
          tries to up it again. */
@@ -790,8 +793,9 @@ interface_reset(struct interface *ifp)
         rc = setsockopt(protocol_socket, IPPROTO_IPV6, IPV6_LEAVE_GROUP,
                         (char*)&mreq, sizeof(mreq));
         if(rc < 0)
-            zlog_err("setsockopt(IPV6_LEAVE_GROUP) on interface '%s': %s",
-                     ifp->name, safe_strerror(errno));
+            flog_err_sys(LIB_ERR_SOCKET,
+		      "setsockopt(IPV6_LEAVE_GROUP) on interface '%s': %s",
+                      ifp->name, safe_strerror(errno));
     }
 
     update_interface_metric(ifp);
@@ -1001,7 +1005,7 @@ show_babel_routes_sub(struct babel_route
                 break;
             if(k > 0)
                 channels[j++] = ',';
-            snprintf(channels + j, 100 - j, "%d", route->channels[k]);
+            snprintf(channels + j, 100 - j, "%u", route->channels[k]);
             j = strlen(channels);
         }
         snprintf(channels + j, 100 - j, ")");
@@ -1056,7 +1060,7 @@ DEFUN (show_babel_route,
         }
         route_stream_done(routes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     xroutes = xroute_stream();
     if(xroutes) {
@@ -1068,7 +1072,7 @@ DEFUN (show_babel_route,
         }
         xroute_stream_done(xroutes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     return CMD_SUCCESS;
 }
@@ -1103,7 +1107,7 @@ DEFUN (show_babel_route_prefix,
         }
         route_stream_done(routes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     xroutes = xroute_stream();
     if(xroutes) {
@@ -1115,7 +1119,7 @@ DEFUN (show_babel_route_prefix,
         }
         xroute_stream_done(xroutes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     return CMD_SUCCESS;
 }
@@ -1161,7 +1165,7 @@ DEFUN (show_babel_route_addr,
         }
         route_stream_done(routes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     xroutes = xroute_stream();
     if(xroutes) {
@@ -1173,7 +1177,7 @@ DEFUN (show_babel_route_addr,
         }
         xroute_stream_done(xroutes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     return CMD_SUCCESS;
 }
@@ -1220,7 +1224,7 @@ DEFUN (show_babel_route_addr6,
         }
         route_stream_done(routes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     xroutes = xroute_stream();
     if(xroutes) {
@@ -1232,7 +1236,7 @@ DEFUN (show_babel_route_addr6,
         }
         xroute_stream_done(xroutes);
     } else {
-        zlog_err("Couldn't allocate route stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
     }
     return CMD_SUCCESS;
 }
diff -urpN frr-frr-5.0.1/babeld/babel_main.c frr-frr-6.0/babeld/babel_main.c
--- frr-frr-5.0.1/babeld/babel_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/babel_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@ THE SOFTWARE.
 #include "vty.h"
 #include "memory.h"
 #include "libfrr.h"
+#include "lib_errors.h"
 
 #include "babel_main.h"
 #include "babeld.h"
@@ -45,6 +46,7 @@ THE SOFTWARE.
 #include "message.h"
 #include "resend.h"
 #include "babel_zebra.h"
+#include "babel_errors.h"
 
 static void babel_fail(void);
 static void babel_init_random(void);
@@ -151,7 +153,7 @@ main(int argc, char **argv)
 
     frr_preinit (&babeld_di, argc, argv);
     frr_opt_add ("", longopts, "");
-  
+
     babel_init_random();
 
     /* set the Babel's default link-local multicast address and Babel's port */
@@ -181,9 +183,7 @@ main(int argc, char **argv)
     master = frr_init ();
 
     /* Library inits. */
-    zprivs_init (&babeld_privs);
-    cmd_init (1);
-    vty_init (master);
+    babel_error_init();
 
     resend_delay = BABEL_DEFAULT_RESEND_DELAY;
     change_smoothing_half_life(BABEL_DEFAULT_SMOOTHING_HALF_LIFE);
@@ -196,9 +196,6 @@ main(int argc, char **argv)
     /* this replace kernel_setup && kernel_setup_socket */
     babelz_zebra_init ();
 
-    /* Get zebra configuration file. */
-    vty_read_config (babeld_di.config_file, babel_config_default);
-
     /* init buffer */
     rc = resize_receive_buffer(1500);
     if(rc < 0)
@@ -228,7 +225,8 @@ babel_init_random(void)
 
     rc = read_random_bytes(&seed, sizeof(seed));
     if(rc < 0) {
-        zlog_err("read(random): %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "read(random): %s",
+		  safe_strerror(errno));
         seed = 42;
     }
 
@@ -248,13 +246,14 @@ babel_replace_by_null(int fd)
 
     fd_null = open("/dev/null", O_RDONLY);
     if(fd_null < 0) {
-        zlog_err("open(null): %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "open(null): %s", safe_strerror(errno));
         exit(1);
     }
 
     rc = dup2(fd_null, fd);
     if(rc < 0) {
-        zlog_err("dup2(null, 0): %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "dup2(null, 0): %s",
+		  safe_strerror(errno));
         exit(1);
     }
 
@@ -273,10 +272,12 @@ babel_load_state_file(void)
 
     fd = open(state_file, O_RDONLY);
     if(fd < 0 && errno != ENOENT)
-        zlog_err("open(babel-state: %s)", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "open(babel-state: %s)",
+		  safe_strerror(errno));
     rc = unlink(state_file);
     if(fd >= 0 && rc < 0) {
-        zlog_err("unlink(babel-state): %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "unlink(babel-state): %s",
+		  safe_strerror(errno));
         /* If we couldn't unlink it, it's probably stale. */
         goto fini;
     }
@@ -287,7 +288,8 @@ babel_load_state_file(void)
         long t;
         rc = read(fd, buf, 99);
         if(rc < 0) {
-            zlog_err("read(babel-state): %s", safe_strerror(errno));
+            flog_err_sys(LIB_ERR_SYSTEM_CALL, "read(babel-state): %s",
+		      safe_strerror(errno));
         } else {
             buf[rc] = '\0';
             rc = sscanf(buf, "%99s %d %ld\n", buf2, &s, &t);
@@ -295,7 +297,7 @@ babel_load_state_file(void)
                 unsigned char sid[8];
                 rc = parse_eui64(buf2, sid);
                 if(rc < 0) {
-                    zlog_err("Couldn't parse babel-state.");
+                    flog_err(BABEL_ERR_CONFIG, "Couldn't parse babel-state.");
                 } else {
                     struct timeval realnow;
                     debugf(BABEL_DEBUG_COMMON,
@@ -305,12 +307,13 @@ babel_load_state_file(void)
                     if(memcmp(sid, myid, 8) == 0)
                         myseqno = seqno_plus(s, 1);
                     else
-                        zlog_err("ID mismatch in babel-state. id=%s; old=%s",
+                        flog_err(BABEL_ERR_CONFIG,
+				 "ID mismatch in babel-state. id=%s; old=%s",
                                  format_eui64(myid),
                                  format_eui64(sid));
                 }
             } else {
-                zlog_err("Couldn't parse babel-state.");
+                flog_err(BABEL_ERR_CONFIG, "Couldn't parse babel-state.");
             }
         }
         goto fini;
@@ -350,7 +353,8 @@ babel_save_state_file(void)
     debugf(BABEL_DEBUG_COMMON, "Save state file.");
     fd = open(state_file, O_WRONLY | O_TRUNC | O_CREAT, 0644);
     if(fd < 0) {
-        zlog_err("creat(babel-state): %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SYSTEM_CALL, "creat(babel-state): %s",
+		  safe_strerror(errno));
         unlink(state_file);
     } else {
         struct timeval realnow;
@@ -360,12 +364,13 @@ babel_save_state_file(void)
                       format_eui64(myid), (int)myseqno,
                       (long)realnow.tv_sec);
         if(rc < 0 || rc >= 100) {
-            zlog_err("write(babel-state): overflow.");
+            flog_err(BABEL_ERR_CONFIG, "write(babel-state): overflow.");
             unlink(state_file);
         } else {
             rc = write(fd, buf, rc);
             if(rc < 0) {
-                zlog_err("write(babel-state): %s", safe_strerror(errno));
+                flog_err(BABEL_ERR_CONFIG, "write(babel-state): %s",
+			  safe_strerror(errno));
                 unlink(state_file);
             }
             fsync(fd);
diff -urpN frr-frr-5.0.1/babeld/babeld.c frr-frr-6.0/babeld/babeld.c
--- frr-frr-5.0.1/babeld/babeld.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/babeld.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,6 +29,7 @@ THE SOFTWARE.
 #include "prefix.h"
 #include "filter.h"
 #include "plist.h"
+#include "lib_errors.h"
 
 #include "babel_main.h"
 #include "babeld.h"
@@ -43,6 +44,7 @@ THE SOFTWARE.
 #include "babel_filter.h"
 #include "babel_zebra.h"
 #include "babel_memory.h"
+#include "babel_errors.h"
 
 static int babel_init_routing_process(struct thread *thread);
 static void babel_get_myid(void);
@@ -143,7 +145,8 @@ babel_create_routing_process (void)
     /* Make socket for Babel protocol. */
     protocol_socket = babel_socket(protocol_port);
     if (protocol_socket < 0) {
-        zlog_err("Couldn't create link local socket: %s", safe_strerror(errno));
+        flog_err_sys(LIB_ERR_SOCKET, "Couldn't create link local socket: %s",
+		  safe_strerror(errno));
         goto fail;
     }
 
@@ -176,7 +179,7 @@ babel_read_protocol (struct thread *thre
                     (struct sockaddr*)&sin6, sizeof(sin6));
     if(rc < 0) {
         if(errno != EAGAIN && errno != EINTR) {
-            zlog_err("recv: %s", safe_strerror(errno));
+            flog_err_sys(LIB_ERR_SOCKET, "recv: %s", safe_strerror(errno));
         }
     } else {
         FOR_ALL_INTERFACES(vrf, ifp) {
@@ -252,11 +255,13 @@ babel_get_myid(void)
         return;
     }
 
-    zlog_err("Warning: couldn't find router id -- using random value.");
+    flog_err(BABEL_ERR_CONFIG,
+	      "Warning: couldn't find router id -- using random value.");
 
     rc = read_random_bytes(myid, 8);
     if(rc < 0) {
-        zlog_err("read(random): %s (cannot assign an ID)",safe_strerror(errno));
+        flog_err(BABEL_ERR_CONFIG, "read(random): %s (cannot assign an ID)",
+		  safe_strerror(errno));
         exit(1);
     }
     /* Clear group and global bits */
@@ -514,7 +519,8 @@ resize_receive_buffer(int size)
     if(receive_buffer == NULL) {
         receive_buffer = malloc(size);
         if(receive_buffer == NULL) {
-            zlog_err("malloc(receive_buffer): %s", safe_strerror(errno));
+            flog_err(BABEL_ERR_MEMORY, "malloc(receive_buffer): %s",
+		      safe_strerror(errno));
             return -1;
         }
         receive_buffer_size = size;
@@ -522,7 +528,8 @@ resize_receive_buffer(int size)
         unsigned char *new;
         new = realloc(receive_buffer, size);
         if(new == NULL) {
-            zlog_err("realloc(receive_buffer): %s", safe_strerror(errno));
+            flog_err(BABEL_ERR_MEMORY, "realloc(receive_buffer): %s",
+		      safe_strerror(errno));
             return -1;
         }
         receive_buffer = new;
diff -urpN frr-frr-5.0.1/babeld/kernel.c frr-frr-6.0/babeld/kernel.c
--- frr-frr-5.0.1/babeld/kernel.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/kernel.c	2018-10-08 14:32:57.000000000 +0200
@@ -73,9 +73,9 @@ kernel_interface_wireless(struct interfa
 }
 
 int
-kernel_route(int operation, const unsigned char *pref, unsigned short plen,
-             const unsigned char *gate, int ifindex, unsigned int metric,
-             const unsigned char *newgate, int newifindex,
+kernel_route(enum babel_kernel_routes operation, const unsigned char *pref,
+	     unsigned short plen, const unsigned char *gate, int ifindex,
+	     unsigned int metric, const unsigned char *newgate, int newifindex,
              unsigned int newmetric)
 {
     int rc;
@@ -116,12 +116,9 @@ kernel_route(int operation, const unsign
                              newmetric);
             return rc;
             break;
-        default:
-            zlog_err("this should never happen (false value - kernel_route)");
-            assert(0);
-            exit(1);
-            break;
     }
+
+    return 0;
 }
 
 static int
diff -urpN frr-frr-5.0.1/babeld/kernel.h frr-frr-6.0/babeld/kernel.h
--- frr-frr-5.0.1/babeld/kernel.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/kernel.h	2018-10-08 14:32:57.000000000 +0200
@@ -29,17 +29,19 @@ THE SOFTWARE.
 
 #define KERNEL_INFINITY 0xFFFF
 
-#define ROUTE_FLUSH 0
-#define ROUTE_ADD 1
-#define ROUTE_MODIFY 2
+enum babel_kernel_routes {
+    ROUTE_FLUSH,
+    ROUTE_ADD,
+    ROUTE_MODIFY,
+};
 
 int kernel_interface_operational(struct interface *interface);
 int kernel_interface_mtu(struct interface *interface);
 int kernel_interface_wireless(struct interface *interface);
-int kernel_route(int operation, const unsigned char *dest, unsigned short plen,
-                 const unsigned char *gate, int ifindex, unsigned int metric,
-                 const unsigned char *newgate, int newifindex,
-                 unsigned int newmetric);
+int kernel_route(enum babel_kernel_routes operation, const unsigned char *dest,
+		 unsigned short plen, const unsigned char *gate, int ifindex,
+		 unsigned int metric, const unsigned char *newgate,
+		 int newifindex, unsigned int newmetric);
 int if_eui64(int ifindex, unsigned char *eui);
 int gettime(struct timeval *tv);
 int read_random_bytes(void *buf, size_t len);
diff -urpN frr-frr-5.0.1/babeld/message.c frr-frr-6.0/babeld/message.c
--- frr-frr-5.0.1/babeld/message.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/message.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@ THE SOFTWARE.
 #include "message.h"
 #include "kernel.h"
 #include "babel_main.h"
+#include "babel_errors.h"
 
 static unsigned char packet_header[4] = {42, 2};
 
@@ -140,12 +141,12 @@ parse_update_subtlv(const unsigned char
         }
 
         if(i + 1 > alen) {
-            zlog_err("Received truncated attributes.");
+            flog_err(BABEL_ERR_PACKET, "Received truncated attributes.");
             return;
         }
         len = a[i + 1];
         if(i + len > alen) {
-            zlog_err("Received truncated attributes.");
+            flog_err(BABEL_ERR_PACKET, "Received truncated attributes.");
             return;
         }
 
@@ -153,13 +154,14 @@ parse_update_subtlv(const unsigned char
             /* Nothing. */
         } else if(type == SUBTLV_DIVERSITY) {
             if(len > DIVERSITY_HOPS) {
-                zlog_err("Received overlong channel information (%d > %d).n",
-                         len, DIVERSITY_HOPS);
+                flog_err(BABEL_ERR_PACKET,
+			  "Received overlong channel information (%d > %d).n",
+                          len, DIVERSITY_HOPS);
                 len = DIVERSITY_HOPS;
             }
             if(memchr(a + i + 2, 0, len) != NULL) {
                 /* 0 is reserved. */
-                zlog_err("Channel information contains 0!");
+                flog_err(BABEL_ERR_PACKET, "Channel information contains 0!");
                 return;
             }
             memset(channels, 0, DIVERSITY_HOPS);
@@ -187,12 +189,14 @@ parse_hello_subtlv(const unsigned char *
         }
 
         if(i + 1 > alen) {
-            zlog_err("Received truncated sub-TLV on Hello message.");
+            flog_err(BABEL_ERR_PACKET,
+		      "Received truncated sub-TLV on Hello message.");
             return -1;
         }
         len = a[i + 1];
         if(i + len > alen) {
-            zlog_err("Received truncated sub-TLV on Hello message.");
+            flog_err(BABEL_ERR_PACKET,
+		      "Received truncated sub-TLV on Hello message.");
             return -1;
         }
 
@@ -203,7 +207,8 @@ parse_hello_subtlv(const unsigned char *
                 DO_NTOHL(*hello_send_us, a + i + 2);
                 ret = 1;
             } else {
-                zlog_err("Received incorrect RTT sub-TLV on Hello message.");
+                flog_err(BABEL_ERR_PACKET,
+			  "Received incorrect RTT sub-TLV on Hello message.");
             }
         } else {
             debugf(BABEL_DEBUG_COMMON,
@@ -230,12 +235,14 @@ parse_ihu_subtlv(const unsigned char *a,
         }
 
         if(i + 1 > alen) {
-            zlog_err("Received truncated sub-TLV on IHU message.");
+            flog_err(BABEL_ERR_PACKET,
+		      "Received truncated sub-TLV on IHU message.");
             return -1;
         }
         len = a[i + 1];
         if(i + len > alen) {
-            zlog_err("Received truncated sub-TLV on IHU message.");
+            flog_err(BABEL_ERR_PACKET,
+		      "Received truncated sub-TLV on IHU message.");
             return -1;
         }
 
@@ -248,7 +255,8 @@ parse_ihu_subtlv(const unsigned char *a,
                 ret = 1;
             }
             else {
-                zlog_err("Received incorrect RTT sub-TLV on IHU message.");
+                flog_err(BABEL_ERR_PACKET,
+			  "Received incorrect RTT sub-TLV on IHU message.");
             }
         } else {
             debugf(BABEL_DEBUG_COMMON,
@@ -337,27 +345,29 @@ parse_packet(const unsigned char *from,
     }
 
     if(!linklocal(from)) {
-        zlog_err("Received packet from non-local address %s.",
-                 format_address(from));
+        flog_err(BABEL_ERR_PACKET,
+		  "Received packet from non-local address %s.",
+                  format_address(from));
         return;
     }
 
     if (babel_packet_examin (packet, packetlen)) {
-        zlog_err("Received malformed packet on %s from %s.",
-                 ifp->name, format_address(from));
+        flog_err(BABEL_ERR_PACKET,
+		  "Received malformed packet on %s from %s.",
+                  ifp->name, format_address(from));
         return;
     }
 
     neigh = find_neighbour(from, ifp);
     if(neigh == NULL) {
-        zlog_err("Couldn't allocate neighbour.");
+        flog_err(BABEL_ERR_PACKET, "Couldn't allocate neighbour.");
         return;
     }
 
     DO_NTOHS(bodylen, packet + 2);
 
     if(bodylen + 4 > packetlen) {
-        zlog_err("Received truncated packet (%d + 4 > %d).",
+        flog_err(BABEL_ERR_PACKET, "Received truncated packet (%d + 4 > %d).",
                  bodylen, packetlen);
         bodylen = packetlen - 4;
     }
@@ -506,7 +516,8 @@ parse_packet(const unsigned char *from,
                 have_router_id = 1;
             }
             if(!have_router_id && message[2] != 0) {
-                zlog_err("Received prefix with no router id.");
+                flog_err(BABEL_ERR_PACKET,
+			  "Received prefix with no router id.");
                 goto fail;
             }
             debugf(BABEL_DEBUG_COMMON,"Received update%s%s for %s from %s on %s.",
@@ -517,7 +528,8 @@ parse_packet(const unsigned char *from,
 
             if(message[2] == 0) {
                 if(metric < 0xFFFF) {
-                    zlog_err("Received wildcard update with finite metric.");
+                    flog_err(BABEL_ERR_PACKET,
+			      "Received wildcard update with finite metric.");
                     goto done;
                 }
                 retract_neighbour_routes(neigh);
@@ -609,8 +621,9 @@ parse_packet(const unsigned char *from,
         continue;
 
     fail:
-        zlog_err("Couldn't parse packet (%d, %d) from %s on %s.",
-                 message[0], message[1], format_address(from), ifp->name);
+        flog_err(BABEL_ERR_PACKET,
+		  "Couldn't parse packet (%d, %d) from %s on %s.",
+                  message[0], message[1], format_address(from), ifp->name);
         goto done;
     }
 
@@ -662,7 +675,7 @@ static int
 check_bucket(struct interface *ifp)
 {
     babel_interface_nfo *babel_ifp = babel_get_if_nfo(ifp);
-    if(babel_ifp->bucket <= 0) {
+    if(babel_ifp->bucket == 0) {
         int seconds = babel_now.tv_sec - babel_ifp->bucket_time;
         if(seconds > 0) {
             babel_ifp->bucket = MIN(BUCKET_TOKENS_MAX,
@@ -697,7 +710,7 @@ fill_rtt_message(struct interface *ifp)
             DO_HTONL(babel_ifp->sendbuf + babel_ifp->buffered_hello + 10, time);
             return 1;
         } else {
-            zlog_err("No space left for timestamp sub-TLV "
+            flog_err(BABEL_ERR_PACKET, "No space left for timestamp sub-TLV "
                      "(this shouldn't happen)");
             return -1;
         }
@@ -732,10 +745,11 @@ flushbuf(struct interface *ifp)
                             babel_ifp->sendbuf, babel_ifp->buffered,
                             (struct sockaddr*)&sin6, sizeof(sin6));
             if(rc < 0)
-                zlog_err("send: %s", safe_strerror(errno));
+                flog_err(BABEL_ERR_PACKET, "send: %s", safe_strerror(errno));
         } else {
-            zlog_err("Warning: bucket full, dropping packet to %s.",
-                     ifp->name);
+            flog_err(BABEL_ERR_PACKET,
+		      "Warning: bucket full, dropping packet to %s.",
+                      ifp->name);
         }
     }
     VALGRIND_MAKE_MEM_UNDEFINED(babel_ifp->sendbuf, babel_ifp->bufsize);
@@ -856,7 +870,8 @@ start_unicast_message(struct neighbour *
     if(!unicast_buffer)
         unicast_buffer = malloc(UNICAST_BUFSIZE);
     if(!unicast_buffer) {
-        zlog_err("malloc(unicast_buffer): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_MEMORY, "malloc(unicast_buffer): %s",
+		  safe_strerror(errno));
         return -1;
     }
 
@@ -992,11 +1007,13 @@ flush_unicast(int dofree)
                         unicast_buffer, unicast_buffered,
                         (struct sockaddr*)&sin6, sizeof(sin6));
         if(rc < 0)
-            zlog_err("send(unicast): %s", safe_strerror(errno));
+            flog_err(BABEL_ERR_PACKET, "send(unicast): %s",
+		      safe_strerror(errno));
     } else {
-        zlog_err("Warning: bucket full, dropping unicast packet to %s if %s.",
-                 format_address(unicast_neighbour->address),
-                 unicast_neighbour->ifp->name);
+        flog_err(BABEL_ERR_PACKET,
+		  "Warning: bucket full, dropping unicast packet to %s if %s.",
+                  format_address(unicast_neighbour->address),
+                  unicast_neighbour->ifp->name);
     }
 
  done:
@@ -1301,7 +1318,8 @@ buffer_update(struct interface *ifp,
     again:
         babel_ifp->buffered_updates = malloc(n *sizeof(struct buffered_update));
         if(babel_ifp->buffered_updates == NULL) {
-            zlog_err("malloc(buffered_updates): %s", safe_strerror(errno));
+            flog_err(BABEL_ERR_MEMORY, "malloc(buffered_updates): %s",
+		      safe_strerror(errno));
             if(n > 4) {
                 /* Try again with a tiny buffer. */
                 n = 4;
@@ -1364,7 +1382,7 @@ send_update(struct interface *ifp, int u
             }
             route_stream_done(routes);
         } else {
-            zlog_err("Couldn't allocate route stream.");
+            flog_err(BABEL_ERR_MEMORY, "Couldn't allocate route stream.");
         }
         set_timeout(&babel_ifp->update_timeout, babel_ifp->update_interval);
         babel_ifp->last_update_time = babel_now.tv_sec;
@@ -1442,7 +1460,7 @@ send_self_update(struct interface *ifp)
         }
         xroute_stream_done(xroutes);
     } else {
-        zlog_err("Couldn't allocate xroute stream.");
+        flog_err(BABEL_ERR_MEMORY, "Couldn't allocate xroute stream.");
     }
 }
 
diff -urpN frr-frr-5.0.1/babeld/neighbour.c frr-frr-6.0/babeld/neighbour.c
--- frr-frr-5.0.1/babeld/neighbour.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/neighbour.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@ THE SOFTWARE.
 #include "route.h"
 #include "message.h"
 #include "resend.h"
+#include "babel_errors.h"
 
 struct neighbour *neighs = NULL;
 
@@ -89,7 +90,8 @@ find_neighbour(const unsigned char *addr
 
     neigh = malloc(sizeof(struct neighbour));
     if(neigh == NULL) {
-        zlog_err("malloc(neighbour): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_MEMORY, "malloc(neighbour): %s",
+		  safe_strerror(errno));
         return NULL;
     }
 
@@ -120,7 +122,7 @@ update_neighbour(struct neighbour *neigh
     int rc = 0;
 
     if(hello < 0) {
-        if(neigh->hello_interval <= 0)
+        if(neigh->hello_interval == 0)
             return rc;
         missed_hellos =
             ((int)timeval_minus_msec(&babel_now, &neigh->hello_time) -
diff -urpN frr-frr-5.0.1/babeld/route.c frr-frr-6.0/babeld/route.c
--- frr-frr-5.0.1/babeld/route.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/route.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,13 +34,14 @@ THE SOFTWARE.
 #include "xroute.h"
 #include "message.h"
 #include "resend.h"
+#include "babel_errors.h"
 
 static void consider_route(struct babel_route *route);
 
 struct babel_route **routes = NULL;
 static int route_slots = 0, max_route_slots = 0;
 int kernel_metric = 0;
-int diversity_kind = DIVERSITY_NONE;
+enum babel_diversity diversity_kind = DIVERSITY_NONE;
 int diversity_factor = BABEL_DEFAULT_DIVERSITY_FACTOR;
 int keep_unfeasible = 0;
 
@@ -398,15 +399,16 @@ install_route(struct babel_route *route)
         return;
 
     if(!route_feasible(route))
-        zlog_err("WARNING: installing unfeasible route "
-                 "(this shouldn't happen).");
+        flog_err(BABEL_ERR_ROUTE, "WARNING: installing unfeasible route "
+                  "(this shouldn't happen).");
 
     i = find_route_slot(route->src->prefix, route->src->plen, NULL);
     assert(i >= 0 && i < route_slots);
 
     if(routes[i] != route && routes[i]->installed) {
-        zlog_err("WARNING: attempting to install duplicate route "
-                 "(this shouldn't happen).");
+        flog_err(BABEL_ERR_ROUTE,
+		  "WARNING: attempting to install duplicate route "
+                  "(this shouldn't happen).");
         return;
     }
 
@@ -416,7 +418,8 @@ install_route(struct babel_route *route)
                       metric_to_kernel(route_metric(route)), NULL, 0, 0);
     if(rc < 0) {
         int save = errno;
-        zlog_err("kernel_route(ADD): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_ROUTE, "kernel_route(ADD): %s",
+		  safe_strerror(errno));
         if(save != EEXIST)
             return;
     }
@@ -438,7 +441,8 @@ uninstall_route(struct babel_route *rout
                       route->neigh->ifp->ifindex,
                       metric_to_kernel(route_metric(route)), NULL, 0, 0);
     if(rc < 0)
-        zlog_err("kernel_route(FLUSH): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_ROUTE, "kernel_route(FLUSH): %s",
+		  safe_strerror(errno));
 
     route->installed = 0;
 }
@@ -461,8 +465,8 @@ switch_routes(struct babel_route *old, s
         return;
 
     if(!route_feasible(new))
-        zlog_err("WARNING: switching to unfeasible route "
-                 "(this shouldn't happen).");
+        flog_err(BABEL_ERR_ROUTE, "WARNING: switching to unfeasible route "
+                  "(this shouldn't happen).");
 
     rc = kernel_route(ROUTE_MODIFY, old->src->prefix, old->src->plen,
                       old->nexthop, old->neigh->ifp->ifindex,
@@ -470,7 +474,8 @@ switch_routes(struct babel_route *old, s
                       new->nexthop, new->neigh->ifp->ifindex,
                       metric_to_kernel(route_metric(new)));
     if(rc < 0) {
-        zlog_err("kernel_route(MODIFY): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_ROUTE, "kernel_route(MODIFY): %s",
+		  safe_strerror(errno));
         return;
     }
 
@@ -498,7 +503,8 @@ change_route_metric(struct babel_route *
                           route->nexthop, route->neigh->ifp->ifindex,
                           new);
         if(rc < 0) {
-            zlog_err("kernel_route(MODIFY metric): %s", safe_strerror(errno));
+            flog_err(BABEL_ERR_ROUTE, "kernel_route(MODIFY metric): %s",
+		      safe_strerror(errno));
             return;
         }
     }
@@ -581,10 +587,9 @@ route_interferes(struct babel_route *rou
             }
         }
         return 0;
-    default:
-        zlog_err("Unknown kind of diversity.");
-        return 1;
     }
+
+    return 1;
 }
 
 int
@@ -793,7 +798,7 @@ update_route(const unsigned char *router
         return NULL;
 
     if(martian_prefix(prefix, plen)) {
-        zlog_err("Rejecting martian route to %s through %s.",
+        flog_err(BABEL_ERR_ROUTE, "Rejecting martian route to %s through %s.",
                  format_prefix(prefix, plen), format_address(nexthop));
         return NULL;
     }
@@ -901,7 +906,7 @@ update_route(const unsigned char *router
         route->next = NULL;
         new_route = insert_route(route);
         if(new_route == NULL) {
-            zlog_err("Couldn't insert route.");
+            flog_err(BABEL_ERR_ROUTE, "Couldn't insert route.");
             free(route);
             return NULL;
         }
diff -urpN frr-frr-5.0.1/babeld/route.h frr-frr-6.0/babeld/route.h
--- frr-frr-5.0.1/babeld/route.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/route.h	2018-10-08 14:32:57.000000000 +0200
@@ -27,10 +27,12 @@ THE SOFTWARE.
 #include "babel_interface.h"
 #include "source.h"
 
-#define DIVERSITY_NONE 0
-#define DIVERSITY_INTERFACE_1 1
-#define DIVERSITY_CHANNEL_1 2
-#define DIVERSITY_CHANNEL 3
+enum babel_diversity {
+    DIVERSITY_NONE,
+    DIVERSITY_INTERFACE_1,
+    DIVERSITY_CHANNEL_1,
+    DIVERSITY_CHANNEL,
+};
 
 #define DIVERSITY_HOPS 8
 
@@ -55,7 +57,8 @@ struct route_stream;
 
 extern struct babel_route **routes;
 extern int kernel_metric;
-extern int diversity_kind, diversity_factor;
+extern enum babel_diversity diversity_kind;
+extern int diversity_factor;
 extern int keep_unfeasible;
 extern int smoothing_half_life;
 
diff -urpN frr-frr-5.0.1/babeld/source.c frr-frr-6.0/babeld/source.c
--- frr-frr-5.0.1/babeld/source.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/source.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@ THE SOFTWARE.
 #include "source.h"
 #include "babel_interface.h"
 #include "route.h"
+#include "babel_errors.h"
 
 struct source *srcs = NULL;
 
@@ -58,7 +59,7 @@ find_source(const unsigned char *id, con
 
     src = malloc(sizeof(struct source));
     if(src == NULL) {
-        zlog_err("malloc(source): %s", safe_strerror(errno));
+        flog_err(BABEL_ERR_MEMORY, "malloc(source): %s", safe_strerror(errno));
         return NULL;
     }
 
diff -urpN frr-frr-5.0.1/babeld/subdir.am frr-frr-6.0/babeld/subdir.am
--- frr-frr-5.0.1/babeld/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -9,6 +9,7 @@ dist_examples_DATA += babeld/babeld.conf
 endif
 
 babeld_libbabel_a_SOURCES = \
+	babeld/babel_errors.c \
 	babeld/babel_filter.c \
 	babeld/babel_interface.c \
 	babeld/babel_memory.c \
@@ -26,6 +27,7 @@ babeld_libbabel_a_SOURCES = \
 	# end
 
 noinst_HEADERS += \
+	babeld/babel_errors.h \
 	babeld/babel_filter.h \
 	babeld/babel_interface.h \
 	babeld/babel_main.h \
diff -urpN frr-frr-5.0.1/babeld/util.c frr-frr-6.0/babeld/util.c
--- frr-frr-5.0.1/babeld/util.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/babeld/util.c	2018-10-08 14:32:57.000000000 +0200
@@ -303,7 +303,7 @@ format_thousands(unsigned int value)
     static char buf[4][15];
     static int i = 0;
     i = (i + 1) % 4;
-    snprintf(buf[i], 15, "%d.%.3d", value / 1000, value % 1000);
+    snprintf(buf[i], 15, "%u.%.3u", value / 1000, value % 1000);
     return buf[i];
 }
 
diff -urpN frr-frr-5.0.1/bfdd/.gitignore frr-frr-6.0/bfdd/.gitignore
--- frr-frr-5.0.1/bfdd/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,3 @@
+# ignore binary files
+*.a
+bfdd
diff -urpN frr-frr-5.0.1/bfdd/bfd.c frr-frr-6.0/bfdd/bfd.c
--- frr-frr-5.0.1/bfdd/bfd.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,1298 @@
+/*********************************************************************
+ * Copyright 2013 Cumulus Networks, LLC.  All rights reserved.
+ * Copyright 2014,2015,2016,2017 Cumulus Networks, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * bfd.c: implements the BFD protocol.
+ *
+ * Authors
+ * -------
+ * Shrijeet Mukherjee [shm@cumulusnetworks.com]
+ * Kanna Rajagopal [kanna@cumulusnetworks.com]
+ * Radhika Mahankali [Radhika@cumulusnetworks.com]
+ */
+
+#include <zebra.h>
+
+#include "lib/jhash.h"
+
+#include "bfd.h"
+
+DEFINE_QOBJ_TYPE(bfd_session);
+
+/*
+ * Prototypes
+ */
+static uint32_t ptm_bfd_gen_ID(void);
+static void ptm_bfd_echo_xmt_TO(struct bfd_session *bfd);
+static void bfd_session_free(struct bfd_session *bs);
+static struct bfd_session *bfd_session_new(int sd);
+static struct bfd_session *bfd_find_disc(struct sockaddr_any *sa,
+					 uint32_t ldisc);
+static int bfd_session_update(struct bfd_session *bs, struct bfd_peer_cfg *bpc);
+static const char *get_diag_str(int diag);
+
+
+/*
+ * Functions
+ */
+struct bfd_session *bs_peer_find(struct bfd_peer_cfg *bpc)
+{
+	struct bfd_session *bs;
+	struct peer_label *pl;
+	struct bfd_mhop_key mhop;
+	struct bfd_shop_key shop;
+
+	/* Try to find label first. */
+	if (bpc->bpc_has_label) {
+		pl = pl_find(bpc->bpc_label);
+		if (pl != NULL) {
+			bs = pl->pl_bs;
+			return bs;
+		}
+	}
+
+	/* Otherwise fallback to peer/local hash lookup. */
+	if (bpc->bpc_mhop) {
+		memset(&mhop, 0, sizeof(mhop));
+		mhop.peer = bpc->bpc_peer;
+		mhop.local = bpc->bpc_local;
+		if (bpc->bpc_has_vrfname)
+			strlcpy(mhop.vrf_name, bpc->bpc_vrfname,
+				sizeof(mhop.vrf_name));
+
+		bs = bfd_mhop_lookup(mhop);
+	} else {
+		memset(&shop, 0, sizeof(shop));
+		shop.peer = bpc->bpc_peer;
+		if (!bpc->bpc_has_vxlan && bpc->bpc_has_localif)
+			strlcpy(shop.port_name, bpc->bpc_localif,
+				sizeof(shop.port_name));
+
+		bs = bfd_shop_lookup(shop);
+	}
+
+	return bs;
+}
+
+static uint32_t ptm_bfd_gen_ID(void)
+{
+	static uint32_t sessionID = 1;
+
+	return (sessionID++);
+}
+
+void ptm_bfd_start_xmt_timer(struct bfd_session *bfd, bool is_echo)
+{
+	uint64_t jitter, xmt_TO;
+	int maxpercent;
+
+	xmt_TO = is_echo ? bfd->echo_xmt_TO : bfd->xmt_TO;
+
+	/*
+	 * From section 6.5.2: trasmit interval should be randomly jittered
+	 * between
+	 * 75% and 100% of nominal value, unless detect_mult is 1, then should
+	 * be
+	 * between 75% and 90%.
+	 */
+	maxpercent = (bfd->detect_mult == 1) ? 16 : 26;
+	jitter = (xmt_TO * (75 + (random() % maxpercent))) / 100;
+	/* XXX remove that division above */
+
+	if (is_echo)
+		bfd_echo_xmttimer_update(bfd, jitter);
+	else
+		bfd_xmttimer_update(bfd, jitter);
+}
+
+static void ptm_bfd_echo_xmt_TO(struct bfd_session *bfd)
+{
+	/* Send the scheduled echo  packet */
+	ptm_bfd_echo_snd(bfd);
+
+	/* Restart the timer for next time */
+	ptm_bfd_start_xmt_timer(bfd, true);
+}
+
+void ptm_bfd_xmt_TO(struct bfd_session *bfd, int fbit)
+{
+	/* Send the scheduled control packet */
+	ptm_bfd_snd(bfd, fbit);
+
+	/* Restart the timer for next time */
+	ptm_bfd_start_xmt_timer(bfd, false);
+}
+
+void ptm_bfd_echo_stop(struct bfd_session *bfd, int polling)
+{
+	bfd->echo_xmt_TO = 0;
+	bfd->echo_detect_TO = 0;
+	BFD_UNSET_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE);
+
+	bfd_echo_xmttimer_delete(bfd);
+	bfd_echo_recvtimer_delete(bfd);
+
+	if (polling) {
+		bfd->polling = polling;
+		bfd->new_timers.desired_min_tx = bfd->up_min_tx;
+		bfd->new_timers.required_min_rx = bfd->timers.required_min_rx;
+		ptm_bfd_snd(bfd, 0);
+	}
+}
+
+void ptm_bfd_echo_start(struct bfd_session *bfd)
+{
+	bfd->echo_detect_TO = (bfd->remote_detect_mult * bfd->echo_xmt_TO);
+	ptm_bfd_echo_xmt_TO(bfd);
+
+	bfd->polling = 1;
+	bfd->new_timers.desired_min_tx = bfd->up_min_tx;
+	bfd->new_timers.required_min_rx = bfd->timers.required_min_rx;
+	ptm_bfd_snd(bfd, 0);
+}
+
+void ptm_bfd_ses_up(struct bfd_session *bfd)
+{
+	int old_state = bfd->ses_state;
+
+	bfd->local_diag = 0;
+	bfd->ses_state = PTM_BFD_UP;
+	bfd->polling = 1;
+	monotime(&bfd->uptime);
+
+	/* If the peer is capable to receiving Echo pkts */
+	if (bfd->echo_xmt_TO && !BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_MH)) {
+		ptm_bfd_echo_start(bfd);
+	} else {
+		bfd->new_timers.desired_min_tx = bfd->up_min_tx;
+		bfd->new_timers.required_min_rx = bfd->timers.required_min_rx;
+		ptm_bfd_snd(bfd, 0);
+	}
+
+	control_notify(bfd);
+
+	if (old_state != bfd->ses_state) {
+		bfd->stats.session_up++;
+		log_info("state-change: [%s] %s -> %s", bs_to_string(bfd),
+			 state_list[old_state].str,
+			 state_list[bfd->ses_state].str);
+	}
+}
+
+void ptm_bfd_ses_dn(struct bfd_session *bfd, uint8_t diag)
+{
+	int old_state = bfd->ses_state;
+
+	bfd->local_diag = diag;
+	bfd->discrs.remote_discr = 0;
+	bfd->ses_state = PTM_BFD_DOWN;
+	bfd->polling = 0;
+	bfd->demand_mode = 0;
+	monotime(&bfd->downtime);
+
+	ptm_bfd_snd(bfd, 0);
+
+	/* only signal clients when going from up->down state */
+	if (old_state == PTM_BFD_UP)
+		control_notify(bfd);
+
+	/* Stop echo packet transmission if they are active */
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE))
+		ptm_bfd_echo_stop(bfd, 0);
+
+	if (old_state != bfd->ses_state) {
+		bfd->stats.session_down++;
+		log_info("state-change: [%s] %s -> %s reason:%s",
+			 bs_to_string(bfd), state_list[old_state].str,
+			 state_list[bfd->ses_state].str,
+			 get_diag_str(bfd->local_diag));
+	}
+}
+
+static int ptm_bfd_get_vrf_name(char *port_name, char *vrf_name)
+{
+	struct bfd_iface *iface;
+	struct bfd_vrf *vrf;
+
+	if ((port_name == NULL) || (vrf_name == NULL))
+		return -1;
+
+	iface = bfd_iface_lookup(port_name);
+	if (iface) {
+		vrf = bfd_vrf_lookup(iface->vrf_id);
+		if (vrf) {
+			strlcpy(vrf_name, vrf->name, sizeof(vrf->name));
+			return 0;
+		}
+	}
+	return -1;
+}
+
+static struct bfd_session *bfd_find_disc(struct sockaddr_any *sa,
+					 uint32_t ldisc)
+{
+	struct bfd_session *bs;
+
+	bs = bfd_id_lookup(ldisc);
+	if (bs == NULL)
+		return NULL;
+
+	/* Remove unused fields. */
+	switch (sa->sa_sin.sin_family) {
+	case AF_INET:
+		sa->sa_sin.sin_port = 0;
+		if (memcmp(sa, &bs->shop.peer, sizeof(sa->sa_sin)) == 0)
+			return bs;
+		break;
+	case AF_INET6:
+		sa->sa_sin6.sin6_port = 0;
+		if (memcmp(sa, &bs->shop.peer, sizeof(sa->sa_sin6)) == 0)
+			return bs;
+		break;
+	}
+
+	return NULL;
+}
+
+struct bfd_session *ptm_bfd_sess_find(struct bfd_pkt *cp, char *port_name,
+				      struct sockaddr_any *peer,
+				      struct sockaddr_any *local,
+				      char *vrf_name, bool is_mhop)
+{
+	struct bfd_session *l_bfd = NULL;
+	struct bfd_mhop_key mhop;
+	struct bfd_shop_key shop;
+	char vrf_buf[MAXNAMELEN];
+
+	/* Find our session using the ID signaled by the remote end. */
+	if (cp->discrs.remote_discr)
+		return bfd_find_disc(peer, ntohl(cp->discrs.remote_discr));
+
+	/* Search for session without using discriminator. */
+	if (is_mhop) {
+		memset(&mhop, 0, sizeof(mhop));
+		mhop.peer = *peer;
+		mhop.local = *local;
+		if (vrf_name && vrf_name[0]) {
+			strlcpy(mhop.vrf_name, vrf_name, sizeof(mhop.vrf_name));
+		} else if (port_name && port_name[0]) {
+			memset(vrf_buf, 0, sizeof(vrf_buf));
+			if (ptm_bfd_get_vrf_name(port_name, vrf_buf) != -1)
+				strlcpy(mhop.vrf_name, vrf_buf,
+					sizeof(mhop.vrf_name));
+		}
+
+		l_bfd = bfd_mhop_lookup(mhop);
+	} else {
+		memset(&shop, 0, sizeof(shop));
+		shop.peer = *peer;
+		if (port_name && port_name[0])
+			strlcpy(shop.port_name, port_name,
+				sizeof(shop.port_name));
+
+		l_bfd = bfd_shop_lookup(shop);
+	}
+
+	/* XXX maybe remoteDiscr should be checked for remoteHeard cases. */
+	return l_bfd;
+}
+
+#if 0  /* TODO VxLAN Support */
+static void
+_update_vxlan_sess_parms(struct bfd_session *bfd, bfd_sess_parms *sess_parms)
+{
+	struct bfd_session_vxlan_info *vxlan_info = &bfd->vxlan_info;
+	bfd_parms_list *parms = &sess_parms->parms;
+
+	vxlan_info->vnid = parms->vnid;
+	vxlan_info->check_tnl_key = parms->check_tnl_key;
+	vxlan_info->forwarding_if_rx = parms->forwarding_if_rx;
+	vxlan_info->cpath_down = parms->cpath_down;
+	vxlan_info->decay_min_rx = parms->decay_min_rx;
+
+	inet_aton(parms->local_dst_ip, &vxlan_info->local_dst_ip);
+	inet_aton(parms->remote_dst_ip, &vxlan_info->peer_dst_ip);
+
+	memcpy(vxlan_info->local_dst_mac, parms->local_dst_mac, ETH_ALEN);
+	memcpy(vxlan_info->peer_dst_mac, parms->remote_dst_mac, ETH_ALEN);
+
+	/* The interface may change for Vxlan BFD sessions, so update
+	 * the local mac and ifindex
+	 */
+	bfd->ifindex = sess_parms->ifindex;
+	memcpy(bfd->local_mac, sess_parms->local_mac, sizeof(bfd->local_mac));
+}
+#endif /* VxLAN support */
+
+int bfd_xmt_cb(struct thread *t)
+{
+	struct bfd_session *bs = THREAD_ARG(t);
+
+	ptm_bfd_xmt_TO(bs, 0);
+
+	return 0;
+}
+
+int bfd_echo_xmt_cb(struct thread *t)
+{
+	struct bfd_session *bs = THREAD_ARG(t);
+
+	ptm_bfd_echo_xmt_TO(bs);
+
+	return 0;
+}
+
+/* Was ptm_bfd_detect_TO() */
+int bfd_recvtimer_cb(struct thread *t)
+{
+	struct bfd_session *bs = THREAD_ARG(t);
+
+	switch (bs->ses_state) {
+	case PTM_BFD_INIT:
+	case PTM_BFD_UP:
+		ptm_bfd_ses_dn(bs, BFD_DIAGDETECTTIME);
+		bfd_recvtimer_update(bs);
+		break;
+
+	default:
+		/* Second detect time expiration, zero remote discr (section
+		 * 6.5.1)
+		 */
+		bs->discrs.remote_discr = 0;
+		break;
+	}
+
+	return 0;
+}
+
+/* Was ptm_bfd_echo_detect_TO() */
+int bfd_echo_recvtimer_cb(struct thread *t)
+{
+	struct bfd_session *bs = THREAD_ARG(t);
+
+	switch (bs->ses_state) {
+	case PTM_BFD_INIT:
+	case PTM_BFD_UP:
+		ptm_bfd_ses_dn(bs, BFD_DIAGDETECTTIME);
+		break;
+	}
+
+	return 0;
+}
+
+static struct bfd_session *bfd_session_new(int sd)
+{
+	struct bfd_session *bs;
+
+	bs = XCALLOC(MTYPE_BFDD_CONFIG, sizeof(*bs));
+	if (bs == NULL)
+		return NULL;
+
+	QOBJ_REG(bs, bfd_session);
+
+	bs->up_min_tx = BFD_DEFDESIREDMINTX;
+	bs->timers.required_min_rx = BFD_DEFREQUIREDMINRX;
+	bs->timers.required_min_echo = BFD_DEF_REQ_MIN_ECHO;
+	bs->detect_mult = BFD_DEFDETECTMULT;
+	bs->mh_ttl = BFD_DEF_MHOP_TTL;
+
+	bs->sock = sd;
+	monotime(&bs->uptime);
+	bs->downtime = bs->uptime;
+
+	return bs;
+}
+
+int bfd_session_update_label(struct bfd_session *bs, const char *nlabel)
+{
+	/* New label treatment:
+	 * - Check if the label is taken;
+	 * - Try to allocate the memory for it and register;
+	 */
+	if (bs->pl == NULL) {
+		if (pl_find(nlabel) != NULL) {
+			/* Someone is already using it. */
+			return -1;
+		}
+
+		if (pl_new(nlabel, bs) == NULL)
+			return -1;
+
+		return 0;
+	}
+
+	/*
+	 * Test label change consistency:
+	 * - Do nothing if it's the same label;
+	 * - Check if the future label is already taken;
+	 * - Change label;
+	 */
+	if (strcmp(nlabel, bs->pl->pl_label) == 0)
+		return -1;
+	if (pl_find(nlabel) != NULL)
+		return -1;
+
+	strlcpy(bs->pl->pl_label, nlabel, sizeof(bs->pl->pl_label));
+	return 0;
+}
+
+static void _bfd_session_update(struct bfd_session *bs,
+				struct bfd_peer_cfg *bpc)
+{
+	if (bpc->bpc_echo) {
+		/* Check if echo mode is already active. */
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+			goto skip_echo;
+
+		BFD_SET_FLAG(bs->flags, BFD_SESS_FLAG_ECHO);
+		ptm_bfd_echo_start(bs);
+
+		/* Activate/update echo receive timeout timer. */
+		bfd_echo_recvtimer_update(bs);
+	} else {
+		/* Check if echo mode is already disabled. */
+		if (!BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+			goto skip_echo;
+
+		BFD_UNSET_FLAG(bs->flags, BFD_SESS_FLAG_ECHO);
+		ptm_bfd_echo_stop(bs, 0);
+	}
+
+skip_echo:
+	if (bpc->bpc_has_txinterval)
+		bs->up_min_tx = bpc->bpc_txinterval * 1000;
+
+	if (bpc->bpc_has_recvinterval)
+		bs->timers.required_min_rx = bpc->bpc_recvinterval * 1000;
+
+	if (bpc->bpc_has_detectmultiplier)
+		bs->detect_mult = bpc->bpc_detectmultiplier;
+
+	if (bpc->bpc_has_echointerval)
+		bs->timers.required_min_echo = bpc->bpc_echointerval * 1000;
+
+	if (bpc->bpc_has_label)
+		bfd_session_update_label(bs, bpc->bpc_label);
+
+	if (bpc->bpc_shutdown) {
+		/* Check if already shutdown. */
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+			return;
+
+		BFD_SET_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN);
+
+		/* Disable all events. */
+		bfd_recvtimer_delete(bs);
+		bfd_echo_recvtimer_delete(bs);
+		bfd_xmttimer_delete(bs);
+		bfd_echo_xmttimer_delete(bs);
+
+		/* Change and notify state change. */
+		bs->ses_state = PTM_BFD_ADM_DOWN;
+		control_notify(bs);
+
+		ptm_bfd_snd(bs, 0);
+	} else {
+		/* Check if already working. */
+		if (!BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+			return;
+
+		BFD_UNSET_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN);
+
+		/* Change and notify state change. */
+		bs->ses_state = PTM_BFD_DOWN;
+		control_notify(bs);
+
+		/* Enable all timers. */
+		bfd_recvtimer_update(bs);
+		bfd_xmttimer_update(bs, bs->xmt_TO);
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO)) {
+			bfd_echo_recvtimer_update(bs);
+			bfd_echo_xmttimer_update(bs, bs->echo_xmt_TO);
+		}
+	}
+}
+
+static int bfd_session_update(struct bfd_session *bs, struct bfd_peer_cfg *bpc)
+{
+	/* User didn't want to update, return failure. */
+	if (bpc->bpc_createonly)
+		return -1;
+
+	_bfd_session_update(bs, bpc);
+
+	/* TODO add VxLAN support. */
+
+	control_notify_config(BCM_NOTIFY_CONFIG_UPDATE, bs);
+
+	return 0;
+}
+
+static void bfd_session_free(struct bfd_session *bs)
+{
+	if (bs->sock != -1)
+		close(bs->sock);
+
+	bfd_recvtimer_delete(bs);
+	bfd_echo_recvtimer_delete(bs);
+	bfd_xmttimer_delete(bs);
+	bfd_echo_xmttimer_delete(bs);
+
+	bfd_id_delete(bs->discrs.my_discr);
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))
+		bfd_mhop_delete(bs->mhop);
+	else
+		bfd_shop_delete(bs->shop);
+
+	pl_free(bs->pl);
+
+	QOBJ_UNREG(bs);
+	XFREE(MTYPE_BFDD_CONFIG, bs);
+}
+
+struct bfd_session *ptm_bfd_sess_new(struct bfd_peer_cfg *bpc)
+{
+	struct bfd_session *bfd, *l_bfd;
+	int psock;
+
+	/* check to see if this needs a new session */
+	l_bfd = bs_peer_find(bpc);
+	if (l_bfd) {
+		/* Requesting a duplicated peer means update configuration. */
+		if (bfd_session_update(l_bfd, bpc) == 0)
+			return l_bfd;
+		else
+			return NULL;
+	}
+
+	/*
+	 * Get socket for transmitting control packets.  Note that if we
+	 * could use the destination port (3784) for the source
+	 * port we wouldn't need a socket per session.
+	 */
+	if (bpc->bpc_ipv4) {
+		psock = bp_peer_socket(bpc);
+		if (psock == -1)
+			return NULL;
+	} else {
+		psock = bp_peer_socketv6(bpc);
+		if (psock == -1)
+			return NULL;
+	}
+
+	/* Get memory */
+	bfd = bfd_session_new(psock);
+	if (bfd == NULL) {
+		log_error("session-new: allocation failed");
+		return NULL;
+	}
+
+	if (bpc->bpc_has_localif && !bpc->bpc_mhop) {
+		bfd->ifindex = ptm_bfd_fetch_ifindex(bpc->bpc_localif);
+		ptm_bfd_fetch_local_mac(bpc->bpc_localif, bfd->local_mac);
+	}
+
+	if (bpc->bpc_has_vxlan)
+		BFD_SET_FLAG(bfd->flags, BFD_SESS_FLAG_VXLAN);
+
+	if (bpc->bpc_ipv4 == false) {
+		BFD_SET_FLAG(bfd->flags, BFD_SESS_FLAG_IPV6);
+
+		/* Set the IPv6 scope id for link-local addresses. */
+		if (IN6_IS_ADDR_LINKLOCAL(&bpc->bpc_local.sa_sin6.sin6_addr))
+			bpc->bpc_local.sa_sin6.sin6_scope_id = bfd->ifindex;
+		if (IN6_IS_ADDR_LINKLOCAL(&bpc->bpc_peer.sa_sin6.sin6_addr))
+			bpc->bpc_peer.sa_sin6.sin6_scope_id = bfd->ifindex;
+	}
+
+	/* Initialize the session */
+	bfd->ses_state = PTM_BFD_DOWN;
+	bfd->discrs.my_discr = ptm_bfd_gen_ID();
+	bfd->discrs.remote_discr = 0;
+	bfd->local_ip = bpc->bpc_local;
+	bfd->local_address = bpc->bpc_local;
+	bfd->timers.desired_min_tx = bfd->up_min_tx;
+	bfd->detect_TO = (bfd->detect_mult * BFD_DEF_SLOWTX);
+
+	/* Use detect_TO first for slow detection, then use recvtimer_update. */
+	bfd_recvtimer_update(bfd);
+
+	bfd_id_insert(bfd);
+
+	if (bpc->bpc_mhop) {
+		BFD_SET_FLAG(bfd->flags, BFD_SESS_FLAG_MH);
+		bfd->mhop.peer = bpc->bpc_peer;
+		bfd->mhop.local = bpc->bpc_local;
+		if (bpc->bpc_has_vrfname)
+			strlcpy(bfd->mhop.vrf_name, bpc->bpc_vrfname,
+				sizeof(bfd->mhop.vrf_name));
+
+		bfd_mhop_insert(bfd);
+	} else {
+		bfd->shop.peer = bpc->bpc_peer;
+		if (!bpc->bpc_has_vxlan && bpc->bpc_has_localif)
+			strlcpy(bfd->shop.port_name, bpc->bpc_localif,
+				sizeof(bfd->shop.port_name));
+
+		bfd_shop_insert(bfd);
+	}
+
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_VXLAN)) {
+		static uint8_t bfd_def_vxlan_dmac[] = {0x00, 0x23, 0x20,
+						       0x00, 0x00, 0x01};
+		memcpy(bfd->peer_mac, bfd_def_vxlan_dmac,
+		       sizeof(bfd_def_vxlan_dmac));
+	}
+#if 0 /* TODO */
+	else if (event->rmac) {
+		if (sscanf(event->rmac, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+		    &bfd->peer_mac[0], &bfd->peer_mac[1], &bfd->peer_mac[2],
+		    &bfd->peer_mac[3], &bfd->peer_mac[4], &bfd->peer_mac[5])
+		    != 6)
+			DLOG("%s: Assigning remote mac = %s", __func__,
+			     event->rmac);
+	}
+#endif
+
+	/*
+	 * XXX: session update triggers echo start, so we must have our
+	 * discriminator ID set first.
+	 */
+	_bfd_session_update(bfd, bpc);
+
+	/* Start transmitting with slow interval until peer responds */
+	bfd->xmt_TO = BFD_DEF_SLOWTX;
+
+	ptm_bfd_xmt_TO(bfd, 0);
+
+	log_info("session-new: %s", bs_to_string(bfd));
+
+	control_notify_config(BCM_NOTIFY_CONFIG_ADD, bfd);
+
+	return bfd;
+}
+
+int ptm_bfd_ses_del(struct bfd_peer_cfg *bpc)
+{
+	struct bfd_session *bs;
+
+	/* Find session and call free(). */
+	bs = bs_peer_find(bpc);
+	if (bs == NULL)
+		return -1;
+
+	/* This pointer is being referenced, don't let it be deleted. */
+	if (bs->refcount > 0) {
+		log_error("session-delete: refcount failure: %" PRIu64
+			  " references",
+			  bs->refcount);
+		return -1;
+	}
+
+	log_info("session-delete: %s", bs_to_string(bs));
+
+	control_notify_config(BCM_NOTIFY_CONFIG_DELETE, bs);
+
+	bfd_session_free(bs);
+
+	return 0;
+}
+
+void bfd_set_polling(struct bfd_session *bs)
+{
+	bs->new_timers.desired_min_tx = bs->up_min_tx;
+	bs->new_timers.required_min_rx = bs->timers.required_min_rx;
+	bs->new_timers.required_min_echo = bs->timers.required_min_echo;
+	bs->polling = 1;
+}
+
+
+/*
+ * Helper functions.
+ */
+static const char *get_diag_str(int diag)
+{
+	for (int i = 0; diag_list[i].str; i++) {
+		if (diag_list[i].type == diag)
+			return diag_list[i].str;
+	}
+	return "N/A";
+}
+
+const char *satostr(struct sockaddr_any *sa)
+{
+#define INETSTR_BUFCOUNT 8
+	static char buf[INETSTR_BUFCOUNT][INET6_ADDRSTRLEN];
+	static int bufidx;
+	struct sockaddr_in *sin = &sa->sa_sin;
+	struct sockaddr_in6 *sin6 = &sa->sa_sin6;
+
+	bufidx += (bufidx + 1) % INETSTR_BUFCOUNT;
+	buf[bufidx][0] = 0;
+
+	switch (sin->sin_family) {
+	case AF_INET:
+		inet_ntop(AF_INET, &sin->sin_addr, buf[bufidx],
+			  sizeof(buf[bufidx]));
+		break;
+	case AF_INET6:
+		inet_ntop(AF_INET6, &sin6->sin6_addr, buf[bufidx],
+			  sizeof(buf[bufidx]));
+		break;
+
+	default:
+		strlcpy(buf[bufidx], "unknown", sizeof(buf[bufidx]));
+		break;
+	}
+
+	return buf[bufidx];
+}
+
+const char *diag2str(uint8_t diag)
+{
+	switch (diag) {
+	case 0:
+		return "ok";
+	case 1:
+		return "control detection time expired";
+	case 2:
+		return "echo function failed";
+	case 3:
+		return "neighbor signaled session down";
+	case 4:
+		return "forwarding plane reset";
+	case 5:
+		return "path down";
+	case 6:
+		return "concatenated path down";
+	case 7:
+		return "administratively down";
+	case 8:
+		return "reverse concatenated path down";
+	default:
+		return "unknown";
+	}
+}
+
+int strtosa(const char *addr, struct sockaddr_any *sa)
+{
+	memset(sa, 0, sizeof(*sa));
+
+	if (inet_pton(AF_INET, addr, &sa->sa_sin.sin_addr) == 1) {
+		sa->sa_sin.sin_family = AF_INET;
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+		sa->sa_sin.sin_len = sizeof(sa->sa_sin);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+		return 0;
+	}
+
+	if (inet_pton(AF_INET6, addr, &sa->sa_sin6.sin6_addr) == 1) {
+		sa->sa_sin6.sin6_family = AF_INET6;
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+		sa->sa_sin6.sin6_len = sizeof(sa->sa_sin6);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+		return 0;
+	}
+
+	return -1;
+}
+
+void integer2timestr(uint64_t time, char *buf, size_t buflen)
+{
+	unsigned int year, month, day, hour, minute, second;
+	int rv;
+
+#define MINUTES (60)
+#define HOURS (24 * MINUTES)
+#define DAYS (30 * HOURS)
+#define MONTHS (12 * DAYS)
+#define YEARS (MONTHS)
+	if (time >= YEARS) {
+		year = time / YEARS;
+		time -= year * YEARS;
+
+		rv = snprintf(buf, buflen, "%u year(s), ", year);
+		buf += rv;
+		buflen -= rv;
+	}
+	if (time >= MONTHS) {
+		month = time / MONTHS;
+		time -= month * MONTHS;
+
+		rv = snprintf(buf, buflen, "%u month(s), ", month);
+		buf += rv;
+		buflen -= rv;
+	}
+	if (time >= DAYS) {
+		day = time / DAYS;
+		time -= day * DAYS;
+
+		rv = snprintf(buf, buflen, "%u day(s), ", day);
+		buf += rv;
+		buflen -= rv;
+	}
+	if (time >= HOURS) {
+		hour = time / HOURS;
+		time -= hour * HOURS;
+
+		rv = snprintf(buf, buflen, "%u hour(s), ", hour);
+		buf += rv;
+		buflen -= rv;
+	}
+	if (time >= MINUTES) {
+		minute = time / MINUTES;
+		time -= minute * MINUTES;
+
+		rv = snprintf(buf, buflen, "%u minute(s), ", minute);
+		buf += rv;
+		buflen -= rv;
+	}
+	second = time % MINUTES;
+	snprintf(buf, buflen, "%u second(s)", second);
+}
+
+const char *bs_to_string(struct bfd_session *bs)
+{
+	static char buf[256];
+	int pos;
+	bool is_mhop = BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH);
+
+	pos = snprintf(buf, sizeof(buf), "mhop:%s", is_mhop ? "yes" : "no");
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		pos += snprintf(buf + pos, sizeof(buf) - pos,
+				" peer:%s local:%s", satostr(&bs->mhop.peer),
+				satostr(&bs->mhop.local));
+
+		if (bs->mhop.vrf_name[0])
+			snprintf(buf + pos, sizeof(buf) - pos, " vrf:%s",
+				 bs->mhop.vrf_name);
+	} else {
+		pos += snprintf(buf + pos, sizeof(buf) - pos, " peer:%s",
+				satostr(&bs->shop.peer));
+
+		if (bs->local_address.sa_sin.sin_family)
+			pos += snprintf(buf + pos, sizeof(buf) - pos,
+					" local:%s",
+					satostr(&bs->local_address));
+
+		if (bs->shop.port_name[0])
+			snprintf(buf + pos, sizeof(buf) - pos, " interface:%s",
+				 bs->shop.port_name);
+	}
+
+	return buf;
+}
+
+
+/*
+ * BFD hash data structures to find sessions.
+ */
+static struct hash *bfd_id_hash;
+static struct hash *bfd_shop_hash;
+static struct hash *bfd_mhop_hash;
+static struct hash *bfd_vrf_hash;
+static struct hash *bfd_iface_hash;
+
+static unsigned int bfd_id_hash_do(void *p);
+static int bfd_id_hash_cmp(const void *n1, const void *n2);
+static unsigned int bfd_shop_hash_do(void *p);
+static int bfd_shop_hash_cmp(const void *n1, const void *n2);
+static unsigned int bfd_mhop_hash_do(void *p);
+static int bfd_mhop_hash_cmp(const void *n1, const void *n2);
+static unsigned int bfd_vrf_hash_do(void *p);
+static int bfd_vrf_hash_cmp(const void *n1, const void *n2);
+static unsigned int bfd_iface_hash_do(void *p);
+static int bfd_iface_hash_cmp(const void *n1, const void *n2);
+
+static void _shop_key(struct bfd_session *bs, const struct bfd_shop_key *shop);
+static void _shop_key2(struct bfd_session *bs, const struct bfd_shop_key *shop);
+static void _mhop_key(struct bfd_session *bs, const struct bfd_mhop_key *mhop);
+static int _iface_key(struct bfd_iface *iface, const char *ifname);
+
+static void _bfd_free(struct hash_backet *hb,
+		      void *arg __attribute__((__unused__)));
+static void _vrf_free(void *arg);
+static void _iface_free(void *arg);
+
+/* BFD hash for our discriminator. */
+static unsigned int bfd_id_hash_do(void *p)
+{
+	struct bfd_session *bs = p;
+
+	return jhash_1word(bs->discrs.my_discr, 0);
+}
+
+static int bfd_id_hash_cmp(const void *n1, const void *n2)
+{
+	const struct bfd_session *bs1 = n1, *bs2 = n2;
+
+	return bs1->discrs.my_discr == bs2->discrs.my_discr;
+}
+
+/* BFD hash for single hop. */
+static unsigned int bfd_shop_hash_do(void *p)
+{
+	struct bfd_session *bs = p;
+
+	return jhash(&bs->shop, sizeof(bs->shop), 0);
+}
+
+static int bfd_shop_hash_cmp(const void *n1, const void *n2)
+{
+	const struct bfd_session *bs1 = n1, *bs2 = n2;
+
+	return memcmp(&bs1->shop, &bs2->shop, sizeof(bs1->shop)) == 0;
+}
+
+/* BFD hash for multi hop. */
+static unsigned int bfd_mhop_hash_do(void *p)
+{
+	struct bfd_session *bs = p;
+
+	return jhash(&bs->mhop, sizeof(bs->mhop), 0);
+}
+
+static int bfd_mhop_hash_cmp(const void *n1, const void *n2)
+{
+	const struct bfd_session *bs1 = n1, *bs2 = n2;
+
+	return memcmp(&bs1->mhop, &bs2->mhop, sizeof(bs1->mhop)) == 0;
+}
+
+/* BFD hash for VRFs. */
+static unsigned int bfd_vrf_hash_do(void *p)
+{
+	struct bfd_vrf *vrf = p;
+
+	return jhash_1word(vrf->vrf_id, 0);
+}
+
+static int bfd_vrf_hash_cmp(const void *n1, const void *n2)
+{
+	const struct bfd_vrf *v1 = n1, *v2 = n2;
+
+	return v1->vrf_id == v2->vrf_id;
+}
+
+/* BFD hash for interfaces. */
+static unsigned int bfd_iface_hash_do(void *p)
+{
+	struct bfd_iface *iface = p;
+
+	return string_hash_make(iface->ifname);
+}
+
+static int bfd_iface_hash_cmp(const void *n1, const void *n2)
+{
+	const struct bfd_iface *i1 = n1, *i2 = n2;
+
+	return strcmp(i1->ifname, i2->ifname) == 0;
+}
+
+/* Helper functions */
+static void _shop_key(struct bfd_session *bs, const struct bfd_shop_key *shop)
+{
+	bs->shop = *shop;
+
+	/* Remove unused fields. */
+	switch (bs->shop.peer.sa_sin.sin_family) {
+	case AF_INET:
+		bs->shop.peer.sa_sin.sin_port = 0;
+		break;
+	case AF_INET6:
+		bs->shop.peer.sa_sin6.sin6_port = 0;
+		break;
+	}
+}
+
+static void _shop_key2(struct bfd_session *bs, const struct bfd_shop_key *shop)
+{
+	_shop_key(bs, shop);
+	memset(bs->shop.port_name, 0, sizeof(bs->shop.port_name));
+}
+
+static void _mhop_key(struct bfd_session *bs, const struct bfd_mhop_key *mhop)
+{
+	bs->mhop = *mhop;
+
+	/* Remove unused fields. */
+	switch (bs->mhop.peer.sa_sin.sin_family) {
+	case AF_INET:
+		bs->mhop.peer.sa_sin.sin_port = 0;
+		bs->mhop.local.sa_sin.sin_port = 0;
+		break;
+	case AF_INET6:
+		bs->mhop.peer.sa_sin6.sin6_port = 0;
+		bs->mhop.local.sa_sin6.sin6_port = 0;
+		break;
+	}
+}
+
+static int _iface_key(struct bfd_iface *iface, const char *ifname)
+{
+	size_t slen = sizeof(iface->ifname);
+
+	memset(iface->ifname, 0, slen);
+	if (strlcpy(iface->ifname, ifname, slen) >= slen)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * Hash public interface / exported functions.
+ */
+
+/* Lookup functions. */
+struct bfd_session *bfd_id_lookup(uint32_t id)
+{
+	struct bfd_session bs;
+
+	bs.discrs.my_discr = id;
+
+	return hash_lookup(bfd_id_hash, &bs);
+}
+
+struct bfd_session *bfd_shop_lookup(struct bfd_shop_key shop)
+{
+	struct bfd_session bs, *bsp;
+
+	_shop_key(&bs, &shop);
+
+	bsp = hash_lookup(bfd_shop_hash, &bs);
+	if (bsp == NULL && bs.shop.port_name[0] != 0) {
+		/*
+		 * Since the local interface spec is optional, try
+		 * searching the key without it as well.
+		 */
+		_shop_key2(&bs, &shop);
+		bsp = hash_lookup(bfd_shop_hash, &bs);
+	}
+
+	return bsp;
+}
+
+struct bfd_session *bfd_mhop_lookup(struct bfd_mhop_key mhop)
+{
+	struct bfd_session bs;
+
+	_mhop_key(&bs, &mhop);
+
+	return hash_lookup(bfd_shop_hash, &bs);
+}
+
+struct bfd_vrf *bfd_vrf_lookup(int vrf_id)
+{
+	struct bfd_vrf vrf;
+
+	vrf.vrf_id = vrf_id;
+
+	return hash_lookup(bfd_vrf_hash, &vrf);
+}
+
+struct bfd_iface *bfd_iface_lookup(const char *ifname)
+{
+	struct bfd_iface iface;
+
+	if (_iface_key(&iface, ifname) != 0)
+		return NULL;
+
+	return hash_lookup(bfd_iface_hash, &iface);
+}
+
+/*
+ * Delete functions.
+ *
+ * Delete functions searches and remove the item from the hash and
+ * returns a pointer to the removed item data. If the item was not found
+ * then it returns NULL.
+ *
+ * The data stored inside the hash is not free()ed, so you must do it
+ * manually after getting the pointer back.
+ */
+struct bfd_session *bfd_id_delete(uint32_t id)
+{
+	struct bfd_session bs;
+
+	bs.discrs.my_discr = id;
+
+	return hash_release(bfd_id_hash, &bs);
+}
+
+struct bfd_session *bfd_shop_delete(struct bfd_shop_key shop)
+{
+	struct bfd_session bs, *bsp;
+
+	_shop_key(&bs, &shop);
+	bsp = hash_release(bfd_shop_hash, &bs);
+	if (bsp == NULL && shop.port_name[0] != 0) {
+		/*
+		 * Since the local interface spec is optional, try
+		 * searching the key without it as well.
+		 */
+		_shop_key2(&bs, &shop);
+		bsp = hash_release(bfd_shop_hash, &bs);
+	}
+
+	return bsp;
+}
+
+struct bfd_session *bfd_mhop_delete(struct bfd_mhop_key mhop)
+{
+	struct bfd_session bs;
+
+	_mhop_key(&bs, &mhop);
+
+	return hash_release(bfd_mhop_hash, &bs);
+}
+
+struct bfd_vrf *bfd_vrf_delete(int vrf_id)
+{
+	struct bfd_vrf vrf;
+
+	vrf.vrf_id = vrf_id;
+
+	return hash_release(bfd_vrf_hash, &vrf);
+}
+
+struct bfd_iface *bfd_iface_delete(const char *ifname)
+{
+	struct bfd_iface iface;
+
+	if (_iface_key(&iface, ifname) != 0)
+		return NULL;
+
+	return hash_release(bfd_iface_hash, &iface);
+}
+
+/* Iteration functions. */
+void bfd_id_iterate(hash_iter_func hif, void *arg)
+{
+	hash_iterate(bfd_id_hash, hif, arg);
+}
+
+void bfd_shop_iterate(hash_iter_func hif, void *arg)
+{
+	hash_iterate(bfd_shop_hash, hif, arg);
+}
+
+void bfd_mhop_iterate(hash_iter_func hif, void *arg)
+{
+	hash_iterate(bfd_mhop_hash, hif, arg);
+}
+
+void bfd_vrf_iterate(hash_iter_func hif, void *arg)
+{
+	hash_iterate(bfd_vrf_hash, hif, arg);
+}
+
+void bfd_iface_iterate(hash_iter_func hif, void *arg)
+{
+	hash_iterate(bfd_iface_hash, hif, arg);
+}
+
+/*
+ * Insert functions.
+ *
+ * Inserts session into hash and returns `true` on success, otherwise
+ * `false`.
+ */
+bool bfd_id_insert(struct bfd_session *bs)
+{
+	return (hash_get(bfd_id_hash, bs, hash_alloc_intern) == bs);
+}
+
+bool bfd_shop_insert(struct bfd_session *bs)
+{
+	return (hash_get(bfd_shop_hash, bs, hash_alloc_intern) == bs);
+}
+
+bool bfd_mhop_insert(struct bfd_session *bs)
+{
+	return (hash_get(bfd_mhop_hash, bs, hash_alloc_intern) == bs);
+}
+
+bool bfd_vrf_insert(struct bfd_vrf *vrf)
+{
+	return (hash_get(bfd_vrf_hash, vrf, hash_alloc_intern) == vrf);
+}
+
+bool bfd_iface_insert(struct bfd_iface *iface)
+{
+	return (hash_get(bfd_iface_hash, iface, hash_alloc_intern) == iface);
+}
+
+void bfd_initialize(void)
+{
+	bfd_id_hash = hash_create(bfd_id_hash_do, bfd_id_hash_cmp,
+				  "BFD discriminator hash");
+	bfd_shop_hash = hash_create(bfd_shop_hash_do, bfd_shop_hash_cmp,
+				    "BFD single hop hash");
+	bfd_mhop_hash = hash_create(bfd_mhop_hash_do, bfd_mhop_hash_cmp,
+				    "BFD multihop hop hash");
+	bfd_vrf_hash =
+		hash_create(bfd_vrf_hash_do, bfd_vrf_hash_cmp, "BFD VRF hash");
+	bfd_iface_hash = hash_create(bfd_iface_hash_do, bfd_iface_hash_cmp,
+				     "BFD interface hash");
+}
+
+static void _bfd_free(struct hash_backet *hb,
+		      void *arg __attribute__((__unused__)))
+{
+	struct bfd_session *bs = hb->data;
+
+	bfd_session_free(bs);
+}
+
+static void _vrf_free(void *arg)
+{
+	struct bfd_vrf *vrf = arg;
+
+	XFREE(MTYPE_BFDD_CONFIG, vrf);
+}
+
+static void _iface_free(void *arg)
+{
+	struct bfd_iface *iface = arg;
+
+	XFREE(MTYPE_BFDD_CONFIG, iface);
+}
+
+void bfd_shutdown(void)
+{
+	/*
+	 * Close and free all BFD sessions.
+	 *
+	 * _bfd_free() will call bfd_session_free() which will take care
+	 * of removing the session from all hashes, so we just run an
+	 * assert() here to make sure it really happened.
+	 */
+	bfd_id_iterate(_bfd_free, NULL);
+	assert(bfd_shop_hash->count == 0);
+	assert(bfd_mhop_hash->count == 0);
+
+	/* Clean the VRF and interface hashes. */
+	hash_clean(bfd_vrf_hash, _vrf_free);
+	hash_clean(bfd_iface_hash, _iface_free);
+
+	/* Now free the hashes themselves. */
+	hash_free(bfd_id_hash);
+	hash_free(bfd_shop_hash);
+	hash_free(bfd_mhop_hash);
+	hash_free(bfd_vrf_hash);
+	hash_free(bfd_iface_hash);
+}
diff -urpN frr-frr-5.0.1/bfdd/bfd.h frr-frr-6.0/bfdd/bfd.h
--- frr-frr-5.0.1/bfdd/bfd.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfd.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,634 @@
+/*********************************************************************
+ * Copyright 2014,2015,2016,2017 Cumulus Networks, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * bfd.h: implements the BFD protocol.
+ */
+
+#ifndef _BFD_H_
+#define _BFD_H_
+
+#include <netinet/in.h>
+
+#include <stdbool.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include "lib/hash.h"
+#include "lib/libfrr.h"
+#include "lib/qobj.h"
+#include "lib/queue.h"
+
+#include "bfdctl.h"
+
+#define ETHERNET_ADDRESS_LENGTH 6
+
+#ifdef BFD_DEBUG
+#define BFDD_JSON_CONV_OPTIONS (JSON_C_TO_STRING_PRETTY)
+#else
+#define BFDD_JSON_CONV_OPTIONS (0)
+#endif
+
+DECLARE_MGROUP(BFDD);
+DECLARE_MTYPE(BFDD_TMP);
+DECLARE_MTYPE(BFDD_CONFIG);
+DECLARE_MTYPE(BFDD_LABEL);
+DECLARE_MTYPE(BFDD_CONTROL);
+DECLARE_MTYPE(BFDD_NOTIFICATION);
+
+struct bfd_timers {
+	uint32_t desired_min_tx;
+	uint32_t required_min_rx;
+	uint32_t required_min_echo;
+};
+
+struct bfd_discrs {
+	uint32_t my_discr;
+	uint32_t remote_discr;
+};
+
+/*
+ * Format of control packet.  From section 4)
+ */
+struct bfd_pkt {
+	union {
+		uint32_t byteFields;
+		struct {
+			uint8_t diag;
+			uint8_t flags;
+			uint8_t detect_mult;
+			uint8_t len;
+		};
+	};
+	struct bfd_discrs discrs;
+	struct bfd_timers timers;
+};
+
+/*
+ * Format of Echo packet.
+ */
+struct bfd_echo_pkt {
+	union {
+		uint32_t byteFields;
+		struct {
+			uint8_t ver;
+			uint8_t len;
+			uint16_t reserved;
+		};
+	};
+	uint32_t my_discr;
+	uint8_t pad[16];
+};
+
+
+/* Macros for manipulating control packets */
+#define BFD_VERMASK 0x03
+#define BFD_DIAGMASK 0x1F
+#define BFD_GETVER(diag) ((diag >> 5) & BFD_VERMASK)
+#define BFD_SETVER(diag, val) ((diag) |= (val & BFD_VERMASK) << 5)
+#define BFD_VERSION 1
+#define BFD_PBIT 0x20
+#define BFD_FBIT 0x10
+#define BFD_CBIT 0x08
+#define BFD_ABIT 0x04
+#define BFD_DEMANDBIT 0x02
+#define BFD_DIAGNEIGHDOWN 3
+#define BFD_DIAGDETECTTIME 1
+#define BFD_DIAGADMINDOWN 7
+#define BFD_SETDEMANDBIT(flags, val)                                           \
+	{                                                                      \
+		if ((val))                                                     \
+			flags |= BFD_DEMANDBIT;                                \
+	}
+#define BFD_SETPBIT(flags, val)                                                \
+	{                                                                      \
+		if ((val))                                                     \
+			flags |= BFD_PBIT;                                     \
+	}
+#define BFD_GETPBIT(flags) (flags & BFD_PBIT)
+#define BFD_SETFBIT(flags, val)                                                \
+	{                                                                      \
+		if ((val))                                                     \
+			flags |= BFD_FBIT;                                     \
+	}
+#define BFD_GETFBIT(flags) (flags & BFD_FBIT)
+#define BFD_SETSTATE(flags, val)                                               \
+	{                                                                      \
+		if ((val))                                                     \
+			flags |= (val & 0x3) << 6;                             \
+	}
+#define BFD_GETSTATE(flags) ((flags >> 6) & 0x3)
+#define BFD_ECHO_VERSION 1
+#define BFD_ECHO_PKT_LEN sizeof(struct bfd_echo_pkt)
+#define BFD_CTRL_PKT_LEN sizeof(struct bfd_pkt)
+#define IP_HDR_LEN 20
+#define UDP_HDR_LEN 8
+#define ETH_HDR_LEN 14
+#define VXLAN_HDR_LEN 8
+#define HEADERS_MIN_LEN (ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN)
+#define BFD_ECHO_PKT_TOT_LEN                                                   \
+	((int)(ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN + BFD_ECHO_PKT_LEN))
+#define BFD_VXLAN_PKT_TOT_LEN                                                  \
+	((int)(VXLAN_HDR_LEN + ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN          \
+	       + BFD_CTRL_PKT_LEN))
+#define BFD_RX_BUF_LEN 160
+
+/* BFD session flags */
+enum bfd_session_flags {
+	BFD_SESS_FLAG_NONE = 0,
+	BFD_SESS_FLAG_ECHO = 1 << 0,	/* BFD Echo functionality */
+	BFD_SESS_FLAG_ECHO_ACTIVE = 1 << 1, /* BFD Echo Packets are being sent
+					     * actively
+					     */
+	BFD_SESS_FLAG_MH = 1 << 2,	  /* BFD Multi-hop session */
+	BFD_SESS_FLAG_VXLAN = 1 << 3,       /* BFD Multi-hop session which is
+					     * used to monitor vxlan tunnel
+					     */
+	BFD_SESS_FLAG_IPV6 = 1 << 4,	/* BFD IPv6 session */
+	BFD_SESS_FLAG_SEND_EVT_ACTIVE = 1 << 5, /* send event timer active */
+	BFD_SESS_FLAG_SEND_EVT_IGNORE = 1 << 6, /* ignore send event when timer
+						 * expires
+						 */
+	BFD_SESS_FLAG_SHUTDOWN = 1 << 7,	/* disable BGP peer function */
+};
+
+#define BFD_SET_FLAG(field, flag) (field |= flag)
+#define BFD_UNSET_FLAG(field, flag) (field &= ~flag)
+#define BFD_CHECK_FLAG(field, flag) (field & flag)
+
+/* BFD session hash keys */
+struct bfd_shop_key {
+	struct sockaddr_any peer;
+	char port_name[MAXNAMELEN + 1];
+};
+
+struct bfd_mhop_key {
+	struct sockaddr_any peer;
+	struct sockaddr_any local;
+	char vrf_name[MAXNAMELEN + 1];
+};
+
+struct bfd_session_stats {
+	uint64_t rx_ctrl_pkt;
+	uint64_t tx_ctrl_pkt;
+	uint64_t rx_echo_pkt;
+	uint64_t tx_echo_pkt;
+	uint64_t session_up;
+	uint64_t session_down;
+	uint64_t znotification;
+};
+
+struct bfd_session_vxlan_info {
+	uint32_t vnid;
+	uint32_t decay_min_rx;
+	uint8_t forwarding_if_rx;
+	uint8_t cpath_down;
+	uint8_t check_tnl_key;
+	uint8_t local_dst_mac[ETHERNET_ADDRESS_LENGTH];
+	uint8_t peer_dst_mac[ETHERNET_ADDRESS_LENGTH];
+	struct in_addr local_dst_ip;
+	struct in_addr peer_dst_ip;
+};
+
+/* bfd_session shortcut label forwarding. */
+struct peer_label;
+
+/*
+ * Session state information
+ */
+struct bfd_session {
+
+	/* protocol state per RFC 5880*/
+	uint8_t ses_state;
+	struct bfd_discrs discrs;
+	uint8_t local_diag;
+	uint8_t demand_mode;
+	uint8_t detect_mult;
+	uint8_t remote_detect_mult;
+	uint8_t mh_ttl;
+
+	/* Timers */
+	struct bfd_timers timers;
+	struct bfd_timers new_timers;
+	uint32_t up_min_tx;
+	uint64_t detect_TO;
+	struct thread *echo_recvtimer_ev;
+	struct thread *recvtimer_ev;
+	uint64_t xmt_TO;
+	uint64_t echo_xmt_TO;
+	struct thread *xmttimer_ev;
+	struct thread *echo_xmttimer_ev;
+	uint64_t echo_detect_TO;
+
+	/* software object state */
+	uint8_t polling;
+
+	/* This and the localDiscr are the keys to state info */
+	struct peer_label *pl;
+	union {
+		struct bfd_shop_key shop;
+		struct bfd_mhop_key mhop;
+	};
+	int sock;
+
+	struct sockaddr_any local_address;
+	struct sockaddr_any local_ip;
+	int ifindex;
+	uint8_t local_mac[ETHERNET_ADDRESS_LENGTH];
+	uint8_t peer_mac[ETHERNET_ADDRESS_LENGTH];
+	uint16_t ip_id;
+
+	/* BFD session flags */
+	enum bfd_session_flags flags;
+
+	uint8_t echo_pkt[BFD_ECHO_PKT_TOT_LEN]; /* Save the Echo Packet
+						 * which will be transmitted
+						 */
+	struct bfd_session_stats stats;
+	struct bfd_session_vxlan_info vxlan_info;
+
+	struct timeval uptime;   /* last up time */
+	struct timeval downtime; /* last down time */
+
+	/* Remote peer data (for debugging mostly) */
+	uint8_t remote_diag;
+	struct bfd_timers remote_timers;
+
+	uint64_t refcount; /* number of pointers referencing this. */
+
+	/* VTY context data. */
+	QOBJ_FIELDS;
+};
+DECLARE_QOBJ_TYPE(bfd_session);
+
+struct peer_label {
+	TAILQ_ENTRY(peer_label) pl_entry;
+
+	struct bfd_session *pl_bs;
+	char pl_label[MAXNAMELEN];
+};
+TAILQ_HEAD(pllist, peer_label);
+
+struct bfd_diag_str_list {
+	const char *str;
+	int type;
+};
+
+struct bfd_state_str_list {
+	const char *str;
+	int type;
+};
+
+struct bfd_vrf {
+	int vrf_id;
+	char name[MAXNAMELEN + 1];
+} bfd_vrf;
+
+struct bfd_iface {
+	int vrf_id;
+	char ifname[MAXNAMELEN + 1];
+} bfd_iface;
+
+
+/* States defined per 4.1 */
+#define PTM_BFD_ADM_DOWN 0
+#define PTM_BFD_DOWN 1
+#define PTM_BFD_INIT 2
+#define PTM_BFD_UP 3
+
+
+/* Various constants */
+/* Retrieved from ptm_timer.h from Cumulus PTM sources. */
+#define MSEC_PER_SEC 1000L
+#define NSEC_PER_MSEC 1000000L
+
+#define BFD_DEF_DEMAND 0
+#define BFD_DEFDETECTMULT 3
+#define BFD_DEFDESIREDMINTX (300 * MSEC_PER_SEC)
+#define BFD_DEFREQUIREDMINRX (300 * MSEC_PER_SEC)
+#define BFD_DEF_REQ_MIN_ECHO (50 * MSEC_PER_SEC)
+#define BFD_DEF_SLOWTX (2000 * MSEC_PER_SEC)
+#define BFD_DEF_MHOP_TTL 5
+#define BFD_PKT_LEN 24 /* Length of control packet */
+#define BFD_TTL_VAL 255
+#define BFD_RCV_TTL_VAL 1
+#define BFD_TOS_VAL 0xC0
+#define BFD_PKT_INFO_VAL 1
+#define BFD_IPV6_PKT_INFO_VAL 1
+#define BFD_IPV6_ONLY_VAL 1
+#define BFD_SRCPORTINIT 49142
+#define BFD_SRCPORTMAX 65536
+#define BFD_DEFDESTPORT 3784
+#define BFD_DEF_ECHO_PORT 3785
+#define BFD_DEF_MHOP_DEST_PORT 4784
+#define BFD_CMD_STRING_LEN (MAXNAMELEN + 50)
+#define BFD_BUFFER_LEN (BFD_CMD_STRING_LEN + MAXNAMELEN + 1)
+
+/*
+ * control.c
+ *
+ * Daemon control code to speak with local consumers.
+ */
+
+/* See 'bfdctrl.h' for client protocol definitions. */
+
+struct bfd_control_buffer {
+	size_t bcb_left;
+	size_t bcb_pos;
+	union {
+		struct bfd_control_msg *bcb_bcm;
+		uint8_t *bcb_buf;
+	};
+};
+
+struct bfd_control_queue {
+	TAILQ_ENTRY(bfd_control_queue) bcq_entry;
+
+	struct bfd_control_buffer bcq_bcb;
+};
+TAILQ_HEAD(bcqueue, bfd_control_queue);
+
+struct bfd_notify_peer {
+	TAILQ_ENTRY(bfd_notify_peer) bnp_entry;
+
+	struct bfd_session *bnp_bs;
+};
+TAILQ_HEAD(bnplist, bfd_notify_peer);
+
+struct bfd_control_socket {
+	TAILQ_ENTRY(bfd_control_socket) bcs_entry;
+
+	int bcs_sd;
+	struct thread *bcs_ev;
+	struct thread *bcs_outev;
+	struct bcqueue bcs_bcqueue;
+
+	/* Notification data */
+	uint64_t bcs_notify;
+	struct bnplist bcs_bnplist;
+
+	enum bc_msg_version bcs_version;
+	enum bc_msg_type bcs_type;
+
+	/* Message buffering */
+	struct bfd_control_buffer bcs_bin;
+	struct bfd_control_buffer *bcs_bout;
+};
+TAILQ_HEAD(bcslist, bfd_control_socket);
+
+int control_init(const char *path);
+void control_shutdown(void);
+int control_notify(struct bfd_session *bs);
+int control_notify_config(const char *op, struct bfd_session *bs);
+int control_accept(struct thread *t);
+
+
+/*
+ * bfdd.c
+ *
+ * Daemon specific code.
+ */
+struct bfd_global {
+	int bg_shop;
+	int bg_mhop;
+	int bg_shop6;
+	int bg_mhop6;
+	int bg_echo;
+	int bg_vxlan;
+	struct thread *bg_ev[6];
+
+	int bg_csock;
+	struct thread *bg_csockev;
+	struct bcslist bg_bcslist;
+
+	struct pllist bg_pllist;
+};
+extern struct bfd_global bglobal;
+extern struct bfd_diag_str_list diag_list[];
+extern struct bfd_state_str_list state_list[];
+
+void socket_close(int *s);
+
+
+/*
+ * config.c
+ *
+ * Contains the code related with loading/reloading configuration.
+ */
+int parse_config(const char *fname);
+int config_request_add(const char *jsonstr);
+int config_request_del(const char *jsonstr);
+char *config_response(const char *status, const char *error);
+char *config_notify(struct bfd_session *bs);
+char *config_notify_config(const char *op, struct bfd_session *bs);
+
+typedef int (*bpc_handle)(struct bfd_peer_cfg *, void *arg);
+int config_notify_request(struct bfd_control_socket *bcs, const char *jsonstr,
+			  bpc_handle bh);
+
+struct peer_label *pl_new(const char *label, struct bfd_session *bs);
+struct peer_label *pl_find(const char *label);
+void pl_free(struct peer_label *pl);
+
+
+/*
+ * log.c
+ *
+ * Contains code that does the logging procedures. Might implement multiple
+ * backends (e.g. zebra log, syslog or other logging lib).
+ */
+enum blog_level {
+	/* level vs syslog equivalent */
+	BLOG_DEBUG = 0,   /* LOG_DEBUG */
+	BLOG_INFO = 1,    /* LOG_INFO */
+	BLOG_WARNING = 2, /* LOG_WARNING */
+	BLOG_ERROR = 3,   /* LOG_ERR */
+	BLOG_FATAL = 4,   /* LOG_CRIT */
+};
+
+void log_init(int foreground, enum blog_level level,
+	      struct frr_daemon_info *fdi);
+void log_info(const char *fmt, ...);
+void log_debug(const char *fmt, ...);
+void log_warning(const char *fmt, ...);
+void log_error(const char *fmt, ...);
+void log_fatal(const char *fmt, ...);
+
+
+/*
+ * bfd_packet.c
+ *
+ * Contains the code related with receiving/seding, packing/unpacking BFD data.
+ */
+int bp_set_ttlv6(int sd);
+int bp_set_ttl(int sd);
+int bp_set_tosv6(int sd);
+int bp_set_tos(int sd);
+int bp_bind_dev(int sd, const char *dev);
+
+int bp_udp_shop(void);
+int bp_udp_mhop(void);
+int bp_udp6_shop(void);
+int bp_udp6_mhop(void);
+int bp_peer_socket(struct bfd_peer_cfg *bpc);
+int bp_peer_socketv6(struct bfd_peer_cfg *bpc);
+
+void ptm_bfd_snd(struct bfd_session *bfd, int fbit);
+void ptm_bfd_echo_snd(struct bfd_session *bfd);
+
+int bfd_recv_cb(struct thread *t);
+
+uint16_t checksum(uint16_t *buf, int len);
+
+
+/*
+ * event.c
+ *
+ * Contains the code related with event loop.
+ */
+typedef void (*bfd_ev_cb)(struct thread *t);
+
+void bfd_recvtimer_update(struct bfd_session *bs);
+void bfd_echo_recvtimer_update(struct bfd_session *bs);
+void bfd_xmttimer_update(struct bfd_session *bs, uint64_t jitter);
+void bfd_echo_xmttimer_update(struct bfd_session *bs, uint64_t jitter);
+
+void bfd_xmttimer_delete(struct bfd_session *bs);
+void bfd_echo_xmttimer_delete(struct bfd_session *bs);
+void bfd_recvtimer_delete(struct bfd_session *bs);
+void bfd_echo_recvtimer_delete(struct bfd_session *bs);
+
+void bfd_recvtimer_assign(struct bfd_session *bs, bfd_ev_cb cb, int sd);
+void bfd_echo_recvtimer_assign(struct bfd_session *bs, bfd_ev_cb cb, int sd);
+void bfd_xmttimer_assign(struct bfd_session *bs, bfd_ev_cb cb);
+void bfd_echo_xmttimer_assign(struct bfd_session *bs, bfd_ev_cb cb);
+
+
+/*
+ * bfd.c
+ *
+ * BFD protocol specific code.
+ */
+struct bfd_session *ptm_bfd_sess_new(struct bfd_peer_cfg *bpc);
+int ptm_bfd_ses_del(struct bfd_peer_cfg *bpc);
+void ptm_bfd_ses_dn(struct bfd_session *bfd, uint8_t diag);
+void ptm_bfd_ses_up(struct bfd_session *bfd);
+void fetch_portname_from_ifindex(int ifindex, char *ifname, size_t ifnamelen);
+void ptm_bfd_echo_stop(struct bfd_session *bfd, int polling);
+void ptm_bfd_echo_start(struct bfd_session *bfd);
+void ptm_bfd_xmt_TO(struct bfd_session *bfd, int fbit);
+void ptm_bfd_start_xmt_timer(struct bfd_session *bfd, bool is_echo);
+struct bfd_session *ptm_bfd_sess_find(struct bfd_pkt *cp, char *port_name,
+				      struct sockaddr_any *peer,
+				      struct sockaddr_any *local,
+				      char *vrf_name, bool is_mhop);
+
+struct bfd_session *bs_peer_find(struct bfd_peer_cfg *bpc);
+int bfd_session_update_label(struct bfd_session *bs, const char *nlabel);
+void bfd_set_polling(struct bfd_session *bs);
+const char *satostr(struct sockaddr_any *sa);
+const char *diag2str(uint8_t diag);
+int strtosa(const char *addr, struct sockaddr_any *sa);
+void integer2timestr(uint64_t time, char *buf, size_t buflen);
+const char *bs_to_string(struct bfd_session *bs);
+
+/* BFD hash data structures interface */
+void bfd_initialize(void);
+void bfd_shutdown(void);
+struct bfd_session *bfd_id_lookup(uint32_t id);
+struct bfd_session *bfd_shop_lookup(struct bfd_shop_key shop);
+struct bfd_session *bfd_mhop_lookup(struct bfd_mhop_key mhop);
+struct bfd_vrf *bfd_vrf_lookup(int vrf_id);
+struct bfd_iface *bfd_iface_lookup(const char *ifname);
+
+struct bfd_session *bfd_id_delete(uint32_t id);
+struct bfd_session *bfd_shop_delete(struct bfd_shop_key shop);
+struct bfd_session *bfd_mhop_delete(struct bfd_mhop_key mhop);
+struct bfd_vrf *bfd_vrf_delete(int vrf_id);
+struct bfd_iface *bfd_iface_delete(const char *ifname);
+
+bool bfd_id_insert(struct bfd_session *bs);
+bool bfd_shop_insert(struct bfd_session *bs);
+bool bfd_mhop_insert(struct bfd_session *bs);
+bool bfd_vrf_insert(struct bfd_vrf *vrf);
+bool bfd_iface_insert(struct bfd_iface *iface);
+
+typedef void (*hash_iter_func)(struct hash_backet *hb, void *arg);
+void bfd_id_iterate(hash_iter_func hif, void *arg);
+void bfd_shop_iterate(hash_iter_func hif, void *arg);
+void bfd_mhop_iterate(hash_iter_func hif, void *arg);
+void bfd_vrf_iterate(hash_iter_func hif, void *arg);
+void bfd_iface_iterate(hash_iter_func hif, void *arg);
+
+/* Export callback functions for `event.c`. */
+extern struct thread_master *master;
+
+int bfd_recvtimer_cb(struct thread *t);
+int bfd_echo_recvtimer_cb(struct thread *t);
+int bfd_xmt_cb(struct thread *t);
+int bfd_echo_xmt_cb(struct thread *t);
+
+
+/*
+ * bfdd_vty.c
+ *
+ * BFD daemon vty shell commands.
+ */
+void bfdd_vty_init(void);
+
+
+/*
+ * ptm_adapter.c
+ */
+void bfdd_zclient_init(struct zebra_privs_t *bfdd_priv);
+void bfdd_zclient_stop(void);
+
+int ptm_bfd_notify(struct bfd_session *bs);
+
+
+/*
+ * OS compatibility functions.
+ */
+struct udp_psuedo_header {
+	uint32_t saddr;
+	uint32_t daddr;
+	uint8_t reserved;
+	uint8_t protocol;
+	uint16_t len;
+};
+
+#define UDP_PSUEDO_HDR_LEN sizeof(struct udp_psuedo_header)
+
+#if defined(BFD_LINUX) || defined(BFD_BSD)
+int ptm_bfd_fetch_ifindex(const char *ifname);
+void ptm_bfd_fetch_local_mac(const char *ifname, uint8_t *mac);
+void fetch_portname_from_ifindex(int ifindex, char *ifname, size_t ifnamelen);
+int ptm_bfd_echo_sock_init(void);
+int ptm_bfd_vxlan_sock_init(void);
+#endif /* BFD_LINUX || BFD_BSD */
+
+#ifdef BFD_LINUX
+uint16_t udp4_checksum(struct iphdr *iph, uint8_t *buf, int len);
+#endif /* BFD_LINUX */
+
+#ifdef BFD_BSD
+uint16_t udp4_checksum(struct ip *ip, uint8_t *buf, int len);
+ssize_t bsd_echo_sock_read(int sd, uint8_t *buf, ssize_t *buflen,
+			   struct sockaddr_storage *ss, socklen_t *sslen,
+			   uint8_t *ttl, uint32_t *id);
+#endif /* BFD_BSD */
+
+#endif /* _BFD_H_ */
diff -urpN frr-frr-5.0.1/bfdd/bfd_packet.c frr-frr-6.0/bfdd/bfd_packet.c
--- frr-frr-5.0.1/bfdd/bfd_packet.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfd_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,1549 @@
+/*********************************************************************
+ * Copyright 2017 Cumulus Networks, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * bfd_packet.c: implements the BFD protocol packet handling.
+ *
+ * Authors
+ * -------
+ * Shrijeet Mukherjee [shm@cumulusnetworks.com]
+ * Kanna Rajagopal [kanna@cumulusnetworks.com]
+ * Radhika Mahankali [Radhika@cumulusnetworks.com]
+ */
+
+#include <zebra.h>
+
+#ifdef BFD_LINUX
+#include <linux/if_packet.h>
+#endif /* BFD_LINUX */
+
+#include <netinet/if_ether.h>
+#include <netinet/udp.h>
+
+#include "lib/sockopt.h"
+
+#include "bfd.h"
+
+/*
+ * Definitions
+ */
+
+/* iov for BFD control frames */
+#define CMSG_HDR_LEN sizeof(struct cmsghdr)
+#define CMSG_TTL_LEN (CMSG_HDR_LEN + sizeof(uint32_t))
+#define CMSG_IN_PKT_INFO_LEN (CMSG_HDR_LEN + sizeof(struct in_pktinfo) + 4)
+#define CMSG_IN6_PKT_INFO_LEN                                                  \
+	(CMSG_HDR_LEN + sizeof(struct in6_addr) + sizeof(int) + 4)
+
+struct bfd_raw_echo_pkt {
+#ifdef BFD_LINUX
+	struct iphdr ip;
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	struct ip ip;
+#endif /* BFD_BSD */
+	struct udphdr udp;
+	struct bfd_echo_pkt data;
+};
+
+#if 0 /* TODO: VxLAN support. */
+struct bfd_raw_ctrl_pkt {
+	struct iphdr ip;
+	struct udphdr udp;
+	struct bfd_pkt data;
+};
+#endif
+
+struct vxlan_hdr {
+	uint32_t flags;
+	uint32_t vnid;
+};
+
+#define IP_ECHO_PKT_LEN (IP_HDR_LEN + UDP_HDR_LEN + BFD_ECHO_PKT_LEN)
+#define UDP_ECHO_PKT_LEN (UDP_HDR_LEN + BFD_ECHO_PKT_LEN)
+#define IP_CTRL_PKT_LEN (IP_HDR_LEN + UDP_HDR_LEN + BFD_PKT_LEN)
+#define UDP_CTRL_PKT_LEN (UDP_HDR_LEN + BFD_PKT_LEN)
+
+static uint8_t msgbuf[BFD_PKT_LEN];
+
+static int ttlval = BFD_TTL_VAL;
+static int tosval = BFD_TOS_VAL;
+static int rcvttl = BFD_RCV_TTL_VAL;
+
+/*
+ * Prototypes
+ */
+static uint16_t ptm_bfd_gen_IP_ID(struct bfd_session *bfd);
+static void ptm_bfd_echo_pkt_create(struct bfd_session *bfd);
+static int ptm_bfd_echo_loopback(uint8_t *pkt, int pkt_len, struct sockaddr *ss,
+				 socklen_t sslen);
+static void ptm_bfd_vxlan_pkt_snd(struct bfd_session *bfd, int fbit);
+static int ptm_bfd_process_echo_pkt(int s);
+static bool
+ptm_bfd_validate_vxlan_pkt(struct bfd_session *bfd,
+			   struct bfd_session_vxlan_info *vxlan_info);
+
+static void bfd_sd_reschedule(int sd);
+static ssize_t bfd_recv_ipv4(int sd, bool is_mhop, char *port, size_t portlen,
+			     char *vrfname, size_t vrfnamelen,
+			     struct sockaddr_any *local,
+			     struct sockaddr_any *peer);
+static ssize_t bfd_recv_ipv6(int sd, bool is_mhop, char *port, size_t portlen,
+			     char *vrfname, size_t vrfnamelen,
+			     struct sockaddr_any *local,
+			     struct sockaddr_any *peer);
+
+/* socket related prototypes */
+static void bp_set_ipopts(int sd);
+static void bp_bind_ip(int sd, uint16_t port);
+static void bp_set_ipv6opts(int sd);
+static void bp_bind_ipv6(int sd, uint16_t port);
+
+
+/*
+ * Functions
+ */
+uint16_t checksum(uint16_t *buf, int len)
+{
+	int nbytes = len;
+	int sum = 0;
+	uint16_t csum = 0;
+	int size = sizeof(uint16_t);
+
+	while (nbytes > 1) {
+		sum += *buf++;
+		nbytes -= size;
+	}
+
+	if (nbytes == 1) {
+		*(uint8_t *)(&csum) = *(uint8_t *)buf;
+		sum += csum;
+	}
+
+	sum = (sum >> 16) + (sum & 0xFFFF);
+	sum += (sum >> 16);
+	csum = ~sum;
+	return csum;
+}
+
+static uint16_t ptm_bfd_gen_IP_ID(struct bfd_session *bfd)
+{
+	return (++bfd->ip_id);
+}
+
+static int _ptm_bfd_send(struct bfd_session *bs, bool use_layer2,
+			 uint16_t *port, const void *data, size_t datalen)
+{
+	struct sockaddr *sa;
+	struct sockaddr_in sin;
+	struct sockaddr_in6 sin6;
+#ifdef BFD_LINUX
+	struct sockaddr_ll dll;
+#endif /* BFD_LINUX */
+	socklen_t slen;
+	ssize_t rv;
+	int sd = -1;
+
+	if (use_layer2) {
+#ifdef BFD_LINUX
+		memset(&dll, 0, sizeof(dll));
+		dll.sll_family = AF_PACKET;
+		dll.sll_protocol = htons(ETH_P_IP);
+		memcpy(dll.sll_addr, bs->peer_mac, ETHERNET_ADDRESS_LENGTH);
+		dll.sll_halen = htons(ETHERNET_ADDRESS_LENGTH);
+		dll.sll_ifindex = bs->ifindex;
+
+		sd = bglobal.bg_echo;
+		sa = (struct sockaddr *)&dll;
+		slen = sizeof(dll);
+#else
+		/*
+		 * TODO: implement layer 2 send for *BSDs. This is
+		 * needed for VxLAN.
+		 */
+		log_warning("packet-send: not implemented");
+		return -1;
+#endif
+	} else if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_IPV6)) {
+		memset(&sin6, 0, sizeof(sin6));
+		sin6.sin6_family = AF_INET6;
+		sin6.sin6_addr = bs->shop.peer.sa_sin6.sin6_addr;
+		sin6.sin6_port =
+			(port) ? *port
+			       : (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))
+					 ? htons(BFD_DEF_MHOP_DEST_PORT)
+					 : htons(BFD_DEFDESTPORT);
+
+		sd = bs->sock;
+		sa = (struct sockaddr *)&sin6;
+		slen = sizeof(sin6);
+	} else {
+		memset(&sin, 0, sizeof(sin));
+		sin.sin_family = AF_INET;
+		sin.sin_addr = bs->shop.peer.sa_sin.sin_addr;
+		sin.sin_port =
+			(port) ? *port
+			       : (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))
+					 ? htons(BFD_DEF_MHOP_DEST_PORT)
+					 : htons(BFD_DEFDESTPORT);
+
+		sd = bs->sock;
+		sa = (struct sockaddr *)&sin;
+		slen = sizeof(sin);
+	}
+
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+	sa->sa_len = slen;
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+	rv = sendto(sd, data, datalen, 0, sa, slen);
+	if (rv <= 0) {
+		log_debug("packet-send: send failure: %s", strerror(errno));
+		return -1;
+	}
+	if (rv < (ssize_t)datalen)
+		log_debug("packet-send: send partial", strerror(errno));
+
+	return 0;
+}
+
+static void ptm_bfd_echo_pkt_create(struct bfd_session *bfd)
+{
+	struct bfd_raw_echo_pkt ep;
+	uint8_t *pkt = bfd->echo_pkt;
+
+	memset(&ep, 0, sizeof(ep));
+	memset(bfd->echo_pkt, 0, sizeof(bfd->echo_pkt));
+
+	/* Construct ethernet header information */
+	memcpy(pkt, bfd->peer_mac, ETHERNET_ADDRESS_LENGTH);
+	pkt = pkt + ETHERNET_ADDRESS_LENGTH;
+	memcpy(pkt, bfd->local_mac, ETHERNET_ADDRESS_LENGTH);
+	pkt = pkt + ETHERNET_ADDRESS_LENGTH;
+#ifdef BFD_LINUX
+	pkt[0] = ETH_P_IP / 256;
+	pkt[1] = ETH_P_IP % 256;
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	pkt[0] = ETHERTYPE_IP / 256;
+	pkt[1] = ETHERTYPE_IP % 256;
+#endif /* BFD_BSD */
+	pkt += 2;
+
+	/* Construct IP header information */
+#ifdef BFD_LINUX
+	ep.ip.version = 4;
+	ep.ip.ihl = 5;
+	ep.ip.tos = 0;
+	ep.ip.tot_len = htons(IP_ECHO_PKT_LEN);
+	ep.ip.id = htons(ptm_bfd_gen_IP_ID(bfd));
+	ep.ip.frag_off = 0;
+	ep.ip.ttl = BFD_TTL_VAL;
+	ep.ip.protocol = IPPROTO_UDP;
+	ep.ip.saddr = bfd->local_ip.sa_sin.sin_addr.s_addr;
+	ep.ip.daddr = bfd->shop.peer.sa_sin.sin_addr.s_addr;
+	ep.ip.check = checksum((uint16_t *)&ep.ip, IP_HDR_LEN);
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	ep.ip.ip_v = 4;
+	ep.ip.ip_hl = 5;
+	ep.ip.ip_tos = 0;
+	ep.ip.ip_len = htons(IP_ECHO_PKT_LEN);
+	ep.ip.ip_id = htons(ptm_bfd_gen_IP_ID(bfd));
+	ep.ip.ip_off = 0;
+	ep.ip.ip_ttl = BFD_TTL_VAL;
+	ep.ip.ip_p = IPPROTO_UDP;
+	ep.ip.ip_src = bfd->local_ip.sa_sin.sin_addr;
+	ep.ip.ip_dst = bfd->shop.peer.sa_sin.sin_addr;
+	ep.ip.ip_sum = checksum((uint16_t *)&ep.ip, IP_HDR_LEN);
+#endif /* BFD_BSD */
+
+	/* Construct UDP header information */
+#ifdef BFD_LINUX
+	ep.udp.source = htons(BFD_DEF_ECHO_PORT);
+	ep.udp.dest = htons(BFD_DEF_ECHO_PORT);
+	ep.udp.len = htons(UDP_ECHO_PKT_LEN);
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	ep.udp.uh_sport = htons(BFD_DEF_ECHO_PORT);
+	ep.udp.uh_dport = htons(BFD_DEF_ECHO_PORT);
+	ep.udp.uh_ulen = htons(UDP_ECHO_PKT_LEN);
+#endif /* BFD_BSD */
+
+	/* Construct Echo packet information */
+	ep.data.ver = BFD_ECHO_VERSION;
+	ep.data.len = BFD_ECHO_PKT_LEN;
+	ep.data.my_discr = htonl(bfd->discrs.my_discr);
+#ifdef BFD_LINUX
+	ep.udp.check =
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	ep.udp.uh_sum =
+#endif /* BFD_BSD */
+		udp4_checksum(&ep.ip, (uint8_t *)&ep.udp,
+			      UDP_ECHO_PKT_LEN);
+
+	memcpy(pkt, &ep, sizeof(ep));
+}
+
+void ptm_bfd_echo_snd(struct bfd_session *bfd)
+{
+	struct bfd_raw_echo_pkt *ep;
+	bool use_layer2 = false;
+	const void *pkt;
+	size_t pktlen;
+	uint16_t port = htons(BFD_DEF_ECHO_PORT);
+
+	if (!BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE)) {
+		ptm_bfd_echo_pkt_create(bfd);
+		BFD_SET_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE);
+	} else {
+		/* just update the checksum and ip Id */
+		ep = (struct bfd_raw_echo_pkt *)(bfd->echo_pkt + ETH_HDR_LEN);
+#ifdef BFD_LINUX
+		ep->ip.id = htons(ptm_bfd_gen_IP_ID(bfd));
+		ep->ip.check = 0;
+		ep->ip.check = checksum((uint16_t *)&ep->ip, IP_HDR_LEN);
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+		ep->ip.ip_id = htons(ptm_bfd_gen_IP_ID(bfd));
+		ep->ip.ip_sum = 0;
+		ep->ip.ip_sum = checksum((uint16_t *)&ep->ip, IP_HDR_LEN);
+#endif /* BFD_BSD */
+	}
+
+	if (use_layer2) {
+		pkt = bfd->echo_pkt;
+		pktlen = BFD_ECHO_PKT_TOT_LEN;
+	} else {
+		pkt = &bfd->echo_pkt[ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN];
+		pktlen = BFD_ECHO_PKT_TOT_LEN
+			 - (ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN);
+	}
+
+	if (_ptm_bfd_send(bfd, use_layer2, &port, pkt, pktlen) != 0) {
+		log_debug("echo-packet: send failure: %s", strerror(errno));
+		return;
+	}
+
+	bfd->stats.tx_echo_pkt++;
+}
+
+static int ptm_bfd_echo_loopback(uint8_t *pkt, int pkt_len, struct sockaddr *ss,
+				 socklen_t sslen)
+{
+#ifdef BFD_LINUX
+	struct bfd_raw_echo_pkt *ep =
+		(struct bfd_raw_echo_pkt *)(pkt + ETH_HDR_LEN);
+	uint8_t temp_mac[ETHERNET_ADDRESS_LENGTH];
+	uint32_t temp_ip;
+	struct ethhdr *eth = (struct ethhdr *)pkt;
+
+	/* swap the mac addresses */
+	memcpy(temp_mac, eth->h_source, ETHERNET_ADDRESS_LENGTH);
+	memcpy(eth->h_source, eth->h_dest, ETHERNET_ADDRESS_LENGTH);
+	memcpy(eth->h_dest, temp_mac, ETHERNET_ADDRESS_LENGTH);
+
+	/* swap ip addresses */
+	temp_ip = ep->ip.saddr;
+	ep->ip.saddr = ep->ip.daddr;
+	ep->ip.daddr = temp_ip;
+
+	ep->ip.ttl = ep->ip.ttl - 1;
+	ep->ip.check = 0;
+	ep->ip.check = checksum((uint16_t *)ep, IP_HDR_LEN);
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD_FILTER
+	struct bfd_raw_echo_pkt_t *ep =
+		(struct bfd_raw_echo_pkt *)(pkt + ETH_HDR_LEN);
+	uint8_t temp_mac[ETHERNET_ADDRESS_LENGTH];
+	struct in_addr temp_ip;
+	struct ether_header *ether = (struct ether_header *)pkt;
+
+	/*
+	 * TODO: this is not yet implemented and requires BPF code for
+	 * OmniOS, NetBSD and FreeBSD9.
+	 */
+
+	/* swap the mac addresses */
+	memcpy(temp_mac, ether->ether_shost, ETHERNET_ADDRESS_LENGTH);
+	memcpy(ether->ether_shost, ether->ether_dhost, ETHERNET_ADDRESS_LENGTH);
+	memcpy(ether->ether_dhost, temp_mac, ETHERNET_ADDRESS_LENGTH);
+
+	/* swap ip addresses */
+	temp_ip = ep->ip.ip_src;
+	ep->ip.ip_src = ep->ip.ip_dst;
+	ep->ip.ip_dst = temp_ip;
+
+	ep->ip.ip_ttl = ep->ip.ip_ttl - 1;
+	ep->ip.ip_sum = 0;
+	ep->ip.ip_sum = checksum((uint16_t *)ep, IP_HDR_LEN);
+#endif /* BFD_BSD_FILTER */
+
+	if (sendto(bglobal.bg_echo, pkt, pkt_len, 0, ss, sslen) < 0) {
+		log_debug("echo-loopback: send failure: %s", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void ptm_bfd_vxlan_pkt_snd(struct bfd_session *bfd
+				  __attribute__((__unused__)),
+				  int fbit __attribute__((__unused__)))
+{
+#if 0 /* TODO: VxLAN support. */
+	struct bfd_raw_ctrl_pkt cp;
+	uint8_t vxlan_pkt[BFD_VXLAN_PKT_TOT_LEN];
+	uint8_t *pkt = vxlan_pkt;
+	struct sockaddr_in sin;
+	struct vxlan_hdr *vhdr;
+
+	memset(vxlan_pkt, 0, sizeof(vxlan_pkt));
+	memset(&cp, 0, sizeof(cp));
+
+	/* Construct VxLAN header information */
+	vhdr = (struct vxlan_hdr *)pkt;
+	vhdr->flags = htonl(0x08000000);
+	vhdr->vnid = htonl(bfd->vxlan_info.vnid << 8);
+	pkt += VXLAN_HDR_LEN;
+
+	/* Construct ethernet header information */
+	memcpy(pkt, bfd->vxlan_info.peer_dst_mac, ETHERNET_ADDRESS_LENGTH);
+	pkt = pkt + ETHERNET_ADDRESS_LENGTH;
+	memcpy(pkt, bfd->vxlan_info.local_dst_mac, ETHERNET_ADDRESS_LENGTH);
+	pkt = pkt + ETHERNET_ADDRESS_LENGTH;
+	pkt[0] = ETH_P_IP / 256;
+	pkt[1] = ETH_P_IP % 256;
+	pkt += 2;
+
+	/* Construct IP header information */
+	cp.ip.version = 4;
+	cp.ip.ihl = 5;
+	cp.ip.tos = 0;
+	cp.ip.tot_len = htons(IP_CTRL_PKT_LEN);
+	cp.ip.id = ptm_bfd_gen_IP_ID(bfd);
+	cp.ip.frag_off = 0;
+	cp.ip.ttl = BFD_TTL_VAL;
+	cp.ip.protocol = IPPROTO_UDP;
+	cp.ip.daddr = bfd->vxlan_info.peer_dst_ip.s_addr;
+	cp.ip.saddr = bfd->vxlan_info.local_dst_ip.s_addr;
+	cp.ip.check = checksum((uint16_t *)&cp.ip, IP_HDR_LEN);
+
+	/* Construct UDP header information */
+	cp.udp.source = htons(BFD_DEFDESTPORT);
+	cp.udp.dest = htons(BFD_DEFDESTPORT);
+	cp.udp.len = htons(UDP_CTRL_PKT_LEN);
+
+	/* Construct BFD control packet information */
+	cp.data.diag = bfd->local_diag;
+	BFD_SETVER(cp.data.diag, BFD_VERSION);
+	BFD_SETSTATE(cp.data.flags, bfd->ses_state);
+	BFD_SETDEMANDBIT(cp.data.flags, BFD_DEF_DEMAND);
+	BFD_SETPBIT(cp.data.flags, bfd->polling);
+	BFD_SETFBIT(cp.data.flags, fbit);
+	cp.data.detect_mult = bfd->detect_mult;
+	cp.data.len = BFD_PKT_LEN;
+	cp.data.discrs.my_discr = htonl(bfd->discrs.my_discr);
+	cp.data.discrs.remote_discr = htonl(bfd->discrs.remote_discr);
+	cp.data.timers.desired_min_tx = htonl(bfd->timers.desired_min_tx);
+	cp.data.timers.required_min_rx = htonl(bfd->timers.required_min_rx);
+	cp.data.timers.required_min_echo = htonl(bfd->timers.required_min_echo);
+
+	cp.udp.check =
+		udp4_checksum(&cp.ip, (uint8_t *)&cp.udp, UDP_CTRL_PKT_LEN);
+
+	memcpy(pkt, &cp, sizeof(cp));
+	sin.sin_family = AF_INET;
+	sin.sin_addr = bfd->shop.peer.sa_sin.sin_addr;
+	sin.sin_port = htons(4789);
+
+	if (sendto(bfd->sock, vxlan_pkt, BFD_VXLAN_PKT_TOT_LEN, 0,
+		   (struct sockaddr *)&sin, sizeof(struct sockaddr_in))
+	    < 0) {
+		ERRLOG("Error sending vxlan bfd pkt: %s", strerror(errno));
+	} else {
+		bfd->stats.tx_ctrl_pkt++;
+	}
+#endif
+}
+
+static int ptm_bfd_process_echo_pkt(int s)
+{
+	uint32_t my_discr = 0;
+	struct sockaddr_storage ss;
+	socklen_t sslen = sizeof(ss);
+	uint8_t rx_pkt[BFD_RX_BUF_LEN];
+	ssize_t pkt_len = sizeof(rx_pkt);
+	struct bfd_session *bfd;
+#ifdef BFD_LINUX
+	struct bfd_raw_echo_pkt *ep;
+
+	/*
+	 * valgrind: memset() ss so valgrind doesn't complain about
+	 * uninitialized memory.
+	 */
+	memset(&ss, 0, sizeof(ss));
+	pkt_len = recvfrom(s, rx_pkt, sizeof(rx_pkt), MSG_DONTWAIT,
+			   (struct sockaddr *)&ss, &sslen);
+	if (pkt_len <= 0) {
+		if (errno != EAGAIN)
+			log_error("echo-packet: read failure: %s",
+				  strerror(errno));
+
+		return -1;
+	}
+
+	/* Check if we have at least the basic headers to send back. */
+	if (pkt_len < BFD_ECHO_PKT_TOT_LEN) {
+		log_debug("echo-packet: too short (got %ld, expected %d)",
+			  pkt_len, BFD_ECHO_PKT_TOT_LEN);
+		return -1;
+	}
+
+	ep = (struct bfd_raw_echo_pkt *)(rx_pkt + ETH_HDR_LEN);
+	/* if TTL = 255, assume that the received echo packet has
+	 * to be looped back
+	 */
+	if (ep->ip.ttl == BFD_TTL_VAL)
+		return ptm_bfd_echo_loopback(rx_pkt, pkt_len,
+					     (struct sockaddr *)&ss,
+					     sizeof(struct sockaddr_ll));
+
+	my_discr = ntohl(ep->data.my_discr);
+	if (ep->data.my_discr == 0) {
+		log_debug("echo-packet: 'my discriminator' is zero");
+		return -1;
+	}
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	int rv;
+	uint8_t ttl;
+
+	/*
+	 * bsd_echo_sock_read() already treats invalid TTL values and
+	 * zeroed discriminators.
+	 */
+	rv = bsd_echo_sock_read(s, rx_pkt, &pkt_len, &ss, &sslen, &ttl,
+				&my_discr);
+	if (rv == -1)
+		return -1;
+
+	if (ttl == BFD_TTL_VAL)
+		return ptm_bfd_echo_loopback(rx_pkt, pkt_len,
+					     (struct sockaddr *)&ss, sslen);
+#endif /* BFD_BSD */
+
+	/* Your discriminator not zero - use it to find session */
+	bfd = bfd_id_lookup(my_discr);
+	if (bfd == NULL) {
+		log_debug("echo-packet: no matching session (id:%u)", my_discr);
+		return -1;
+	}
+
+	if (!BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE)) {
+		log_debug("echo-packet: echo disabled [%s]", my_discr,
+			  bs_to_string(bfd));
+		return -1;
+	}
+
+	bfd->stats.rx_echo_pkt++;
+
+	/* Compute detect time */
+	bfd->echo_detect_TO = bfd->remote_detect_mult * bfd->echo_xmt_TO;
+
+	/* Update echo receive timeout. */
+	bfd_echo_recvtimer_update(bfd);
+
+	return 0;
+}
+
+void ptm_bfd_snd(struct bfd_session *bfd, int fbit)
+{
+	struct bfd_pkt cp;
+
+	/* if the BFD session is for VxLAN tunnel, then construct and
+	 * send bfd raw packet
+	 */
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_VXLAN)) {
+		ptm_bfd_vxlan_pkt_snd(bfd, fbit);
+		return;
+	}
+
+	/* Set fields according to section 6.5.7 */
+	cp.diag = bfd->local_diag;
+	BFD_SETVER(cp.diag, BFD_VERSION);
+	cp.flags = 0;
+	BFD_SETSTATE(cp.flags, bfd->ses_state);
+	BFD_SETDEMANDBIT(cp.flags, BFD_DEF_DEMAND);
+	BFD_SETPBIT(cp.flags, bfd->polling);
+	BFD_SETFBIT(cp.flags, fbit);
+	cp.detect_mult = bfd->detect_mult;
+	cp.len = BFD_PKT_LEN;
+	cp.discrs.my_discr = htonl(bfd->discrs.my_discr);
+	cp.discrs.remote_discr = htonl(bfd->discrs.remote_discr);
+	if (bfd->polling) {
+		cp.timers.desired_min_tx =
+			htonl(bfd->new_timers.desired_min_tx);
+		cp.timers.required_min_rx =
+			htonl(bfd->new_timers.required_min_rx);
+	} else {
+		cp.timers.desired_min_tx = htonl(bfd->timers.desired_min_tx);
+		cp.timers.required_min_rx = htonl(bfd->timers.required_min_rx);
+	}
+	cp.timers.required_min_echo = htonl(bfd->timers.required_min_echo);
+
+	if (_ptm_bfd_send(bfd, false, NULL, &cp, BFD_PKT_LEN) != 0)
+		return;
+
+	bfd->stats.tx_ctrl_pkt++;
+}
+
+#if 0  /* TODO VxLAN Support */
+static struct bfd_pkt *
+ptm_bfd_process_vxlan_pkt(int s, ptm_sockevent_e se, void *udata, int *ifindex,
+			  struct sockaddr_in *sin,
+			  struct bfd_session_vxlan_info_t *vxlan_info,
+			  uint8_t *rx_pkt, int *mlen)
+{
+	struct sockaddr_ll sll;
+	uint32_t from_len = sizeof(struct sockaddr_ll);
+	struct bfd_raw_ctrl_pkt *cp;
+	uint8_t *pkt = rx_pkt;
+	struct iphdr *iph;
+	struct ethhdr *inner_ethh;
+
+	*mlen = recvfrom(s, rx_pkt, BFD_RX_BUF_LEN, MSG_DONTWAIT,
+			 (struct sockaddr *)&sll, &from_len);
+
+	if (*mlen < 0) {
+		if (errno != EAGAIN)
+			ERRLOG("Error receiving from BFD Vxlan socket %d: %m",
+			       s);
+		return NULL;
+	}
+
+	iph = (struct iphdr *)(pkt + ETH_HDR_LEN);
+	pkt = pkt + ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN;
+	vxlan_info->vnid = ntohl(*((int *)(pkt + 4)));
+	vxlan_info->vnid = vxlan_info->vnid >> 8;
+
+	pkt = pkt + VXLAN_HDR_LEN;
+	inner_ethh = (struct ethhdr *)pkt;
+
+	cp = (struct bfd_raw_ctrl_pkt *)(pkt + ETH_HDR_LEN);
+
+	/* Discard the non BFD packets */
+	if (ntohs(cp->udp.dest) != BFD_DEFDESTPORT)
+		return NULL;
+
+	*ifindex = sll.sll_ifindex;
+	sin->sin_addr.s_addr = iph->saddr;
+	sin->sin_port = ntohs(cp->udp.dest);
+
+	vxlan_info->local_dst_ip.s_addr = cp->ip.daddr;
+	memcpy(vxlan_info->local_dst_mac, inner_ethh->h_dest,
+	       ETHERNET_ADDRESS_LENGTH);
+
+	return &cp->data;
+}
+#endif /* VxLAN */
+
+static bool
+ptm_bfd_validate_vxlan_pkt(struct bfd_session *bfd,
+			   struct bfd_session_vxlan_info *vxlan_info)
+{
+	if (bfd->vxlan_info.check_tnl_key && (vxlan_info->vnid != 0)) {
+		log_error("vxlan-packet: vnid not zero: %d", vxlan_info->vnid);
+		return false;
+	}
+
+	if (bfd->vxlan_info.local_dst_ip.s_addr
+	    != vxlan_info->local_dst_ip.s_addr) {
+		log_error("vxlan-packet: wrong inner destination",
+			  inet_ntoa(vxlan_info->local_dst_ip));
+		return false;
+	}
+
+	if (memcmp(bfd->vxlan_info.local_dst_mac, vxlan_info->local_dst_mac,
+		   ETHERNET_ADDRESS_LENGTH)) {
+		log_error(
+			"vxlan-packet: wrong inner mac: %02x:%02x:%02x:%02x:%02x:%02x",
+			vxlan_info->local_dst_mac[0],
+			vxlan_info->local_dst_mac[1],
+			vxlan_info->local_dst_mac[2],
+			vxlan_info->local_dst_mac[3],
+			vxlan_info->local_dst_mac[4],
+			vxlan_info->local_dst_mac[5]);
+		return false;
+	}
+
+	return true;
+}
+
+static ssize_t bfd_recv_ipv4(int sd, bool is_mhop, char *port, size_t portlen,
+			     char *vrfname, size_t vrfnamelen,
+			     struct sockaddr_any *local,
+			     struct sockaddr_any *peer)
+{
+	struct cmsghdr *cm;
+	int ifindex;
+	ssize_t mlen;
+	struct sockaddr_in msgaddr;
+	struct msghdr msghdr;
+	struct iovec iov[1];
+	uint8_t cmsgbuf[255];
+
+	/* Prepare the recvmsg params. */
+	iov[0].iov_base = msgbuf;
+	iov[0].iov_len = sizeof(msgbuf);
+
+	memset(&msghdr, 0, sizeof(msghdr));
+	msghdr.msg_name = &msgaddr;
+	msghdr.msg_namelen = sizeof(msgaddr);
+	msghdr.msg_iov = iov;
+	msghdr.msg_iovlen = 1;
+	msghdr.msg_control = cmsgbuf;
+	msghdr.msg_controllen = sizeof(cmsgbuf);
+
+	mlen = recvmsg(sd, &msghdr, MSG_DONTWAIT);
+	if (mlen == -1) {
+		if (errno != EAGAIN)
+			log_error("ipv4-recv: recv failed: %s",
+				  strerror(errno));
+
+		return -1;
+	}
+
+	/* Get source address */
+	peer->sa_sin = *((struct sockaddr_in *)(msghdr.msg_name));
+
+	/* Get and check TTL */
+	for (cm = CMSG_FIRSTHDR(&msghdr); cm != NULL;
+	     cm = CMSG_NXTHDR(&msghdr, cm)) {
+		if (cm->cmsg_level != IPPROTO_IP)
+			continue;
+
+		switch (cm->cmsg_type) {
+#ifdef BFD_LINUX
+		case IP_TTL: {
+			uint32_t ttl;
+
+			memcpy(&ttl, CMSG_DATA(cm), sizeof(ttl));
+			if ((is_mhop == false) && (ttl != BFD_TTL_VAL)) {
+				log_debug(
+					"ipv4-recv: invalid TTL from %s (expected %d, got %d flags %d)",
+					satostr(peer), ttl, BFD_TTL_VAL,
+					msghdr.msg_flags);
+				return -1;
+			}
+			break;
+		}
+
+		case IP_PKTINFO: {
+			struct in_pktinfo *pi =
+				(struct in_pktinfo *)CMSG_DATA(cm);
+
+			if (pi == NULL)
+				break;
+
+			local->sa_sin.sin_family = AF_INET;
+			local->sa_sin.sin_addr = pi->ipi_addr;
+			fetch_portname_from_ifindex(pi->ipi_ifindex, port,
+						    portlen);
+			break;
+		}
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+		case IP_RECVTTL: {
+			uint8_t ttl;
+
+			memcpy(&ttl, CMSG_DATA(cm), sizeof(ttl));
+			if ((is_mhop == false) && (ttl != BFD_TTL_VAL)) {
+				log_debug(
+					"ipv4-recv: invalid TTL from %s (expected %d, got %d flags %d)",
+					satostr(peer), ttl, BFD_TTL_VAL,
+					msghdr.msg_flags);
+				return -1;
+			}
+			break;
+		}
+
+		case IP_RECVDSTADDR: {
+			struct in_addr ia;
+
+			memcpy(&ia, CMSG_DATA(cm), sizeof(ia));
+			local->sa_sin.sin_family = AF_INET;
+			local->sa_sin.sin_addr = ia;
+			break;
+		}
+#endif /* BFD_BSD */
+
+		default:
+			/*
+			 * On *BSDs we expect to land here when skipping
+			 * the IP_RECVIF header. It will be handled by
+			 * getsockopt_ifindex() below.
+			 */
+			/* NOTHING */
+			break;
+		}
+	}
+
+	/* OS agnostic way of getting interface name. */
+	if (port[0] == 0) {
+		ifindex = getsockopt_ifindex(AF_INET, &msghdr);
+		if (ifindex > 0)
+			fetch_portname_from_ifindex(ifindex, port, portlen);
+	}
+
+	return mlen;
+}
+
+ssize_t bfd_recv_ipv6(int sd, bool is_mhop, char *port, size_t portlen,
+		      char *vrfname, size_t vrfnamelen,
+		      struct sockaddr_any *local, struct sockaddr_any *peer)
+{
+	struct cmsghdr *cm;
+	struct in6_pktinfo *pi6 = NULL;
+	int ifindex = 0;
+	ssize_t mlen;
+	struct sockaddr_in6 msgaddr6;
+	struct msghdr msghdr6;
+	struct iovec iov[1];
+	uint8_t cmsgbuf6[255];
+
+	/* Prepare the recvmsg params. */
+	iov[0].iov_base = msgbuf;
+	iov[0].iov_len = sizeof(msgbuf);
+
+	memset(&msghdr6, 0, sizeof(msghdr6));
+	msghdr6.msg_name = &msgaddr6;
+	msghdr6.msg_namelen = sizeof(msgaddr6);
+	msghdr6.msg_iov = iov;
+	msghdr6.msg_iovlen = 1;
+	msghdr6.msg_control = cmsgbuf6;
+	msghdr6.msg_controllen = sizeof(cmsgbuf6);
+
+	mlen = recvmsg(sd, &msghdr6, MSG_DONTWAIT);
+	if (mlen == -1) {
+		if (errno != EAGAIN)
+			log_error("ipv4-recv: recv failed: %s",
+				  strerror(errno));
+
+		return -1;
+	}
+
+	/* Get source address */
+	peer->sa_sin6 = *((struct sockaddr_in6 *)(msghdr6.msg_name));
+
+	/* Get and check TTL */
+	for (cm = CMSG_FIRSTHDR(&msghdr6); cm != NULL;
+	     cm = CMSG_NXTHDR(&msghdr6, cm)) {
+		if (cm->cmsg_level != IPPROTO_IPV6)
+			continue;
+
+		if (cm->cmsg_type == IPV6_HOPLIMIT) {
+			memcpy(&ttlval, CMSG_DATA(cm), 4);
+			if ((is_mhop == false) && (ttlval != BFD_TTL_VAL)) {
+				log_debug(
+					"ipv6-recv: invalid TTL from %s (expected %d, got %d flags %d)",
+					satostr(peer), ttlval, BFD_TTL_VAL,
+					msghdr6.msg_flags);
+				return -1;
+			}
+		} else if (cm->cmsg_type == IPV6_PKTINFO) {
+			pi6 = (struct in6_pktinfo *)CMSG_DATA(cm);
+			if (pi6) {
+				local->sa_sin.sin_family = AF_INET6;
+				local->sa_sin6.sin6_addr = pi6->ipi6_addr;
+				fetch_portname_from_ifindex(pi6->ipi6_ifindex,
+							    port, portlen);
+				ifindex = pi6->ipi6_ifindex;
+			}
+		}
+	}
+
+	/* Set scope ID for link local addresses. */
+	if (IN6_IS_ADDR_LINKLOCAL(&peer->sa_sin6.sin6_addr))
+		peer->sa_sin6.sin6_scope_id = ifindex;
+	if (IN6_IS_ADDR_LINKLOCAL(&local->sa_sin6.sin6_addr))
+		local->sa_sin6.sin6_scope_id = ifindex;
+
+	return mlen;
+}
+
+static void bfd_sd_reschedule(int sd)
+{
+	if (sd == bglobal.bg_shop) {
+		bglobal.bg_ev[0] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_shop,
+				&bglobal.bg_ev[0]);
+	} else if (sd == bglobal.bg_mhop) {
+		bglobal.bg_ev[1] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_mhop,
+				&bglobal.bg_ev[1]);
+	} else if (sd == bglobal.bg_shop6) {
+		bglobal.bg_ev[2] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_shop6,
+				&bglobal.bg_ev[2]);
+	} else if (sd == bglobal.bg_mhop6) {
+		bglobal.bg_ev[3] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_mhop6,
+				&bglobal.bg_ev[3]);
+	} else if (sd == bglobal.bg_echo) {
+		bglobal.bg_ev[4] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_echo,
+				&bglobal.bg_ev[4]);
+	} else if (sd == bglobal.bg_vxlan) {
+		bglobal.bg_ev[5] = NULL;
+		thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_vxlan,
+				&bglobal.bg_ev[5]);
+	}
+}
+
+static void cp_debug(bool mhop, struct sockaddr_any *peer,
+		     struct sockaddr_any *local, const char *port,
+		     const char *vrf, const char *fmt, ...)
+{
+	char buf[512], peerstr[128], localstr[128], portstr[64], vrfstr[64];
+	va_list vl;
+
+	if (peer->sa_sin.sin_family)
+		snprintf(peerstr, sizeof(peerstr), " peer:%s", satostr(peer));
+	else
+		peerstr[0] = 0;
+
+	if (local->sa_sin.sin_family)
+		snprintf(localstr, sizeof(localstr), " local:%s",
+			 satostr(local));
+	else
+		localstr[0] = 0;
+
+	if (port[0])
+		snprintf(portstr, sizeof(portstr), " port:%s", port);
+	else
+		portstr[0] = 0;
+
+	if (vrf[0])
+		snprintf(vrfstr, sizeof(vrfstr), " vrf:%s", port);
+	else
+		vrfstr[0] = 0;
+
+	va_start(vl, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, vl);
+	va_end(vl);
+
+	log_debug("control-packet: %s [mhop:%s%s%s%s%s]", buf,
+		  mhop ? "yes" : "no", peerstr, localstr, portstr, vrfstr);
+}
+
+int bfd_recv_cb(struct thread *t)
+{
+	int sd = THREAD_FD(t);
+	struct bfd_session *bfd;
+	struct bfd_pkt *cp;
+	bool is_mhop, is_vxlan;
+	ssize_t mlen = 0;
+	uint32_t oldEchoXmt_TO, oldXmtTime;
+	struct sockaddr_any local, peer;
+	char port[MAXNAMELEN + 1], vrfname[MAXNAMELEN + 1];
+	struct bfd_session_vxlan_info vxlan_info;
+
+	/* Schedule next read. */
+	bfd_sd_reschedule(sd);
+
+	/* Handle echo packets. */
+	if (sd == bglobal.bg_echo) {
+		ptm_bfd_process_echo_pkt(sd);
+		return 0;
+	}
+
+	/* Sanitize input/output. */
+	memset(port, 0, sizeof(port));
+	memset(vrfname, 0, sizeof(vrfname));
+	memset(&local, 0, sizeof(local));
+	memset(&peer, 0, sizeof(peer));
+
+	/* Handle control packets. */
+	is_mhop = is_vxlan = false;
+	if (sd == bglobal.bg_shop || sd == bglobal.bg_mhop) {
+		is_mhop = sd == bglobal.bg_mhop;
+		mlen = bfd_recv_ipv4(sd, is_mhop, port, sizeof(port), vrfname,
+				     sizeof(vrfname), &local, &peer);
+	} else if (sd == bglobal.bg_shop6 || sd == bglobal.bg_mhop6) {
+		is_mhop = sd == bglobal.bg_mhop6;
+		mlen = bfd_recv_ipv6(sd, is_mhop, port, sizeof(port), vrfname,
+				     sizeof(vrfname), &local, &peer);
+	}
+#if 0 /* TODO vxlan handling */
+	cp = ptm_bfd_process_vxlan_pkt(s, se, udata, &local_ifindex,
+				       &sin, &vxlan_info, rx_pkt, &mlen);
+	if (!cp)
+		return -1;
+
+	is_vxlan = true;
+	/* keep in network-byte order */
+	peer.ip4_addr.s_addr = sin.sin_addr.s_addr;
+	peer.family = AF_INET;
+	strcpy(peer_addr, inet_ntoa(sin.sin_addr));
+#endif
+
+	/* Implement RFC 5880 6.8.6 */
+	if (mlen < BFD_PKT_LEN) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "too small (%ld bytes)", mlen);
+		return 0;
+	}
+
+	/*
+	 * Parse the control header for inconsistencies:
+	 * - Invalid version;
+	 * - Bad multiplier configuration;
+	 * - Short packets;
+	 * - Invalid discriminator;
+	 */
+	cp = (struct bfd_pkt *)(msgbuf);
+	if (BFD_GETVER(cp->diag) != BFD_VERSION) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "bad version %d", BFD_GETVER(cp->diag));
+		return 0;
+	}
+
+	if (cp->detect_mult == 0) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "detect multiplier set to zero");
+		return 0;
+	}
+
+	if ((cp->len < BFD_PKT_LEN) || (cp->len > mlen)) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname, "too small");
+		return 0;
+	}
+
+	if (cp->discrs.my_discr == 0) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "'my discriminator' is zero");
+		return 0;
+	}
+
+	/* Find the session that this packet belongs. */
+	bfd = ptm_bfd_sess_find(cp, port, &peer, &local, vrfname, is_mhop);
+	if (bfd == NULL) {
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "no session found");
+		return 0;
+	}
+
+	/* Handle VxLAN cases. */
+	if (is_vxlan && !ptm_bfd_validate_vxlan_pkt(bfd, &vxlan_info))
+		return 0;
+
+	bfd->stats.rx_ctrl_pkt++;
+
+	/*
+	 * Multi hop: validate packet TTL.
+	 * Single hop: set local address that received the packet.
+	 */
+	if (is_mhop) {
+		if ((BFD_TTL_VAL - bfd->mh_ttl) > ttlval) {
+			cp_debug(is_mhop, &peer, &local, port, vrfname,
+				 "exceeded max hop count (expected %d, got %d)",
+				 bfd->mh_ttl, ttlval);
+			return 0;
+		}
+	} else if (bfd->local_ip.sa_sin.sin_family == AF_UNSPEC) {
+		bfd->local_ip = local;
+	}
+
+	/*
+	 * If no interface was detected, save the interface where the
+	 * packet came in.
+	 */
+	if (bfd->ifindex == 0)
+		bfd->ifindex = ptm_bfd_fetch_ifindex(port);
+
+	/* Log remote discriminator changes. */
+	if ((bfd->discrs.remote_discr != 0)
+	    && (bfd->discrs.remote_discr != ntohl(cp->discrs.my_discr)))
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "remote discriminator mismatch (expected %d, got %d)",
+			 bfd->discrs.remote_discr, ntohl(cp->discrs.my_discr));
+
+	bfd->discrs.remote_discr = ntohl(cp->discrs.my_discr);
+
+	/* If received the Final bit, the new values should take effect */
+	if (bfd->polling && BFD_GETFBIT(cp->flags)) {
+		bfd->timers.desired_min_tx = bfd->new_timers.desired_min_tx;
+		bfd->timers.required_min_rx = bfd->new_timers.required_min_rx;
+		bfd->new_timers.desired_min_tx = 0;
+		bfd->new_timers.required_min_rx = 0;
+		bfd->polling = 0;
+	}
+
+	if (!bfd->demand_mode) {
+		/* Compute detect time */
+		bfd->detect_TO = cp->detect_mult
+				 * ((bfd->timers.required_min_rx
+				     > ntohl(cp->timers.desired_min_tx))
+					    ? bfd->timers.required_min_rx
+					    : ntohl(cp->timers.desired_min_tx));
+		bfd->remote_detect_mult = cp->detect_mult;
+	} else
+		cp_debug(is_mhop, &peer, &local, port, vrfname,
+			 "unsupported demand mode");
+
+	/* Save remote diagnostics before state switch. */
+	bfd->remote_diag = cp->diag & BFD_DIAGMASK;
+
+	/* State switch from section 6.8.6 */
+	if (BFD_GETSTATE(cp->flags) == PTM_BFD_ADM_DOWN) {
+		if (bfd->ses_state != PTM_BFD_DOWN)
+			ptm_bfd_ses_dn(bfd, BFD_DIAGNEIGHDOWN);
+	} else {
+		switch (bfd->ses_state) {
+		case (PTM_BFD_DOWN):
+			if (BFD_GETSTATE(cp->flags) == PTM_BFD_INIT)
+				ptm_bfd_ses_up(bfd);
+			else if (BFD_GETSTATE(cp->flags) == PTM_BFD_DOWN)
+				bfd->ses_state = PTM_BFD_INIT;
+			break;
+		case (PTM_BFD_INIT):
+			if (BFD_GETSTATE(cp->flags) == PTM_BFD_INIT
+			    || BFD_GETSTATE(cp->flags) == PTM_BFD_UP)
+				ptm_bfd_ses_up(bfd);
+			break;
+		case (PTM_BFD_UP):
+			if (BFD_GETSTATE(cp->flags) == PTM_BFD_DOWN)
+				ptm_bfd_ses_dn(bfd, BFD_DIAGNEIGHDOWN);
+			break;
+		}
+	}
+
+	/*
+	 * Handle echo packet status:
+	 * - Start echo packets if configured and permitted
+	 *   (required_min_echo > 0);
+	 * - Stop echo packets if not allowed (required_min_echo == 0);
+	 * - Recalculate echo packet interval;
+	 */
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO)) {
+		if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE)) {
+			if (!ntohl(cp->timers.required_min_echo)) {
+				ptm_bfd_echo_stop(bfd, 1);
+			} else {
+				oldEchoXmt_TO = bfd->echo_xmt_TO;
+				bfd->echo_xmt_TO =
+					bfd->timers.required_min_echo;
+				if (ntohl(cp->timers.required_min_echo)
+				    > bfd->echo_xmt_TO)
+					bfd->echo_xmt_TO = ntohl(
+						cp->timers.required_min_echo);
+				if (oldEchoXmt_TO != bfd->echo_xmt_TO)
+					ptm_bfd_echo_start(bfd);
+			}
+		} else if (ntohl(cp->timers.required_min_echo)) {
+			bfd->echo_xmt_TO = bfd->timers.required_min_echo;
+			if (ntohl(cp->timers.required_min_echo)
+			    > bfd->echo_xmt_TO)
+				bfd->echo_xmt_TO =
+					ntohl(cp->timers.required_min_echo);
+			ptm_bfd_echo_start(bfd);
+		}
+	}
+
+	if (BFD_CHECK_FLAG(bfd->flags, BFD_SESS_FLAG_ECHO_ACTIVE)) {
+		bfd->echo_xmt_TO = bfd->timers.required_min_echo;
+		if (ntohl(cp->timers.required_min_echo) > bfd->echo_xmt_TO)
+			bfd->echo_xmt_TO = ntohl(cp->timers.required_min_echo);
+	}
+
+	/* Calculate new transmit time */
+	oldXmtTime = bfd->xmt_TO;
+	bfd->xmt_TO =
+		(bfd->timers.desired_min_tx > ntohl(cp->timers.required_min_rx))
+			? bfd->timers.desired_min_tx
+			: ntohl(cp->timers.required_min_rx);
+
+	/* If transmit time has changed, and too much time until next xmt,
+	 * restart
+	 */
+	if (BFD_GETPBIT(cp->flags)) {
+		ptm_bfd_xmt_TO(bfd, 1);
+	} else if (oldXmtTime != bfd->xmt_TO) {
+		/* XXX add some skid to this as well */
+		ptm_bfd_start_xmt_timer(bfd, false);
+	}
+
+	/* Restart detection timer (packet received) */
+	if (!bfd->demand_mode)
+		bfd_recvtimer_update(bfd);
+
+	/*
+	 * Save the timers and state sent by the remote end
+	 * for debugging and statistics.
+	 */
+	if (BFD_GETFBIT(cp->flags)) {
+		bfd->remote_timers.desired_min_tx =
+			ntohl(cp->timers.desired_min_tx);
+		bfd->remote_timers.required_min_rx =
+			ntohl(cp->timers.required_min_rx);
+		bfd->remote_timers.required_min_echo =
+			ntohl(cp->timers.required_min_echo);
+
+		control_notify_config(BCM_NOTIFY_CONFIG_UPDATE, bfd);
+	}
+
+	return 0;
+}
+
+
+/*
+ * Sockets creation.
+ */
+
+
+/*
+ * IPv4 sockets
+ */
+int bp_set_ttl(int sd)
+{
+	if (setsockopt(sd, IPPROTO_IP, IP_TTL, &ttlval, sizeof(ttlval)) == -1) {
+		log_warning("%s: setsockopt(IP_TTL): %s", __func__,
+			    strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+int bp_set_tos(int sd)
+{
+	if (setsockopt(sd, IPPROTO_IP, IP_TOS, &tosval, sizeof(tosval)) == -1) {
+		log_warning("%s: setsockopt(IP_TOS): %s", __func__,
+			    strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void bp_set_ipopts(int sd)
+{
+	if (bp_set_ttl(sd) != 0)
+		log_fatal("%s: TTL configuration failed", __func__);
+
+	if (setsockopt(sd, IPPROTO_IP, IP_RECVTTL, &rcvttl, sizeof(rcvttl))
+	    == -1)
+		log_fatal("%s: setsockopt(IP_RECVTTL): %s", __func__,
+			  strerror(errno));
+
+#ifdef BFD_LINUX
+	int pktinfo = BFD_PKT_INFO_VAL;
+	/* Figure out address and interface to do the peer matching. */
+	if (setsockopt(sd, IPPROTO_IP, IP_PKTINFO, &pktinfo, sizeof(pktinfo))
+	    == -1)
+		log_fatal("%s: setsockopt(IP_PKTINFO): %s", __func__,
+			  strerror(errno));
+#endif /* BFD_LINUX */
+#ifdef BFD_BSD
+	int yes = 1;
+
+	/* Find out our address for peer matching. */
+	if (setsockopt(sd, IPPROTO_IP, IP_RECVDSTADDR, &yes, sizeof(yes)) == -1)
+		log_fatal("%s: setsockopt(IP_RECVDSTADDR): %s", __func__,
+			  strerror(errno));
+
+	/* Find out interface where the packet came in. */
+	if (setsockopt_ifindex(AF_INET, sd, yes) == -1)
+		log_fatal("%s: setsockopt_ipv4_ifindex: %s", __func__,
+			  strerror(errno));
+#endif /* BFD_BSD */
+}
+
+static void bp_bind_ip(int sd, uint16_t port)
+{
+	struct sockaddr_in sin;
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = htonl(INADDR_ANY);
+	sin.sin_port = htons(port);
+	if (bind(sd, (struct sockaddr *)&sin, sizeof(sin)) == -1)
+		log_fatal("%s: bind: %s", __func__, strerror(errno));
+}
+
+int bp_udp_shop(void)
+{
+	int sd;
+
+	sd = socket(AF_INET, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1)
+		log_fatal("%s: socket: %s", __func__, strerror(errno));
+
+	bp_set_ipopts(sd);
+	bp_bind_ip(sd, BFD_DEFDESTPORT);
+
+	return sd;
+}
+
+int bp_udp_mhop(void)
+{
+	int sd;
+
+	sd = socket(AF_INET, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1)
+		log_fatal("%s: socket: %s", __func__, strerror(errno));
+
+	bp_set_ipopts(sd);
+	bp_bind_ip(sd, BFD_DEF_MHOP_DEST_PORT);
+
+	return sd;
+}
+
+int bp_peer_socket(struct bfd_peer_cfg *bpc)
+{
+	int sd, pcount;
+	struct sockaddr_in sin;
+	static int srcPort = BFD_SRCPORTINIT;
+
+	sd = socket(AF_INET, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1) {
+		log_error("ipv4-new: failed to create socket: %s",
+			  strerror(errno));
+		return -1;
+	}
+
+	if (!bpc->bpc_has_vxlan) {
+		/* Set TTL to 255 for all transmitted packets */
+		if (bp_set_ttl(sd) != 0) {
+			close(sd);
+			return -1;
+		}
+	}
+
+	/* Set TOS to CS6 for all transmitted packets */
+	if (bp_set_tos(sd) != 0) {
+		close(sd);
+		return -1;
+	}
+
+	/* dont bind-to-device incase of vxlan */
+	if (!bpc->bpc_has_vxlan && bpc->bpc_has_localif) {
+		if (bp_bind_dev(sd, bpc->bpc_localif) != 0) {
+			close(sd);
+			return -1;
+		}
+	} else if (bpc->bpc_mhop && bpc->bpc_has_vrfname) {
+		if (bp_bind_dev(sd, bpc->bpc_vrfname) != 0) {
+			close(sd);
+			return -1;
+		}
+	}
+
+	/* Find an available source port in the proper range */
+	memset(&sin, 0, sizeof(sin));
+	sin = bpc->bpc_local.sa_sin;
+	sin.sin_family = AF_INET;
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+	sin.sin_len = sizeof(sin);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+	if (bpc->bpc_mhop || bpc->bpc_has_vxlan)
+		sin.sin_addr = bpc->bpc_local.sa_sin.sin_addr;
+	else
+		sin.sin_addr.s_addr = INADDR_ANY;
+
+	pcount = 0;
+	do {
+		if ((++pcount) > (BFD_SRCPORTMAX - BFD_SRCPORTINIT)) {
+			/* Searched all ports, none available */
+			log_error("ipv4-new: failed to bind port: %s",
+				  strerror(errno));
+			close(sd);
+			return -1;
+		}
+		if (srcPort >= BFD_SRCPORTMAX)
+			srcPort = BFD_SRCPORTINIT;
+		sin.sin_port = htons(srcPort++);
+	} while (bind(sd, (struct sockaddr *)&sin, sizeof(sin)) < 0);
+
+	return sd;
+}
+
+
+/*
+ * IPv6 sockets
+ */
+
+int bp_peer_socketv6(struct bfd_peer_cfg *bpc)
+{
+	int sd, pcount, ifindex;
+	struct sockaddr_in6 sin6;
+	static int srcPort = BFD_SRCPORTINIT;
+
+	sd = socket(AF_INET6, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1) {
+		log_error("ipv6-new: failed to create socket: %s",
+			  strerror(errno));
+		return -1;
+	}
+
+	if (!bpc->bpc_has_vxlan) {
+		/* Set TTL to 255 for all transmitted packets */
+		if (bp_set_ttlv6(sd) != 0) {
+			close(sd);
+			return -1;
+		}
+	}
+
+	/* Set TOS to CS6 for all transmitted packets */
+	if (bp_set_tosv6(sd) != 0) {
+		close(sd);
+		return -1;
+	}
+
+	/* Find an available source port in the proper range */
+	memset(&sin6, 0, sizeof(sin6));
+	sin6.sin6_family = AF_INET6;
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+	sin6.sin6_len = sizeof(sin6);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+	sin6 = bpc->bpc_local.sa_sin6;
+	ifindex = ptm_bfd_fetch_ifindex(bpc->bpc_localif);
+	if (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr))
+		sin6.sin6_scope_id = ifindex;
+
+	if (bpc->bpc_has_localif) {
+		if (bp_bind_dev(sd, bpc->bpc_localif) != 0) {
+			close(sd);
+			return -1;
+		}
+	} else if (bpc->bpc_mhop && bpc->bpc_has_vrfname) {
+		if (bp_bind_dev(sd, bpc->bpc_vrfname) != 0) {
+			close(sd);
+			return -1;
+		}
+	}
+
+	pcount = 0;
+	do {
+		if ((++pcount) > (BFD_SRCPORTMAX - BFD_SRCPORTINIT)) {
+			/* Searched all ports, none available */
+			log_error("ipv6-new: failed to bind port: %s",
+				  strerror(errno));
+			close(sd);
+			return -1;
+		}
+		if (srcPort >= BFD_SRCPORTMAX)
+			srcPort = BFD_SRCPORTINIT;
+		sin6.sin6_port = htons(srcPort++);
+	} while (bind(sd, (struct sockaddr *)&sin6, sizeof(sin6)) < 0);
+
+	return sd;
+}
+
+int bp_set_ttlv6(int sd)
+{
+	if (setsockopt(sd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttlval,
+		       sizeof(ttlval))
+	    == -1) {
+		log_warning("%s: setsockopt(IPV6_UNICAST_HOPS): %s", __func__,
+			    strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+int bp_set_tosv6(int sd)
+{
+	if (setsockopt(sd, IPPROTO_IPV6, IPV6_TCLASS, &tosval, sizeof(tosval))
+	    == -1) {
+		log_warning("%s: setsockopt(IPV6_TCLASS): %s", __func__,
+			    strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void bp_set_ipv6opts(int sd)
+{
+	static int ipv6_pktinfo = BFD_IPV6_PKT_INFO_VAL;
+	static int ipv6_only = BFD_IPV6_ONLY_VAL;
+
+	if (setsockopt(sd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttlval,
+		       sizeof(ttlval))
+	    == -1)
+		log_fatal("%s: setsockopt(IPV6_UNICAST_HOPS): %s", __func__,
+			  strerror(errno));
+
+	if (setsockopt_ipv6_hoplimit(sd, rcvttl) == -1)
+		log_fatal("%s: setsockopt(IPV6_HOPLIMIT): %s", __func__,
+			  strerror(errno));
+
+	if (setsockopt_ipv6_pktinfo(sd, ipv6_pktinfo) == -1)
+		log_fatal("%s: setsockopt(IPV6_PKTINFO): %s", __func__,
+			  strerror(errno));
+
+	if (setsockopt(sd, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6_only,
+		       sizeof(ipv6_only))
+	    == -1)
+		log_fatal("%s: setsockopt(IPV6_V6ONLY): %s", __func__,
+			  strerror(errno));
+}
+
+static void bp_bind_ipv6(int sd, uint16_t port)
+{
+	struct sockaddr_in6 sin6;
+
+	memset(&sin6, 0, sizeof(sin6));
+	sin6.sin6_family = AF_INET6;
+	sin6.sin6_addr = in6addr_any;
+	sin6.sin6_port = htons(port);
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+	sin6.sin6_len = sizeof(sin6);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+	if (bind(sd, (struct sockaddr *)&sin6, sizeof(sin6)) == -1)
+		log_fatal("%s: bind: %s", __func__, strerror(errno));
+}
+
+int bp_udp6_shop(void)
+{
+	int sd;
+
+	sd = socket(AF_INET6, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1)
+		log_fatal("%s: socket: %s", __func__, strerror(errno));
+
+	bp_set_ipv6opts(sd);
+	bp_bind_ipv6(sd, BFD_DEFDESTPORT);
+
+	return sd;
+}
+
+int bp_udp6_mhop(void)
+{
+	int sd;
+
+	sd = socket(AF_INET6, SOCK_DGRAM, PF_UNSPEC);
+	if (sd == -1)
+		log_fatal("%s: socket: %s", __func__, strerror(errno));
+
+	bp_set_ipv6opts(sd);
+	bp_bind_ipv6(sd, BFD_DEF_MHOP_DEST_PORT);
+
+	return sd;
+}
diff -urpN frr-frr-5.0.1/bfdd/bfdctl.h frr-frr-6.0/bfdd/bfdctl.h
--- frr-frr-5.0.1/bfdd/bfdctl.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfdctl.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,160 @@
+/*********************************************************************
+ * Copyright 2017-2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * bfdctl.h: all BFDd control socket protocol definitions.
+ *
+ * Authors
+ * -------
+ * Rafael Zalamena <rzalamena@opensourcerouting.org>
+ */
+
+#ifndef _BFDCTRL_H_
+#define _BFDCTRL_H_
+
+#include <netinet/in.h>
+
+#include <stdbool.h>
+#include <stdint.h>
+
+/*
+ * Auxiliary definitions
+ */
+struct sockaddr_any {
+	union {
+		struct sockaddr_in sa_sin;
+		struct sockaddr_in6 sa_sin6;
+	};
+};
+
+#ifndef MAXNAMELEN
+#define MAXNAMELEN 32
+#endif
+
+#define BPC_DEF_DETECTMULTIPLIER 3
+#define BPC_DEF_RECEIVEINTERVAL 300  /* milliseconds */
+#define BPC_DEF_TRANSMITINTERVAL 300 /* milliseconds */
+#define BPC_DEF_ECHOINTERVAL 50      /* milliseconds */
+
+/* Peer status */
+enum bfd_peer_status {
+	BPS_SHUTDOWN = 0, /* == PTM_BFD_ADM_DOWN, "adm-down" */
+	BPS_DOWN = 1,     /* == PTM_BFD_DOWN, "down" */
+	BPS_INIT = 2,     /* == PTM_BFD_INIT, "init" */
+	BPS_UP = 3,       /* == PTM_BFD_UP, "up" */
+};
+
+struct bfd_peer_cfg {
+	bool bpc_mhop;
+	bool bpc_ipv4;
+	struct sockaddr_any bpc_peer;
+	struct sockaddr_any bpc_local;
+
+	bool bpc_has_label;
+	char bpc_label[MAXNAMELEN];
+
+	bool bpc_has_vxlan;
+	unsigned int bpc_vxlan;
+
+	bool bpc_has_localif;
+	char bpc_localif[MAXNAMELEN + 1];
+
+	bool bpc_has_vrfname;
+	char bpc_vrfname[MAXNAMELEN + 1];
+
+	bool bpc_has_detectmultiplier;
+	uint8_t bpc_detectmultiplier;
+
+	bool bpc_has_recvinterval;
+	uint64_t bpc_recvinterval;
+
+	bool bpc_has_txinterval;
+	uint64_t bpc_txinterval;
+
+	bool bpc_has_echointerval;
+	uint64_t bpc_echointerval;
+
+	bool bpc_echo;
+	bool bpc_createonly;
+	bool bpc_shutdown;
+
+	/* Status information */
+	enum bfd_peer_status bpc_bps;
+	uint32_t bpc_id;
+	uint32_t bpc_remoteid;
+	uint8_t bpc_diag;
+	uint8_t bpc_remotediag;
+	uint8_t bpc_remote_detectmultiplier;
+	uint64_t bpc_remote_recvinterval;
+	uint64_t bpc_remote_txinterval;
+	uint64_t bpc_remote_echointerval;
+	uint64_t bpc_lastevent;
+};
+
+
+/*
+ * Protocol definitions
+ */
+enum bc_msg_version {
+	BMV_VERSION_1 = 1,
+};
+
+enum bc_msg_type {
+	BMT_RESPONSE = 1,
+	BMT_REQUEST_ADD = 2,
+	BMT_REQUEST_DEL = 3,
+	BMT_NOTIFY = 4,
+	BMT_NOTIFY_ADD = 5,
+	BMT_NOTIFY_DEL = 6,
+};
+
+/* Notify flags to use with bcm_notify. */
+#define BCM_NOTIFY_ALL ((uint64_t)-1)
+#define BCM_NOTIFY_PEER_STATE (1ULL << 0)
+#define BCM_NOTIFY_CONFIG (1ULL << 1)
+#define BCM_NOTIFY_NONE 0
+
+/* Response 'status' definitions. */
+#define BCM_RESPONSE_OK "ok"
+#define BCM_RESPONSE_ERROR "error"
+
+/* Notify operation. */
+#define BCM_NOTIFY_PEER_STATUS "status"
+#define BCM_NOTIFY_CONFIG_ADD "add"
+#define BCM_NOTIFY_CONFIG_DELETE "delete"
+#define BCM_NOTIFY_CONFIG_UPDATE "update"
+
+/* Notification special ID. */
+#define BCM_NOTIFY_ID 0
+
+struct bfd_control_msg {
+	/* Total length without the header. */
+	uint32_t bcm_length;
+	/*
+	 * Message request/response id.
+	 * All requests will have a correspondent response with the
+	 * same id.
+	 */
+	uint16_t bcm_id;
+	/* Message type. */
+	uint8_t bcm_type;
+	/* Message version. */
+	uint8_t bcm_ver;
+	/* Message payload. */
+	uint8_t bcm_data[0];
+};
+
+#endif
diff -urpN frr-frr-5.0.1/bfdd/bfdd.c frr-frr-6.0/bfdd/bfdd.c
--- frr-frr-5.0.1/bfdd/bfdd.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfdd.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,236 @@
+/*
+ * BFD daemon code
+ * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * FRR is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FRR; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "bfd.h"
+#include "lib/version.h"
+
+
+/*
+ * FRR related code.
+ */
+DEFINE_MGROUP(BFDD, "Bidirectional Forwarding Detection Daemon");
+DEFINE_MTYPE(BFDD, BFDD_TMP, "short-lived temporary memory");
+DEFINE_MTYPE(BFDD, BFDD_CONFIG, "long-lived configuration memory");
+DEFINE_MTYPE(BFDD, BFDD_LABEL, "long-lived label memory");
+DEFINE_MTYPE(BFDD, BFDD_CONTROL, "long-lived control socket memory");
+DEFINE_MTYPE(BFDD, BFDD_NOTIFICATION, "short-lived control notification data");
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* BFDd privileges */
+static zebra_capabilities_t _caps_p[] = {ZCAP_BIND};
+
+struct zebra_privs_t bfdd_privs = {
+#if defined(FRR_USER) && defined(FRR_GROUP)
+	.user = FRR_USER,
+	.group = FRR_GROUP,
+#endif
+#if defined(VTY_GROUP)
+	.vty_group = VTY_GROUP,
+#endif
+	.caps_p = _caps_p,
+	.cap_num_p = array_size(_caps_p),
+	.cap_num_i = 0,
+};
+
+void socket_close(int *s)
+{
+	if (*s <= 0)
+		return;
+
+	if (close(*s) != 0)
+		log_error("%s: close(%d): (%d) %s", __func__, *s, errno,
+			  strerror(errno));
+
+	*s = -1;
+}
+
+static void sigusr1_handler(void)
+{
+	zlog_rotate();
+}
+
+static void sigterm_handler(void)
+{
+	/* Signalize shutdown. */
+	frr_early_fini();
+
+	/* Stop receiving message from zebra. */
+	bfdd_zclient_stop();
+
+	/* Shutdown controller to avoid receiving anymore commands. */
+	control_shutdown();
+
+	/* Shutdown and free all protocol related memory. */
+	bfd_shutdown();
+
+	/* Close all descriptors. */
+	socket_close(&bglobal.bg_echo);
+	socket_close(&bglobal.bg_shop);
+	socket_close(&bglobal.bg_mhop);
+	socket_close(&bglobal.bg_shop6);
+	socket_close(&bglobal.bg_mhop6);
+	socket_close(&bglobal.bg_vxlan);
+
+	/* Terminate and free() FRR related memory. */
+	frr_fini();
+
+	exit(0);
+}
+
+static struct quagga_signal_t bfd_signals[] = {
+	{
+		.signal = SIGUSR1,
+		.handler = &sigusr1_handler,
+	},
+	{
+		.signal = SIGTERM,
+		.handler = &sigterm_handler,
+	},
+	{
+		.signal = SIGINT,
+		.handler = &sigterm_handler,
+	},
+};
+
+FRR_DAEMON_INFO(bfdd, BFD, .vty_port = 2617,
+		.proghelp = "Implementation of the BFD protocol.",
+		.signals = bfd_signals, .n_signals = array_size(bfd_signals),
+		.privs = &bfdd_privs)
+
+#define OPTION_CTLSOCK 1001
+static struct option longopts[] = {
+	{"bfdctl", required_argument, NULL, OPTION_CTLSOCK},
+	{0}
+};
+
+
+/*
+ * BFD daemon related code.
+ */
+struct bfd_global bglobal;
+
+struct bfd_diag_str_list diag_list[] = {
+	{.str = "NeighDown", .type = BFD_DIAGNEIGHDOWN},
+	{.str = "DetectTime", .type = BFD_DIAGDETECTTIME},
+	{.str = "AdminDown", .type = BFD_DIAGADMINDOWN},
+	{.str = NULL},
+};
+
+struct bfd_state_str_list state_list[] = {
+	{.str = "AdminDown", .type = PTM_BFD_ADM_DOWN},
+	{.str = "Down", .type = PTM_BFD_DOWN},
+	{.str = "Init", .type = PTM_BFD_INIT},
+	{.str = "Up", .type = PTM_BFD_UP},
+	{.str = NULL},
+};
+
+
+static void bg_init(void)
+{
+	TAILQ_INIT(&bglobal.bg_bcslist);
+
+	bglobal.bg_shop = bp_udp_shop();
+	bglobal.bg_mhop = bp_udp_mhop();
+	bglobal.bg_shop6 = bp_udp6_shop();
+	bglobal.bg_mhop6 = bp_udp6_mhop();
+	bglobal.bg_echo = ptm_bfd_echo_sock_init();
+	bglobal.bg_vxlan = ptm_bfd_vxlan_sock_init();
+}
+
+int main(int argc, char *argv[])
+{
+	const char *ctl_path = BFDD_CONTROL_SOCKET;
+	int opt;
+
+	frr_preinit(&bfdd_di, argc, argv);
+	frr_opt_add("", longopts,
+		    "      --bfdctl       Specify bfdd control socket\n");
+
+	while (true) {
+		opt = frr_getopt(argc, argv, NULL);
+		if (opt == EOF)
+			break;
+
+		switch (opt) {
+		case OPTION_CTLSOCK:
+			ctl_path = optarg;
+			break;
+
+		default:
+			frr_help_exit(1);
+			break;
+		}
+	}
+
+#if 0 /* TODO add support for JSON configuration files. */
+	parse_config(conf);
+#endif
+
+	/* Initialize logging API. */
+	log_init(1, BLOG_DEBUG, &bfdd_di);
+
+	/* Initialize system sockets. */
+	bg_init();
+
+	/* Initialize control socket. */
+	control_init(ctl_path);
+
+	/* Initialize FRR infrastructure. */
+	master = frr_init();
+
+	/* Initialize BFD data structures. */
+	bfd_initialize();
+
+	/* Initialize zebra connection. */
+	bfdd_zclient_init(&bfdd_privs);
+
+	/* Add descriptors to the event loop. */
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_shop,
+			&bglobal.bg_ev[0]);
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_mhop,
+			&bglobal.bg_ev[1]);
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_shop6,
+			&bglobal.bg_ev[2]);
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_mhop6,
+			&bglobal.bg_ev[3]);
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_echo,
+			&bglobal.bg_ev[4]);
+#if 0 /* TODO VxLAN support. */
+	thread_add_read(master, bfd_recv_cb, NULL, bglobal.bg_vxlan,
+			&bglobal.bg_ev[5]);
+#endif
+	thread_add_read(master, control_accept, NULL, bglobal.bg_csock,
+			&bglobal.bg_csockev);
+
+	/* Install commands. */
+	bfdd_vty_init();
+
+	/* read configuration file and daemonize  */
+	frr_config_fork();
+
+	frr_run(master);
+	/* NOTREACHED */
+
+	return 0;
+}
diff -urpN frr-frr-5.0.1/bfdd/bfdd.conf.sample frr-frr-6.0/bfdd/bfdd.conf.sample
--- frr-frr-5.0.1/bfdd/bfdd.conf.sample	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfdd.conf.sample	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,5 @@
+password zebra
+!
+log stdout
+!
+line vty
diff -urpN frr-frr-5.0.1/bfdd/bfdd_vty.c frr-frr-6.0/bfdd/bfdd_vty.c
--- frr-frr-5.0.1/bfdd/bfdd_vty.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bfdd_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,1037 @@
+/*
+ * BFD daemon code
+ * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * FRR is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FRR; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "lib/command.h"
+#include "lib/json.h"
+#include "lib/log.h"
+#include "lib/vty.h"
+
+#include "bfd.h"
+
+#ifndef VTYSH_EXTRACT_PL
+#include "bfdd/bfdd_vty_clippy.c"
+#endif
+
+/*
+ * Commands help string definitions.
+ */
+#define PEER_STR "Configure peer\n"
+#define INTERFACE_NAME_STR "Configure interface name to use\n"
+#define PEER_IPV4_STR "IPv4 peer address\n"
+#define PEER_IPV6_STR "IPv6 peer address\n"
+#define MHOP_STR "Configure multihop\n"
+#define LOCAL_STR "Configure local address\n"
+#define LOCAL_IPV4_STR "IPv4 local address\n"
+#define LOCAL_IPV6_STR "IPv6 local address\n"
+#define LOCAL_INTF_STR "Configure local interface name to use\n"
+#define VRF_STR "Configure VRF\n"
+#define VRF_NAME_STR "Configure VRF name\n"
+
+/*
+ * Prototypes
+ */
+static int bfdd_write_config(struct vty *vty);
+static int bfdd_peer_write_config(struct vty *vty);
+static void _bfdd_peer_write_config(struct hash_backet *hb, void *arg);
+static int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,
+			      const struct sockaddr_any *peer,
+			      const struct sockaddr_any *local,
+			      const char *ifname, const char *vrfname,
+			      char *ebuf, size_t ebuflen);
+
+static void _display_peer_header(struct vty *vty, struct bfd_session *bs);
+static struct json_object *__display_peer_json(struct bfd_session *bs);
+static struct json_object *_peer_json_header(struct bfd_session *bs);
+static void _display_peer_json(struct vty *vty, struct bfd_session *bs);
+static void _display_peer(struct vty *vty, struct bfd_session *bs);
+static void _display_all_peers(struct vty *vty, bool use_json);
+static void _display_peer_iter(struct hash_backet *hb, void *arg);
+static void _display_peer_json_iter(struct hash_backet *hb, void *arg);
+static void _display_peer_counter(struct vty *vty, struct bfd_session *bs);
+static struct json_object *__display_peer_counters_json(struct bfd_session *bs);
+static void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs);
+static void _display_peer_counter_iter(struct hash_backet *hb, void *arg);
+static void _display_peer_counter_json_iter(struct hash_backet *hb, void *arg);
+static void _display_peers_counter(struct vty *vty, bool use_json);
+static struct bfd_session *
+_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,
+		    const char *label, const char *peer_str,
+		    const char *local_str, const char *ifname,
+		    const char *vrfname);
+
+
+/*
+ * Commands definition.
+ */
+DEFUN_NOSH(bfd_enter, bfd_enter_cmd, "bfd", "Configure BFD peers\n")
+{
+	vty->node = BFD_NODE;
+	return CMD_SUCCESS;
+}
+
+DEFUN_NOSH(
+	bfd_peer_enter, bfd_peer_enter_cmd,
+	"peer <A.B.C.D|X:X::X:X> [{multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME|vrf NAME}]",
+	PEER_STR PEER_IPV4_STR PEER_IPV6_STR
+	MHOP_STR
+	LOCAL_STR LOCAL_IPV4_STR LOCAL_IPV6_STR
+	INTERFACE_STR
+	LOCAL_INTF_STR
+	VRF_STR VRF_NAME_STR)
+{
+	bool mhop;
+	int idx;
+	struct bfd_session *bs;
+	const char *peer, *ifname, *local, *vrfname;
+	struct bfd_peer_cfg bpc;
+	struct sockaddr_any psa, lsa, *lsap;
+	char errormsg[128];
+
+	vrfname = peer = ifname = local = NULL;
+
+	/* Gather all provided information. */
+	peer = argv[1]->arg;
+
+	idx = 0;
+	mhop = argv_find(argv, argc, "multihop", &idx);
+
+	idx = 0;
+	if (argv_find(argv, argc, "interface", &idx))
+		ifname = argv[idx + 1]->arg;
+
+	idx = 0;
+	if (argv_find(argv, argc, "local-address", &idx))
+		local = argv[idx + 1]->arg;
+
+	idx = 0;
+	if (argv_find(argv, argc, "vrf", &idx))
+		vrfname = argv[idx + 1]->arg;
+
+	if (vrfname && ifname) {
+		vty_out(vty, "%% VRF is not mixable with interface\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	strtosa(peer, &psa);
+	if (local) {
+		strtosa(local, &lsa);
+		lsap = &lsa;
+	} else
+		lsap = NULL;
+
+	if (bfd_configure_peer(&bpc, mhop, &psa, lsap, ifname, vrfname,
+			       errormsg, sizeof(errormsg))
+	    != 0) {
+		vty_out(vty, "%% Invalid peer configuration: %s\n", errormsg);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	bs = bs_peer_find(&bpc);
+	if (bs == NULL) {
+		bs = ptm_bfd_sess_new(&bpc);
+		if (bs == NULL) {
+			vty_out(vty, "%% Failed to add peer.\n");
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	VTY_PUSH_CONTEXT(BFD_PEER_NODE, bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_detectmultiplier, bfd_peer_detectmultiplier_cmd,
+      "detect-multiplier (2-255)$multiplier",
+      "Configure peer detection multiplier\n"
+      "Configure peer detection multiplier value\n")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (bs->detect_mult == multiplier)
+		return CMD_SUCCESS;
+
+	bs->detect_mult = multiplier;
+	bfd_set_polling(bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_recvinterval, bfd_peer_recvinterval_cmd,
+      "receive-interval (10-60000)$interval",
+      "Configure peer receive interval\n"
+      "Configure peer receive interval value in milliseconds\n")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (bs->timers.required_min_rx == (uint32_t)(interval * 1000))
+		return CMD_SUCCESS;
+
+	bs->timers.required_min_rx = interval * 1000;
+	bfd_set_polling(bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_txinterval, bfd_peer_txinterval_cmd,
+      "transmit-interval (10-60000)$interval",
+      "Configure peer transmit interval\n"
+      "Configure peer transmit interval value in milliseconds\n")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (bs->up_min_tx == (uint32_t)(interval * 1000))
+		return CMD_SUCCESS;
+
+	bs->up_min_tx = interval * 1000;
+	bfd_set_polling(bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_echointerval, bfd_peer_echointerval_cmd,
+      "echo-interval (10-60000)$interval",
+      "Configure peer echo interval\n"
+      "Configure peer echo interval value in milliseconds\n")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (bs->timers.required_min_echo == (uint32_t)(interval * 1000))
+		return CMD_SUCCESS;
+
+	bs->timers.required_min_echo = interval * 1000;
+	bfd_set_polling(bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_shutdown, bfd_peer_shutdown_cmd, "[no] shutdown",
+      NO_STR "Disable BFD peer")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (no) {
+		if (!BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+			return CMD_SUCCESS;
+
+		BFD_UNSET_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN);
+
+		/* Change and notify state change. */
+		bs->ses_state = PTM_BFD_DOWN;
+		control_notify(bs);
+
+		/* Enable all timers. */
+		bfd_recvtimer_update(bs);
+		bfd_xmttimer_update(bs, bs->xmt_TO);
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO)) {
+			bfd_echo_recvtimer_update(bs);
+			bfd_echo_xmttimer_update(bs, bs->echo_xmt_TO);
+		}
+	} else {
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+			return CMD_SUCCESS;
+
+		BFD_SET_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN);
+
+		/* Disable all events. */
+		bfd_recvtimer_delete(bs);
+		bfd_echo_recvtimer_delete(bs);
+		bfd_xmttimer_delete(bs);
+		bfd_echo_xmttimer_delete(bs);
+
+		/* Change and notify state change. */
+		bs->ses_state = PTM_BFD_ADM_DOWN;
+		control_notify(bs);
+
+		ptm_bfd_snd(bs, 0);
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_echo, bfd_peer_echo_cmd, "[no] echo-mode",
+      NO_STR "Configure echo mode\n")
+{
+	struct bfd_session *bs;
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (no) {
+		if (!BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+			return CMD_SUCCESS;
+
+		BFD_UNSET_FLAG(bs->flags, BFD_SESS_FLAG_ECHO);
+		ptm_bfd_echo_stop(bs, 0);
+	} else {
+		if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+			return CMD_SUCCESS;
+
+		BFD_SET_FLAG(bs->flags, BFD_SESS_FLAG_ECHO);
+		/* Apply setting immediately. */
+		if (!BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN)) {
+			ptm_bfd_echo_start(bs);
+			bfd_echo_recvtimer_update(bs);
+		}
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_peer_label, bfd_peer_label_cmd, "label WORD$label",
+      "Register peer label\n"
+      "Register peer label identification\n")
+{
+	struct bfd_session *bs;
+
+	/* Validate label length. */
+	if (strlen(label) >= MAXNAMELEN) {
+		vty_out(vty, "%% Label name is too long\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	bs = VTY_GET_CONTEXT(bfd_session);
+	if (bfd_session_update_label(bs, label) == -1) {
+		vty_out(vty, "%% Failed to update peer label.\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_no_peer, bfd_no_peer_cmd,
+      "no peer <A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]",
+      NO_STR
+      PEER_STR PEER_IPV4_STR PEER_IPV6_STR
+      MHOP_STR
+      LOCAL_STR LOCAL_IPV4_STR LOCAL_IPV6_STR
+      INTERFACE_STR
+      LOCAL_INTF_STR
+      VRF_STR VRF_NAME_STR)
+{
+	int idx;
+	bool mhop;
+	struct bfd_peer_cfg bpc;
+	struct sockaddr_any psa, lsa, *lsap;
+	char errormsg[128];
+
+	strtosa(peer_str, &psa);
+	if (local) {
+		strtosa(local_str, &lsa);
+		lsap = &lsa;
+	} else {
+		lsap = NULL;
+	}
+
+	idx = 0;
+	mhop = argv_find(argv, argc, "multihop", &idx);
+
+	if (bfd_configure_peer(&bpc, mhop, &psa, lsap, ifname, vrfname,
+			       errormsg, sizeof(errormsg))
+	    != 0) {
+		vty_out(vty, "%% Invalid peer configuration: %s\n", errormsg);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (ptm_bfd_ses_del(&bpc) != 0) {
+		vty_out(vty, "%% Failed to remove peer.\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return CMD_SUCCESS;
+}
+
+
+/*
+ * Show commands helper functions
+ */
+static void _display_peer_header(struct vty *vty, struct bfd_session *bs)
+{
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		vty_out(vty, "\tpeer %s", satostr(&bs->mhop.peer));
+		vty_out(vty, " multihop");
+		vty_out(vty, " local-address %s", satostr(&bs->mhop.local));
+		if (bs->mhop.vrf_name[0])
+			vty_out(vty, " vrf %s", bs->mhop.vrf_name);
+		vty_out(vty, "\n");
+	} else {
+		vty_out(vty, "\tpeer %s", satostr(&bs->shop.peer));
+		if (bs->local_address.sa_sin.sin_family != AF_UNSPEC)
+			vty_out(vty, " local-address %s",
+				satostr(&bs->local_address));
+		if (bs->shop.port_name[0])
+			vty_out(vty, " interface %s", bs->shop.port_name);
+		vty_out(vty, "\n");
+	}
+
+	if (bs->pl)
+		vty_out(vty, "\t\tlabel: %s\n", bs->pl->pl_label);
+}
+
+static void _display_peer(struct vty *vty, struct bfd_session *bs)
+{
+	char buf[256];
+	time_t now;
+
+	_display_peer_header(vty, bs);
+
+	vty_out(vty, "\t\tID: %u\n", bs->discrs.my_discr);
+	vty_out(vty, "\t\tRemote ID: %u\n", bs->discrs.remote_discr);
+
+	vty_out(vty, "\t\tStatus: ");
+	switch (bs->ses_state) {
+	case PTM_BFD_ADM_DOWN:
+		vty_out(vty, "shutdown\n");
+		break;
+	case PTM_BFD_DOWN:
+		vty_out(vty, "down\n");
+
+		now = monotime(NULL);
+		integer2timestr(now - bs->downtime.tv_sec, buf, sizeof(buf));
+		vty_out(vty, "\t\tDowntime: %s\n", buf);
+		break;
+	case PTM_BFD_INIT:
+		vty_out(vty, "init\n");
+		break;
+	case PTM_BFD_UP:
+		vty_out(vty, "up\n");
+
+		now = monotime(NULL);
+		integer2timestr(now - bs->uptime.tv_sec, buf, sizeof(buf));
+		vty_out(vty, "\t\tUptime: %s\n", buf);
+		break;
+
+	default:
+		vty_out(vty, "unknown\n");
+		break;
+	}
+
+	vty_out(vty, "\t\tDiagnostics: %s\n", diag2str(bs->local_diag));
+	vty_out(vty, "\t\tRemote diagnostics: %s\n", diag2str(bs->remote_diag));
+
+	vty_out(vty, "\t\tLocal timers:\n");
+	vty_out(vty, "\t\t\tReceive interval: %" PRIu32 "ms\n",
+		bs->timers.required_min_rx / 1000);
+	vty_out(vty, "\t\t\tTransmission interval: %" PRIu32 "ms",
+		bs->timers.desired_min_tx / 1000);
+	if (bs->up_min_tx != bs->timers.desired_min_tx)
+		vty_out(vty, " (configured %" PRIu32 "ms)\n",
+			bs->up_min_tx / 1000);
+	else
+		vty_out(vty, "\n");
+
+	vty_out(vty, "\t\t\tEcho transmission interval: ");
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+		vty_out(vty, "%" PRIu32 "ms\n",
+			bs->timers.required_min_echo / 1000);
+	else
+		vty_out(vty, "disabled\n");
+
+	vty_out(vty, "\t\tRemote timers:\n");
+	vty_out(vty, "\t\t\tReceive interval: %" PRIu32 "ms\n",
+		bs->remote_timers.required_min_rx / 1000);
+	vty_out(vty, "\t\t\tTransmission interval: %" PRIu32 "ms\n",
+		bs->remote_timers.desired_min_tx / 1000);
+	vty_out(vty, "\t\t\tEcho transmission interval: %" PRIu32 "ms\n",
+		bs->remote_timers.required_min_echo / 1000);
+
+	vty_out(vty, "\n");
+}
+
+static struct json_object *_peer_json_header(struct bfd_session *bs)
+{
+	struct json_object *jo = json_object_new_object();
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		json_object_boolean_true_add(jo, "multihop");
+		json_object_string_add(jo, "peer", satostr(&bs->mhop.peer));
+		json_object_string_add(jo, "local", satostr(&bs->mhop.local));
+		if (bs->mhop.vrf_name[0])
+			json_object_string_add(jo, "vrf", bs->mhop.vrf_name);
+	} else {
+		json_object_boolean_false_add(jo, "multihop");
+		json_object_string_add(jo, "peer", satostr(&bs->shop.peer));
+		if (bs->local_address.sa_sin.sin_family != AF_UNSPEC)
+			json_object_string_add(jo, "local",
+					       satostr(&bs->local_address));
+		if (bs->shop.port_name[0])
+			json_object_string_add(jo, "interface",
+					       bs->shop.port_name);
+	}
+
+	if (bs->pl)
+		json_object_string_add(jo, "label", bs->pl->pl_label);
+
+	return jo;
+}
+
+static struct json_object *__display_peer_json(struct bfd_session *bs)
+{
+	struct json_object *jo = _peer_json_header(bs);
+
+	json_object_int_add(jo, "id", bs->discrs.my_discr);
+	json_object_int_add(jo, "remote-id", bs->discrs.remote_discr);
+
+	switch (bs->ses_state) {
+	case PTM_BFD_ADM_DOWN:
+		json_object_string_add(jo, "status", "shutdown");
+		break;
+	case PTM_BFD_DOWN:
+		json_object_string_add(jo, "status", "down");
+		json_object_int_add(jo, "downtime",
+				    monotime(NULL) - bs->downtime.tv_sec);
+		break;
+	case PTM_BFD_INIT:
+		json_object_string_add(jo, "status", "init");
+		break;
+	case PTM_BFD_UP:
+		json_object_string_add(jo, "status", "up");
+		json_object_int_add(jo, "uptime",
+				    monotime(NULL) - bs->uptime.tv_sec);
+		break;
+
+	default:
+		json_object_string_add(jo, "status", "unknown");
+		break;
+	}
+
+	json_object_string_add(jo, "diagnostic", diag2str(bs->local_diag));
+	json_object_string_add(jo, "remote-diagnostic",
+			       diag2str(bs->remote_diag));
+
+	json_object_int_add(jo, "receive-interval",
+			    bs->timers.required_min_rx / 1000);
+	json_object_int_add(jo, "transmit-interval",
+			    bs->timers.desired_min_tx / 1000);
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+		json_object_int_add(jo, "echo-interval",
+				    bs->timers.required_min_echo / 1000);
+	else
+		json_object_int_add(jo, "echo-interval", 0);
+
+	json_object_int_add(jo, "remote-receive-interval",
+			    bs->remote_timers.required_min_rx / 1000);
+	json_object_int_add(jo, "remote-transmit-interval",
+			    bs->remote_timers.desired_min_tx / 1000);
+	json_object_int_add(jo, "remote-echo-interval",
+			    bs->remote_timers.required_min_echo / 1000);
+
+	return jo;
+}
+
+static void _display_peer_json(struct vty *vty, struct bfd_session *bs)
+{
+	struct json_object *jo = __display_peer_json(bs);
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
+static void _display_peer_iter(struct hash_backet *hb, void *arg)
+{
+	struct vty *vty = arg;
+	struct bfd_session *bs = hb->data;
+
+	_display_peer(vty, bs);
+}
+
+static void _display_peer_json_iter(struct hash_backet *hb, void *arg)
+{
+	struct json_object *jo = arg, *jon = NULL;
+	struct bfd_session *bs = hb->data;
+
+	jon = __display_peer_json(bs);
+	if (jon == NULL) {
+		log_warning("%s: not enough memory", __func__);
+		return;
+	}
+
+	json_object_array_add(jo, jon);
+}
+
+static void _display_all_peers(struct vty *vty, bool use_json)
+{
+	struct json_object *jo;
+
+	if (use_json == false) {
+		vty_out(vty, "BFD Peers:\n");
+		bfd_id_iterate(_display_peer_iter, vty);
+		return;
+	}
+
+	jo = json_object_new_array();
+	bfd_id_iterate(_display_peer_json_iter, jo);
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
+static void _display_peer_counter(struct vty *vty, struct bfd_session *bs)
+{
+	_display_peer_header(vty, bs);
+
+	vty_out(vty, "\t\tControl packet input: %" PRIu64 " packets\n",
+		bs->stats.rx_ctrl_pkt);
+	vty_out(vty, "\t\tControl packet output: %" PRIu64 " packets\n",
+		bs->stats.tx_ctrl_pkt);
+	vty_out(vty, "\t\tEcho packet input: %" PRIu64 " packets\n",
+		bs->stats.rx_echo_pkt);
+	vty_out(vty, "\t\tEcho packet output: %" PRIu64 " packets\n",
+		bs->stats.tx_echo_pkt);
+	vty_out(vty, "\t\tSession up events: %" PRIu64 "\n",
+		bs->stats.session_up);
+	vty_out(vty, "\t\tSession down events: %" PRIu64 "\n",
+		bs->stats.session_down);
+	vty_out(vty, "\t\tZebra notifications: %" PRIu64 "\n",
+		bs->stats.znotification);
+	vty_out(vty, "\n");
+}
+
+static struct json_object *__display_peer_counters_json(struct bfd_session *bs)
+{
+	struct json_object *jo = _peer_json_header(bs);
+
+	json_object_int_add(jo, "control-packet-input", bs->stats.rx_ctrl_pkt);
+	json_object_int_add(jo, "control-packet-output", bs->stats.tx_ctrl_pkt);
+	json_object_int_add(jo, "echo-packet-input", bs->stats.rx_echo_pkt);
+	json_object_int_add(jo, "echo-packet-output", bs->stats.tx_echo_pkt);
+	json_object_int_add(jo, "session-up", bs->stats.session_up);
+	json_object_int_add(jo, "session-down", bs->stats.session_down);
+	json_object_int_add(jo, "zebra-notifications", bs->stats.znotification);
+
+	return jo;
+}
+
+static void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs)
+{
+	struct json_object *jo = __display_peer_counters_json(bs);
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
+static void _display_peer_counter_iter(struct hash_backet *hb, void *arg)
+{
+	struct vty *vty = arg;
+	struct bfd_session *bs = hb->data;
+
+	_display_peer_counter(vty, bs);
+}
+
+static void _display_peer_counter_json_iter(struct hash_backet *hb, void *arg)
+{
+	struct json_object *jo = arg, *jon = NULL;
+	struct bfd_session *bs = hb->data;
+
+	jon = __display_peer_counters_json(bs);
+	if (jon == NULL) {
+		log_warning("%s: not enough memory", __func__);
+		return;
+	}
+
+	json_object_array_add(jo, jon);
+}
+
+static void _display_peers_counter(struct vty *vty, bool use_json)
+{
+	struct json_object *jo;
+
+	if (use_json == false) {
+		vty_out(vty, "BFD Peers:\n");
+		bfd_id_iterate(_display_peer_counter_iter, vty);
+		return;
+	}
+
+	jo = json_object_new_array();
+	bfd_id_iterate(_display_peer_counter_json_iter, jo);
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
+static struct bfd_session *
+_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,
+		    const char *label, const char *peer_str,
+		    const char *local_str, const char *ifname,
+		    const char *vrfname)
+{
+	int idx;
+	bool mhop;
+	struct bfd_session *bs = NULL;
+	struct peer_label *pl;
+	struct bfd_peer_cfg bpc;
+	struct sockaddr_any psa, lsa, *lsap;
+	char errormsg[128];
+
+	/* Look up the BFD peer. */
+	if (label) {
+		pl = pl_find(label);
+		if (pl)
+			bs = pl->pl_bs;
+	} else {
+		strtosa(peer_str, &psa);
+		if (local_str) {
+			strtosa(local_str, &lsa);
+			lsap = &lsa;
+		} else
+			lsap = NULL;
+
+		idx = 0;
+		mhop = argv_find(argv, argc, "multihop", &idx);
+
+		if (bfd_configure_peer(&bpc, mhop, &psa, lsap, ifname, vrfname,
+				       errormsg, sizeof(errormsg))
+		    != 0) {
+			vty_out(vty, "%% Invalid peer configuration: %s\n",
+				errormsg);
+			return NULL;
+		}
+
+		bs = bs_peer_find(&bpc);
+	}
+
+	/* Find peer data. */
+	if (bs == NULL) {
+		vty_out(vty, "%% Unable to find 'peer %s",
+			label ? label : peer_str);
+		if (ifname)
+			vty_out(vty, " interface %s", ifname);
+		if (local_str)
+			vty_out(vty, " local-address %s", local_str);
+		if (vrfname)
+			vty_out(vty, " vrf %s", vrfname);
+		vty_out(vty, "'\n");
+
+		return NULL;
+	}
+
+	return bs;
+}
+
+
+/*
+ * Show commands.
+ */
+DEFPY(bfd_show_peers, bfd_show_peers_cmd, "show bfd peers [json]",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      "BFD peers status\n" JSON_STR)
+{
+	_display_all_peers(vty, use_json(argc, argv));
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_show_peer, bfd_show_peer_cmd,
+      "show bfd peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]> [json]",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      "BFD peers status\n"
+      "Peer label\n" PEER_IPV4_STR PEER_IPV6_STR MHOP_STR LOCAL_STR
+	      LOCAL_IPV4_STR LOCAL_IPV6_STR INTERFACE_STR LOCAL_INTF_STR VRF_STR
+		      VRF_NAME_STR JSON_STR)
+{
+	struct bfd_session *bs;
+
+	/* Look up the BFD peer. */
+	bs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,
+				 ifname, vrfname);
+	if (bs == NULL)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (use_json(argc, argv)) {
+		_display_peer_json(vty, bs);
+	} else {
+		vty_out(vty, "BFD Peer:\n");
+		_display_peer(vty, bs);
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_show_peer_counters, bfd_show_peer_counters_cmd,
+      "show bfd peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]> counters [json]",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      "BFD peers status\n"
+      "Peer label\n"
+      PEER_IPV4_STR
+      PEER_IPV6_STR
+      MHOP_STR
+      LOCAL_STR
+      LOCAL_IPV4_STR
+      LOCAL_IPV6_STR
+      INTERFACE_STR
+      LOCAL_INTF_STR
+      VRF_STR
+      VRF_NAME_STR
+      "Show BFD peer counters information\n"
+      JSON_STR)
+{
+	struct bfd_session *bs;
+
+	/* Look up the BFD peer. */
+	bs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,
+				 ifname, vrfname);
+	if (bs == NULL)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (use_json(argc, argv))
+		_display_peer_counters_json(vty, bs);
+	else
+		_display_peer_counter(vty, bs);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(bfd_show_peers_counters, bfd_show_peers_counters_cmd,
+      "show bfd peers counters [json]",
+      SHOW_STR
+      "Bidirection Forwarding Detection\n"
+      "BFD peers status\n"
+      "Show BFD peer counters information\n"
+      JSON_STR)
+{
+	_display_peers_counter(vty, use_json(argc, argv));
+
+	return CMD_SUCCESS;
+}
+
+
+/*
+ * Function definitions.
+ */
+
+/*
+ * Configuration rules:
+ *
+ * Single hop:
+ * peer + (optional vxlan or interface name)
+ *
+ * Multi hop:
+ * peer + local + (optional vrf)
+ *
+ * Anything else is misconfiguration.
+ */
+static int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,
+			      const struct sockaddr_any *peer,
+			      const struct sockaddr_any *local,
+			      const char *ifname, const char *vrfname,
+			      char *ebuf, size_t ebuflen)
+{
+	memset(bpc, 0, sizeof(*bpc));
+
+	/* Defaults */
+	bpc->bpc_shutdown = true;
+	bpc->bpc_detectmultiplier = BPC_DEF_DETECTMULTIPLIER;
+	bpc->bpc_recvinterval = BPC_DEF_RECEIVEINTERVAL;
+	bpc->bpc_txinterval = BPC_DEF_TRANSMITINTERVAL;
+	bpc->bpc_echointerval = BPC_DEF_ECHOINTERVAL;
+	bpc->bpc_lastevent = monotime(NULL);
+
+	/* Safety check: when no error buf is provided len must be zero. */
+	if (ebuf == NULL)
+		ebuflen = 0;
+
+	/* Peer is always mandatory. */
+	if (peer == NULL) {
+		snprintf(ebuf, ebuflen, "peer must not be empty");
+		return -1;
+	}
+
+	/* Validate address families. */
+	if (peer->sa_sin.sin_family == AF_INET) {
+		if (local && local->sa_sin.sin_family != AF_INET) {
+			snprintf(ebuf, ebuflen,
+				 "local is IPv6, but peer is IPv4");
+			return -1;
+		}
+
+		bpc->bpc_ipv4 = true;
+	} else if (peer->sa_sin.sin_family == AF_INET6) {
+		if (local && local->sa_sin.sin_family != AF_INET6) {
+			snprintf(ebuf, ebuflen,
+				 "local is IPv4, but peer is IPv6");
+			return -1;
+		}
+
+		bpc->bpc_ipv4 = false;
+	} else {
+		snprintf(ebuf, ebuflen, "invalid peer address family");
+		return -1;
+	}
+
+	/* Copy local and/or peer addresses. */
+	if (local)
+		bpc->bpc_local = *local;
+
+	if (peer) {
+		bpc->bpc_peer = *peer;
+	} else {
+		/* Peer configuration is mandatory. */
+		snprintf(ebuf, ebuflen, "no peer configured");
+		return -1;
+	}
+
+	bpc->bpc_mhop = mhop;
+
+#if 0
+	/* Handle VxLAN configuration. */
+	if (vxlan >= 0) {
+		if (vxlan > ((1 << 24) - 1)) {
+			snprintf(ebuf, ebuflen, "invalid VxLAN %d", vxlan);
+			return -1;
+		}
+		if (bpc->bpc_mhop) {
+			snprintf(ebuf, ebuflen,
+				 "multihop doesn't accept VxLAN");
+			return -1;
+		}
+
+		bpc->bpc_vxlan = vxlan;
+	}
+#endif /* VxLAN */
+
+	/* Handle interface specification configuration. */
+	if (ifname) {
+		if (bpc->bpc_mhop) {
+			snprintf(ebuf, ebuflen,
+				 "multihop doesn't accept interface names");
+			return -1;
+		}
+
+		bpc->bpc_has_localif = true;
+		if (strlcpy(bpc->bpc_localif, ifname, sizeof(bpc->bpc_localif))
+		    > sizeof(bpc->bpc_localif)) {
+			snprintf(ebuf, ebuflen, "interface name too long");
+			return -1;
+		}
+	}
+
+	/* Handle VRF configuration. */
+	if (vrfname) {
+		bpc->bpc_has_vrfname = true;
+		if (strlcpy(bpc->bpc_vrfname, vrfname, sizeof(bpc->bpc_vrfname))
+		    > sizeof(bpc->bpc_vrfname)) {
+			snprintf(ebuf, ebuflen, "vrf name too long");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+static int bfdd_write_config(struct vty *vty)
+{
+	vty_out(vty, "bfd\n");
+	vty_out(vty, "!\n");
+	return 0;
+}
+
+static void _bfdd_peer_write_config(struct hash_backet *hb, void *arg)
+{
+	struct vty *vty = arg;
+	struct bfd_session *bs = hb->data;
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		vty_out(vty, " peer %s", satostr(&bs->mhop.peer));
+		vty_out(vty, " multihop");
+		vty_out(vty, " local-address %s", satostr(&bs->mhop.local));
+		if (bs->mhop.vrf_name[0])
+			vty_out(vty, " vrf %s", bs->mhop.vrf_name);
+		vty_out(vty, "\n");
+	} else {
+		vty_out(vty, " peer %s", satostr(&bs->shop.peer));
+		if (bs->local_address.sa_sin.sin_family != AF_UNSPEC)
+			vty_out(vty, " local-address %s",
+				satostr(&bs->local_address));
+		if (bs->shop.port_name[0])
+			vty_out(vty, " interface %s", bs->shop.port_name);
+		vty_out(vty, "\n");
+	}
+
+	if (bs->detect_mult != BPC_DEF_DETECTMULTIPLIER)
+		vty_out(vty, "  detect-multiplier %d\n", bs->detect_mult);
+	if (bs->timers.required_min_rx != (BPC_DEF_RECEIVEINTERVAL * 1000))
+		vty_out(vty, "  receive-interval %" PRIu32 "\n",
+			bs->timers.required_min_rx / 1000);
+	if (bs->up_min_tx != (BPC_DEF_TRANSMITINTERVAL * 1000))
+		vty_out(vty, "  transmit-interval %" PRIu32 "\n",
+			bs->up_min_tx / 1000);
+	if (bs->timers.required_min_echo != (BPC_DEF_ECHOINTERVAL * 1000))
+		vty_out(vty, "  echo-interval %" PRIu32 "\n",
+			bs->timers.required_min_echo / 1000);
+	if (bs->pl)
+		vty_out(vty, "  label %s\n", bs->pl->pl_label);
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+		vty_out(vty, "  echo-mode\n");
+
+	vty_out(vty, "  %sshutdown\n",
+		BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN) ? "" : "no ");
+
+	vty_out(vty, " !\n");
+}
+
+static int bfdd_peer_write_config(struct vty *vty)
+{
+	bfd_id_iterate(_bfdd_peer_write_config, vty);
+	return 1;
+}
+
+struct cmd_node bfd_node = {
+	BFD_NODE,
+	"%s(config-bfd)# ",
+	1,
+};
+
+struct cmd_node bfd_peer_node = {
+	BFD_PEER_NODE,
+	"%s(config-bfd-peer)# ",
+	1,
+};
+
+void bfdd_vty_init(void)
+{
+	install_element(ENABLE_NODE, &bfd_show_peers_counters_cmd);
+	install_element(ENABLE_NODE, &bfd_show_peer_counters_cmd);
+	install_element(ENABLE_NODE, &bfd_show_peers_cmd);
+	install_element(ENABLE_NODE, &bfd_show_peer_cmd);
+	install_element(CONFIG_NODE, &bfd_enter_cmd);
+
+	/* Install BFD node and commands. */
+	install_node(&bfd_node, bfdd_write_config);
+	install_default(BFD_NODE);
+	install_element(BFD_NODE, &bfd_peer_enter_cmd);
+	install_element(BFD_NODE, &bfd_no_peer_cmd);
+
+	/* Install BFD peer node. */
+	install_node(&bfd_peer_node, bfdd_peer_write_config);
+	install_default(BFD_PEER_NODE);
+	install_element(BFD_PEER_NODE, &bfd_peer_detectmultiplier_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_recvinterval_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_txinterval_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_echointerval_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_shutdown_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_echo_cmd);
+	install_element(BFD_PEER_NODE, &bfd_peer_label_cmd);
+}
diff -urpN frr-frr-5.0.1/bfdd/bsd.c frr-frr-6.0/bfdd/bsd.c
--- frr-frr-5.0.1/bfdd/bsd.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/bsd.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,290 @@
+/*
+ * *BSD specific code
+ *
+ * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * FRR is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FRR; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#ifdef BFD_BSD
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <ifaddrs.h>
+
+#include "bfd.h"
+
+/*
+ * Prototypes
+ */
+static const char *sockaddr_to_string(const void *sv, char *buf, size_t buflen);
+
+/*
+ * Definitions.
+ */
+static const char *sockaddr_to_string(const void *sv, char *buf, size_t buflen)
+{
+	const struct sockaddr *sa = sv;
+	const struct sockaddr_in *sin = sv;
+	const struct sockaddr_in6 *sin6 = sv;
+	int unknown = 1;
+
+	switch (sa->sa_family) {
+	case AF_INET:
+		if (inet_ntop(AF_INET, &sin->sin_addr, buf, buflen) != NULL)
+			unknown = 0;
+		break;
+
+	case AF_INET6:
+		if (inet_ntop(AF_INET6, &sin6->sin6_addr, buf, buflen) != NULL)
+			unknown = 0;
+		break;
+	}
+	if (unknown == 0)
+		return buf;
+
+	snprintf(buf, buflen, "unknown (af=%d)", sa->sa_family);
+	return buf;
+}
+
+int ptm_bfd_fetch_ifindex(const char *ifname)
+{
+	return if_nametoindex(ifname);
+}
+
+void ptm_bfd_fetch_local_mac(const char *ifname, uint8_t *mac)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct if_data *ifi;
+	struct sockaddr_dl *sdl;
+	size_t maclen;
+
+	/* Always clean the target, zeroed macs mean failure. */
+	memset(mac, 0, ETHERNET_ADDRESS_LENGTH);
+
+	if (getifaddrs(&ifap) != 0)
+		return;
+
+	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
+		/* Find interface with that name. */
+		if (strcmp(ifa->ifa_name, ifname) != 0)
+			continue;
+		/* Skip non link addresses. We want the MAC address. */
+		if (ifa->ifa_addr->sa_family != AF_LINK)
+			continue;
+
+		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
+		ifi = (struct if_data *)ifa->ifa_data;
+		/* Skip non ethernet related data. */
+		if (ifi->ifi_type != IFT_ETHER)
+			continue;
+
+		if (sdl->sdl_alen != ETHERNET_ADDRESS_LENGTH)
+			log_warning("%s:%d mac address length %d (expected %d)",
+				    __func__, __LINE__, sdl->sdl_alen,
+				    ETHERNET_ADDRESS_LENGTH);
+
+		maclen = (sdl->sdl_alen > ETHERNET_ADDRESS_LENGTH)
+				 ? ETHERNET_ADDRESS_LENGTH
+				 : sdl->sdl_alen;
+		memcpy(mac, LLADDR(sdl), maclen);
+		break;
+	}
+
+	freeifaddrs(ifap);
+}
+
+
+/* Was _fetch_portname_from_ifindex() */
+void fetch_portname_from_ifindex(int ifindex, char *ifname, size_t ifnamelen)
+{
+	char ifname_tmp[IF_NAMESIZE];
+
+	/* Set ifname to empty to signalize failures. */
+	memset(ifname, 0, ifnamelen);
+
+	if (if_indextoname(ifindex, ifname_tmp) == NULL)
+		return;
+
+	if (strlcpy(ifname, ifname_tmp, ifnamelen) > ifnamelen)
+		log_warning("%s:%d interface name truncated", __func__,
+			    __LINE__);
+}
+
+int ptm_bfd_echo_sock_init(void)
+{
+	int s, ttl, yes = 1;
+	struct sockaddr_in sin;
+
+	s = socket(AF_INET, SOCK_DGRAM, PF_UNSPEC);
+	if (s == -1) {
+		log_error("echo-socket: creation failed: %s", strerror(errno));
+		return -1;
+	}
+
+	memset(&sin, 0, sizeof(sin));
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+	/* OmniOS doesn't have this field, but uses this code. */
+	sin.sin_len = sizeof(sin);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+	sin.sin_family = AF_INET;
+	sin.sin_port = htons(3785);
+	if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) == -1) {
+		log_error("echo-socket: bind failure: %s", strerror(errno));
+		close(s);
+		return -1;
+	}
+
+	if (setsockopt(s, IPPROTO_IP, IP_RECVTTL, &yes, sizeof(yes)) == -1) {
+		log_error("echo-socket: setsockopt(IP_RECVTTL): %s",
+			  strerror(errno));
+		close(s);
+		return -1;
+	}
+
+	ttl = BFD_TTL_VAL;
+	if (setsockopt(s, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl)) == -1) {
+		log_error("echo-socket: setsockopt(IP_TTL): %s",
+			  strerror(errno));
+		close(s);
+		return -1;
+	}
+
+	return s;
+}
+
+ssize_t bsd_echo_sock_read(int sd, uint8_t *buf, ssize_t *buflen,
+			   struct sockaddr_storage *ss, socklen_t *sslen,
+			   uint8_t *ttl, uint32_t *id)
+{
+	struct cmsghdr *cmsg;
+	struct bfd_echo_pkt *bep;
+	ssize_t readlen;
+	struct iovec iov;
+	struct msghdr msg;
+	uint8_t msgctl[255];
+	char errbuf[255];
+
+	/* Prepare socket read. */
+	memset(ss, 0, sizeof(*ss));
+	memset(&msg, 0, sizeof(msg));
+	iov.iov_base = buf;
+	iov.iov_len = *buflen;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = msgctl;
+	msg.msg_controllen = sizeof(msgctl);
+	msg.msg_name = ss;
+	msg.msg_namelen = *sslen;
+
+	/* Read the socket and treat errors. */
+	readlen = recvmsg(sd, &msg, 0);
+	if (readlen == 0) {
+		log_error("%s: recvmsg: socket closed", __func__);
+		return -1;
+	}
+	if (readlen == -1) {
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
+			return -1;
+
+		log_error("%s: recvmsg: (%d) %s", __func__, errno,
+			  strerror(errno));
+		return -1;
+	}
+	/* Short packet, better not risk reading it. */
+	if (readlen < (ssize_t)sizeof(*bep)) {
+		log_warning("%s: short packet (%ld of %d) from %s", __func__,
+			    readlen, sizeof(*bep),
+			    sockaddr_to_string(ss, errbuf, sizeof(errbuf)));
+		return -1;
+	}
+	*buflen = readlen;
+
+	/* Read TTL information. */
+	*ttl = 0;
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
+	     cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+		if (cmsg->cmsg_level != IPPROTO_IP)
+			continue;
+		if (cmsg->cmsg_type != IP_RECVTTL)
+			continue;
+
+		*ttl = *(uint8_t *)CMSG_DATA(cmsg);
+		break;
+	}
+	if (*ttl == 0) {
+		log_debug("%s: failed to read TTL", __func__);
+		return -1;
+	}
+
+	/* Read my discriminator from BFD Echo packet. */
+	bep = (struct bfd_echo_pkt *)buf;
+	*id = bep->my_discr;
+	if (*id == 0) {
+		log_debug("%s: invalid packet discriminator from: %s", __func__,
+			  sockaddr_to_string(ss, errbuf, sizeof(errbuf)));
+		return -1;
+	}
+
+	/* Set the returned sockaddr new length. */
+	*sslen = msg.msg_namelen;
+
+	return 0;
+}
+
+int ptm_bfd_vxlan_sock_init(void)
+{
+	/* TODO: not supported yet. */
+	return -1;
+}
+
+int bp_bind_dev(int sd, const char *dev)
+{
+	/*
+	 * *BSDs don't support `SO_BINDTODEVICE`, instead you must
+	 * manually specify the main address of the interface or use
+	 * BPF on the socket descriptor.
+	 */
+	return 0;
+}
+
+uint16_t udp4_checksum(struct ip *ip, uint8_t *buf, int len)
+{
+	char *ptr;
+	struct udp_psuedo_header pudp_hdr;
+	uint16_t csum;
+
+	pudp_hdr.saddr = ip->ip_src.s_addr;
+	pudp_hdr.daddr = ip->ip_dst.s_addr;
+	pudp_hdr.reserved = 0;
+	pudp_hdr.protocol = ip->ip_p;
+	pudp_hdr.len = htons(len);
+
+	ptr = XMALLOC(MTYPE_BFDD_TMP, UDP_PSUEDO_HDR_LEN + len);
+	memcpy(ptr, &pudp_hdr, UDP_PSUEDO_HDR_LEN);
+	memcpy(ptr + UDP_PSUEDO_HDR_LEN, buf, len);
+
+	csum = checksum((uint16_t *)ptr, UDP_PSUEDO_HDR_LEN + len);
+	XFREE(MTYPE_BFDD_TMP, ptr);
+	return csum;
+}
+
+#endif /* BFD_BSD */
diff -urpN frr-frr-5.0.1/bfdd/config.c frr-frr-6.0/bfdd/config.c
--- frr-frr-5.0.1/bfdd/config.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/config.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,606 @@
+/*********************************************************************
+ * Copyright 2017-2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * config.c: implements the BFD daemon configuration handling.
+ *
+ * Authors
+ * -------
+ * Rafael Zalamena <rzalamena@opensourcerouting.org>
+ */
+
+#include <zebra.h>
+
+#include <string.h>
+
+#include "lib/json.h"
+
+#include "bfd.h"
+
+/*
+ * Definitions
+ */
+enum peer_list_type {
+	PLT_IPV4,
+	PLT_IPV6,
+	PLT_LABEL,
+};
+
+
+/*
+ * Prototypes
+ */
+static int parse_config_json(struct json_object *jo, bpc_handle h, void *arg);
+static int parse_list(struct json_object *jo, enum peer_list_type plt,
+		      bpc_handle h, void *arg);
+static int parse_peer_config(struct json_object *jo, struct bfd_peer_cfg *bpc);
+static int parse_peer_label_config(struct json_object *jo,
+				   struct bfd_peer_cfg *bpc);
+
+static int config_add(struct bfd_peer_cfg *bpc, void *arg);
+static int config_del(struct bfd_peer_cfg *bpc, void *arg);
+
+static int json_object_add_peer(struct json_object *jo, struct bfd_session *bs);
+
+
+/*
+ * Implementation
+ */
+static int config_add(struct bfd_peer_cfg *bpc,
+		      void *arg __attribute__((unused)))
+{
+	return ptm_bfd_sess_new(bpc) == NULL;
+}
+
+static int config_del(struct bfd_peer_cfg *bpc,
+		      void *arg __attribute__((unused)))
+{
+	return ptm_bfd_ses_del(bpc) != 0;
+}
+
+static int parse_config_json(struct json_object *jo, bpc_handle h, void *arg)
+{
+	const char *key, *sval;
+	struct json_object *jo_val;
+	struct json_object_iterator joi, join;
+	int error = 0;
+
+	JSON_FOREACH (jo, joi, join) {
+		key = json_object_iter_peek_name(&joi);
+		jo_val = json_object_iter_peek_value(&joi);
+
+		if (strcmp(key, "ipv4") == 0) {
+			error += parse_list(jo_val, PLT_IPV4, h, arg);
+		} else if (strcmp(key, "ipv6") == 0) {
+			error += parse_list(jo_val, PLT_IPV6, h, arg);
+		} else if (strcmp(key, "label") == 0) {
+			error += parse_list(jo_val, PLT_LABEL, h, arg);
+		} else {
+			sval = json_object_get_string(jo_val);
+			log_warning("%s:%d invalid configuration: %s", __func__,
+				    __LINE__, sval);
+			error++;
+		}
+	}
+
+	/*
+	 * Our callers never call free() on json_object and only expect
+	 * the return value, so lets free() it here.
+	 */
+	json_object_put(jo);
+
+	return error;
+}
+
+int parse_config(const char *fname)
+{
+	struct json_object *jo;
+
+	jo = json_object_from_file(fname);
+	if (jo == NULL)
+		return -1;
+
+	return parse_config_json(jo, config_add, NULL);
+}
+
+static int parse_list(struct json_object *jo, enum peer_list_type plt,
+		      bpc_handle h, void *arg)
+{
+	struct json_object *jo_val;
+	struct bfd_peer_cfg bpc;
+	int allen, idx;
+	int error = 0, result;
+
+	allen = json_object_array_length(jo);
+	for (idx = 0; idx < allen; idx++) {
+		jo_val = json_object_array_get_idx(jo, idx);
+
+		/* Set defaults. */
+		memset(&bpc, 0, sizeof(bpc));
+		bpc.bpc_detectmultiplier = BFD_DEFDETECTMULT;
+		bpc.bpc_recvinterval = BFD_DEFREQUIREDMINRX;
+		bpc.bpc_txinterval = BFD_DEFDESIREDMINTX;
+		bpc.bpc_echointerval = BFD_DEF_REQ_MIN_ECHO;
+
+		switch (plt) {
+		case PLT_IPV4:
+			log_debug("ipv4 peers %d:", allen);
+			bpc.bpc_ipv4 = true;
+			break;
+		case PLT_IPV6:
+			log_debug("ipv6 peers %d:", allen);
+			bpc.bpc_ipv4 = false;
+			break;
+		case PLT_LABEL:
+			log_debug("label peers %d:", allen);
+			if (parse_peer_label_config(jo_val, &bpc) != 0) {
+				error++;
+				continue;
+			}
+			break;
+
+		default:
+			error++;
+			log_error("%s:%d: unsupported peer type", __func__,
+				  __LINE__);
+			break;
+		}
+
+		result = parse_peer_config(jo_val, &bpc);
+		error += result;
+		if (result == 0)
+			error += (h(&bpc, arg) != 0);
+	}
+
+	return error;
+}
+
+static int parse_peer_config(struct json_object *jo, struct bfd_peer_cfg *bpc)
+{
+	const char *key, *sval;
+	struct json_object *jo_val;
+	struct json_object_iterator joi, join;
+	int family_type = (bpc->bpc_ipv4) ? AF_INET : AF_INET6;
+	int error = 0;
+
+	log_debug("\tpeer: %s", bpc->bpc_ipv4 ? "ipv4" : "ipv6");
+
+	JSON_FOREACH (jo, joi, join) {
+		key = json_object_iter_peek_name(&joi);
+		jo_val = json_object_iter_peek_value(&joi);
+
+		if (strcmp(key, "multihop") == 0) {
+			bpc->bpc_mhop = json_object_get_boolean(jo_val);
+			log_debug("\tmultihop: %s",
+				  bpc->bpc_mhop ? "true" : "false");
+		} else if (strcmp(key, "peer-address") == 0) {
+			sval = json_object_get_string(jo_val);
+			if (strtosa(sval, &bpc->bpc_peer) != 0
+			    || bpc->bpc_peer.sa_sin.sin_family != family_type) {
+				log_info(
+					"%s:%d failed to parse peer-address '%s'",
+					__func__, __LINE__, sval);
+				error++;
+			}
+			log_debug("\tpeer-address: %s", sval);
+		} else if (strcmp(key, "local-address") == 0) {
+			sval = json_object_get_string(jo_val);
+			if (strtosa(sval, &bpc->bpc_local) != 0
+			    || bpc->bpc_local.sa_sin.sin_family
+				       != family_type) {
+				log_info(
+					"%s:%d failed to parse local-address '%s'",
+					__func__, __LINE__, sval);
+				error++;
+			}
+			log_debug("\tlocal-address: %s", sval);
+		} else if (strcmp(key, "local-interface") == 0) {
+			bpc->bpc_has_localif = true;
+			sval = json_object_get_string(jo_val);
+			if (strlcpy(bpc->bpc_localif, sval,
+				    sizeof(bpc->bpc_localif))
+			    > sizeof(bpc->bpc_localif)) {
+				log_debug("\tlocal-interface: %s (truncated)");
+				error++;
+			} else {
+				log_debug("\tlocal-interface: %s", sval);
+			}
+		} else if (strcmp(key, "vxlan") == 0) {
+			bpc->bpc_vxlan = json_object_get_int64(jo_val);
+			bpc->bpc_has_vxlan = true;
+			log_debug("\tvxlan: %ld", bpc->bpc_vxlan);
+		} else if (strcmp(key, "vrf-name") == 0) {
+			bpc->bpc_has_vrfname = true;
+			sval = json_object_get_string(jo_val);
+			if (strlcpy(bpc->bpc_vrfname, sval,
+				    sizeof(bpc->bpc_vrfname))
+			    > sizeof(bpc->bpc_vrfname)) {
+				log_debug("\tvrf-name: %s (truncated)", sval);
+				error++;
+			} else {
+				log_debug("\tvrf-name: %s", sval);
+			}
+		} else if (strcmp(key, "detect-multiplier") == 0) {
+			bpc->bpc_detectmultiplier =
+				json_object_get_int64(jo_val);
+			bpc->bpc_has_detectmultiplier = true;
+			log_debug("\tdetect-multiplier: %llu",
+				  bpc->bpc_detectmultiplier);
+		} else if (strcmp(key, "receive-interval") == 0) {
+			bpc->bpc_recvinterval = json_object_get_int64(jo_val);
+			bpc->bpc_has_recvinterval = true;
+			log_debug("\treceive-interval: %llu",
+				  bpc->bpc_recvinterval);
+		} else if (strcmp(key, "transmit-interval") == 0) {
+			bpc->bpc_txinterval = json_object_get_int64(jo_val);
+			bpc->bpc_has_txinterval = true;
+			log_debug("\ttransmit-interval: %llu",
+				  bpc->bpc_txinterval);
+		} else if (strcmp(key, "echo-interval") == 0) {
+			bpc->bpc_echointerval = json_object_get_int64(jo_val);
+			bpc->bpc_has_echointerval = true;
+			log_debug("\techo-interval: %llu",
+				  bpc->bpc_echointerval);
+		} else if (strcmp(key, "create-only") == 0) {
+			bpc->bpc_createonly = json_object_get_boolean(jo_val);
+			log_debug("\tcreate-only: %s",
+				  bpc->bpc_createonly ? "true" : "false");
+		} else if (strcmp(key, "shutdown") == 0) {
+			bpc->bpc_shutdown = json_object_get_boolean(jo_val);
+			log_debug("\tshutdown: %s",
+				  bpc->bpc_shutdown ? "true" : "false");
+		} else if (strcmp(key, "echo-mode") == 0) {
+			bpc->bpc_echo = json_object_get_boolean(jo_val);
+			log_debug("\techo-mode: %s",
+				  bpc->bpc_echo ? "true" : "false");
+		} else if (strcmp(key, "label") == 0) {
+			bpc->bpc_has_label = true;
+			sval = json_object_get_string(jo_val);
+			if (strlcpy(bpc->bpc_label, sval,
+				    sizeof(bpc->bpc_label))
+			    > sizeof(bpc->bpc_label)) {
+				log_debug("\tlabel: %s (truncated)", sval);
+				error++;
+			} else {
+				log_debug("\tlabel: %s", sval);
+			}
+		} else {
+			sval = json_object_get_string(jo_val);
+			log_warning("%s:%d invalid configuration: '%s: %s'",
+				    __func__, __LINE__, key, sval);
+			error++;
+		}
+	}
+
+	if (bpc->bpc_peer.sa_sin.sin_family == 0) {
+		log_debug("%s:%d no peer address provided", __func__, __LINE__);
+		error++;
+	}
+
+	return error;
+}
+
+static int parse_peer_label_config(struct json_object *jo,
+				   struct bfd_peer_cfg *bpc)
+{
+	struct peer_label *pl;
+	struct json_object *label;
+	const char *sval;
+
+	/* Get label and translate it to BFD daemon key. */
+	if (!json_object_object_get_ex(jo, "label", &label))
+		return 1;
+
+	sval = json_object_get_string(label);
+
+	pl = pl_find(sval);
+	if (pl == NULL)
+		return 1;
+
+	log_debug("\tpeer-label: %s", sval);
+
+	/* Translate the label into BFD address keys. */
+	bpc->bpc_ipv4 = !BFD_CHECK_FLAG(pl->pl_bs->flags, BFD_SESS_FLAG_IPV6);
+	bpc->bpc_mhop = BFD_CHECK_FLAG(pl->pl_bs->flags, BFD_SESS_FLAG_MH);
+	if (bpc->bpc_mhop) {
+		bpc->bpc_peer = pl->pl_bs->mhop.peer;
+		bpc->bpc_local = pl->pl_bs->mhop.local;
+		if (pl->pl_bs->mhop.vrf_name[0]) {
+			bpc->bpc_has_vrfname = true;
+			strlcpy(bpc->bpc_vrfname, pl->pl_bs->mhop.vrf_name,
+				sizeof(bpc->bpc_vrfname));
+		}
+	} else {
+		bpc->bpc_peer = pl->pl_bs->shop.peer;
+		if (pl->pl_bs->shop.port_name[0]) {
+			bpc->bpc_has_localif = true;
+			strlcpy(bpc->bpc_localif, pl->pl_bs->shop.port_name,
+				sizeof(bpc->bpc_localif));
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ * Control socket JSON parsing.
+ */
+int config_request_add(const char *jsonstr)
+{
+	struct json_object *jo;
+
+	jo = json_tokener_parse(jsonstr);
+	if (jo == NULL)
+		return -1;
+
+	return parse_config_json(jo, config_add, NULL);
+}
+
+int config_request_del(const char *jsonstr)
+{
+	struct json_object *jo;
+
+	jo = json_tokener_parse(jsonstr);
+	if (jo == NULL)
+		return -1;
+
+	return parse_config_json(jo, config_del, NULL);
+}
+
+char *config_response(const char *status, const char *error)
+{
+	struct json_object *resp, *jo;
+	char *jsonstr;
+
+	resp = json_object_new_object();
+	if (resp == NULL)
+		return NULL;
+
+	/* Add 'status' response key. */
+	jo = json_object_new_string(status);
+	if (jo == NULL) {
+		json_object_put(resp);
+		return NULL;
+	}
+
+	json_object_object_add(resp, "status", jo);
+
+	/* Add 'error' response key. */
+	if (error != NULL) {
+		jo = json_object_new_string(error);
+		if (jo == NULL) {
+			json_object_put(resp);
+			return NULL;
+		}
+
+		json_object_object_add(resp, "error", jo);
+	}
+
+	/* Generate JSON response. */
+	jsonstr = XSTRDUP(
+		MTYPE_BFDD_NOTIFICATION,
+		json_object_to_json_string_ext(resp, BFDD_JSON_CONV_OPTIONS));
+	json_object_put(resp);
+
+	return jsonstr;
+}
+
+char *config_notify(struct bfd_session *bs)
+{
+	struct json_object *resp;
+	char *jsonstr;
+	time_t now;
+
+	resp = json_object_new_object();
+	if (resp == NULL)
+		return NULL;
+
+	json_object_string_add(resp, "op", BCM_NOTIFY_PEER_STATUS);
+
+	json_object_add_peer(resp, bs);
+
+	/* Add status information */
+	json_object_int_add(resp, "id", bs->discrs.my_discr);
+	json_object_int_add(resp, "remote-id", bs->discrs.my_discr);
+
+	switch (bs->ses_state) {
+	case PTM_BFD_UP:
+		json_object_string_add(resp, "state", "up");
+
+		now = monotime(NULL);
+		json_object_int_add(resp, "uptime", now - bs->uptime.tv_sec);
+		break;
+	case PTM_BFD_ADM_DOWN:
+		json_object_string_add(resp, "state", "adm-down");
+		break;
+	case PTM_BFD_DOWN:
+		json_object_string_add(resp, "state", "down");
+
+		now = monotime(NULL);
+		json_object_int_add(resp, "downtime",
+				    now - bs->downtime.tv_sec);
+		break;
+	case PTM_BFD_INIT:
+		json_object_string_add(resp, "state", "init");
+		break;
+
+	default:
+		json_object_string_add(resp, "state", "unknown");
+		break;
+	}
+
+	json_object_int_add(resp, "diagnostics", bs->local_diag);
+	json_object_int_add(resp, "remote-diagnostics", bs->remote_diag);
+
+	/* Generate JSON response. */
+	jsonstr = XSTRDUP(
+		MTYPE_BFDD_NOTIFICATION,
+		json_object_to_json_string_ext(resp, BFDD_JSON_CONV_OPTIONS));
+	json_object_put(resp);
+
+	return jsonstr;
+}
+
+char *config_notify_config(const char *op, struct bfd_session *bs)
+{
+	struct json_object *resp;
+	char *jsonstr;
+
+	resp = json_object_new_object();
+	if (resp == NULL)
+		return NULL;
+
+	json_object_string_add(resp, "op", op);
+
+	json_object_add_peer(resp, bs);
+
+	/* On peer deletion we don't need to add any additional information. */
+	if (strcmp(op, BCM_NOTIFY_CONFIG_DELETE) == 0)
+		goto skip_config;
+
+	json_object_int_add(resp, "detect-multiplier", bs->detect_mult);
+	json_object_int_add(resp, "receive-interval",
+			    bs->timers.required_min_rx / 1000);
+	json_object_int_add(resp, "transmit-interval", bs->up_min_tx / 1000);
+	json_object_int_add(resp, "echo-interval",
+			    bs->timers.required_min_echo / 1000);
+
+	json_object_int_add(resp, "remote-detect-multiplier",
+			    bs->remote_detect_mult);
+	json_object_int_add(resp, "remote-receive-interval",
+			    bs->remote_timers.required_min_rx / 1000);
+	json_object_int_add(resp, "remote-transmit-interval",
+			    bs->remote_timers.desired_min_tx / 1000);
+	json_object_int_add(resp, "remote-echo-interval",
+			    bs->remote_timers.required_min_echo / 1000);
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))
+		json_object_boolean_true_add(resp, "echo-mode");
+	else
+		json_object_boolean_false_add(resp, "echo-mode");
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+		json_object_boolean_true_add(resp, "shutdown");
+	else
+		json_object_boolean_false_add(resp, "shutdown");
+
+skip_config:
+	/* Generate JSON response. */
+	jsonstr = XSTRDUP(
+		MTYPE_BFDD_NOTIFICATION,
+		json_object_to_json_string_ext(resp, BFDD_JSON_CONV_OPTIONS));
+	json_object_put(resp);
+
+	return jsonstr;
+}
+
+int config_notify_request(struct bfd_control_socket *bcs, const char *jsonstr,
+			  bpc_handle bh)
+{
+	struct json_object *jo;
+
+	jo = json_tokener_parse(jsonstr);
+	if (jo == NULL)
+		return -1;
+
+	return parse_config_json(jo, bh, bcs);
+}
+
+static int json_object_add_peer(struct json_object *jo, struct bfd_session *bs)
+{
+	/* Add peer 'key' information. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_IPV6))
+		json_object_boolean_true_add(jo, "ipv6");
+	else
+		json_object_boolean_false_add(jo, "ipv6");
+
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		json_object_boolean_true_add(jo, "multihop");
+		json_object_string_add(jo, "peer-address",
+				       satostr(&bs->mhop.peer));
+		json_object_string_add(jo, "local-address",
+				       satostr(&bs->mhop.local));
+		if (strlen(bs->mhop.vrf_name) > 0)
+			json_object_string_add(jo, "vrf-name",
+					       bs->mhop.vrf_name);
+	} else {
+		json_object_boolean_false_add(jo, "multihop");
+		json_object_string_add(jo, "peer-address",
+				       satostr(&bs->shop.peer));
+		if (bs->local_address.sa_sin.sin_family != AF_UNSPEC)
+			json_object_string_add(jo, "local-address",
+					       satostr(&bs->local_address));
+		if (strlen(bs->shop.port_name) > 0)
+			json_object_string_add(jo, "local-interface",
+					       bs->shop.port_name);
+	}
+
+	if (bs->pl)
+		json_object_string_add(jo, "label", bs->pl->pl_label);
+
+	return 0;
+}
+
+
+/*
+ * Label handling
+ */
+struct peer_label *pl_find(const char *label)
+{
+	struct peer_label *pl;
+
+	TAILQ_FOREACH (pl, &bglobal.bg_pllist, pl_entry) {
+		if (strcmp(pl->pl_label, label) != 0)
+			continue;
+
+		return pl;
+	}
+
+	return NULL;
+}
+
+struct peer_label *pl_new(const char *label, struct bfd_session *bs)
+{
+	struct peer_label *pl;
+
+	pl = XCALLOC(MTYPE_BFDD_LABEL, sizeof(*pl));
+	if (pl == NULL)
+		return NULL;
+
+	if (strlcpy(pl->pl_label, label, sizeof(pl->pl_label))
+	    > sizeof(pl->pl_label))
+		log_warning("%s:%d: label was truncated", __func__, __LINE__);
+
+	pl->pl_bs = bs;
+	bs->pl = pl;
+
+	TAILQ_INSERT_HEAD(&bglobal.bg_pllist, pl, pl_entry);
+
+	return pl;
+}
+
+void pl_free(struct peer_label *pl)
+{
+	if (pl == NULL)
+		return;
+
+	/* Remove the pointer back. */
+	pl->pl_bs->pl = NULL;
+
+	TAILQ_REMOVE(&bglobal.bg_pllist, pl, pl_entry);
+	XFREE(MTYPE_BFDD_LABEL, pl);
+}
diff -urpN frr-frr-5.0.1/bfdd/control.c frr-frr-6.0/bfdd/control.c
--- frr-frr-5.0.1/bfdd/control.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/control.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,895 @@
+/*********************************************************************
+ * Copyright 2017-2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * control.c: implements the BFD daemon control socket. It will be used
+ * to talk with clients daemon/scripts/consumers.
+ *
+ * Authors
+ * -------
+ * Rafael Zalamena <rzalamena@opensourcerouting.org>
+ */
+
+#include <zebra.h>
+
+#include <sys/un.h>
+
+#include "bfd.h"
+
+/*
+ * Prototypes
+ */
+static int sock_set_nonblock(int fd);
+struct bfd_control_queue *control_queue_new(struct bfd_control_socket *bcs);
+static void control_queue_free(struct bfd_control_socket *bcs,
+			       struct bfd_control_queue *bcq);
+static int control_queue_dequeue(struct bfd_control_socket *bcs);
+static int control_queue_enqueue(struct bfd_control_socket *bcs,
+				 struct bfd_control_msg *bcm);
+static int control_queue_enqueue_first(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm);
+struct bfd_notify_peer *control_notifypeer_new(struct bfd_control_socket *bcs,
+					       struct bfd_session *bs);
+static void control_notifypeer_free(struct bfd_control_socket *bcs,
+				    struct bfd_notify_peer *bnp);
+struct bfd_notify_peer *control_notifypeer_find(struct bfd_control_socket *bcs,
+						struct bfd_session *bs);
+
+
+struct bfd_control_socket *control_new(int sd);
+static void control_free(struct bfd_control_socket *bcs);
+static void control_reset_buf(struct bfd_control_buffer *bcb);
+static int control_read(struct thread *t);
+static int control_write(struct thread *t);
+
+static void control_handle_request_add(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm);
+static void control_handle_request_del(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm);
+static int notify_add_cb(struct bfd_peer_cfg *bpc, void *arg);
+static int notify_del_cb(struct bfd_peer_cfg *bpc, void *arg);
+static void control_handle_notify_add(struct bfd_control_socket *bcs,
+				      struct bfd_control_msg *bcm);
+static void control_handle_notify_del(struct bfd_control_socket *bcs,
+				      struct bfd_control_msg *bcm);
+static void _control_handle_notify(struct hash_backet *hb, void *arg);
+static void control_handle_notify(struct bfd_control_socket *bcs,
+				  struct bfd_control_msg *bcm);
+static void control_response(struct bfd_control_socket *bcs, uint16_t id,
+			     const char *status, const char *error);
+
+static void _control_notify_config(struct bfd_control_socket *bcs,
+				   const char *op, struct bfd_session *bs);
+static void _control_notify(struct bfd_control_socket *bcs,
+			    struct bfd_session *bs);
+
+
+/*
+ * Functions
+ */
+static int sock_set_nonblock(int fd)
+{
+	int flags;
+
+	flags = fcntl(fd, F_GETFL, 0);
+	if (flags == -1) {
+		log_warning("%s: fcntl F_GETFL: %s", __func__, strerror(errno));
+		return -1;
+	}
+
+	flags |= O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, flags) == -1) {
+		log_warning("%s: fcntl F_SETFL: %s", __func__, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+int control_init(const char *path)
+{
+	int sd;
+	mode_t umval;
+	struct sockaddr_un sun_ = {
+		.sun_family = AF_UNIX,
+		.sun_path = BFDD_CONTROL_SOCKET,
+	};
+
+	if (path)
+		strlcpy(sun_.sun_path, path, sizeof(sun_.sun_path));
+
+	/* Remove previously created sockets. */
+	unlink(sun_.sun_path);
+
+	sd = socket(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
+	if (sd == -1) {
+		log_error("%s: socket: %s", __func__, strerror(errno));
+		return -1;
+	}
+
+	umval = umask(0);
+	if (bind(sd, (struct sockaddr *)&sun_, sizeof(sun_)) == -1) {
+		log_error("%s: bind: %s", __func__, strerror(errno));
+		close(sd);
+		return -1;
+	}
+	umask(umval);
+
+	if (listen(sd, SOMAXCONN) == -1) {
+		log_error("%s: listen: %s", __func__, strerror(errno));
+		close(sd);
+		return -1;
+	}
+
+	sock_set_nonblock(sd);
+
+	bglobal.bg_csock = sd;
+
+	return 0;
+}
+
+void control_shutdown(void)
+{
+	struct bfd_control_socket *bcs;
+
+	if (bglobal.bg_csockev) {
+		thread_cancel(bglobal.bg_csockev);
+		bglobal.bg_csockev = NULL;
+	}
+
+	socket_close(&bglobal.bg_csock);
+
+	while (!TAILQ_EMPTY(&bglobal.bg_bcslist)) {
+		bcs = TAILQ_FIRST(&bglobal.bg_bcslist);
+		control_free(bcs);
+	}
+}
+
+int control_accept(struct thread *t)
+{
+	int csock, sd = THREAD_FD(t);
+
+	csock = accept(sd, NULL, 0);
+	if (csock == -1) {
+		log_warning("%s: accept: %s", __func__, strerror(errno));
+		return 0;
+	}
+
+	if (control_new(csock) == NULL)
+		close(csock);
+
+	bglobal.bg_csockev = NULL;
+	thread_add_read(master, control_accept, NULL, sd, &bglobal.bg_csockev);
+
+	return 0;
+}
+
+
+/*
+ * Client handling
+ */
+struct bfd_control_socket *control_new(int sd)
+{
+	struct bfd_control_socket *bcs;
+
+	bcs = XCALLOC(MTYPE_BFDD_CONTROL, sizeof(*bcs));
+	if (bcs == NULL)
+		return NULL;
+
+	/* Disable notifications by default. */
+	bcs->bcs_notify = 0;
+
+	bcs->bcs_sd = sd;
+	thread_add_read(master, control_read, bcs, sd, &bcs->bcs_ev);
+
+	TAILQ_INIT(&bcs->bcs_bcqueue);
+	TAILQ_INIT(&bcs->bcs_bnplist);
+	TAILQ_INSERT_TAIL(&bglobal.bg_bcslist, bcs, bcs_entry);
+
+	return bcs;
+}
+
+static void control_free(struct bfd_control_socket *bcs)
+{
+	struct bfd_control_queue *bcq;
+	struct bfd_notify_peer *bnp;
+
+	if (bcs->bcs_ev) {
+		thread_cancel(bcs->bcs_ev);
+		bcs->bcs_ev = NULL;
+	}
+
+	if (bcs->bcs_outev) {
+		thread_cancel(bcs->bcs_outev);
+		bcs->bcs_outev = NULL;
+	}
+
+	close(bcs->bcs_sd);
+
+	TAILQ_REMOVE(&bglobal.bg_bcslist, bcs, bcs_entry);
+
+	/* Empty output queue. */
+	while (!TAILQ_EMPTY(&bcs->bcs_bcqueue)) {
+		bcq = TAILQ_FIRST(&bcs->bcs_bcqueue);
+		control_queue_free(bcs, bcq);
+	}
+
+	/* Empty notification list. */
+	while (!TAILQ_EMPTY(&bcs->bcs_bnplist)) {
+		bnp = TAILQ_FIRST(&bcs->bcs_bnplist);
+		control_notifypeer_free(bcs, bnp);
+	}
+
+	control_reset_buf(&bcs->bcs_bin);
+	XFREE(MTYPE_BFDD_CONTROL, bcs);
+}
+
+struct bfd_notify_peer *control_notifypeer_new(struct bfd_control_socket *bcs,
+					       struct bfd_session *bs)
+{
+	struct bfd_notify_peer *bnp;
+
+	bnp = control_notifypeer_find(bcs, bs);
+	if (bnp)
+		return bnp;
+
+	bnp = XCALLOC(MTYPE_BFDD_CONTROL, sizeof(*bnp));
+	if (bnp == NULL) {
+		log_warning("%s: calloc: %s", __func__, strerror(errno));
+		return NULL;
+	}
+
+	TAILQ_INSERT_TAIL(&bcs->bcs_bnplist, bnp, bnp_entry);
+	bnp->bnp_bs = bs;
+	bs->refcount++;
+
+	return bnp;
+}
+
+static void control_notifypeer_free(struct bfd_control_socket *bcs,
+				    struct bfd_notify_peer *bnp)
+{
+	TAILQ_REMOVE(&bcs->bcs_bnplist, bnp, bnp_entry);
+	bnp->bnp_bs->refcount--;
+	XFREE(MTYPE_BFDD_CONTROL, bnp);
+}
+
+struct bfd_notify_peer *control_notifypeer_find(struct bfd_control_socket *bcs,
+						struct bfd_session *bs)
+{
+	struct bfd_notify_peer *bnp;
+
+	TAILQ_FOREACH (bnp, &bcs->bcs_bnplist, bnp_entry) {
+		if (bnp->bnp_bs == bs)
+			return bnp;
+	}
+
+	return NULL;
+}
+
+struct bfd_control_queue *control_queue_new(struct bfd_control_socket *bcs)
+{
+	struct bfd_control_queue *bcq;
+
+	bcq = XCALLOC(MTYPE_BFDD_NOTIFICATION, sizeof(*bcq));
+	if (bcq == NULL) {
+		log_warning("%s: calloc: %s", __func__, strerror(errno));
+		return NULL;
+	}
+
+	control_reset_buf(&bcq->bcq_bcb);
+	TAILQ_INSERT_TAIL(&bcs->bcs_bcqueue, bcq, bcq_entry);
+
+	return bcq;
+}
+
+static void control_queue_free(struct bfd_control_socket *bcs,
+			       struct bfd_control_queue *bcq)
+{
+	control_reset_buf(&bcq->bcq_bcb);
+	TAILQ_REMOVE(&bcs->bcs_bcqueue, bcq, bcq_entry);
+	XFREE(MTYPE_BFDD_NOTIFICATION, bcq);
+}
+
+static int control_queue_dequeue(struct bfd_control_socket *bcs)
+{
+	struct bfd_control_queue *bcq;
+
+	/* List is empty, nothing to do. */
+	if (TAILQ_EMPTY(&bcs->bcs_bcqueue))
+		goto empty_list;
+
+	bcq = TAILQ_FIRST(&bcs->bcs_bcqueue);
+	control_queue_free(bcs, bcq);
+
+	/* Get the next buffer to send. */
+	if (TAILQ_EMPTY(&bcs->bcs_bcqueue))
+		goto empty_list;
+
+	bcq = TAILQ_FIRST(&bcs->bcs_bcqueue);
+	bcs->bcs_bout = &bcq->bcq_bcb;
+
+	bcs->bcs_outev = NULL;
+	thread_add_write(master, control_write, bcs, bcs->bcs_sd,
+			 &bcs->bcs_outev);
+
+	return 1;
+
+empty_list:
+	if (bcs->bcs_outev) {
+		thread_cancel(bcs->bcs_outev);
+		bcs->bcs_outev = NULL;
+	}
+	bcs->bcs_bout = NULL;
+	return 0;
+}
+
+static int control_queue_enqueue(struct bfd_control_socket *bcs,
+				 struct bfd_control_msg *bcm)
+{
+	struct bfd_control_queue *bcq;
+	struct bfd_control_buffer *bcb;
+
+	bcq = control_queue_new(bcs);
+	if (bcq == NULL)
+		return -1;
+
+	bcb = &bcq->bcq_bcb;
+	bcb->bcb_left = sizeof(struct bfd_control_msg) + ntohl(bcm->bcm_length);
+	bcb->bcb_pos = 0;
+	bcb->bcb_bcm = bcm;
+
+	/* If this is the first item, then dequeue and start using it. */
+	if (bcs->bcs_bout == NULL) {
+		bcs->bcs_bout = bcb;
+
+		/* New messages, active write events. */
+		thread_add_write(master, control_write, bcs, bcs->bcs_sd,
+				 &bcs->bcs_outev);
+	}
+
+	return 0;
+}
+
+static int control_queue_enqueue_first(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm)
+{
+	struct bfd_control_queue *bcq, *bcqn;
+	struct bfd_control_buffer *bcb;
+
+	/* Enqueue it somewhere. */
+	if (control_queue_enqueue(bcs, bcm) == -1)
+		return -1;
+
+	/*
+	 * The item is either the first or the last. So we must first
+	 * check the best case where the item is already the first.
+	 */
+	bcq = TAILQ_FIRST(&bcs->bcs_bcqueue);
+	bcb = &bcq->bcq_bcb;
+	if (bcm == bcb->bcb_bcm)
+		return 0;
+
+	/*
+	 * The item was not the first, so it is the last. We'll try to
+	 * assign it to the head of the queue, however if there is a
+	 * transfer in progress, then we have to make the item as the
+	 * next one.
+	 *
+	 * Interrupting the transfer of in progress message will cause
+	 * the client to lose track of the message position/data.
+	 */
+	bcqn = TAILQ_LAST(&bcs->bcs_bcqueue, bcqueue);
+	TAILQ_REMOVE(&bcs->bcs_bcqueue, bcqn, bcq_entry);
+	if (bcb->bcb_pos != 0) {
+		/*
+		 * First position is already being sent, insert into
+		 * second position.
+		 */
+		TAILQ_INSERT_AFTER(&bcs->bcs_bcqueue, bcq, bcqn, bcq_entry);
+	} else {
+		/*
+		 * Old message didn't start being sent, we still have
+		 * time to put this one in the head of the queue.
+		 */
+		TAILQ_INSERT_HEAD(&bcs->bcs_bcqueue, bcqn, bcq_entry);
+		bcb = &bcqn->bcq_bcb;
+		bcs->bcs_bout = bcb;
+	}
+
+	return 0;
+}
+
+static void control_reset_buf(struct bfd_control_buffer *bcb)
+{
+	/* Get ride of old data. */
+	XFREE(MTYPE_BFDD_NOTIFICATION, bcb->bcb_buf);
+	bcb->bcb_buf = NULL;
+	bcb->bcb_pos = 0;
+	bcb->bcb_left = 0;
+}
+
+static int control_read(struct thread *t)
+{
+	struct bfd_control_socket *bcs = THREAD_ARG(t);
+	struct bfd_control_buffer *bcb = &bcs->bcs_bin;
+	int sd = bcs->bcs_sd;
+	struct bfd_control_msg bcm;
+	ssize_t bread;
+	size_t plen;
+
+	/*
+	 * Check if we have already downloaded message content, if so then skip
+	 * to
+	 * download the rest of it and process.
+	 *
+	 * Otherwise download a new message header and allocate the necessary
+	 * memory.
+	 */
+	if (bcb->bcb_buf != NULL)
+		goto skip_header;
+
+	bread = read(sd, &bcm, sizeof(bcm));
+	if (bread == 0) {
+		control_free(bcs);
+		return 0;
+	}
+	if (bread < 0) {
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
+			goto schedule_next_read;
+
+		log_warning("%s: read: %s", __func__, strerror(errno));
+		control_free(bcs);
+		return 0;
+	}
+
+	/* Validate header fields. */
+	plen = ntohl(bcm.bcm_length);
+	if (plen < 2) {
+		log_debug("%s: client closed due small message length: %d",
+			  __func__, bcm.bcm_length);
+		control_free(bcs);
+		return 0;
+	}
+
+	if (bcm.bcm_ver != BMV_VERSION_1) {
+		log_debug("%s: client closed due bad version: %d", __func__,
+			  bcm.bcm_ver);
+		control_free(bcs);
+		return 0;
+	}
+
+	/* Prepare the buffer to load the message. */
+	bcs->bcs_version = bcm.bcm_ver;
+	bcs->bcs_type = bcm.bcm_type;
+
+	bcb->bcb_pos = sizeof(bcm);
+	bcb->bcb_left = plen;
+	bcb->bcb_buf = XMALLOC(MTYPE_BFDD_NOTIFICATION,
+			       sizeof(bcm) + bcb->bcb_left + 1);
+	if (bcb->bcb_buf == NULL) {
+		log_warning("%s: not enough memory for message size: %u",
+			    __func__, bcb->bcb_left);
+		control_free(bcs);
+		return 0;
+	}
+
+	memcpy(bcb->bcb_buf, &bcm, sizeof(bcm));
+
+	/* Terminate data string with NULL for later processing. */
+	bcb->bcb_buf[sizeof(bcm) + bcb->bcb_left] = 0;
+
+skip_header:
+	/* Download the remaining data of the message and process it. */
+	bread = read(sd, &bcb->bcb_buf[bcb->bcb_pos], bcb->bcb_left);
+	if (bread == 0) {
+		control_free(bcs);
+		return 0;
+	}
+	if (bread < 0) {
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
+			goto schedule_next_read;
+
+		log_warning("%s: read: %s", __func__, strerror(errno));
+		control_free(bcs);
+		return 0;
+	}
+
+	bcb->bcb_pos += bread;
+	bcb->bcb_left -= bread;
+	/* We need more data, return to wait more. */
+	if (bcb->bcb_left > 0)
+		goto schedule_next_read;
+
+	switch (bcb->bcb_bcm->bcm_type) {
+	case BMT_REQUEST_ADD:
+		control_handle_request_add(bcs, bcb->bcb_bcm);
+		break;
+	case BMT_REQUEST_DEL:
+		control_handle_request_del(bcs, bcb->bcb_bcm);
+		break;
+	case BMT_NOTIFY:
+		control_handle_notify(bcs, bcb->bcb_bcm);
+		break;
+	case BMT_NOTIFY_ADD:
+		control_handle_notify_add(bcs, bcb->bcb_bcm);
+		break;
+	case BMT_NOTIFY_DEL:
+		control_handle_notify_del(bcs, bcb->bcb_bcm);
+		break;
+
+	default:
+		log_debug("%s: unhandled message type: %d", __func__,
+			  bcb->bcb_bcm->bcm_type);
+		control_response(bcs, bcb->bcb_bcm->bcm_id, BCM_RESPONSE_ERROR,
+				 "invalid message type");
+		break;
+	}
+
+	bcs->bcs_version = 0;
+	bcs->bcs_type = 0;
+	control_reset_buf(bcb);
+
+schedule_next_read:
+	bcs->bcs_ev = NULL;
+	thread_add_read(master, control_read, bcs, sd, &bcs->bcs_ev);
+
+	return 0;
+}
+
+static int control_write(struct thread *t)
+{
+	struct bfd_control_socket *bcs = THREAD_ARG(t);
+	struct bfd_control_buffer *bcb = bcs->bcs_bout;
+	int sd = bcs->bcs_sd;
+	ssize_t bwrite;
+
+	bwrite = write(sd, &bcb->bcb_buf[bcb->bcb_pos], bcb->bcb_left);
+	if (bwrite == 0) {
+		control_free(bcs);
+		return 0;
+	}
+	if (bwrite < 0) {
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
+			bcs->bcs_outev = NULL;
+			thread_add_write(master, control_write, bcs,
+					 bcs->bcs_sd, &bcs->bcs_outev);
+			return 0;
+		}
+
+		log_warning("%s: write: %s", __func__, strerror(errno));
+		control_free(bcs);
+		return 0;
+	}
+
+	bcb->bcb_pos += bwrite;
+	bcb->bcb_left -= bwrite;
+	if (bcb->bcb_left > 0) {
+		bcs->bcs_outev = NULL;
+		thread_add_write(master, control_write, bcs, bcs->bcs_sd,
+				 &bcs->bcs_outev);
+		return 0;
+	}
+
+	control_queue_dequeue(bcs);
+
+	return 0;
+}
+
+
+/*
+ * Message processing
+ */
+static void control_handle_request_add(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm)
+{
+	const char *json = (const char *)bcm->bcm_data;
+
+	if (config_request_add(json) == 0)
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_OK, NULL);
+	else
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_ERROR,
+				 "request add failed");
+}
+
+static void control_handle_request_del(struct bfd_control_socket *bcs,
+				       struct bfd_control_msg *bcm)
+{
+	const char *json = (const char *)bcm->bcm_data;
+
+	if (config_request_del(json) == 0)
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_OK, NULL);
+	else
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_ERROR,
+				 "request del failed");
+}
+
+static struct bfd_session *_notify_find_peer(struct bfd_peer_cfg *bpc)
+{
+	struct peer_label *pl;
+
+	if (bpc->bpc_has_label) {
+		pl = pl_find(bpc->bpc_label);
+		if (pl)
+			return pl->pl_bs;
+	}
+
+	return bs_peer_find(bpc);
+}
+
+static void _control_handle_notify(struct hash_backet *hb, void *arg)
+{
+	struct bfd_control_socket *bcs = arg;
+	struct bfd_session *bs = hb->data;
+
+	/* Notify peer configuration. */
+	if (bcs->bcs_notify & BCM_NOTIFY_CONFIG)
+		_control_notify_config(bcs, BCM_NOTIFY_CONFIG_ADD, bs);
+
+	/* Notify peer status. */
+	if (bcs->bcs_notify & BCM_NOTIFY_PEER_STATE)
+		_control_notify(bcs, bs);
+}
+
+static void control_handle_notify(struct bfd_control_socket *bcs,
+				  struct bfd_control_msg *bcm)
+{
+	memcpy(&bcs->bcs_notify, bcm->bcm_data, sizeof(bcs->bcs_notify));
+
+	control_response(bcs, bcm->bcm_id, BCM_RESPONSE_OK, NULL);
+
+	/*
+	 * If peer asked for notification configuration, send everything that
+	 * was configured until the moment to sync up.
+	 */
+	if (bcs->bcs_notify & (BCM_NOTIFY_CONFIG | BCM_NOTIFY_PEER_STATE))
+		bfd_id_iterate(_control_handle_notify, bcs);
+}
+
+static int notify_add_cb(struct bfd_peer_cfg *bpc, void *arg)
+{
+	struct bfd_control_socket *bcs = arg;
+	struct bfd_session *bs = _notify_find_peer(bpc);
+
+	if (bs == NULL)
+		return -1;
+
+	if (control_notifypeer_new(bcs, bs) == NULL)
+		return -1;
+
+	/* Notify peer status. */
+	_control_notify(bcs, bs);
+
+	return 0;
+}
+
+static int notify_del_cb(struct bfd_peer_cfg *bpc, void *arg)
+{
+	struct bfd_control_socket *bcs = arg;
+	struct bfd_session *bs = _notify_find_peer(bpc);
+	struct bfd_notify_peer *bnp;
+
+	if (bs == NULL)
+		return -1;
+
+	bnp = control_notifypeer_find(bcs, bs);
+	if (bnp)
+		control_notifypeer_free(bcs, bnp);
+
+	return 0;
+}
+
+static void control_handle_notify_add(struct bfd_control_socket *bcs,
+				      struct bfd_control_msg *bcm)
+{
+	const char *json = (const char *)bcm->bcm_data;
+
+	if (config_notify_request(bcs, json, notify_add_cb) == 0) {
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_OK, NULL);
+		return;
+	}
+
+	control_response(bcs, bcm->bcm_id, BCM_RESPONSE_ERROR,
+			 "failed to parse notify data");
+}
+
+static void control_handle_notify_del(struct bfd_control_socket *bcs,
+				      struct bfd_control_msg *bcm)
+{
+	const char *json = (const char *)bcm->bcm_data;
+
+	if (config_notify_request(bcs, json, notify_del_cb) == 0) {
+		control_response(bcs, bcm->bcm_id, BCM_RESPONSE_OK, NULL);
+		return;
+	}
+
+	control_response(bcs, bcm->bcm_id, BCM_RESPONSE_ERROR,
+			 "failed to parse notify data");
+}
+
+
+/*
+ * Internal functions used by the BFD daemon.
+ */
+static void control_response(struct bfd_control_socket *bcs, uint16_t id,
+			     const char *status, const char *error)
+{
+	struct bfd_control_msg *bcm;
+	char *jsonstr;
+	size_t jsonstrlen;
+
+	/* Generate JSON response. */
+	jsonstr = config_response(status, error);
+	if (jsonstr == NULL) {
+		log_warning("%s: config_response: failed to get JSON str",
+			    __func__);
+		return;
+	}
+
+	/* Allocate data and answer. */
+	jsonstrlen = strlen(jsonstr);
+	bcm = XMALLOC(MTYPE_BFDD_NOTIFICATION,
+		      sizeof(struct bfd_control_msg) + jsonstrlen);
+	if (bcm == NULL) {
+		log_warning("%s: malloc: %s", __func__, strerror(errno));
+		XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+		return;
+	}
+
+	bcm->bcm_length = htonl(jsonstrlen);
+	bcm->bcm_ver = BMV_VERSION_1;
+	bcm->bcm_type = BMT_RESPONSE;
+	bcm->bcm_id = id;
+	memcpy(bcm->bcm_data, jsonstr, jsonstrlen);
+	XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+
+	control_queue_enqueue_first(bcs, bcm);
+}
+
+static void _control_notify(struct bfd_control_socket *bcs,
+			    struct bfd_session *bs)
+{
+	struct bfd_control_msg *bcm;
+	char *jsonstr;
+	size_t jsonstrlen;
+
+	/* Generate JSON response. */
+	jsonstr = config_notify(bs);
+	if (jsonstr == NULL) {
+		log_warning("%s: config_notify: failed to get JSON str",
+			    __func__);
+		return;
+	}
+
+	/* Allocate data and answer. */
+	jsonstrlen = strlen(jsonstr);
+	bcm = XMALLOC(MTYPE_BFDD_NOTIFICATION,
+		      sizeof(struct bfd_control_msg) + jsonstrlen);
+	if (bcm == NULL) {
+		log_warning("%s: malloc: %s", __func__, strerror(errno));
+		XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+		return;
+	}
+
+	bcm->bcm_length = htonl(jsonstrlen);
+	bcm->bcm_ver = BMV_VERSION_1;
+	bcm->bcm_type = BMT_NOTIFY;
+	bcm->bcm_id = htons(BCM_NOTIFY_ID);
+	memcpy(bcm->bcm_data, jsonstr, jsonstrlen);
+	XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+
+	control_queue_enqueue(bcs, bcm);
+}
+
+int control_notify(struct bfd_session *bs)
+{
+	struct bfd_control_socket *bcs;
+	struct bfd_notify_peer *bnp;
+
+	/* Notify zebra listeners as well. */
+	ptm_bfd_notify(bs);
+
+	/*
+	 * PERFORMANCE: reuse the bfd_control_msg allocated data for
+	 * all control sockets to avoid wasting memory.
+	 */
+	TAILQ_FOREACH (bcs, &bglobal.bg_bcslist, bcs_entry) {
+		/*
+		 * Test for all notifications first, then search for
+		 * specific peers.
+		 */
+		if ((bcs->bcs_notify & BCM_NOTIFY_PEER_STATE) == 0) {
+			bnp = control_notifypeer_find(bcs, bs);
+			/*
+			 * If the notification is not configured here,
+			 * don't send it.
+			 */
+			if (bnp == NULL)
+				continue;
+		}
+
+		_control_notify(bcs, bs);
+	}
+
+	return 0;
+}
+
+static void _control_notify_config(struct bfd_control_socket *bcs,
+				   const char *op, struct bfd_session *bs)
+{
+	struct bfd_control_msg *bcm;
+	char *jsonstr;
+	size_t jsonstrlen;
+
+	/* Generate JSON response. */
+	jsonstr = config_notify_config(op, bs);
+	if (jsonstr == NULL) {
+		log_warning("%s: config_notify_config: failed to get JSON str",
+			    __func__);
+		return;
+	}
+
+	/* Allocate data and answer. */
+	jsonstrlen = strlen(jsonstr);
+	bcm = XMALLOC(MTYPE_BFDD_NOTIFICATION,
+		      sizeof(struct bfd_control_msg) + jsonstrlen);
+	if (bcm == NULL) {
+		log_warning("%s: malloc: %s", __func__, strerror(errno));
+		XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+		return;
+	}
+
+	bcm->bcm_length = htonl(jsonstrlen);
+	bcm->bcm_ver = BMV_VERSION_1;
+	bcm->bcm_type = BMT_NOTIFY;
+	bcm->bcm_id = htons(BCM_NOTIFY_ID);
+	memcpy(bcm->bcm_data, jsonstr, jsonstrlen);
+	XFREE(MTYPE_BFDD_NOTIFICATION, jsonstr);
+
+	control_queue_enqueue(bcs, bcm);
+}
+
+int control_notify_config(const char *op, struct bfd_session *bs)
+{
+	struct bfd_control_socket *bcs;
+	struct bfd_notify_peer *bnp;
+
+	/* Remove the control sockets notification for this peer. */
+	if (strcmp(op, BCM_NOTIFY_CONFIG_DELETE) == 0 && bs->refcount > 0) {
+		TAILQ_FOREACH (bcs, &bglobal.bg_bcslist, bcs_entry) {
+			bnp = control_notifypeer_find(bcs, bs);
+			if (bnp)
+				control_notifypeer_free(bcs, bnp);
+		}
+	}
+
+	/*
+	 * PERFORMANCE: reuse the bfd_control_msg allocated data for
+	 * all control sockets to avoid wasting memory.
+	 */
+	TAILQ_FOREACH (bcs, &bglobal.bg_bcslist, bcs_entry) {
+		/*
+		 * Test for all notifications first, then search for
+		 * specific peers.
+		 */
+		if ((bcs->bcs_notify & BCM_NOTIFY_CONFIG) == 0)
+			continue;
+
+		_control_notify_config(bcs, op, bs);
+	}
+
+	return 0;
+}
diff -urpN frr-frr-5.0.1/bfdd/event.c frr-frr-6.0/bfdd/event.c
--- frr-frr-5.0.1/bfdd/event.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/event.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,155 @@
+/*********************************************************************
+ * Copyright 2017-2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * event.c: implements the BFD loop event handlers.
+ *
+ * Authors
+ * -------
+ * Rafael Zalamena <rzalamena@opensourcerouting.org>
+ */
+
+#include <zebra.h>
+
+#include "bfd.h"
+
+void tv_normalize(struct timeval *tv);
+
+void tv_normalize(struct timeval *tv)
+{
+	/* Remove seconds part from microseconds. */
+	tv->tv_sec = tv->tv_usec / 1000000;
+	tv->tv_usec = tv->tv_usec % 1000000;
+}
+
+void bfd_recvtimer_update(struct bfd_session *bs)
+{
+	struct timeval tv = {.tv_sec = 0, .tv_usec = bs->detect_TO};
+
+	/* Don't add event if peer is deactivated. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+		return;
+
+	tv_normalize(&tv);
+#ifdef BFD_EVENT_DEBUG
+	log_debug("%s: sec = %ld, usec = %ld", __func__, tv.tv_sec, tv.tv_usec);
+#endif /* BFD_EVENT_DEBUG */
+
+	/* Remove previous schedule if any. */
+	if (bs->recvtimer_ev)
+		bfd_recvtimer_delete(bs);
+
+	thread_add_timer_tv(master, bfd_recvtimer_cb, bs, &tv,
+			    &bs->recvtimer_ev);
+}
+
+void bfd_echo_recvtimer_update(struct bfd_session *bs)
+{
+	struct timeval tv = {.tv_sec = 0, .tv_usec = bs->echo_detect_TO};
+
+	/* Don't add event if peer is deactivated. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+		return;
+
+	tv_normalize(&tv);
+#ifdef BFD_EVENT_DEBUG
+	log_debug("%s: sec = %ld, usec = %ld", __func__, tv.tv_sec, tv.tv_usec);
+#endif /* BFD_EVENT_DEBUG */
+
+	/* Remove previous schedule if any. */
+	if (bs->echo_recvtimer_ev)
+		bfd_echo_recvtimer_delete(bs);
+
+	thread_add_timer_tv(master, bfd_echo_recvtimer_cb, bs, &tv,
+			    &bs->echo_recvtimer_ev);
+}
+
+void bfd_xmttimer_update(struct bfd_session *bs, uint64_t jitter)
+{
+	struct timeval tv = {.tv_sec = 0, .tv_usec = jitter};
+
+	/* Don't add event if peer is deactivated. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+		return;
+
+	tv_normalize(&tv);
+#ifdef BFD_EVENT_DEBUG
+	log_debug("%s: sec = %ld, usec = %ld", __func__, tv.tv_sec, tv.tv_usec);
+#endif /* BFD_EVENT_DEBUG */
+
+	/* Remove previous schedule if any. */
+	if (bs->xmttimer_ev)
+		bfd_xmttimer_delete(bs);
+
+	thread_add_timer_tv(master, bfd_xmt_cb, bs, &tv, &bs->xmttimer_ev);
+}
+
+void bfd_echo_xmttimer_update(struct bfd_session *bs, uint64_t jitter)
+{
+	struct timeval tv = {.tv_sec = 0, .tv_usec = jitter};
+
+	/* Don't add event if peer is deactivated. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN))
+		return;
+
+	tv_normalize(&tv);
+#ifdef BFD_EVENT_DEBUG
+	log_debug("%s: sec = %ld, usec = %ld", __func__, tv.tv_sec, tv.tv_usec);
+#endif /* BFD_EVENT_DEBUG */
+
+	/* Remove previous schedule if any. */
+	if (bs->echo_xmttimer_ev)
+		bfd_echo_xmttimer_delete(bs);
+
+	thread_add_timer_tv(master, bfd_echo_xmt_cb, bs, &tv,
+			    &bs->echo_xmttimer_ev);
+}
+
+void bfd_recvtimer_delete(struct bfd_session *bs)
+{
+	if (bs->recvtimer_ev == NULL)
+		return;
+
+	thread_cancel(bs->recvtimer_ev);
+	bs->recvtimer_ev = NULL;
+}
+
+void bfd_echo_recvtimer_delete(struct bfd_session *bs)
+{
+	if (bs->echo_recvtimer_ev == NULL)
+		return;
+
+	thread_cancel(bs->echo_recvtimer_ev);
+	bs->echo_recvtimer_ev = NULL;
+}
+
+void bfd_xmttimer_delete(struct bfd_session *bs)
+{
+	if (bs->xmttimer_ev == NULL)
+		return;
+
+	thread_cancel(bs->xmttimer_ev);
+	bs->xmttimer_ev = NULL;
+}
+
+void bfd_echo_xmttimer_delete(struct bfd_session *bs)
+{
+	if (bs->echo_xmttimer_ev == NULL)
+		return;
+
+	thread_cancel(bs->echo_xmttimer_ev);
+	bs->echo_xmttimer_ev = NULL;
+}
diff -urpN frr-frr-5.0.1/bfdd/linux.c frr-frr-6.0/bfdd/linux.c
--- frr-frr-5.0.1/bfdd/linux.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/linux.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,221 @@
+/*
+ * Linux specific code
+ *
+ * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * FRR is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FRR; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#ifdef BFD_LINUX
+
+/* XXX: fix compilation error on Ubuntu 16.04 or older. */
+#ifndef _UAPI_IPV6_H
+#define _UAPI_IPV6_H
+#endif /* _UAPI_IPV6_H */
+
+#include <linux/filter.h>
+#include <linux/if_packet.h>
+
+#include <netinet/if_ether.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+
+#include "bfd.h"
+
+/* Berkeley Packet filter code to filter out BFD Echo packets.
+ * tcpdump -dd "(udp dst port 3785)"
+ */
+static struct sock_filter bfd_echo_filter[] = {
+	{0x28, 0, 0, 0x0000000c}, {0x15, 0, 4, 0x000086dd},
+	{0x30, 0, 0, 0x00000014}, {0x15, 0, 11, 0x00000011},
+	{0x28, 0, 0, 0x00000038}, {0x15, 8, 9, 0x00000ec9},
+	{0x15, 0, 8, 0x00000800}, {0x30, 0, 0, 0x00000017},
+	{0x15, 0, 6, 0x00000011}, {0x28, 0, 0, 0x00000014},
+	{0x45, 4, 0, 0x00001fff}, {0xb1, 0, 0, 0x0000000e},
+	{0x48, 0, 0, 0x00000010}, {0x15, 0, 1, 0x00000ec9},
+	{0x6, 0, 0, 0x0000ffff},  {0x6, 0, 0, 0x00000000},
+};
+
+/* Berkeley Packet filter code to filter out BFD vxlan packets.
+ * tcpdump -dd "(udp dst port 4789)"
+ */
+static struct sock_filter bfd_vxlan_filter[] = {
+	{0x28, 0, 0, 0x0000000c}, {0x15, 0, 4, 0x000086dd},
+	{0x30, 0, 0, 0x00000014}, {0x15, 0, 11, 0x00000011},
+	{0x28, 0, 0, 0x00000038}, {0x15, 8, 9, 0x000012b5},
+	{0x15, 0, 8, 0x00000800}, {0x30, 0, 0, 0x00000017},
+	{0x15, 0, 6, 0x00000011}, {0x28, 0, 0, 0x00000014},
+	{0x45, 4, 0, 0x00001fff}, {0xb1, 0, 0, 0x0000000e},
+	{0x48, 0, 0, 0x00000010}, {0x15, 0, 1, 0x000012b5},
+	{0x6, 0, 0, 0x0000ffff},  {0x6, 0, 0, 0x00000000},
+};
+
+
+/*
+ * Definitions.
+ */
+int ptm_bfd_fetch_ifindex(const char *ifname)
+{
+	struct ifreq ifr;
+
+	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name))
+	    > sizeof(ifr.ifr_name))
+		log_error("interface-to-index: name truncated ('%s' -> '%s')",
+			  ifr.ifr_name, ifname);
+
+	if (ioctl(bglobal.bg_shop, SIOCGIFINDEX, &ifr) == -1) {
+		log_error("interface-to-index: %s translation failed: %s",
+			  ifname, strerror(errno));
+		return -1;
+	}
+
+	return ifr.ifr_ifindex;
+}
+
+void ptm_bfd_fetch_local_mac(const char *ifname, uint8_t *mac)
+{
+	struct ifreq ifr;
+
+	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name))
+	    > sizeof(ifr.ifr_name))
+		log_error("interface-mac: name truncated ('%s' -> '%s')",
+			  ifr.ifr_name, ifname);
+
+	if (ioctl(bglobal.bg_shop, SIOCGIFHWADDR, &ifr) == -1) {
+		log_error("interface-mac: %s MAC retrieval failed: %s", ifname,
+			  strerror(errno));
+		return;
+	}
+
+	memcpy(mac, ifr.ifr_hwaddr.sa_data, ETHERNET_ADDRESS_LENGTH);
+}
+
+
+/* Was _fetch_portname_from_ifindex() */
+void fetch_portname_from_ifindex(int ifindex, char *ifname, size_t ifnamelen)
+{
+	struct ifreq ifr;
+
+	ifname[0] = 0;
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_ifindex = ifindex;
+
+	if (ioctl(bglobal.bg_shop, SIOCGIFNAME, &ifr) == -1) {
+		log_error("index-to-interface: index %d failure: %s", ifindex,
+			  strerror(errno));
+		return;
+	}
+
+	if (strlcpy(ifname, ifr.ifr_name, ifnamelen) >= ifnamelen)
+		log_debug("index-to-interface: name truncated '%s' -> '%s'",
+			  ifr.ifr_name, ifname);
+}
+
+int ptm_bfd_echo_sock_init(void)
+{
+	int s;
+	struct sock_fprog bpf = {.len = sizeof(bfd_echo_filter)
+					/ sizeof(bfd_echo_filter[0]),
+				 .filter = bfd_echo_filter};
+
+	s = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));
+	if (s == -1) {
+		log_error("echo-socket: creation failure: %s", strerror(errno));
+		return -1;
+	}
+
+	if (setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf))
+	    == -1) {
+		log_error("echo-socket: setsockopt(SO_ATTACH_FILTER): %s",
+			  strerror(errno));
+		close(s);
+		return -1;
+	}
+
+	return s;
+}
+
+int ptm_bfd_vxlan_sock_init(void)
+{
+	int s;
+	struct sock_fprog bpf = {.len = sizeof(bfd_vxlan_filter)
+					/ sizeof(bfd_vxlan_filter[0]),
+				 .filter = bfd_vxlan_filter};
+
+	s = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));
+	if (s == -1) {
+		log_error("vxlan-socket: creation failure: %s",
+			  strerror(errno));
+		return -1;
+	}
+
+	if (setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf))
+	    == -1) {
+		log_error("vxlan-socket: setsockopt(SO_ATTACH_FILTER): %s",
+			  strerror(errno));
+		close(s);
+		return -1;
+	}
+
+	return s;
+}
+
+int bp_bind_dev(int sd __attribute__((__unused__)),
+		const char *dev __attribute__((__unused__)))
+{
+	/*
+	 * TODO: implement this differently. It is not possible to
+	 * SO_BINDTODEVICE after the daemon has dropped its privileges.
+	 */
+#if 0
+	size_t devlen = strlen(dev) + 1;
+
+	if (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, dev, devlen) == -1) {
+		log_warning("%s: setsockopt(SO_BINDTODEVICE, \"%s\"): %s",
+			    __func__, dev, strerror(errno));
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
+uint16_t udp4_checksum(struct iphdr *iph, uint8_t *buf, int len)
+{
+	char *ptr;
+	struct udp_psuedo_header pudp_hdr;
+	uint16_t csum;
+
+	pudp_hdr.saddr = iph->saddr;
+	pudp_hdr.daddr = iph->daddr;
+	pudp_hdr.reserved = 0;
+	pudp_hdr.protocol = iph->protocol;
+	pudp_hdr.len = htons(len);
+
+	ptr = XMALLOC(MTYPE_BFDD_TMP, UDP_PSUEDO_HDR_LEN + len);
+	memcpy(ptr, &pudp_hdr, UDP_PSUEDO_HDR_LEN);
+	memcpy(ptr + UDP_PSUEDO_HDR_LEN, buf, len);
+
+	csum = checksum((uint16_t *)ptr, UDP_PSUEDO_HDR_LEN + len);
+	XFREE(MTYPE_BFDD_TMP, ptr);
+	return csum;
+}
+
+#endif /* BFD_LINUX */
diff -urpN frr-frr-5.0.1/bfdd/log.c frr-frr-6.0/bfdd/log.c
--- frr-frr-5.0.1/bfdd/log.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/log.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,125 @@
+/*********************************************************************
+ * Copyright 2017-2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * log.c: implements an abstraction between loggers interface. Implement all
+ * log backends in this file.
+ *
+ * Authors
+ * -------
+ * Rafael Zalamena <rzalamena@opensourcerouting.org>
+ */
+
+#include <zebra.h>
+
+#include "bfd.h"
+
+#include "lib/log_int.h"
+
+void log_msg(int level, const char *fmt, va_list vl);
+
+
+static int log_fg;
+static int log_level = BLOG_DEBUG;
+
+void log_init(int foreground, enum blog_level level,
+	      struct frr_daemon_info *fdi)
+{
+	log_fg = foreground;
+	log_level = level;
+
+	openzlog(fdi->progname, fdi->logname, 0,
+		 LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON);
+}
+
+void log_msg(int level, const char *fmt, va_list vl)
+{
+	if (level < log_level)
+		return;
+
+	switch (level) {
+	case BLOG_DEBUG:
+		vzlog(LOG_DEBUG, fmt, vl);
+		break;
+
+	case BLOG_INFO:
+		vzlog(LOG_INFO, fmt, vl);
+		break;
+
+	case BLOG_WARNING:
+		vzlog(LOG_WARNING, fmt, vl);
+		break;
+
+	case BLOG_ERROR:
+		vzlog(LOG_ERR, fmt, vl);
+		break;
+
+	case BLOG_FATAL:
+		vzlog(LOG_EMERG, fmt, vl);
+		break;
+
+	default:
+		vfprintf(stderr, fmt, vl);
+		break;
+	}
+}
+
+void log_info(const char *fmt, ...)
+{
+	va_list vl;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_INFO, fmt, vl);
+	va_end(vl);
+}
+
+void log_debug(const char *fmt, ...)
+{
+	va_list vl;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_DEBUG, fmt, vl);
+	va_end(vl);
+}
+
+void log_error(const char *fmt, ...)
+{
+	va_list vl;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_ERROR, fmt, vl);
+	va_end(vl);
+}
+
+void log_warning(const char *fmt, ...)
+{
+	va_list vl;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_WARNING, fmt, vl);
+	va_end(vl);
+}
+
+void log_fatal(const char *fmt, ...)
+{
+	va_list vl;
+
+	va_start(vl, fmt);
+	log_msg(BLOG_FATAL, fmt, vl);
+	va_end(vl);
+
+	exit(1);
+}
diff -urpN frr-frr-5.0.1/bfdd/ptm_adapter.c frr-frr-6.0/bfdd/ptm_adapter.c
--- frr-frr-5.0.1/bfdd/ptm_adapter.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/ptm_adapter.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,713 @@
+/*
+ * BFD PTM adapter code
+ * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")
+ *
+ * FRR is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FRR; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "lib/libfrr.h"
+#include "lib/queue.h"
+#include "lib/stream.h"
+#include "lib/zclient.h"
+
+#include "lib/bfd.h"
+
+#include "bfd.h"
+
+/*
+ * Data structures
+ */
+struct ptm_client_notification {
+	struct bfd_session *pcn_bs;
+	struct ptm_client *pcn_pc;
+
+	TAILQ_ENTRY(ptm_client_notification) pcn_entry;
+};
+TAILQ_HEAD(pcnqueue, ptm_client_notification);
+
+struct ptm_client {
+	uint32_t pc_pid;
+	struct pcnqueue pc_pcnqueue;
+
+	TAILQ_ENTRY(ptm_client) pc_entry;
+};
+TAILQ_HEAD(pcqueue, ptm_client);
+
+static struct pcqueue pcqueue;
+static struct zclient *zclient;
+
+
+/*
+ * Prototypes
+ */
+static int _ptm_msg_address(struct stream *msg, struct sockaddr_any *sa);
+
+static void _ptm_msg_read_address(struct stream *msg, struct sockaddr_any *sa);
+static int _ptm_msg_read(struct stream *msg, int command,
+			 struct bfd_peer_cfg *bpc, struct ptm_client **pc);
+
+static struct ptm_client *pc_lookup(uint32_t pid);
+static struct ptm_client *pc_new(uint32_t pid);
+static void pc_free(struct ptm_client *pc);
+static void pc_free_all(void);
+static struct ptm_client_notification *pcn_new(struct ptm_client *pc,
+					       struct bfd_session *bs);
+static struct ptm_client_notification *pcn_lookup(struct ptm_client *pc,
+						  struct bfd_session *bs);
+static void pcn_free(struct ptm_client_notification *pcn);
+
+
+static void bfdd_dest_register(struct stream *msg);
+static void bfdd_dest_deregister(struct stream *msg);
+static void bfdd_client_register(struct stream *msg);
+static void bfdd_client_deregister(struct stream *msg);
+
+/*
+ * Functions
+ */
+#ifdef BFD_DEBUG
+static void debug_printbpc(const char *func, unsigned int line,
+			   struct bfd_peer_cfg *bpc);
+
+static void debug_printbpc(const char *func, unsigned int line,
+			   struct bfd_peer_cfg *bpc)
+{
+	char addr[3][128];
+	char timers[3][128];
+
+	addr[0][0] = addr[1][0] = addr[2][0] = timers[0][0] = timers[1][0] =
+		timers[2][0] = 0;
+
+	snprintf(addr[0], sizeof(addr[0]), "peer:%s", satostr(&bpc->bpc_peer));
+	if (bpc->bpc_local.sa_sin.sin_family)
+		snprintf(addr[1], sizeof(addr[1]), " local:%s",
+			 satostr(&bpc->bpc_local));
+
+	if (bpc->bpc_has_localif)
+		snprintf(addr[2], sizeof(addr[2]), " ifname:%s",
+			 bpc->bpc_localif);
+
+	if (bpc->bpc_has_vrfname)
+		snprintf(addr[2], sizeof(addr[2]), " vrf:%s", bpc->bpc_vrfname);
+
+	if (bpc->bpc_has_recvinterval)
+		snprintf(timers[0], sizeof(timers[0]), " rx:%lu",
+			 bpc->bpc_recvinterval);
+
+	if (bpc->bpc_has_txinterval)
+		snprintf(timers[1], sizeof(timers[1]), " tx:%lu",
+			 bpc->bpc_recvinterval);
+
+	if (bpc->bpc_has_detectmultiplier)
+		snprintf(timers[2], sizeof(timers[2]), " detect-multiplier:%d",
+			 bpc->bpc_detectmultiplier);
+
+	log_debug("%s:%d: %s %s%s%s%s%s%s", func, line,
+		  bpc->bpc_mhop ? "multi-hop" : "single-hop", addr[0], addr[1],
+		  addr[2], timers[0], timers[1], timers[2]);
+}
+
+#define DEBUG_PRINTBPC(bpc) debug_printbpc(__FILE__, __LINE__, (bpc))
+#else
+#define DEBUG_PRINTBPC(bpc)
+#endif /* BFD_DEBUG */
+
+static int _ptm_msg_address(struct stream *msg, struct sockaddr_any *sa)
+{
+	switch (sa->sa_sin.sin_family) {
+	case AF_INET:
+		stream_putc(msg, sa->sa_sin.sin_family);
+		stream_put_in_addr(msg, &sa->sa_sin.sin_addr);
+		stream_putc(msg, 32);
+		break;
+
+	case AF_INET6:
+		stream_putc(msg, sa->sa_sin6.sin6_family);
+		stream_put(msg, &sa->sa_sin6.sin6_addr,
+			   sizeof(sa->sa_sin6.sin6_addr));
+		stream_putc(msg, 128);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+int ptm_bfd_notify(struct bfd_session *bs)
+{
+	struct stream *msg;
+	struct sockaddr_any sac;
+
+	bs->stats.znotification++;
+
+	/*
+	 * Message format:
+	 * - header: command, vrf
+	 * - l: interface index
+	 * - c: family
+	 *   - AF_INET:
+	 *     - 4 bytes: ipv4
+	 *   - AF_INET6:
+	 *     - 16 bytes: ipv6
+	 *   - c: prefix length
+	 * - l: bfd status
+	 * - c: family
+	 *   - AF_INET:
+	 *     - 4 bytes: ipv4
+	 *   - AF_INET6:
+	 *     - 16 bytes: ipv6
+	 *   - c: prefix length
+	 *
+	 * Commands: ZEBRA_BFD_DEST_REPLAY
+	 *
+	 * q(64), l(32), w(16), c(8)
+	 */
+	msg = zclient->obuf;
+	stream_reset(msg);
+
+	/* TODO: VRF handling */
+	zclient_create_header(msg, ZEBRA_BFD_DEST_REPLAY, VRF_DEFAULT);
+
+	/* This header will be handled by `zebra_ptm.c`. */
+	stream_putl(msg, ZEBRA_INTERFACE_BFD_DEST_UPDATE);
+
+	/* NOTE: Interface is a shortcut to avoid comparing source address. */
+	stream_putl(msg, bs->ifindex);
+
+	/* BFD destination prefix information. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))
+		_ptm_msg_address(msg, &bs->mhop.peer);
+	else
+		_ptm_msg_address(msg, &bs->shop.peer);
+
+	/* BFD status */
+	switch (bs->ses_state) {
+	case PTM_BFD_UP:
+		stream_putl(msg, BFD_STATUS_UP);
+		break;
+
+	case PTM_BFD_ADM_DOWN:
+	case PTM_BFD_DOWN:
+	case PTM_BFD_INIT:
+		stream_putl(msg, BFD_STATUS_DOWN);
+		break;
+
+	default:
+		stream_putl(msg, BFD_STATUS_UNKNOWN);
+		break;
+	}
+
+	/* BFD source prefix information. */
+	if (BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {
+		_ptm_msg_address(msg, &bs->mhop.local);
+	} else {
+		if (bs->local_address.sa_sin.sin_family)
+			_ptm_msg_address(msg, &bs->local_address);
+		else if (bs->local_address.sa_sin.sin_family)
+			_ptm_msg_address(msg, &bs->local_ip);
+		else {
+			sac = bs->shop.peer;
+			switch (sac.sa_sin.sin_family) {
+			case AF_INET:
+				memset(&sac.sa_sin.sin_addr, 0,
+				       sizeof(sac.sa_sin.sin_family));
+				break;
+			case AF_INET6:
+				memset(&sac.sa_sin6.sin6_addr, 0,
+				       sizeof(sac.sa_sin6.sin6_family));
+				break;
+
+			default:
+				assert(false);
+				break;
+			}
+
+			/* No local address found yet, so send zeroes. */
+			_ptm_msg_address(msg, &sac);
+		}
+	}
+
+	/* Write packet size. */
+	stream_putw_at(msg, 0, stream_get_endp(msg));
+
+	return zclient_send_message(zclient);
+}
+
+static void _ptm_msg_read_address(struct stream *msg, struct sockaddr_any *sa)
+{
+	uint16_t family;
+
+	STREAM_GETW(msg, family);
+
+	switch (family) {
+	case AF_INET:
+		sa->sa_sin.sin_family = family;
+		STREAM_GET(&sa->sa_sin.sin_addr, msg,
+			   sizeof(sa->sa_sin.sin_addr));
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+		sa->sa_sin.sin_len = sizeof(sa->sa_sin);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+		return;
+
+	case AF_INET6:
+		sa->sa_sin6.sin6_family = family;
+		STREAM_GET(&sa->sa_sin6.sin6_addr, msg,
+			   sizeof(sa->sa_sin6.sin6_addr));
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+		sa->sa_sin6.sin6_len = sizeof(sa->sa_sin6);
+#endif /* HAVE_STRUCT_SOCKADDR_SA_LEN */
+		return;
+
+	default:
+		log_warning("ptm-read-address: invalid family: %d", family);
+		break;
+	}
+
+stream_failure:
+	memset(sa, 0, sizeof(*sa));
+}
+
+static int _ptm_msg_read(struct stream *msg, int command,
+			 struct bfd_peer_cfg *bpc, struct ptm_client **pc)
+{
+	uint32_t pid;
+	uint8_t ttl __attribute__((unused));
+	uint8_t ifnamelen;
+
+	/*
+	 * Register/Deregister/Update Message format:
+	 * - header: Command, VRF
+	 * - l: pid
+	 * - w: family
+	 *   - AF_INET:
+	 *     - l: destination ipv4
+	 *   - AF_INET6:
+	 *     - 16 bytes: destination IPv6
+	 * - command != ZEBRA_BFD_DEST_DEREGISTER
+	 *   - l: min_rx
+	 *   - l: min_tx
+	 *   - c: detect multiplier
+	 * - c: is_multihop?
+	 *   - multihop:
+	 *     - w: family
+	 *       - AF_INET:
+	 *         - l: destination ipv4
+	 *       - AF_INET6:
+	 *         - 16 bytes: destination IPv6
+	 *     - c: ttl
+	 *   - no multihop
+	 *     - AF_INET6:
+	 *       - w: family
+	 *       - 16 bytes: ipv6 address
+	 *     - c: ifname length
+	 *     - X bytes: interface name
+	 *
+	 * q(64), l(32), w(16), c(8)
+	 */
+
+	/* Initialize parameters return values. */
+	memset(bpc, 0, sizeof(*bpc));
+	*pc = NULL;
+
+	/* Find or allocate process context data. */
+	STREAM_GETL(msg, pid);
+
+	*pc = pc_new(pid);
+	if (*pc == NULL) {
+		log_debug("ptm-read: failed to allocate memory");
+		return -1;
+	}
+
+	/* Register/update peer information. */
+	_ptm_msg_read_address(msg, &bpc->bpc_peer);
+
+	/* Determine IP type from peer destination. */
+	bpc->bpc_ipv4 = (bpc->bpc_peer.sa_sin.sin_family == AF_INET);
+
+	/* Get peer configuration. */
+	if (command != ZEBRA_BFD_DEST_DEREGISTER) {
+		STREAM_GETL(msg, bpc->bpc_recvinterval);
+		bpc->bpc_has_recvinterval =
+			(bpc->bpc_recvinterval != BPC_DEF_RECEIVEINTERVAL);
+
+		STREAM_GETL(msg, bpc->bpc_txinterval);
+		bpc->bpc_has_txinterval =
+			(bpc->bpc_txinterval != BPC_DEF_TRANSMITINTERVAL);
+
+		STREAM_GETC(msg, bpc->bpc_detectmultiplier);
+		bpc->bpc_has_detectmultiplier =
+			(bpc->bpc_detectmultiplier != BPC_DEF_DETECTMULTIPLIER);
+	}
+
+	/* Read (single|multi)hop and its options. */
+	STREAM_GETC(msg, bpc->bpc_mhop);
+	if (bpc->bpc_mhop) {
+		/* Read multihop source address and TTL. */
+		_ptm_msg_read_address(msg, &bpc->bpc_local);
+		STREAM_GETC(msg, ttl);
+	} else {
+		/* If target is IPv6, then we must obtain local address. */
+		if (bpc->bpc_ipv4 == false)
+			_ptm_msg_read_address(msg, &bpc->bpc_local);
+
+		/*
+		 * Read interface name and make sure it fits our data
+		 * structure, otherwise fail.
+		 */
+		STREAM_GETC(msg, ifnamelen);
+		if (ifnamelen >= sizeof(bpc->bpc_localif)) {
+			log_error("ptm-read: interface name is too big");
+			return -1;
+		}
+
+		bpc->bpc_has_localif = ifnamelen > 0;
+		if (bpc->bpc_has_localif) {
+			STREAM_GET(bpc->bpc_localif, msg, ifnamelen);
+			bpc->bpc_localif[ifnamelen] = 0;
+		}
+	}
+
+	/* Sanity check: peer and local address must match IP types. */
+	if (bpc->bpc_local.sa_sin.sin_family != 0
+	    && (bpc->bpc_local.sa_sin.sin_family
+		!= bpc->bpc_peer.sa_sin.sin_family)) {
+		log_warning("ptm-read: peer family doesn't match local type");
+		return -1;
+	}
+
+	return 0;
+
+stream_failure:
+	return -1;
+}
+
+static void bfdd_dest_register(struct stream *msg)
+{
+	struct ptm_client *pc;
+	struct ptm_client_notification *pcn;
+	struct bfd_session *bs;
+	struct bfd_peer_cfg bpc;
+
+	/* Read the client context and peer data. */
+	if (_ptm_msg_read(msg, ZEBRA_BFD_DEST_REGISTER, &bpc, &pc) == -1)
+		return;
+
+	DEBUG_PRINTBPC(&bpc);
+
+	/* Find or start new BFD session. */
+	bs = bs_peer_find(&bpc);
+	if (bs == NULL) {
+		bs = ptm_bfd_sess_new(&bpc);
+		if (bs == NULL) {
+			log_debug("ptm-add-dest: failed to create BFD session");
+			return;
+		}
+	} else {
+		/* Don't try to change echo/shutdown state. */
+		bpc.bpc_echo = BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO);
+		bpc.bpc_shutdown =
+			BFD_CHECK_FLAG(bs->flags, BFD_SESS_FLAG_SHUTDOWN);
+	}
+
+	/* Create client peer notification register. */
+	pcn = pcn_new(pc, bs);
+	if (pcn == NULL) {
+		log_error("ptm-add-dest: failed to registrate notifications");
+		return;
+	}
+
+	ptm_bfd_notify(bs);
+}
+
+static void bfdd_dest_deregister(struct stream *msg)
+{
+	struct ptm_client *pc;
+	struct ptm_client_notification *pcn;
+	struct bfd_session *bs;
+	struct bfd_peer_cfg bpc;
+
+	/* Read the client context and peer data. */
+	if (_ptm_msg_read(msg, ZEBRA_BFD_DEST_DEREGISTER, &bpc, &pc) == -1)
+		return;
+
+	DEBUG_PRINTBPC(&bpc);
+
+	/* Find or start new BFD session. */
+	bs = bs_peer_find(&bpc);
+	if (bs == NULL) {
+		log_debug("ptm-del-dest: failed to find BFD session");
+		return;
+	}
+
+	/* Unregister client peer notification. */
+	pcn = pcn_lookup(pc, bs);
+	pcn_free(pcn);
+}
+
+/*
+ * header: command, VRF
+ * l: pid
+ */
+static void bfdd_client_register(struct stream *msg)
+{
+	struct ptm_client *pc;
+	uint32_t pid;
+
+	/* Find or allocate process context data. */
+	STREAM_GETL(msg, pid);
+
+	pc = pc_new(pid);
+	if (pc == NULL) {
+		log_error("ptm-add-client: failed to register client: %u", pid);
+		return;
+	}
+
+	return;
+
+stream_failure:
+	log_error("ptm-add-client: failed to register client");
+}
+
+/*
+ * header: command, VRF
+ * l: pid
+ */
+static void bfdd_client_deregister(struct stream *msg)
+{
+	struct ptm_client *pc;
+	uint32_t pid;
+
+	/* Find or allocate process context data. */
+	STREAM_GETL(msg, pid);
+
+	pc = pc_lookup(pid);
+	if (pc == NULL) {
+		log_debug("ptm-del-client: failed to find client: %u", pid);
+		return;
+	}
+
+	pc_free(pc);
+
+	return;
+
+stream_failure:
+	log_error("ptm-del-client: failed to deregister client");
+}
+
+static int bfdd_replay(int cmd, struct zclient *zc, uint16_t len, vrf_id_t vid)
+{
+	struct stream *msg = zc->ibuf;
+	uint32_t rcmd;
+
+	STREAM_GETL(msg, rcmd);
+
+	switch (rcmd) {
+	case ZEBRA_BFD_DEST_REGISTER:
+	case ZEBRA_BFD_DEST_UPDATE:
+		bfdd_dest_register(msg);
+		break;
+	case ZEBRA_BFD_DEST_DEREGISTER:
+		bfdd_dest_deregister(msg);
+		break;
+	case ZEBRA_BFD_CLIENT_REGISTER:
+		bfdd_client_register(msg);
+		break;
+	case ZEBRA_BFD_CLIENT_DEREGISTER:
+		bfdd_client_deregister(msg);
+		break;
+
+	default:
+		log_debug("ptm-replay: invalid message type %u", rcmd);
+		return -1;
+	}
+
+	return 0;
+
+stream_failure:
+	log_error("ptm-replay: failed to find command");
+	return -1;
+}
+
+static void bfdd_zebra_connected(struct zclient *zc)
+{
+	struct stream *msg = zc->obuf;
+
+	/* Clean-up and free ptm clients data memory. */
+	pc_free_all();
+
+	/*
+	 * The replay is an empty message just to trigger client daemons
+	 * configuration replay.
+	 */
+	stream_reset(msg);
+	zclient_create_header(msg, ZEBRA_BFD_DEST_REPLAY, VRF_DEFAULT);
+	stream_putl(msg, ZEBRA_BFD_DEST_REPLAY);
+	stream_putw_at(msg, 0, stream_get_endp(msg));
+
+	zclient_send_message(zclient);
+}
+
+void bfdd_zclient_init(struct zebra_privs_t *bfdd_priv)
+{
+	zclient = zclient_new_notify(master, &zclient_options_default);
+	assert(zclient != NULL);
+	zclient_init(zclient, ZEBRA_ROUTE_BFD, 0, bfdd_priv);
+
+	/*
+	 * We'll receive all messages through replay, however it will
+	 * contain a special field with the real command inside so we
+	 * avoid having to create too many handlers.
+	 */
+	zclient->bfd_dest_replay = bfdd_replay;
+
+	/* Send replay request on zebra connect. */
+	zclient->zebra_connected = bfdd_zebra_connected;
+}
+
+void bfdd_zclient_stop(void)
+{
+	zclient_stop(zclient);
+
+	/* Clean-up and free ptm clients data memory. */
+	pc_free_all();
+}
+
+
+/*
+ * Client handling.
+ */
+static struct ptm_client *pc_lookup(uint32_t pid)
+{
+	struct ptm_client *pc;
+
+	TAILQ_FOREACH (pc, &pcqueue, pc_entry) {
+		if (pc->pc_pid != pid)
+			continue;
+
+		break;
+	}
+
+	return pc;
+}
+
+static struct ptm_client *pc_new(uint32_t pid)
+{
+	struct ptm_client *pc;
+
+	/* Look up first, if not found create the client. */
+	pc = pc_lookup(pid);
+	if (pc != NULL)
+		return pc;
+
+	/* Allocate the client data and save it. */
+	pc = XCALLOC(MTYPE_BFDD_CONTROL, sizeof(*pc));
+	if (pc == NULL)
+		return NULL;
+
+	pc->pc_pid = pid;
+	TAILQ_INSERT_HEAD(&pcqueue, pc, pc_entry);
+	return pc;
+}
+
+static void pc_free(struct ptm_client *pc)
+{
+	struct ptm_client_notification *pcn;
+
+	if (pc == NULL)
+		return;
+
+	TAILQ_REMOVE(&pcqueue, pc, pc_entry);
+
+	while (!TAILQ_EMPTY(&pc->pc_pcnqueue)) {
+		pcn = TAILQ_FIRST(&pc->pc_pcnqueue);
+		pcn_free(pcn);
+	}
+
+	XFREE(MTYPE_BFDD_CONTROL, pc);
+}
+
+static void pc_free_all(void)
+{
+	struct ptm_client *pc;
+
+	while (!TAILQ_EMPTY(&pcqueue)) {
+		pc = TAILQ_FIRST(&pcqueue);
+		pc_free(pc);
+	}
+}
+
+static struct ptm_client_notification *pcn_new(struct ptm_client *pc,
+					       struct bfd_session *bs)
+{
+	struct ptm_client_notification *pcn;
+
+	/* Try to find an existing pcn fist. */
+	pcn = pcn_lookup(pc, bs);
+	if (pcn != NULL)
+		return pcn;
+
+	/* Save the client notification data. */
+	pcn = XCALLOC(MTYPE_BFDD_NOTIFICATION, sizeof(*pcn));
+	if (pcn == NULL)
+		return NULL;
+
+	TAILQ_INSERT_HEAD(&pc->pc_pcnqueue, pcn, pcn_entry);
+	pcn->pcn_pc = pc;
+	pcn->pcn_bs = bs;
+	bs->refcount++;
+
+	return pcn;
+}
+
+static struct ptm_client_notification *pcn_lookup(struct ptm_client *pc,
+						  struct bfd_session *bs)
+{
+	struct ptm_client_notification *pcn;
+
+	TAILQ_FOREACH (pcn, &pc->pc_pcnqueue, pcn_entry) {
+		if (pcn->pcn_bs != bs)
+			continue;
+
+		break;
+	}
+
+	return pcn;
+}
+
+static void pcn_free(struct ptm_client_notification *pcn)
+{
+	struct ptm_client *pc;
+	struct bfd_session *bs;
+
+	if (pcn == NULL)
+		return;
+
+	/* Handle session de-registration. */
+	bs = pcn->pcn_bs;
+	pcn->pcn_bs = NULL;
+	bs->refcount--;
+
+	/* Handle ptm_client deregistration. */
+	pc = pcn->pcn_pc;
+	pcn->pcn_pc = NULL;
+	TAILQ_REMOVE(&pc->pc_pcnqueue, pcn, pcn_entry);
+
+	XFREE(MTYPE_BFDD_NOTIFICATION, pcn);
+}
diff -urpN frr-frr-5.0.1/bfdd/subdir.am frr-frr-6.0/bfdd/subdir.am
--- frr-frr-5.0.1/bfdd/subdir.am	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bfdd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+#
+# bfdd
+#
+
+if BFDD
+noinst_LIBRARIES += bfdd/libbfd.a
+sbin_PROGRAMS += bfdd/bfdd
+dist_examples_DATA += bfdd/bfdd.conf.sample
+endif
+
+bfdd_libbfd_a_SOURCES = \
+	bfdd/bfd.c \
+	bfdd/bfdd_vty.c \
+	bfdd/bfd_packet.c \
+	bfdd/bsd.c \
+	bfdd/config.c \
+	bfdd/control.c \
+	bfdd/event.c \
+	bfdd/linux.c \
+	bfdd/log.c \
+	bfdd/ptm_adapter.c \
+	# end
+
+bfdd/bfdd_vty_clippy.c: $(CLIPPY_DEPS)
+bfdd/bfdd_vty.$(OBJEXT): bfdd/bfdd_vty_clippy.c
+
+noinst_HEADERS += \
+	bfdd/bfdctl.h \
+	bfdd/bfd.h \
+	# end
+
+bfdd_bfdd_SOURCES = bfdd/bfdd.c
+bfdd_bfdd_LDADD = bfdd/libbfd.a lib/libfrr.la
diff -urpN frr-frr-5.0.1/bgpd/IMPLEMENTATION.txt frr-frr-6.0/bgpd/IMPLEMENTATION.txt
--- frr-frr-5.0.1/bgpd/IMPLEMENTATION.txt	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/IMPLEMENTATION.txt	2018-10-08 14:32:57.000000000 +0200
@@ -131,7 +131,6 @@ bgpd.h
   struct peer_group
   struct bgp_notify: (in-core representation of wire format?)
   struct bgp_nexthop: (v4 and v6 addresses, *ifp)
-  struct bgp_rd: router distinguisher: 8 octects
   struct bgp_filter: distribute, prefix, aslist, route_maps
   struct peer: neighbor structure (very rich/complex)
   struct bgp_nlri: reference to wire format
diff -urpN frr-frr-5.0.1/bgpd/Makefile.am frr-frr-6.0/bgpd/Makefile.am
--- frr-frr-5.0.1/bgpd/Makefile.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -61,13 +61,11 @@ BGP_VNC_RFP_HD=
 BGP_VNC_RFP_LD_FLAGS=
 endif
 
-AM_CPPFLAGS = -I.. -I$(top_srcdir) -I$(top_srcdir)/lib -I$(top_builddir)/lib \
+AM_CPPFLAGS += -I.. -I$(top_srcdir) -I$(top_srcdir)/lib -I$(top_builddir)/lib \
 	$(BGP_VNC_RFAPI_INC) $(BGP_VNC_RFP_INC)
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
-AM_CFLAGS = $(WERROR)
-
 noinst_LIBRARIES = libbgp.a
 module_LTLIBRARIES =
 sbin_PROGRAMS = bgpd
@@ -87,7 +85,7 @@ libbgp_a_SOURCES = \
 	bgp_encap_tlv.c $(BGP_VNC_RFAPI_SRC) bgp_attr_evpn.c \
 	bgp_evpn.c bgp_evpn_vty.c bgp_vpn.c bgp_label.c bgp_rd.c \
 	bgp_keepalives.c bgp_io.c bgp_flowspec.c bgp_flowspec_util.c \
-	bgp_flowspec_vty.c bgp_labelpool.c bgp_pbr.c
+	bgp_flowspec_vty.c bgp_labelpool.c bgp_pbr.c bgp_errors.c
 
 noinst_HEADERS = \
 	bgp_memory.h \
@@ -101,7 +99,7 @@ noinst_HEADERS = \
 	$(BGP_VNC_RFAPI_HD) bgp_attr_evpn.h bgp_evpn.h bgp_evpn_vty.h \
         bgp_vpn.h bgp_label.h bgp_rd.h bgp_evpn_private.h bgp_keepalives.h \
 	bgp_io.h bgp_flowspec.h bgp_flowspec_private.h bgp_flowspec_util.h \
-	bgp_labelpool.h bgp_pbr.h
+	bgp_labelpool.h bgp_pbr.h bgp_errors.h
 
 bgpd_SOURCES = bgp_main.c
 bgpd_LDADD = libbgp.a  $(BGP_VNC_RFP_LIB) ../lib/libfrr.la @LIBCAP@ @LIBM@
@@ -116,7 +114,7 @@ module_LTLIBRARIES += bgpd_snmp.la
 endif
 
 bgpd_snmp_la_SOURCES = bgp_snmp.c
-bgpd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+bgpd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 bgpd_snmp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 bgpd_snmp_la_LIBADD = ../lib/libfrrsnmp.la
 
@@ -136,6 +134,7 @@ dist_examples_DATA = bgpd.conf.sample bg
 
 bgp_vty.o: bgp_vty_clippy.c
 bgp_route.o: bgp_route_clippy.c
+bgp_debug.o: bgp_debug_clippy.c
 
 EXTRA_DIST = BGP4-MIB.txt
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_aspath.c frr-frr-6.0/bgpd/bgp_aspath.c
--- frr-frr-5.0.1/bgpd/bgp_aspath.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_aspath.c	2018-10-08 14:32:57.000000000 +0200
@@ -214,16 +214,11 @@ static struct assegment *assegment_appen
 	newas = XREALLOC(MTYPE_AS_SEG_DATA, seg->as,
 			 ASSEGMENT_DATA_SIZE(seg->length + num, 1));
 
-	if (newas) {
-		seg->as = newas;
-		memcpy(seg->as + seg->length, asnos,
-		       ASSEGMENT_DATA_SIZE(num, 1));
-		seg->length += num;
-		return seg;
-	}
-
-	assegment_free_all(seg);
-	return NULL;
+	seg->as = newas;
+	memcpy(seg->as + seg->length, asnos,
+	       ASSEGMENT_DATA_SIZE(num, 1));
+	seg->length += num;
+	return seg;
 }
 
 static int int_cmp(const void *p1, const void *p2)
@@ -904,7 +899,7 @@ size_t aspath_put(struct stream *s, stru
 			while ((seg->length - written) > AS_SEGMENT_MAX) {
 				assegment_header_put(s, seg->type,
 						     AS_SEGMENT_MAX);
-				assegment_data_put(s, seg->as, AS_SEGMENT_MAX,
+				assegment_data_put(s, (seg->as + written), AS_SEGMENT_MAX,
 						   use32bit);
 				written += AS_SEGMENT_MAX;
 				bytes += ASSEGMENT_SIZE(AS_SEGMENT_MAX,
@@ -1632,7 +1627,7 @@ struct aspath *aspath_reconcile_as4(stru
 	struct aspath *newpath = NULL, *mergedpath;
 	int hops, cpasns = 0;
 
-	if (!aspath)
+	if (!aspath || !as4path)
 		return NULL;
 
 	seg = aspath->segments;
diff -urpN frr-frr-5.0.1/bgpd/bgp_attr.c frr-frr-6.0/bgpd/bgp_attr.c
--- frr-frr-5.0.1/bgpd/bgp_attr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_attr.c	2018-10-08 14:32:57.000000000 +0200
@@ -39,6 +39,7 @@
 #include "bgpd/bgp_aspath.h"
 #include "bgpd/bgp_community.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_label.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -996,12 +997,14 @@ bgp_attr_flags_diagnose(struct bgp_attr_
 	for (i = 0; i <= 2; i++) /* O,T,P, but not E */
 		if (CHECK_FLAG(desired_flags, attr_flag_str[i].key)
 		    != CHECK_FLAG(real_flags, attr_flag_str[i].key)) {
-			zlog_err("%s attribute must%s be flagged as \"%s\"",
-				 lookup_msg(attr_str, attr_code, NULL),
-				 CHECK_FLAG(desired_flags, attr_flag_str[i].key)
-					 ? ""
-					 : " not",
-				 attr_flag_str[i].str);
+			flog_err(
+				BGP_ERR_ATTR_FLAG,
+				"%s attribute must%s be flagged as \"%s\"",
+				lookup_msg(attr_str, attr_code, NULL),
+				CHECK_FLAG(desired_flags, attr_flag_str[i].key)
+					? ""
+					: " not",
+				attr_flag_str[i].str);
 			seen = 1;
 		}
 	if (!seen) {
@@ -1059,7 +1062,8 @@ static int bgp_attr_flag_invalid(struct
 	 */
 	if (!CHECK_FLAG(BGP_ATTR_FLAG_OPTIONAL, flags)
 	    && !CHECK_FLAG(BGP_ATTR_FLAG_TRANS, flags)) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_ATTR_FLAG,
 			"%s well-known attributes must have transitive flag set (%x)",
 			lookup_msg(attr_str, attr_code, NULL), flags);
 		return 1;
@@ -1071,18 +1075,18 @@ static int bgp_attr_flag_invalid(struct
 	 */
 	if (CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL)) {
 		if (!CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)) {
-			zlog_err(
-				"%s well-known attribute "
-				"must NOT have the partial flag set (%x)",
-				lookup_msg(attr_str, attr_code, NULL), flags);
+			flog_err(BGP_ERR_ATTR_FLAG,
+				  "%s well-known attribute "
+				  "must NOT have the partial flag set (%x)",
+				  lookup_msg(attr_str, attr_code, NULL), flags);
 			return 1;
 		}
 		if (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)
 		    && !CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)) {
-			zlog_err(
-				"%s optional + transitive attribute "
-				"must NOT have the partial flag set (%x)",
-				lookup_msg(attr_str, attr_code, NULL), flags);
+			flog_err(BGP_ERR_ATTR_FLAG,
+				  "%s optional + transitive attribute "
+				  "must NOT have the partial flag set (%x)",
+				  lookup_msg(attr_str, attr_code, NULL), flags);
 			return 1;
 		}
 	}
@@ -1114,7 +1118,8 @@ static bgp_attr_parse_ret_t bgp_attr_ori
 	   field contains the erroneous attribute (type, length and
 	   value). */
 	if (length != 1) {
-		zlog_err("Origin attribute length is not one %d", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "Origin attribute length is not one %d", length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
 	}
@@ -1127,7 +1132,8 @@ static bgp_attr_parse_ret_t bgp_attr_ori
 	   contains the unrecognized attribute (type, length and value). */
 	if ((attr->origin != BGP_ORIGIN_IGP) && (attr->origin != BGP_ORIGIN_EGP)
 	    && (attr->origin != BGP_ORIGIN_INCOMPLETE)) {
-		zlog_err("Origin attribute value is invalid %d", attr->origin);
+		flog_err(BGP_ERR_ATTR_ORIGIN,
+			  "Origin attribute value is invalid %d", attr->origin);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_INVAL_ORIGIN,
 					  args->total);
 	}
@@ -1155,8 +1161,9 @@ static int bgp_attr_aspath(struct bgp_at
 
 	/* In case of IBGP, length will be zero. */
 	if (!attr->aspath) {
-		zlog_err("Malformed AS path from %s, length is %d", peer->host,
-			 length);
+		flog_err(BGP_ERR_ATTR_MAL_AS_PATH,
+			  "Malformed AS path from %s, length is %d", peer->host,
+			  length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,
 					  0);
 	}
@@ -1184,7 +1191,8 @@ static bgp_attr_parse_ret_t bgp_attr_asp
 	     && !aspath_left_confed_check(attr->aspath))
 	    || (peer->sort == BGP_PEER_EBGP
 		&& aspath_confed_check(attr->aspath))) {
-		zlog_err("Malformed AS path from %s", peer->host);
+		flog_err(BGP_ERR_ATTR_MAL_AS_PATH, "Malformed AS path from %s",
+			  peer->host);
 		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
 				BGP_NOTIFY_UPDATE_MAL_AS_PATH);
 		return BGP_ATTR_PARSE_ERROR;
@@ -1194,8 +1202,9 @@ static bgp_attr_parse_ret_t bgp_attr_asp
 	if (CHECK_FLAG(peer->flags, PEER_FLAG_ENFORCE_FIRST_AS)) {
 		if (peer->sort == BGP_PEER_EBGP
 		    && !aspath_firstas_check(attr->aspath, peer->as)) {
-			zlog_err("%s incorrect first AS (must be %u)",
-				 peer->host, peer->as);
+			flog_err(BGP_ERR_ATTR_FIRST_AS,
+				  "%s incorrect first AS (must be %u)",
+				  peer->host, peer->as);
 			bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
 					BGP_NOTIFY_UPDATE_MAL_AS_PATH);
 			return BGP_ATTR_PARSE_ERROR;
@@ -1227,8 +1236,9 @@ static int bgp_attr_as4_path(struct bgp_
 
 	/* In case of IBGP, length will be zero. */
 	if (!*as4_path) {
-		zlog_err("Malformed AS4 path from %s, length is %d", peer->host,
-			 length);
+		flog_err(BGP_ERR_ATTR_MAL_AS_PATH,
+			  "Malformed AS4 path from %s, length is %d",
+			  peer->host, length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH,
 					  0);
 	}
@@ -1250,7 +1260,8 @@ static bgp_attr_parse_ret_t bgp_attr_nex
 
 	/* Check nexthop attribute length. */
 	if (length != 4) {
-		zlog_err("Nexthop attribute length isn't four [%d]", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "Nexthop attribute length isn't four [%d]", length);
 
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
@@ -1274,7 +1285,7 @@ static bgp_attr_parse_ret_t bgp_attr_nex
 	{
 		char buf[INET_ADDRSTRLEN];
 		inet_ntop(AF_INET, &nexthop_n, buf, INET_ADDRSTRLEN);
-		zlog_err("Martian nexthop %s", buf);
+		flog_err(BGP_ERR_ATTR_MARTIAN_NH, "Martian nexthop %s", buf);
 		return bgp_attr_malformed(
 			args, BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, args->total);
 	}
@@ -1294,7 +1305,8 @@ static bgp_attr_parse_ret_t bgp_attr_med
 
 	/* Length check. */
 	if (length != 4) {
-		zlog_err("MED attribute length isn't four [%d]", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "MED attribute length isn't four [%d]", length);
 
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
@@ -1317,7 +1329,8 @@ bgp_attr_local_pref(struct bgp_attr_pars
 
 	/* Length check. */
 	if (length != 4) {
-		zlog_err("LOCAL_PREF attribute length isn't 4 [%u]", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "LOCAL_PREF attribute length isn't 4 [%u]", length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
 	}
@@ -1346,8 +1359,9 @@ static int bgp_attr_atomic(struct bgp_at
 
 	/* Length check. */
 	if (length != 0) {
-		zlog_err("ATOMIC_AGGREGATE attribute length isn't 0 [%u]",
-			 length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "ATOMIC_AGGREGATE attribute length isn't 0 [%u]",
+			  length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
 	}
@@ -1372,8 +1386,9 @@ static int bgp_attr_aggregator(struct bg
 		wantedlen = 8;
 
 	if (length != wantedlen) {
-		zlog_err("AGGREGATOR attribute length isn't %u [%u]", wantedlen,
-			 length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "AGGREGATOR attribute length isn't %u [%u]",
+			  wantedlen, length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
 	}
@@ -1401,7 +1416,8 @@ bgp_attr_as4_aggregator(struct bgp_attr_
 	const bgp_size_t length = args->length;
 
 	if (length != 8) {
-		zlog_err("New Aggregator length is not 8 [%d]", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "New Aggregator length is not 8 [%d]", length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  0);
 	}
@@ -1513,6 +1529,9 @@ bgp_attr_munge_as4_attrs(struct peer *co
 	if (!ignore_as4_path
 	    && (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))) {
 		newpath = aspath_reconcile_as4(attr->aspath, as4_path);
+		if (!newpath)
+			return BGP_ATTR_PARSE_ERROR;
+
 		aspath_unintern(&attr->aspath);
 		attr->aspath = aspath_intern(newpath);
 	}
@@ -1557,7 +1576,8 @@ bgp_attr_originator_id(struct bgp_attr_p
 
 	/* Length check. */
 	if (length != 4) {
-		zlog_err("Bad originator ID length %d", length);
+		flog_err(BGP_ERR_ATTR_LEN, "Bad originator ID length %d",
+			  length);
 
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
@@ -1580,7 +1600,8 @@ bgp_attr_cluster_list(struct bgp_attr_pa
 
 	/* Check length. */
 	if (length % 4) {
-		zlog_err("Bad cluster list length %d", length);
+		flog_err(BGP_ERR_ATTR_LEN, "Bad cluster list length %d",
+			  length);
 
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
@@ -1887,6 +1908,16 @@ bgp_attr_ext_communities(struct bgp_attr
 	/* Check if this is a Gateway MAC-IP advertisement */
 	attr->default_gw = bgp_attr_default_gw(attr);
 
+	/* Handle scenario where router flag ecommunity is not
+	 * set but default gw ext community is present.
+	 * Use default gateway, set and propogate R-bit.
+	 */
+	if (attr->default_gw)
+		attr->router_flag = 1;
+
+	/* Check EVPN Neighbor advertisement flags, R-bit */
+	bgp_attr_evpn_na_flag(attr, &attr->router_flag);
+
 	/* Extract the Rmac, if any */
 	bgp_attr_rmac(attr, &attr->rmac);
 
@@ -2020,36 +2051,32 @@ static int bgp_attr_encap(uint8_t type,
 	return 0;
 }
 
-/* Prefix SID attribute
- * draft-ietf-idr-bgp-prefix-sid-05
+/*
+ * Read an individual SID value returning how much data we have read
+ * Returns 0 if there was an error that needs to be passed up the stack
  */
-static bgp_attr_parse_ret_t
-bgp_attr_prefix_sid(struct bgp_attr_parser_args *args,
-		    struct bgp_nlri *mp_update)
+static bgp_attr_parse_ret_t bgp_attr_psid_sub(int32_t type,
+					      int32_t length,
+					      struct bgp_attr_parser_args *args,
+					      struct bgp_nlri *mp_update)
 {
 	struct peer *const peer = args->peer;
 	struct attr *const attr = args->attr;
-	int type;
-	int length;
 	uint32_t label_index;
 	struct in6_addr ipv6_sid;
 	uint32_t srgb_base;
 	uint32_t srgb_range;
 	int srgb_count;
 
-	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);
-
-	type = stream_getc(peer->curr);
-	length = stream_getw(peer->curr);
-
 	if (type == BGP_PREFIX_SID_LABEL_INDEX) {
 		if (length != BGP_PREFIX_SID_LABEL_INDEX_LENGTH) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_ATTR_LEN,
 				"Prefix SID label index length is %d instead of %d",
 				length, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);
-			return bgp_attr_malformed(
-				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
-				args->total);
+			return bgp_attr_malformed(args,
+						  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
+						  args->total);
 		}
 
 		/* Ignore flags and reserved */
@@ -2059,9 +2086,8 @@ bgp_attr_prefix_sid(struct bgp_attr_pars
 		/* Fetch the label index and see if it is valid. */
 		label_index = stream_getl(peer->curr);
 		if (label_index == BGP_INVALID_LABEL_INDEX)
-			return bgp_attr_malformed(
-				args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
-				args->total);
+			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
+						  args->total);
 
 		/* Store label index; subsequently, we'll check on
 		 * address-family */
@@ -2080,11 +2106,12 @@ bgp_attr_prefix_sid(struct bgp_attr_pars
 	/* Placeholder code for the IPv6 SID type */
 	else if (type == BGP_PREFIX_SID_IPV6) {
 		if (length != BGP_PREFIX_SID_IPV6_LENGTH) {
-			zlog_err("Prefix SID IPv6 length is %d instead of %d",
-				 length, BGP_PREFIX_SID_IPV6_LENGTH);
-			return bgp_attr_malformed(
-				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
-				args->total);
+			flog_err(BGP_ERR_ATTR_LEN,
+				  "Prefix SID IPv6 length is %d instead of %d",
+				  length, BGP_PREFIX_SID_IPV6_LENGTH);
+			return bgp_attr_malformed(args,
+						  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
+						  args->total);
 		}
 
 		/* Ignore reserved */
@@ -2102,7 +2129,8 @@ bgp_attr_prefix_sid(struct bgp_attr_pars
 		length -= 2;
 
 		if (length % BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_ATTR_LEN,
 				"Prefix SID Originator SRGB length is %d, it must be a multiple of %d ",
 				length, BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH);
 			return bgp_attr_malformed(
@@ -2121,6 +2149,49 @@ bgp_attr_prefix_sid(struct bgp_attr_pars
 	return BGP_ATTR_PARSE_PROCEED;
 }
 
+/* Prefix SID attribute
+ * draft-ietf-idr-bgp-prefix-sid-05
+ */
+bgp_attr_parse_ret_t
+bgp_attr_prefix_sid(int32_t tlength, struct bgp_attr_parser_args *args,
+		    struct bgp_nlri *mp_update)
+{
+	struct peer *const peer = args->peer;
+	struct attr *const attr = args->attr;
+	bgp_attr_parse_ret_t ret;
+
+	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);
+
+	while (tlength) {
+		int32_t type, length;
+
+		type = stream_getc(peer->curr);
+		length = stream_getw(peer->curr);
+
+		ret = bgp_attr_psid_sub(type, length, args, mp_update);
+
+		if (ret != BGP_ATTR_PARSE_PROCEED)
+			return ret;
+		/*
+		 * Subtract length + the T and the L
+		 * since length is the Vector portion
+		 */
+		tlength -= length + 3;
+
+		if (tlength < 0) {
+			flog_err(
+				BGP_ERR_ATTR_LEN,
+				"Prefix SID internal length %d causes us to read beyond the total Prefix SID length",
+				length);
+			return bgp_attr_malformed(args,
+						  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
+						  args->total);
+		}
+	}
+
+	return BGP_ATTR_PARSE_PROCEED;
+}
+
 /* PMSI tunnel attribute (RFC 6514)
  * Basic validation checks done here.
  */
@@ -2136,21 +2207,24 @@ bgp_attr_pmsi_tunnel(struct bgp_attr_par
 	 * can only support that.
 	 */
 	if (length < 2) {
-		zlog_err("Bad PMSI tunnel attribute length %d", length);
+		flog_err(BGP_ERR_ATTR_LEN,
+			  "Bad PMSI tunnel attribute length %d", length);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 					  args->total);
 	}
 	stream_getc(peer->curr); /* Flags */
 	tnl_type = stream_getc(peer->curr);
 	if (tnl_type > PMSI_TNLTYPE_MAX) {
-		zlog_err("Invalid PMSI tunnel attribute type %d", tnl_type);
+		flog_err(BGP_ERR_ATTR_PMSI_TYPE,
+			  "Invalid PMSI tunnel attribute type %d", tnl_type);
 		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
 					  args->total);
 	}
 	if (tnl_type == PMSI_TNLTYPE_INGR_REPL) {
 		if (length != 9) {
-			zlog_err("Bad PMSI tunnel attribute length %d for IR",
-				 length);
+			flog_err(BGP_ERR_ATTR_PMSI_LEN,
+				  "Bad PMSI tunnel attribute length %d for IR",
+				  length);
 			return bgp_attr_malformed(
 				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
 				args->total);
@@ -2498,7 +2572,8 @@ bgp_attr_parse_ret_t bgp_attr_parse(stru
 					     startp);
 			break;
 		case BGP_ATTR_PREFIX_SID:
-			ret = bgp_attr_prefix_sid(&attr_args, mp_update);
+			ret = bgp_attr_prefix_sid(length,
+						  &attr_args, mp_update);
 			break;
 		case BGP_ATTR_PMSI_TUNNEL:
 			ret = bgp_attr_pmsi_tunnel(&attr_args);
@@ -2749,9 +2824,10 @@ size_t bgp_packet_mpattr_start(struct st
 		break;
 	default:
 		if (safi != SAFI_FLOWSPEC)
-			zlog_err(
-				 "Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d",
-				 peer->host, afi, safi, attr->mp_nexthop_len);
+			flog_err(
+				BGP_ERR_ATTR_NH_SEND_LEN,
+				"Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d",
+				peer->host, afi, safi, attr->mp_nexthop_len);
 		break;
 	}
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_attr.h frr-frr-6.0/bgpd/bgp_attr.h
--- frr-frr-5.0.1/bgpd/bgp_attr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_attr.h	2018-10-08 14:32:57.000000000 +0200
@@ -185,6 +185,9 @@ struct attr {
 	/* Flag for default gateway extended community in EVPN */
 	uint8_t default_gw;
 
+	/* NA router flag (R-bit) support in EVPN */
+	uint8_t router_flag;
+
 	/* route tag */
 	route_tag_t tag;
 
@@ -308,6 +311,9 @@ extern int bgp_mp_reach_parse(struct bgp
 			      struct bgp_nlri *);
 extern int bgp_mp_unreach_parse(struct bgp_attr_parser_args *args,
 				struct bgp_nlri *);
+extern bgp_attr_parse_ret_t
+bgp_attr_prefix_sid(int32_t tlength, struct bgp_attr_parser_args *args,
+		    struct bgp_nlri *mp_update);
 
 extern struct bgp_attr_encap_subtlv *
 encap_tlv_dup(struct bgp_attr_encap_subtlv *orig);
diff -urpN frr-frr-5.0.1/bgpd/bgp_attr_evpn.c frr-frr-6.0/bgpd/bgp_attr_evpn.c
--- frr-frr-5.0.1/bgpd/bgp_attr_evpn.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_attr_evpn.c	2018-10-08 14:32:57.000000000 +0200
@@ -210,6 +210,39 @@ uint32_t bgp_attr_mac_mobility_seqnum(st
 	return 0;
 }
 
+/*
+ * return true if attr contains router flag extended community
+ */
+void bgp_attr_evpn_na_flag(struct attr *attr, uint8_t *router_flag)
+{
+	struct ecommunity *ecom;
+	int i;
+	uint8_t val;
+
+	ecom = attr->ecommunity;
+	if (!ecom || !ecom->size)
+		return;
+
+	/* If there is a evpn na extendd community set router_flag */
+	for (i = 0; i < ecom->size; i++) {
+		uint8_t *pnt;
+		uint8_t type, sub_type;
+
+		pnt = (ecom->val + (i * ECOMMUNITY_SIZE));
+		type = *pnt++;
+		sub_type = *pnt++;
+
+		if (type == ECOMMUNITY_ENCODE_EVPN &&
+		    sub_type == ECOMMUNITY_EVPN_SUBTYPE_ND) {
+			val = *pnt++;
+			if (val & ECOMMUNITY_EVPN_SUBTYPE_ND_ROUTER_FLAG) {
+				*router_flag = 1;
+				break;
+			}
+		}
+	}
+}
+
 /* dst prefix must be AF_INET or AF_INET6 prefix, to forge EVPN prefix */
 extern int bgp_build_evpn_prefix(int evpn_type, uint32_t eth_tag,
 				 struct prefix *dst)
@@ -227,16 +260,18 @@ extern int bgp_build_evpn_prefix(int evp
 	dst->family = AF_EVPN;
 	p_evpn_p->route_type = evpn_type;
 	if (evpn_type == BGP_EVPN_IP_PREFIX_ROUTE) {
-		p_evpn_p->eth_tag = eth_tag;
-		p_evpn_p->ip_prefix_length = p2.prefixlen;
+		p_evpn_p->prefix_addr.eth_tag = eth_tag;
+		p_evpn_p->prefix_addr.ip_prefix_length = p2.prefixlen;
 		if (src->family == AF_INET) {
-			SET_IPADDR_V4(&p_evpn_p->ip);
-			memcpy(&p_evpn_p->ip.ipaddr_v4, &src->u.prefix4,
+			SET_IPADDR_V4(&p_evpn_p->prefix_addr.ip);
+			memcpy(&p_evpn_p->prefix_addr.ip.ipaddr_v4,
+			       &src->u.prefix4,
 			       sizeof(struct in_addr));
 			dst->prefixlen = (uint8_t)PREFIX_LEN_ROUTE_TYPE_5_IPV4;
 		} else {
-			SET_IPADDR_V6(&p_evpn_p->ip);
-			memcpy(&p_evpn_p->ip.ipaddr_v6, &src->u.prefix6,
+			SET_IPADDR_V6(&p_evpn_p->prefix_addr.ip);
+			memcpy(&p_evpn_p->prefix_addr.ip.ipaddr_v6,
+			       &src->u.prefix6,
 			       sizeof(struct in6_addr));
 			dst->prefixlen = (uint8_t)PREFIX_LEN_ROUTE_TYPE_5_IPV6;
 		}
diff -urpN frr-frr-5.0.1/bgpd/bgp_attr_evpn.h frr-frr-6.0/bgpd/bgp_attr_evpn.h
--- frr-frr-5.0.1/bgpd/bgp_attr_evpn.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_attr_evpn.h	2018-10-08 14:32:57.000000000 +0200
@@ -65,4 +65,6 @@ extern uint32_t bgp_attr_mac_mobility_se
 					     uint8_t *sticky);
 extern uint8_t bgp_attr_default_gw(struct attr *attr);
 
+extern void bgp_attr_evpn_na_flag(struct attr *attr, uint8_t *router_flag);
+
 #endif /* _QUAGGA_BGP_ATTR_EVPN_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_bfd.c frr-frr-6.0/bgpd/bgp_bfd.c
--- frr-frr-5.0.1/bgpd/bgp_bfd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_bfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -509,9 +509,13 @@ void bgp_bfd_peer_config_write(struct vt
 	bfd_info = (struct bfd_info *)peer->bfd_info;
 
 	if (CHECK_FLAG(bfd_info->flags, BFD_FLAG_PARAM_CFG))
+#if HAVE_BFDD > 0
+		vty_out(vty, " neighbor %s bfd\n", addr);
+#else
 		vty_out(vty, " neighbor %s bfd %d %d %d\n", addr,
 			bfd_info->detect_mult, bfd_info->required_min_rx,
 			bfd_info->desired_min_tx);
+#endif /* HAVE_BFDD */
 
 	if (bfd_info->type != BFD_TYPE_NOT_CONFIGURED)
 		vty_out(vty, " neighbor %s bfd %s\n", addr,
@@ -556,7 +560,12 @@ DEFUN (neighbor_bfd,
 	return CMD_SUCCESS;
 }
 
-DEFUN (neighbor_bfd_param,
+#if HAVE_BFDD > 0
+DEFUN_HIDDEN(
+#else
+DEFUN(
+#endif /* HAVE_BFDD */
+       neighbor_bfd_param,
        neighbor_bfd_param_cmd,
        "neighbor <A.B.C.D|X:X::X:X|WORD> bfd (2-255) (50-60000) (50-60000)",
        NEIGHBOR_STR
@@ -628,14 +637,21 @@ DEFUN_HIDDEN (neighbor_bfd_type,
 
 DEFUN (no_neighbor_bfd,
        no_neighbor_bfd_cmd,
+#if HAVE_BFDD > 0
+       "no neighbor <A.B.C.D|X:X::X:X|WORD> bfd",
+#else
        "no neighbor <A.B.C.D|X:X::X:X|WORD> bfd [(2-255) (50-60000) (50-60000)]",
+#endif /* HAVE_BFDD */
        NO_STR
        NEIGHBOR_STR
        NEIGHBOR_ADDR_STR2
        "Disables BFD support\n"
+#if HAVE_BFDD == 0
        "Detect Multiplier\n"
        "Required min receive interval\n"
-       "Desired min transmit interval\n")
+       "Desired min transmit interval\n"
+#endif /* !HAVE_BFDD */
+)
 {
 	int idx_peer = 2;
 	struct peer *peer;
diff -urpN frr-frr-5.0.1/bgpd/bgp_btoa.c frr-frr-6.0/bgpd/bgp_btoa.c
--- frr-frr-5.0.1/bgpd/bgp_btoa.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_btoa.c	2018-10-08 14:32:57.000000000 +0200
@@ -122,7 +122,7 @@ static int attr_parse(struct stream *s,
 int main(int argc, char **argv)
 {
 	int ret;
-	FILE *fp;
+	int fd;
 	struct stream *s;
 	time_t now;
 	int type;
@@ -143,8 +143,8 @@ int main(int argc, char **argv)
 		fprintf(stderr, "Usage: %s FILENAME\n", argv[0]);
 		exit(1);
 	}
-	fp = fopen(argv[1], "r");
-	if (!fp) {
+	fd = open(argv[1], O_RDONLY);
+	if (fd < 0) {
 		fprintf(stdout,
 			"%% Can't open configuration file %s due to '%s'.\n",
 			argv[1], safe_strerror(errno));
@@ -154,13 +154,14 @@ int main(int argc, char **argv)
 	while (1) {
 		stream_reset(s);
 
-		ret = fread(s->data, 12, 1, fp);
-		if (!ret || feof(fp)) {
-			printf("END OF FILE\n");
-			break;
-		}
-		if (ferror(fp)) {
-			printf("ERROR OF FREAD\n");
+		ret = stream_read(s, fd, 12);
+		if (ret != 12) {
+			if (!ret)
+				printf("END OF FILE\n");
+			else if (ret < 0)
+				printf("ERROR OF READ\n");
+			else
+				printf("UNDERFLOW\n");
 			break;
 		}
 
@@ -217,13 +218,14 @@ int main(int argc, char **argv)
 
 		printf("len: %zd\n", len);
 
-		fread(s->data + 12, len, 1, fp);
-		if (feof(fp)) {
-			printf("ENDOF FILE 2\n");
-			break;
-		}
-		if (ferror(fp)) {
-			printf("ERROR OF FREAD 2\n");
+		ret = stream_read(s, fd, len);
+		if (ret != (int)len) {
+			if (!ret)
+				printf("END OF FILE 2\n");
+			else if (ret < 0)
+				printf("ERROR OF READ 2\n");
+			else
+				printf("UNDERFLOW 2\n");
 			break;
 		}
 
@@ -284,6 +286,6 @@ int main(int argc, char **argv)
 			printf("\n");
 		}
 	}
-	fclose(fp);
+	close(fd);
 	return 0;
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_clist.c frr-frr-6.0/bgpd/bgp_clist.c
--- frr-frr-5.0.1/bgpd/bgp_clist.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_clist.c	2018-10-08 14:32:57.000000000 +0200
@@ -274,8 +274,7 @@ static void community_list_entry_add(str
 
 /* Delete community-list entry from the list.  */
 static void community_list_entry_delete(struct community_list *list,
-					struct community_entry *entry,
-					int style)
+					struct community_entry *entry)
 {
 	if (entry->next)
 		entry->next->prev = entry->prev;
@@ -333,71 +332,70 @@ community_list_entry_lookup(struct commu
 
 static char *community_str_get(struct community *com, int i)
 {
-	int len;
 	uint32_t comval;
 	uint16_t as;
 	uint16_t val;
 	char *str;
-	char *pnt;
 
 	memcpy(&comval, com_nthval(com, i), sizeof(uint32_t));
 	comval = ntohl(comval);
 
 	switch (comval) {
 	case COMMUNITY_INTERNET:
-		len = strlen(" internet");
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "internet");
 		break;
-	case COMMUNITY_NO_EXPORT:
-		len = strlen(" no-export");
+	case COMMUNITY_GSHUT:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "graceful-shutdown");
 		break;
-	case COMMUNITY_NO_ADVERTISE:
-		len = strlen(" no-advertise");
+	case COMMUNITY_ACCEPT_OWN:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "accept-own");
 		break;
-	case COMMUNITY_LOCAL_AS:
-		len = strlen(" local-AS");
+	case COMMUNITY_ROUTE_FILTER_TRANSLATED_v4:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR,
+			      "route-filter-translated-v4");
 		break;
-	case COMMUNITY_GSHUT:
-		len = strlen(" graceful-shutdown");
+	case COMMUNITY_ROUTE_FILTER_v4:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "route-filter-v4");
 		break;
-	default:
-		len = strlen(" 65536:65535");
+	case COMMUNITY_ROUTE_FILTER_TRANSLATED_v6:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR,
+			      "route-filter-translated-v6");
 		break;
-	}
-
-	/* Allocate memory.  */
-	str = pnt = XMALLOC(MTYPE_COMMUNITY_STR, len);
-
-	switch (comval) {
-	case COMMUNITY_INTERNET:
-		strcpy(pnt, "internet");
-		pnt += strlen("internet");
+	case COMMUNITY_ROUTE_FILTER_v6:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "route-filter-v6");
+		break;
+	case COMMUNITY_LLGR_STALE:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "llgr-stale");
+		break;
+	case COMMUNITY_NO_LLGR:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "no-llgr");
+		break;
+	case COMMUNITY_ACCEPT_OWN_NEXTHOP:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "accept-own-nexthop");
+		break;
+	case COMMUNITY_BLACKHOLE:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "blackhole");
 		break;
 	case COMMUNITY_NO_EXPORT:
-		strcpy(pnt, "no-export");
-		pnt += strlen("no-export");
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "no-export");
 		break;
 	case COMMUNITY_NO_ADVERTISE:
-		strcpy(pnt, "no-advertise");
-		pnt += strlen("no-advertise");
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "no-advertise");
 		break;
 	case COMMUNITY_LOCAL_AS:
-		strcpy(pnt, "local-AS");
-		pnt += strlen("local-AS");
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "local-AS");
 		break;
-	case COMMUNITY_GSHUT:
-		strcpy(pnt, "graceful-shutdown");
-		pnt += strlen("graceful-shutdown");
+	case COMMUNITY_NO_PEER:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "no-peer");
 		break;
 	default:
+		str = XSTRDUP(MTYPE_COMMUNITY_STR, "65536:65535");
 		as = (comval >> 16) & 0xFFFF;
 		val = comval & 0xFFFF;
-		sprintf(pnt, "%u:%d", as, val);
-		pnt += strlen(pnt);
+		snprintf(str, strlen(str), "%u:%d", as, val);
 		break;
 	}
 
-	*pnt = '\0';
-
 	return str;
 }
 
@@ -548,47 +546,77 @@ static int ecommunity_regexp_match(struc
 static struct community *
 community_regexp_delete (struct community *com, regex_t * reg)
 {
-  int i;
-  uint32_t comval;
-  /* Maximum is "65535:65535" + '\0'. */
-  char c[12];
-  const char *str;
-
-  if (!com)
-    return NULL;
-
-  i = 0;
-  while (i < com->size)
-    {
-      memcpy (&comval, com_nthval (com, i), sizeof (uint32_t));
-      comval = ntohl (comval);
-
-      switch (comval)
-        {
-        case COMMUNITY_INTERNET:
-          str = "internet";
-          break;
-        case COMMUNITY_NO_EXPORT:
-          str = "no-export";
-          break;
-        case COMMUNITY_NO_ADVERTISE:
-          str = "no-advertise";
-          break;
-        case COMMUNITY_LOCAL_AS:
-          str = "local-AS";
-          break;
-        default:
-          sprintf (c, "%d:%d", (comval >> 16) & 0xFFFF, comval & 0xFFFF);
-          str = c;
-          break;
-        }
-
-      if (regexec (reg, str, 0, NULL, 0) == 0)
-        community_del_val (com, com_nthval (com, i));
-      else
-        i++;
-    }
-  return com;
+	int i;
+	uint32_t comval;
+	/* Maximum is "65535:65535" + '\0'. */
+	char c[12];
+	const char *str;
+
+	if (!com)
+		return NULL;
+
+	i = 0;
+	while (i < com->size)
+	{
+		memcpy (&comval, com_nthval (com, i), sizeof (uint32_t));
+		comval = ntohl (comval);
+
+		switch (comval) {
+		case COMMUNITY_INTERNET:
+			str = "internet";
+			break;
+		case COMMUNITY_ACCEPT_OWN:
+			str = "accept-own";
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v4:
+			str = "route-filter-translated-v4";
+			break;
+		case COMMUNITY_ROUTE_FILTER_v4:
+			str = "route-filter-v4";
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v6:
+			str = "route-filter-translated-v6";
+			break;
+		case COMMUNITY_ROUTE_FILTER_v6:
+			str = "route-filter-v6";
+			break;
+		case COMMUNITY_LLGR_STALE:
+			str = "llgr-stale";
+			break;
+		case COMMUNITY_NO_LLGR:
+			str = "no-llgr";
+			break;
+		case COMMUNITY_ACCEPT_OWN_NEXTHOP:
+			str = "accept-own-nexthop";
+			break;
+		case COMMUNITY_BLACKHOLE:
+			str = "blackhole";
+			break;
+		case COMMUNITY_NO_EXPORT:
+			str = "no-export";
+			break;
+		case COMMUNITY_NO_ADVERTISE:
+			str = "no-advertise";
+			break;
+		case COMMUNITY_LOCAL_AS:
+			str = "local-AS";
+			break;
+		case COMMUNITY_NO_PEER:
+			str = "no-peer";
+			break;
+		default:
+			sprintf (c, "%d:%d", (comval >> 16) & 0xFFFF,
+			 comval & 0xFFFF);
+			str = c;
+			break;
+		}
+
+		if (regexec (reg, str, 0, NULL, 0) == 0)
+			community_del_val (com, com_nthval (com, i));
+		else
+			i++;
+	}
+	return com;
 }
 #endif
 
@@ -882,7 +910,7 @@ int community_list_unset(struct communit
 	if (!entry)
 		return COMMUNITY_LIST_ERR_CANT_FIND_LIST;
 
-	community_list_entry_delete(list, entry, style);
+	community_list_entry_delete(list, entry);
 	route_map_notify_dependencies(name, RMAP_EVENT_CLIST_DELETED);
 
 	return 0;
@@ -1040,7 +1068,7 @@ int lcommunity_list_unset(struct communi
 	if (!entry)
 		return COMMUNITY_LIST_ERR_CANT_FIND_LIST;
 
-	community_list_entry_delete(list, entry, style);
+	community_list_entry_delete(list, entry);
 
 	return 0;
 }
@@ -1054,7 +1082,8 @@ int extcommunity_list_set(struct communi
 	struct ecommunity *ecom = NULL;
 	regex_t *regex = NULL;
 
-	entry = NULL;
+	if (str == NULL)
+		return COMMUNITY_LIST_ERR_MALFORMED_VAL;
 
 	/* Get community list. */
 	list = community_list_get(ch, name, EXTCOMMUNITY_LIST_MASTER);
@@ -1089,7 +1118,7 @@ int extcommunity_list_set(struct communi
 	entry = community_entry_new();
 	entry->direct = direct;
 	entry->style = style;
-	entry->any = (str ? 0 : 1);
+	entry->any = 0;
 	if (ecom)
 		entry->config = ecommunity_ecom2str(
 			ecom, ECOMMUNITY_FORMAT_COMMUNITY_LIST, 0);
@@ -1146,7 +1175,7 @@ int extcommunity_list_unset(struct commu
 	if (!entry)
 		return COMMUNITY_LIST_ERR_CANT_FIND_LIST;
 
-	community_list_entry_delete(list, entry, style);
+	community_list_entry_delete(list, entry);
 	route_map_notify_dependencies(name, RMAP_EVENT_ECLIST_DELETED);
 
 	return 0;
diff -urpN frr-frr-5.0.1/bgpd/bgp_community.c frr-frr-6.0/bgpd/bgp_community.c
--- frr-frr-5.0.1/bgpd/bgp_community.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_community.c	2018-10-08 14:32:57.000000000 +0200
@@ -188,10 +188,20 @@ struct community *community_uniq_sort(st
    For Well-known communities value, below keyword is used.
 
    0x0             "internet"
+   0xFFFF0000      "graceful-shutdown"
+   0xFFFF0001      "accept-own"
+   0xFFFF0002      "route-filter-translated-v4"
+   0xFFFF0003      "route-filter-v4"
+   0xFFFF0004      "route-filter-translated-v6"
+   0xFFFF0005      "route-filter-v6"
+   0xFFFF0006      "llgr-stale"
+   0xFFFF0007      "no-llgr"
+   0xFFFF0008      "accept-own-nexthop"
+   0xFFFF029A      "blackhole"
    0xFFFFFF01      "no-export"
    0xFFFFFF02      "no-advertise"
    0xFFFFFF03      "local-AS"
-   0xFFFF0000      "graceful-shutdown"
+   0xFFFFFF04      "no-peer"
 
    For other values, "AS:VAL" format is used.  */
 static void set_community_string(struct community *com, bool make_json)
@@ -241,6 +251,36 @@ static void set_community_string(struct
 		case COMMUNITY_INTERNET:
 			len += strlen(" internet");
 			break;
+		case COMMUNITY_GSHUT:
+			len += strlen(" graceful-shutdown");
+			break;
+		case COMMUNITY_ACCEPT_OWN:
+			len += strlen(" accept-own");
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v4:
+			len += strlen(" route-filter-translated-v4");
+			break;
+		case COMMUNITY_ROUTE_FILTER_v4:
+			len += strlen(" route-filter-v4");
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v6:
+			len += strlen(" route-filter-translated-v6");
+			break;
+		case COMMUNITY_ROUTE_FILTER_v6:
+			len += strlen(" route-filter-v6");
+			break;
+		case COMMUNITY_LLGR_STALE:
+			len += strlen(" llgr-stale");
+			break;
+		case COMMUNITY_NO_LLGR:
+			len += strlen(" no-llgr");
+			break;
+		case COMMUNITY_ACCEPT_OWN_NEXTHOP:
+			len += strlen(" accept-own-nexthop");
+			break;
+		case COMMUNITY_BLACKHOLE:
+			len += strlen(" blackhole");
+			break;
 		case COMMUNITY_NO_EXPORT:
 			len += strlen(" no-export");
 			break;
@@ -250,8 +290,8 @@ static void set_community_string(struct
 		case COMMUNITY_LOCAL_AS:
 			len += strlen(" local-AS");
 			break;
-		case COMMUNITY_GSHUT:
-			len += strlen(" graceful-shutdown");
+		case COMMUNITY_NO_PEER:
+			len += strlen(" no-peer");
 			break;
 		default:
 			len += strlen(" 65536:65535");
@@ -284,6 +324,106 @@ static void set_community_string(struct
 						      json_string);
 			}
 			break;
+		case COMMUNITY_GSHUT:
+			strcpy(pnt, "graceful-shutdown");
+			pnt += strlen("graceful-shutdown");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"gracefulShutdown");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ACCEPT_OWN:
+			strcpy(pnt, "accept-own");
+			pnt += strlen("accept-own");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"acceptown");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v4:
+			strcpy(pnt, "route-filter-translated-v4");
+			pnt += strlen("route-filter-translated-v4");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"routeFilterTranslatedV4");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ROUTE_FILTER_v4:
+			strcpy(pnt, "route-filter-v4");
+			pnt += strlen("route-filter-v4");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"routeFilterV4");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ROUTE_FILTER_TRANSLATED_v6:
+			strcpy(pnt, "route-filter-translated-v6");
+			pnt += strlen("route-filter-translated-v6");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"routeFilterTranslatedV6");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ROUTE_FILTER_v6:
+			strcpy(pnt, "route-filter-v6");
+			pnt += strlen("route-filter-v6");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"routeFilterV6");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_LLGR_STALE:
+			strcpy(pnt, "llgr-stale");
+			pnt += strlen("llgr-stale");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"llgrStale");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_NO_LLGR:
+			strcpy(pnt, "no-llgr");
+			pnt += strlen("no-llgr");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"noLlgr");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_ACCEPT_OWN_NEXTHOP:
+			strcpy(pnt, "accept-own-nexthop");
+			pnt += strlen("accept-own-nexthop");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"acceptownnexthop");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
+		case COMMUNITY_BLACKHOLE:
+			strcpy(pnt, "blackhole");
+			pnt += strlen("blackhole");
+			if (make_json) {
+				json_string = json_object_new_string(
+					"blackhole");
+				json_object_array_add(json_community_list,
+						      json_string);
+			}
+			break;
 		case COMMUNITY_NO_EXPORT:
 			strcpy(pnt, "no-export");
 			pnt += strlen("no-export");
@@ -313,12 +453,11 @@ static void set_community_string(struct
 						      json_string);
 			}
 			break;
-		case COMMUNITY_GSHUT:
-			strcpy(pnt, "graceful-shutdown");
-			pnt += strlen("graceful-shutdown");
+		case COMMUNITY_NO_PEER:
+			strcpy(pnt, "no-peer");
+			pnt += strlen("no-peer");
 			if (make_json) {
-				json_string = json_object_new_string(
-					"gracefulShutdown");
+				json_string = json_object_new_string("noPeer");
 				json_object_array_add(json_community_list,
 						      json_string);
 			}
@@ -508,10 +647,20 @@ struct community *community_merge(struct
 /* Community token enum. */
 enum community_token {
 	community_token_val,
+	community_token_gshut,
+	community_token_accept_own,
+	community_token_route_filter_translated_v4,
+	community_token_route_filter_v4,
+	community_token_route_filter_translated_v6,
+	community_token_route_filter_v6,
+	community_token_llgr_stale,
+	community_token_no_llgr,
+	community_token_accept_own_nexthop,
+	community_token_blackhole,
 	community_token_no_export,
 	community_token_no_advertise,
 	community_token_local_as,
-	community_token_gshut,
+	community_token_no_peer,
 	community_token_unknown
 };
 
@@ -537,6 +686,79 @@ community_gettoken(const char *buf, enum
 			p += strlen("internet");
 			return p;
 		}
+		if (strncmp(p, "graceful-shutdown", strlen("graceful-shutdown"))
+		    == 0) {
+			*val = COMMUNITY_GSHUT;
+			*token = community_token_gshut;
+			p += strlen("graceful-shutdown");
+			return p;
+		}
+		if (strncmp(p, "accept-own", strlen("accept-own"))
+		    == 0) {
+			*val = COMMUNITY_ACCEPT_OWN;
+			*token = community_token_accept_own;
+			p += strlen("accept-own");
+			return p;
+		}
+		if (strncmp(p, "route-filter-translated-v4",
+			strlen("route-filter-translated-v4"))
+		    == 0) {
+			*val = COMMUNITY_ROUTE_FILTER_TRANSLATED_v4;
+			*token = community_token_route_filter_translated_v4;
+			p += strlen("route-filter-translated-v4");
+			return p;
+		}
+		if (strncmp(p, "route-filter-v4", strlen("route-filter-v4"))
+		    == 0) {
+			*val = COMMUNITY_ROUTE_FILTER_v4;
+			*token = community_token_route_filter_v4;
+			p += strlen("route-filter-v4");
+			return p;
+		}
+		if (strncmp(p, "route-filter-translated-v6",
+			strlen("route-filter-translated-v6"))
+		    == 0) {
+			*val = COMMUNITY_ROUTE_FILTER_TRANSLATED_v6;
+			*token = community_token_route_filter_translated_v6;
+			p += strlen("route-filter-translated-v6");
+			return p;
+		}
+		if (strncmp(p, "route-filter-v6", strlen("route-filter-v6"))
+		    == 0) {
+			*val = COMMUNITY_ROUTE_FILTER_v6;
+			*token = community_token_route_filter_v6;
+			p += strlen("route-filter-v6");
+			return p;
+		}
+		if (strncmp(p, "llgr-stale", strlen("llgr-stale"))
+		    == 0) {
+			*val = COMMUNITY_LLGR_STALE;
+			*token = community_token_llgr_stale;
+			p += strlen("llgr-stale");
+			return p;
+		}
+		if (strncmp(p, "no-llgr", strlen("no-llgr"))
+		    == 0) {
+			*val = COMMUNITY_NO_LLGR;
+			*token = community_token_no_llgr;
+			p += strlen("no-llgr");
+			return p;
+		}
+		if (strncmp(p, "accept-own-nexthop",
+			strlen("accept-own-nexthop"))
+		    == 0) {
+			*val = COMMUNITY_ACCEPT_OWN_NEXTHOP;
+			*token = community_token_accept_own_nexthop;
+			p += strlen("accept-own-nexthop");
+			return p;
+		}
+		if (strncmp(p, "blackhole", strlen("blackhole"))
+		    == 0) {
+			*val = COMMUNITY_BLACKHOLE;
+			*token = community_token_blackhole;
+			p += strlen("blackhole");
+			return p;
+		}
 		if (strncmp(p, "no-export", strlen("no-export")) == 0) {
 			*val = COMMUNITY_NO_EXPORT;
 			*token = community_token_no_export;
@@ -555,11 +777,10 @@ community_gettoken(const char *buf, enum
 			p += strlen("local-AS");
 			return p;
 		}
-		if (strncmp(p, "graceful-shutdown", strlen("graceful-shutdown"))
-		    == 0) {
-			*val = COMMUNITY_GSHUT;
-			*token = community_token_gshut;
-			p += strlen("graceful-shutdown");
+		if (strncmp(p, "no-peer", strlen("no-peer")) == 0) {
+			*val = COMMUNITY_NO_PEER;
+			*token = community_token_no_peer;
+			p += strlen("no-peer");
 			return p;
 		}
 
@@ -631,10 +852,20 @@ struct community *community_str2com(cons
 
 		switch (token) {
 		case community_token_val:
+		case community_token_gshut:
+		case community_token_accept_own:
+		case community_token_route_filter_translated_v4:
+		case community_token_route_filter_v4:
+		case community_token_route_filter_translated_v6:
+		case community_token_route_filter_v6:
+		case community_token_llgr_stale:
+		case community_token_no_llgr:
+		case community_token_accept_own_nexthop:
+		case community_token_blackhole:
 		case community_token_no_export:
 		case community_token_no_advertise:
 		case community_token_local_as:
-		case community_token_gshut:
+		case community_token_no_peer:
 			if (com == NULL) {
 				com = community_new();
 				com->json = NULL;
@@ -642,16 +873,12 @@ struct community *community_str2com(cons
 			community_add_val(com, val);
 			break;
 		case community_token_unknown:
-		default:
 			if (com)
 				community_free(com);
 			return NULL;
 		}
 	} while (str);
 
-	if (!com)
-		return NULL;
-
 	com_sort = community_uniq_sort(com);
 	community_free(com);
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_community.h frr-frr-6.0/bgpd/bgp_community.h
--- frr-frr-5.0.1/bgpd/bgp_community.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_community.h	2018-10-08 14:32:57.000000000 +0200
@@ -43,12 +43,22 @@ struct community {
 };
 
 /* Well-known communities value.  */
-#define COMMUNITY_INTERNET              0x0
-#define COMMUNITY_NO_EXPORT             0xFFFFFF01
-#define COMMUNITY_NO_ADVERTISE          0xFFFFFF02
-#define COMMUNITY_NO_EXPORT_SUBCONFED   0xFFFFFF03
-#define COMMUNITY_LOCAL_AS              0xFFFFFF03
-#define COMMUNITY_GSHUT                 0xFFFF0000
+#define COMMUNITY_INTERNET                      0x0
+#define COMMUNITY_GSHUT                         0xFFFF0000
+#define COMMUNITY_ACCEPT_OWN                    0xFFFF0001
+#define COMMUNITY_ROUTE_FILTER_TRANSLATED_v4    0xFFFF0002
+#define COMMUNITY_ROUTE_FILTER_v4               0xFFFF0003
+#define COMMUNITY_ROUTE_FILTER_TRANSLATED_v6    0xFFFF0004
+#define COMMUNITY_ROUTE_FILTER_v6               0xFFFF0005
+#define COMMUNITY_LLGR_STALE                    0xFFFF0006
+#define COMMUNITY_NO_LLGR                       0xFFFF0007
+#define COMMUNITY_ACCEPT_OWN_NEXTHOP            0xFFFF0008
+#define COMMUNITY_BLACKHOLE                     0xFFFF029A
+#define COMMUNITY_NO_EXPORT                     0xFFFFFF01
+#define COMMUNITY_NO_ADVERTISE                  0xFFFFFF02
+#define COMMUNITY_NO_EXPORT_SUBCONFED           0xFFFFFF03
+#define COMMUNITY_LOCAL_AS                      0xFFFFFF03
+#define COMMUNITY_NO_PEER                       0xFFFFFF04
 
 /* Macros of community attribute.  */
 #define com_length(X)    ((X)->size * 4)
diff -urpN frr-frr-5.0.1/bgpd/bgp_debug.c frr-frr-6.0/bgpd/bgp_debug.c
--- frr-frr-5.0.1/bgpd/bgp_debug.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_debug.c	2018-10-08 14:32:57.000000000 +0200
@@ -42,6 +42,9 @@
 #include "bgpd/bgp_ecommunity.h"
 #include "bgpd/bgp_label.h"
 #include "bgpd/bgp_evpn.h"
+#include "bgpd/bgp_evpn_private.h"
+#include "bgpd/bgp_evpn_vty.h"
+#include "bgpd/bgp_vty.h"
 #include "bgpd/bgp_flowspec.h"
 
 unsigned long conf_bgp_debug_as4;
@@ -169,6 +172,8 @@ static const struct message bgp_notify_c
 const char *bgp_origin_str[] = {"i", "e", "?"};
 const char *bgp_origin_long_str[] = {"IGP", "EGP", "incomplete"};
 
+static int bgp_debug_print_evpn_prefix(struct vty *vty, const char *desc,
+				       struct prefix *p);
 /* Given a string return a pointer the corresponding peer structure */
 static struct peer *bgp_find_peer(struct vty *vty, const char *peer_str)
 {
@@ -213,14 +218,16 @@ static void bgp_debug_list_free(struct l
 		}
 }
 
-/* Print the desc along with a list of peers/prefixes this debug is
- * enabled for */
+/*
+ * Print the desc along with a list of peers/prefixes this debug is
+ * enabled for
+ */
 static void bgp_debug_list_print(struct vty *vty, const char *desc,
 				 struct list *list)
 {
 	struct bgp_debug_filter *filter;
 	struct listnode *node, *nnode;
-	char buf[INET6_ADDRSTRLEN];
+	char buf[PREFIX2STR_BUFFER];
 
 	vty_out(vty, "%s", desc);
 
@@ -230,19 +237,20 @@ static void bgp_debug_list_print(struct
 			if (filter->host)
 				vty_out(vty, " %s", filter->host);
 
-			if (filter->p)
-				vty_out(vty, " %s/%d",
-					inet_ntop(filter->p->family,
-						  &filter->p->u.prefix, buf,
-						  INET6_ADDRSTRLEN),
-					filter->p->prefixlen);
+			if (filter->p && filter->p->family == AF_EVPN)
+				bgp_debug_print_evpn_prefix(vty, "", filter->p);
+			else if (filter->p) {
+				prefix2str(filter->p, buf, sizeof(buf));
+				vty_out(vty, " %s", buf);
+			}
 		}
 	}
 
 	vty_out(vty, "\n");
 }
 
-/* Print the command to enable the debug for each peer/prefix this debug is
+/*
+ * Print the command to enable the debug for each peer/prefix this debug is
  * enabled for
  */
 static int bgp_debug_list_conf_print(struct vty *vty, const char *desc,
@@ -250,7 +258,7 @@ static int bgp_debug_list_conf_print(str
 {
 	struct bgp_debug_filter *filter;
 	struct listnode *node, *nnode;
-	char buf[INET6_ADDRSTRLEN];
+	char buf[PREFIX2STR_BUFFER];
 	int write = 0;
 
 	if (list && !list_isempty(list)) {
@@ -260,13 +268,13 @@ static int bgp_debug_list_conf_print(str
 				write++;
 			}
 
-
-			if (filter->p) {
-				vty_out(vty, "%s %s/%d\n", desc,
-					inet_ntop(filter->p->family,
-						  &filter->p->u.prefix, buf,
-						  INET6_ADDRSTRLEN),
-					filter->p->prefixlen);
+			if (filter->p && filter->p->family == AF_EVPN) {
+				bgp_debug_print_evpn_prefix(vty, desc,
+							    filter->p);
+				write++;
+			} else if (filter->p) {
+				prefix2str(filter->p, buf, sizeof(buf));
+				vty_out(vty, "%s %s\n", desc, buf);
 				write++;
 			}
 		}
@@ -543,6 +551,106 @@ static void bgp_debug_clear_updgrp_updat
 	update_group_walk(bgp, update_group_clear_update_dbg, NULL);
 }
 
+static int bgp_debug_print_evpn_prefix(struct vty *vty, const char *desc,
+				       struct prefix *p)
+{
+	char evpn_desc[PREFIX2STR_BUFFER + INET_ADDRSTRLEN];
+	char buf[PREFIX2STR_BUFFER];
+	char buf2[ETHER_ADDR_STRLEN];
+
+	if (p->u.prefix_evpn.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+		if (is_evpn_prefix_ipaddr_none((struct prefix_evpn *)p)) {
+			sprintf(evpn_desc, "l2vpn evpn type macip mac %s",
+				 prefix_mac2str(
+					&p->u.prefix_evpn.macip_addr.mac,
+					buf2, sizeof(buf2)));
+		} else {
+			uint8_t family = is_evpn_prefix_ipaddr_v4(
+						(struct prefix_evpn *)p) ?
+							AF_INET : AF_INET6;
+			sprintf(evpn_desc, "l2vpn evpn type macip mac %s ip %s",
+				 prefix_mac2str(
+					&p->u.prefix_evpn.macip_addr.mac,
+					buf2, sizeof(buf2)),
+				 inet_ntop(family,
+					&p->u.prefix_evpn.macip_addr.ip.ip.addr,
+					buf, PREFIX2STR_BUFFER));
+		}
+	} else if (p->u.prefix_evpn.route_type == BGP_EVPN_IMET_ROUTE) {
+		sprintf(evpn_desc, "l2vpn evpn type multicast ip %s",
+			inet_ntoa(p->u.prefix_evpn.imet_addr.ip.ipaddr_v4));
+	} else if (p->u.prefix_evpn.route_type == BGP_EVPN_IP_PREFIX_ROUTE) {
+		uint8_t family = is_evpn_prefix_ipaddr_v4(
+					(struct prefix_evpn *)p) ? AF_INET
+								: AF_INET6;
+		sprintf(evpn_desc, "l2vpn evpn type prefix ip %s/%d",
+			inet_ntop(family,
+				  &p->u.prefix_evpn.prefix_addr.ip.ip.addr, buf,
+				  PREFIX2STR_BUFFER),
+			p->u.prefix_evpn.prefix_addr.ip_prefix_length);
+	}
+
+	vty_out(vty, "%s %s\n", desc, evpn_desc);
+
+	return 0;
+}
+
+static int bgp_debug_parse_evpn_prefix(struct vty *vty, struct cmd_token **argv,
+				       int argc, struct prefix **argv_pp)
+{
+	struct prefix *argv_p;
+	struct ethaddr mac;
+	struct ipaddr ip;
+	int evpn_type;
+	int type_idx = 0;
+	int mac_idx = 0;
+	int ip_idx = 0;
+
+	argv_p = *argv_pp;
+
+	if (argv_find(argv, argc, "macip", &type_idx))
+		evpn_type = BGP_EVPN_MAC_IP_ROUTE;
+	else if (argv_find(argv, argc, "multicast", &type_idx))
+		evpn_type = BGP_EVPN_IMET_ROUTE;
+	else if (argv_find(argv, argc, "prefix", &type_idx))
+		evpn_type = BGP_EVPN_IP_PREFIX_ROUTE;
+	else
+		evpn_type = 0;
+
+	if (evpn_type == BGP_EVPN_MAC_IP_ROUTE) {
+		memset(&ip, 0, sizeof(struct ipaddr));
+
+		argv_find(argv, argc, "mac", &mac_idx);
+		(void)prefix_str2mac(argv[mac_idx + 1]->arg, &mac);
+
+		argv_find(argv, argc, "ip", &ip_idx);
+		str2ipaddr(argv[ip_idx + 1]->arg, &ip);
+
+		build_evpn_type2_prefix((struct prefix_evpn *)argv_p,
+					&mac, &ip);
+	} else if (evpn_type == BGP_EVPN_IMET_ROUTE) {
+		memset(&ip, 0, sizeof(struct ipaddr));
+
+		argv_find(argv, argc, "ip", &ip_idx);
+		str2ipaddr(argv[ip_idx + 1]->arg, &ip);
+
+		build_evpn_type3_prefix((struct prefix_evpn *)argv_p,
+					ip.ipaddr_v4);
+	} else if (evpn_type == BGP_EVPN_IP_PREFIX_ROUTE) {
+		struct prefix ip_prefix;
+
+		memset(&ip_prefix, 0, sizeof(struct prefix));
+		if (argv_find(argv, argc, "ip", &ip_idx)) {
+			(void)str2prefix(argv[ip_idx + 1]->arg, &ip_prefix);
+			apply_mask(&ip_prefix);
+		}
+		build_type5_prefix_from_ip_prefix(
+					(struct prefix_evpn *)argv_p,
+					&ip_prefix);
+	}
+
+	return CMD_SUCCESS;
+}
 
 /* Debug option setting interface. */
 unsigned long bgp_debug_option = 0;
@@ -1266,6 +1374,141 @@ DEFUN (no_debug_bgp_update_direct_peer,
 	return CMD_SUCCESS;
 }
 
+#ifndef VTYSH_EXTRACT_PL
+#include "bgpd/bgp_debug_clippy.c"
+#endif
+
+DEFPY (debug_bgp_update_prefix_afi_safi,
+       debug_bgp_update_prefix_afi_safi_cmd,
+       "debug bgp updates prefix l2vpn$afi evpn$safi type <macip mac <M:A:C|M:A:C/M> [ip <A.B.C.D|X:X::X:X>]|multicast ip <A.B.C.D|X:X::X:X>|prefix ip <A.B.C.D/M|X:X::X:X/M>>",
+       DEBUG_STR
+       BGP_STR
+       "BGP updates\n"
+       "Specify a prefix to debug\n"
+       L2VPN_HELP_STR
+       EVPN_HELP_STR
+       "Specify EVPN Route type\n"
+       "MAC-IP (Type-2) route\n"
+       MAC_STR MAC_STR MAC_STR
+       IP_STR
+       "IPv4 address\n"
+       "IPv6 address\n"
+       "Multicast (Type-3) route\n"
+       IP_STR
+       "IPv4 address\n"
+       "IPv6 address\n"
+       "Prefix (Type-5) route\n"
+       IP_STR
+       "IPv4 prefix\n"
+       "IPv6 prefix\n")
+{
+	struct prefix *argv_p;
+	int ret = CMD_SUCCESS;
+	char buf[PREFIX2STR_BUFFER];
+
+	argv_p = prefix_new();
+
+	ret = bgp_debug_parse_evpn_prefix(vty, argv, argc, &argv_p);
+	if (ret != CMD_SUCCESS) {
+		prefix_free(argv_p);
+		return ret;
+	}
+
+	if (!bgp_debug_update_prefixes)
+		bgp_debug_update_prefixes = list_new();
+
+	prefix2str(argv_p, buf, sizeof(buf));
+
+	if (bgp_debug_list_has_entry(bgp_debug_update_prefixes, NULL, argv_p)) {
+		vty_out(vty,
+			"BGP updates debugging is already enabled for %s\n",
+			buf);
+		prefix_free(argv_p);
+		return CMD_SUCCESS;
+	}
+
+	bgp_debug_list_add_entry(bgp_debug_update_prefixes, NULL, argv_p);
+
+	if (vty->node == CONFIG_NODE) {
+		DEBUG_ON(update, UPDATE_PREFIX);
+	} else {
+		TERM_DEBUG_ON(update, UPDATE_PREFIX);
+		vty_out(vty, "BGP updates debugging is on for %s\n", buf);
+	}
+
+	prefix_free(argv_p);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (no_debug_bgp_update_prefix_afi_safi,
+       no_debug_bgp_update_prefix_afi_safi_cmd,
+       "no debug bgp updates prefix l2vpn$afi evpn$safi type <macip mac <M:A:C|M:A:C/M> [ip <A.B.C.D|X:X::X:X>]|multicast ip <A.B.C.D|X:X::X:X>|prefix ip <A.B.C.D/M|X:X::X:X/M>>",
+       NO_STR
+       DEBUG_STR
+       BGP_STR
+       "BGP updates\n"
+       "Specify a prefix to debug\n"
+       L2VPN_HELP_STR
+       EVPN_HELP_STR
+       "Specify EVPN Route type\n"
+       "MAC-IP (Type-2) route\n"
+       MAC_STR MAC_STR MAC_STR
+       IP_STR
+       "IPv4 address\n"
+       "IPv6 address\n"
+       "Multicast (Type-3) route\n"
+       IP_STR
+       "IPv4 address\n"
+       "IPv6 address\n"
+       "Prefix (Type-5) route\n"
+       IP_STR
+       "IPv4 prefix\n"
+       "IPv6 prefix\n")
+{
+	struct prefix *argv_p;
+	bool found_prefix = false;
+	int ret = CMD_SUCCESS;
+	char buf[PREFIX2STR_BUFFER];
+
+	argv_p = prefix_new();
+
+	ret = bgp_debug_parse_evpn_prefix(vty, argv, argc, &argv_p);
+	if (ret != CMD_SUCCESS) {
+		prefix_free(argv_p);
+		return ret;
+	}
+
+	if (bgp_debug_update_prefixes
+	    && !list_isempty(bgp_debug_update_prefixes)) {
+		found_prefix = bgp_debug_list_remove_entry(
+			bgp_debug_update_prefixes, NULL, argv_p);
+
+		if (list_isempty(bgp_debug_update_prefixes)) {
+			if (vty->node == CONFIG_NODE) {
+				DEBUG_OFF(update, UPDATE_PREFIX);
+			} else {
+				TERM_DEBUG_OFF(update, UPDATE_PREFIX);
+				vty_out(vty,
+					"BGP updates debugging (per prefix) is off\n");
+			}
+		}
+	}
+
+	prefix2str(argv_p, buf, sizeof(buf));
+
+	if (found_prefix)
+		vty_out(vty, "BGP updates debugging is off for %s\n", buf);
+	else
+		vty_out(vty, "BGP updates debugging was not enabled for %s\n",
+			buf);
+
+	prefix_free(argv_p);
+
+	return ret;
+}
+
+
 DEFUN (debug_bgp_update_prefix,
        debug_bgp_update_prefix_cmd,
        "debug bgp updates prefix <A.B.C.D/M|X:X::X:X/M>",
@@ -2095,6 +2338,10 @@ void bgp_debug_init(void)
 	install_element(CONFIG_NODE, &debug_bgp_update_prefix_cmd);
 	install_element(ENABLE_NODE, &no_debug_bgp_update_prefix_cmd);
 	install_element(CONFIG_NODE, &no_debug_bgp_update_prefix_cmd);
+	install_element(ENABLE_NODE, &debug_bgp_update_prefix_afi_safi_cmd);
+	install_element(CONFIG_NODE, &debug_bgp_update_prefix_afi_safi_cmd);
+	install_element(ENABLE_NODE, &no_debug_bgp_update_prefix_afi_safi_cmd);
+	install_element(CONFIG_NODE, &no_debug_bgp_update_prefix_afi_safi_cmd);
 
 	/* debug bgp zebra prefix A.B.C.D/M */
 	install_element(ENABLE_NODE, &debug_bgp_zebra_prefix_cmd);
diff -urpN frr-frr-5.0.1/bgpd/bgp_ecommunity.c frr-frr-6.0/bgpd/bgp_ecommunity.c
--- frr-frr-5.0.1/bgpd/bgp_ecommunity.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_ecommunity.c	2018-10-08 14:32:57.000000000 +0200
@@ -52,6 +52,11 @@ struct ecommunity *ecommunity_new(void)
 					    sizeof(struct ecommunity));
 }
 
+void ecommunity_strfree(char **s)
+{
+	XFREE(MTYPE_ECOMMUNITY_STR, *s);
+}
+
 /* Allocate ecommunities.  */
 void ecommunity_free(struct ecommunity **ecom)
 {
@@ -60,7 +65,6 @@ void ecommunity_free(struct ecommunity *
 	if ((*ecom)->str)
 		XFREE(MTYPE_ECOMMUNITY_STR, (*ecom)->str);
 	XFREE(MTYPE_ECOMMUNITY, *ecom);
-	ecom = NULL;
 }
 
 static void ecommunity_hash_free(struct ecommunity *ecom)
@@ -735,6 +739,13 @@ char *ecommunity_ecom2str(struct ecommun
 				else
 					len = sprintf(str_buf + str_pnt,
 						      "MM:%u", seqnum);
+			} else if (*pnt == ECOMMUNITY_EVPN_SUBTYPE_ND) {
+				uint8_t flags = *++pnt;
+
+				if (flags
+				    & ECOMMUNITY_EVPN_SUBTYPE_ND_ROUTER_FLAG)
+					len = sprintf(str_buf + str_pnt,
+						      "ND:Router Flag");
 			} else
 				unk_ecom = 1;
 		} else if (type == ECOMMUNITY_ENCODE_REDIRECT_IP_NH) {
@@ -796,6 +807,21 @@ char *ecommunity_ecom2str(struct ecommun
 				len = sprintf(
 					str_buf + str_pnt,
 					"FS:marking %u", *(pnt+5));
+			} else if (*pnt
+				   == ECOMMUNITY_EVPN_SUBTYPE_ES_IMPORT_RT) {
+				struct ethaddr mac;
+
+				pnt++;
+				memcpy(&mac, pnt, ETH_ALEN);
+				len = sprintf(
+					str_buf + str_pnt,
+					"ES-Import-Rt:%02x:%02x:%02x:%02x:%02x:%02x",
+					(uint8_t)mac.octet[0],
+					(uint8_t)mac.octet[1],
+					(uint8_t)mac.octet[2],
+					(uint8_t)mac.octet[3],
+					(uint8_t)mac.octet[4],
+					(uint8_t)mac.octet[5]);
 			} else
 				unk_ecom = 1;
 		} else {
diff -urpN frr-frr-5.0.1/bgpd/bgp_ecommunity.h frr-frr-6.0/bgpd/bgp_ecommunity.h
--- frr-frr-5.0.1/bgpd/bgp_ecommunity.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_ecommunity.h	2018-10-08 14:32:57.000000000 +0200
@@ -48,8 +48,11 @@
 #define ECOMMUNITY_EVPN_SUBTYPE_ES_IMPORT_RT 0x02
 #define ECOMMUNITY_EVPN_SUBTYPE_ROUTERMAC    0x03
 #define ECOMMUNITY_EVPN_SUBTYPE_DEF_GW       0x0d
+#define ECOMMUNITY_EVPN_SUBTYPE_ND           0x08
 
 #define ECOMMUNITY_EVPN_SUBTYPE_MACMOBILITY_FLAG_STICKY 0x01
+#define ECOMMUNITY_EVPN_SUBTYPE_ND_ROUTER_FLAG		0x01
+#define ECOMMUNITY_EVPN_SUBTYPE_ND_OVERRIDE_FLAG	0x02
 
 /* Low-order octet of the Extended Communities type field for OPAQUE types */
 #define ECOMMUNITY_OPAQUE_SUBTYPE_ENCAP     0x0c
@@ -156,6 +159,7 @@ extern void ecommunity_unintern(struct e
 extern unsigned int ecommunity_hash_make(void *);
 extern struct ecommunity *ecommunity_str2com(const char *, int, int);
 extern char *ecommunity_ecom2str(struct ecommunity *, int, int);
+extern void ecommunity_strfree(char **s);
 extern int ecommunity_match(const struct ecommunity *,
 			    const struct ecommunity *);
 extern char *ecommunity_str(struct ecommunity *);
diff -urpN frr-frr-5.0.1/bgpd/bgp_errors.c frr-frr-6.0/bgpd/bgp_errors.c
--- frr-frr-5.0.1/bgpd/bgp_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bgpd/bgp_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,306 @@
+/*
+ * BGP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Don Slice
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "bgp_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_bgp_err[] = {
+	{
+		.code = BGP_ERR_ATTR_FLAG,
+		.title = "BGP attribute flag is incorrect",
+		.description = "BGP attribute flag is set to the wrong value (Optional/Transitive/Partial)",
+		.suggestion = "Determine the soure of the attribute and determine why the attribute flag has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_LEN,
+		.title = "BGP attribute length is incorrect",
+		.description = "BGP attribute length is incorrect",
+		.suggestion = "Determine the soure of the attribute and determine why the attribute length has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_ORIGIN,
+		.title = "BGP attribute origin value invalid",
+		.description = "BGP attribute origin value is invalid",
+		.suggestion = "Determine the soure of the attribute and determine why the origin attribute has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_MAL_AS_PATH,
+		.title = "BGP as path is invalid",
+		.description = "BGP as path has been malformed",
+		.suggestion = "Determine the soure of the update and determine why the as path has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_FIRST_AS,
+		.title = "BGP as path first as is invalid",
+		.description = "BGP update has invalid first as in as path",
+		.suggestion = "Determine the soure of the update and determine why the as path first as value has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_PMSI_TYPE,
+		.title = "BGP PMSI tunnel attribute type is invalid",
+		.description = "BGP update has invalid type for PMSI tunnel",
+		.suggestion = "Determine the soure of the update and determine why the PMSI tunnel attribute type has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_ATTR_PMSI_LEN,
+		.title = "BGP PMSI tunnel attribute length is invalid",
+		.description = "BGP update has invalid length for PMSI tunnel",
+		.suggestion = "Determine the soure of the update and determine why the PMSI tunnel attribute length has been set incorrectly"
+	},
+	{
+		.code = BGP_ERR_PEER_GROUP,
+		.title = "BGP peergroup operated on in error",
+		.description = "BGP operating on peer-group instead of peers included",
+		.suggestion = "Ensure the config doesn't contain peergroups contained within peergroups"
+	},
+	{
+		.code = BGP_ERR_PEER_DELETE,
+		.title = "BGP failed to delete peer structure",
+		.description = "BGP was unable to delete peer structure when address-family removed",
+		.suggestion = "Determine if all expected peers are removed and restart FRR if not. Most likely a bug"
+	},
+	{
+		.code = BGP_ERR_TABLE_CHUNK,
+		.title = "BGP failed to get table chunk memory",
+		.description = "BGP unable to get chunk memory for table manager",
+		.suggestion = "Ensure there is adequate memory on the device to support the table requirements"
+	},
+	{
+		.code = BGP_ERR_MACIP_LEN,
+		.title = "BGP received MACIP with invalid IP addr len",
+		.description = "BGP received MACIP with invalid IP addr len from Zebra",
+		.suggestion = "Verify MACIP entries inserted in Zebra are correct.  Most likely a bug"
+	},
+	{
+		.code = BGP_ERR_LM_ERROR,
+		.title = "BGP received invalid label manager message",
+		.description = "BGP received invalid label manager message from label manager",
+		.suggestion = "Label manager sent invalid essage to BGP for wrong protocol, instance, etc. Most likely a bug"
+	},
+	{
+		.code = BGP_ERR_JSON_MEM_ERROR,
+		.title = "BGP unable to allocate memory for JSON output",
+		.description = "BGP attempted to generate JSON output and was unable to allocate the memory required",
+		.suggestion = "Ensure that the device has adequate memory to suport the required functions"
+	},
+	{
+		.code = BGP_ERR_UPDGRP_ATTR_LEN,
+		.title = "BGP update had attributes too long to send",
+		.description = "BGP attempted to send an update but the attributes were too long to fit",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_UPDGRP_CREATE,
+		.title = "BGP update group creation failed",
+		.description = "BGP attempted to create an update group but was unable to",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_UPDATE_SND,
+		.title = "BGP error creating update packet",
+		.description = "BGP attempted to create an update packet but was unable to",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_PKT_OPEN,
+		.title = "BGP error receiving open packet",
+		.description = "BGP received an open from a peer that was invalid",
+		.suggestion = "Determine the sending peer and correct his invalid open packet"
+	},
+	{
+		.code = BGP_ERR_SND_FAIL,
+		.title = "BGP error sending to peer",
+		.description = "BGP attempted to respond to open from a peer and failed",
+		.suggestion = "BGP attempted to respond to an open and could not sene the packet. Check local IP address for source"
+	},
+	{
+		.code = BGP_ERR_INVALID_STATUS,
+		.title = "BGP error receiving from  peer",
+		.description = "BGP received an update from a peer but status was incorrect",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_UPDATE_RCV,
+		.title = "BGP error receiving update packet",
+		.description = "BGP received an invalid update packet",
+		.suggestion = "Determine the source of the update and resolve the invalid update being sent"
+	},
+	{
+		.code = BGP_ERR_NO_CAP,
+		.title = "BGP error due to capability not enabled",
+		.description = "BGP attempted a function that did not have the capability enabled",
+		.suggestion = "Enable the capability if this functionality is desired"
+	},
+	{
+		.code = BGP_ERR_NOTIFY_RCV,
+		.title = "BGP error receiving notify message",
+		.description = "BGP unable to process notification message",
+		.suggestion = "BGP notify received while in stopped state. If the problem persists, report for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_KEEP_RCV,
+		.title = "BGP error receiving keepalive packet",
+		.description = "BGP unable to process keepalive packet",
+		.suggestion = "BGP keepalive received while in stopped state. If the problem persists, report for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_RFSH_RCV,
+		.title = "BGP error receiving route refresh message",
+		.description = "BGP unable to process route refresh message",
+		.suggestion = "BGP route refresh received while in stopped state. If the problem persists, report for troubleshooting"},
+	{
+		.code = BGP_ERR_CAP_RCV,
+		.title = "BGP error capability message",
+		.description = "BGP unable to process received capability",
+		 .suggestion = "BGP capability message received while in stopped state. If the problem persists, report for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_NH_UPD,
+		.title = "BGP error with nexthopo update",
+		.description = "BGP unable to process nexthop update",
+		.suggestion = "BGP received nexthop update but nexthop is not reachable in this bgp instance. Report for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_LABEL,
+		.title = "Failure to apply label",
+		.description = "BGP attempted to attempted to apply a label but could not",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_MULTIPATH,
+		.title = "Multipath specified is invalid",
+		.description = "BGP was started with an invalid ecmp/multipath value",
+		.suggestion = "Correct the ecmp/multipath value supplied when starting the BGP daemon"
+	},
+	{
+		.code = BGP_ERR_PKT_PROCESS,
+		.title = "Failure to process a packet",
+		.description = "BGP attempted to process a received packet but could not",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_CONNECT,
+		.title = "Failure to connect to peer",
+		.description = "BGP attempted to send open to peer but couldn't connect",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_FSM,
+		.title = "BGP FSM issue",
+		.description = "BGP neighbor transition problem",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_VNI,
+		.title = "BGP VNI creation issue",
+		.description = "BGP could not create a new VNI",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_NO_DFLT,
+		.title = "BGP default instance missing",
+		.description = "BGP could not find default instance",
+		.suggestion = "Define a default instance of BGP since some feature requires it's existence"
+	},
+	{
+		.code = BGP_ERR_VTEP_INVALID,
+		.title = "BGP remote VTEP invalid",
+		.description = "BGP remote VTEP is invalid and cannot be used",
+		.suggestion = "Correct remote VTEP configuration or resolve the source of the problem"
+	},
+	{
+		.code = BGP_ERR_ES_INVALID,
+		.title = "BGP ES route error",
+		.description = "BGP ES route incorrect, learned both local and remote",
+		.suggestion = "Correct configuration or addressing so that same not learned both local and remote"
+	},
+	{
+		.code = BGP_ERR_EVPN_ROUTE_DELETE,
+		.title = "BGP EVPN route delete error",
+		.description = "BGP attempted to delete an EVPN route and failed",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_EVPN_FAIL,
+		.title = "BGP EVPN install/uninstall error",
+		.description = "BGP attempted to install or uninstall an EVPN prefix and failed",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_EVPN_ROUTE_INVALID,
+		.title = "BGP EVPN route received with invalid contents",
+		.description = "BGP received an EVPN route with invalid contents",
+		.suggestion = "Determine the source of the EVPN route and resolve whatever is causing invalid contents"
+	},
+	{
+		.code = BGP_ERR_EVPN_ROUTE_CREATE,
+		.title = "BGP EVPN route create error",
+		.description = "BGP attempted to create an EVPN route and failed",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_ES_CREATE,
+		.title = "BGP EVPN ES entry create error",
+		.description = "BGP attempted to create an EVPN ES entry and failed",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = BGP_ERR_MULTI_INSTANCE,
+		.title = "BGP config multi-instance issue",
+		.description = "BGP configuration attempting multiple instances without enabling the feature",
+		.suggestion = "Correct the configuration so that bgp multiple-instance is enabled if desired"
+	},
+	{
+		.code = BGP_ERR_EVPN_AS_MISMATCH,
+		.title = "BGP AS configuration issue",
+		.description = "BGP configuration attempted for a different AS than currently configured",
+		.suggestion = "Correct the configuration so that the correct BGP AS number is used"
+	},
+	{
+		.code = BGP_ERR_EVPN_INSTANCE_MISMATCH,
+		.title = "BGP EVPN AS and process name mismatch",
+		.description = "BGP configuration has AS and process name mismatch",
+		.suggestion = "Correct the configuration so that the BGP AS number and instance name are consistent"
+	},
+	{
+		.code = BGP_ERR_FLOWSPEC_PACKET,
+		.title = "BGP Flowspec packet processing error",
+		.description = "The BGP flowspec subsystem has detected a error in the send or receive of a packet",
+		.suggestion = "Gather log files from both sides of the peering relationship and open an issue"
+	},
+	{
+		.code = BGP_ERR_FLOWSPEC_INSTALLATION,
+		.title = "BGP Flowspec Installation/removal Error",
+		.description = "The BGP flowspec subsystem has detected that there was a failure for installation/removal/modification of Flowspec from the dataplane",
+		.suggestion = "Gather log files from the router and open an issue, Restart FRR"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void bgp_error_init(void)
+{
+	log_ref_add(ferr_bgp_err);
+}
diff -urpN frr-frr-5.0.1/bgpd/bgp_errors.h frr-frr-6.0/bgpd/bgp_errors.h
--- frr-frr-5.0.1/bgpd/bgp_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/bgpd/bgp_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ * BGP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Don Slice
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __BGP_ERRORS_H__
+#define __BGP_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum bgp_log_refs {
+
+	BGP_ERR_ATTR_FLAG = BGP_FERR_START,
+	BGP_ERR_ATTR_LEN,
+	BGP_ERR_ATTR_ORIGIN,
+	BGP_ERR_ATTR_MAL_AS_PATH,
+	BGP_ERR_ATTR_FIRST_AS,
+	BGP_ERR_ATTR_MARTIAN_NH,
+	BGP_ERR_ATTR_PMSI_TYPE,
+	BGP_ERR_ATTR_PMSI_LEN,
+	BGP_ERR_ATTR_NH_SEND_LEN,
+	BGP_ERR_PEER_GROUP,
+	BGP_ERR_PEER_DELETE,
+	BGP_ERR_TABLE_CHUNK,
+	BGP_ERR_MACIP_LEN,
+	BGP_ERR_LM_ERROR,
+	BGP_ERR_JSON_MEM_ERROR,
+	BGP_ERR_UPDGRP_ATTR_LEN,
+	BGP_ERR_UPDGRP_CREATE,
+	BGP_ERR_UPDATE_SND,
+	BGP_ERR_PKT_OPEN,
+	BGP_ERR_SND_FAIL,
+	BGP_ERR_INVALID_STATUS,
+	BGP_ERR_UPDATE_RCV,
+	BGP_ERR_NO_CAP,
+	BGP_ERR_NOTIFY_RCV,
+	BGP_ERR_KEEP_RCV,
+	BGP_ERR_RFSH_RCV,
+	BGP_ERR_CAP_RCV,
+	BGP_ERR_NH_UPD,
+	BGP_ERR_LABEL,
+	BGP_ERR_MULTIPATH,
+	BGP_ERR_PKT_PROCESS,
+	BGP_ERR_CONNECT,
+	BGP_ERR_FSM,
+	BGP_ERR_VNI,
+	BGP_ERR_NO_DFLT,
+	BGP_ERR_VTEP_INVALID,
+	BGP_ERR_ES_INVALID,
+	BGP_ERR_EVPN_ROUTE_DELETE,
+	BGP_ERR_EVPN_FAIL,
+	BGP_ERR_EVPN_ROUTE_INVALID,
+	BGP_ERR_EVPN_ROUTE_CREATE,
+	BGP_ERR_ES_CREATE,
+	BGP_ERR_MULTI_INSTANCE,
+	BGP_ERR_EVPN_AS_MISMATCH,
+	BGP_ERR_EVPN_INSTANCE_MISMATCH,
+	BGP_ERR_FLOWSPEC_PACKET,
+	BGP_ERR_FLOWSPEC_INSTALLATION,
+};
+
+extern void bgp_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/bgpd/bgp_evpn.c frr-frr-6.0/bgpd/bgp_evpn.c
--- frr-frr-5.0.1/bgpd/bgp_evpn.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_evpn.c	2018-10-08 14:32:57.000000000 +0200
@@ -43,6 +43,7 @@
 #include "bgpd/bgp_ecommunity.h"
 #include "bgpd/bgp_encap_types.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_aspath.h"
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_nexthop.h"
@@ -53,13 +54,15 @@
 extern struct zclient *zclient;
 
 DEFINE_QOBJ_TYPE(bgpevpn)
+DEFINE_QOBJ_TYPE(evpnes)
 
 
 /*
  * Static function declarations
  */
-static void delete_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
-				    afi_t afi, safi_t safi, struct bgp_node *rn,
+static void delete_evpn_route_entry(struct bgp *bgp,
+				    afi_t afi, safi_t safi,
+				    struct bgp_node *rn,
 				    struct bgp_info **ri);
 static int delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn);
 
@@ -67,6 +70,47 @@ static int delete_all_vni_routes(struct
  * Private functions.
  */
 
+/* compare two IPV4 VTEP IPs */
+static int evpn_vtep_ip_cmp(const void *p1, const void *p2)
+{
+	const struct in_addr *ip1 = p1;
+	const struct in_addr *ip2 = p2;
+
+	if (!ip1 && !ip2)
+		return 1;
+	if (!ip1 || !ip2)
+		return 0;
+	return (ip1->s_addr == ip2->s_addr);
+}
+
+/*
+ * Make hash key for ESI.
+ */
+static unsigned int esi_hash_keymake(void *p)
+{
+	struct evpnes *pes = p;
+	const void *pnt = (void *)pes->esi.val;
+
+	return jhash(pnt, ESI_BYTES, 0xa5a5a55a);
+}
+
+/*
+ * Compare two ESIs.
+ */
+static int esi_cmp(const void *p1, const void *p2)
+{
+	const struct evpnes *pes1 = p1;
+	const struct evpnes *pes2 = p2;
+
+	if (pes1 == NULL && pes2 == NULL)
+		return 1;
+
+	if (pes1 == NULL || pes2 == NULL)
+		return 0;
+
+	return (memcmp(pes1->esi.val, pes2->esi.val, ESI_BYTES) == 0);
+}
+
 /*
  * Make vni hash key.
  */
@@ -129,7 +173,8 @@ static struct vrf_irt_node *vrf_import_r
 
 	bgp_def = bgp_get_default();
 	if (!bgp_def) {
-		zlog_err("vrf import rt new - def instance not created yet");
+		flog_err(BGP_ERR_NO_DFLT,
+			  "vrf import rt new - def instance not created yet");
 		return NULL;
 	}
 
@@ -159,11 +204,13 @@ static void vrf_import_rt_free(struct vr
 
 	bgp_def = bgp_get_default();
 	if (!bgp_def) {
-		zlog_err("vrf import rt free - def instance not created yet");
+		flog_err(BGP_ERR_NO_DFLT,
+			  "vrf import rt free - def instance not created yet");
 		return;
 	}
 
 	hash_release(bgp_def->vrf_import_rt_hash, irt);
+	list_delete_and_null(&irt->vrfs);
 	XFREE(MTYPE_BGP_EVPN_VRF_IMPORT_RT, irt);
 }
 
@@ -179,7 +226,9 @@ static struct vrf_irt_node *lookup_vrf_i
 
 	bgp_def = bgp_get_default();
 	if (!bgp_def) {
-		zlog_err("vrf import rt lookup - def instance not created yet");
+		flog_err(
+			BGP_ERR_NO_DFLT,
+			"vrf import rt lookup - def instance not created yet");
 		return NULL;
 	}
 
@@ -265,6 +314,7 @@ static struct irt_node *import_rt_new(st
 static void import_rt_free(struct bgp *bgp, struct irt_node *irt)
 {
 	hash_release(bgp->import_rt_hash, irt);
+	list_delete_and_null(&irt->vnis);
 	XFREE(MTYPE_BGP_EVPN_IMPORT_RT, irt);
 }
 
@@ -327,6 +377,12 @@ static int evpn_route_target_cmp(struct
 	return strcmp(ecom1->str, ecom2->str);
 }
 
+static void evpn_xxport_delete_ecomm(void *val)
+{
+	struct ecommunity *ecomm = val;
+	ecommunity_free(&ecomm);
+}
+
 /*
  * Mask off global-admin field of specified extended community (RT),
  * just retain the local-admin field.
@@ -387,7 +443,6 @@ static void unmap_vrf_from_rt(struct bgp
 	/* Delete VRF from list for this RT. */
 	listnode_delete(irt->vrfs, bgp_vrf);
 	if (!listnode_head(irt->vrfs)) {
-		list_delete_and_null(&irt->vrfs);
 		vrf_import_rt_free(irt);
 	}
 }
@@ -410,7 +465,7 @@ static void map_vni_to_rt(struct bgp *bg
 		mask_ecom_global_admin(&eval_tmp, eval);
 
 	irt = lookup_import_rt(bgp, &eval_tmp);
-	if (irt && irt->vnis)
+	if (irt)
 		if (is_vni_present_in_irt_vnis(irt->vnis, vpn))
 			/* Already mapped. */
 			return;
@@ -434,7 +489,6 @@ static void unmap_vni_from_rt(struct bgp
 	/* Delete VNI from hash list for this RT. */
 	listnode_delete(irt->vnis, vpn);
 	if (!listnode_head(irt->vnis)) {
-		list_delete_and_null(&irt->vnis);
 		import_rt_free(bgp, irt);
 	}
 }
@@ -452,6 +506,8 @@ static void form_auto_rt(struct bgp *bgp
 	struct ecommunity_val eval;
 	struct ecommunity *ecomadd;
 
+	if (bgp->advertise_autort_rfc8365)
+		vni |= EVPN_AUTORT_VXLAN;
 	encode_route_target_as((bgp->as & 0xFFFF), vni, &eval);
 
 	ecomadd = ecommunity_new();
@@ -510,15 +566,15 @@ static int bgp_zebra_send_remote_macip(s
 		s, add ? ZEBRA_REMOTE_MACIP_ADD : ZEBRA_REMOTE_MACIP_DEL,
 		bgp->vrf_id);
 	stream_putl(s, vpn->vni);
-	stream_put(s, &p->prefix.mac.octet, ETH_ALEN); /* Mac Addr */
+	stream_put(s, &p->prefix.macip_addr.mac.octet, ETH_ALEN); /* Mac Addr */
 	/* IP address length and IP address, if any. */
-	if (IS_EVPN_PREFIX_IPADDR_NONE(p))
+	if (is_evpn_prefix_ipaddr_none(p))
 		stream_putl(s, 0);
 	else {
-		ipa_len = IS_EVPN_PREFIX_IPADDR_V4(p) ? IPV4_MAX_BYTELEN
+		ipa_len = is_evpn_prefix_ipaddr_v4(p) ? IPV4_MAX_BYTELEN
 						      : IPV6_MAX_BYTELEN;
 		stream_putl(s, ipa_len);
-		stream_put(s, &p->prefix.ip.ip.addr, ipa_len);
+		stream_put(s, &p->prefix.macip_addr.ip.ip.addr, ipa_len);
 	}
 	stream_put_in_addr(s, &remote_vtep_ip);
 
@@ -532,8 +588,10 @@ static int bgp_zebra_send_remote_macip(s
 		zlog_debug(
 			"Tx %s MACIP, VNI %u MAC %s IP %s (flags: 0x%x) remote VTEP %s",
 			add ? "ADD" : "DEL", vpn->vni,
-			prefix_mac2str(&p->prefix.mac, buf1, sizeof(buf1)),
-			ipaddr2str(&p->prefix.ip, buf3, sizeof(buf3)), flags,
+			prefix_mac2str(&p->prefix.macip_addr.mac,
+				       buf1, sizeof(buf1)),
+			ipaddr2str(&p->prefix.macip_addr.ip,
+				   buf3, sizeof(buf3)), flags,
 			inet_ntop(AF_INET, &remote_vtep_ip, buf2,
 				  sizeof(buf2)));
 
@@ -563,10 +621,11 @@ static int bgp_zebra_send_remote_vtep(st
 		s, add ? ZEBRA_REMOTE_VTEP_ADD : ZEBRA_REMOTE_VTEP_DEL,
 		bgp->vrf_id);
 	stream_putl(s, vpn->vni);
-	if (IS_EVPN_PREFIX_IPADDR_V4(p))
-		stream_put_in_addr(s, &p->prefix.ip.ipaddr_v4);
-	else if (IS_EVPN_PREFIX_IPADDR_V6(p)) {
-		zlog_err(
+	if (is_evpn_prefix_ipaddr_v4(p))
+		stream_put_in_addr(s, &p->prefix.imet_addr.ip.ipaddr_v4);
+	else if (is_evpn_prefix_ipaddr_v6(p)) {
+		flog_err(
+			BGP_ERR_VTEP_INVALID,
 			"Bad remote IP when trying to %s remote VTEP for VNI %u",
 			add ? "ADD" : "DEL", vpn->vni);
 		return -1;
@@ -577,12 +636,46 @@ static int bgp_zebra_send_remote_vtep(st
 	if (bgp_debug_zebra(NULL))
 		zlog_debug("Tx %s Remote VTEP, VNI %u remote VTEP %s",
 			   add ? "ADD" : "DEL", vpn->vni,
-			   inet_ntoa(p->prefix.ip.ipaddr_v4));
+			   inet_ntoa(p->prefix.imet_addr.ip.ipaddr_v4));
 
 	return zclient_send_message(zclient);
 }
 
 /*
+ * Build extended community for EVPN ES (type-4) route
+ */
+static void build_evpn_type4_route_extcomm(struct evpnes *es,
+					   struct attr *attr)
+{
+	struct ecommunity ecom_encap;
+	struct ecommunity ecom_es_rt;
+	struct ecommunity_val eval;
+	struct ecommunity_val eval_es_rt;
+	bgp_encap_types tnl_type;
+	struct ethaddr mac;
+
+	/* Encap */
+	tnl_type = BGP_ENCAP_TYPE_VXLAN;
+	memset(&ecom_encap, 0, sizeof(ecom_encap));
+	encode_encap_extcomm(tnl_type, &eval);
+	ecom_encap.size = 1;
+	ecom_encap.val = (uint8_t *)eval.val;
+	attr->ecommunity = ecommunity_dup(&ecom_encap);
+
+	/* ES import RT */
+	memset(&mac, 0, sizeof(struct ethaddr));
+	memset(&ecom_es_rt, 0, sizeof(ecom_es_rt));
+	es_get_system_mac(&es->esi, &mac);
+	encode_es_rt_extcomm(&eval_es_rt, &mac);
+	ecom_es_rt.size = 1;
+	ecom_es_rt.val = (uint8_t *)eval_es_rt.val;
+	attr->ecommunity =
+		ecommunity_merge(attr->ecommunity, &ecom_es_rt);
+
+	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);
+}
+
+/*
  * Build extended communities for EVPN prefix route.
  */
 static void build_evpn_type5_route_extcomm(struct bgp *bgp_vrf,
@@ -609,11 +702,9 @@ static void build_evpn_type5_route_extco
 
 	/* Add the export RTs for L3VNI/VRF */
 	vrf_export_rtl = bgp_vrf->vrf_export_rtl;
-	if (vrf_export_rtl && !list_isempty(vrf_export_rtl)) {
-		for (ALL_LIST_ELEMENTS(vrf_export_rtl, node, nnode, ecom))
-			attr->ecommunity =
-				ecommunity_merge(attr->ecommunity, ecom);
-	}
+	for (ALL_LIST_ELEMENTS(vrf_export_rtl, node, nnode, ecom))
+		attr->ecommunity =
+			ecommunity_merge(attr->ecommunity, ecom);
 
 	/* add the router mac extended community */
 	if (!is_zero_mac(&attr->rmac)) {
@@ -645,10 +736,13 @@ static void build_evpn_route_extcomm(str
 	struct ecommunity ecom_sticky;
 	struct ecommunity ecom_default_gw;
 	struct ecommunity ecom_rmac;
+	struct ecommunity ecom_na;
 	struct ecommunity_val eval;
 	struct ecommunity_val eval_sticky;
 	struct ecommunity_val eval_default_gw;
 	struct ecommunity_val eval_rmac;
+	struct ecommunity_val eval_na;
+
 	bgp_encap_types tnl_type;
 	struct listnode *node, *nnode;
 	struct ecommunity *ecom;
@@ -713,6 +807,15 @@ static void build_evpn_route_extcomm(str
 			ecommunity_merge(attr->ecommunity, &ecom_default_gw);
 	}
 
+	if (attr->router_flag) {
+		memset(&ecom_na, 0, sizeof(ecom_na));
+		encode_na_flag_extcomm(&eval_na, attr->router_flag);
+		ecom_na.size = 1;
+		ecom_na.val = (uint8_t *)eval_na.val;
+		attr->ecommunity = ecommunity_merge(attr->ecommunity,
+						   &ecom_na);
+	}
+
 	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES);
 }
 
@@ -761,8 +864,11 @@ static void add_mac_mobility_to_attr(uin
 		ecom_tmp.size = 1;
 		ecom_tmp.val = (uint8_t *)eval.val;
 
-		attr->ecommunity =
-			ecommunity_merge(attr->ecommunity, &ecom_tmp);
+		if (attr->ecommunity)
+			attr->ecommunity =
+				ecommunity_merge(attr->ecommunity, &ecom_tmp);
+		else
+			attr->ecommunity = ecommunity_dup(&ecom_tmp);
 	}
 }
 
@@ -820,7 +926,7 @@ static void evpn_delete_old_local_route(
 					(struct prefix *)&rn->p, &vpn->prd);
 	if (global_rn) {
 		/* Delete route entry in the global EVPN table. */
-		delete_evpn_route_entry(bgp, vpn, afi, safi, global_rn, &ri);
+		delete_evpn_route_entry(bgp, afi, safi, global_rn, &ri);
 
 		/* Schedule for processing - withdraws to peers happen from
 		 * this table.
@@ -834,6 +940,164 @@ static void evpn_delete_old_local_route(
 	bgp_info_delete(rn, old_local);
 }
 
+static struct in_addr *es_vtep_new(struct in_addr vtep)
+{
+	struct in_addr *ip;
+
+	ip = XCALLOC(MTYPE_BGP_EVPN_ES_VTEP, sizeof(struct in_addr));
+	if (!ip)
+		return NULL;
+
+	ip->s_addr = vtep.s_addr;
+	return ip;
+}
+
+static void es_vtep_free(struct in_addr *ip)
+{
+	XFREE(MTYPE_BGP_EVPN_ES_VTEP, ip);
+}
+
+/* check if VTEP is already part of the list */
+static int is_vtep_present_in_list(struct list *list,
+				   struct in_addr vtep)
+{
+	struct listnode *node = NULL;
+	struct in_addr *tmp;
+
+	for (ALL_LIST_ELEMENTS_RO(list, node, tmp)) {
+		if (tmp->s_addr == vtep.s_addr)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Best path for ES route was changed,
+ * update the list of VTEPs for this ES
+ */
+static int evpn_es_install_vtep(struct bgp *bgp,
+				struct evpnes *es,
+				struct prefix_evpn *p,
+				struct in_addr rvtep)
+{
+	struct in_addr *vtep_ip;
+
+	if (is_vtep_present_in_list(es->vtep_list, rvtep))
+		return 0;
+
+
+	vtep_ip = es_vtep_new(rvtep);
+	if (vtep_ip)
+		listnode_add_sort(es->vtep_list, vtep_ip);
+	return 0;
+}
+
+/*
+ * Best path for ES route was changed,
+ * update the list of VTEPs for this ES
+ */
+static int evpn_es_uninstall_vtep(struct bgp *bgp,
+				  struct evpnes *es,
+				  struct prefix_evpn *p,
+				  struct in_addr rvtep)
+{
+	struct listnode *node, *nnode, *node_to_del = NULL;
+	struct in_addr *tmp;
+
+	for (ALL_LIST_ELEMENTS(es->vtep_list, node, nnode, tmp)) {
+		if (tmp->s_addr == rvtep.s_addr) {
+			es_vtep_free(tmp);
+			node_to_del = node;
+		}
+	}
+
+	if (node_to_del)
+		list_delete_node(es->vtep_list, node_to_del);
+
+	return 0;
+}
+
+/*
+ * Calculate the best path for a ES(type-4) route.
+ */
+static int evpn_es_route_select_install(struct bgp *bgp,
+					struct evpnes *es,
+					struct bgp_node *rn)
+{
+	int ret = 0;
+	afi_t afi = AFI_L2VPN;
+	safi_t safi = SAFI_EVPN;
+	struct bgp_info *old_select; /* old best */
+	struct bgp_info *new_select; /* new best */
+	struct bgp_info_pair old_and_new;
+
+	/* Compute the best path. */
+	bgp_best_selection(bgp, rn, &bgp->maxpaths[afi][safi],
+			   &old_and_new, afi, safi);
+	old_select = old_and_new.old;
+	new_select = old_and_new.new;
+
+	/*
+	 * If the best path hasn't changed - see if something needs to be
+	 * updated
+	 */
+	if (old_select && old_select == new_select
+	    && old_select->type == ZEBRA_ROUTE_BGP
+	    && old_select->sub_type == BGP_ROUTE_IMPORTED
+	    && !CHECK_FLAG(rn->flags, BGP_NODE_USER_CLEAR)
+	    && !CHECK_FLAG(old_select->flags, BGP_INFO_ATTR_CHANGED)
+	    && !bgp->addpath_tx_used[afi][safi]) {
+		if (bgp_zebra_has_route_changed(rn, old_select)) {
+			ret = evpn_es_install_vtep(bgp, es,
+						   (struct prefix_evpn *)&rn->p,
+						   old_select->attr->nexthop);
+		}
+		UNSET_FLAG(old_select->flags, BGP_INFO_MULTIPATH_CHG);
+		bgp_zebra_clear_route_change_flags(rn);
+		return ret;
+	}
+
+	/* If the user did a "clear" this flag will be set */
+	UNSET_FLAG(rn->flags, BGP_NODE_USER_CLEAR);
+
+	/*
+	 * bestpath has changed; update relevant fields and install or uninstall
+	 * into the zebra RIB.
+	 */
+	if (old_select || new_select)
+		bgp_bump_version(rn);
+
+	if (old_select)
+		bgp_info_unset_flag(rn, old_select, BGP_INFO_SELECTED);
+	if (new_select) {
+		bgp_info_set_flag(rn, new_select, BGP_INFO_SELECTED);
+		bgp_info_unset_flag(rn, new_select, BGP_INFO_ATTR_CHANGED);
+		UNSET_FLAG(new_select->flags, BGP_INFO_MULTIPATH_CHG);
+	}
+
+	if (new_select && new_select->type == ZEBRA_ROUTE_BGP
+	    && new_select->sub_type == BGP_ROUTE_IMPORTED) {
+		ret = evpn_es_install_vtep(bgp, es,
+					   (struct prefix_evpn *)&rn->p,
+					   new_select->attr->nexthop);
+	} else {
+		if (old_select && old_select->type == ZEBRA_ROUTE_BGP
+		    && old_select->sub_type == BGP_ROUTE_IMPORTED)
+			ret = evpn_es_uninstall_vtep(
+				bgp, es, (struct prefix_evpn *)&rn->p,
+				old_select->attr->nexthop);
+	}
+
+	/* Clear any route change flags. */
+	bgp_zebra_clear_route_change_flags(rn);
+
+	/* Reap old select bgp_info, if it has been removed */
+	if (old_select && CHECK_FLAG(old_select->flags, BGP_INFO_REMOVED))
+		bgp_info_reap(rn, old_select);
+
+	return ret;
+}
+
 /*
  * Calculate the best path for an EVPN route. Install/update best path in zebra,
  * if appropriate.
@@ -843,6 +1107,7 @@ static int evpn_route_select_install(str
 {
 	struct bgp_info *old_select, *new_select;
 	struct bgp_info_pair old_and_new;
+	struct prefix_evpn *evp;
 	afi_t afi = AFI_L2VPN;
 	safi_t safi = SAFI_EVPN;
 	int ret = 0;
@@ -854,6 +1119,7 @@ static int evpn_route_select_install(str
 	old_select = old_and_new.old;
 	new_select = old_and_new.new;
 
+	evp = (struct prefix_evpn *)&rn->p;
 	/* If the best path hasn't changed - see if there is still something to
 	 * update
 	 * to zebra RIB.
@@ -869,6 +1135,10 @@ static int evpn_route_select_install(str
 				SET_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY);
 			if (old_select->attr->default_gw)
 				SET_FLAG(flags, ZEBRA_MACIP_TYPE_GW);
+			if (is_evpn_prefix_ipaddr_v6(evp) &&
+			    old_select->attr->router_flag)
+				SET_FLAG(flags, ZEBRA_MACIP_TYPE_ROUTER_FLAG);
+
 			ret = evpn_zebra_install(
 				bgp, vpn, (struct prefix_evpn *)&rn->p,
 				old_select->attr->nexthop, flags);
@@ -902,6 +1172,10 @@ static int evpn_route_select_install(str
 			SET_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY);
 		if (new_select->attr->default_gw)
 			SET_FLAG(flags, ZEBRA_MACIP_TYPE_GW);
+		if (is_evpn_prefix_ipaddr_v6(evp) &&
+		    new_select->attr->router_flag)
+			SET_FLAG(flags, ZEBRA_MACIP_TYPE_ROUTER_FLAG);
+
 		ret = evpn_zebra_install(bgp, vpn, (struct prefix_evpn *)&rn->p,
 					 new_select->attr->nexthop, flags);
 		/* If an old best existed and it was a "local" route, the only
@@ -978,6 +1252,180 @@ static int evpn_route_is_sticky(struct b
 	return local_ri->attr->sticky;
 }
 
+/*
+ * create or update EVPN type4 route entry.
+ * This could be in the ES table or the global table.
+ * TODO: handle remote ES (type4) routes as well
+ */
+static int update_evpn_type4_route_entry(struct bgp *bgp,
+					 struct evpnes *es,
+					 afi_t afi, safi_t safi,
+					 struct bgp_node *rn,
+					 struct attr *attr,
+					 int add,
+					 struct bgp_info **ri,
+					 int *route_changed)
+{
+	char buf[ESI_STR_LEN];
+	char buf1[INET6_ADDRSTRLEN];
+	struct bgp_info *tmp_ri = NULL;
+	struct bgp_info *local_ri = NULL; /* local route entry if any */
+	struct bgp_info *remote_ri = NULL; /* remote route entry if any */
+	struct attr *attr_new = NULL;
+	struct prefix_evpn *evp = NULL;
+
+	*ri = NULL;
+	*route_changed = 1;
+	evp = (struct prefix_evpn *)&rn->p;
+
+	/* locate the local and remote entries if any */
+	for (tmp_ri = rn->info; tmp_ri; tmp_ri = tmp_ri->next) {
+		if (tmp_ri->peer == bgp->peer_self &&
+		    tmp_ri->type == ZEBRA_ROUTE_BGP &&
+		    tmp_ri->sub_type == BGP_ROUTE_STATIC)
+			local_ri = tmp_ri;
+		if (tmp_ri->type == ZEBRA_ROUTE_BGP &&
+		    tmp_ri->sub_type == BGP_ROUTE_IMPORTED &&
+		    CHECK_FLAG(tmp_ri->flags, BGP_INFO_VALID))
+			remote_ri = tmp_ri;
+	}
+
+	/* we don't expect to see a remote_ri at this point.
+	 * An ES route has esi + vtep_ip as the key,
+	 * We shouldn't see the same route from any other vtep.
+	 */
+	if (remote_ri) {
+		flog_err(
+			BGP_ERR_ES_INVALID,
+			"%u ERROR: local es route for ESI: %s Vtep %s also learnt from remote",
+			bgp->vrf_id,
+			esi_to_str(&evp->prefix.es_addr.esi, buf, sizeof(buf)),
+			ipaddr2str(&es->originator_ip, buf1, sizeof(buf1)));
+		return -1;
+	}
+
+	if (!local_ri && !add)
+		return 0;
+
+	/* create or update the entry */
+	if (!local_ri) {
+
+		/* Add or update attribute to hash */
+		attr_new = bgp_attr_intern(attr);
+
+		/* Create new route with its attribute. */
+		tmp_ri = info_make(ZEBRA_ROUTE_BGP, BGP_ROUTE_STATIC,
+				   0, bgp->peer_self, attr_new, rn);
+		SET_FLAG(tmp_ri->flags, BGP_INFO_VALID);
+
+		/* add the newly created path to the route-node */
+		bgp_info_add(rn, tmp_ri);
+	} else {
+		tmp_ri = local_ri;
+		if (attrhash_cmp(tmp_ri->attr, attr)
+		    && !CHECK_FLAG(tmp_ri->flags, BGP_INFO_REMOVED))
+			*route_changed = 0;
+		else {
+			/* The attribute has changed.
+			 * Add (or update) attribute to hash. */
+			attr_new = bgp_attr_intern(attr);
+			bgp_info_set_flag(rn, tmp_ri, BGP_INFO_ATTR_CHANGED);
+
+			/* Restore route, if needed. */
+			if (CHECK_FLAG(tmp_ri->flags, BGP_INFO_REMOVED))
+				bgp_info_restore(rn, tmp_ri);
+
+			/* Unintern existing, set to new. */
+			bgp_attr_unintern(&tmp_ri->attr);
+			tmp_ri->attr = attr_new;
+			tmp_ri->uptime = bgp_clock();
+		}
+	}
+
+	/* Return back the route entry. */
+	*ri = tmp_ri;
+	return 0;
+}
+
+/* update evpn es (type-4) route */
+static int update_evpn_type4_route(struct bgp *bgp,
+				   struct evpnes *es,
+				   struct prefix_evpn *p)
+{
+	int ret = 0;
+	int route_changed = 0;
+	char buf[ESI_STR_LEN];
+	char buf1[INET6_ADDRSTRLEN];
+	afi_t afi = AFI_L2VPN;
+	safi_t safi = SAFI_EVPN;
+	struct attr attr;
+	struct attr *attr_new = NULL;
+	struct bgp_node *rn = NULL;
+	struct bgp_info *ri = NULL;
+
+	memset(&attr, 0, sizeof(struct attr));
+
+	/* Build path-attribute for this route. */
+	bgp_attr_default_set(&attr, BGP_ORIGIN_IGP);
+	attr.nexthop = es->originator_ip.ipaddr_v4;
+	attr.mp_nexthop_global_in = es->originator_ip.ipaddr_v4;
+	attr.mp_nexthop_len = BGP_ATTR_NHLEN_IPV4;
+
+	/* Set up extended community. */
+	build_evpn_type4_route_extcomm(es, &attr);
+
+	/* First, create (or fetch) route node within the ESI. */
+	/* NOTE: There is no RD here. */
+	rn = bgp_node_get(es->route_table, (struct prefix *)p);
+
+	/* Create or update route entry. */
+	ret = update_evpn_type4_route_entry(bgp, es, afi, safi, rn,
+					    &attr, 1, &ri,
+					    &route_changed);
+	if (ret != 0) {
+		flog_err(
+			BGP_ERR_ES_INVALID,
+			"%u ERROR: Failed to updated ES route ESI: %s VTEP %s",
+			bgp->vrf_id,
+			esi_to_str(&p->prefix.es_addr.esi, buf, sizeof(buf)),
+			ipaddr2str(&es->originator_ip, buf1, sizeof(buf1)));
+	}
+
+	assert(ri);
+	attr_new = ri->attr;
+
+	/* Perform route selection;
+	 * this is just to set the flags correctly
+	 * as local route in the ES always wins.
+	 */
+	evpn_es_route_select_install(bgp, es, rn);
+	bgp_unlock_node(rn);
+
+	/* If this is a new route or some attribute has changed, export the
+	 * route to the global table. The route will be advertised to peers
+	 * from there. Note that this table is a 2-level tree (RD-level +
+	 * Prefix-level) similar to L3VPN routes.
+	 */
+	if (route_changed) {
+		struct bgp_info *global_ri;
+
+		rn = bgp_afi_node_get(bgp->rib[afi][safi], afi, safi,
+				      (struct prefix *)p, &es->prd);
+		update_evpn_type4_route_entry(bgp, es, afi, safi,
+					      rn, attr_new,
+					      1, &global_ri,
+					      &route_changed);
+
+		/* Schedule for processing and unlock node. */
+		bgp_process(bgp, rn, afi, safi);
+		bgp_unlock_node(rn);
+	}
+
+	/* Unintern temporary. */
+	aspath_unintern(&attr.aspath);
+	return 0;
+}
+
 static int update_evpn_type5_route_entry(struct bgp *bgp_def,
 					 struct bgp *bgp_vrf, afi_t afi,
 					 safi_t safi, struct bgp_node *rn,
@@ -998,8 +1446,9 @@ static int update_evpn_type5_route_entry
 			local_ri = tmp_ri;
 	}
 
-	/* create a new route entry if one doesnt exist.
-	   Otherwise see if route attr has changed
+	/*
+	 * create a new route entry if one doesnt exist.
+	 * Otherwise see if route attr has changed
 	 */
 	if (!local_ri) {
 
@@ -1158,8 +1607,7 @@ static int update_evpn_route_entry(struc
 	if (!local_ri) {
 		/* When learnt locally for the first time but already known from
 		 * remote, we have to initiate appropriate MAC mobility steps.
-		 * This
-		 * is applicable when updating the VNI routing table.
+		 * This is applicable when updating the VNI routing table.
 		 * We need to skip mobility steps for g/w macs (local mac on g/w
 		 * SVI) advertised in EVPN.
 		 * This will ensure that local routes are preferred for g/w macs
@@ -1278,6 +1726,8 @@ static int update_evpn_route(struct bgp
 	attr.mp_nexthop_len = BGP_ATTR_NHLEN_IPV4;
 	attr.sticky = CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY) ? 1 : 0;
 	attr.default_gw = CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_GW) ? 1 : 0;
+	attr.router_flag = CHECK_FLAG(flags,
+				      ZEBRA_MACIP_TYPE_ROUTER_FLAG) ? 1 : 0;
 
 	/* PMSI is only needed for type-3 routes */
 	if (p->prefix.route_type == BGP_EVPN_IMET_ROUTE)
@@ -1293,9 +1743,10 @@ static int update_evpn_route(struct bgp
 	 * these routes.
 	 */
 	if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE &&
-	    (IS_EVPN_PREFIX_IPADDR_V4(p) ||
-	     !IN6_IS_ADDR_LINKLOCAL(&p->prefix.ip.ipaddr_v6)) &&
-	    CHECK_FLAG(vpn->flags, VNI_FLAG_USE_TWO_LABELS))
+	    (is_evpn_prefix_ipaddr_v4(p) ||
+	     !IN6_IS_ADDR_LINKLOCAL(&p->prefix.macip_addr.ip.ipaddr_v6)) &&
+	    CHECK_FLAG(vpn->flags, VNI_FLAG_USE_TWO_LABELS) &&
+	    bgpevpn_get_l3vni(vpn))
 		add_l3_ecomm = 1;
 
 	/* Set up extended community. */
@@ -1341,19 +1792,22 @@ static int update_evpn_route(struct bgp
 	return 0;
 }
 
-/* Delete EVPN type5 route entry from global table */
-static void delete_evpn_type5_route_entry(struct bgp *bgp_def,
-					  struct bgp *bgp_vrf, afi_t afi,
-					  safi_t safi, struct bgp_node *rn,
-					  struct bgp_info **ri)
+/*
+ * Delete EVPN route entry.
+ * The entry can be in ESI/VNI table or the global table.
+ */
+static void delete_evpn_route_entry(struct bgp *bgp,
+				    afi_t afi, safi_t safi,
+				    struct bgp_node *rn,
+				    struct bgp_info **ri)
 {
-	struct bgp_info *tmp_ri = NULL;
+	struct bgp_info *tmp_ri;
 
 	*ri = NULL;
 
-	/* find the matching route entry */
+	/* Now, find matching route. */
 	for (tmp_ri = rn->info; tmp_ri; tmp_ri = tmp_ri->next)
-		if (tmp_ri->peer == bgp_def->peer_self
+		if (tmp_ri->peer == bgp->peer_self
 		    && tmp_ri->type == ZEBRA_ROUTE_BGP
 		    && tmp_ri->sub_type == BGP_ROUTE_STATIC)
 			break;
@@ -1365,6 +1819,57 @@ static void delete_evpn_type5_route_entr
 		bgp_info_delete(rn, tmp_ri);
 }
 
+
+
+/* Delete EVPN ES (type-4) route */
+static int delete_evpn_type4_route(struct bgp *bgp,
+				   struct evpnes *es,
+				   struct prefix_evpn *p)
+{
+	afi_t afi = AFI_L2VPN;
+	safi_t safi = SAFI_EVPN;
+	struct bgp_info *ri;
+	struct bgp_node *rn = NULL; /* rn in esi table */
+	struct bgp_node *global_rn = NULL; /* rn in global table */
+
+	/* First, locate the route node within the ESI.
+	 * If it doesn't exist, ther is nothing to do.
+	 * Note: there is no RD here.
+	 */
+	rn = bgp_node_lookup(es->route_table, (struct prefix *)p);
+	if (!rn)
+		return 0;
+
+	/* Next, locate route node in the global EVPN routing table.
+	 * Note that this table is a 2-level tree (RD-level + Prefix-level)
+	 */
+	global_rn = bgp_afi_node_lookup(bgp->rib[afi][safi], afi, safi,
+					(struct prefix *)p, &es->prd);
+	if (global_rn) {
+
+		/* Delete route entry in the global EVPN table. */
+		delete_evpn_route_entry(bgp, afi, safi,
+					global_rn, &ri);
+
+		/* Schedule for processing - withdraws to peers happen from
+		 * this table.
+		 */
+		if (ri)
+			bgp_process(bgp, global_rn, afi, safi);
+		bgp_unlock_node(global_rn);
+	}
+
+	/*
+	 * Delete route entry in the ESI route table.
+	 * This can just be removed.
+	 */
+	delete_evpn_route_entry(bgp, afi, safi, rn, &ri);
+	if (ri)
+		bgp_info_reap(rn, ri);
+	bgp_unlock_node(rn);
+	return 0;
+}
+
 /* Delete EVPN type5 route */
 static int delete_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp)
 {
@@ -1384,7 +1889,7 @@ static int delete_evpn_type5_route(struc
 	if (!rn)
 		return 0;
 
-	delete_evpn_type5_route_entry(bgp_def, bgp_vrf, afi, safi, rn, &ri);
+	delete_evpn_route_entry(bgp_def, afi, safi, rn, &ri);
 	if (ri)
 		bgp_process(bgp_def, rn, afi, safi);
 	bgp_unlock_node(rn);
@@ -1392,32 +1897,6 @@ static int delete_evpn_type5_route(struc
 }
 
 /*
- * Delete EVPN route entry. This could be in the VNI route table
- * or the global route table.
- */
-static void delete_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
-				    afi_t afi, safi_t safi, struct bgp_node *rn,
-				    struct bgp_info **ri)
-{
-	struct bgp_info *tmp_ri;
-
-	*ri = NULL;
-
-	/* Now, find matching route. */
-	for (tmp_ri = rn->info; tmp_ri; tmp_ri = tmp_ri->next)
-		if (tmp_ri->peer == bgp->peer_self
-		    && tmp_ri->type == ZEBRA_ROUTE_BGP
-		    && tmp_ri->sub_type == BGP_ROUTE_STATIC)
-			break;
-
-	*ri = tmp_ri;
-
-	/* Mark route for delete. */
-	if (tmp_ri)
-		bgp_info_delete(rn, tmp_ri);
-}
-
-/*
  * Delete EVPN route (of type based on prefix) for specified VNI and
  * schedule for processing.
  */
@@ -1446,7 +1925,7 @@ static int delete_evpn_route(struct bgp
 					(struct prefix *)p, &vpn->prd);
 	if (global_rn) {
 		/* Delete route entry in the global EVPN table. */
-		delete_evpn_route_entry(bgp, vpn, afi, safi, global_rn, &ri);
+		delete_evpn_route_entry(bgp, afi, safi, global_rn, &ri);
 
 		/* Schedule for processing - withdraws to peers happen from
 		 * this table.
@@ -1458,7 +1937,7 @@ static int delete_evpn_route(struct bgp
 
 	/* Delete route entry in the VNI route table. This can just be removed.
 	 */
-	delete_evpn_route_entry(bgp, vpn, afi, safi, rn, &ri);
+	delete_evpn_route_entry(bgp, afi, safi, rn, &ri);
 	if (ri)
 		bgp_info_reap(rn, ri);
 	bgp_unlock_node(rn);
@@ -1519,7 +1998,8 @@ static int update_all_type2_routes(struc
 	/* Add L3 VNI RTs and RMAC for non IPv6 link-local attributes if
 	 * using L3 VNI for type-2 routes also.
 	 */
-	if (CHECK_FLAG(vpn->flags, VNI_FLAG_USE_TWO_LABELS))
+	if (CHECK_FLAG(vpn->flags, VNI_FLAG_USE_TWO_LABELS) &&
+	    bgpevpn_get_l3vni(vpn))
 		add_l3_ecomm = 1;
 
 	build_evpn_route_extcomm(vpn, &attr, add_l3_ecomm);
@@ -1539,8 +2019,8 @@ static int update_all_type2_routes(struc
 		if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
 			continue;
 
-		if (IS_EVPN_PREFIX_IPADDR_V6(evp) &&
-		    IN6_IS_ADDR_LINKLOCAL(&evp->prefix.ip.ipaddr_v6))
+		if (is_evpn_prefix_ipaddr_v6(evp) &&
+		    IN6_IS_ADDR_LINKLOCAL(&evp->prefix.macip_addr.ip.ipaddr_v6))
 			update_evpn_route_entry(bgp, vpn, afi, safi, rn,
 						&attr_ip6_ll, 0, 1, &ri, 0);
 		else {
@@ -1548,11 +2028,13 @@ static int update_all_type2_routes(struc
 				update_evpn_route_entry(bgp, vpn, afi, safi, rn,
 							&attr_sticky, 0, 1, &ri,
 							0);
-			else if (evpn_route_is_def_gw(bgp, rn))
+			else if (evpn_route_is_def_gw(bgp, rn)) {
+				if (is_evpn_prefix_ipaddr_v6(evp))
+					attr_def_gw.router_flag = 1;
 				update_evpn_route_entry(bgp, vpn, afi, safi, rn,
 							&attr_def_gw, 0, 1, &ri,
 							0);
-			else
+			} else
 				update_evpn_route_entry(bgp, vpn, afi, safi, rn,
 							&attr, 0, 1, &ri, 0);
 		}
@@ -1616,7 +2098,7 @@ static int delete_global_type2_routes(st
 			if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
 				continue;
 
-			delete_evpn_route_entry(bgp, vpn, afi, safi, rn, &ri);
+			delete_evpn_route_entry(bgp, afi, safi, rn, &ri);
 			if (ri)
 				bgp_process(bgp, rn, afi, safi);
 		}
@@ -1657,7 +2139,7 @@ static int delete_all_type2_routes(struc
 		if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
 			continue;
 
-		delete_evpn_route_entry(bgp, vpn, afi, safi, rn, &ri);
+		delete_evpn_route_entry(bgp, afi, safi, rn, &ri);
 
 		/* Route entry in local table gets deleted immediately. */
 		if (ri)
@@ -1668,6 +2150,27 @@ static int delete_all_type2_routes(struc
 }
 
 /*
+ * Delete all routes in per ES route-table
+ */
+static int delete_all_es_routes(struct bgp *bgp, struct evpnes *es)
+{
+	struct bgp_node *rn;
+	struct bgp_info *ri, *nextri;
+
+	/* Walk this ES's route table and delete all routes. */
+	for (rn = bgp_table_top(es->route_table); rn;
+	     rn = bgp_route_next(rn)) {
+		for (ri = rn->info; (ri != NULL) && (nextri = ri->next, 1);
+		     ri = nextri) {
+			bgp_info_delete(rn, ri);
+			bgp_info_reap(rn, ri);
+		}
+	}
+
+	return 0;
+}
+
+/*
  * Delete all routes in the per-VNI route table.
  */
 static int delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
@@ -1710,6 +2213,29 @@ static int update_routes_for_vni(struct
 	return update_all_type2_routes(bgp, vpn);
 }
 
+/* Delete (and withdraw) local routes for specified ES from global and ES table.
+ * Also remove all other routes from the per ES table.
+ * Invoked when ES is deleted.
+ */
+static int delete_routes_for_es(struct bgp *bgp, struct evpnes *es)
+{
+	int ret;
+	char buf[ESI_STR_LEN];
+	struct prefix_evpn p;
+
+	/* Delete and withdraw locally learnt ES route */
+	build_evpn_type4_prefix(&p, &es->esi, es->originator_ip.ipaddr_v4);
+	ret = delete_evpn_type4_route(bgp, es, &p);
+	if (ret) {
+		flog_err(BGP_ERR_EVPN_ROUTE_DELETE,
+			  "%u failed to delete type-4 route for ESI %s",
+			  bgp->vrf_id, esi_to_str(&es->esi, buf, sizeof(buf)));
+	}
+
+	/* Delete all routes from per ES table */
+	return delete_all_es_routes(bgp, es);
+}
+
 /*
  * Delete (and withdraw) local routes for specified VNI from the global
  * table and per-VNI table. After this, remove all other routes from
@@ -1772,6 +2298,68 @@ static int handle_tunnel_ip_change(struc
 	return 0;
 }
 
+/* Install EVPN route entry in ES */
+static int install_evpn_route_entry_in_es(struct bgp *bgp,
+					  struct evpnes *es,
+					  struct prefix_evpn *p,
+					  struct bgp_info *parent_ri)
+{
+	int ret = 0;
+	struct bgp_node *rn = NULL;
+	struct bgp_info *ri = NULL;
+	struct attr *attr_new = NULL;
+
+	/* Create (or fetch) route within the VNI.
+	 * NOTE: There is no RD here.
+	 */
+	rn = bgp_node_get(es->route_table, (struct prefix *)p);
+
+	/* Check if route entry is already present. */
+	for (ri = rn->info; ri; ri = ri->next)
+		if (ri->extra &&
+		    (struct bgp_info *)ri->extra->parent == parent_ri)
+			break;
+
+	if (!ri) {
+		/* Add (or update) attribute to hash. */
+		attr_new = bgp_attr_intern(parent_ri->attr);
+
+		/* Create new route with its attribute. */
+		ri = info_make(parent_ri->type, BGP_ROUTE_IMPORTED, 0,
+			       parent_ri->peer, attr_new, rn);
+		SET_FLAG(ri->flags, BGP_INFO_VALID);
+		bgp_info_extra_get(ri);
+		ri->extra->parent = parent_ri;
+		bgp_info_add(rn, ri);
+	} else {
+		if (attrhash_cmp(ri->attr, parent_ri->attr)
+		    && !CHECK_FLAG(ri->flags, BGP_INFO_REMOVED)) {
+			bgp_unlock_node(rn);
+			return 0;
+		}
+		/* The attribute has changed. */
+		/* Add (or update) attribute to hash. */
+		attr_new = bgp_attr_intern(parent_ri->attr);
+
+		/* Restore route, if needed. */
+		if (CHECK_FLAG(ri->flags, BGP_INFO_REMOVED))
+			bgp_info_restore(rn, ri);
+
+		/* Mark if nexthop has changed. */
+		if (!IPV4_ADDR_SAME(&ri->attr->nexthop, &attr_new->nexthop))
+			SET_FLAG(ri->flags, BGP_INFO_IGP_CHANGED);
+
+		/* Unintern existing, set to new. */
+		bgp_attr_unintern(&ri->attr);
+		ri->attr = attr_new;
+		ri->uptime = bgp_clock();
+	}
+
+	/* Perform route selection and update zebra, if required. */
+	ret = evpn_es_route_select_install(bgp, es, rn);
+	return ret;
+}
+
 /*
  * Install route entry into the VRF routing table and invoke route selection.
  */
@@ -1792,10 +2380,7 @@ static int install_evpn_route_entry_in_v
 	char buf1[PREFIX_STRLEN];
 
 	memset(pp, 0, sizeof(struct prefix));
-	if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
-		ip_prefix_from_type2_prefix(evp, pp);
-	else if (evp->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE)
-		ip_prefix_from_type5_prefix(evp, pp);
+	ip_prefix_from_evpn_prefix(evp, pp);
 
 	if (bgp_debug_zebra(NULL)) {
 		zlog_debug(
@@ -1807,11 +2392,11 @@ static int install_evpn_route_entry_in_v
 
 	/* Create (or fetch) route within the VRF. */
 	/* NOTE: There is no RD here. */
-	if (IS_EVPN_PREFIX_IPADDR_V4(evp)) {
+	if (is_evpn_prefix_ipaddr_v4(evp)) {
 		afi = AFI_IP;
 		safi = SAFI_UNICAST;
 		rn = bgp_node_get(bgp_vrf->rib[afi][safi], pp);
-	} else if (IS_EVPN_PREFIX_IPADDR_V6(evp)) {
+	} else if (is_evpn_prefix_ipaddr_v6(evp)) {
 		afi = AFI_IP6;
 		safi = SAFI_UNICAST;
 		rn = bgp_node_get(bgp_vrf->rib[afi][safi], pp);
@@ -1820,12 +2405,15 @@ static int install_evpn_route_entry_in_v
 
 	/* EVPN routes currently only support a IPv4 next hop which corresponds
 	 * to the remote VTEP. When importing into a VRF, if it is IPv6 host
-	 * route, we have to convert the next hop to an IPv4-mapped address
-	 * for the rest of the code to flow through.
+	 * or prefix route, we have to convert the next hop to an IPv4-mapped
+	 * address for the rest of the code to flow through. In the case of IPv4,
+	 * make sure to set the flag for next hop attribute.
 	 */
 	bgp_attr_dup(&attr, parent_ri->attr);
 	if (afi == AFI_IP6)
 		evpn_convert_nexthop_to_ipv6(&attr);
+	else
+		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);
 
 	/* Check if route entry is already present. */
 	for (ri = rn->info; ri; ri = ri->next)
@@ -1842,7 +2430,8 @@ static int install_evpn_route_entry_in_v
 			       parent_ri->peer, attr_new, rn);
 		SET_FLAG(ri->flags, BGP_INFO_VALID);
 		bgp_info_extra_get(ri);
-		ri->extra->parent = parent_ri;
+		ri->extra->parent = bgp_info_lock(parent_ri);
+		bgp_lock_node((struct bgp_node *)parent_ri->net);
 		if (parent_ri->extra) {
 			memcpy(&ri->extra->label, &parent_ri->extra->label,
 			       sizeof(ri->extra->label));
@@ -1914,7 +2503,8 @@ static int install_evpn_route_entry(stru
 			       parent_ri->peer, attr_new, rn);
 		SET_FLAG(ri->flags, BGP_INFO_VALID);
 		bgp_info_extra_get(ri);
-		ri->extra->parent = parent_ri;
+		ri->extra->parent = bgp_info_lock(parent_ri);
+		bgp_lock_node((struct bgp_node *)parent_ri->net);
 		if (parent_ri->extra) {
 			memcpy(&ri->extra->label, &parent_ri->extra->label,
 			       sizeof(ri->extra->label));
@@ -1951,6 +2541,47 @@ static int install_evpn_route_entry(stru
 	return ret;
 }
 
+/* Uninstall EVPN route entry from ES route table */
+static int uninstall_evpn_route_entry_in_es(struct bgp *bgp,
+					    struct evpnes *es,
+					    struct prefix_evpn *p,
+					    struct bgp_info *parent_ri)
+{
+	int ret;
+	struct bgp_node *rn;
+	struct bgp_info *ri;
+
+	if (!es->route_table)
+		return 0;
+
+	/* Locate route within the ESI.
+	 * NOTE: There is no RD here.
+	 */
+	rn = bgp_node_lookup(es->route_table, (struct prefix *)p);
+	if (!rn)
+		return 0;
+
+	/* Find matching route entry. */
+	for (ri = rn->info; ri; ri = ri->next)
+		if (ri->extra &&
+		    (struct bgp_info *)ri->extra->parent == parent_ri)
+			break;
+
+	if (!ri)
+		return 0;
+
+	/* Mark entry for deletion */
+	bgp_info_delete(rn, ri);
+
+	/* Perform route selection and update zebra, if required. */
+	ret = evpn_es_route_select_install(bgp, es, rn);
+
+	/* Unlock route node. */
+	bgp_unlock_node(rn);
+
+	return ret;
+}
+
 /*
  * Uninstall route entry from the VRF routing table and send message
  * to zebra, if appropriate.
@@ -1970,10 +2601,7 @@ static int uninstall_evpn_route_entry_in
 	char buf1[PREFIX_STRLEN];
 
 	memset(pp, 0, sizeof(struct prefix));
-	if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
-		ip_prefix_from_type2_prefix(evp, pp);
-	else if (evp->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE)
-		ip_prefix_from_type5_prefix(evp, pp);
+	ip_prefix_from_evpn_prefix(evp, pp);
 
 	if (bgp_debug_zebra(NULL)) {
 		zlog_debug(
@@ -1985,7 +2613,7 @@ static int uninstall_evpn_route_entry_in
 
 	/* Locate route within the VRF. */
 	/* NOTE: There is no RD here. */
-	if (IS_EVPN_PREFIX_IPADDR_V4(evp)) {
+	if (is_evpn_prefix_ipaddr_v4(evp)) {
 		afi = AFI_IP;
 		safi = SAFI_UNICAST;
 		rn = bgp_node_lookup(bgp_vrf->rib[afi][safi], pp);
@@ -2059,6 +2687,22 @@ static int uninstall_evpn_route_entry(st
 }
 
 /*
+ * Given a prefix, see if it belongs to ES.
+ */
+static int is_prefix_matching_for_es(struct prefix_evpn *p,
+				     struct evpnes *es)
+{
+	/* if not an ES route return false */
+	if (p->prefix.route_type != BGP_EVPN_ES_ROUTE)
+		return 0;
+
+	if (memcmp(&p->prefix.es_addr.esi, &es->esi, sizeof(esi_t)) == 0)
+		return 1;
+
+	return 0;
+}
+
+/*
  * Given a route entry and a VRF, see if this route entry should be
  * imported into the VRF i.e., RTs match.
  */
@@ -2098,7 +2742,7 @@ static int is_route_matching_for_vrf(str
 
 		/* See if this RT matches specified VNIs import RTs */
 		irt = lookup_vrf_import_rt(eval);
-		if (irt && irt->vrfs)
+		if (irt)
 			if (is_vrf_present_in_irt_vrfs(irt->vrfs, bgp_vrf))
 				return 1;
 
@@ -2116,7 +2760,7 @@ static int is_route_matching_for_vrf(str
 			mask_ecom_global_admin(&eval_tmp, eval);
 			irt = lookup_vrf_import_rt(&eval_tmp);
 		}
-		if (irt && irt->vrfs)
+		if (irt)
 			if (is_vrf_present_in_irt_vrfs(irt->vrfs, bgp_vrf))
 				return 1;
 	}
@@ -2165,7 +2809,7 @@ static int is_route_matching_for_vni(str
 
 		/* See if this RT matches specified VNIs import RTs */
 		irt = lookup_import_rt(bgp, eval);
-		if (irt && irt->vnis)
+		if (irt)
 			if (is_vni_present_in_irt_vnis(irt->vnis, vpn))
 				return 1;
 
@@ -2183,7 +2827,7 @@ static int is_route_matching_for_vni(str
 			mask_ecom_global_admin(&eval_tmp, eval);
 			irt = lookup_import_rt(bgp, &eval_tmp);
 		}
-		if (irt && irt->vnis)
+		if (irt)
 			if (is_vni_present_in_irt_vnis(irt->vnis, vpn))
 				return 1;
 	}
@@ -2191,6 +2835,74 @@ static int is_route_matching_for_vni(str
 	return 0;
 }
 
+static int install_uninstall_routes_for_es(struct bgp *bgp,
+					   struct evpnes *es,
+					   int install)
+{
+	int ret;
+	afi_t afi;
+	safi_t safi;
+	char buf[PREFIX_STRLEN];
+	char buf1[ESI_STR_LEN];
+	struct bgp_node *rd_rn, *rn;
+	struct bgp_table *table;
+	struct bgp_info *ri;
+
+	afi = AFI_L2VPN;
+	safi = SAFI_EVPN;
+
+	/*
+	 * Walk entire global routing table and evaluate routes which could be
+	 * imported into this VRF. Note that we need to loop through all global
+	 * routes to determine which route matches the import rt on vrf
+	 */
+	for (rd_rn = bgp_table_top(bgp->rib[afi][safi]); rd_rn;
+	     rd_rn = bgp_route_next(rd_rn)) {
+		table = (struct bgp_table *)(rd_rn->info);
+		if (!table)
+			continue;
+
+		for (rn = bgp_table_top(table); rn; rn = bgp_route_next(rn)) {
+			struct prefix_evpn *evp = (struct prefix_evpn *)&rn->p;
+
+			for (ri = rn->info; ri; ri = ri->next) {
+				/*
+				 * Consider "valid" remote routes applicable for
+				 * this ES.
+				 */
+				if (!(CHECK_FLAG(ri->flags, BGP_INFO_VALID)
+				      && ri->type == ZEBRA_ROUTE_BGP
+				      && ri->sub_type == BGP_ROUTE_NORMAL))
+					continue;
+
+				if (!is_prefix_matching_for_es(evp, es))
+					continue;
+
+				if (install)
+					ret = install_evpn_route_entry_in_es(
+						bgp, es, evp, ri);
+				else
+					ret = uninstall_evpn_route_entry_in_es(
+						bgp, es, evp, ri);
+
+				if (ret) {
+					flog_err(
+						BGP_ERR_EVPN_FAIL,
+						"Failed to %s EVPN %s route in ESI %s",
+						install ? "install"
+							: "uninstall",
+						prefix2str(evp, buf,
+							   sizeof(buf)),
+						esi_to_str(&es->esi, buf1,
+							   sizeof(buf1)));
+					return ret;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
 /*
  * Install or uninstall mac-ip routes are appropriate for this
  * particular VRF.
@@ -2232,8 +2944,8 @@ static int install_uninstall_routes_for_
 				continue;
 
 			/* if not a mac+ip route skip this route */
-			if (!(IS_EVPN_PREFIX_IPADDR_V4(evp)
-			      || IS_EVPN_PREFIX_IPADDR_V6(evp)))
+			if (!(is_evpn_prefix_ipaddr_v4(evp)
+			      || is_evpn_prefix_ipaddr_v6(evp)))
 				continue;
 
 			for (ri = rn->info; ri; ri = ri->next) {
@@ -2254,7 +2966,8 @@ static int install_uninstall_routes_for_
 							bgp_vrf, evp, ri);
 
 					if (ret) {
-						zlog_err(
+						flog_err(
+							BGP_ERR_EVPN_FAIL,
 							"Failed to %s EVPN %s route in VRF %s",
 							install ? "install"
 								: "uninstall",
@@ -2327,7 +3040,8 @@ static int install_uninstall_routes_for_
 							bgp, vpn, evp, ri);
 
 					if (ret) {
-						zlog_err(
+						flog_err(
+							BGP_ERR_EVPN_FAIL,
 							"%u: Failed to %s EVPN %s route in VNI %u",
 							bgp->vrf_id,
 							install ? "install"
@@ -2346,6 +3060,15 @@ static int install_uninstall_routes_for_
 	return 0;
 }
 
+/* Install any existing remote ES routes applicable for this ES into its routing
+ * table. This is invoked when ES comes up.
+ */
+static int install_routes_for_es(struct bgp *bgp, struct evpnes *es)
+{
+	return install_uninstall_routes_for_es(bgp, es, 1);
+}
+
+
 /* Install any existing remote routes applicable for this VRF into VRF RIB. This
  * is invoked upon l3vni-add or l3vni import rt change
  */
@@ -2404,6 +3127,32 @@ static int uninstall_routes_for_vni(stru
 						0);
 }
 
+/* Install or unistall route in ES */
+static int install_uninstall_route_in_es(struct bgp *bgp, struct evpnes *es,
+					 afi_t afi, safi_t safi,
+					 struct prefix_evpn *evp,
+					 struct bgp_info *ri,
+					 int install)
+{
+	int ret = 0;
+	char buf[ESI_STR_LEN];
+
+	if (install)
+		ret = install_evpn_route_entry_in_es(bgp, es, evp, ri);
+	else
+		ret = uninstall_evpn_route_entry_in_es(bgp, es, evp, ri);
+
+	if (ret) {
+		flog_err(
+			BGP_ERR_EVPN_FAIL,
+			"%u: Failed to %s EVPN %s route in ESI %s", bgp->vrf_id,
+			install ? "install" : "uninstall", "ES",
+			esi_to_str(&evp->prefix.es_addr.esi, buf, sizeof(buf)));
+		return ret;
+	}
+	return 0;
+}
+
 /*
  * Install or uninstall route in matching VRFs (list).
  */
@@ -2423,8 +3172,8 @@ static int install_uninstall_route_in_vr
 
 	/* if it is type-2 route and not a mac+ip route skip this route */
 	if ((evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
-	    && !(IS_EVPN_PREFIX_IPADDR_V4(evp)
-		 || IS_EVPN_PREFIX_IPADDR_V6(evp)))
+	    && !(is_evpn_prefix_ipaddr_v4(evp)
+		 || is_evpn_prefix_ipaddr_v6(evp)))
 		return 0;
 
 	for (ALL_LIST_ELEMENTS(vrfs, node, nnode, bgp_vrf)) {
@@ -2437,11 +3186,12 @@ static int install_uninstall_route_in_vr
 								ri);
 
 		if (ret) {
-			zlog_err("%u: Failed to %s prefix %s in VRF %s",
-				 bgp_def->vrf_id,
-				 install ? "install" : "uninstall",
-				 prefix2str(evp, buf, sizeof(buf)),
-				 vrf_id_to_name(bgp_vrf->vrf_id));
+			flog_err(BGP_ERR_EVPN_FAIL,
+				  "%u: Failed to %s prefix %s in VRF %s",
+				  bgp_def->vrf_id,
+				  install ? "install" : "uninstall",
+				  prefix2str(evp, buf, sizeof(buf)),
+				  vrf_id_to_name(bgp_vrf->vrf_id));
 			return ret;
 		}
 	}
@@ -2472,12 +3222,14 @@ static int install_uninstall_route_in_vn
 			ret = uninstall_evpn_route_entry(bgp, vpn, evp, ri);
 
 		if (ret) {
-			zlog_err("%u: Failed to %s EVPN %s route in VNI %u",
-				 bgp->vrf_id, install ? "install" : "uninstall",
-				 evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE
-					 ? "MACIP"
-					 : "IMET",
-				 vpn->vni);
+			flog_err(
+				BGP_ERR_EVPN_FAIL,
+				"%u: Failed to %s EVPN %s route in VNI %u",
+				bgp->vrf_id, install ? "install" : "uninstall",
+				evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE
+					? "MACIP"
+					: "IMET",
+				vpn->vni);
 			return ret;
 		}
 	}
@@ -2486,7 +3238,7 @@ static int install_uninstall_route_in_vn
 }
 
 /*
- * Install or uninstall route for appropriate VNIs.
+ * Install or uninstall route for appropriate VNIs/ESIs.
  */
 static int install_uninstall_evpn_route(struct bgp *bgp, afi_t afi, safi_t safi,
 					struct prefix *p, struct bgp_info *ri,
@@ -2499,9 +3251,10 @@ static int install_uninstall_evpn_route(
 
 	assert(attr);
 
-	/* Only type-2 and type-3 and type-5 are supported currently */
+	/* Only type-2, type-3, type-4 and type-5 are supported currently */
 	if (!(evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE
 	      || evp->prefix.route_type == BGP_EVPN_IMET_ROUTE
+	      || evp->prefix.route_type == BGP_EVPN_ES_ROUTE
 	      || evp->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE))
 		return 0;
 
@@ -2513,9 +3266,8 @@ static int install_uninstall_evpn_route(
 	if (!ecom || !ecom->size)
 		return -1;
 
-	/* For each extended community RT, see which VNIs/VRFs match and import
-	 * the route into matching VNIs/VRFs.
-	 */
+	/* An EVPN route belongs to a VNI or a VRF or an ESI based on the RTs
+	 * attached to the route */
 	for (i = 0; i < ecom->size; i++) {
 		uint8_t *pnt;
 		uint8_t type, sub_type;
@@ -2523,6 +3275,7 @@ static int install_uninstall_evpn_route(
 		struct ecommunity_val eval_tmp;
 		struct irt_node *irt;	 /* import rt for l2vni */
 		struct vrf_irt_node *vrf_irt; /* import rt for l3vni */
+		struct evpnes *es;
 
 		/* Only deal with RTs */
 		pnt = (ecom->val + (i * ECOMMUNITY_SIZE));
@@ -2533,51 +3286,79 @@ static int install_uninstall_evpn_route(
 		if (sub_type != ECOMMUNITY_ROUTE_TARGET)
 			continue;
 
-		/* Import route into matching l2-vnis (type-2/type-3 routes go
-		 * into l2vni table)
+		/*
+		 * macip routes (type-2) are imported into VNI and VRF tables.
+		 * IMET route is imported into VNI table.
+		 * prefix routes are imported into VRF table.
 		 */
-		irt = lookup_import_rt(bgp, eval);
-		if (irt && irt->vnis)
-			install_uninstall_route_in_vnis(bgp, afi, safi, evp, ri,
-							irt->vnis, import);
+		if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE ||
+		    evp->prefix.route_type == BGP_EVPN_IMET_ROUTE ||
+		    evp->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE) {
 
-		/* Import route into matching l3-vnis (type-2/type-5 routes go
-		 * into l3vni/vrf table)
-		 */
-		vrf_irt = lookup_vrf_import_rt(eval);
-		if (vrf_irt && vrf_irt->vrfs)
-			install_uninstall_route_in_vrfs(bgp, afi, safi, evp, ri,
-							vrf_irt->vrfs, import);
-
-		/* Also check for non-exact match. In this,
-		 *  we mask out the AS and
-		 * only check on the local-admin sub-field.
-		 * This is to facilitate using
-		 * VNI as the RT for EBGP peering too.
-		 */
-		irt = NULL;
-		vrf_irt = NULL;
-		if (type == ECOMMUNITY_ENCODE_AS
-		    || type == ECOMMUNITY_ENCODE_AS4
-		    || type == ECOMMUNITY_ENCODE_IP) {
-			memcpy(&eval_tmp, eval, ECOMMUNITY_SIZE);
-			mask_ecom_global_admin(&eval_tmp, eval);
-			irt = lookup_import_rt(bgp, &eval_tmp);
-			vrf_irt = lookup_vrf_import_rt(&eval_tmp);
+			irt = lookup_import_rt(bgp, eval);
+			if (irt)
+				install_uninstall_route_in_vnis(bgp, afi, safi,
+								evp, ri,
+								irt->vnis,
+								import);
+
+			vrf_irt = lookup_vrf_import_rt(eval);
+			if (vrf_irt)
+				install_uninstall_route_in_vrfs(bgp, afi, safi,
+								evp, ri,
+								vrf_irt->vrfs,
+								import);
+
+			/* Also check for non-exact match.
+			 * In this, we mask out the AS and
+			 * only check on the local-admin sub-field.
+			 * This is to facilitate using
+			 * VNI as the RT for EBGP peering too.
+			 */
+			irt = NULL;
+			vrf_irt = NULL;
+			if (type == ECOMMUNITY_ENCODE_AS
+			    || type == ECOMMUNITY_ENCODE_AS4
+			    || type == ECOMMUNITY_ENCODE_IP) {
+				memcpy(&eval_tmp, eval, ECOMMUNITY_SIZE);
+				mask_ecom_global_admin(&eval_tmp, eval);
+				irt = lookup_import_rt(bgp, &eval_tmp);
+				vrf_irt = lookup_vrf_import_rt(&eval_tmp);
+			}
+
+			if (irt)
+				install_uninstall_route_in_vnis(bgp, afi, safi,
+								evp, ri,
+								irt->vnis,
+								import);
+			if (vrf_irt)
+				install_uninstall_route_in_vrfs(bgp, afi, safi,
+								evp, ri,
+								vrf_irt->vrfs,
+								import);
+		}
+
+		/* es route is imported into the es table */
+		if (evp->prefix.route_type == BGP_EVPN_ES_ROUTE) {
+
+			/* we will match based on the entire esi to avoid
+			 * imoort of an es route for esi2 into esi1
+			 */
+			es = bgp_evpn_lookup_es(bgp, &evp->prefix.es_addr.esi);
+			if (es && is_es_local(es))
+				install_uninstall_route_in_es(bgp, es,
+							      afi, safi,
+							      evp, ri, import);
 		}
-		if (irt && irt->vnis)
-			install_uninstall_route_in_vnis(bgp, afi, safi, evp, ri,
-							irt->vnis, import);
-		if (vrf_irt && vrf_irt->vrfs)
-			install_uninstall_route_in_vrfs(bgp, afi, safi, evp, ri,
-							vrf_irt->vrfs, import);
 	}
 
 	return 0;
 }
 
-/* delete and withdraw all ipv4 and ipv6 routes in the vrf table as type-5
- * routes */
+/*
+ * delete and withdraw all ipv4 and ipv6 routes in the vrf table as type-5
+ * routes
+ */
 static void delete_withdraw_vrf_routes(struct bgp *bgp_vrf)
 {
 	/* delete all ipv4 routes and withdraw from peers */
@@ -2589,8 +3370,10 @@ static void delete_withdraw_vrf_routes(s
 		bgp_evpn_withdraw_type5_routes(bgp_vrf, AFI_IP6, SAFI_UNICAST);
 }
 
-/* update and advertise all ipv4 and ipv6 routes in thr vrf table as type-5
- * routes */
+/*
+ * update and advertise all ipv4 and ipv6 routes in thr vrf table as type-5
+ * routes
+ */
 static void update_advertise_vrf_routes(struct bgp *bgp_vrf)
 {
 	/* update all ipv4 routes */
@@ -2738,7 +3521,7 @@ static int delete_withdraw_vni_routes(st
 					(struct prefix *)&p, &vpn->prd);
 	if (global_rn) {
 		/* Delete route entry in the global EVPN table. */
-		delete_evpn_route_entry(bgp, vpn, afi, safi, global_rn, &ri);
+		delete_evpn_route_entry(bgp, afi, safi, global_rn, &ri);
 
 		/* Schedule for processing - withdraws to peers happen from
 		 * this table.
@@ -2759,14 +3542,7 @@ static int delete_withdraw_vni_routes(st
  */
 static void update_router_id_vni(struct hash_backet *backet, struct bgp *bgp)
 {
-	struct bgpevpn *vpn;
-
-	vpn = (struct bgpevpn *)backet->data;
-
-	if (!vpn) {
-		zlog_warn("%s: VNI hash entry for VNI not found", __FUNCTION__);
-		return;
-	}
+	struct bgpevpn *vpn = (struct bgpevpn *)backet->data;
 
 	/* Skip VNIs with configured RD. */
 	if (is_rd_configured(vpn))
@@ -2784,14 +3560,7 @@ static void update_router_id_vni(struct
  */
 static void withdraw_router_id_vni(struct hash_backet *backet, struct bgp *bgp)
 {
-	struct bgpevpn *vpn;
-
-	vpn = (struct bgpevpn *)backet->data;
-
-	if (!vpn) {
-		zlog_warn("%s: VNI hash entry for VNI not found", __FUNCTION__);
-		return;
-	}
+	struct bgpevpn *vpn = (struct bgpevpn *)backet->data;
 
 	/* Skip VNIs with configured RD. */
 	if (is_rd_configured(vpn))
@@ -2825,8 +3594,9 @@ static int process_type2_route(struct pe
 	 */
 	if (psize != 33 && psize != 37 && psize != 49 && psize != 36
 	    && psize != 40 && psize != 52) {
-		zlog_err("%u:%s - Rx EVPN Type-2 NLRI with invalid length %d",
-			 peer->bgp->vrf_id, peer->host, psize);
+		flog_err(BGP_ERR_EVPN_ROUTE_INVALID,
+			  "%u:%s - Rx EVPN Type-2 NLRI with invalid length %d",
+			  peer->bgp->vrf_id, peer->host, psize);
 		return -1;
 	}
 
@@ -2841,7 +3611,7 @@ static int process_type2_route(struct pe
 	/* Make EVPN prefix. */
 	memset(&p, 0, sizeof(struct prefix_evpn));
 	p.family = AF_EVPN;
-	p.prefixlen = EVPN_TYPE_2_ROUTE_PREFIXLEN;
+	p.prefixlen = EVPN_ROUTE_PREFIXLEN;
 	p.prefix.route_type = BGP_EVPN_MAC_IP_ROUTE;
 
 	/* Copy Ethernet Seg Identifier */
@@ -2850,7 +3620,7 @@ static int process_type2_route(struct pe
 
 	/* Copy Ethernet Tag */
 	memcpy(&eth_tag, pfx, 4);
-	p.prefix.eth_tag = ntohl(eth_tag);
+	p.prefix.macip_addr.eth_tag = ntohl(eth_tag);
 	pfx += 4;
 
 	/* Get the MAC Addr len */
@@ -2858,10 +3628,11 @@ static int process_type2_route(struct pe
 
 	/* Get the MAC Addr */
 	if (macaddr_len == (ETH_ALEN * 8)) {
-		memcpy(&p.prefix.mac.octet, pfx, ETH_ALEN);
+		memcpy(&p.prefix.macip_addr.mac.octet, pfx, ETH_ALEN);
 		pfx += ETH_ALEN;
 	} else {
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_INVALID,
 			"%u:%s - Rx EVPN Type-2 NLRI with unsupported MAC address length %d",
 			peer->bgp->vrf_id, peer->host, macaddr_len);
 		return -1;
@@ -2872,7 +3643,8 @@ static int process_type2_route(struct pe
 	ipaddr_len = *pfx++;
 	if (ipaddr_len != 0 && ipaddr_len != IPV4_MAX_BITLEN
 	    && ipaddr_len != IPV6_MAX_BITLEN) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_INVALID,
 			"%u:%s - Rx EVPN Type-2 NLRI with unsupported IP address length %d",
 			peer->bgp->vrf_id, peer->host, ipaddr_len);
 		return -1;
@@ -2880,10 +3652,10 @@ static int process_type2_route(struct pe
 
 	if (ipaddr_len) {
 		ipaddr_len /= 8; /* Convert to bytes. */
-		p.prefix.ip.ipa_type = (ipaddr_len == IPV4_MAX_BYTELEN)
+		p.prefix.macip_addr.ip.ipa_type = (ipaddr_len == IPV4_MAX_BYTELEN)
 					       ? IPADDR_V4
 					       : IPADDR_V6;
-		memcpy(&p.prefix.ip.ip.addr, pfx, ipaddr_len);
+		memcpy(&p.prefix.macip_addr.ip.ip.addr, pfx, ipaddr_len);
 	}
 	pfx += ipaddr_len;
 
@@ -2933,8 +3705,9 @@ static int process_type3_route(struct pe
 	 * IP len (1) and IP (4 or 16).
 	 */
 	if (psize != 17 && psize != 29) {
-		zlog_err("%u:%s - Rx EVPN Type-3 NLRI with invalid length %d",
-			 peer->bgp->vrf_id, peer->host, psize);
+		flog_err(BGP_ERR_EVPN_ROUTE_INVALID,
+			  "%u:%s - Rx EVPN Type-3 NLRI with invalid length %d",
+			  peer->bgp->vrf_id, peer->host, psize);
 		return -1;
 	}
 
@@ -2960,21 +3733,22 @@ static int process_type3_route(struct pe
 	/* Make EVPN prefix. */
 	memset(&p, 0, sizeof(struct prefix_evpn));
 	p.family = AF_EVPN;
-	p.prefixlen = EVPN_TYPE_3_ROUTE_PREFIXLEN;
+	p.prefixlen = EVPN_ROUTE_PREFIXLEN;
 	p.prefix.route_type = BGP_EVPN_IMET_ROUTE;
 
 	/* Copy Ethernet Tag */
 	memcpy(&eth_tag, pfx, 4);
-	p.prefix.eth_tag = ntohl(eth_tag);
+	p.prefix.imet_addr.eth_tag = ntohl(eth_tag);
 	pfx += 4;
 
 	/* Get the IP. */
 	ipaddr_len = *pfx++;
 	if (ipaddr_len == IPV4_MAX_BITLEN) {
-		p.prefix.ip.ipa_type = IPADDR_V4;
-		memcpy(&p.prefix.ip.ip.addr, pfx, IPV4_MAX_BYTELEN);
+		p.prefix.imet_addr.ip.ipa_type = IPADDR_V4;
+		memcpy(&p.prefix.imet_addr.ip.ip.addr, pfx, IPV4_MAX_BYTELEN);
 	} else {
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_INVALID,
 			"%u:%s - Rx EVPN Type-3 NLRI with unsupported IP address length %d",
 			peer->bgp->vrf_id, peer->host, ipaddr_len);
 		return -1;
@@ -2993,6 +3767,68 @@ static int process_type3_route(struct pe
 }
 
 /*
+ * Process received EVPN type-4 route (advertise or withdraw).
+ */
+static int process_type4_route(struct peer *peer, afi_t afi, safi_t safi,
+			       struct attr *attr, uint8_t *pfx, int psize,
+			       uint32_t addpath_id)
+{
+	int ret;
+	esi_t esi;
+	uint8_t ipaddr_len;
+	struct in_addr vtep_ip;
+	struct prefix_rd prd;
+	struct prefix_evpn p;
+
+	/* Type-4 route should be either 23 or 35 bytes
+	 *  RD (8), ESI (10), ip-len (1), ip (4 or 16)
+	 */
+	if (psize != 23 && psize != 35) {
+		flog_err(BGP_ERR_EVPN_ROUTE_INVALID,
+			  "%u:%s - Rx EVPN Type-4 NLRI with invalid length %d",
+			  peer->bgp->vrf_id, peer->host, psize);
+		return -1;
+	}
+
+	/* Make prefix_rd */
+	prd.family = AF_UNSPEC;
+	prd.prefixlen = 64;
+	memcpy(&prd.val, pfx, 8);
+	pfx += 8;
+
+	/* get the ESI */
+	memcpy(&esi, pfx, ESI_BYTES);
+	pfx += ESI_BYTES;
+
+
+	/* Get the IP. */
+	ipaddr_len = *pfx++;
+	if (ipaddr_len == IPV4_MAX_BITLEN) {
+		memcpy(&vtep_ip, pfx, IPV4_MAX_BYTELEN);
+	} else {
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_INVALID,
+			"%u:%s - Rx EVPN Type-4 NLRI with unsupported IP address length %d",
+			peer->bgp->vrf_id, peer->host, ipaddr_len);
+		return -1;
+	}
+
+	build_evpn_type4_prefix(&p, &esi, vtep_ip);
+	/* Process the route. */
+	if (attr) {
+		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
+				 afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
+				 &prd, NULL, 0, 0, NULL);
+	} else {
+		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
+				   afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
+				   &prd, NULL, 0, NULL);
+	}
+	return ret;
+}
+
+
+/*
  * Process received EVPN type-5 route (advertise or withdraw).
  */
 static int process_type5_route(struct peer *peer, afi_t afi, safi_t safi,
@@ -3013,8 +3849,9 @@ static int process_type5_route(struct pe
 	 * Note that the IP and GW should both be IPv4 or both IPv6.
 	 */
 	if (psize != 34 && psize != 58) {
-		zlog_err("%u:%s - Rx EVPN Type-5 NLRI with invalid length %d",
-			 peer->bgp->vrf_id, peer->host, psize);
+		flog_err(BGP_ERR_EVPN_ROUTE_INVALID,
+			  "%u:%s - Rx EVPN Type-5 NLRI with invalid length %d",
+			  peer->bgp->vrf_id, peer->host, psize);
 		return -1;
 	}
 
@@ -3027,7 +3864,7 @@ static int process_type5_route(struct pe
 	/* Make EVPN prefix. */
 	memset(&p, 0, sizeof(struct prefix_evpn));
 	p.family = AF_EVPN;
-	p.prefixlen = EVPN_TYPE_5_ROUTE_PREFIXLEN;
+	p.prefixlen = EVPN_ROUTE_PREFIXLEN;
 	p.prefix.route_type = BGP_EVPN_IP_PREFIX_ROUTE;
 
 	/* Additional information outside of prefix - ESI and GW IP */
@@ -3039,32 +3876,33 @@ static int process_type5_route(struct pe
 
 	/* Fetch Ethernet Tag. */
 	memcpy(&eth_tag, pfx, 4);
-	p.prefix.eth_tag = ntohl(eth_tag);
+	p.prefix.prefix_addr.eth_tag = ntohl(eth_tag);
 	pfx += 4;
 
 	/* Fetch IP prefix length. */
 	ippfx_len = *pfx++;
 	if (ippfx_len > IPV6_MAX_BITLEN) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_INVALID,
 			"%u:%s - Rx EVPN Type-5 NLRI with invalid IP Prefix length %d",
 			peer->bgp->vrf_id, peer->host, ippfx_len);
 		return -1;
 	}
-	p.prefix.ip_prefix_length = ippfx_len;
+	p.prefix.prefix_addr.ip_prefix_length = ippfx_len;
 
 	/* Determine IPv4 or IPv6 prefix */
 	/* Since the address and GW are from the same family, this just becomes
 	 * a simple check on the total size.
 	 */
 	if (psize == 34) {
-		SET_IPADDR_V4(&p.prefix.ip);
-		memcpy(&p.prefix.ip.ipaddr_v4, pfx, 4);
+		SET_IPADDR_V4(&p.prefix.prefix_addr.ip);
+		memcpy(&p.prefix.prefix_addr.ip.ipaddr_v4, pfx, 4);
 		pfx += 4;
 		memcpy(&evpn.gw_ip.ipv4, pfx, 4);
 		pfx += 4;
 	} else {
-		SET_IPADDR_V6(&p.prefix.ip);
-		memcpy(&p.prefix.ip.ipaddr_v6, pfx, 16);
+		SET_IPADDR_V6(&p.prefix.prefix_addr.ip);
+		memcpy(&p.prefix.prefix_addr.ip.ipaddr_v6, pfx, 16);
 		pfx += 16;
 		memcpy(&evpn.gw_ip.ipv6, pfx, 16);
 		pfx += 16;
@@ -3109,7 +3947,7 @@ static void evpn_mpattr_encode_type5(str
 	/* len denites the total len of IP and GW-IP in the route
 	   IP and GW-IP have to be both ipv4 or ipv6
 	 */
-	if (IS_IPADDR_V4(&p_evpn_p->ip))
+	if (IS_IPADDR_V4(&p_evpn_p->prefix_addr.ip))
 		len = 8; /* IP and GWIP are both ipv4 */
 	else
 		len = 32; /* IP and GWIP are both ipv6 */
@@ -3120,20 +3958,20 @@ static void evpn_mpattr_encode_type5(str
 		stream_put(s, &(attr->evpn_overlay.eth_s_id), 10);
 	else
 		stream_put(s, &temp, 10);
-	stream_putl(s, p_evpn_p->eth_tag);
-	stream_putc(s, p_evpn_p->ip_prefix_length);
-	if (IS_IPADDR_V4(&p_evpn_p->ip))
-		stream_put_ipv4(s, p_evpn_p->ip.ipaddr_v4.s_addr);
+	stream_putl(s, p_evpn_p->prefix_addr.eth_tag);
+	stream_putc(s, p_evpn_p->prefix_addr.ip_prefix_length);
+	if (IS_IPADDR_V4(&p_evpn_p->prefix_addr.ip))
+		stream_put_ipv4(s, p_evpn_p->prefix_addr.ip.ipaddr_v4.s_addr);
 	else
-		stream_put(s, &p_evpn_p->ip.ipaddr_v6, 16);
+		stream_put(s, &p_evpn_p->prefix_addr.ip.ipaddr_v6, 16);
 	if (attr) {
-		if (IS_IPADDR_V4(&p_evpn_p->ip))
+		if (IS_IPADDR_V4(&p_evpn_p->prefix_addr.ip))
 			stream_put_ipv4(s,
 					attr->evpn_overlay.gw_ip.ipv4.s_addr);
 		else
 			stream_put(s, &(attr->evpn_overlay.gw_ip.ipv6), 16);
 	} else {
-		if (IS_IPADDR_V4(&p_evpn_p->ip))
+		if (IS_IPADDR_V4(&p_evpn_p->prefix_addr.ip))
 			stream_put_ipv4(s, 0);
 		else
 			stream_put(s, &temp, 16);
@@ -3166,9 +4004,8 @@ static void cleanup_vni_on_disable(struc
  */
 static void free_vni_entry(struct hash_backet *backet, struct bgp *bgp)
 {
-	struct bgpevpn *vpn;
+	struct bgpevpn *vpn = (struct bgpevpn *)backet->data;
 
-	vpn = (struct bgpevpn *)backet->data;
 	delete_all_vni_routes(bgp, vpn);
 	bgp_evpn_free(bgp, vpn);
 }
@@ -3234,6 +4071,30 @@ static void bgp_evpn_handle_export_rt_ch
 }
 
 /*
+ * Handle autort change for a given VNI.
+ */
+static void update_autort_vni(struct hash_backet *backet, struct bgp *bgp)
+{
+	struct bgpevpn *vpn = backet->data;
+
+	if (!is_import_rt_configured(vpn)) {
+		if (is_vni_live(vpn))
+			bgp_evpn_uninstall_routes(bgp, vpn);
+		bgp_evpn_unmap_vni_from_its_rts(bgp, vpn);
+		list_delete_all_node(vpn->import_rtl);
+		bgp_evpn_derive_auto_rt_import(bgp, vpn);
+		if (is_vni_live(vpn))
+			bgp_evpn_install_routes(bgp, vpn);
+	}
+	if (!is_export_rt_configured(vpn)) {
+		list_delete_all_node(vpn->export_rtl);
+		bgp_evpn_derive_auto_rt_export(bgp, vpn);
+		if (is_vni_live(vpn))
+			bgp_evpn_handle_export_rt_change(bgp, vpn);
+	}
+}
+
+/*
  * Public functions.
  */
 
@@ -3248,7 +4109,8 @@ void bgp_evpn_withdraw_type5_route(struc
 	build_type5_prefix_from_ip_prefix(&evp, p);
 	ret = delete_evpn_type5_route(bgp_vrf, &evp);
 	if (ret) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_DELETE,
 			"%u failed to delete type-5 route for prefix %s in vrf %s",
 			bgp_vrf->vrf_id, prefix2str(p, buf, sizeof(buf)),
 			vrf_id_to_name(bgp_vrf->vrf_id));
@@ -3290,12 +4152,13 @@ void bgp_evpn_advertise_type5_route(stru
 	int ret = 0;
 	struct prefix_evpn evp;
 	char buf[PREFIX_STRLEN];
-  
+
 	build_type5_prefix_from_ip_prefix(&evp, p);
 	ret = update_evpn_type5_route(bgp_vrf, &evp, src_attr);
 	if (ret)
-		zlog_err("%u: Failed to create type-5 route for prefix %s",
-			 bgp_vrf->vrf_id, prefix2str(p, buf, sizeof(buf)));
+		flog_err(BGP_ERR_EVPN_ROUTE_CREATE,
+			  "%u: Failed to create type-5 route for prefix %s",
+			  bgp_vrf->vrf_id, prefix2str(p, buf, sizeof(buf)));
 }
 
 /* Inject all prefixes of a particular address-family (currently, IPv4 or
@@ -3344,6 +4207,8 @@ void evpn_rt_delete_auto(struct bgp *bgp
 	struct ecommunity *ecom, *ecom_auto;
 	struct ecommunity_val eval;
 
+	if (bgp->advertise_autort_rfc8365)
+		vni |= EVPN_AUTORT_VXLAN;
 	encode_route_target_as((bgp->as & 0xFFFF), vni, &eval);
 
 	ecom_auto = ecommunity_new();
@@ -3410,8 +4275,9 @@ void bgp_evpn_unconfigure_import_rt_for_
 	if (node_to_del)
 		list_delete_node(bgp_vrf->vrf_import_rtl, node_to_del);
 
+	assert(bgp_vrf->vrf_import_rtl);
 	/* fallback to auto import rt, if this was the last RT */
-	if (list_isempty(bgp_vrf->vrf_import_rtl)) {
+	if (bgp_vrf->vrf_import_rtl && list_isempty(bgp_vrf->vrf_import_rtl)) {
 		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD);
 		evpn_auto_rt_import_add_for_vrf(bgp_vrf);
 	}
@@ -3454,8 +4320,18 @@ void bgp_evpn_unconfigure_export_rt_for_
 	if (node_to_del)
 		list_delete_node(bgp_vrf->vrf_export_rtl, node_to_del);
 
+	/*
+	 * Temporary assert to make SA happy.
+	 * The ALL_LIST_ELEMENTS macro above has a NULL check
+	 * which means that SA is going to complain about
+	 * the list_isempty call, which doesn't NULL check.
+	 * So until we get this situation cleaned up, here
+	 * we are.
+	 */
+	assert(bgp_vrf->vrf_export_rtl);
+
 	/* fall back to auto-generated RT if this was the last RT */
-	if (bgp_vrf->vrf_export_rtl && list_isempty(bgp_vrf->vrf_export_rtl)) {
+	if (list_isempty(bgp_vrf->vrf_export_rtl)) {
 		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD);
 		evpn_auto_rt_export_add_for_vrf(bgp_vrf);
 	}
@@ -3504,6 +4380,17 @@ void bgp_evpn_handle_router_id_update(st
 }
 
 /*
+ * Handle change to auto-RT algorithm - update and advertise local routes.
+ */
+void bgp_evpn_handle_autort_change(struct bgp *bgp)
+{
+	hash_iterate(bgp->vnihash,
+		     (void (*)(struct hash_backet *,
+			       void*))update_autort_vni,
+		     bgp);
+}
+
+/*
  * Handle change to export RT - update and advertise local routes.
  */
 int bgp_evpn_handle_export_rt_change(struct bgp *bgp, struct bgpevpn *vpn)
@@ -3583,44 +4470,49 @@ void bgp_evpn_route2json(struct prefix_e
 
 	if (p->prefix.route_type == BGP_EVPN_IMET_ROUTE) {
 		json_object_int_add(json, "routeType", p->prefix.route_type);
-		json_object_int_add(json, "ethTag", p->prefix.eth_tag);
+		json_object_int_add(json, "ethTag",
+				    p->prefix.imet_addr.eth_tag);
 		json_object_int_add(json, "ipLen",
-				    IS_EVPN_PREFIX_IPADDR_V4(p)
+				    is_evpn_prefix_ipaddr_v4(p)
 					    ? IPV4_MAX_BITLEN
 					    : IPV6_MAX_BITLEN);
 		json_object_string_add(json, "ip",
-				       inet_ntoa(p->prefix.ip.ipaddr_v4));
+				       inet_ntoa(p->prefix.imet_addr.ip.ipaddr_v4));
 	} else if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
-		if (IS_EVPN_PREFIX_IPADDR_NONE(p)) {
+		if (is_evpn_prefix_ipaddr_none(p)) {
 			json_object_int_add(json, "routeType",
 					    p->prefix.route_type);
-			json_object_int_add(json, "ethTag", p->prefix.eth_tag);
+			json_object_int_add(json, "ethTag",
+					    p->prefix.macip_addr.eth_tag);
 			json_object_int_add(json, "macLen", 8 * ETH_ALEN);
 			json_object_string_add(json, "mac",
-					       prefix_mac2str(&p->prefix.mac,
+					       prefix_mac2str(&p->prefix.macip_addr.mac,
 							      buf1,
 							      sizeof(buf1)));
 		} else {
 			uint8_t family;
 
-			family = IS_EVPN_PREFIX_IPADDR_V4(p) ? AF_INET
+			family = is_evpn_prefix_ipaddr_v4(p) ? AF_INET
 							     : AF_INET6;
 
 			json_object_int_add(json, "routeType",
 					    p->prefix.route_type);
-			json_object_int_add(json, "ethTag", p->prefix.eth_tag);
+			json_object_int_add(json, "ethTag",
+					    p->prefix.macip_addr.eth_tag);
 			json_object_int_add(json, "macLen", 8 * ETH_ALEN);
 			json_object_string_add(json, "mac",
-					       prefix_mac2str(&p->prefix.mac,
+					       prefix_mac2str(&p->prefix.macip_addr.mac,
 							      buf1,
 							      sizeof(buf1)));
 			json_object_int_add(json, "ipLen",
-					    IS_EVPN_PREFIX_IPADDR_V4(p)
+					    is_evpn_prefix_ipaddr_v4(p)
 						    ? IPV4_MAX_BITLEN
 						    : IPV6_MAX_BITLEN);
 			json_object_string_add(
 				json, "ip",
-				inet_ntop(family, &p->prefix.ip.ip.addr, buf2,
+				inet_ntop(family,
+					  &p->prefix.macip_addr.ip.ip.addr,
+					  buf2,
 					  PREFIX2STR_BUFFER));
 		}
 	} else {
@@ -3636,45 +4528,55 @@ char *bgp_evpn_route2str(struct prefix_e
 {
 	char buf1[ETHER_ADDR_STRLEN];
 	char buf2[PREFIX2STR_BUFFER];
+	char buf3[ESI_STR_LEN];
 
 	if (p->prefix.route_type == BGP_EVPN_IMET_ROUTE) {
 		snprintf(buf, len, "[%d]:[%d]:[%d]:[%s]", p->prefix.route_type,
-			 p->prefix.eth_tag,
-			 IS_EVPN_PREFIX_IPADDR_V4(p) ? IPV4_MAX_BITLEN
+			 p->prefix.imet_addr.eth_tag,
+			 is_evpn_prefix_ipaddr_v4(p) ? IPV4_MAX_BITLEN
 						     : IPV6_MAX_BITLEN,
-			 inet_ntoa(p->prefix.ip.ipaddr_v4));
+			 inet_ntoa(p->prefix.imet_addr.ip.ipaddr_v4));
 	} else if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
-		if (IS_EVPN_PREFIX_IPADDR_NONE(p))
+		if (is_evpn_prefix_ipaddr_none(p))
 			snprintf(buf, len, "[%d]:[%d]:[%d]:[%s]",
 				 p->prefix.route_type,
-				 p->prefix.eth_tag,
+				 p->prefix.macip_addr.eth_tag,
 				 8 * ETH_ALEN,
-				 prefix_mac2str(&p->prefix.mac, buf1,
+				 prefix_mac2str(&p->prefix.macip_addr.mac, buf1,
 						sizeof(buf1)));
 		else {
 			uint8_t family;
 
-			family = IS_EVPN_PREFIX_IPADDR_V4(p) ? AF_INET
+			family = is_evpn_prefix_ipaddr_v4(p) ? AF_INET
 							     : AF_INET6;
 			snprintf(buf, len, "[%d]:[%d]:[%d]:[%s]:[%d]:[%s]",
 				 p->prefix.route_type,
-				 p->prefix.eth_tag,
+				 p->prefix.macip_addr.eth_tag,
 				 8 * ETH_ALEN,
-				 prefix_mac2str(&p->prefix.mac, buf1,
+				 prefix_mac2str(&p->prefix.macip_addr.mac, buf1,
 						sizeof(buf1)),
 				 family == AF_INET ? IPV4_MAX_BITLEN
 						   : IPV6_MAX_BITLEN,
-				 inet_ntop(family, &p->prefix.ip.ip.addr, buf2,
+				 inet_ntop(family,
+					   &p->prefix.macip_addr.ip.ip.addr,
+					   buf2,
 					   PREFIX2STR_BUFFER));
 		}
 	} else if (p->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE) {
 		snprintf(buf, len, "[%d]:[%d]:[%d]:[%s]",
 			 p->prefix.route_type,
-			 p->prefix.eth_tag,
-			 p->prefix.ip_prefix_length,
-			 IS_EVPN_PREFIX_IPADDR_V4(p)
-				 ? inet_ntoa(p->prefix.ip.ipaddr_v4)
-				 : inet6_ntoa(p->prefix.ip.ipaddr_v6));
+			 p->prefix.prefix_addr.eth_tag,
+			 p->prefix.prefix_addr.ip_prefix_length,
+			 is_evpn_prefix_ipaddr_v4(p)
+				 ? inet_ntoa(p->prefix.prefix_addr.ip.ipaddr_v4)
+				 : inet6_ntoa(p->prefix.prefix_addr.ip.ipaddr_v6));
+	} else if (p->prefix.route_type == BGP_EVPN_ES_ROUTE) {
+		snprintf(buf, len, "[%d]:[%s]:[%d]:[%s]",
+			 p->prefix.route_type,
+			 esi_to_str(&p->prefix.es_addr.esi, buf3, sizeof(buf3)),
+			 is_evpn_prefix_ipaddr_v4(p) ? IPV4_MAX_BITLEN
+						     : IPV6_MAX_BITLEN,
+			 inet_ntoa(p->prefix.es_addr.ip.ipaddr_v4));
 	} else {
 		/* For EVPN route types not supported yet. */
 		snprintf(buf, len, "(unsupported route type %d)",
@@ -3703,9 +4605,9 @@ void bgp_evpn_encode_prefix(struct strea
 
 	switch (evp->prefix.route_type) {
 	case BGP_EVPN_MAC_IP_ROUTE:
-		if (IS_EVPN_PREFIX_IPADDR_V4(evp))
+		if (is_evpn_prefix_ipaddr_v4(evp))
 			ipa_len = IPV4_MAX_BYTELEN;
-		else if (IS_EVPN_PREFIX_IPADDR_V6(evp))
+		else if (is_evpn_prefix_ipaddr_v6(evp))
 			ipa_len = IPV6_MAX_BYTELEN;
 		/* RD, ESI, EthTag, MAC+len, IP len, [IP], 1 VNI */
 		len = 8 + 10 + 4 + 1 + 6 + 1 + ipa_len + 3;
@@ -3717,12 +4619,13 @@ void bgp_evpn_encode_prefix(struct strea
 			stream_put(s, &attr->evpn_overlay.eth_s_id, ESI_LEN);
 		else
 			stream_put(s, 0, 10);
-		stream_putl(s, evp->prefix.eth_tag);	    /* Ethernet Tag ID */
+		stream_putl(s, evp->prefix.macip_addr.eth_tag);	/* Ethernet Tag ID */
 		stream_putc(s, 8 * ETH_ALEN); /* Mac Addr Len - bits */
-		stream_put(s, evp->prefix.mac.octet, 6); /* Mac Addr */
-		stream_putc(s, 8 * ipa_len);		 /* IP address Length */
-		if (ipa_len)				 /* IP */
-			stream_put(s, &evp->prefix.ip.ip.addr, ipa_len);
+		stream_put(s, evp->prefix.macip_addr.mac.octet, 6); /* Mac Addr */
+		stream_putc(s, 8 * ipa_len); /* IP address Length */
+		if (ipa_len) /* IP */
+			stream_put(s, &evp->prefix.macip_addr.ip.ip.addr,
+				   ipa_len);
 		/* 1st label is the L2 VNI */
 		stream_put(s, label, BGP_LABEL_BYTES);
 		/* Include 2nd label (L3 VNI) if advertising MAC+IP */
@@ -3733,10 +4636,19 @@ void bgp_evpn_encode_prefix(struct strea
 	case BGP_EVPN_IMET_ROUTE:
 		stream_putc(s, 17); // TODO: length - assumes IPv4 address
 		stream_put(s, prd->val, 8);      /* RD */
-		stream_putl(s, evp->prefix.eth_tag);		 /* Ethernet Tag ID */
+		stream_putl(s, evp->prefix.imet_addr.eth_tag); /* Ethernet Tag ID */
 		stream_putc(s, IPV4_MAX_BITLEN); /* IP address Length - bits */
 		/* Originating Router's IP Addr */
-		stream_put_in_addr(s, &evp->prefix.ip.ipaddr_v4);
+		stream_put_in_addr(s, &evp->prefix.imet_addr.ip.ipaddr_v4);
+		break;
+
+	case BGP_EVPN_ES_ROUTE:
+		stream_putc(s, 23); /* TODO: length: assumes ipv4 VTEP */
+		stream_put(s, prd->val, 8); /* RD */
+		stream_put(s, evp->prefix.es_addr.esi.val, 10); /* ESI */
+		stream_putc(s, IPV4_MAX_BITLEN); /* IP address Length - bits */
+		/* VTEP IP */
+		stream_put_in_addr(s, &evp->prefix.es_addr.ip.ipaddr_v4);
 		break;
 
 	case BGP_EVPN_IP_PREFIX_ROUTE:
@@ -3760,7 +4672,6 @@ int bgp_nlri_parse_evpn(struct peer *pee
 	int addpath_encoded;
 	int psize = 0;
 	uint8_t rtype;
-	uint8_t rlen;
 	struct prefix p;
 
 	/* Start processing the NLRI - there may be multiple in the MP_REACH */
@@ -3794,7 +4705,7 @@ int bgp_nlri_parse_evpn(struct peer *pee
 			return -1;
 
 		rtype = *pnt++;
-		psize = rlen = *pnt++;
+		psize = *pnt++;
 
 		/* When packet overflow occur return immediately. */
 		if (pnt + psize > lim)
@@ -3805,7 +4716,8 @@ int bgp_nlri_parse_evpn(struct peer *pee
 			if (process_type2_route(peer, afi, safi,
 						withdraw ? NULL : attr, pnt,
 						psize, addpath_id)) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_EVPN_FAIL,
 					"%u:%s - Error in processing EVPN type-2 NLRI size %d",
 					peer->bgp->vrf_id, peer->host, psize);
 				return -1;
@@ -3816,17 +4728,31 @@ int bgp_nlri_parse_evpn(struct peer *pee
 			if (process_type3_route(peer, afi, safi,
 						withdraw ? NULL : attr, pnt,
 						psize, addpath_id)) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_PKT_PROCESS,
 					"%u:%s - Error in processing EVPN type-3 NLRI size %d",
 					peer->bgp->vrf_id, peer->host, psize);
 				return -1;
 			}
 			break;
 
+		case BGP_EVPN_ES_ROUTE:
+			if (process_type4_route(peer, afi, safi,
+						withdraw ? NULL : attr, pnt,
+						psize, addpath_id)) {
+				flog_err(
+					BGP_ERR_PKT_PROCESS,
+					"%u:%s - Error in processing EVPN type-4 NLRI size %d",
+					peer->bgp->vrf_id, peer->host, psize);
+				return -1;
+			}
+			break;
+
 		case BGP_EVPN_IP_PREFIX_ROUTE:
 			if (process_type5_route(peer, afi, safi, attr, pnt,
 						psize, addpath_id, withdraw)) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_PKT_PROCESS,
 					"%u:%s - Error in processing EVPN type-5 NLRI size %d",
 					peer->bgp->vrf_id, peer->host, psize);
 				return -1;
@@ -4006,6 +4932,23 @@ void bgp_evpn_derive_auto_rd(struct bgp
 }
 
 /*
+ * Lookup L3-VNI
+ */
+bool bgp_evpn_lookup_l3vni_l2vni_table(vni_t vni)
+{
+	struct list *inst = bm->bgp;
+	struct listnode *node;
+	struct bgp *bgp_vrf;
+
+	for (ALL_LIST_ELEMENTS_RO(inst, node, bgp_vrf)) {
+		if (bgp_vrf->l3vni == vni)
+			return true;
+	}
+
+	return false;
+}
+
+/*
  * Lookup VNI.
  */
 struct bgpevpn *bgp_evpn_lookup_vni(struct bgp *bgp, vni_t vni)
@@ -4043,8 +4986,10 @@ struct bgpevpn *bgp_evpn_new(struct bgp
 	/* Initialize route-target import and export lists */
 	vpn->import_rtl = list_new();
 	vpn->import_rtl->cmp = (int (*)(void *, void *))evpn_route_target_cmp;
+	vpn->import_rtl->del = evpn_xxport_delete_ecomm;
 	vpn->export_rtl = list_new();
 	vpn->export_rtl->cmp = (int (*)(void *, void *))evpn_route_target_cmp;
+	vpn->export_rtl->del = evpn_xxport_delete_ecomm;
 	bf_assign_index(bm->rd_idspace, vpn->rd_id);
 	derive_rd_rt_for_vni(bgp, vpn);
 
@@ -4084,7 +5029,81 @@ void bgp_evpn_free(struct bgp *bgp, stru
 }
 
 /*
- * Import route into matching VNI(s).
+ * Lookup local ES.
+ */
+struct evpnes *bgp_evpn_lookup_es(struct bgp *bgp, esi_t *esi)
+{
+	struct evpnes *es;
+	struct evpnes tmp;
+
+	memset(&tmp, 0, sizeof(struct evpnes));
+	memcpy(&tmp.esi, esi, sizeof(esi_t));
+	es = hash_lookup(bgp->esihash, &tmp);
+	return es;
+}
+
+/*
+ * Create a new local es - invoked upon zebra notification.
+ */
+struct evpnes *bgp_evpn_es_new(struct bgp *bgp,
+			       esi_t *esi,
+			       struct ipaddr *originator_ip)
+{
+	char buf[100];
+	struct evpnes *es;
+
+	if (!bgp)
+		return NULL;
+
+	es = XCALLOC(MTYPE_BGP_EVPN_ES, sizeof(struct evpnes));
+	if (!es)
+		return NULL;
+
+	/* set the ESI and originator_ip */
+	memcpy(&es->esi, esi, sizeof(esi_t));
+	memcpy(&es->originator_ip, originator_ip, sizeof(struct ipaddr));
+
+	/* Initialise the VTEP list */
+	es->vtep_list = list_new();
+	es->vtep_list->cmp = (int (*)(void *, void *))evpn_vtep_ip_cmp;
+
+	/* auto derive RD for this es */
+	bf_assign_index(bm->rd_idspace, es->rd_id);
+	es->prd.family = AF_UNSPEC;
+	es->prd.prefixlen = 64;
+	sprintf(buf, "%s:%hu", inet_ntoa(bgp->router_id), es->rd_id);
+	(void)str2prefix_rd(buf, &es->prd);
+
+	/* Initialize the ES route table */
+	es->route_table = bgp_table_init(bgp, AFI_L2VPN, SAFI_EVPN);
+
+	/* Add to hash */
+	if (!hash_get(bgp->esihash, es, hash_alloc_intern)) {
+		XFREE(MTYPE_BGP_EVPN_ES, es);
+		return NULL;
+	}
+
+	QOBJ_REG(es, evpnes);
+	return es;
+}
+
+/*
+ * Free a given ES -
+ * This just frees appropriate memory, caller should have taken other
+ * needed actions.
+ */
+void bgp_evpn_es_free(struct bgp *bgp, struct evpnes *es)
+{
+	list_delete_and_null(&es->vtep_list);
+	bgp_table_unlock(es->route_table);
+	bf_release_index(bm->rd_idspace, es->rd_id);
+	hash_release(bgp->esihash, es);
+	QOBJ_UNREG(es);
+	XFREE(MTYPE_BGP_EVPN_ES, es);
+}
+
+/*
+ * Import evpn route from global table to VNI/VRF/ESI.
  */
 int bgp_evpn_import_route(struct bgp *bgp, afi_t afi, safi_t safi,
 			  struct prefix *p, struct bgp_info *ri)
@@ -4093,7 +5112,7 @@ int bgp_evpn_import_route(struct bgp *bg
 }
 
 /*
- * Unimport route from matching VNI(s).
+ * Unimport evpn route from VNI/VRF/ESI.
  */
 int bgp_evpn_unimport_route(struct bgp *bgp, afi_t afi, safi_t safi,
 			    struct prefix *p, struct bgp_info *ri)
@@ -4175,11 +5194,6 @@ int bgp_evpn_local_macip_del(struct bgp
 	struct bgpevpn *vpn;
 	struct prefix_evpn p;
 
-	if (!bgp->vnihash) {
-		zlog_err("%u: VNI hash not created", bgp->vrf_id);
-		return -1;
-	}
-
 	/* Lookup VNI hash - should exist. */
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
 	if (!vpn || !is_vni_live(vpn)) {
@@ -4204,11 +5218,6 @@ int bgp_evpn_local_macip_add(struct bgp
 	struct bgpevpn *vpn;
 	struct prefix_evpn p;
 
-	if (!bgp->vnihash) {
-		zlog_err("%u: VNI hash not created", bgp->vrf_id);
-		return -1;
-	}
-
 	/* Lookup VNI hash - should exist. */
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
 	if (!vpn || !is_vni_live(vpn)) {
@@ -4223,7 +5232,8 @@ int bgp_evpn_local_macip_add(struct bgp
 		char buf[ETHER_ADDR_STRLEN];
 		char buf2[INET6_ADDRSTRLEN];
 
-		zlog_err(
+		flog_err(
+			BGP_ERR_EVPN_ROUTE_CREATE,
 			"%u:Failed to create Type-2 route, VNI %u %s MAC %s IP %s (flags: 0x%x)",
 			bgp->vrf_id, vpn->vni,
 			CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY)
@@ -4240,13 +5250,12 @@ int bgp_evpn_local_macip_add(struct bgp
 static void link_l2vni_hash_to_l3vni(struct hash_backet *backet,
 				     struct bgp *bgp_vrf)
 {
-	struct bgpevpn *vpn = NULL;
+	struct bgpevpn *vpn = (struct bgpevpn *)backet->data;
 	struct bgp *bgp_def = NULL;
 
 	bgp_def = bgp_get_default();
 	assert(bgp_def);
 
-	vpn = (struct bgpevpn *)backet->data;
 	if (vpn->tenant_vrf_id == bgp_vrf->vrf_id)
 		bgpevpn_link_to_l3vni(vpn);
 }
@@ -4260,12 +5269,13 @@ int bgp_evpn_local_l3vni_add(vni_t l3vni
 	struct bgpevpn *vpn = NULL;
 	as_t as = 0;
 
-	/* get the default instamce - required to get the AS number for VRF
+	/* get the default instance - required to get the AS number for VRF
 	 * auto-creatio
 	 */
 	bgp_def = bgp_get_default();
 	if (!bgp_def) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_NO_DFLT,
 			"Cannot process L3VNI  %u ADD - default BGP instance not yet created",
 			l3vni);
 		return -1;
@@ -4282,13 +5292,16 @@ int bgp_evpn_local_l3vni_add(vni_t l3vni
 			      BGP_INSTANCE_TYPE_VRF);
 		switch (ret) {
 		case BGP_ERR_MULTIPLE_INSTANCE_NOT_SET:
-			zlog_err("'bgp multiple-instance' not present\n");
+			flog_err(BGP_ERR_MULTI_INSTANCE,
+				  "'bgp multiple-instance' not present\n");
 			return -1;
 		case BGP_ERR_AS_MISMATCH:
-			zlog_err("BGP is already running; AS is %u\n", as);
+			flog_err(BGP_ERR_EVPN_AS_MISMATCH,
+				  "BGP is already running; AS is %u\n", as);
 			return -1;
 		case BGP_ERR_INSTANCE_MISMATCH:
-			zlog_err("BGP instance name and AS number mismatch\n");
+			flog_err(BGP_ERR_EVPN_INSTANCE_MISMATCH,
+				  "BGP instance name and AS number mismatch\n");
 			return -1;
 		}
 
@@ -4349,7 +5362,8 @@ int bgp_evpn_local_l3vni_del(vni_t l3vni
 
 	bgp_vrf = bgp_lookup_by_vrf_id(vrf_id);
 	if (!bgp_vrf) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_NO_DFLT,
 			"Cannot process L3VNI %u Del - Could not find BGP instance",
 			l3vni);
 		return -1;
@@ -4357,17 +5371,19 @@ int bgp_evpn_local_l3vni_del(vni_t l3vni
 
 	bgp_def = bgp_get_default();
 	if (!bgp_def) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_NO_DFLT,
 			"Cannot process L3VNI %u Del - Could not find default BGP instance",
 			l3vni);
 		return -1;
 	}
 
-	/* unimport remote routes from VRF, if it is AUTO vrf bgp_delete will
-	 * take care of uninstalling the routes from zebra
+	/* Remove remote routes from BGT VRF even if BGP_VRF_AUTO is configured,
+	 * bgp_delete would not remove/decrement bgp_info of the ip_prefix
+	 * routes. This will uninstalling the routes from zebra and decremnt the
+	 * bgp info count.
 	 */
-	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_AUTO))
-		uninstall_routes_for_vrf(bgp_vrf);
+	uninstall_routes_for_vrf(bgp_vrf);
 
 	/* delete/withdraw all type-5 routes */
 	delete_withdraw_vrf_routes(bgp_vrf);
@@ -4379,11 +5395,11 @@ int bgp_evpn_local_l3vni_del(vni_t l3vni
 	memset(&bgp_vrf->rmac, 0, sizeof(struct ethaddr));
 
 	/* delete RD/RT */
-	if (bgp_vrf->vrf_import_rtl && !list_isempty(bgp_vrf->vrf_import_rtl)) {
+	if (!list_isempty(bgp_vrf->vrf_import_rtl)) {
 		bgp_evpn_unmap_vrf_from_its_rts(bgp_vrf);
 		list_delete_all_node(bgp_vrf->vrf_import_rtl);
 	}
-	if (bgp_vrf->vrf_export_rtl && !list_isempty(bgp_vrf->vrf_export_rtl)) {
+	if (!list_isempty(bgp_vrf->vrf_export_rtl)) {
 		list_delete_all_node(bgp_vrf->vrf_export_rtl);
 	}
 
@@ -4413,16 +5429,13 @@ int bgp_evpn_local_vni_del(struct bgp *b
 {
 	struct bgpevpn *vpn;
 
-	if (!bgp->vnihash) {
-		zlog_err("%u: VNI hash not created", bgp->vrf_id);
-		return -1;
-	}
-
 	/* Locate VNI hash */
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
 	if (!vpn) {
-		zlog_warn("%u: VNI hash entry for VNI %u not found at DEL",
-			  bgp->vrf_id, vni);
+		if (bgp_debug_zebra(NULL))
+			zlog_warn(
+				"%u: VNI hash entry for VNI %u not found at DEL",
+				bgp->vrf_id, vni);
 		return 0;
 	}
 
@@ -4454,11 +5467,6 @@ int bgp_evpn_local_vni_add(struct bgp *b
 	struct bgpevpn *vpn;
 	struct prefix_evpn p;
 
-	if (!bgp->vnihash) {
-		zlog_err("%u: VNI hash not created", bgp->vrf_id);
-		return -1;
-	}
-
 	/* Lookup VNI. If present and no change, exit. */
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
 	if (vpn) {
@@ -4494,7 +5502,8 @@ int bgp_evpn_local_vni_add(struct bgp *b
 	if (!vpn) {
 		vpn = bgp_evpn_new(bgp, vni, originator_ip, tenant_vrf_id);
 		if (!vpn) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_VNI,
 				"%u: Failed to allocate VNI entry for VNI %u - at Add",
 				bgp->vrf_id, vni);
 			return -1;
@@ -4517,8 +5526,9 @@ int bgp_evpn_local_vni_add(struct bgp *b
 	/* Create EVPN type-3 route and schedule for processing. */
 	build_evpn_type3_prefix(&p, vpn->originator_ip);
 	if (update_evpn_route(bgp, vpn, &p, 0)) {
-		zlog_err("%u: Type3 route creation failure for VNI %u",
-			 bgp->vrf_id, vni);
+		flog_err(BGP_ERR_EVPN_ROUTE_CREATE,
+			  "%u: Type3 route creation failure for VNI %u",
+			  bgp->vrf_id, vni);
 		return -1;
 	}
 
@@ -4536,6 +5546,88 @@ int bgp_evpn_local_vni_add(struct bgp *b
 }
 
 /*
+ * bgp_evpn_local_es_del
+ */
+int bgp_evpn_local_es_del(struct bgp *bgp,
+			  esi_t *esi,
+			  struct ipaddr *originator_ip)
+{
+	char buf[ESI_STR_LEN];
+	struct evpnes *es = NULL;
+
+	if (!bgp->esihash) {
+		flog_err(BGP_ERR_ES_CREATE, "%u: ESI hash not yet created",
+			  bgp->vrf_id);
+		return -1;
+	}
+
+	/* Lookup ESI hash - should exist. */
+	es = bgp_evpn_lookup_es(bgp, esi);
+	if (!es) {
+		zlog_warn("%u: ESI hash entry for ESI %s at Local ES DEL",
+			  bgp->vrf_id,
+			  esi_to_str(esi, buf, sizeof(buf)));
+		return -1;
+	}
+
+	/* Delete all local EVPN ES routes from ESI table
+	 * and schedule for processing (to withdraw from peers))
+	 */
+	delete_routes_for_es(bgp, es);
+
+	/* free the hash entry */
+	bgp_evpn_es_free(bgp, es);
+
+	return 0;
+}
+
+/*
+ * bgp_evpn_local_es_add
+ */
+int bgp_evpn_local_es_add(struct bgp *bgp,
+			  esi_t *esi,
+			  struct ipaddr *originator_ip)
+{
+	char buf[ESI_STR_LEN];
+	struct evpnes *es = NULL;
+	struct prefix_evpn p;
+
+	if (!bgp->esihash) {
+		flog_err(BGP_ERR_ES_CREATE, "%u: ESI hash not yet created",
+			  bgp->vrf_id);
+		return -1;
+	}
+
+	/* create the new es */
+	es = bgp_evpn_lookup_es(bgp, esi);
+	if (!es) {
+		es = bgp_evpn_es_new(bgp, esi, originator_ip);
+		if (!es) {
+			flog_err(
+				BGP_ERR_ES_CREATE,
+				"%u: Failed to allocate ES entry for ESI %s - at Local ES Add",
+				bgp->vrf_id, esi_to_str(esi, buf, sizeof(buf)));
+			return -1;
+		}
+	}
+	UNSET_FLAG(es->flags, EVPNES_REMOTE);
+	SET_FLAG(es->flags, EVPNES_LOCAL);
+
+	build_evpn_type4_prefix(&p, esi, originator_ip->ipaddr_v4);
+	if (update_evpn_type4_route(bgp, es, &p)) {
+		flog_err(BGP_ERR_EVPN_ROUTE_CREATE,
+			  "%u: Type4 route creation failure for ESI %s",
+			  bgp->vrf_id, esi_to_str(esi, buf, sizeof(buf)));
+		return -1;
+	}
+
+	/* import all remote ES routes in th ES table */
+	install_routes_for_es(bgp, es);
+
+	return 0;
+}
+
+/*
  * Cleanup EVPN information on disable - Need to delete and withdraw
  * EVPN routes from peers.
  */
@@ -4552,25 +5644,25 @@ void bgp_evpn_cleanup_on_disable(struct
  */
 void bgp_evpn_cleanup(struct bgp *bgp)
 {
-	if (bgp->vnihash)
-		hash_iterate(bgp->vnihash, (void (*)(struct hash_backet *,
-						     void *))free_vni_entry,
-			     bgp);
-	if (bgp->import_rt_hash)
-		hash_free(bgp->import_rt_hash);
+	hash_iterate(bgp->vnihash,
+		     (void (*)(struct hash_backet *, void *))free_vni_entry,
+		     bgp);
+
+	hash_free(bgp->import_rt_hash);
 	bgp->import_rt_hash = NULL;
-	if (bgp->vrf_import_rt_hash)
-		hash_free(bgp->vrf_import_rt_hash);
+
+	hash_free(bgp->vrf_import_rt_hash);
 	bgp->vrf_import_rt_hash = NULL;
-	if (bgp->vnihash)
-		hash_free(bgp->vnihash);
+
+	hash_free(bgp->vnihash);
 	bgp->vnihash = NULL;
-	if (bgp->vrf_import_rtl)
-		list_delete_and_null(&bgp->vrf_import_rtl);
-	if (bgp->vrf_export_rtl)
-		list_delete_and_null(&bgp->vrf_export_rtl);
-	if (bgp->l2vnis)
-		list_delete_and_null(&bgp->l2vnis);
+	if (bgp->esihash)
+		hash_free(bgp->esihash);
+	bgp->esihash = NULL;
+
+	list_delete_and_null(&bgp->vrf_import_rtl);
+	list_delete_and_null(&bgp->vrf_export_rtl);
+	list_delete_and_null(&bgp->l2vnis);
 }
 
 /*
@@ -4583,6 +5675,9 @@ void bgp_evpn_init(struct bgp *bgp)
 {
 	bgp->vnihash =
 		hash_create(vni_hash_key_make, vni_hash_cmp, "BGP VNI Hash");
+	bgp->esihash =
+		hash_create(esi_hash_keymake, esi_cmp,
+			    "BGP EVPN Local ESI Hash");
 	bgp->import_rt_hash =
 		hash_create(import_rt_hash_key_make, import_rt_hash_cmp,
 			    "BGP Import RT Hash");
@@ -4592,10 +5687,11 @@ void bgp_evpn_init(struct bgp *bgp)
 	bgp->vrf_import_rtl = list_new();
 	bgp->vrf_import_rtl->cmp =
 		(int (*)(void *, void *))evpn_route_target_cmp;
-
+	bgp->vrf_import_rtl->del = evpn_xxport_delete_ecomm;
 	bgp->vrf_export_rtl = list_new();
 	bgp->vrf_export_rtl->cmp =
 		(int (*)(void *, void *))evpn_route_target_cmp;
+	bgp->vrf_export_rtl->del = evpn_xxport_delete_ecomm;
 	bgp->l2vnis = list_new();
 	bgp->l2vnis->cmp = (int (*)(void *, void *))vni_hash_cmp;
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_evpn.h frr-frr-6.0/bgpd/bgp_evpn.h
--- frr-frr-5.0.1/bgpd/bgp_evpn.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_evpn.h	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 #include "bgpd.h"
 
 #define EVPN_ROUTE_STRLEN 200 /* Must be >> MAC + IPv6 strings. */
+#define EVPN_AUTORT_VXLAN 0x10000000
 
 static inline int is_evpn_enabled(void)
 {
@@ -140,6 +141,10 @@ extern int bgp_evpn_local_vni_del(struct
 extern int bgp_evpn_local_vni_add(struct bgp *bgp, vni_t vni,
 				  struct in_addr originator_ip,
 				  vrf_id_t tenant_vrf_id);
+extern int bgp_evpn_local_es_add(struct bgp *bgp, esi_t *esi,
+				 struct ipaddr *originator_ip);
+extern int bgp_evpn_local_es_del(struct bgp *bgp, esi_t *esi,
+				 struct ipaddr *originator_ip);
 extern void bgp_evpn_cleanup_on_disable(struct bgp *bgp);
 extern void bgp_evpn_cleanup(struct bgp *bgp);
 extern void bgp_evpn_init(struct bgp *bgp);
diff -urpN frr-frr-5.0.1/bgpd/bgp_evpn_private.h frr-frr-6.0/bgpd/bgp_evpn_private.h
--- frr-frr-5.0.1/bgpd/bgp_evpn_private.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_evpn_private.h	2018-10-08 14:32:57.000000000 +0200
@@ -31,9 +31,7 @@
 #define RT_ADDRSTRLEN 28
 
 /* EVPN prefix lengths. This reprsent the sizeof struct prefix_evpn  */
-#define EVPN_TYPE_2_ROUTE_PREFIXLEN      224
-#define EVPN_TYPE_3_ROUTE_PREFIXLEN      224
-#define EVPN_TYPE_5_ROUTE_PREFIXLEN      224
+#define EVPN_ROUTE_PREFIXLEN     224
 
 /* EVPN route types. */
 typedef enum {
@@ -98,6 +96,42 @@ struct bgpevpn {
 
 DECLARE_QOBJ_TYPE(bgpevpn)
 
+struct evpnes {
+
+	/* Ethernet Segment Identifier */
+	esi_t esi;
+
+	/* es flags */
+	uint16_t flags;
+#define EVPNES_LOCAL	0x01
+#define EVPNES_REMOTE	0x02
+
+	/*
+	 * Id for deriving the RD
+	 * automatically for this ESI
+	 */
+	uint16_t rd_id;
+
+	/* RD for this VNI. */
+	struct prefix_rd prd;
+
+	/* originator ip address  */
+	struct ipaddr originator_ip;
+
+	/* list of VTEPs in the same site */
+	struct list *vtep_list;
+
+	/*
+	 * Route table for EVPN routes for
+	 * this ESI. - type4 routes
+	 */
+	struct bgp_table *route_table;
+
+	QOBJ_FIELDS
+};
+
+DECLARE_QOBJ_TYPE(evpnes)
+
 /* Mapping of Import RT to VNIs.
  * The Import RTs of all VNIs are maintained in a hash table with each
  * RT linking to all VNIs that will import routes matching this RT.
@@ -238,6 +272,15 @@ static inline int is_vni_param_configure
 		|| is_export_rt_configured(vpn));
 }
 
+static inline void encode_es_rt_extcomm(struct ecommunity_val *eval,
+					struct ethaddr *mac)
+{
+	memset(eval, 0, sizeof(struct ecommunity_val));
+	eval->val[0] = ECOMMUNITY_ENCODE_EVPN;
+	eval->val[1] = ECOMMUNITY_EVPN_SUBTYPE_ES_IMPORT_RT;
+	memcpy(&eval->val[2], mac, ETH_ALEN);
+}
+
 static inline void encode_rmac_extcomm(struct ecommunity_val *eval,
 				       struct ethaddr *rmac)
 {
@@ -268,60 +311,80 @@ static inline void encode_mac_mobility_e
 	eval->val[7] = seq & 0xff;
 }
 
+static inline void encode_na_flag_extcomm(struct ecommunity_val *eval,
+					  uint8_t na_flag)
+{
+	memset(eval, 0, sizeof(*eval));
+	eval->val[0] = ECOMMUNITY_ENCODE_EVPN;
+	eval->val[1] = ECOMMUNITY_EVPN_SUBTYPE_ND;
+	if (na_flag)
+		eval->val[2] |= ECOMMUNITY_EVPN_SUBTYPE_ND_ROUTER_FLAG;
+}
+
 static inline void ip_prefix_from_type5_prefix(struct prefix_evpn *evp,
 					       struct prefix *ip)
 {
 	memset(ip, 0, sizeof(struct prefix));
-	if (IS_EVPN_PREFIX_IPADDR_V4(evp)) {
+	if (is_evpn_prefix_ipaddr_v4(evp)) {
 		ip->family = AF_INET;
-		ip->prefixlen = evp->prefix.ip_prefix_length;
-		memcpy(&(ip->u.prefix4), &(evp->prefix.ip.ip),
+		ip->prefixlen = evp->prefix.prefix_addr.ip_prefix_length;
+		memcpy(&(ip->u.prefix4), &(evp->prefix.prefix_addr.ip.ip),
 		       IPV4_MAX_BYTELEN);
-	} else if (IS_EVPN_PREFIX_IPADDR_V6(evp)) {
+	} else if (is_evpn_prefix_ipaddr_v6(evp)) {
 		ip->family = AF_INET6;
-		ip->prefixlen = evp->prefix.ip_prefix_length;
-		memcpy(&(ip->u.prefix6), &(evp->prefix.ip.ip),
+		ip->prefixlen = evp->prefix.prefix_addr.ip_prefix_length;
+		memcpy(&(ip->u.prefix6), &(evp->prefix.prefix_addr.ip.ip),
 		       IPV6_MAX_BYTELEN);
 	}
 }
 
-static inline int is_evpn_prefix_default(struct prefix *evp)
+static inline int is_evpn_prefix_default(const struct prefix *evp)
 {
 	if (evp->family != AF_EVPN)
 		return 0;
 
-	return ((evp->u.prefix_evpn.ip_prefix_length  == 0) ? 1 : 0);
+	return ((evp->u.prefix_evpn.prefix_addr.ip_prefix_length  == 0) ?
+		1 : 0);
 }
 
 static inline void ip_prefix_from_type2_prefix(struct prefix_evpn *evp,
 					       struct prefix *ip)
 {
 	memset(ip, 0, sizeof(struct prefix));
-	if (IS_EVPN_PREFIX_IPADDR_V4(evp)) {
+	if (is_evpn_prefix_ipaddr_v4(evp)) {
 		ip->family = AF_INET;
 		ip->prefixlen = IPV4_MAX_BITLEN;
-		memcpy(&(ip->u.prefix4), &(evp->prefix.ip.ip),
+		memcpy(&(ip->u.prefix4), &(evp->prefix.macip_addr.ip.ip),
 		       IPV4_MAX_BYTELEN);
-	} else if (IS_EVPN_PREFIX_IPADDR_V6(evp)) {
+	} else if (is_evpn_prefix_ipaddr_v6(evp)) {
 		ip->family = AF_INET6;
 		ip->prefixlen = IPV6_MAX_BITLEN;
-		memcpy(&(ip->u.prefix6), &(evp->prefix.ip.ip),
+		memcpy(&(ip->u.prefix6), &(evp->prefix.macip_addr.ip.ip),
 		       IPV6_MAX_BYTELEN);
 	}
 }
 
+static inline void ip_prefix_from_evpn_prefix(struct prefix_evpn *evp,
+					      struct prefix *ip)
+{
+	if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
+		ip_prefix_from_type2_prefix(evp, ip);
+	else if (evp->prefix.route_type == BGP_EVPN_IP_PREFIX_ROUTE)
+		ip_prefix_from_type5_prefix(evp, ip);
+}
+
 static inline void build_evpn_type2_prefix(struct prefix_evpn *p,
 					   struct ethaddr *mac,
 					   struct ipaddr *ip)
 {
 	memset(p, 0, sizeof(struct prefix_evpn));
 	p->family = AF_EVPN;
-	p->prefixlen = EVPN_TYPE_2_ROUTE_PREFIXLEN;
+	p->prefixlen = EVPN_ROUTE_PREFIXLEN;
 	p->prefix.route_type = BGP_EVPN_MAC_IP_ROUTE;
-	memcpy(&p->prefix.mac.octet, mac->octet, ETH_ALEN);
-	p->prefix.ip.ipa_type = IPADDR_NONE;
+	memcpy(&p->prefix.macip_addr.mac.octet, mac->octet, ETH_ALEN);
+	p->prefix.macip_addr.ip.ipa_type = IPADDR_NONE;
 	if (ip)
-		memcpy(&p->prefix.ip, ip, sizeof(*ip));
+		memcpy(&p->prefix.macip_addr.ip, ip, sizeof(*ip));
 }
 
 static inline void build_type5_prefix_from_ip_prefix(struct prefix_evpn *evp,
@@ -342,11 +405,11 @@ static inline void build_type5_prefix_fr
 
 	memset(evp, 0, sizeof(struct prefix_evpn));
 	evp->family = AF_EVPN;
-	evp->prefixlen = EVPN_TYPE_5_ROUTE_PREFIXLEN;
-	evp->prefix.ip_prefix_length = ip_prefix->prefixlen;
+	evp->prefixlen = EVPN_ROUTE_PREFIXLEN;
 	evp->prefix.route_type = BGP_EVPN_IP_PREFIX_ROUTE;
-	evp->prefix.ip.ipa_type = ip.ipa_type;
-	memcpy(&evp->prefix.ip, &ip, sizeof(struct ipaddr));
+	evp->prefix.prefix_addr.ip_prefix_length = ip_prefix->prefixlen;
+	evp->prefix.prefix_addr.ip.ipa_type = ip.ipa_type;
+	memcpy(&evp->prefix.prefix_addr.ip, &ip, sizeof(struct ipaddr));
 }
 
 static inline void build_evpn_type3_prefix(struct prefix_evpn *p,
@@ -354,10 +417,24 @@ static inline void build_evpn_type3_pref
 {
 	memset(p, 0, sizeof(struct prefix_evpn));
 	p->family = AF_EVPN;
-	p->prefixlen = EVPN_TYPE_3_ROUTE_PREFIXLEN;
+	p->prefixlen = EVPN_ROUTE_PREFIXLEN;
 	p->prefix.route_type = BGP_EVPN_IMET_ROUTE;
-	p->prefix.ip.ipa_type = IPADDR_V4;
-	p->prefix.ip.ipaddr_v4 = originator_ip;
+	p->prefix.imet_addr.ip.ipa_type = IPADDR_V4;
+	p->prefix.imet_addr.ip.ipaddr_v4 = originator_ip;
+}
+
+static inline void build_evpn_type4_prefix(struct prefix_evpn *p,
+					   esi_t *esi,
+					   struct in_addr originator_ip)
+{
+	memset(p, 0, sizeof(struct prefix_evpn));
+	p->family = AF_EVPN;
+	p->prefixlen = EVPN_ROUTE_PREFIXLEN;
+	p->prefix.route_type = BGP_EVPN_ES_ROUTE;
+	p->prefix.es_addr.ip_prefix_length = IPV4_MAX_BITLEN;
+	p->prefix.es_addr.ip.ipa_type = IPADDR_V4;
+	p->prefix.es_addr.ip.ipaddr_v4 = originator_ip;
+	memcpy(&p->prefix.es_addr.esi, esi, sizeof(esi_t));
 }
 
 static inline int evpn_default_originate_set(struct bgp *bgp, afi_t afi,
@@ -374,6 +451,21 @@ static inline int evpn_default_originate
 	return 0;
 }
 
+static inline void es_get_system_mac(esi_t *esi,
+				     struct ethaddr *mac)
+{
+	/*
+	 * for type-1 and type-3 ESIs,
+	 * the system mac starts at val[1]
+	 */
+	memcpy(mac, &esi->val[1], ETH_ALEN);
+}
+
+static inline int is_es_local(struct evpnes *es)
+{
+	return CHECK_FLAG(es->flags, EVPNES_LOCAL) ? 1 : 0;
+}
+
 extern void evpn_rt_delete_auto(struct bgp *, vni_t, struct list *);
 extern void bgp_evpn_configure_export_rt_for_vrf(struct bgp *bgp_vrf,
 						 struct ecommunity *ecomadd);
@@ -385,6 +477,7 @@ extern void bgp_evpn_unconfigure_import_
 						   struct ecommunity *ecomdel);
 extern int bgp_evpn_handle_export_rt_change(struct bgp *bgp,
 					    struct bgpevpn *vpn);
+extern void bgp_evpn_handle_autort_change(struct bgp *bgp);
 extern void bgp_evpn_handle_vrf_rd_change(struct bgp *bgp_vrf, int withdraw);
 extern void bgp_evpn_handle_rd_change(struct bgp *bgp, struct bgpevpn *vpn,
 				      int withdraw);
@@ -406,4 +499,9 @@ extern struct bgpevpn *bgp_evpn_new(stru
 				    struct in_addr originator_ip,
 				    vrf_id_t tenant_vrf_id);
 extern void bgp_evpn_free(struct bgp *bgp, struct bgpevpn *vpn);
+extern struct evpnes *bgp_evpn_lookup_es(struct bgp *bgp, esi_t *esi);
+extern struct evpnes *bgp_evpn_es_new(struct bgp *bgp, esi_t *esi,
+				      struct ipaddr *originator_ip);
+extern void bgp_evpn_es_free(struct bgp *bgp, struct evpnes *es);
+extern bool bgp_evpn_lookup_l3vni_l2vni_table(vni_t vni);
 #endif /* _BGP_EVPN_PRIVATE_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_evpn_vty.c frr-frr-6.0/bgpd/bgp_evpn_vty.c
--- frr-frr-5.0.1/bgpd/bgp_evpn_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_evpn_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "bgpd/bgp_evpn_private.h"
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_vty.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_ecommunity.h"
 
 #define SHOW_DISPLAY_STANDARD 0
@@ -52,7 +53,6 @@ struct vni_walk_ctx {
 	json_object *json;
 };
 
-#if defined(HAVE_CUMULUS)
 static void display_vrf_import_rt(struct vty *vty, struct vrf_irt_node *irt,
 				  json_object *json)
 {
@@ -245,7 +245,7 @@ static void display_import_rt(struct vty
 	for (ALL_LIST_ELEMENTS(irt->vnis, node, nnode, tmp_vpn)) {
 		if (json)
 			json_object_array_add(
-				json_vnis, json_object_new_int64(tmp_vpn->vni));
+				json_vnis, json_object_new_int(tmp_vpn->vni));
 		else
 			vty_out(vty, "  %u\n", tmp_vpn->vni);
 	}
@@ -311,7 +311,7 @@ static void bgp_evpn_show_route_rd_heade
 }
 
 static void bgp_evpn_show_route_header(struct vty *vty, struct bgp *bgp,
-				       json_object *json)
+				       uint64_t tbl_ver, json_object *json)
 {
 	char ri_header[] =
 		"   Network          Next Hop            Metric LocPrf Weight Path\n";
@@ -319,9 +319,8 @@ static void bgp_evpn_show_route_header(s
 	if (json)
 		return;
 
-
-	vty_out(vty, "BGP table version is 0, local router ID is %s\n",
-		inet_ntoa(bgp->router_id));
+	vty_out(vty, "BGP table version is %" PRIu64 ", local router ID is %s\n",
+		tbl_ver, inet_ntoa(bgp->router_id));
 	vty_out(vty,
 		"Status codes: s suppressed, d damped, h history, "
 		"* valid, > best, i - internal\n");
@@ -329,6 +328,7 @@ static void bgp_evpn_show_route_header(s
 	vty_out(vty,
 		"EVPN type-2 prefix: [2]:[EthTag]:[MAClen]:[MAC]:[IPlen]:[IP]\n");
 	vty_out(vty, "EVPN type-3 prefix: [3]:[EthTag]:[IPlen]:[OrigIP]\n");
+	vty_out(vty, "EVPN type-4 prefix: [4]:[ESI]:[IPlen]:[OrigIP]\n");
 	vty_out(vty, "EVPN type-5 prefix: [5]:[EthTag]:[IPlen]:[IP]\n\n");
 	vty_out(vty, "%s", ri_header);
 }
@@ -410,6 +410,47 @@ static void display_l3vni(struct vty *vt
 		json_object_object_add(json, "exportRts", json_export_rtl);
 }
 
+static void display_es(struct vty *vty, struct evpnes *es, json_object *json)
+{
+	struct in_addr *vtep;
+	char buf[ESI_STR_LEN];
+	char buf1[RD_ADDRSTRLEN];
+	char buf2[INET6_ADDRSTRLEN];
+	struct listnode *node = NULL;
+	json_object *json_vteps = NULL;
+
+	if (json) {
+		json_vteps = json_object_new_array();
+		json_object_string_add(json, "esi",
+				       esi_to_str(&es->esi, buf, sizeof(buf)));
+		json_object_string_add(json, "rd",
+				       prefix_rd2str(&es->prd, buf1,
+						     sizeof(buf1)));
+		json_object_string_add(
+			json, "originatorIp",
+			ipaddr2str(&es->originator_ip, buf2, sizeof(buf2)));
+		if (es->vtep_list) {
+			for (ALL_LIST_ELEMENTS_RO(es->vtep_list, node, vtep))
+				json_object_array_add(
+					json_vteps, json_object_new_string(
+							    inet_ntoa(*vtep)));
+		}
+		json_object_object_add(json, "vteps", json_vteps);
+	} else {
+		vty_out(vty, "ESI: %s\n",
+			esi_to_str(&es->esi, buf, sizeof(buf)));
+		vty_out(vty, "  RD: %s\n", prefix_rd2str(&es->prd, buf1,
+						       sizeof(buf1)));
+		vty_out(vty, "  Originator-IP: %s\n",
+			ipaddr2str(&es->originator_ip, buf2, sizeof(buf2)));
+		if (es->vtep_list) {
+			vty_out(vty, "  VTEP List:\n");
+			for (ALL_LIST_ELEMENTS_RO(es->vtep_list, node, vtep))
+				vty_out(vty, "    %s\n", inet_ntoa(*vtep));
+		}
+	}
+}
+
 static void display_vni(struct vty *vty, struct bgpevpn *vpn, json_object *json)
 {
 	char buf1[RD_ADDRSTRLEN];
@@ -488,18 +529,104 @@ static void display_vni(struct vty *vty,
 		json_object_object_add(json, "exportRts", json_export_rtl);
 }
 
+static void show_esi_routes(struct bgp *bgp,
+			    struct evpnes *es,
+			    struct vty *vty,
+			    json_object *json)
+{
+	int header = 1;
+	struct bgp_node *rn;
+	struct bgp_info *ri;
+	uint32_t prefix_cnt, path_cnt;
+	uint64_t tbl_ver;
+
+	prefix_cnt = path_cnt = 0;
+
+	tbl_ver = es->route_table->version;
+	for (rn = bgp_table_top(es->route_table); rn;
+	     rn = bgp_route_next(rn)) {
+		int add_prefix_to_json = 0;
+		char prefix_str[BUFSIZ];
+		json_object *json_paths = NULL;
+		json_object *json_prefix = NULL;
+
+		bgp_evpn_route2str((struct prefix_evpn *)&rn->p, prefix_str,
+				   sizeof(prefix_str));
+
+		if (json)
+			json_prefix = json_object_new_object();
+
+		if (rn->info) {
+			/* Overall header/legend displayed once. */
+			if (header) {
+				bgp_evpn_show_route_header(vty, bgp,
+							   tbl_ver, json);
+				header = 0;
+			}
+
+			prefix_cnt++;
+		}
+
+		if (json)
+			json_paths = json_object_new_array();
+
+		/* For EVPN, the prefix is displayed for each path (to fit in
+		 * with code that already exists).
+		 */
+		for (ri = rn->info; ri; ri = ri->next) {
+			json_object *json_path = NULL;
+
+			if (json)
+				json_path = json_object_new_array();
+
+			route_vty_out(vty, &rn->p, ri, 0, SAFI_EVPN, json_path);
+
+			if (json)
+				json_object_array_add(json_paths, json_path);
+
+			path_cnt++;
+			add_prefix_to_json = 1;
+		}
+
+		if (json && add_prefix_to_json) {
+			json_object_string_add(json_prefix, "prefix",
+					       prefix_str);
+			json_object_int_add(json_prefix, "prefixLen",
+					    rn->p.prefixlen);
+			json_object_object_add(json_prefix, "paths",
+					       json_paths);
+			json_object_object_add(json, prefix_str, json_prefix);
+		}
+	}
+
+	if (json) {
+		json_object_int_add(json, "numPrefix", prefix_cnt);
+		json_object_int_add(json, "numPaths", path_cnt);
+	} else {
+		if (prefix_cnt == 0)
+			vty_out(vty, "No EVPN prefixes exist for this ESI\n");
+		else
+			vty_out(vty, "\nDisplayed %u prefixes (%u paths)\n",
+				prefix_cnt, path_cnt);
+	}
+}
+
 static void show_vni_routes(struct bgp *bgp, struct bgpevpn *vpn, int type,
 			    struct vty *vty, struct in_addr vtep_ip,
 			    json_object *json)
 {
 	struct bgp_node *rn;
 	struct bgp_info *ri;
+	struct bgp_table *table;
 	int header = 1;
+	uint64_t tbl_ver;
 	uint32_t prefix_cnt, path_cnt;
 
 	prefix_cnt = path_cnt = 0;
 
-	for (rn = bgp_table_top(vpn->route_table); rn;
+	table = vpn->route_table;
+	tbl_ver = table->version;
+	for (rn = bgp_table_top(table); rn;
 	     rn = bgp_route_next(rn)) {
 		struct prefix_evpn *evp = (struct prefix_evpn *)&rn->p;
 		int add_prefix_to_json = 0;
@@ -519,7 +646,8 @@ static void show_vni_routes(struct bgp *
 		if (rn->info) {
 			/* Overall header/legend displayed once. */
 			if (header) {
-				bgp_evpn_show_route_header(vty, bgp, json);
+				bgp_evpn_show_route_header(vty, bgp,
+							   tbl_ver, json);
 				header = 0;
 			}
 
@@ -571,7 +699,7 @@ static void show_vni_routes(struct bgp *
 			vty_out(vty, "No EVPN prefixes %sexist for this VNI",
 				type ? "(of requested type) " : "");
 		else
-			vty_out(vty, "\nDisplayed %u prefixes (%u paths)%s",
+			vty_out(vty, "\nDisplayed %u prefixes (%u paths)%s\n",
 				prefix_cnt, path_cnt,
 				type ? " (of requested type)" : "");
 	}
@@ -703,6 +831,48 @@ static void show_l3vni_entry(struct vty
 	}
 }
 
+static void show_es_entry(struct hash_backet *backet, void *args[])
+{
+	char buf[ESI_STR_LEN];
+	char buf1[RD_ADDRSTRLEN];
+	char buf2[INET6_ADDRSTRLEN];
+	struct in_addr *vtep = NULL;
+	struct vty *vty = args[0];
+	json_object *json = args[1];
+	json_object *json_vteps = NULL;
+	struct listnode *node = NULL;
+	struct evpnes *es = (struct evpnes *)backet->data;
+
+	if (json) {
+		json_vteps = json_object_new_array();
+		json_object_string_add(json, "esi",
+				       esi_to_str(&es->esi, buf, sizeof(buf)));
+		json_object_string_add(json, "type",
+				       is_es_local(es) ? "Local" : "Remote");
+		json_object_string_add(json, "rd",
+				       prefix_rd2str(&es->prd, buf1,
+						     sizeof(buf1)));
+		json_object_string_add(
+			json, "originatorIp",
+			ipaddr2str(&es->originator_ip, buf2, sizeof(buf2)));
+		if (es->vtep_list) {
+			for (ALL_LIST_ELEMENTS_RO(es->vtep_list, node, vtep))
+				json_object_array_add(json_vteps,
+						json_object_new_string(
+							inet_ntoa(*vtep)));
+		}
+		json_object_object_add(json, "vteps", json_vteps);
+	} else {
+		vty_out(vty, "%-30s %-6s %-21s %-15s %-6d\n",
+			esi_to_str(&es->esi, buf, sizeof(buf)),
+			is_es_local(es) ? "Local" : "Remote",
+			prefix_rd2str(&es->prd, buf1, sizeof(buf1)),
+			ipaddr2str(&es->originator_ip, buf2,
+				   sizeof(buf2)),
+			es->vtep_list ? listcount(es->vtep_list) : 0);
+	}
+}
+
 static void show_vni_entry(struct hash_backet *backet, void *args[])
 {
 	struct vty *vty;
@@ -810,7 +980,6 @@ static void show_vni_entry(struct hash_b
 		vty_out(vty, "\n");
 	}
 }
-#endif /* HAVE_CUMULUS */
 
 static int bgp_show_ethernet_vpn(struct vty *vty, struct prefix_rd *prd,
 				 enum bgp_show_type type, void *output_arg,
@@ -862,6 +1031,8 @@ static int bgp_show_ethernet_vpn(struct
 
 	for (rn = bgp_table_top(bgp->rib[afi][SAFI_EVPN]); rn;
 	     rn = bgp_route_next(rn)) {
+		uint64_t tbl_ver;
+
 		if (use_json)
 			continue; /* XXX json TODO */
 
@@ -872,6 +1043,7 @@ static int bgp_show_ethernet_vpn(struct
 			continue;
 
 		rd_header = 1;
+		tbl_ver = table->version;
 
 		for (rm = bgp_table_top(table); rm; rm = bgp_route_next(rm))
 			for (ri = rm->info; ri; ri = ri->next) {
@@ -891,7 +1063,7 @@ static int bgp_show_ethernet_vpn(struct
 							json_object_int_add(
 								json,
 								"bgpTableVersion",
-								0);
+								tbl_ver);
 							json_object_string_add(
 								json,
 								"bgpLocalRouterId",
@@ -917,7 +1089,8 @@ static int bgp_show_ethernet_vpn(struct
 								V4_HEADER_OVERLAY);
 						else {
 							vty_out(vty,
-								"BGP table version is 0, local router ID is %s\n",
+								"BGP table version is %" PRIu64 ", local router ID is %s\n",
+								tbl_ver,
 								inet_ntoa(
 									bgp->router_id));
 							vty_out(vty,
@@ -1462,8 +1635,6 @@ DEFUN(no_evpnrt5_network,
 		argv[idx_gwip]->arg, argv[idx_ethtag]->arg);
 }
 
-#if defined(HAVE_CUMULUS)
-
 static void evpn_import_rt_delete_auto(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	evpn_rt_delete_auto(bgp, vpn->vni, vpn->import_rtl);
@@ -1547,6 +1718,7 @@ static void evpn_unconfigure_import_rt(s
 			list_delete_node(vpn->import_rtl, node_to_del);
 	}
 
+	assert(vpn->import_rtl);
 	/* Reset to auto RT - this also rebuilds the RT to VNI mapping */
 	if (list_isempty(vpn->import_rtl)) {
 		UNSET_FLAG(vpn->flags, VNI_FLAG_IMPRT_CFGD);
@@ -1614,6 +1786,7 @@ static void evpn_unconfigure_export_rt(s
 			list_delete_node(vpn->export_rtl, node_to_del);
 	}
 
+	assert(vpn->export_rtl);
 	if (list_isempty(vpn->export_rtl)) {
 		UNSET_FLAG(vpn->flags, VNI_FLAG_EXPRT_CFGD);
 		bgp_evpn_derive_auto_rt_export(bgp, vpn);
@@ -1655,6 +1828,7 @@ static void evpn_unconfigure_vrf_rd(stru
 
 	/* fall back to default RD */
 	bgp_evpn_derive_auto_rd_for_vrf(bgp_vrf);
+	UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_RD_CFGD);
 
 	/* We have a new RD for VRF.
 	 * Advertise all type-5 routes again with the new RD
@@ -1714,12 +1888,21 @@ static struct bgpevpn *evpn_create_updat
 
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
 	if (!vpn) {
+		/* Check if this L2VNI is already configured as L3VNI */
+		if (bgp_evpn_lookup_l3vni_l2vni_table(vni)) {
+			flog_err(BGP_ERR_VNI,
+				 "%u: Failed to create L2VNI %u, it is configured as L3VNI",
+				 bgp->vrf_id, vni);
+			return NULL;
+		}
+
 		/* tenant vrf will be updated when we get local_vni_add from
 		 * zebra
 		 */
 		vpn = bgp_evpn_new(bgp, vni, bgp->router_id, 0);
 		if (!vpn) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_VNI,
 				"%u: Failed to allocate VNI entry for VNI %u - at Config",
 				bgp->vrf_id, vni);
 			return NULL;
@@ -1961,6 +2144,23 @@ static void evpn_show_route_vni_macip(st
 	}
 }
 
+/* Disaplay EVPN routes for a ESI - VTY handler */
+static void evpn_show_routes_esi(struct vty *vty, struct bgp *bgp,
+				 esi_t *esi, json_object *json)
+{
+	struct evpnes *es = NULL;
+
+	/* locate the ES */
+	es = bgp_evpn_lookup_es(bgp, esi);
+	if (!es) {
+		if (!json)
+			vty_out(vty, "ESI not found\n");
+		return;
+	}
+
+	show_esi_routes(bgp, es, vty, json);
+}
+
 /*
  * Display EVPN routes for a VNI - vty handler.
  * If 'type' is non-zero, only routes matching that type are shown.
@@ -2201,11 +2401,13 @@ static void evpn_show_all_routes(struct
 		char rd_str[RD_ADDRSTRLEN];
 		json_object *json_rd = NULL; /* contains routes for an RD */
 		int add_rd_to_json = 0;
+		uint64_t tbl_ver;
 
 		table = (struct bgp_table *)rd_rn->info;
 		if (table == NULL)
 			continue;
 
+		tbl_ver = table->version;
 		prefix_rd2str((struct prefix_rd *)&rd_rn->p, rd_str,
 			      sizeof(rd_str));
 
@@ -2236,6 +2438,7 @@ static void evpn_show_all_routes(struct
 				/* Overall header/legend displayed once. */
 				if (header) {
 					bgp_evpn_show_route_header(vty, bgp,
+								   tbl_ver,
 								   json);
 					header = 0;
 				}
@@ -2307,6 +2510,43 @@ static void evpn_show_all_routes(struct
 	}
 }
 
+/* Display specific ES */
+static void evpn_show_es(struct vty *vty, struct bgp *bgp, esi_t *esi,
+			 json_object *json)
+{
+	struct evpnes *es = NULL;
+
+	es = bgp_evpn_lookup_es(bgp, esi);
+	if (es) {
+		display_es(vty, es, json);
+	} else {
+		if (json) {
+			vty_out(vty, "{}\n");
+		} else {
+			vty_out(vty, "ESI not found\n");
+			return;
+		}
+	}
+}
+
+/* Display all ESs */
+static void evpn_show_all_es(struct vty *vty, struct bgp *bgp,
+			     json_object *json)
+{
+	void *args[2];
+
+	if (!json)
+		vty_out(vty, "%-30s %-6s %-21s %-15s %-6s\n",
+			"ESI", "Type", "RD", "Originator-IP", "#VTEPs");
+
+	/* print all ESs */
+	args[0] = vty;
+	args[1] = json;
+	hash_iterate(bgp->esihash,
+		     (void (*)(struct hash_backet *, void *))show_es_entry,
+		     args);
+}
+
 /*
  * Display specified VNI (vty handler)
  */
@@ -2502,7 +2742,24 @@ static void evpn_unset_advertise_all_vni
 	bgp_zebra_advertise_all_vni(bgp, bgp->advertise_all_vni);
 	bgp_evpn_cleanup_on_disable(bgp);
 }
-#endif /* HAVE_CUMULUS */
+
+/*
+ * EVPN - use RFC8365 to auto-derive RT
+ */
+static void evpn_set_advertise_autort_rfc8365(struct bgp *bgp)
+{
+	bgp->advertise_autort_rfc8365 = 1;
+	bgp_evpn_handle_autort_change(bgp);
+}
+
+/*
+ * EVPN - don't use RFC8365 to auto-derive RT
+ */
+static void evpn_unset_advertise_autort_rfc8365(struct bgp *bgp)
+{
+	bgp->advertise_autort_rfc8365 = 0;
+	bgp_evpn_handle_autort_change(bgp);
+}
 
 static void write_vni_config(struct vty *vty, struct bgpevpn *vpn)
 {
@@ -2549,14 +2806,6 @@ static void write_vni_config(struct vty
 	}
 }
 
-static void write_vni_config_for_entry(struct hash_backet *backet,
-				       struct vty *vty)
-{
-	struct bgpevpn *vpn = (struct bgpevpn *)backet->data;
-	write_vni_config(vty, vpn);
-}
-
-#if defined(HAVE_CUMULUS)
 DEFUN (bgp_evpn_advertise_default_gw_vni,
        bgp_evpn_advertise_default_gw_vni_cmd,
        "advertise-default-gw",
@@ -2568,9 +2817,6 @@ DEFUN (bgp_evpn_advertise_default_gw_vni
 	if (!bgp)
 		return CMD_WARNING;
 
-	if (!vpn)
-		return CMD_WARNING;
-
 	evpn_set_advertise_default_gw(bgp, vpn);
 
 	return CMD_SUCCESS;
@@ -2588,9 +2834,6 @@ DEFUN (no_bgp_evpn_advertise_default_vni
 	if (!bgp)
 		return CMD_WARNING;
 
-	if (!vpn)
-		return CMD_WARNING;
-
 	evpn_unset_advertise_default_gw(bgp, vpn);
 
 	return CMD_SUCCESS;
@@ -2655,6 +2898,35 @@ DEFUN (no_bgp_evpn_advertise_all_vni,
 	return CMD_SUCCESS;
 }
 
+DEFUN (bgp_evpn_advertise_autort_rfc8365,
+       bgp_evpn_advertise_autort_rfc8365_cmd,
+       "autort rfc8365-compatible",
+       "Auto-derivation of RT\n"
+       "Auto-derivation of RT using RFC8365\n")
+{
+	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
+
+	if (!bgp)
+		return CMD_WARNING;
+	evpn_set_advertise_autort_rfc8365(bgp);
+	return CMD_SUCCESS;
+}
+
+DEFUN (no_bgp_evpn_advertise_autort_rfc8365,
+       no_bgp_evpn_advertise_autort_rfc8365_cmd,
+       "no autort rfc8365-compatible",
+       NO_STR
+       "Auto-derivation of RT\n"
+       "Auto-derivation of RT using RFC8365\n")
+{
+	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
+
+	if (!bgp)
+		return CMD_WARNING;
+	evpn_unset_advertise_autort_rfc8365(bgp);
+	return CMD_SUCCESS;
+}
+
 DEFUN (bgp_evpn_default_originate,
        bgp_evpn_default_originate_cmd,
        "default-originate <ipv4 | ipv6>",
@@ -2704,9 +2976,6 @@ DEFUN_HIDDEN (bgp_evpn_advertise_vni_sub
 	if (!bgp)
 		return CMD_WARNING;
 
-	if (!vpn)
-		return CMD_WARNING;
-
 	bgp_vrf = bgp_lookup_by_vrf_id(vpn->tenant_vrf_id);
 	if (!bgp_vrf)
 		return CMD_WARNING;
@@ -2727,9 +2996,6 @@ DEFUN_HIDDEN (no_bgp_evpn_advertise_vni_
 	if (!bgp)
 		return CMD_WARNING;
 
-	if (!vpn)
-		return CMD_WARNING;
-
 	evpn_unset_advertise_subnet(bgp, vpn);
 	return CMD_SUCCESS;
 }
@@ -2873,7 +3139,7 @@ DEFUN (no_bgp_evpn_advertise_type5,
 		if (CHECK_FLAG(bgp_vrf->af_flags[AFI_L2VPN][SAFI_EVPN],
 			       BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST)) {
 			bgp_evpn_withdraw_type5_routes(bgp_vrf, afi, safi);
-			UNSET_FLAG(bgp_vrf->vrf_flags,
+			UNSET_FLAG(bgp_vrf->af_flags[AFI_L2VPN][SAFI_EVPN],
 				   BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST);
 		}
 	}
@@ -2976,6 +3242,60 @@ DEFUN(show_bgp_l2vpn_evpn_vni,
 	return CMD_SUCCESS;
 }
 
+/* Disaply ES */
+DEFUN(show_bgp_l2vpn_evpn_es,
+      show_bgp_l2vpn_evpn_es_cmd,
+      "show bgp l2vpn evpn es [ESI] [json]",
+      SHOW_STR
+      BGP_STR
+      L2VPN_HELP_STR
+      EVPN_HELP_STR
+      "ethernet-Segment\n"
+      "Ethernet-Segment Identifier\n"
+      JSON_STR)
+{
+	int idx = 0;
+	uint8_t uj = 0;
+	esi_t esi;
+	json_object *json = NULL;
+	struct bgp *bgp = NULL;
+
+	memset(&esi, 0, sizeof(esi));
+	uj = use_json(argc, argv);
+
+	bgp = bgp_get_default();
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (!argv_find(argv, argc, "evpn", &idx))
+		return CMD_WARNING;
+
+	if ((uj && argc == ((idx + 1) + 2)) ||
+	    (!uj && argc == (idx + 1) + 1)) {
+
+		/* show all ESs */
+		evpn_show_all_es(vty, bgp, json);
+	} else {
+
+		/* show a specific ES */
+
+		/* get the ESI - ESI-ID is at argv[5] */
+		if (!str_to_esi(argv[idx + 2]->arg, &esi)) {
+			vty_out(vty, "%% Malformed ESI\n");
+			return CMD_WARNING;
+		}
+		evpn_show_es(vty, bgp, &esi, json);
+	}
+
+	if (uj) {
+		vty_out(vty, "%s\n", json_object_to_json_string_ext(
+					     json, JSON_C_TO_STRING_PRETTY));
+		json_object_free(json);
+	}
+
+	return CMD_SUCCESS;
+}
+
 /*
  * Display EVPN neighbor summary.
  */
@@ -3005,7 +3325,7 @@ DEFUN(show_bgp_l2vpn_evpn_summary,
  */
 DEFUN(show_bgp_l2vpn_evpn_route,
       show_bgp_l2vpn_evpn_route_cmd,
-      "show bgp l2vpn evpn route [type <macip|multicast|prefix>] [json]",
+      "show bgp l2vpn evpn route [type <macip|multicast|es|prefix>] [json]",
       SHOW_STR
       BGP_STR
       L2VPN_HELP_STR
@@ -3014,7 +3334,8 @@ DEFUN(show_bgp_l2vpn_evpn_route,
       "Specify Route type\n"
       "MAC-IP (Type-2) route\n"
       "Multicast (Type-3) route\n"
-      "Prefix route\n"
+      "Ethernet Segment (type-4) route \n"
+      "Prefix (type-5 )route\n"
       JSON_STR)
 {
 	struct bgp *bgp;
@@ -3039,6 +3360,8 @@ DEFUN(show_bgp_l2vpn_evpn_route,
 			type = BGP_EVPN_MAC_IP_ROUTE;
 		else if (strncmp(argv[type_idx + 1]->arg, "mu", 2) == 0)
 			type = BGP_EVPN_IMET_ROUTE;
+		else if (strncmp(argv[type_idx + 1]->arg, "es", 2) == 0)
+			type = BGP_EVPN_ES_ROUTE;
 		else if (strncmp(argv[type_idx + 1]->arg, "pr", 2) == 0)
 			type = BGP_EVPN_IP_PREFIX_ROUTE;
 		else
@@ -3060,7 +3383,7 @@ DEFUN(show_bgp_l2vpn_evpn_route,
  */
 DEFUN(show_bgp_l2vpn_evpn_route_rd,
       show_bgp_l2vpn_evpn_route_rd_cmd,
-      "show bgp l2vpn evpn route rd ASN:NN_OR_IP-ADDRESS:NN [type <macip|multicast|prefix>] [json]",
+      "show bgp l2vpn evpn route rd ASN:NN_OR_IP-ADDRESS:NN [type <macip|multicast|es|prefix>] [json]",
       SHOW_STR
       BGP_STR
       L2VPN_HELP_STR
@@ -3071,6 +3394,7 @@ DEFUN(show_bgp_l2vpn_evpn_route_rd,
       "Specify Route type\n"
       "MAC-IP (Type-2) route\n"
       "Multicast (Type-3) route\n"
+      "Ethernet Segment route\n"
       "Prefix route\n"
       JSON_STR)
 {
@@ -3204,6 +3528,51 @@ DEFUN(show_bgp_l2vpn_evpn_route_rd_macip
 	return CMD_SUCCESS;
 }
 
+/* Display per ESI routing table */
+DEFUN(show_bgp_l2vpn_evpn_route_esi,
+      show_bgp_l2vpn_evpn_route_esi_cmd,
+      "show bgp l2vpn evpn route esi ESI [json]",
+      SHOW_STR
+      BGP_STR
+      L2VPN_HELP_STR
+      EVPN_HELP_STR
+      "EVPN route information\n"
+      "Ethernet Segment Identifier\n"
+      "ESI ID\n"
+      JSON_STR)
+{
+	int uj = 0;
+	esi_t esi;
+	struct bgp *bgp = NULL;
+	json_object *json = NULL;
+
+	memset(&esi, 0, sizeof(esi));
+	bgp = bgp_get_default();
+	if (!bgp)
+		return CMD_WARNING;
+
+	uj = use_json(argc, argv);
+	if (uj)
+		json = json_object_new_object();
+
+	/* get the ESI - ESI-ID is at argv[6] */
+	if (!str_to_esi(argv[6]->arg, &esi)) {
+		vty_out(vty, "%% Malformed ESI\n");
+		return CMD_WARNING;
+	}
+
+	evpn_show_routes_esi(vty, bgp, &esi, json);
+
+	if (uj) {
+		vty_out(vty, "%s\n", json_object_to_json_string_ext(
+					     json, JSON_C_TO_STRING_PRETTY));
+		json_object_free(json);
+	}
+
+	return CMD_SUCCESS;
+}
+
+
 /*
  * Display per-VNI EVPN routing table.
  */
@@ -3531,7 +3900,78 @@ DEFUN(show_bgp_l2vpn_evpn_import_rt,
 	return CMD_SUCCESS;
 }
 
-#if defined(HAVE_CUMULUS)
+DEFUN(test_adv_evpn_type4_route,
+      test_adv_evpn_type4_route_cmd,
+      "advertise es ESI",
+      "Advertise EVPN ES route\n"
+      "Ethernet-segment\n"
+      "Ethernet-Segment Identifier\n")
+{
+	int ret = 0;
+	esi_t esi;
+	struct bgp *bgp;
+	struct ipaddr vtep_ip;
+
+	bgp = bgp_get_default();
+	if (!bgp) {
+		vty_out(vty, "%%Default BGP instance not yet created\n");
+		return CMD_WARNING;
+	}
+
+	if (!str_to_esi(argv[2]->arg, &esi)) {
+		vty_out(vty, "%%Malformed ESI\n");
+		return CMD_WARNING;
+	}
+
+	vtep_ip.ipa_type = IPADDR_V4;
+	vtep_ip.ipaddr_v4 = bgp->router_id;
+
+	ret = bgp_evpn_local_es_add(bgp, &esi, &vtep_ip);
+	if (ret == -1) {
+		vty_out(vty, "%%Failed to EVPN advertise type-4 route\n");
+		return CMD_WARNING;
+	}
+	return CMD_SUCCESS;
+}
+
+DEFUN(test_withdraw_evpn_type4_route,
+      test_withdraw_evpn_type4_route_cmd,
+      "withdraw es ESI",
+      "Advertise EVPN ES route\n"
+      "Ethernet-segment\n"
+      "Ethernet-Segment Identifier\n")
+{
+	int ret = 0;
+	esi_t esi;
+	struct bgp *bgp;
+	struct ipaddr vtep_ip;
+
+	bgp = bgp_get_default();
+	if (!bgp) {
+		vty_out(vty, "%%Default BGP instance not yet created\n");
+		return CMD_WARNING;
+	}
+
+	if (!bgp->peer_self) {
+		vty_out(vty, "%%BGP instance doesnt have self peer\n");
+		return CMD_WARNING;
+	}
+
+	if (!str_to_esi(argv[2]->arg, &esi)) {
+		vty_out(vty, "%%Malformed ESI\n");
+		return CMD_WARNING;
+	}
+
+	vtep_ip.ipa_type = IPADDR_V4;
+	vtep_ip.ipaddr_v4 = bgp->router_id;
+	ret = bgp_evpn_local_es_del(bgp, &esi, &vtep_ip);
+	if (ret == -1) {
+		vty_out(vty, "%%Failed to withdraw EVPN type-4 route\n");
+		return CMD_WARNING;
+	}
+	return CMD_SUCCESS;
+}
+
 ALIAS_HIDDEN(show_bgp_l2vpn_evpn_vni, show_bgp_evpn_vni_cmd,
 	     "show bgp evpn vni [(1-16777215)]", SHOW_STR BGP_STR EVPN_HELP_STR
 	     "Show VNI\n"
@@ -3619,7 +4059,6 @@ ALIAS_HIDDEN(show_bgp_l2vpn_evpn_route_v
 ALIAS_HIDDEN(show_bgp_l2vpn_evpn_import_rt, show_bgp_evpn_import_rt_cmd,
 	     "show bgp evpn import-rt",
 	     SHOW_STR BGP_STR EVPN_HELP_STR "Show import route target\n")
-#endif
 
 DEFUN_NOSH (bgp_evpn_vni,
             bgp_evpn_vni_cmd,
@@ -3784,8 +4223,14 @@ DEFUN (bgp_evpn_vni_rd,
 	VTY_DECLVAR_CONTEXT_SUB(bgpevpn, vpn);
 	int ret;
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	ret = str2prefix_rd(argv[1]->arg, &prd);
 	if (!ret) {
@@ -3814,8 +4259,14 @@ DEFUN (no_bgp_evpn_vni_rd,
 	VTY_DECLVAR_CONTEXT_SUB(bgpevpn, vpn);
 	int ret;
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	ret = str2prefix_rd(argv[2]->arg, &prd);
 	if (!ret) {
@@ -3848,8 +4299,14 @@ DEFUN (no_bgp_evpn_vni_rd_without_val,
 	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
 	VTY_DECLVAR_CONTEXT_SUB(bgpevpn, vpn);
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	/* Check if we should disallow. */
 	if (!is_rd_configured(vpn)) {
@@ -4171,8 +4628,14 @@ DEFUN (bgp_evpn_vni_rt,
 	int rt_type;
 	struct ecommunity *ecomadd = NULL;
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	if (!strcmp(argv[1]->text, "import"))
 		rt_type = RT_TYPE_IMPORT;
@@ -4233,8 +4696,14 @@ DEFUN (no_bgp_evpn_vni_rt,
 	int rt_type, found_ecomdel;
 	struct ecommunity *ecomdel = NULL;
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	if (!strcmp(argv[2]->text, "import"))
 		rt_type = RT_TYPE_IMPORT;
@@ -4326,8 +4795,14 @@ DEFUN (no_bgp_evpn_vni_rt_without_val,
 	VTY_DECLVAR_CONTEXT_SUB(bgpevpn, vpn);
 	int rt_type;
 
-	if (!bgp || !vpn)
+	if (!bgp)
+		return CMD_WARNING;
+
+	if (bgp->vrf_id != VRF_DEFAULT) {
+		vty_out(vty,
+			"This command is only supported under Default VRF\n");
 		return CMD_WARNING;
+	}
 
 	if (!strcmp(argv[2]->text, "import")) {
 		rt_type = RT_TYPE_IMPORT;
@@ -4360,7 +4835,15 @@ DEFUN (no_bgp_evpn_vni_rt_without_val,
 		evpn_unconfigure_export_rt(bgp, vpn, NULL);
 	return CMD_SUCCESS;
 }
-#endif
+
+static int vni_cmp(const void **a, const void **b)
+{
+	const struct bgpevpn *first = *a;
+	const struct bgpevpn *secnd = *b;
+
+	return secnd->vni - first->vni;
+}
+
 /*
  * Output EVPN configuration information.
  */
@@ -4369,25 +4852,44 @@ void bgp_config_write_evpn_info(struct v
 {
 	char buf1[RD_ADDRSTRLEN];
 
-	if (bgp->vnihash)
-		hash_iterate(bgp->vnihash,
-			     (void (*)(struct hash_backet *,
-				       void *))write_vni_config_for_entry,
-			     vty);
+	if (bgp->vnihash) {
+		struct list *vnilist = hash_to_list(bgp->vnihash);
+		struct listnode *ln;
+		struct bgpevpn *data;
+
+		list_sort(vnilist, vni_cmp);
+		for (ALL_LIST_ELEMENTS_RO(vnilist, ln, data))
+			write_vni_config(vty, data);
+
+		list_delete_and_null(&vnilist);
+	}
 
 	if (bgp->advertise_all_vni)
 		vty_out(vty, "  advertise-all-vni\n");
 
+	if (bgp->advertise_autort_rfc8365)
+		vty_out(vty, "  autort rfc8365-compatible\n");
+
 	if (bgp->advertise_gw_macip)
 		vty_out(vty, "  advertise-default-gw\n");
 
 	if (CHECK_FLAG(bgp->af_flags[AFI_L2VPN][SAFI_EVPN],
-		       BGP_L2VPN_EVPN_ADVERTISE_IPV4_UNICAST))
-		vty_out(vty, "  advertise ipv4 unicast\n");
+		       BGP_L2VPN_EVPN_ADVERTISE_IPV4_UNICAST)) {
+		if (bgp->adv_cmd_rmap[AFI_IP][SAFI_UNICAST].name)
+			vty_out(vty, "  advertise ipv4 unicast route-map %s\n",
+				bgp->adv_cmd_rmap[AFI_IP][SAFI_UNICAST].name);
+		else
+			vty_out(vty, "  advertise ipv4 unicast\n");
+	}
 
 	if (CHECK_FLAG(bgp->af_flags[AFI_L2VPN][SAFI_EVPN],
-		       BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST))
-		vty_out(vty, "  advertise ipv6 unicast\n");
+		       BGP_L2VPN_EVPN_ADVERTISE_IPV6_UNICAST)) {
+		if (bgp->adv_cmd_rmap[AFI_IP6][SAFI_UNICAST].name)
+			vty_out(vty, "  advertise ipv6 unicast route-map %s\n",
+				bgp->adv_cmd_rmap[AFI_IP6][SAFI_UNICAST].name);
+		else
+			vty_out(vty, "  advertise ipv6 unicast\n");
+	}
 
 	if (CHECK_FLAG(bgp->af_flags[AFI_L2VPN][SAFI_EVPN],
 		       BGP_L2VPN_EVPN_DEFAULT_ORIGINATE_IPV4))
@@ -4452,9 +4954,10 @@ void bgp_ethernetvpn_init(void)
 	install_element(VIEW_NODE, &show_ip_bgp_l2vpn_evpn_all_overlay_cmd);
 	install_element(BGP_EVPN_NODE, &no_evpnrt5_network_cmd);
 	install_element(BGP_EVPN_NODE, &evpnrt5_network_cmd);
-#if defined(HAVE_CUMULUS)
 	install_element(BGP_EVPN_NODE, &bgp_evpn_advertise_all_vni_cmd);
 	install_element(BGP_EVPN_NODE, &no_bgp_evpn_advertise_all_vni_cmd);
+	install_element(BGP_EVPN_NODE, &bgp_evpn_advertise_autort_rfc8365_cmd);
+	install_element(BGP_EVPN_NODE, &no_bgp_evpn_advertise_autort_rfc8365_cmd);
 	install_element(BGP_EVPN_NODE, &bgp_evpn_advertise_default_gw_cmd);
 	install_element(BGP_EVPN_NODE, &no_bgp_evpn_advertise_default_gw_cmd);
 	install_element(BGP_EVPN_NODE, &bgp_evpn_advertise_type5_cmd);
@@ -4462,12 +4965,18 @@ void bgp_ethernetvpn_init(void)
 	install_element(BGP_EVPN_NODE, &bgp_evpn_default_originate_cmd);
 	install_element(BGP_EVPN_NODE, &no_bgp_evpn_default_originate_cmd);
 
+	/* test commands */
+	install_element(BGP_EVPN_NODE, &test_adv_evpn_type4_route_cmd);
+	install_element(BGP_EVPN_NODE, &test_withdraw_evpn_type4_route_cmd);
+
 	/* "show bgp l2vpn evpn" commands. */
+	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_es_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_vni_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_summary_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_route_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_route_rd_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_route_rd_macip_cmd);
+	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_route_esi_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_route_vni_cmd);
 	install_element(VIEW_NODE,
 			&show_bgp_l2vpn_evpn_route_vni_multicast_cmd);
@@ -4510,5 +5019,4 @@ void bgp_ethernetvpn_init(void)
 	install_element(BGP_EVPN_VNI_NODE, &bgp_evpn_advertise_vni_subnet_cmd);
 	install_element(BGP_EVPN_VNI_NODE,
 			&no_bgp_evpn_advertise_vni_subnet_cmd);
-#endif
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_flowspec.c frr-frr-6.0/bgpd/bgp_flowspec.c
--- frr-frr-5.0.1/bgpd/bgp_flowspec.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_flowspec.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 
 #include <zebra.h>
 #include "prefix.h"
+#include "lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_route.h"
@@ -30,6 +31,7 @@
 #include "bgpd/bgp_flowspec_private.h"
 #include "bgpd/bgp_ecommunity.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 
 static int bgp_fs_nlri_validate(uint8_t *nlri_content, uint32_t len)
 {
@@ -91,7 +93,6 @@ int bgp_nlri_parse_flowspec(struct peer
 	afi_t afi;
 	safi_t safi;
 	int psize = 0;
-	uint8_t rlen;
 	struct prefix p;
 	int ret;
 	void *temp;
@@ -103,13 +104,15 @@ int bgp_nlri_parse_flowspec(struct peer
 	safi = packet->safi;
 
 	if (afi == AFI_IP6) {
-		zlog_err("BGP flowspec IPv6 not supported");
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "BGP flowspec IPv6 not supported");
 		return -1;
 	}
 
 	if (packet->length >= FLOWSPEC_NLRI_SIZELIMIT) {
-		zlog_err("BGP flowspec nlri length maximum reached (%u)",
-			 packet->length);
+		flog_err(BGP_ERR_FLOWSPEC_PACKET,
+			  "BGP flowspec nlri length maximum reached (%u)",
+			  packet->length);
 		return -1;
 	}
 
@@ -121,16 +124,18 @@ int bgp_nlri_parse_flowspec(struct peer
 		if (pnt + 1 > lim)
 			return -1;
 
-		psize = rlen = *pnt++;
+		psize = *pnt++;
 
 		/* When packet overflow occur return immediately. */
 		if (pnt + psize > lim) {
-			zlog_err("Flowspec NLRI length inconsistent ( size %u seen)",
-				 psize);
+			flog_err(BGP_ERR_FLOWSPEC_PACKET,
+				  "Flowspec NLRI length inconsistent ( size %u seen)",
+				  psize);
 			return -1;
 		}
 		if (bgp_fs_nlri_validate(pnt, psize) < 0) {
-			zlog_err("Bad flowspec format or NLRI options not supported");
+			flog_err(BGP_ERR_FLOWSPEC_PACKET,
+				  "Bad flowspec format or NLRI options not supported");
 			return -1;
 		}
 		p.family = AF_FLOWSPEC;
@@ -143,7 +148,7 @@ int bgp_nlri_parse_flowspec(struct peer
 
 		if (BGP_DEBUG(flowspec, FLOWSPEC)) {
 			char return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];
-			char local_string[BGP_FLOWSPEC_NLRI_STRING_MAX];
+			char local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];
 			char ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];
 			char *s = NULL;
 
@@ -152,17 +157,19 @@ int bgp_nlri_parse_flowspec(struct peer
 					       p.u.prefix_flowspec.prefixlen,
 					       return_string,
 					       NLRI_STRING_FORMAT_MIN, NULL);
-			snprintf(ec_string, BGP_FLOWSPEC_NLRI_STRING_MAX,
+			snprintf(ec_string, sizeof(ec_string),
 				 "EC{none}");
 			if (attr && attr->ecommunity) {
 				s = ecommunity_ecom2str(attr->ecommunity,
 						ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
-				snprintf(ec_string,
-					 BGP_FLOWSPEC_NLRI_STRING_MAX,
+				snprintf(ec_string, sizeof(ec_string),
 					 "EC{%s}",
 					s == NULL ? "none" : s);
+
+				if (s)
+					ecommunity_strfree(&s);
 			}
-			snprintf(local_string, BGP_FLOWSPEC_NLRI_STRING_MAX,
+			snprintf(local_string, sizeof(local_string),
 				 "FS Rx %s %s %s %s", withdraw ?
 				 "Withdraw":"Update",
 				 afi2str(afi), return_string,
@@ -181,8 +188,9 @@ int bgp_nlri_parse_flowspec(struct peer
 					   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
 					   NULL, NULL, 0, NULL);
 		if (ret) {
-			zlog_err("Flowspec NLRI failed to be %s.",
-				 attr ? "added" : "withdrawn");
+			flog_err(BGP_ERR_FLOWSPEC_INSTALLATION,
+				  "Flowspec NLRI failed to be %s.",
+				  attr ? "added" : "withdrawn");
 			return -1;
 		}
 	}
diff -urpN frr-frr-5.0.1/bgpd/bgp_flowspec.h frr-frr-6.0/bgpd/bgp_flowspec.h
--- frr-frr-5.0.1/bgpd/bgp_flowspec.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_flowspec.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,4 +50,12 @@ extern void route_vty_out_flowspec(struc
 extern int bgp_fs_config_write_pbr(struct vty *vty, struct bgp *bgp,
 				   afi_t afi, safi_t safi);
 
+extern int bgp_flowspec_display_match_per_ip(afi_t afi,
+				struct bgp_table *rib,
+				struct prefix *match,
+				int prefix_check,
+				struct vty *vty,
+				uint8_t use_json,
+				json_object *json_paths);
+
 #endif /* _FRR_BGP_FLOWSPEC_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_flowspec_util.c frr-frr-6.0/bgpd/bgp_flowspec_util.c
--- frr-frr-5.0.1/bgpd/bgp_flowspec_util.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_flowspec_util.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,11 +21,13 @@
 #include "zebra.h"
 
 #include "prefix.h"
+#include "lib_errors.h"
 
 #include "bgp_table.h"
 #include "bgp_flowspec_util.h"
 #include "bgp_flowspec_private.h"
 #include "bgp_pbr.h"
+#include "bgp_errors.h"
 
 static void hex2bin(uint8_t *hex, int *bin)
 {
@@ -66,16 +68,17 @@ static int bgp_flowspec_call_non_opaque_
 			     len,
 			     mval, error);
 	if (*error < 0)
-		zlog_err("%s: flowspec_op_decode error %d",
-			 __func__, *error);
+		flog_err(BGP_ERR_FLOWSPEC_PACKET,
+			  "%s: flowspec_op_decode error %d",
+			  __func__, *error);
 	else
 		*match_num = *error;
 	return ret;
 }
 
-static bool bgp_flowspec_contains_prefix(struct prefix *pfs,
-					 struct prefix *input,
-					 int prefix_check)
+bool bgp_flowspec_contains_prefix(struct prefix *pfs,
+				 struct prefix *input,
+				 int prefix_check)
 {
 	uint32_t offset = 0;
 	int type;
@@ -444,8 +447,9 @@ int bgp_flowspec_match_rules_fill(uint8_
 					len - offset,
 					prefix, &error);
 			if (error < 0)
-				zlog_err("%s: flowspec_ip_address error %d",
-					 __func__, error);
+				flog_err(BGP_ERR_FLOWSPEC_PACKET,
+					  "%s: flowspec_ip_address error %d",
+					  __func__, error);
 			else
 				bpem->match_bitmask |= bitmask;
 			offset += ret;
@@ -538,8 +542,9 @@ int bgp_flowspec_match_rules_fill(uint8_
 					len - offset,
 					&bpem->tcpflags, &error);
 			if (error < 0)
-				zlog_err("%s: flowspec_tcpflags_decode error %d",
-					 __func__, error);
+				flog_err(BGP_ERR_FLOWSPEC_PACKET,
+					  "%s: flowspec_tcpflags_decode error %d",
+					  __func__, error);
 			else
 				bpem->match_tcpflags_num = error;
 			/* contains the number of slots used */
@@ -552,36 +557,17 @@ int bgp_flowspec_match_rules_fill(uint8_
 					len - offset, &bpem->fragment,
 					&error);
 			if (error < 0)
-				zlog_err("%s: flowspec_fragment_type_decode error %d",
-					 __func__, error);
+				flog_err(BGP_ERR_FLOWSPEC_PACKET,
+					  "%s: flowspec_fragment_type_decode error %d",
+					  __func__, error);
 			else
 				bpem->match_fragment_num = error;
 			offset += ret;
 			break;
 		default:
-			zlog_err("%s: unknown type %d\n", __func__, type);
+			flog_err(LIB_ERR_DEVELOPMENT, "%s: unknown type %d\n",
+				  __func__, type);
 		}
 	}
 	return error;
 }
-
-
-struct bgp_node *bgp_flowspec_get_match_per_ip(afi_t afi,
-					       struct bgp_table *rib,
-					       struct prefix *match,
-					       int prefix_check)
-{
-	struct bgp_node *rn;
-	struct prefix *prefix;
-
-	for (rn = bgp_table_top(rib); rn; rn = bgp_route_next(rn)) {
-		prefix = &rn->p;
-
-		if (prefix->family != AF_FLOWSPEC)
-			continue;
-
-		if (bgp_flowspec_contains_prefix(prefix, match, prefix_check))
-			return rn;
-	}
-	return NULL;
-}
diff -urpN frr-frr-5.0.1/bgpd/bgp_flowspec_util.h frr-frr-6.0/bgpd/bgp_flowspec_util.h
--- frr-frr-5.0.1/bgpd/bgp_flowspec_util.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_flowspec_util.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,8 +50,8 @@ struct bgp_pbr_entry_main;
 extern int bgp_flowspec_match_rules_fill(uint8_t *nlri_content, int len,
 					 struct bgp_pbr_entry_main *bpem);
 
-extern struct bgp_node *bgp_flowspec_get_match_per_ip(afi_t afi,
-						      struct bgp_table *rib,
-						      struct prefix *match,
-						      int prefix_check);
+extern bool bgp_flowspec_contains_prefix(struct prefix *pfs,
+					 struct prefix *input,
+					 int prefix_check);
+
 #endif /* _FRR_BGP_FLOWSPEC_UTIL_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_flowspec_vty.c frr-frr-6.0/bgpd/bgp_flowspec_vty.c
--- frr-frr-5.0.1/bgpd/bgp_flowspec_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_flowspec_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -274,7 +274,7 @@ void route_vty_out_flowspec(struct vty *
 			else
 				json_nlri_path = json_paths;
 		}
-		if (display == NLRI_STRING_FORMAT_LARGE)
+		if (display == NLRI_STRING_FORMAT_LARGE && binfo)
 			vty_out(vty, "BGP flowspec entry: (flags 0x%x)\n",
 				binfo->flags);
 		bgp_fs_nlri_get_string((unsigned char *)
@@ -332,16 +332,32 @@ void route_vty_out_flowspec(struct vty *
 		struct bgp_info_extra *extra = bgp_info_extra_get(binfo);
 
 		if (extra->bgp_fs_pbr) {
+			struct listnode *node;
 			struct bgp_pbr_match_entry *bpme;
 			struct bgp_pbr_match *bpm;
+			bool list_began = false;
+			struct list *list_bpm;
 
-			bpme = (struct bgp_pbr_match_entry *)extra->bgp_fs_pbr;
-			bpm = bpme->backpointer;
-			vty_out(vty, "\tinstalled in PBR");
-			if (bpm)
-				vty_out(vty, " (%s)\n", bpm->ipset_name);
-			else
-				vty_out(vty, "\n");
+			list_bpm = list_new();
+			if (listcount(extra->bgp_fs_pbr))
+				vty_out(vty, "\tinstalled in PBR");
+			for (ALL_LIST_ELEMENTS_RO(extra->bgp_fs_pbr,
+						  node, bpme)) {
+				bpm = bpme->backpointer;
+				if (listnode_lookup(list_bpm, bpm))
+					continue;
+				listnode_add(list_bpm, bpm);
+				if (!list_began) {
+					vty_out(vty, " (");
+					list_began = true;
+				} else
+					vty_out(vty, ", ");
+				vty_out(vty, "%s", bpm->ipset_name);
+			}
+			if (list_began)
+				vty_out(vty, ")");
+			vty_out(vty, "\n");
+			list_delete_and_null(&list_bpm);
 		} else
 			vty_out(vty, "\tnot installed in PBR\n");
 	}
@@ -444,8 +460,6 @@ int bgp_fs_config_write_pbr(struct vty *
 	RB_FOREACH (pbr_if, bgp_pbr_interface_head, head) {
 		vty_out(vty, "  local-install %s\n", pbr_if->name);
 	}
-	if (!bgp_pbr_interface_any)
-		vty_out(vty, "  no local-install any\n");
 	return declare_node ? 1 : 0;
 }
 
@@ -513,17 +527,34 @@ DEFUN (bgp_fs_local_install_ifname,
 	return bgp_fs_local_install_interface(bgp, no, ifname);
 }
 
-DEFUN (bgp_fs_local_install_any,
-	bgp_fs_local_install_any_cmd,
-	"[no] local-install any",
-	NO_STR
-	"Apply local policy routing\n"
-	"Any Interface\n")
+extern int bgp_flowspec_display_match_per_ip(afi_t afi,
+			struct bgp_table *rib,
+			struct prefix *match,
+			int prefix_check,
+			struct vty *vty,
+			uint8_t use_json,
+			json_object *json_paths)
 {
-	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
-	const char *no = strmatch(argv[0]->text, (char *)"no") ? "no" : NULL;
+	struct bgp_node *rn;
+	struct prefix *prefix;
+	int display = 0;
 
-	return bgp_fs_local_install_interface(bgp, no, NULL);
+	for (rn = bgp_table_top(rib); rn; rn = bgp_route_next(rn)) {
+		prefix = &rn->p;
+
+		if (prefix->family != AF_FLOWSPEC)
+			continue;
+
+		if (bgp_flowspec_contains_prefix(prefix, match, prefix_check)) {
+			route_vty_out_flowspec(vty, &rn->p,
+					       rn->info, use_json ?
+					       NLRI_STRING_FORMAT_JSON :
+					       NLRI_STRING_FORMAT_LARGE,
+					       json_paths);
+			display++;
+		}
+	}
+	return display;
 }
 
 void bgp_flowspec_vty_init(void)
@@ -532,6 +563,5 @@ void bgp_flowspec_vty_init(void)
 	install_element(CONFIG_NODE, &debug_bgp_flowspec_cmd);
 	install_element(ENABLE_NODE, &no_debug_bgp_flowspec_cmd);
 	install_element(CONFIG_NODE, &no_debug_bgp_flowspec_cmd);
-	install_element(BGP_FLOWSPECV4_NODE, &bgp_fs_local_install_any_cmd);
 	install_element(BGP_FLOWSPECV4_NODE, &bgp_fs_local_install_ifname_cmd);
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_fsm.c frr-frr-6.0/bgpd/bgp_fsm.c
--- frr-frr-5.0.1/bgpd/bgp_fsm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_fsm.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,11 +34,13 @@
 #include "queue.h"
 #include "filter.h"
 #include "command.h"
+#include "lib_errors.h"
 
 #include "lib/json.h"
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_network.h"
@@ -52,6 +54,7 @@
 #include "bgpd/bgp_memory.h"
 #include "bgpd/bgp_keepalives.h"
 #include "bgpd/bgp_io.h"
+#include "bgpd/bgp_zebra.h"
 
 DEFINE_HOOK(peer_backward_transition, (struct peer * peer), (peer))
 DEFINE_HOOK(peer_established, (struct peer * peer), (peer))
@@ -163,7 +166,8 @@ static struct peer *peer_xfer_conn(struc
 		 * runs in our pthread.
 		 */
 		if (peer->curr) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_PKT_PROCESS,
 				"[%s] Dropping pending packet on connection transfer:",
 				peer->host);
 			uint16_t type = stream_getc_from(peer->curr,
@@ -241,7 +245,8 @@ static struct peer *peer_xfer_conn(struc
 	}
 
 	if (bgp_getsockname(peer) < 0) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"%%bgp_getsockname() failed for %s peer %s fd %d (from_peer fd %d)",
 			(CHECK_FLAG(peer->sflags, PEER_STATUS_ACCEPT_PEER)
 				 ? "accept"
@@ -253,8 +258,10 @@ static struct peer *peer_xfer_conn(struc
 	}
 	if (from_peer->status > Active) {
 		if (bgp_getsockname(from_peer) < 0) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_SOCKET,
 				"%%bgp_getsockname() failed for %s from_peer %s fd %d (peer fd %d)",
+
 				(CHECK_FLAG(from_peer->sflags,
 					    PEER_STATUS_ACCEPT_PEER)
 					 ? "accept"
@@ -1255,7 +1262,8 @@ static int bgp_connect_check(struct thre
 
 	/* If getsockopt is fail, this is fatal error. */
 	if (ret < 0) {
-		zlog_info("can't get sockopt for nonblocking connect");
+		zlog_info("can't get sockopt for nonblocking connect: %d(%s)",
+			  errno, safe_strerror(errno));
 		BGP_EVENT_ADD(peer, TCP_fatal_error);
 		return -1;
 	}
@@ -1266,8 +1274,8 @@ static int bgp_connect_check(struct thre
 		return 1;
 	} else {
 		if (bgp_debug_neighbor_events(peer))
-			zlog_debug("%s [Event] Connect failed (%s)", peer->host,
-				   safe_strerror(errno));
+			zlog_debug("%s [Event] Connect failed %d(%s)",
+				   peer->host, status, safe_strerror(status));
 		BGP_EVENT_ADD(peer, TCP_connection_open_failed);
 		return 0;
 	}
@@ -1278,15 +1286,17 @@ static int bgp_connect_check(struct thre
 static int bgp_connect_success(struct peer *peer)
 {
 	if (peer->fd < 0) {
-		zlog_err("bgp_connect_success peer's fd is negative value %d",
-			 peer->fd);
+		flog_err(BGP_ERR_CONNECT,
+			  "bgp_connect_success peer's fd is negative value %d",
+			  peer->fd);
 		bgp_stop(peer);
 		return -1;
 	}
 
 	if (bgp_getsockname(peer) < 0) {
-		zlog_err("%s: bgp_getsockname(): failed for peer %s, fd %d",
-			 __FUNCTION__, peer->host, peer->fd);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: bgp_getsockname(): failed for peer %s, fd %d",
+			     __FUNCTION__, peer->host, peer->fd);
 		bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,
 				0); /* internal error */
 		bgp_writes_on(peer);
@@ -1344,10 +1354,10 @@ int bgp_start(struct peer *peer)
 
 	if (BGP_PEER_START_SUPPRESSED(peer)) {
 		if (bgp_debug_neighbor_events(peer))
-			zlog_err(
-				"%s [FSM] Trying to start suppressed peer"
-				" - this is never supposed to happen!",
-				peer->host);
+			flog_err(BGP_ERR_FSM,
+				  "%s [FSM] Trying to start suppressed peer"
+				  " - this is never supposed to happen!",
+				  peer->host);
 		return -1;
 	}
 
@@ -1379,7 +1389,8 @@ int bgp_start(struct peer *peer)
 
 	if (peer->bgp->vrf_id == VRF_UNKNOWN) {
 		if (bgp_debug_neighbor_events(peer))
-			zlog_err(
+			flog_err(
+				BGP_ERR_FSM,
 				"%s [FSM] In a VRF that is not initialised yet",
 				peer->host);
 		return -1;
@@ -1396,13 +1407,14 @@ int bgp_start(struct peer *peer)
 	if (!bgp_find_or_add_nexthop(peer->bgp, peer->bgp,
 				     family2afi(peer->su.sa.sa_family), NULL,
 				     peer, connected)) {
-#if defined(HAVE_CUMULUS)
-		if (bgp_debug_neighbor_events(peer))
-			zlog_debug("%s [FSM] Waiting for NHT", peer->host);
+		if (bgp_zebra_num_connects()) {
+			if (bgp_debug_neighbor_events(peer))
+				zlog_debug("%s [FSM] Waiting for NHT",
+					   peer->host);
 
-		BGP_EVENT_ADD(peer, TCP_connection_open_failed);
-		return 0;
-#endif
+			BGP_EVENT_ADD(peer, TCP_connection_open_failed);
+			return 0;
+		}
 	}
 
 	assert(!peer->t_write);
@@ -1432,8 +1444,9 @@ int bgp_start(struct peer *peer)
 				"%s [FSM] Non blocking connect waiting result, fd %d",
 				peer->host, peer->fd);
 		if (peer->fd < 0) {
-			zlog_err("bgp_start peer's fd is negative value %d",
-				 peer->fd);
+			flog_err(BGP_ERR_FSM,
+				  "bgp_start peer's fd is negative value %d",
+				  peer->fd);
 			return -1;
 		}
 		/*
@@ -1479,8 +1492,9 @@ static int bgp_fsm_open(struct peer *pee
    peer and change to Idle status. */
 static int bgp_fsm_event_error(struct peer *peer)
 {
-	zlog_err("%s [FSM] unexpected packet received in state %s", peer->host,
-		 lookup_msg(bgp_status_msg, peer->status, NULL));
+	flog_err(BGP_ERR_FSM,
+		  "%s [FSM] unexpected packet received in state %s", peer->host,
+		  lookup_msg(bgp_status_msg, peer->status, NULL));
 
 	return bgp_stop_with_notify(peer, BGP_NOTIFY_FSM_ERR, 0);
 }
@@ -1512,7 +1526,7 @@ static int bgp_establish(struct peer *pe
 	other = peer->doppelganger;
 	peer = peer_xfer_conn(peer);
 	if (!peer) {
-		zlog_err("%%Neighbor failed in xfer_conn");
+		flog_err(BGP_ERR_CONNECT, "%%Neighbor failed in xfer_conn");
 		return -1;
 	}
 
@@ -1671,7 +1685,8 @@ static int bgp_fsm_update(struct peer *p
 /* This is empty event. */
 static int bgp_ignore(struct peer *peer)
 {
-	zlog_err(
+	flog_err(
+		BGP_ERR_FSM,
 		"%s [FSM] Ignoring event %s in state %s, prior events %s, %s, fd %d",
 		peer->host, bgp_event_str[peer->cur_event],
 		lookup_msg(bgp_status_msg, peer->status, NULL),
@@ -1683,7 +1698,8 @@ static int bgp_ignore(struct peer *peer)
 /* This is to handle unexpected events.. */
 static int bgp_fsm_exeption(struct peer *peer)
 {
-	zlog_err(
+	flog_err(
+		BGP_ERR_FSM,
 		"%s [FSM] Unexpected event %s in state %s, prior events %s, %s, fd %d",
 		peer->host, bgp_event_str[peer->cur_event],
 		lookup_msg(bgp_status_msg, peer->status, NULL),
@@ -1957,7 +1973,8 @@ int bgp_event_update(struct peer *peer,
 		 * code.
 		 */
 		if (!dyn_nbr && !passive_conn && peer->bgp) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_FSM,
 				"%s [FSM] Failure handling event %s in state %s, "
 				"prior events %s, %s, fd %d",
 				peer->host, bgp_event_str[peer->cur_event],
diff -urpN frr-frr-5.0.1/bgpd/bgp_io.c frr-frr-6.0/bgpd/bgp_io.c
--- frr-frr-5.0.1/bgpd/bgp_io.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_io.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 
 #include "bgpd/bgp_io.h"
 #include "bgpd/bgp_debug.h"	// for bgp_debug_neighbor_events, bgp_type_str
+#include "bgpd/bgp_errors.h"	// for expanded error reference information
 #include "bgpd/bgp_fsm.h"	// for BGP_EVENT_ADD, bgp_event
 #include "bgpd/bgp_packet.h"	// for bgp_notify_send_with_data, bgp_notify...
 #include "bgpd/bgpd.h"		// for peer, BGP_MARKER_SIZE, bgp_master, bm
@@ -174,12 +175,11 @@ static int bgp_process_reads(struct thre
 	bool more = true;		// whether we got more data
 	bool fatal = false;		// whether fatal error occurred
 	bool added_pkt = false;		// whether we pushed onto ->ibuf
-	bool header_valid = true;	// whether header is valid
 	/* clang-format on */
 
 	peer = THREAD_ARG(thread);
 
-	if (peer->fd < 0)
+	if (peer->fd < 0 || bm->terminating)
 		return -1;
 
 	struct frr_pthread *fpt = frr_pthread_get(PTHREAD_IO);
@@ -214,10 +214,8 @@ static int bgp_process_reads(struct thre
 		if (ringbuf_remain(ibw) < BGP_HEADER_SIZE)
 			break;
 
-		/* validate header */
-		header_valid = validate_header(peer);
-
-		if (!header_valid) {
+		/* check that header is valid */
+		if (!validate_header(peer)) {
 			fatal = true;
 			break;
 		}
@@ -404,8 +402,9 @@ static uint16_t bgp_read(struct peer *pe
 		SET_FLAG(status, BGP_IO_TRANS_ERR);
 		/* Fatal error; tear down session */
 	} else if (nbytes < 0) {
-		zlog_err("%s [Error] bgp_read_packet error: %s", peer->host,
-			 safe_strerror(errno));
+		flog_err(BGP_ERR_UPDATE_RCV,
+			  "%s [Error] bgp_read_packet error: %s", peer->host,
+			  safe_strerror(errno));
 
 		if (peer->status == Established) {
 			if (CHECK_FLAG(peer->sflags, PEER_STATUS_NSF_MODE)) {
diff -urpN frr-frr-5.0.1/bgpd/bgp_keepalives.c frr-frr-6.0/bgpd/bgp_keepalives.c
--- frr-frr-5.0.1/bgpd/bgp_keepalives.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_keepalives.c	2018-10-08 14:32:57.000000000 +0200
@@ -180,6 +180,12 @@ void *bgp_keepalives_start(void *arg)
 	pthread_cond_init(peerhash_cond, &attrs);
 	pthread_condattr_destroy(&attrs);
 
+#ifdef GNU_LINUX
+	pthread_setname_np(fpt->thread, "bgpd_ka");
+#elif defined(OPEN_BSD)
+	pthread_set_name_np(fpt->thread, "bgpd_ka");
+#endif
+
 	/* initialize peer hashtable */
 	peerhash = hash_create_size(2048, peer_hash_key, peer_hash_cmp, NULL);
 	pthread_mutex_lock(peerhash_mtx);
@@ -233,10 +239,10 @@ void bgp_keepalives_on(struct peer *peer
 	/* placeholder bucket data to use for fast key lookups */
 	static struct pkat holder = {0};
 
-	if (!peerhash_mtx) {
-		zlog_warn("%s: call bgp_keepalives_init() first", __func__);
-		return;
-	}
+	/*
+	 * We need to ensure that bgp_keepalives_init was called first
+	 */
+	assert(peerhash_mtx);
 
 	pthread_mutex_lock(peerhash_mtx);
 	{
@@ -263,10 +269,10 @@ void bgp_keepalives_off(struct peer *pee
 	/* placeholder bucket data to use for fast key lookups */
 	static struct pkat holder = {0};
 
-	if (!peerhash_mtx) {
-		zlog_warn("%s: call bgp_keepalives_init() first", __func__);
-		return;
-	}
+	/*
+	 * We need to ensure that bgp_keepalives_init was called first
+	 */
+	assert(peerhash_mtx);
 
 	pthread_mutex_lock(peerhash_mtx);
 	{
diff -urpN frr-frr-5.0.1/bgpd/bgp_label.c frr-frr-6.0/bgpd/bgp_label.c
--- frr-frr-5.0.1/bgpd/bgp_label.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_label.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@
 #include "bgpd/bgp_label.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 
 extern struct zclient *zclient;
 
@@ -57,7 +58,7 @@ int bgp_parse_fec_update(void)
 	memset(&p, 0, sizeof(struct prefix));
 	p.family = stream_getw(s);
 	p.prefixlen = stream_getc(s);
-	stream_get(&p.u.prefix, s, PSIZE(p.prefixlen));
+	stream_get(p.u.val, s, PSIZE(p.prefixlen));
 	label = stream_getl(s);
 
 	/* hack for the bgp instance & SAFI = have to send/receive it */
@@ -244,7 +245,8 @@ int bgp_nlri_parse_label(struct peer *pe
 
 		/* sanity check against packet data */
 		if ((pnt + psize) > lim) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)",
 				peer->host, prefixlen, (uint)(lim - pnt));
 			return -1;
@@ -256,10 +258,10 @@ int bgp_nlri_parse_label(struct peer *pe
 
 		/* There needs to be at least one label */
 		if (prefixlen < 24) {
-			zlog_err(
-				"%s [Error] Update packet error"
-				" (wrong label length %d)",
-				peer->host, prefixlen);
+			flog_err(BGP_ERR_UPDATE_RCV,
+				  "%s [Error] Update packet error"
+				  " (wrong label length %d)",
+				  peer->host, prefixlen);
 			bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
 					BGP_NOTIFY_UPDATE_INVAL_NETWORK);
 			return -1;
@@ -284,7 +286,8 @@ int bgp_nlri_parse_label(struct peer *pe
 				 * be logged locally, and the prefix SHOULD be
 				 * ignored.
 				  */
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv4 labeled-unicast NLRI is multicast address %s, ignoring",
 					peer->host, inet_ntoa(p.u.prefix4));
 				continue;
@@ -296,7 +299,8 @@ int bgp_nlri_parse_label(struct peer *pe
 			if (IN6_IS_ADDR_LINKLOCAL(&p.u.prefix6)) {
 				char buf[BUFSIZ];
 
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv6 labeled-unicast NLRI is link-local address %s, ignoring",
 					peer->host,
 					inet_ntop(AF_INET6, &p.u.prefix6, buf,
@@ -308,7 +312,8 @@ int bgp_nlri_parse_label(struct peer *pe
 			if (IN6_IS_ADDR_MULTICAST(&p.u.prefix6)) {
 				char buf[BUFSIZ];
 
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv6 unicast NLRI is multicast address %s, ignoring",
 					peer->host,
 					inet_ntop(AF_INET6, &p.u.prefix6, buf,
@@ -331,7 +336,8 @@ int bgp_nlri_parse_label(struct peer *pe
 
 	/* Packet length consistency check. */
 	if (pnt != lim) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_UPDATE_RCV,
 			"%s [Error] Update packet error / L-U (%zu data remaining after parsing)",
 			peer->host, lim - pnt);
 		return -1;
diff -urpN frr-frr-5.0.1/bgpd/bgp_labelpool.c frr-frr-6.0/bgpd/bgp_labelpool.c
--- frr-frr-5.0.1/bgpd/bgp_labelpool.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_labelpool.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_labelpool.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 
 /*
  * Definitions and external declarations.
@@ -126,7 +127,8 @@ static wq_item_status lp_cbq_docallback(
 
 	if (lcbq->label == MPLS_LABEL_NONE) {
 		/* shouldn't happen */
-		zlog_err("%s: error: label==MPLS_LABEL_NONE", __func__);
+		flog_err(BGP_ERR_LABEL, "%s: error: label==MPLS_LABEL_NONE",
+			  __func__);
 		return WQ_SUCCESS;
 	}
 
@@ -202,10 +204,6 @@ void bgp_lp_init(struct thread_master *m
 	lp->requests = XCALLOC(MTYPE_BGP_LABEL_FIFO, sizeof(struct lp_fifo));
 	LABEL_FIFO_INIT(lp->requests);
 	lp->callback_q = work_queue_new(master, "label callbacks");
-	if (!lp->callback_q) {
-		zlog_err("%s: Failed to allocate work queue", __func__);
-		exit(1);
-	}
 
 	lp->callback_q->spec.workfunc = lp_cbq_docallback;
 	lp->callback_q->spec.del_item_data = lp_cbq_item_free;
@@ -340,8 +338,9 @@ void bgp_lp_get(
 
 		if (rc) {
 			/* shouldn't happen */
-			zlog_err("%s: can't insert new LCB into ledger list",
-				__func__);
+			flog_err(BGP_ERR_LABEL,
+				  "%s: can't insert new LCB into ledger list",
+				  __func__);
 			XFREE(MTYPE_BGP_LABEL_CB, lcb);
 			return;
 		}
@@ -428,8 +427,9 @@ void bgp_lp_event_chunk(uint8_t keep, ui
 	struct lp_fifo *lf;
 
 	if (last < first) {
-		zlog_err("%s: zebra label chunk invalid: first=%u, last=%u",
-			__func__, first, last);
+		flog_err(BGP_ERR_LABEL,
+			  "%s: zebra label chunk invalid: first=%u, last=%u",
+			  __func__, first, last);
 		return;
 	}
 
@@ -530,7 +530,6 @@ void bgp_lp_event_zebra_up(void)
 	int chunks_needed;
 	void *labelid;
 	struct lp_lcb *lcb;
-	int lm_init_ok;
 
 	/*
 	 * Get label chunk allocation request dispatched to zebra
@@ -542,11 +541,6 @@ void bgp_lp_event_zebra_up(void)
 	chunks_needed = (labels_needed / LP_CHUNK_SIZE) + 1;
 	labels_needed = chunks_needed * LP_CHUNK_SIZE;
 
-	lm_init_ok = lm_label_manager_connect(zclient, 1) == 0;
-
-	if (!lm_init_ok)
-		zlog_err("%s: label manager connection error", __func__);
-
 	zclient_send_get_label_chunk(zclient, 0, labels_needed);
 	lp->pending_count = labels_needed;
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_lcommunity.c frr-frr-6.0/bgpd/bgp_lcommunity.c
--- frr-frr-5.0.1/bgpd/bgp_lcommunity.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_lcommunity.c	2018-10-08 14:32:57.000000000 +0200
@@ -50,7 +50,6 @@ void lcommunity_free(struct lcommunity *
 	if ((*lcom)->str)
 		XFREE(MTYPE_LCOMMUNITY_STR, (*lcom)->str);
 	XFREE(MTYPE_LCOMMUNITY, *lcom);
-	lcom = NULL;
 }
 
 static void lcommunity_hash_free(struct lcommunity *lcom)
diff -urpN frr-frr-5.0.1/bgpd/bgp_main.c frr-frr-6.0/bgpd/bgp_main.c
--- frr-frr-5.0.1/bgpd/bgp_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -54,11 +54,13 @@
 #include "bgpd/bgp_regex.h"
 #include "bgpd/bgp_clist.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_filter.h"
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_keepalives.h"
 #include "bgpd/bgp_network.h"
+#include "bgpd/bgp_errors.h"
 
 #ifdef ENABLE_BGP_VNC
 #include "bgpd/rfapi/rfapi_backend.h"
@@ -68,11 +70,13 @@
 static const struct option longopts[] = {
 	{"bgp_port", required_argument, NULL, 'p'},
 	{"listenon", required_argument, NULL, 'l'},
+#if CONFDATE > 20190521
+	CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
 	{"retain", no_argument, NULL, 'r'},
 	{"no_kernel", no_argument, NULL, 'n'},
 	{"skip_runas", no_argument, NULL, 'S'},
 	{"ecmp", required_argument, NULL, 'e'},
-	{"int_num", required_argument, NULL, 'I'},
 	{0}};
 
 /* signal definitions */
@@ -102,9 +106,6 @@ static struct quagga_signal_t bgp_signal
 	},
 };
 
-/* Route retain mode flag. */
-static int retain_mode = 0;
-
 /* privileges */
 static zebra_capabilities_t _caps_p[] = {ZCAP_BIND, ZCAP_NET_RAW,
 					 ZCAP_NET_ADMIN, ZCAP_SYS_ADMIN};
@@ -144,9 +145,10 @@ void sighup(void)
 __attribute__((__noreturn__)) void sigint(void)
 {
 	zlog_notice("Terminating on signal");
+	assert(bm->terminating == false);
+	bm->terminating = true;	/* global flag that shutting down */
 
-	if (!retain_mode)
-		bgp_terminate();
+	bgp_terminate();
 
 	bgp_exit(0);
 
@@ -168,7 +170,7 @@ void sigusr1(void)
 */
 static __attribute__((__noreturn__)) void bgp_exit(int status)
 {
-	struct bgp *bgp;
+	struct bgp *bgp, *bgp_default;
 	struct listnode *node, *nnode;
 
 	/* it only makes sense for this to be called on a clean exit */
@@ -180,9 +182,16 @@ static __attribute__((__noreturn__)) voi
 
 	bgp_close();
 
+	bgp_default = bgp_get_default();
+
 	/* reverse bgp_master_init */
-	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp))
+	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
+		if (bgp_default == bgp)
+			continue;
 		bgp_delete(bgp);
+	}
+	if (bgp_default)
+		bgp_delete(bgp_default);
 
 	/* reverse bgp_dump_init */
 	bgp_dump_finish();
@@ -268,6 +277,14 @@ static int bgp_vrf_enable(struct vrf *vr
 		bgp_instance_up(bgp);
 		vpn_leak_zebra_vrf_label_update(bgp, AFI_IP);
 		vpn_leak_zebra_vrf_label_update(bgp, AFI_IP6);
+		vpn_leak_postchange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP,
+				    bgp_get_default(), bgp);
+		vpn_leak_postchange(BGP_VPN_POLICY_DIR_FROMVPN, AFI_IP,
+				    bgp_get_default(), bgp);
+		vpn_leak_postchange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP6,
+				    bgp_get_default(), bgp);
+		vpn_leak_postchange(BGP_VPN_POLICY_DIR_FROMVPN, AFI_IP6,
+				    bgp_get_default(), bgp);
 	}
 
 	return 0;
@@ -289,6 +306,14 @@ static int bgp_vrf_disable(struct vrf *v
 
 		vpn_leak_zebra_vrf_label_withdraw(bgp, AFI_IP);
 		vpn_leak_zebra_vrf_label_withdraw(bgp, AFI_IP6);
+		vpn_leak_prechange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP,
+				   bgp_get_default(), bgp);
+		vpn_leak_prechange(BGP_VPN_POLICY_DIR_FROMVPN, AFI_IP,
+				   bgp_get_default(), bgp);
+		vpn_leak_prechange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP6,
+				   bgp_get_default(), bgp);
+		vpn_leak_prechange(BGP_VPN_POLICY_DIR_FROMVPN, AFI_IP6,
+				   bgp_get_default(), bgp);
 
 		old_vrf_id = bgp->vrf_id;
 		bgp_handle_socket(bgp, vrf, VRF_UNKNOWN, false);
@@ -323,6 +348,11 @@ FRR_DAEMON_INFO(bgpd, BGP, .vty_port = B
 
 		.privs = &bgpd_privs, )
 
+#if CONFDATE > 20190521
+CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
+#define DEPRECATED_OPTIONS "r"
+
 /* Main routine of bgpd. Treatment of argument and start bgp finite
    state machine is handled at here. */
 int main(int argc, char **argv)
@@ -334,23 +364,27 @@ int main(int argc, char **argv)
 	char *bgp_address = NULL;
 	int no_fib_flag = 0;
 	int skip_runas = 0;
-	int instance = 0;
 
 	frr_preinit(&bgpd_di, argc, argv);
 	frr_opt_add(
-		"p:l:rSne:I:", longopts,
+		"p:l:Sne:" DEPRECATED_OPTIONS, longopts,
 		"  -p, --bgp_port     Set BGP listen port number (0 means do not listen).\n"
 		"  -l, --listenon     Listen on specified address (implies -n)\n"
-		"  -r, --retain       When program terminates, retain added route by bgpd.\n"
 		"  -n, --no_kernel    Do not install route to kernel.\n"
 		"  -S, --skip_runas   Skip capabilities checks, and changing user and group IDs.\n"
-		"  -e, --ecmp         Specify ECMP to use.\n"
-		"  -I, --int_num      Set instance number (label-manager)\n");
+		"  -e, --ecmp         Specify ECMP to use.\n");
 
 	/* Command line argument treatment. */
 	while (1) {
 		opt = frr_getopt(argc, argv, 0);
 
+		if (opt && opt < 128 && strchr(DEPRECATED_OPTIONS, opt)) {
+			fprintf(stderr,
+				"The -%c option no longer exists.\nPlease refer to the manual.\n",
+				opt);
+			continue;
+		}
+
 		if (opt == EOF)
 			break;
 
@@ -368,15 +402,13 @@ int main(int argc, char **argv)
 			multipath_num = atoi(optarg);
 			if (multipath_num > MULTIPATH_NUM
 			    || multipath_num <= 0) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_MULTIPATH,
 					"Multipath Number specified must be less than %d and greater than 0",
 					MULTIPATH_NUM);
 				return 1;
 			}
 			break;
-		case 'r':
-			retain_mode = 1;
-			break;
 		case 'l':
 			bgp_address = optarg;
 		/* listenon implies -n */
@@ -387,12 +419,6 @@ int main(int argc, char **argv)
 		case 'S':
 			skip_runas = 1;
 			break;
-		case 'I':
-			instance = atoi(optarg);
-			if (instance > (unsigned short)-1)
-				zlog_err("Instance %i out of range (0..%u)",
-					 instance, (unsigned short)-1);
-			break;
 		default:
 			frr_help_exit(1);
 			break;
@@ -410,11 +436,12 @@ int main(int argc, char **argv)
 	if (no_fib_flag)
 		bgp_option_set(BGP_OPT_NO_FIB);
 
+	bgp_error_init();
 	/* Initializations. */
 	bgp_vrf_init();
 
 	/* BGP related initialization.  */
-	bgp_init((unsigned short)instance);
+	bgp_init();
 
 	snprintf(bgpd_di.startinfo, sizeof(bgpd_di.startinfo), ", bgp@%s:%d",
 		 (bm->address ? bm->address : "<all>"), bm->port);
diff -urpN frr-frr-5.0.1/bgpd/bgp_memory.c frr-frr-6.0/bgpd/bgp_memory.c
--- frr-frr-5.0.1/bgpd/bgp_memory.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_memory.c	2018-10-08 14:32:57.000000000 +0200
@@ -116,6 +116,8 @@ DEFINE_MTYPE(BGPD, LCOMMUNITY_STR, "Larg
 DEFINE_MTYPE(BGPD, LCOMMUNITY_VAL, "Large Community value")
 
 DEFINE_MTYPE(BGPD, BGP_EVPN, "BGP EVPN Information")
+DEFINE_MTYPE(BGPD, BGP_EVPN_ES_VTEP, "BGP EVPN ES VTEP Ip")
+DEFINE_MTYPE(BGPD, BGP_EVPN_ES, "BGP EVPN ESI Information")
 DEFINE_MTYPE(BGPD, BGP_EVPN_IMPORT_RT, "BGP EVPN Import RT")
 DEFINE_MTYPE(BGPD, BGP_EVPN_VRF_IMPORT_RT, "BGP EVPN VRF Import RT")
 DEFINE_MTYPE(BGPD, BGP_EVPN_MACIP, "BGP EVPN MAC IP")
diff -urpN frr-frr-5.0.1/bgpd/bgp_memory.h frr-frr-6.0/bgpd/bgp_memory.h
--- frr-frr-5.0.1/bgpd/bgp_memory.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_memory.h	2018-10-08 14:32:57.000000000 +0200
@@ -111,6 +111,9 @@ DECLARE_MTYPE(LCOMMUNITY)
 DECLARE_MTYPE(LCOMMUNITY_STR)
 DECLARE_MTYPE(LCOMMUNITY_VAL)
 
+DECLARE_MTYPE(BGP_EVPN_ES)
+DECLARE_MTYPE(BGP_EVPN_ES_VTEP)
+
 DECLARE_MTYPE(BGP_EVPN)
 DECLARE_MTYPE(BGP_EVPN_IMPORT_RT)
 DECLARE_MTYPE(BGP_EVPN_VRF_IMPORT_RT)
diff -urpN frr-frr-5.0.1/bgpd/bgp_mpath.c frr-frr-6.0/bgpd/bgp_mpath.c
--- frr-frr-5.0.1/bgpd/bgp_mpath.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_mpath.c	2018-10-08 14:32:57.000000000 +0200
@@ -471,7 +471,7 @@ void bgp_info_mpath_update(struct bgp_no
 		zlog_debug(
 			"%s: starting mpath update, newbest %s num candidates %d old-mpath-count %d",
 			pfx_buf, new_best ? new_best->peer->host : "NONE",
-			listcount(mp_list), old_mpath_count);
+			mp_list ? listcount(mp_list) : 0, old_mpath_count);
 
 	/*
 	 * We perform an ordered walk through both lists in parallel.
diff -urpN frr-frr-5.0.1/bgpd/bgp_mplsvpn.c frr-frr-6.0/bgpd/bgp_mplsvpn.c
--- frr-frr-5.0.1/bgpd/bgp_mplsvpn.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_mplsvpn.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_table.h"
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_attr.h"
@@ -150,7 +151,8 @@ int bgp_nlri_parse_vpn(struct peer *peer
 		psize = PSIZE(prefixlen);
 
 		if (prefixlen < VPN_PREFIXLEN_MIN_BYTES * 8) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error / VPN (prefix length %d less than VPN min length)",
 				peer->host, prefixlen);
 			return -1;
@@ -158,7 +160,8 @@ int bgp_nlri_parse_vpn(struct peer *peer
 
 		/* sanity check against packet data */
 		if ((pnt + psize) > lim) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error / VPN (prefix length %d exceeds packet size %u)",
 				peer->host, prefixlen, (uint)(lim - pnt));
 			return -1;
@@ -166,7 +169,8 @@ int bgp_nlri_parse_vpn(struct peer *peer
 
 		/* sanity check against storage for the IP address portion */
 		if ((psize - VPN_PREFIXLEN_MIN_BYTES) > (ssize_t)sizeof(p.u)) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error / VPN (psize %d exceeds storage size %zu)",
 				peer->host,
 				prefixlen - VPN_PREFIXLEN_MIN_BYTES * 8,
@@ -176,7 +180,8 @@ int bgp_nlri_parse_vpn(struct peer *peer
 
 		/* Sanity check against max bitlen of the address family */
 		if ((psize - VPN_PREFIXLEN_MIN_BYTES) > prefix_blen(&p)) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error / VPN (psize %d exceeds family (%u) max byte len %u)",
 				peer->host,
 				prefixlen - VPN_PREFIXLEN_MIN_BYTES * 8,
@@ -213,14 +218,15 @@ int bgp_nlri_parse_vpn(struct peer *peer
 #endif
 
 		default:
-			zlog_err("Unknown RD type %d", type);
+			flog_err(BGP_ERR_UPDATE_RCV, "Unknown RD type %d",
+				  type);
 			break; /* just report */
 		}
 
 		p.prefixlen =
 			prefixlen
 			- VPN_PREFIXLEN_MIN_BYTES * 8; /* exclude label & RD */
-		memcpy(&p.u.prefix, pnt + VPN_PREFIXLEN_MIN_BYTES,
+		memcpy(p.u.val, pnt + VPN_PREFIXLEN_MIN_BYTES,
 		       psize - VPN_PREFIXLEN_MIN_BYTES);
 
 		if (attr) {
@@ -235,7 +241,8 @@ int bgp_nlri_parse_vpn(struct peer *peer
 	}
 	/* Packet length consistency check. */
 	if (pnt != lim) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_UPDATE_RCV,
 			"%s [Error] Update packet error / VPN (%zu data remaining after parsing)",
 			peer->host, lim - pnt);
 		return -1;
@@ -359,8 +366,10 @@ int vpn_leak_label_callback(
 			return 0;
 		}
 		/* Shouldn't happen: different label allocation */
-		zlog_err("%s: %s had label %u but got new assignment %u",
-			__func__, vp->bgp->name_pretty, vp->tovpn_label, label);
+		flog_err(BGP_ERR_LABEL,
+			  "%s: %s had label %u but got new assignment %u",
+			  __func__, vp->bgp->name_pretty, vp->tovpn_label,
+			  label);
 		/* use new one */
 	}
 
@@ -490,7 +499,7 @@ leak_update(
 	 * (only one hop back to ultimate parent for vrf-vpn-vrf scheme).
 	 * Using a loop here supports more complex intra-bgp import-export
 	 * schemes that could be implemented in the future.
-	 * 
+	 *
 	 */
 	for (bi_ultimate = source_bi;
 		bi_ultimate->extra && bi_ultimate->extra->parent;
@@ -577,7 +586,7 @@ leak_update(
 			zlog_debug("%s: ->%s: %s Found route, changed attr",
 				   __func__, bgp->name_pretty, buf_prefix);
 
-		return NULL;
+		return bi;
 	}
 
 	new = info_make(ZEBRA_ROUTE_BGP, BGP_ROUTE_IMPORTED, 0,
@@ -586,14 +595,15 @@ leak_update(
 	if (nexthop_self_flag)
 		bgp_info_set_flag(bn, new, BGP_INFO_ANNC_NH_SELF);
 
+	bgp_info_extra_get(new);
+
 	if (num_labels)
 		setlabels(new, label, num_labels);
 
-	bgp_info_extra_get(new);
-	new->extra->parent = parent;
-
+	new->extra->parent = bgp_info_lock(parent);
+	bgp_lock_node((struct bgp_node *)((struct bgp_info *)parent)->net);
 	if (bgp_orig)
-		new->extra->bgp_orig = bgp_orig;
+		new->extra->bgp_orig = bgp_lock(bgp_orig);
 	if (nexthop_orig)
 		new->extra->nexthop_orig = *nexthop_orig;
 
@@ -603,7 +613,7 @@ leak_update(
 	struct bgp *bgp_nexthop = bgp;
 	int nh_valid;
 
-	if (new->extra && new->extra->bgp_orig)
+	if (new->extra->bgp_orig)
 		bgp_nexthop = new->extra->bgp_orig;
 
 	/*
@@ -1355,6 +1365,8 @@ void vpn_leak_to_vrf_update_all(struct b
 	struct bgp_node *prn;
 	safi_t safi = SAFI_MPLS_VPN;
 
+	assert(bgp_vpn);
+
 	/*
 	 * Walk vpn table
 	 */
@@ -2249,3 +2261,66 @@ vrf_id_t get_first_vrf_for_redirect_with
 	}
 	return VRF_UNKNOWN;
 }
+
+/*
+ * The purpose of this function is to process leaks that were deferred
+ * from earlier per-vrf configuration due to not-yet-existing default
+ * vrf, in other words, configuration such as:
+ *
+ *     router bgp MMM vrf FOO
+ *       address-family ipv4 unicast
+ *         rd vpn export 1:1
+ *       exit-address-family
+ *
+ *     router bgp NNN
+ *       ...
+ *
+ * This function gets called when the default instance ("router bgp NNN")
+ * is created.
+ */
+void vpn_leak_postchange_all(void)
+{
+	struct listnode *next;
+	struct bgp *bgp;
+	struct bgp *bgp_default = bgp_get_default();
+
+	assert(bgp_default);
+
+	/* First, do any exporting from VRFs to the single VPN RIB */
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, next, bgp)) {
+
+		if (bgp->inst_type != BGP_INSTANCE_TYPE_VRF)
+			continue;
+
+		vpn_leak_postchange(
+			BGP_VPN_POLICY_DIR_TOVPN,
+			AFI_IP,
+			bgp_default,
+			bgp);
+
+		vpn_leak_postchange(
+			BGP_VPN_POLICY_DIR_TOVPN,
+			AFI_IP6,
+			bgp_default,
+			bgp);
+	}
+
+	/* Now, do any importing to VRFs from the single VPN RIB */
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, next, bgp)) {
+
+		if (bgp->inst_type != BGP_INSTANCE_TYPE_VRF)
+			continue;
+
+		vpn_leak_postchange(
+			BGP_VPN_POLICY_DIR_FROMVPN,
+			AFI_IP,
+			bgp_default,
+			bgp);
+
+		vpn_leak_postchange(
+			BGP_VPN_POLICY_DIR_FROMVPN,
+			AFI_IP6,
+			bgp_default,
+			bgp);
+	}
+}
diff -urpN frr-frr-5.0.1/bgpd/bgp_mplsvpn.h frr-frr-6.0/bgpd/bgp_mplsvpn.h
--- frr-frr-5.0.1/bgpd/bgp_mplsvpn.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_mplsvpn.h	2018-10-08 14:32:57.000000000 +0200
@@ -151,6 +151,12 @@ static inline int vpn_leak_from_vpn_acti
 		return 0;
 	}
 
+	if (bgp_vrf->vrf_id == VRF_UNKNOWN) {
+		if (pmsg)
+			*pmsg = "destination bgp instance vrf is VRF_UNKNOWN";
+		return 0;
+	}
+
 	/* Is vrf configured to import from vpn? */
 	if (!CHECK_FLAG(bgp_vrf->af_flags[afi][SAFI_UNICAST],
 			BGP_CONFIG_MPLSVPN_TO_VRF_IMPORT)
@@ -182,6 +188,10 @@ static inline void vpn_leak_prechange(vp
 				      afi_t afi, struct bgp *bgp_vpn,
 				      struct bgp *bgp_vrf)
 {
+	/* Detect when default bgp instance is not (yet) defined by config */
+	if (!bgp_vpn)
+		return;
+
 	if ((direction == BGP_VPN_POLICY_DIR_FROMVPN) &&
 		vpn_leak_from_vpn_active(bgp_vrf, afi, NULL)) {
 
@@ -198,6 +208,10 @@ static inline void vpn_leak_postchange(v
 				       afi_t afi, struct bgp *bgp_vpn,
 				       struct bgp *bgp_vrf)
 {
+	/* Detect when default bgp instance is not (yet) defined by config */
+	if (!bgp_vpn)
+		return;
+
 	if (direction == BGP_VPN_POLICY_DIR_FROMVPN)
 		vpn_leak_to_vrf_update_all(bgp_vrf, bgp_vpn, afi);
 	if (direction == BGP_VPN_POLICY_DIR_TOVPN) {
@@ -216,4 +230,6 @@ extern void vpn_policy_routemap_event(co
 
 extern vrf_id_t get_first_vrf_for_redirect_with_rt(struct ecommunity *eckey);
 
+extern void vpn_leak_postchange_all(void);
+
 #endif /* _QUAGGA_BGP_MPLSVPN_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_network.c frr-frr-6.0/bgpd/bgp_network.c
--- frr-frr-5.0.1/bgpd/bgp_network.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_network.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,12 +35,14 @@
 #include "hash.h"
 #include "filter.h"
 #include "ns.h"
+#include "lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_open.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_network.h"
 
 extern struct zebra_privs_t bgpd_privs;
@@ -95,15 +97,9 @@ static int bgp_md5_set_connect(int socke
 	int ret = -1;
 
 #if HAVE_DECL_TCP_MD5SIG
-	if (bgpd_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("%s: could not raise privs", __func__);
-		return ret;
+	frr_elevate_privs(&bgpd_privs) {
+		ret = bgp_md5_set_socket(socket, su, password);
 	}
-
-	ret = bgp_md5_set_socket(socket, su, password);
-
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs", __func__);
 #endif /* HAVE_TCP_MD5SIG */
 
 	return ret;
@@ -115,25 +111,18 @@ static int bgp_md5_set_password(struct p
 	int ret = 0;
 	struct bgp_listener *listener;
 
-	if (bgpd_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("%s: could not raise privs", __func__);
-		return -1;
-	}
-
+	frr_elevate_privs(&bgpd_privs) {
 	/* Set or unset the password on the listen socket(s). Outbound
-	 * connections
-	 * are taken care of in bgp_connect() below.
+	 * connections are taken care of in bgp_connect() below.
 	 */
-	for (ALL_LIST_ELEMENTS_RO(bm->listen_sockets, node, listener))
-		if (listener->su.sa.sa_family == peer->su.sa.sa_family) {
-			ret = bgp_md5_set_socket(listener->fd, &peer->su,
-						 password);
-			break;
-		}
-
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs", __func__);
-
+		for (ALL_LIST_ELEMENTS_RO(bm->listen_sockets, node, listener))
+			if (listener->su.sa.sa_family
+			    == peer->su.sa.sa_family) {
+				ret = bgp_md5_set_socket(listener->fd,
+							 &peer->su, password);
+				break;
+			}
+	}
 	return ret;
 }
 
@@ -158,10 +147,12 @@ int bgp_set_socket_ttl(struct peer *peer
 	if (!peer->gtsm_hops && (peer_sort(peer) == BGP_PEER_EBGP)) {
 		ret = sockopt_ttl(peer->su.sa.sa_family, bgp_sock, peer->ttl);
 		if (ret) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_SOCKET,
 				"%s: Can't set TxTTL on peer (rtrid %s) socket, err = %d",
-				__func__, inet_ntop(AF_INET, &peer->remote_id,
-						    buf, sizeof(buf)),
+				__func__,
+				inet_ntop(AF_INET, &peer->remote_id, buf,
+					  sizeof(buf)),
 				errno);
 			return ret;
 		}
@@ -172,20 +163,24 @@ int bgp_set_socket_ttl(struct peer *peer
 		*/
 		ret = sockopt_ttl(peer->su.sa.sa_family, bgp_sock, MAXTTL);
 		if (ret) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_SOCKET,
 				"%s: Can't set TxTTL on peer (rtrid %s) socket, err = %d",
-				__func__, inet_ntop(AF_INET, &peer->remote_id,
-						    buf, sizeof(buf)),
+				__func__,
+				inet_ntop(AF_INET, &peer->remote_id, buf,
+					  sizeof(buf)),
 				errno);
 			return ret;
 		}
 		ret = sockopt_minttl(peer->su.sa.sa_family, bgp_sock,
 				     MAXTTL + 1 - peer->gtsm_hops);
 		if (ret) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_SOCKET,
 				"%s: Can't set MinTTL on peer (rtrid %s) socket, err = %d",
-				__func__, inet_ntop(AF_INET, &peer->remote_id,
-						    buf, sizeof(buf)),
+				__func__,
+				inet_ntop(AF_INET, &peer->remote_id, buf,
+					  sizeof(buf)),
 				errno);
 			return ret;
 		}
@@ -226,8 +221,10 @@ static int bgp_get_instance_for_inc_conn
 	rc = getsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, name, &name_len);
 	if (rc != 0) {
 #if defined(HAVE_CUMULUS)
-		zlog_err("[Error] BGP SO_BINDTODEVICE get failed (%s), sock %d",
-			 safe_strerror(errno), sock);
+		flog_err(
+			LIB_ERR_SOCKET,
+			"[Error] BGP SO_BINDTODEVICE get failed (%s), sock %d",
+			safe_strerror(errno), sock);
 		return -1;
 #endif
 	}
@@ -282,7 +279,8 @@ static int bgp_accept(struct thread *thr
 	/* Register accept thread. */
 	accept_sock = THREAD_FD(thread);
 	if (accept_sock < 0) {
-		zlog_err("accept_sock is nevative value %d", accept_sock);
+		flog_err_sys(LIB_ERR_SOCKET, "accept_sock is nevative value %d",
+			     accept_sock);
 		return -1;
 	}
 	listener->thread = NULL;
@@ -293,8 +291,9 @@ static int bgp_accept(struct thread *thr
 	/* Accept client connection. */
 	bgp_sock = sockunion_accept(accept_sock, &su);
 	if (bgp_sock < 0) {
-		zlog_err("[Error] BGP socket accept failed (%s)",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "[Error] BGP socket accept failed (%s)",
+			     safe_strerror(errno));
 		return -1;
 	}
 	set_nonblocking(bgp_sock);
@@ -543,13 +542,11 @@ int bgp_connect(struct peer *peer)
 		zlog_debug("Peer address not learnt: Returning from connect");
 		return 0;
 	}
-	if (bgpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&bgpd_privs) {
 	/* Make socket for the peer. */
-	peer->fd = vrf_sockunion_socket(&peer->su, peer->bgp->vrf_id,
-					bgp_get_bound_name(peer));
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+		peer->fd = vrf_sockunion_socket(&peer->su, peer->bgp->vrf_id,
+						bgp_get_bound_name(peer));
+	}
 	if (peer->fd < 0)
 		return -1;
 
@@ -568,14 +565,14 @@ int bgp_connect(struct peer *peer)
 			  peer->host, safe_strerror(errno));
 
 #ifdef IPTOS_PREC_INTERNETCONTROL
-	if (bgpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs", __func__);
-	if (sockunion_family(&peer->su) == AF_INET)
-		setsockopt_ipv4_tos(peer->fd, IPTOS_PREC_INTERNETCONTROL);
-	else if (sockunion_family(&peer->su) == AF_INET6)
-		setsockopt_ipv6_tclass(peer->fd, IPTOS_PREC_INTERNETCONTROL);
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs", __func__);
+	frr_elevate_privs(&bgpd_privs) {
+		if (sockunion_family(&peer->su) == AF_INET)
+			setsockopt_ipv4_tos(peer->fd,
+					    IPTOS_PREC_INTERNETCONTROL);
+		else if (sockunion_family(&peer->su) == AF_INET6)
+			setsockopt_ipv6_tclass(peer->fd,
+					       IPTOS_PREC_INTERNETCONTROL);
+	}
 #endif
 
 	if (peer->password)
@@ -623,7 +620,8 @@ int bgp_getsockname(struct peer *peer)
 	if (bgp_nexthop_set(peer->su_local, peer->su_remote, &peer->nexthop,
 			    peer)) {
 #if defined(HAVE_CUMULUS)
-		zlog_err(
+		flog_err(
+			BGP_ERR_NH_UPD,
 			"%s: nexthop_set failed, resetting connection - intf %p",
 			peer->host, peer->nexthop.ifp);
 		return -1;
@@ -642,31 +640,31 @@ static int bgp_listener(int sock, struct
 	sockopt_reuseaddr(sock);
 	sockopt_reuseport(sock);
 
-	if (bgpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs", __func__);
+	frr_elevate_privs(&bgpd_privs) {
 
 #ifdef IPTOS_PREC_INTERNETCONTROL
-	if (sa->sa_family == AF_INET)
-		setsockopt_ipv4_tos(sock, IPTOS_PREC_INTERNETCONTROL);
-	else if (sa->sa_family == AF_INET6)
-		setsockopt_ipv6_tclass(sock, IPTOS_PREC_INTERNETCONTROL);
+		if (sa->sa_family == AF_INET)
+			setsockopt_ipv4_tos(sock, IPTOS_PREC_INTERNETCONTROL);
+		else if (sa->sa_family == AF_INET6)
+			setsockopt_ipv6_tclass(sock,
+					       IPTOS_PREC_INTERNETCONTROL);
 #endif
 
-	sockopt_v6only(sa->sa_family, sock);
+		sockopt_v6only(sa->sa_family, sock);
 
-	ret = bind(sock, sa, salen);
-	en = errno;
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs", __func__);
+		ret = bind(sock, sa, salen);
+		en = errno;
+	}
 
 	if (ret < 0) {
-		zlog_err("bind: %s", safe_strerror(en));
+		flog_err_sys(LIB_ERR_SOCKET, "bind: %s", safe_strerror(en));
 		return ret;
 	}
 
 	ret = listen(sock, SOMAXCONN);
 	if (ret < 0) {
-		zlog_err("listen: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "listen: %s",
+			     safe_strerror(errno));
 		return ret;
 	}
 
@@ -674,7 +672,8 @@ static int bgp_listener(int sock, struct
 	listener->fd = sock;
 
 	/* this socket needs a change of ns. record bgp back pointer */
-	if (bgp->vrf_id != VRF_DEFAULT && vrf_is_mapped_on_netns(bgp->vrf_id))
+	if (bgp->vrf_id != VRF_DEFAULT && vrf_is_mapped_on_netns(
+						vrf_lookup_by_id(bgp->vrf_id)))
 		listener->bgp = bgp;
 
 	memcpy(&listener->su, sa, salen);
@@ -702,14 +701,13 @@ int bgp_socket(struct bgp *bgp, unsigned
 	snprintf(port_str, sizeof(port_str), "%d", port);
 	port_str[sizeof(port_str) - 1] = '\0';
 
-	if (bgpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ret = vrf_getaddrinfo(address, port_str, &req, &ainfo_save,
-			      bgp->vrf_id);
-	if (bgpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&bgpd_privs) {
+		ret = vrf_getaddrinfo(address, port_str, &req, &ainfo_save,
+				      bgp->vrf_id);
+	}
 	if (ret != 0) {
-		zlog_err("getaddrinfo: %s", gai_strerror(ret));
+		flog_err_sys(LIB_ERR_SOCKET, "getaddrinfo: %s",
+			     gai_strerror(ret));
 		return -1;
 	}
 
@@ -720,16 +718,17 @@ int bgp_socket(struct bgp *bgp, unsigned
 		if (ainfo->ai_family != AF_INET && ainfo->ai_family != AF_INET6)
 			continue;
 
-		if (bgpd_privs.change(ZPRIVS_RAISE))
-			zlog_err("Can't raise privileges");
-		sock = vrf_socket(ainfo->ai_family, ainfo->ai_socktype,
-				  ainfo->ai_protocol, bgp->vrf_id,
-				  (bgp->inst_type == BGP_INSTANCE_TYPE_VRF ?
-				   bgp->name : NULL));
-		if (bgpd_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
+		frr_elevate_privs(&bgpd_privs) {
+			sock = vrf_socket(ainfo->ai_family,
+					  ainfo->ai_socktype,
+					  ainfo->ai_protocol, bgp->vrf_id,
+					  (bgp->inst_type
+					   == BGP_INSTANCE_TYPE_VRF
+					   ? bgp->name : NULL));
+		}
 		if (sock < 0) {
-			zlog_err("socket: %s", safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET, "socket: %s",
+				     safe_strerror(errno));
 			continue;
 		}
 
@@ -746,10 +745,12 @@ int bgp_socket(struct bgp *bgp, unsigned
 	}
 	freeaddrinfo(ainfo_save);
 	if (count == 0 && bgp->inst_type != BGP_INSTANCE_TYPE_VRF) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"%s: no usable addresses please check other programs usage of specified port %d",
 			__func__, port);
-		zlog_err("%s: Program cannot continue", __func__);
+		flog_err_sys(LIB_ERR_SOCKET, "%s: Program cannot continue",
+			     __func__);
 		exit(-1);
 	}
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_nexthop.c frr-frr-6.0/bgpd/bgp_nexthop.c
--- frr-frr-5.0.1/bgpd/bgp_nexthop.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_nexthop.c	2018-10-08 14:32:57.000000000 +0200
@@ -326,35 +326,21 @@ void bgp_connected_delete(struct bgp *bg
 {
 	struct prefix p;
 	struct prefix *addr;
-	struct bgp_node *rn;
+	struct bgp_node *rn = NULL;
 	struct bgp_connected_ref *bc;
 
 	addr = ifc->address;
 
 	p = *(CONNECTED_PREFIX(ifc));
+	apply_mask(&p);
 	if (addr->family == AF_INET) {
-		apply_mask_ipv4((struct prefix_ipv4 *)&p);
-
 		if (prefix_ipv4_any((struct prefix_ipv4 *)&p))
 			return;
 
 		bgp_address_del(bgp, addr);
 
 		rn = bgp_node_lookup(bgp->connected_table[AFI_IP], &p);
-		if (!rn)
-			return;
-
-		bc = rn->info;
-		bc->refcnt--;
-		if (bc->refcnt == 0) {
-			XFREE(MTYPE_BGP_CONN, bc);
-			rn->info = NULL;
-		}
-		bgp_unlock_node(rn);
-		bgp_unlock_node(rn);
 	} else if (addr->family == AF_INET6) {
-		apply_mask_ipv6((struct prefix_ipv6 *)&p);
-
 		if (IN6_IS_ADDR_UNSPECIFIED(&p.u.prefix6))
 			return;
 
@@ -363,17 +349,34 @@ void bgp_connected_delete(struct bgp *bg
 
 		rn = bgp_node_lookup(bgp->connected_table[AFI_IP6],
 				     (struct prefix *)&p);
-		if (!rn)
-			return;
+	}
 
-		bc = rn->info;
-		bc->refcnt--;
-		if (bc->refcnt == 0) {
-			XFREE(MTYPE_BGP_CONN, bc);
-			rn->info = NULL;
-		}
-		bgp_unlock_node(rn);
-		bgp_unlock_node(rn);
+	if (!rn)
+		return;
+
+	bc = rn->info;
+	bc->refcnt--;
+	if (bc->refcnt == 0) {
+		XFREE(MTYPE_BGP_CONN, bc);
+		rn->info = NULL;
+	}
+	bgp_unlock_node(rn);
+	bgp_unlock_node(rn);
+}
+
+static void bgp_connected_cleanup(struct route_table *table,
+				  struct route_node *rn)
+{
+	struct bgp_connected_ref *bc;
+
+	bc = rn->info;
+	if (!bc)
+		return;
+
+	bc->refcnt--;
+	if (bc->refcnt == 0) {
+		XFREE(MTYPE_BGP_CONN, bc);
+		rn->info = NULL;
 	}
 }
 
@@ -435,7 +438,7 @@ int bgp_subgrp_multiaccess_check_v4(stru
 	struct bgp_node *rn1, *rn2;
 	struct peer_af *paf;
 	struct prefix p, np;
-	struct bgp *bgp = NULL;
+	struct bgp *bgp;
 
 	np.family = AF_INET;
 	np.prefixlen = IPV4_MAX_BITLEN;
@@ -444,8 +447,6 @@ int bgp_subgrp_multiaccess_check_v4(stru
 	p.family = AF_INET;
 	p.prefixlen = IPV4_MAX_BITLEN;
 
-	rn1 = rn2 = NULL;
-
 	bgp = SUBGRP_INST(subgrp);
 	rn1 = bgp_node_match(bgp->connected_table[AFI_IP], &np);
 	if (!rn1)
@@ -656,6 +657,8 @@ void bgp_scan_finish(struct bgp *bgp)
 		bgp_table_unlock(bgp->nexthop_cache_table[afi]);
 		bgp->nexthop_cache_table[afi] = NULL;
 
+		bgp->connected_table[afi]->route_table->cleanup =
+			bgp_connected_cleanup;
 		bgp_table_unlock(bgp->connected_table[afi]);
 		bgp->connected_table[afi] = NULL;
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_nht.c frr-frr-6.0/bgpd/bgp_nht.c
--- frr-frr-5.0.1/bgpd/bgp_nht.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_nht.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_nexthop.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_nht.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_zebra.h"
@@ -343,7 +344,8 @@ void bgp_parse_nexthop_update(int comman
 
 	bgp = bgp_lookup_by_vrf_id(vrf_id);
 	if (!bgp) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_NH_UPD,
 			"parse nexthop update: instance not found for vrf_id %u",
 			vrf_id);
 		return;
diff -urpN frr-frr-5.0.1/bgpd/bgp_open.c frr-frr-6.0/bgpd/bgp_open.c
--- frr-frr-5.0.1/bgpd/bgp_open.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_open.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_open.h"
@@ -80,8 +81,9 @@ void bgp_capability_vty_out(struct vty *
 			afi_t afi;
 			safi_t safi;
 
-			bgp_map_afi_safi_iana2int(ntohs(mpc.afi), mpc.safi,
-						  &afi, &safi);
+			(void)bgp_map_afi_safi_iana2int(ntohs(mpc.afi),
+							mpc.safi, &afi, &safi);
+
 			if (use_json) {
 				switch (afi) {
 				case AFI_IP:
@@ -519,8 +521,9 @@ static as_t bgp_capability_as4(struct pe
 	SET_FLAG(peer->cap, PEER_CAP_AS4_RCV);
 
 	if (hdr->length != CAPABILITY_CODE_AS4_LEN) {
-		zlog_err("%s AS4 capability has incorrect data length %d",
-			 peer->host, hdr->length);
+		flog_err(BGP_ERR_PKT_OPEN,
+			  "%s AS4 capability has incorrect data length %d",
+			  peer->host, hdr->length);
 		return 0;
 	}
 
@@ -1183,10 +1186,10 @@ int bgp_open_option_parse(struct peer *p
 		    && !peer->afc_nego[AFI_IP6][SAFI_ENCAP]
 		    && !peer->afc_nego[AFI_IP6][SAFI_FLOWSPEC]
 		    && !peer->afc_nego[AFI_L2VPN][SAFI_EVPN]) {
-			zlog_err(
-				"%s [Error] Configured AFI/SAFIs do not "
-				"overlap with received MP capabilities",
-				peer->host);
+			flog_err(BGP_ERR_PKT_OPEN,
+				  "%s [Error] Configured AFI/SAFIs do not "
+				  "overlap with received MP capabilities",
+				  peer->host);
 
 			if (error != error_data)
 				bgp_notify_send_with_data(
diff -urpN frr-frr-5.0.1/bgpd/bgp_open.h frr-frr-6.0/bgpd/bgp_open.h
--- frr-frr-5.0.1/bgpd/bgp_open.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_open.h	2018-10-08 14:32:57.000000000 +0200
@@ -34,21 +34,12 @@ struct capability_mp_data {
 	uint8_t safi; /* iana_safi_t */
 };
 
-struct capability_as4 {
-	uint32_t as4;
-};
-
 struct graceful_restart_af {
 	afi_t afi;
 	safi_t safi;
 	uint8_t flag;
 };
 
-struct capability_gr {
-	uint16_t restart_flag_time;
-	struct graceful_restart_af gr[];
-};
-
 /* Capability Code */
 #define CAPABILITY_CODE_MP              1 /* Multiprotocol Extensions */
 #define CAPABILITY_CODE_REFRESH         2 /* Route Refresh Capability */
diff -urpN frr-frr-5.0.1/bgpd/bgp_packet.c frr-frr-6.0/bgpd/bgp_packet.c
--- frr-frr-5.0.1/bgpd/bgp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -36,12 +36,14 @@
 #include "plist.h"
 #include "queue.h"
 #include "filter.h"
+#include "lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_table.h"
 #include "bgpd/bgp_dump.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_packet.h"
@@ -1089,8 +1091,9 @@ static int bgp_open_receive(struct peer
 	/* Just in case we have a silly peer who sends AS4 capability set to 0
 	 */
 	if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV) && !as4) {
-		zlog_err("%s bad OPEN, got AS4 capability, but AS4 set to 0",
-			 peer->host);
+		flog_err(BGP_ERR_PKT_OPEN,
+			  "%s bad OPEN, got AS4 capability, but AS4 set to 0",
+			  peer->host);
 		bgp_notify_send_with_data(peer, BGP_NOTIFY_OPEN_ERR,
 					  BGP_NOTIFY_OPEN_BAD_PEER_AS,
 					  notify_data_remote_as4, 4);
@@ -1103,7 +1106,8 @@ static int bgp_open_receive(struct peer
 		 * BGP_AS_TRANS, for some unknown reason.
 		 */
 		if (as4 == BGP_AS_TRANS) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_PKT_OPEN,
 				"%s [AS4] NEW speaker using AS_TRANS for AS4, not allowed",
 				peer->host);
 			bgp_notify_send_with_data(peer, BGP_NOTIFY_OPEN_ERR,
@@ -1132,7 +1136,8 @@ static int bgp_open_receive(struct peer
 		if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)
 		    && as4 != remote_as) {
 			/* raise error, log this, close session */
-			zlog_err(
+			flog_err(
+				BGP_ERR_PKT_OPEN,
 				"%s bad OPEN, got AS4 capability, but remote_as %u"
 				" mismatch with 16bit 'myasn' %u in open",
 				peer->host, as4, remote_as);
@@ -1299,8 +1304,9 @@ static int bgp_open_receive(struct peer
 
 	/* Get sockname. */
 	if ((ret = bgp_getsockname(peer)) < 0) {
-		zlog_err("%s: bgp_getsockname() failed for peer: %s",
-			 __FUNCTION__, peer->host);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: bgp_getsockname() failed for peer: %s",
+			     __FUNCTION__, peer->host);
 		return BGP_Stop;
 	}
 
@@ -1313,7 +1319,8 @@ static int bgp_open_receive(struct peer
 	    || peer->afc_nego[AFI_IP][SAFI_ENCAP]) {
 		if (!peer->nexthop.v4.s_addr) {
 #if defined(HAVE_CUMULUS)
-			zlog_err(
+			flog_err(
+				BGP_ERR_SND_FAIL,
 				"%s: No local IPv4 addr resetting connection, fd %d",
 				peer->host, peer->fd);
 			bgp_notify_send(peer, BGP_NOTIFY_CEASE,
@@ -1329,7 +1336,8 @@ static int bgp_open_receive(struct peer
 	    || peer->afc_nego[AFI_IP6][SAFI_ENCAP]) {
 		if (IN6_IS_ADDR_UNSPECIFIED(&peer->nexthop.v6_global)) {
 #if defined(HAVE_CUMULUS)
-			zlog_err(
+			flog_err(
+				BGP_ERR_SND_FAIL,
 				"%s: No local IPv6 addr resetting connection, fd %d",
 				peer->host, peer->fd);
 			bgp_notify_send(peer, BGP_NOTIFY_CEASE,
@@ -1391,9 +1399,10 @@ static int bgp_update_receive(struct pee
 
 	/* Status must be Established. */
 	if (peer->status != Established) {
-		zlog_err("%s [FSM] Update packet received under status %s",
-			 peer->host,
-			 lookup_msg(bgp_status_msg, peer->status, NULL));
+		flog_err(BGP_ERR_INVALID_STATUS,
+			  "%s [FSM] Update packet received under status %s",
+			  peer->host,
+			  lookup_msg(bgp_status_msg, peer->status, NULL));
 		bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR, 0);
 		return BGP_Stop;
 	}
@@ -1414,10 +1423,10 @@ static int bgp_update_receive(struct pee
 	   Attribute Length + 23 exceeds the message Length), then the Error
 	   Subcode is set to Malformed Attribute List.  */
 	if (stream_pnt(s) + 2 > end) {
-		zlog_err(
-			"%s [Error] Update packet error"
-			" (packet length is short for unfeasible length)",
-			peer->host);
+		flog_err(BGP_ERR_UPDATE_RCV,
+			  "%s [Error] Update packet error"
+			  " (packet length is short for unfeasible length)",
+			  peer->host);
 		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
 				BGP_NOTIFY_UPDATE_MAL_ATTR);
 		return BGP_Stop;
@@ -1428,10 +1437,10 @@ static int bgp_update_receive(struct pee
 
 	/* Unfeasible Route Length check. */
 	if (stream_pnt(s) + withdraw_len > end) {
-		zlog_err(
-			"%s [Error] Update packet error"
-			" (packet unfeasible length overflow %d)",
-			peer->host, withdraw_len);
+		flog_err(BGP_ERR_UPDATE_RCV,
+			  "%s [Error] Update packet error"
+			  " (packet unfeasible length overflow %d)",
+			  peer->host, withdraw_len);
 		bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
 				BGP_NOTIFY_UPDATE_MAL_ATTR);
 		return BGP_Stop;
@@ -1502,7 +1511,8 @@ static int bgp_update_receive(struct pee
 		ret = bgp_dump_attr(&attr, peer->rcvd_attr_str, BUFSIZ);
 
 		if (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s rcvd UPDATE with errors in attr(s)!! Withdrawing route.",
 				peer->host);
 
@@ -1562,7 +1572,8 @@ static int bgp_update_receive(struct pee
 		}
 
 		if (nlri_ret < 0) {
-			zlog_err("%s [Error] Error parsing NLRI", peer->host);
+			flog_err(BGP_ERR_UPDATE_RCV,
+				  "%s [Error] Error parsing NLRI", peer->host);
 			if (peer->status == Established)
 				bgp_notify_send(
 					peer, BGP_NOTIFY_UPDATE_ERR,
@@ -1733,8 +1744,9 @@ static int bgp_route_refresh_receive(str
 
 	/* If peer does not have the capability, send notification. */
 	if (!CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_ADV)) {
-		zlog_err("%s [Error] BGP route refresh is not enabled",
-			 peer->host);
+		flog_err(BGP_ERR_NO_CAP,
+			  "%s [Error] BGP route refresh is not enabled",
+			  peer->host);
 		bgp_notify_send(peer, BGP_NOTIFY_HEADER_ERR,
 				BGP_NOTIFY_HEADER_BAD_MESTYPE);
 		return BGP_Stop;
@@ -1742,7 +1754,8 @@ static int bgp_route_refresh_receive(str
 
 	/* Status must be Established. */
 	if (peer->status != Established) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_INVALID_STATUS,
 			"%s [Error] Route refresh packet received under status %s",
 			peer->host,
 			lookup_msg(bgp_status_msg, peer->status, NULL));
@@ -2122,8 +2135,9 @@ int bgp_capability_receive(struct peer *
 
 	/* If peer does not have the capability, send notification. */
 	if (!CHECK_FLAG(peer->cap, PEER_CAP_DYNAMIC_ADV)) {
-		zlog_err("%s [Error] BGP dynamic capability is not enabled",
-			 peer->host);
+		flog_err(BGP_ERR_NO_CAP,
+			  "%s [Error] BGP dynamic capability is not enabled",
+			  peer->host);
 		bgp_notify_send(peer, BGP_NOTIFY_HEADER_ERR,
 				BGP_NOTIFY_HEADER_BAD_MESTYPE);
 		return BGP_Stop;
@@ -2131,7 +2145,8 @@ int bgp_capability_receive(struct peer *
 
 	/* Status must be Established. */
 	if (peer->status != Established) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_NO_CAP,
 			"%s [Error] Dynamic capability packet received under status %s",
 			peer->host,
 			lookup_msg(bgp_status_msg, peer->status, NULL));
@@ -2212,7 +2227,8 @@ int bgp_process_packet(struct thread *th
 						  memory_order_relaxed);
 			mprc = bgp_open_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_PKT_OPEN,
 					"%s: BGP OPEN receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
@@ -2222,7 +2238,8 @@ int bgp_process_packet(struct thread *th
 			peer->readtime = monotime(NULL);
 			mprc = bgp_update_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: BGP UPDATE receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
@@ -2231,7 +2248,8 @@ int bgp_process_packet(struct thread *th
 						  memory_order_relaxed);
 			mprc = bgp_notify_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_NOTIFY_RCV,
 					"%s: BGP NOTIFY receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
@@ -2241,7 +2259,8 @@ int bgp_process_packet(struct thread *th
 						  memory_order_relaxed);
 			mprc = bgp_keepalive_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_KEEP_RCV,
 					"%s: BGP KEEPALIVE receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
@@ -2251,7 +2270,8 @@ int bgp_process_packet(struct thread *th
 						  memory_order_relaxed);
 			mprc = bgp_route_refresh_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_RFSH_RCV,
 					"%s: BGP ROUTEREFRESH receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
@@ -2260,7 +2280,8 @@ int bgp_process_packet(struct thread *th
 						  memory_order_relaxed);
 			mprc = bgp_capability_receive(peer, size);
 			if (mprc == BGP_Stop)
-				zlog_err(
+				flog_err(
+					BGP_ERR_CAP_RCV,
 					"%s: BGP CAPABILITY receipt failed for peer: %s",
 					__FUNCTION__, peer->host);
 			break;
diff -urpN frr-frr-5.0.1/bgpd/bgp_pbr.c frr-frr-6.0/bgpd/bgp_pbr.c
--- frr-frr-5.0.1/bgpd/bgp_pbr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_pbr.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_mplsvpn.h"
 #include "bgpd/bgp_flowspec_private.h"
+#include "bgpd/bgp_errors.h"
 
 DEFINE_MTYPE_STATIC(BGPD, PBR_MATCH_ENTRY, "PBR match entry")
 DEFINE_MTYPE_STATIC(BGPD, PBR_MATCH, "PBR match")
@@ -231,6 +232,8 @@ static void bgp_pbr_policyroute_add_to_z
 						  struct nexthop *nh,
 						  float *rate);
 
+static void bgp_pbr_dump_entry(struct bgp_pbr_filter *bpf, bool add);
+
 static bool bgp_pbr_extract_enumerate_unary_opposite(
 				 uint8_t unary_operator,
 				 struct bgp_pbr_val_mask *and_valmask,
@@ -348,7 +351,7 @@ static bool bgp_pbr_extract_enumerate(st
 				      void *valmask, uint8_t type_entry)
 {
 	bool ret;
-	uint8_t unary_operator_val = unary_operator;
+	uint8_t unary_operator_val;
 	bool double_check = false;
 
 	if ((unary_operator & OPERATOR_UNARY_OR) &&
@@ -650,8 +653,9 @@ static int bgp_pbr_build_and_validate_en
 			action_count++;
 			if (action_count > ACTIONS_MAX_NUM) {
 				if (BGP_DEBUG(pbr, PBR_ERROR))
-					zlog_err("%s: flowspec actions exceeds limit (max %u)",
-						 __func__, action_count);
+					flog_err(BGP_ERR_FLOWSPEC_PACKET,
+						  "%s: flowspec actions exceeds limit (max %u)",
+						  __func__, action_count);
 				break;
 			}
 			api_action = &api->actions[action_count - 1];
@@ -833,12 +837,12 @@ uint32_t bgp_pbr_match_hash_key(void *ar
 
 	key = jhash_1word(pbm->vrf_id, 0x4312abde);
 	key = jhash_1word(pbm->flags, key);
-	key = jhash_1word(pbm->pkt_len_min, key);
-	key = jhash_1word(pbm->pkt_len_max, key);
-	key = jhash_1word(pbm->tcp_flags, key);
-	key = jhash_1word(pbm->tcp_mask_flags, key);
-	key = jhash_1word(pbm->dscp_value, key);
-	key = jhash_1word(pbm->fragment, key);
+	key = jhash(&pbm->pkt_len_min, 2, key);
+	key = jhash(&pbm->pkt_len_max, 2, key);
+	key = jhash(&pbm->tcp_flags, 2, key);
+	key = jhash(&pbm->tcp_mask_flags, 2, key);
+	key = jhash(&pbm->dscp_value, 1, key);
+	key = jhash(&pbm->fragment, 1, key);
 	return jhash_1word(pbm->type, key);
 }
 
@@ -1225,7 +1229,8 @@ static void bgp_pbr_flush_entry(struct b
 			/* unlink bgp_info to bpme */
 			bgp_info = (struct bgp_info *)bpme->bgp_info;
 			extra = bgp_info_extra_get(bgp_info);
-			extra->bgp_fs_pbr = NULL;
+			if (extra->bgp_fs_pbr)
+				listnode_delete(extra->bgp_fs_pbr, bpme);
 			bpme->bgp_info = NULL;
 		}
 	}
@@ -1282,7 +1287,13 @@ static int bgp_pbr_get_remaining_entry(s
 	bpm_temp = bpme->backpointer;
 	if (bpm_temp->vrf_id != bpm->vrf_id ||
 	    bpm_temp->type != bpm->type ||
-	    bpm_temp->flags != bpm->flags)
+	    bpm_temp->flags != bpm->flags ||
+	    bpm_temp->tcp_flags != bpm->tcp_flags ||
+	    bpm_temp->tcp_mask_flags != bpm->tcp_mask_flags ||
+	    bpm_temp->pkt_len_min != bpm->pkt_len_min ||
+	    bpm_temp->pkt_len_max != bpm->pkt_len_max ||
+	    bpm_temp->dscp_value != bpm->dscp_value ||
+	    bpm_temp->fragment != bpm->fragment)
 		return HASHWALK_CONTINUE;
 
 	/* look for remaining bpme */
@@ -1311,6 +1322,9 @@ static void bgp_pbr_policyroute_remove_f
 	dst_port = bpf->dst_port;
 	pkt_len = bpf->pkt_len;
 
+	if (BGP_DEBUG(zebra, ZEBRA))
+		bgp_pbr_dump_entry(bpf, false);
+
 	/* as we don't know information from EC
 	 * look for bpm that have the bpm
 	 * with vrf_id characteristics
@@ -1581,6 +1595,101 @@ static void bgp_pbr_policyroute_remove_f
 		list_delete_all_node(bpof->fragment);
 }
 
+static void bgp_pbr_dump_entry(struct bgp_pbr_filter *bpf, bool add)
+{
+	struct bgp_pbr_range_port *src_port;
+	struct bgp_pbr_range_port *dst_port;
+	struct bgp_pbr_range_port *pkt_len;
+	char bufsrc[64], bufdst[64];
+	char buffer[64];
+	int remaining_len = 0;
+	char protocol_str[16];
+
+	if (!bpf)
+		return;
+	src_port = bpf->src_port;
+	dst_port = bpf->dst_port;
+	pkt_len = bpf->pkt_len;
+
+	protocol_str[0] = '\0';
+	if (bpf->tcp_flags && bpf->tcp_flags->mask)
+		bpf->protocol = IPPROTO_TCP;
+	if (bpf->protocol)
+		snprintf(protocol_str, sizeof(protocol_str),
+			 "proto %d", bpf->protocol);
+	buffer[0] = '\0';
+	if (bpf->protocol == IPPROTO_ICMP && src_port && dst_port)
+		remaining_len += snprintf(buffer, sizeof(buffer),
+					  "type %d, code %d",
+					  src_port->min_port,
+					  dst_port->min_port);
+	else if (bpf->protocol == IPPROTO_UDP ||
+		 bpf->protocol == IPPROTO_TCP) {
+
+		if (src_port && src_port->min_port)
+			remaining_len += snprintf(buffer,
+						  sizeof(buffer),
+						  "from [%u:%u]",
+						  src_port->min_port,
+						  src_port->max_port ?
+						  src_port->max_port :
+						  src_port->min_port);
+		if (dst_port && dst_port->min_port)
+			remaining_len += snprintf(buffer +
+						  remaining_len,
+						  sizeof(buffer)
+						  - remaining_len,
+						  "to [%u:%u]",
+						  dst_port->min_port,
+						  dst_port->max_port ?
+						  dst_port->max_port :
+						  dst_port->min_port);
+	}
+	if (pkt_len && (pkt_len->min_port || pkt_len->max_port)) {
+		remaining_len += snprintf(buffer + remaining_len,
+					  sizeof(buffer)
+					  - remaining_len,
+					  " len [%u:%u]",
+					  pkt_len->min_port,
+					  pkt_len->max_port ?
+					  pkt_len->max_port :
+					  pkt_len->min_port);
+	} else if (bpf->pkt_len_val) {
+		remaining_len += snprintf(buffer + remaining_len,
+					  sizeof(buffer)
+					  - remaining_len,
+					  " %s len %u",
+					  bpf->pkt_len_val->mask
+					  ? "!" : "",
+					  bpf->pkt_len_val->val);
+	}
+	if (bpf->tcp_flags) {
+		remaining_len += snprintf(buffer + remaining_len,
+					  sizeof(buffer)
+					  - remaining_len,
+					  "tcpflags %x/%x",
+					  bpf->tcp_flags->val,
+					  bpf->tcp_flags->mask);
+	}
+	if (bpf->dscp) {
+		snprintf(buffer + remaining_len,
+			 sizeof(buffer)
+			 - remaining_len,
+			 "%s dscp %d",
+			 bpf->dscp->mask
+			 ? "!" : "",
+			 bpf->dscp->val);
+	}
+	zlog_debug("BGP: %s FS PBR from %s to %s, %s %s",
+		  add ? "adding" : "removing",
+		  bpf->src == NULL ? "<all>" :
+		  prefix2str(bpf->src, bufsrc, sizeof(bufsrc)),
+		  bpf->dst == NULL ? "<all>" :
+		  prefix2str(bpf->dst, bufdst, sizeof(bufdst)),
+		  protocol_str, buffer);
+
+}
+
 static void bgp_pbr_policyroute_add_to_zebra_unit(struct bgp *bgp,
 				     struct bgp_info *binfo,
 				     struct bgp_pbr_filter *bpf,
@@ -1597,6 +1706,7 @@ static void bgp_pbr_policyroute_add_to_z
 	struct bgp_pbr_range_port *src_port;
 	struct bgp_pbr_range_port *dst_port;
 	struct bgp_pbr_range_port *pkt_len;
+	bool bpme_found = false;
 
 	if (!bpf)
 		return;
@@ -1604,87 +1714,9 @@ static void bgp_pbr_policyroute_add_to_z
 	dst_port = bpf->dst_port;
 	pkt_len = bpf->pkt_len;
 
-	if (BGP_DEBUG(zebra, ZEBRA)) {
-		char bufsrc[64], bufdst[64];
-		char buffer[64];
-		int remaining_len = 0;
-		char protocol_str[16];
-
-		protocol_str[0] = '\0';
-		if (bpf->tcp_flags && bpf->tcp_flags->mask)
-			bpf->protocol = IPPROTO_TCP;
-		if (bpf->protocol)
-			snprintf(protocol_str, sizeof(protocol_str),
-				 "proto %d", bpf->protocol);
-		buffer[0] = '\0';
-		if (bpf->protocol == IPPROTO_ICMP && src_port && dst_port)
-			remaining_len += snprintf(buffer, sizeof(buffer),
-						  "type %d, code %d",
-				 src_port->min_port, dst_port->min_port);
-		else if (bpf->protocol == IPPROTO_UDP ||
-			 bpf->protocol == IPPROTO_TCP) {
-
-			if (src_port && src_port->min_port)
-				remaining_len += snprintf(buffer,
-							  sizeof(buffer),
-							  "from [%u:%u]",
-							  src_port->min_port,
-							  src_port->max_port ?
-							  src_port->max_port :
-							  src_port->min_port);
-			if (dst_port && dst_port->min_port)
-				remaining_len += snprintf(buffer +
-							  remaining_len,
-							  sizeof(buffer)
-							  - remaining_len,
-							  "to [%u:%u]",
-							  dst_port->min_port,
-							  dst_port->max_port ?
-							  dst_port->max_port :
-							  dst_port->min_port);
-		}
-		if (pkt_len && (pkt_len->min_port || pkt_len->max_port)) {
-			remaining_len += snprintf(buffer + remaining_len,
-						  sizeof(buffer)
-						  - remaining_len,
-						  " len [%u:%u]",
-						  pkt_len->min_port,
-						  pkt_len->max_port ?
-						  pkt_len->max_port :
-						  pkt_len->min_port);
-		} else if (bpf->pkt_len_val) {
-			remaining_len += snprintf(buffer + remaining_len,
-						  sizeof(buffer)
-						  - remaining_len,
-						  " %s len %u",
-						  bpf->pkt_len_val->mask
-						  ? "!" : "",
-						  bpf->pkt_len_val->val);
-		}
-		if (bpf->tcp_flags) {
-			remaining_len += snprintf(buffer + remaining_len,
-						  sizeof(buffer)
-						  - remaining_len,
-						  "tcpflags %x/%x",
-						  bpf->tcp_flags->val,
-						  bpf->tcp_flags->mask);
-		}
-		if (bpf->dscp) {
-			snprintf(buffer + remaining_len,
-				 sizeof(buffer)
-				 - remaining_len,
-				 "%s dscp %d",
-				 bpf->dscp->mask
-				 ? "!" : "",
-				 bpf->dscp->val);
-		}
-		zlog_info("BGP: adding FS PBR from %s to %s, %s %s",
-			  bpf->src == NULL ? "<all>" :
-			  prefix2str(bpf->src, bufsrc, sizeof(bufsrc)),
-			  bpf->dst == NULL ? "<all>" :
-			  prefix2str(bpf->dst, bufdst, sizeof(bufdst)),
-			  protocol_str, buffer);
-	}
+	if (BGP_DEBUG(zebra, ZEBRA))
+		bgp_pbr_dump_entry(bpf, true);
+
 	/* look for bpa first */
 	memset(&temp3, 0, sizeof(temp3));
 	if (rate)
@@ -1775,7 +1807,7 @@ static void bgp_pbr_policyroute_add_to_z
 		       bgp_pbr_match_alloc_intern);
 
 	/* new, then self allocate ipset_name and unique */
-	if (bpm && bpm->unique == 0) {
+	if (bpm->unique == 0) {
 		bpm->unique = ++bgp_pbr_match_counter_unique;
 		/* 0 value is forbidden */
 		sprintf(bpm->ipset_name, "match%p", bpm);
@@ -1806,10 +1838,9 @@ static void bgp_pbr_policyroute_add_to_z
 	temp2.src_port_max = src_port ? src_port->max_port : 0;
 	temp2.dst_port_max = dst_port ? dst_port->max_port : 0;
 	temp2.proto = bpf->protocol;
-	if (bpm)
-		bpme = hash_get(bpm->entry_hash, &temp2,
-				bgp_pbr_match_entry_alloc_intern);
-	if (bpme && bpme->unique == 0) {
+	bpme = hash_get(bpm->entry_hash, &temp2,
+			bgp_pbr_match_entry_alloc_intern);
+	if (bpme->unique == 0) {
 		bpme->unique = ++bgp_pbr_match_entry_counter_unique;
 		/* 0 value is forbidden */
 		bpme->backpointer = bpm;
@@ -1817,8 +1848,21 @@ static void bgp_pbr_policyroute_add_to_z
 		bpme->install_in_progress = false;
 		/* link bgp info to bpme */
 		bpme->bgp_info = (void *)binfo;
-	}
+	} else
+		bpme_found = true;
 
+	/* already installed */
+	if (bpme_found) {
+		struct bgp_info_extra *extra = bgp_info_extra_get(binfo);
+
+		if (extra && extra->bgp_fs_pbr &&
+		    listnode_lookup(extra->bgp_fs_pbr, bpme)) {
+			if (BGP_DEBUG(pbr, PBR_ERROR))
+				zlog_err("%s: entry %p/%p already installed in bgp pbr",
+					 __func__, binfo, bpme);
+			return;
+		}
+	}
 	/* BGP FS: append entry to zebra
 	 * - policies are not routing entries and as such
 	 * route replace semantics don't necessarily follow
@@ -2195,7 +2239,6 @@ void bgp_pbr_update_entry(struct bgp *bg
 			 bool nlri_update)
 {
 	struct bgp_pbr_entry_main api;
-	struct bgp_info_extra *extra = bgp_info_extra_get(info);
 
 	if (afi == AFI_IP6)
 		return; /* IPv6 not supported */
@@ -2208,22 +2251,17 @@ void bgp_pbr_update_entry(struct bgp *bg
 
 	if (!bgp_zebra_tm_chunk_obtained()) {
 		if (BGP_DEBUG(pbr, PBR_ERROR))
-			zlog_err("%s: table chunk not obtained yet",
-				 __func__);
-		return;
-	}
-	/* already installed */
-	if (nlri_update && extra->bgp_fs_pbr) {
-		if (BGP_DEBUG(pbr, PBR_ERROR))
-			zlog_err("%s: entry %p already installed in bgp pbr",
-				 __func__, info);
+			flog_err(BGP_ERR_TABLE_CHUNK,
+				  "%s: table chunk not obtained yet",
+				  __func__);
 		return;
 	}
 
 	if (bgp_pbr_build_and_validate_entry(p, info, &api) < 0) {
 		if (BGP_DEBUG(pbr, PBR_ERROR))
-			zlog_err("%s: cancel updating entry %p in bgp pbr",
-				 __func__, info);
+			flog_err(BGP_ERR_FLOWSPEC_INSTALLATION,
+				  "%s: cancel updating entry %p in bgp pbr",
+				  __func__, info);
 		return;
 	}
 	bgp_pbr_handle_entry(bgp, info, &api, nlri_update);
diff -urpN frr-frr-5.0.1/bgpd/bgp_pbr.h frr-frr-6.0/bgpd/bgp_pbr.h
--- frr-frr-5.0.1/bgpd/bgp_pbr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_pbr.h	2018-10-08 14:32:57.000000000 +0200
@@ -57,17 +57,13 @@ struct bgp_pbr_match_val {
 	uint16_t value;
 	uint8_t compare_operator;
 	uint8_t unary_operator;
-} bgp_pbr_value_t;
+};
 
 #define FRAGMENT_DONT  1
 #define FRAGMENT_IS    2
 #define FRAGMENT_FIRST 4
 #define FRAGMENT_LAST  8
 
-struct bgp_pbr_fragment_val {
-	uint8_t bitmask;
-};
-
 struct bgp_pbr_entry_action {
 	/* used to store enum bgp_pbr_action_enum enumerate */
 	uint8_t action;
diff -urpN frr-frr-5.0.1/bgpd/bgp_rd.c frr-frr-6.0/bgpd/bgp_rd.c
--- frr-frr-5.0.1/bgpd/bgp_rd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_rd.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@
 #include "memory.h"
 #include "stream.h"
 #include "filter.h"
+#include "frrstr.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_rd.h"
@@ -210,5 +211,5 @@ void form_auto_rd(struct in_addr router_
 	prd->family = AF_UNSPEC;
 	prd->prefixlen = 64;
 	sprintf(buf, "%s:%hu", inet_ntoa(router_id), rd_id);
-	str2prefix_rd(buf, prd);
+	(void)str2prefix_rd(buf, prd);
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_route.c frr-frr-6.0/bgpd/bgp_route.c
--- frr-frr-5.0.1/bgpd/bgp_route.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_route.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,12 +38,14 @@
 #include "queue.h"
 #include "memory.h"
 #include "lib/json.h"
+#include "lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_table.h"
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_aspath.h"
 #include "bgpd/bgp_regex.h"
 #include "bgpd/bgp_community.h"
@@ -174,16 +176,49 @@ static struct bgp_info_extra *bgp_info_e
 
 static void bgp_info_extra_free(struct bgp_info_extra **extra)
 {
-	if (extra && *extra) {
-		if ((*extra)->damp_info)
-			bgp_damp_info_free((*extra)->damp_info, 0);
+	struct bgp_info_extra *e;
 
-		(*extra)->damp_info = NULL;
+	if (!extra || !*extra)
+		return;
 
-		XFREE(MTYPE_BGP_ROUTE_EXTRA, *extra);
+	e = *extra;
+	if (e->damp_info)
+		bgp_damp_info_free(e->damp_info, 0);
+
+	e->damp_info = NULL;
+	if (e->parent) {
+		struct bgp_info *bi = (struct bgp_info *)e->parent;
+
+		if (bi->net) {
+			/* FIXME: since multiple e may have the same e->parent
+			 * and e->parent->net is holding a refcount for each
+			 * of them, we need to do some fudging here.
+			 *
+			 * WARNING: if bi->net->lock drops to 0, bi may be
+			 * freed as well (because bi->net was holding the
+			 * last reference to bi) => write after free!
+			 */
+			unsigned refcount;
 
-		*extra = NULL;
+			bi = bgp_info_lock(bi);
+			refcount = bi->net->lock - 1;
+			bgp_unlock_node((struct bgp_node *)bi->net);
+			if (!refcount)
+				bi->net = NULL;
+			bgp_info_unlock(bi);
+		}
+		bgp_info_unlock(e->parent);
+		e->parent = NULL;
 	}
+
+	if (e->bgp_orig)
+		bgp_unlock(e->bgp_orig);
+
+	if ((*extra)->bgp_fs_pbr)
+		list_delete_and_null(&((*extra)->bgp_fs_pbr));
+	XFREE(MTYPE_BGP_ROUTE_EXTRA, *extra);
+
+	*extra = NULL;
 }
 
 /* Get bgp_info extra information for the given bgp_info, lazy allocated
@@ -319,14 +354,9 @@ static void bgp_pcount_adjust(struct bgp
 		/* slight hack, but more robust against errors. */
 		if (ri->peer->pcount[table->afi][table->safi])
 			ri->peer->pcount[table->afi][table->safi]--;
-		else {
-			zlog_warn(
-				"%s: Asked to decrement 0 prefix count for peer %s",
-				__func__, ri->peer->host);
-			zlog_backtrace(LOG_WARNING);
-			zlog_warn("%s: Please report to Quagga bugzilla",
-				  __func__);
-		}
+		else
+			flog_err(LIB_ERR_DEVELOPMENT,
+				 "Asked to decrement 0 prefix count for peer");
 	} else if (BGP_INFO_COUNTABLE(ri)
 		   && !CHECK_FLAG(ri->flags, BGP_INFO_COUNTED)) {
 		SET_FLAG(ri->flags, BGP_INFO_COUNTED);
@@ -475,16 +505,18 @@ static int bgp_info_cmp(struct bgp *bgp,
 			}
 
 			if (newattr->sticky && !existattr->sticky) {
-				zlog_warn(
-					"%s: %s wins over %s due to sticky MAC flag",
-					pfx_buf, new_buf, exist_buf);
+				if (debug)
+					zlog_debug(
+						"%s: %s wins over %s due to sticky MAC flag",
+						pfx_buf, new_buf, exist_buf);
 				return 1;
 			}
 
 			if (!newattr->sticky && existattr->sticky) {
-				zlog_warn(
-					"%s: %s loses to %s due to sticky MAC flag",
-					pfx_buf, new_buf, exist_buf);
+				if (debug)
+					zlog_debug(
+						"%s: %s loses to %s due to sticky MAC flag",
+						pfx_buf, new_buf, exist_buf);
 				return 0;
 			}
 		}
@@ -1018,8 +1050,8 @@ static enum filter_type bgp_input_filter
 
 #define FILTER_EXIST_WARN(F, f, filter)                                        \
 	if (BGP_DEBUG(update, UPDATE_IN) && !(F##_IN(filter)))                 \
-		zlog_warn("%s: Could not find configured input %s-list %s!",   \
-			  peer->host, #f, F##_IN_NAME(filter));
+		zlog_debug("%s: Could not find configured input %s-list %s!",  \
+			   peer->host, #f, F##_IN_NAME(filter));
 
 	if (DISTRIBUTE_IN_NAME(filter)) {
 		FILTER_EXIST_WARN(DISTRIBUTE, distribute, filter);
@@ -1057,8 +1089,8 @@ static enum filter_type bgp_output_filte
 
 #define FILTER_EXIST_WARN(F, f, filter)                                        \
 	if (BGP_DEBUG(update, UPDATE_OUT) && !(F##_OUT(filter)))               \
-		zlog_warn("%s: Could not find configured output %s-list %s!",  \
-			  peer->host, #f, F##_OUT_NAME(filter));
+		zlog_debug("%s: Could not find configured output %s-list %s!", \
+			   peer->host, #f, F##_OUT_NAME(filter));
 
 	if (DISTRIBUTE_OUT_NAME(filter)) {
 		FILTER_EXIST_WARN(DISTRIBUTE, distribute, filter);
@@ -1158,6 +1190,7 @@ static int bgp_input_modifier(struct pee
 
 	/* Route map apply. */
 	if (rmap) {
+		memset(&info, 0, sizeof(struct bgp_info));
 		/* Duplicate current value to new strucutre for modification. */
 		info.peer = peer;
 		info.attr = attr;
@@ -1206,6 +1239,7 @@ static int bgp_output_modifier(struct pe
 	if (rmap == NULL)
 		return RMAP_DENY;
 
+	memset(&info, 0, sizeof(struct bgp_info));
 	/* Route map apply. */
 	/* Duplicate current value to new strucutre for modification. */
 	info.peer = peer;
@@ -1301,6 +1335,8 @@ void bgp_attr_add_gshut_community(struct
 	old = attr->community;
 	gshut = community_str2com("graceful-shutdown");
 
+	assert(gshut);
+
 	if (old) {
 		merge = community_merge(community_dup(old), gshut);
 
@@ -1332,6 +1368,8 @@ static void subgroup_announce_reset_nhop
 	}
 	if (family == AF_INET6)
 		memset(&attr->mp_nexthop_global, 0, IPV6_MAX_BYTELEN);
+	if (family == AF_EVPN)
+		memset(&attr->mp_nexthop_global_in, 0, BGP_ATTR_NHLEN_IPV4);
 }
 
 int subgroup_announce_check(struct bgp_node *rn, struct bgp_info *ri,
@@ -1661,6 +1699,7 @@ int subgroup_announce_check(struct bgp_n
 		struct bgp_info_extra dummy_info_extra;
 		struct attr dummy_attr;
 
+		memset(&info, 0, sizeof(struct bgp_info));
 		info.peer = peer;
 		info.attr = attr;
 
@@ -2092,19 +2131,18 @@ int bgp_zebra_has_route_changed(struct b
 {
 	struct bgp_info *mpinfo;
 
-	/* If this is multipath, check all selected paths for any nexthop change
-	 * or
-	 * attribute change. Some attribute changes (e.g., community) aren't of
-	 * relevance to the RIB, but we'll update zebra to ensure we handle the
-	 * case of BGP nexthop change. This is the behavior when the best path
-	 * has
-	 * an attribute change anyway.
+	/* If this is multipath, check all selected paths for any nexthop
+	 * change or attribute change. Some attribute changes (e.g., community)
+	 * aren't of relevance to the RIB, but we'll update zebra to ensure
+	 * we handle the case of BGP nexthop change. This is the behavior
+	 * when the best path has an attribute change anyway.
 	 */
 	if (CHECK_FLAG(selected->flags, BGP_INFO_IGP_CHANGED)
 	    || CHECK_FLAG(selected->flags, BGP_INFO_MULTIPATH_CHG))
 		return 1;
 
-	/* If this is multipath, check all selected paths for any nexthop change
+	/*
+	 * If this is multipath, check all selected paths for any nexthop change
 	 */
 	for (mpinfo = bgp_info_mpath_first(selected); mpinfo;
 	     mpinfo = bgp_info_mpath_next(mpinfo)) {
@@ -2147,7 +2185,6 @@ struct bgp_process_queue {
 static void bgp_process_main_one(struct bgp *bgp, struct bgp_node *rn,
 				 afi_t afi, safi_t safi)
 {
-	struct prefix *p = &rn->p;
 	struct bgp_info *new_select;
 	struct bgp_info *old_select;
 	struct bgp_info_pair old_and_new;
@@ -2170,6 +2207,8 @@ static void bgp_process_main_one(struct
 		return;
 	}
 
+	struct prefix *p = &rn->p;
+
 	debug = bgp_debug_bestpath(&rn->p);
 	if (debug) {
 		prefix2str(&rn->p, pfx_buf, sizeof(pfx_buf));
@@ -2332,10 +2371,18 @@ static void bgp_process_main_one(struct
 		if (new_select && new_select->type == ZEBRA_ROUTE_BGP
 		    && (new_select->sub_type == BGP_ROUTE_NORMAL
 			|| new_select->sub_type == BGP_ROUTE_AGGREGATE
-			|| new_select->sub_type == BGP_ROUTE_IMPORTED))
+			|| new_select->sub_type == BGP_ROUTE_IMPORTED)) {
+
+			/* if this is an evpn imported type-5 prefix,
+			 * we need to withdraw the route first to clear
+			 * the nh neigh and the RMAC entry.
+			 */
+			if (old_select &&
+			    is_route_parent_evpn(old_select))
+				bgp_zebra_withdraw(p, old_select, bgp, safi);
 
 			bgp_zebra_announce(rn, p, new_select, bgp, afi, safi);
-		else {
+		} else {
 			/* Withdraw the route from the kernel. */
 			if (old_select && old_select->type == ZEBRA_ROUTE_BGP
 			    && (old_select->sub_type == BGP_ROUTE_NORMAL
@@ -2349,12 +2396,28 @@ static void bgp_process_main_one(struct
 	/* advertise/withdraw type-5 routes */
 	if ((afi == AFI_IP || afi == AFI_IP6) && (safi == SAFI_UNICAST)) {
 		if (advertise_type5_routes(bgp, afi) && new_select &&
-		    (!new_select->extra || !new_select->extra->parent))
-			bgp_evpn_advertise_type5_route(bgp, &rn->p,
-						       new_select->attr,
-						       afi, safi);
-		else if (advertise_type5_routes(bgp, afi) && old_select &&
-		         (!old_select->extra || !old_select->extra->parent))
+		    (!new_select->extra || !new_select->extra->parent)) {
+
+			/* apply the route-map */
+			if (bgp->adv_cmd_rmap[afi][safi].map) {
+				int ret = 0;
+
+				ret = route_map_apply(
+					bgp->adv_cmd_rmap[afi][safi].map,
+					&rn->p, RMAP_BGP, new_select);
+				if (ret == RMAP_MATCH)
+					bgp_evpn_advertise_type5_route(
+						bgp, &rn->p, new_select->attr,
+						afi, safi);
+			} else {
+				bgp_evpn_advertise_type5_route(bgp,
+							       &rn->p,
+							       new_select->attr,
+							       afi, safi);
+
+			}
+		} else if (advertise_type5_routes(bgp, afi) && old_select &&
+			 (!old_select->extra || !old_select->extra->parent))
 			bgp_evpn_withdraw_type5_route(bgp, &rn->p, afi, safi);
 	}
 
@@ -2410,16 +2473,10 @@ static void bgp_processq_del(struct work
 
 void bgp_process_queue_init(void)
 {
-	if (!bm->process_main_queue) {
+	if (!bm->process_main_queue)
 		bm->process_main_queue =
 			work_queue_new(bm->master, "process_main_queue");
 
-		if (!bm->process_main_queue) {
-			zlog_err("%s: Failed to allocate work queue", __func__);
-			exit(1);
-		}
-	}
-
 	bm->process_main_queue->spec.workfunc = &bgp_process_wq;
 	bm->process_main_queue->spec.del_item_data = &bgp_processq_del;
 	bm->process_main_queue->spec.max_retries = 0;
@@ -2513,7 +2570,9 @@ static int bgp_maximum_prefix_restart_ti
 			"%s Maximum-prefix restart timer expired, restore peering",
 			peer->host);
 
-	peer_clear(peer, NULL);
+	if ((peer_clear(peer, NULL) < 0) && bgp_debug_neighbor_events(peer))
+		zlog_debug("%s: %s peer_clear failed",
+			   __PRETTY_FUNCTION__, peer->host);
 
 	return 0;
 }
@@ -2625,14 +2684,12 @@ static void bgp_rib_withdraw(struct bgp_
 			     struct peer *peer, afi_t afi, safi_t safi,
 			     struct prefix_rd *prd)
 {
-	int status = BGP_DAMP_NONE;
-
 	/* apply dampening, if result is suppressed, we'll be retaining
 	 * the bgp_info in the RIB for historical reference.
 	 */
 	if (CHECK_FLAG(peer->bgp->af_flags[afi][safi], BGP_CONFIG_DAMPENING)
 	    && peer->sort == BGP_PEER_EBGP)
-		if ((status = bgp_damp_withdraw(ri, rn, afi, safi, 0))
+		if ((bgp_damp_withdraw(ri, rn, afi, safi, 0))
 		    == BGP_DAMP_SUPPRESSED) {
 			bgp_aggregate_decrement(peer->bgp, &rn->p, ri, afi,
 						safi);
@@ -3789,11 +3846,7 @@ static void bgp_clear_node_queue_init(st
 	snprintf(wname, sizeof(wname), "clear %s", peer->host);
 #undef CLEAR_QUEUE_NAME_LEN
 
-	if ((peer->clear_node_queue = work_queue_new(bm->master, wname))
-	    == NULL) {
-		zlog_err("%s: Failed to allocate work queue", __func__);
-		exit(1);
-	}
+	peer->clear_node_queue = work_queue_new(bm->master, wname);
 	peer->clear_node_queue->spec.hold = 10;
 	peer->clear_node_queue->spec.workfunc = &bgp_clear_route_node;
 	peer->clear_node_queue->spec.del_item_data = &bgp_clear_node_queue_del;
@@ -4163,8 +4216,9 @@ int bgp_nlri_parse_ip(struct peer *peer,
 
 		/* Prefix length check. */
 		if (p.prefixlen > prefix_blen(&p) * 8) {
-			zlog_err(
-				"%s [Error] Update packet error (wrong perfix length %d for afi %u)",
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
+				"%s [Error] Update packet error (wrong prefix length %d for afi %u)",
 				peer->host, p.prefixlen, packet->afi);
 			return -1;
 		}
@@ -4174,7 +4228,8 @@ int bgp_nlri_parse_ip(struct peer *peer,
 
 		/* When packet overflow occur return immediately. */
 		if (pnt + psize > lim) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error (prefix length %d overflows packet)",
 				peer->host, p.prefixlen);
 			return -1;
@@ -4183,14 +4238,15 @@ int bgp_nlri_parse_ip(struct peer *peer,
 		/* Defensive coding, double-check the psize fits in a struct
 		 * prefix */
 		if (psize > (ssize_t)sizeof(p.u)) {
-			zlog_err(
+			flog_err(
+				BGP_ERR_UPDATE_RCV,
 				"%s [Error] Update packet error (prefix length %d too large for prefix storage %zu)",
 				peer->host, p.prefixlen, sizeof(p.u));
 			return -1;
 		}
 
 		/* Fetch prefix from NLRI packet. */
-		memcpy(&p.u.prefix, pnt, psize);
+		memcpy(p.u.val, pnt, psize);
 
 		/* Check address. */
 		if (afi == AFI_IP && safi == SAFI_UNICAST) {
@@ -4204,7 +4260,8 @@ int bgp_nlri_parse_ip(struct peer *peer,
 				 * be logged locally, and the prefix SHOULD be
 				 * ignored.
 				 */
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv4 unicast NLRI is multicast address %s, ignoring",
 					peer->host, inet_ntoa(p.u.prefix4));
 				continue;
@@ -4216,7 +4273,8 @@ int bgp_nlri_parse_ip(struct peer *peer,
 			if (IN6_IS_ADDR_LINKLOCAL(&p.u.prefix6)) {
 				char buf[BUFSIZ];
 
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv6 unicast NLRI is link-local address %s, ignoring",
 					peer->host,
 					inet_ntop(AF_INET6, &p.u.prefix6, buf,
@@ -4227,7 +4285,8 @@ int bgp_nlri_parse_ip(struct peer *peer,
 			if (IN6_IS_ADDR_MULTICAST(&p.u.prefix6)) {
 				char buf[BUFSIZ];
 
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDATE_RCV,
 					"%s: IPv6 unicast NLRI is multicast address %s, ignoring",
 					peer->host,
 					inet_ntop(AF_INET6, &p.u.prefix6, buf,
@@ -4256,7 +4315,8 @@ int bgp_nlri_parse_ip(struct peer *peer,
 
 	/* Packet length consistency check. */
 	if (pnt != lim) {
-		zlog_err(
+		flog_err(
+			BGP_ERR_UPDATE_RCV,
 			"%s [Error] Update packet error (prefix length mismatch with total length)",
 			peer->host);
 		return -1;
@@ -4317,6 +4377,8 @@ void bgp_static_update(struct bgp *bgp,
 	/* Apply route-map. */
 	if (bgp_static->rmap.name) {
 		struct attr attr_tmp = attr;
+
+		memset(&info, 0, sizeof(struct bgp_info));
 		info.peer = bgp->peer_self;
 		info.attr = &attr_tmp;
 
@@ -4622,7 +4684,7 @@ static void bgp_static_update_safi(struc
 		if (bgp_static->encap_tunneltype == BGP_ENCAP_TYPE_VXLAN) {
 			struct bgp_encap_type_vxlan bet;
 			memset(&bet, 0, sizeof(struct bgp_encap_type_vxlan));
-			bet.vnid = p->u.prefix_evpn.eth_tag;
+			bet.vnid = p->u.prefix_evpn.prefix_addr.eth_tag;
 			bgp_encap_type_vxlan_to_tlv(&bet, &attr);
 		}
 		if (bgp_static->router_mac) {
@@ -5097,10 +5159,10 @@ int bgp_static_set_safi(afi_t afi, safi_
 				return CMD_WARNING_CONFIG_FAILED;
 			}
 			if ((gw_ip.family == AF_INET
-			     && IS_EVPN_PREFIX_IPADDR_V6(
+			     && is_evpn_prefix_ipaddr_v6(
 					(struct prefix_evpn *)&p))
 			    || (gw_ip.family == AF_INET6
-				&& IS_EVPN_PREFIX_IPADDR_V4(
+				&& is_evpn_prefix_ipaddr_v4(
 					   (struct prefix_evpn *)&p))) {
 				vty_out(vty,
 					"%% GatewayIp family differs with IP prefix\n");
@@ -5150,8 +5212,8 @@ int bgp_static_set_safi(afi_t afi, safi_
 			if (routermac) {
 				bgp_static->router_mac =
 					XCALLOC(MTYPE_ATTR, ETH_ALEN + 1);
-				prefix_str2mac(routermac,
-					       bgp_static->router_mac);
+				(void)prefix_str2mac(routermac,
+						     bgp_static->router_mac);
 			}
 			if (gwip)
 				prefix_copy(&bgp_static->gatewayIp, &gw_ip);
@@ -5394,6 +5456,100 @@ static void bgp_aggregate_free(struct bg
 	XFREE(MTYPE_BGP_AGGREGATE, aggregate);
 }
 
+static int bgp_aggregate_info_same(struct bgp_info *ri, uint8_t origin,
+				   struct aspath *aspath,
+				   struct community *comm)
+{
+	static struct aspath *ae = NULL;
+
+	if (!ae)
+		ae = aspath_empty();
+
+	if (!ri)
+		return 0;
+
+	if (origin != ri->attr->origin)
+		return 0;
+
+	if (!aspath_cmp(ri->attr->aspath, (aspath) ? aspath : ae))
+		return 0;
+
+	if (!community_cmp(ri->attr->community, comm))
+		return 0;
+
+	return 1;
+}
+
+static void bgp_aggregate_install(struct bgp *bgp, afi_t afi, safi_t safi,
+				  struct prefix *p, uint8_t origin,
+				  struct aspath *aspath,
+				  struct community *community,
+				  uint8_t atomic_aggregate,
+				  struct bgp_aggregate *aggregate)
+{
+	struct bgp_node *rn;
+	struct bgp_table *table;
+	struct bgp_info *ri, *new;
+
+	table = bgp->rib[afi][safi];
+
+	rn = bgp_node_get(table, p);
+
+	for (ri = rn->info; ri; ri = ri->next)
+		if (ri->peer == bgp->peer_self && ri->type == ZEBRA_ROUTE_BGP
+		    && ri->sub_type == BGP_ROUTE_AGGREGATE)
+			break;
+
+	if (aggregate->count > 0) {
+		/*
+		 * If the aggregate information has not changed
+		 * no need to re-install it again.
+		 */
+		if (bgp_aggregate_info_same(rn->info, origin, aspath,
+					    community)) {
+			bgp_unlock_node(rn);
+
+			if (aspath)
+				aspath_free(aspath);
+			if (community)
+				community_free(community);
+
+			return;
+		}
+
+		/*
+		 * Mark the old as unusable
+		 */
+		if (ri)
+			bgp_info_delete(rn, ri);
+
+		new = info_make(
+			ZEBRA_ROUTE_BGP, BGP_ROUTE_AGGREGATE, 0, bgp->peer_self,
+			bgp_attr_aggregate_intern(bgp, origin, aspath,
+						  community, aggregate->as_set,
+						  atomic_aggregate),
+			rn);
+		SET_FLAG(new->flags, BGP_INFO_VALID);
+
+		bgp_info_add(rn, new);
+		bgp_process(bgp, rn, afi, safi);
+	} else {
+		for (ri = rn->info; ri; ri = ri->next)
+			if (ri->peer == bgp->peer_self
+			    && ri->type == ZEBRA_ROUTE_BGP
+			    && ri->sub_type == BGP_ROUTE_AGGREGATE)
+				break;
+
+		/* Withdraw static BGP route from routing table. */
+		if (ri) {
+			bgp_info_delete(rn, ri);
+			bgp_process(bgp, rn, afi, safi);
+		}
+	}
+
+	bgp_unlock_node(rn);
+}
+
 /* Update an aggregate as routes are added/removed from the BGP table */
 static void bgp_aggregate_route(struct bgp *bgp, struct prefix *p,
 				struct bgp_info *rinew, afi_t afi, safi_t safi,
@@ -5408,24 +5564,10 @@ static void bgp_aggregate_route(struct b
 	struct aspath *asmerge = NULL;
 	struct community *community = NULL;
 	struct community *commerge = NULL;
-#if defined(AGGREGATE_NEXTHOP_CHECK)
-	struct in_addr nexthop;
-	uint32_t med = 0;
-#endif
 	struct bgp_info *ri;
-	struct bgp_info *new;
-	int first = 1;
 	unsigned long match = 0;
 	uint8_t atomic_aggregate = 0;
 
-	/* Record adding route's nexthop and med. */
-	if (rinew) {
-#if defined(AGGREGATE_NEXTHOP_CHECK)
-		nexthop = rinew->attr->nexthop;
-		med = rinew->attr->med;
-#endif
-	}
-
 	/* ORIGIN attribute: If at least one route among routes that are
 	   aggregated has ORIGIN with the value INCOMPLETE, then the
 	   aggregated route must have the ORIGIN attribute with the value
@@ -5440,88 +5582,81 @@ static void bgp_aggregate_route(struct b
 
 	top = bgp_node_get(table, p);
 	for (rn = bgp_node_get(table, p); rn;
-	     rn = bgp_route_next_until(rn, top))
-		if (rn->p.prefixlen > p->prefixlen) {
-			match = 0;
+	     rn = bgp_route_next_until(rn, top)) {
+		if (rn->p.prefixlen <= p->prefixlen)
+			continue;
 
-			for (ri = rn->info; ri; ri = ri->next) {
-				if (BGP_INFO_HOLDDOWN(ri))
-					continue;
+		match = 0;
 
-				if (del && ri == del)
-					continue;
+		for (ri = rn->info; ri; ri = ri->next) {
+			if (BGP_INFO_HOLDDOWN(ri))
+				continue;
 
-				if (!rinew && first) {
-#if defined(AGGREGATE_NEXTHOP_CHECK)
-					nexthop = ri->attr->nexthop;
-					med = ri->attr->med;
-#endif
-					first = 0;
-				}
+			if (del && ri == del)
+				continue;
 
-#ifdef AGGREGATE_NEXTHOP_CHECK
-				if (!IPV4_ADDR_SAME(&ri->attr->nexthop,
-						    &nexthop)
-				    || ri->attr->med != med) {
-					if (aspath)
-						aspath_free(aspath);
-					if (community)
-						community_free(community);
-					bgp_unlock_node(rn);
-					bgp_unlock_node(top);
-					return;
-				}
-#endif /* AGGREGATE_NEXTHOP_CHECK */
+			if (ri->attr->flag
+			    & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE))
+				atomic_aggregate = 1;
 
-				if (ri->attr->flag
-				    & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE))
-					atomic_aggregate = 1;
-
-				if (ri->sub_type != BGP_ROUTE_AGGREGATE) {
-					if (aggregate->summary_only) {
-						(bgp_info_extra_get(ri))
-							->suppress++;
-						bgp_info_set_flag(
-							rn, ri,
-							BGP_INFO_ATTR_CHANGED);
-						match++;
-					}
+			if (ri->sub_type == BGP_ROUTE_AGGREGATE)
+				continue;
 
-					aggregate->count++;
+			/*
+			 * summary-only aggregate route suppress
+			 * aggregated route announcements.
+			 */
+			if (aggregate->summary_only) {
+				(bgp_info_extra_get(ri))->suppress++;
+				bgp_info_set_flag(rn, ri,
+						  BGP_INFO_ATTR_CHANGED);
+				match++;
+			}
 
-					if (origin < ri->attr->origin)
-						origin = ri->attr->origin;
+			aggregate->count++;
 
-					if (aggregate->as_set) {
-						if (aspath) {
-							asmerge = aspath_aggregate(
-								aspath,
-								ri->attr->aspath);
-							aspath_free(aspath);
-							aspath = asmerge;
-						} else
-							aspath = aspath_dup(
-								ri->attr->aspath);
-
-						if (ri->attr->community) {
-							if (community) {
-								commerge = community_merge(
-									community,
-									ri->attr->community);
-								community = community_uniq_sort(
-									commerge);
-								community_free(
-									commerge);
-							} else
-								community = community_dup(
-									ri->attr->community);
-						}
-					}
-				}
-			}
-			if (match)
-				bgp_process(bgp, rn, afi, safi);
+			/*
+                        * If at least one route among routes that are
+                        * aggregated has ORIGIN with the value INCOMPLETE,
+                        * then the aggregated route MUST have the ORIGIN
+                        * attribute with the value INCOMPLETE.  Otherwise, if
+                        * at least one route among routes that are aggregated
+                        * has ORIGIN with the value EGP, then the aggregated
+                        * route MUST have the ORIGIN attribute with the value
+                        * EGP.
+                        */
+			if (origin < ri->attr->origin)
+				origin = ri->attr->origin;
+
+			if (!aggregate->as_set)
+				continue;
+
+			/*
+			 * as-set aggregate route generate origin, as path,
+			 * and community aggregation.
+			 */
+			if (aspath) {
+				asmerge = aspath_aggregate(aspath,
+							   ri->attr->aspath);
+				aspath_free(aspath);
+				aspath = asmerge;
+			} else
+				aspath = aspath_dup(ri->attr->aspath);
+
+			if (!ri->attr->community)
+				continue;
+
+			if (community) {
+				commerge = community_merge(community,
+							   ri->attr->community);
+				community = community_uniq_sort(commerge);
+				community_free(commerge);
+			} else
+				community = community_dup(ri->attr->community);
 		}
+		if (match)
+			bgp_process(bgp, rn, afi, safi);
+	}
 	bgp_unlock_node(top);
 
 	if (rinew) {
@@ -5557,20 +5692,10 @@ static void bgp_aggregate_route(struct b
 		}
 	}
 
-	if (aggregate->count > 0) {
-		rn = bgp_node_get(table, p);
-		new = info_make(
-			ZEBRA_ROUTE_BGP, BGP_ROUTE_AGGREGATE, 0, bgp->peer_self,
-			bgp_attr_aggregate_intern(bgp, origin, aspath,
-						  community, aggregate->as_set,
-						  atomic_aggregate),
-			rn);
-		SET_FLAG(new->flags, BGP_INFO_VALID);
+	bgp_aggregate_install(bgp, afi, safi, p, origin, aspath, community,
+			      atomic_aggregate, aggregate);
 
-		bgp_info_add(rn, new);
-		bgp_unlock_node(rn);
-		bgp_process(bgp, rn, afi, safi);
-	} else {
+	if (aggregate->count == 0) {
 		if (aspath)
 			aspath_free(aspath);
 		if (community)
@@ -5578,8 +5703,50 @@ static void bgp_aggregate_route(struct b
 	}
 }
 
-void bgp_aggregate_delete(struct bgp *, struct prefix *, afi_t, safi_t,
-			  struct bgp_aggregate *);
+static void bgp_aggregate_delete(struct bgp *bgp, struct prefix *p, afi_t afi,
+				 safi_t safi, struct bgp_aggregate *aggregate)
+{
+	struct bgp_table *table;
+	struct bgp_node *top;
+	struct bgp_node *rn;
+	struct bgp_info *ri;
+	unsigned long match;
+
+	table = bgp->rib[afi][safi];
+
+	/* If routes exists below this node, generate aggregate routes. */
+	top = bgp_node_get(table, p);
+	for (rn = bgp_node_get(table, p); rn;
+	     rn = bgp_route_next_until(rn, top)) {
+		if (rn->p.prefixlen <= p->prefixlen)
+			continue;
+		match = 0;
+
+		for (ri = rn->info; ri; ri = ri->next) {
+			if (BGP_INFO_HOLDDOWN(ri))
+				continue;
+
+			if (ri->sub_type == BGP_ROUTE_AGGREGATE)
+				continue;
+
+			if (aggregate->summary_only && ri->extra) {
+				ri->extra->suppress--;
+
+				if (ri->extra->suppress == 0) {
+					bgp_info_set_flag(
+						rn, ri, BGP_INFO_ATTR_CHANGED);
+					match++;
+				}
+			}
+			aggregate->count--;
+		}
+
+		/* If this node was suppressed, process the change. */
+		if (match)
+			bgp_process(bgp, rn, afi, safi);
+	}
+	bgp_unlock_node(top);
+}
 
 void bgp_aggregate_increment(struct bgp *bgp, struct prefix *p,
 			     struct bgp_info *ri, afi_t afi, safi_t safi)
@@ -5589,12 +5756,6 @@ void bgp_aggregate_increment(struct bgp
 	struct bgp_aggregate *aggregate;
 	struct bgp_table *table;
 
-	/* MPLS-VPN aggregation is not yet supported. */
-	if ((safi == SAFI_MPLS_VPN) || (safi == SAFI_ENCAP)
-	    || (safi == SAFI_EVPN)
-	    || (safi == SAFI_FLOWSPEC))
-		return;
-
 	table = bgp->aggregate[afi][safi];
 
 	/* No aggregates configured. */
@@ -5628,12 +5789,6 @@ void bgp_aggregate_decrement(struct bgp
 	struct bgp_aggregate *aggregate;
 	struct bgp_table *table;
 
-	/* MPLS-VPN aggregation is not yet supported. */
-	if ((safi == SAFI_MPLS_VPN) || (safi == SAFI_ENCAP)
-	    || (safi == SAFI_EVPN)
-	    || (safi == SAFI_FLOWSPEC))
-		return;
-
 	table = bgp->aggregate[afi][safi];
 
 	/* No aggregates configured. */
@@ -5656,196 +5811,6 @@ void bgp_aggregate_decrement(struct bgp
 	bgp_unlock_node(child);
 }
 
-/* Called via bgp_aggregate_set when the user configures aggregate-address */
-static void bgp_aggregate_add(struct bgp *bgp, struct prefix *p, afi_t afi,
-			      safi_t safi, struct bgp_aggregate *aggregate)
-{
-	struct bgp_table *table;
-	struct bgp_node *top;
-	struct bgp_node *rn;
-	struct bgp_info *new;
-	struct bgp_info *ri;
-	unsigned long match;
-	uint8_t origin = BGP_ORIGIN_IGP;
-	struct aspath *aspath = NULL;
-	struct aspath *asmerge = NULL;
-	struct community *community = NULL;
-	struct community *commerge = NULL;
-	uint8_t atomic_aggregate = 0;
-
-	table = bgp->rib[afi][safi];
-
-	/* Sanity check. */
-	if (afi == AFI_IP && p->prefixlen == IPV4_MAX_BITLEN)
-		return;
-	if (afi == AFI_IP6 && p->prefixlen == IPV6_MAX_BITLEN)
-		return;
-
-	/* If routes exists below this node, generate aggregate routes. */
-	top = bgp_node_get(table, p);
-	for (rn = bgp_node_get(table, p); rn;
-	     rn = bgp_route_next_until(rn, top)) {
-		if (rn->p.prefixlen <= p->prefixlen)
-			continue;
-
-		match = 0;
-
-		for (ri = rn->info; ri; ri = ri->next) {
-			if (BGP_INFO_HOLDDOWN(ri))
-				continue;
-
-			if (ri->attr->flag
-			    & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE))
-				atomic_aggregate = 1;
-
-			if (ri->sub_type == BGP_ROUTE_AGGREGATE)
-				continue;
-
-			/* summary-only aggregate route suppress
-			 * aggregated route announcement.  */
-			if (aggregate->summary_only) {
-				(bgp_info_extra_get(ri))->suppress++;
-				bgp_info_set_flag(rn, ri,
-						  BGP_INFO_ATTR_CHANGED);
-				match++;
-			}
-
-			/* If at least one route among routes that are
-			 * aggregated has ORIGIN with the value INCOMPLETE,
-			 * then the aggregated route MUST have the ORIGIN
-			 * attribute with the value INCOMPLETE.  Otherwise, if
-			 * at least one route among routes that are aggregated
-			 * has ORIGIN with the value EGP, then the aggregated
-			 * route MUST have the ORIGIN attribute with the value
-			 * EGP.
-			 */
-			if (origin < ri->attr->origin)
-				origin = ri->attr->origin;
-
-			/* as-set aggregate route generate origin, as path,
-			 * community aggregation.  */
-			if (aggregate->as_set) {
-				if (aspath) {
-					asmerge = aspath_aggregate(
-						aspath, ri->attr->aspath);
-					aspath_free(aspath);
-					aspath = asmerge;
-				} else
-					aspath = aspath_dup(ri->attr->aspath);
-
-				if (ri->attr->community) {
-					if (community) {
-						commerge = community_merge(
-							community,
-							ri->attr->community);
-						community = community_uniq_sort(
-							commerge);
-						community_free(commerge);
-					} else
-						community = community_dup(
-							ri->attr->community);
-				}
-			}
-			aggregate->count++;
-		}
-
-		/* If this node is suppressed, process the change. */
-		if (match)
-			bgp_process(bgp, rn, afi, safi);
-	}
-	bgp_unlock_node(top);
-
-	/* Add aggregate route to BGP table. */
-	if (aggregate->count) {
-		rn = bgp_node_get(table, p);
-		new = info_make(
-			ZEBRA_ROUTE_BGP, BGP_ROUTE_AGGREGATE, 0, bgp->peer_self,
-			bgp_attr_aggregate_intern(bgp, origin, aspath,
-						  community, aggregate->as_set,
-						  atomic_aggregate),
-			rn);
-		SET_FLAG(new->flags, BGP_INFO_VALID);
-
-		bgp_info_add(rn, new);
-		bgp_unlock_node(rn);
-
-		/* Process change. */
-		bgp_process(bgp, rn, afi, safi);
-	} else {
-		if (aspath)
-			aspath_free(aspath);
-		if (community)
-			community_free(community);
-	}
-}
-
-void bgp_aggregate_delete(struct bgp *bgp, struct prefix *p, afi_t afi,
-			  safi_t safi, struct bgp_aggregate *aggregate)
-{
-	struct bgp_table *table;
-	struct bgp_node *top;
-	struct bgp_node *rn;
-	struct bgp_info *ri;
-	unsigned long match;
-
-	table = bgp->rib[afi][safi];
-
-	if (afi == AFI_IP && p->prefixlen == IPV4_MAX_BITLEN)
-		return;
-	if (afi == AFI_IP6 && p->prefixlen == IPV6_MAX_BITLEN)
-		return;
-
-	/* If routes exists below this node, generate aggregate routes. */
-	top = bgp_node_get(table, p);
-	for (rn = bgp_node_get(table, p); rn;
-	     rn = bgp_route_next_until(rn, top)) {
-		if (rn->p.prefixlen <= p->prefixlen)
-			continue;
-		match = 0;
-
-		for (ri = rn->info; ri; ri = ri->next) {
-			if (BGP_INFO_HOLDDOWN(ri))
-				continue;
-
-			if (ri->sub_type == BGP_ROUTE_AGGREGATE)
-				continue;
-
-			if (aggregate->summary_only && ri->extra) {
-				ri->extra->suppress--;
-
-				if (ri->extra->suppress == 0) {
-					bgp_info_set_flag(
-						rn, ri, BGP_INFO_ATTR_CHANGED);
-					match++;
-				}
-			}
-			aggregate->count--;
-		}
-
-		/* If this node was suppressed, process the change. */
-		if (match)
-			bgp_process(bgp, rn, afi, safi);
-	}
-	bgp_unlock_node(top);
-
-	/* Delete aggregate route from BGP table. */
-	rn = bgp_node_get(table, p);
-
-	for (ri = rn->info; ri; ri = ri->next)
-		if (ri->peer == bgp->peer_self && ri->type == ZEBRA_ROUTE_BGP
-		    && ri->sub_type == BGP_ROUTE_AGGREGATE)
-			break;
-
-	/* Withdraw static BGP route from routing table. */
-	if (ri) {
-		bgp_info_delete(rn, ri);
-		bgp_process(bgp, rn, afi, safi);
-	}
-
-	/* Unlock bgp_node_lookup. */
-	bgp_unlock_node(rn);
-}
-
 /* Aggregate route attribute. */
 #define AGGREGATE_SUMMARY_ONLY 1
 #define AGGREGATE_AS_SET       1
@@ -5859,9 +5824,6 @@ static int bgp_aggregate_unset(struct vt
 	struct bgp_node *rn;
 	struct bgp_aggregate *aggregate;
 
-	if (safi == SAFI_FLOWSPEC)
-		return CMD_WARNING_CONFIG_FAILED;
-
 	/* Convert string to prefix structure. */
 	ret = str2prefix(prefix_str, &p);
 	if (!ret) {
@@ -5879,13 +5841,8 @@ static int bgp_aggregate_unset(struct vt
 	}
 
 	aggregate = rn->info;
-	if (aggregate->safi == SAFI_UNICAST)
-		bgp_aggregate_delete(bgp, &p, afi, SAFI_UNICAST, aggregate);
-	if (aggregate->safi == SAFI_LABELED_UNICAST)
-		bgp_aggregate_delete(bgp, &p, afi, SAFI_LABELED_UNICAST,
-				     aggregate);
-	if (aggregate->safi == SAFI_MULTICAST)
-		bgp_aggregate_delete(bgp, &p, afi, SAFI_MULTICAST, aggregate);
+	bgp_aggregate_delete(bgp, &p, afi, safi, aggregate);
+	bgp_aggregate_install(bgp, afi, safi, &p, 0, NULL, NULL, 0, aggregate);
 
 	/* Unlock aggregate address configuration. */
 	rn->info = NULL;
@@ -5905,9 +5862,6 @@ static int bgp_aggregate_set(struct vty
 	struct bgp_node *rn;
 	struct bgp_aggregate *aggregate;
 
-	if (safi == SAFI_FLOWSPEC)
-		return CMD_WARNING_CONFIG_FAILED;
-
 	/* Convert string to prefix structure. */
 	ret = str2prefix(prefix_str, &p);
 	if (!ret) {
@@ -5916,6 +5870,13 @@ static int bgp_aggregate_set(struct vty
 	}
 	apply_mask(&p);
 
+	if ((afi == AFI_IP && p.prefixlen == IPV4_MAX_BITLEN) ||
+	    (afi == AFI_IP6 && p.prefixlen == IPV6_MAX_BITLEN)) {
+		vty_out(vty, "Specified prefix: %s will not result in any useful aggregation, disallowing\n",
+			prefix_str);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
 	/* Old configuration check. */
 	rn = bgp_node_get(bgp->aggregate[afi][safi], &p);
 
@@ -5938,13 +5899,7 @@ static int bgp_aggregate_set(struct vty
 	rn->info = aggregate;
 
 	/* Aggregate address insert into BGP routing table. */
-	if (safi == SAFI_UNICAST)
-		bgp_aggregate_add(bgp, &p, afi, SAFI_UNICAST, aggregate);
-	if (safi == SAFI_LABELED_UNICAST)
-		bgp_aggregate_add(bgp, &p, afi, SAFI_LABELED_UNICAST,
-				  aggregate);
-	if (safi == SAFI_MULTICAST)
-		bgp_aggregate_add(bgp, &p, afi, SAFI_MULTICAST, aggregate);
+	bgp_aggregate_route(bgp, &p, NULL, afi, safi, NULL, aggregate);
 
 	return CMD_SUCCESS;
 }
@@ -6148,6 +6103,7 @@ void bgp_redistribute_add(struct bgp *bg
 
 		/* Apply route-map. */
 		if (red->rmap.name) {
+			memset(&info, 0, sizeof(struct bgp_info));
 			info.peer = bgp->peer_self;
 			info.attr = &attr_new;
 
@@ -6315,24 +6271,14 @@ static void route_vty_out_route(struct p
 				json_object *json)
 {
 	int len = 0;
-	uint32_t destination;
 	char buf[BUFSIZ];
 
 	if (p->family == AF_INET) {
 		if (!json) {
-			len = vty_out(vty, "%s",
-				      inet_ntop(p->family, &p->u.prefix, buf,
-						BUFSIZ));
-			destination = ntohl(p->u.prefix4.s_addr);
-
-			if ((IN_CLASSC(destination) && p->prefixlen == 24)
-			    || (IN_CLASSB(destination) && p->prefixlen == 16)
-			    || (IN_CLASSA(destination) && p->prefixlen == 8)
-			    || p->u.prefix4.s_addr == 0) {
-				/* When mask is natural,
-				   mask is not displayed. */
-			} else
-				len += vty_out(vty, "/%d", p->prefixlen);
+			len = vty_out(
+				vty, "%s/%d",
+				inet_ntop(p->family, &p->u.prefix, buf, BUFSIZ),
+				p->prefixlen);
 		} else {
 			json_object_string_add(json, "prefix",
 					       inet_ntop(p->family,
@@ -6344,7 +6290,6 @@ static void route_vty_out_route(struct p
 		prefix2str(p, buf, PREFIX_STRLEN);
 		len = vty_out(vty, "%s", buf);
 	} else if (p->family == AF_EVPN) {
-#if defined(HAVE_CUMULUS)
 		if (!json)
 			len = vty_out(
 				vty, "%s",
@@ -6352,10 +6297,6 @@ static void route_vty_out_route(struct p
 						   BUFSIZ));
 		else
 			bgp_evpn_route2json((struct prefix_evpn *)p, json);
-#else
-		prefix2str(p, buf, PREFIX_STRLEN);
-		len = vty_out(vty, "%s", buf);
-#endif
 	} else if (p->family == AF_FLOWSPEC) {
 		route_vty_out_flowspec(vty, p, NULL,
 			       json ?
@@ -6628,14 +6569,8 @@ void route_vty_out(struct vty *vty, stru
 		} else {
 			char buf[BUFSIZ];
 
-			if ((safi == SAFI_MPLS_VPN) || (safi == SAFI_EVPN))
-				snprintf(buf, sizeof(buf), "%s%s",
-					inet_ntoa(attr->mp_nexthop_global_in),
-					vrf_id_str);
-			else
-				snprintf(buf, sizeof(buf), "%s%s",
-					inet_ntoa(attr->nexthop),
-					vrf_id_str);
+			snprintf(buf, sizeof(buf), "%s%s",
+				inet_ntoa(attr->nexthop), vrf_id_str);
 			vty_out(vty, "%-16s", buf);
 		}
 	}
@@ -7016,8 +6951,8 @@ void route_vty_out_tag(struct vty *vty,
 			   || (safi == SAFI_EVPN
 			       && BGP_ATTR_NEXTHOP_AFI_IP6(attr))
 			   || (BGP_ATTR_NEXTHOP_AFI_IP6(attr))) {
-			char buf_a[BUFSIZ];
-			char buf_b[BUFSIZ];
+			char buf_a[512];
+			char buf_b[512];
 			char buf_c[BUFSIZ];
 			if (attr->mp_nexthop_len
 			    == BGP_ATTR_NHLEN_IPV6_GLOBAL) {
@@ -7027,22 +6962,22 @@ void route_vty_out_tag(struct vty *vty,
 						inet_ntop(
 							AF_INET6,
 							&attr->mp_nexthop_global,
-							buf_a, BUFSIZ));
+							buf_a, sizeof(buf_a)));
 				else
 					vty_out(vty, "%s",
 						inet_ntop(
 							AF_INET6,
 							&attr->mp_nexthop_global,
-							buf_a, BUFSIZ));
+							buf_a, sizeof(buf_a)));
 			} else if (attr->mp_nexthop_len
 				   == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {
 				if (json) {
 					inet_ntop(AF_INET6,
 						  &attr->mp_nexthop_global,
-						  buf_a, BUFSIZ);
+						  buf_a, sizeof(buf_a));
 					inet_ntop(AF_INET6,
 						  &attr->mp_nexthop_local,
-						  buf_b, BUFSIZ);
+						  buf_b, sizeof(buf_b));
 					sprintf(buf_c, "%s(%s)", buf_a, buf_b);
 					json_object_string_add(
 						json_out,
@@ -7052,11 +6987,11 @@ void route_vty_out_tag(struct vty *vty,
 						inet_ntop(
 							AF_INET6,
 							&attr->mp_nexthop_global,
-							buf_a, BUFSIZ),
+							buf_a, sizeof(buf_a)),
 						inet_ntop(
 							AF_INET6,
 							&attr->mp_nexthop_local,
-							buf_b, BUFSIZ));
+							buf_b, sizeof(buf_b)));
 			}
 		}
 	}
@@ -7125,10 +7060,10 @@ void route_vty_out_overlay(struct vty *v
 		vty_out(vty, "%s", str);
 		XFREE(MTYPE_TMP, str);
 
-		if (IS_EVPN_PREFIX_IPADDR_V4((struct prefix_evpn *)p)) {
+		if (is_evpn_prefix_ipaddr_v4((struct prefix_evpn *)p)) {
 			vty_out(vty, "/%s",
 				inet_ntoa(attr->evpn_overlay.gw_ip.ipv4));
-		} else if (IS_EVPN_PREFIX_IPADDR_V6((struct prefix_evpn *)p)) {
+		} else if (is_evpn_prefix_ipaddr_v6((struct prefix_evpn *)p)) {
 			vty_out(vty, "/%s",
 				inet_ntop(AF_INET6,
 					  &(attr->evpn_overlay.gw_ip.ipv6), buf,
@@ -7369,9 +7304,7 @@ void route_vty_out_detail(struct vty *vt
 {
 	char buf[INET6_ADDRSTRLEN];
 	char buf1[BUFSIZ];
-#if defined(HAVE_CUMULUS)
 	char buf2[EVPN_ROUTE_STRLEN];
-#endif
 	struct attr *attr;
 	int sockunion_vty_out(struct vty *, union sockunion *);
 	time_t tbuf;
@@ -7404,7 +7337,6 @@ void route_vty_out_detail(struct vty *vt
 		json_nexthop_global = json_object_new_object();
 	}
 
-#if defined(HAVE_CUMULUS)
 	if (!json_paths && safi == SAFI_EVPN) {
 		char tag_buf[30];
 
@@ -7434,7 +7366,6 @@ void route_vty_out_detail(struct vty *vt
 			}
 		}
 	}
-#endif
 
 	attr = binfo->attr;
 
@@ -7812,13 +7743,6 @@ void route_vty_out_detail(struct vty *vt
 			else
 				vty_out(vty, ", localpref %u",
 					attr->local_pref);
-		} else {
-			if (json_paths)
-				json_object_int_add(json_path, "localpref",
-						    bgp->default_local_pref);
-			else
-				vty_out(vty, ", localpref %u",
-					bgp->default_local_pref);
 		}
 
 		if (attr->weight != 0) {
@@ -8087,14 +8011,9 @@ void route_vty_out_detail(struct vty *vt
 		if (binfo->extra && binfo->extra->damp_info)
 			bgp_damp_info_vty(vty, binfo, json_path);
 
-/* Remote Label */
-#if defined(HAVE_CUMULUS)
+		/* Remote Label */
 		if (binfo->extra && bgp_is_valid_label(&binfo->extra->label[0])
-		    && safi != SAFI_EVPN)
-#else
-		if (binfo->extra && bgp_is_valid_label(&binfo->extra->label[0]))
-#endif
-		{
+		    && safi != SAFI_EVPN) {
 			mpls_label_t label =
 				label_pton(&binfo->extra->label[0]);
 			if (json_paths)
@@ -8246,7 +8165,7 @@ static int bgp_show_regexp(struct vty *v
 			   afi_t afi, safi_t safi, enum bgp_show_type type);
 static int bgp_show_community(struct vty *vty, struct bgp *bgp,
 			      const char *comstr, int exact, afi_t afi,
-			      safi_t safi);
+			      safi_t safi, uint8_t use_json);
 
 
 static int bgp_show_table(struct vty *vty, struct bgp *bgp, safi_t safi,
@@ -8284,7 +8203,6 @@ static int bgp_show_table(struct vty *vt
 			vty_out(vty, " \"routeDistinguishers\" : {");
 			++*json_header_depth;
 		}
-		json_paths = json_object_new_object();
 	}
 
 	if (use_json && rd) {
@@ -8511,8 +8429,6 @@ static int bgp_show_table(struct vty *vt
 		*total_cum = total_count;
 	}
 	if (use_json) {
-		if (json_paths)
-			json_object_free(json_paths);
 		if (rd) {
 			vty_out(vty, " }%s ", (is_last ? "" : ","));
 		}
@@ -8665,16 +8581,24 @@ void route_vty_out_detail_header(struct
 	struct listnode *node, *nnode;
 	char buf1[RD_ADDRSTRLEN];
 	char buf2[INET6_ADDRSTRLEN];
-#if defined(HAVE_CUMULUS)
 	char buf3[EVPN_ROUTE_STRLEN];
-#endif
 	char prefix_str[BUFSIZ];
 	int count = 0;
 	int best = 0;
 	int suppress = 0;
+	int accept_own = 0;
+	int route_filter_translated_v4 = 0;
+	int route_filter_v4 = 0;
+	int route_filter_translated_v6 = 0;
+	int route_filter_v6 = 0;
+	int llgr_stale = 0;
+	int no_llgr = 0;
+	int accept_own_nexthop = 0;
+	int blackhole = 0;
 	int no_export = 0;
 	int no_advertise = 0;
 	int local_as = 0;
+	int no_peer = 0;
 	int first = 1;
 	int has_valid_label = 0;
 	mpls_label_t label = 0;
@@ -8694,7 +8618,6 @@ void route_vty_out_detail_header(struct
 			json, "prefix",
 			prefix2str(p, prefix_str, sizeof(prefix_str)));
 	} else {
-#if defined(HAVE_CUMULUS)
 		if (safi == SAFI_EVPN)
 			vty_out(vty, "BGP routing table entry for %s%s%s\n",
 				prd ? prefix_rd2str(prd, buf1, sizeof(buf1))
@@ -8712,29 +8635,10 @@ void route_vty_out_detail_header(struct
 				inet_ntop(p->family, &p->u.prefix, buf2,
 					  INET6_ADDRSTRLEN),
 				p->prefixlen);
-#else
-		if (p->family == AF_ETHERNET)
-			prefix2str(p, buf2, INET6_ADDRSTRLEN);
-		else
-			inet_ntop(p->family, &p->u.prefix, buf2,
-				  INET6_ADDRSTRLEN);
-		vty_out(vty, "BGP routing table entry for %s%s%s/%d\n",
-			((safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP
-			  || safi == SAFI_EVPN)
-				 ? prefix_rd2str(prd, buf1, sizeof(buf1))
-				 : ""),
-			((safi == SAFI_MPLS_VPN) || (safi == SAFI_EVPN)) ? ":"
-									 : "",
-			buf2, p->prefixlen);
-#endif
 
 		if (has_valid_label)
 			vty_out(vty, "Local label: %d\n", label);
-#if defined(HAVE_CUMULUS)
 		if (bgp_labeled_safi(safi) && safi != SAFI_EVPN)
-#else
-		if (bgp_labeled_safi(safi))
-#endif
 			vty_out(vty, "not allocated\n");
 	}
 
@@ -8771,12 +8675,41 @@ void route_vty_out_detail_header(struct
 		} else
 			vty_out(vty, ", no best path");
 
-		if (no_advertise)
-			vty_out(vty, ", not advertised to any peer");
+		if (accept_own)
+			vty_out(vty,
+			", accept own local route exported and imported in different VRF");
+		else if (route_filter_translated_v4)
+			vty_out(vty,
+			", mark translated RTs for VPNv4 route filtering");
+		else if (route_filter_v4)
+			vty_out(vty,
+			", attach RT as-is for VPNv4 route filtering");
+		else if (route_filter_translated_v6)
+			vty_out(vty,
+			", mark translated RTs for VPNv6 route filtering");
+		else if (route_filter_v6)
+			vty_out(vty,
+			", attach RT as-is for VPNv6 route filtering");
+		else if (llgr_stale)
+			vty_out(vty,
+			", mark routes to be retained for a longer time. Requeres support for Long-lived BGP Graceful Restart");
+		else if (no_llgr)
+			vty_out(vty,
+			", mark routes to not be treated according to Long-lived BGP Graceful Restart operations");
+		else if (accept_own_nexthop)
+			vty_out(vty,
+			", accept local nexthop");
+		else if (blackhole)
+			vty_out(vty, ", inform peer to blackhole prefix");
 		else if (no_export)
 			vty_out(vty, ", not advertised to EBGP peer");
+		else if (no_advertise)
+			vty_out(vty, ", not advertised to any peer");
 		else if (local_as)
 			vty_out(vty, ", not advertised outside local AS");
+		else if (no_peer)
+			vty_out(vty,
+			", inform EBGP peer not to advertise to their EBGP peers");
 
 		if (suppress)
 			vty_out(vty,
@@ -8894,17 +8827,11 @@ static int bgp_show_route_in_table(struc
 			bgp_unlock_node(rm);
 		}
 	} else if (safi == SAFI_FLOWSPEC) {
-		rn = bgp_flowspec_get_match_per_ip(afi, rib,
-						   &match, prefix_check);
-		if (rn != NULL) {
-			route_vty_out_flowspec(vty, &rn->p,
-					       rn->info, use_json ?
-					       NLRI_STRING_FORMAT_JSON :
-					       NLRI_STRING_FORMAT_LARGE,
-					       json_paths);
-			display++;
-			bgp_unlock_node(rn);
-		}
+		display = bgp_flowspec_display_match_per_ip(afi, rib,
+					   &match, prefix_check,
+					   vty,
+					   use_json,
+					   json_paths);
 	} else {
 		header = 1;
 
@@ -9143,7 +9070,10 @@ DEFUN (show_ip_bgp,
            |prefix-list WORD\
            |filter-list WORD\
            |statistics\
-           |community <AA:NN|local-AS|no-advertise|no-export|graceful-shutdown> [exact-match]\
+           |community <AA:NN|local-AS|no-advertise|no-export|graceful-shutdown\
+           no-peer|blackhole|llgr-stale|no-llgr|accept-own|accept-own-nexthop\
+           route-filter-v6|route-filter-v4|route-filter-translated-v6|\
+           route-filter-translated-v4> [exact-match]\
            |community-list <(1-500)|WORD> [exact-match]\
            |A.B.C.D/M longer-prefixes\
            |X:X::X:X/M longer-prefixes\
@@ -9169,6 +9099,16 @@ DEFUN (show_ip_bgp,
        "Do not advertise to any peer (well-known community)\n"
        "Do not export to next AS (well-known community)\n"
        "Graceful shutdown (well-known community)\n"
+       "Do not export to any peer (well-known community)\n"
+       "Inform EBGP peers to blackhole traffic to prefix (well-known community)\n"
+       "Staled Long-lived Graceful Restart VPN route (well-known community)\n"
+       "Removed because Long-lived Graceful Restart was not enabled for VPN route (well-known community)\n"
+       "Should accept local VPN route if exported and imported into different VRF (well-known community)\n"
+       "Should accept VPN route with local nexthop (well-known community)\n"
+       "RT VPNv6 route filtering (well-known community)\n"
+       "RT VPNv4 route filtering (well-known community)\n"
+       "RT translated VPNv6 route filtering (well-known community)\n"
+       "RT translated VPNv4 route filtering (well-known community)\n"
        "Exact match of the communities\n"
        "Display routes matching the community-list\n"
        "community-list number\n"
@@ -9184,7 +9124,6 @@ DEFUN (show_ip_bgp,
 	int exact_match = 0;
 	struct bgp *bgp = NULL;
 	int idx = 0;
-	int idx_community_type = 0;
 
 	bgp_vty_find_and_parse_afi_safi_bgp(vty, argv, argc, &idx, &afi, &safi,
 					    &bgp);
@@ -9211,24 +9150,6 @@ DEFUN (show_ip_bgp,
 		return bgp_show_route_map(vty, bgp, argv[idx + 1]->arg, afi,
 					  safi, bgp_show_type_route_map);
 
-	if (argv_find(argv, argc, "community", &idx)) {
-		/* show a specific community */
-		if (argv_find(argv, argc, "local-AS", &idx_community_type)
-		    || argv_find(argv, argc, "no-advertise",
-				 &idx_community_type)
-		    || argv_find(argv, argc, "no-export", &idx_community_type)
-		    || argv_find(argv, argc, "graceful-shutdown",
-				 &idx_community_type)
-		    || argv_find(argv, argc, "AA:NN", &idx_community_type)) {
-
-			if (argv_find(argv, argc, "exact-match", &idx))
-				exact_match = 1;
-			return bgp_show_community(vty, bgp,
-						  argv[idx_community_type]->arg,
-						  exact_match, afi, safi);
-		}
-	}
-
 	if (argv_find(argv, argc, "community-list", &idx)) {
 		const char *clist_number_or_name = argv[++idx]->arg;
 		if (++idx < argc && strmatch(argv[idx]->text, "exact-match"))
@@ -9253,7 +9174,7 @@ DEFUN (show_ip_bgp_json,
           [<\
              cidr-only\
              |dampening <flap-statistics|dampened-paths>\
-             |community \
+             |community [<AA:NN|local-AS|no-advertise|no-export|graceful-shutdown>] [exact-match]\
           >] [json]",
        SHOW_STR
        IP_STR
@@ -9266,6 +9187,12 @@ DEFUN (show_ip_bgp_json,
        "Display flap statistics of routes\n"
        "Display paths suppressed due to dampening\n"
        "Display routes matching the communities\n"
+       COMMUNITY_AANN_STR
+       "Do not send outside local AS (well-known community)\n"
+       "Do not advertise to any peer (well-known community)\n"
+       "Do not export to next AS (well-known community)\n"
+       "Graceful shutdown (well-known community)\n"
+       "Exact match of the communities\n"
        JSON_STR)
 {
 	afi_t afi = AFI_IP6;
@@ -9273,6 +9200,8 @@ DEFUN (show_ip_bgp_json,
 	enum bgp_show_type sh_type = bgp_show_type_normal;
 	struct bgp *bgp = NULL;
 	int idx = 0;
+	int idx_community_type = 0;
+	int exact_match = 0;
 
 	bgp_vty_find_and_parse_afi_safi_bgp(vty, argv, argc, &idx, &afi, &safi,
 					    &bgp);
@@ -9298,10 +9227,31 @@ DEFUN (show_ip_bgp_json,
 	}
 
 	if (argv_find(argv, argc, "community", &idx)) {
-		/* show all communities */
-		return bgp_show(vty, bgp, afi, safi,
-				bgp_show_type_community_all, NULL, uj);
+
+		/* show a specific community */
+		if (argv_find(argv, argc, "local-AS", &idx_community_type) ||
+			argv_find(argv, argc, "no-advertise",
+					&idx_community_type) ||
+			argv_find(argv, argc, "no-export",
+					&idx_community_type) ||
+			argv_find(argv, argc, "graceful-shutdown",
+					&idx_community_type) ||
+			argv_find(argv, argc, "AA:NN", &idx_community_type)) {
+			if (argv_find(argv, argc, "exact-match", &idx))
+				exact_match = 1;
+
+			return (bgp_show_community(vty, bgp,
+						argv[idx_community_type]->arg,
+						exact_match, afi, safi, uj));
+		} else {
+
+			/* show all communities */
+			return (bgp_show(vty, bgp, afi, safi,
+					bgp_show_type_community_all, NULL,
+					uj));
+		}
 	}
+
 	return bgp_show(vty, bgp, afi, safi, sh_type, NULL, uj);
 }
 
@@ -9508,7 +9458,7 @@ static int bgp_show_route_map(struct vty
 
 static int bgp_show_community(struct vty *vty, struct bgp *bgp,
 			      const char *comstr, int exact, afi_t afi,
-			      safi_t safi)
+			      safi_t safi, uint8_t use_json)
 {
 	struct community *com;
 	int ret = 0;
@@ -9522,7 +9472,7 @@ static int bgp_show_community(struct vty
 	ret = bgp_show(vty, bgp, afi, safi,
 		       (exact ? bgp_show_type_community_exact
 			      : bgp_show_type_community),
-		       com, 0);
+		       com, use_json);
 	community_free(com);
 
 	return ret;
@@ -9610,13 +9560,13 @@ static struct peer *peer_lookup_in_view(
 			json_object *json_no = NULL;
 			json_no = json_object_new_object();
 			json_object_string_add(json_no, "warning",
-					       "No such neighbor");
+					       "No such neighbor in this view/vrf");
 			vty_out(vty, "%s\n",
 				json_object_to_json_string_ext(
 					json_no, JSON_C_TO_STRING_PRETTY));
 			json_object_free(json_no);
 		} else
-			vty_out(vty, "No such neighbor\n");
+			vty_out(vty, "No such neighbor in this view/vrf\n");
 		return NULL;
 	}
 
@@ -9673,7 +9623,7 @@ ravg_tally (unsigned long count, unsigne
   unsigned long newtot = (count-1) * oldavg + (newval * TALLY_SIGFIG);
   unsigned long res = (newtot * TALLY_SIGFIG) / count;
   unsigned long ret = newtot / count;
-  
+
   if ((res % TALLY_SIGFIG) > (TALLY_SIGFIG/2))
     return ret + 1;
   else
@@ -9767,7 +9717,7 @@ static int bgp_table_stats_walker(struct
 				ts->counts[BGP_STATS_ASPATH_TOTHOPS] += hops;
 				ts->counts[BGP_STATS_ASPATH_TOTSIZE] += size;
 #if 0
-              ts->counts[BGP_STATS_ASPATH_AVGHOPS] 
+              ts->counts[BGP_STATS_ASPATH_AVGHOPS]
                 = ravg_tally (ts->counts[BGP_STATS_ASPATH_COUNT],
                               ts->counts[BGP_STATS_ASPATH_AVGHOPS],
                               hops);
@@ -9920,8 +9870,6 @@ static int bgp_peer_count_walker(struct
 				pc->count[PCOUNT_ADJ_IN]++;
 
 		for (ri = rn->info; ri; ri = ri->next) {
-			char buf[SU_ADDRSTRLEN];
-
 			if (ri->peer != peer)
 				continue;
 
@@ -9943,22 +9891,12 @@ static int bgp_peer_count_walker(struct
 			if (CHECK_FLAG(ri->flags, BGP_INFO_COUNTED)) {
 				pc->count[PCOUNT_COUNTED]++;
 				if (CHECK_FLAG(ri->flags, BGP_INFO_UNUSEABLE))
-					zlog_warn(
-						"%s [pcount] %s/%d is counted but flags 0x%x",
-						peer->host,
-						inet_ntop(rn->p.family,
-							  &rn->p.u.prefix, buf,
-							  SU_ADDRSTRLEN),
-						rn->p.prefixlen, ri->flags);
+					flog_err(LIB_ERR_DEVELOPMENT,
+						 "Attempting to count but flags say it is unusable");
 			} else {
 				if (!CHECK_FLAG(ri->flags, BGP_INFO_UNUSEABLE))
-					zlog_warn(
-						"%s [pcount] %s/%d not counted but flags 0x%x",
-						peer->host,
-						inet_ntop(rn->p.family,
-							  &rn->p.u.prefix, buf,
-							  SU_ADDRSTRLEN),
-						rn->p.prefixlen, ri->flags);
+					flog_err(LIB_ERR_DEVELOPMENT,
+						 "Not counted but flags say we should");
 			}
 		}
 	}
@@ -10204,6 +10142,7 @@ static void show_adj_route(struct vty *v
 	json_object *json_ocode = NULL;
 	json_object *json_ar = NULL;
 	struct peer_af *paf;
+	bool route_filtered;
 
 	if (use_json) {
 		json_scode = json_object_new_object();
@@ -10254,9 +10193,9 @@ static void show_adj_route(struct vty *v
 					       json_scode);
 			json_object_object_add(json, "bgpOriginCodes",
 					       json_ocode);
-			json_object_string_add(json,
-					       "bgpOriginatingDefaultNetwork",
-					       "0.0.0.0");
+			json_object_string_add(
+				json, "bgpOriginatingDefaultNetwork",
+				(afi == AFI_IP) ? "0.0.0.0/0" : "::/0");
 		} else {
 			vty_out(vty, "BGP table version is %" PRIu64
 				     ", local router ID is %s, vrf id ",
@@ -10270,7 +10209,8 @@ static void show_adj_route(struct vty *v
 			vty_out(vty, BGP_SHOW_NCODE_HEADER);
 			vty_out(vty, BGP_SHOW_OCODE_HEADER);
 
-			vty_out(vty, "Originating default network 0.0.0.0\n\n");
+			vty_out(vty, "Originating default network %s\n\n",
+				(afi == AFI_IP) ? "0.0.0.0/0" : "::/0");
 		}
 		header1 = 0;
 	}
@@ -10326,17 +10266,27 @@ static void show_adj_route(struct vty *v
 				}
 
 				bgp_attr_dup(&attr, ain->attr);
+				route_filtered = false;
+
+				/* Filter prefix using distribute list,
+				 * filter list or prefix list
+				 */
+				if ((bgp_input_filter(peer, &rn->p, &attr, afi,
+						safi)) == FILTER_DENY)
+					route_filtered = true;
+
+				/* Filter prefix using route-map */
 				ret = bgp_input_modifier(peer, &rn->p, &attr,
-							 afi, safi, rmap_name);
+							afi, safi, rmap_name);
 
-				if (type == bgp_show_adj_route_filtered
-				    && ret != RMAP_DENY) {
+				if (type == bgp_show_adj_route_filtered &&
+					!route_filtered && ret != RMAP_DENY) {
 					bgp_attr_undup(&attr, ain->attr);
 					continue;
 				}
 
-				if (type == bgp_show_adj_route_received
-				    && ret == RMAP_DENY)
+				if (type == bgp_show_adj_route_received &&
+					(route_filtered || ret == RMAP_DENY))
 					filtered_count++;
 
 				route_vty_out_tmp(vty, &rn->p, &attr, safi,
@@ -10727,10 +10677,8 @@ DEFUN (show_ip_bgp_neighbor_routes,
 	peerstr = argv[++idx]->arg;
 
 	peer = peer_lookup_in_view(vty, bgp, peerstr, uj);
-	if (!peer) {
-		vty_out(vty, "No such neighbor\n");
+	if (!peer)
 		return CMD_WARNING;
-	}
 
 	if (argv_find(argv, argc, "flap-statistics", &idx))
 		sh_type = bgp_show_type_flap_neighbor;
@@ -11376,7 +11324,7 @@ static void bgp_config_write_network_evp
 	struct prefix *p;
 	struct prefix_rd *prd;
 	struct bgp_static *bgp_static;
-	char buf[PREFIX_STRLEN];
+	char buf[PREFIX_STRLEN * 2];
 	char buf2[SU_ADDRSTRLEN];
 	char rdbuf[RD_ADDRSTRLEN];
 
@@ -11405,14 +11353,15 @@ static void bgp_config_write_network_evp
 			prefix_rd2str(prd, rdbuf, sizeof(rdbuf));
 			if (p->u.prefix_evpn.route_type == 5) {
 				char local_buf[PREFIX_STRLEN];
-				uint8_t family = IS_EVPN_PREFIX_IPADDR_V4((
+				uint8_t family = is_evpn_prefix_ipaddr_v4((
 							 struct prefix_evpn *)p)
 							 ? AF_INET
 							 : AF_INET6;
-				inet_ntop(family, &p->u.prefix_evpn.ip.ip.addr,
+				inet_ntop(family,
+					  &p->u.prefix_evpn.prefix_addr.ip.ip.addr,
 					  local_buf, PREFIX_STRLEN);
 				sprintf(buf, "%s/%u", local_buf,
-					p->u.prefix_evpn.ip_prefix_length);
+					p->u.prefix_evpn.prefix_addr.ip_prefix_length);
 			} else {
 				prefix2str(p, buf, sizeof(buf));
 			}
@@ -11424,7 +11373,8 @@ static void bgp_config_write_network_evp
 					  sizeof(buf2));
 			vty_out(vty,
 				"  network %s rd %s ethtag %u label %u esi %s gwip %s routermac %s\n",
-				buf, rdbuf, p->u.prefix_evpn.eth_tag,
+				buf, rdbuf,
+				p->u.prefix_evpn.prefix_addr.eth_tag,
 				decode_label(&bgp_static->label), esi, buf2,
 				macrouter);
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_route.h frr-frr-6.0/bgpd/bgp_route.h
--- frr-frr-5.0.1/bgpd/bgp_route.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_route.h	2018-10-08 14:32:57.000000000 +0200
@@ -147,7 +147,7 @@ struct bgp_info_extra {
 	 */
 	struct prefix nexthop_orig;
 	/* presence of FS pbr entry */
-	void *bgp_fs_pbr;
+	struct list *bgp_fs_pbr;
 };
 
 struct bgp_info {
diff -urpN frr-frr-5.0.1/bgpd/bgp_routemap.c frr-frr-6.0/bgpd/bgp_routemap.c
--- frr-frr-5.0.1/bgpd/bgp_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,7 @@
 #include "sockunion.h"
 #include "hash.h"
 #include "queue.h"
+#include "frrstr.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_table.h"
@@ -233,7 +234,8 @@ struct bgp_match_peer_compiled {
 /* Compares the peer specified in the 'match peer' clause with the peer
     received in bgp_info->peer. If it is the same, or if the peer structure
     received is a peer_group containing it, returns RMAP_MATCH. */
-static route_map_result_t route_match_peer(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_peer(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -333,7 +335,7 @@ struct route_map_rule_cmd route_match_pe
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_ip_address(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -373,7 +375,7 @@ struct route_map_rule_cmd route_match_ip
 
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_ip_next_hop(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -420,7 +422,7 @@ struct route_map_rule_cmd route_match_ip
 
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_ip_route_source(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *pfx,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -429,7 +431,7 @@ static route_map_result_t route_match_ip
 	struct peer *peer;
 	struct prefix_ipv4 p;
 
-	if (type == RMAP_BGP && prefix->family == AF_INET) {
+	if (type == RMAP_BGP && pfx->family == AF_INET) {
 		bgp_info = object;
 		peer = bgp_info->peer;
 
@@ -472,7 +474,7 @@ struct route_map_rule_cmd route_match_ip
 /* `match ip address prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_address_prefix_list(void *rule, const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -507,7 +509,7 @@ struct route_map_rule_cmd route_match_ip
 /* `match ip next-hop prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_next_hop_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_next_hop_prefix_list(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -549,7 +551,8 @@ struct route_map_rule_cmd route_match_ip
 /* `match ip route-source prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_route_source_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_route_source_prefix_list(void *rule,
+					const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -598,7 +601,7 @@ struct route_map_rule_cmd route_match_ip
 
 /* Match function should return 1 if match is success else 0 */
 static route_map_result_t route_match_evpn_default_route(void *rule,
-							 struct prefix *p,
+							 const struct prefix *p,
 							 route_map_object_t
 							 type, void *object)
 {
@@ -617,7 +620,7 @@ struct route_map_rule_cmd route_match_ev
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_mac_address(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -634,7 +637,7 @@ static route_map_result_t route_match_ma
 
 		p.family = AF_ETHERNET;
 		p.prefixlen = ETH_ALEN * 8;
-		p.u.prefix_eth = prefix->u.prefix_evpn.mac;
+		p.u.prefix_eth = prefix->u.prefix_evpn.macip_addr.mac;
 
 		return (access_list_apply(alist, &p) == FILTER_DENY
 				? RMAP_NOMATCH
@@ -666,7 +669,8 @@ struct route_map_rule_cmd route_match_ma
 
 /* Match function should return 1 if match is success else return
    zero. */
-static route_map_result_t route_match_vni(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_vni(void *rule,
+					  const struct prefix *prefix,
 					  route_map_object_t type, void *object)
 {
 	vni_t vni = 0;
@@ -676,6 +680,9 @@ static route_map_result_t route_match_vn
 		vni = *((vni_t *)rule);
 		bgp_info = (struct bgp_info *)object;
 
+		if (bgp_info->extra == NULL)
+			return RMAP_NOMATCH;
+
 		if (vni == label2vni(&bgp_info->extra->label[0]))
 			return RMAP_MATCH;
 	}
@@ -718,7 +725,7 @@ struct route_map_rule_cmd route_match_ev
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_evpn_route_type(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *pfx,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -727,7 +734,7 @@ static route_map_result_t route_match_ev
 	if (type == RMAP_BGP) {
 		route_type = *((uint8_t *)rule);
 
-		if (route_type == prefix->u.prefix_evpn.route_type)
+		if (route_type == pfx->u.prefix_evpn.route_type)
 			return RMAP_MATCH;
 	}
 
@@ -766,7 +773,7 @@ struct route_map_rule_cmd route_match_ev
 
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_local_pref(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -825,7 +832,8 @@ struct route_map_rule_cmd route_match_lo
 /* `match metric METRIC' */
 
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_metric(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -848,7 +856,8 @@ struct route_map_rule_cmd route_match_me
 /* `match as-path ASPATH' */
 
 /* Match function for as-path match.  I assume given object is */
-static route_map_result_t route_match_aspath(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_aspath(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -897,7 +906,7 @@ struct rmap_community {
 
 /* Match function for community match. */
 static route_map_result_t route_match_community(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -965,7 +974,7 @@ struct route_map_rule_cmd route_match_co
 
 /* Match function for lcommunity match. */
 static route_map_result_t route_match_lcommunity(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -1026,7 +1035,7 @@ struct route_map_rule_cmd route_match_lc
 
 /* Match function for extcommunity match. */
 static route_map_result_t route_match_ecommunity(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -1068,7 +1077,8 @@ struct route_map_rule_cmd route_match_ec
    and `address-family vpnv4'.  */
 
 /* `match origin' */
-static route_map_result_t route_match_origin(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_origin(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -1116,7 +1126,7 @@ struct route_map_rule_cmd route_match_or
 /* match probability  { */
 
 static route_map_result_t route_match_probability(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -1171,7 +1181,7 @@ struct route_map_rule_cmd route_match_pr
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_interface(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -1217,7 +1227,8 @@ struct route_map_rule_cmd route_match_in
 /* `set ip next-hop IP_ADDRESS' */
 
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_tag(void *rule,
+					  const struct prefix *prefix,
 					  route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -1250,7 +1261,7 @@ struct rmap_ip_nexthop_set {
 };
 
 static route_map_result_t route_set_ip_nexthop(void *rule,
-					       struct prefix *prefix,
+					       const struct prefix *prefix,
 					       route_map_object_t type,
 					       void *object)
 {
@@ -1294,6 +1305,9 @@ static route_map_result_t route_set_ip_n
 			bgp_info->attr->nexthop = *rins->address;
 			SET_FLAG(bgp_info->attr->rmap_change_flags,
 				 BATTR_RMAP_IPV4_NHOP_CHANGED);
+			/* case for MP-BGP : MPLS VPN */
+			bgp_info->attr->mp_nexthop_global_in = *rins->address;
+			bgp_info->attr->mp_nexthop_len = sizeof(*rins->address);
 		}
 	}
 
@@ -1355,7 +1369,7 @@ struct route_map_rule_cmd route_set_ip_n
 
 /* Set local preference. */
 static route_map_result_t route_set_local_pref(void *rule,
-					       struct prefix *prefix,
+					       const struct prefix *prefix,
 					       route_map_object_t type,
 					       void *object)
 {
@@ -1389,7 +1403,8 @@ struct route_map_rule_cmd route_set_loca
 /* `set weight WEIGHT' */
 
 /* Set weight. */
-static route_map_result_t route_set_weight(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_weight(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -1417,7 +1432,8 @@ struct route_map_rule_cmd route_set_weig
 /* `set metric METRIC' */
 
 /* Set metric to attribute. */
-static route_map_result_t route_set_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_metric(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -1450,7 +1466,7 @@ struct route_map_rule_cmd route_set_metr
 
 /* For AS path prepend mechanism. */
 static route_map_result_t route_set_aspath_prepend(void *rule,
-						   struct prefix *prefix,
+						   const struct prefix *prefix,
 						   route_map_object_t type,
 						   void *object)
 {
@@ -1513,7 +1529,7 @@ struct route_map_rule_cmd route_set_aspa
  * Make a deep copy of existing AS_PATH, but for the first ASn only.
  */
 static route_map_result_t route_set_aspath_exclude(void *rule,
-						   struct prefix *dummy,
+						   const struct prefix *dummy,
 						   route_map_object_t type,
 						   void *object)
 {
@@ -1547,7 +1563,8 @@ struct rmap_com_set {
 };
 
 /* For community set mechanism. */
-static route_map_result_t route_set_community(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_community(void *rule,
+					      const struct prefix *prefix,
 					      route_map_object_t type,
 					      void *object)
 {
@@ -1663,7 +1680,7 @@ struct rmap_lcom_set {
 
 /* For lcommunity set mechanism. */
 static route_map_result_t route_set_lcommunity(void *rule,
-					       struct prefix *prefix,
+					       const struct prefix *prefix,
 					       route_map_object_t type,
 					       void *object)
 {
@@ -1776,7 +1793,7 @@ struct route_map_rule_cmd route_set_lcom
 
 /* For large community set mechanism. */
 static route_map_result_t route_set_lcommunity_delete(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *pfx,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -1859,10 +1876,11 @@ struct route_map_rule_cmd route_set_lcom
 /* `set comm-list (<1-99>|<100-500>|WORD) delete' */
 
 /* For community set mechanism. */
-static route_map_result_t route_set_community_delete(void *rule,
-						     struct prefix *prefix,
-						     route_map_object_t type,
-						     void *object)
+static route_map_result_t route_set_community_delete(
+	void *rule,
+	const struct prefix *prefix,
+	route_map_object_t type,
+	void *object)
 {
 	struct community_list *list;
 	struct community *merge;
@@ -1943,7 +1961,7 @@ struct route_map_rule_cmd route_set_comm
 
 /* For community set mechanism.  Used by _rt and _soo. */
 static route_map_result_t route_set_ecommunity(void *rule,
-					       struct prefix *prefix,
+					       const struct prefix *prefix,
 					       route_map_object_t type,
 					       void *object)
 {
@@ -2030,7 +2048,8 @@ struct route_map_rule_cmd route_set_ecom
 /* `set origin ORIGIN' */
 
 /* For origin set. */
-static route_map_result_t route_set_origin(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_origin(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -2080,7 +2099,7 @@ struct route_map_rule_cmd route_set_orig
 
 /* For atomic aggregate set. */
 static route_map_result_t route_set_atomic_aggregate(void *rule,
-						     struct prefix *prefix,
+						     const struct prefix *pfx,
 						     route_map_object_t type,
 						     void *object)
 {
@@ -2120,7 +2139,7 @@ struct aggregator {
 };
 
 static route_map_result_t route_set_aggregator_as(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -2173,7 +2192,8 @@ struct route_map_rule_cmd route_set_aggr
 };
 
 /* Set tag to object. object must be pointer to struct bgp_info */
-static route_map_result_t route_set_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_tag(void *rule,
+					const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -2198,7 +2218,7 @@ static struct route_map_rule_cmd route_s
 
 /* Set label-index to object. object must be pointer to struct bgp_info */
 static route_map_result_t route_set_label_index(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -2232,7 +2252,7 @@ static struct route_map_rule_cmd route_s
 /* `match ipv6 address IP_ACCESS_LIST' */
 
 static route_map_result_t route_match_ipv6_address(void *rule,
-						   struct prefix *prefix,
+						   const struct prefix *prefix,
 						   route_map_object_t type,
 						   void *object)
 {
@@ -2268,7 +2288,7 @@ struct route_map_rule_cmd route_match_ip
 /* `match ipv6 next-hop IP_ADDRESS' */
 
 static route_map_result_t route_match_ipv6_next_hop(void *rule,
-						    struct prefix *prefix,
+						    const struct prefix *prefix,
 						    route_map_object_t type,
 						    void *object)
 {
@@ -2320,7 +2340,7 @@ struct route_map_rule_cmd route_match_ip
 /* `match ipv6 address prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ipv6_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ipv6_address_prefix_list(void *rule, const struct prefix *prefix,
 				     route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -2356,7 +2376,7 @@ struct route_map_rule_cmd route_match_ip
 
 /* Set nexthop to object.  ojbect must be pointer to struct attr. */
 static route_map_result_t route_set_ipv6_nexthop_global(void *rule,
-							struct prefix *prefix,
+							const struct prefix *p,
 							route_map_object_t type,
 							void *object)
 {
@@ -2416,7 +2436,7 @@ struct route_map_rule_cmd route_set_ipv6
 
 /* Set next-hop preference value. */
 static route_map_result_t
-route_set_ipv6_nexthop_prefer_global(void *rule, struct prefix *prefix,
+route_set_ipv6_nexthop_prefer_global(void *rule, const struct prefix *prefix,
 				     route_map_object_t type, void *object)
 {
 	struct bgp_info *bgp_info;
@@ -2470,7 +2490,7 @@ struct route_map_rule_cmd route_set_ipv6
 
 /* Set nexthop to object.  ojbect must be pointer to struct attr. */
 static route_map_result_t route_set_ipv6_nexthop_local(void *rule,
-						       struct prefix *prefix,
+						       const struct prefix *p,
 						       route_map_object_t type,
 						       void *object)
 {
@@ -2533,7 +2553,7 @@ struct route_map_rule_cmd route_set_ipv6
 
 /* Set nexthop to object.  ojbect must be pointer to struct attr. */
 static route_map_result_t route_set_ipv6_nexthop_peer(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *pfx,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -2612,7 +2632,7 @@ struct route_map_rule_cmd route_set_ipv6
 /* `set ipv4 vpn next-hop A.B.C.D' */
 
 static route_map_result_t route_set_vpnv4_nexthop(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -2652,7 +2672,7 @@ static void *route_set_vpnv4_nexthop_com
 /* `set ipv6 vpn next-hop A.B.C.D' */
 
 static route_map_result_t route_set_vpnv6_nexthop(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -2708,7 +2728,7 @@ struct route_map_rule_cmd route_set_vpnv
 
 /* For origin set. */
 static route_map_result_t route_set_originator_id(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -3109,7 +3129,7 @@ static void bgp_route_map_process_update
 	}
 }
 
-static int bgp_route_map_process_update_cb(char *rmap_name)
+static void bgp_route_map_process_update_cb(char *rmap_name)
 {
 	struct listnode *node, *nnode;
 	struct bgp *bgp;
@@ -3124,8 +3144,6 @@ static int bgp_route_map_process_update_
 	}
 
 	vpn_policy_routemap_event(rmap_name);
-
-	return 0;
 }
 
 int bgp_route_map_update_timer(struct thread *thread)
@@ -3169,7 +3187,7 @@ static void bgp_route_map_mark_update(co
 
 static void bgp_route_map_add(const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 0) == 0)
+	if (route_map_mark_updated(rmap_name) == 0)
 		bgp_route_map_mark_update(rmap_name);
 
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
@@ -3177,7 +3195,7 @@ static void bgp_route_map_add(const char
 
 static void bgp_route_map_delete(const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 1) == 0)
+	if (route_map_mark_updated(rmap_name) == 0)
 		bgp_route_map_mark_update(rmap_name);
 
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_DELETED);
@@ -3185,7 +3203,7 @@ static void bgp_route_map_delete(const c
 
 static void bgp_route_map_event(route_map_event_t event, const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 0) == 0)
+	if (route_map_mark_updated(rmap_name) == 0)
 		bgp_route_map_mark_update(rmap_name);
 
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
@@ -4792,9 +4810,5 @@ void bgp_route_map_init(void)
 void bgp_route_map_terminate(void)
 {
 	/* ToDo: Cleanup all the used memory */
-
-	route_map_add_hook(NULL);
-	route_map_delete_hook(NULL);
-	route_map_event_hook(NULL);
 	route_map_finish();
 }
diff -urpN frr-frr-5.0.1/bgpd/bgp_rpki.c frr-frr-6.0/bgpd/bgp_rpki.c
--- frr-frr-5.0.1/bgpd/bgp_rpki.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_rpki.c	2018-10-08 14:32:57.000000000 +0200
@@ -5,8 +5,8 @@
  * Berlin
  * Copyright (C) 2016-2017 Colin Sames (colin.sames@haw-hamburg.de), for HAW
  * Hamburg
- * Copyright (C) 2017-2018 Marcel Rthke (marcel.roethke@haw-hamburg.de), for HAW
- * Hamburg
+ * Copyright (C) 2017-2018 Marcel Rthke (marcel.roethke@haw-hamburg.de),
+ * for HAW Hamburg
  *
  * This file is part of FRRouting.
  *
@@ -47,6 +47,8 @@
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_aspath.h"
 #include "bgpd/bgp_route.h"
+#include "lib/network.h"
+#include "lib/thread.h"
 #include "rtrlib/rtrlib.h"
 #include "rtrlib/rtr_mgr.h"
 #include "rtrlib/lib/ip.h"
@@ -125,19 +127,27 @@ static void print_record(const struct pf
 static int is_synchronized(void);
 static int is_running(void);
 static void route_match_free(void *rule);
-static route_map_result_t route_match(void *rule, struct prefix *prefix,
+static route_map_result_t route_match(void *rule, const struct prefix *prefix,
 				      route_map_object_t type, void *object);
 static void *route_match_compile(const char *arg);
+static void revalidate_bgp_node(struct bgp_node *bgp_node, afi_t afi,
+				safi_t safi);
+static void revalidate_all_routes(void);
 
 static struct rtr_mgr_config *rtr_config;
 static struct list *cache_list;
 static int rtr_is_running;
+static int rtr_is_stopping;
+static int rtr_is_starting;
+static _Atomic int rtr_update_overflow;
 static int rpki_debug;
 static unsigned int polling_period;
 static unsigned int expire_interval;
 static unsigned int retry_interval;
 static unsigned int timeout;
 static unsigned int initial_synchronisation_timeout;
+static int rpki_sync_socket_rtr;
+static int rpki_sync_socket_bgpd;
 
 static struct cmd_node rpki_node = {RPKI_NODE, "%s(config-rpki)# ", 1};
 static struct route_map_rule_cmd route_match_rpki_cmd = {
@@ -183,16 +193,25 @@ static void free_tr_socket(struct cache
 }
 
 static int rpki_validate_prefix(struct peer *peer, struct attr *attr,
-				struct prefix *prefix);
+				const struct prefix *prefix);
+
+static void ipv6_addr_to_network_byte_order(const uint32_t *src, uint32_t *dest)
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		dest[i] = htonl(src[i]);
+}
 
 static void ipv6_addr_to_host_byte_order(const uint32_t *src, uint32_t *dest)
 {
 	int i;
+
 	for (i = 0; i < 4; i++)
 		dest[i] = ntohl(src[i]);
 }
 
-static route_map_result_t route_match(void *rule, struct prefix *prefix,
+static route_map_result_t route_match(void *rule, const struct prefix *prefix,
 				      route_map_object_t type, void *object)
 {
 	int *rpki_status = rule;
@@ -213,7 +232,7 @@ static void *route_match_compile(const c
 {
 	int *rpki_status;
 
-	rpki_status = XMALLOC(MTYPE_ROUTE_MAP_COMPILED, sizeof(uint8_t));
+	rpki_status = XMALLOC(MTYPE_ROUTE_MAP_COMPILED, sizeof(int));
 
 	if (strcmp(arg, "valid") == 0)
 		*rpki_status = RPKI_VALID;
@@ -302,10 +321,204 @@ inline int is_running(void)
 	return rtr_is_running;
 }
 
+static struct prefix *pfx_record_to_prefix(struct pfx_record *record)
+{
+	struct prefix *prefix = prefix_new();
+
+	prefix->prefixlen = record->min_len;
+
+	if (record->prefix.ver == LRTR_IPV4) {
+		prefix->family = AF_INET;
+		prefix->u.prefix4.s_addr = htonl(record->prefix.u.addr4.addr);
+	} else {
+		prefix->family = AF_INET6;
+		ipv6_addr_to_network_byte_order(record->prefix.u.addr6.addr,
+						prefix->u.prefix6.s6_addr32);
+	}
+
+	return prefix;
+}
+
+static int bgpd_sync_callback(struct thread *thread)
+{
+	struct bgp *bgp;
+	struct listnode *node;
+	struct prefix *prefix;
+	struct pfx_record rec;
+
+	thread_add_read(bm->master, bgpd_sync_callback, NULL,
+			rpki_sync_socket_bgpd, NULL);
+
+	if (atomic_load_explicit(&rtr_update_overflow, memory_order_seq_cst)) {
+		while (read(rpki_sync_socket_bgpd, &rec,
+			    sizeof(struct pfx_record))
+		       != -1)
+			;
+
+		atomic_store_explicit(&rtr_update_overflow, 0,
+				      memory_order_seq_cst);
+		revalidate_all_routes();
+		return 0;
+	}
+
+	int retval =
+		read(rpki_sync_socket_bgpd, &rec, sizeof(struct pfx_record));
+	if (retval != sizeof(struct pfx_record)) {
+		RPKI_DEBUG("Could not read from rpki_sync_socket_bgpd");
+		return retval;
+	}
+	prefix = pfx_record_to_prefix(&rec);
+
+	afi_t afi = (rec.prefix.ver == LRTR_IPV4) ? AFI_IP : AFI_IP6;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, node, bgp)) {
+		struct peer *peer;
+		struct listnode *peer_listnode;
+
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, peer_listnode, peer)) {
+			safi_t safi;
+
+			for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
+				if (!peer->bgp->rib[afi][safi])
+					continue;
+
+				struct list *matches = list_new();
+
+				matches->del =
+					(void (*)(void *))bgp_unlock_node;
+
+				bgp_table_range_lookup(
+					peer->bgp->rib[afi][safi], prefix,
+					rec.max_len, matches);
+
+
+				struct bgp_node *bgp_node;
+				struct listnode *bgp_listnode;
+
+				for (ALL_LIST_ELEMENTS_RO(matches, bgp_listnode,
+							  bgp_node))
+					revalidate_bgp_node(bgp_node, afi,
+							    safi);
+
+				list_delete_and_null(&matches);
+			}
+		}
+	}
+
+	prefix_free(prefix);
+	return 0;
+}
+
+static void revalidate_bgp_node(struct bgp_node *bgp_node, afi_t afi,
+				safi_t safi)
+{
+	struct bgp_adj_in *ain;
+
+	for (ain = bgp_node->adj_in; ain; ain = ain->next) {
+		int ret;
+		struct bgp_info *bgp_info = bgp_node->info;
+		mpls_label_t *label = NULL;
+		uint32_t num_labels = 0;
+
+		if (bgp_info && bgp_info->extra) {
+			label = bgp_info->extra->label;
+			num_labels = bgp_info->extra->num_labels;
+		}
+		ret = bgp_update(ain->peer, &bgp_node->p, ain->addpath_rx_id,
+				 ain->attr, afi, safi, ZEBRA_ROUTE_BGP,
+				 BGP_ROUTE_NORMAL, NULL, label, num_labels, 1,
+				 NULL);
+
+		if (ret < 0)
+			return;
+	}
+}
+
+static void revalidate_all_routes(void)
+{
+	struct bgp *bgp;
+	struct listnode *node;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, node, bgp)) {
+		struct peer *peer;
+		struct listnode *peer_listnode;
+
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, peer_listnode, peer)) {
+
+			for (size_t i = 0; i < 2; i++) {
+				safi_t safi;
+				afi_t afi = (i == 0) ? AFI_IP : AFI_IP6;
+
+				for (safi = SAFI_UNICAST; safi < SAFI_MAX;
+				     safi++) {
+					if (!peer->bgp->rib[afi][safi])
+						continue;
+
+					bgp_soft_reconfig_in(peer, afi, safi);
+				}
+			}
+		}
+	}
+}
+
+static void rpki_update_cb_sync_rtr(struct pfx_table *p __attribute__((unused)),
+				    const struct pfx_record rec,
+				    const bool added __attribute__((unused)))
+{
+	if (rtr_is_stopping || rtr_is_starting
+	    || atomic_load_explicit(&rtr_update_overflow, memory_order_seq_cst))
+		return;
+
+	int retval =
+		write(rpki_sync_socket_rtr, &rec, sizeof(struct pfx_record));
+	if (retval == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))
+		atomic_store_explicit(&rtr_update_overflow, 1,
+				      memory_order_seq_cst);
+
+	else if (retval != sizeof(struct pfx_record))
+		RPKI_DEBUG("Could not write to rpki_sync_socket_rtr");
+}
+
+static void rpki_init_sync_socket(void)
+{
+	int fds[2];
+	const char *msg;
+
+	RPKI_DEBUG("initializing sync socket");
+	if (socketpair(PF_LOCAL, SOCK_DGRAM, 0, fds) != 0) {
+		msg = "could not open rpki sync socketpair";
+		goto err;
+	}
+	rpki_sync_socket_rtr = fds[0];
+	rpki_sync_socket_bgpd = fds[1];
+
+	if (set_nonblocking(rpki_sync_socket_rtr) != 0) {
+		msg = "could not set rpki_sync_socket_rtr to non blocking";
+		goto err;
+	}
+
+	if (set_nonblocking(rpki_sync_socket_bgpd) != 0) {
+		msg = "could not set rpki_sync_socket_bgpd to non blocking";
+		goto err;
+	}
+
+
+	thread_add_read(bm->master, bgpd_sync_callback, NULL,
+			rpki_sync_socket_bgpd, NULL);
+
+	return;
+
+err:
+	zlog_err("RPKI: %s", msg);
+	abort();
+
+}
+
 static int bgp_rpki_init(struct thread_master *master)
 {
 	rpki_debug = 0;
 	rtr_is_running = 0;
+	rtr_is_stopping = 0;
 
 	cache_list = list_new();
 	cache_list->del = (void (*)(void *)) & free_cache;
@@ -317,6 +530,7 @@ static int bgp_rpki_init(struct thread_m
 	initial_synchronisation_timeout =
 		INITIAL_SYNCHRONISATION_TIMEOUT_DEFAULT;
 	install_cli_commands();
+	rpki_init_sync_socket();
 	return 0;
 }
 
@@ -325,6 +539,9 @@ static int bgp_rpki_fini(void)
 	stop();
 	list_delete_and_null(&cache_list);
 
+	close(rpki_sync_socket_rtr);
+	close(rpki_sync_socket_bgpd);
+
 	return 0;
 }
 
@@ -343,6 +560,10 @@ static int start(void)
 	unsigned int waiting_time = 0;
 	int ret;
 
+	rtr_is_stopping = 0;
+	rtr_is_starting = 1;
+	rtr_update_overflow = 0;
+
 	if (list_isempty(cache_list)) {
 		RPKI_DEBUG(
 			"No caches were found in config. Prefix validation is off.");
@@ -352,9 +573,10 @@ static int start(void)
 	int groups_len = listcount(cache_list);
 	struct rtr_mgr_group *groups = get_groups();
 
+	RPKI_DEBUG("Polling period: %d", polling_period);
 	ret = rtr_mgr_init(&rtr_config, groups, groups_len, polling_period,
-			   expire_interval, retry_interval, NULL, NULL, NULL,
-			   NULL);
+			   expire_interval, retry_interval,
+			   rpki_update_cb_sync_rtr, NULL, NULL, NULL);
 	if (ret == RTR_ERROR) {
 		RPKI_DEBUG("Init rtr_mgr failed.");
 		return ERROR;
@@ -377,9 +599,13 @@ static int start(void)
 	}
 	if (rtr_mgr_conf_in_sync(rtr_config)) {
 		RPKI_DEBUG("Got synchronisation with at least one RPKI cache!");
+		RPKI_DEBUG("Forcing revalidation.");
+		rtr_is_starting = 0;
+		revalidate_all_routes();
 	} else {
 		RPKI_DEBUG(
 			"Timeout expired! Proceeding without RPKI validation data.");
+		rtr_is_starting = 0;
 	}
 
 	XFREE(MTYPE_BGP_RPKI_CACHE_GROUP, groups);
@@ -389,6 +615,7 @@ static int start(void)
 
 static void stop(void)
 {
+	rtr_is_stopping = 1;
 	if (rtr_is_running) {
 		rtr_mgr_stop(rtr_config);
 		rtr_mgr_free(rtr_config);
@@ -408,7 +635,7 @@ static int reset(bool force)
 
 static struct rtr_mgr_group *get_connected_group(void)
 {
-	if (list_isempty(cache_list))
+	if (!cache_list || list_isempty(cache_list))
 		return NULL;
 
 	return rtr_mgr_get_first_group(rtr_config);
@@ -443,7 +670,7 @@ static void print_prefix_table(struct vt
 }
 
 static int rpki_validate_prefix(struct peer *peer, struct attr *attr,
-				struct prefix *prefix)
+				const struct prefix *prefix)
 {
 	struct assegment *as_segment;
 	as_t as_number = 0;
@@ -863,7 +1090,7 @@ DEFPY (rpki_cache,
        "Preference of the cache server\n"
        "Preference value\n")
 {
-	int return_value = SUCCESS;
+	int return_value;
 
 	// use ssh connection
 	if (ssh_uname) {
@@ -872,6 +1099,7 @@ DEFPY (rpki_cache,
 			add_ssh_cache(cache, sshport, ssh_uname, ssh_privkey,
 				      ssh_pubkey, server_pubkey, preference);
 #else
+		return_value = SUCCESS;
 		vty_out(vty,
 			"ssh sockets are not supported. "
 			"Please recompile rtrlib and frr with ssh support. "
@@ -1031,10 +1259,10 @@ DEFUN_NOSH (rpki_exit,
 	    "exit",
 	    "Exit rpki configuration and restart rpki session\n")
 {
-	int ret = reset(false);
+	reset(false);
 
 	vty->node = CONFIG_NODE;
-	return ret == SUCCESS ? CMD_SUCCESS : CMD_WARNING;
+	return CMD_SUCCESS;
 }
 
 DEFUN_NOSH (rpki_quit,
diff -urpN frr-frr-5.0.1/bgpd/bgp_table.c frr-frr-6.0/bgpd/bgp_table.c
--- frr-frr-5.0.1/bgpd/bgp_table.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_table.c	2018-10-08 14:32:57.000000000 +0200
@@ -114,3 +114,65 @@ struct bgp_table *bgp_table_init(struct
 
 	return rt;
 }
+
+static struct bgp_node *
+bgp_route_next_until_maxlen(struct bgp_node *node, const struct bgp_node *limit,
+			    const uint8_t maxlen)
+{
+	if (node->l_left && node->p.prefixlen < maxlen
+	    && node->l_left->p.prefixlen <= maxlen) {
+		return bgp_node_from_rnode(node->l_left);
+	}
+	if (node->l_right && node->p.prefixlen < maxlen
+	    && node->l_right->p.prefixlen <= maxlen) {
+		return bgp_node_from_rnode(node->l_right);
+	}
+
+	while (node->parent && node != limit) {
+		if (bgp_node_from_rnode(node->parent->l_left) == node
+		    && node->parent->l_right) {
+			return bgp_node_from_rnode(node->parent->l_right);
+		}
+		node = bgp_node_from_rnode(node->parent);
+	}
+	return NULL;
+}
+
+void bgp_table_range_lookup(const struct bgp_table *table, struct prefix *p,
+			    uint8_t maxlen, struct list *matches)
+{
+	struct bgp_node *node = bgp_node_from_rnode(table->route_table->top);
+	struct bgp_node *matched = NULL;
+
+	while (node && node->p.prefixlen <= p->prefixlen
+	       && prefix_match(&node->p, p)) {
+		if (node->info && node->p.prefixlen == p->prefixlen) {
+			matched = node;
+			break;
+		}
+		node = bgp_node_from_rnode(node->link[prefix_bit(
+			&p->u.prefix, node->p.prefixlen)]);
+	}
+
+	if (node == NULL)
+		return;
+
+	if ((matched == NULL && node->p.prefixlen > maxlen) || !node->parent)
+		return;
+	else if (matched == NULL)
+		matched = node = bgp_node_from_rnode(node->parent);
+
+	if (matched->info) {
+		bgp_lock_node(matched);
+		listnode_add(matches, matched);
+	}
+
+	while ((node = bgp_route_next_until_maxlen(node, matched, maxlen))) {
+		if (prefix_match(p, &node->p)) {
+			if (node->info) {
+				bgp_lock_node(node);
+				listnode_add(matches, node);
+			}
+		}
+	}
+}
diff -urpN frr-frr-5.0.1/bgpd/bgp_table.h frr-frr-6.0/bgpd/bgp_table.h
--- frr-frr-5.0.1/bgpd/bgp_table.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_table.h	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include "mpls.h"
 #include "table.h"
 #include "queue.h"
+#include "linklist.h"
 
 struct bgp_table {
 	/* table belongs to this instance */
@@ -309,4 +310,7 @@ static inline uint64_t bgp_table_version
 	return table->version;
 }
 
+void bgp_table_range_lookup(const struct bgp_table *table, struct prefix *p,
+			    uint8_t maxlen, struct list *matches);
+
 #endif /* _QUAGGA_BGP_TABLE_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_updgrp.c frr-frr-6.0/bgpd/bgp_updgrp.c
--- frr-frr-5.0.1/bgpd/bgp_updgrp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_updgrp.c	2018-10-08 14:32:57.000000000 +0200
@@ -47,6 +47,7 @@
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_table.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_advertise.h"
 #include "bgpd/bgp_packet.h"
@@ -812,7 +813,7 @@ static void update_subgroup_delete(struc
 		THREAD_TIMER_OFF(subgrp->t_coalesce);
 	sync_delete(subgrp);
 
-	if (BGP_DEBUG(update_groups, UPDATE_GROUPS))
+	if (BGP_DEBUG(update_groups, UPDATE_GROUPS) && subgrp->update_group)
 		zlog_debug("delete subgroup u%" PRIu64 ":s%" PRIu64,
 			   subgrp->update_group->id, subgrp->id);
 
@@ -905,7 +906,7 @@ static void update_subgroup_add_peer(str
 static void update_subgroup_remove_peer_internal(struct update_subgroup *subgrp,
 						 struct peer_af *paf)
 {
-	assert(subgrp && paf);
+	assert(subgrp && paf && subgrp->update_group);
 
 	if (bgp_debug_peer_updout_enabled(paf->peer->host)) {
 		UPDGRP_PEER_DBG_DIS(subgrp->update_group);
@@ -1630,8 +1631,9 @@ void update_group_adjust_peer(struct pee
 	if (!updgrp) {
 		updgrp = update_group_create(paf);
 		if (!updgrp) {
-			zlog_err("couldn't create update group for peer %s",
-				 paf->peer->host);
+			flog_err(BGP_ERR_UPDGRP_CREATE,
+				  "couldn't create update group for peer %s",
+				  paf->peer->host);
 			return;
 		}
 	}
diff -urpN frr-frr-5.0.1/bgpd/bgp_updgrp_adv.c frr-frr-6.0/bgpd/bgp_updgrp_adv.c
--- frr-frr-5.0.1/bgpd/bgp_updgrp_adv.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_updgrp_adv.c	2018-10-08 14:32:57.000000000 +0200
@@ -663,7 +663,7 @@ void subgroup_default_originate(struct u
 {
 	struct bgp *bgp;
 	struct attr attr;
-	struct aspath *aspath;
+	struct bgp_info *info, init_info, tmp_info;
 	struct prefix p;
 	struct peer *from;
 	struct bgp_node *rn;
@@ -687,47 +687,59 @@ void subgroup_default_originate(struct u
 	from = bgp->peer_self;
 
 	bgp_attr_default_set(&attr, BGP_ORIGIN_IGP);
-	aspath = attr.aspath;
-
 	attr.local_pref = bgp->default_local_pref;
 
-	memset(&p, 0, sizeof(p));
-	p.family = afi2family(afi);
-	p.prefixlen = 0;
-
 	if ((afi == AFI_IP6) || peer_cap_enhe(peer, afi, safi)) {
-		/* IPv6 global nexthop must be included. */
+		/* IPv6 global nexthop must be included.
+		 */
 		attr.mp_nexthop_len = BGP_ATTR_NHLEN_IPV6_GLOBAL;
 
-		/* If the peer is on shared nextwork and we have link-local
-		   nexthop set it. */
+		/* If the peer is on shared nextwork and
+		 * we have link-local nexthop set it. */
 		if (peer->shared_network
 		    && !IN6_IS_ADDR_UNSPECIFIED(&peer->nexthop.v6_local))
 			attr.mp_nexthop_len = BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL;
 	}
+	init_info.attr = &attr;
+	info = &init_info;
+	bgp_attr_intern(info->attr);
+
+	memset(&p, 0, sizeof(p));
+	p.family = afi2family(afi);
+	p.prefixlen = 0;
 
 	if (peer->default_rmap[afi][safi].name) {
 		SET_FLAG(bgp->peer_self->rmap_type, PEER_RMAP_TYPE_DEFAULT);
 		for (rn = bgp_table_top(bgp->rib[afi][safi]); rn;
 		     rn = bgp_route_next(rn)) {
 			for (ri = rn->info; ri; ri = ri->next) {
-				struct attr dummy_attr;
-				struct bgp_info info;
+				tmp_info.peer = ri->peer;
+				tmp_info.attr = ri->attr;
 
-				/* Provide dummy so the route-map can't modify
-				 * the attributes */
-				bgp_attr_dup(&dummy_attr, ri->attr);
-				info.peer = ri->peer;
-				info.attr = &dummy_attr;
+				/* Reset attributes every time to avoid \
+				 * unexpected as-path prepends */
+				bgp_attr_default_set(tmp_info.attr,
+						     BGP_ORIGIN_IGP);
+
+				if ((afi == AFI_IP6)
+				    || peer_cap_enhe(peer, afi, safi)) {
+					tmp_info.attr->mp_nexthop_len =
+						BGP_ATTR_NHLEN_IPV6_GLOBAL;
+
+					if (peer->shared_network
+					    && !IN6_IS_ADDR_UNSPECIFIED(
+						       &peer->nexthop.v6_local))
+						tmp_info.attr->mp_nexthop_len =
+							BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL;
+				}
 
 				ret = route_map_apply(
 					peer->default_rmap[afi][safi].map,
-					&rn->p, RMAP_BGP, &info);
+					&rn->p, RMAP_BGP, &tmp_info);
+
+				info = &tmp_info;
+				bgp_attr_intern(info->attr);
 
-				/* The route map might have set attributes. If
-				 * we don't flush them
-				 * here, they will be leaked. */
-				bgp_attr_flush(&dummy_attr);
 				if (ret != RMAP_DENYMATCH)
 					break;
 			}
@@ -749,12 +761,13 @@ void subgroup_default_originate(struct u
 				SUBGRP_STATUS_DEFAULT_ORIGINATE)) {
 
 			if (bgp_flag_check(bgp, BGP_FLAG_GRACEFUL_SHUTDOWN)) {
-				bgp_attr_add_gshut_community(&attr);
+				bgp_attr_add_gshut_community(info->attr);
 			}
 
 			SET_FLAG(subgrp->sflags,
 				 SUBGRP_STATUS_DEFAULT_ORIGINATE);
-			subgroup_default_update_packet(subgrp, &attr, from);
+			subgroup_default_update_packet(subgrp, info->attr,
+						       from);
 
 			/* The 'neighbor x.x.x.x default-originate' default will
 			 * act as an
@@ -774,8 +787,7 @@ void subgroup_default_originate(struct u
 				BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE);
 		}
 	}
-
-	aspath_unintern(&aspath);
+	aspath_unintern(&info->attr->aspath);
 }
 
 /*
diff -urpN frr-frr-5.0.1/bgpd/bgp_updgrp_packet.c frr-frr-6.0/bgpd/bgp_updgrp_packet.c
--- frr-frr-5.0.1/bgpd/bgp_updgrp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_updgrp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -46,6 +46,7 @@
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_packet.h"
@@ -397,7 +398,7 @@ struct stream *bpacket_reformat_for_peer
 	vec = &pkt->arr.entries[BGP_ATTR_VEC_NH];
 	if (CHECK_FLAG(vec->flags, BPKT_ATTRVEC_FLAGS_UPDATED)) {
 		uint8_t nhlen;
-		afi_t nhafi = AFI_MAX; /* NH AFI is based on nhlen! */
+		afi_t nhafi;
 		int route_map_sets_nh;
 		nhlen = stream_getc_from(s, vec->offset);
 		if (peer_cap_enhe(peer, paf->afi, paf->safi))
@@ -467,13 +468,12 @@ struct stream *bpacket_reformat_for_peer
 				nh_modified = 1;
 			} else if (
 				peer->sort == BGP_PEER_EBGP
-				&& paf->safi != SAFI_EVPN
 				&& (bgp_multiaccess_check_v4(v4nh, peer) == 0)
 				&& !CHECK_FLAG(
 					   vec->flags,
 					   BPKT_ATTRVEC_FLAGS_RMAP_NH_UNCHANGED)
 				&& !peer_af_flag_check(
-					   peer, nhafi, paf->safi,
+					   peer, paf->afi, paf->safi,
 					   PEER_FLAG_NEXTHOP_UNCHANGED)) {
 				/* NOTE: not handling case where NH has new AFI
 				 */
@@ -787,7 +787,8 @@ struct bpacket *subgroup_update_packet(s
 			 * NLRI then
 			 * return */
 			if (space_remaining < space_needed) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_UPDGRP_ATTR_LEN,
 					"u%" PRIu64 ":s%" PRIu64
 					" attributes too long, cannot send UPDATE",
 					subgrp->update_group->id, subgrp->id);
diff -urpN frr-frr-5.0.1/bgpd/bgp_vnc_types.h frr-frr-6.0/bgpd/bgp_vnc_types.h
--- frr-frr-5.0.1/bgpd/bgp_vnc_types.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_vnc_types.h	2018-10-08 14:32:57.000000000 +0200
@@ -25,16 +25,5 @@ typedef enum {
 	BGP_VNC_SUBTLV_TYPE_RFPOPTION = 2, /* deprecated */
 } bgp_vnc_subtlv_types;
 
-/*
- * VNC Attribute subtlvs
- */
-struct bgp_vnc_subtlv_lifetime {
-	uint32_t lifetime;
-};
-
-struct bgp_vnc_subtlv_unaddr {
-	struct prefix un_address; /* IPv4 or IPv6; pfx length ignored */
-};
-
 #endif /* ENABLE_BGP_VNC */
 #endif /* _QUAGGA_BGP_VNC_TYPES_H */
diff -urpN frr-frr-5.0.1/bgpd/bgp_vpn.c frr-frr-6.0/bgpd/bgp_vpn.c
--- frr-frr-5.0.1/bgpd/bgp_vpn.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_vpn.c	2018-10-08 14:32:57.000000000 +0200
@@ -125,7 +125,7 @@ int show_adj_route_vpn(struct vty *vty,
 
 					if (rd_header) {
 						uint16_t type;
-						struct rd_as rd_as;
+						struct rd_as rd_as = {0};
 						struct rd_ip rd_ip = {0};
 #if ENABLE_BGP_VNC
 						struct rd_vnc_eth rd_vnc_eth = {
@@ -223,23 +223,27 @@ int show_adj_route_vpn(struct vty *vty,
 						}
 						rd_header = 0;
 					}
-					route_vty_out_tmp(vty, &rm->p, attr,
-							  SAFI_MPLS_VPN,
-							  use_json, json_array);
+					if (use_json) {
+						char buf_a[BUFSIZ];
+						char buf_b[BUFSIZ];
+
+						sprintf(buf_a, "%s/%d",
+							inet_ntop(rm->p.family,
+								  rm->p.u.val,
+								  buf_b,
+								  BUFSIZ),
+							rm->p.prefixlen);
+						json_object_object_add(
+							json_routes, buf_a,
+							json_array);
+					} else {
+						route_vty_out_tmp(
+							vty, &rm->p, attr,
+							SAFI_MPLS_VPN, use_json,
+							json_array);
+					}
 				}
 			}
-			if (use_json) {
-				struct prefix *p;
-				char buf_a[BUFSIZ];
-				char buf_b[BUFSIZ];
-				p = &rm->p;
-				sprintf(buf_a, "%s/%d",
-					inet_ntop(p->family, &p->u.prefix,
-						  buf_b, BUFSIZ),
-					p->prefixlen);
-				json_object_object_add(json_routes, buf_a,
-						       json_array);
-			}
 		}
 	}
 	if (use_json) {
diff -urpN frr-frr-5.0.1/bgpd/bgp_vty.c frr-frr-6.0/bgpd/bgp_vty.c
--- frr-frr-5.0.1/bgpd/bgp_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "hash.h"
 #include "queue.h"
 #include "filter.h"
+#include "frrstr.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_advertise.h"
@@ -44,6 +45,7 @@
 #include "bgpd/bgp_lcommunity.h"
 #include "bgpd/bgp_damp.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_nexthop.h"
 #include "bgpd/bgp_open.h"
@@ -183,6 +185,7 @@ safi_t bgp_node_safi(struct vty *vty)
  * @param afi string, one of
  *  - "ipv4"
  *  - "ipv6"
+ *  - "l2vpn"
  * @return the corresponding afi_t
  */
 afi_t bgp_vty_afi_from_str(const char *afi_str)
@@ -192,6 +195,8 @@ afi_t bgp_vty_afi_from_str(const char *a
 		afi = AFI_IP;
 	else if (strmatch(afi_str, "ipv6"))
 		afi = AFI_IP6;
+	else if (strmatch(afi_str, "l2vpn"))
+		afi = AFI_L2VPN;
 	return afi;
 }
 
@@ -221,6 +226,8 @@ safi_t bgp_vty_safi_from_str(const char
 		safi = SAFI_UNICAST;
 	else if (strmatch(safi_str, "vpn"))
 		safi = SAFI_MPLS_VPN;
+	else if (strmatch(safi_str, "evpn"))
+		safi = SAFI_EVPN;
 	else if (strmatch(safi_str, "labeled-unicast"))
 		safi = SAFI_LABELED_UNICAST;
 	else if (strmatch(safi_str, "flowspec"))
@@ -771,18 +778,21 @@ static void bgp_clear_star_soft_out(stru
 #endif
 
 /* BGP global configuration.  */
-
-DEFUN (bgp_multiple_instance_func,
-       bgp_multiple_instance_cmd,
-       "bgp multiple-instance",
-       BGP_STR
-       "Enable bgp multiple instance\n")
+#if (CONFDATE > 20190601)
+CPP_NOTICE("bgpd: time to remove deprecated bgp multiple-instance")
+CPP_NOTICE("This includes BGP_OPT_MULTIPLE_INSTANCE")
+#endif
+DEFUN_HIDDEN (bgp_multiple_instance_func,
+	      bgp_multiple_instance_cmd,
+	      "bgp multiple-instance",
+	      BGP_STR
+	      "Enable bgp multiple instance\n")
 {
 	bgp_option_set(BGP_OPT_MULTIPLE_INSTANCE);
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_bgp_multiple_instance,
+DEFUN_HIDDEN (no_bgp_multiple_instance,
        no_bgp_multiple_instance_cmd,
        "no bgp multiple-instance",
        NO_STR
@@ -791,6 +801,9 @@ DEFUN (no_bgp_multiple_instance,
 {
 	int ret;
 
+	vty_out(vty, "This config option is deprecated, and is scheduled for removal.\n");
+	vty_out(vty, "if you are using this please let the developers know\n");
+	zlog_info("Deprecated option: `bgp multiple-instance` being used");
 	ret = bgp_option_unset(BGP_OPT_MULTIPLE_INSTANCE);
 	if (ret < 0) {
 		vty_out(vty, "%% There are more than two BGP instances\n");
@@ -799,31 +812,38 @@ DEFUN (no_bgp_multiple_instance,
 	return CMD_SUCCESS;
 }
 
-DEFUN (bgp_config_type,
-       bgp_config_type_cmd,
-       "bgp config-type <cisco|zebra>",
-       BGP_STR
-       "Configuration type\n"
-       "cisco\n"
-       "zebra\n")
+#if (CONFDATE > 20190601)
+CPP_NOTICE("bgpd: time to remove deprecated cli bgp config-type cisco")
+CPP_NOTICE("This includes BGP_OPT_CISCO_CONFIG")
+#endif
+DEFUN_HIDDEN (bgp_config_type,
+	      bgp_config_type_cmd,
+	      "bgp config-type <cisco|zebra>",
+	      BGP_STR
+	      "Configuration type\n"
+	      "cisco\n"
+	      "zebra\n")
 {
 	int idx = 0;
-	if (argv_find(argv, argc, "cisco", &idx))
+	if (argv_find(argv, argc, "cisco", &idx)) {
+		vty_out(vty, "This config option is deprecated, and is scheduled for removal.\n");
+		vty_out(vty, "if you are using this please let the developers know!\n");
+		zlog_info("Deprecated option: `bgp config-type cisco` being used");
 		bgp_option_set(BGP_OPT_CONFIG_CISCO);
-	else
+	} else
 		bgp_option_unset(BGP_OPT_CONFIG_CISCO);
 
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_bgp_config_type,
-       no_bgp_config_type_cmd,
-       "no bgp config-type [<cisco|zebra>]",
-       NO_STR
-       BGP_STR
-       "Display configuration type\n"
-       "cisco\n"
-       "zebra\n")
+DEFUN_HIDDEN (no_bgp_config_type,
+	      no_bgp_config_type_cmd,
+	      "no bgp config-type [<cisco|zebra>]",
+	      NO_STR
+	      BGP_STR
+	      "Display configuration type\n"
+	      "cisco\n"
+	      "zebra\n")
 {
 	bgp_option_unset(BGP_OPT_CONFIG_CISCO);
 	return CMD_SUCCESS;
@@ -914,6 +934,14 @@ DEFUN_NOSH (router_bgp,
 			return CMD_WARNING_CONFIG_FAILED;
 		}
 
+		/*
+		 * If we just instantiated the default instance, complete
+		 * any pending VRF-VPN leaking that was configured via
+		 * earlier "router bgp X vrf FOO" blocks.
+		 */
+		if (inst_type == BGP_INSTANCE_TYPE_DEFAULT)
+			vpn_leak_postchange_all();
+
 		/* Pending: handle when user tries to change a view to vrf n vv.
 		 */
 	}
@@ -1991,31 +2019,23 @@ DEFUN (no_bgp_fast_external_failover,
 }
 
 /* "bgp enforce-first-as" configuration. */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180517
+#if CONFDATE > 20190517
 CPP_NOTICE("bgpd: remove deprecated '[no] bgp enforce-first-as' commands")
 #endif
 
-DEFUN_DEPRECATED (bgp_enforce_first_as,
-       bgp_enforce_first_as_cmd,
-       "bgp enforce-first-as",
-       BGP_STR
-       "Enforce the first AS for EBGP routes\n")
+DEFUN_HIDDEN (bgp_enforce_first_as,
+	      bgp_enforce_first_as_cmd,
+	      "[no] bgp enforce-first-as",
+	      NO_STR
+	      BGP_STR
+	      "Enforce the first AS for EBGP routes\n")
 {
 	VTY_DECLVAR_CONTEXT(bgp, bgp);
-	bgp_flag_set(bgp, BGP_FLAG_ENFORCE_FIRST_AS);
-
-	return CMD_SUCCESS;
-}
 
-DEFUN_DEPRECATED (no_bgp_enforce_first_as,
-       no_bgp_enforce_first_as_cmd,
-       "no bgp enforce-first-as",
-       NO_STR
-       BGP_STR
-       "Enforce the first AS for EBGP routes\n")
-{
-	VTY_DECLVAR_CONTEXT(bgp, bgp);
-	bgp_flag_unset(bgp, BGP_FLAG_ENFORCE_FIRST_AS);
+	if (strmatch(argv[0]->text, "no"))
+		bgp_flag_unset(bgp, BGP_FLAG_ENFORCE_FIRST_AS);
+	else
+		bgp_flag_set(bgp, BGP_FLAG_ENFORCE_FIRST_AS);
 
 	return CMD_SUCCESS;
 }
@@ -3366,8 +3386,6 @@ DEFUN (neighbor_set_peer_group,
 	struct peer *peer;
 	struct peer_group *group;
 
-	peer = NULL;
-
 	ret = str2sockunion(argv[idx_peer]->arg, &su);
 	if (ret < 0) {
 		peer = peer_lookup_by_conf_if(bgp, argv[idx_peer]->arg);
@@ -6345,6 +6363,10 @@ DEFPY (af_label_vpn_export,
 	if (argv_find(argv, argc, "no", &idx))
 		yes = 0;
 
+	/* If "no ...", squash trailing parameter */
+	if (!yes)
+		label_auto = NULL;
+
 	if (yes) {
 		if (!label_auto)
 			label = label_val; /* parser should force unsigned */
@@ -6727,6 +6749,11 @@ DEFPY (bgp_imexport_vrf,
 	safi_t safi;
 	afi_t afi;
 
+	if (import_name == NULL) {
+		vty_out(vty, "%% Missing import name\n");
+		return CMD_WARNING;
+	}
+
 	if (argv_find(argv, argc, "no", &idx))
 		remove = true;
 
@@ -7057,7 +7084,7 @@ static int bgp_clear_prefix(struct vty *
 				    != NULL) {
 					if (rm->p.prefixlen
 					    == match.prefixlen) {
-						SET_FLAG(rn->flags,
+						SET_FLAG(rm->flags,
 							 BGP_NODE_USER_CLEAR);
 						bgp_process(bgp, rm, afi, safi);
 					}
@@ -7888,9 +7915,11 @@ static int bgp_show_summary(struct vty *
 		if (use_json) {
 			json_peer = json_object_new_object();
 
-			if (peer_dynamic_neighbor(peer))
+			if (peer_dynamic_neighbor(peer)) {
+				dn_count++;
 				json_object_boolean_true_add(json_peer,
 							     "dynamicPeer");
+			}
 
 			if (peer->hostname)
 				json_object_string_add(json_peer, "hostname",
@@ -7920,6 +7949,11 @@ static int bgp_show_summary(struct vty *
 			if (CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN))
 				json_object_string_add(json_peer, "state",
 						       "Idle (Admin)");
+			else if (peer->afc_recv[afi][safi])
+				json_object_string_add(
+					json_peer, "state",
+					lookup_msg(bgp_status_msg, peer->status,
+						   NULL));
 			else if (CHECK_FLAG(peer->sflags,
 					    PEER_STATUS_PREFIX_OVERFLOW))
 				json_object_string_add(json_peer, "state",
@@ -8006,16 +8040,11 @@ static int bgp_show_summary(struct vty *
 		if (count)
 			vty_out(vty, "\nTotal number of neighbors %d\n", count);
 		else {
-			if (use_json)
-				vty_out(vty,
-					"{\"error\": {\"message\": \"No %s neighbor configured\"}}\n",
-					afi_safi_print(afi, safi));
-			else
-				vty_out(vty, "No %s neighbor is configured\n",
-					afi_safi_print(afi, safi));
+			vty_out(vty, "No %s neighbor is configured\n",
+				afi_safi_print(afi, safi));
 		}
 
-		if (dn_count && !use_json) {
+		if (dn_count) {
 			vty_out(vty, "* - dynamic neighbor\n");
 			vty_out(vty, "%d dynamic neighbor(s), limit %d\n",
 				dn_count, bgp->dynamic_neighbors_limit);
@@ -9094,6 +9123,10 @@ static void bgp_show_peer(struct vty *vt
 		json_object_string_add(
 			json_neigh, "remoteRouterId",
 			inet_ntop(AF_INET, &p->remote_id, buf1, sizeof(buf1)));
+		json_object_string_add(
+			json_neigh, "localRouterId",
+			inet_ntop(AF_INET, &bgp->router_id, buf1,
+					sizeof(buf1)));
 
 		/* Confederation */
 		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
@@ -9113,7 +9146,7 @@ static void bgp_show_peer(struct vty *vt
 			uptime -= p->uptime;
 			epoch_tbuf = time(NULL) - uptime;
 
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20200101
+#if CONFDATE > 20200101
 			CPP_NOTICE(
 				"bgpTimerUp should be deprecated and can be removed now");
 #endif
@@ -9207,8 +9240,11 @@ static void bgp_show_peer(struct vty *vt
 
 		/* BGP Version. */
 		vty_out(vty, "  BGP version 4");
-		vty_out(vty, ", remote router ID %s\n",
+		vty_out(vty, ", remote router ID %s",
 			inet_ntop(AF_INET, &p->remote_id, buf1, sizeof(buf1)));
+		vty_out(vty, ", local router ID %s\n",
+			inet_ntop(AF_INET, &bgp->router_id, buf1,
+					sizeof(buf1)));
 
 		/* Confederation */
 		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
@@ -10688,7 +10724,7 @@ static int bgp_show_neighbor(struct vty
 		if (use_json)
 			json_object_boolean_true_add(json, "bgpNoSuchNeighbor");
 		else
-			vty_out(vty, "%% No such neighbor\n");
+			vty_out(vty, "%% No such neighbor in this view/vrf\n");
 	}
 
 	if (use_json) {
@@ -10719,7 +10755,8 @@ static void bgp_show_all_instances_neigh
 	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
 		if (use_json) {
 			if (!(json = json_object_new_object())) {
-				zlog_err(
+				flog_err(
+					BGP_ERR_JSON_MEM_ERROR,
 					"Unable to allocate memory for JSON object");
 				vty_out(vty,
 					"{\"error\": {\"message:\": \"Unable to allocate memory for JSON object\"}}}\n");
@@ -10958,7 +10995,7 @@ DEFUN (show_ip_bgp_attr_info,
 }
 
 static int bgp_show_route_leak_vty(struct vty *vty, const char *name,
-				   afi_t afi, safi_t safi)
+				   afi_t afi, safi_t safi, uint8_t use_json)
 {
 	struct bgp *bgp;
 	struct listnode *node;
@@ -10967,64 +11004,148 @@ static int bgp_show_route_leak_vty(struc
 	char *ecom_str;
 	vpn_policy_direction_t dir;
 
-	if (name) {
-		bgp = bgp_lookup_by_name(name);
+	if (use_json) {
+		json_object *json = NULL;
+		json_object *json_import_vrfs = NULL;
+		json_object *json_export_vrfs = NULL;
+
+		json = json_object_new_object();
+
+		/* Provide context for the block */
+		json_object_string_add(json, "vrf", name ? name : "default");
+		json_object_string_add(json, "afiSafi",
+					afi_safi_print(afi, safi));
+
+		bgp = name ? bgp_lookup_by_name(name) : bgp_get_default();
+
 		if (!bgp) {
-			vty_out(vty, "%% No such BGP instance exist\n");
+			json_object_boolean_true_add(json,
+						     "bgpNoSuchInstance");
+			vty_out(vty, "%s\n",
+				json_object_to_json_string_ext(
+					json,
+					JSON_C_TO_STRING_PRETTY));
+			json_object_free(json);
+
 			return CMD_WARNING;
 		}
+
+		if (!CHECK_FLAG(bgp->af_flags[afi][safi],
+				BGP_CONFIG_VRF_TO_VRF_IMPORT)) {
+			json_object_string_add(json, "importFromVrfs", "none");
+			json_object_string_add(json, "importRts", "none");
+		} else {
+			json_import_vrfs = json_object_new_array();
+
+			for (ALL_LIST_ELEMENTS_RO(
+						bgp->vpn_policy[afi].import_vrf,
+						node, vname))
+				json_object_array_add(json_import_vrfs,
+						json_object_new_string(vname));
+
+			dir = BGP_VPN_POLICY_DIR_FROMVPN;
+			ecom_str = ecommunity_ecom2str(
+					bgp->vpn_policy[afi].rtlist[dir],
+					ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+			json_object_object_add(json, "importFromVrfs",
+					       json_import_vrfs);
+			json_object_string_add(json, "importRts", ecom_str);
+
+			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
+		}
+
+		if (!CHECK_FLAG(bgp->af_flags[afi][safi],
+				BGP_CONFIG_VRF_TO_VRF_EXPORT)) {
+			json_object_string_add(json, "exportToVrfs", "none");
+			json_object_string_add(json, "routeDistinguisher",
+					       "none");
+			json_object_string_add(json, "exportRts", "none");
+		} else {
+			json_export_vrfs = json_object_new_array();
+
+			for (ALL_LIST_ELEMENTS_RO(
+						bgp->vpn_policy[afi].export_vrf,
+						node, vname))
+				json_object_array_add(json_export_vrfs,
+						json_object_new_string(vname));
+			json_object_object_add(json, "exportToVrfs",
+					       json_export_vrfs);
+			json_object_string_add(json, "routeDistinguisher",
+				   prefix_rd2str(&bgp->vpn_policy[afi].tovpn_rd,
+						 buf1, RD_ADDRSTRLEN));
+
+			dir = BGP_VPN_POLICY_DIR_TOVPN;
+			ecom_str = ecommunity_ecom2str(
+					       bgp->vpn_policy[afi].rtlist[dir],
+					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+			json_object_string_add(json, "exportRts", ecom_str);
+
+			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
+		}
+
+		vty_out(vty, "%s\n",
+			json_object_to_json_string_ext(json,
+						      JSON_C_TO_STRING_PRETTY));
+		json_object_free(json);
+
 	} else {
-		bgp = bgp_get_default();
+		bgp = name ? bgp_lookup_by_name(name) : bgp_get_default();
+
 		if (!bgp) {
-			vty_out(vty,
-				"%% Default BGP instance does not exist\n");
+			vty_out(vty, "%% No such BGP instance exist\n");
 			return CMD_WARNING;
 		}
-	}
 
-	if (!CHECK_FLAG(bgp->af_flags[afi][safi],
-			BGP_CONFIG_VRF_TO_VRF_IMPORT)) {
-		vty_out(vty,
-			"This VRF is not importing %s routes from any other VRF\n",
-			afi_safi_print(afi, safi));
-	} else {
-		vty_out(vty,
-			"This VRF is importing %s routes from the following VRFs:\n",
-			afi_safi_print(afi, safi));
-		for (ALL_LIST_ELEMENTS_RO(bgp->vpn_policy[afi].import_vrf, node,
-					  vname)) {
-			vty_out(vty, "  %s\n", vname);
+		if (!CHECK_FLAG(bgp->af_flags[afi][safi],
+				BGP_CONFIG_VRF_TO_VRF_IMPORT))
+			vty_out(vty,
+		     "This VRF is not importing %s routes from any other VRF\n",
+		      afi_safi_print(afi, safi));
+		else {
+			vty_out(vty,
+		   "This VRF is importing %s routes from the following VRFs:\n",
+		    afi_safi_print(afi, safi));
+
+			for (ALL_LIST_ELEMENTS_RO(
+						bgp->vpn_policy[afi].import_vrf,
+						node, vname))
+				vty_out(vty, "  %s\n", vname);
+
+			dir = BGP_VPN_POLICY_DIR_FROMVPN;
+			ecom_str = ecommunity_ecom2str(
+					       bgp->vpn_policy[afi].rtlist[dir],
+					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+			vty_out(vty, "Import RT(s): %s\n", ecom_str);
+
+			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
 		}
-		dir = BGP_VPN_POLICY_DIR_FROMVPN;
-		ecom_str = ecommunity_ecom2str(
-				bgp->vpn_policy[afi].rtlist[dir],
-				ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
-		vty_out(vty, "Import RT(s): %s\n", ecom_str);
-		XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
-	}
 
-	if (!CHECK_FLAG(bgp->af_flags[afi][safi],
-			BGP_CONFIG_VRF_TO_VRF_EXPORT)) {
-		vty_out(vty,
-			"This VRF is not exporting %s routes to any other VRF\n",
+		if (!CHECK_FLAG(bgp->af_flags[afi][safi],
+				BGP_CONFIG_VRF_TO_VRF_EXPORT))
+			vty_out(vty,
+		       "This VRF is not exporting %s routes to any other VRF\n",
 			afi_safi_print(afi, safi));
-	} else {
-		vty_out(vty,
-			"This VRF is exporting %s routes to the following VRFs:\n",
+		else {
+			vty_out(vty,
+		       "This VRF is exporting %s routes to the following VRFs:\n",
 			afi_safi_print(afi, safi));
-		for (ALL_LIST_ELEMENTS_RO(bgp->vpn_policy[afi].export_vrf, node,
-					  vname)) {
-			vty_out(vty, "  %s\n", vname);
+
+			for (ALL_LIST_ELEMENTS_RO(
+						bgp->vpn_policy[afi].export_vrf,
+						node, vname))
+				vty_out(vty, "  %s\n", vname);
+
+			vty_out(vty, "RD: %s\n",
+				prefix_rd2str(&bgp->vpn_policy[afi].tovpn_rd,
+					      buf1, RD_ADDRSTRLEN));
+
+			dir = BGP_VPN_POLICY_DIR_TOVPN;
+			ecom_str = ecommunity_ecom2str(
+					bgp->vpn_policy[afi].rtlist[dir],
+					ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+			vty_out(vty, "Export RT: %s\n", ecom_str);
+			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
 		}
-		vty_out(vty, "RD: %s\n",
-			prefix_rd2str(&bgp->vpn_policy[afi].tovpn_rd,
-				      buf1, RD_ADDRSTRLEN));
-		dir = BGP_VPN_POLICY_DIR_TOVPN;
-		ecom_str = ecommunity_ecom2str(
-				bgp->vpn_policy[afi].rtlist[dir],
-				ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
-		vty_out(vty, "Emport RT: %s\n", ecom_str);
-		XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
 	}
 
 	return CMD_SUCCESS;
@@ -11032,20 +11153,22 @@ static int bgp_show_route_leak_vty(struc
 
 /* "show [ip] bgp route-leak" command.  */
 DEFUN (show_ip_bgp_route_leak,
-       show_ip_bgp_route_leak_cmd,
-       "show [ip] bgp [<view|vrf> VIEWVRFNAME] ["BGP_AFI_CMD_STR" ["BGP_SAFI_CMD_STR"]] route-leak",
-       SHOW_STR
-       IP_STR
-       BGP_STR
-       BGP_INSTANCE_HELP_STR
-       BGP_AFI_HELP_STR
-       BGP_SAFI_HELP_STR
-       "Route leaking information\n")
+	show_ip_bgp_route_leak_cmd,
+	"show [ip] bgp [<view|vrf> VIEWVRFNAME] ["BGP_AFI_CMD_STR" ["BGP_SAFI_CMD_STR"]] route-leak  [json]",
+	SHOW_STR
+	IP_STR
+	BGP_STR
+	BGP_INSTANCE_HELP_STR
+	BGP_AFI_HELP_STR
+	BGP_SAFI_HELP_STR
+	"Route leaking information\n"
+	JSON_STR)
 {
 	char *vrf = NULL;
 	afi_t afi = AFI_MAX;
 	safi_t safi = SAFI_MAX;
 
+	uint8_t uj = use_json(argc, argv);
 	int idx = 0;
 
 	/* show [ip] bgp */
@@ -11073,7 +11196,7 @@ DEFUN (show_ip_bgp_route_leak,
 		return CMD_WARNING;
 	}
 
-	return bgp_show_route_leak_vty(vty, vrf, afi, safi);
+	return bgp_show_route_leak_vty(vty, vrf, afi, safi, uj);
 }
 
 static void bgp_show_all_instances_updgrps_vty(struct vty *vty, afi_t afi,
@@ -11396,7 +11519,6 @@ DEFUN (show_ip_bgp_peer_groups,
        "Peer group name\n")
 {
 	char *vrf, *pg;
-	vrf = pg = NULL;
 	int idx = 0;
 
 	vrf = argv_find(argv, argc, "VIEWVRFNAME", &idx) ? argv[idx]->arg
@@ -11426,7 +11548,7 @@ DEFUN (bgp_redistribute_ipv4,
 	}
 
 	bgp_redist_add(bgp, AFI_IP, type, 0);
-	return bgp_redistribute_set(bgp, AFI_IP, type, 0);
+	return bgp_redistribute_set(bgp, AFI_IP, type, 0, false);
 }
 
 ALIAS_HIDDEN(
@@ -11447,6 +11569,7 @@ DEFUN (bgp_redistribute_ipv4_rmap,
 	int idx_word = 3;
 	int type;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11455,8 +11578,8 @@ DEFUN (bgp_redistribute_ipv4_rmap,
 	}
 
 	red = bgp_redist_add(bgp, AFI_IP, type, 0);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP, type, 0);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP, type, 0, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11480,6 +11603,7 @@ DEFUN (bgp_redistribute_ipv4_metric,
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11489,8 +11613,8 @@ DEFUN (bgp_redistribute_ipv4_metric,
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, type, 0);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
-	return bgp_redistribute_set(bgp, AFI_IP, type, 0);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
+	return bgp_redistribute_set(bgp, AFI_IP, type, 0, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11517,6 +11641,7 @@ DEFUN (bgp_redistribute_ipv4_rmap_metric
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11526,9 +11651,9 @@ DEFUN (bgp_redistribute_ipv4_rmap_metric
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, type, 0);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
-	return bgp_redistribute_set(bgp, AFI_IP, type, 0);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	changed |= bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
+	return bgp_redistribute_set(bgp, AFI_IP, type, 0, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11559,6 +11684,7 @@ DEFUN (bgp_redistribute_ipv4_metric_rmap
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11568,9 +11694,9 @@ DEFUN (bgp_redistribute_ipv4_metric_rmap
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, type, 0);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP, type, 0);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP, type, metric);
+	changed |= bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP, type, 0, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11606,7 +11732,7 @@ DEFUN (bgp_redistribute_ipv4_ospf,
 		protocol = ZEBRA_ROUTE_TABLE;
 
 	bgp_redist_add(bgp, AFI_IP, protocol, instance);
-	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance);
+	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance, false);
 }
 
 ALIAS_HIDDEN(bgp_redistribute_ipv4_ospf, bgp_redistribute_ipv4_ospf_hidden_cmd,
@@ -11633,6 +11759,7 @@ DEFUN (bgp_redistribute_ipv4_ospf_rmap,
 	struct bgp_redist *red;
 	unsigned short instance;
 	int protocol;
+	bool changed;
 
 	if (strncmp(argv[idx_ospf_table]->arg, "o", 1) == 0)
 		protocol = ZEBRA_ROUTE_OSPF;
@@ -11641,8 +11768,8 @@ DEFUN (bgp_redistribute_ipv4_ospf_rmap,
 
 	instance = strtoul(argv[idx_number]->arg, NULL, 10);
 	red = bgp_redist_add(bgp, AFI_IP, protocol, instance);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance, changed);
 }
 
 ALIAS_HIDDEN(bgp_redistribute_ipv4_ospf_rmap,
@@ -11673,6 +11800,7 @@ DEFUN (bgp_redistribute_ipv4_ospf_metric
 	struct bgp_redist *red;
 	unsigned short instance;
 	int protocol;
+	bool changed;
 
 	if (strncmp(argv[idx_ospf_table]->arg, "o", 1) == 0)
 		protocol = ZEBRA_ROUTE_OSPF;
@@ -11683,8 +11811,9 @@ DEFUN (bgp_redistribute_ipv4_ospf_metric
 	metric = strtoul(argv[idx_number_2]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, protocol, instance);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol, metric);
-	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol,
+						metric);
+	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance, changed);
 }
 
 ALIAS_HIDDEN(bgp_redistribute_ipv4_ospf_metric,
@@ -11718,6 +11847,7 @@ DEFUN (bgp_redistribute_ipv4_ospf_rmap_m
 	struct bgp_redist *red;
 	unsigned short instance;
 	int protocol;
+	bool changed;
 
 	if (strncmp(argv[idx_ospf_table]->arg, "o", 1) == 0)
 		protocol = ZEBRA_ROUTE_OSPF;
@@ -11728,9 +11858,10 @@ DEFUN (bgp_redistribute_ipv4_ospf_rmap_m
 	metric = strtoul(argv[idx_number_2]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, protocol, instance);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol, metric);
-	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	changed |= bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol,
+						metric);
+	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11767,6 +11898,7 @@ DEFUN (bgp_redistribute_ipv4_ospf_metric
 	struct bgp_redist *red;
 	unsigned short instance;
 	int protocol;
+	bool changed;
 
 	if (strncmp(argv[idx_ospf_table]->arg, "o", 1) == 0)
 		protocol = ZEBRA_ROUTE_OSPF;
@@ -11777,9 +11909,10 @@ DEFUN (bgp_redistribute_ipv4_ospf_metric
 	metric = strtoul(argv[idx_number_2]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP, protocol, instance);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol, metric);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP, protocol,
+						metric);
+	changed |= bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP, protocol, instance, changed);
 }
 
 ALIAS_HIDDEN(
@@ -11887,7 +12020,7 @@ DEFUN (bgp_redistribute_ipv6,
 	}
 
 	bgp_redist_add(bgp, AFI_IP6, type, 0);
-	return bgp_redistribute_set(bgp, AFI_IP6, type, 0);
+	return bgp_redistribute_set(bgp, AFI_IP6, type, 0, false);
 }
 
 DEFUN (bgp_redistribute_ipv6_rmap,
@@ -11903,6 +12036,7 @@ DEFUN (bgp_redistribute_ipv6_rmap,
 	int idx_word = 3;
 	int type;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP6, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11911,8 +12045,8 @@ DEFUN (bgp_redistribute_ipv6_rmap,
 	}
 
 	red = bgp_redist_add(bgp, AFI_IP6, type, 0);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP6, type, 0);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP6, type, 0, changed);
 }
 
 DEFUN (bgp_redistribute_ipv6_metric,
@@ -11929,6 +12063,7 @@ DEFUN (bgp_redistribute_ipv6_metric,
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP6, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11938,8 +12073,8 @@ DEFUN (bgp_redistribute_ipv6_metric,
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP6, type, 0);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP6, type, metric);
-	return bgp_redistribute_set(bgp, AFI_IP6, type, 0);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP6, type, metric);
+	return bgp_redistribute_set(bgp, AFI_IP6, type, 0, changed);
 }
 
 DEFUN (bgp_redistribute_ipv6_rmap_metric,
@@ -11959,6 +12094,7 @@ DEFUN (bgp_redistribute_ipv6_rmap_metric
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP6, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11968,9 +12104,10 @@ DEFUN (bgp_redistribute_ipv6_rmap_metric
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP6, type, 0);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP6, type, metric);
-	return bgp_redistribute_set(bgp, AFI_IP6, type, 0);
+	changed = bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	changed |= bgp_redistribute_metric_set(bgp, red, AFI_IP6, type,
+						metric);
+	return bgp_redistribute_set(bgp, AFI_IP6, type, 0, changed);
 }
 
 DEFUN (bgp_redistribute_ipv6_metric_rmap,
@@ -11990,6 +12127,7 @@ DEFUN (bgp_redistribute_ipv6_metric_rmap
 	int type;
 	uint32_t metric;
 	struct bgp_redist *red;
+	bool changed;
 
 	type = proto_redistnum(AFI_IP6, argv[idx_protocol]->text);
 	if (type < 0) {
@@ -11999,9 +12137,10 @@ DEFUN (bgp_redistribute_ipv6_metric_rmap
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	red = bgp_redist_add(bgp, AFI_IP6, type, 0);
-	bgp_redistribute_metric_set(bgp, red, AFI_IP6, SAFI_UNICAST, metric);
-	bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
-	return bgp_redistribute_set(bgp, AFI_IP6, type, 0);
+	changed = bgp_redistribute_metric_set(bgp, red, AFI_IP6, SAFI_UNICAST,
+						metric);
+	changed |= bgp_redistribute_rmap_set(red, argv[idx_word]->arg);
+	return bgp_redistribute_set(bgp, AFI_IP6, type, 0, changed);
 }
 
 DEFUN (no_bgp_redistribute_ipv6,
@@ -12216,7 +12355,6 @@ static void bgp_ac_neighbor(vector comps
 {
 	struct bgp *bgp;
 	struct peer *peer;
-	struct peer_group *group;
 	struct listnode *lnbgp, *lnpeer;
 
 	for (ALL_LIST_ELEMENTS_RO(bm->bgp, lnbgp, bgp)) {
@@ -12240,11 +12378,6 @@ static void bgp_ac_neighbor(vector comps
 
 			vector_set(comps, XSTRDUP(MTYPE_COMPLETION, name));
 		}
-
-		if (token->type == VARIABLE_TKN)
-			for (ALL_LIST_ELEMENTS_RO(bgp->group, lnpeer, group))
-				vector_set(comps, XSTRDUP(MTYPE_COMPLETION,
-							  group->name));
 	}
 }
 
@@ -12254,9 +12387,27 @@ static const struct cmd_variable_handler
 	{.varname = "peer", .completions = bgp_ac_neighbor},
 	{.completions = NULL}};
 
+static void bgp_ac_peergroup(vector comps, struct cmd_token *token)
+{
+	struct bgp *bgp;
+	struct peer_group *group;
+	struct listnode *lnbgp, *lnpeer;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, lnbgp, bgp)) {
+		for (ALL_LIST_ELEMENTS_RO(bgp->group, lnpeer, group))
+			vector_set(comps, XSTRDUP(MTYPE_COMPLETION,
+						  group->name));
+	}
+}
+
+static const struct cmd_variable_handler bgp_var_peergroup[] = {
+	{.tokenname = "PGNAME", .completions = bgp_ac_peergroup},
+	{.completions = NULL} };
+
 void bgp_vty_init(void)
 {
 	cmd_variable_handler_register(bgp_var_neighbor);
+	cmd_variable_handler_register(bgp_var_peergroup);
 
 	/* Install bgp top node. */
 	install_node(&bgp_node, bgp_config_write);
@@ -12415,7 +12566,6 @@ void bgp_vty_init(void)
 
 	/* "bgp enforce-first-as" commands */
 	install_element(BGP_NODE, &bgp_enforce_first_as_cmd);
-	install_element(BGP_NODE, &no_bgp_enforce_first_as_cmd);
 
 	/* "bgp bestpath compare-routerid" commands */
 	install_element(BGP_NODE, &bgp_bestpath_compare_router_id_cmd);
@@ -12638,6 +12788,8 @@ void bgp_vty_init(void)
 	install_element(BGP_VPNV4_NODE, &no_neighbor_nexthop_self_cmd);
 	install_element(BGP_VPNV6_NODE, &neighbor_nexthop_self_cmd);
 	install_element(BGP_VPNV6_NODE, &no_neighbor_nexthop_self_cmd);
+	install_element(BGP_EVPN_NODE, &neighbor_nexthop_self_cmd);
+	install_element(BGP_EVPN_NODE, &no_neighbor_nexthop_self_cmd);
 
 	/* "neighbor next-hop-self force" commands. */
 	install_element(BGP_NODE, &neighbor_nexthop_self_force_hidden_cmd);
diff -urpN frr-frr-5.0.1/bgpd/bgp_zebra.c frr-frr-6.0/bgpd/bgp_zebra.c
--- frr-frr-5.0.1/bgpd/bgp_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -44,6 +44,7 @@
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_fsm.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_mpath.h"
 #include "bgpd/bgp_nexthop.h"
 #include "bgpd/bgp_nht.h"
@@ -1016,7 +1017,7 @@ static int bgp_zebra_tm_connect(struct t
 		ret = tm_table_manager_connect(zclient);
 	}
 	if (ret < 0) {
-		zlog_warn("Error connecting to table manager!");
+		zlog_info("Error connecting to table manager!");
 		bgp_tm_status_connected = false;
 	} else {
 		if (!bgp_tm_status_connected)
@@ -1077,7 +1078,8 @@ int bgp_zebra_get_table_range(uint32_t c
 		return -1;
 	ret = tm_get_table_chunk(zclient, chunk_size, start, end);
 	if (ret < 0) {
-		zlog_err("BGP: Error getting table chunk %u", chunk_size);
+		flog_err(BGP_ERR_TABLE_CHUNK,
+			  "BGP: Error getting table chunk %u", chunk_size);
 		return -1;
 	}
 	zlog_info("BGP: Table Manager returns range from chunk %u is [%u %u]",
@@ -1190,7 +1192,7 @@ void bgp_zebra_announce(struct bgp_node
 	mpls_label_t label;
 	int nh_othervrf = 0;
 	char buf_prefix[PREFIX_STRLEN];	/* filled in if we are debugging */
-	bool is_evpn = false;
+	bool is_evpn;
 	int nh_updated;
 
 	/* Don't try to install if we're not connected to Zebra or Zebra doesn't
@@ -1203,7 +1205,7 @@ void bgp_zebra_announce(struct bgp_node
 		return;
 
 	if (bgp_debug_zebra(p))
-		prefix2str(&api.prefix, buf_prefix, sizeof(buf_prefix));
+		prefix2str(p, buf_prefix, sizeof(buf_prefix));
 
 	if (safi == SAFI_FLOWSPEC)
 		return bgp_pbr_update_entry(bgp, &rn->p,
@@ -1217,7 +1219,6 @@ void bgp_zebra_announce(struct bgp_node
 
 	/* Make Zebra API structure. */
 	memset(&api, 0, sizeof(api));
-	memcpy(&api.rmac, &(info->attr->rmac), sizeof(struct ethaddr));
 	api.vrf_id = bgp->vrf_id;
 	api.type = ZEBRA_ROUTE_BGP;
 	api.safi = safi;
@@ -1236,13 +1237,6 @@ void bgp_zebra_announce(struct bgp_node
 
 	tag = info->attr->tag;
 
-	/*
-	 * When we create an aggregate route we must also install a
-	 * Null0 route in the RIB
-	 */
-	if (info->sub_type == BGP_ROUTE_AGGREGATE)
-		zapi_route_set_blackhole(&api, BLACKHOLE_NULL);
-
 	/* If the route's source is EVPN, flag as such. */
 	is_evpn = is_route_parent_evpn(info);
 	if (is_evpn)
@@ -1298,17 +1292,11 @@ void bgp_zebra_announce(struct bgp_node
 				}
 			}
 
-			if (bgp->table_map[afi][safi].name || nh_othervrf) {
+			if (bgp->table_map[afi][safi].name) {
 				/* Copy info and attributes, so the route-map
 				   apply doesn't modify the BGP route info. */
 				local_attr = *mpinfo->attr;
 				mpinfo_cp->attr = &local_attr;
-				if (nh_othervrf) {
-					/* allow route-map to modify */
-					local_attr.nexthop =
-						info->extra->nexthop_orig.u
-							.prefix4;
-				}
 			}
 
 			if (bgp->table_map[afi][safi].name) {
@@ -1330,22 +1318,14 @@ void bgp_zebra_announce(struct bgp_node
 					&mpinfo_cp->attr->nexthop,
 					mpinfo_cp->attr, is_evpn, api_nh);
 		} else {
-			ifindex_t ifindex;
+			ifindex_t ifindex = IFINDEX_INTERNAL;
 			struct in6_addr *nexthop;
 
-			if (bgp->table_map[afi][safi].name || nh_othervrf) {
+			if (bgp->table_map[afi][safi].name) {
 				/* Copy info and attributes, so the route-map
 				   apply doesn't modify the BGP route info. */
 				local_attr = *mpinfo->attr;
 				mpinfo_cp->attr = &local_attr;
-				if (nh_othervrf) {
-					/* allow route-map to modify */
-					local_attr.mp_nexthop_global =
-						info->extra->nexthop_orig.u
-							.prefix6;
-					local_attr.mp_nexthop_len =
-						BGP_ATTR_NHLEN_IPV6_GLOBAL;
-				}
 			}
 
 			if (bgp->table_map[afi][safi].name) {
@@ -1386,6 +1366,8 @@ void bgp_zebra_announce(struct bgp_node
 			api_nh->label_num = 1;
 			api_nh->labels[0] = label;
 		}
+		memcpy(&api_nh->rmac, &(mpinfo->attr->rmac),
+		       sizeof(struct ethaddr));
 		valid_nh_count++;
 	}
 
@@ -1394,7 +1376,14 @@ void bgp_zebra_announce(struct bgp_node
 	if (has_valid_label && !(CHECK_FLAG(api.flags, ZEBRA_FLAG_EVPN_ROUTE)))
 		SET_FLAG(api.message, ZAPI_MESSAGE_LABEL);
 
-	if (info->sub_type != BGP_ROUTE_AGGREGATE)
+	/*
+	 * When we create an aggregate route we must also
+	 * install a Null0 route in the RIB, so overwrite
+	 * what was written into api with a blackhole route
+	 */
+	if (info->sub_type == BGP_ROUTE_AGGREGATE)
+		zapi_route_set_blackhole(&api, BLACKHOLE_NULL);
+	else
 		api.nexthop_num = valid_nh_count;
 
 	SET_FLAG(api.message, ZAPI_MESSAGE_METRIC);
@@ -1510,7 +1499,6 @@ void bgp_zebra_withdraw(struct prefix *p
 	}
 
 	memset(&api, 0, sizeof(api));
-	memcpy(&api.rmac, &(info->attr->rmac), sizeof(struct ethaddr));
 	api.vrf_id = bgp->vrf_id;
 	api.type = ZEBRA_ROUTE_BGP;
 	api.safi = safi;
@@ -1588,8 +1576,14 @@ static void bgp_redist_del(struct bgp *b
 
 /* Other routes redistribution into BGP. */
 int bgp_redistribute_set(struct bgp *bgp, afi_t afi, int type,
-			 unsigned short instance)
+			 unsigned short instance, bool changed)
 {
+	/* If redistribute options are changed call
+	 * bgp_redistribute_unreg() to reset the option and withdraw
+	 * the routes
+	 */
+	if (changed)
+		bgp_redistribute_unreg(bgp, afi, type, instance);
 
 	/* Return if already redistribute flag is set. */
 	if (instance) {
@@ -1923,7 +1917,7 @@ int bgp_zebra_advertise_gw_macip(struct
 
 	zclient_create_header(s, ZEBRA_ADVERTISE_DEFAULT_GW, bgp->vrf_id);
 	stream_putc(s, advertise);
-	stream_put3(s, vni);
+	stream_putl(s, vni);
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	return zclient_send_message(zclient);
@@ -2012,7 +2006,7 @@ static int ipset_notify_owner(int comman
 	bgp_pbim = bgp_pbr_match_ipset_lookup(vrf_id, unique);
 	if (!bgp_pbim) {
 		if (BGP_DEBUG(zebra, ZEBRA))
-			zlog_debug("%s: Fail to look BGP match ( %u %u)",
+			zlog_debug("%s: Fail to look BGP match ( %u, ID %u)",
 				   __PRETTY_FUNCTION__, note, unique);
 		return 0;
 	}
@@ -2062,7 +2056,7 @@ static int ipset_entry_notify_owner(int
 						     unique);
 	if (!bgp_pbime) {
 		if (BGP_DEBUG(zebra, ZEBRA))
-			zlog_debug("%s: Fail to look BGP match entry (%u %u)",
+			zlog_debug("%s: Fail to look BGP match entry (%u, ID %u)",
 				   __PRETTY_FUNCTION__, note, unique);
 		return 0;
 	}
@@ -2088,7 +2082,9 @@ static int ipset_entry_notify_owner(int
 			/* link bgp_info to bpme */
 			bgp_info = (struct bgp_info *)bgp_pbime->bgp_info;
 			extra = bgp_info_extra_get(bgp_info);
-			extra->bgp_fs_pbr = (void *)bgp_pbime;
+			if (extra->bgp_fs_pbr == NULL)
+				extra->bgp_fs_pbr = list_new();
+			listnode_add(extra->bgp_fs_pbr, bgp_pbime);
 		}
 		break;
 	case ZAPI_IPSET_ENTRY_FAIL_REMOVE:
@@ -2269,6 +2265,40 @@ static void bgp_zebra_connected(struct z
 	 */
 }
 
+static int bgp_zebra_process_local_es(int cmd, struct zclient *zclient,
+				      zebra_size_t length, vrf_id_t vrf_id)
+{
+	esi_t esi;
+	struct bgp *bgp = NULL;
+	struct stream *s = NULL;
+	char buf[ESI_STR_LEN];
+	char buf1[INET6_ADDRSTRLEN];
+	struct ipaddr originator_ip;
+
+	memset(&esi, 0, sizeof(esi_t));
+	memset(&originator_ip, 0, sizeof(struct ipaddr));
+
+	bgp = bgp_lookup_by_vrf_id(vrf_id);
+	if (!bgp)
+		return 0;
+
+	s = zclient->ibuf;
+	stream_get(&esi, s, sizeof(esi_t));
+	stream_get(&originator_ip, s, sizeof(struct ipaddr));
+
+	if (BGP_DEBUG(zebra, ZEBRA))
+		zlog_debug("Rx %s ESI %s originator-ip %s",
+			   (cmd == ZEBRA_LOCAL_ES_ADD) ? "add" : "del",
+			   esi_to_str(&esi, buf, sizeof(buf)),
+			   ipaddr2str(&originator_ip, buf1, sizeof(buf1)));
+
+	if (cmd == ZEBRA_LOCAL_ES_ADD)
+		bgp_evpn_local_es_add(bgp, &esi, &originator_ip);
+	else
+		bgp_evpn_local_es_del(bgp, &esi, &originator_ip);
+	return 0;
+}
+
 static int bgp_zebra_process_local_l3vni(int cmd, struct zclient *zclient,
 					 zebra_size_t length, vrf_id_t vrf_id)
 {
@@ -2359,9 +2389,10 @@ static int bgp_zebra_process_local_macip
 	ipa_len = stream_getl(s);
 	if (ipa_len != 0 && ipa_len != IPV4_MAX_BYTELEN
 	    && ipa_len != IPV6_MAX_BYTELEN) {
-		zlog_err("%u:Recv MACIP %s with invalid IP addr length %d",
-			 vrf_id, (command == ZEBRA_MACIP_ADD) ? "Add" : "Del",
-			 ipa_len);
+		flog_err(BGP_ERR_MACIP_LEN,
+			  "%u:Recv MACIP %s with invalid IP addr length %d",
+			  vrf_id, (command == ZEBRA_MACIP_ADD) ? "Add" : "Del",
+			  ipa_len);
 		return -1;
 	}
 
@@ -2451,11 +2482,13 @@ static void bgp_zebra_process_label_chun
 	STREAM_GETL(s, last);
 
 	if (zclient->redist_default != proto) {
-		zlog_err("Got LM msg with wrong proto %u", proto);
+		flog_err(BGP_ERR_LM_ERROR, "Got LM msg with wrong proto %u",
+			  proto);
 		return;
 	}
 	if (zclient->instance != instance) {
-		zlog_err("Got LM msg with wrong instance %u", proto);
+		flog_err(BGP_ERR_LM_ERROR, "Got LM msg with wrong instance %u",
+			  proto);
 		return;
 	}
 
@@ -2463,8 +2496,8 @@ static void bgp_zebra_process_label_chun
 		first < MPLS_LABEL_UNRESERVED_MIN ||
 		last > MPLS_LABEL_UNRESERVED_MAX) {
 
-		zlog_err("%s: Invalid Label chunk: %u - %u",
-			__func__, first, last);
+		flog_err(BGP_ERR_LM_ERROR, "%s: Invalid Label chunk: %u - %u",
+			  __func__, first, last);
 		return;
 	}
 	if (BGP_DEBUG(zebra, ZEBRA)) {
@@ -2480,7 +2513,7 @@ stream_failure:		/* for STREAM_GETX */
 
 extern struct zebra_privs_t bgpd_privs;
 
-void bgp_zebra_init(struct thread_master *master, unsigned short instance)
+void bgp_zebra_init(struct thread_master *master)
 {
 	zclient_num_connects = 0;
 
@@ -2504,6 +2537,8 @@ void bgp_zebra_init(struct thread_master
 	zclient->nexthop_update = bgp_read_nexthop_update;
 	zclient->import_check_update = bgp_read_import_check_update;
 	zclient->fec_update = bgp_read_fec_update;
+	zclient->local_es_add = bgp_zebra_process_local_es;
+	zclient->local_es_del = bgp_zebra_process_local_es;
 	zclient->local_vni_add = bgp_zebra_process_local_vni;
 	zclient->local_vni_del = bgp_zebra_process_local_vni;
 	zclient->local_macip_add = bgp_zebra_process_local_macip;
@@ -2517,7 +2552,6 @@ void bgp_zebra_init(struct thread_master
 	zclient->ipset_notify_owner = ipset_notify_owner;
 	zclient->ipset_entry_notify_owner = ipset_entry_notify_owner;
 	zclient->iptable_notify_owner = iptable_notify_owner;
-	zclient->instance = instance;
 }
 
 void bgp_zebra_destroy(void)
@@ -2566,9 +2600,10 @@ void bgp_send_pbr_ipset_match(struct bgp
 	if (pbrim->install_in_progress)
 		return;
 	if (BGP_DEBUG(zebra, ZEBRA))
-		zlog_debug("%s: name %s type %d %d",
+		zlog_debug("%s: name %s type %d %d, ID %u",
 			   __PRETTY_FUNCTION__,
-			   pbrim->ipset_name, pbrim->type, install);
+			   pbrim->ipset_name, pbrim->type,
+			   install, pbrim->unique);
 	s = zclient->obuf;
 	stream_reset(s);
 
@@ -2594,9 +2629,9 @@ void bgp_send_pbr_ipset_entry_match(stru
 	if (pbrime->install_in_progress)
 		return;
 	if (BGP_DEBUG(zebra, ZEBRA))
-		zlog_debug("%s: name %s %d %d", __PRETTY_FUNCTION__,
+		zlog_debug("%s: name %s %d %d, ID %u", __PRETTY_FUNCTION__,
 			   pbrime->backpointer->ipset_name,
-			   pbrime->unique, install);
+			   pbrime->unique, install, pbrime->unique);
 	s = zclient->obuf;
 	stream_reset(s);
 
@@ -2661,9 +2696,10 @@ void bgp_send_pbr_iptable(struct bgp_pbr
 	if (pbm->install_iptable_in_progress)
 		return;
 	if (BGP_DEBUG(zebra, ZEBRA))
-		zlog_debug("%s: name %s type %d mark %d %d",
+		zlog_debug("%s: name %s type %d mark %d %d, ID %u",
 			   __PRETTY_FUNCTION__, pbm->ipset_name,
-			   pbm->type, pba->fwmark, install);
+			   pbm->type, pba->fwmark, install,
+			   pbm->unique2);
 	s = zclient->obuf;
 	stream_reset(s);
 
diff -urpN frr-frr-5.0.1/bgpd/bgp_zebra.h frr-frr-6.0/bgpd/bgp_zebra.h
--- frr-frr-5.0.1/bgpd/bgp_zebra.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgp_zebra.h	2018-10-08 14:32:57.000000000 +0200
@@ -23,8 +23,7 @@
 
 #include "vxlan.h"
 
-extern void bgp_zebra_init(struct thread_master *master,
-			   unsigned short instance);
+extern void bgp_zebra_init(struct thread_master *master);
 extern void bgp_zebra_init_tm_connect(struct bgp *bgp);
 extern uint32_t bgp_zebra_tm_get_id(void);
 extern bool bgp_zebra_tm_chunk_obtained(void);
@@ -52,7 +51,8 @@ extern struct bgp_redist *bgp_redist_loo
 					    unsigned short);
 extern struct bgp_redist *bgp_redist_add(struct bgp *, afi_t, uint8_t,
 					 unsigned short);
-extern int bgp_redistribute_set(struct bgp *, afi_t, int, unsigned short);
+extern int bgp_redistribute_set(struct bgp *, afi_t, int, unsigned short,
+				bool changed);
 extern int bgp_redistribute_resend(struct bgp *, afi_t, int, unsigned short);
 extern int bgp_redistribute_rmap_set(struct bgp_redist *, const char *);
 extern int bgp_redistribute_metric_set(struct bgp *, struct bgp_redist *, afi_t,
diff -urpN frr-frr-5.0.1/bgpd/bgpd.c frr-frr-6.0/bgpd/bgpd.c
--- frr-frr-5.0.1/bgpd/bgpd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgpd.c	2018-10-08 14:32:57.000000000 +0200
@@ -52,6 +52,7 @@
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_dump.h"
 #include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_errors.h"
 #include "bgpd/bgp_community.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_regex.h"
@@ -102,6 +103,7 @@ struct community_list_handler *bgp_clist
 unsigned int multipath_num = MULTIPATH_NUM;
 
 static void bgp_if_finish(struct bgp *bgp);
+static void peer_drop_dynamic_neighbor(struct peer *peer);
 
 extern struct zclient *zclient;
 
@@ -682,12 +684,6 @@ struct peer_af *peer_af_create(struct pe
 	/* Allocate new peer af */
 	af = XCALLOC(MTYPE_BGP_PEER_AF, sizeof(struct peer_af));
 
-	if (af == NULL) {
-		zlog_err("Could not create af structure for peer %s",
-			 peer->host);
-		return NULL;
-	}
-
 	peer->peer_af_array[afid] = af;
 	af->afi = afi;
 	af->safi = safi;
@@ -887,129 +883,6 @@ static bool peergroup_filter_check(struc
 	}
 }
 
-/* Reset all address family specific configuration.  */
-static void peer_af_flag_reset(struct peer *peer, afi_t afi, safi_t safi)
-{
-	int i;
-	struct bgp_filter *filter;
-	char orf_name[BUFSIZ];
-
-	filter = &peer->filter[afi][safi];
-
-	/* Clear neighbor filter and route-map */
-	for (i = FILTER_IN; i < FILTER_MAX; i++) {
-		if (filter->dlist[i].name) {
-			XFREE(MTYPE_BGP_FILTER_NAME, filter->dlist[i].name);
-			filter->dlist[i].name = NULL;
-		}
-		if (filter->plist[i].name) {
-			XFREE(MTYPE_BGP_FILTER_NAME, filter->plist[i].name);
-			filter->plist[i].name = NULL;
-		}
-		if (filter->aslist[i].name) {
-			XFREE(MTYPE_BGP_FILTER_NAME, filter->aslist[i].name);
-			filter->aslist[i].name = NULL;
-		}
-	}
-	for (i = RMAP_IN; i < RMAP_MAX; i++) {
-		if (filter->map[i].name) {
-			XFREE(MTYPE_BGP_FILTER_NAME, filter->map[i].name);
-			filter->map[i].name = NULL;
-		}
-	}
-
-	/* Clear unsuppress map.  */
-	if (filter->usmap.name)
-		XFREE(MTYPE_BGP_FILTER_NAME, filter->usmap.name);
-	filter->usmap.name = NULL;
-	filter->usmap.map = NULL;
-
-	/* Clear neighbor's all address family flags.  */
-	peer->af_flags[afi][safi] = 0;
-
-	/* Clear neighbor's all address family sflags. */
-	peer->af_sflags[afi][safi] = 0;
-
-	/* Clear neighbor's all address family capabilities. */
-	peer->af_cap[afi][safi] = 0;
-
-	/* Clear ORF info */
-	peer->orf_plist[afi][safi] = NULL;
-	sprintf(orf_name, "%s.%d.%d", peer->host, afi, safi);
-	prefix_bgp_orf_remove_all(afi, orf_name);
-
-	/* Set default neighbor send-community.  */
-	if (!bgp_option_check(BGP_OPT_CONFIG_CISCO)) {
-		SET_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY);
-		SET_FLAG(peer->af_flags[afi][safi],
-			 PEER_FLAG_SEND_EXT_COMMUNITY);
-		SET_FLAG(peer->af_flags[afi][safi],
-			 PEER_FLAG_SEND_LARGE_COMMUNITY);
-
-		SET_FLAG(peer->af_flags_invert[afi][safi],
-			 PEER_FLAG_SEND_COMMUNITY);
-		SET_FLAG(peer->af_flags_invert[afi][safi],
-			 PEER_FLAG_SEND_EXT_COMMUNITY);
-		SET_FLAG(peer->af_flags_invert[afi][safi],
-			 PEER_FLAG_SEND_LARGE_COMMUNITY);
-	}
-
-	/* Clear neighbor default_originate_rmap */
-	if (peer->default_rmap[afi][safi].name)
-		XFREE(MTYPE_ROUTE_MAP_NAME, peer->default_rmap[afi][safi].name);
-	peer->default_rmap[afi][safi].name = NULL;
-	peer->default_rmap[afi][safi].map = NULL;
-
-	/* Clear neighbor maximum-prefix */
-	peer->pmax[afi][safi] = 0;
-	peer->pmax_threshold[afi][safi] = MAXIMUM_PREFIX_THRESHOLD_DEFAULT;
-}
-
-/* peer global config reset */
-static void peer_global_config_reset(struct peer *peer)
-{
-	int saved_flags = 0;
-
-	peer->change_local_as = 0;
-	peer->ttl = (peer_sort(peer) == BGP_PEER_IBGP ? MAXTTL : 1);
-	if (peer->update_source) {
-		sockunion_free(peer->update_source);
-		peer->update_source = NULL;
-	}
-	if (peer->update_if) {
-		XFREE(MTYPE_PEER_UPDATE_SOURCE, peer->update_if);
-		peer->update_if = NULL;
-	}
-
-	if (peer_sort(peer) == BGP_PEER_IBGP)
-		peer->v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;
-	else
-		peer->v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;
-
-	/* These are per-peer specific flags and so we must preserve them */
-	saved_flags |= CHECK_FLAG(peer->flags, PEER_FLAG_IFPEER_V6ONLY);
-	saved_flags |= CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN);
-	peer->flags = 0;
-	SET_FLAG(peer->flags, saved_flags);
-
-	peer->holdtime = 0;
-	peer->keepalive = 0;
-	peer->connect = 0;
-	peer->v_connect = BGP_DEFAULT_CONNECT_RETRY;
-
-	/* Reset some other configs back to defaults. */
-	peer->v_start = BGP_INIT_START_TIMER;
-	peer->password = NULL;
-	peer->local_id = peer->bgp->router_id;
-	peer->v_holdtime = peer->bgp->default_holdtime;
-	peer->v_keepalive = peer->bgp->default_keepalive;
-
-	bfd_info_free(&(peer->bfd_info));
-
-	/* Set back the CONFIG_NODE flag. */
-	SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
-}
-
 /* Check peer's AS number and determines if this peer is IBGP or EBGP */
 static inline bgp_peer_sort_t peer_calc_sort(struct peer *peer)
 {
@@ -1025,12 +898,16 @@ static inline bgp_peer_sort_t peer_calc_
 		else if (peer->as_type == AS_EXTERNAL)
 			return BGP_PEER_EBGP;
 
-		else if (peer->as_type == AS_SPECIFIED && peer->as)
+		else if (peer->as_type == AS_SPECIFIED && peer->as) {
+			assert(bgp);
 			return (bgp->as == peer->as ? BGP_PEER_IBGP
 						    : BGP_PEER_EBGP);
+		}
 
 		else {
 			struct peer *peer1;
+
+			assert(peer->group);
 			peer1 = listnode_head(peer->group->peer);
 
 			if (peer1)
@@ -1242,6 +1119,11 @@ struct peer *peer_new(struct bgp *bgp)
 				 PEER_FLAG_SEND_LARGE_COMMUNITY);
 		}
 	}
+
+	/* set nexthop-unchanged for l2vpn evpn by default */
+	SET_FLAG(peer->af_flags[AFI_L2VPN][SAFI_EVPN],
+		 PEER_FLAG_NEXTHOP_UNCHANGED);
+
 	SET_FLAG(peer->sflags, PEER_STATUS_CAPABILITY_OPEN);
 
 	/* Create buffers.  */
@@ -1453,6 +1335,12 @@ void bgp_peer_conf_if_to_su_update(struc
 	if (!peer->conf_if)
 		return;
 
+	/*
+	 * Our peer structure is stored in the bgp->peerhash
+	 * release it before we modify anything.
+	 */
+	hash_release(peer->bgp->peerhash, peer);
+
 	prev_family = peer->su.sa.sa_family;
 	if ((ifp = if_lookup_by_name(peer->conf_if, peer->bgp->vrf_id))) {
 		peer->ifp = ifp;
@@ -1493,8 +1381,9 @@ void bgp_peer_conf_if_to_su_update(struc
 		memset(&peer->su.sin6.sin6_addr, 0, sizeof(struct in6_addr));
 	}
 
-	/* Since our su changed we need to del/add peer to the peerhash */
-	hash_release(peer->bgp->peerhash, peer);
+	/*
+	 * Since our su changed we need to del/add peer to the peerhash
+	 */
 	hash_get(peer->bgp->peerhash, peer, hash_alloc_intern);
 }
 
@@ -1915,8 +1804,8 @@ static int peer_activate_af(struct peer
 	int active;
 
 	if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
-		zlog_err("%s was called for peer-group %s", __func__,
-			 peer->host);
+		flog_err(BGP_ERR_PEER_GROUP, "%s was called for peer-group %s",
+			  __func__, peer->host);
 		return 1;
 	}
 
@@ -2029,8 +1918,8 @@ static int non_peergroup_deactivate_af(s
 				       safi_t safi)
 {
 	if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
-		zlog_err("%s was called for peer-group %s", __func__,
-			 peer->host);
+		flog_err(BGP_ERR_PEER_GROUP, "%s was called for peer-group %s",
+			  __func__, peer->host);
 		return 1;
 	}
 
@@ -2042,8 +1931,9 @@ static int non_peergroup_deactivate_af(s
 	peer->afc[afi][safi] = 0;
 
 	if (peer_af_delete(peer, afi, safi) != 0) {
-		zlog_err("couldn't delete af structure for peer %s",
-			 peer->host);
+		flog_err(BGP_ERR_PEER_DELETE,
+			  "couldn't delete af structure for peer %s",
+			  peer->host);
 		return 1;
 	}
 
@@ -2092,8 +1982,9 @@ int peer_deactivate(struct peer *peer, a
 		group = peer->group;
 
 		if (peer_af_delete(peer, afi, safi) != 0) {
-			zlog_err("couldn't delete af structure for peer %s",
-				 peer->host);
+			flog_err(BGP_ERR_PEER_DELETE,
+				  "couldn't delete af structure for peer %s",
+				  peer->host);
 		}
 
 		for (ALL_LIST_ELEMENTS(group->peer, node, nnode, tmp_peer)) {
@@ -2720,9 +2611,8 @@ int peer_group_bind(struct bgp *bgp, uni
 		if (peer->group) {
 			assert(group && peer->group == group);
 		} else {
-			struct listnode *pn;
-			pn = listnode_lookup(bgp->peer, peer);
-			list_delete_node(bgp->peer, pn);
+			listnode_delete(bgp->peer, peer);
+
 			peer->group = group;
 			listnode_add_sort(bgp->peer, peer);
 
@@ -2805,61 +2695,6 @@ int peer_group_bind(struct bgp *bgp, uni
 	return 0;
 }
 
-int peer_group_unbind(struct bgp *bgp, struct peer *peer,
-		      struct peer_group *group)
-{
-	struct peer *other;
-	afi_t afi;
-	safi_t safi;
-
-	if (group != peer->group)
-		return BGP_ERR_PEER_GROUP_MISMATCH;
-
-	FOREACH_AFI_SAFI (afi, safi) {
-		if (peer->afc[afi][safi]) {
-			peer->afc[afi][safi] = 0;
-			peer_af_flag_reset(peer, afi, safi);
-
-			if (peer_af_delete(peer, afi, safi) != 0) {
-				zlog_err(
-					"couldn't delete af structure for peer %s",
-					peer->host);
-			}
-		}
-	}
-
-	assert(listnode_lookup(group->peer, peer));
-	peer_unlock(peer); /* peer group list reference */
-	listnode_delete(group->peer, peer);
-	peer->group = NULL;
-	other = peer->doppelganger;
-
-	if (group->conf->as) {
-		peer_delete(peer);
-		if (other && other->status != Deleted) {
-			if (other->group) {
-				peer_unlock(other);
-				listnode_delete(group->peer, other);
-			}
-			other->group = NULL;
-			peer_delete(other);
-		}
-		return 0;
-	}
-
-	bgp_bfd_deregister_peer(peer);
-	peer_global_config_reset(peer);
-
-	if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
-		peer->last_reset = PEER_DOWN_RMAP_UNBIND;
-		bgp_notify_send(peer, BGP_NOTIFY_CEASE,
-				BGP_NOTIFY_CEASE_CONFIG_CHANGE);
-	} else
-		bgp_session_reset(peer);
-
-	return 0;
-}
-
 static int bgp_startup_timer_expire(struct thread *thread)
 {
 	struct bgp *bgp;
@@ -2870,6 +2705,18 @@ static int bgp_startup_timer_expire(stru
 	return 0;
 }
 
+/*
+ * On shutdown we call the cleanup function which
+ * does a free of the link list nodes,  free up
+ * the data we are pointing at too.
+ */
+static void bgp_vrf_string_name_delete(void *data)
+{
+	char *vname = data;
+
+	XFREE(MTYPE_TMP, vname);
+}
+
 /* BGP instance creation by `router bgp' commands. */
 static struct bgp *bgp_create(as_t *as, const char *name,
 			      enum bgp_instance_type inst_type)
@@ -2980,7 +2827,11 @@ static struct bgp *bgp_create(as_t *as,
 			MPLS_LABEL_NONE;
 
 		bgp->vpn_policy[afi].import_vrf = list_new();
+		bgp->vpn_policy[afi].import_vrf->del =
+			bgp_vrf_string_name_delete;
 		bgp->vpn_policy[afi].export_vrf = list_new();
+		bgp->vpn_policy[afi].export_vrf->del =
+			bgp_vrf_string_name_delete;
 	}
 	if (name) {
 		bgp->name = XSTRDUP(MTYPE_BGP, name);
@@ -3264,7 +3115,11 @@ int bgp_delete(struct bgp *bgp)
 	afi_t afi;
 	int i;
 
+	assert(bgp);
 	THREAD_OFF(bgp->t_startup);
+	THREAD_OFF(bgp->t_maxmed_onstartup);
+	THREAD_OFF(bgp->t_update_delay);
+	THREAD_OFF(bgp->t_establish_wait);
 
 	if (BGP_DEBUG(zebra, ZEBRA)) {
 		if (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
@@ -3332,15 +3187,16 @@ int bgp_delete(struct bgp *bgp)
 				.import_redirect_rtlist);
 		bgp->vpn_policy[afi].import_redirect_rtlist = NULL;
 	}
-	/* Remove visibility via the master list - there may however still be
-	 * routes to be processed still referencing the struct bgp.
-	 */
-	listnode_delete(bm->bgp, bgp);
 
 	/* Deregister from Zebra, if needed */
 	if (IS_BGP_INST_KNOWN_TO_ZEBRA(bgp))
 		bgp_zebra_instance_deregister(bgp);
 
+	/* Remove visibility via the master list - there may however still be
+	 * routes to be processed still referencing the struct bgp.
+	 */
+	listnode_delete(bm->bgp, bgp);
+
 	/* Free interfaces in this instance. */
 	bgp_if_finish(bgp);
 
@@ -3392,17 +3248,6 @@ void bgp_free(struct bgp *bgp)
 		rmap = &bgp->table_map[afi][safi];
 		if (rmap->name)
 			XFREE(MTYPE_ROUTE_MAP_NAME, rmap->name);
-
-		/*
-		 * Yes this is per AFI, but
-		 * the list_delete_and_null nulls the pointer
-		 * and we'll not leak anything on going down
-		 * and the if test will fail on the second safi.
-		 */
-		if (bgp->vpn_policy[afi].import_vrf)
-			list_delete_and_null(&bgp->vpn_policy[afi].import_vrf);
-		if (bgp->vpn_policy[afi].export_vrf)
-			list_delete_and_null(&bgp->vpn_policy[afi].export_vrf);
 	}
 
 	bgp_scan_finish(bgp);
@@ -3414,6 +3259,23 @@ void bgp_free(struct bgp *bgp)
 
 	bgp_evpn_cleanup(bgp);
 	bgp_pbr_cleanup(bgp);
+
+	for (afi = AFI_IP; afi < AFI_MAX; afi++) {
+		vpn_policy_direction_t dir;
+
+		if (bgp->vpn_policy[afi].import_vrf)
+			list_delete_and_null(&bgp->vpn_policy[afi].import_vrf);
+		if (bgp->vpn_policy[afi].export_vrf)
+			list_delete_and_null(&bgp->vpn_policy[afi].export_vrf);
+
+		dir = BGP_VPN_POLICY_DIR_FROMVPN;
+		if (bgp->vpn_policy[afi].rtlist[dir])
+			ecommunity_free(&bgp->vpn_policy[afi].rtlist[dir]);
+		dir = BGP_VPN_POLICY_DIR_TOVPN;
+		if (bgp->vpn_policy[afi].rtlist[dir])
+			ecommunity_free(&bgp->vpn_policy[afi].rtlist[dir]);
+	}
+
 	if (bgp->name)
 		XFREE(MTYPE_BGP, bgp->name);
 	if (bgp->name_pretty)
@@ -3676,10 +3538,10 @@ struct peer *peer_lookup_dynamic_neighbo
 	return peer;
 }
 
-void peer_drop_dynamic_neighbor(struct peer *peer)
+static void peer_drop_dynamic_neighbor(struct peer *peer)
 {
 	int dncount = -1;
-	if (peer->group && peer->group->bgp) {
+	if (peer->group->bgp) {
 		dncount = peer->group->bgp->dynamic_neighbors_count;
 		if (dncount)
 			peer->group->bgp->dynamic_neighbors_count = --dncount;
@@ -3689,7 +3551,6 @@ void peer_drop_dynamic_neighbor(struct p
 			   peer->group->name, dncount);
 }
 
-
 /* If peer is configured at least one address family return 1. */
 int peer_active(struct peer *peer)
 {
@@ -3787,9 +3648,6 @@ struct peer_flag_action {
 
 	/* Action when the flag is changed.  */
 	enum peer_change_type type;
-
-	/* Peer down cause */
-	uint8_t peer_down;
 };
 
 static const struct peer_flag_action peer_flag_action_list[] = {
@@ -4105,6 +3963,35 @@ static int peer_af_flag_modify(struct pe
 		}
 	}
 
+	/*
+	 * For EVPN we implicitly set the NEXTHOP_UNCHANGED flag,
+	 * if we are setting/unsetting flags which conflict with this flag
+	 * handle accordingly
+	 */
+	if (afi == AFI_L2VPN && safi == SAFI_EVPN) {
+		if (set) {
+
+			/*
+			 * if we are setting NEXTHOP_SELF, we need to unset the
+			 * NEXTHOP_UNCHANGED flag
+			 */
+			if (CHECK_FLAG(flag, PEER_FLAG_NEXTHOP_SELF) ||
+			    CHECK_FLAG(flag, PEER_FLAG_FORCE_NEXTHOP_SELF))
+				UNSET_FLAG(peer->af_flags[afi][safi],
+					   PEER_FLAG_NEXTHOP_UNCHANGED);
+		} else {
+
+			/*
+			 * if we are unsetting NEXTHOP_SELF, we need to set the
+			 * NEXTHOP_UNCHANGED flag to reset the defaults for EVPN
+			 */
+			if (CHECK_FLAG(flag, PEER_FLAG_NEXTHOP_SELF) ||
+			    CHECK_FLAG(flag, PEER_FLAG_FORCE_NEXTHOP_SELF))
+				SET_FLAG(peer->af_flags[afi][safi],
+					 PEER_FLAG_NEXTHOP_UNCHANGED);
+		}
+	}
+
 	/* Inherit from peer-group or set/unset flags accordingly. */
 	if (peer_group_active(peer) && set == invert)
 		peer_af_flag_inherit(peer, afi, safi, flag);
@@ -4205,7 +4092,7 @@ static int peer_af_flag_modify(struct pe
 			if (flag & PEER_FLAG_ADDPATH_TX_BESTPATH_PER_AS) {
 				if (!bgp_flag_check(
 					    bgp, BGP_FLAG_DETERMINISTIC_MED)) {
-					zlog_warn(
+					zlog_info(
 						"%s: enabling bgp deterministic-med, this is required"
 						" for addpath-tx-bestpath-per-AS",
 						peer->host);
@@ -6745,17 +6632,6 @@ char *peer_uptime(time_t uptime2, char *
 	time_t uptime1, epoch_tbuf;
 	struct tm *tm;
 
-	/* Check buffer length. */
-	if (len < BGP_UPTIME_LEN) {
-		if (!use_json) {
-			zlog_warn("peer_uptime (): buffer shortage %lu",
-				  (unsigned long)len);
-			/* XXX: should return status instead of buf... */
-			snprintf(buf, len, "<error> ");
-		}
-		return buf;
-	}
-
 	/* If there is no connection has been done before print `never'. */
 	if (uptime2 == 0) {
 		if (use_json) {
@@ -7340,7 +7216,9 @@ static void bgp_config_write_peer_af(str
 
 	/* atribute-unchanged. */
 	if (peer_af_flag_check(peer, afi, safi, PEER_FLAG_AS_PATH_UNCHANGED)
-	    || peer_af_flag_check(peer, afi, safi, PEER_FLAG_NEXTHOP_UNCHANGED)
+	    || (safi != SAFI_EVPN
+		&& peer_af_flag_check(peer, afi, safi,
+				      PEER_FLAG_NEXTHOP_UNCHANGED))
 	    || peer_af_flag_check(peer, afi, safi, PEER_FLAG_MED_UNCHANGED)) {
 
 		if (!peer_group_active(peer)
@@ -7468,7 +7346,7 @@ static void bgp_config_write_family(stru
 }
 
 /* clang-format off */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180517
+#if CONFDATE > 20190517
 CPP_NOTICE("bgpd: remove 'bgp enforce-first-as' config migration from bgp_config_write")
 #endif
 /* clang-format on */
@@ -7580,10 +7458,6 @@ int bgp_config_write(struct vty *vty)
 			vty_out(vty, " bgp default subgroup-pkt-queue-max %u\n",
 				bgp->default_subgroup_pkt_queue_max);
 
-		/* BGP default autoshutdown neighbors */
-		if (bgp->autoshutdown)
-			vty_out(vty, " bgp default shutdown\n");
-
 		/* BGP client-to-client reflection. */
 		if (bgp_flag_check(bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT))
 			vty_out(vty, " no bgp client-to-client reflection\n");
@@ -7737,6 +7611,16 @@ int bgp_config_write(struct vty *vty)
 		/* listen range and limit for dynamic BGP neighbors */
 		bgp_config_write_listen(vty, bgp);
 
+		/*
+		 * BGP default autoshutdown neighbors
+		 *
+		 * This must be placed after any peer and peer-group
+		 * configuration, to avoid setting all peers to shutdown after
+		 * a daemon restart, which is undesired behavior. (see #2286)
+		 */
+		if (bgp->autoshutdown)
+			vty_out(vty, " bgp default shutdown\n");
+
 		/* No auto-summary */
 		if (bgp_option_check(BGP_OPT_CONFIG_CISCO))
 			vty_out(vty, " no auto-summary\n");
@@ -7804,6 +7688,7 @@ void bgp_master_init(struct thread_maste
 	bm->start_time = bgp_clock();
 	bm->t_rmap_update = NULL;
 	bm->rmap_update_timer = RMAP_DEFAULT_UPDATE_TIMER;
+	bm->terminating = false;
 
 	bgp_process_queue_init();
 
@@ -7844,8 +7729,6 @@ static void bgp_if_finish(struct bgp *bg
 	}
 }
 
-extern void bgp_snmp_init(void);
-
 static void bgp_viewvrf_autocomplete(vector comps, struct cmd_token *token)
 {
 	struct vrf *vrf = NULL;
@@ -7907,7 +7790,7 @@ void bgp_pthreads_finish()
 	frr_pthread_finish();
 }
 
-void bgp_init(unsigned short instance)
+void bgp_init(void)
 {
 
 	/* allocates some vital data structures used by peer commands in
@@ -7917,7 +7800,7 @@ void bgp_init(unsigned short instance)
 	bgp_pthreads_init();
 
 	/* Init zebra. */
-	bgp_zebra_init(bm->master, instance);
+	bgp_zebra_init(bm->master);
 
 #if ENABLE_BGP_VNC
 	vnc_zebra_init(bm->master);
diff -urpN frr-frr-5.0.1/bgpd/bgpd.h frr-frr-6.0/bgpd/bgpd.h
--- frr-frr-5.0.1/bgpd/bgpd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/bgpd.h	2018-10-08 14:32:57.000000000 +0200
@@ -145,6 +145,7 @@ struct bgp_master {
 	/* dynamic mpls label allocation pool */
 	struct labelpool labelpool;
 
+	bool terminating;	/* global flag that sigint terminate seen */
 	QOBJ_FIELDS
 };
 DECLARE_QOBJ_TYPE(bgp_master)
@@ -481,6 +482,9 @@ struct bgp {
 	/* EVPN enable - advertise local VNIs and their MACs etc. */
 	int advertise_all_vni;
 
+	/* EVPN - use RFC 8365 to auto-derive RT */
+	int advertise_autort_rfc8365;
+
 	/* Hash table of Import RTs to EVIs */
 	struct hash *import_rt_hash;
 
@@ -530,6 +534,9 @@ struct bgp {
 
 	struct bgp_pbr_config *bgp_pbr_cfg;
 
+	/* local esi hash table */
+	struct hash *esihash;
+
 	QOBJ_FIELDS
 };
 DECLARE_QOBJ_TYPE(bgp)
@@ -583,13 +590,7 @@ struct bgp_nexthop {
 
 #define BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE 1
 
-/* BGP router distinguisher value.  */
-#define BGP_RD_SIZE                8
-
-struct bgp_rd {
-	uint8_t val[BGP_RD_SIZE];
-};
-
+/* Route map direction */
 #define RMAP_IN  0
 #define RMAP_OUT 1
 #define RMAP_MAX 2
@@ -1492,7 +1493,6 @@ extern struct peer_group *peer_group_loo
 							     struct prefix **);
 extern struct peer *peer_lookup_dynamic_neighbor(struct bgp *,
 						 union sockunion *);
-extern void peer_drop_dynamic_neighbor(struct peer *);
 
 /*
  * Peers are incredibly easy to memory leak
@@ -1519,7 +1519,7 @@ extern int bgp_config_write(struct vty *
 
 extern void bgp_master_init(struct thread_master *master);
 
-extern void bgp_init(unsigned short instance);
+extern void bgp_init(void);
 extern void bgp_pthreads_run(void);
 extern void bgp_pthreads_finish(void);
 extern void bgp_route_map_init(void);
@@ -1584,7 +1584,6 @@ extern int peer_afc_set(struct peer *, a
 
 extern int peer_group_bind(struct bgp *, union sockunion *, struct peer *,
 			   struct peer_group *, as_t *);
-extern int peer_group_unbind(struct bgp *, struct peer *, struct peer_group *);
 
 extern int peer_flag_set(struct peer *, uint32_t);
 extern int peer_flag_unset(struct peer *, uint32_t);
diff -urpN frr-frr-5.0.1/bgpd/rfapi/bgp_rfapi_cfg.c frr-frr-6.0/bgpd/rfapi/bgp_rfapi_cfg.c
--- frr-frr-5.0.1/bgpd/rfapi/bgp_rfapi_cfg.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/bgp_rfapi_cfg.c	2018-10-08 14:32:57.000000000 +0200
@@ -662,7 +662,8 @@ static int rfapi_str2route_type(const ch
 			vnc_import_bgp_exterior_redist_enable((bgp), (afi));   \
 			break;                                                 \
 		default:                                                       \
-			vnc_redistribute_set((bgp), (afi), (type));            \
+			if ((type) < ZEBRA_ROUTE_MAX)			       \
+				vnc_redistribute_set((bgp), (afi), (type));    \
 			break;                                                 \
 		}                                                              \
 	} while (0)
@@ -677,7 +678,8 @@ static int rfapi_str2route_type(const ch
 			vnc_import_bgp_exterior_redist_disable((bgp), (afi));  \
 			break;                                                 \
 		default:                                                       \
-			vnc_redistribute_unset((bgp), (afi), (type));          \
+			if ((type) < ZEBRA_ROUTE_MAX)			       \
+				vnc_redistribute_unset((bgp), (afi), (type));  \
 			break;                                                 \
 		}                                                              \
 	} while (0)
@@ -1389,43 +1391,6 @@ DEFUN (vnc_export_mode,
 		vty_out(vty,
 			"Changing modes for zebra export not implemented yet\n");
 		return CMD_WARNING_CONFIG_FAILED;
-
-		oldmode = bgp->rfapi_cfg->flags
-			  & BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_BITS;
-		bgp->rfapi_cfg->flags &= ~BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_BITS;
-		switch (argv[4]->arg[0]) {
-		case 'g':
-			if (oldmode == BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_RH) {
-				/* TBD */
-			}
-			bgp->rfapi_cfg->flags |=
-				BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_GRP;
-			if (oldmode != BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_GRP) {
-				/* TBD */
-			}
-			break;
-		case 'n':
-			if (oldmode == BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_RH) {
-				/* TBD */
-			}
-			if (oldmode == BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_GRP) {
-				/* TBD */
-			}
-			break;
-		case 'r':
-			if (oldmode == BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_GRP) {
-				/* TBD */
-			}
-			bgp->rfapi_cfg->flags |=
-				BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_RH;
-			if (oldmode != BGP_VNC_CONFIG_EXPORT_ZEBRA_MODE_RH) {
-				/* TBD */
-			}
-			break;
-		default:
-			vty_out(vty, "Invalid mode\n");
-			return CMD_WARNING_CONFIG_FAILED;
-		}
 	}
 
 	return CMD_SUCCESS;
@@ -1461,7 +1426,8 @@ DEFUN (vnc_export_nvegroup,
 	if (rfg_new == NULL) {
 		rfg_new = bgp_rfapi_cfg_match_byname(bgp, argv[5]->arg,
 						     RFAPI_GROUP_CFG_VRF);
-		vnc_add_vrf_opener(bgp, rfg_new);
+		if (rfg_new)
+			vnc_add_vrf_opener(bgp, rfg_new);
 	}
 
 	if (rfg_new == NULL) {
@@ -4553,7 +4519,7 @@ void bgp_rfapi_show_summary(struct bgp *
 	if (VNC_EXPORT_ZEBRA_GRP_ENABLED(hc)) {
 		redist++;
 		vty_out(vty, "%sToZebra Groups={", (redist == 1 ? "" : " "));
-		if (hc->rfg_export_direct_bgp_l) {
+		if (hc->rfg_export_zebra_l) {
 			int cnt = 0;
 			struct listnode *node, *nnode;
 			struct rfapi_rfg_name *rfgn;
diff -urpN frr-frr-5.0.1/bgpd/rfapi/rfapi.c frr-frr-6.0/bgpd/rfapi/rfapi.c
--- frr-frr-5.0.1/bgpd/rfapi/rfapi.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/rfapi.c	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #include "lib/command.h"
 #include "lib/stream.h"
 #include "lib/ringbuf.h"
+#include "lib/lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -2336,7 +2337,7 @@ int rfapi_reopen(struct rfapi_descriptor
 
 		h = bgp->rfapi;
 
-		assert(!CHECK_FLAG(h->flags, RFAPI_INCALLBACK));
+		assert(h != NULL && !CHECK_FLAG(h->flags, RFAPI_INCALLBACK));
 
 		if (CHECK_FLAG(rfd->flags,
 			       RFAPI_HD_FLAG_CLOSING_ADMINISTRATIVELY)
@@ -3197,8 +3198,8 @@ DEFUN (debug_rfapi_register_vn_un_l2o,
 	memset(optary, 0, sizeof(optary));
 	optary[opt_next].v.l2addr.logical_net_id =
 		strtoul(argv[14]->arg, NULL, 10);
-	if ((rc = rfapiStr2EthAddr(argv[12]->arg,
-				   &optary[opt_next].v.l2addr.macaddr))) {
+	if (rfapiStr2EthAddr(argv[12]->arg,
+			     &optary[opt_next].v.l2addr.macaddr)) {
 		vty_out(vty, "Bad mac address \"%s\"\n", argv[12]->arg);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
@@ -3368,13 +3369,7 @@ DEFUN (debug_rfapi_query_vn_un_l2o,
 {
 	struct rfapi_ip_addr vn;
 	struct rfapi_ip_addr un;
-	struct rfapi_ip_addr target;
-	rfapi_handle handle;
 	int rc;
-	struct rfapi_next_hop_entry *pNextHopEntry;
-	struct rfapi_l2address_option l2o_buf;
-	struct bgp_tea_options hopt;
-	uint8_t valbuf[14];
 
 	/*
 	 * Get VN addr
@@ -3389,69 +3384,8 @@ DEFUN (debug_rfapi_query_vn_un_l2o,
 	if ((rc = rfapiCliGetRfapiIpAddr(vty, argv[6]->arg, &un)))
 		return rc;
 
-
-#if 0 /* there is no IP target arg here ?????? */
-  /*
-   * Get target addr
-   */
-  if ((rc = rfapiCliGetRfapiIpAddr (vty, argv[2], &target)))
-    return rc;
-#else
 	vty_out(vty, "%% This command is broken.\n");
 	return CMD_WARNING_CONFIG_FAILED;
-#endif
-
-	if (rfapi_find_handle_vty(vty, &vn, &un, &handle)) {
-		vty_out(vty, "can't locate handle matching vn=%s, un=%s\n",
-			argv[4]->arg, argv[6]->arg);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	/*
-	 * Set up L2 parameters
-	 */
-	memset(&l2o_buf, 0, sizeof(l2o_buf));
-	if (rfapiStr2EthAddr(argv[10]->arg, &l2o_buf.macaddr)) {
-		vty_out(vty, "Bad mac address \"%s\"\n", argv[10]->arg);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	l2o_buf.logical_net_id = strtoul(argv[8]->arg, NULL, 10);
-
-	/* construct option chain */
-
-	memset(valbuf, 0, sizeof(valbuf));
-	memcpy(valbuf, &l2o_buf.macaddr.octet, ETH_ALEN);
-	valbuf[11] = (l2o_buf.logical_net_id >> 16) & 0xff;
-	valbuf[12] = (l2o_buf.logical_net_id >> 8) & 0xff;
-	valbuf[13] = l2o_buf.logical_net_id & 0xff;
-
-	memset(&hopt, 0, sizeof(hopt));
-	hopt.options_count = 1;
-	hopt.options_length = sizeof(valbuf); /* is this right? */
-	hopt.type = RFAPI_VN_OPTION_TYPE_L2ADDR;
-	hopt.length = sizeof(valbuf);
-	hopt.value = valbuf;
-
-
-	/*
-	 * options parameter not used? Set to NULL for now
-	 */
-	rc = rfapi_query(handle, &target, &l2o_buf, &pNextHopEntry);
-
-	if (rc) {
-		vty_out(vty, "rfapi_query failed with rc=%d (%s)\n", rc,
-			strerror(rc));
-	} else {
-		/*
-		 * print nexthop list
-		 */
-		/* TBD enhance to print L2 information */
-		test_nexthops_callback(/*&target, */ pNextHopEntry,
-				       vty); /* frees nh list! */
-	}
-
-	return CMD_SUCCESS;
 }
 
 
@@ -4000,7 +3934,8 @@ void *rfapi_rfp_init_group_config_ptr_vt
 							    size);
 		break;
 	default:
-		zlog_err("%s: Unknown group type=%d", __func__, type);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: Unknown group type=%d",
+			  __func__, type);
 		/* should never happen */
 		assert("Unknown type" == NULL);
 		break;
@@ -4114,7 +4049,8 @@ void *rfapi_rfp_get_group_config_ptr_nam
 							 criteria, search_cb);
 		break;
 	default:
-		zlog_err("%s: Unknown group type=%d", __func__, type);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: Unknown group type=%d",
+			  __func__, type);
 		/* should never happen */
 		assert("Unknown type" == NULL);
 		break;
diff -urpN frr-frr-5.0.1/bgpd/rfapi/rfapi_import.c frr-frr-6.0/bgpd/rfapi/rfapi_import.c
--- frr-frr-5.0.1/bgpd/rfapi/rfapi_import.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/rfapi_import.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "lib/skiplist.h"
 #include "lib/thread.h"
 #include "lib/stream.h"
+#include "lib/lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -3028,7 +3029,7 @@ static void rfapiBgpInfoFilteredImportEn
 		break;
 
 	default:
-		zlog_err("%s: bad afi %d", __func__, afi);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d", __func__, afi);
 		return;
 	}
 
@@ -3485,7 +3486,7 @@ void rfapiBgpInfoFilteredImportVPN(
 		break;
 
 	default:
-		zlog_err("%s: bad afi %d", __func__, afi);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d", __func__, afi);
 		return;
 	}
 
@@ -3890,7 +3891,8 @@ rfapiBgpInfoFilteredImportFunction(safi_
 
 	default:
 		/* not expected */
-		zlog_err("%s: bad safi %d", __func__, safi);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad safi %d", __func__,
+			  safi);
 		return rfapiBgpInfoFilteredImportBadSafi;
 	}
 }
diff -urpN frr-frr-5.0.1/bgpd/rfapi/rfapi_rib.c frr-frr-6.0/bgpd/rfapi/rfapi_rib.c
--- frr-frr-5.0.1/bgpd/rfapi/rfapi_rib.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/rfapi_rib.c	2018-10-08 14:32:57.000000000 +0200
@@ -2099,7 +2099,6 @@ rfapiRibPreload(struct bgp *bgp, struct
 			nhp->vn_options = NULL;
 
 			XFREE(MTYPE_RFAPI_NEXTHOP, nhp);
-			nhp = NULL;
 		}
 	}
 
diff -urpN frr-frr-5.0.1/bgpd/rfapi/rfapi_vty.c frr-frr-6.0/bgpd/rfapi/rfapi_vty.c
--- frr-frr-5.0.1/bgpd/rfapi/rfapi_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/rfapi_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -388,15 +388,11 @@ int rfapiStream2Vty(void *stream,			   /
 		return 1;
 	}
 
-	if (stream) {
-		*vty = stream; /* VTYNL requires vty to be legit */
-		*fp = (int (*)(void *, const char *, ...))vty_out;
-		*outstream = stream;
-		*vty_newline = str_vty_newline(*vty);
-		return 1;
-	}
-
-	return 0;
+	*vty = stream; /* VTYNL requires vty to be legit */
+	*fp = (int (*)(void *, const char *, ...))vty_out;
+	*outstream = stream;
+	*vty_newline = str_vty_newline(*vty);
+	return 1;
 }
 
 /* called from bgpd/bgp_vty.c'route_vty_out() */
@@ -1733,7 +1729,8 @@ void rfapiPrintMatchingDescriptors(struc
 int rfapiCliGetPrefixAddr(struct vty *vty, const char *str, struct prefix *p)
 {
 	if (!str2prefix(str, p)) {
-		vty_out(vty, "Malformed address \"%s\"%s", str, HVTYNL);
+		vty_out(vty, "Malformed address \"%s\"%s", str ? str : "null",
+			HVTYNL);
 		return CMD_WARNING;
 	}
 	switch (p->family) {
@@ -3020,9 +3017,9 @@ static int rfapiDeleteLocalPrefixesByRFD
 		 * match un, vn addresses of NVEs
 		 */
 		if (pUn && (rfapi_ip_addr_cmp(pUn, &rfd->un_addr)))
-			continue;
+			break;
 		if (pVn && (rfapi_ip_addr_cmp(pVn, &rfd->vn_addr)))
-			continue;
+			break;
 
 #if DEBUG_L2_EXTRA
 		vnc_zlog_debug_verbose("%s: un, vn match", __func__);
diff -urpN frr-frr-5.0.1/bgpd/rfapi/vnc_export_bgp.c frr-frr-6.0/bgpd/rfapi/vnc_export_bgp.c
--- frr-frr-5.0.1/bgpd/rfapi/vnc_export_bgp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/vnc_export_bgp.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@
 #include "lib/linklist.h"
 #include "lib/plist.h"
 #include "lib/routemap.h"
+#include "lib/lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -187,7 +188,8 @@ void vnc_direct_bgp_add_route_ce(struct
 
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of route node", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: can't get afi of route node", __func__);
 		return;
 	}
 
@@ -333,7 +335,7 @@ void vnc_direct_bgp_del_route_ce(struct
 	struct prefix ce_nexthop;
 
 	if (!afi) {
-		zlog_err("%s: bad afi", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi", __func__);
 		return;
 	}
 
@@ -402,7 +404,6 @@ void vnc_direct_bgp_del_route_ce(struct
 
 static void vnc_direct_bgp_vpn_enable_ce(struct bgp *bgp, afi_t afi)
 {
-	struct rfapi_cfg *hc;
 	struct route_node *rn;
 	struct bgp_info *ri;
 
@@ -411,7 +412,7 @@ static void vnc_direct_bgp_vpn_enable_ce
 	if (!bgp)
 		return;
 
-	if (!(hc = bgp->rfapi_cfg))
+	if (!(bgp->rfapi_cfg))
 		return;
 
 	if (!VNC_EXPORT_BGP_CE_ENABLED(bgp->rfapi_cfg)) {
@@ -699,7 +700,8 @@ void vnc_direct_bgp_add_prefix(struct bg
 	afi_t afi = family2afi(rn->p.family);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of route node", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: can't get afi of route node", __func__);
 		return;
 	}
 
@@ -808,7 +810,8 @@ void vnc_direct_bgp_del_prefix(struct bg
 	afi_t afi = family2afi(rn->p.family);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi route node", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi route node",
+			  __func__);
 		return;
 	}
 
@@ -923,7 +926,8 @@ void vnc_direct_bgp_add_nve(struct bgp *
 	afi_t afi = family2afi(rfd->vn_addr.addr_family);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of nve vn addr", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: can't get afi of nve vn addr", __func__);
 		return;
 	}
 
@@ -975,7 +979,8 @@ void vnc_direct_bgp_add_nve(struct bgp *
 			if (afi == AFI_IP || afi == AFI_IP6) {
 				rt = import_table->imported_vpn[afi];
 			} else {
-				zlog_err("%s: bad afi %d", __func__, afi);
+				flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d",
+					  __func__, afi);
 				return;
 			}
 
@@ -1067,7 +1072,8 @@ void vnc_direct_bgp_del_nve(struct bgp *
 	afi_t afi = family2afi(rfd->vn_addr.addr_family);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of nve vn addr", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: can't get afi of nve vn addr", __func__);
 		return;
 	}
 
@@ -1114,7 +1120,8 @@ void vnc_direct_bgp_del_nve(struct bgp *
 			if (afi == AFI_IP || afi == AFI_IP6) {
 				rt = import_table->imported_vpn[afi];
 			} else {
-				zlog_err("%s: bad afi %d", __func__, afi);
+				flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d",
+					  __func__, afi);
 				return;
 			}
 
@@ -1289,7 +1296,7 @@ static void vnc_direct_bgp_add_group_afi
 	if (afi == AFI_IP || afi == AFI_IP6) {
 		rt = import_table->imported_vpn[afi];
 	} else {
-		zlog_err("%s: bad afi %d", __func__, afi);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d", __func__, afi);
 		return;
 	}
 
@@ -1633,7 +1640,8 @@ void vnc_direct_bgp_rh_add_route(struct
 	struct attr *iattr;
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of route node", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: can't get afi of route node", __func__);
 		return;
 	}
 
@@ -1752,7 +1760,8 @@ void vnc_direct_bgp_rh_del_route(struct
 	struct vnc_export_info *eti;
 
 	if (!afi) {
-		zlog_err("%s: can't get afi route node", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi route node",
+			  __func__);
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/bgpd/rfapi/vnc_import_bgp.c frr-frr-6.0/bgpd/rfapi/vnc_import_bgp.c
--- frr-frr-5.0.1/bgpd/rfapi/vnc_import_bgp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/vnc_import_bgp.c	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #include "lib/linklist.h"
 #include "lib/plist.h"
 #include "lib/routemap.h"
+#include "lib/lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -557,7 +558,6 @@ static void vnc_import_bgp_add_route_mod
 	struct bgp_info *info)			/* unicast info */
 {
 	afi_t afi = family2afi(prefix->family);
-	struct rfapi_cfg *hc = NULL;
 
 	struct prefix pfx_unicast_nexthop = {0}; /* happy valgrind */
 
@@ -603,11 +603,12 @@ static void vnc_import_bgp_add_route_mod
 	 */
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of prefix", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi of prefix",
+			  __func__);
 		return;
 	}
 
-	if (!(hc = bgp->rfapi_cfg)) {
+	if (!(bgp->rfapi_cfg)) {
 		vnc_zlog_debug_verbose("%s: bgp->rfapi_cfg is NULL, skipping",
 				       __func__);
 		return;
@@ -698,7 +699,7 @@ static void vnc_import_bgp_add_route_mod
 	struct peer *peer = info->peer;
 	struct attr *attr = info->attr;
 	struct attr hattr;
-	struct rfapi_cfg *hc = NULL;
+	struct rfapi_cfg *hc = bgp->rfapi_cfg;
 	struct attr *iattr = NULL;
 
 	struct rfapi_ip_addr vnaddr;
@@ -719,11 +720,12 @@ static void vnc_import_bgp_add_route_mod
 	}
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of prefix", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi of prefix",
+			  __func__);
 		return;
 	}
 
-	if (!(hc = bgp->rfapi_cfg)) {
+	if (!hc) {
 		vnc_zlog_debug_verbose("%s: bgp->rfapi_cfg is NULL, skipping",
 				       __func__);
 		return;
@@ -886,7 +888,6 @@ vnc_import_bgp_add_route_mode_nvegroup(s
 	struct peer *peer = info->peer;
 	struct attr *attr = info->attr;
 	struct attr hattr;
-	struct rfapi_cfg *hc = NULL;
 	struct attr *iattr = NULL;
 
 	struct rfapi_ip_addr vnaddr;
@@ -907,11 +908,12 @@ vnc_import_bgp_add_route_mode_nvegroup(s
 	assert(rfg);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of prefix", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi of prefix",
+			  __func__);
 		return;
 	}
 
-	if (!(hc = bgp->rfapi_cfg)) {
+	if (!(bgp->rfapi_cfg)) {
 		vnc_zlog_debug_verbose("%s: bgp->rfapi_cfg is NULL, skipping",
 				       __func__);
 		return;
@@ -2630,7 +2632,8 @@ void vnc_import_bgp_add_route(struct bgp
 	VNC_RHNCK(enter);
 
 	if (!afi) {
-		zlog_err("%s: can't get afi of prefix", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: can't get afi of prefix",
+			  __func__);
 		return;
 	}
 
@@ -2904,6 +2907,8 @@ void vnc_import_bgp_redist_disable(struc
 						struct rfapi_descriptor *rfd;
 						vncHDBgpDirect.peer = bi->peer;
 
+						assert(bi->extra);
+
 						rfd = bi->extra->vnc.export
 							      .rfapi_handle;
 
diff -urpN frr-frr-5.0.1/bgpd/rfapi/vnc_zebra.c frr-frr-6.0/bgpd/rfapi/vnc_zebra.c
--- frr-frr-5.0.1/bgpd/rfapi/vnc_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/bgpd/rfapi/vnc_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #include "lib/stream.h"
 #include "lib/ringbuf.h"
 #include "lib/memory.h"
+#include "lib/lib_errors.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_ecommunity.h"
@@ -570,7 +571,8 @@ static void vnc_zebra_add_del_prefix(str
 		return;
 
 	if (rn->p.family != AF_INET && rn->p.family != AF_INET6) {
-		zlog_err("%s: invalid route node addr family", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: invalid route node addr family", __func__);
 		return;
 	}
 
@@ -642,7 +644,8 @@ static void vnc_zebra_add_del_nve(struct
 		return;
 
 	if (afi != AFI_IP && afi != AFI_IP6) {
-		zlog_err("%s: invalid vn addr family", __func__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: invalid vn addr family",
+			  __func__);
 		return;
 	}
 
@@ -739,12 +742,13 @@ static void vnc_zebra_add_del_group_afi(
 	if (afi == AFI_IP || afi == AFI_IP6) {
 		rt = import_table->imported_vpn[afi];
 	} else {
-		zlog_err("%s: bad afi %d", __func__, afi);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: bad afi %d", __func__, afi);
 		return;
 	}
 
 	if (!family) {
-		zlog_err("%s: computed bad family: %d", __func__, family);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: computed bad family: %d",
+			  __func__, family);
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/common.am frr-frr-6.0/common.am
--- frr-frr-5.0.1/common.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/common.am	2018-10-08 14:32:57.000000000 +0200
@@ -1,20 +1,21 @@
 #
 # Automake fragment intended to be shared by Makefile.am files in the
-# tree.
+# tree. When used, should be included at the very top of the file.
 #
+AM_CPPFLAGS = @ASAN_FLAGS@ @TSAN_FLAGS@ @MSAN_FLAGS@ @WERROR@
+AM_CFLAGS = @ASAN_FLAGS@ @TSAN_FLAGS@ @MSAN_FLAGS@ @WERROR@
 
 AM_V_CLIPPY = $(am__v_CLIPPY_$(V))
 am__v_CLIPPY_ = $(am__v_CLIPPY_$(AM_DEFAULT_VERBOSITY))
 am__v_CLIPPY_0 = @echo "  CLIPPY  " $@;
 am__v_CLIPPY_1 =
 
-CLIPPY_SUPPRESSIONS = LSAN_OPTIONS="suppressions=$(top_builddir)/tools/lsan-suppressions.txt"
 CLIPPY_DEPS = $(HOSTTOOLS)lib/clippy $(top_srcdir)/python/clidef.py
 
 SUFFIXES = _clippy.c .proto .pb-c.c .pb-c.h .pb.h
 .c_clippy.c:
 	@{ test -x $(top_builddir)/$(HOSTTOOLS)lib/clippy || $(MAKE) -C $(top_builddir)/$(HOSTTOOLS) lib/clippy; }
-	$(AM_V_CLIPPY) $(CLIPPY_SUPPRESSIONS) $(top_builddir)/$(HOSTTOOLS)lib/clippy $(top_srcdir)/python/clidef.py -o $@ $<
+	$(AM_V_CLIPPY) $(top_builddir)/$(HOSTTOOLS)lib/clippy $(top_srcdir)/python/clidef.py -o $@ $<
 
 ## automake's "ylwrap" is a great piece of GNU software... not. 
 .l.c:
diff -urpN frr-frr-5.0.1/configure.ac frr-frr-6.0/configure.ac
--- frr-frr-5.0.1/configure.ac	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/configure.ac	2018-10-08 14:32:57.000000000 +0200
@@ -7,7 +7,7 @@
 ##
 AC_PREREQ(2.60)
 
-AC_INIT(frr, 5.0.1, [https://github.com/frrouting/frr/issues])
+AC_INIT(frr, 6.0, [https://github.com/frrouting/frr/issues])
 PACKAGE_URL="https://frrouting.org/"
 AC_SUBST(PACKAGE_URL)
 PACKAGE_FULLNAME="FRRouting"
@@ -190,8 +190,11 @@ AC_ARG_ENABLE([address-sanitizer], AS_HE
               [enabled AddressSanitizer support for detecting a wide variety of \
                memory allocation and deallocation errors]), \
               [AC_DEFINE(HAVE_ADDRESS_SANITIZER, 1, [enable AddressSanitizer])
-              CFLAGS="$CFLAGS -fsanitize=address"
-              CXXFLAGS="$CXXFLAGS -fsanitize=address"
+              ASAN_FLAGS="-fsanitize=address"
+              SAN_CLIPPY_FLAGS="-fno-sanitize=all"
+              AC_SUBST([ASAN_FLAGS])
+              AC_SUBST([SAN_CLIPPY_FLAGS])
+              LIBS="-ldl $LIBS"
               AC_TRY_COMPILE([],[const int i=0;],[AC_MSG_NOTICE([Address Sanitizer Enabled])],
                                                  [AC_MSG_ERROR([Address Sanitizer not available])])
               ])
@@ -200,8 +203,11 @@ dnl ThreadSanitizer support
 AC_ARG_ENABLE([thread-sanitizer], AS_HELP_STRING([--enable-thread-sanitizer], \
               [enabled ThreadSanitizer support for detecting data races]), \
               [AC_DEFINE(HAVE_THREAD_SANITIZER, 1, [enable ThreadSanitizer])
-              CFLAGS="$CFLAGS -fsanitize=thread"
-              CXXFLAGS="$CXXFLAGS -fsanitize=thread"
+              TSAN_FLAGS="-fsanitize=thread"
+              SAN_CLIPPY_FLAGS="-fno-sanitize=all"
+              AC_SUBST([TSAN_FLAGS])
+              AC_SUBST([SAN_CLIPPY_FLAGS])
+              LIBS="-ldl $LIBS"
               AC_TRY_COMPILE([],[const int i=0;],[AC_MSG_NOTICE([Thread Sanitizer Enabled])],
                                                  [AC_MSG_ERROR([Thread Sanitizer not available])])
               ])
@@ -210,14 +216,24 @@ dnl MemorySanitizer support
 AC_ARG_ENABLE([memory-sanitizer], AS_HELP_STRING([--enable-memory-sanitizer], \
               [enabled MemorySanitizer support for detecting uninitialized memory reads]), \
               [AC_DEFINE(HAVE_THREAD_SANITIZER, 1, [enable MemorySanitizer])
-              CFLAGS="$CFLAGS -fsanitize=memory -fPIE -pie"
-              CXXFLAGS="$CXXFLAGS -fsanitize=memory -fPIE -pie"
+              MSAN_FLAGS="-fsanitize=memory -fPIE -pie"
+              SAN_CLIPPY_FLAGS="-fno-sanitize=all"
+              AC_SUBST([MSAN_FLAGS])
+              AC_SUBST([SAN_CLIPPY_FLAGS])
+              LIBS="-ldl $LIBS"
               AC_TRY_COMPILE([],[const int i=0;],[AC_MSG_NOTICE([Memory Sanitizer Enabled])],
                                                  [AC_MSG_ERROR([Memory Sanitizer not available])])
               ])
 
 dnl if the user has specified any CFLAGS, override our settings
-if test "x${enable_dev_build}" = "xyes"; then
+if test "x${enable_gcov}" = "xyes"; then
+   if test "z$orig_cflags" = "z"; then
+      AC_C_FLAG([-coverage])
+      AC_C_FLAG([-O0])
+   fi
+
+   LDFLAGS="${LDFLAGS} -lgcov"
+elif test "x${enable_dev_build}" = "xyes"; then
    AC_DEFINE(DEV_BUILD,,Build for development)
    if test "z$orig_cflags" = "z"; then
       AC_C_FLAG([-g3])
@@ -340,7 +356,7 @@ AC_ARG_ENABLE(ospfd,
 AC_ARG_ENABLE(ospf6d,
   AS_HELP_STRING([--disable-ospf6d], [do not build ospf6d]))
 AC_ARG_ENABLE(ldpd,
-  AS_HELP_STRING([--enable-ldpd], [build ldpd]))
+  AS_HELP_STRING([--disable-ldpd], [do not build ldpd]))
 AC_ARG_ENABLE(nhrpd,
   AS_HELP_STRING([--disable-nhrpd], [do not build nhrpd]))
 AC_ARG_ENABLE(eigrpd,
@@ -356,7 +372,9 @@ AC_ARG_ENABLE(pimd,
 AC_ARG_ENABLE(pbrd,
   AS_HELP_STRING([--disable-pbrd], [do not build pbrd]))
 AC_ARG_ENABLE(sharpd,
-  AS_HELP_STRING([--enable-sharpd], [do not build sharpd]))
+  AS_HELP_STRING([--enable-sharpd], [build sharpd]))
+AC_ARG_ENABLE(staticd,
+  AS_HELP_STRING([--disable-staticd], [do not build staticd]))
 AC_ARG_ENABLE(bgp-announce,
   AS_HELP_STRING([--disable-bgp-announce,], [turn off BGP route announcement]))
 AC_ARG_ENABLE(bgp-vnc,
@@ -364,7 +382,7 @@ AC_ARG_ENABLE(bgp-vnc,
 AC_ARG_WITH(rfp-path,
   AS_HELP_STRING([--with-rfp-path[=DIR]],[path to replaced stub RFP used with BGP VNC]))
 AC_ARG_ENABLE(snmp,
-  AS_HELP_STRING([--enable-snmp=ARG], [enable SNMP support (smux or agentx)]))
+  AS_HELP_STRING([--enable-snmp], [enable SNMP support for agentx]))
 AC_ARG_ENABLE(zeromq,
   AS_HELP_STRING([--enable-zeromq], [enable ZeroMQ handler (libfrrzmq)]))
 AC_ARG_WITH(libpam,
@@ -400,8 +418,6 @@ AC_ARG_ENABLE(rusage,
   AS_HELP_STRING([--disable-rusage], [disable using getrusage]))
 AC_ARG_ENABLE(gcc_ultra_verbose,
   AS_HELP_STRING([--enable-gcc-ultra-verbose], [enable ultra verbose GCC warnings]))
-AC_ARG_ENABLE(linux24_tcp_md5,
-  AS_HELP_STRING([--enable-linux24-tcp-md5], [enable support for old, Linux-2.4 RFC2385 patch]))
 AC_ARG_ENABLE(backtrace,
   AS_HELP_STRING([--disable-backtrace,], [disable crash backtraces (default autodetect)]))
 AC_ARG_ENABLE(time-check,
@@ -420,6 +436,8 @@ AC_ARG_ENABLE(datacenter,
   AS_HELP_STRING([--enable-datacenter], [enable Compilation for Data Center Extensions]))
 AC_ARG_ENABLE(fuzzing,
   AS_HELP_STRING([--enable-fuzzing], [enable ability to fuzz various parts of FRR]))
+AC_ARG_ENABLE(netlink_fuzzing,
+  AS_HELP_STRING([--enable-netlink-fuzzing], [enable ability to fuzz netlink listening socket in zebra]))
 AC_ARG_ENABLE(rr-semantics,
   AS_HELP_STRING([--disable-rr-semantics], [disable the v6 Route Replace semantics]))
 AC_ARG_ENABLE([protobuf],
@@ -432,6 +450,10 @@ AC_ARG_ENABLE([clippy-only],
   AS_HELP_STRING([--enable-clippy-only], [Only build clippy]))
 AC_ARG_ENABLE([numeric_version],
   AS_HELP_STRING([--enable-numeric-version], [Only numeric digits allowed in version (for Alpine)]))
+AC_ARG_ENABLE([gcov],
+  AS_HELP_STRING([--enable-gcov], [Add code coverage information]))
+AC_ARG_ENABLE(bfdd,
+  AS_HELP_STRING([--disable-bfdd], [do not build bfdd]))
 
 AS_IF([test "${enable_clippy_only}" != "yes"], [
 AC_CHECK_HEADERS(json-c/json.h)
@@ -483,6 +505,10 @@ if test "${enable_fuzzing}" = "yes" ; th
   AC_DEFINE(HANDLE_ZAPI_FUZZING,,Compile extensions to use with a fuzzer)
 fi
 
+if test "${enable_netlink_fuzzing}" = "yes" ; then
+  AC_DEFINE(HANDLE_NETLINK_FUZZING,,Compile extensions to use with a fuzzer for netlink)
+fi
+
 if test "${enable_cumulus}" = "yes" ; then
   AC_DEFINE(HAVE_CUMULUS,,Compile Special Cumulus Code in)
 fi
@@ -616,10 +642,6 @@ AM_CONDITIONAL([HAVE_PROTOBUF], [test "x
 # End of logic for protobuf support.
 #
 
-if test "${enable_linux24_tcp_md5}" = "yes"; then
-  AC_DEFINE(HAVE_TCP_MD5_LINUX24,,Old Linux 2.4 TCP MD5 Signature Patch)
-fi
-
 AC_MSG_CHECKING(if zebra should be configurable to send Route Advertisements)
 if test "${enable_rtadv}" != "no"; then
   AC_MSG_RESULT(yes)
@@ -683,6 +705,11 @@ AC_DEFINE_UNQUOTED(MULTIPATH_NUM, $MPATH
 
 AC_DEFINE_UNQUOTED(VTYSH_PAGER, "$VTYSH_PAGER", [What pager to use])
 
+dnl --------------------
+dnl Enable code coverage
+dnl --------------------
+AM_CONDITIONAL([HAVE_GCOV],[test '!' "$enable_gcov" = no])
+
 dnl ------------------------------------
 dnl Alpine only accepts numeric versions
 dnl ------------------------------------
@@ -917,8 +944,6 @@ case "$host_os" in
     dnl how to fix it but no real progress on implementation
     dnl when they fix it, remove this
     AC_DEFINE(IPV6_MINHOPCOUNT, 73, Linux ipv6 Min Hop Count)
-
-    AC_CHECK_DECLS([IFLA_INFO_SLAVE_KIND], [], [], [#include <linux/if_link.h>])
     ;;
   openbsd*)
     AC_MSG_RESULT([OpenBSD])
@@ -1163,33 +1188,6 @@ case "$host_os" in
 esac
 AC_DEFINE_UNQUOTED(ISIS_METHOD, $ISIS_METHOD_MACRO, [ selected method for isis, == one of the constants ])
 
-dnl ------------------------------------
-dnl check for broken CMSG_FIRSTHDR macro
-dnl ------------------------------------
-AC_MSG_CHECKING(for broken CMSG_FIRSTHDR)
-AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#ifdef SUNOS_5
-#define _XPG4_2
-#define __EXTENSIONS__
-#endif
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-
-main()
-{
-  struct msghdr msg;
-  char buf[4];
-
-  msg.msg_control = buf;
-  msg.msg_controllen = 0;
-
-  if (CMSG_FIRSTHDR(&msg) != NULL)
-    exit(0);
-  exit (1);
-}]])],[AC_MSG_RESULT(yes - using workaround) AC_DEFINE(HAVE_BROKEN_CMSG_FIRSTHDR,,Broken CMSG_FIRSTHDR)],
-[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
-
 dnl ---------------------------------------------------------------
 dnl figure out how to specify an interface in multicast sockets API
 dnl ---------------------------------------------------------------
@@ -1318,6 +1316,7 @@ dnl disable doc check
 if test "${enable_doc}" = "no";then
   DOC=""
 else
+  AC_CHECK_PROGS([SPHINXBUILD], [sphinx-build sphinx-build3 sphinx-build2], [no])
   DOC="doc"
 fi
 
@@ -1341,6 +1340,30 @@ AS_IF([test "${enable_ldpd}" != "no"], [
   AC_DEFINE(HAVE_LDPD, 1, ldpd)
 ])
 
+if test "$enable_bfdd" = "no"; then
+  AC_DEFINE(HAVE_BFDD, 0, bfdd)
+  BFDD=""
+else
+  AC_DEFINE(HAVE_BFDD, 1, bfdd)
+  BFDD="bfdd"
+
+  case $host_os in
+    linux*)
+      AC_DEFINE(BFD_LINUX, 1, bfdd)
+      ;;
+
+    *)
+      AC_DEFINE(BFD_BSD, 1, bfdd)
+      ;;
+  esac
+fi
+
+AM_CONDITIONAL(BFDD, [test "x$BFDD" = "xbfdd"])
+
+if test $ac_cv_lib_json_c_json_object_get = no -a "x$BFDD" = "xbfdd"; then
+  AC_MSG_ERROR(["you must use json-c library to use bfdd"])
+fi
+
 NHRPD=""
 case "$host_os" in
   linux*)
@@ -1382,6 +1405,7 @@ AM_CONDITIONAL(ISISD, test "${enable_isi
 AM_CONDITIONAL(PIMD, test "${enable_pimd}" != "no")
 AM_CONDITIONAL(PBRD, test "${enable_pbrd}" != "no")
 AM_CONDITIONAL(SHARPD, test "${enable_sharpd}" = "yes")
+AM_CONDITIONAL(STATICD, test "${enable_staticd}" != "no")
 
 if test "${enable_bgp_announce}" = "no";then
   AC_DEFINE(DISABLE_BGP_ANNOUNCE,1,Disable BGP installation to zebra)
@@ -1466,14 +1490,13 @@ int main(void);
      yes)
       SNMP_METHOD=agentx
       ;;
-     smux|agentx)
+     agentx)
       SNMP_METHOD="${enable_snmp}"
       ;;
      *)
-      AC_MSG_ERROR([--enable-snmp given with an unknown method (${enable_snmp}). Use smux or agentx])
+      AC_MSG_ERROR([--enable-snmp given with an unknown method (${enable_snmp}). Use yes or agentx])
       ;;
    esac
-   AH_TEMPLATE([SNMP_SMUX], [Use SNMP SMUX to interface with snmpd])
    AH_TEMPLATE([SNMP_AGENTX], [Use SNMP AgentX to interface with snmpd])
    AC_DEFINE_UNQUOTED(AS_TR_CPP(SNMP_${SNMP_METHOD}),,SNMP method to interface with snmpd)
 fi
@@ -1783,15 +1806,58 @@ dnl order to check no alternative alloca
 dnl has been specified, which might not provide
 dnl mallinfo, e.g. such as Umem on Solaris.
 dnl -----------------------------------------
-AC_CHECK_HEADER([malloc.h],
- [AC_MSG_CHECKING(whether mallinfo is available)
-  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],
-                        [[struct mallinfo ac_x; ac_x = mallinfo ();]])],
-      [AC_MSG_RESULT(yes)
-       AC_DEFINE(HAVE_MALLINFO,,mallinfo)],
-       AC_MSG_RESULT(no)
-  )
- ], [], FRR_INCLUDES)
+AC_CHECK_HEADERS([malloc.h malloc/malloc.h],,, [FRR_INCLUDES])
+
+AC_MSG_CHECKING(whether mallinfo is available)
+AC_LINK_IFELSE([AC_LANG_PROGRAM([FRR_INCLUDES [
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#ifdef HAVE_MALLOC_MALLOC_H
+#include <malloc/malloc.h>
+#endif
+]], [[
+struct mallinfo ac_x; ac_x = mallinfo ();
+]])], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_MALLINFO,,mallinfo)
+], [
+  AC_MSG_RESULT(no)
+])
+
+AC_MSG_CHECKING(whether malloc_usable_size is available)
+AC_LINK_IFELSE([AC_LANG_PROGRAM([FRR_INCLUDES [
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#ifdef HAVE_MALLOC_MALLOC_H
+#include <malloc/malloc.h>
+#endif
+]], [[
+size_t ac_x; ac_x = malloc_usable_size(NULL);
+]])], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_MALLOC_USABLE_SIZE,,malloc_usable_size)
+], [
+  AC_MSG_RESULT(no)
+
+  AC_MSG_CHECKING(whether malloc_size is available)
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#ifdef HAVE_MALLOC_MALLOC_H
+#include <malloc/malloc.h>
+#endif
+]], [[
+size_t ac_x; ac_x = malloc_size(NULL);
+]])], [
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(HAVE_MALLOC_SIZE,,malloc_size)
+  ], [
+    AC_MSG_RESULT(no)
+  ])
+])
 
 dnl ------
 dnl ZeroMQ
@@ -1811,7 +1877,13 @@ AM_CONDITIONAL([ZEROMQ], test "x$ZEROMQ"
 dnl ----------
 dnl configure date
 dnl ----------
-CONFDATE=`date '+%Y%m%d'`
+dev_version=`echo $VERSION | grep dev`
+#don't expire deprecated code in non 'dev' branch
+if test "${dev_version}" = ""; then
+   CONFDATE=0
+else
+   CONFDATE=`date '+%Y%m%d'`
+fi
 AC_SUBST(CONFDATE)
 
 dnl ------------------------------
@@ -1846,6 +1918,7 @@ AC_SUBST(frr_statedir)
 
 AC_DEFINE_UNQUOTED(LDPD_SOCKET, "$frr_statedir/ldpd.sock",ldpd control socket)
 AC_DEFINE_UNQUOTED(ZEBRA_SERV_PATH, "$frr_statedir/zserv.api",zebra api socket)
+AC_DEFINE_UNQUOTED(BFDD_CONTROL_SOCKET, "$frr_statedir/bfdd.sock", bfdd control socket)
 AC_DEFINE_UNQUOTED(DAEMON_VTY_DIR, "$frr_statedir",daemon vty directory)
 
 dnl autoconf does this, but it does it too late...
@@ -1996,3 +2069,8 @@ zebra protobuf enabled  : ${have_protobu
 
 The above user and group must have read/write access to the state file
 directory and to the config files in the config file directory."
+
+if test "${enable_doc}" != "no";then
+  AS_IF([test "x$SPHINXBUILD" = xno],
+     AC_MSG_WARN(sphinx-build is missing but required to build documentation))
+fi
diff -urpN frr-frr-5.0.1/debianpkg/README.deb_build.md frr-frr-6.0/debianpkg/README.deb_build.md
--- frr-frr-5.0.1/debianpkg/README.deb_build.md	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/README.deb_build.md	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-Building your own FRRouting Debian Package
-==========================================
-(Tested on Ubuntu 12.04, 14.04, 16.04, 17.10, 18.04, Debian 8 and 9)
-
-**Note:**  If you try to build for a different distro, then it will most likely
-fail because of the missing backport. See debianpkg/backports/README about
-adding a new backport.
-
-1. Follow the package installation as outlined in doc/Building_on_XXXX.md
-   (XXXX refers your OS Distribution) to install the required build packages
-
-2. Install the following additional packages:
-
-   on Ubuntu 12.04, 14.04, 16.04, 17.10, Debian 8 and 9:
-
-        apt-get install realpath equivs groff fakeroot debhelper devscripts
-
-   on Ubuntu 18.04: (realpath is now part of preinstalled by coreutils)
-
-        apt-get install equivs groff fakeroot debhelper devscripts
-
-3. Checkout FRR under a **unpriviledged** user account
-
-        git clone https://github.com/frrouting/frr.git frr
-        cd frr
-	# git checkout <branch>    - if different branch than master
-
-4. Run Bootstrap and make distribution tar.gz
-
-        ./bootstrap.sh
-        ./configure --with-pkg-extra-version=-MyDebPkgVersion
-        make dist
-            
-    Note: configure parameters are not important for the Debian Package
-    building - except the `with-pkg-extra-version` if you want to give the
-    Debian Package a specific name to mark your own unoffical build
-
-5. Edit `debianpkg/rules` and set the configuration as needed
-
-    Look for section `dh_auto_configure` to modify the configure
-    options as needed. Options might be different between main `rules` and 
-    `backports/XXXX/debian/rules`. Please adjust as needed on all files
-
-6. Create backports debian sources
- 
-    Move the `debianpkg` to `debian` and create the backports
-    (Debian requires to not ship a `debian` directory inside the source
-    directory to avoid build conflicts with the reserved `debian` subdirectory
-    name during the build)
-
-        mv debianpkg debian
-        make -f debian/rules backports
-
-    This will create a `frr_*.orig.tar.gz` with the source (same as dist tar),
-    and multiple `frr_*.debian.tar.xz` and `frr_*.dsc` for the debian package
-    source on each backport supported distribution
-
-7. Create a new directory to build the package and populate with package src
-
-        mkdir frrpkg
-        cd frrpkg
-        tar xf ~/frr/frr_*.orig.tar.gz
-        cd frr*
-        . /etc/os-release
-        tar xf ~/frr/frr_*${ID}${VERSION_ID}*.debian.tar.xz
-
-8. Build Debian Package Dependencies and install them as needed
-
-        sudo mk-build-deps --install debian/control
-
-9. Build Debian Package
-
-    Building with standard options:
-
-        debuild -b -uc -us
-
-    Or change some options:
-    (see `rules` file for available options)
-
-        debuild --set-envvar=WANT_BGP_VNC=1 --set-envvar=WANT_CUMULUS_MODE=1 -b -uc -us
-
-    To build with RPKI, download the librtr packages from
-	https://ci1.netdef.org/browse/RPKI-RTRLIB/latestSuccessful/artifact
-    install librtr-dev on the build server and build the packages as
-        debuild --set-envvar=WANT_RPKI=1 -b -uc -us
-    RPKI packages have an additonal dependency of librtr0 which can be
-    found at the same URL
-    
-DONE.
-
-If all works correctly, then you should end up with the Debian packages under 
-`frrpkg`. If distributed, please make sure you distribute it together with
-the sources (`frr_*.orig.tar.gz`, `frr_*.debian.tar.xz` and `frr_*.dsc`)
-
-
-Enabling daemons after installation of the package:
----------------------------------------------------
-
-1. Edit `/etc/frr/daemons` and enable required routing daemons (Zebra is
-probably needed for most deployments, so make sure to enable it.)
- 
-2. Check your firewall / IPtables to make sure the routing protocols are
-allowed.
-        
-3. Enable FRR at startup
-
-    - On `init.d` based systems (Ubuntu 12.04)
-
-            sudo update-rc.d frr defaults
-
-    - On `systemd` based systems (Debian 8 and later, Ubuntu 14.04 and later)
-
-            sudo systemctl enable frr
-
-4. Start/Restart the daemons (or reboot)
-
-    - On `init.d` based systems (Ubuntu 12.04)
-
-            sudo invoke-rc.d frr start
-
-    - on `systemd` based systems (Debian 8 and later, Ubuntu 14.04 and later)
-
-            sudo systemctl start frr
-
-
-Configuration is stored in `/etc/frr/*.conf` files and daemon selection
-is stored in `/etc/frr/daemons`.
diff -urpN frr-frr-5.0.1/debianpkg/backports/ubuntu12.04/debian/control frr-frr-6.0/debianpkg/backports/ubuntu12.04/debian/control
--- frr-frr-5.0.1/debianpkg/backports/ubuntu12.04/debian/control	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/backports/ubuntu12.04/debian/control	2018-10-08 14:32:57.000000000 +0200
@@ -4,7 +4,7 @@ Priority: optional
 Maintainer: Nobody <nobody@frrouting.org>
 Uploaders: Nobody <nobody@frrouting.org>
 XSBC-Original-Maintainer: <maintainers@frrouting.org>
-Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson0, libjson0-dev, pkg-config, python (>= 2.7), python-ipaddr, install-info
+Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson0, libjson0-dev, pkg-config, python (>= 2.7), python-ipaddr
 Standards-Version: 3.9.6
 Homepage: http://www.frrouting.org/
 XS-Testsuite: autopkgtest
diff -urpN frr-frr-5.0.1/debianpkg/backports/ubuntu12.04/debian/rules frr-frr-6.0/debianpkg/backports/ubuntu12.04/debian/rules
--- frr-frr-5.0.1/debianpkg/backports/ubuntu12.04/debian/rules	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/backports/ubuntu12.04/debian/rules	2018-10-08 14:32:57.000000000 +0200
@@ -10,7 +10,6 @@
 WANT_LDP ?= 1
 WANT_PIM ?= 1
 WANT_OSPFAPI ?= 1
-WANT_TCP_ZEBRA ?= 0
 WANT_BGP_VNC ?= 1
 WANT_CUMULUS_MODE ?= 0
 WANT_MULTIPATH ?= 1
@@ -65,12 +64,6 @@ else
   USE_OSPFAPI=--enable-ospfapi=no
 endif
 
-ifeq ($(WANT_TCP_ZEBRA),1)
-  USE_TCP_ZEBRA=--enable-tcp-zebra
-else
-  USE_TCP_ZEBRA=--disable-tcp-zebra
-endif
-
 ifeq ($(WANT_BGP_VNC), 1)
   USE_BGP_VNC=--enable-bgp-vnc=yes
 else
@@ -123,7 +116,6 @@ override_dh_auto_configure:
 		$(USE_OSPFAPI) \
 		$(USE_MULTIPATH) \
 		$(USE_LDP) \
-		$(USE_TCP_ZEBRA) \
 		--enable-fpm \
 		$(USE_FRR_USER) $(USE_FRR_GROUP) \
 		$(USE_FRR_VTY_GROUP) \
@@ -134,6 +126,7 @@ override_dh_auto_configure:
 		--enable-poll=yes \
 		$(USE_CUMULUS) \
 		$(USE_PIM) \
+		--disable-bfdd \
 		--enable-dependency-tracking \
 		$(USE_BGP_VNC) \
 		$(shell dpkg-buildflags --export=configure); \
@@ -161,12 +154,8 @@ override_dh_auto_install:
 	mkdir -p debian/tmp/etc/frr/
 	perl -pi -e 's#^!log file #!log file /var/log/frr/#' debian/tmp/usr/share/doc/frr/examples/*sample*
 
-	# installing the Frr specific SNMP MIB
-ifeq ($(WANT_SNMP), 1)
-	install -D -m 644 ./zebra/GNOME-PRODUCT-ZEBRA-MIB debian/tmp/usr/share/snmp/mibs/GNOME-PRODUCT-ZEBRA-MIB
-else
+	# leftover from previously shipping SMUX client OID MIB
 	mkdir -p debian/tmp/usr/share/snmp/mibs
-endif
 
 	# cleaning .la files
 	sed -i "/dependency_libs/ s/'.*'/''/" debian/tmp/usr/lib/*.la
diff -urpN frr-frr-5.0.1/debianpkg/backports/ubuntu14.04/debian/control frr-frr-6.0/debianpkg/backports/ubuntu14.04/debian/control
--- frr-frr-5.0.1/debianpkg/backports/ubuntu14.04/debian/control	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/backports/ubuntu14.04/debian/control	2018-10-08 14:32:57.000000000 +0200
@@ -4,7 +4,7 @@ Priority: optional
 Maintainer: Nobody <nobody@frrouting.org>
 Uploaders: Nobody <nobody@frrouting.org>
 XSBC-Original-Maintainer: <maintainers@frrouting.org>
-Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson-c-dev, libjson-c2, pkg-config, python (>= 2.7), python-ipaddr, install-info
+Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson-c-dev, libjson-c2, pkg-config, python (>= 2.7), python-ipaddr
 Standards-Version: 3.9.6
 Homepage: http://www.frrouting.org/
 XS-Testsuite: autopkgtest
diff -urpN frr-frr-5.0.1/debianpkg/backports/ubuntu14.04/debian/rules frr-frr-6.0/debianpkg/backports/ubuntu14.04/debian/rules
--- frr-frr-5.0.1/debianpkg/backports/ubuntu14.04/debian/rules	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/backports/ubuntu14.04/debian/rules	2018-10-08 14:32:57.000000000 +0200
@@ -10,12 +10,12 @@
 WANT_LDP ?= 1
 WANT_PIM ?= 1
 WANT_OSPFAPI ?= 1
-WANT_TCP_ZEBRA ?= 0
 WANT_BGP_VNC ?= 1
 WANT_CUMULUS_MODE ?= 0
 WANT_MULTIPATH ?= 1
 WANT_SNMP ?= 0
 WANT_RPKI ?= 0
+WANT_BFD ?= 1
 
 # NOTES:
 #
@@ -74,12 +74,6 @@ else
   USE_OSPFAPI=--enable-ospfapi=no
 endif
 
-ifeq ($(WANT_TCP_ZEBRA),1)
-  USE_TCP_ZEBRA=--enable-tcp-zebra
-else
-  USE_TCP_ZEBRA=--disable-tcp-zebra
-endif
-
 ifeq ($(WANT_BGP_VNC), 1)
   USE_BGP_VNC=--enable-bgp-vnc=yes
 else
@@ -108,6 +102,12 @@ else
   USE_RPKI=--disable-rpki
 endif
 
+ifeq ($(WANT_BFD), 1)
+  USE_BFD=--enable-bfdd
+else
+  USE_BFD=--disable-bfdd
+endif
+
 ifneq (,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
   DEBIAN_JOBS := $(subst parallel=,,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
 endif
@@ -145,7 +145,6 @@ override_dh_auto_configure:
 		$(USE_OSPFAPI) \
 		$(USE_MULTIPATH) \
 		$(USE_LDP) \
-		$(USE_TCP_ZEBRA) \
 		--enable-fpm \
 		$(USE_FRR_USER) $(USE_FRR_GROUP) \
 		$(USE_FRR_VTY_GROUP) \
@@ -159,6 +158,7 @@ override_dh_auto_configure:
 		--enable-dependency-tracking \
 		$(USE_BGP_VNC) \
 		$(USE_RPKI) \
+		$(USE_BFD) \
 		$(shell dpkg-buildflags --export=configure); \
 	fi
 
@@ -188,12 +188,8 @@ override_dh_auto_install:
 	mkdir -p debian/tmp/etc/frr/
 	perl -pi -e 's#^!log file #!log file /var/log/frr/#' debian/tmp/usr/share/doc/frr/examples/*sample*
 
-	# installing the Frr specific SNMP MIB
-ifeq ($(WANT_SNMP), 1)
-	install -D -m 644 ./zebra/GNOME-PRODUCT-ZEBRA-MIB debian/tmp/usr/share/snmp/mibs/GNOME-PRODUCT-ZEBRA-MIB
-else
+	# leftover from previously shipping SMUX client OID MIB
 	mkdir -p debian/tmp/usr/share/snmp/mibs/
-endif
 
 	# cleaning .la files
 	sed -i "/dependency_libs/ s/'.*'/''/" debian/tmp/usr/lib/*.la
diff -urpN frr-frr-5.0.1/debianpkg/backports/ubuntu18.04/debian/control frr-frr-6.0/debianpkg/backports/ubuntu18.04/debian/control
--- frr-frr-5.0.1/debianpkg/backports/ubuntu18.04/debian/control	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/backports/ubuntu18.04/debian/control	2018-10-08 14:32:57.000000000 +0200
@@ -4,7 +4,7 @@ Priority: optional
 Maintainer: Nobody <nobody@frrouting.org>
 Uploaders: Nobody <nobody@frrouting.org>
 XSBC-Original-Maintainer: <maintainers@frrouting.org>
-Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson-c-dev, libjson-c2 | libjson-c3, dh-systemd, libsystemd-dev, bison, flex, libc-ares-dev, pkg-config, python (>= 2.7), python-ipaddr, python-sphinx, libpython-dev, install-info
+Build-Depends: debhelper (>= 7.0.50~), libncurses5-dev, libreadline-dev, texlive-latex-base, texlive-generic-recommended, libpam0g-dev | libpam-dev, libcap-dev, texinfo (>= 4.7), imagemagick, ghostscript, groff, autotools-dev, libpcre3-dev, gawk, chrpath, libsnmp-dev, git, dh-autoreconf, libjson-c-dev, libjson-c2 | libjson-c3, dh-systemd, libsystemd-dev, bison, flex, libc-ares-dev, pkg-config, python (>= 2.7), python-ipaddr, python-sphinx, libpython-dev
 Standards-Version: 3.9.6
 Homepage: http://www.frrouting.org/
 
diff -urpN frr-frr-5.0.1/debianpkg/changelog.in frr-frr-6.0/debianpkg/changelog.in
--- frr-frr-5.0.1/debianpkg/changelog.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/changelog.in	2018-10-08 14:32:57.000000000 +0200
@@ -1,5 +1,15 @@
 frr (@VERSION@) RELEASED; urgency=medium
 
+  * Staticd: New daemon responsible for management of static routes
+  * ISISd: Implement dst-src routing as per draft-ietf-isis-ipv6-dst-src-routing
+  * BFDd: new daemon for BFD (Bidrectional Forwarding Detection). Responsible
+    for notifying link changes to make routing protocols converge faster.
+  * various bug fixes
+
+ -- FRRouting-Dev <dev@lists.frrouting.org>  Sun,  7 Oct 2018 08:10:00 -0700
+
+frr (5.0.1-0) RELEASED; urgency=medium
+
   * Support Automake 1.16.1
   * BGPd: Support for flowspec ICMP, DSCP, packet length, fragment and tcp flags
   * BGPd: fix rpki validation for ipv6
diff -urpN frr-frr-5.0.1/debianpkg/control frr-frr-6.0/debianpkg/control
--- frr-frr-5.0.1/debianpkg/control	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/control	2018-10-08 14:32:57.000000000 +0200
@@ -29,9 +29,9 @@ Depends: ${shlibs:Depends}, ${misc:Depen
 Priority: extra
 Section: debug
 Description: BGP/OSPF/RIP/RIPng/ISIS/PIM/LDP routing daemon (debug symbols)
- This package provides debugging symbols for all binary packages built 
+ This package provides debugging symbols for all binary packages built
  from frr source package. It's highly recommended to have this package
- installed before reporting any FRR crashes to either FRR developers or 
+ installed before reporting any FRR crashes to either FRR developers or
  Debian package maintainers.
 
 Package: frr-doc
diff -urpN frr-frr-5.0.1/debianpkg/frr-doc.docs frr-frr-6.0/debianpkg/frr-doc.docs
--- frr-frr-5.0.1/debianpkg/frr-doc.docs	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/frr-doc.docs	2018-10-08 14:32:57.000000000 +0200
@@ -1,6 +1,5 @@
 AUTHORS
 NEWS
 README
-REPORTING-BUGS
 doc/user/*.rst
 doc/figures/*.png
diff -urpN frr-frr-5.0.1/debianpkg/frr.logrotate frr-frr-6.0/debianpkg/frr.logrotate
--- frr-frr-5.0.1/debianpkg/frr.logrotate	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/frr.logrotate	2018-10-08 14:32:57.000000000 +0200
@@ -17,7 +17,7 @@
             # open, as well as the daemons, so always signal the daemons.
             # It's safe, a NOP if (only) syslog is being used.
             for i in babeld bgpd eigrpd isisd ldpd nhrpd ospf6d ospfd \
-                pimd ripd ripngd zebra ; do
+                pimd ripd ripngd zebra staticd ; do
                 if [ -e /var/run/frr/$i.pid ] ; then
                     pids="$pids $(cat /var/run/frr/$i.pid)"
                 fi
diff -urpN frr-frr-5.0.1/debianpkg/rules frr-frr-6.0/debianpkg/rules
--- frr-frr-5.0.1/debianpkg/rules	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/debianpkg/rules	2018-10-08 14:32:57.000000000 +0200
@@ -10,12 +10,12 @@
 WANT_LDP ?= 1
 WANT_PIM ?= 1
 WANT_OSPFAPI ?= 1
-WANT_TCP_ZEBRA ?= 0
 WANT_BGP_VNC ?= 1
 WANT_CUMULUS_MODE ?= 0
 WANT_MULTIPATH ?= 1
 WANT_SNMP ?= 0
 WANT_RPKI ?= 0
+WANT_BFD ?= 1
 
 # NOTES:
 #
@@ -74,12 +74,6 @@ else
   USE_OSPFAPI=--enable-ospfapi=no
 endif
 
-ifeq ($(WANT_TCP_ZEBRA),1)
-  USE_TCP_ZEBRA=--enable-tcp-zebra
-else
-  USE_TCP_ZEBRA=--disable-tcp-zebra
-endif
-
 ifeq ($(WANT_BGP_VNC), 1)
   USE_BGP_VNC=--enable-bgp-vnc=yes
 else
@@ -108,6 +102,12 @@ else
   USE_RPKI=--disable-rpki
 endif
 
+ifeq ($(WANT_BFD), 1)
+  USE_BFD=--enable-bfdd
+else
+  USE_BFD=--disable-bfdd
+endif
+
 ifneq (,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
   DEBIAN_JOBS := $(subst parallel=,,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
 endif
@@ -145,7 +145,6 @@ override_dh_auto_configure:
 		$(USE_OSPFAPI) \
 		$(USE_MULTIPATH) \
 		$(USE_LDP) \
-		$(USE_TCP_ZEBRA) \
 		--enable-fpm \
 		$(USE_FRR_USER) $(USE_FRR_GROUP) \
 		$(USE_FRR_VTY_GROUP) \
@@ -160,6 +159,7 @@ override_dh_auto_configure:
 		--enable-dependency-tracking \
 		$(USE_BGP_VNC) \
 		$(USE_RPKI) \
+		$(USE_BFD) \
 		$(shell dpkg-buildflags --export=configure); \
 	fi
 
@@ -186,12 +186,8 @@ override_dh_auto_install:
 	mkdir -p debian/tmp/etc/frr/
 	perl -pi -e 's#^!log file #!log file /var/log/frr/#' debian/tmp/usr/share/doc/frr/examples/*sample*
 
-	# installing the Frr specific SNMP MIB
-ifeq ($(WANT_SNMP), 1)
-	install -D -m 644 ./zebra/GNOME-PRODUCT-ZEBRA-MIB debian/tmp/usr/share/snmp/mibs/GNOME-PRODUCT-ZEBRA-MIB
-else
+	# leftover from previously shipping SMUX client OID MIB
 	mkdir -p debian/tmp/usr/share/snmp/mibs/
-endif
 
 	# cleaning .la files
 	sed -i "/dependency_libs/ s/'.*'/''/" debian/tmp/usr/lib/*.la
diff -urpN frr-frr-5.0.1/doc/Makefile.am frr-frr-6.0/doc/Makefile.am
--- frr-frr-5.0.1/doc/Makefile.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -86,6 +86,14 @@ if SHARPD
 man_MANS += $(MANPAGE_BUILDDIR)/sharpd.8
 endif
 
+if STATICD
+man_MANS += $(MANPAGE_BUILDDIR)/staticd.8
+endif
+
+if BFDD
+man_MANS += $(MANPAGE_BUILDDIR)/bfdd.8
+endif
+
 # Automake is particular about manpages. It is aware of them and has some
 # special facilities for handling them, but it assumes that manpages are always
 # given in groff source and so these facilities are limited to simply
@@ -140,7 +148,7 @@ EXTRA_DIST = frr-sphinx.mk \
 	manpages/index.rst \
 	manpages/isisd.rst \
 	manpages/ldpd.rst \
-	manpages/Makefile \
+	manpages/Makefile.am \
 	manpages/mtracebis.rst \
 	manpages/nhrpd.rst \
 	manpages/ospf6d.rst \
@@ -151,9 +159,12 @@ EXTRA_DIST = frr-sphinx.mk \
 	manpages/pbrd.rst \
 	manpages/ripngd.rst \
 	manpages/sharpd.rst \
+	manpages/staticd.rst \
 	manpages/vtysh.rst \
 	manpages/watchfrr.rst \
 	manpages/zebra.rst \
+	manpages/bfdd.rst \
+	manpages/bfd-options.rst \
 	developer/bgpd.rst \
 	developer/bgp-typecodes.rst \
 	developer/building-frr-on-alpine.rst \
@@ -182,7 +193,9 @@ EXTRA_DIST = frr-sphinx.mk \
 	developer/index.rst \
 	developer/ldpd-basic-test-setup.md \
 	developer/library.rst \
-	developer/Makefile \
+	developer/logging.rst \
+	developer/Makefile.in \
+	developer/maintainer-release-build.rst \
 	developer/memtypes.rst \
 	developer/modules.rst \
 	developer/next-hop-tracking.rst \
@@ -191,10 +204,11 @@ EXTRA_DIST = frr-sphinx.mk \
 	developer/ospf-sr.rst \
 	developer/workflow.rst \
 	developer/zebra.rst \
-	user/appendix.rst \
 	user/babeld.rst \
+	user/ldpd.rst \
 	user/basic.rst \
 	user/bgp.rst \
+	user/bugs.rst \
 	user/conf.py \
 	user/eigrpd.rst \
 	user/filter.rst \
@@ -204,12 +218,13 @@ EXTRA_DIST = frr-sphinx.mk \
 	user/ipv6.rst \
 	user/isisd.rst \
 	user/kernel.rst \
-	user/Makefile \
+	user/Makefile.am \
 	user/nhrpd.rst \
 	user/ospf6d.rst \
 	user/ospfd.rst \
 	user/ospf_fundamentals.rst \
 	user/overview.rst \
+	user/packet-dumps.rst \
 	user/pim.rst \
 	user/ripd.rst \
 	user/pbr.rst \
@@ -217,13 +232,17 @@ EXTRA_DIST = frr-sphinx.mk \
 	user/routemap.rst \
 	user/routeserver.rst \
 	user/rpki.rst \
+	user/setup.rst \
 	user/sharp.rst \
 	user/snmp.rst \
 	user/snmptrap.rst \
+	user/static.rst \
 	user/Useful_Sysctl_Settings.md \
 	user/vnc.rst \
 	user/vtysh.rst \
 	user/zebra.rst \
+	user/bfd.rst \
+	user/flowspec.rst \
 	mpls/ChangeLog.opaque.txt \
 	mpls/ospfd.conf \
 	mpls/cli_summary.txt \
diff -urpN frr-frr-5.0.1/doc/developer/.gitignore frr-frr-6.0/doc/developer/.gitignore
--- frr-frr-5.0.1/doc/developer/.gitignore	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,2 @@
 /_templates
 /_build
-!/Makefile.in
diff -urpN frr-frr-5.0.1/doc/developer/Makefile.am frr-frr-6.0/doc/developer/Makefile.am
--- frr-frr-5.0.1/doc/developer/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,8 @@
+# This is necessary to support VPATH builds.
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+# This variable is used as the documentation source location in frr-sphinx.mk
+SOURCESDIR = @srcdir@
+
+include @srcdir@/../frr-sphinx.mk
diff -urpN frr-frr-5.0.1/doc/developer/Makefile.in frr-frr-6.0/doc/developer/Makefile.in
--- frr-frr-5.0.1/doc/developer/Makefile.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-# This is necessary to support VPATH builds.
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-# This variable is used as the documentation source location in frr-sphinx.mk
-SOURCESDIR = @srcdir@
-
-include @srcdir@/../frr-sphinx.mk
diff -urpN frr-frr-5.0.1/doc/developer/building-frr-on-openbsd6.rst frr-frr-6.0/doc/developer/building-frr-on-openbsd6.rst
--- frr-frr-5.0.1/doc/developer/building-frr-on-openbsd6.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building-frr-on-openbsd6.rst	2018-10-08 14:32:57.000000000 +0200
@@ -14,7 +14,7 @@ Add packages:
 
 ::
 
-    pkg_add git autoconf-2.69p2 automake-1.15p0 libtool bison
+    pkg_add git autoconf-2.69p2 automake-1.15.1 libtool bison
     pkg_add gmake gawk dejagnu openssl json-c py-test py-sphinx
 
 Select Python2.7 as default (required for pytest)
diff -urpN frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1204.rst frr-frr-6.0/doc/developer/building-frr-on-ubuntu1204.rst
--- frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1204.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building-frr-on-ubuntu1204.rst	2018-10-08 14:32:57.000000000 +0200
@@ -13,9 +13,10 @@ Add packages:
 
 ::
 
-    apt-get install git autoconf automake libtool make gawk libreadline-dev \
-       texinfo libpam0g-dev dejagnu libjson0-dev pkg-config libpam0g-dev \
-       libjson0-dev flex python-pip libc-ares-dev python3-dev python3-sphinx
+    apt-get install \
+       git autoconf automake libtool make gawk libreadline-dev texinfo \
+       dejagnu pkg-config libpam0g-dev libjson0-dev flex python-pip \
+       libc-ares-dev python3-dev python3-sphinx install-info
 
 Install newer bison from 14.04 package source (Ubuntu 12.04 package
 source is too old)
@@ -74,7 +75,7 @@ Add frr groups and user
 
 ::
 
-    sudo groupadd -g 92 frr
+    sudo groupadd -r -g 92 frr
     sudo groupadd -r -g 85 frrvty
     sudo adduser --system --ingroup frr --home /var/run/frr/ \
        --gecos "FRR suite" --shell /sbin/nologin frr
diff -urpN frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1404.rst frr-frr-6.0/doc/developer/building-frr-on-ubuntu1404.rst
--- frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1404.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building-frr-on-ubuntu1404.rst	2018-10-08 14:32:57.000000000 +0200
@@ -13,9 +13,10 @@ Add packages:
 
 ::
 
-    apt-get install git autoconf automake libtool make gawk libreadline-dev \
-       texinfo dejagnu pkg-config libpam0g-dev libjson-c-dev bison flex \
-       python-pytest libc-ares-dev python3-dev python3-sphinx
+    apt-get install \
+       git autoconf automake libtool make gawk libreadline-dev texinfo dejagnu \
+       pkg-config libpam0g-dev libjson-c-dev bison flex python-pytest \
+       libc-ares-dev python3-dev python3-sphinx install-info
 
 Get FRR, compile it and install it (from Git)
 ---------------------------------------------
@@ -28,7 +29,7 @@ Add frr groups and user
 
 ::
 
-    sudo groupadd -g 92 frr
+    sudo groupadd -r -g 92 frr
     sudo groupadd -r -g 85 frrvty
     sudo adduser --system --ingroup frr --home /var/run/frr/ \
        --gecos "FRR suite" --shell /sbin/nologin frr
diff -urpN frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1604.rst frr-frr-6.0/doc/developer/building-frr-on-ubuntu1604.rst
--- frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1604.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building-frr-on-ubuntu1604.rst	2018-10-08 14:32:57.000000000 +0200
@@ -13,10 +13,11 @@ Add packages:
 
 ::
 
-    apt-get install git autoconf automake libtool make gawk libreadline-dev \
-       texinfo dejagnu pkg-config libpam0g-dev libjson-c-dev bison flex \
-       python-pytest libc-ares-dev python3-dev libsystemd-dev python-ipaddr \
-       python3-sphinx
+    apt-get install \
+       git autoconf automake libtool make gawk libreadline-dev texinfo dejagnu \
+       pkg-config libpam0g-dev libjson-c-dev bison flex python-pytest \
+       libc-ares-dev python3-dev libsystemd-dev python-ipaddr python3-sphinx \
+       install-info
 
 Get FRR, compile it and install it (from Git)
 ---------------------------------------------
@@ -29,7 +30,7 @@ Add frr groups and user
 
 ::
 
-    sudo groupadd -g 92 frr
+    sudo groupadd -r -g 92 frr
     sudo groupadd -r -g 85 frrvty
     sudo adduser --system --ingroup frr --home /var/run/frr/ \
        --gecos "FRR suite" --shell /sbin/nologin frr
diff -urpN frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1804.rst frr-frr-6.0/doc/developer/building-frr-on-ubuntu1804.rst
--- frr-frr-5.0.1/doc/developer/building-frr-on-ubuntu1804.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building-frr-on-ubuntu1804.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,17 +1,42 @@
-Ubuntu 18.04LTS
-===============================================
+Ubuntu 18.04 LTS
+================
 
-Install required packages
--------------------------
+Install dependencies
+--------------------
 
-Add packages:
+Required packages
+^^^^^^^^^^^^^^^^^
 
 ::
 
-    apt-get install git autoconf automake libtool make gawk libreadline-dev \
-       texinfo pkg-config libpam0g-dev libjson-c-dev bison flex \
-       python-pytest libc-ares-dev python3-dev libsystemd-dev python-ipaddr \
-       python3-sphinx
+   sudo apt-get install \
+      git autoconf automake libtool make gawk libreadline-dev texinfo \
+      pkg-config libpam0g-dev libjson-c-dev bison flex python-pytest \
+      libc-ares-dev python3-dev libsystemd-dev python-ipaddr python3-sphinx \
+      install-info
+
+Optional packages
+^^^^^^^^^^^^^^^^^
+
+Dependencies for additional functionality can be installed as-desired.
+
+Protobuf
+~~~~~~~~
+
+::
+
+   sudo apt-get install \
+       protobuf-c-compiler \
+       libprotobuf-c-dev
+
+ZeroMQ
+~~~~~~
+
+::
+
+   sudo apt-get install \
+       libzmq5 \
+       libzmq3-dev
 
 Get FRR, compile it and install it (from Git)
 ---------------------------------------------
@@ -24,148 +49,201 @@ Add frr groups and user
 
 ::
 
-    sudo groupadd -g 92 frr
-    sudo groupadd -r -g 85 frrvty
-    sudo adduser --system --ingroup frr --home /var/run/frr/ \
-       --gecos "FRR suite" --shell /sbin/nologin frr
-    sudo usermod -a -G frrvty frr
-
-Download Source, configure and compile it
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-(You may prefer different options on configure statement. These are just
-an example.)
+   sudo groupadd -r -g 92 frr
+   sudo groupadd -r -g 85 frrvty
+   sudo adduser --system --ingroup frr --home /var/run/frr/ \
+      --gecos "FRR suite" --shell /sbin/nologin frr
+   sudo usermod -a -G frrvty frr
+
+Download source
+^^^^^^^^^^^^^^^
 
 ::
 
-    git clone https://github.com/frrouting/frr.git frr
-    cd frr
-    ./bootstrap.sh
-    ./configure \
-        --prefix=/usr \
-        --enable-exampledir=/usr/share/doc/frr/examples/ \
-        --localstatedir=/var/run/frr \
-        --sbindir=/usr/lib/frr \
-        --sysconfdir=/etc/frr \
-        --enable-pimd \
-        --enable-watchfrr \
-        --enable-ospfclient=yes \
-        --enable-ospfapi=yes \
-        --enable-multipath=64 \
-        --enable-user=frr \
-        --enable-group=frr \
-        --enable-vty-group=frrvty \
-        --enable-configfile-mask=0640 \
-        --enable-logfile-mask=0640 \
-        --enable-rtadv \
-        --enable-fpm \
-        --enable-systemd=yes \
-        --with-pkg-git-version \
-        --with-pkg-extra-version=-MyOwnFRRVersion
-    make
-    make check
-    sudo make install
+   git clone https://github.com/frrouting/frr.git frr
+
+Configure
+^^^^^^^^^
+Options below are provided as an example.
+
+.. seealso:: *Installation* section of user guide
+
+.. code-block:: shell
+
+   cd frr
+   ./bootstrap.sh
+   ./configure \
+       --prefix=/usr \
+       --enable-exampledir=/usr/share/doc/frr/examples/ \
+       --localstatedir=/var/run/frr \
+       --sbindir=/usr/lib/frr \
+       --sysconfdir=/etc/frr \
+       --enable-pimd \
+       --enable-watchfrr \
+       --enable-ospfclient=yes \
+       --enable-ospfapi=yes \
+       --enable-multipath=64 \
+       --enable-user=frr \
+       --enable-group=frr \
+       --enable-vty-group=frrvty \
+       --enable-configfile-mask=0640 \
+       --enable-logfile-mask=0640 \
+       --enable-rtadv \
+       --enable-fpm \
+       --enable-systemd=yes \
+       --with-pkg-git-version \
+       --with-pkg-extra-version=-MyOwnFRRVersion
+
+If optional packages were installed, the associated feature may now be
+enabled.
+
+.. option:: --enable-protobuf
+
+Enable support for protobuf transport
+
+.. option:: --enable-zeromq
+
+Enable support for ZeroMQ transport
+
+Compile
+^^^^^^^
+
+::
+
+   make
+   make check
+   sudo make install
 
 Create empty FRR configuration files
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-::
+Although not strictly necessary, it's good practice to create empty
+configuration files _before_ starting FRR. This assures that the permissions 
+are correct. If the files are not already present, FRR will create them.
 
-    sudo install -m 755 -o frr -g frr -d /var/log/frr
-    sudo install -m 775 -o frr -g frrvty -d /etc/frr
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/zebra.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/bgpd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ospfd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ospf6d.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/isisd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ripd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ripngd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/pimd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ldpd.conf
-    sudo install -m 640 -o frr -g frr /dev/null /etc/frr/nhrpd.conf
-    sudo install -m 640 -o frr -g frrvty /dev/null /etc/frr/vtysh.conf
+It's also important to consider _which_ files to create. FRR supports writing
+configuration to a monolithic file, :file:`/etc/frr/frr.conf`.
 
-Enable IPv4 & IPv6 forwarding
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+.. seealso:: *VTYSH* section of user guide
+
+The presence of :file:`/etc/frr/frr.conf` on startup implicitly configures FRR
+to ignore daemon-specific configuration files.
 
-Edit ``/etc/sysctl.conf`` and uncomment the following values (ignore the
-other settings)
+Daemon-specific configuration
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 ::
 
-    # Uncomment the next line to enable packet forwarding for IPv4
-    net.ipv4.ip_forward=1
+   sudo install -m 755 -o frr -g frr -d /var/log/frr
+   sudo install -m 775 -o frr -g frrvty -d /etc/frr
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/zebra.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/bgpd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ospfd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ospf6d.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/isisd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ripd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ripngd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/pimd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/ldpd.conf
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/nhrpd.conf
 
-    # Uncomment the next line to enable packet forwarding for IPv6
-    #  Enabling this option disables Stateless Address Autoconfiguration
-    #  based on Router Advertisements for this host
-    net.ipv6.conf.all.forwarding=1
+Monolithic configuration
+~~~~~~~~~~~~~~~~~~~~~~~~
 
-Enable MPLS Forwarding (with Linux Kernel >= 4.5)
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+::
+
+   sudo install -m 755 -o frr -g frr -d /var/log/frr
+   sudo install -m 775 -o frr -g frrvty -d /etc/frr
+   sudo install -m 640 -o frr -g frr /dev/null /etc/frr/frr.conf
+
+Enable IPv4 & IPv6 forwarding
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-Edit ``/etc/sysctl.conf`` and the following lines. Make sure to add a
-line equal to ``net.mpls.conf.eth0.input`` or each interface used with
-MPLS
+Edit :file:`/etc/sysctl.conf` and uncomment the following values (ignore the
+other settings):
 
 ::
 
-    # Enable MPLS Label processing on all interfaces
-    net.mpls.conf.eth0.input=1
-    net.mpls.conf.eth1.input=1
-    net.mpls.conf.eth2.input=1
-    net.mpls.platform_labels=100000
+   # Uncomment the next line to enable packet forwarding for IPv4
+   net.ipv4.ip_forward=1
+
+   # Uncomment the next line to enable packet forwarding for IPv6
+   #  Enabling this option disables Stateless Address Autoconfiguration
+   #  based on Router Advertisements for this host
+   net.ipv6.conf.all.forwarding=1
 
 Add MPLS kernel modules
 ^^^^^^^^^^^^^^^^^^^^^^^
 
-Add the following lines to ``/etc/modules-load.d/modules.conf``:
+Ubuntu 18.04 ships with kernel 4.15. MPLS modules are present by default.  To
+enable, add the following lines to :file:`/etc/modules-load.d/modules.conf`:
 
 ::
 
-    # Load MPLS Kernel Modules
-    mpls-router
-    mpls-iptunnel
+   # Load MPLS Kernel Modules
+   mpls_router
+   mpls_iptunnel
+
+Reboot or use ``sysctl -p`` to apply the same config to the running system.
+
+Enable MPLS Forwarding
+^^^^^^^^^^^^^^^^^^^^^^
+
+Edit :file:`/etc/sysctl.conf` and the following lines. Make sure to add a line
+equal to :file:`net.mpls.conf.eth0.input` for each interface used with MPLS.
+
+::
 
-**Reboot** or use ``sysctl -p`` to apply the same config to the running
-system
+   # Enable MPLS Label processing on all interfaces
+   net.mpls.conf.eth0.input=1
+   net.mpls.conf.eth1.input=1
+   net.mpls.conf.eth2.input=1
+   net.mpls.platform_labels=100000
 
-Install the systemd service (if rebooted from last step, change directory back to frr directory)
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Install the systemd service
+^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 ::
 
-    sudo install -m 644 tools/frr.service /etc/systemd/system/frr.service
-    sudo install -m 644 tools/etc/default/frr /etc/default/frr
-    sudo install -m 644 tools/etc/frr/daemons /etc/frr/daemons
-    sudo install -m 644 tools/etc/frr/daemons.conf /etc/frr/daemons.conf
-    sudo install -m 644 tools/etc/frr/frr.conf /etc/frr/frr.conf
-    sudo install -m 644 -o frr -g frr tools/etc/frr/vtysh.conf /etc/frr/vtysh.conf
+   sudo install -m 644 tools/frr.service /etc/systemd/system/frr.service
+   sudo install -m 644 tools/etc/default/frr /etc/default/frr
+   sudo install -m 644 tools/etc/frr/daemons /etc/frr/daemons
+   sudo install -m 644 tools/etc/frr/daemons.conf /etc/frr/daemons.conf
+   sudo install -m 644 tools/etc/frr/frr.conf /etc/frr/frr.conf
+   sudo install -m 644 -o frr -g frr tools/etc/frr/vtysh.conf /etc/frr/vtysh.conf
 
 Enable daemons
 ^^^^^^^^^^^^^^
 
-| Edit ``/etc/frr/daemons`` and change the value from "no" to "yes" for
-  those daemons you want to start by systemd.
-| For example.
+Edit ``/etc/frr/daemons`` and change the value from "no" to "yes" for those
+daemons you want to start by systemd.  For example:
 
 ::
 
-    zebra=yes
-    bgpd=yes
-    ospfd=yes
-    ospf6d=yes
-    ripd=yes
-    ripngd=yes
-    isisd=yes
+   zebra=yes
+   bgpd=yes
+   ospfd=yes
+   ospf6d=yes
+   ripd=yes
+   ripngd=yes
+   isisd=yes
 
 Enable the systemd service
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 
--  systemctl enable frr
+Enabling the systemd service causes FRR to be started upon boot. To enable it,
+use the following command:
+
+.. code-block:: shell
+
+   systemctl enable frr
 
 Start the systemd service
 ^^^^^^^^^^^^^^^^^^^^^^^^^
 
--  systemctl start frr
--  use ``systemctl status frr`` to check its status.
+.. code-block:: shell
+
+   systemctl start frr
+
+After starting the service, you can use ``systemctl status frr`` to check its
+status.
diff -urpN frr-frr-5.0.1/doc/developer/building.rst frr-frr-6.0/doc/developer/building.rst
--- frr-frr-5.0.1/doc/developer/building.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/building.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,5 @@
+.. _building:
+
 ************
 Building FRR
 ************
diff -urpN frr-frr-5.0.1/doc/developer/cli.rst frr-frr-6.0/doc/developer/cli.rst
--- frr-frr-5.0.1/doc/developer/cli.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/cli.rst	2018-10-08 14:32:57.000000000 +0200
@@ -756,27 +756,30 @@ Consider also:
 
 ::
 
-      show <ip|ipv6> foo
+   show <ip|ipv6> foo
 
 User input:
 
 ::
 
-      show ip foo
+   show ip foo
 
 ``ip`` partially matches ``ipv6`` but exactly matches ``ip``, so ``ip`` will
 win.
 
+Inspection & Debugging
+----------------------
+
 Permutations
-------------
-Finally, it is sometimes useful to check all the possible combinations of input
-that would match an arbitrary definition string. There is a tool in
+^^^^^^^^^^^^
+It is sometimes useful to check all the possible combinations of input that
+would match an arbitrary definition string. There is a tool in
 :file:`tools/permutations` that reads CLI definition strings on ``stdin`` and
 prints out all matching input permutations. It also dumps a text representation
 of the graph, which is more useful for debugging than anything else. It looks
 like this:
 
-::
+.. code-block:: shell
 
    $ ./permutations "show [ip] bgp [<view|vrf> WORD]"
 
@@ -787,6 +790,29 @@ like this:
    show bgp vrf WORD
    show bgp
 
-This functionality is also built into VTY/VTYSH; the ``list permutations``
-command will list all possible matching input permutations in the current CLI
-node.
+This functionality is also built into VTY/VTYSH; :clicmd:`list permutations`
+will list all possible matching input permutations in the current CLI node.
+
+Graph Inspection
+^^^^^^^^^^^^^^^^
+When in the Telnet or VTYSH console, :clicmd:`show cli graph` will dump the
+entire command space of the current mode in the DOT graph language. This can be
+fed into one of the various GraphViz layout engines, such as ``dot``,
+``neato``, etc.
+
+For example, to generate an image of the entire command space for the top-level
+mode (``ENABLE_NODE``):
+
+.. code-block:: shell
+
+   sudo vtysh -c 'show cli graph' | dot -Tjpg -Grankdir=LR > graph.jpg
+
+To do the same for the BGP mode:
+
+.. code-block:: shell
+
+   sudo vtysh -c 'conf t' -c 'router bgp' -c 'show cli graph' | dot -Tjpg -Grankdir=LR > bgpgraph.jpg
+
+This information is very helpful when debugging command resolution, tracking
+down duplicate / ambiguous commands, and debugging patches to the CLI graph
+builder.
diff -urpN frr-frr-5.0.1/doc/developer/index.rst frr-frr-6.0/doc/developer/index.rst
--- frr-frr-5.0.1/doc/developer/index.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/index.rst	2018-10-08 14:32:57.000000000 +0200
@@ -6,6 +6,8 @@ FRRouting Developer's Guide
 
    workflow
    building
+   packaging
+   process-architecture
    library
    bgpd
    ospf
diff -urpN frr-frr-5.0.1/doc/developer/library.rst frr-frr-6.0/doc/developer/library.rst
--- frr-frr-5.0.1/doc/developer/library.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/library.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,5 @@
+.. _libfrr:
+
 ***************************
 Library Facilities (libfrr)
 ***************************
@@ -5,6 +7,7 @@ Library Facilities (libfrr)
 .. toctree::
    :maxdepth: 2
 
+   logging
    memtypes
    hooks
    cli
diff -urpN frr-frr-5.0.1/doc/developer/logging.rst frr-frr-6.0/doc/developer/logging.rst
--- frr-frr-5.0.1/doc/developer/logging.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/logging.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,131 @@
+Developer's Guide to Logging
+============================
+
+One of the most frequent decisions to make while writing code for FRR is what
+to log, what level to log it at, and when to log it.  Here is a list of
+recommendations for these decisions.
+
+
+Errors and warnings
+-------------------
+
+If it is something that the user will want to look at and maybe do
+something, it is either an **error** or a **warning**.
+
+We're expecting that warnings and errors are in some way visible to the
+user (in the worst case by looking at the log after the network broke, but
+maybe by a syslog collector from all routers.)  Therefore, anything that
+needs to get the user in the loopand only these thingsare warnings or
+errors.
+
+Note that this doesn't neccessarily mean the user needs to fix something in
+the FRR instance.  It also includes when we detect something else needs
+fixing, for example another router, the system we're running on, or the
+configuration.  The common point is that the user should probably do
+*something*.
+
+Deciding between a warning and an error is slightly less obvious; the rule
+of thumb here is that an error will cause considerable fallout beyond its
+direct effect.  Closing a BGP session due to a malformed update is an error
+since all routes from the peer are dropped; discarding one route because
+its attributes don't make sense is a warning.
+
+This also loosely corresponds to the kind of reaction we're expecting from
+the user.  An error is likely to need immediate response while a warning
+might be snoozed for a bit and addressed as part of general maintenance.
+If a problem will self-repair (e.g. by retransmits), it should be a
+warningunless the impact until that self-repair is very harsh.
+
+Examples for warnings:
+
+* a BGP update, LSA or LSP could not be processed, but operation is
+  proceeding and the broken pieces are likely to self-fix later
+* some kind of controller cannot be reached, but we can work without it
+* another router is using some unknown or unsupported capability
+
+Examples for errors:
+
+* dropping a BGP session due to malformed data
+* a socket for routing protocol operation cannot be opened
+* desynchronization from network state because something went wrong
+* *everything that we as developers would really like to be notified about,
+  i.e. some assumption in the code isn't holding up*
+
+
+Informational messages
+----------------------
+
+Anything that provides introspection to the user during normal operation
+is an **info** message.
+
+This includes all kinds of operational state transitions and events,
+especially if they might be interesting to the user during the course of
+figuring out a warning or an error.
+
+By itself, these messages should mostly be statements of fact.  They might
+indicate the order and relationship in which things happened.  Also covered
+are conditions that might be "operational issues" like a link failure due
+to an unplugged cable.  If it's pretty much the point of running a routing
+daemon for, it's not a warning or an error, just business as usual.
+
+The user should be able to see the state of these bits from operational
+state output, i.e. `show interface` or `show foobar neighbors`.  The log
+message indicating the change may have been printed weeks ago, but the
+state can always be viewed.  (If some state change has an info message but
+no "show" command, maybe that command needs to be added.)
+
+Examples:
+
+* all kinds of up/down state changes
+
+  * interface coming up or going down
+  * addresses being added or deleted
+  * peers and neighbors coming up or going down
+
+* rejection of some routes due to user-configured route maps
+* backwards compatibility handling because another system on the network
+  has a different or smaller feature set
+
+.. note::
+   The previously used **notify** priority is replaced with *info* in all
+   cases.  We don't currently have a well-defined use case for it.
+
+
+Debug messages and asserts
+--------------------------
+
+Everything that is only interesting on-demand, or only while developing,
+is a **debug** message.  It might be interesting to the user for a
+particularly evasive issue, but in general these are details that an
+average user might not even be able to make sense of.
+
+Most (or all?) debug messages should be behind a `debug foobar` category
+switch that controls which subset of these messages is currently
+interesting and thus printed.  If a debug message doesn't have such a
+guard, there should be a good explanation as to why.
+
+Conversely, debug messages are the only thing that should be guarded by
+these switches.  Neither info nor warning or error messages should be
+hidden in this way.
+
+**Asserts** should only be used as pretty crashes.  We are expecting that
+asserts remain enabled in production builds, but please try to not use
+asserts in a way that would cause a security problem if the assert wasn't
+there (i.e. don't use them for length checks.)
+
+The purpose of asserts is mainly to help development and bug hunting.  If
+the daemon crashes, then having some more information is nice, and the
+assert can provide crucial hints that cut down on the time needed to track
+an issue.  That said, if the issue can be reasonably handled and/or isn't
+going to crash the daemon, it shouldn't be an assert.
+
+For anything else where internal constraints are violated but we're not
+breaking due to it, it's an error instead (not a debug.)  These require
+"user action" of notifying the developers.
+
+Examples:
+
+* mismatched :code:`prev`/:code:`next` pointers in lists
+* some field that is absolutely needed is :code:`NULL`
+* any other kind of data structure corruption that will cause the daemon
+  to crash sooner or later, one way or another
diff -urpN frr-frr-5.0.1/doc/developer/maintainer-release-build.rst frr-frr-6.0/doc/developer/maintainer-release-build.rst
--- frr-frr-5.0.1/doc/developer/maintainer-release-build.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/maintainer-release-build.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,89 @@
+Release Build Procedure for FRR maintainers
+=========================================================
+
+1. Rename branch (if needed)
+
+.. code-block:: shell
+
+   git clone git@github.com:FRRouting/frr.git
+   cd frr
+   git checkout dev/5.0
+   git push origin :refs/heads/dev/5.0
+   git push origin dev/5.0:refs/heads/stable/5.0
+
+2. Checkout the new stable branch:
+
+.. code-block:: shell
+
+   git checkout stable/5.0
+
+3. Update Changelog for RedHat Package:
+
+   Edit :file:`redhat/frr.spec.in` and look for the ``%changelog`` section:
+
+   - Change last (top of list) entry from ``%{version}`` to previous fixed
+     version number, i.e.::
+
+        * Tue Nov  7 2017 Martin Winter <mwinter@opensourcerouting.org> - %{version}
+
+     to::
+
+        * Tue Nov  7 2017 Martin Winter <mwinter@opensourcerouting.org> - 3.0.2
+
+   - Add new entry to the top of the list with ``%{version}`` tag and changelog
+     for version.
+     Make sure to watch the format, i.e. the day is always 2 characters, with
+     the 1st character being a space if the day is one digit.
+
+4. Update Changelog for Debian Packages:
+
+   Edit :file:`debianpkg/changelog.in`:
+
+   - Change last (top of list) entry from ``@VERSION@`` to previous fixed
+     version number, i.e.::
+
+        frr (@VERSION@) RELEASED; urgency=medium
+
+     to::
+
+        frr (3.0.2) RELEASED; urgency=medium
+
+   - Add a new entry to the top of the list with a ``@VERSION@`` tag and
+     changelog for version.
+
+5. Change main version number:
+
+    - Edit :file:`configure.ac` and change version in the ``AC_INIT`` command
+    - Create a new entry with the version as ``%{version}`` tag
+
+6. Test building at least a Red Hat and Ubuntu package (or create a PR to have
+   the CI system test them)
+
+7. Commit the changes, adding the changelog to the commit message
+
+8. Create a git tag for the version:
+
+   .. code-block:: shell
+
+      git tag -a frr-5.0 -m "FRRouting Release 5.0"
+
+9. Push the commit and tag(s) and watch for errors on CI:
+
+   .. code-block:: shell
+
+      git push
+      git push --tags
+
+10. Kick off the Release build plan on the CI system for the correct release
+
+11. Send a Release Announcement with changes to
+    ``announce@lists.frrouting.org``
+
+12. Kick off the Snapcraft build plan for the correct release
+
+13. After CI plans succeed, release on GitHub by going to
+    https://github.com/FRRouting/frr/releases and selecting "Draft a new
+    release".
+
+14. Deploy Snapcraft release (after CI system finishes the tests for snapcraft
+    testplan)
diff -urpN frr-frr-5.0.1/doc/developer/modules.rst frr-frr-6.0/doc/developer/modules.rst
--- frr-frr-5.0.1/doc/developer/modules.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/modules.rst	2018-10-08 14:32:57.000000000 +0200
@@ -100,6 +100,15 @@ a function that removes all of a module'
 There's also the ``frr_module`` symbol in modules, pretty much a
 standard entry point for loadable modules.
 
+Command line parameters
+-----------------------
+
+Command line parameters can be passed directly to a module by appending a 
+colon to the module name when loading it, e.g. ``-M mymodule:myparameter``. 
+The text after the colon will be accessible in the module's code through 
+``THIS_MODULE->load_args``. For example, see how the format parameter is
+configured in the ``zfpm_init()`` function inside ``zebra_fpm.c``.
+
 Hooks
 -----
 
diff -urpN frr-frr-5.0.1/doc/developer/ospf-api.rst frr-frr-6.0/doc/developer/ospf-api.rst
--- frr-frr-5.0.1/doc/developer/ospf-api.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/ospf-api.rst	2018-10-08 14:32:57.000000000 +0200
@@ -77,7 +77,6 @@ the ospfapi server and ospfclient).
 
 ::
 
-    % update-autotools
     % sh ./configure --enable-opaque-lsa
     % make
 
diff -urpN frr-frr-5.0.1/doc/developer/packaging-debian.rst frr-frr-6.0/doc/developer/packaging-debian.rst
--- frr-frr-5.0.1/doc/developer/packaging-debian.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/packaging-debian.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,173 @@
+Debian
+======
+
+(Tested on Ubuntu 12.04, 14.04, 16.04, 17.10, 18.04, Debian 8 and 9)
+
+.. note::
+
+   If you try to build for a different distro, then it will most likely fail
+   because of the missing backport. See :ref:`deb-backports` about adding a new
+   backport.
+
+1. Install build dependencies for your platform as outlined in :ref:`building`.
+
+2. Install the following additional packages:
+
+   - on Ubuntu 12.04, 14.04, 16.04, 17.10, Debian 8 and 9:
+
+   .. code-block:: shell
+
+      apt-get install realpath equivs groff fakeroot debhelper devscripts
+
+   - on Ubuntu 18.04: (realpath is now part of preinstalled by coreutils)
+
+   .. code-block:: shell
+
+      apt-get install equivs groff fakeroot debhelper devscripts
+
+3. Checkout FRR under a **unprivileged** user account:
+
+   .. code-block:: shell
+
+      git clone https://github.com/frrouting/frr.git frr
+      cd frr
+
+   If you wish to build a package for a branch other than master:
+
+   .. code-block:: shell
+
+      git checkout <branch>
+
+4. Run ``bootstrap.sh`` and make a dist tarball:
+
+   .. code-block:: shell
+
+      ./bootstrap.sh
+      ./configure --with-pkg-extra-version=-MyDebPkgVersion
+      make dist
+
+   .. note::
+
+      Configure parameters are not important for the Debian Package building -
+      except the `with-pkg-extra-version` if you want to give the Debian
+      package a specific name to mark your own unoffical build.
+
+5. Edit :file:`debianpkg/rules` and set the configuration as needed.
+
+   Look for section ``dh_auto_configure`` to modify the configure options as
+   needed. Options might be different between the top-level ``rules``` and
+   :file:`backports/XXXX/debian/rules`. Please adjust as needed on all files.
+
+6. Create backports debian sources
+
+   Rename the :file:`debianpkg` directory to :file:`debian` and create the
+   backports (Debian requires to not ship a :file:`debian` directory inside the
+   source directory to avoid build conflicts with the reserved ``debian``
+   subdirectory name during the build):
+
+   .. code-block:: shell
+
+      mv debianpkg debian
+      make -f debian/rules backports
+
+   This will create a :file:`frr_*.orig.tar.gz` with the source (same as the
+   dist tarball), as well as multiple :file:`frr_*.debian.tar.xz` and
+   :file:`frr_*.dsc` corresponding to each distribution for which a backport is
+   available.
+
+7. Create a new directory to build the package and populate with package
+   source.
+
+   .. code-block:: shell
+
+      mkdir frrpkg
+      cd frrpkg
+      tar xf ~/frr/frr_*.orig.tar.gz
+      cd frr*
+      . /etc/os-release
+      tar xf ~/frr/frr_*${ID}${VERSION_ID}*.debian.tar.xz
+
+8. Build Debian package dependencies and install them as needed.
+
+   .. code-block:: shell
+
+      sudo mk-build-deps --install debian/control
+
+9. Build Debian Package
+
+   Building with standard options:
+
+   .. code-block:: shell
+
+      debuild -b -uc -us
+
+   Or change some options (see `rules` file for available options):
+
+   .. code-block:: shell
+
+      debuild --set-envvar=WANT_BGP_VNC=1 --set-envvar=WANT_CUMULUS_MODE=1 -b -uc -us
+
+   To build with RPKI:
+
+   - Download the librtr packages from
+     https://ci1.netdef.org/browse/RPKI-RTRLIB/latestSuccessful/artifact
+
+   - install librtr-dev on the build server
+
+   Then build with:
+
+   .. code-block:: shell
+
+      debuild --set-envvar=WANT_RPKI=1 -b -uc -us
+
+   RPKI packages have an additonal dependency of ``librtr0`` which can be found
+   at the same URL.
+
+10. Done!
+
+If all worked correctly, then you should end up with the Debian packages under
+:file:`frrpkg`. If distributed, please make sure you distribute it together
+with the sources (``frr_*.orig.tar.gz``, ``frr_*.debian.tar.xz`` and
+``frr_*.dsc``)
+
+.. _deb-backports:
+
+Debian Backports
+----------------
+
+The :file:`debianpkg/backports` directory contains the Debian directories for
+backports to other Debian platforms.  These are built via the ``3.0 (custom)``
+source format, which allows one to build a source package directly out of
+tarballs (e.g. an orig.tar.gz tarball and a debian.tar.gz file), at which point
+the format can be changed to a real format (e.g. ``3.0 (quilt)``).
+
+Source packages are assembled via targets of the same name as the system to
+which the backport is done (e.g. ``precise``), included in :file:`debian/rules`.
+
+To create a new Debian backport:
+
+- Add its name to ``KNOWN_BACKPORTS``, defined in :file:`debian/rules`.
+- Create a directory of the same name in :file:`debian/backports`.
+- Add the files ``exclude``, ``versionext``, and ``debian/source/format`` under
+  this directory.
+
+For the last point, these files should contain the following:
+
+``exclude``
+   Contains whitespace-separated paths (relative to the root of the source dir)
+   that should be excluded from the source package (e.g.
+   :file:`debian/patches`).
+
+``versionext``
+   Contains the suffix added to the version number for this backport's build.
+   Distributions often have guidelines for what this should be. If left empty,
+   no new :file:`debian/changelog` entry is created.
+
+``debian/source/format``
+   Contains the source format of the resulting source package.  As of of the
+   writing of this document the only supported format is ``3.0 (quilt)``.
+
+- Add appropriate files under the :file:`debian/` subdirectory.  These will be
+  included in the source package, overriding any top-level :file:`debian/`
+  files with equivalent paths.
+
diff -urpN frr-frr-5.0.1/doc/developer/packaging.rst frr-frr-6.0/doc/developer/packaging.rst
--- frr-frr-5.0.1/doc/developer/packaging.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/packaging.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,8 @@
+*********
+Packaging
+*********
+
+.. toctree::
+   :maxdepth: 2
+
+   packaging-debian
diff -urpN frr-frr-5.0.1/doc/developer/process-architecture.rst frr-frr-6.0/doc/developer/process-architecture.rst
--- frr-frr-5.0.1/doc/developer/process-architecture.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/developer/process-architecture.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,320 @@
+.. _process-architecture:
+
+Process Architecture
+====================
+
+FRR inherited its overall design architecture from Quagga. The chosen model for
+Quagga is that of a suite of independent daemons that do IPC via Unix domain
+sockets. Within each daemon, the architecture follows the event-driven model.
+FRR has inherited this model as well. As FRR is deployed at larger scales and
+gains ever more features, each adding to the overall processing workload, we
+are approaching the saturation point for a single thread per daemon. In light
+of this, there are ongoing efforts to introduce multithreading to various
+components of FRR. This document aims to describe the current design choices
+and overall model for integrating the event-driven and multithreaded
+architectures into a cohesive whole.
+
+Terminology
+-----------
+Because this document describes the architecture for true kernel threads as
+well as the event system, a digression on terminology is in order here.
+
+Historically Quagga's event system was viewed as an implementation of userspace
+threading. Because of this design choice, the names for various datastructures
+within the event system are variations on the term "thread". The primary
+context datastructure in this system is called a "threadmaster". What would
+today be called an 'event' or 'task' in systems such as libevent are called
+"threads" and the datastructure for them is ``struct thread``. To add to the
+confusion, these "threads" have various types, one of which is "event". To
+hopefully avoid some of this confusion, this document refers to these "threads"
+as a 'task' except where the datastructures are explicitly named. When they are
+explicitly named, they will be formatted ``like this`` to differentiate from
+the conceptual names. When speaking of kernel threads, the term used will be
+"pthread" since FRR's kernel threading implementation is POSIX threads.
+
+.. This should be broken into its document under :ref:`libfrr`
+.. _event-architecture:
+
+Event Architecture
+------------------
+This section presents a brief overview of the event model as currently
+implemented in FRR. This doc should be expanded and broken off into its own
+section. For now it provides basic information necessary to understand the
+interplay between the event system and kernel threads.
+
+The core event system is implemented in :file:`lib/thread.[ch]`. The primary
+structure is ``struct thread_master``, hereafter referred to as a
+``threadmaster``. A ``threadmaster`` is a global state object, or context, that
+holds all the tasks currently pending execution as well as statistics on tasks
+that have already executed. The event system is driven by adding tasks to this
+data structure and then calling a function to retrieve the next task to
+execute. At initialization, a daemon will typically create one
+``threadmaster``, add a small set of initial tasks, and then run a loop to
+fetch each task and execute it.
+
+These tasks have various types corresponding to their general action. The types
+are given by integer macros in :file:`thread.h` and are:
+
+``THREAD_READ``
+   Task which waits for a file descriptor to become ready for reading and then
+   executes.
+
+``THREAD_WRITE``
+   Task which waits for a file descriptor to become ready for writing and then
+   executes.
+
+``THREAD_TIMER``
+   Task which executes after a certain amount of time has passed since it was
+   scheduled.
+
+``THREAD_EVENT``
+   Generic task that executes with high priority and carries an arbitrary
+   integer indicating the event type to its handler. These are commonly used to
+   implement the finite state machines typically found in routing protocols.
+
+``THREAD_READY``
+   Type used internally for tasks on the ready queue.
+
+``THREAD_UNUSED``
+   Type used internally for ``struct thread`` objects that aren't being used.
+   The event system pools ``struct thread`` to avoid heap allocations; this is
+   the type they have when they're in the pool.
+
+``THREAD_EXECUTE``
+   Just before a task is run its type is changed to this. This is used to show
+   ``X`` as the type in the output of :clicmd:`show thread cpu`.
+
+The programmer never has to work with these types explicitly. Each type of task
+is created and queued via special-purpose functions (actually macros, but
+irrelevant for the time being) for the specific type. For example, to add a
+``THREAD_READ`` task, you would call
+
+::
+
+   thread_add_read(struct thread_master *master, int (*handler)(struct thread *), void *arg, int fd, struct thread **ref);
+
+The ``struct thread`` is then created and added to the appropriate internal
+datastructure within the ``threadmaster``.
+
+The Event Loop
+^^^^^^^^^^^^^^
+To use the event system, after creating a ``threadmaster`` the program adds an
+initial set of tasks. As these tasks execute, they add more tasks that execute
+at some point in the future. This sequence of tasks drives the lifecycle of the
+program. When no more tasks are available, the program dies. Typically at
+startup the first task added is an I/O task for VTYSH as well as any network
+sockets needed for peerings or IPC.
+
+To retrieve the next task to run the program calls ``thread_fetch()``.
+``thread_fetch()`` internally computes which task to execute next based on
+rudimentary priority logic. Events (type ``THREAD_EVENT``) execute with the
+highest priority, followed by expired timers and finally I/O tasks (type
+``THREAD_READ`` and ``THREAD_WRITE``). When scheduling a task a function and an
+arbitrary argument are provided. The task returned from ``thread_fetch()`` is
+then executed with ``thread_call()``.
+
+The following diagram illustrates a simplified version of this infrastructure.
+
+.. todo: replace these with SVG
+.. figure:: ../figures/threadmaster-single.png
+   :align: center
+   
+   Lifecycle of a program using a single threadmaster.
+
+The series of "task" boxes represents the current ready task queue. The various
+other queues for other types are not shown. The fetch-execute loop is
+illustrated at the bottom.
+
+Mapping the general names used in the figure to specific FRR functions:
+
+- ``task`` is ``struct thread *``
+- ``fetch`` is ``thread_fetch()``
+- ``exec()`` is ``thread_call``
+- ``cancel()`` is ``thread_cancel()``
+- ``schedule()`` is any of the various task-specific ``thread_add_*`` functions
+
+Adding tasks is done with various task-specific function-like macros. These
+macros wrap underlying functions in :file:`thread.c` to provide additional
+information added at compile time, such as the line number the task was
+scheduled from, that can be accessed at runtime for debugging, logging and
+informational purposes. Each task type has its own specific scheduling function
+that follow the naming convention ``thread_add_<type>``; see :file:`thread.h`
+for details.
+
+There are some gotchas to keep in mind:
+
+- I/O tasks are keyed off the file descriptor associated with the I/O
+  operation. This means that for any given file descriptor, only one of each
+  type of I/O task (``THREAD_READ`` and ``THREAD_WRITE``) can be scheduled. For
+  example, scheduling two write tasks one after the other will overwrite the
+  first task with the second, resulting in total loss of the first task and
+  difficult bugs.
+
+- Timer tasks are only as accurate as the monotonic clock provided by the
+  underlying operating system.
+
+- Memory management of the arbitrary handler argument passed in the schedule
+  call is the responsibility of the caller.
+
+
+Kernel Thread Architecture
+--------------------------
+Efforts have begun to introduce kernel threads into FRR to improve performance
+and stability. Naturally a kernel thread architecture has long been seen as
+orthogonal to an event-driven architecture, and the two do have significant
+overlap in terms of design choices. Since the event model is tightly integrated
+into FRR, careful thought has been put into how pthreads are introduced, what
+role they fill, and how they will interoperate with the event model.
+
+Design Overview
+^^^^^^^^^^^^^^^
+Each kernel thread behaves as a lightweight process within FRR, sharing the
+same process memory space. On the other hand, the event system is designed to
+run in a single process and drive serial execution of a set of tasks. With this
+consideration, a natural choice is to implement the event system within each
+kernel thread. This allows us to leverage the event-driven execution model with
+the currently existing task and context primitives. In this way the familiar
+execution model of FRR gains the ability to execute tasks simultaneously while
+preserving the existing model for concurrency.
+
+The following figure illustrates the architecture with multiple pthreads, each
+running their own ``threadmaster``-based event loop.
+
+.. todo: replace these with SVG
+.. figure:: ../figures/threadmaster-multiple.png
+   :align: center
+   
+   Lifecycle of a program using multiple pthreads, each running their own
+   ``threadmaster``
+
+Each roundrect represents a single pthread running the same event loop
+described under :ref:`event-architecture`. Note the arrow from the ``exec()``
+box on the right to the ``schedule()`` box in the middle pthread. This
+illustrates code running in one pthread scheduling a task onto another
+pthread's threadmaster. A global lock for each ``threadmaster`` is used to
+synchronize these operations. The pthread names are examples.
+
+
+.. This should be broken into its document under :ref:`libfrr`
+.. _kernel-thread-wrapper:
+
+Kernel Thread Wrapper
+^^^^^^^^^^^^^^^^^^^^^
+The basis for the integration of pthreads and the event system is a lightweight
+wrapper for both systems implemented in :file:`lib/frr_pthread.[ch]`. The
+header provides a core datastructure, ``struct frr_pthread``, that encapsulates
+structures from both POSIX threads and :file:`thread.[ch]`. In particular, this
+datastructure has a pointer to a ``threadmaster`` that runs within the pthread.
+It also has fields for a name as well as start and stop functions that have
+signatures similar to the POSIX arguments for ``pthread_create()``.
+
+Calling ``frr_pthread_new()`` creates and registers a new ``frr_pthread``. The
+returned structure has a pre-initialized ``threadmaster``, and its ``start``
+and ``stop`` functions are initialized to defaults that will run a basic event
+loop with the given threadmaster. Calling ``frr_pthread_run`` starts the thread
+with the ``start`` function. From there, the model is the same as the regular
+event model. To schedule tasks on a particular pthread, simply use the regular
+:file:`thread.c` functions as usual and provide the ``threadmaster`` pointed to
+from the ``frr_pthread``. As part of implementing the wrapper, the
+:file:`thread.c` functions were made thread-safe. Consequently, it is safe to
+schedule events on a ``threadmaster`` belonging both to the calling thread as
+well as *any other pthread*. This serves as the basis for inter-thread
+communication and boils down to a slightly more complicated method of message
+passing, where the messages are the regular task events as used in the
+event-driven model. The only difference is thread cancellation, which requires
+calling ``thread_cancel_async()`` instead of ``thread_cancel`` to cancel a task
+currently scheduled on a ``threadmaster`` belonging to a different pthread.
+This is necessary to avoid race conditions in the specific case where one
+pthread wants to guarantee that a task on another pthread is cancelled before
+proceeding.
+
+In addition, the existing commands to show statistics and other information for
+tasks within the event driven model have been expanded to handle multiple
+pthreads; running :clicmd:`show thread cpu` will display the usual event
+breakdown, but it will do so for each pthread running in the program. For
+example, :ref:`bgpd` runs a dedicated I/O pthread and shows the following
+output for :clicmd:`show thread cpu`:
+
+::
+
+   frr# show thread cpu
+
+   Thread statistics for bgpd:
+
+   Showing statistics for pthread main
+   ------------------------------------
+                         CPU (user+system): Real (wall-clock):
+   Active   Runtime(ms)   Invoked Avg uSec Max uSecs Avg uSec Max uSecs  Type  Thread
+       0       1389.000        10   138900    248000   135549    255349   T   subgroup_coalesce_timer
+       0          0.000         1        0         0       18        18   T   bgp_startup_timer_expire
+       0        850.000        18    47222    222000    47795    233814   T   work_queue_run
+       0          0.000        10        0         0        6        14   T   update_subgroup_merge_check_thread_cb
+       0          0.000         8        0         0      117       160  W    zclient_flush_data
+       2          2.000         1     2000      2000      831       831 R     bgp_accept
+       0          1.000         1     1000      1000     2832      2832    E  zclient_connect
+       1      42082.000    240574      174     37000      178     72810 R     vtysh_read
+       1        152.000      1885       80      2000       96      6292 R     zclient_read
+       0     549346.000   2997298      183      7000      153     20242    E  bgp_event
+       0       2120.000       300     7066     14000     6813     22046   T   (bgp_holdtime_timer)
+       0          0.000         2        0         0       57        59   T   update_group_refresh_default_originate_route_map
+       0         90.000         1    90000     90000    73729     73729   T   bgp_route_map_update_timer
+       0       1417.000      9147      154     48000      132     61998   T   bgp_process_packet
+     300      71807.000   2995200       23      3000       24     11066   T   (bgp_connect_timer)
+       0       1894.000     12713      148     45000      112     33606   T   (bgp_generate_updgrp_packets)
+       0          0.000         1        0         0      105       105  W    vtysh_write
+       0         52.000       599       86      2000      138      6992   T   (bgp_start_timer)
+       1          1.000         8      125      1000      164       593 R     vtysh_accept
+       0         15.000       600       25      2000       15       153   T   (bgp_routeadv_timer)
+       0         11.000       299       36      3000       53      3128 RW    bgp_connect_check
+
+
+   Showing statistics for pthread BGP I/O thread
+   ----------------------------------------------
+                         CPU (user+system): Real (wall-clock):
+   Active   Runtime(ms)   Invoked Avg uSec Max uSecs Avg uSec Max uSecs  Type  Thread
+       0       1611.000      9296      173     13000      188     13685 R     bgp_process_reads
+       0       2995.000     11753      254     26000      182     29355  W    bgp_process_writes
+
+
+   Showing statistics for pthread BGP Keepalives thread
+   -----------------------------------------------------
+                         CPU (user+system): Real (wall-clock):
+   Active   Runtime(ms)   Invoked Avg uSec Max uSecs Avg uSec Max uSecs  Type  Thread
+   No data to display yet.
+
+Attentive readers will notice that there is a third thread, the Keepalives
+thread. This thread is responsible for -- surprise -- generating keepalives for
+peers. However, there are no statistics showing for that thread. Although the
+pthread uses the ``frr_pthread`` wrapper, it opts not to use the embedded
+``threadmaster`` facilities. Instead it replaces the ``start`` and ``stop``
+functions with custom functions. This was done because the ``threadmaster``
+facilities introduce a small but significant amount of overhead relative to the
+pthread's task. In this case since the pthread does not need the event-driven
+model and does not need to receive tasks from other pthreads, it is simpler and
+more efficient to implement it outside of the provided event facilities.  The
+point to take away from this example is that while the facilities to make using
+pthreads within FRR easy are already implemented, the wrapper is flexible and
+allows usage of other models while still integrating with the rest of the FRR
+core infrastructure. Starting and stopping this pthread works the same as it
+does for any other ``frr_pthread``; the only difference is that event
+statistics are not collected for it, because there are no events.
+
+Notes on Design and Documentation
+---------------------------------
+Because of the choice to embed the existing event system into each pthread
+within FRR, at this time there is not integrated support for other models of
+pthread use such as divide and conquer. Similarly, there is no explicit support
+for thread pooling or similar higher level constructs. The currently existing
+infrastructure is designed around the concept of long-running worker threads
+responsible for specific jobs within each daemon. This is not to say that
+divide and conquer, thread pooling, etc. could not be implemented in the
+future. However, designs in this direction must be very careful to take into
+account the existing codebase. Introducing kernel threads into programs that
+have been written under the assumption of a single thread of execution must be
+done very carefully to avoid insidious errors and to ensure the program remains
+understandable and maintainable.
+
+In keeping with these goals, future work on kernel threading should be
+extensively documented here and FRR developers should be very careful with
+their design choices, as poor choices tightly integrated can prove to be
+catastrophic for development efforts in the future.
diff -urpN frr-frr-5.0.1/doc/developer/workflow.rst frr-frr-6.0/doc/developer/workflow.rst
--- frr-frr-5.0.1/doc/developer/workflow.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/workflow.rst	2018-10-08 14:32:57.000000000 +0200
@@ -4,6 +4,8 @@
 Process & Workflow
 *******************
 
+.. highlight:: none
+
 FRR is a large project developed by many different groups. This section
 documents standards for code style & quality, commit messages, pull requests
 and best practices that all contributors are asked to follow.
@@ -35,43 +37,66 @@ community. Italicized lists are private.
 +----------------------------------+--------------------------------+
 
 The Development list is used to discuss and document general issues related to
-project development and governance. The public Slack instance,
-frrouting.slack.com, and weekly technical meetings provide a higher bandwidth
-channel for discussions.  The results of such discussions must be reflected in
-updates, as appropriate, to code (i.e., merges), `Github issues`_, and for
-governance or process changes, updates to the Development list and either this
-file or information posted at https://frrouting.org/.
+project development and governance. The public
+`Slack instance <https://frrouting.slack.com>`_ and weekly technical meetings
+provide a higher bandwidth channel for discussions.  The results of such
+discussions must be reflected in updates, as appropriate, to code (i.e.,
+merges), `GitHub issues`_, and for governance or process changes, updates to
+the Development list and either this file or information posted at
+https://frrouting.org/.
+
+Development & Release Cycle
+===========================
+
+Development
+-----------
+
+.. figure:: ../figures/git_branches.png
+   :align: center
+   :scale: 55%
+   :alt: Merging Git branches into a central trunk
 
-Release Process & Schedule
-==========================
+   Rough outline of FRR development workflow
 
-FRR employs a <MAJOR>.<MINOR>.<BUGFIX> versioning scheme.
+The master Git for FRR resides on `GitHub`_.
 
-MAJOR
+There is one main branch for development, ``master``. For each major release
+(2.0, 3.0 etc) a new release branch is created based on the master. Significant
+bugfixes should be backported to upcoming and existing release branches no more
+than 1 year old. As a general rule new features are not backported to release
+branches.
+
+Subsequent point releases based on a major branch are handled with git tags.
+
+Releases
+--------
+FRR employs a ``<MAJOR>.<MINOR>.<BUGFIX>`` versioning scheme.
+
+``MAJOR``
    Significant new features or multiple minor features. The addition of a new
    routing protocol or daemon would fall under this class.
 
-MINOR
+``MINOR``
    Small features, e.g. options for automatic BGP shutdown.
 
-BUGFIX
+``BUGFIX``
    Fixes for actual bugs and/or security issues.
 
 We will pull a new development branch for the next release every 4 months.  The
-current schedule is Feb/June/October 1. The decision for a MAJOR/MINOR release
-is made at the time of branch pull based on what has been received the previous
-4 months. The branch name will be dev/MAJOR.MINOR. At this point in time the
-master branch, :file:`configure.ac`, documentation and packaging systems will
-be updated to reflect the next possible release name to allow for easy
-distinguishing. Additionally the new dev branch will have these files updated
-too.
-
-After one month the development branch will be renamed to stable/MAJOR.MINOR.
-This process is not held up unless a crash or security issue has been found and
-needs to be addressed. Issues being fixed will not cause a delay.
+current schedule is Feb/June/October 1. The decision for a ``MAJOR/MINOR``
+release is made at the time of branch pull based on what has been received the
+previous 4 months. The branch name will be ``dev/MAJOR.MINOR``. At this point
+in time the master branch and this new branch, :file:`configure.ac`,
+documentation and packaging systems will be updated to reflect the next
+possible release name to allow for easy distinguishing.
+
+After one month the development branch will be renamed to
+``stable/MAJOR.MINOR``.  This process is not held up unless a crash or security
+issue has been found and needs to be addressed. Issues being fixed will not
+cause a delay.
 
 Bugfix releases are made as needed at 1 month intervals until the next
-MAJOR.MINOR relese branch is pulled. Depending on the severity of the bugs,
+``MAJOR.MINOR`` relese branch is pulled. Depending on the severity of the bugs,
 bugfix releases may occur sooner.
 
 Bugfixes are applied to the two most recent releases. Security fixes are
@@ -79,8 +104,7 @@ backported to all releases less than or
 may also be backported to older releases depending on severity.
 
 Changelog
-=========
-
+---------
 The changelog will be the base for the release notes. A changelog entry for
 your changes is usually not required and will be added based on your commit
 messages by the maintainers. However, you are free to include an update to the
@@ -92,115 +116,26 @@ Submitting Patches and Enhancements
 FRR accepts patches from two sources:
 
 - Email (git format-patch)
-- Github pull request
+- GitHub pull request
 
-Contributors are highly encouraged to use Github's fork-and-pr workflow. It is
-easier for us to review it, test it, try it and discuss it on Github than it is
-via email, thus your patch will get more attention more quickly on Github.
+Contributors are highly encouraged to use GitHub's fork-and-PR workflow. It is
+easier for us to review it, test it, try it and discuss it on GitHub than it is
+via email, thus your patch will get more attention more quickly on GitHub.
 
 The base branch for new contributions and non-critical bug fixes should be
 ``master``. Please ensure your pull request is based on this branch when you
 submit it.
 
-Pre-submission Checklist
-------------------------
-
--  Format code (see `Code Formatting <#developers-guidelines>`__)
--  Verify and acknowledge license (see `License for
-   contributions <#license-for-contributions>`__)
--  Ensure you have properly signed off (see `Signing
-   Off <#signing-off>`__)
--  Test building with various configurations:
-
-   -  ``buildtest.sh``
-
--  Verify building source distribution:
-
-   -  ``make dist`` (and try rebuilding from the resulting tar file)
-
--  Run unit tests:
-
-   -  ``make test``
-
--  Document Regression Runs and plans for continued maintenance of the
-   feature
-
-License for contributions
--------------------------
-
-FRR is under a GPLv2 or later license. Any code submitted must
-be released under the same license (preferred) or any license which
-allows redistribution under this GPLv2 license (eg MIT License).
-
-Signing Off
------------
-
-Code submitted to FRR must be signed off. We have the same
-requirements for using the signed-off-by process as the Linux kernel. In
-short, you must include a signed-off-by tag in every patch.
-
-``Signed-off-by:`` this is a developer's certification that he or she
-has the right to submit the patch for inclusion into the project. It is
-an agreement to the Developer's Certificate of Origin (below). Code
-without a proper signoff can not and will not be merged.
-
-If you are unfamiliar with this process, you should read the `official
-policy at
-kernel.org <https://www.kernel.org/doc/html/latest/process/submitting-patches.html>`__
-and you might find this article about `participating in the Linux
-community on the Linux Foundation
-website <http://www.linuxfoundation.org/content/how-participate-linux-community-0>`__
-to be a helpful resource.
-
-In short, when you sign off on a commit, you assert your agreement to
-all of the following:
-
-::
-
-    Developer's Certificate of Origin 1.1
-
-    By making a contribution to this project, I certify that:
-
-    (a) The contribution was created in whole or in part by me and I
-        have the right to submit it under the open source license
-        indicated in the file; or
-
-    (b) The contribution is based upon previous work that, to the best
-        of my knowledge, is covered under an appropriate open source
-        license and I have the right under that license to submit that
-        work with modifications, whether created in whole or in part by
-        me, under the same open source license (unless I am permitted to
-        submit under a different license), as indicated in the file; or
-
-    (c) The contribution was provided directly to me by some other
-        person who certified (a), (b) or (c) and I have not modified it.
-
-    (d) I understand and agree that this project and the contribution
-        are public and that a record of the contribution (including all
-        personal information I submit with it, including my sign-off) is
-        maintained indefinitely and may be redistributed consistent with
-        this project or the open source license(s) involved.
-
-What do I submit my changes against?
-------------------------------------
-
-We've documented where we would like to have the different fixes applied
-at
-https://github.com/FRR/frr/wiki/Where-Do-I-create-a-Pull-Request-against%3F
-If you are unsure where your submission goes, look at that document or
-ask a project maintainer.
-
-Github pull requests
+GitHub Pull Requests
 --------------------
 
-The preferred method of submitting changes is a Github pull request.
-Code submitted by pull request will be automatically tested by one or
-more CI systems. Once the automated tests succeed, other developers will
-review your code for quality and correctness. After any concerns are
-resolved, your code will be merged into the branch it was submitted
-against.
+The preferred method of submitting changes is a GitHub pull request.  Code
+submitted by pull request will be automatically tested by one or more CI
+systems. Once the automated tests succeed, other developers will review your
+code for quality and correctness. After any concerns are resolved, your code
+will be merged into the branch it was submitted against.
 
-Patch submission via mailing list
+Patch Submission via Mailing List
 ---------------------------------
 
 As an alternative submission method, a patch can be mailed to the
@@ -209,32 +144,105 @@ picked up by Patchwork and tested agains
 
 The recommended way to send the patch (or series of NN patches) to the
 list is by using ``git send-email`` as follows (assuming they are the N
-most recent commit(s) in your git history:
-
-::
+most recent commit(s) in your git history)::
 
     git send-email -NN --annotate --to=dev@lists.frrouting.org
 
 If your commits do not already contain a ``Signed-off-by`` line, then
 use the following command to add it (after making sure you agree to the
-Developer Certificate of Origin as outlined above):
-
-::
+Developer Certificate of Origin as outlined above)::
 
     git send-email -NN --annotate --signoff --to=dev@lists.frrouting.org
 
-Submitting multi-commit patches as a Github pull request is **strongly
-encouraged** and increases the probability of your patch getting
-reviewed and merged in a timely manner.
+Submitting multi-commit patches as a GitHub pull request is **strongly
+encouraged** and increases the probability of your patch getting reviewed and
+merged in a timely manner.
+
+.. _license-for-contributions:
 
-After submitting your changes
+License for Contributions
+-------------------------
+FRR is under a GPLv2 or later license. Any code submitted must be released
+under the same license (preferred) or any license which allows redistribution
+under this GPLv2 license (eg MIT License).
+
+Pre-submission Checklist
+------------------------
+-  Format code (see `Code Formatting <#code-formatting>`__)
+-  Verify and acknowledge license (see :ref:`license-for-contributions`)
+-  Ensure you have properly signed off (see :ref:`signing-off`)
+-  Test building with various configurations:
+
+   -  ``buildtest.sh``
+
+-  Verify building source distribution:
+
+   -  ``make dist`` (and try rebuilding from the resulting tar file)
+
+-  Run unit tests:
+
+   -  ``make test``
+
+- In the case of a major new feature or other significant change, document
+  plans for continued maintenance of the feature
+
+.. _signing-off:
+
+Signing Off
+-----------
+Code submitted to FRR must be signed off. We have the same requirements for
+using the signed-off-by process as the Linux kernel. In short, you must include
+a ``Signed-off-by`` tag in every patch.
+
+``Signed-off-by`` is a developer's certification that they have the right to
+submit the patch for inclusion into the project. It is an agreement to the
+:ref:`Developer's Certificate of Origin <developers-certificate-of-origin>`.
+Code without a proper ``Signed-off-by`` line cannot and will not be merged.
+
+If you are unfamiliar with this process, you should read the
+`official policy at kernel.org <https://www.kernel.org/doc/html/latest/process/submitting-patches.html>`_.
+You might also find
+`this article <http://www.linuxfoundation.org/content/how-participate-linux-community-0>`_
+about participating in the Linux community on the Linux Foundation website to
+be a helpful resource.
+
+.. _developers-certificate-of-origin:
+
+In short, when you sign off on a commit, you assert your agreement to all of
+the following::
+
+   Developer's Certificate of Origin 1.1
+
+   By making a contribution to this project, I certify that:
+
+   (a) The contribution was created in whole or in part by me and I
+       have the right to submit it under the open source license
+       indicated in the file; or
+
+   (b) The contribution is based upon previous work that, to the best
+       of my knowledge, is covered under an appropriate open source
+       license and I have the right under that license to submit that
+       work with modifications, whether created in whole or in part by
+       me, under the same open source license (unless I am permitted to
+       submit under a different license), as indicated in the file; or
+
+   (c) The contribution was provided directly to me by some other
+       person who certified (a), (b) or (c) and I have not modified it.
+
+   (d) I understand and agree that this project and the contribution
+       are public and that a record of the contribution (including all
+       personal information I submit with it, including my sign-off) is
+       maintained indefinitely and may be redistributed consistent with
+       this project or the open source license(s) involved.
+
+After Submitting Your Changes
 -----------------------------
 
--  Watch for Continuous Integration (CI) Test results
+-  Watch for Continuous Integration (CI) test results
 
    -  You should automatically receive an email with the test results
       within less than 2 hrs of the submission. If you dont get the
-      email, then check status on the Github pull request.
+      email, then check status on the GitHub pull request.
    -  Please notify the development mailing list if you think something
       doesn't work.
 
@@ -273,22 +281,6 @@ After submitting your changes
    community members.
 -  Your submission is done once it is merged to the master branch.
 
-Git Structure
-=============
-
-.. figure:: ../figures/git_branches.png
-   :align: center
-   :scale: 55%
-   :alt: Merging Git branches into a central trunk
-
-   Rough outline of FRR development workflow
-
-The master Git for FRR resides on `GitHub`_.
-
-There is one main branch for development, ``master``. For each major release
-(2.0, 3.0 etc) a new release branch is created based on the master. Subsequent
-point releases based on a major branch are marked by tagging.
-
 Programming Languages, Tools and Libraries
 ==========================================
 
@@ -308,6 +300,36 @@ Documentation should be written in reStr
 utilized but pure ReST is preferred where possible. See
 :ref:`documentation`.
 
+Code Reviews
+============
+
+Code quality is paramount for any large program. Consequently we require
+reviews of all submitted patches by at least one person other than the
+submitter before the patch is merged.
+
+Because of the nature of the software, FRR's maintainer list (i.e. those with
+commit permissions) tends to contain employees / members of various
+organizations. In order to prevent conflicts of interest, we use an honor
+system in which submissions from an individual representing one company should
+be merged by someone unaffiliated with that company.
+
+Guidelines for code review
+""""""""""""""""""""""""""
+
+- As a rule of thumb, the depth of the review should be proportional to the
+  scope and / or impact of the patch.
+
+- Anyone may review a patch.
+
+- When using GitHub reviews, marking "Approve" on a code review indicates
+  willingness to merge the PR.
+
+- For individuals with merge rights, marking "Changes requested" is equivalent
+  to a NAK.
+
+- For a PR you marked with "Changes requested", please respond to updates in a
+  timely manner to avoid impeding the flow of development.
+
 
 Coding Practices & Style
 ========================
@@ -316,30 +338,33 @@ Commit messages
 ---------------
 
 Commit messages should be formatted in the same way as Linux kernel
-commit messages. The format is roughly
-
-::
+commit messages. The format is roughly::
 
     dir: short summary
 
     extended summary
 
-``dir`` should be the top level source directory under which the change
-was made. For example, a change in bgpd/rfapi would be formatted as:::
+``dir`` should be the top level source directory under which the change was
+made. For example, a change in :file:`bgpd/rfapi` would be formatted as::
 
    bgpd: short summary
 
-The first line should be no longer than 50 characters. Subsequent lines
-should be wrapped to 72 characters.
+   ...
+
+The first line should be no longer than 50 characters. Subsequent lines should
+be wrapped to 72 characters.
+
+You must also sign off on your commit.
+
+.. seealso:: :ref:`signing-off`
 
-Source file header
+Source File Header
 ------------------
 
-New files need to have a Copyright header (see `License for
-contributions <#license-for-contributions>`__ above) added to the file.
-Preferred form of the header is as follows:
+New files must have a copyright header (see :ref:`license-for-contributions`
+above) added to the file. The header should be:
 
-::
+.. code-block:: c
 
     /*
      * Title/Function of file
@@ -362,25 +387,34 @@ Preferred form of the header is as follo
 
     #include <zebra.h>
 
-Adding copyright claims to existing files
+Please copy-paste this header verbatim. In particular:
+
+- Do not replace "This program" with "FRR"
+- Do not change the address of the FSF
+
+Adding Copyright Claims to Existing Files
 -----------------------------------------
 
-When adding copyright claims for modifications to an existing file,
-please preface the claim with "Portions: " on a line before it and
-indent the "Copyright ..." string. If such a case already exists, add
-your indented claim immediately after. E.g.:
+When adding copyright claims for modifications to an existing file, please
+add a ``Portions:`` section as shown below. If this section already exists, add
+your new claim at the end of the list.
 
-::
+.. code-block:: c
 
-    Portions:
-      Copyright (C) 2010 Entity A ....
-      Copyright (C) 2016 Your name [optional brief change description]
+    /*
+     * Title/Function of file
+     * Copyright (C) YEAR  Authors Name
+     * Portions:
+     *     Copyright (C) 2010 Entity A ....
+     *     Copyright (C) 2016 Your name [optional brief change description]
+     * ...
+     */
 
-Code formatting
+Code Formatting
 ---------------
 
-FRR uses Linux kernel style except where noted below. Code which does
-not comply with these style guidelines will not be accepted.
+FRR uses Linux kernel style except where noted below. Code which does not
+comply with these style guidelines will not be accepted.
 
 The project provides multiple tools to allow you to correctly style your code
 as painlessly as possible, primarily built around ``clang-format``.
@@ -451,11 +485,9 @@ checkpatch.sh
    submission is highly recommended. The CI system runs this script as well and
    will comment on the PR with the results if style errors are found.
 
-   It is run like this:
-
-   ::
+   It is run like this::
 
-      checkpatch.sh <patch> <tree>
+      ./checkpatch.sh <patch> <tree>
 
    Reports are generated on ``stderr`` and the exit code indicates whether
    issues were found (2, 1) or not (0).
@@ -635,20 +667,19 @@ is preferred to
     frobnicate ();
     #endif /* SOME_SYMBOL */
 
-Note that the former approach requires ensuring that ``SOME_SYMBOL``
-will be defined (watch your ``AC_DEFINE``\ s).
+Note that the former approach requires ensuring that ``SOME_SYMBOL`` will be
+defined (watch your ``AC_DEFINE``\ s).
 
 Debug-guards in code
 --------------------
 
-Debugging statements are an important methodology to allow developers to
-fix issues found in the code after it has been released. The caveat here
-is that the developer must remember that people will be using the code
-at scale and in ways that can be unexpected for the original
-implementor. As such debugs **MUST** be guarded in such a way that they
-can be turned off. FRR has the ability to turn on/off debugs from the
-CLI and it is expected that the developer will use this convention to
-allow control of their debugs.
+Debugging statements are an important methodology to allow developers to fix
+issues found in the code after it has been released. The caveat here is that
+the developer must remember that people will be using the code at scale and in
+ways that can be unexpected for the original implementor. As such debugs
+**MUST** be guarded in such a way that they can be turned off. FRR has the
+ability to turn on/off debugs from the CLI and it is expected that the
+developer will use this convention to allow control of their debugs.
 
 Static Analysis and Sanitizers
 ------------------------------
@@ -704,53 +735,50 @@ members with Coverity access of newly in
 CLI changes
 -----------
 
-CLI's are a complicated ugly beast. Additions or changes to the CLI
-should use a DEFUN to encapsulate one setting as much as is possible.
-Additionally as new DEFUN's are added to the system, documentation
-should be provided for the new commands.
+CLI's are a complicated ugly beast. Additions or changes to the CLI should use
+a DEFUN to encapsulate one setting as much as is possible.  Additionally as new
+DEFUN's are added to the system, documentation should be provided for the new
+commands.
 
 Backwards Compatibility
 -----------------------
 
-As a general principle, changes to CLI and code in the lib/ directory
-should be made in a backwards compatible fashion. This means that
-changes that are purely stylistic in nature should be avoided, e.g.,
-renaming an existing macro or library function name without any
-functional change. When adding new parameters to common functions, it is
-also good to consider if this too should be done in a backward
-compatible fashion, e.g., by preserving the old form in addition to
+As a general principle, changes to CLI and code in the lib/ directory should be
+made in a backwards compatible fashion. This means that changes that are purely
+stylistic in nature should be avoided, e.g., renaming an existing macro or
+library function name without any functional change. When adding new parameters
+to common functions, it is also good to consider if this too should be done in
+a backward compatible fashion, e.g., by preserving the old form in addition to
 adding the new form.
 
-This is not to say that minor or even major functional changes to CLI
-and common code should be avoided, but rather that the benefit gained
-from a change should be weighed against the added cost/complexity to
-existing code. Also, that when making such changes, it is good to
-preserve compatibility when possible to do so without introducing
-maintenance overhead/cost. It is also important to keep in mind,
-existing code includes code that may reside in private repositories (and
-is yet to be submitted) or code that has yet to be migrated from Quagga
-to FRR.
-
-That said, compatibility measures can (and should) be removed when
-either:
-
--  they become a significant burden, e.g. when data structures change
-   and the compatibility measure would need a complex adaptation layer
-   or becomes flat-out impossible
--  some measure of time (dependent on the specific case) has passed, so
-   that the compatibility grace period is considered expired.
-
-In all cases, compatibility pieces should be marked with
-compiler/preprocessor annotations to print warnings at compile time,
-pointing to the appropriate update path. A ``-Werror`` build should fail
-if compatibility bits are used. To avoid compilation issues in released
-code, such compiler/preprocessor annotations must be ignored
-non-development branches. For example:
-
-    #if defined(VERSION_TYPE_DEV) && CONFDATE > 20180403
-    CPP_NOTICE("Use of <XYZ> is deprecated, please use <ABC>")
-    #endif
-
+This is not to say that minor or even major functional changes to CLI and
+common code should be avoided, but rather that the benefit gained from a change
+should be weighed against the added cost/complexity to existing code. Also,
+that when making such changes, it is good to preserve compatibility when
+possible to do so without introducing maintenance overhead/cost. It is also
+important to keep in mind, existing code includes code that may reside in
+private repositories (and is yet to be submitted) or code that has yet to be
+migrated from Quagga to FRR.
+
+That said, compatibility measures can (and should) be removed when either:
+
+-  they become a significant burden, e.g. when data structures change and the
+   compatibility measure would need a complex adaptation layer or becomes
+   flat-out impossible
+-  some measure of time (dependent on the specific case) has passed, so that
+   the compatibility grace period is considered expired.
+
+In all cases, compatibility pieces should be marked with compiler/preprocessor
+annotations to print warnings at compile time, pointing to the appropriate
+update path. A ``-Werror`` build should fail if compatibility bits are used. To
+avoid compilation issues in released code, such compiler/preprocessor
+annotations must be ignored non-development branches. For example:
+
+.. code-block:: c
+
+   #if CONFDATE > 20180403
+   CPP_NOTICE("Use of <XYZ> is deprecated, please use <ABC>")
+   #endif
 
 Preferably, the shell script :file:`tools/fixup-deprecated.py` will be
 updated along with making non-backwards compatible code changes, or an
@@ -762,8 +790,8 @@ changes, just internal code, macros and
 Miscellaneous
 -------------
 
-When in doubt, follow the guidelines in the Linux kernel style guide, or
-ask on the development mailing list / public Slack instance.
+When in doubt, follow the guidelines in the Linux kernel style guide, or ask on
+the development mailing list / public Slack instance.
 
 
 .. _documentation:
@@ -859,14 +887,19 @@ Some specific guidelines that contributo
      /*
       * Determines whether or not a string is cool.
       *
-      * @param text - the string to check for coolness
-      * @param is_clccfc - whether capslock is cruise control for cool
-      * @return 7 if the text is cool, 0 otherwise
+      * text
+      *    the string to check for coolness
+      *
+      * is_clccfc
+      *    whether capslock is cruise control for cool
+      *
+      * Returns:
+      *    7 if the text is cool, 0 otherwise
       */
      int check_coolness(const char *text, bool is_clccfc);
 
-  The Javadoc-style annotations are not required, but you should still strive
-  to make it equally clear what parameters and return values are used for.
+  Function comments should make it clear what parameters and return values are
+  used for.
 
 - Static functions should have descriptive comments in the same form as above
   if what they do is not immediately obvious. Use good engineering judgement
diff -urpN frr-frr-5.0.1/doc/developer/zebra.rst frr-frr-6.0/doc/developer/zebra.rst
--- frr-frr-5.0.1/doc/developer/zebra.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/developer/zebra.rst	2018-10-08 14:32:57.000000000 +0200
@@ -102,14 +102,6 @@ Zebra Protocol Commands
 +-----------------------------------+-------+
 | ZEBRA_INTERFACE_DOWN              | 6     |
 +-----------------------------------+-------+
-| ZEBRA_IPV4_ROUTE_ADD              | 7     |
-+-----------------------------------+-------+
-| ZEBRA_IPV4_ROUTE_DELETE           | 8     |
-+-----------------------------------+-------+
-| ZEBRA_IPV6_ROUTE_ADD              | 9     |
-+-----------------------------------+-------+
-| ZEBRA_IPV6_ROUTE_DELETE           | 10    |
-+-----------------------------------+-------+
 | ZEBRA_REDISTRIBUTE_ADD            | 11    |
 +-----------------------------------+-------+
 | ZEBRA_REDISTRIBUTE_DELETE         | 12    |
diff -urpN frr-frr-5.0.1/doc/extra/spelling_wordlist.txt frr-frr-6.0/doc/extra/spelling_wordlist.txt
--- frr-frr-5.0.1/doc/extra/spelling_wordlist.txt	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/extra/spelling_wordlist.txt	2018-10-08 14:32:57.000000000 +0200
@@ -83,6 +83,7 @@ IPv
 isis
 isisd
 lan
+ldpd
 le
 libc
 libcap
Binary files frr-frr-5.0.1/doc/figures/threadmaster-multiple.png and frr-frr-6.0/doc/figures/threadmaster-multiple.png differ
Binary files frr-frr-5.0.1/doc/figures/threadmaster-single.png and frr-frr-6.0/doc/figures/threadmaster-single.png differ
diff -urpN frr-frr-5.0.1/doc/figures/threadmaster.svg frr-frr-6.0/doc/figures/threadmaster.svg
--- frr-frr-5.0.1/doc/figures/threadmaster.svg	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/figures/threadmaster.svg	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,42 @@
+<svg width="640" height="480" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
+ <!-- Created with SVG-edit - http://svg-edit.googlecode.com/ -->
+ <g>
+  <title>Layer 1</title>
+  <rect stroke="#000000" id="svg_14" height="209.999998" width="78.999998" y="42.000002" x="44" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="#ffaaaa"/>
+  <rect stroke="#000000" id="svg_7" height="391.000012" width="278.000011" y="20" x="24.999992" fill="#e5e5e5"/>
+  <rect stroke="#000000" id="svg_8" height="371.999978" width="259.000006" y="27.5" x="34.5" fill="#aad4ff"/>
+  <text stroke="#000000" transform="matrix(0.6990958452224731,0,0,0.7454545497894287,7.038336245343089,56.89090812206268) " opacity="0.95" xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" id="svg_19" y="259.756097" x="80.760476" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">I/O</text>
+  <text id="svg_35" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="139.834812" x="60.305235" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task3</text>
+  <text id="svg_36" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="143.062739" x="62.867657" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task3</text>
+  <rect stroke="#000000" id="svg_9" height="196.000002" width="53" y="35" x="44" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="#ffaaaa"/>
+  <text id="svg_40" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="144.681173" x="161.373439" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <rect id="svg_15" stroke="#000000" height="196.000002" width="53" y="35" x="104" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="#ffaaaa"/>
+  <rect id="svg_16" stroke="#000000" height="196.000002" width="53" y="35" x="164" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="#ffaaaa"/>
+  <rect id="svg_17" stroke="#000000" height="196.000002" width="53" y="35" x="225" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="#a2f9a2"/>
+  <text id="svg_20" stroke="#000000" transform="matrix(0.5625633135745076,0,0,0.5774844344081629,24.86726517334988,96.24168390657653) " opacity="0.95" xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="264.951043" x="181.542341" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">Timer</text>
+  <text id="svg_21" stroke="#000000" transform="matrix(0.5749753656942643,0,0,0.6334746061662456,38.254388934566045,86.97425370192815) " opacity="0.95" xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="256.836039" x="263.041264" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">Event</text>
+  <text id="svg_22" stroke="#000000" transform="matrix(0.5985540174236015,0,0,0.6031454293478589,42.9067138136931,90.27170546109113) " opacity="0.95" xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="263.072047" x="346.818415" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">Ready</text>
+  <line id="svg_24" y2="62" x2="278.034186" y1="62" x1="44" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
+  <line id="svg_25" y2="90" x2="278.034186" y1="90" x1="44" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
+  <line id="svg_26" y2="118.5" x2="278.034186" y1="118.5" x1="44" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
+  <rect id="svg_27" height="45" width="182" y="287" x="103" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="#cccccc"/>
+  <rect id="svg_28" height="45" width="182" y="342" x="103" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="#cccccc"/>
+  <text stroke="#000000" transform="matrix(0.791700541973114,0,0,0.7857142686843872,21.471117571927607,58.28571891784668) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" id="svg_31" y="325.818183" x="222.3407" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">thread_fetch()</text>
+  <text stroke="#000000" transform="matrix(0.8357433386864528,0,0,0.7633649135312126,6.654719490831912,79.40761438745744) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" id="svg_32" y="380.181209" x="228.949154" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">thread_call()</text>
+  <text stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" id="svg_33" y="47" x="56" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task1</text>
+  <text style="cursor: move;" id="svg_34" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="94.51867" x="58.592092" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task2</text>
+  <text style="cursor: move;" id="svg_37" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="141.444306" x="58.584825" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task9</text>
+  <text style="cursor: move;" id="svg_38" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="50.812022" x="163.086583" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task4</text>
+  <text style="cursor: move;" id="svg_39" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="92.891296" x="164.799726" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">task7</text>
+  <text id="svg_41" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="138.207438" x="158.803698" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_42" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="54.046518" x="265.881445" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_43" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="96.125793" x="264.168301" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_44" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="143.060369" x="259.02887" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_45" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="50.809651" x="370.383203" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_46" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="99.36266" x="372.096346" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <text id="svg_47" stroke="#000000" transform="matrix(0.5837222373092742,0,0,0.6178813716933291,36.307626092448714,21.493443100305285) " xml:space="preserve" text-anchor="middle" font-family="Monospace" font-size="24" y="141.441935" x="372.096346" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">...</text>
+  <line stroke="#000000" id="svg_54" y2="286.009435" x2="275" y1="230.500001" x1="275" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="none"/>
+  <line stroke="#000000" id="svg_57" y2="278.49643" x2="267.246429" y1="286" x1="275.5" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="none"/>
+  <line id="svg_58" y2="285.754309" x2="274.995691" y1="278.5" x1="282.25" opacity="0.95" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
+ </g>
+</svg>
diff -urpN frr-frr-5.0.1/doc/manpages/.gitignore frr-frr-6.0/doc/manpages/.gitignore
--- frr-frr-5.0.1/doc/manpages/.gitignore	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,2 @@
 /_templates
 /_build
-!/Makefile.in
diff -urpN frr-frr-5.0.1/doc/manpages/Makefile.am frr-frr-6.0/doc/manpages/Makefile.am
--- frr-frr-5.0.1/doc/manpages/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/manpages/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,48 @@
+# This is necessary to support VPATH builds.
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+# This variable is used as the documentation source location in frr-sphinx.mk
+SOURCESDIR = @srcdir@
+
+include @srcdir@/../frr-sphinx.mk
+
+# -----------------------------------------------------------------------------
+# Automake requires that 3rd-party Makefiles recognize these targets.
+# -----------------------------------------------------------------------------
+# install
+# install-data
+# install-exec
+# uninstall
+# install-dvi
+# install-html
+# install-info
+# install-ps
+# install-pdf
+# installdirs
+# check
+# installcheck
+# mostlyclean
+# clean
+# distclean
+# maintainer-clean
+# dvi
+# pdf
+# ps
+# info
+# html
+# tags
+# ctags
+
+# These targets are automatically generated by Sphinx but conflict with
+# implicitly defined Automake rules, so we manually override them to nothing.
+# The other option is deleting the Sphinx-generated rules, which suppresses the
+# warning but kinda screws up the symmetry between Makefiles.
+info: ;
+html: ;
+
+all: man
+
+install-data: man
+
+install: install-data
diff -urpN frr-frr-5.0.1/doc/manpages/Makefile.in frr-frr-6.0/doc/manpages/Makefile.in
--- frr-frr-5.0.1/doc/manpages/Makefile.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-# This is necessary to support VPATH builds.
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-# This variable is used as the documentation source location in frr-sphinx.mk
-SOURCESDIR = @srcdir@
-
-include @srcdir@/../frr-sphinx.mk
-
-# -----------------------------------------------------------------------------
-# Automake requires that 3rd-party Makefiles recognize these targets.
-# -----------------------------------------------------------------------------
-# install
-# install-data
-# install-exec
-# uninstall
-# install-dvi
-# install-html
-# install-info
-# install-ps
-# install-pdf
-# installdirs
-# check
-# installcheck
-# mostlyclean
-# clean
-# distclean
-# maintainer-clean
-# dvi
-# pdf
-# ps
-# info
-# html
-# tags
-# ctags
-
-# ignore these targets
-EMPTY_AUTOMAKE_TARGETS = dvi pdf ps tags ctags distdir installdirs check installcheck install-dvi install-ps install-html install-pdf install-info install-exec
-.PHONY: $(EMPTY_AUTOMAKE_TARGETS)
-$(EMPTY_AUTOMAKE_TARGETS):
-
-# These targets are automatically generated by Sphinx but conflict with
-# implicitly defined Automake rules, so we manually override them to nothing.
-# The other option is deleting the Sphinx-generated rules, which suppresses the
-# warning but kinda screws up the symmetry between Makefiles.
-info: ;
-html: ;
-
-all: man
-
-install-data: man
-
-install: install-data
-
-mostlyclean distclean maintainer-clean: clean
diff -urpN frr-frr-5.0.1/doc/manpages/bfd-options.rst frr-frr-6.0/doc/manpages/bfd-options.rst
--- frr-frr-5.0.1/doc/manpages/bfd-options.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/manpages/bfd-options.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,10 @@
+BFD SOCKET
+----------
+
+The following option controls the BFD daemon control socket location.
+
+.. option:: --bfdctl bfd-control-socket
+
+   Opens the BFD daemon control socket located at the pointed location.
+
+   (default: |INSTALL_PREFIX_STATE|/bfdd.sock)
diff -urpN frr-frr-5.0.1/doc/manpages/bfdd.rst frr-frr-6.0/doc/manpages/bfdd.rst
--- frr-frr-5.0.1/doc/manpages/bfdd.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/manpages/bfdd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,40 @@
+****
+BFDD
+****
+
+.. include:: defines.rst
+.. |DAEMON| replace:: bfdd
+
+SYNOPSIS
+========
+|DAEMON| |synopsis-options-hv|
+
+|DAEMON| |synopsis-options|
+
+DESCRIPTION
+===========
+|DAEMON| is a communication failure detection component that works with
+the FRRouting routing engine.
+
+OPTIONS
+=======
+OPTIONS available for the |DAEMON| command:
+
+.. include:: common-options.rst
+.. include:: bfd-options.rst
+
+FILES
+=====
+
+|INSTALL_PREFIX_SBIN|/|DAEMON|
+   The default location of the |DAEMON| binary.
+
+|INSTALL_PREFIX_ETC|/|DAEMON|.conf
+   The default location of the |DAEMON| config file.
+
+$(PWD)/|DAEMON|.log
+   If the |DAEMON| process is configured to output logs to a file, then you
+   will find this file in the directory where you started |DAEMON|.
+
+.. include:: epilogue.rst
+
diff -urpN frr-frr-5.0.1/doc/manpages/bgpd.rst frr-frr-6.0/doc/manpages/bgpd.rst
--- frr-frr-5.0.1/doc/manpages/bgpd.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/bgpd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -21,13 +21,6 @@ OPTIONS available for the |DAEMON| comma
 
 .. include:: common-options.rst
 
-LABEL MANAGER
--------------
-
-.. option:: -I, --int_num
-
-   Set zclient id. This is required when using Zebra label manager in proxy mode.
-
 FILES
 =====
 
diff -urpN frr-frr-5.0.1/doc/manpages/common-options.rst frr-frr-6.0/doc/manpages/common-options.rst
--- frr-frr-5.0.1/doc/manpages/common-options.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/common-options.rst	2018-10-08 14:32:57.000000000 +0200
@@ -123,8 +123,10 @@ These following options control the daem
       ldpd            2612
       eigrpd          2613
       pbrd            2615
+      staticd         2616
+      bfdd            2617
 
-   Port 2607 is used for ospfd's Opaque LSA API, while port 2600 is used for the (insecure) TCP-ZEBRA interface.
+   Port 2607 is used for ospfd's Opaque LSA API.
 
 .. option:: --vty_socket vty-path
 
@@ -157,10 +159,3 @@ frr supports optional dynamically loadab
 
 The list of loaded modules can be inspected at runtime with the show modules VTY command.
 
-ROUTES
-------
-
-.. option:: -r, --retain
-
-   When the program terminates, retain routes added by the daemon.
-
diff -urpN frr-frr-5.0.1/doc/manpages/conf.py frr-frr-6.0/doc/manpages/conf.py
--- frr-frr-5.0.1/doc/manpages/conf.py	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/conf.py	2018-10-08 14:32:57.000000000 +0200
@@ -324,6 +324,7 @@ man_pages = [
     ('pimd', 'pimd', fwfrr.format("a PIM "), [], 8),
     ('pbrd', 'pbrd', fwfrr.format("a PBR "), [], 8),
     ('sharpd', 'sharpd', fwfrr.format("a SHARP "), [], 8),
+    ('staticd', 'staticd', fwfrr.format("a static route manager "), [], 8),
     ('mtracebis', 'mtracebis', "a multicast trace client", [], 8),
     ('ripd', 'ripd', fwfrr.format("a RIP "), [], 8),
     ('ripngd', 'ripngd', fwfrr.format("a RIPNG "), [], 8),
@@ -331,6 +332,7 @@ man_pages = [
     ('watchfrr', 'watchfrr', 'a program to monitor the status of FRRouting daemons', [], 8),
     ('vtysh', 'vtysh', 'an integrated shell for FRRouting.', [], 1),
     ('frr', 'frr', 'a systemd interaction script', [], 1),
+    ('bfdd', 'bfdd', fwfrr.format("a bfd"), [], 8),
 ]
 
 # -- Options for Texinfo output -------------------------------------------
diff -urpN frr-frr-5.0.1/doc/manpages/defines.rst frr-frr-6.0/doc/manpages/defines.rst
--- frr-frr-5.0.1/doc/manpages/defines.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/defines.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,3 @@
 .. |synopsis-options| replace:: [-d|-t|-dt] [-C] [-f config-file] [-i pid-file] [-z zclient-path] [-u user] [-g group] [-A vty-addr] [-P vty-port] [-M module[:options]] [-N pathspace] [--vty_socket vty-path] [--moduledir module-path]
 .. |synopsis-options-hv| replace:: [-h] [-v]
-.. |seealso-programs| replace:: zebra(8), vtysh(1), ripd(8), ripngd(8), ospfd(8), ospf6d(8), bgpd(8), isisd(8), babeld(8), nhrpd(8), pimd(8), pbrd(8), ldpd(8), eigrpd(8), mtracebis(8)
+.. |seealso-programs| replace:: zebra(8), vtysh(1), ripd(8), ripngd(8), ospfd(8), ospf6d(8), bgpd(8), isisd(8), babeld(8), nhrpd(8), pimd(8), pbrd(8), ldpd(8), eigrpd(8), staticd(8), mtracebis(8)
diff -urpN frr-frr-5.0.1/doc/manpages/index.rst frr-frr-6.0/doc/manpages/index.rst
--- frr-frr-5.0.1/doc/manpages/index.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/index.rst	2018-10-08 14:32:57.000000000 +0200
@@ -6,6 +6,7 @@
 .. toctree::
    :maxdepth: 2
 
+   bfdd
    bgpd
    eigrpd
    isisd
@@ -20,6 +21,7 @@
    ripd
    ripngd
    sharpd
+   staticd
    watchfrr
    zebra
    vtysh
diff -urpN frr-frr-5.0.1/doc/manpages/staticd.rst frr-frr-6.0/doc/manpages/staticd.rst
--- frr-frr-5.0.1/doc/manpages/staticd.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/manpages/staticd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,38 @@
+*******
+STATICD
+*******
+
+.. include:: defines.rst
+.. |DAEMON| replace:: staticd
+
+SYNOPSIS
+========
+|DAEMON| |synopsis-options-hv|
+
+|DAEMON| |synopsis-options|
+
+DESCRIPTION
+===========
+|DAEMON| is a routing component that works with the FRRouting engine.
+
+OPTIONS
+=======
+OPTIONS available for the |DAEMON| command:
+
+.. include:: common-options.rst
+
+FILES
+=====
+
+|INSTALL_PREFIX_SBIN|/|DAEMON|
+   The default location of the |DAEMON| binary.
+
+|INSTALL_PREFIX_ETC|/|DAEMON|.conf
+   The default location of the |DAEMON| config file.
+
+$(PWD)/|DAEMON|.log
+   If the |DAEMON| process is configured to output logs to a file, then you will find this file in the directory where you started |DAEMON|.
+
+.. include:: epilogue.rst
+
+
diff -urpN frr-frr-5.0.1/doc/manpages/zebra.rst frr-frr-6.0/doc/manpages/zebra.rst
--- frr-frr-5.0.1/doc/manpages/zebra.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/manpages/zebra.rst	2018-10-08 14:32:57.000000000 +0200
@@ -42,6 +42,14 @@ OPTIONS available for the |DAEMON| comma
 
    Enable namespace VRF backend. By default, the VRF backend relies on VRF-lite support from the Linux kernel. This option permits discovering Linux named network namespaces and mapping it to FRR VRF contexts.
 
+ROUTES
+------
+
+.. option:: -r, --retain
+
+   When the program terminates, do not flush routes installed by zebra from the kernel.
+
+
 FILES
 =====
 
diff -urpN frr-frr-5.0.1/doc/user/.gitignore frr-frr-6.0/doc/user/.gitignore
--- frr-frr-5.0.1/doc/user/.gitignore	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -1,3 +1,2 @@
 /_templates
 /_build
-!/Makefile.in
diff -urpN frr-frr-5.0.1/doc/user/Makefile.am frr-frr-6.0/doc/user/Makefile.am
--- frr-frr-5.0.1/doc/user/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,55 @@
+# This is necessary to support VPATH builds.
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+# This variable is used as the documentation source location in frr-sphinx.mk
+SOURCESDIR = @srcdir@
+
+include @srcdir@/../frr-sphinx.mk
+
+# -----------------------------------------------------------------------------
+# Automake requires that 3rd-party Makefiles recognize these targets.
+# -----------------------------------------------------------------------------
+# install
+# install-data
+# install-exec
+# uninstall
+# install-dvi
+# install-html
+# install-info
+# install-ps
+# install-pdf
+# installdirs
+# check
+# installcheck
+# mostlyclean
+# clean
+# distclean
+# maintainer-clean
+# dvi
+# pdf
+# ps
+# info
+# html
+# tags
+# ctags
+
+# When building 'all', the logic is that we want to make docs that are easily
+# readable by the person that just built them. Technically the reST source is
+# readable in its own right, but we'll also build info and html because those
+# offer sequentially better reading experiences. PDF is not built by default
+# because it takes quite a while.
+all: info
+
+# info and html already have built-in sphinx rules; pdf goes to latexpdf
+pdf: latexpdf
+
+# install user manual as info file
+install-info: info
+	install -d ${DESTDIR}${infodir}
+	gzip < _build/texinfo/frr.info > ${DESTDIR}${infodir}/frr.info.gz
+	install-info _build/texinfo/frr.info ${DESTDIR}${infodir}/dir
+
+install-data: install-info
+
+install: install-data
diff -urpN frr-frr-5.0.1/doc/user/Makefile.in frr-frr-6.0/doc/user/Makefile.in
--- frr-frr-5.0.1/doc/user/Makefile.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-# This is necessary to support VPATH builds.
-srcdir = @srcdir@
-VPATH = @srcdir@
-
-# This variable is used as the documentation source location in frr-sphinx.mk
-SOURCESDIR = @srcdir@
-
-include @srcdir@/../frr-sphinx.mk
-
-# -----------------------------------------------------------------------------
-# Automake requires that 3rd-party Makefiles recognize these targets.
-# -----------------------------------------------------------------------------
-# install
-# install-data
-# install-exec
-# uninstall
-# install-dvi
-# install-html
-# install-info
-# install-ps
-# install-pdf
-# installdirs
-# check
-# installcheck
-# mostlyclean
-# clean
-# distclean
-# maintainer-clean
-# dvi
-# pdf
-# ps
-# info
-# html
-# tags
-# ctags
-
-# ignore these targets
-EMPTY_AUTOMAKE_TARGETS = dvi ps tags ctags distdir install-exec install-dvi install-ps installdirs check installcheck install-html install-pdf install-data install
-.PHONY: $(EMPTY_AUTOMAKE_TARGETS)
-$(EMPTY_AUTOMAKE_TARGETS):
-
-# When building 'all', the logic is that we want to make docs that are easily
-# readable by the person that just built them. Technically the reST source is
-# readable in its own right, but we'll also build info and html because those
-# offer sequentially better reading experiences. PDF is not built by default
-# because it takes quite a while.
-all: info
-
-# info and html already have built-in sphinx rules; pdf goes to latexpdf
-pdf: latexpdf
-
-# install user manual as info file
-install-info: info
-	install -d ${DESTDIR}${infodir}
-	gzip < _build/texinfo/frr.info > ${DESTDIR}${infodir}/frr.info.gz
-	install-info _build/texinfo/frr.info ${DESTDIR}${infodir}/dir
-
-install-data: install-info
-
-install: install-data
-
-mostlyclean distclean maintainer-clean: clean
diff -urpN frr-frr-5.0.1/doc/user/_static/overrides.css frr-frr-6.0/doc/user/_static/overrides.css
--- frr-frr-5.0.1/doc/user/_static/overrides.css	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/_static/overrides.css	2018-10-08 14:32:57.000000000 +0200
@@ -6,3 +6,50 @@ div.body {
 pre {
     background-color: #e2e2e2;
 }
+
+/* styling for the protocols vs. OS table in overview.rst */
+/* first, general bits */
+div.body td.mark {
+    text-align: center;
+    border-left: 1px solid #ccc;
+}
+table.mark th {
+    text-align: center;
+}
+table.mark td {
+    vertical-align: middle;
+}
+table.mark td[colspan="7"] {
+    text-align: center;
+    padding-top: 8pt;
+    padding-bottom: 2pt;
+}
+table.mark cite {
+    font-weight: bold;
+}
+
+/* individual Y/N/... cells */
+td.mark {
+    width: 4.5em;
+}
+td.mark span {
+    display: block;
+    padding: 3px 1px;
+    border: 1px dotted #666;
+    width: 36pt;
+    margin:auto;
+}
+span.mark-y   { background-color: #77ffaa; }
+span.mark-geq { background-color: #aaff77; }
+span.mark-cp  { background-color: #ffbb55; }
+span.mark-n   { background-color: #ff8877; }
+span.mark-dag { background-color: #ffee99; font-size: 8pt; padding:0px 1px; border-top:0px; }
+
+/* for the legend below */
+li span.mark {
+    display: inline-block;
+    padding: 3px 1px;
+    border: 1px dotted #666;
+    width: 36pt;
+    text-align: center;
+}
diff -urpN frr-frr-5.0.1/doc/user/_static/overrides.js frr-frr-6.0/doc/user/_static/overrides.js
--- frr-frr-5.0.1/doc/user/_static/overrides.js	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/_static/overrides.js	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,13 @@
+/* special styling for the protocols vs. OS table in overview.rst
+ *
+ * unfortunately this can't be done in straight CSS because we're changing
+ * the styling on the parent.
+ */
+$(document).ready(function() {
+    $("span.mark:contains('Y')" ).addClass("mark-y"  ).parent("td").addClass("mark");
+    $("span.mark:contains('')" ).addClass("mark-geq").parent("td").addClass("mark");
+    $("span.mark:contains('N')" ).addClass("mark-n"  ).parent("td").addClass("mark");
+    $("span.mark:contains('CP')").addClass("mark-cp" ).parent("td").addClass("mark");
+    $("span.mark:contains('')" ).addClass("mark-dag").parent("td").addClass("mark");
+    $('td.mark').parents('table').addClass("mark").children('colgroup').remove();
+});
diff -urpN frr-frr-5.0.1/doc/user/appendix.rst frr-frr-6.0/doc/user/appendix.rst
--- frr-frr-5.0.1/doc/user/appendix.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/appendix.rst	1970-01-01 01:00:00.000000000 +0100
@@ -1,221 +0,0 @@
-.. _packet-binary-dump-format:
-
-Packet Binary Dump Format
-=========================
-
-FRR can dump routing protocol packets into a file with a binary format.
-
-It seems to be better that we share the MRT's header format for
-backward compatibility with MRT's dump logs. We should also define the
-binary format excluding the header, because we must support both IP
-v4 and v6 addresses as socket addresses and / or routing entries.
-
-In the last meeting, we discussed to have a version field in the
-header. But Masaki told us that we can define new 'type' value rather
-than having a 'version' field, and it seems to be better because we
-don't need to change header format.
-
-Here is the common header format. This is same as that of MRT.::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                              Time                             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |             Type              |            Subtype            |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                             Length                            |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-
-If 'type' is PROTOCOL_BGP4MP_ET, the common header format will
-contain an additional microsecond field (RFC6396 2011).::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                              Time                             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |             Type              |            Subtype            |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                             Length                            |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                          Microsecond                          |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_STATE_CHANGE, and
-Address Family == IP (version 4)::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Source AS number       |     Destination AS number     |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Interface Index        |      Address Family           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address                      |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address                    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |            Old State          |           New State           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-Where State is the value defined in RFC1771.
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_STATE_CHANGE,
-and Address Family == IP version 6::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Source AS number       |     Destination AS number     |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Interface Index        |      Address Family           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address                      |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address                    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |            Old State          |           New State           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_MESSAGE,
-and Address Family == IP (version 4)::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Source AS number       |     Destination AS number     |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Interface Index        |      Address Family           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address                      |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address                    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                       BGP Message Packet                      |
-    |                                                               |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-Where BGP Message Packet is the whole contents of the
-BGP4 message including header portion.
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_MESSAGE,
-and Address Family == IP version 6::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Source AS number       |     Destination AS number     |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |        Interface Index        |      Address Family           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address                      |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Source IP address (Cont'd)             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address                    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                     Destination IP address (Cont'd)           |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                       BGP Message Packet                      |
-    |                                                               |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_ENTRY,
-and Address Family == IP (version 4)::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |            View #             |            Status             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Time Last Change                       |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |       Address Family          |    SAFI       | Next-Hop-Len  |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Next Hop Address                       |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    | Prefix Length |             Address Prefix [variable]         |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |       Attribute Length        |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |      BGP Attribute [variable length]    			|
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_ENTRY,
-and Address Family == IP version 6::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |            View #             |            Status             |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Time Last Change                       |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |       Address Family          |    SAFI       | Next-Hop-Len  |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Next Hop Address                       |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Next Hop Address (Cont'd)              |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Next Hop Address (Cont'd)              |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |                        Next Hop Address (Cont'd)              |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    | Prefix Length |             Address Prefix [variable]         |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |     Address Prefix (cont'd) [variable]        |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |       Attribute Length        |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |      BGP Attribute [variable length]    			    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-BGP4 Attribute must not contain MP_UNREACH_NLRI. If BGP Attribute has
-MP_REACH_NLRI field, it must has zero length NLRI, e.g., MP_REACH_NLRI has only
-Address Family, SAFI and next-hop values.
-
-If 'type' is PROTOCOL_BGP4MP and 'subtype' is BGP4MP_SNAPSHOT::
-
-    0                   1                   2                   3
-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-    |           View #              |       File Name [variable]    |
-    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-The file specified in "File Name" contains all routing entries,
-which are in the format of ``subtype == BGP4MP_ENTRY``.
-
-::
-
-   Constants:
-
-     /\* type value \*/
-     #define MSG_PROTOCOL_BGP4MP    16
-     #define MSG_PROTOCOL_BGP4MP_ET 17
-     /\* subtype value \*/
-     #define BGP4MP_STATE_CHANGE 0
-     #define BGP4MP_MESSAGE 1
-     #define BGP4MP_ENTRY 2
-     #define BGP4MP_SNAPSHOT 3
diff -urpN frr-frr-5.0.1/doc/user/basic.rst frr-frr-6.0/doc/user/basic.rst
--- frr-frr-5.0.1/doc/user/basic.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/basic.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,23 +1,10 @@
 .. _basic-commands:
 
 **************
-Basic commands
+Basic Commands
 **************
 
-There are five routing daemons in use, and there is one manager daemon.
-These daemons may be located on separate machines from the manager
-daemon. Each of these daemons will listen on a particular port for
-incoming VTY connections. The routing daemons are:
-
-- *ripd*
-- *ripngd*
-- *ospfd*
-- *ospf6d*
-- *bgpd*
-- *zebra*
-
-The following sections discuss commands common to all the routing
-daemons.
+The following sections discuss commands common to all the routing daemons.
 
 .. _config-commands:
 
@@ -33,9 +20,8 @@ Config Commands
 .. index:: Getting the herd running
 
 In a config file, you can write the debugging options, a vty's password,
-routing daemon configurations, a log file name, and so forth. This
-information forms the initial command set for a routing beast as it is
-starting.
+routing daemon configurations, a log file name, and so forth. This information
+forms the initial command set for a routing beast as it is starting.
 
 Config files are generally found in |INSTALL_PREFIX_ETC|.
 
@@ -50,7 +36,6 @@ Basic Config Commands
 ---------------------
 
 .. index:: hostname HOSTNAME
-
 .. clicmd:: hostname HOSTNAME
 
    Set hostname of the router.
@@ -83,9 +68,9 @@ Basic Config Commands
    compatibility. The log trap command sets the current logging level for all
    enabled logging destinations, and it sets the default for all future logging
    commands that do not specify a level. The normal default logging level is
-   debugging. The ``no`` form of the command resets the default level for future
-   logging commands to debugging, but it does not change the logging level of
-   existing logging destinations.
+   debugging. The ``no`` form of the command resets the default level for
+   future logging commands to debugging, but it does not change the logging
+   level of existing logging destinations.
 
 .. index::
    single: no log stdout [LEVEL]
@@ -95,12 +80,11 @@ Basic Config Commands
 
    Enable logging output to stdout. If the optional second argument specifying
    the logging level is not present, the default logging level (typically
-   debugging, but can be changed using the deprecated ``log trap`` command) will
-   be used. The ``no`` form of the command disables logging to stdout. The
-   ``LEVEL`` argument must have one of these values: emergencies, alerts,
-   critical, errors, warnings, notifications, informational, or debugging. Note
-   that the existing code logs its most important messages with severity
-   ``errors``.
+   debugging) will be used. The ``no`` form of the command disables logging to
+   stdout. The ``LEVEL`` argument must have one of these values: emergencies,
+   alerts, critical, errors, warnings, notifications, informational, or
+   debugging. Note that the existing code logs its most important messages with
+   severity ``errors``.
 
 .. index::
    single: no log file [FILENAME [LEVEL]]
@@ -109,19 +93,24 @@ Basic Config Commands
 .. clicmd:: [no] log file [FILENAME [LEVEL]]
 
    If you want to log into a file, please specify ``filename`` as
-   in this example: ::
+   in this example:
+
+   ::
 
-     log file /var/log/frr/bgpd.log informational
+      log file /var/log/frr/bgpd.log informational
 
    If the optional second argument specifying the logging level is not present,
    the default logging level (typically debugging, but can be changed using the
    deprecated ``log trap`` command) will be used. The ``no`` form of the command
-   disables logging to a file. *Note:* if you do not configure any file logging,
-   and a daemon crashes due to a signal or an assertion failure, it will attempt
-   to save the crash information in a file named /var/tmp/frr.<daemon
-   name>.crashlog. For security reasons, this will not happen if the file exists
-   already, so it is important to delete the file after reporting the crash
-   information.
+   disables logging to a file.
+
+   .. note::
+
+      If you do not configure any file logging, and a daemon crashes due to a
+      signal or an assertion failure, it will attempt to save the crash
+      information in a file named :file:`/var/tmp/frr.<daemon name>.crashlog`.
+      For security reasons, this will not happen if the file exists already, so
+      it is important to delete the file after reporting the crash information.
 
 .. index::
    single: no log syslog [LEVEL]
@@ -142,12 +131,11 @@ Basic Config Commands
 
    Enable logging output to vty terminals that have enabled logging using the
    ``terminal monitor`` command. By default, monitor logging is enabled at the
-   debugging level, but this command (or the deprecated ``log trap`` command) can
-   be used to change the monitor logging level. If the optional second argument
-   specifying the logging level is not present, the default logging level
-   (typically debugging, but can be changed using the deprecated ``log trap``
-   command) will be used. The ``no`` form of the command disables logging to
-   terminal monitors.
+   debugging level, but this command (or the deprecated ``log trap`` command)
+   can be used to change the monitor logging level. If the optional second
+   argument specifying the logging level is not present, the default logging
+   level (typically debugging) will be used. The ``no`` form of the command
+   disables logging to terminal monitors.
 
 .. index::
    single: no log facility [FACILITY]
@@ -156,8 +144,8 @@ Basic Config Commands
 .. clicmd:: [no] log facility [FACILITY]
 
    This command changes the facility used in syslog messages. The default
-   facility is ``daemon``. The ``no`` form of the command resets
-   the facility to the default ``daemon`` facility.
+   facility is ``daemon``. The ``no`` form of the command resets the facility
+   to the default ``daemon`` facility.
 
 .. index::
    single: no log record-priority
@@ -179,67 +167,59 @@ Basic Config Commands
 
 .. clicmd:: [no] log timestamp precision [(0-6)]
 
-   This command sets the precision of log message timestamps to the given number
-   of digits after the decimal point. Currently, the value must be in the range
-   0 to 6 (i.e. the maximum precision is microseconds). To restore the default
-   behavior (1-second accuracy), use the ``no`` form of the command, or set the
-   precision explicitly to 0.
+   This command sets the precision of log message timestamps to the given
+   number of digits after the decimal point. Currently, the value must be in
+   the range 0 to 6 (i.e. the maximum precision is microseconds). To restore
+   the default behavior (1-second accuracy), use the ``no`` form of the
+   command, or set the precision explicitly to 0.
 
-::
+   ::
 
-     log timestamp precision 3
+      log timestamp precision 3
 
    In this example, the precision is set to provide timestamps with
    millisecond accuracy.
 
 .. index:: log commands
-
 .. clicmd:: log commands
 
-   This command enables the logging of all commands typed by a user to
-   all enabled log destinations. The note that logging includes full
-   command lines, including passwords. Once set, command logging can only
-   be turned off by restarting the daemon.
+   This command enables the logging of all commands typed by a user to all
+   enabled log destinations. The note that logging includes full command lines,
+   including passwords. Once set, command logging can only be turned off by
+   restarting the daemon.
 
 .. index:: service password-encryption
-
 .. clicmd:: service password-encryption
 
    Encrypt password.
 
 .. index:: service advanced-vty
-
 .. clicmd:: service advanced-vty
 
    Enable advanced mode VTY.
 
 .. index:: service terminal-length (0-512)
-
 .. clicmd:: service terminal-length (0-512)
 
-   Set system wide line configuration. This configuration command applies
-   to all VTY interfaces.
+   Set system wide line configuration. This configuration command applies to
+   all VTY interfaces.
 
 .. index:: line vty
-
 .. clicmd:: line vty
 
    Enter vty configuration mode.
 
 .. index:: banner motd default
-
 .. clicmd:: banner motd default
 
    Set default motd string.
 
 .. index:: no banner motd
-
 .. clicmd:: no banner motd
 
    No motd banner string will be printed.
 
 .. index:: exec-timeout MINUTE [SECOND]
-
 .. clicmd:: exec-timeout MINUTE [SECOND]
 
    Set VTY connection timeout value. When only one argument is specified
@@ -248,17 +228,17 @@ Basic Config Commands
    When timeout value is zero, it means no timeout.
 
 .. index:: no exec-timeout
-
 .. clicmd:: no exec-timeout
 
-   Do not perform timeout at all. This command is as same as *exec-timeout 0 0*.
+   Do not perform timeout at all. This command is as same as
+   ``exec-timeout 0 0``.
 
 .. index:: access-class ACCESS-LIST
-
 .. clicmd:: access-class ACCESS-LIST
 
    Restrict vty connections with an access list.
 
+
 .. _sample-config-file:
 
 Sample Config File
@@ -280,17 +260,17 @@ Below is a sample configuration file for
    !
 
 
-'!' and '#' are comment characters. If the first character of the word
-is one of the comment characters then from the rest of the line forward
-will be ignored as a comment.
+``!`` and ``#`` are comment characters. If the first character of the word is
+one of the comment characters then from the rest of the line forward will be
+ignored as a comment.
 
 .. code-block:: frr
 
    password zebra!password
 
-If a comment character is not the first character of the word, it's a
-normal character. So in the above example '!' will not be regarded as a
-comment and the password is set to 'zebra!password'.
+If a comment character is not the first character of the word, it's a normal
+character. So in the above example ``!`` will not be regarded as a comment and
+the password is set to ``zebra!password``.
 
 .. _terminal-mode-commands:
 
@@ -298,62 +278,142 @@ Terminal Mode Commands
 ======================
 
 .. index:: write terminal
-
 .. clicmd:: write terminal
 
    Displays the current configuration to the vty interface.
 
 .. index:: write file
-
 .. clicmd:: write file
 
    Write current configuration to configuration file.
 
 .. index:: configure terminal
-
 .. clicmd:: configure terminal
 
    Change to configuration mode. This command is the first step to
    configuration.
 
 .. index:: terminal length (0-512)
-
 .. clicmd:: terminal length (0-512)
 
-   Set terminal display length to ``(0-512)``. If length is 0, no
-   display control is performed.
+   Set terminal display length to ``(0-512)``. If length is 0, no display
+   control is performed.
 
 .. index:: who
-
 .. clicmd:: who
 
    Show a list of currently connected vty sessions.
 
 .. index:: list
-
 .. clicmd:: list
 
    List all available commands.
 
 .. index:: show version
-
 .. clicmd:: show version
 
    Show the current version of |PACKAGE_NAME| and its build host information.
 
 .. index:: show logging
-
 .. clicmd:: show logging
 
-   Shows the current configuration of the logging system. This includes
-   the status of all logging destinations.
+   Shows the current configuration of the logging system. This includes the
+   status of all logging destinations.
 
-.. index:: logmsg LEVEL MESSAGE
+.. index:: show memory
+.. clicmd:: show memory
+
+   Show information on how much memory is used for which specific things in
+   |PACKAGE_NAME|.  Output may vary depending on system capabilities but will
+   generally look something like this:
+
+   ::
+
+      frr# show memory
+      System allocator statistics:
+        Total heap allocated:  1584 KiB
+        Holding block headers: 0 bytes
+        Used small blocks:     0 bytes
+        Used ordinary blocks:  1484 KiB
+        Free small blocks:     2096 bytes
+        Free ordinary blocks:  100 KiB
+        Ordinary blocks:       2
+        Small blocks:          60
+        Holding blocks:        0
+      (see system documentation for 'mallinfo' for meaning)
+      --- qmem libfrr ---
+      Buffer                        :          3      24                  72
+      Buffer data                   :          1    4120                4120
+      Host config                   :          3  (variably sized)        72
+      Command Tokens                :       3427      72              247160
+      Command Token Text            :       2555  (variably sized)     83720
+      Command Token Help            :       2555  (variably sized)     61720
+      Command Argument              :          2  (variably sized)        48
+      Command Argument Name         :        641  (variably sized)     15672
+      [...]
+      --- qmem Label Manager ---
+      --- qmem zebra ---
+      ZEBRA VRF                     :          1     912                 920
+      Route Entry                   :         11      80                 968
+      Static route                  :          1     192                 200
+      RIB destination               :          8      48                 448
+      RIB table info                :          4      16                  96
+      Nexthop tracking object       :          1     200                 200
+      Zebra Name Space              :          1     312                 312
+      --- qmem Table Manager ---
+
+   To understand system allocator statistics, refer to your system's
+   :manpage:`mallinfo(3)` man page.
+
+   Below these statistics, statistics on individual memory allocation types
+   in |PACKAGE_NAME| (so-called `MTYPEs`) is printed:
+
+   * the first column of numbers is the current count of allocations made for
+     the type (the number decreases when items are freed.)
+   * the second column is the size of each item.  This is only available if
+     allocations on a type are always made with the same size.
+   * the third column is the total amount of memory allocated for the
+     particular type, including padding applied by malloc.  This means that
+     the number may be larger than the first column multiplied by the second.
+     Overhead incurred by malloc's bookkeeping is not included in this, and
+     the column may be missing if system support is not available.
+
+   When executing this command from ``vtysh``, each of the daemons' memory
+   usage is printed sequentially.
 
+.. index:: logmsg LEVEL MESSAGE
 .. clicmd:: logmsg LEVEL MESSAGE
 
-   Send a message to all logging destinations that are enabled for messages
-   of the given severity.
+   Send a message to all logging destinations that are enabled for messages of
+   the given severity.
+
+.. index:: find COMMAND...
+.. clicmd:: find COMMAND...
+
+   This commmand performs a simple substring search across all defined commands
+   in all modes. As an example, suppose you're in enable mode and can't
+   remember where the command to turn OSPF segment routing on is:
+
+   ::
+
+      frr# find segment-routing on
+        (ospf)  segment-routing on
+
+   The CLI mode is displayed next to each command. In this example,
+   :clicmd:`segment-routing on` is under the `router ospf` mode.
+
+   Similarly, suppose you want a listing of all commands that contain "l2vpn":
+
+   ::
+
+      frr# find l2vpn
+        (view)  show [ip] bgp l2vpn evpn [json]
+        (view)  show [ip] bgp l2vpn evpn all <A.B.C.D|A.B.C.D/M> [json]
+        (view)  show [ip] bgp l2vpn evpn all neighbors A.B.C.D advertised-routes [json]
+        (view)  show [ip] bgp l2vpn evpn all neighbors A.B.C.D routes [json]
+        (view)  show [ip] bgp l2vpn evpn all overlay
+        ...
+
 
 .. _common-invocation-options:
 
@@ -382,16 +442,16 @@ These options apply to all |PACKAGE_NAME
    to implement commands such as ``.../init.d/zebra status``,
    ``.../init.d/zebra restart`` or ``.../init.d/zebra stop``.
 
-   The file name is an run-time option rather than a configure-time option
-   so that multiple routing daemons can be run simultaneously. This is
-   useful when using |PACKAGE_NAME| to implement a routing looking glass. One
-   machine can be used to collect differing routing views from differing
-   points in the network.
+   The file name is an run-time option rather than a configure-time option so
+   that multiple routing daemons can be run simultaneously. This is useful when
+   using |PACKAGE_NAME| to implement a routing looking glass. One machine can
+   be used to collect differing routing views from differing points in the
+   network.
 
 .. option:: -A, --vty_addr <address>
 
-   Set the VTY local address to bind to. If set, the VTY socket will only
-   be bound to this address.
+   Set the VTY local address to bind to. If set, the VTY socket will only be
+   bound to this address.
 
 .. option:: -P, --vty_port <port>
 
@@ -406,6 +466,18 @@ These options apply to all |PACKAGE_NAME
 
    Print program version.
 
+.. option:: --log <stdout|syslog|file:/path/to/log/file>
+
+   When initializing the daemon, setup the log to go to either stdout,
+   syslog or to a file.  These values will be displayed as part of
+   a show run.  Additionally they can be overridden at runtime if
+   desired via the normal log commands.
+
+.. option:: --log-level <emergencies|alerts|critical|errors|warnings|notifications|informational|debugging>
+
+   When initializing the daemon, allow the specification of a default
+   log level at startup from one of the specified levels.
+
 .. _loadable-module-support:
 
 Loadable Module Support
@@ -428,15 +500,17 @@ the following command line option at dae
    This option is available on all daemons, though some daemons may not have
    any modules available to be loaded.
 
+
 The SNMP Module
 ---------------
 
 If SNMP is enabled during compile-time and installed as part of the package,
-the ``snmp`` module can be loaded for the *zebra*, *bgpd*, *ospfd*, *ospf6d*
+the ``snmp`` module can be loaded for the *Zebra*, *bgpd*, *ospfd*, *ospf6d*
 and *ripd* daemons.
 
-The module ignores any options passed to it. Refer to :ref:`snmp-support`
-for information on its usage.
+The module ignores any options passed to it. Refer to :ref:`snmp-support` for
+information on its usage.
+
 
 The FPM Module
 --------------
@@ -450,6 +524,7 @@ specifying the encapsulation to use. ``N
 ``protobuf`` may not be available if the module was built without protobuf
 support. Refer to :ref:`zebra-fib-push-interface` for more information.
 
+
 .. _virtual-terminal-interfaces:
 
 Virtual Terminal Interfaces
@@ -458,6 +533,7 @@ Virtual Terminal Interfaces
 VTY -- Virtual Terminal [aka TeletYpe] Interface is a command line
 interface (CLI) for user interaction with the routing daemon.
 
+
 .. _vty-overview:
 
 VTY Overview
@@ -499,8 +575,6 @@ is no VTY password, one cannot connect t
    Router#
 
 
-:kbd:`?` and the ``find`` command are very useful for looking up commands.
-
 .. _vty-modes:
 
 VTY Modes
@@ -637,3 +711,34 @@ insta-help, and VTY session management.
    line.  Typing :kbd:`?` at any point in the line will show possible
    completions.
 
+Pipe Actions
+^^^^^^^^^^^^
+
+VTY supports optional modifiers at the end of commands that perform
+postprocessing on command output or modify the action of commands. These do not
+show up in the :kbd:`?` or :kbd:`TAB` suggestion lists.
+
+``... | include REGEX``
+   Filters the output of the preceding command, including only lines which
+   match the POSIX Extended Regular Expression ``REGEX``. Do not put the regex
+   in quotes.
+
+   Examples:
+
+   ::
+
+      frr# show ip bgp sum json | include remoteAs
+            "remoteAs":0,
+            "remoteAs":455,
+            "remoteAs":99,
+
+   ::
+
+      frr# show run | include neigh.*[0-9]{2}\.0\.[2-4]\.[0-9]*
+       neighbor 10.0.2.106 remote-as 99
+       neighbor 10.0.2.107 remote-as 99
+       neighbor 10.0.2.108 remote-as 99
+       neighbor 10.0.2.109 remote-as 99
+       neighbor 10.0.2.110 remote-as 99
+       neighbor 10.0.3.111 remote-as 111
+
diff -urpN frr-frr-5.0.1/doc/user/bfd.rst frr-frr-6.0/doc/user/bfd.rst
--- frr-frr-5.0.1/doc/user/bfd.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/bfd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,405 @@
+.. _bfd:
+
+**********************************
+Bidirectional Forwarding Detection
+**********************************
+
+:abbr:`BFD (Bidirectional Forwarding Detection)` stands for
+Bidirectional Forwarding Detection and it is described and extended by
+the following RFCs:
+
+* :rfc:`5880`
+* :rfc:`5881`
+* :rfc:`5883`
+
+Currently, there are two implementations of the BFD commands in FRR:
+
+* :abbr:`PTM (Prescriptive Topology Manager)`: an external daemon which
+  implements BFD;
+* ``bfdd``: a BFD implementation that is able to talk with remote peers;
+
+This document will focus on the later implementation: *bfdd*.
+
+
+.. _bfd-starting:
+
+Starting BFD
+============
+
+*bfdd* default configuration file is :file:`bfdd.conf`. *bfdd* searches
+the current directory first then |INSTALL_PREFIX_ETC|/bfdd.conf. All of
+*bfdd*'s command must be configured in :file:`bfdd.conf`.
+
+*bfdd* specific invocation options are described below. Common options
+may also be specified (:ref:`common-invocation-options`).
+
+.. program:: bfdd
+
+.. option:: --bfdctl <unix-socket>
+
+   Set the BFD daemon control socket location. If using a non-default
+   socket location::
+
+      /usr/lib/frr/bfdd --bfdctl /tmp/bfdd.sock
+
+
+   The default UNIX socket location is:
+
+      #define BFDD_CONTROL_SOCKET "|INSTALL_PREFIX_STATE|/bfdd.sock"
+
+
+.. _bfd-commands:
+
+BFDd Commands
+=============
+
+.. index:: bfd
+.. clicmd:: bfd
+
+   Opens the BFD daemon configuration node.
+
+.. index:: peer <A.B.C.D|X:X::X:X> [{multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME|vrf NAME}]
+.. clicmd:: peer <A.B.C.D|X:X::X:X> [{multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME|vrf NAME}]
+
+   Creates and configures a new BFD peer to listen and talk to.
+
+   `multihop` tells the BFD daemon that we should expect packets with
+   TTL less than 254 (because it will take more than one hop) and to
+   listen on the multihop port (4784). When using multi-hop mode
+   `echo-mode` will not work (see :rfc:`5883` section 3).
+
+   `local-address` provides a local address that we should bind our
+   peer listener to and the address we should use to send the packets.
+   This option is mandatory for IPv6.
+
+   `interface` selects which interface we should use. This option
+   conflicts with `vrf`.
+
+   `vrf` selects which domain we want to use.
+
+.. index:: no peer <A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]
+.. clicmd:: no peer <A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]
+
+    Stops and removes the selected peer.
+
+.. index:: show bfd peers [json]
+.. clicmd:: show bfd peers [json]
+
+    Show all configured BFD peers information and current status.
+
+.. index:: show bfd peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]> [json]
+.. clicmd:: show bfd peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname|vrf NAME$vrfname}]> [json]
+
+    Show status for a specific BFD peer.
+
+
+.. _bfd-peer-config:
+
+Peer Configurations
+-------------------
+
+.. index:: detect-multiplier (2-255)
+.. clicmd:: detect-multiplier (2-255)
+
+   Configures the detection multiplier to determine packet loss. The
+   remote transmission interval will be multiplied by this value to
+   determine the connection loss detection timer. The default value is
+   3.
+
+   Example: when the local system has `detect-multiplier 3` and  the
+   remote system has `transmission interval 300`, the local system will
+   detect failures only after 900 milliseconds without receiving
+   packets.
+
+.. index:: receive-interval (10-60000)
+.. clicmd:: receive-interval (10-60000)
+
+   Configures the minimum interval that this system is capable of
+   receiving control packets. The default value is 300 milliseconds.
+
+.. index:: transmit-interval (10-60000)
+.. clicmd:: transmit-interval (10-60000)
+
+   The minimum transmission interval (less jitter) that this system
+   wants to use to send BFD control packets.
+
+.. index:: echo-interval (10-60000)
+.. clicmd:: echo-interval (10-60000)
+
+   Configures the minimal echo receive transmission interval that this
+   system is capable of handling.
+
+.. index:: [no] echo-mode
+.. clicmd:: [no] echo-mode
+
+   Enables or disables the echo transmission mode. This mode is disabled
+   by default.
+
+   It is recommended that the transmission interval of control packets
+   to be increased after enabling echo-mode to reduce bandwidth usage.
+   For example: `transmission-interval 2000`.
+
+   Echo mode is not supported on multi-hop setups (see :rfc:`5883`
+   section 3).
+
+.. index:: [no] shutdown
+.. clicmd:: [no] shutdown
+
+   Enables or disables the peer. When the peer is disabled an
+   'administrative down' message is sent to the remote peer.
+
+.. index:: label WORD
+.. clicmd:: label WORD
+
+   Labels a peer with the provided word. This word can be referenced
+   later on other daemons to refer to a specific peer.
+
+
+.. _bfd-bgp-peer-config:
+
+BGP BFD Configuration
+---------------------
+
+The following commands are available inside the BGP configuration node.
+
+.. index:: neighbor <A.B.C.D|X:X::X:X|WORD> bfd
+.. clicmd:: neighbor <A.B.C.D|X:X::X:X|WORD> bfd
+
+   Listen for BFD events registered on the same target as this BGP
+   neighbor. When BFD peer goes down it immediately asks BGP to shutdown
+   the connection with its neighbor and, when it goes back up, notify
+   BGP to try to connect to it.
+
+.. index:: no neighbor <A.B.C.D|X:X::X:X|WORD> bfd
+.. clicmd:: no neighbor <A.B.C.D|X:X::X:X|WORD> bfd
+
+   Removes any notification registration for this neighbor.
+
+
+.. _bfd-ospf-peer-config:
+
+OSPF BFD Configuration
+----------------------
+
+The following commands are available inside the interface configuration node.
+
+.. index:: ip ospf bfd
+.. clicmd:: ip ospf bfd
+
+   Listen for BFD events on peers created on the interface. Every time
+   a new neighbor is found a BFD peer is created to monitor the link
+   status for fast convergence.
+
+.. index:: no ip ospf bfd
+.. clicmd:: no ip ospf bfd
+
+   Removes any notification registration for this interface peers.
+
+
+.. _bfd-ospf6-peer-config:
+
+OSPF6 BFD Configuration
+-----------------------
+
+The following commands are available inside the interface configuration node.
+
+.. index:: ipv6 ospf6 bfd
+.. clicmd:: ipv6 ospf6 bfd
+
+   Listen for BFD events on peers created on the interface. Every time
+   a new neighbor is found a BFD peer is created to monitor the link
+   status for fast convergence.
+
+.. index:: no ipv6 ospf6 bfd
+.. clicmd:: no ipv6 ospf6 bfd
+
+   Removes any notification registration for this interface peers.
+
+
+.. _bfd-pim-peer-config:
+
+PIM BFD Configuration
+---------------------
+
+The following commands are available inside the interface configuration node.
+
+.. index:: ip pim bfd
+.. clicmd:: ip pim bfd
+
+   Listen for BFD events on peers created on the interface. Every time
+   a new neighbor is found a BFD peer is created to monitor the link
+   status for fast convergence.
+
+.. index:: no ip pim bfd
+.. clicmd:: no ip pim bfd
+
+   Removes any notification registration for this interface peers.
+
+
+.. _bfd-configuration:
+
+Configuration
+=============
+
+Before applying ``bfdd`` rules to integrated daemons (like BGPd), we must
+create the corresponding peers inside the ``bfd`` configuration node.
+
+Here is an example of BFD configuration:
+
+::
+
+    bfd
+     peer 192.168.0.1
+       label home-peer
+       no shutdown
+     !
+    !
+    router bgp 65530
+     neighbor 192.168.0.1 remote-as 65531
+     neighbor 192.168.0.1 bfd
+     neighbor 192.168.0.2 remote-as 65530
+     neighbor 192.168.0.2 bfd
+     neighbor 192.168.0.3 remote-as 65532
+     neighbor 192.168.0.3 bfd
+    !
+
+Peers can be identified by its address (use ``multihop`` when you need
+to specify a multi hop peer) or can be specified manually by a label.
+
+Here are the available peer configurations:
+
+::
+
+   bfd
+
+    ! configure a peer on an specific interface
+    peer 192.168.0.1 interface eth0
+     no shutdown
+    !
+
+    ! configure a multihop peer
+    peer 192.168.0.2 multihop local-address 192.168.0.3
+      shutdown
+    !
+
+    ! configure a peer in a different vrf
+    peer 192.168.0.3 vrf foo
+     shutdown
+    !
+
+    ! configure a peer with every option possible
+    peer 192.168.0.4
+     label peer-label
+     detect-multiplier 50
+     receive-interval 60000
+     transmit-interval 3000
+     shutdown
+    !
+
+    ! remove a peer
+    no peer 192.168.0.3 vrf foo
+
+
+.. _bfd-status:
+
+Status
+======
+
+You can inspect the current BFD peer status with the following commands:
+
+::
+
+   frr# show bfd peers
+   BFD Peers:
+           peer 192.168.0.1
+                   ID: 1
+                   Remote ID: 1
+                   Status: up
+                   Uptime: 1 minute(s), 51 second(s)
+                   Diagnostics: ok
+                   Remote diagnostics: ok
+                   Local timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: disabled
+                   Remote timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: 50ms
+
+           peer 192.168.1.1
+                   label: router3-peer
+                   ID: 2
+                   Remote ID: 2
+                   Status: up
+                   Uptime: 1 minute(s), 53 second(s)
+                   Diagnostics: ok
+                   Remote diagnostics: ok
+                   Local timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: disabled
+                   Remote timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: 50ms
+
+   frr# show bfd peer 192.168.1.1
+   BFD Peer:
+               peer 192.168.1.1
+                   label: router3-peer
+                   ID: 2
+                   Remote ID: 2
+                   Status: up
+                   Uptime: 3 minute(s), 4 second(s)
+                   Diagnostics: ok
+                   Remote diagnostics: ok
+                   Local timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: disabled
+                   Remote timers:
+                           Receive interval: 300ms
+                           Transmission interval: 300ms
+                           Echo transmission interval: 50ms
+
+   frr# show bfd peer 192.168.0.1 json
+   {"multihop":false,"peer":"192.168.0.1","id":1,"remote-id":1,"status":"up","uptime":161,"diagnostic":"ok","remote-diagnostic":"ok","receive-interval":300,"transmit-interval":300,"echo-interval":50,"remote-receive-interval":300,"remote-transmit-interval":300,"remote-echo-interval":50}
+
+
+You can also inspect peer session counters with the following commands:
+
+::
+
+   frr# show bfd peers counters
+   BFD Peers:
+        peer 192.168.2.1 interface r2-eth2
+                Control packet input: 28 packets
+                Control packet output: 28 packets
+                Echo packet input: 0 packets
+                Echo packet output: 0 packets
+                Session up events: 1
+                Session down events: 0
+                Zebra notifications: 2
+
+        peer 192.168.0.1
+                Control packet input: 54 packets
+                Control packet output: 103 packets
+                Echo packet input: 965 packets
+                Echo packet output: 966 packets
+                Session up events: 1
+                Session down events: 0
+                Zebra notifications: 4
+
+   frr# show bfd peer 192.168.0.1 counters
+        peer 192.168.0.1
+                Control packet input: 126 packets
+                Control packet output: 247 packets
+                Echo packet input: 2409 packets
+                Echo packet output: 2410 packets
+                Session up events: 1
+                Session down events: 0
+                Zebra notifications: 4
+
+   frr# show bfd peer 192.168.0.1 counters json
+   {"multihop":false,"peer":"192.168.0.1","control-packet-input":348,"control-packet-output":685,"echo-packet-input":6815,"echo-packet-output":6816,"session-up":1,"session-down":0,"zebra-notifications":4}
diff -urpN frr-frr-5.0.1/doc/user/bgp.rst frr-frr-6.0/doc/user/bgp.rst
--- frr-frr-5.0.1/doc/user/bgp.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/bgp.rst	2018-10-08 14:32:57.000000000 +0200
@@ -4,21 +4,20 @@
 BGP
 ***
 
-:abbr:`BGP` stands for a Border Gateway Protocol. The latest BGP version is 4.
+:abbr:`BGP` stands for Border Gateway Protocol. The latest BGP version is 4.
 BGP-4 is one of the Exterior Gateway Protocols and the de facto standard
-interdomain routing protocol. BGP-4 is described in :rfc:`1771`.
-
-Many extensions have been added to :rfc:`1771`. :rfc:`2858` adds multiprotocol
-support to BGP-4.
+interdomain routing protocol. BGP-4 is described in :rfc:`1771` and updated by
+:rfc:`4271`. :rfc:`2858` adds multiprotocol support to BGP-4.
 
 .. _starting-bgp:
 
 Starting BGP
 ============
 
-Default configuration file of *bgpd* is :file:`bgpd.conf`.  *bgpd* searches the
-current directory first then |INSTALL_PREFIX_ETC|/bgpd.conf. All of bgpd's
-command must be configured in :file:`bgpd.conf`.
+The default configuration file of *bgpd* is :file:`bgpd.conf`. *bgpd* searches
+the current directory first, followed by |INSTALL_PREFIX_ETC|/bgpd.conf. All of
+*bgpd*'s commands must be configured in :file:`bgpd.conf` when the integrated
+config is not being used.
 
 *bgpd* specific invocation options are described below. Common options may also
 be specified (:ref:`common-invocation-options`).
@@ -30,127 +29,207 @@ be specified (:ref:`common-invocation-op
    Set the bgp protocol's port number. When port number is 0, that means do not
    listen bgp port.
 
-.. option:: -r, --retain
-
-   When program terminates, retain BGP routes added by zebra.
-
 .. option:: -l, --listenon
 
-   Specify a specific IP address for bgpd to listen on, rather than its
-   default of INADDR_ANY / IN6ADDR_ANY. This can be useful to constrain bgpd
-   to an internal address, or to run multiple bgpd processes on one host.
-
-
-.. _bgp-router:
-
-BGP router
-==========
+   Specify a specific IP address for bgpd to listen on, rather than its default
+   of ``0.0.0.0`` / ``::``. This can be useful to constrain bgpd to an internal
+   address, or to run multiple bgpd processes on one host.
 
-First of all you must configure BGP router with *router bgp* command. To
-configure BGP router, you need AS number. AS number is an identification of
-autonomous system. BGP protocol uses the AS number for detecting whether the
-BGP connection is internal one or external one.
+.. _bgp-basic-concepts:
 
-.. index:: router bgp ASN
-.. clicmd:: router bgp ASN
+Basic Concepts
+==============
 
-   Enable a BGP protocol process with the specified ASN. After
-   this statement you can input any `BGP Commands`. You can not
-   create different BGP process under different ASN without
-   specifying `multiple-instance` (:ref:`multiple-instance`).
+.. _bgp-autonomous-systems:
 
-.. index:: no router bgp ASN
-.. clicmd:: no router bgp ASN
+Autonomous Systems
+------------------
 
-   Destroy a BGP protocol process with the specified ASN.
+From :rfc:`1930`:
 
-.. index:: bgp router-id A.B.C.D
-.. clicmd:: bgp router-id A.B.C.D
+   An AS is a connected group of one or more IP prefixes run by one or more
+   network operators which has a SINGLE and CLEARLY DEFINED routing policy.
 
-   This command specifies the router-ID. If *bgpd* connects to *zebra* it gets
-   interface and address information. In that case default router ID value is
-   selected as the largest IP Address of the interfaces. When `router zebra` is
-   not enabled *bgpd* can't get interface information so `router-id` is set to
-   0.0.0.0. So please set router-id by hand.
+Each AS has an identifying number associated with it called an :abbr:`ASN
+(Autonomous System Number)`. This is a two octet value ranging in value from 1
+to 65535. The AS numbers 64512 through 65535 are defined as private AS numbers.
+Private AS numbers must not be advertised on the global Internet.
 
-.. _bgp-distance:
+The :abbr:`ASN (Autonomous System Number)` is one of the essential elements of
+BGP. BGP is a distance vector routing protocol, and the AS-Path framework
+provides distance vector metric and loop detection to BGP.
 
-BGP distance
-------------
+.. seealso:: :rfc:`1930`
 
-.. index:: distance bgp (1-255) (1-255) (1-255)
-.. clicmd:: distance bgp (1-255) (1-255) (1-255)
+.. _bgp-address-families:
 
-   This command change distance value of BGP. Each argument is distance value
-   for external routes, internal routes and local routes.
+Address Families
+----------------
 
-.. index:: distance (1-255) A.B.C.D/M
-.. clicmd:: distance (1-255) A.B.C.D/M
+Multiprotocol extensions enable BGP to carry routing information for multiple
+network layer protocols. BGP supports an Address Family Identifier (AFI) for
+IPv4 and IPv6. Support is also provided for multiple sets of per-AFI
+information via the BGP Subsequent Address Family Identifier (SAFI). FRR
+supports SAFIs for unicast information, labeled information (:rfc:`3107` and
+:rfc:`8277`), and Layer 3 VPN information (:rfc:`4364` and :rfc:`4659`).
 
-.. index:: distance (1-255) A.B.C.D/M word
-.. clicmd:: distance (1-255) A.B.C.D/M word
+.. _bgp-route-selection:
 
-.. _bgp-decision-process:
+Route Selection
+---------------
 
-BGP decision process
---------------------
+The route selection process used by FRR's BGP implementation uses the following
+decision criterion, starting at the top of the list and going towards the
+bottom until one of the factors can be used.
 
-The decision process FRR BGP uses to select routes is as follows:
+1. **Weight check**
 
-1. *Weight check*
    Prefer higher local weight routes to lower routes.
 
-2. *Local preference check*
+2. **Local preference check**
+
    Prefer higher local preference routes to lower.
 
-3. *Local route check*
+3. **Local route check**
+
    Prefer local routes (statics, aggregates, redistributed) to received routes.
 
-4. *AS path length check*
+4. **AS path length check**
+
    Prefer shortest hop-count AS_PATHs.
 
-5. *Origin check*
+5. **Origin check**
+
    Prefer the lowest origin type route. That is, prefer IGP origin routes to
    EGP, to Incomplete routes.
 
-6. *MED check*
+6. **MED check**
+
    Where routes with a MED were received from the same AS, prefer the route
    with the lowest MED. :ref:`bgp-med`.
 
-7. *External check*
+7. **External check**
+
    Prefer the route received from an external, eBGP peer over routes received
    from other types of peers.
 
-8. *IGP cost check*
+8. **IGP cost check**
+
    Prefer the route with the lower IGP cost.
 
-9. *Multi-path check*
+9. **Multi-path check**
+
    If multi-pathing is enabled, then check whether the routes not yet
    distinguished in preference may be considered equal. If
    :clicmd:`bgp bestpath as-path multipath-relax` is set, all such routes are
    considered equal, otherwise routes received via iBGP with identical AS_PATHs
    or routes received from eBGP neighbours in the same AS are considered equal.
 
-10. *Already-selected external check*
+10. **Already-selected external check**
+
     Where both routes were received from eBGP peers, then prefer the route
     which is already selected. Note that this check is not applied if
     :clicmd:`bgp bestpath compare-routerid` is configured. This check can
     prevent some cases of oscillation.
 
-11. *Router-ID check*
+11. **Router-ID check**
+
     Prefer the route with the lowest `router-ID`. If the route has an
     `ORIGINATOR_ID` attribute, through iBGP reflection, then that router ID is
     used, otherwise the `router-ID` of the peer the route was received from is
     used.
 
-12. *Cluster-List length check*
+12. **Cluster-List length check**
+
     The route with the shortest cluster-list length is used. The cluster-list
     reflects the iBGP reflection path the route has taken.
 
-13. *Peer address*
+13. **Peer address**
+
     Prefer the route received from the peer with the higher transport layer
     address, as a last-resort tie-breaker.
 
+.. _bgp-capability-negotiation:
+
+Capability Negotiation
+----------------------
+
+When adding IPv6 routing information exchange feature to BGP. There were some
+proposals. :abbr:`IETF (Internet Engineering Task Force)`
+:abbr:`IDR (Inter Domain Routing)` adopted a proposal called Multiprotocol
+Extension for BGP. The specification is described in :rfc:`2283`. The protocol
+does not define new protocols. It defines new attributes to existing BGP. When
+it is used exchanging IPv6 routing information it is called BGP-4+. When it is
+used for exchanging multicast routing information it is called MBGP.
+
+*bgpd* supports Multiprotocol Extension for BGP. So if a remote peer supports
+the protocol, *bgpd* can exchange IPv6 and/or multicast routing information.
+
+Traditional BGP did not have the feature to detect a remote peer's
+capabilities, e.g. whether it can handle prefix types other than IPv4 unicast
+routes. This was a big problem using Multiprotocol Extension for BGP in an
+operational network. :rfc:`2842` adopted a feature called Capability
+Negotiation. *bgpd* use this Capability Negotiation to detect the remote peer's
+capabilities. If a peer is only configured as an IPv4 unicast neighbor, *bgpd*
+does not send these Capability Negotiation packets (at least not unless other
+optional BGP features require capability negotiation).
+
+By default, FRR will bring up peering with minimal common capability for the
+both sides. For example, if the local router has unicast and multicast
+capabilities and the remote router only has unicast capability the local router
+will establish the connection with unicast only capability. When there are no
+common capabilities, FRR sends Unsupported Capability error and then resets the
+connection.
+
+.. _bgp-concepts-vrfs:
+
+VRFs: Virtual Routing and Forwarding
+------------------------------------
+
+*bgpd* supports :abbr:`L3VPN (Layer 3 Virtual Private Networks)` :abbr:`VRFs
+(Virtual Routing and Forwarding tables)` for IPv4 :rfc:`4364` and IPv6
+:rfc:`4659`.  L3VPN routes, and their associated VRF MPLS labels, can be
+distributed to VPN SAFI neighbors in the *default*, i.e., non VRF, BGP
+instance. VRF MPLS labels are reached using *core* MPLS labels which are
+distributed using LDP or BGP labeled unicast.  *bgpd* also supports inter-VRF
+route leaking.  General information on FRR's VRF support can be found in
+:ref:`zebra-vrf`.
+
+.. _bgp-router-configuration:
+
+BGP Router Configuration
+========================
+
+ASN and Router ID
+-----------------
+
+First of all you must configure BGP router with the :clicmd:`router bgp ASN`
+command. The AS number is an identifier for the autonomous system. The BGP
+protocol uses the AS number for detecting whether the BGP connection is
+internal or external.
+
+.. index:: router bgp ASN
+.. clicmd:: router bgp ASN
+
+   Enable a BGP protocol process with the specified ASN. After
+   this statement you can input any `BGP Commands`.
+
+.. index:: no router bgp ASN
+.. clicmd:: no router bgp ASN
+
+   Destroy a BGP protocol process with the specified ASN.
+
+.. index:: bgp router-id A.B.C.D
+.. clicmd:: bgp router-id A.B.C.D
+
+   This command specifies the router-ID. If *bgpd* connects to *zebra* it gets
+   interface and address information. In that case default router ID value is
+   selected as the largest IP Address of the interfaces. When `router zebra` is
+   not enabled *bgpd* can't get interface information so `router-id` is set to
+   0.0.0.0. So please set router-id by hand.
+
+Route Selection
+---------------
 
 .. index:: bgp bestpath as-path confed
 .. clicmd:: bgp bestpath as-path confed
@@ -186,11 +265,30 @@ The decision process FRR BGP uses to sel
    other measures were taken to avoid these. The exact behaviour will be
    sensitive to the iBGP and reflection topology.
 
+.. _bgp-distance:
+
+Administrative Distance Metrics
+-------------------------------
+
+.. index:: distance bgp (1-255) (1-255) (1-255)
+.. clicmd:: distance bgp (1-255) (1-255) (1-255)
+
+   This command change distance value of BGP. The arguments are the distance
+   values for for external routes, internal routes and local routes
+   respectively.
+
+.. index:: distance (1-255) A.B.C.D/M
+.. clicmd:: distance (1-255) A.B.C.D/M
+
+.. index:: distance (1-255) A.B.C.D/M WORD
+.. clicmd:: distance (1-255) A.B.C.D/M WORD
+
+   Sets the administrative distance for a particular route.
 
 .. _bgp-route-flap-dampening:
 
-BGP route flap dampening
-------------------------
+Route Flap Dampening
+--------------------
 
 .. clicmd:: bgp dampening (1-45) (1-20000) (1-20000) (1-255)
 
@@ -212,15 +310,14 @@ BGP route flap dampening
    this command is not recommended nowadays.
 
 .. seealso::
-
-   `http://www.ripe.net/ripe/docs/ripe-378,,RIPE-378 <http://www.ripe.net/ripe/docs/ripe-378,,RIPE-378>`_
+   https://www.ripe.net/publications/docs/ripe-378
 
 .. _bgp-med:
 
-BGP MED
-=======
+Multi-Exit Discriminator
+------------------------
 
-The BGP :abbr:`MED (Multi Exit Discriminator)` attribute has properties which
+The BGP :abbr:`MED (Multi-Exit Discriminator)` attribute has properties which
 can cause subtle convergence problems in BGP. These properties and problems
 have proven to be hard to understand, at least historically, and may still not
 be widely understood. The following attempts to collect together and present
@@ -367,7 +464,7 @@ choosing to update to new a route based
 at the cost of a non-deterministic selection process. FRR implements this, as
 do many other implementations, so long as it is not overridden by setting
 :clicmd:`bgp bestpath compare-routerid`, and see also
-:ref:`bgp-decision-process`.
+:ref:`bgp-route-selection`.
 
 However, more complex and insidious cycles of oscillation are possible with
 iBGP route-reflection, which are not so easily avoided. These have been
@@ -437,7 +534,7 @@ follow the IGP topology.
 
 Note that there are other sources of indeterminism in the route selection
 process, specifically, the preference for older and already selected routes
-from eBGP peers, :ref:`bgp-decision-process`.
+from eBGP peers, :ref:`bgp-route-selection`.
 
 .. index:: bgp always-compare-med
 .. clicmd:: bgp always-compare-med
@@ -457,14 +554,8 @@ from eBGP peers, :ref:`bgp-decision-proc
 
 .. _bgp-network:
 
-BGP network
-===========
-
-
-.. _bgp-route:
-
-BGP route
----------
+Networks
+--------
 
 .. index:: network A.B.C.D/M
 .. clicmd:: network A.B.C.D/M
@@ -486,8 +577,7 @@ BGP route
 .. index:: no network A.B.C.D/M
 .. clicmd:: no network A.B.C.D/M
 
-
-.. _route-aggregation:
+.. _bgp-route-aggregation:
 
 Route Aggregation
 -----------------
@@ -512,12 +602,10 @@ Route Aggregation
 .. index:: no aggregate-address A.B.C.D/M
 .. clicmd:: no aggregate-address A.B.C.D/M
 
+.. _bgp-redistribute-to-bgp:
 
-
-.. _redistribute-to-bgp:
-
-Redistribute to BGP
--------------------
+Redistribution
+--------------
 
 .. index:: redistribute kernel
 .. clicmd:: redistribute kernel
@@ -590,15 +678,15 @@ Redistribute to BGP
    Supported for ipv4 and ipv6 address families. It works on multi-paths as
    well, however, metric setting is based on the best-path only.
 
-.. _bgp-peer:
+.. _bgp-peers:
 
-BGP Peer
-========
+Peers
+-----
 
-.. _defining-peer:
+.. _bgp-defining-peers:
 
-Defining Peer
--------------
+Defining Peers
+^^^^^^^^^^^^^^
 
 .. index:: neighbor PEER remote-as ASN
 .. clicmd:: neighbor PEER remote-as ASN
@@ -632,43 +720,35 @@ Defining Peer
    peers ASN is the same as mine as specified under the :clicmd:`router bgp ASN`
    command the connection will be denied.
 
-.. _bgp-peer-commands:
-
-BGP Peer commands
------------------
-
-In a `router bgp` clause there are neighbor specific configurations
-required.
+.. _bgp-configuring-peers:
 
-.. index:: neighbor PEER shutdown
-.. clicmd:: neighbor PEER shutdown
+Configuring Peers
+^^^^^^^^^^^^^^^^^
 
-.. index:: no neighbor PEER shutdown
-.. clicmd:: no neighbor PEER shutdown
+.. index:: [no] neighbor PEER shutdown
+.. clicmd:: [no] neighbor PEER shutdown
 
    Shutdown the peer. We can delete the neighbor's configuration by
    ``no neighbor PEER remote-as ASN`` but all configuration of the neighbor
    will be deleted. When you want to preserve the configuration, but want to
    drop the BGP peer, use this syntax.
 
-.. index:: neighbor PEER ebgp-multihop
-.. clicmd:: neighbor PEER ebgp-multihop
-
-.. index:: no neighbor PEER ebgp-multihop
-.. clicmd:: no neighbor PEER ebgp-multihop
-
+.. index:: [no] neighbor PEER disable-connected-check
+.. clicmd:: [no] neighbor PEER disable-connected-check
 
-.. index:: neighbor PEER description ...
-.. clicmd:: neighbor PEER description ...
+   Allow peerings between directly connected eBGP peers using loopback
+   addresses.
 
+.. index:: [no] neighbor PEER ebgp-multihop
+.. clicmd:: [no] neighbor PEER ebgp-multihop
 
-.. index:: no neighbor PEER description ...
-.. clicmd:: no neighbor PEER description ...
+.. index:: [no] neighbor PEER description ...
+.. clicmd:: [no] neighbor PEER description ...
 
    Set description of the peer.
 
-.. index:: neighbor PEER version VERSION
-.. clicmd:: neighbor PEER version VERSION
+.. index:: [no] neighbor PEER version VERSION
+.. clicmd:: [no] neighbor PEER version VERSION
 
    Set up the neighbor's BGP version. `version` can be `4`, `4+` or `4-`. BGP
    version `4` is the default value used for BGP peering. BGP version `4+`
@@ -677,12 +757,8 @@ required.
    revision 00's Multiprotocol Extensions for BGP-4. Some routing software is
    still using this version.
 
-.. index:: neighbor PEER interface IFNAME
-.. clicmd:: neighbor PEER interface IFNAME
-
-
-.. index:: no neighbor PEER interface IFNAME
-.. clicmd:: no neighbor PEER interface IFNAME
+.. index:: [no] neighbor PEER interface IFNAME
+.. clicmd:: [no] neighbor PEER interface IFNAME
 
    When you connect to a BGP peer over an IPv6 link-local address, you have to
    specify the IFNAME of the interface used for the connection. To specify
@@ -692,24 +768,16 @@ required.
    This command is deprecated and may be removed in a future release. Its use
    should be avoided.
 
-.. index:: neighbor PEER next-hop-self [all]
-.. clicmd:: neighbor PEER next-hop-self [all]
-
-
-.. index:: no neighbor PEER next-hop-self [all]
-.. clicmd:: no neighbor PEER next-hop-self [all]
+.. index:: [no] neighbor PEER next-hop-self [all]
+.. clicmd:: [no] neighbor PEER next-hop-self [all]
 
    This command specifies an announced route's nexthop as being equivalent to
    the address of the bgp router if it is learned via eBGP.  If the optional
    keyword `all` is specified the modification is done also for routes learned
    via iBGP.
 
-.. index:: neighbor PEER update-source <IFNAME|ADDRESS>
-.. clicmd:: neighbor PEER update-source <IFNAME|ADDRESS>
-
-
-.. index:: no neighbor PEER update-source
-.. clicmd:: no neighbor PEER update-source
+.. index:: [no] neighbor PEER update-source <IFNAME|ADDRESS>
+.. clicmd:: [no] neighbor PEER update-source <IFNAME|ADDRESS>
 
    Specify the IPv4 source address to use for the :abbr:`BGP` session to this
    neighbour, may be specified as either an IPv4 address directly or as an
@@ -723,11 +791,8 @@ required.
        neighbor bar update-source lo0
 
 
-.. index:: neighbor PEER default-originate
-.. clicmd:: neighbor PEER default-originate
-
-.. index:: no neighbor PEER default-originate
-.. clicmd:: no neighbor PEER default-originate
+.. index:: [no] neighbor PEER default-originate
+.. clicmd:: [no] neighbor PEER default-originate
 
    *bgpd*'s default is to not announce the default route (0.0.0.0/0) even if it
    is in routing table. When you want to announce default routes to the peer,
@@ -739,37 +804,22 @@ required.
 .. index:: neighbor PEER send-community
 .. clicmd:: neighbor PEER send-community
 
-.. index:: neighbor PEER weight WEIGHT
-.. clicmd:: neighbor PEER weight WEIGHT
-
-
-.. index:: no neighbor PEER weight WEIGHT
-.. clicmd:: no neighbor PEER weight WEIGHT
+.. index:: [no] neighbor PEER weight WEIGHT
+.. clicmd:: [no] neighbor PEER weight WEIGHT
 
    This command specifies a default `weight` value for the neighbor's routes.
 
-.. index:: neighbor PEER maximum-prefix NUMBER
-.. clicmd:: neighbor PEER maximum-prefix NUMBER
-
-
-.. index:: no neighbor PEER maximum-prefix NUMBER
-.. clicmd:: no neighbor PEER maximum-prefix NUMBER
-
-
-.. index:: neighbor PEER local-as AS-NUMBER
-.. clicmd:: neighbor PEER local-as AS-NUMBER
-
-
-.. index:: neighbor PEER local-as AS-NUMBER no-prepend
-.. clicmd:: neighbor PEER local-as AS-NUMBER no-prepend
+.. index:: [no] neighbor PEER maximum-prefix NUMBER
+.. clicmd:: [no] neighbor PEER maximum-prefix NUMBER
 
+.. index:: [no] neighbor PEER local-as AS-NUMBER no-prepend
+.. clicmd:: [no] neighbor PEER local-as AS-NUMBER no-prepend
 
-.. index:: neighbor PEER local-as AS-NUMBER no-prepend replace-as
-.. clicmd:: neighbor PEER local-as AS-NUMBER no-prepend replace-as
+.. index:: [no] neighbor PEER local-as AS-NUMBER no-prepend replace-as
+.. clicmd:: [no] neighbor PEER local-as AS-NUMBER no-prepend replace-as
 
-
-.. index:: no neighbor PEER local-as
-.. clicmd:: no neighbor PEER local-as
+.. index:: [no] neighbor PEER local-as AS-NUMBER
+.. clicmd:: [no] neighbor PEER local-as AS-NUMBER
 
    Specify an alternate AS for this BGP process when interacting with the
    specified peer. With no modifiers, the specified local-as is prepended to
@@ -787,22 +837,18 @@ required.
 
    This command is only allowed for eBGP peers.
 
-.. index:: neighbor PEER ttl-security hops NUMBER
-.. clicmd:: neighbor PEER ttl-security hops NUMBER
-
-
-.. index:: no neighbor PEER ttl-security hops NUMBER
-.. clicmd:: no neighbor PEER ttl-security hops NUMBER
+.. index:: [no] neighbor PEER ttl-security hops NUMBER
+.. clicmd:: [no] neighbor PEER ttl-security hops NUMBER
 
    This command enforces Generalized TTL Security Mechanism (GTSM), as
    specified in RFC 5082. With this command, only neighbors that are the
    specified number of hops away will be allowed to become neighbors. This
    command is mutually exclusive with *ebgp-multihop*.
 
-.. _peer-filtering:
+.. _bgp-peer-filtering:
 
-Peer filtering
---------------
+Peer Filtering
+^^^^^^^^^^^^^^
 
 .. index:: neighbor PEER distribute-list NAME [in|out]
 .. clicmd:: neighbor PEER distribute-list NAME [in|out]
@@ -830,8 +876,16 @@ Peer filtering
 
 .. _bgp-peer-group:
 
-BGP Peer Group
-==============
+Peer Groups
+^^^^^^^^^^^
+
+Peer groups are used to help improve scaling by generating the same
+update information to all members of a peer group. Note that this means
+that the routes generated by a member of a peer group will be sent back
+to that originating peer with the originator identifier attribute set to
+indicated the originating peer.  All peers not associated with a
+specific peer group are treated as belonging to a default peer group,
+and will share updates.
 
 .. index:: neighbor WORD peer-group
 .. clicmd:: neighbor WORD peer-group
@@ -843,66 +897,63 @@ BGP Peer Group
 
    This command bind specific peer to peer group WORD.
 
-.. _bgp-address-family:
-
-BGP Address Family
-==================
-
-Multiprotocol BGP enables BGP to carry routing information for multiple Network
-Layer protocols. BGP supports multiple Address Family Identifier (AFI), namely
-IPv4 and IPv6. Support is also provided for multiple sets of per-AFI
-information via Subsequent Address Family Identifiers (SAFI). In addition to
-unicast information, VPN information :rfc:`4364` and :rfc:`4659`, and
-Encapsulation attribute :rfc:`5512` is supported.
-
-.. index:: show ip bgp ipv4 vpn
-.. clicmd:: show ip bgp ipv4 vpn
+.. index:: neighbor PEER solo
+.. clicmd:: neighbor PEER solo
 
-.. index:: show ipv6 bgp ipv6 vpn
-.. clicmd:: show ipv6 bgp ipv6 vpn
+   This command is used to indicate that routes advertised by the peer
+   should not be reflected back to the peer.  This command only is only
+   meaningful when there is a single peer defined in the peer-group.
 
-   Print active IPV4 or IPV6 routes advertised via the VPN SAFI.
+Capability Negotiation
+^^^^^^^^^^^^^^^^^^^^^^
 
-.. index:: show bgp ipv4 vpn summary
-.. clicmd:: show bgp ipv4 vpn summary
+.. index:: neighbor PEER strict-capability-match
+.. clicmd:: neighbor PEER strict-capability-match
 
-.. index:: show bgp ipv6 vpn summary
-.. clicmd:: show bgp ipv6 vpn summary
+.. index:: no neighbor PEER strict-capability-match
+.. clicmd:: no neighbor PEER strict-capability-match
 
-   Print a summary of neighbor connections for the specified AFI/SAFI combination.
+   Strictly compares remote capabilities and local capabilities. If
+   capabilities are different, send Unsupported Capability error then reset
+   connection.
 
-.. _autonomous-system:
+   You may want to disable sending Capability Negotiation OPEN message optional
+   parameter to the peer when remote peer does not implement Capability
+   Negotiation. Please use *dont-capability-negotiate* command to disable the
+   feature.
 
-Autonomous System
-=================
+.. index:: neighbor PEER dont-capability-negotiate
+.. clicmd:: neighbor PEER dont-capability-negotiate
 
-The :abbr:`AS (Autonomous System)` number is one of the essential element of
-BGP. BGP is a distance vector routing protocol, and the AS-Path framework
-provides distance vector metric and loop detection to BGP. :rfc:`1930` provides
-some background on the concepts of an AS.
+.. index:: no neighbor PEER dont-capability-negotiate
+.. clicmd:: no neighbor PEER dont-capability-negotiate
 
-The AS number is a two octet value, ranging in value from 1 to 65535. The AS
-numbers 64512 through 65535 are defined as private AS numbers. Private AS
-numbers must not to be advertised in the global Internet.
+   Suppress sending Capability Negotiation as OPEN message optional parameter
+   to the peer. This command only affects the peer is configured other than
+   IPv4 unicast configuration.
 
-.. _display-bgp-routes-by-as-path:
+   When remote peer does not have capability negotiation feature, remote peer
+   will not send any capabilities at all. In that case, bgp configures the peer
+   with configured capabilities.
 
-Display BGP Routes by AS Path
------------------------------
+   You may prefer locally configured capabilities more than the negotiated
+   capabilities even though remote peer sends capabilities. If the peer is
+   configured by *override-capability*, *bgpd* ignores received capabilities
+   then override negotiated capabilities with configured values.
 
-To show BGP routes which has specific AS path information `show ip bgp` command
-can be used.
+.. index:: neighbor PEER override-capability
+.. clicmd:: neighbor PEER override-capability
 
-.. index:: show bgp ipv4|ipv6 regexp LINE
-.. clicmd:: show bgp ipv4|ipv6 regexp LINE
+.. index:: no neighbor PEER override-capability
+.. clicmd:: no neighbor PEER override-capability
 
-   This commands displays BGP routes that matches a regular
-   expression `line` (:ref:`bgp-regular-expressions`).
+   Override the result of Capability Negotiation with local configuration.
+   Ignore remote peer's capability value.
 
-.. _as-path-access-list:
+.. _bgp-as-path-access-lists:
 
-AS Path Access List
--------------------
+AS Path Access Lists
+--------------------
 
 AS path access list is user defined AS path.
 
@@ -917,7 +968,7 @@ AS path access list is user defined AS p
 .. index:: no ip as-path access-list WORD permit|deny LINE
 .. clicmd:: no ip as-path access-list WORD permit|deny LINE
 
-.. _using-as-path-in-route-map:
+.. _bgp-using-as-path-in-route-map:
 
 Using AS Path in Route Map
 --------------------------
@@ -936,116 +987,188 @@ Using AS Path in Route Map
 
    Prepend the existing last AS number (the leftmost ASN) to the AS_PATH.
 
-.. _private-as-numbers:
-
-Private AS Numbers
-------------------
-
 .. _bgp-communities-attribute:
 
-BGP Communities Attribute
-=========================
+Communities Attribute
+---------------------
 
-BGP communities attribute is widely used for implementing policy routing.
+The BGP communities attribute is widely used for implementing policy routing.
 Network operators can manipulate BGP communities attribute based on their
 network policy. BGP communities attribute is defined in :rfc:`1997` and
 :rfc:`1998`. It is an optional transitive attribute, therefore local policy can
 travel through different autonomous system.
 
-Communities attribute is a set of communities values. Each communities value is
-4 octet long. The following format is used to define communities value.
+The communities attribute is a set of communities values. Each community value
+is 4 octet long. The following format is used to define the community value.
 
-
-AS:VAL
+``AS:VAL``
    This format represents 4 octet communities value. ``AS`` is high order 2
    octet in digit format. ``VAL`` is low order 2 octet in digit format. This
    format is useful to define AS oriented policy value. For example,
    ``7675:80`` can be used when AS 7675 wants to pass local policy value 80 to
    neighboring peer.
 
-internet
-   `internet` represents well-known communities value 0.
+``internet``
+   ``internet`` represents well-known communities value 0.
+
+``graceful-shutdown``
+   ``graceful-shutdown`` represents well-known communities value
+   ``GRACEFUL_SHUTDOWN`` ``0xFFFF0000`` ``65535:0``. :rfc:`8326` implements
+   the purpose Graceful BGP Session Shutdown to reduce the amount of
+   lost traffic when taking BGP sessions down for maintainance. The use
+   of the community needs to be supported from your peers side to
+   actually have any effect.
+
+``accept-own``
+   ``accept-own`` represents well-known communities value ``ACCEPT_OWN``
+   ``0xFFFF0001`` ``65535:1``. :rfc:`7611` implements a way to signal
+   to a router to accept routes with a local nexthop address. This
+   can be the case when doing policing and having traffic having a
+   nexthop located in another VRF but still local interface to the
+   router. It is recommended to read the RFC for full details.
+
+``route-filter-translated-v4``
+   ``route-filter-translated-v4`` represents well-known communities value
+   ``ROUTE_FILTER_TRANSLATED_v4`` ``0xFFFF0002`` ``65535:2``.
+
+``route-filter-v4``
+   ``route-filter-v4`` represents well-known communities value
+   ``ROUTE_FILTER_v4`` ``0xFFFF0003`` ``65535:3``.
+
+``route-filter-translated-v6``
+   ``route-filter-translated-v6`` represents well-known communities value
+   ``ROUTE_FILTER_TRANSLATED_v6`` ``0xFFFF0004`` ``65535:4``.
+
+``route-filter-v6``
+   ``route-filter-v6`` represents well-known communities value
+   ``ROUTE_FILTER_v6`` ``0xFFFF0005`` ``65535:5``.
+
+``llgr-stale``
+   ``llgr-stale`` represents well-known communities value ``LLGR_STALE``
+   ``0xFFFF0006`` ``65535:6``.
+   Assigned and intented only for use with routers supporting the
+   Long-lived Graceful Restart Capability  as described in
+   :rfc:`draft-uttaro-idr-bgp-persistence`.
+   Routers recieving routes with this community may (depending on
+   implementation) choose allow to reject or modify routes on the
+   presence or absence of this community.
+
+``no-llgr``
+   ``no-llgr`` represents well-known communities value ``NO_LLGR``
+   ``0xFFFF0007`` ``65535:7``.
+   Assigned and intented only for use with routers supporting the
+   Long-lived Graceful Restart Capability  as described in
+   :rfc:`draft-uttaro-idr-bgp-persistence`.
+   Routers recieving routes with this community may (depending on
+   implementation) choose allow to reject or modify routes on the
+   presence or absence of this community.
+
+``accept-own-nexthop``
+   ``accept-own-nexthop`` represents well-known communities value
+   ``accept-own-nexthop`` ``0xFFFF0008`` ``65535:8``.
+   :rfc:`draft-agrewal-idr-accept-own-nexthop` describes
+   how to tag and label VPN routes to be able to send traffic between VRFs
+   via an internal layer 2 domain on the same PE device. Refer to
+   :rfc:`draft-agrewal-idr-accept-own-nexthop` for full details.
+
+``blackhole``
+   ``blackhole`` represents well-known communities value ``BLACKHOLE``
+   ``0xFFFF029A`` ``65535:666``. :rfc:`7999` documents sending prefixes to
+   EBGP peers and upstream for the purpose of blackholing traffic.
+   Prefixes tagged with the this community should normally not be
+   re-advertised from neighbors of the originating network. It is
+   recommended upon receiving prefixes tagged with this community to
+   add ``NO_EXPORT`` and ``NO_ADVERTISE``.
 
-no-export
+``no-export``
    ``no-export`` represents well-known communities value ``NO_EXPORT``
    ``0xFFFFFF01``. All routes carry this value must not be advertised to
    outside a BGP confederation boundary. If neighboring BGP peer is part of BGP
    confederation, the peer is considered as inside a BGP confederation
    boundary, so the route will be announced to the peer.
 
-no-advertise
+``no-advertise``
    ``no-advertise`` represents well-known communities value ``NO_ADVERTISE``
    ``0xFFFFFF02``. All routes carry this value must not be advertise to other
    BGP peers.
 
-local-AS
+``local-AS``
    ``local-AS`` represents well-known communities value ``NO_EXPORT_SUBCONFED``
    ``0xFFFFFF03``. All routes carry this value must not be advertised to
    external BGP peers. Even if the neighboring router is part of confederation,
    it is considered as external BGP peer, so the route will not be announced to
    the peer.
 
-When BGP communities attribute is received, duplicated communities value in the
-communities attribute is ignored and each communities values are sorted in
-numerical order.
+``no-peer``
+   ``no-peer`` represents well-known communities value ``NOPEER``
+   ``0xFFFFFF04``  ``65535:65284``. :rfc:`3765` is used to communicate to
+   another network how the originating network want the prefix propagated.
 
-.. _bgp-community-lists:
+When the communities attribute is received duplicate community values in the
+attribute are ignored and value is sorted in numerical order.
 
-BGP Community Lists
--------------------
+.. _bgp-community-lists:
 
-BGP community list is a user defined BGP communities attribute list. BGP
-community list can be used for matching or manipulating BGP communities
-attribute in updates.
-
-There are two types of community list. One is standard community list and
-another is expanded community list. Standard community list defines communities
-attribute. Expanded community list defines communities attribute string with
-regular expression. Standard community list is compiled into binary format when
-user define it. Standard community list will be directly compared to BGP
-communities attribute in BGP updates. Therefore the comparison is faster than
-expanded community list.
+Community Lists
+^^^^^^^^^^^^^^^
+Community lists are user defined lists of community attribute values. These
+lists can be used for matching or manipulating the communities attribute in
+UPDATE messages.
+
+There are two types of community list:
+
+standard
+   This type accepts an explicit value for the atttribute.
+
+expanded
+   This type accepts a regular expression. Because the regex must be
+   interpreted on each use expanded community lists are slower than standard
+   lists.
 
 .. index:: ip community-list standard NAME permit|deny COMMUNITY
 .. clicmd:: ip community-list standard NAME permit|deny COMMUNITY
 
-   This command defines a new standard community list. COMUNITY is
-   communities value. The COMUNITY is compiled into community structure. We
-   can define multiple community list under same name. In that case match will
-   happen user defined order. Once the community list matches to communities
-   attribute in BGP updates it return permit or deny by the community list
-   definition. When there is no matched entry, deny will be returned. When
-   COMUNITY is empty it matches to any routes.
-
-.. index:: ip community-list expanded NAME permit|deny LINE
-.. clicmd:: ip community-list expanded NAME permit|deny LINE
-
-   This command defines a new expanded community list. COMUNITY is a
-   string expression of communities attribute. COMUNITY can be a
-   regular expression (:ref:`bgp-regular-expressions`) to match
-   the communities attribute in BGP updates.
-
-.. index:: no ip community-list NAME
-.. clicmd:: no ip community-list NAME
-
-.. index:: no ip community-list standard NAME
-.. clicmd:: no ip community-list standard NAME
-
-.. index:: no ip community-list expanded NAME
-.. clicmd:: no ip community-list expanded NAME
-
-   These commands delete community lists specified by NAME. All of
-   community lists shares a single name space. So community lists can be
-   removed simply specifying community lists name.
+   This command defines a new standard community list. ``COMMUNITY`` is
+   communities value. The ``COMMUNITY`` is compiled into community structure.
+   We can define multiple community list under same name. In that case match
+   will happen user defined order. Once the community list matches to
+   communities attribute in BGP updates it return permit or deny by the
+   community list definition. When there is no matched entry, deny will be
+   returned. When ``COMMUNITY`` is empty it matches to any routes.
+
+.. index:: ip community-list expanded NAME permit|deny COMMUNITY
+.. clicmd:: ip community-list expanded NAME permit|deny COMMUNITY
+
+   This command defines a new expanded community list. ``COMMUNITY`` is a
+   string expression of communities attribute. ``COMMUNITY`` can be a regular
+   expression (:ref:`bgp-regular-expressions`) to match the communities
+   attribute in BGP updates.
+
+.. deprecated:: 5.0
+   It is recommended to use the more explicit versions of this command.
 
-.. index:: show ip community-list
-.. clicmd:: show ip community-list
+.. index:: ip community-list NAME permit|deny COMMUNITY
+.. clicmd:: ip community-list NAME permit|deny COMMUNITY
+
+   When the community list type is not specified, the community list type is
+   automatically detected. If ``COMMUNITY`` can be compiled into communities
+   attribute, the community list is defined as a standard community list.
+   Otherwise it is defined as an expanded community list. This feature is left
+   for backward compatibility. Use of this feature is not recommended.
 
-.. index:: show ip community-list NAME
-.. clicmd:: show ip community-list NAME
 
-   This command displays current community list information. When NAME is
-   specified the specified community list's information is shown.
+.. index:: no ip community-list [standard|expanded] NAME
+.. clicmd:: no ip community-list [standard|expanded] NAME
+
+   Deletes the community list specified by ``NAME``. All community lists share
+   the same namespace, so it's not necessary to specify ``standard`` or
+   ``expanded``; these modifiers are purely aesthetic.
+
+.. index:: show ip community-list [NAME]
+.. clicmd:: show ip community-list [NAME]
+
+   Displays community list information. When ``NAME`` is specified the
+   specified community list's information is shown.
 
    ::
 
@@ -1062,10 +1185,10 @@ expanded community list.
        deny internet
 
 
-.. _numbered-bgp-community-lists:
+.. _bgp-numbered-community-lists:
 
-Numbered BGP Community Lists
-----------------------------
+Numbered Community Lists
+^^^^^^^^^^^^^^^^^^^^^^^^
 
 When number is used for BGP community list name, the number has
 special meanings. Community list number in the range from 1 and 99 is
@@ -1077,43 +1200,28 @@ is called as named community lists.
 .. index:: ip community-list (1-99) permit|deny COMMUNITY
 .. clicmd:: ip community-list (1-99) permit|deny COMMUNITY
 
-   This command defines a new community list. (1-99) is standard
-   community list number. Community list name within this range defines
-   standard community list. When `community` is empty it matches to
-   any routes.
+   This command defines a new community list. The argument to (1-99) defines
+   the list identifier.
 
 .. index:: ip community-list (100-199) permit|deny COMMUNITY
 .. clicmd:: ip community-list (100-199) permit|deny COMMUNITY
 
-   This command defines a new community list. (100-199) is expanded
-   community list number. Community list name within this range defines
-   expanded community list.
+   This command defines a new expanded community list. The argument to
+   (100-199) defines the list identifier.
 
-.. index:: ip community-list NAME permit|deny COMMUNITY
-.. clicmd:: ip community-list NAME permit|deny COMMUNITY
+.. _bgp-using-communities-in-route-map:
 
-   When community list type is not specified, the community list type is
-   automatically detected. If COMMUNITY can be compiled into communities
-   attribute, the community list is defined as a standard community list.
-   Otherwise it is defined as an expanded community list. This feature is left
-   for backward compatibility. Use of this feature is not recommended.
+Using Communities in Route Maps
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-.. _bgp-community-in-route-map:
+In :ref:`route-map` we can match on or set the BGP communities attribute. Using
+this feature network operator can implement their network policy based on BGP
+communities attribute.
 
-BGP Community in Route Map
---------------------------
+The ollowing commands can be used in route maps:
 
-In Route Map (:ref:`route-map`), we can match or set BGP
-communities attribute. Using this feature network operator can
-implement their network policy based on BGP communities attribute.
-
-Following commands can be used in Route Map.
-
-.. index:: match community WORD
-.. clicmd:: match community WORD
-
-.. index:: match community WORD exact-match
-.. clicmd:: match community WORD exact-match
+.. index:: match community WORD exact-match [exact-match]
+.. clicmd:: match community WORD exact-match [exact-match]
 
    This command perform match to BGP updates using community list WORD. When
    the one of BGP communities value match to the one of communities value in
@@ -1121,79 +1229,36 @@ Following commands can be used in Route
    happen only when BGP updates have completely same communities value
    specified in the community list.
 
-.. index:: set community none
-.. clicmd:: set community none
+.. index:: set community <none|COMMUNITY> additive
+.. clicmd:: set community <none|COMMUNITY> additive
 
-.. index:: set community COMMUNITY
-.. clicmd:: set community COMMUNITY
+   This command sets the community value in BGP updates.  If the attribute is
+   already configured, the newly provided value replaces the old one unless the
+   ``additive`` keyword is specified, in which case the new value is appended
+   to the existing value.
 
-.. index:: set community COMMUNITY additive
-.. clicmd:: set community COMMUNITY additive
-
-   This command manipulate communities value in BGP updates. When
-   `none` is specified as communities value, it removes entire
-   communities attribute from BGP updates. When `community` is not
-   `none`, specified communities value is set to BGP updates. If
-   BGP updates already has BGP communities value, the existing BGP
-   communities value is replaced with specified `community` value.
-   When `additive` keyword is specified, `community` is appended
-   to the existing communities value.
+   If ``none`` is specified as the community value, the communities attribute
+   is not sent.
 
 .. index:: set comm-list WORD delete
 .. clicmd:: set comm-list WORD delete
 
-   This command remove communities value from BGP communities attribute.
-   The `word` is community list name. When BGP route's communities
-   value matches to the community list `word`, the communities value
-   is removed. When all of communities value is removed eventually, the
-   BGP update's communities attribute is completely removed.
-
-.. _display-bgp-routes-by-community:
-
-Display BGP Routes by Community
--------------------------------
-
-To show BGP routes which has specific BGP communities attribute,
-`show bgp {ipv4|ipv6}` command can be used. The
-`community` and `community-list` subcommand can be used.
-
-.. index:: show bgp ipv4|ipv6 community
-.. clicmd:: show bgp ipv4|ipv6 community
-
-.. index:: show bgp ipv4|ipv6 community COMMUNITY
-.. clicmd:: show bgp ipv4|ipv6 community COMMUNITY
-
-.. index:: show bgp ipv4|ipv6 community COMMUNITY exact-match
-.. clicmd:: show bgp ipv4|ipv6 community COMMUNITY exact-match
-
-   `show bgp {ipv4|ipv6} community` displays BGP routes which has communities
-   attribute. Where the address family can be IPv4 or IPv6 among others. When
-   `community` is specified, BGP routes that matches `community` value is
-   displayed. For this command, `internet` keyword can't be used for
-   `community` value. When `exact-match` is specified, it display only
-   routes that have an exact match.
-
-.. index:: show bgp ipv4|ipv6 community-list WORD
-.. clicmd:: show bgp ipv4|ipv6 community-list WORD
-
-.. index:: show bgp ipv4|ipv6 community-list WORD exact-match
-.. clicmd:: show bgp ipv4|ipv6 community-list WORD exact-match
-
-   This commands display BGP routes for the address family specified that matches
-   community list `word`. When `exact-match` is specified, display only
-   routes that have an exact match.
-
-.. _using-bgp-communities-attribute:
-
-Using BGP Communities Attribute
--------------------------------
-
-Following configuration is the most typical usage of BGP communities
-attribute. AS 7675 provides upstream Internet connection to AS 100.
-When following configuration exists in AS 7675, AS 100 networks
-operator can set local preference in AS 7675 network by setting BGP
-communities attribute to the updates.
-
+   This command remove communities value from BGP communities attribute.  The
+   ``word`` is community list name. When BGP route's communities value matches
+   to the community list ``word``, the communities value is removed. When all
+   of communities value is removed eventually, the BGP update's communities
+   attribute is completely removed.
+
+.. _bgp-communities-example:
+
+Example Configuration
+^^^^^^^^^^^^^^^^^^^^^
+
+The following configuration is exemplary of the most typical usage of BGP
+communities attribute. In the example, AS 7675 provides an upstream Internet
+connection to AS 100. When the following configuration exists in AS 7675, the
+network operator of AS 100 can set local preference in AS 7675 network by
+setting BGP communities attribute to the updates.
 
 .. code-block:: frr
 
@@ -1223,10 +1288,9 @@ communities attribute to the updates.
     set local-preference 90
 
 
-Following configuration announce 10.0.0.0/8 from AS 100 to AS 7675.
-The route has communities value 7675:80 so when above configuration
-exists in AS 7675, announced route's local preference will be set to
-value 80.
+The following configuration announces ``10.0.0.0/8`` from AS 100 to AS 7675.
+The route has communities value ``7675:80`` so when above configuration exists
+in AS 7675, the announced routes' local preference value will be set to 80.
 
 .. code-block:: frr
 
@@ -1244,11 +1308,11 @@ value 80.
     set community 7675:80
 
 
-Following configuration is an example of BGP route filtering using
-communities attribute. This configuration only permit BGP routes
-which has BGP communities value 0:80 or 0:90. Network operator can
-put special internal communities value at BGP border router, then
-limit the BGP routes announcement into the internal network.
+The following configuration is an example of BGP route filtering using
+communities attribute. This configuration only permit BGP routes which has BGP
+communities value ``0:80`` or ``0:90``. The network operator can set special
+internal communities value at BGP border router, then limit the BGP route
+announcements into the internal network.
 
 .. code-block:: frr
 
@@ -1264,9 +1328,10 @@ limit the BGP routes announcement into t
     match community 1
 
 
-Following example filter BGP routes which has communities value 1:1.
-When there is no match community-list returns deny. To avoid
-filtering all of routes, we need to define permit any at last.
+The following example filters BGP routes which have a community value of
+``1:1``. When there is no match community-list returns ``deny``. To avoid
+filtering all routes, a ``permit`` line is set at the end of the
+community-list.
 
 .. code-block:: frr
 
@@ -1283,11 +1348,10 @@ filtering all of routes, we need to defi
     match community FILTER
 
 
-Communities value keyword `internet` has special meanings in
-standard community lists. In below example `internet` act as
-match any. It matches all of BGP routes even if the route does not
-have communities attribute at all. So community list ``INTERNET``
-is same as above example's ``FILTER``.
+The communities value keyword ``internet`` has special meanings in standard
+community lists. In the below example ``internet`` matches all BGP routes even
+if the route does not have communities attribute at all. So community list
+``INTERNET`` is the same as ``FILTER`` in the previous example.
 
 .. code-block:: frr
 
@@ -1295,10 +1359,10 @@ is same as above example's ``FILTER``.
    ip community-list standard INTERNET permit internet
 
 
-Following configuration is an example of communities value deletion.
-With this configuration communities value 100:1 and 100:2 is removed
-from BGP updates. For communities value deletion, only `permit`
-community-list is used. `deny` community-list is ignored.
+The following configuration is an example of communities value deletion.  With
+this configuration the community values ``100:1`` and ``100:2`` are removed
+from BGP updates. For communities value deletion, only ``permit``
+community-list is used. ``deny`` community-list is ignored.
 
 .. code-block:: frr
 
@@ -1316,8 +1380,8 @@ community-list is used. `deny` community
 
 .. _bgp-extended-communities-attribute:
 
-BGP Extended Communities Attribute
-==================================
+Extended Communities Attribute
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 BGP extended communities attribute is introduced with MPLS VPN/BGP technology.
 MPLS VPN/BGP expands capability of network infrastructure to provide VPN
@@ -1337,25 +1401,21 @@ provides community space structure.
 There are two format to define Extended Community value. One is AS based format
 the other is IP address based format.
 
-*AS:VAL*
-   This is a format to define AS based Extended Community value.
-   `AS` part is 2 octets Global Administrator subfield in Extended
-   Community value. `VAL` part is 4 octets Local Administrator
-   subfield. `7675:100` represents AS 7675 policy value 100.
+``AS:VAL``
+   This is a format to define AS based Extended Community value.  ``AS`` part
+   is 2 octets Global Administrator subfield in Extended Community value.
+   ``VAL`` part is 4 octets Local Administrator subfield. ``7675:100``
+   represents AS 7675 policy value 100.
 
-*IP-Address:VAL*
+``IP-Address:VAL``
    This is a format to define IP address based Extended Community value.
-   `IP-Address` part is 4 octets Global Administrator subfield.
-   `VAL` part is 2 octets Local Administrator subfield.
-   `10.0.0.1:100` represents
+   ``IP-Address`` part is 4 octets Global Administrator subfield.  ``VAL`` part
+   is 2 octets Local Administrator subfield.
 
 .. _bgp-extended-community-lists:
 
-BGP Extended Community Lists
-----------------------------
-
-Expanded Community Lists is a user defined BGP Expanded Community
-Lists.
+Extended Community Lists
+^^^^^^^^^^^^^^^^^^^^^^^^
 
 .. index:: ip extcommunity-list standard NAME permit|deny EXTCOMMUNITY
 .. clicmd:: ip extcommunity-list standard NAME permit|deny EXTCOMMUNITY
@@ -1405,12 +1465,11 @@ Lists.
 .. _bgp-extended-communities-in-route-map:
 
 BGP Extended Communities in Route Map
--------------------------------------
+"""""""""""""""""""""""""""""""""""""
 
 .. index:: match extcommunity WORD
 .. clicmd:: match extcommunity WORD
 
-
 .. index:: set extcommunity rt EXTCOMMUNITY
 .. clicmd:: set extcommunity rt EXTCOMMUNITY
 
@@ -1423,37 +1482,36 @@ BGP Extended Communities in Route Map
 
 .. _bgp-large-communities-attribute:
 
-BGP Large Communities Attribute
-===============================
+Large Communities Attribute
+^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The BGP Large Communities attribute was introduced in Feb 2017 with
 :rfc:`8092`.
 
-The BGP Large Communities Attribute is similar to the BGP Communities
-Attribute except that it has 3 components instead of two and each of
-which are 4 octets in length. Large Communities bring additional
-functionality and convenience over traditional communities, specifically
-the fact that the `GLOBAL` part below is now 4 octets wide allowing
-AS4 operators seamless use.
-
-
-*GLOBAL:LOCAL1:LOCAL2*
-   This is the format to define Large Community values. Referencing
-   :t:`RFC8195, Use of BGP Large Communities` the values are commonly
-   referred to as follows.
-   The `GLOBAL` part is a 4 octet Global Administrator field, common
-   use of this field is the operators AS number.
-   The `LOCAL1` part is a 4 octet Local Data Part 1 subfield referred
-   to as a function.
-   The `LOCAL2` part is a 4 octet Local Data Part 2 field and referred
-   to as the parameter subfield. `65551:1:10` represents AS 65551
-   function 1 and parameter 10.
-   The referenced RFC above gives some guidelines on recommended usage.
+The BGP Large Communities Attribute is similar to the BGP Communities Attribute
+except that it has 3 components instead of two and each of which are 4 octets
+in length. Large Communities bring additional functionality and convenience
+over traditional communities, specifically the fact that the ``GLOBAL`` part
+below is now 4 octets wide allowing seamless use in networks using 4-byte ASNs.
+
+``GLOBAL:LOCAL1:LOCAL2``
+   This is the format to define Large Community values. Referencing :rfc:`8195`
+   the values are commonly referred to as follows:
+
+   - The ``GLOBAL`` part is a 4 octet Global Administrator field, commonly used
+     as the operators AS number.
+   - The ``LOCAL1`` part is a 4 octet Local Data Part 1 subfield referred to as
+     a function.
+   - The ``LOCAL2`` part is a 4 octet Local Data Part 2 field and referred to
+     as the parameter subfield.
+
+   As an example, ``65551:1:10`` represents AS 65551 function 1 and parameter
+   10. The referenced RFC above gives some guidelines on recommended usage.
 
 .. _bgp-large-community-lists:
 
-BGP Large Community Lists
--------------------------
+Large Community Lists
+"""""""""""""""""""""
 
 Two types of large community lists are supported, namely `standard` and
 `expanded`.
@@ -1507,8 +1565,8 @@ Two types of large community lists are s
 
 .. _bgp-large-communities-in-route-map:
 
-BGP Large Communities in Route Map
-----------------------------------
+Large Communities in Route Map
+""""""""""""""""""""""""""""""
 
 .. index:: match large-community LINE
 .. clicmd:: match large-community LINE
@@ -1536,29 +1594,44 @@ BGP Large Communities in Route Map
 
 .. _bgp-vrfs:
 
-BGP VRFs
-========
+VRFs
+----
 
-BPGD supports multiple VRF instances via the *router bgp* command:
+BGP supports multiple VRF instances with the following command:
 
 .. index:: router bgp ASN vrf VRFNAME
 .. clicmd:: router bgp ASN vrf VRFNAME
 
-VRFNAME is matched against VRFs configured in the kernel. When no *vrf VRFNAME*
-is specified, the BGP protocol process belongs to the default VRF.
-
-BGP routes may be leaked (i.e., copied) between a unicast VRF RIB and the VPN
-safi RIB of the default VRF (leaking is also permitted between the unicast RIB
-of the default VRF and VPN).  A shortcut syntax is also available for
-specifying leaking from one vrf to another vrf using the VPN RIB as
-the intemediary.  A common application of the VPN-VRF feature is to
-connect a customer's private routing domain to a provider's VPN service.
-Leaking is configured from the point of view of an individual VRF: ``import``
-refers to routes leaked from VPN to a unicast VRF, whereas ``export`` refers to
-routes leaked from a unicast VRF to VPN.
+``VRFNAME`` is matched against VRFs configured in the kernel. When
+``vrf VRFNAME`` is not specified, the BGP protocol process belongs to the
+default VRF.
+
+With VRF, you can isolate networking information. Having BGP VRF allows you to
+have several BGP instances on the same system process. This solution solves
+scalabiliy issues where the network administrator had previously to run
+separately several BGP processes on each namespace. Now, not only BGP VRF
+solves this, but also this method applies to both kind of VRFs backend: default
+VRF from Linux kernel or network namespaces. Also, having separate BGP
+instances does not imply that the AS number has to be different. For internal
+purposes, it is possible to do iBGP peering from two differents network
+namespaces.
+
+VRF Route Leaking
+^^^^^^^^^^^^^^^^^
+
+BGP routes may be leaked (i.e. copied) between a unicast VRF RIB and the VPN
+SAFI RIB of the default VRF for use in MPLS-based L3VPNs. Unicast routes may
+also be leaked between any VRFs (including the unicast RIB of the default BGP
+instanced). A shortcut syntax is also available for specifying leaking from one
+VRF to another VRF using the default instance's VPN RIB as the intemediary. A
+common application of the VRF-VRF feature is to connect a customer's private
+routing domain to a provider's VPN service. Leaking is configured from the
+point of view of an individual VRF: ``import`` refers to routes leaked from VPN
+to a unicast VRF, whereas ``export`` refers to routes leaked from a unicast VRF
+to VPN.
 
-Required Parameters
--------------------
+Required parameters
+"""""""""""""""""""
 
 Routes exported from a unicast VRF to the VPN RIB must be augmented by two
 parameters:
@@ -1591,10 +1664,10 @@ leaking of sets of routes in various way
 When using the shortcut syntax for vrf-to-vrf leaking, the RD and RT are
 auto-derived.
 
-Configuration
--------------
+General configuration
+"""""""""""""""""""""
 
-Configuration of route leaking between a unicast VRF RIB and the VPN safi RIB
+Configuration of route leaking between a unicast VRF RIB and the VPN SAFI RIB
 of the default VRF is accomplished via commands in the context of a VRF
 address-family:
 
@@ -1691,367 +1764,445 @@ address-family:
    Disables automatic leaking from vrf VRFNAME to the current VRF using
    the VPN RIB as intermediary.
 
-.. _displaying-bgp-information:
-
-Displaying BGP information
-==========================
+.. _bgp-instances-and-views:
 
+Instances and Views
+-------------------
 
-.. _showing-bgp-information:
+A BGP *instance* is a normal BGP process. Routes selected by BGP are installed
+into the kernel routing table.
 
-Showing BGP information
------------------------
+.. note::
+   In previous versions of FRR, running multiple AS's from the same BGP process
+   was not supported; in order to run multiple AS's it was necessary to run
+   multiple BGP processes. This had to be explicitly configured with the
+   ``bgp multiple-instance`` command. Recent versions of FRR support multiple
+   BGP AS's within the same process by simply defining multiple
+   ``router bgp X`` blocks, so the ``multiple-instance`` command is now
+   unnecessary and deprecated.
 
-.. index:: show ip bgp
-.. clicmd:: show ip bgp
-
-.. index:: show ip bgp A.B.C.D
-.. clicmd:: show ip bgp A.B.C.D
+.. index:: router bgp AS-NUMBER
+.. clicmd:: router bgp AS-NUMBER
 
-.. index:: show ip bgp X:X::X:X
-.. clicmd:: show ip bgp X:X::X:X
+   Make a new BGP instance. You can use an arbitrary word for the `name`.
 
-   This command displays BGP routes. When no route is specified it
-   display all of IPv4 BGP routes.
+   .. code-block:: frr
 
-   ::
+      router bgp 1
+       neighbor 10.0.0.1 remote-as 2
+       neighbor 10.0.0.2 remote-as 3
+      !
+      router bgp 2
+       neighbor 10.0.0.3 remote-as 4
+       neighbor 10.0.0.4 remote-as 5
 
-      BGP table version is 0, local router ID is 10.1.1.1
-         Status codes: s suppressed, d damped, h history, * valid, > best, i - internal
-         Origin codes: i - IGP, e - EGP, ? - incomplete
+.. deprecated:: 5.0
+   This command does nothing and can be safely removed.
 
-      Network    Next Hop      Metric LocPrf Weight Path
-         \*> 1.1.1.1/32       0.0.0.0      0   32768 i
+.. index:: bgp multiple-instance
+.. clicmd:: bgp multiple-instance
 
-         Total number of prefixes 1
+   Enable BGP multiple instance feature. Because this is now the default
+   configuration this command will not be displayed in the running
+   configuration.
 
+.. deprecated:: 5.0
+   This command does nothing and can be safely removed.
 
-.. index:: show ip bgp regexp LINE
-.. clicmd:: show ip bgp regexp LINE
+.. index:: no bgp multiple-instance
+.. clicmd:: no bgp multiple-instance
 
-   This command displays BGP routes using AS path regular expression
-   (:ref:`bgp-regular-expressions`).
+   In previous versions of FRR, this command disabled the BGP multiple instance
+   feature. This functionality is automatically turned on when BGP multiple
+   instances or views exist so this command no longer does anything.
+
+BGP views are almost same as normal BGP processes, except that routes selected
+by BGP are not installed into the kernel routing table. The view functionality
+allows the exchange of BGP routing information only without affecting the
+kernel routing tables.
 
-.. index:: show ip bgp community COMMUNITY
-.. clicmd:: show ip bgp community COMMUNITY
+.. index:: router bgp AS-NUMBER view NAME
+.. clicmd:: router bgp AS-NUMBER view NAME
 
-.. index:: show ip bgp community COMMUNITY exact-match
-.. clicmd:: show ip bgp community COMMUNITY exact-match
+   Make a new BGP view. You can use arbitrary word for the ``NAME``. Routes selected by the view are not installed into the kernel routing table.
+   view's route selection result does not go to the kernel routing table.
 
-   This command displays BGP routes using `community`
-   (:ref:`display-bgp-routes-by-community`).
+   With this command, you can setup Route Server like below.
 
-.. index:: show ip bgp community-list WORD
-.. clicmd:: show ip bgp community-list WORD
+   .. code-block:: frr
 
-.. index:: show ip bgp community-list WORD exact-match
-.. clicmd:: show ip bgp community-list WORD exact-match
+      !
+      router bgp 1 view 1
+       neighbor 10.0.0.1 remote-as 2
+       neighbor 10.0.0.2 remote-as 3
+      !
+      router bgp 2 view 2
+       neighbor 10.0.0.3 remote-as 4
+       neighbor 10.0.0.4 remote-as 5
 
-   This command displays BGP routes using community list
-   (:ref:`display-bgp-routes-by-community`).
+.. index:: show [ip] bgp view NAME
+.. clicmd:: show [ip] bgp view NAME
 
-.. index:: show bgp ipv4|ipv6 summary
-.. clicmd:: show bgp ipv4|ipv6 summary
+   Display the routing table of BGP view ``NAME``.
 
-   Show a bgp peer summary for the specified address family.
+.. _bgp-cisco-compatibility:
 
-.. index:: show bgp ipv4|ipv6 neighbor [PEER]
-.. clicmd:: show bgp ipv4|ipv6 neighbor [PEER]
+Cisco Compatibility
+-------------------
 
-   This command shows information on a specific BGP `peer`.
+FRR has commands that change some configuration syntax and default behavior to
+behave more closely to Cisco conventions. These are deprecated and will be
+removed in a future version of FRR.
 
-.. index:: show bgp ipv4|ipv6 dampening dampened-paths
-.. clicmd:: show bgp ipv4|ipv6 dampening dampened-paths
+.. deprecated:: 5.0
+   Please transition to using the FRR specific syntax for your configuration.
 
-   Display paths suppressed due to dampening.
+.. index:: bgp config-type cisco
+.. clicmd:: bgp config-type cisco
 
-.. index:: show bgp ipv4|ipv6 dampening flap-statistics
-.. clicmd:: show bgp ipv4|ipv6 dampening flap-statistics
+   Cisco compatible BGP configuration output.
 
-   Display flap statistics of routes.
+   When this configuration line is specified:
 
-.. _other-bgp-commands:
+   - ``no synchronization`` is displayed.  This command does nothing and is for
+     display purposes only.
+   - ``no auto-summary`` is displayed.
+   - The ``network`` and ``aggregate-address`` arguments are displayed as:
+
+     ::
+
+        A.B.C.D M.M.M.M
+
+        FRR: network 10.0.0.0/8
+        Cisco: network 10.0.0.0
+
+        FRR: aggregate-address 192.168.0.0/24
+        Cisco: aggregate-address 192.168.0.0 255.255.255.0
+
+   Community attribute handling is also different. If no configuration is
+   specified community attribute and extended community attribute are sent to
+   the neighbor. If a user manually disables the feature, the community
+   attribute is not sent to the neighbor. When ``bgp config-type cisco`` is
+   specified, the community attribute is not sent to the neighbor by default.
+   To send the community attribute user has to specify
+   :clicmd:`neighbor A.B.C.D send-community` like so:
 
-Other BGP commands
-------------------
+   .. code-block:: frr
 
-.. index:: clear bgp ipv4|ipv6 \*
-.. clicmd:: clear bgp ipv4|ipv6 \*
+      !
+      router bgp 1
+       neighbor 10.0.0.1 remote-as 1
+       address-family ipv4 unicast
+        no neighbor 10.0.0.1 send-community
+       exit-address-family
+      !
+      router bgp 1
+       neighbor 10.0.0.1 remote-as 1
+       address-family ipv4 unicast
+        neighbor 10.0.0.1 send-community
+       exit-address-family
+      !
 
-   Clear all address family peers.
+.. deprecated:: 5.0
+   Please transition to using the FRR specific syntax for your configuration.
 
-.. index:: clear bgp ipv4|ipv6 PEER
-.. clicmd:: clear bgp ipv4|ipv6 PEER
+.. index:: bgp config-type zebra
+.. clicmd:: bgp config-type zebra
 
-   Clear peers which have addresses of X.X.X.X
+   FRR style BGP configuration. This is the default.
 
-.. index:: clear bgp ipv4|ipv6 PEER soft in
-.. clicmd:: clear bgp ipv4|ipv6 PEER soft in
+.. _bgp-debugging:
 
-   Clear peer using soft reconfiguration.
+Debugging
+---------
 
 .. index:: show debug
 .. clicmd:: show debug
 
-.. index:: debug event
-.. clicmd:: debug event
+   Show all enabled debugs.
 
-.. index:: debug update
-.. clicmd:: debug update
+.. index:: [no] debug bgp neighbor-events
+.. clicmd:: [no] debug bgp neighbor-events
 
-.. index:: debug keepalive
-.. clicmd:: debug keepalive
+   Enable or disable debugging for neighbor events. This provides general
+   information on BGP events such as peer connection / disconnection, session
+   establishment / teardown, and capability negotiation.
 
-.. index:: no debug event
-.. clicmd:: no debug event
+.. index:: [no] debug bgp updates
+.. clicmd:: [no] debug bgp updates
 
-.. index:: no debug update
-.. clicmd:: no debug update
+   Enable or disable debugging for BGP updates. This provides information on
+   BGP UPDATE messages transmitted and received between local and remote
+   instances.
 
-.. index:: no debug keepalive
-.. clicmd:: no debug keepalive
+.. index:: [no] debug bgp keepalives
+.. clicmd:: [no] debug bgp keepalives
 
+   Enable or disable debugging for BGP keepalives. This provides information on
+   BGP KEEPALIVE messages transmitted and received between local and remote
+   instances.
 
-.. _capability-negotiation:
+.. index:: [no] debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>
+.. clicmd:: [no] debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>
 
-Capability Negotiation
-======================
+   Enable or disable debugging for bestpath selection on the specified prefix.
 
-When adding IPv6 routing information exchange feature to BGP. There were some
-proposals. :abbr:`IETF (Internet Engineering Task Force)`
-:abbr:`IDR (Inter Domain Routing)` adopted a proposal called Multiprotocol
-Extension for BGP. The specification is described in :rfc:`2283`. The protocol
-does not define new protocols. It defines new attributes to existing BGP. When
-it is used exchanging IPv6 routing information it is called BGP-4+. When it is
-used for exchanging multicast routing information it is called MBGP.
+.. index:: [no] debug bgp nht
+.. clicmd:: [no] debug bgp nht
 
-*bgpd* supports Multiprotocol Extension for BGP. So if a remote peer supports
-the protocol, *bgpd* can exchange IPv6 and/or multicast routing information.
+   Enable or disable debugging of BGP nexthop tracking.
 
-Traditional BGP did not have the feature to detect a remote peer's
-capabilities, e.g. whether it can handle prefix types other than IPv4 unicast
-routes. This was a big problem using Multiprotocol Extension for BGP in an
-operational network. :rfc:`2842` adopted a feature called Capability
-Negotiation. *bgpd* use this Capability Negotiation to detect the remote peer's
-capabilities. If a peer is only configured as an IPv4 unicast neighbor, *bgpd*
-does not send these Capability Negotiation packets (at least not unless other
-optional BGP features require capability negotiation).
+.. index:: [no] debug bgp update-groups
+.. clicmd:: [no] debug bgp update-groups
 
-By default, FRR will bring up peering with minimal common capability for the
-both sides. For example, if the local router has unicast and multicast
-capabilities and the remote router only has unicast capability the local router
-will establish the connection with unicast only capability. When there are no
-common capabilities, FRR sends Unsupported Capability error and then resets the
-connection.
+   Enable or disable debugging of dynamic update groups. This provides general
+   information on group creation, deletion, join and prune events.
 
-If you want to completely match capabilities with remote peer. Please use
-*strict-capability-match* command.
+.. index:: [no] debug bgp zebra
+.. clicmd:: [no] debug bgp zebra
 
-.. index:: neighbor PEER strict-capability-match
-.. clicmd:: neighbor PEER strict-capability-match
+   Enable or disable debugging of communications between *bgpd* and *zebra*.
 
-.. index:: no neighbor PEER strict-capability-match
-.. clicmd:: no neighbor PEER strict-capability-match
+Dumping Messages and Routing Tables
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-   Strictly compares remote capabilities and local capabilities. If
-   capabilities are different, send Unsupported Capability error then reset
-   connection.
+.. index:: dump bgp all PATH [INTERVAL]
+.. clicmd:: dump bgp all PATH [INTERVAL]
 
-   You may want to disable sending Capability Negotiation OPEN message optional
-   parameter to the peer when remote peer does not implement Capability
-   Negotiation. Please use *dont-capability-negotiate* command to disable the
-   feature.
+.. index:: dump bgp all-et PATH [INTERVAL]
+.. clicmd:: dump bgp all-et PATH [INTERVAL]
 
-.. index:: neighbor PEER dont-capability-negotiate
-.. clicmd:: neighbor PEER dont-capability-negotiate
+.. index:: no dump bgp all [PATH] [INTERVAL]
+.. clicmd:: no dump bgp all [PATH] [INTERVAL]
 
-.. index:: no neighbor PEER dont-capability-negotiate
-.. clicmd:: no neighbor PEER dont-capability-negotiate
+   Dump all BGP packet and events to `path` file.
+   If `interval` is set, a new file will be created for echo `interval` of
+   seconds.  The path `path` can be set with date and time formatting
+   (strftime).  The type all-et enables support for Extended Timestamp Header
+   (:ref:`packet-binary-dump-format`).
 
-   Suppress sending Capability Negotiation as OPEN message optional parameter
-   to the peer. This command only affects the peer is configured other than
-   IPv4 unicast configuration.
+.. index:: dump bgp updates PATH [INTERVAL]
+.. clicmd:: dump bgp updates PATH [INTERVAL]
 
-   When remote peer does not have capability negotiation feature, remote peer
-   will not send any capabilities at all. In that case, bgp configures the peer
-   with configured capabilities.
+.. index:: dump bgp updates-et PATH [INTERVAL]
+.. clicmd:: dump bgp updates-et PATH [INTERVAL]
 
-   You may prefer locally configured capabilities more than the negotiated
-   capabilities even though remote peer sends capabilities. If the peer is
-   configured by *override-capability*, *bgpd* ignores received capabilities
-   then override negotiated capabilities with configured values.
+.. index:: no dump bgp updates [PATH] [INTERVAL]
+.. clicmd:: no dump bgp updates [PATH] [INTERVAL]
 
-.. index:: neighbor PEER override-capability
-.. clicmd:: neighbor PEER override-capability
+   Dump only BGP updates messages to `path` file.
+   If `interval` is set, a new file will be created for echo `interval` of
+   seconds.  The path `path` can be set with date and time formatting
+   (strftime).  The type updates-et enables support for Extended Timestamp
+   Header (:ref:`packet-binary-dump-format`).
 
-.. index:: no neighbor PEER override-capability
-.. clicmd:: no neighbor PEER override-capability
+.. index:: dump bgp routes-mrt PATH
+.. clicmd:: dump bgp routes-mrt PATH
 
-   Override the result of Capability Negotiation with local configuration.
-   Ignore remote peer's capability value.
+.. index:: dump bgp routes-mrt PATH INTERVAL
+.. clicmd:: dump bgp routes-mrt PATH INTERVAL
 
-.. _route-reflector:
+.. index:: no dump bgp route-mrt [PATH] [INTERVAL]
+.. clicmd:: no dump bgp route-mrt [PATH] [INTERVAL]
 
-Route Reflector
-===============
+   Dump whole BGP routing table to `path`. This is heavy process. The path
+   `path` can be set with date and time formatting (strftime). If `interval` is
+   set, a new file will be created for echo `interval` of seconds.
 
-.. index:: bgp cluster-id A.B.C.D
-.. clicmd:: bgp cluster-id A.B.C.D
+   Note: the interval variable can also be set using hours and minutes: 04h20m00.
 
-.. index:: neighbor PEER route-reflector-client
-.. clicmd:: neighbor PEER route-reflector-client
 
-.. index:: no neighbor PEER route-reflector-client
-.. clicmd:: no neighbor PEER route-reflector-client
+.. _bgp-other-commands:
 
+Other BGP Commands
+------------------
 
-.. _route-server:
+.. index:: clear bgp ipv4|ipv6 \*
+.. clicmd:: clear bgp ipv4|ipv6 \*
 
-Route Server
-============
+   Clear all address family peers.
 
-At an Internet Exchange point, many ISPs are connected to each other by the
-"full mesh method". As with internal BGP full mesh formation, this method has a
-scaling problem.
-
-This scaling problem is well known. Route Server is a method to resolve the
-problem. Each ISP's BGP router only peers to Route Server. Route Server serves
-as BGP information exchange to other BGP routers. By applying this method,
-numbers of BGP connections is reduced from O(n*(n-1)/2) to O(n).
-
-Unlike a normal BGP router, Route Server must have several routing tables for
-managing different routing policies for each BGP speaker. We call the routing
-tables as different "views". *bgpd* can work as normal BGP router or Route
-Server or both at the same time.
+.. index:: clear bgp ipv4|ipv6 PEER
+.. clicmd:: clear bgp ipv4|ipv6 PEER
 
-.. _multiple-instance:
+   Clear peers which have addresses of X.X.X.X
 
-Multiple instance
------------------
+.. index:: clear bgp ipv4|ipv6 PEER soft in
+.. clicmd:: clear bgp ipv4|ipv6 PEER soft in
 
-To enable multiple view function of *bgpd*, you must turn on multiple instance
-feature beforehand.
+   Clear peer using soft reconfiguration.
 
-.. index:: bgp multiple-instance
-.. clicmd:: bgp multiple-instance
 
-   Enable BGP multiple instance feature. After this feature is enabled,
-   you can make multiple BGP instances or multiple BGP views.
+.. _bgp-displaying-bgp-information:
 
-.. index:: no bgp multiple-instance
-.. clicmd:: no bgp multiple-instance
+Displaying BGP Information
+==========================
 
-   Disable BGP multiple instance feature. You can not disable this feature
-   when BGP multiple instances or views exist.
+The following four commands display the IPv6 and IPv4 routing tables, depending
+on whether or not the ``ip`` keyword is used.
+Actually, :clicmd:`show ip bgp` command was used on older `Quagga` routing
+daemon project, while :clicmd:`show bgp` command is the new format. The choice
+has been done to keep old format with IPv4 routing table, while new format
+displays IPv6 routing table.
 
-When you want to make configuration more Cisco like one,
+.. index:: show ip bgp
+.. clicmd:: show ip bgp
 
-.. index:: bgp config-type cisco
-.. clicmd:: bgp config-type cisco
+.. index:: show ip bgp A.B.C.D
+.. clicmd:: show ip bgp A.B.C.D
 
-   Cisco compatible BGP configuration output.
+.. index:: show bgp
+.. clicmd:: show bgp
 
-When bgp config-type cisco is specified,
+.. index:: show bgp X:X::X:X
+.. clicmd:: show bgp X:X::X:X
 
-``no synchronization`` is displayed.
-``no auto-summary`` is displayed.
+   These commands display BGP routes. When no route is specified, the default
+   is to display all BGP routes.
 
-The ``network`` and ``aggregate-address`` arguments are displayed as::
+   ::
 
-   A.B.C.D M.M.M.M
+      BGP table version is 0, local router ID is 10.1.1.1
+         Status codes: s suppressed, d damped, h history, * valid, > best, i - internal
+         Origin codes: i - IGP, e - EGP, ? - incomplete
 
-   FRR: network 10.0.0.0/8
-   Cisco: network 10.0.0.0
+      Network    Next Hop      Metric LocPrf Weight Path
+         \*> 1.1.1.1/32       0.0.0.0      0   32768 i
 
-   FRR: aggregate-address 192.168.0.0/24
-   Cisco: aggregate-address 192.168.0.0 255.255.255.0
+         Total number of prefixes 1
 
-Community attribute handling is also different. If no configuration is
-specified community attribute and extended community attribute are sent to the
-neighbor. If a user manually disables the feature, the community attribute is
-not sent to the neighbor. When ``bgp config-type cisco`` is specified, the
-community attribute is not sent to the neighbor by default. To send the
-community attribute user has to specify *neighbor A.B.C.D send-community*
-command.
+Some other commands provide additional options for filtering the output.
 
-.. code-block:: frr
+.. index:: show [ip] bgp regexp LINE
+.. clicmd:: show [ip] bgp regexp LINE
 
-   !
-   router bgp 1
-    neighbor 10.0.0.1 remote-as 1
-    address-family ipv4 unicast
-     no neighbor 10.0.0.1 send-community
-    exit-address-family
-   !
-   router bgp 1
-    neighbor 10.0.0.1 remote-as 1
-    address-family ipv4 unicast
-     neighbor 10.0.0.1 send-community
-    exit-address-family
-   !
+   This command displays BGP routes using AS path regular expression
+   (:ref:`bgp-regular-expressions`).
 
+.. index:: show [ip] bgp summary
+.. clicmd:: show [ip] bgp summary
 
-.. index:: bgp config-type zebra
-.. clicmd:: bgp config-type zebra
+   Show a bgp peer summary for the specified address family.
 
-   FRR style BGP configuration. This is default.
+The old command structure :clicmd:`show ip bgp` may be removed in the future
+and should no longer be used. In order to reach the other BGP routing tables
+other than the IPv6 routing table given by :clicmd:`show bgp`, the new command
+structure is extended with :clicmd:`show bgp [afi] [safi]`.
 
-.. _bgp-instance-and-view:
+.. index:: show bgp [afi] [safi]
+.. clicmd:: show bgp [afi] [safi]
 
-BGP instance and view
----------------------
+.. index:: show bgp <ipv4|ipv6> <unicast|multicast|vpn|labeled-unicast>
+.. clicmd:: show bgp <ipv4|ipv6> <unicast|multicast|vpn|labeled-unicast>
 
-BGP instance is a normal BGP process. The result of route selection goes to the
-kernel routing table. You can setup different AS at the same time when BGP
-multiple instance feature is enabled.
+   These commands display BGP routes for the specific routing table indicated by
+   the selected afi and the selected safi. If no afi and no safi value is given,
+   the command falls back to the default IPv6 routing table
 
-.. index:: router bgp AS-NUMBER
-.. clicmd:: router bgp AS-NUMBER
+.. index:: show bgp [afi] [safi] summary
+.. clicmd:: show bgp [afi] [safi] summary
 
-   Make a new BGP instance. You can use an arbitrary word for the `name`.
+   Show a bgp peer summary for the specified address family, and subsequent
+   address-family.
 
-   .. code-block:: frr
+.. index:: show bgp [afi] [safi] neighbor [PEER]
+.. clicmd:: show bgp [afi] [safi] neighbor [PEER]
 
-      bgp multiple-instance
-      !
-      router bgp 1
-       neighbor 10.0.0.1 remote-as 2
-       neighbor 10.0.0.2 remote-as 3
-      !
-      router bgp 2
-       neighbor 10.0.0.3 remote-as 4
-       neighbor 10.0.0.4 remote-as 5
+   This command shows information on a specific BGP peer of the relevant
+   afi and safi selected.
 
+.. index:: show bgp [afi] [safi] dampening dampened-paths
+.. clicmd:: show bgp [afi] [safi] dampening dampened-paths
 
-BGP view is almost same as normal BGP process. The result of route selection
-does not go to the kernel routing table. BGP view is only for exchanging BGP
-routing information.
+   Display paths suppressed due to dampening of the selected afi and safi
+   selected.
 
-.. index:: router bgp AS-NUMBER view NAME
-.. clicmd:: router bgp AS-NUMBER view NAME
+.. index:: show bgp [afi] [safi] dampening flap-statistics
+.. clicmd:: show bgp [afi] [safi] dampening flap-statistics
 
-   Make a new BGP view. You can use arbitrary word for the `name`. This view's
-   route selection result does not go to the kernel routing table.
+   Display flap statistics of routes of the selected afi and safi selected.
 
-   With this command, you can setup Route Server like below.
+.. _bgp-display-routes-by-community:
 
-   .. code-block:: frr
+Displaying Routes by Community Attribute
+----------------------------------------
 
-      bgp multiple-instance
-      !
-      router bgp 1 view 1
-       neighbor 10.0.0.1 remote-as 2
-       neighbor 10.0.0.2 remote-as 3
-      !
-      router bgp 2 view 2
-       neighbor 10.0.0.3 remote-as 4
-       neighbor 10.0.0.4 remote-as 5
+The following commands allow displaying routes based on their community
+attribute.
+
+.. index:: show [ip] bgp <ipv4|ipv6> community
+.. clicmd:: show [ip] bgp <ipv4|ipv6> community
+
+.. index:: show [ip] bgp <ipv4|ipv6> community COMMUNITY
+.. clicmd:: show [ip] bgp <ipv4|ipv6> community COMMUNITY
+
+.. index:: show [ip] bgp <ipv4|ipv6> community COMMUNITY exact-match
+.. clicmd:: show [ip] bgp <ipv4|ipv6> community COMMUNITY exact-match
+
+   These commands display BGP routes which have the community attribute.
+   attribute. When ``COMMUNITY`` is specified, BGP routes that match that
+   community are displayed. When `exact-match` is specified, it display only
+   routes that have an exact match.
+
+.. index:: show [ip] bgp <ipv4|ipv6> community-list WORD
+.. clicmd:: show [ip] bgp <ipv4|ipv6> community-list WORD
+
+.. index:: show [ip] bgp <ipv4|ipv6> community-list WORD exact-match
+.. clicmd:: show [ip] bgp <ipv4|ipv6> community-list WORD exact-match
+
+   These commands display BGP routes for the address family specified that
+   match the specified community list. When `exact-match` is specified, it
+   displays only routes that have an exact match.
+
+.. _bgp-display-routes-by-as-path:
+
+Displaying Routes by AS Path
+----------------------------
+
+.. index:: show bgp ipv4|ipv6 regexp LINE
+.. clicmd:: show bgp ipv4|ipv6 regexp LINE
+
+   This commands displays BGP routes that matches a regular
+   expression `line` (:ref:`bgp-regular-expressions`).
+
+.. index:: show [ip] bgp ipv4 vpn
+.. clicmd:: show [ip] bgp ipv4 vpn
+
+.. index:: show [ip] bgp ipv6 vpn
+.. clicmd:: show [ip] bgp ipv6 vpn
+
+   Print active IPV4 or IPV6 routes advertised via the VPN SAFI.
+
+.. index:: show bgp ipv4 vpn summary
+.. clicmd:: show bgp ipv4 vpn summary
+
+.. index:: show bgp ipv6 vpn summary
+.. clicmd:: show bgp ipv6 vpn summary
+
+   Print a summary of neighbor connections for the specified AFI/SAFI combination.
+
+
+.. _bgp-route-reflector:
+
+Route Reflector
+===============
+
+.. note:: This documentation is woefully incomplete.
+
+.. index:: bgp cluster-id A.B.C.D
+.. clicmd:: bgp cluster-id A.B.C.D
+
+.. index:: neighbor PEER route-reflector-client
+.. clicmd:: neighbor PEER route-reflector-client
+
+.. index:: no neighbor PEER route-reflector-client
+.. clicmd:: no neighbor PEER route-reflector-client
 
 
 .. _routing-policy:
 
-Routing policy
---------------
+Routing Policy
+==============
 
 You can set different routing policy for a peer. For example, you can set
 different filter for a peer.
@@ -2072,41 +2223,28 @@ different filter for a peer.
      neighbor 10.0.0.1 distribute-list 2 in
     exit-address-family
 
-
 This means BGP update from a peer 10.0.0.1 goes to both BGP view 1 and view 2.
 When the update is inserted into view 1, distribute-list 1 is applied. On the
 other hand, when the update is inserted into view 2, distribute-list 2 is
 applied.
 
-.. _viewing-the-view:
-
-Viewing the view
-----------------
-
-To display routing table of BGP view, you must specify view name.
-
-.. index:: show ip bgp view NAME
-.. clicmd:: show ip bgp view NAME
-
-   Display routing table of BGP view ``NAME``.
 
 .. _bgp-regular-expressions:
 
 BGP Regular Expressions
 =======================
 
-BGP regular expressions are based on `POSIX 1003.2` regular expressions. The
-following description is just a quick subset of the `POSIX` regular
-expressions. Adding to that, the special character '_' is added.
+BGP regular expressions are based on :t:`POSIX 1003.2` regular expressions. The
+following description is just a quick subset of the POSIX regular expressions.
 
 
-.*
+.\*
    Matches any single character.
 
-*
+\*
    Matches 0 or more occurrences of pattern.
 
-+
+\+
    Matches 1 or more occurrences of pattern.
 
 ?
@@ -2119,103 +2257,18 @@ $
    Matches the end of the line.
 
 _
-   Character `_` has special meanings in BGP regular expressions.  It matches
-   to space and comma , and AS set delimiter { and } and AS confederation
-   delimiter `(` and `)`. And it also matches to the beginning of the line and
-   the end of the line. So `_` can be used for AS value boundaries match. This
-   character technically evaluates to `(^|[,{}() ]|$)`.
+   The ``_`` character has special meanings in BGP regular expressions.  It
+   matches to space and comma , and AS set delimiter ``{`` and ``}`` and AS
+   confederation delimiter ``(`` and ``)``. And it also matches to the
+   beginning of the line and the end of the line. So ``_`` can be used for AS
+   value boundaries match. This character technically evaluates to
+   ``(^|[,{}()]|$)``.
 
-.. _how-to-set-up-a-6-bone-connection:
-
-How to set up a 6-Bone connection
-=================================
-
-.. code-block:: frr
-
-   ! bgpd configuration
-   ! ==================
-   !
-   ! MP-BGP configuration
-   !
-   router bgp 7675
-    bgp router-id 10.0.0.1
-    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 remote-as `as-number`
-   !
-    address-family ipv6
-    network 3ffe:506::/32
-    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 activate
-    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 route-map set-nexthop out
-    neighbor 3ffe:1cfa:0:2:2c0:4fff:fe68:a231 remote-as `as-number`
-    neighbor 3ffe:1cfa:0:2:2c0:4fff:fe68:a231 route-map set-nexthop out
-    exit-address-family
-   !
-   ipv6 access-list all permit any
-   !
-   ! Set output nexthop address.
-   !
-   route-map set-nexthop permit 10
-    match ipv6 address all
-    set ipv6 nexthop global 3ffe:1cfa:0:2:2c0:4fff:fe68:a225
-    set ipv6 nexthop local fe80::2c0:4fff:fe68:a225
-   !
-   log file bgpd.log
-   !
-
-
-.. _dump-bgp-packets-and-table:
-
-Dump BGP packets and table
-==========================
-
-.. index:: dump bgp all PATH [INTERVAL]
-.. clicmd:: dump bgp all PATH [INTERVAL]
-
-.. index:: dump bgp all-et PATH [INTERVAL]
-.. clicmd:: dump bgp all-et PATH [INTERVAL]
-
-.. index:: no dump bgp all [PATH] [INTERVAL]
-.. clicmd:: no dump bgp all [PATH] [INTERVAL]
-
-   Dump all BGP packet and events to `path` file.
-   If `interval` is set, a new file will be created for echo `interval` of
-   seconds.  The path `path` can be set with date and time formatting
-   (strftime).  The type all-et enables support for Extended Timestamp Header
-   (:ref:`packet-binary-dump-format`).
-
-.. index:: dump bgp updates PATH [INTERVAL]
-.. clicmd:: dump bgp updates PATH [INTERVAL]
-
-.. index:: dump bgp updates-et PATH [INTERVAL]
-.. clicmd:: dump bgp updates-et PATH [INTERVAL]
-
-.. index:: no dump bgp updates [PATH] [INTERVAL]
-.. clicmd:: no dump bgp updates [PATH] [INTERVAL]
-
-   Dump only BGP updates messages to `path` file.
-   If `interval` is set, a new file will be created for echo `interval` of
-   seconds.  The path `path` can be set with date and time formatting
-   (strftime).  The type updates-et enables support for Extended Timestamp
-   Header (:ref:`packet-binary-dump-format`).
-
-.. index:: dump bgp routes-mrt PATH
-.. clicmd:: dump bgp routes-mrt PATH
-
-.. index:: dump bgp routes-mrt PATH INTERVAL
-.. clicmd:: dump bgp routes-mrt PATH INTERVAL
-
-.. index:: no dump bgp route-mrt [PATH] [INTERVAL]
-.. clicmd:: no dump bgp route-mrt [PATH] [INTERVAL]
-
-   Dump whole BGP routing table to `path`. This is heavy process. The path
-   `path` can be set with date and time formatting (strftime). If `interval` is
-   set, a new file will be created for echo `interval` of seconds.
-
-   Note: the interval variable can also be set using hours and minutes: 04h20m00.
 
 .. _bgp-configuration-examples:
 
-BGP Configuration Examples
-==========================
+Miscellaneous Configuration Examples
+====================================
 
 Example of a session to an upstream, advertising only one prefix to it.
 
@@ -2237,12 +2290,12 @@ Example of a session to an upstream, adv
    ip prefix-list pl-allowed-adv seq 5 permit 82.195.133.0/25
    ip prefix-list pl-allowed-adv seq 10 deny any
 
-A more complex example. With upstream, peer and customer sessions.  Advertising
-global prefixes and NO_EXPORT prefixes and providing actions for customer
-routes based on community values. Extensive use of route-maps and the 'call'
-feature to support selective advertising of prefixes. This example is intended
-as guidance only, it has NOT been tested and almost certainly contains silly
-mistakes, if not serious flaws.
+A more complex example including upstream, peer and customer sessions
+advertising global prefixes and NO_EXPORT prefixes and providing actions for
+customer routes based on community values. Extensive use is made of route-maps
+and the 'call' feature to support selective advertising of prefixes. This
+example is intended as guidance only, it has NOT been tested and almost
+certainly contains silly mistakes, if not serious flaws.
 
 .. code-block:: frr
 
@@ -2448,10 +2501,46 @@ mistakes, if not serious flaws.
    route-map rm-peer-in permit 10
     set community additive 64512:3200
 
+
+Example of how to set up a 6-Bone connection.
+
+.. code-block:: frr
+
+   ! bgpd configuration
+   ! ==================
+   !
+   ! MP-BGP configuration
+   !
+   router bgp 7675
+    bgp router-id 10.0.0.1
+    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 remote-as `as-number`
+   !
+    address-family ipv6
+    network 3ffe:506::/32
+    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 activate
+    neighbor 3ffe:1cfa:0:2:2a0:c9ff:fe9e:f56 route-map set-nexthop out
+    neighbor 3ffe:1cfa:0:2:2c0:4fff:fe68:a231 remote-as `as-number`
+    neighbor 3ffe:1cfa:0:2:2c0:4fff:fe68:a231 route-map set-nexthop out
+    exit-address-family
+   !
+   ipv6 access-list all permit any
+   !
+   ! Set output nexthop address.
+   !
+   route-map set-nexthop permit 10
+    match ipv6 address all
+    set ipv6 nexthop global 3ffe:1cfa:0:2:2c0:4fff:fe68:a225
+    set ipv6 nexthop local fe80::2c0:4fff:fe68:a225
+   !
+   log file bgpd.log
+   !
+
+
 .. include:: routeserver.rst
 
 .. include:: rpki.rst
 
+.. include:: flowspec.rst
 
 .. [#med-transitivity-rant] For some set of objects to have an order, there *must* be some binary ordering relation that is defined for *every* combination of those objects, and that relation *must* be transitive. I.e.:, if the relation operator is <, and if a < b and b < c then that relation must carry over and it *must* be that a < c for the objects to have an order. The ordering relation may allow for equality, i.e. a < b and b < a may both be true and imply that a and b are equal in the order and not distinguished by it, in which case the set has a partial order. Otherwise, if there is an order, all the objects have a distinct place in the order and the set has a total order)
 .. [bgp-route-osci-cond] McPherson, D. and Gill, V. and Walton, D., "Border Gateway Protocol (BGP) Persistent Route Oscillation Condition", IETF RFC3345
diff -urpN frr-frr-5.0.1/doc/user/bugs.rst frr-frr-6.0/doc/user/bugs.rst
--- frr-frr-5.0.1/doc/user/bugs.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/bugs.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,70 @@
+.. index:: Bug Reports
+.. index:: Reporting bugs
+
+.. _bug-reports:
+
+**************
+Reporting Bugs
+**************
+
+This file describes the procedure for reporting FRRouting bugs.  You are asked
+to follow this format when submitting bug reports.
+
+Bugs submitted with woefully incomplete information will receive little
+attention and are likely to be closed. If you hit a suspected bug in an older
+version, you may be asked to test with a later version in your environment.
+
+Often you may be asked for additional information to help solve the bug. Bugs
+may be closed after 30 days of non-response to requests to reconfirm or supply
+additional information.
+
+Please report bugs on the project GitHub issue tracker at
+https://github.com/frrouting/frr/issues
+
+Report Format & Requested Information
+=====================================
+
+When reporting a bug, please provide the following information.
+
+#. Your FRR version if it is a release build, or the commit hash if you built
+   from source.
+
+#. If you compiled from source, please provide your ``./configure`` line,
+   including all option flags.
+
+#. A full list of the FRR daemons you run.
+
+#. Your platform name and version, e.g. ``Ubuntu 18.04``.
+
+#. Problem description.
+
+   - Provide as much information as possible.
+   - Copy and paste relevant commands and their output to describe your network
+     setup.
+   - Topology diagrams are helpful when reporting bugs involving more than one
+     box.
+   - Platform routing tables and interface configurations are useful if you are
+     reporting a routing issue.
+
+   *Please be sure to review the provided information and censor any sensitive
+   material.*
+
+#. All FRR configuration files you use. Again, please be sure to censor any
+   sensitive information. For sensitive v4 / v6 addresses, we ask that you
+   censor the inner octets; e.g., ``192.XXX.XXX.32/24``.
+
+#. If you are reporting a crash and have a core file, please supply a stack
+   trace using GDB:
+
+   ::
+
+      $ gdb exec_file core_file
+        (gdb) bt .
+
+#. Run all FRR daemons with full debugging on and send *only* the portion of
+   logs which are relevant to your problem.
+
+#. Patches, workarounds, and fixes are always welcome.
+
+.. seealso:: :ref:`basic-config-commands`
+
diff -urpN frr-frr-5.0.1/doc/user/conf.py frr-frr-6.0/doc/user/conf.py
--- frr-frr-5.0.1/doc/user/conf.py	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/conf.py	2018-10-08 14:32:57.000000000 +0200
@@ -131,7 +131,8 @@ language = None
 
 # List of patterns, relative to source directory, that match files and
 # directories to ignore when looking for source files.
-exclude_patterns = ['_build', 'rpki.rst', 'routeserver.rst', 'ospf_fundamentals.rst']
+exclude_patterns = ['_build', 'rpki.rst', 'routeserver.rst',
+                    'ospf_fundamentals.rst', 'flowspec.rst']
 
 # The reST default role (used for this markup: `text`) to use for all
 # documents.
@@ -357,6 +358,7 @@ def setup(app):
     app.add_object_type('clicmd', 'clicmd')
     # css overrides for HTML theme
     app.add_stylesheet('overrides.css')
+    app.add_javascript('overrides.js')
     # load Pygments lexer for FRR config syntax
     #
     # NB: in Pygments 2.2+ this can be done with `load_lexer_from_file`, but we
diff -urpN frr-frr-5.0.1/doc/user/eigrpd.rst frr-frr-6.0/doc/user/eigrpd.rst
--- frr-frr-5.0.1/doc/user/eigrpd.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/eigrpd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -60,10 +60,6 @@ Certain signals have special meanings to
 
 .. program:: eigrpd
 
-.. option:: -r, --retain
-
-   When the program terminates, retain routes added by *eigrpd*.
-
 .. _eigrp-configuration:
 
 EIGRP Configuration
diff -urpN frr-frr-5.0.1/doc/user/flowspec.rst frr-frr-6.0/doc/user/flowspec.rst
--- frr-frr-5.0.1/doc/user/flowspec.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/flowspec.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,351 @@
+.. _flowspec:
+
+Flowspec
+========
+
+.. _features-of-the-current-implementation-flowspec:
+
+Overview
+---------
+
+Flowspec introduces a new :abbr:`NLRI (Network Layer Reachability Information)`
+encoding format that is used to distribute traffic rule flow specifications.
+Basically, instead of simply relying on destination IP address for IP prefixes,
+the IP prefix is replaced by a n-tuple consisting of a rule. That rule can be a
+more or less complex combination of the following:
+
+
+- Network source/destination (can be one or the other, or both).
+- Layer 4 information for UDP/TCP: source port, destination port, or any port.
+- Layer 4 information for ICMP type and ICMP code.
+- Layer 4 information for TCP Flags.
+- Layer 3 information: DSCP value, Protocol type, packet length, fragmentation.
+- Misc layer 4 TCP flags.
+
+A combination of the above rules is applied for traffic filtering. This is
+encoded as part of specific BGP extended communities and the action can range
+from the obvious rerouting (to nexthop or to separate VRF) to shaping, or
+discard.
+
+The following IETF drafts and RFCs have been used to implement FRR Flowspec:
+
+- :rfc:`5575`
+- [Draft-IETF-IDR-Flowspec-redirect-IP]_
+
+.. _design-principles-flowspec:
+
+Design Principles
+-----------------
+
+FRR implements the Flowspec client side, that is to say that BGP is able to
+receive Flowspec entries, but is not able to act as manager and send Flowspec
+entries.
+
+Linux provides the following mechanisms to implement policy based routing:
+
+- Filtering the traffic with ``Netfilter``.
+  ``Netfilter`` provides a set of tools like ``ipset`` and ``iptables`` that are
+  powerful enough to be able to filter such Flowspec filter rule.
+
+- using non standard routing tables via ``iproute2`` (via the ``ip rule``
+  command provided by ``iproute2``).
+  ``iproute2`` is already used by FRR's :ref:`pbr` daemon which provides basic
+  policy based routing based on IP source and destination criterion.
+
+Below example is an illustration of what Flowspec will inject in the underlying
+system:
+
+.. code-block:: shell
+
+   # linux shell
+   ipset create match0x102 hash:net,net counters
+   ipset add match0x102 32.0.0.0/16,40.0.0.0/16
+   iptables -N match0x102 -t mangle
+   iptables -A match0x102 -t mangle -j MARK --set-mark 102
+   iptables -A match0x102 -t mangle -j ACCEPT
+   iptables -i ntfp3 -t mangle -I PREROUTING -m set --match-set match0x102
+                src,dst -g match0x102
+   ip rule add fwmark 102 lookup 102
+   ip route add 40.0.0.0/16 via 44.0.0.2 table 102
+
+For handling an incoming Flowspec entry, the following workflow is applied:
+
+- Incoming Flowspec entries are handled by *bgpd*, stored in the BGP RIB.
+- Flowspec entry is installed according to its complexity.
+
+It will be installed if one of the following filtering action is seen on the
+BGP extended community: either redirect IP, or redirect VRF, in conjunction
+with rate option, for redirecting traffic. Or rate option set to 0, for
+discarding traffic.
+
+According to the degree of complexity of the Flowspec entry, it will be
+installed in *zebra* RIB. For more information about what is supported in the
+FRR implementation as rule, see :ref:`flowspec-known-issues` chapter. Flowspec
+entry is split in several parts before being sent to *zebra*.
+
+- *zebra* daemon receives the policy routing configuration
+
+Policy Based Routing entities necessary to policy route the traffic in the
+underlying system, are received by *zebra*. Two filtering contexts will be
+created or appended in ``Netfilter``: ``ipset`` and ``iptable`` context. The
+former is used to define an IP filter based on multiple criterium. For
+instance, an ipset ``net:net`` is based on two ip addresses, while
+``net,port,net`` is based on two ip addresses and one port (for ICMP, UDP, or
+TCP). The way the filtering is used (for example, is src port or dst port
+used?) is defined by the latter filtering context. ``iptable`` command will
+reference the ``ipset`` context and will tell how to filter and what to do. In
+our case, a marker will be set to indicate ``iproute2`` where to forward the
+traffic to. Sometimes, for dropping action, there is no need to add a marker;
+the ``iptable`` will tell to drop all packets matching the ``ipset`` entry.
+
+Configuration Guide
+-------------------
+
+In order to configure an IPv4 Flowspec engine, use the following configuration.
+As of today, it is only possible to configure Flowspec on the default VRF.
+
+.. code-block:: frr
+
+   router bgp <AS>
+     neighbor <A.B.C.D> remote-as <remoteAS>
+     address-family ipv4 flowspec
+      neighbor <A.B.C.D> activate
+    exit
+   exit
+
+You can see Flowspec entries, by using one of the following show commands:
+
+.. index:: show bgp ipv4 flowspec [detail | A.B.C.D]
+.. clicmd:: show bgp ipv4 flowspec [detail | A.B.C.D]
+
+
+Per-interface configuration
+^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+One nice feature to use is the ability to apply Flowspec to a specific
+interface, instead of applying it to the whole machine. Despite the following
+IETF draft [Draft-IETF-IDR-Flowspec-Interface-Set]_ is not implemented, it is
+possible to manually limit Flowspec application to some incoming interfaces.
+Actually, not using it can result to some unexpected behaviour like accounting
+twice the traffic, or slow down the traffic (filtering costs). To limit
+Flowspec to one specific interface, use the following command, under
+`flowspec address-family` node.
+
+.. index:: [no] local-install <IFNAME | any>
+.. clicmd:: [no] local-install <IFNAME | any>
+
+By default, Flowspec is activated on all interfaces. Installing it to a named
+interface will result in allowing only this interface. Conversely, enabling any
+interface will flush all previously configured interfaces.
+
+VRF redirection
+^^^^^^^^^^^^^^^
+
+Another nice feature to configure is the ability to redirect traffic to a
+separate VRF. This feature does not go against the ability to configure
+Flowspec only on default VRF. Actually, when you receive incoming BGP flowspec
+entries on that default VRF, you can redirect traffic to an other VRF.
+
+As a reminder, BGP flowspec entries have a BGP extended community that contains
+a Route Target. Finding out a local VRF based on Route Target consists in the
+following:
+
+- A configuration of each VRF must be done, with its Route Target set
+  Each VRF is being configured within a BGP VRF instance with its own Route
+  Target list. Route Target accepted format matches the following:
+  ``A.B.C.D:U16``, or ``U16:U32``, ``U32:U16``.
+
+- The first VRF with the matching Route Target will be selected to route traffic
+  to. Use the following command under ipv4 unicast address-family node
+
+.. index:: [no] rt redirect import RTLIST...
+.. clicmd:: [no] rt redirect import RTLIST...
+
+In order to illustrate, if the Route Target configured in the Flowspec entry is
+``E.F.G.H:II``, then a BGP VRF instance with the same Route Target will be set
+set.  That VRF will then be selected. The below full configuration example
+depicts how Route Targets are configured and how VRFs and cross VRF
+configuration is done.  Note that the VRF are mapped on Linux Network
+Namespaces. For data traffic to cross VRF boundaries, virtual ethernet
+interfaces are created with private IP adressing scheme.
+
+.. code-block:: frr
+
+   router bgp <ASx>
+    neighbor <A.B.C.D> remote-as <ASz>
+    address-family ipv4 flowspec
+     neighbor A.B.C.D activate
+    exit
+   exit
+   router bgp <ASy> vrf vrf2
+    address-family ipv4 unicast
+     rt redirect import <E.F.G.H:II>
+    exit
+   exit
+
+Flowspec monitoring & troubleshooting
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+You can monitor policy-routing objects by using one of the following commands.
+Those command rely on the filtering contexts configured from BGP, and get the
+statistics information retrieved from the underlying system. In other words,
+those statistics are retrieved from ``Netfilter``.
+
+.. index:: show pbr ipset IPSETNAME | iptable
+.. clicmd:: show pbr ipset IPSETNAME | iptable
+
+``IPSETNAME`` is the policy routing object name created by ``ipset``.  About
+rule contexts, it is possible to know which rule has been configured to
+policy-route some specific traffic. The :clicmd:`show pbr iptable` command
+displays for forwarded traffic, which table is used. Then it is easy to use
+that table identifier to dump the routing table that the forwarded traffic will
+match.
+
+.. code-block:: frr
+
+.. index:: show ip route table TABLEID
+.. clicmd:: show ip route table TABLEID
+
+   ``TABLEID`` is the table number identifier referencing the non standard
+   routing table used in this example.
+
+.. index:: [no] debug bgp flowspec
+.. clicmd:: [no] debug bgp flowspec
+
+   You can troubleshoot Flowspec, or BGP policy based routing. For instance, if
+   you encounter some issues when decoding a Flowspec entry, you should enable
+   :clicmd:`debug bgp flowspec`.
+
+.. index:: [no] debug bgp pbr [error]
+.. clicmd:: [no] debug bgp pbr [error]
+
+   If you fail to apply the flowspec entry into *zebra*, there should be some
+   relationship with policy routing mechanism. Here,
+   :clicmd:`debug bgp pbr error` could help.
+
+   To get information about policy routing contexts created/removed, only use
+   :clicmd:`debug bgp pbr` command.
+
+Ensuring that a Flowspec entry has been correctly installed and that incoming
+traffic is policy-routed correctly can be checked as demonstrated below. First
+of all, you must check whether the Flowspec entry has been installed or not.
+
+.. code-block:: frr
+
+   CLI# show bgp ipv4 flowspec 5.5.5.2/32
+    BGP flowspec entry: (flags 0x418)
+      Destination Address 5.5.5.2/32
+      IP Protocol = 17
+      Destination Port >= 50 , <= 90
+      FS:redirect VRF RT:255.255.255.255:255
+      received for 18:41:37
+      installed in PBR (match0x271ce00)
+
+This means that the Flowspec entry has been installed in an ``iptable`` named
+``match0x271ce00``. Once you have confirmation it is installed, you can check
+whether you find the associate entry by executing following command. You can
+also check whether incoming traffic has been matched by looking at counter
+line.
+
+.. code-block:: frr
+
+   CLI# show pbr ipset match0x271ce00
+   IPset match0x271ce00 type net,port
+        to 5.5.5.0/24:proto 6:80-120 (8)
+           pkts 1000, bytes 1000000
+        to 5.5.5.2:proto 17:50-90 (5)
+           pkts 1692918, bytes 157441374
+
+As you can see, the entry is present. note that an ``iptable`` entry can be
+used to host several Flowspec entries. In order to know where the matching
+traffic is redirected to, you have to look at the policy routing rules. The
+policy-routing is done by forwarding traffic to a routing table number. That
+routing table number is reached by using a ``iptable``. The relationship
+between the routing table number and the incoming traffic is a ``MARKER`` that
+is set by the IPtable referencing the IPSet. In Flowspec case, ``iptable``
+referencing the ``ipset`` context have the same name. So it is easy to know
+which routing table is used by issuing following command:
+
+.. code-block:: frr
+
+   CLI# show pbr iptable
+      IPtable match0x271ce00 action redirect (5)
+        pkts 1700000, bytes 158000000
+        table 257, fwmark 257
+   ...
+
+As you can see, by using following Linux commands, the MARKER ``0x101`` is
+present in both ``iptable`` and ``ip rule`` contexts.
+
+.. code-block:: shell
+
+   # iptables -t mangle --list match0x271ce00 -v
+   Chain match0x271ce00 (1 references)
+   pkts bytes target     prot opt in     out     source              destination
+   1700K  158M MARK       all  --  any    any     anywhere             anywhere
+        MARK set 0x101
+   1700K  158M ACCEPT     all  --  any    any     anywhere             anywhere
+
+   # ip rule list
+   0:from all lookup local
+   0:from all fwmark 0x101 lookup 257
+   32766:from all lookup main
+   32767:from all lookup default
+
+This allows us to see where the traffic is forwarded to.
+
+.. _flowspec-known-issues:
+
+Limitations / Known Issues
+--------------------------
+
+As you can see, Flowspec is rich and can be very complex. As of today, not all
+Flowspec rules will be able to be converted into Policy Based Routing actions.
+
+- The ``Netfilter`` driver is not integrated into FRR yet. Not having this
+  piece of code prevents from injecting flowspec entries into the underlying
+  system.
+
+- There are some limitations around filtering contexts
+
+  If I take example of UDP ports, or TCP ports in Flowspec, the information
+  can be a range of ports, or a unique value. This case is handled.
+  However, complexity can be increased, if the flow is a combination of a list
+  of range of ports and an enumerate of unique values. Here this case is not
+  handled. Similarly, it is not possible to create a filter for both src port
+  and dst port. For instance, filter on src port from [1-1000] and dst port =
+  80. The same kind of complexity is not possible for packet length, ICMP type,
+  ICMP code.
+
+There are some other known issues:
+
+- The validation procedure depicted in :rfc:`5575` is not available.
+
+  This validation procedure has not been implemented, as this feature was not
+  used in the existing setups you shared wih us.
+
+- The filtering action shaper value, if positive, is not used to apply shaping.
+
+  If value is positive, the traffic is redirected to the wished destination,
+  without any other action configured by Flowspec.
+  It is recommended to configure Quality of Service if needed, more globally on
+  a per interface basis.
+
+- Upon an unexpected crash or other event, *zebra* may not have time to flush
+  PBR contexts.
+
+  That is to say ``ipset``, ``iptable`` and ``ip rule`` contexts. This is also a
+  consequence due to the fact that ip rule / ipset / iptables are not discovered
+  at startup (not able to read appropriate contexts coming from Flowspec).
+
+Appendix
+--------
+
+More information with a public presentation that explains the design of Flowspec
+inside FRRouting.
+
+[Presentation]_
+
+.. [Draft-IETF-IDR-Flowspec-redirect-IP] <https://tools.ietf.org/id/draft-ietf-idr-flowspec-redirect-ip-02.txt>
+.. [Draft-IETF-IDR-Flowspec-Interface-Set] <https://tools.ietf.org/id/draft-ietf-idr-flowspec-interfaceset-03.txt>
+.. [Presentation] <https://docs.google.com/presentation/d/1ekQygUAG5yvQ3wWUyrw4Wcag0LgmbW1kV02IWcU4iUg/edit#slide=id.g378f0e1b5e_1_44>
diff -urpN frr-frr-5.0.1/doc/user/index.rst frr-frr-6.0/doc/user/index.rst
--- frr-frr-5.0.1/doc/user/index.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/index.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,11 +1,26 @@
 FRRouting User Guide
 ====================
 
+############
+Introduction
+############
+
+.. _introduction:
 .. toctree::
    :maxdepth: 2
 
    overview
    installation
+   setup
+
+######
+Basics
+######
+
+.. _basics:
+.. toctree::
+   :maxdepth: 2
+
    basic
    vtysh
    filter
@@ -13,9 +28,21 @@ FRRouting User Guide
    ipv6
    kernel
    snmp
+.. modules
+
+#########
+Protocols
+#########
+
+.. _protocols:
+.. toctree::
+   :maxdepth: 2
+
    zebra
+   bfd
    bgp
    babeld
+   ldpd
    eigrpd
    isisd
    nhrpd
@@ -26,7 +53,17 @@ FRRouting User Guide
    ripd
    ripngd
    sharp
+   static
    vnc
-   glossary
-   appendix
 
+########
+Appendix
+########
+
+.. _appendix:
+.. toctree::
+   :maxdepth: 2
+
+   bugs
+   packet-dumps
+   glossary
diff -urpN frr-frr-5.0.1/doc/user/installation.rst frr-frr-6.0/doc/user/installation.rst
--- frr-frr-5.0.1/doc/user/installation.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/installation.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,8 +1,7 @@
 .. _installation:
 
-************
 Installation
-************
+============
 
 .. index:: How to install FRR
 .. index:: Installation
@@ -10,46 +9,73 @@ Installation
 .. index:: Building the system
 .. index:: Making FRR
 
-Several distributions provide packages for FRR. Check your distribution's
-repositories to find out if a suitable version is available.
+This section covers the basics of building, installing and setting up FRR.
 
-FRR depends on various libraries depending on your operating system.
+From Packages
+-------------
 
-After installing these dependencies, change to the frr source directory and
-issue the following commands:
+The project publishes packages for Red Hat, Centos, Debian and Ubuntu on the
+`GitHub releases <https://github.com/FRRouting/frr/releases>`_. page. External
+contributors offer packages for many other platforms including \*BSD, Alpine,
+Gentoo, Docker, and others. There is currently no documentation on how to use
+those but we hope to add it soon.
 
-::
+From Snapcraft
+--------------
 
-  $ ./bootstrap.sh
-  $ ./configure
-  $ make
-  $ make install
+In addition to traditional packages the project also builds and publishes
+universal Snap images, available at https://snapcraft.io/frr.
 
+From Source
+-----------
 
-.. _configure-the-software:
+Building FRR from source is the best way to ensure you have the latest features
+and bug fixes. Details for each supported platform, including dependency
+package listings, permissions, and other gotchas, are in the developer's
+documentation. This section provides a brief overview on the process.
 
-Configure the Software
-======================
+Getting the Source
+^^^^^^^^^^^^^^^^^^
 
+FRR's source is available on the project
+`GitHub page <https://github.com/FRRouting/frr>`_.
 
-.. _the-configure-script:
+.. code-block:: shell
 
-The Configure Script
---------------------
+   git clone https://github.com/FRRouting/frr.git
 
-.. index:: Configuration options
+When building from Git there are several branches to choose from. The
+``master`` branch is the primary development branch. It should be considered
+unstable. Each release has its own branch named ``stable/X.X``, where ``X.X``
+is the release version.
 
-.. index:: Options for configuring
+In addition, release tarballs are published on the GitHub releases page
+`here <https://github.com/FRRouting/frr/releases>`_.
 
-.. index:: Build options
+Configuration
+^^^^^^^^^^^^^
 
+.. index:: Configuration options
+.. index:: Options for configuring
+.. index:: Build options
 .. index:: Distribution configuration
-
 .. index:: Options to `./configure`
 
-FRR has an excellent configure script which automatically detects most
-host configurations.  There are several additional configure options to
-customize the build to include or exclude specific features and dependencies.
+FRR has an excellent configure script which automatically detects most host
+configurations. There are several additional configure options to customize the
+build to include or exclude specific features and dependencies.
+
+First, update the build system. Change into your FRR source directory and issue:
+
+.. code-block:: shell
+
+   ./bootstrap.sh
+
+This will install any missing build scripts and update the Autotools
+configuration. Once this is done you can move on to choosing your configuration
+options from the list below.
+
+.. _frr-configuration:
 
 .. program:: configure
 
@@ -77,6 +103,10 @@ customize the build to include or exclud
 
    Do not build bgpd.
 
+.. option:: --disable-bfdd
+
+   Do not build bfdd.
+
 .. option:: --disable-bgp-announce
 
    Make *bgpd* which does not make bgp announcements at all.  This
@@ -117,11 +147,6 @@ customize the build to include or exclud
 
    Enable Traffic Engineering Extension for ISIS (RFC5305)
 
-.. option:: --enable-multipath <ARG>
-
-   Enable support for Equal Cost Multipath. `ARG` is the maximum number
-   of ECMP paths to allow, set to 0 to allow unlimited number of paths.
-
 .. option:: --enable-realms
 
    Enable the support of Linux Realms. Convert tag values from 1-255 into a
@@ -176,6 +201,23 @@ customize the build to include or exclud
    With this option, we provide a way to strip out these characters for APK dev
    package builds.
 
+.. option:: --enable-multipath=X
+
+   Compile FRR with up to X way ECMP supported.  This number can be from 0-999.
+   For backwards compatability with older configure options when setting X = 0,
+   we will build FRR with 64 way ECMP.  This is needed because there are
+   hardcoded arrays that FRR builds towards, so we need to know how big to
+   make these arrays at build time.
+
+.. option:: --enable-gcov
+
+   Code coverage reports from gcov require adjustments to the C and LD flags.
+   With this option, gcov instrumentation is added to the build and coverage
+   reports are created during execution.  The check-coverage make target is
+   also created to ease report uploading to codecov.io.  The upload requires
+   the COMMIT (git hash) and TOKEN (codecov upload token) environment variables
+   be set.
+
 You may specify any combination of the above options to the configure
 script. By default, the executables are placed in :file:`/usr/local/sbin`
 and the configuration files in :file:`/usr/local/etc`. The :file:`/usr/local/`
@@ -199,10 +241,9 @@ options to the configuration script.
 .. _least-privilege-support:
 
 Least-Privilege Support
------------------------
+"""""""""""""""""""""""
 
 .. index:: FRR Least-Privileges
-
 .. index:: FRR Privileges
 
 Additionally, you may configure zebra to drop its elevated privileges
@@ -237,56 +278,29 @@ only Linux), FRR will retain only minima
 raise these capabilities for brief periods. On systems without libcap, FRR will
 run as the user specified and only raise its UID to 0 for brief periods.
 
-.. _linux-notes:
-
 Linux Notes
------------
-
-.. index:: Configuring FRR
+"""""""""""
 
 .. index:: Building on Linux boxes
-
 .. index:: Linux configurations
 
-There are several options available only to GNU/Linux systems [#]_.
-If you use GNU/Linux, make sure that the current kernel configuration is what
-you want.  FRR will run with any kernel configuration but some recommendations
-do exist.
-
-
-- :makevar:`CONFIG_NETLINK`
-  Kernel/User Netlink socket. This is a brand new feature which enables an
-  advanced interface between the Linux kernel and zebra (:ref:`kernel-interface`).
-- :makevar:`CONFIG_RTNETLINK`
-  Routing messages.
-  This makes it possible to receive Netlink routing messages.  If you
-  specify this option, *zebra* can detect routing information
-  updates directly from the kernel (:ref:`kernel-interface`).
-- :makevar:`CONFIG_IP_MULTICAST`
-  IP: multicasting.
-  This option should be specified when you use *ripd* (:ref:`rip`) or
-  *ospfd* (:ref:`ospfv2`) because these protocols use multicast.
-
-IPv6 support has been added in GNU/Linux kernel version 2.2.  If you
-try to use the FRR IPv6 feature on a GNU/Linux kernel, please
-make sure the following libraries have been installed.  Please note that
-these libraries will not be needed when you uses GNU C library 2.1
-or upper.
-
-- inet6-apps
-
-  The `inet6-apps` package includes basic IPv6 related libraries such
-  as `inet_ntop` and `inet_pton`.  Some basic IPv6 programs such
-  as *ping*, *ftp*, and *inetd* are also
-  included. The `inet-apps` can be found at
-  `ftp://ftp.inner.net/pub/ipv6/ <ftp://ftp.inner.net/pub/ipv6/>`_.
-
-- net-tools
-
-  The `net-tools` package provides an IPv6 enabled interface and routing
-  utility.  It contains *ifconfig*, *route*, *netstat*, and other tools.
-  `net-tools` may be found at http://www.tazenda.demon.co.uk/phil/net-tools/.
-
+There are several options available only to GNU/Linux systems.  If you use
+GNU/Linux, make sure that the current kernel configuration is what you want.
+FRR will run with any kernel configuration but some recommendations do exist.
+
+:makevar:`CONFIG_NETLINK`
+   Kernel/User Netlink socket. This is a enables an advanced interface between
+   the Linux kernel and *zebra* (:ref:`kernel-interface`).
+
+:makevar:`CONFIG_RTNETLINK`
+   This makes it possible to receive Netlink routing messages.  If you specify
+   this option, *zebra* can detect routing information updates directly from
+   the kernel (:ref:`kernel-interface`).
+
+:makevar:`CONFIG_IP_MULTICAST`
+   This option enables IP multicast and should be specified when you use *ripd*
+   (:ref:`rip`) or *ospfd* (:ref:`ospfv2`) because these protocols use
+   multicast.
 
 Linux sysctl settings and kernel modules
 ````````````````````````````````````````
@@ -336,7 +350,7 @@ Additional kernel modules are also neede
    appropriate value.
 
 :makevar:`VRF forwarding`
-   General information on Linux VRF support can be found in
+   General information on Linux VRF support can be found in 
    https://www.kernel.org/doc/Documentation/networking/vrf.txt. Kernel
    support for VRFs was introduced in 4.3 and improved upon through
    4.13, which is the version most used in FRR testing (as of June
@@ -372,63 +386,31 @@ Additional kernel modules are also neede
    included in future kernel versions so upgrading your kernel may also
    address this issue.
 
+   
+Building
+^^^^^^^^
+
+Once you have chosen your configure options, run the configure script and pass
+the options you chose:
+
+.. code-block:: shell
+
+   ./configure \
+       --prefix=/usr \
+       --enable-exampledir=/usr/share/doc/frr/examples/ \
+       --localstatedir=/var/run/frr \
+       --sbindir=/usr/lib/frr \
+       --sysconfdir=/etc/frr \
+       --enable-pimd \
+       --enable-watchfrr \
+       ...
+
+After configuring the software, you are ready to build and install it for your
+system.
 
-.. _build-the-software:
-
-Build the Software
-==================
-
-After configuring the software, you will need to compile it for your system.
-Simply issue the command *make* in the root of the source directory and the
-software will be compiled. Cliff Notes versions of different compilation
-examples can be found in the Developer's Manual Appendix.  If you have *any*
-problems at this stage, please send a bug report :ref:`bug-reports`.
-
-::
-
-  $ ./bootstrap.sh
-  $ ./configure <appropriate to your system>
-  $ make
-
-
-Install the Software
-====================
-
-Installing the software to your system consists of copying the compiled
-programs and supporting files to a standard location. After the
-installation process has completed, these files have been copied
-from your work directory to :file:`/usr/local/bin`, and :file:`/usr/local/etc`.
-
-To install the FRR suite, issue the following command at your shell
-prompt:::
-
-  $ make install
-
-FRR daemons have their own terminal interface or VTY.  After
-installation, you have to setup each beast's port number to connect to
-them. Please add the following entries to :file:`/etc/services`.
-
-::
-
-  zebrasrv      2600/tcp		  # zebra service
-  zebra         2601/tcp		  # zebra vty
-  ripd          2602/tcp		  # RIPd vty
-  ripngd        2603/tcp		  # RIPngd vty
-  ospfd         2604/tcp		  # OSPFd vty
-  bgpd          2605/tcp		  # BGPd vty
-  ospf6d        2606/tcp		  # OSPF6d vty
-  ospfapi       2607/tcp		  # ospfapi
-  isisd         2608/tcp		  # ISISd vty
-  nhrpd         2610/tcp		  # nhrpd vty
-  pimd          2611/tcp		  # PIMd vty
-
-
-If you use a FreeBSD newer than 2.2.8, the above entries are already
-added to :file:`/etc/services` so there is no need to add it. If you
-specify a port number when starting the daemon, these entries may not be
-needed.
+.. code-block:: shell
 
-You may need to make changes to the config files in
-|INSTALL_PREFIX_ETC|. :ref:`config-commands`.
+   make && sudo make install
 
-.. [#] GNU/Linux has very flexible kernel configuration features.
+If everything finishes successfully, FRR should be installed. You should now
+skip to the section on :ref:`basic-setup`.
diff -urpN frr-frr-5.0.1/doc/user/ldpd.rst frr-frr-6.0/doc/user/ldpd.rst
--- frr-frr-5.0.1/doc/user/ldpd.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/ldpd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,309 @@
+.. _ldp:
+
+***
+LDP
+***
+
+The *ldpd* daemon is a standardised protocol that permits exchanging MPLS label
+information between MPLS devices. The LDP protocol creates peering between
+devices, so as to exchange that label information. This information is stored in
+MPLS table of *zebra*, and it injects that MPLS information in the underlying
+system (Linux kernel or OpenBSD system for instance).
+*ldpd* provides necessary options to create a Layer 2 VPN across MPLS network.
+For instance, it is possible to interconnect several sites that share the same
+broadcast domain.
+
+FRR implements LDP as described in :rfc:`5036`; other LDP standard are the
+following ones: :rfc:`6720`, :rfc:`6667`, :rfc:`5919`, :rfc:`5561`, :rfc:`7552`,
+:rfc:`4447`.
+Because MPLS is already available, FRR also supports :rfc:`3031`.
+
+Running Ldpd
+============
+
+The *ldpd* daemon can be invoked with any of the common
+options (:ref:`common-invocation-options`).
+
+The *zebra* daemon must be running before *ldpd* is invoked.
+
+Configuration of *ldpd* is done in its configuration file
+:file:`ldpd.conf`.
+
+
+.. _understanding-ldp:
+
+Understanding LDP principles
+============================
+
+Let's first introduce some definitions that permit understand better the LDP
+protocol:
+
+- `LSR` : Labeled Switch Router. Networking devices handling labels used to
+  forward traffic between and through them.
+
+- `LER` : Labeled Edge Router. A Labeled edge router is located at the edge of
+   an MPLS network, generally between an IP network and an MPLS network.
+
+
+``LDP`` aims at sharing label information across devices. It tries to establish
+peering with remote LDP capable devices, first by discovering using UDP port 646
+, then by peering using TCP port 646. Once the TCP session is established, the
+label information is shared, through label advertisements.
+
+There are different methods to send label advertisement modes. The
+implementation actually supports the following : Liberal Label Retention +
+Downstream Unsolicited + Independent Control.
+The other advertising modes are depicted below, and compared with the current
+implementation.
+
+- Liberal label retention versus conservative mode
+  In liberal mode, every label sent by every LSR is stored in the MPLS table.
+  In conservative mode, only the label that was sent by the best next hop
+  (determined by the IGP metric) for that particular FEC is stored in the MPLS
+  table.
+
+- Independent LSP Control versus ordered LSP Control
+  MPLS has two ways of binding labels to FECs; either through ordered LSP
+  control, or independent LSP control.
+  Ordered LSP control only binds a label to a FEC if it is the egress LSR, or
+  the router received a label binding for a FEC from the next hop router. In
+  this mode, an MPLS router will create a label binding for each FEC and
+  distribute it to its neighbors so long as he has a entry in the RIB for the
+  destination.
+  In the other mode, label bindings are made without any dependencies on another
+  router advertising a label for a particular FEC. Each router makes it own
+  independent decision to create a label for each FEC.
+  By default IOS uses Independent LSP Control, while Juniper implements the
+  Ordered Control. Both modes are interoperable, the difference is that Ordered
+  Control prevent blackholing during the LDP convergence process, at cost of
+  slowing down the convergence itself
+
+- unsolicited downstream versus downstream on demand
+  Downstream on demand label distribution is where an LSR must explicitly
+  request that a label be sent from its downstream router for a particular FEC.
+  Unsolicited label distribution is where a label is sent from the downstream
+  router without the original router requesting it.
+
+.. _configuring-ldpd:
+
+.. _ldp-configuration:
+
+LDP Configuration
+===================
+
+.. index:: [no] mpls ldp
+.. clicmd:: [no] mpls ldp
+
+   Enable or disable LDP daemon
+
+.. index:: [no] router-id A.B.C.D
+.. clicmd:: [no] router-id A.B.C.D
+
+   The following command located under MPLS router node configures the MPLS
+   router-id of the local device.
+
+.. index:: [no] address-family [ipv4 | ipv6]
+.. clicmd:: [no] address-family [ipv4 | ipv6]
+
+   Configure LDP for IPv4 or IPv6 address-family. Located under MPLS route node,
+   this subnode permits configuring the LDP neighbors.
+
+.. index:: [no] interface IFACE
+.. clicmd:: [no] interface IFACE
+
+   Located under MPLS address-family node, use this command to enable or disable
+   LDP discovery per interface. IFACE stands for the interface name where LDP is
+   enabled. By default it is disabled. Once this command executed, the
+   address-family interface node is configured.
+
+.. index:: [no] discovery transport-address A.B.C.D | A:B::C:D
+.. clicmd:: [no] discovery transport-address A.B.C.D | A:B::C:D
+
+   Located under mpls address-family interface node, use this command to set
+   the IPv4 or IPv6 transport-address used by the LDP protocol to talk on this
+   interface.
+
+.. index:: [no] neighbor A.B.C.D password PASSWORD
+.. clicmd:: [no] neighbor A.B.C.D password PASSWORD
+
+   The following command located under MPLS router node configures the router
+   of a LDP device. This device, if found, will have to comply with the
+   configured password. PASSWORD is a clear text password wit its digest sent
+   through the network.
+
+.. index:: [no] neighbor A.B.C.D holdtime HOLDTIME
+.. clicmd:: [no] neighbor A.B.C.D holdtime HOLDTIME
+
+   The following command located under MPLS router node configures the holdtime
+   value in seconds of the LDP neighbor ID. Configuring it triggers a keepalive
+   mechanism. That value can be configured between 15 and 65535 seconds. After
+   this time of non response, the LDP established session will be considered as
+   set to down. By default, no holdtime is configured for the LDP devices.
+
+.. index:: [no] discovery hello holdtime HOLDTIME
+.. clicmd:: [no] discovery hello holdtime HOLDTIME
+
+.. index:: [no] discovery hello interval INTERVAL
+.. clicmd:: [no] discovery hello interval INTERVAL
+
+   INTERVAL value ranges from 1 to 65535 seconds. Default value is 5 seconds.
+   This is the value between each hello timer message sent.
+   HOLDTIME value ranges from 1 to 65535 seconds. Default value is 15 seconds.
+   That value is added as a TLV in the LDP messages.
+
+.. _show-ldp-information:
+
+Show LDP Information
+====================
+
+These commands dump various parts of *ldpd*.
+
+.. index:: show mpls ldp neighbor [A.B.C.D]
+.. clicmd:: show mpls ldp neighbor [A.B.C.D]
+
+   This command dumps the various neighbors discovered. Below example shows that
+   local machine has an operation neighbor with ID set to 1.1.1.1.
+
+   ::
+
+      west-vm# show mpls ldp neighbor
+      AF   ID              State       Remote Address    Uptime
+      ipv4 1.1.1.1         OPERATIONAL 1.1.1.1         00:01:37
+      west-vm#
+
+.. index:: show mpls ldp neighbor [A.B.C.D] capabilities
+.. clicmd:: show mpls ldp neighbor [A.B.C.D] capabilities
+
+.. index:: show mpls ldp neighbor [A.B.C.D] detail
+.. clicmd:: show mpls ldp neighbor [A.B.C.D] detail
+
+   Above commands dump other neighbor information.
+
+.. index:: show mpls ldp discovery [detail]
+.. clicmd:: show mpls ldp discovery [detail]
+
+.. index:: show mpls ldp ipv4 discovery [detail]
+.. clicmd:: show mpls ldp ipv4 discovery [detail]
+
+.. index:: show mpls ldp ipv6 discovery [detail]
+.. clicmd:: show mpls ldp ipv6 discovery [detail]
+
+   Above commands dump discovery information.
+
+.. index:: show mpls ldp ipv4 interface
+.. clicmd:: show mpls ldp ipv4 interface
+
+.. index:: show mpls ldp ipv6 interface
+.. clicmd:: show mpls ldp ipv6 interface
+
+   Above command dumps the IPv4 or IPv6 interface per where LDP is enabled.
+   Below output illustrates what is dumped for IPv4.
+
+   ::
+
+      west-vm# show mpls ldp ipv4 interface
+      AF   Interface   State  Uptime   Hello Timers  ac
+      ipv4 eth1       ACTIVE 00:08:35 5/15           0
+      ipv4 eth3       ACTIVE 00:08:35 5/15           1
+
+
+.. index:: show mpls ldp ipv4|ipv6 binding
+.. clicmd:: show mpls ldp ipv4|ipv6 binding
+
+   Above command dumps the binding obtained through MPLS exchanges with LDP.
+
+   ::
+
+      west-vm# show mpls ldp ipv4 binding
+      AF   Destination          Nexthop         Local Label Remote Label  In Use
+      ipv4 1.1.1.1/32           1.1.1.1         16          imp-null         yes
+      ipv4 2.2.2.2/32           1.1.1.1         imp-null    16                no
+      ipv4 10.0.2.0/24          1.1.1.1         imp-null    imp-null          no
+      ipv4 10.115.0.0/24        1.1.1.1         imp-null    17                no
+      ipv4 10.135.0.0/24        1.1.1.1         imp-null    imp-null          no
+      ipv4 10.200.0.0/24        1.1.1.1         17          imp-null         yes
+      west-vm#
+
+LDP debugging commands
+========================
+
+.. index::
+   simple: debug mpls ldp KIND
+   simple: no debug mpls ldp KIND
+
+.. clicmd:: [no] debug mpls ldp KIND
+
+   Enable or disable debugging messages of a given kind. ``KIND`` can
+   be one of:
+
+   - ``discovery``
+   - ``errors``
+   - ``event``
+   - ``labels``
+   - ``messages``
+   - ``zebra``
+
+LDP Example Configuration
+=========================
+
+Below configuration gives a typical MPLS configuration of a device located in a
+MPLS backbone. LDP is enabled on two interfaces and will attempt to peer with
+two neighbors with router-id set to either 1.1.1.1 or 3.3.3.3.
+
+.. code-block:: frr
+
+   mpls ldp
+    router-id 2.2.2.2
+    neighbor 1.1.1.1 password test
+    neighbor 3.3.3.3 password test
+    !
+    address-family ipv4
+     discovery transport-address 2.2.2.2
+     !
+     interface eth1
+     !
+     interface eth3
+     !
+    exit-address-family
+    !
+
+
+Deploying LDP across a backbone generally is done in a full mesh configuration
+topology. LDP is typically deployed with an IGP like OSPF, that helps discover
+the remote IPs. Below example is an OSPF configuration extract that goes with
+LDP configuration
+
+.. code-block:: frr
+
+   router ospf
+    ospf router-id 2.2.2.2
+     network 0.0.0.0/0 area 0
+    !
+
+
+Below output shows the routing entry on the LER side. The OSPF routing entry
+(10.200.0.0) is associated with Label entry (17), and shows that MPLS push action
+that traffic to that destination will be applied.
+
+::
+
+   north-vm# show ip route
+   Codes: K - kernel route, C - connected, S - static, R - RIP,
+          O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
+          T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
+          F - PBR,
+          > - selected route, * - FIB route
+
+   O>* 1.1.1.1/32 [110/120] via 10.115.0.1, eth2, label 16, 00:00:15
+   O>* 2.2.2.2/32 [110/20] via 10.115.0.1, eth2, label implicit-null, 00:00:15
+   O   3.3.3.3/32 [110/10] via 0.0.0.0, loopback1 onlink, 00:01:19
+   C>* 3.3.3.3/32 is directly connected, loopback1, 00:01:29
+   O>* 10.0.2.0/24 [110/11] via 10.115.0.1, eth2, label implicit-null, 00:00:15
+   O   10.100.0.0/24 [110/10] is directly connected, eth1, 00:00:32
+   C>* 10.100.0.0/24 is directly connected, eth1, 00:00:32
+   O   10.115.0.0/24 [110/10] is directly connected, eth2, 00:00:25
+   C>* 10.115.0.0/24 is directly connected, eth2, 00:00:32
+   O>* 10.135.0.0/24 [110/110] via 10.115.0.1, eth2, label implicit-null, 00:00:15
+   O>* 10.200.0.0/24 [110/210] via 10.115.0.1, eth2, label 17, 00:00:15
+   north-vm#
+
diff -urpN frr-frr-5.0.1/doc/user/ospf6d.rst frr-frr-6.0/doc/user/ospf6d.rst
--- frr-frr-5.0.1/doc/user/ospf6d.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/ospf6d.rst	2018-10-08 14:32:57.000000000 +0200
@@ -101,7 +101,7 @@ OSPF6 interface
 .. index:: ipv6 ospf6 hello-interval HELLOINTERVAL
 .. clicmd:: ipv6 ospf6 hello-interval HELLOINTERVAL
 
-   Sets interface's Hello Interval. Default 40
+   Sets interface's Hello Interval. Default 10
 
 .. index:: ipv6 ospf6 dead-interval DEADINTERVAL
 .. clicmd:: ipv6 ospf6 dead-interval DEADINTERVAL
diff -urpN frr-frr-5.0.1/doc/user/overview.rst frr-frr-6.0/doc/user/overview.rst
--- frr-frr-5.0.1/doc/user/overview.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/overview.rst	2018-10-08 14:32:57.000000000 +0200
@@ -4,64 +4,64 @@
 Overview
 ********
 
-`FRR`_ is a routing software package that provides TCP/IP based
-routing services with routing protocols support such as RIPv1, RIPv2, RIPng,
-OSPFv2, OSPFv3, IS-IS, BGP-4, and BGP-4+ (:ref:`supported-rfcs`). FRR also
-supports special BGP Route Reflector and Route Server behavior.  In addition to
+`FRR`_ is a routing software package that provides TCP/IP based routing
+services with routing protocols support such as BGP, RIP, OSPF, IS-IS and more
+(see :ref:`supported-protocols`). FRR also supports
+special BGP Route Reflector and Route Server behavior.  In addition to
 traditional IPv4 routing protocols, FRR also supports IPv6 routing protocols.
-With SNMP daemon which supports SMUX and AgentX protocol, FRR provides routing
-protocol MIBs (:ref:`snmp-support`).
+With an SNMP daemon that supports the AgentX protocol, FRR provides routing
+protocol MIB read-only access (:ref:`snmp-support`).
 
-FRR uses an advanced software architecture to provide you with a high
-quality, multi server routing engine. FRR has an interactive user
-interface for each routing protocol and supports common client commands.
-Due to this design, you can add new protocol daemons to FRR easily.  You
-can use FRR library as your program's client user interface.
+FRR uses an advanced software architecture to provide you with a high quality,
+multi server routing engine. FRR has an interactive user interface for each
+routing protocol and supports common client commands.  Due to this design, you
+can add new protocol daemons to FRR easily.  You can use FRR library as your
+program's client user interface.
 
 FRR is distributed under the GNU General Public License.
 
+FRR is a fork of `Quagga <http://www.quagga.net/>`_.
+
 .. _about-frr:
 
 About FRR
 =========
 
-Today, TCP/IP networks are covering all of the world.  The Internet has
-been deployed in many countries, companies, and to the home.  When you
-connect to the Internet your packet will pass many routers which have TCP/IP
-routing functionality.
-
-A system with FRR installed acts as a dedicated router.  With FRR,
-your machine exchanges routing information with other routers using routing
-protocols.  FRR uses this information to update the kernel routing table
-so that the right data goes to the right place.  You can dynamically change
-the configuration and you may view routing table information from the FRR
-terminal interface.
+Today, TCP/IP networks are covering all of the world.  The Internet has been
+deployed in many countries, companies, and to the home.  When you connect to
+the Internet your packet will pass many routers which have TCP/IP routing
+functionality.
+
+A system with FRR installed acts as a dedicated router.  With FRR, your machine
+exchanges routing information with other routers using routing protocols.  FRR
+uses this information to update the kernel routing table so that the right data
+goes to the right place.  You can dynamically change the configuration and you
+may view routing table information from the FRR terminal interface.
 
 Adding to routing protocol support, FRR can setup interface's flags,
-interface's address, static routes and so on.  If you have a small network,
-or a stub network, or xDSL connection, configuring the FRR routing
-software is very easy.  The only thing you have to do is to set up the
-interfaces and put a few commands about static routes and/or default routes.
-If the network is rather large, or if the network structure changes
-frequently, you will want to take advantage of FRR's dynamic routing
-protocol support for protocols such as RIP, OSPF, IS-IS or BGP.
-
-Traditionally, UNIX based router configuration is done by
-*ifconfig* and *route* commands.  Status of routing
-table is displayed by *netstat* utility.  Almost of these commands
-work only if the user has root privileges.  FRR has a different system
-administration method.  There are two user modes in FRR.  One is normal
-mode, the other is enable mode.  Normal mode user can only view system
-status, enable mode user can change system configuration.  This UNIX account
-independent feature will be great help to the router administrator.
+interface's address, static routes and so on.  If you have a small network, or
+a stub network, or xDSL connection, configuring the FRR routing software is
+very easy.  The only thing you have to do is to set up the interfaces and put a
+few commands about static routes and/or default routes.  If the network is
+rather large, or if the network structure changes frequently, you will want to
+take advantage of FRR's dynamic routing protocol support for protocols such as
+RIP, OSPF, IS-IS or BGP.
+
+Traditionally, UNIX based router configuration is done by *ifconfig* and
+*route* commands.  Status of routing table is displayed by *netstat* utility.
+Almost of these commands work only if the user has root privileges.  FRR has a
+different system administration method.  There are two user modes in FRR.  One
+is normal mode, the other is enable mode.  Normal mode user can only view
+system status, enable mode user can change system configuration.  This UNIX
+account independent feature will be great help to the router administrator.
 
-Currently, FRR supports common unicast routing protocols, that is BGP,
-OSPF, RIP and IS-IS.  Upcoming for MPLS support, an implementation of LDP is
+Currently, FRR supports common unicast routing protocols, that is BGP, OSPF,
+RIP and IS-IS.  Upcoming for MPLS support, an implementation of LDP is
 currently being prepared for merging.  Implementations of BFD and PIM-SSM
 (IPv4) also exist, but are not actively being worked on.
 
-The ultimate goal of the FRR project is making a productive, quality, free
-TCP/IP routing software package.
+The ultimate goal of the FRR project is making a production-grade, high
+quality, featureful and free IP routing software suite.
 
 
 System Architecture
@@ -73,79 +73,61 @@ System Architecture
 
 .. index:: Software internals
 
-Traditional routing software is made as a one process program which
-provides all of the routing protocol functionalities.  FRR takes a
-different approach.  It is made from a collection of several daemons that
-work together to build the routing table.  There may be several
-protocol-specific routing daemons and zebra the kernel routing manager.
-
-The *ripd* daemon handles the RIP protocol, while
-*ospfd* is a daemon which supports OSPF version 2.
-*bgpd* supports the BGP-4 protocol.  For changing the kernel
-routing table and for redistribution of routes between different routing
-protocols, there is a kernel routing table manager *zebra* daemon.
-It is easy to add a new routing protocol daemons to the entire routing
-system without affecting any other software.  You need to run only the
-protocol daemon associated with routing protocols in use.  Thus, user may
-run a specific daemon and send routing reports to a central routing console.
-
-There is no need for these daemons to be running on the same machine. You
-can even run several same protocol daemons on the same machine.  This
-architecture creates new possibilities for the routing system.
+Traditional routing software is made as a one process program which provides
+all of the routing protocol functionalities. FRR takes a different approach.
+FRR is a suite of daemons that work together to build the routing table. There
+is a daemon for each major supported protocol as well as a middleman daemon
+(*Zebra*) which serves as the broker between these daemons and the kernel.
+
+This architecture allows for high resiliency, since an error, crash or exploit
+in one protocol daemon will generally not affect the others.  It is also
+flexible and extensible since the modularity makes it easy to implement new
+protocols and tie them into the suite.
 
-::
+An illustration of the large scale architecture is given below.
 
-   +----+  +----+  +-----+  +-----+
-   |bgpd|  |ripd|  |ospfd|  |zebra|
-   +----+  +----+  +-----+  +-----+
-                               |
-   +---------------------------|--+
-   |                           v  |
-   |  UNIX Kernel  routing table  |
-   |                              |
-   +------------------------------+
-
-       FRR System Architecture
-
-
-Multi-process architecture brings extensibility, modularity and
-maintainability.  At the same time it also brings many configuration files
-and terminal interfaces.  Each daemon has it's own configuration file and
-terminal interface.  When you configure a static route, it must be done in
-*zebra* configuration file.  When you configure BGP network it must
-be done in *bgpd* configuration file.  This can be a very annoying
-thing.  To resolve the problem, FRR provides integrated user interface
-shell called *vtysh*.  *vtysh* connects to each daemon with
-UNIX domain socket and then works as a proxy for user input.
-
-FRR was planned to use multi-threaded mechanism when it runs with a
-kernel that supports multi-threads.  But at the moment, the thread library
-which comes with GNU/Linux or FreeBSD has some problems with running
-reliable services such as routing software, so we don't use threads at all.
-Instead we use the *select(2)* system call for multiplexing the
-events.
+::
 
+   +----+  +----+  +-----+  +----+  +----+  +----+  +-----+
+   |bgpd|  |ripd|  |ospfd|  |ldpd|  |pbrd|  |pimd|  |.....|
+   +----+  +----+  +-----+  +----+  +----+  +----+  +-----+
+        |       |        |       |       |       |        |
+   +----v-------v--------v-------v-------v-------v--------v
+   |                                                      |
+   |                         Zebra                        |
+   |                                                      |
+   +------------------------------------------------------+
+          |                    |                   |
+          |                    |                   |
+   +------v------+   +---------v--------+   +------v------+
+   |             |   |                  |   |             |
+   | *NIX Kernel |   | Remote dataplane |   | ........... |
+   |             |   |                  |   |             |
+   +-------------+   +------------------+   +-------------+
+
+
+The multi-process architecture brings extensibility, modularity and
+maintainability. At the same time it also brings many configuration files and
+terminal interfaces. Each daemon has its own configuration file and terminal
+interface. When you configure a static route, it must be done in the *Zebra*
+configuration file. When you configure BGP network it must be done in the
+*bgpd* configuration file. This can become difficult to manage. To resolve the
+problem, FRR provides integrated user interface shell called *vtysh*. *vtysh*
+connects to each daemon with UNIX domain socket and then works as a proxy for
+user input.
 
 Supported Platforms
 ===================
 
 .. index:: Supported platforms
-
 .. index:: FRR on other systems
-
 .. index:: Compatibility with other systems
-
 .. index:: Operating systems that support FRR
 
-Currently FRR supports GNU/Linux and BSD. Porting FRR
-to other platforms is not too difficult as platform dependent code should
-most be limited to the *zebra* daemon.  Protocol daemons are mostly
-platform independent. Please let us know when you find out FRR runs on a
-platform which is not listed below.
-
-The list of officially supported platforms are listed below. Note that
-FRR may run correctly on other platforms, and may run with partial
-functionality on further platforms.
+Currently FRR supports GNU/Linux and BSD. Porting FRR to other platforms is not
+too difficult as platform dependent code should be mostly limited to the
+*Zebra* daemon. Protocol daemons are largely platform independent. Please let
+us know if you can get FRR to run on a platform which is not listed below:
 
 - GNU/Linux
 - FreeBSD
@@ -154,28 +136,117 @@ functionality on further platforms.
 
 Versions of these platforms that are older than around 2 years from the point
 of their original release (in case of GNU/Linux, this is since the kernel's
-release on https://kernel.org/) may need some work.  Similarly, the following platforms
-may work with some effort:
+release on https://kernel.org/) may need some work.  Similarly, the following
+platforms may work with some effort:
 
 - Solaris
 - MacOS
 
-Also note that, in particular regarding proprietary platforms, compiler
-and C library choice will affect FRR.  Only recent versions of the
-following C compilers are well-tested:
+Recent versions of the following compilers are well tested:
 
 - GNU's GCC
-- LLVM's clang
+- LLVM's Clang
 - Intel's ICC
 
+.. _supported-protocols:
+
+Supported Protocols vs. Platform
+================================
+
+The following table lists all protocols cross-refrenced to all operating
+systems that have at least CI build tests.  Note that for features, only
+features with system dependencies are included here.
+
+.. role:: mark
+
+.. comment - the :mark:`X` pieces mesh with a little bit of JavaScript and
+   CSS in _static/overrides.{js,css} respectively.  The JS code looks at the
+   presence of the 'Y' 'N' '' '' or 'CP' strings.  This seemed to be the
+   best / least intrusive way of getting a nice table in HTML.  The table
+   will look somewhat shoddy on other sphinx targets like PDF or info (but
+   should still be readable.)
+
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| Daemon / Feature                  | Linux          | OpenBSD      | FreeBSD    | NetBSD     | Solaris    |
++==+================================+================+==============+============+============+============+
+| FRR Core                                                                                                 |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `zebra`                           | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | VRF                            | :mark:`4.8`   | :mark:`N`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | MPLS                           | :mark:`4.5`   | :mark:`Y`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `pbrd` (Policy Routing)           | :mark:`Y`      | :mark:`N`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| WAN / Carrier protocols                                                                                  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `bgpd` (BGP)                      | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | VRF / L3VPN                    | :mark:`4.8`   | :mark:`CP`   | :mark:`CP` | :mark:`CP` | :mark:`CP` |
+|  |                                | :mark:`4.3`   |              |            |            |            |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | EVPN                           | :mark:`4.18`  | :mark:`CP`   | :mark:`CP` | :mark:`CP` | :mark:`CP` |
+|  |                                | :mark:`4.9`   |              |            |            |            |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | VNC (Virtual Network Control)  | :mark:`CP`     | :mark:`CP`   | :mark:`CP` | :mark:`CP` | :mark:`CP` |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | Flowspec                       | :mark:`CP`     | :mark:`CP`   | :mark:`CP` | :mark:`CP` | :mark:`CP` |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `ldpd` (LDP)                      | :mark:`4.5`   | :mark:`Y`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | VPWS / PW                      | :mark:`N`      | :mark:`5.8` | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | VPLS                           | :mark:`N`      | :mark:`5.8` | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `nhrpd` (NHRP)                    | :mark:`Y`      | :mark:`N`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| Link-State Routing                                                                                       |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `ospfd` (OSPFv2)                  | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | Segment Routing                | :mark:`4.12`  | :mark:`N`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `ospf6d` (OSPFv3)                 | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `isisd` (IS-IS)                   | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| Distance-Vector Routing                                                                                  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `ripd` (RIPv2)                    | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `ripngd` (RIPng)                  | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `babeld` (BABEL)                  | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `eigrpd` (EIGRP)                  | :mark:`Y`      | :mark:`Y`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| Multicast Routing                                                                                        |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+| `pimd` (PIM)                      | :mark:`4.18`  | :mark:`N`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | SSM (Source Specific)          | :mark:`Y`      | :mark:`N`    | :mark:`Y`  | :mark:`Y`  | :mark:`Y`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+|  | ASM (Any Source)               | :mark:`Y`      | :mark:`N`    | :mark:`N`  | :mark:`N`  | :mark:`N`  |
++--+--------------------------------+----------------+--------------+------------+------------+------------+
+
+The indicators have the following semantics:
+
+* :mark:`Y` - daemon/feature fully functional
+* :mark:`X.X` - fully functional with kernel version X.X or newer
+* :mark:`X.X` - restricted functionality or impaired performance with kernel version X.X or newer
+* :mark:`CP` - control plane only (i.e. BGP route server / route reflector)
+* :mark:`N` - daemon/feature not supported by operating system
 
 .. _supported-rfcs:
 
 Supported RFCs
-==============
+--------------
 
 FRR implements the following RFCs:
 
+.. note:: This list is incomplete.
+
 - :rfc:`1058`
   :t:`Routing Information Protocol. C.L. Hedrick. Jun-01-1988.`
 - :rfc:`2082`
@@ -212,6 +283,42 @@ FRR implements the following RFCs:
 - :rfc:`3137`
   :t:`OSPF Stub Router Advertisement, A. Retana, L. Nguyen, R. White, A. Zinin,
   D. McPherson. June 2001`
+- :rfc:`4447`
+  :t:`Pseudowire Setup and Maintenance Using the Label Distribution Protocol
+  (LDP), L. Martini, E. Rosen, N. El-Aawar, T. Smith, and G. Heron. April
+  2006.`
+- :rfc:`4762`
+  :t:`Virtual Private LAN Service (VPLS) Using Label Distribution Protocol
+  (LDP) Signaling, M. Lasserre and V. Kompella. January 2007.`
+- :rfc:`5036`
+  :t:`LDP Specification, L. Andersson, I. Minei, and B. Thomas. October 2007.`
+- :rfc:`5561`
+  :t:`LDP Capabilities, B. Thomas, K. Raza, S. Aggarwal, R. Aggarwal, and
+  JL. Le Roux. July 2009.`
+- :rfc:`5918`
+  :t:`Label Distribution Protocol (LDP) 'Typed Wildcard' Forward Equivalence
+  Class (FEC), R. Asati, I. Minei, and B. Thomas. August 2010.`
+- :rfc:`5919`
+  :t:`Signaling LDP Label Advertisement Completion, R. Asati, P. Mohapatra,
+  E. Chen, and B. Thomas. August 2010.`
+- :rfc:`6667`
+  :t:`LDP 'Typed Wildcard' Forwarding Equivalence Class (FEC) for PWid and
+  Generalized PWid FEC Elements, K. Raza, S. Boutros, and C. Pignataro. July
+  2012.`
+- :rfc:`6720`
+  :t:`The Generalized TTL Security Mechanism (GTSM) for the Label Distribution
+  Protocol (LDP), C. Pignataro and R. Asati. August 2012.`
+- :rfc:`7552`
+  :t:`Updates to LDP for IPv6, R. Asati, C. Pignataro, K. Raza, V. Manral,
+  and R. Papneja. June 2015.`
+- :rfc:`5880`
+  :t:`Bidirectional Forwarding Detection (BFD), D. Katz, D. Ward. June 2010`
+- :rfc:`5881`
+  :t:`Bidirectional Forwarding Detection (BFD) for IPv4 and IPv6 (Single Hop),
+  D. Katz, D. Ward. June 2010`
+- :rfc:`5883`
+  :t:`Bidirectional Forwarding Detection (BFD) for Multihop Paths, D. Katz,
+  D. Ward. June 2010`
 
 **When SNMP support is enabled, the following RFCs are also supported:**
 
@@ -235,7 +342,8 @@ How to get FRR
 The official FRR website is located at |PACKAGE_URL| and contains further
 information, as well as links to additional resources.
 
-FRR is a fork of `Quagga <http://www.quagga.net/>`_.
+Several distributions provide packages for FRR. Check your distribution's
+repositories to find out if a suitable version is available.
 
 Mailing Lists
 =============
@@ -269,32 +377,10 @@ results of such discussions are reflecte
 changes, updates to the Development list and either this file or information
 posted at `FRR`_.
 
-.. index:: Bug Reports
-.. index:: Bug hunting
-.. index:: Found a bug?
-.. index:: Reporting bugs
-.. index:: Reporting software errors
-.. index:: Errors in the software
-
-.. _bug-reports:
-
 Bug Reports
 ===========
 
-If you think you have found a bug, please file a bug report on our
-`GitHub issues`_ page.
-
-When you send a bug report, please be careful about the points below.
-
-- Please note what kind of OS you are using.  If you use the IPv6 stack
-  please note that as well.
-- Please show us the results of `netstat -rn` and `ifconfig -a`.
-  Information from zebra's VTY command `show ip route` will also be
-  helpful.
-- Please send your configuration file with the report.  If you specify
-  arguments to the configure script please note that too.
-
-Bug reports help us improve FRR and are very much appreciated.
+For information on reporting bugs, please see :ref:`bug-reports`.
 
 .. _frr: |package-url|
 .. _github: https://github.com/frrouting/frr/
diff -urpN frr-frr-5.0.1/doc/user/packet-dumps.rst frr-frr-6.0/doc/user/packet-dumps.rst
--- frr-frr-5.0.1/doc/user/packet-dumps.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/packet-dumps.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,221 @@
+.. _packet-binary-dump-format:
+
+Packet Binary Dump Format
+=========================
+
+FRR can dump routing protocol packets into a file with a binary format.
+
+It seems to be better that we share the MRT's header format for
+backward compatibility with MRT's dump logs. We should also define the
+binary format excluding the header, because we must support both IP
+v4 and v6 addresses as socket addresses and / or routing entries.
+
+In the last meeting, we discussed to have a version field in the
+header. But Masaki told us that we can define new 'type' value rather
+than having a 'version' field, and it seems to be better because we
+don't need to change header format.
+
+Here is the common header format. This is same as that of MRT.::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                              Time                             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |             Type              |            Subtype            |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                             Length                            |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+
+If 'type' is PROTOCOL_BGP4MP_ET, the common header format will
+contain an additional microsecond field (RFC6396 2011).::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                              Time                             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |             Type              |            Subtype            |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                             Length                            |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                          Microsecond                          |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_STATE_CHANGE, and
+Address Family == IP (version 4)::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Source AS number       |     Destination AS number     |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Interface Index        |      Address Family           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address                      |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address                    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |            Old State          |           New State           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+Where State is the value defined in RFC1771.
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_STATE_CHANGE,
+and Address Family == IP version 6::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Source AS number       |     Destination AS number     |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Interface Index        |      Address Family           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address                      |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address                    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |            Old State          |           New State           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_MESSAGE,
+and Address Family == IP (version 4)::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Source AS number       |     Destination AS number     |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Interface Index        |      Address Family           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address                      |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address                    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                       BGP Message Packet                      |
+    |                                                               |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+Where BGP Message Packet is the whole contents of the
+BGP4 message including header portion.
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_MESSAGE,
+and Address Family == IP version 6::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Source AS number       |     Destination AS number     |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |        Interface Index        |      Address Family           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address                      |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Source IP address (Cont'd)             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address                    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                     Destination IP address (Cont'd)           |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                       BGP Message Packet                      |
+    |                                                               |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_ENTRY,
+and Address Family == IP (version 4)::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |            View #             |            Status             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Time Last Change                       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       Address Family          |    SAFI       | Next-Hop-Len  |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Next Hop Address                       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    | Prefix Length |             Address Prefix [variable]         |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       Attribute Length        |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |      BGP Attribute [variable length]    			|
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+If 'type' is PROTOCOL_BGP4MP, 'subtype' is BGP4MP_ENTRY,
+and Address Family == IP version 6::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |            View #             |            Status             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Time Last Change                       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       Address Family          |    SAFI       | Next-Hop-Len  |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Next Hop Address                       |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Next Hop Address (Cont'd)              |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Next Hop Address (Cont'd)              |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                        Next Hop Address (Cont'd)              |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    | Prefix Length |             Address Prefix [variable]         |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |     Address Prefix (cont'd) [variable]        |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |       Attribute Length        |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |      BGP Attribute [variable length]    			    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+BGP4 Attribute must not contain MP_UNREACH_NLRI. If BGP Attribute has
+MP_REACH_NLRI field, it must has zero length NLRI, e.g., MP_REACH_NLRI has only
+Address Family, SAFI and next-hop values.
+
+If 'type' is PROTOCOL_BGP4MP and 'subtype' is BGP4MP_SNAPSHOT::
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |           View #              |       File Name [variable]    |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+The file specified in "File Name" contains all routing entries,
+which are in the format of ``subtype == BGP4MP_ENTRY``.
+
+::
+
+   Constants:
+
+     /\* type value \*/
+     #define MSG_PROTOCOL_BGP4MP    16
+     #define MSG_PROTOCOL_BGP4MP_ET 17
+     /\* subtype value \*/
+     #define BGP4MP_STATE_CHANGE 0
+     #define BGP4MP_MESSAGE 1
+     #define BGP4MP_ENTRY 2
+     #define BGP4MP_SNAPSHOT 3
diff -urpN frr-frr-5.0.1/doc/user/pbr.rst frr-frr-6.0/doc/user/pbr.rst
--- frr-frr-5.0.1/doc/user/pbr.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/pbr.rst	2018-10-08 14:32:57.000000000 +0200
@@ -33,7 +33,6 @@ Nexthop Groups
 Nexthop groups are a way to encapsulate ECMP information together.  It's a
 listing of ECMP nexthops used to forward packets for when a pbr-map is matched.
 
-.. index:: nexthop-group
 .. clicmd:: nexthop-group NAME
 
    Create a nexthop-group with an associated NAME.  This will put you into a
@@ -46,24 +45,38 @@ listing of ECMP nexthops used to forward
    are used to are allowed here.  The syntax was intentionally kept the same as
    creating nexthops as you would for static routes.
 
+.. clicmd:: [no] pbr table range (10000-4294966272) (10000-4294966272)
+
+   Set or unset the range used to assign numeric table ID's to new
+   nexthop-group tables. Existing tables will not be modified to fit in this
+   range, so it is recommended to configure this before adding nexthop groups.
+
+   .. seealso:: :ref:`pbr-details`
+
+Showing Nexthop Group Information
+---------------------------------
+
+.. clicmd:: show pbr nexthop-groups [NAME]
+
+   Display information on a PBR nexthop-group. If ``NAME`` is omitted, all
+   nexthop groups are shown.
+
 .. _pbr-maps:
 
 PBR Maps
 ========
 
-PBR maps are a way to group policies that we would like to apply
-to individual interfaces.  These policies when applied are matched
-against incoming packets.  If matched the nexthop-group or nexthop
-is used to forward the packets to the end destination
+PBR maps are a way to group policies that we would like to apply to individual
+interfaces. These policies when applied are matched against incoming packets.
+If matched the nexthop-group or nexthop is used to forward the packets to the
+end destination.
 
-.. index:: pbr-map
-.. clicmd:: pbr-map NAME seq (1-1000)
+.. clicmd:: pbr-map NAME seq (1-700)
 
    Create a pbr-map with NAME and sequence number specified.  This command puts
    you into a new submode for pbr-map specification.  To exit this mode type
    exit or end as per normal conventions for leaving a sub-mode.
 
-.. index:: match
 .. clicmd:: match src-ip PREFIX
 
    When a incoming packet matches the source prefix specified, take the packet
diff -urpN frr-frr-5.0.1/doc/user/pim.rst frr-frr-6.0/doc/user/pim.rst
--- frr-frr-5.0.1/doc/user/pim.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/pim.rst	2018-10-08 14:32:57.000000000 +0200
@@ -189,6 +189,11 @@ is in a vrf, enter the interface command
    Tell pim to receive IGMP reports and Query on this interface. The default
    version is v3. This command is useful on the LHR.
 
+.. index:: ip igmp join A.B.C.D A.B.C.D
+.. clicmd:: ip igmp join A.B.C.D A.B.C.D
+
+   Join multicast source-group on an interface.
+
 .. index:: ip igmp query-interval (1-1800)
 .. clicmd:: ip igmp query-interval (1-1800)
 
@@ -247,6 +252,41 @@ vrf is specified then the default vrf is
 'all' allows you to look at all vrfs for the command. Naming a vrf 'all' will
 cause great confusion.
 
+.. index:: show ip igmp interface
+.. clicmd:: show ip igmp interface
+
+   Display IGMP interface information.
+
+.. index:: show ip igmp join
+.. clicmd:: show ip igmp join
+
+   Display IGMP static join information.
+
+.. index:: show ip igmp groups
+.. clicmd:: show ip igmp groups
+
+   Display IGMP groups information.
+
+.. index:: show ip igmp groups retransmissions
+.. clicmd:: show ip igmp groups retransmissions
+
+   Display IGMP group retransmission information.
+
+.. index:: show ip igmp sources
+.. clicmd:: show ip igmp sources
+
+   Display IGMP sources information.
+
+.. index:: show ip igmp sources retransmissions
+.. clicmd:: show ip igmp sources retransmissions
+
+   Display IGMP source retransmission information.
+
+.. index:: show ip igmp statistics
+.. clicmd:: show ip igmp statistics
+
+   Display IGMP statistics information.
+
 .. index:: show ip multicast
 .. clicmd:: show ip multicast
 
@@ -364,6 +404,11 @@ cause great confusion.
 
    Display the multicast RIB created in zebra.
 
+.. index:: mtrace A.B.C.D [A.B.C.D]
+.. clicmd:: mtrace A.B.C.D [A.B.C.D]
+
+   Display multicast traceroute towards source, optionally for particular group.
+
 PIM Debug Commands
 ==================
 
@@ -373,6 +418,21 @@ configure CLI mode. If you specify debug
 mode, the debug commands can be persistent across restarts of the FRR pimd if
 the config was written out.
 
+.. index:: debug igmp
+.. clicmd:: debug igmp
+
+   This turns on debugging for IGMP protocol activity.
+
+.. index:: debug mtrace
+.. clicmd:: debug mtrace
+
+   This turns on debugging for mtrace protocol activity.
+
+.. index:: debug mroute
+.. clicmd:: debug mroute
+
+   This turns on debugging for PIM interaction with kernel MFC cache.
+
 .. index:: debug pim events
 .. clicmd:: debug pim events
 
@@ -406,3 +466,32 @@ the config was written out.
 .. clicmd:: debug pim zebra
 
    This gathers data about events from zebra that come up through the ZAPI.
+
+PIM Clear Commands
+==================
+Clear commands reset various variables.
+
+.. index:: clear ip interfaces
+.. clicmd:: clear ip interfaces
+
+   Reset interfaces.
+
+.. index:: clear ip igmp interfaces
+.. clicmd:: clear ip igmp interfaces
+
+   Reset IGMP interfaces.
+
+.. index:: clear ip mroute
+.. clicmd:: clear ip mroute
+
+   Reset multicast routes.
+
+.. index:: clear ip pim interfaces
+.. clicmd:: clear ip pim interfaces
+
+   Reset PIM interfaces.
+
+.. index:: clear ip pim oil
+.. clicmd:: clear ip pim oil
+
+   Rescan PIM OIL (output interface list).
diff -urpN frr-frr-5.0.1/doc/user/ripd.rst frr-frr-6.0/doc/user/ripd.rst
--- frr-frr-5.0.1/doc/user/ripd.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/ripd.rst	2018-10-08 14:32:57.000000000 +0200
@@ -60,9 +60,6 @@ Certain signals have special meanings to
 *ripd* invocation options. Common options that can be specified
 (:ref:`common-invocation-options`).
 
-.. option:: -r, --retain
-
-   When the program terminates, retain routes added by *ripd*.
 
 .. _rip-netmask:
 
diff -urpN frr-frr-5.0.1/doc/user/routemap.rst frr-frr-6.0/doc/user/routemap.rst
--- frr-frr-5.0.1/doc/user/routemap.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/routemap.rst	2018-10-08 14:32:57.000000000 +0200
@@ -277,6 +277,11 @@ Route Map Set Command
 
    Set the BGP-4+ link local IPv6 nexthop address.
 
+.. index:: set origin ORIGIN <egp|igp|incomplete>
+.. clicmd:: set origin ORIGIN <egp|igp|incomplete>
+
+   Set BGP route origin.
+
 .. _route-map-call-command:
 
 Route Map Call Command
diff -urpN frr-frr-5.0.1/doc/user/rpki.rst frr-frr-6.0/doc/user/rpki.rst
--- frr-frr-5.0.1/doc/user/rpki.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/rpki.rst	2018-10-08 14:32:57.000000000 +0200
@@ -44,6 +44,9 @@ In a nutshell, the current implementatio
 - Route maps can be configured to match a specific RPKI validation state. This
   allows the creation of local policies, which handle BGP routes based on the
   outcome of the Prefix Origin Validation.
+- Updates from the RPKI cache servers are directly applied and path selection
+  is updated accordingly. (Soft reconfiguration **must** be enabled for this
+  to work).
 
 
 .. _enabling-rpki:
@@ -57,12 +60,40 @@ Enabling RPKI
    This command enables the RPKI configuration mode. Most commands that start
    with *rpki* can only be used in this mode.
 
-   When it is used in a telnet session, leaving of this mode cause rpki to be initialized.
+   When it is used in a telnet session, leaving of this mode cause rpki to be
+   initialized.
 
    Executing this command alone does not activate prefix validation. You need
    to configure at least one reachable cache server. See section
    :ref:`configuring-rpki-rtr-cache-servers` for configuring a cache server.
 
+.. index:: RPKI and daemons.conf
+
+When first installing FRR with RPKI support from the pre-packaged binaries.
+Remember to add ``-M rpki`` to the variable ``bgpd_options`` in
+:file:`/etc/frr/daemons.conf` , like so::
+
+   bgpd_options="   --daemon -A 127.0.0.1 -M rpki"
+
+instead of the default setting::
+
+   bgpd_options="   --daemon -A 127.0.0.1"
+
+Otherwise you will encounter an error when trying to enter RPKI
+configuration mode due to the ``rpki`` module not being loaded when the BGP
+daemon is initialized.
+
+Examples of the error::
+
+   router(config)# debug rpki
+   % [BGP] Unknown command: debug rpki
+
+   router(config)# rpki
+   % [BGP] Unknown command: rpki
+
+Note that the RPKI commands will be available in vtysh when running
+``find rpki`` regardless of whether the module is loaded.
+
 .. _configuring-rpki-rtr-cache-servers:
 
 Configuring RPKI/RTR Cache Servers
diff -urpN frr-frr-5.0.1/doc/user/setup.rst frr-frr-6.0/doc/user/setup.rst
--- frr-frr-5.0.1/doc/user/setup.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/setup.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,160 @@
+.. _basic-setup:
+
+Basic Setup
+============
+
+After installing FRR, some basic configuration must be completed before it is
+ready to use.
+
+Daemons File
+------------
+After a fresh install, starting FRR will do nothing. This is because daemons
+must be explicitly enabled by editing a file in your configuration directory.
+This file is usually located at :file:`/etc/frr/daemons` and determines which
+daemons are activated when issuing a service start / stop command via init or
+systemd. The file initially looks like this:
+
+::
+
+   zebra=no
+   bgpd=no
+   ospfd=no
+   ospf6d=no
+   ripd=no
+   ripngd=no
+   isisd=no
+   pimd=no
+   ldpd=no
+   nhrpd=no
+   eigrpd=no
+   babeld=no
+   sharpd=no
+   staticd=no
+   pbrd=no
+   bfdd=no
+
+To enable a particular daemon, simply change the corresponding 'no' to 'yes'.
+Subsequent service restarts should start the daemon.
+
+Daemons Configuration File
+--------------------------
+There is another file that controls the default options passed to daemons when
+starting FRR as a service. This file is located in your configuration
+directory, usually at :file:`/etc/frr/daemons.conf`.
+
+This file has several parts. Here is an example:
+
+::
+
+   #
+   # If this option is set the /etc/init.d/frr script automatically loads
+   # the config via "vtysh -b" when the servers are started.
+   # Check /etc/pam.d/frr if you intend to use "vtysh"!
+   #
+   vtysh_enable=yes
+   zebra_options=" -s 90000000 --daemon -A 127.0.0.1"
+   bgpd_options="   --daemon -A 127.0.0.1"
+   ospfd_options="  --daemon -A 127.0.0.1"
+   ospf6d_options=" --daemon -A ::1"
+   ripd_options="   --daemon -A 127.0.0.1"
+   ripngd_options=" --daemon -A ::1"
+   isisd_options="  --daemon -A 127.0.0.1"
+   pimd_options="  --daemon -A 127.0.0.1"
+   ldpd_options="  --daemon -A 127.0.0.1"
+   nhrpd_options="  --daemon -A 127.0.0.1"
+   eigrpd_options="  --daemon -A 127.0.0.1"
+   babeld_options="  --daemon -A 127.0.0.1"
+   sharpd_options="  --daemon -A 127.0.0.1"
+   staticd_options="  --daemon -A 127.0.0.1"
+   pbrd_options="  --daemon -A 127.0.0.1"
+   bfdd_options="  --daemon -A 127.0.0.1"
+
+   # The list of daemons to watch is automatically generated by the init script.
+   watchfrr_enable=yes
+   watchfrr_options=(-d -r /usr/sbin/servicebBfrrbBrestartbB%s -s /usr/sbin/servicebBfrrbBstartbB%s -k /usr/sbin/servicebBfrrbBstopbB%s -b bB)
+
+   # If valgrind_enable is 'yes' the frr daemons will be started via valgrind.
+   # The use case for doing so is tracking down memory leaks, etc in frr.
+   valgrind_enable=no
+   valgrind=/usr/bin/valgrind
+
+Breaking this file down:
+
+::
+
+   vtysh_enable=yes
+
+As the comment says, this causes :ref:`VTYSH <vty-shell>` to apply
+configuration when starting the daemons. This is useful for a variety of
+reasons touched on in the VTYSH documentation and should generally be enabled.
+
+::
+
+   zebra_options=" -s 90000000 --daemon -A 127.0.0.1"
+   bgpd_options="   --daemon -A 127.0.0.1"
+   ...
+
+The next set of lines controls what options are passed to daemons when started
+from the service script. Usually daemons will have ``--daemon`` and ``-A
+<address>`` specified in order to daemonize and listen for VTY commands on a
+particular address.
+
+::
+
+   # The list of daemons to watch is automatically generated by the init script.
+   watchfrr_enable=yes
+   watchfrr_options=(-d -r /usr/sbin/servicebBfrrbBrestartbB%s -s /usr/sbin/servicebBfrrbBstartbB%s -k /usr/sbin/servicebBfrrbBstopbB%s -b bB)
+
+Options for the ``watchfrr``, the watchdog daemon.
+
+::
+
+   valgrind_enable=no
+   valgrind=/usr/bin/valgrind
+
+Whether or not to start FRR daemons under Valgrind. This is primarily useful
+for gathering information for bug reports and for developers.
+``valgrind_enable`` should be ``no`` for production use.
+
+Services
+--------
+FRR daemons have their own terminal interface or VTY.  After installation, it's
+a good idea to setup each daemon's port number to connect to them. To do this
+add the following entries to :file:`/etc/services`.
+
+::
+
+   zebrasrv      2600/tcp		  # zebra service
+   zebra         2601/tcp		  # zebra vty
+   ripd          2602/tcp		  # RIPd vty
+   ripngd        2603/tcp		  # RIPngd vty
+   ospfd         2604/tcp		  # OSPFd vty
+   bgpd          2605/tcp		  # BGPd vty
+   ospf6d        2606/tcp		  # OSPF6d vty
+   ospfapi       2607/tcp		  # ospfapi
+   isisd         2608/tcp		  # ISISd vty
+   babeld        2609/tcp                 # BABELd vty
+   nhrpd         2610/tcp		  # nhrpd vty
+   pimd          2611/tcp		  # PIMd vty
+   ldpd          2612/tcp                 # LDPd vty
+   eigprd        2613/tcp                 # EIGRPd vty
+   bfdd          2617/tcp                 # bfdd vty
+
+
+If you use a FreeBSD newer than 2.2.8, the above entries are already added to
+:file:`/etc/services` so there is no need to add it. If you specify a port
+number when starting the daemon, these entries may not be needed.
+
+You may need to make changes to the config files in |INSTALL_PREFIX_ETC|.
+
+systemd
+-------
+Although not installed when installing from source, FRR provides a service file
+for use with ``systemd``. It is located in :file:`tools/frr.service` in the Git
+repository. If ``systemctl status frr.service`` indicates that the FRR service
+is not found, copy the service file from the Git repository into your preferred
+location. A good place is usually ``/etc/systemd/system/``.
+
+After issuing a ``systemctl daemon-reload``, you should be able to start the
+FRR service via ``systemctl start frr``. If this fails, or no daemons are
+started. check the ``journalctl`` logs for an indication of what went wrong.
diff -urpN frr-frr-5.0.1/doc/user/sharp.rst frr-frr-6.0/doc/user/sharp.rst
--- frr-frr-5.0.1/doc/user/sharp.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/sharp.rst	2018-10-08 14:32:57.000000000 +0200
@@ -1,13 +1,13 @@
 .. _sharp:
 
-***
+*****
 SHARP
-***
+*****
+
+:abbr:`SHARP (Super Happy Advanced Routing Process)` is a daemon that provides
+miscellaneous functionality used for testing FRR and creating proof-of-concept
+labs.
 
-:abbr:`SHARP` Super Happy Advanced Routing Process.  This daemon is useful
-for the testing of FRR itself as well as useful for creation of Proof of
-Concept labs.
-      
 .. _starting-sharp:
 
 Starting SHARP
@@ -26,42 +26,39 @@ documented elsewhere.
 
 .. _using-sharp:
 
-USING SHARP
+Using SHARP
 ===========
 
-All sharp commands are under the enable node and proceeded by the
-:abbr:`sharp` keyword.  There are currently no permenent sharp
-commands for configuration.
-
-..index:: sharp install
-..clicmd:: sharp install routes A.B.C.D nexthop E.F.G.H (1-1000000)
-
-Install up to a million /32 routes starting at A.B.C.D with specified nexthop
-E.F.G.H.  The nexthop is a NEXTHOP_TYPE_IPV4 and must be reachable to be
-installed into the kernel.  The routes are installed into zebra as
-ZEBRA_ROUTE_SHARP and can be used as part of a normal route redistribution.
-Route installation time is noted in the debug log and upon zebra successful
-installation into the kernel and sharp receiving the notification of all
-route installs the success will be noted in the debug log as well.
-
-..index:: sharp remove
-..clicmd:: sharp remove routes A.B.C.D (1-1000000)
-
-Remove up 1000000 million /32 routes starting at A.B.C.D.  The routes are
-removed from zebra.  Route deletion start is noted in the debug log
-and when all routes have been successfully deleted the debug log will
-be updated with this information as well.
-
-..index:: sharp label
-..clicmd:: sharp label <ipv4|ipv6> vrf NAME label (0-1000000)
+All sharp commands are under the enable node and preceeded by the ``sharp``
+keyword. At present, no sharp commands will be preserved in the config.
 
-Install a label into the kernel that causes the specified vrf NAME table to be
-used for pop and forward operations when the specified label is seen.
+.. index:: sharp install
+.. clicmd:: sharp install routes A.B.C.D nexthop E.F.G.H (1-1000000)
 
-..index:: sharp watch
-..clicmd: sharp watch nexthop <A.B.C.D|X:X::X:X>
+   Install up to 1,000,000 (one million) /32 routes starting at ``A.B.C.D``
+   with specified nexthop ``E.F.G.H``. The nexthop is a ``NEXTHOP_TYPE_IPV4``
+   and must be reachable to be installed into the kernel. The routes are
+   installed into zebra as ``ZEBRA_ROUTE_SHARP`` and can be used as part of a
+   normal route redistribution. Route installation time is noted in the debug
+   log. When zebra successfully installs a route into the kernel and SHARP
+   receives success notifications for all routes this is logged as well.
+
+.. index:: sharp remove
+.. clicmd:: sharp remove routes A.B.C.D (1-1000000)
+
+   Remove up to 1,000,000 (one million) /32 routes starting at ``A.B.C.D``. The
+   routes are removed from zebra. Route deletion start is noted in the debug
+   log and when all routes have been successfully deleted the debug log will be
+   updated with this information as well.
+
+.. index:: sharp label
+.. clicmd:: sharp label <ipv4|ipv6> vrf NAME label (0-1000000)
 
-Instruct zebra to monitor and notify sharp when the specified nexthop is
-changed.  The notification from zebra is written into the debug log.
+   Install a label into the kernel that causes the specified vrf NAME table to
+   be used for pop and forward operations when the specified label is seen.
 
+.. index:: sharp watch
+.. clicmd:: sharp watch nexthop <A.B.C.D|X:X::X:X>
 
+   Instruct zebra to monitor and notify sharp when the specified nexthop is
+   changed. The notification from zebra is written into the debug log.
diff -urpN frr-frr-5.0.1/doc/user/snmp.rst frr-frr-6.0/doc/user/snmp.rst
--- frr-frr-5.0.1/doc/user/snmp.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/snmp.rst	2018-10-08 14:32:57.000000000 +0200
@@ -7,8 +7,8 @@ SNMP Support
 :abbr:`SNMP (Simple Network Managing Protocol)` is a widely implemented feature
 for collecting network information from router and/or host. FRR itself does
 not support SNMP agent (server daemon) functionality but is able to connect to
-a SNMP agent using the SMUX protocol (:rfc:`1227`) or the AgentX protocol
-(:rfc:`2741`) and make the routing protocol MIBs available through it.
+a SNMP agent using the the AgentX protocol (:rfc:`2741`) and make the
+routing protocol MIBs available through it.
 
 Note that SNMP Support needs to be enabled at compile-time and loaded as module
 on daemon startup. Refer to :ref:`loadable-module-support` on the latter.
@@ -18,16 +18,10 @@ on daemon startup. Refer to :ref:`loadab
 Getting and installing an SNMP agent
 ====================================
 
-There are several SNMP agent which support SMUX or AgentX. We recommend to use
+The supported SNMP agent is AgentX. We recommend to use
 the latest version of `net-snmp` which was formerly known as `ucd-snmp`. It is
 free and open software and available at `http://www.net-snmp.org/ <http://www.net-snmp.org/>`_
-and as binary package for most Linux distributions. `net-snmp` has to be
-compiled with `--with-mib-modules=agentx` to be able to accept connections from
-FRR using AgentX protocol or with `--with-mib-modules=smux` to use SMUX
-protocol.
-
-Nowadays, SMUX is a legacy protocol. The AgentX protocol should be preferred
-for any new deployment. Both protocols have the same coverage.
+and as binary package for most Linux distributions.
 
 .. _agentx-configuration:
 
@@ -42,7 +36,10 @@ master SNMP agent (snmpd) and each of th
 :file:`/etc/snmp/snmpd.conf`, the ``master agentx`` directive should be added.
 In each of the FRR daemons, ``agentx`` command will enable AgentX support.
 
-:file:`/etc/snmp/snmpd.conf`:
+:file:`/etc/snmp/zebra.conf`:
+
+::
+
    #
    # example access restrictions setup
    #
@@ -94,99 +91,6 @@ need to configure FRR to use another tra
    agentXSocket tcp:192.168.15.12:705
 
 
-.. _smux-configuration:
-
-SMUX configuration
-==================
-
-To enable SMUX protocol support, FRR must have been build with the
-:option:`--enable-snmp` option.
-
-A separate connection has then to be established between the SNMP agent (snmpd)
-and each of the FRR daemons. This connections each use different OID numbers
-and passwords. Be aware that this OID number is not the one that is used in
-queries by clients, it is solely used for the intercommunication of the
-daemons.
-
-In the following example the ospfd daemon will be connected to the snmpd daemon
-using the password "frr_ospfd". For testing it is recommending to take exactly
-the below snmpd.conf as wrong access restrictions can be hard to debug.
-
-:file:`/etc/snmp/snmpd.conf`:
-   #
-   # example access restrictions setup
-   #
-   com2sec readonly default public
-   group MyROGroup v1 readonly
-   view all included .1 80
-   access MyROGroup "" any noauth exact all none none
-   #
-   # the following line is relevant for FRR
-   #
-   smuxpeer .1.3.6.1.4.1.3317.1.2.5 frr_ospfd
-
-:file:`/etc/frr/ospf`:
-   ! ... the rest of ospfd.conf has been omitted for clarity ...
-   !
-   smux peer .1.3.6.1.4.1.3317.1.2.5 frr_ospfd
-   !
-
-
-After restarting snmpd and frr, a successful connection can be verified in the
-syslog and by querying the SNMP daemon:
-
-::
-
-   snmpd[12300]: [smux_accept] accepted fd 12 from 127.0.0.1:36255
-   snmpd[12300]: accepted smux peer: \\
-      oid GNOME-PRODUCT-ZEBRA-MIB::ospfd, frr-0.96.5
-
-   # snmpwalk -c public -v1 localhost .1.3.6.1.2.1.14.1.1
-   OSPF-MIB::ospfRouterId.0 = IpAddress: 192.168.42.109
-
-
-Be warned that the current version (5.1.1) of the Net-SNMP daemon writes a line
-for every SNMP connect to the syslog which can lead to enormous log file sizes.
-If that is a problem you should consider to patch snmpd and comment out the
-troublesome `snmp_log()` line in the function `netsnmp_agent_check_packet()` in
-`agent/snmp_agent.c`.
-
-MIB and command reference
-=========================
-
-The following OID numbers are used for the interprocess communication of snmpd and
-the FRR daemons with SMUX only.::
-
-  .    (OIDs below .iso.org.dod.internet.private.enterprises)
-  zebra	.1.3.6.1.4.1.3317.1.2.1 .gnome.gnomeProducts.zebra.zserv
-  bgpd	.1.3.6.1.4.1.3317.1.2.2 .gnome.gnomeProducts.zebra.bgpd
-  ripd	.1.3.6.1.4.1.3317.1.2.3 .gnome.gnomeProducts.zebra.ripd
-  ospfd	.1.3.6.1.4.1.3317.1.2.5 .gnome.gnomeProducts.zebra.ospfd
-  ospf6d	.1.3.6.1.4.1.3317.1.2.6 .gnome.gnomeProducts.zebra.ospf6d
-
-
-Sadly, SNMP has not been implemented in all daemons yet. The following
-OID numbers are used for querying the SNMP daemon by a client:::
-
-  zebra	.1.3.6.1.2.1.4.24   .iso.org.dot.internet.mgmt.mib-2.ip.ipForward
-  ospfd	.1.3.6.1.2.1.14	    .iso.org.dot.internet.mgmt.mib-2.ospf
-  bgpd	.1.3.6.1.2.1.15	    .iso.org.dot.internet.mgmt.mib-2.bgp
-  ripd	.1.3.6.1.2.1.23	    .iso.org.dot.internet.mgmt.mib-2.rip2
-  ospf6d	.1.3.6.1.3.102	    .iso.org.dod.internet.experimental.ospfv3
-
-
-The following syntax is understood by the FRR daemons for configuring SNMP
-using SMUX:
-
-.. index:: smux peer OID
-.. clicmd:: smux peer OID
-.. index:: no smux peer OID
-.. clicmd:: no smux peer OID
-.. index:: smux peer OID PASSWORD
-.. clicmd:: smux peer OID PASSWORD
-.. index:: no smux peer OID PASSWORD
-.. clicmd:: no smux peer OID PASSWORD
-
 Here is the syntax for using AgentX:
 
 .. index:: agentx
diff -urpN frr-frr-5.0.1/doc/user/static.rst frr-frr-6.0/doc/user/static.rst
--- frr-frr-5.0.1/doc/user/static.rst	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/doc/user/static.rst	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,130 @@
+.. _static:
+
+******
+STATIC
+******
+
+:abbr:`STATIC` is a daemon that handles the installation and deletion
+of static routes.
+
+.. _starting-static:
+
+Starting STATIC 
+===============
+
+Default configuration file for *staticd* is :file:`staticd.conf`.  The typical
+location of :file:`staticd.conf` is |INSTALL_PREFIX_ETC|/staticd.conf.
+
+If the user is using integrated config, then :file:`staticd.conf` need not be
+present and the :file:`frr.conf` is read instead.
+
+If the user has not fully upgraded to using the staticd.conf and still has
+a non-integrated config with zebra.conf holding the static routes, *staticd*
+will read in the :file:`zebrad.conf` as a backup.
+
+.. program:: staticd
+
+:abbr:`STATIC` supports all the common FRR daemon start options which are
+documented elsewhere.
+
+.. _static-route-commands:
+
+Static Route Commands
+=====================
+
+Static routing is a very fundamental feature of routing technology. It defines
+a static prefix and gateway.
+
+.. index:: ip route NETWORK GATEWAY table TABLENO nexthop-vrf VRFNAME DISTANCE vrf VRFNAME
+.. clicmd:: ip route NETWORK GATEWAY table TABLENO nexthop-vrf VRFNAME DISTANCE vrf VRFNAME
+
+.. index:: ipv6 route NETWORK from SRCPREFIX GATEWAY table TABLENO nexthop-vrf VRFNAME DISTANCE vrf VRFNAME
+.. clicmd:: ipv6 route NETWORK from SRCPREFIX GATEWAY table TABLENO nexthop-vrf VRFNAME DISTANCE vrf VRFNAME
+
+   NETWORK is destination prefix with a valid v4 or v6 network based upon
+   initial form of the command.  GATEWAY is gateway for the prefix it currently
+   must match the v4 or v6 route type specified at the start of the command.
+   GATEWAY can also be treated as an interface name. If the interface name
+   is ``null0`` then zebra installs a blackhole route.  TABLENO 
+   is an optional parameter for namespaces that allows you to create the
+   route in a specified table associated with the vrf namespace. table will
+   be rejected if you are not using namespace based vrfs.  ``nexthop-vrf``
+   allows you to create a leaked route with a nexthop in the specified VRFNAME 
+   vrf VRFNAME allows you to create the route in a specified vrf.
+   ``nexthop-vrf`` cannot be currently used with namespace based vrfs
+   currently as well.
+   The v6 variant allows the installation of a static source-specific route
+   with the SRCPREFIX sub command.  These routes are currently supported
+   on Linux operating systems only, and perform AND matching on packet's
+   destination and source addresses in the kernel's forwarding path. Note
+   that destination longest-prefix match is "more important" than source
+   LPM, e.g.  ``2001:db8:1::/64 from 2001:db8::/48`` will win over
+   ``2001:db8::/48 from 2001:db8:1::/64`` if both match.
+
+.. _multiple-route-command:
+
+Multiple nexthop static route
+=============================
+
+To create multiple nexthops to the same NETWORK, just reenter the same
+network statement with different nexthop information.
+
+.. code-block:: frr
+
+   ip route 10.0.0.1/32 10.0.0.2
+   ip route 10.0.0.1/32 10.0.0.3
+   ip route 10.0.0.1/32 eth0
+
+
+If there is no route to 10.0.0.2 and 10.0.0.3, and interface eth0
+is reachable, then the last route is installed into the kernel.
+
+If zebra has been compiled with multipath support, and both 10.0.0.2 and
+10.0.0.3 are reachable, zebra will install a multipath route via both
+nexthops, if the platform supports this.
+
+::
+
+   router> show ip route
+   S>  10.0.0.1/32 [1/0] via 10.0.0.2 inactive
+       via 10.0.0.3 inactive
+     *       is directly connected, eth0
+
+
+.. code-block:: frr
+
+   ip route 10.0.0.0/8 10.0.0.2
+   ip route 10.0.0.0/8 10.0.0.3
+   ip route 10.0.0.0/8 null0 255
+
+
+This will install a multihop route via the specified next-hops if they are
+reachable, as well as a high-distance blackhole route, which can be useful to
+prevent traffic destined for a prefix to match less-specific routes (e.g.
+default) should the specified gateways not be reachable. E.g.:
+
+::
+
+   router> show ip route 10.0.0.0/8
+   Routing entry for 10.0.0.0/8
+     Known via "static", distance 1, metric 0
+       10.0.0.2 inactive
+       10.0.0.3 inactive
+
+   Routing entry for 10.0.0.0/8
+     Known via "static", distance 255, metric 0
+       directly connected, Null0
+
+Also, if the user wants to configure a static route for a specific VRF, then
+a specific VRF configuration mode is available. After entering into that mode
+with :clicmd:`vrf VRF` the user can enter the same route command as before,
+but this time, the route command will apply to the VRF.
+
+.. code-block:: frr
+
+   # case with VRF
+   configure terminal
+   vrf r1-cust1
+    ip route 10.0.0.0/24 10.0.0.2
+   exit-vrf
+
diff -urpN frr-frr-5.0.1/doc/user/zebra.rst frr-frr-6.0/doc/user/zebra.rst
--- frr-frr-5.0.1/doc/user/zebra.rst	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/doc/user/zebra.rst	2018-10-08 14:32:57.000000000 +0200
@@ -29,12 +29,55 @@ Besides the common invocation options (:
 
 .. option:: -r, --retain
 
-   When program terminates, retain routes added by zebra.
+   When program terminates, do not flush routes installed by *zebra* from the
+   kernel.
 
-.. program:: configure
+.. option:: -e X, --ecmp X
+
+   Run zebra with a limited ecmp ability compared to what it is compiled to.
+   If you are running zebra on hardware limited functionality you can
+   force zebra to limit the maximum ecmp allowed to X.  This number
+   is bounded by what you compiled FRR with as the maximum number.
+
+.. option:: -n, --vrfwnetns
+
+   When *Zebra* starts with this option, the VRF backend is based on Linux
+   network namespaces. That implies that all network namespaces discovered by
+   ZEBRA will create an associated VRF. The other daemons will operate on the VRF
+   VRF defined by *Zebra*, as usual.
+
+   .. seealso:: :ref:`zebra-vrf`
+
+.. option:: --v6-rr-semantics
+
+   The linux kernel is receiving the ability to use the same route
+   replacement semantics for v6 that v4 uses.  If you are using a
+   kernel that supports this functionality then run *Zebra* with this
+   option and we will use Route Replace Semantics instead of delete
+   than add.
 
 .. _interface-commands:
 
+Configuration Addresses behaviour
+=================================
+
+At startup, *Zebra* will first discover the underlying networking objects
+from the operating system. This includes interfaces, addresses of
+interfaces, static routes, etc. Then, it will read the configuration
+file, including its own interface addresses, static routes, etc. All this
+information comprises the operational context from *Zebra*. But
+configuration context from *Zebra* will remain the same as the one from
+:file:`zebra.conf` config file. As an example, executing the following
+:clicmd:`show running-config` will reflect what was in :file:`zebra.conf`.
+In a similar way, networking objects that are configured outside of the
+*Zebra* like *iproute2* will not impact the configuration context from
+*Zebra*. This behaviour permits you to continue saving your own config
+file, and decide what is really to be pushed on the config file, and what
+is dependent on the underlying system.
+Note that inversely, from *Zebra*, you will not be able to delete networking
+objects that were previously configured outside of *Zebra*.
+
+
 Interface Commands
 ==================
 
@@ -47,6 +90,10 @@ Standard Commands
 
 .. clicmd:: interface IFNAME
 
+.. index:: interface IFNAME vrf VRF
+
+.. clicmd:: interface IFNAME vrf VRF
+
 .. index:: shutdown
 
 .. clicmd:: shutdown
@@ -222,132 +269,180 @@ Link Parameters Commands
    for InterASv2 link in OSPF (RFC5392).  Note that this option is not yet
    supported for ISIS (RFC5316).
 
-.. _static-route-commands:
-
-Static Route Commands
-=====================
-
-Static routing is a very fundamental feature of routing technology. It
-defines static prefix and gateway.
-
-.. index:: ip route NETWORK GATEWAY
-.. clicmd:: ip route NETWORK GATEWAY
-
-   NETWORK is destination prefix with format of A.B.C.D/M. GATEWAY is gateway
-   for the prefix. When GATEWAY is A.B.C.D format. It is taken as a IPv4
-   address gateway. Otherwise it is treated as an interface name. If the
-   interface name is ``null0`` then zebra installs a blackhole route.
-
-   Some example configuration:
-
-   .. code-block:: frr
-
-      ip route 10.0.0.0/8 10.0.0.2
-      ip route 10.0.0.0/8 ppp0
-      ip route 10.0.0.0/8 null0
-
-   First example defines 10.0.0.0/8 static route with gateway 10.0.0.2.
-   Second one defines the same prefix but with gateway to interface ppp0. The
-   third install a blackhole route.
-
-.. index:: ip route NETWORK NETMASK GATEWAY
-.. clicmd:: ip route NETWORK NETMASK GATEWAY
-
-   This is alternate version of above command. When NETWORK is
-   A.B.C.D format, user must define NETMASK value with A.B.C.D
-   format. GATEWAY is same option as above command.
-
-   .. code-block:: frr
-
-      ip route 10.0.0.0 255.255.255.0 10.0.0.2
-      ip route 10.0.0.0 255.255.255.0 ppp0
-      ip route 10.0.0.0 255.255.255.0 null0
-
-
-   These statements are equivalent to those in the previous example.
-
-.. index:: ip route NETWORK GATEWAY DISTANCE
-.. clicmd:: ip route NETWORK GATEWAY DISTANCE
-
-   Installs the route with the specified distance.
-
-Multiple nexthop static route:
-
-.. code-block:: frr
-
-   ip route 10.0.0.1/32 10.0.0.2
-   ip route 10.0.0.1/32 10.0.0.3
-   ip route 10.0.0.1/32 eth0
-
+.. index:: table TABLENO
+.. clicmd:: table TABLENO
 
-If there is no route to 10.0.0.2 and 10.0.0.3, and interface eth0
-is reachable, then the last route is installed into the kernel.
+   Select the primary kernel routing table to be used. This only works for
+   kernels supporting multiple routing tables (like GNU/Linux 2.2.x and later).
+   After setting TABLENO with this command, static routes defined after this
+   are added to the specified table.
+
+.. _zebra-vrf:
+
+Virtual Routing and Forwarding
+==============================
+
+FRR supports :abbr:`VRF (Virtual Routing and Forwarding)`. VRF is a way to
+separate networking contexts on the same machine. Those networking contexts are
+associated with separate interfaces, thus making it possible to associate one
+interface with a specific VRF.
+
+VRF can be used, for example, when instantiating per enterprise networking
+services, without having to instantiate the physical host machine or the
+routing management daemons for each enterprise. As a result, interfaces are
+separate for each set of VRF, and routing daemons can have their own context
+for each VRF.
+
+This conceptual view introduces the *Default VRF* case. If the user does not
+configure any specific VRF, then by default, FRR uses the *Default VRF*.
+
+Configuring VRF networking contexts can be done in various ways on FRR. The VRF
+interfaces can be configured by entering in interface configuration mode
+:clicmd:`interface IFNAME vrf VRF`.
+
+A VRF backend mode is chosen when running *Zebra*.
+
+If no option is chosen, then the *Linux VRF* implementation as references in
+https://www.kernel.org/doc/Documentation/networking/vrf.txt will be mapped over
+the *Zebra* VRF. The routing table associated to that VRF is a Linux table
+identifier located in the same *Linux network namespace* where *Zebra* started.
+
+If the :option:`-n` option is chosen, then the *Linux network namespace* will
+be mapped over the *Zebra* VRF. That implies that *Zebra* is able to configure
+several *Linux network namespaces*.  The routing table associated to that VRF
+is the whole routing tables located in that namespace. For instance, this mode
+matches OpenStack Network Namespaces. It matches also OpenFastPath. The default
+behavior remains Linux VRF which is supported by the Linux kernel community,
+see https://www.kernel.org/doc/Documentation/networking/vrf.txt.
+
+Because of that difference, there are some subtle differences when running some
+commands in relationship to VRF. Here is an extract of some of those commands:
+
+.. index:: vrf VRF
+.. clicmd:: vrf VRF
+
+   This command is available on configuration mode. By default, above command
+   permits accessing the VRF configuration mode. This mode is available for
+   both VRFs. It is to be noted that *Zebra* does not create Linux VRF.
+   The network administrator can however decide to provision this command in
+   configuration file to provide more clarity about the intended configuration.
+
+.. index:: netns NAMESPACE
+.. clicmd:: netns NAMESPACE
+
+   This command is based on VRF configuration mode. This command is available
+   when *Zebra* is run in :option:`-n` mode. This command reflects which *Linux
+   network namespace* is to be mapped with *Zebra* VRF. It is to be noted that
+   *Zebra* creates and detects added/suppressed VRFs from the Linux environment
+   (in fact, those managed with iproute2). The network administrator can however
+   decide to provision this command in configuration file to provide more clarity
+   about the intended configuration.
+
+.. index:: show ip route vrf VRF
+.. clicmd:: show ip route vrf VRF
+
+   The show command permits dumping the routing table associated to the VRF. If
+   *Zebra* is launched with default settings, this will be the ``TABLENO`` of
+   the VRF configured on the kernel, thanks to information provided in
+   https://www.kernel.org/doc/Documentation/networking/vrf.txt. If *Zebra* is
+   launched with :option:`-n` option, this will be the default routing table of
+   the *Linux network namespace* ``VRF``.
+
+.. index:: show ip route vrf VRF table TABLENO
+.. clicmd:: show ip route vrf VRF table TABLENO
+
+   The show command is only available with :option:`-n` option. This command
+   will dump the routing table ``TABLENO`` of the *Linux network namespace*
+   ``VRF``.
+
+
+.. _zebra-mpls:
+
+MPLS Commands
+=============
+
+You can configure static mpls entries in zebra. Basically, handling MPLS
+consists of popping, swapping or pushing labels to IP packets.
+
+MPLS Acronyms
+-------------
+
+:abbr:`LSR (Labeled Switch Router)`
+   Networking devices handling labels used to forward traffic between and through
+   them.
+
+:abbr:`LER (Labeled Edge Router)`
+   A Labeled edge router is located at the edge of an MPLS network, generally
+   between an IP network and an MPLS network.
+
+MPLS Push Action
+----------------
+
+The push action is generally used for LER devices, which want to encapsulate
+all traffic for a wished destination into an MPLS label. This action is stored
+in routing entry, and can be configured like a route:
+
+.. index:: [no] ip route NETWORK MASK GATEWAY|INTERFACE label LABEL
+.. clicmd:: [no] ip route NETWORK MASK GATEWAY|INTERFACE label LABEL
+
+   NETWORK ans MASK stand for the IP prefix entry to be added as static
+   route entry.
+   GATEWAY is the gateway IP address to reach, in order to reach the prefix.
+   INTERFACE is the interface behind which the prefix is located.
+   LABEL is the MPLS label to use to reach the prefix abovementioned.
 
-If zebra has been compiled with multipath support, and both 10.0.0.2 and
-10.0.0.3 are reachable, zebra will install a multipath route via both
-nexthops, if the platform supports this.
+   You can check that the static entry is stored in the zebra RIB database, by
+   looking at the presence of the entry.
 
-::
+   ::
 
-   zebra> show ip route
-   S>  10.0.0.1/32 [1/0] via 10.0.0.2 inactive
-       via 10.0.0.3 inactive
-     *       is directly connected, eth0
+      zebra(configure)# ip route 1.1.1.1/32 10.0.1.1 label 777
+      zebra# show ip route
+      Codes: K - kernel route, C - connected, S - static, R - RIP,
+      O - OSPF, I - IS-IS, B - BGP, E - EIGRP, N - NHRP,
+      T - Table, v - VNC, V - VNC-Direct, A - Babel, D - SHARP,
+      F - PBR,
+      > - selected route, * - FIB route
 
+      S>* 1.1.1.1/32 [1/0] via 10.0.1.1, r2-eth0, label 777, 00:39:42
 
-.. code-block:: frr
+MPLS Swap and Pop Action
+------------------------
 
-   ip route 10.0.0.0/8 10.0.0.2
-   ip route 10.0.0.0/8 10.0.0.3
-   ip route 10.0.0.0/8 null0 255
+The swap action is generally used for LSR devices, which swap a packet with a
+label, with an other label. The Pop action is used on LER devices, at the
+termination of the MPLS traffic; this is used to remove MPLS header.
+
+.. index:: [no] mpls lsp INCOMING_LABEL GATEWAY OUTGOING_LABEL|explicit-null|implicit-null
+.. clicmd:: [no] mpls lsp INCOMING_LABEL GATEWAY OUTGOING_LABEL|explicit-null|implicit-null
+
+   INCOMING_LABEL and OUTGOING_LABEL are MPLS labels with values ranging from 16
+   to 1048575.
+   GATEWAY is the gateway IP address where to send MPLS packet.
+   The outgoing label can either be a value or have an explicit-null label header. This
+   specific header can be read by IP devices. The incoming label can also be removed; in
+   that case the implicit-null keyword is used, and the outgoing packet emitted is an IP
+   packet without MPLS header.
 
+You can check that the MPLS actions are stored in the zebra MPLS table, by looking at the
+presence of the entry.
 
-This will install a multihop route via the specified next-hops if they are
-reachable, as well as a high-metric blackhole route, which can be useful to
-prevent traffic destined for a prefix to match less-specific routes (e.g.
-default) should the specified gateways not be reachable. E.g.:
+.. index:: show mpls table
+.. clicmd:: show mpls table
 
 ::
 
-   zebra> show ip route 10.0.0.0/8
-   Routing entry for 10.0.0.0/8
-     Known via "static", distance 1, metric 0
-       10.0.0.2 inactive
-       10.0.0.3 inactive
+   zebra(configure)# mpls lsp 18 10.125.0.2 implicit-null
+   zebra(configure)# mpls lsp 19 10.125.0.2 20
+   zebra(configure)# mpls lsp 21 10.125.0.2 explicit-null
+   zebra# show mpls table
+   Inbound                            Outbound
+   Label     Type          Nexthop     Label
+   --------  -------  ---------------  --------
+   18     Static       10.125.0.2  implicit-null
+   19     Static       10.125.0.2  20
+   21     Static       10.125.0.2  IPv4 Explicit Null
 
-   Routing entry for 10.0.0.0/8
-     Known via "static", distance 255, metric 0
-       directly connected, Null0
-
-
-.. index:: ipv6 route NETWORK GATEWAY
-.. clicmd:: ipv6 route NETWORK GATEWAY
-
-.. index:: ipv6 route NETWORK GATEWAY DISTANCE
-.. clicmd:: ipv6 route NETWORK GATEWAY DISTANCE
-
-   These behave similarly to their ipv4 counterparts.
-
-.. index:: ipv6 route NETWORK from SRCPREFIX GATEWAY
-.. clicmd:: ipv6 route NETWORK from SRCPREFIX GATEWAY
-
-.. index:: ipv6 route NETWORK from SRCPREFIX GATEWAY DISTANCE
-.. clicmd:: ipv6 route NETWORK from SRCPREFIX GATEWAY DISTANCE
-
-   Install a static source-specific route. These routes are currently supported
-   on Linux operating systems only, and perform AND matching on packet's
-   destination and source addresses in the kernel's forwarding path. Note that
-   destination longest-prefix match is "more important" than source LPM, e.g.
-   *"2001:db8:1::/64 from 2001:db8::/48"* will win over
-   *"2001:db8::/48 from 2001:db8:1::/64"* if both match.
-
-.. index:: table TABLENO
-.. clicmd:: table TABLENO
-
-   Select the primary kernel routing table to be used. This only works
-   for kernels supporting multiple routing tables (like GNU/Linux 2.2.x
-   and later). After setting TABLENO with this command,
-   static routes defined after this are added to the specified table.
 
 .. _multicast-rib-commands:
 
@@ -519,6 +614,8 @@ The FIB push interface comprises of a TC
 the FPM. The connection is initiated by zebra -- that is, the FPM acts
 as the TCP server.
 
+.. program:: configure
+
 The relevant zebra code kicks in when zebra is configured with the
 :option:`--enable-fpm` flag. Zebra periodically attempts to connect to
 the well-known FPM port. Once the connection is up, zebra starts
diff -urpN frr-frr-5.0.1/docker/alpine/Dockerfile-coverage frr-frr-6.0/docker/alpine/Dockerfile-coverage
--- frr-frr-5.0.1/docker/alpine/Dockerfile-coverage	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/docker/alpine/Dockerfile-coverage	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,12 @@
+FROM alpine:3.7
+ARG commit
+ARG token
+ENV COMMIT=${commit}
+ENV TOKEN=${token}
+ADD . /src
+RUN cd /src && \
+	source alpine/APKBUILD.in && \
+	apk add --no-cache alpine-sdk $makedepends $checkdepends && \
+	./bootstrap.sh && \
+	./configure --enable-gcov
+ENTRYPOINT [ "/bin/sh", "-c", "cd /src && make && make -j 1 check-coverage" ]
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_errors.c frr-frr-6.0/eigrpd/eigrp_errors.c
--- frr-frr-5.0.1/eigrpd/eigrp_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/eigrpd/eigrp_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * EIGRP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "eigrp_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_eigrp_err[] = {
+	{
+		.code = EIGRP_ERR_PACKET,
+		.title = "EIGRP Packet Error",
+		.description = "EIGRP has a packet that does not correctly decode or encode",
+		.suggestion = "Gather log files from both sides of the neighbor relationship and open an issue"
+	},
+	{
+		.code = EIGRP_ERR_CONFIG,
+		.title = "EIGRP Configuration Error",
+		.description = "EIGRP has detected a configuration error",
+		.suggestion = "Correct the configuration issue, if it still persists open an Issue"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void eigrp_error_init(void)
+{
+	log_ref_add(ferr_eigrp_err);
+}
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_errors.h frr-frr-6.0/eigrpd/eigrp_errors.h
--- frr-frr-5.0.1/eigrpd/eigrp_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/eigrpd/eigrp_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * EIGRP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __EIGRP_ERRORS_H__
+#define __EIGRP_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum eigrp_log_refs {
+	EIGRP_ERR_PACKET = EIGRP_FERR_START,
+	EIGRP_ERR_CONFIG,
+};
+
+extern void eigrp_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_filter.c frr-frr-6.0/eigrpd/eigrp_filter.c
--- frr-frr-5.0.1/eigrpd/eigrp_filter.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_filter.c	2018-10-08 14:32:57.000000000 +0200
@@ -74,6 +74,7 @@ void eigrp_distribute_update(struct dist
 	/* if no interface address is present, set list to eigrp process struct
 	 */
 	e = eigrp_lookup();
+	assert(e != NULL);
 
 	/* Check if distribute-list was set for process or interface */
 	if (!dist->ifname) {
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_fsm.c frr-frr-6.0/eigrpd/eigrp_fsm.c
--- frr-frr-5.0.1/eigrpd/eigrp_fsm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_fsm.c	2018-10-08 14:32:57.000000000 +0200
@@ -486,6 +486,7 @@ int eigrp_fsm_event_q_fcn(struct eigrp_f
 
 int eigrp_fsm_event_keep_state(struct eigrp_fsm_action_message *msg)
 {
+	struct eigrp *eigrp;
 	struct eigrp_prefix_entry *prefix = msg->prefix;
 	struct eigrp_nexthop_entry *ne = listnode_head(prefix->entries);
 
@@ -498,9 +499,10 @@ int eigrp_fsm_event_keep_state(struct ei
 			if (msg->packet_type == EIGRP_OPC_QUERY)
 				eigrp_send_reply(msg->adv_router, prefix);
 			prefix->req_action |= EIGRP_FSM_NEED_UPDATE;
-			listnode_add(
-				(eigrp_lookup())->topology_changes_internalIPV4,
-				prefix);
+			eigrp = eigrp_lookup();
+			assert(eigrp);
+			listnode_add(eigrp->topology_changes_internalIPV4,
+				     prefix);
 		}
 		eigrp_topology_update_node_flags(prefix);
 		eigrp_update_routing_table(prefix);
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_hello.c frr-frr-6.0/eigrpd/eigrp_hello.c
--- frr-frr-5.0.1/eigrpd/eigrp_hello.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_hello.c	2018-10-08 14:32:57.000000000 +0200
@@ -54,6 +54,7 @@
 #include "eigrpd/eigrp_vty.h"
 #include "eigrpd/eigrp_dump.h"
 #include "eigrpd/eigrp_macros.h"
+#include "eigrpd/eigrp_errors.h"
 
 /* Packet Type String. */
 static const struct message eigrp_general_tlv_type_str[] = {
@@ -417,10 +418,12 @@ void eigrp_sw_version_initialize(void)
 	if (dash)
 		dash[0] = '\0';
 
-	ret = sscanf(ver_string, "%d.%d", &FRR_MAJOR, &FRR_MINOR);
+	ret = sscanf(ver_string, "%" SCNu32 ".%" SCNu32, &FRR_MAJOR,
+		     &FRR_MINOR);
 	if (ret != 2)
-		zlog_err("Did not Properly parse %s, please fix VERSION string",
-			 VERSION);
+		flog_err(EIGRP_ERR_PACKET,
+			  "Did not Properly parse %s, please fix VERSION string",
+			  VERSION);
 }
 
 /**
@@ -630,7 +633,7 @@ static struct eigrp_packet *eigrp_hello_
 	uint16_t length = EIGRP_HEADER_LEN;
 
 	// allocate a new packet to be sent
-	ep = eigrp_packet_new(ei->ifp->mtu, NULL);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(ei->ifp->mtu), NULL);
 
 	if (ep) {
 		// encode common header feilds
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_interface.c frr-frr-6.0/eigrpd/eigrp_interface.c
--- frr-frr-5.0.1/eigrpd/eigrp_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -336,6 +336,9 @@ void eigrp_if_free(struct eigrp_interfac
 	struct eigrp_prefix_entry *pe;
 	struct eigrp *eigrp = eigrp_lookup();
 
+	if (!eigrp)
+		return;
+
 	if (source == INTERFACE_DOWN_BY_VTY) {
 		THREAD_OFF(ei->t_hello);
 		eigrp_hello_send(ei, EIGRP_HELLO_GRACEFUL_SHUTDOWN, NULL);
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_macros.h frr-frr-6.0/eigrpd/eigrp_macros.h
--- frr-frr-5.0.1/eigrpd/eigrp_macros.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_macros.h	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,8 @@
 
 //--------------------------------------------------------------------------
 
+#define EIGRP_PACKET_MTU(mtu) ((mtu) - (sizeof(struct ip)))
+
 /* Topology Macros */
 
 
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_main.c frr-frr-6.0/eigrpd/eigrp_main.c
--- frr-frr-5.0.1/eigrpd/eigrp_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -64,6 +64,7 @@
 #include "eigrpd/eigrp_network.h"
 #include "eigrpd/eigrp_snmp.h"
 #include "eigrpd/eigrp_filter.h"
+#include "eigrpd/eigrp_errors.h"
 //#include "eigrpd/eigrp_routemap.h"
 
 /* eigprd privileges */
@@ -168,6 +169,7 @@ int main(int argc, char **argv, char **e
 	eigrp_om->master = frr_init();
 	master = eigrp_om->master;
 
+	eigrp_error_init();
 	vrf_init(NULL, NULL, NULL, NULL);
 
 	/*EIGRPd init*/
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_neighbor.c frr-frr-6.0/eigrpd/eigrp_neighbor.c
--- frr-frr-5.0.1/eigrpd/eigrp_neighbor.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_neighbor.c	2018-10-08 14:32:57.000000000 +0200
@@ -53,6 +53,7 @@
 #include "eigrpd/eigrp_network.h"
 #include "eigrpd/eigrp_topology.h"
 #include "eigrpd/eigrp_memory.h"
+#include "eigrpd/eigrp_errors.h"
 
 struct eigrp_neighbor *eigrp_nbr_new(struct eigrp_interface *ei)
 {
@@ -335,7 +336,8 @@ int eigrp_nbr_count_get(void)
 void eigrp_nbr_hard_restart(struct eigrp_neighbor *nbr, struct vty *vty)
 {
 	if (nbr == NULL) {
-		zlog_err("Nbr Hard restart: Neighbor not specified.");
+		flog_err(EIGRP_ERR_CONFIG,
+			  "Nbr Hard restart: Neighbor not specified.");
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_network.c frr-frr-6.0/eigrpd/eigrp_network.c
--- frr-frr-5.0.1/eigrpd/eigrp_network.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_network.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,7 @@
 #include "privs.h"
 #include "table.h"
 #include "vty.h"
+#include "lib_errors.h"
 
 #include "eigrpd/eigrp_structs.h"
 #include "eigrpd/eigrpd.h"
@@ -55,62 +56,47 @@ static void eigrp_network_run_interface(
 int eigrp_sock_init(void)
 {
 	int eigrp_sock;
-	int ret, hincl = 1;
+	int ret;
+#ifdef IP_HDRINCL
+	int hincl = 1;
+#endif
 
-	if (eigrpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("eigrp_sock_init: could not raise privs, %s",
-			 safe_strerror(errno));
-
-	eigrp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_EIGRPIGP);
-	if (eigrp_sock < 0) {
-		int save_errno = errno;
-		if (eigrpd_privs.change(ZPRIVS_LOWER))
-			zlog_err("eigrp_sock_init: could not lower privs, %s",
+	frr_elevate_privs(&eigrpd_privs) {
+		eigrp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_EIGRPIGP);
+		if (eigrp_sock < 0) {
+			zlog_err("eigrp_read_sock_init: socket: %s",
 				 safe_strerror(errno));
-		zlog_err("eigrp_read_sock_init: socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
+			exit(1);
+		}
 
 #ifdef IP_HDRINCL
-	/* we will include IP header with packet */
-	ret = setsockopt(eigrp_sock, IPPROTO_IP, IP_HDRINCL, &hincl,
-			 sizeof(hincl));
-	if (ret < 0) {
-		int save_errno = errno;
-		if (eigrpd_privs.change(ZPRIVS_LOWER))
-			zlog_err("eigrp_sock_init: could not lower privs, %s",
-				 safe_strerror(errno));
-		zlog_warn("Can't set IP_HDRINCL option for fd %d: %s",
-			  eigrp_sock, safe_strerror(save_errno));
-	}
+		/* we will include IP header with packet */
+		ret = setsockopt(eigrp_sock, IPPROTO_IP, IP_HDRINCL, &hincl,
+				 sizeof(hincl));
+		if (ret < 0) {
+			zlog_warn("Can't set IP_HDRINCL option for fd %d: %s",
+				  eigrp_sock, safe_strerror(errno));
+		}
 #elif defined(IPTOS_PREC_INTERNETCONTROL)
 #warning "IP_HDRINCL not available on this system"
 #warning "using IPTOS_PREC_INTERNETCONTROL"
-	ret = setsockopt_ipv4_tos(eigrp_sock, IPTOS_PREC_INTERNETCONTROL);
-	if (ret < 0) {
-		int save_errno = errno;
-		if (eigrpd_privs.change(ZPRIVS_LOWER))
-			zlog_err("eigrpd_sock_init: could not lower privs, %s",
-				 safe_strerror(errno));
-		zlog_warn("can't set sockopt IP_TOS %d to socket %d: %s", tos,
-			  eigrp_sock, safe_strerror(save_errno));
-		close(eigrp_sock); /* Prevent sd leak. */
-		return ret;
-	}
+		ret = setsockopt_ipv4_tos(eigrp_sock,
+					  IPTOS_PREC_INTERNETCONTROL);
+		if (ret < 0) {
+			zlog_warn("can't set sockopt IP_TOS %d to socket %d: %s",
+				  tos, eigrp_sock, safe_strerror(errno));
+			close(eigrp_sock); /* Prevent sd leak. */
+			return ret;
+		}
 #else /* !IPTOS_PREC_INTERNETCONTROL */
 #warning "IP_HDRINCL not available, nor is IPTOS_PREC_INTERNETCONTROL"
-	zlog_warn("IP_HDRINCL option not available");
+		zlog_warn("IP_HDRINCL option not available");
 #endif /* IP_HDRINCL */
 
-	ret = setsockopt_ifindex(AF_INET, eigrp_sock, 1);
-
-	if (ret < 0)
-		zlog_warn("Can't set pktinfo option for fd %d", eigrp_sock);
-
-	if (eigrpd_privs.change(ZPRIVS_LOWER)) {
-		zlog_err("eigrp_sock_init: could not lower privs, %s",
-			 safe_strerror(errno));
+		ret = setsockopt_ifindex(AF_INET, eigrp_sock, 1);
+		if (ret < 0)
+			zlog_warn("Can't set pktinfo option for fd %d",
+				  eigrp_sock);
 	}
 
 	return eigrp_sock;
@@ -122,9 +108,7 @@ void eigrp_adjust_sndbuflen(struct eigrp
 	/* Check if any work has to be done at all. */
 	if (eigrp->maxsndbuflen >= buflen)
 		return;
-	if (eigrpd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __func__,
-			 safe_strerror(errno));
+	frr_elevate_privs(&eigrpd_privs) {
 
 	/* Now we try to set SO_SNDBUF to what our caller has requested
 	 * (the MTU of a newly added interface). However, if the OS has
@@ -133,18 +117,16 @@ void eigrp_adjust_sndbuflen(struct eigrp
 	 * may allocate more buffer space, than requested, this isn't
 	 * a error.
 	 */
-	setsockopt_so_sendbuf(eigrp->fd, buflen);
-	newbuflen = getsockopt_so_sendbuf(eigrp->fd);
-	if (newbuflen < 0 || newbuflen < (int)buflen)
-		zlog_warn("%s: tried to set SO_SNDBUF to %u, but got %d",
-			  __func__, buflen, newbuflen);
-	if (newbuflen >= 0)
-		eigrp->maxsndbuflen = (unsigned int)newbuflen;
-	else
-		zlog_warn("%s: failed to get SO_SNDBUF", __func__);
-	if (eigrpd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __func__,
-			 safe_strerror(errno));
+		setsockopt_so_sendbuf(eigrp->fd, buflen);
+		newbuflen = getsockopt_so_sendbuf(eigrp->fd);
+		if (newbuflen < 0 || newbuflen < (int)buflen)
+			zlog_warn("%s: tried to set SO_SNDBUF to %u, but got %d",
+				  __func__, buflen, newbuflen);
+		if (newbuflen >= 0)
+			eigrp->maxsndbuflen = (unsigned int)newbuflen;
+		else
+			zlog_warn("%s: failed to get SO_SNDBUF", __func__);
+	}
 }
 
 int eigrp_if_ipmulticast(struct eigrp *top, struct prefix *p,
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_packet.c frr-frr-6.0/eigrpd/eigrp_packet.c
--- frr-frr-5.0.1/eigrpd/eigrp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -42,6 +42,7 @@
 #include "checksum.h"
 #include "md5.h"
 #include "sha256.h"
+#include "lib_errors.h"
 
 #include "eigrpd/eigrp_structs.h"
 #include "eigrpd/eigrpd.h"
@@ -51,10 +52,12 @@
 #include "eigrpd/eigrp_zebra.h"
 #include "eigrpd/eigrp_vty.h"
 #include "eigrpd/eigrp_dump.h"
+#include "eigrpd/eigrp_macros.h"
 #include "eigrpd/eigrp_network.h"
 #include "eigrpd/eigrp_topology.h"
 #include "eigrpd/eigrp_fsm.h"
 #include "eigrpd/eigrp_memory.h"
+#include "eigrpd/eigrp_errors.h"
 
 /* Packet Type String. */
 const struct message eigrp_packet_type_str[] = {
@@ -345,12 +348,14 @@ int eigrp_write(struct thread *thread)
 	/* Get one packet from queue. */
 	ep = eigrp_fifo_next(ei->obuf);
 	if (!ep) {
-		zlog_err("%s: Interface %s no packet on queue?",
-			 __PRETTY_FUNCTION__, ei->ifp->name);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: Interface %s no packet on queue?",
+			  __PRETTY_FUNCTION__, ei->ifp->name);
 		goto out;
 	}
 	if (ep->length < EIGRP_HEADER_LEN) {
-		zlog_err("%s: Packet just has a header?", __PRETTY_FUNCTION__);
+		flog_err(EIGRP_ERR_PACKET,
+			  "%s: Packet just has a header?", __PRETTY_FUNCTION__);
 		eigrp_header_dump((struct eigrp_header *)ep->s->data);
 		eigrp_packet_delete(ei);
 		goto out;
@@ -565,7 +570,7 @@ int eigrp_read(struct thread *thread)
 	//    return -1;
 
 	/* If incoming interface is passive one, ignore it. */
-	if (ei && eigrp_if_is_passive(ei)) {
+	if (eigrp_if_is_passive(ei)) {
 		char buf[3][INET_ADDRSTRLEN];
 
 		if (IS_DEBUG_EIGRP_TRANSMIT(0, RECV))
@@ -724,12 +729,12 @@ static struct stream *eigrp_recv_packet(
 		zlog_warn("stream_recvmsg failed: %s", safe_strerror(errno));
 		return NULL;
 	}
-	if ((unsigned int)ret < sizeof(iph)) /* ret must be > 0 now */
+	if ((unsigned int)ret < sizeof(*iph)) /* ret must be > 0 now */
 	{
 		zlog_warn(
 			"eigrp_recv_packet: discarding runt packet of length %d "
 			"(ip header size is %u)",
-			ret, (unsigned int)sizeof(iph));
+			ret, (unsigned int)sizeof(*iph));
 		return NULL;
 	}
 
@@ -943,8 +948,6 @@ void eigrp_packet_free(struct eigrp_pack
 	THREAD_OFF(ep->t_retrans_timer);
 
 	XFREE(MTYPE_EIGRP_PACKET, ep);
-
-	ep = NULL;
 }
 
 /* EIGRP Header verification. */
@@ -1088,7 +1091,7 @@ struct eigrp_packet *eigrp_packet_duplic
 {
 	struct eigrp_packet *new;
 
-	new = eigrp_packet_new(nbr->ei->ifp->mtu, nbr);
+	new = eigrp_packet_new(EIGRP_PACKET_MTU(nbr->ei->ifp->mtu), nbr);
 	new->length = old->length;
 	new->retrans_counter = old->retrans_counter;
 	new->dst = old->dst;
@@ -1211,8 +1214,9 @@ uint16_t eigrp_add_internalTLV_to_stream
 		stream_putw(s, length);
 		break;
 	default:
-		zlog_err("%s: Unexpected prefix length: %d",
-			 __PRETTY_FUNCTION__, pe->destination->prefixlen);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "%s: Unexpected prefix length: %d",
+			  __PRETTY_FUNCTION__, pe->destination->prefixlen);
 		return 0;
 	}
 	stream_putl(s, 0x00000000);
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_query.c frr-frr-6.0/eigrpd/eigrp_query.c
--- frr-frr-5.0.1/eigrpd/eigrp_query.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_query.c	2018-10-08 14:32:57.000000000 +0200
@@ -167,6 +167,7 @@ void eigrp_send_query(struct eigrp_inter
 	struct eigrp_prefix_entry *pe;
 	bool has_tlv = false;
 	bool new_packet = true;
+	uint16_t eigrp_mtu = EIGRP_PACKET_MTU(ei->ifp->mtu);
 
 	for (ALL_LIST_ELEMENTS(ei->eigrp->topology_changes_internalIPV4, node,
 			       nnode, pe)) {
@@ -174,7 +175,7 @@ void eigrp_send_query(struct eigrp_inter
 			continue;
 
 		if (new_packet) {
-			ep = eigrp_packet_new(ei->ifp->mtu, NULL);
+			ep = eigrp_packet_new(eigrp_mtu, NULL);
 
 			/* Prepare EIGRP INIT UPDATE header */
 			eigrp_packet_header_init(EIGRP_OPC_QUERY, ei->eigrp,
@@ -197,7 +198,7 @@ void eigrp_send_query(struct eigrp_inter
 				listnode_add(pe->rij, nbr);
 		}
 
-		if (length + EIGRP_TLV_MAX_IPV4_BYTE > (uint16_t)ei->ifp->mtu) {
+		if (length + EIGRP_TLV_MAX_IPV4_BYTE > eigrp_mtu) {
 			if ((ei->params.auth_type == EIGRP_AUTH_TYPE_MD5)
 			    && ei->params.auth_keychain != NULL) {
 				eigrp_make_md5_digest(ei, ep->s,
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_reply.c frr-frr-6.0/eigrpd/eigrp_reply.c
--- frr-frr-5.0.1/eigrpd/eigrp_reply.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_reply.c	2018-10-08 14:32:57.000000000 +0200
@@ -59,6 +59,7 @@
 #include "eigrpd/eigrp_topology.h"
 #include "eigrpd/eigrp_fsm.h"
 #include "eigrpd/eigrp_memory.h"
+#include "eigrpd/eigrp_errors.h"
 
 void eigrp_send_reply(struct eigrp_neighbor *nbr, struct eigrp_prefix_entry *pe)
 {
@@ -85,7 +86,7 @@ void eigrp_send_reply(struct eigrp_neigh
 	 * End of filtering
 	 */
 
-	ep = eigrp_packet_new(ei->ifp->mtu, nbr);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(ei->ifp->mtu), nbr);
 
 	/* Prepare EIGRP INIT UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_REPLY, eigrp, ep->s, 0,
@@ -169,10 +170,10 @@ void eigrp_reply_receive(struct eigrp *e
 		if (!dest) {
 			char buf[PREFIX_STRLEN];
 
-			zlog_err(
-				"%s: Received prefix %s which we do not know about",
-				__PRETTY_FUNCTION__,
-				prefix2str(&dest_addr, buf, sizeof(buf)));
+			flog_err(EIGRP_ERR_PACKET,
+				  "%s: Received prefix %s which we do not know about",
+				  __PRETTY_FUNCTION__,
+				  prefix2str(&dest_addr, buf, sizeof(buf)));
 			eigrp_IPv4_InternalTLV_free(tlv);
 			continue;
 		}
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_siaquery.c frr-frr-6.0/eigrpd/eigrp_siaquery.c
--- frr-frr-5.0.1/eigrpd/eigrp_siaquery.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_siaquery.c	2018-10-08 14:32:57.000000000 +0200
@@ -119,7 +119,7 @@ void eigrp_send_siaquery(struct eigrp_ne
 	struct eigrp_packet *ep;
 	uint16_t length = EIGRP_HEADER_LEN;
 
-	ep = eigrp_packet_new(nbr->ei->ifp->mtu, nbr);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(nbr->ei->ifp->mtu), nbr);
 
 	/* Prepare EIGRP INIT UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_SIAQUERY, nbr->ei->eigrp, ep->s, 0,
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_siareply.c frr-frr-6.0/eigrpd/eigrp_siareply.c
--- frr-frr-5.0.1/eigrpd/eigrp_siareply.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_siareply.c	2018-10-08 14:32:57.000000000 +0200
@@ -118,7 +118,7 @@ void eigrp_send_siareply(struct eigrp_ne
 	struct eigrp_packet *ep;
 	uint16_t length = EIGRP_HEADER_LEN;
 
-	ep = eigrp_packet_new(nbr->ei->ifp->mtu, nbr);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(nbr->ei->ifp->mtu), nbr);
 
 	/* Prepare EIGRP INIT UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_SIAREPLY, nbr->ei->eigrp, ep->s, 0,
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_snmp.c frr-frr-6.0/eigrpd/eigrp_snmp.c
--- frr-frr-5.0.1/eigrpd/eigrp_snmp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_snmp.c	2018-10-08 14:32:57.000000000 +0200
@@ -514,7 +514,6 @@ eigrp_snmp_nbr_lookup_next(struct in_add
 	struct listnode *node, *nnode, *node2, *nnode2;
 	struct eigrp_interface *ei;
 	struct eigrp_neighbor *nbr;
-	struct route_node *rn;
 	struct eigrp_neighbor *min = NULL;
 	struct eigrp *eigrp;
 
@@ -573,7 +572,7 @@ static struct eigrp_neighbor *eigrpNbrLo
 		first = 0;
 		len = *length - v->namelen;
 
-		if (len <= 0)
+		if (len == 0)
 			first = 1;
 
 		if (len > IN_ADDR_SIZE)
@@ -918,8 +917,6 @@ static uint8_t *eigrpTopologyEntry(struc
 				   WriteMethod **write_method)
 {
 	struct eigrp *eigrp;
-	struct eigrp_interface *ei;
-	struct listnode *node, *nnode;
 
 	eigrp = eigrp_lookup();
 
@@ -1067,7 +1064,6 @@ static uint8_t *eigrpPeerEntry(struct va
 {
 	struct eigrp *eigrp;
 	struct eigrp_interface *ei;
-	struct listnode *node, *nnode;
 	struct eigrp_neighbor *nbr;
 	struct in_addr nbr_addr;
 	unsigned int ifindex;
@@ -1199,11 +1195,9 @@ static uint8_t *eigrpInterfaceEntry(stru
 				    WriteMethod **write_method)
 {
 	struct eigrp *eigrp;
-	struct eigrp_interface *ei;
 	struct listnode *node, *nnode;
 	struct keychain *keychain;
 	struct list *keylist;
-	int counter;
 
 	eigrp = eigrp_lookup();
 
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_topology.c frr-frr-6.0/eigrpd/eigrp_topology.c
--- frr-frr-5.0.1/eigrpd/eigrp_topology.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_topology.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,7 @@
 #include "log.h"
 #include "linklist.h"
 #include "vty.h"
+#include "lib_errors.h"
 
 #include "eigrpd/eigrp_structs.h"
 #include "eigrpd/eigrpd.h"
@@ -182,6 +183,9 @@ void eigrp_prefix_entry_delete(struct ro
 	struct eigrp *eigrp = eigrp_lookup();
 	struct route_node *rn;
 
+	if (!eigrp)
+		return;
+
 	rn = route_node_lookup(table, pe->destination);
 	if (!rn)
 		return;
@@ -408,7 +412,8 @@ eigrp_topology_update_distance(struct ei
 		}
 		break;
 	default:
-		zlog_err("%s: Please implement handler", __PRETTY_FUNCTION__);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: Please implement handler",
+			  __PRETTY_FUNCTION__);
 		break;
 	}
 distance_done:
@@ -426,6 +431,9 @@ void eigrp_topology_update_all_node_flag
 	struct eigrp_prefix_entry *pe;
 	struct route_node *rn;
 
+	if (!eigrp)
+		return;
+
 	for (rn = route_top(eigrp->topology_table); rn; rn = route_next(rn)) {
 		pe = rn->info;
 
@@ -442,18 +450,27 @@ void eigrp_topology_update_node_flags(st
 	struct eigrp_nexthop_entry *entry;
 	struct eigrp *eigrp = eigrp_lookup();
 
+	assert(eigrp);
+
 	for (ALL_LIST_ELEMENTS_RO(dest->entries, node, entry)) {
-		if (((uint64_t)entry->distance
-		     <= (uint64_t)dest->distance * (uint64_t)eigrp->variance)
-		    && entry->distance != EIGRP_MAX_METRIC) // is successor
-		{
-			entry->flags |= EIGRP_NEXTHOP_ENTRY_SUCCESSOR_FLAG;
-			entry->flags &= ~EIGRP_NEXTHOP_ENTRY_FSUCCESSOR_FLAG;
-		} else if (entry->reported_distance
-			   < dest->fdistance) // is feasible successor
-		{
-			entry->flags |= EIGRP_NEXTHOP_ENTRY_FSUCCESSOR_FLAG;
-			entry->flags &= ~EIGRP_NEXTHOP_ENTRY_SUCCESSOR_FLAG;
+		if (entry->reported_distance < dest->fdistance) {
+			// is feasible successor, can be successor
+			if (((uint64_t)entry->distance
+			     <= (uint64_t)dest->distance
+					* (uint64_t)eigrp->variance)
+			    && entry->distance != EIGRP_MAX_METRIC) {
+				// is successor
+				entry->flags |=
+					EIGRP_NEXTHOP_ENTRY_SUCCESSOR_FLAG;
+				entry->flags &=
+					~EIGRP_NEXTHOP_ENTRY_FSUCCESSOR_FLAG;
+			} else {
+				// is feasible successor only
+				entry->flags |=
+					EIGRP_NEXTHOP_ENTRY_FSUCCESSOR_FLAG;
+				entry->flags &=
+					~EIGRP_NEXTHOP_ENTRY_SUCCESSOR_FLAG;
+			}
 		} else {
 			entry->flags &= ~EIGRP_NEXTHOP_ENTRY_FSUCCESSOR_FLAG;
 			entry->flags &= ~EIGRP_NEXTHOP_ENTRY_SUCCESSOR_FLAG;
@@ -464,11 +481,15 @@ void eigrp_topology_update_node_flags(st
 void eigrp_update_routing_table(struct eigrp_prefix_entry *prefix)
 {
 	struct eigrp *eigrp = eigrp_lookup();
-	struct list *successors =
-		eigrp_topology_get_successor_max(prefix, eigrp->max_paths);
+	struct list *successors;
 	struct listnode *node;
 	struct eigrp_nexthop_entry *entry;
 
+	if (!eigrp)
+		return;
+
+	successors = eigrp_topology_get_successor_max(prefix, eigrp->max_paths);
+
 	if (successors) {
 		eigrp_zebra_route_add(prefix->destination, successors);
 		for (ALL_LIST_ELEMENTS_RO(successors, node, entry))
diff -urpN frr-frr-5.0.1/eigrpd/eigrp_update.c frr-frr-6.0/eigrpd/eigrp_update.c
--- frr-frr-5.0.1/eigrpd/eigrp_update.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrp_update.c	2018-10-08 14:32:57.000000000 +0200
@@ -420,7 +420,7 @@ void eigrp_update_send_init(struct eigrp
 	struct eigrp_packet *ep;
 	uint16_t length = EIGRP_HEADER_LEN;
 
-	ep = eigrp_packet_new(nbr->ei->ifp->mtu, nbr);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(nbr->ei->ifp->mtu), nbr);
 
 	/* Prepare EIGRP INIT UPDATE header */
 	if (IS_DEBUG_EIGRP_PACKET(0, RECV))
@@ -533,10 +533,10 @@ void eigrp_update_send_EOT(struct eigrp_
 	struct eigrp *eigrp = ei->eigrp;
 	struct prefix *dest_addr;
 	uint32_t seq_no = eigrp->sequence_number;
-	uint16_t mtu = ei->ifp->mtu;
+	uint16_t eigrp_mtu = EIGRP_PACKET_MTU(ei->ifp->mtu);
 	struct route_node *rn;
 
-	ep = eigrp_packet_new(mtu, nbr);
+	ep = eigrp_packet_new(eigrp_mtu, nbr);
 
 	/* Prepare EIGRP EOT UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_UPDATE, eigrp, ep->s, EIGRP_EOT_FLAG,
@@ -557,13 +557,13 @@ void eigrp_update_send_EOT(struct eigrp_
 			if (eigrp_nbr_split_horizon_check(te, ei))
 				continue;
 
-			if ((length + EIGRP_TLV_MAX_IPV4_BYTE) > mtu) {
+			if ((length + EIGRP_TLV_MAX_IPV4_BYTE) > eigrp_mtu) {
 				eigrp_update_place_on_nbr_queue(nbr, ep, seq_no,
 								length);
 				seq_no++;
 
 				length = EIGRP_HEADER_LEN;
-				ep = eigrp_packet_new(mtu, nbr);
+				ep = eigrp_packet_new(eigrp_mtu, nbr);
 				eigrp_packet_header_init(
 					EIGRP_OPC_UPDATE, nbr->ei->eigrp, ep->s,
 					EIGRP_EOT_FLAG, seq_no,
@@ -604,13 +604,14 @@ void eigrp_update_send(struct eigrp_inte
 	struct eigrp *eigrp = ei->eigrp;
 	struct prefix *dest_addr;
 	uint32_t seq_no = eigrp->sequence_number;
+	uint16_t eigrp_mtu = EIGRP_PACKET_MTU(ei->ifp->mtu);
 
 	if (ei->nbrs->count == 0)
 		return;
 
 	uint16_t length = EIGRP_HEADER_LEN;
 
-	ep = eigrp_packet_new(ei->ifp->mtu, NULL);
+	ep = eigrp_packet_new(eigrp_mtu, NULL);
 
 	/* Prepare EIGRP INIT UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_UPDATE, eigrp, ep->s, 0, seq_no, 0);
@@ -633,8 +634,7 @@ void eigrp_update_send(struct eigrp_inte
 		if (eigrp_nbr_split_horizon_check(ne, ei))
 			continue;
 
-		if ((length + EIGRP_TLV_MAX_IPV4_BYTE)
-		    > (uint16_t)ei->ifp->mtu) {
+		if ((length + EIGRP_TLV_MAX_IPV4_BYTE) > eigrp_mtu) {
 			if ((ei->params.auth_type == EIGRP_AUTH_TYPE_MD5)
 			    && (ei->params.auth_keychain != NULL)) {
 				eigrp_make_md5_digest(ei, ep->s,
@@ -651,7 +651,7 @@ void eigrp_update_send(struct eigrp_inte
 			eigrp_update_send_to_all_nbrs(ei, ep);
 
 			length = EIGRP_HEADER_LEN;
-			ep = eigrp_packet_new(ei->ifp->mtu, NULL);
+			ep = eigrp_packet_new(eigrp_mtu, NULL);
 			eigrp_packet_header_init(EIGRP_OPC_UPDATE, eigrp, ep->s,
 						 0, seq_no, 0);
 			if ((ei->params.auth_type == EIGRP_AUTH_TYPE_MD5)
@@ -757,7 +757,6 @@ static void eigrp_update_send_GR_part(st
 	prefixes = nbr->nbr_gr_prefixes_send;
 
 	send_prefixes = 0;
-	length = EIGRP_HEADER_LEN;
 
 	/* if there already were last packet chunk, we won't continue */
 	if (nbr->nbr_gr_packet_type == EIGRP_PACKET_PART_LAST)
@@ -790,7 +789,7 @@ static void eigrp_update_send_GR_part(st
 		}
 	}
 
-	ep = eigrp_packet_new(ei->ifp->mtu, nbr);
+	ep = eigrp_packet_new(EIGRP_PACKET_MTU(ei->ifp->mtu), nbr);
 
 	/* Prepare EIGRP Graceful restart UPDATE header */
 	eigrp_packet_header_init(EIGRP_OPC_UPDATE, eigrp, ep->s, flags,
diff -urpN frr-frr-5.0.1/eigrpd/eigrpd.c frr-frr-6.0/eigrpd/eigrpd.c
--- frr-frr-5.0.1/eigrpd/eigrpd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/eigrpd.c	2018-10-08 14:32:57.000000000 +0200
@@ -43,6 +43,7 @@
 #include "sockopt.h"
 #include "keychain.h"
 #include "libfrr.h"
+#include "lib_errors.h"
 
 #include "eigrpd/eigrp_structs.h"
 #include "eigrpd/eigrpd.h"
@@ -161,21 +162,16 @@ static struct eigrp *eigrp_new(const cha
 	eigrp->networks = eigrp_topology_new();
 
 	if ((eigrp_socket = eigrp_sock_init()) < 0) {
-		zlog_err(
-			"eigrp_new: fatal error: eigrp_sock_init was unable to open "
-			"a socket");
+		flog_err_sys(
+			LIB_ERR_SOCKET,
+			"eigrp_new: fatal error: eigrp_sock_init was unable to open a socket");
 		exit(1);
 	}
 
 	eigrp->fd = eigrp_socket;
 	eigrp->maxsndbuflen = getsockopt_so_sendbuf(eigrp->fd);
 
-	if ((eigrp->ibuf = stream_new(EIGRP_PACKET_MAX_LEN + 1)) == NULL) {
-		zlog_err(
-			"eigrp_new: fatal error: stream_new (%u) failed allocating ibuf",
-			EIGRP_PACKET_MAX_LEN + 1);
-		exit(1);
-	}
+	eigrp->ibuf = stream_new(EIGRP_PACKET_MAX_LEN + 1);
 
 	eigrp->t_read = NULL;
 	thread_add_read(master, eigrp_read, eigrp, eigrp->fd, &eigrp->t_read);
diff -urpN frr-frr-5.0.1/eigrpd/subdir.am frr-frr-6.0/eigrpd/subdir.am
--- frr-frr-5.0.1/eigrpd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/eigrpd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -10,6 +10,7 @@ endif
 
 eigrpd_libeigrp_a_SOURCES = \
 	eigrpd/eigrp_dump.c \
+	eigrpd/eigrp_errors.c \
 	eigrpd/eigrp_filter.c \
 	eigrpd/eigrp_fsm.c \
 	eigrpd/eigrp_hello.c \
@@ -39,6 +40,7 @@ eigrpdheader_HEADERS = \
 
 noinst_HEADERS += \
 	eigrpd/eigrp_const.h \
+	eigrpd/eigrp_errors.h \
 	eigrpd/eigrp_filter.h \
 	eigrpd/eigrp_fsm.h \
 	eigrpd/eigrp_interface.h \
diff -urpN frr-frr-5.0.1/include/linux/netlink.h frr-frr-6.0/include/linux/netlink.h
--- frr-frr-5.0.1/include/linux/netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/include/linux/netlink.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,247 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+#include <linux/kernel.h>
+#include <linux/socket.h> /* for __kernel_sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
+#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
+#define NETLINK_RDMA		20
+#define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_SMC		22	/* SMC monitoring */
+
+#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
+
+#define MAX_LINKS 32		
+
+struct sockaddr_nl {
+	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* port ID	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr {
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process port ID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		0x01	/* It is request message. 	*/
+#define NLM_F_MULTI		0x02	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		0x04	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		0x08	/* Echo this request 		*/
+#define NLM_F_DUMP_INTR		0x10	/* Dump was inconsistent due to sequence change */
+#define NLM_F_DUMP_FILTERED	0x20	/* Dump was filtered as requested */
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/* Modifiers to DELETE request */
+#define NLM_F_NONREC	0x100	/* Do not delete recursively	*/
+
+/* Flags for ACK message */
+#define NLM_F_CAPPED	0x100	/* request was capped */
+#define NLM_F_ACK_TLVS	0x200	/* extended ACK TVLs were included */
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4U
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
+struct nlmsgerr {
+	int		error;
+	struct nlmsghdr msg;
+	/*
+	 * followed by the message contents unless NETLINK_CAP_ACK was set
+	 * or the ACK indicates success (error == 0)
+	 * message length is aligned with NLMSG_ALIGN()
+	 */
+	/*
+	 * followed by TLVs defined in enum nlmsgerr_attrs
+	 * if NETLINK_EXT_ACK was set
+	 */
+};
+
+/**
+ * enum nlmsgerr_attrs - nlmsgerr attributes
+ * @NLMSGERR_ATTR_UNUSED: unused
+ * @NLMSGERR_ATTR_MSG: error message string (string)
+ * @NLMSGERR_ATTR_OFFS: offset of the invalid attribute in the original
+ *	 message, counting from the beginning of the header (u32)
+ * @NLMSGERR_ATTR_COOKIE: arbitrary subsystem specific cookie to
+ *	be used - in the success case - to identify a created
+ *	object or operation or similar (binary)
+ * @__NLMSGERR_ATTR_MAX: number of attributes
+ * @NLMSGERR_ATTR_MAX: highest attribute number
+ */
+enum nlmsgerr_attrs {
+	NLMSGERR_ATTR_UNUSED,
+	NLMSGERR_ATTR_MSG,
+	NLMSGERR_ATTR_OFFS,
+	NLMSGERR_ATTR_COOKIE,
+
+	__NLMSGERR_ATTR_MAX,
+	NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1
+};
+
+#define NETLINK_ADD_MEMBERSHIP		1
+#define NETLINK_DROP_MEMBERSHIP		2
+#define NETLINK_PKTINFO			3
+#define NETLINK_BROADCAST_ERROR		4
+#define NETLINK_NO_ENOBUFS		5
+#define NETLINK_RX_RING			6
+#define NETLINK_TX_RING			7
+#define NETLINK_LISTEN_ALL_NSID		8
+#define NETLINK_LIST_MEMBERSHIPS	9
+#define NETLINK_CAP_ACK			10
+#define NETLINK_EXT_ACK			11
+
+struct nl_pktinfo {
+	__u32	group;
+};
+
+struct nl_mmap_req {
+	unsigned int	nm_block_size;
+	unsigned int	nm_block_nr;
+	unsigned int	nm_frame_size;
+	unsigned int	nm_frame_nr;
+};
+
+struct nl_mmap_hdr {
+	unsigned int	nm_status;
+	unsigned int	nm_len;
+	__u32		nm_group;
+	/* credentials */
+	__u32		nm_pid;
+	__u32		nm_uid;
+	__u32		nm_gid;
+};
+
+enum nl_mmap_status {
+	NL_MMAP_STATUS_UNUSED,
+	NL_MMAP_STATUS_RESERVED,
+	NL_MMAP_STATUS_VALID,
+	NL_MMAP_STATUS_COPY,
+	NL_MMAP_STATUS_SKIP,
+};
+
+#define NL_MMAP_MSG_ALIGNMENT		NLMSG_ALIGNTO
+#define NL_MMAP_MSG_ALIGN(sz)		__ALIGN_KERNEL(sz, NL_MMAP_MSG_ALIGNMENT)
+#define NL_MMAP_HDRLEN			NL_MMAP_MSG_ALIGN(sizeof(struct nl_mmap_hdr))
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr {
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
+/* Generic 32 bitflags attribute content sent to the kernel.
+ *
+ * The value is a bitmap that defines the values being set
+ * The selector is a bitmask that defines which value is legit
+ *
+ * Examples:
+ *  value = 0x0, and selector = 0x1
+ *  implies we are selecting bit 1 and we want to set its value to 0.
+ *
+ *  value = 0x2, and selector = 0x2
+ *  implies we are selecting bit 2 and we want to set its value to 1.
+ *
+ */
+struct nla_bitfield32 {
+	__u32 value;
+	__u32 selector;
+};
+
+#endif /* __LINUX_NETLINK_H */
diff -urpN frr-frr-5.0.1/include/subdir.am frr-frr-6.0/include/subdir.am
--- frr-frr-5.0.1/include/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/include/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -4,6 +4,7 @@ noinst_HEADERS += \
 	include/linux/lwtunnel.h \
 	include/linux/mpls_iptunnel.h \
 	include/linux/neighbour.h \
+	include/linux/netlink.h \
 	include/linux/rtnetlink.h \
 	include/linux/socket.h \
 	include/linux/net_namespace.h \
diff -urpN frr-frr-5.0.1/isisd/dict.c frr-frr-6.0/isisd/dict.c
--- frr-frr-5.0.1/isisd/dict.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/dict.c	2018-10-08 14:32:57.000000000 +0200
@@ -244,19 +244,18 @@ dict_t *dict_create(dictcount_t maxcount
 {
 	dict_t *new = XCALLOC(MTYPE_ISIS_DICT, sizeof(dict_t));
 
-	if (new) {
-		new->compare = comp;
-		new->allocnode = dnode_alloc;
-		new->freenode = dnode_free;
-		new->context = NULL;
-		new->nodecount = 0;
-		new->maxcount = maxcount;
-		new->nilnode.left = &new->nilnode;
-		new->nilnode.right = &new->nilnode;
-		new->nilnode.parent = &new->nilnode;
-		new->nilnode.color = dnode_black;
-		new->dupes = 0;
-	}
+	new->compare = comp;
+	new->allocnode = dnode_alloc;
+	new->freenode = dnode_free;
+	new->context = NULL;
+	new->nodecount = 0;
+	new->maxcount = maxcount;
+	new->nilnode.left = &new->nilnode;
+	new->nilnode.right = &new->nilnode;
+	new->nilnode.parent = &new->nilnode;
+	new->nilnode.color = dnode_black;
+	new->dupes = 0;
+
 	return new;
 }
 
@@ -974,12 +973,12 @@ static void dnode_free(dnode_t *node, vo
 dnode_t *dnode_create(void *data)
 {
 	dnode_t *new = XCALLOC(MTYPE_ISIS_DICT_NODE, sizeof(dnode_t));
-	if (new) {
-		new->data = data;
-		new->parent = NULL;
-		new->left = NULL;
-		new->right = NULL;
-	}
+
+	new->data = data;
+	new->parent = NULL;
+	new->left = NULL;
+	new->right = NULL;
+
 	return new;
 }
 
@@ -1250,8 +1249,8 @@ static char *dupstring(char *str)
 {
 	int sz = strlen(str) + 1;
 	char *new = XCALLOC(MTYPE_ISIS_TMP, sz);
-	if (new)
-		memcpy(new, str, sz);
+
+	memcpy(new, str, sz);
 	return new;
 }
 
diff -urpN frr-frr-5.0.1/isisd/isis_adjacency.c frr-frr-6.0/isisd/isis_adjacency.c
--- frr-frr-5.0.1/isisd/isis_adjacency.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_adjacency.c	2018-10-08 14:32:57.000000000 +0200
@@ -288,7 +288,6 @@ void isis_adj_state_change(struct isis_a
 		if (del)
 			isis_delete_adj(adj);
 
-		adj = NULL;
 	} else if (circuit->circ_type == CIRCUIT_T_P2P) {
 		del = false;
 		for (level = IS_LEVEL_1; level <= IS_LEVEL_2; level++) {
@@ -326,8 +325,6 @@ void isis_adj_state_change(struct isis_a
 
 		if (del)
 			isis_delete_adj(adj);
-
-		adj = NULL;
 	}
 
 	return;
diff -urpN frr-frr-5.0.1/isisd/isis_bpf.c frr-frr-6.0/isisd/isis_bpf.c
--- frr-frr-5.0.1/isisd/isis_bpf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_bpf.c	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #include "network.h"
 #include "stream.h"
 #include "if.h"
+#include "lib_errors.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -42,6 +43,7 @@
 #include "isisd/isis_constants.h"
 #include "isisd/isis_circuit.h"
 #include "isisd/isis_network.h"
+#include "isisd/isis_pdu.h"
 
 #include "privs.h"
 
@@ -186,30 +188,25 @@ int isis_sock_init(struct isis_circuit *
 {
 	int retval = ISIS_OK;
 
-	if (isisd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __func__,
-			 safe_strerror(errno));
-
-	retval = open_bpf_dev(circuit);
-
-	if (retval != ISIS_OK) {
-		zlog_warn("%s: could not initialize the socket", __func__);
-		goto end;
-	}
-
-	if (if_is_broadcast(circuit->interface)) {
-		circuit->tx = isis_send_pdu_bcast;
-		circuit->rx = isis_recv_pdu_bcast;
-	} else {
-		zlog_warn("isis_sock_init(): unknown circuit type");
-		retval = ISIS_WARNING;
-		goto end;
-	}
-
-end:
-	if (isisd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __func__,
-			 safe_strerror(errno));
+	frr_elevate_privs(&isisd_privs) {
+
+		retval = open_bpf_dev(circuit);
+
+		if (retval != ISIS_OK) {
+			zlog_warn("%s: could not initialize the socket",
+				  __func__);
+			break;
+		}
+
+		if (if_is_broadcast(circuit->interface)) {
+			circuit->tx = isis_send_pdu_bcast;
+			circuit->rx = isis_recv_pdu_bcast;
+		} else {
+			zlog_warn("isis_sock_init(): unknown circuit type");
+			retval = ISIS_WARNING;
+			break;
+		}
+	}
 
 	return retval;
 }
diff -urpN frr-frr-5.0.1/isisd/isis_circuit.c frr-frr-6.0/isisd/isis_circuit.c
--- frr-frr-5.0.1/isisd/isis_circuit.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_circuit.c	2018-10-08 14:32:57.000000000 +0200
@@ -57,6 +57,7 @@
 #include "isisd/isis_events.h"
 #include "isisd/isis_te.h"
 #include "isisd/isis_mt.h"
+#include "isisd/isis_errors.h"
 
 DEFINE_QOBJ_TYPE(isis_circuit)
 
@@ -73,10 +74,6 @@ struct isis_circuit *isis_circuit_new()
 	int i;
 
 	circuit = XCALLOC(MTYPE_ISIS_CIRCUIT, sizeof(struct isis_circuit));
-	if (circuit == NULL) {
-		zlog_err("Can't malloc isis circuit");
-		return NULL;
-	}
 
 	/*
 	 * Default values
@@ -357,14 +354,14 @@ void isis_circuit_del_addr(struct isis_c
 			for (ALL_LIST_ELEMENTS_RO(circuit->ipv6_link, node,
 						  ip6)) {
 				prefix2str((struct prefix *)ip6, (char *)buf,
-					   BUFSIZ);
+					   sizeof(buf));
 				zlog_warn("  %s", buf);
 			}
 			zlog_warn(" -----");
 			for (ALL_LIST_ELEMENTS_RO(circuit->ipv6_non_link, node,
 						  ip6)) {
 				prefix2str((struct prefix *)ip6, (char *)buf,
-					   BUFSIZ);
+					   sizeof(buf));
 				zlog_warn("  %s", buf);
 			}
 			zlog_warn("End of addresses");
@@ -539,7 +536,7 @@ void isis_circuit_stream(struct isis_cir
 		*stream = stream_new(stream_size);
 	} else {
 		if (STREAM_SIZE(*stream) != stream_size)
-			stream_resize(*stream, stream_size);
+			stream_resize_inplace(stream, stream_size);
 		stream_reset(*stream);
 	}
 }
@@ -570,7 +567,8 @@ int isis_circuit_up(struct isis_circuit
 		return ISIS_OK;
 
 	if (circuit->area->lsp_mtu > isis_circuit_pdu_size(circuit)) {
-		zlog_err(
+		flog_err(
+			ISIS_ERR_CONFIG,
 			"Interface MTU %zu on %s is too low to support area lsp mtu %u!",
 			isis_circuit_pdu_size(circuit),
 			circuit->interface->name, circuit->area->lsp_mtu);
@@ -581,7 +579,9 @@ int isis_circuit_up(struct isis_circuit
 	if (circuit->circ_type == CIRCUIT_T_BROADCAST) {
 		circuit->circuit_id = isis_circuit_id_gen(isis, circuit->interface);
 		if (!circuit->circuit_id) {
-			zlog_err("There are already 255 broadcast circuits active!");
+			flog_err(
+				ISIS_ERR_CONFIG,
+				"There are already 255 broadcast circuits active!");
 			return ISIS_ERROR;
 		}
 
@@ -638,7 +638,7 @@ int isis_circuit_up(struct isis_circuit
 			thread_add_timer(master, isis_run_dr_l2, circuit,
 					 2 * circuit->hello_interval[1],
 					 &circuit->u.bc.t_run_dr[1]);
-	} else {
+	} else if (circuit->circ_type == CIRCUIT_T_P2P) {
 		/* initializing the hello send threads
 		 * for a ptp IF
 		 */
@@ -682,9 +682,6 @@ int isis_circuit_up(struct isis_circuit
 
 void isis_circuit_down(struct isis_circuit *circuit)
 {
-	if (circuit->state != C_STATE_UP)
-		return;
-
 	/* Clear the flags for all the lsps of the circuit. */
 	isis_circuit_update_all_srmflags(circuit, 0);
 
@@ -756,10 +753,12 @@ void isis_circuit_down(struct isis_circu
 	}
 
 	/* send one gratuitous hello to spead up convergence */
-	if (circuit->is_type & IS_LEVEL_1)
-		send_hello(circuit, IS_LEVEL_1);
-	if (circuit->is_type & IS_LEVEL_2)
-		send_hello(circuit, IS_LEVEL_2);
+	if (circuit->state == C_STATE_UP) {
+		if (circuit->is_type & IS_LEVEL_1)
+			send_hello(circuit, IS_LEVEL_1);
+		if (circuit->is_type & IS_LEVEL_2)
+			send_hello(circuit, IS_LEVEL_2);
+	}
 
 	circuit->upadjcount[0] = 0;
 	circuit->upadjcount[1] = 0;
diff -urpN frr-frr-5.0.1/isisd/isis_csm.c frr-frr-6.0/isisd/isis_csm.c
--- frr-frr-5.0.1/isisd/isis_csm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_csm.c	2018-10-08 14:32:57.000000000 +0200
@@ -47,6 +47,7 @@
 #include "isisd/isisd.h"
 #include "isisd/isis_csm.h"
 #include "isisd/isis_events.h"
+#include "isisd/isis_errors.h"
 
 extern struct isis *isis;
 
@@ -137,10 +138,12 @@ isis_csm_state_change(int event, struct
 		case IF_UP_FROM_Z:
 			isis_circuit_if_add(circuit, (struct interface *)arg);
 			if (isis_circuit_up(circuit) != ISIS_OK) {
-				zlog_err(
+				flog_err(
+					ISIS_ERR_CONFIG,
 					"Could not bring up %s because of invalid config.",
 					circuit->interface->name);
-				zlog_err(
+				flog_err(
+					ISIS_ERR_CONFIG,
 					"Clearing config for %s. Please re-examine it.",
 					circuit->interface->name);
 				if (circuit->ip_router) {
diff -urpN frr-frr-5.0.1/isisd/isis_dlpi.c frr-frr-6.0/isisd/isis_dlpi.c
--- frr-frr-5.0.1/isisd/isis_dlpi.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_dlpi.c	2018-10-08 14:32:57.000000000 +0200
@@ -36,6 +36,7 @@
 #include "network.h"
 #include "stream.h"
 #include "if.h"
+#include "lib_errors.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -467,31 +468,26 @@ int isis_sock_init(struct isis_circuit *
 {
 	int retval = ISIS_OK;
 
-	if (isisd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __func__,
-			 safe_strerror(errno));
+	frr_elevate_privs(&isisd_privs) {
 
-	retval = open_dlpi_dev(circuit);
+		retval = open_dlpi_dev(circuit);
 
-	if (retval != ISIS_OK) {
-		zlog_warn("%s: could not initialize the socket", __func__);
-		goto end;
-	}
+		if (retval != ISIS_OK) {
+			zlog_warn("%s: could not initialize the socket",
+				  __func__);
+			break;
+		}
 
-	if (circuit->circ_type == CIRCUIT_T_BROADCAST) {
-		circuit->tx = isis_send_pdu_bcast;
-		circuit->rx = isis_recv_pdu_bcast;
-	} else {
-		zlog_warn("isis_sock_init(): unknown circuit type");
-		retval = ISIS_WARNING;
-		goto end;
+		if (circuit->circ_type == CIRCUIT_T_BROADCAST) {
+			circuit->tx = isis_send_pdu_bcast;
+			circuit->rx = isis_recv_pdu_bcast;
+		} else {
+			zlog_warn("isis_sock_init(): unknown circuit type");
+			retval = ISIS_WARNING;
+			break;
+		}
 	}
 
-end:
-	if (isisd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __func__,
-			 safe_strerror(errno));
-
 	return retval;
 }
 
diff -urpN frr-frr-5.0.1/isisd/isis_errors.c frr-frr-6.0/isisd/isis_errors.c
--- frr-frr-5.0.1/isisd/isis_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/isisd/isis_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * ISIS-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "isis_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_isis_err[] = {
+	{
+		.code = ISIS_ERR_PACKET,
+		.title = "ISIS Packet Error",
+		.description = "Isis has detected an error with a packet from a peer",
+		.suggestion = "Gather log information and open an issue then restart FRR"
+	},
+	{
+		.code = ISIS_ERR_CONFIG,
+		.title = "ISIS Configuration Error",
+		.description = "Isis has detected an error within configuration for the router",
+		.suggestion = "Ensure configuration is correct"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void isis_error_init(void)
+{
+	log_ref_add(ferr_isis_err);
+}
diff -urpN frr-frr-5.0.1/isisd/isis_errors.h frr-frr-6.0/isisd/isis_errors.h
--- frr-frr-5.0.1/isisd/isis_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/isisd/isis_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * ISIS-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __ISIS_ERRORS_H__
+#define __ISIS_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum isis_log_refs {
+	ISIS_ERR_PACKET = ISIS_FERR_START,
+	ISIS_ERR_CONFIG,
+};
+
+extern void isis_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/isisd/isis_events.c frr-frr-6.0/isisd/isis_events.c
--- frr-frr-5.0.1/isisd/isis_events.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_events.c	2018-10-08 14:32:57.000000000 +0200
@@ -48,6 +48,7 @@
 #include "isisd/isis_csm.h"
 #include "isisd/isis_events.h"
 #include "isisd/isis_spf.h"
+#include "isisd/isis_errors.h"
 
 /* debug isis-spf spf-events
  4w4d: ISIS-Spf (tlt): L2 SPF needed, new adjacency, from 0x609229F4
@@ -156,9 +157,9 @@ void isis_circuit_is_type_set(struct isi
 		return; /* No change */
 
 	if (!(newtype & circuit->area->is_type)) {
-		zlog_err(
-			"ISIS-Evt (%s) circuit type change - invalid level %s because"
-			" area is %s",
+		flog_err(
+			ISIS_ERR_CONFIG,
+			"ISIS-Evt (%s) circuit type change - invalid level %s because area is %s",
 			circuit->area->area_tag, circuit_t2string(newtype),
 			circuit_t2string(circuit->area->is_type));
 		return;
diff -urpN frr-frr-5.0.1/isisd/isis_lsp.c frr-frr-6.0/isisd/isis_lsp.c
--- frr-frr-5.0.1/isisd/isis_lsp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_lsp.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,8 @@
 #include "checksum.h"
 #include "md5.h"
 #include "table.h"
+#include "srcdest_table.h"
+#include "lib_errors.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -55,9 +57,6 @@
 #include "isisd/isis_mt.h"
 #include "isisd/isis_tlvs.h"
 
-/* staticly assigned vars for printing purposes */
-char lsp_bits_string[200]; /* FIXME: enough ? */
-
 static int lsp_l1_refresh(struct thread *thread);
 static int lsp_l2_refresh(struct thread *thread);
 static int lsp_l1_refresh_pseudo(struct thread *thread);
@@ -455,7 +454,8 @@ void lsp_update(struct isis_lsp *lsp, st
 		struct isis_area *area, int level, bool confusion)
 {
 	if (lsp->own_lsp) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_DEVELOPMENT,
 			"ISIS-Upd (%s): BUG updating LSP %s still marked as own LSP",
 			area->area_tag, rawlspid_print(lsp->hdr.lsp_id));
 		lsp_clear_data(lsp);
@@ -608,13 +608,16 @@ static void lspid_print(uint8_t *lsp_id,
 }
 
 /* Convert the lsp attribute bits to attribute string */
-static const char *lsp_bits2string(uint8_t lsp_bits)
+static const char *lsp_bits2string(uint8_t lsp_bits, char *buf, size_t buf_size)
 {
-	char *pos = lsp_bits_string;
+	char *pos = buf;
 
 	if (!lsp_bits)
 		return " none";
 
+	if (buf_size < 2 * 3)
+		return " error";
+
 	/* we only focus on the default metric */
 	pos += sprintf(pos, "%d/",
 		       ISIS_MASK_LSP_ATT_DEFAULT_BIT(lsp_bits) ? 1 : 0);
@@ -622,11 +625,9 @@ static const char *lsp_bits2string(uint8
 	pos += sprintf(pos, "%d/",
 		       ISIS_MASK_LSP_PARTITION_BIT(lsp_bits) ? 1 : 0);
 
-	pos += sprintf(pos, "%d", ISIS_MASK_LSP_OL_BIT(lsp_bits) ? 1 : 0);
+	sprintf(pos, "%d", ISIS_MASK_LSP_OL_BIT(lsp_bits) ? 1 : 0);
 
-	*(pos) = '\0';
-
-	return lsp_bits_string;
+	return buf;
 }
 
 /* this function prints the lsp on show isis database */
@@ -634,6 +635,7 @@ void lsp_print(struct isis_lsp *lsp, str
 {
 	uint8_t LSPid[255];
 	char age_out[8];
+	char b[200];
 
 	lspid_print(lsp->hdr.lsp_id, LSPid, dynhost, 1);
 	vty_out(vty, "%-21s%c  ", LSPid, lsp->own_lsp ? '*' : ' ');
@@ -646,7 +648,7 @@ void lsp_print(struct isis_lsp *lsp, str
 		vty_out(vty, "%7s   ", age_out);
 	} else
 		vty_out(vty, " %5" PRIu16 "    ", lsp->hdr.rem_lifetime);
-	vty_out(vty, "%s\n", lsp_bits2string(lsp->hdr.lsp_bits));
+	vty_out(vty, "%s\n", lsp_bits2string(lsp->hdr.lsp_bits, b, sizeof(b)));
 }
 
 void lsp_print_detail(struct isis_lsp *lsp, struct vty *vty, char dynhost)
@@ -766,18 +768,28 @@ static void lsp_build_ext_reach_ipv6(str
 		return;
 
 	for (struct route_node *rn = route_top(er_table); rn;
-	     rn = route_next(rn)) {
+	     rn = srcdest_route_next(rn)) {
 		if (!rn->info)
 			continue;
-
-		struct prefix_ipv6 *ipv6 = (struct prefix_ipv6 *)&rn->p;
 		struct isis_ext_info *info = rn->info;
 
+		struct prefix_ipv6 *p, *src_p;
+		srcdest_rnode_prefixes(rn, (const struct prefix **)&p,
+				       (const struct prefix **)&src_p);
+
 		uint32_t metric = info->metric;
 		if (info->metric > MAX_WIDE_PATH_METRIC)
 			metric = MAX_WIDE_PATH_METRIC;
-		isis_tlvs_add_ipv6_reach(
-			lsp->tlvs, isis_area_ipv6_topology(area), ipv6, metric);
+
+		if (!src_p || !src_p->prefixlen) {
+			isis_tlvs_add_ipv6_reach(lsp->tlvs,
+						 isis_area_ipv6_topology(area),
+						 p, metric);
+		} else if (isis_area_ipv6_dstsrc_enabled(area)) {
+			isis_tlvs_add_ipv6_dstsrc_reach(lsp->tlvs,
+							ISIS_MT_IPV6_DSTSRC,
+							p, src_p, metric);
+		}
 	}
 }
 
@@ -1053,6 +1065,7 @@ static void lsp_build(struct isis_lsp *l
 					uint8_t subtlv_len;
 
 					if (IS_MPLS_TE(isisMplsTE)
+					    && circuit->interface != NULL
 					    && HAS_LINK_PARAMS(
 						       circuit->interface))
 						/* Update Local and Remote IP
@@ -1231,8 +1244,9 @@ static int lsp_regenerate(struct isis_ar
 	lsp = lsp_search(lspid, lspdb);
 
 	if (!lsp) {
-		zlog_err("ISIS-Upd (%s): lsp_regenerate: no L%d LSP found!",
-			 area->area_tag, level);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "ISIS-Upd (%s): lsp_regenerate: no L%d LSP found!",
+			  area->area_tag, level);
 		return ISIS_ERROR;
 	}
 
@@ -1599,8 +1613,9 @@ static int lsp_regenerate_pseudo(struct
 	lsp = lsp_search(lsp_id, lspdb);
 
 	if (!lsp) {
-		zlog_err("lsp_regenerate_pseudo: no l%d LSP %s found!", level,
-			 rawlspid_print(lsp_id));
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "lsp_regenerate_pseudo: no l%d LSP %s found!", level,
+			  rawlspid_print(lsp_id));
 		return ISIS_ERROR;
 	}
 
diff -urpN frr-frr-5.0.1/isisd/isis_main.c frr-frr-6.0/isisd/isis_main.c
--- frr-frr-5.0.1/isisd/isis_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -53,6 +53,7 @@
 #include "isisd/isis_routemap.h"
 #include "isisd/isis_zebra.h"
 #include "isisd/isis_te.h"
+#include "isisd/isis_errors.h"
 
 /* Default configuration file name */
 #define ISISD_DEFAULT_CONFIG "isisd.conf"
@@ -103,7 +104,7 @@ static __attribute__((__noreturn__)) voi
 
 void sighup(void)
 {
-	zlog_err("SIGHUP/reload is not implemented for isisd");
+	zlog_notice("SIGHUP/reload is not implemented for isisd");
 	return;
 }
 
@@ -189,6 +190,7 @@ int main(int argc, char **argv, char **e
 	/*
 	 *  initializations
 	 */
+	isis_error_init();
 	access_list_init();
 	vrf_init(NULL, NULL, NULL, NULL);
 	prefix_list_init();
diff -urpN frr-frr-5.0.1/isisd/isis_mt.c frr-frr-6.0/isisd/isis_mt.c
--- frr-frr-5.0.1/isisd/isis_mt.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_mt.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,14 @@ DEFINE_MTYPE_STATIC(ISISD, MT_AREA_SETTI
 DEFINE_MTYPE_STATIC(ISISD, MT_CIRCUIT_SETTING, "ISIS MT Circuit Setting")
 DEFINE_MTYPE_STATIC(ISISD, MT_ADJ_INFO, "ISIS MT Adjacency Info")
 
+bool isis_area_ipv6_dstsrc_enabled(struct isis_area *area)
+{
+	struct isis_area_mt_setting *area_mt_setting;
+	area_mt_setting = area_lookup_mt_setting(area, ISIS_MT_IPV6_DSTSRC);
+
+	return (area_mt_setting && area_mt_setting->enabled);
+}
+
 uint16_t isis_area_ipv6_topology(struct isis_area *area)
 {
 	struct isis_area_mt_setting *area_mt_setting;
@@ -61,6 +69,8 @@ const char *isis_mtid2str(uint16_t mtid)
 		return "ipv6-multicast";
 	case ISIS_MT_IPV6_MGMT:
 		return "ipv6-mgmt";
+	case ISIS_MT_IPV6_DSTSRC:
+		return "ipv6-dstsrc";
 	default:
 		snprintf(buf, sizeof(buf), "%" PRIu16, mtid);
 		return buf;
@@ -81,6 +91,8 @@ uint16_t isis_str2mtid(const char *name)
 		return ISIS_MT_IPV6_MULTICAST;
 	if (!strcmp(name, "ipv6-mgmt"))
 		return ISIS_MT_IPV6_MGMT;
+	if (!strcmp(name, "ipv6-dstsrc"))
+		return ISIS_MT_IPV6_DSTSRC;
 	return -1;
 }
 
diff -urpN frr-frr-5.0.1/isisd/isis_mt.h frr-frr-6.0/isisd/isis_mt.h
--- frr-frr-5.0.1/isisd/isis_mt.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_mt.h	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #define ISIS_MT_IPV4_MULTICAST 3
 #define ISIS_MT_IPV6_MULTICAST 4
 #define ISIS_MT_IPV6_MGMT      5
+#define ISIS_MT_IPV6_DSTSRC    3996 /* FIXME: IANA */
 
 #define ISIS_MT_NAMES                                                          \
 	"<ipv4-unicast"                                                        \
@@ -40,6 +41,7 @@
 	"|ipv4-multicast"                                                      \
 	"|ipv6-multicast"                                                      \
 	"|ipv6-mgmt"                                                           \
+	"|ipv6-dstsrc"                                                         \
 	">"
 
 #define ISIS_MT_DESCRIPTIONS                                                   \
@@ -48,7 +50,9 @@
 	"IPv6 unicast topology\n"                                              \
 	"IPv4 multicast topology\n"                                            \
 	"IPv6 multicast topology\n"                                            \
-	"IPv6 management topology\n"
+	"IPv6 management topology\n"                                           \
+	"IPv6 dst-src topology\n"                                              \
+	""
 
 #define ISIS_MT_INFO_FIELDS uint16_t mtid;
 
@@ -75,6 +79,8 @@ struct tlvs;
 struct te_is_neigh;
 struct isis_tlvs;
 
+bool isis_area_ipv6_dstsrc_enabled(struct isis_area *area);
+
 uint16_t isis_area_ipv6_topology(struct isis_area *area);
 
 struct isis_area_mt_setting *area_lookup_mt_setting(struct isis_area *area,
diff -urpN frr-frr-5.0.1/isisd/isis_pdu.c frr-frr-6.0/isisd/isis_pdu.c
--- frr-frr-5.0.1/isisd/isis_pdu.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_pdu.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "if.h"
 #include "checksum.h"
 #include "md5.h"
+#include "lib_errors.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -54,6 +55,7 @@
 #include "isisd/isis_te.h"
 #include "isisd/isis_mt.h"
 #include "isisd/isis_tlvs.h"
+#include "isisd/isis_errors.h"
 
 static int ack_lsp(struct isis_lsp_hdr *hdr, struct isis_circuit *circuit,
 		   int level)
@@ -86,9 +88,10 @@ static int ack_lsp(struct isis_lsp_hdr *
 
 	retval = circuit->tx(circuit, level);
 	if (retval != ISIS_OK)
-		zlog_err("ISIS-Upd (%s): Send L%d LSP PSNP on %s failed",
-			 circuit->area->area_tag, level,
-			 circuit->interface->name);
+		flog_err(ISIS_ERR_PACKET,
+			  "ISIS-Upd (%s): Send L%d LSP PSNP on %s failed",
+			  circuit->area->area_tag, level,
+			  circuit->interface->name);
 
 	return retval;
 }
@@ -614,8 +617,9 @@ static int process_hello(uint8_t pdu_typ
 	}
 
 	if (!p2p_hello && !(level & iih.circ_type)) {
-		zlog_err("Level %d LAN Hello with Circuit Type %d", level,
-			 iih.circ_type);
+		flog_err(ISIS_ERR_PACKET,
+			  "Level %d LAN Hello with Circuit Type %d", level,
+			  iih.circ_type);
 		return ISIS_ERROR;
 	}
 
@@ -673,8 +677,15 @@ static int process_hello(uint8_t pdu_typ
 	iih.v6_usable = (circuit->ipv6_link && listcount(circuit->ipv6_link)
 			 && iih.tlvs->ipv6_address.count);
 
-	if (!iih.v4_usable && !iih.v6_usable)
+	if (!iih.v4_usable && !iih.v6_usable) {
+		if (isis->debugs & DEBUG_ADJ_PACKETS) {
+			zlog_warn(
+				"ISIS-Adj (%s): Neither IPv4 nor IPv6 considered usable. Ignoring IIH",
+				circuit->area->area_tag);
+		}
+
 		goto out;
+	}
 
 	retval = p2p_hello ? process_p2p_hello(&iih) : process_lan_hello(&iih);
 out:
@@ -1343,7 +1354,7 @@ int isis_handle_pdu(struct isis_circuit
 
 	/* Verify that at least the 8 bytes fixed header have been received */
 	if (stream_get_endp(circuit->rcv_stream) < ISIS_FIXED_HDR_LEN) {
-		zlog_err("PDU is too short to be IS-IS.");
+		flog_err(ISIS_ERR_PACKET, "PDU is too short to be IS-IS.");
 		return ISIS_ERROR;
 	}
 
@@ -1358,12 +1369,14 @@ int isis_handle_pdu(struct isis_circuit
 	uint8_t max_area_addrs = stream_getc(circuit->rcv_stream);
 
 	if (idrp == ISO9542_ESIS) {
-		zlog_err("No support for ES-IS packet IDRP=%" PRIx8, idrp);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "No support for ES-IS packet IDRP=%" PRIx8, idrp);
 		return ISIS_ERROR;
 	}
 
 	if (idrp != ISO10589_ISIS) {
-		zlog_err("Not an IS-IS packet IDRP=%" PRIx8, idrp);
+		flog_err(ISIS_ERR_PACKET, "Not an IS-IS packet IDRP=%" PRIx8,
+			  idrp);
 		return ISIS_ERROR;
 	}
 
@@ -1373,7 +1386,8 @@ int isis_handle_pdu(struct isis_circuit
 	}
 
 	if (id_len != 0 && id_len != ISIS_SYS_ID_LEN) {
-		zlog_err(
+		flog_err(
+			ISIS_ERR_PACKET,
 			"IDFieldLengthMismatch: ID Length field in a received PDU  %" PRIu8
 			", while the parameter for this IS is %u",
 			id_len, ISIS_SYS_ID_LEN);
@@ -1387,14 +1401,16 @@ int isis_handle_pdu(struct isis_circuit
 	}
 
 	if (length != expected_length) {
-		zlog_err("Exepected fixed header length = %" PRIu8
-			 " but got %" PRIu8,
-			 expected_length, length);
+		flog_err(ISIS_ERR_PACKET,
+			  "Exepected fixed header length = %" PRIu8
+			  " but got %" PRIu8,
+			  expected_length, length);
 		return ISIS_ERROR;
 	}
 
 	if (stream_get_endp(circuit->rcv_stream) < length) {
-		zlog_err(
+		flog_err(
+			ISIS_ERR_PACKET,
 			"PDU is too short to contain fixed header of given PDU type.");
 		return ISIS_ERROR;
 	}
@@ -1412,7 +1428,8 @@ int isis_handle_pdu(struct isis_circuit
 
 	/* either 3 or 0 */
 	if (max_area_addrs != 0 && max_area_addrs != isis->max_area_addrs) {
-		zlog_err(
+		flog_err(
+			ISIS_ERR_PACKET,
 			"maximumAreaAddressesMismatch: maximumAreaAdresses in a received PDU %" PRIu8
 			" while the parameter for this IS is %u",
 			max_area_addrs, isis->max_area_addrs);
@@ -1636,9 +1653,10 @@ int send_hello(struct isis_circuit *circ
 
 	retval = circuit->tx(circuit, level);
 	if (retval != ISIS_OK)
-		zlog_err("ISIS-Adj (%s): Send L%d IIH on %s failed",
-			 circuit->area->area_tag, level,
-			 circuit->interface->name);
+		flog_err(ISIS_ERR_PACKET,
+			  "ISIS-Adj (%s): Send L%d IIH on %s failed",
+			  circuit->area->area_tag, level,
+			  circuit->interface->name);
 
 	return retval;
 }
@@ -1833,9 +1851,10 @@ int send_csnp(struct isis_circuit *circu
 
 		int retval = circuit->tx(circuit, level);
 		if (retval != ISIS_OK) {
-			zlog_err("ISIS-Snp (%s): Send L%d CSNP on %s failed",
-				 circuit->area->area_tag, level,
-				 circuit->interface->name);
+			flog_err(ISIS_ERR_PACKET,
+				  "ISIS-Snp (%s): Send L%d CSNP on %s failed",
+				  circuit->area->area_tag, level,
+				  circuit->interface->name);
 			isis_free_tlvs(tlvs);
 			return retval;
 		}
@@ -1997,9 +2016,10 @@ static int send_psnp(int level, struct i
 
 		int retval = circuit->tx(circuit, level);
 		if (retval != ISIS_OK) {
-			zlog_err("ISIS-Snp (%s): Send L%d PSNP on %s failed",
-				 circuit->area->area_tag, level,
-				 circuit->interface->name);
+			flog_err(ISIS_ERR_PACKET,
+				  "ISIS-Snp (%s): Send L%d PSNP on %s failed",
+				  circuit->area->area_tag, level,
+				  circuit->interface->name);
 			isis_free_tlvs(tlvs);
 			return retval;
 		}
@@ -2104,7 +2124,8 @@ int send_lsp(struct thread *thread)
 	 * than
 	 * the circuit's MTU. So handle and log this case here. */
 	if (stream_get_endp(lsp->pdu) > stream_get_size(circuit->snd_stream)) {
-		zlog_err(
+		flog_err(
+			ISIS_ERR_PACKET,
 			"ISIS-Upd (%s): Can't send L%d LSP %s, seq 0x%08" PRIx32
 			", cksum 0x%04" PRIx16 ", lifetime %" PRIu16
 			"s on %s. LSP Size is %zu while interface stream size is %zu.",
@@ -2139,11 +2160,12 @@ int send_lsp(struct thread *thread)
 	clear_srm = 0;
 	retval = circuit->tx(circuit, lsp->level);
 	if (retval != ISIS_OK) {
-		zlog_err("ISIS-Upd (%s): Send L%d LSP on %s failed %s",
-			 circuit->area->area_tag, lsp->level,
-			 circuit->interface->name,
-			 (retval == ISIS_WARNING) ? "temporarily"
-						  : "permanently");
+		flog_err(ISIS_ERR_PACKET,
+			  "ISIS-Upd (%s): Send L%d LSP on %s failed %s",
+			  circuit->area->area_tag, lsp->level,
+			  circuit->interface->name,
+			  (retval == ISIS_WARNING) ? "temporarily"
+						   : "permanently");
 	}
 
 out:
diff -urpN frr-frr-5.0.1/isisd/isis_pfpacket.c frr-frr-6.0/isisd/isis_pfpacket.c
--- frr-frr-5.0.1/isisd/isis_pfpacket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_pfpacket.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "network.h"
 #include "stream.h"
 #include "if.h"
+#include "lib_errors.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -184,35 +185,30 @@ int isis_sock_init(struct isis_circuit *
 {
 	int retval = ISIS_OK;
 
-	if (isisd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __func__,
-			 safe_strerror(errno));
-
-	retval = open_packet_socket(circuit);
-
-	if (retval != ISIS_OK) {
-		zlog_warn("%s: could not initialize the socket", __func__);
-		goto end;
-	}
+	frr_elevate_privs(&isisd_privs) {
+
+		retval = open_packet_socket(circuit);
+
+		if (retval != ISIS_OK) {
+			zlog_warn("%s: could not initialize the socket",
+				  __func__);
+			break;
+		}
 
 	/* Assign Rx and Tx callbacks are based on real if type */
-	if (if_is_broadcast(circuit->interface)) {
-		circuit->tx = isis_send_pdu_bcast;
-		circuit->rx = isis_recv_pdu_bcast;
-	} else if (if_is_pointopoint(circuit->interface)) {
-		circuit->tx = isis_send_pdu_p2p;
-		circuit->rx = isis_recv_pdu_p2p;
-	} else {
-		zlog_warn("isis_sock_init(): unknown circuit type");
-		retval = ISIS_WARNING;
-		goto end;
+		if (if_is_broadcast(circuit->interface)) {
+			circuit->tx = isis_send_pdu_bcast;
+			circuit->rx = isis_recv_pdu_bcast;
+		} else if (if_is_pointopoint(circuit->interface)) {
+			circuit->tx = isis_send_pdu_p2p;
+			circuit->rx = isis_recv_pdu_p2p;
+		} else {
+			zlog_warn("isis_sock_init(): unknown circuit type");
+			retval = ISIS_WARNING;
+			break;
+		}
 	}
 
-end:
-	if (isisd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __func__,
-			 safe_strerror(errno));
-
 	return retval;
 }
 
@@ -309,9 +305,9 @@ int isis_recv_pdu_p2p(struct isis_circui
 	addr_len = sizeof(s_addr);
 
 	/* we can read directly to the stream */
-	stream_recvfrom(circuit->rcv_stream, circuit->fd,
-			circuit->interface->mtu, 0, (struct sockaddr *)&s_addr,
-			(socklen_t *)&addr_len);
+	(void)stream_recvfrom(
+		circuit->rcv_stream, circuit->fd, circuit->interface->mtu, 0,
+		(struct sockaddr *)&s_addr, (socklen_t *)&addr_len);
 
 	if (s_addr.sll_pkttype == PACKET_OUTGOING) {
 		/*  Read the packet into discard buff */
diff -urpN frr-frr-5.0.1/isisd/isis_redist.c frr-frr-6.0/isisd/isis_redist.c
--- frr-frr-5.0.1/isisd/isis_redist.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_redist.c	2018-10-08 14:32:57.000000000 +0200
@@ -30,6 +30,7 @@
 #include "stream.h"
 #include "table.h"
 #include "vty.h"
+#include "srcdest_table.h"
 
 #include "isisd/dict.h"
 #include "isisd/isis_constants.h"
@@ -86,33 +87,13 @@ struct route_table *get_ext_reach(struct
 	return area->ext_reach[protocol][level - 1];
 }
 
-static struct route_node *
-isis_redist_route_node_create(route_table_delegate_t *delegate,
-			      struct route_table *table)
-{
-	struct route_node *node;
-	node = XCALLOC(MTYPE_ISIS_EXT_ROUTE, sizeof(*node));
-	return node;
-}
-
-static void isis_redist_route_node_destroy(route_table_delegate_t *delegate,
-					   struct route_table *table,
-					   struct route_node *node)
-{
-	if (node->info)
-		XFREE(MTYPE_ISIS_EXT_INFO, node->info);
-	XFREE(MTYPE_ISIS_EXT_ROUTE, node);
-}
-
-static route_table_delegate_t isis_redist_rt_delegate = {
-	.create_node = isis_redist_route_node_create,
-	.destroy_node = isis_redist_route_node_destroy};
-
 /* Install external reachability information into a
  * specific area for a specific level.
  * Schedule an lsp regenerate if necessary */
 static void isis_redist_install(struct isis_area *area, int level,
-				struct prefix *p, struct isis_ext_info *info)
+				const struct prefix *p,
+				const struct prefix_ipv6 *src_p,
+				struct isis_ext_info *info)
 {
 	int family = p->family;
 	struct route_table *er_table = get_ext_reach(area, family, level);
@@ -126,7 +107,7 @@ static void isis_redist_install(struct i
 		return;
 	}
 
-	er_node = route_node_get(er_table, p);
+	er_node = srcdest_rnode_get(er_table, p, src_p);
 	if (er_node->info) {
 		route_unlock_node(er_node);
 
@@ -145,7 +126,8 @@ static void isis_redist_install(struct i
  * specific area for a specific level.
  * Schedule an lsp regenerate if necessary. */
 static void isis_redist_uninstall(struct isis_area *area, int level,
-				  struct prefix *p)
+				  const struct prefix *p,
+				  const struct prefix_ipv6 *src_p)
 {
 	int family = p->family;
 	struct route_table *er_table = get_ext_reach(area, family, level);
@@ -159,7 +141,7 @@ static void isis_redist_uninstall(struct
 		return;
 	}
 
-	er_node = route_node_lookup(er_table, p);
+	er_node = srcdest_rnode_lookup(er_table, p, src_p);
 	if (!er_node)
 		return;
 	else
@@ -177,7 +159,8 @@ static void isis_redist_uninstall(struct
  * and prefix, using the given redistribution settings. */
 static void isis_redist_update_ext_reach(struct isis_area *area, int level,
 					 struct isis_redist *redist,
-					 struct prefix *p,
+					 const struct prefix *p,
+					 const struct prefix_ipv6 *src_p,
 					 struct isis_ext_info *info)
 {
 	struct isis_ext_info area_info;
@@ -188,7 +171,8 @@ static void isis_redist_update_ext_reach
 
 	if (redist->map_name) {
 		map_ret =
-			route_map_apply(redist->map, p, RMAP_ISIS, &area_info);
+			route_map_apply(redist->map, (struct prefix *)p,
+					RMAP_ISIS, &area_info);
 		if (map_ret == RMAP_DENYMATCH)
 			area_info.distance = 255;
 	}
@@ -199,9 +183,9 @@ static void isis_redist_update_ext_reach
 		area_info.distance = 255;
 
 	if (area_info.distance < 255)
-		isis_redist_install(area, level, p, &area_info);
+		isis_redist_install(area, level, p, src_p, &area_info);
 	else
-		isis_redist_uninstall(area, level, p);
+		isis_redist_uninstall(area, level, p, src_p);
 }
 
 static void isis_redist_ensure_default(struct isis *isis, int family)
@@ -222,7 +206,7 @@ static void isis_redist_ensure_default(s
 	} else
 		assert(!"Unknown family!");
 
-	ei_node = route_node_get(ei_table, &p);
+	ei_node = srcdest_rnode_get(ei_table, &p, NULL);
 	if (ei_node->info) {
 		route_unlock_node(ei_node);
 		return;
@@ -238,8 +222,8 @@ static void isis_redist_ensure_default(s
 }
 
 /* Handle notification about route being added */
-void isis_redist_add(int type, struct prefix *p, uint8_t distance,
-		     uint32_t metric)
+void isis_redist_add(int type, struct prefix *p, struct prefix_ipv6 *src_p,
+		     uint8_t distance, uint32_t metric)
 {
 	int family = p->family;
 	struct route_table *ei_table = get_ext_info(isis, family);
@@ -262,7 +246,7 @@ void isis_redist_add(int type, struct pr
 		return;
 	}
 
-	ei_node = route_node_get(ei_table, p);
+	ei_node = srcdest_rnode_get(ei_table, p, src_p);
 	if (ei_node->info)
 		route_unlock_node(ei_node);
 	else
@@ -274,8 +258,10 @@ void isis_redist_add(int type, struct pr
 	info->distance = distance;
 	info->metric = metric;
 
-	if (is_default_prefix(p))
+	if (is_default_prefix(p)
+	    && (!src_p || !src_p->prefixlen)) {
 		type = DEFAULT_ROUTE;
+	}
 
 	for (ALL_LIST_ELEMENTS_RO(isis->area_list, node, area))
 		for (level = 1; level <= ISIS_LEVELS; level++) {
@@ -284,11 +270,11 @@ void isis_redist_add(int type, struct pr
 				continue;
 
 			isis_redist_update_ext_reach(area, level, redist, p,
-						     info);
+						     src_p, info);
 		}
 }
 
-void isis_redist_delete(int type, struct prefix *p)
+void isis_redist_delete(int type, struct prefix *p, struct prefix_ipv6 *src_p)
 {
 	int family = p->family;
 	struct route_table *ei_table = get_ext_info(isis, family);
@@ -304,12 +290,14 @@ void isis_redist_delete(int type, struct
 	zlog_debug("%s: Removing route %s from %s.", __func__, debug_buf,
 		   zebra_route_string(type));
 
-	if (is_default_prefix(p)) {
+	if (is_default_prefix(p)
+	    && (!src_p || !src_p->prefixlen)) {
 		/* Don't remove default route but add synthetic route for use
 		 * by "default-information originate always". Areas without the
 		 * "always" setting will ignore routes with origin
 		 * DEFAULT_ROUTE. */
-		isis_redist_add(DEFAULT_ROUTE, p, 254, MAX_WIDE_PATH_METRIC);
+		isis_redist_add(DEFAULT_ROUTE, p, NULL,
+				254, MAX_WIDE_PATH_METRIC);
 		return;
 	}
 
@@ -319,7 +307,7 @@ void isis_redist_delete(int type, struct
 		return;
 	}
 
-	ei_node = route_node_lookup(ei_table, p);
+	ei_node = srcdest_rnode_lookup(ei_table, p, src_p);
 	if (!ei_node || !ei_node->info) {
 		char buf[BUFSIZ];
 		prefix2str(p, buf, sizeof(buf));
@@ -334,12 +322,12 @@ void isis_redist_delete(int type, struct
 	route_unlock_node(ei_node);
 
 	for (ALL_LIST_ELEMENTS_RO(isis->area_list, node, area))
-		for (level = 1; level < ISIS_LEVELS; level++) {
+		for (level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
 			redist = get_redist_settings(area, family, type, level);
 			if (!redist->redist)
 				continue;
 
-			isis_redist_uninstall(area, level, p);
+			isis_redist_uninstall(area, level, p, src_p);
 		}
 
 	XFREE(MTYPE_ISIS_EXT_INFO, ei_node->info);
@@ -418,17 +406,14 @@ static void isis_redist_set(struct isis_
 	isis_redist_routemap_set(redist, routemap);
 
 	if (!area->ext_reach[protocol][level - 1]) {
-		area->ext_reach[protocol][level - 1] =
-			route_table_init_with_delegate(
-				&isis_redist_rt_delegate);
+		area->ext_reach[protocol][level - 1] = srcdest_table_init();
 	}
 
-	for (i = 0; i < REDIST_PROTOCOL_COUNT; i++)
+	for (i = 0; i < REDIST_PROTOCOL_COUNT; i++) {
 		if (!area->isis->ext_info[i]) {
-			area->isis->ext_info[i] =
-				route_table_init_with_delegate(
-					&isis_redist_rt_delegate);
+			area->isis->ext_info[i] = srcdest_table_init();
 		}
+	}
 
 	isis_redist_update_zebra_subscriptions(area->isis);
 
@@ -436,20 +421,27 @@ static void isis_redist_set(struct isis_
 		isis_redist_ensure_default(area->isis, family);
 
 	ei_table = get_ext_info(area->isis, family);
-	for (rn = route_top(ei_table); rn; rn = route_next(rn)) {
+	for (rn = route_top(ei_table); rn; rn = srcdest_route_next(rn)) {
 		if (!rn->info)
 			continue;
 		info = rn->info;
 
+		const struct prefix *p, *src_p;
+
+		srcdest_rnode_prefixes(rn, &p, &src_p);
+
 		if (type == DEFAULT_ROUTE) {
-			if (!is_default_prefix(&rn->p))
+			if (!is_default_prefix(p)
+			    || (src_p && src_p->prefixlen)) {
 				continue;
+			}
 		} else {
 			if (info->origin != type)
 				continue;
 		}
 
-		isis_redist_update_ext_reach(area, level, redist, &rn->p, info);
+		isis_redist_update_ext_reach(area, level, redist, p,
+					     (struct prefix_ipv6 *)src_p, info);
 	}
 }
 
@@ -472,14 +464,19 @@ static void isis_redist_unset(struct isi
 		return;
 	}
 
-	for (rn = route_top(er_table); rn; rn = route_next(rn)) {
+	for (rn = route_top(er_table); rn; rn = srcdest_route_next(rn)) {
 		if (!rn->info)
 			continue;
 		info = rn->info;
 
+		const struct prefix *p, *src_p;
+		srcdest_rnode_prefixes(rn, &p, &src_p);
+
 		if (type == DEFAULT_ROUTE) {
-			if (!is_default_prefix(&rn->p))
+			if (!is_default_prefix(p)
+			    || (src_p && src_p->prefixlen)) {
 				continue;
+			}
 		} else {
 			if (info->origin != type)
 				continue;
diff -urpN frr-frr-5.0.1/isisd/isis_redist.h frr-frr-6.0/isisd/isis_redist.h
--- frr-frr-5.0.1/isisd/isis_redist.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_redist.h	2018-10-08 14:32:57.000000000 +0200
@@ -42,13 +42,14 @@ struct isis_redist {
 
 struct isis_area;
 struct prefix;
+struct prefix_ipv6;
 struct vty;
 
 struct route_table *get_ext_reach(struct isis_area *area, int family,
 				  int level);
-void isis_redist_add(int type, struct prefix *p, uint8_t distance,
-		     uint32_t metric);
-void isis_redist_delete(int type, struct prefix *p);
+void isis_redist_add(int type, struct prefix *p, struct prefix_ipv6 *src_p,
+		     uint8_t distance, uint32_t metric);
+void isis_redist_delete(int type, struct prefix *p, struct prefix_ipv6 *src_p);
 int isis_redist_config_write(struct vty *vty, struct isis_area *area,
 			     int family);
 void isis_redist_init(void);
diff -urpN frr-frr-5.0.1/isisd/isis_route.c frr-frr-6.0/isisd/isis_route.c
--- frr-frr-5.0.1/isisd/isis_route.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_route.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@
 #include "hash.h"
 #include "if.h"
 #include "table.h"
+#include "srcdest_table.h"
 
 #include "isis_constants.h"
 #include "isis_common.h"
@@ -199,6 +200,7 @@ static void adjinfo2nexthop6(struct list
 }
 
 static struct isis_route_info *isis_route_info_new(struct prefix *prefix,
+						   struct prefix_ipv6 *src_p,
 						   uint32_t cost,
 						   uint32_t depth,
 						   struct list *adjacencies)
@@ -232,8 +234,10 @@ static struct isis_route_info *isis_rout
 				SET_FLAG(rinfo->flag,
 					 ISIS_ROUTE_FLAG_ZEBRA_RESYNC);
 			/* update neighbor router address */
-			if (depth == 2 && prefix->prefixlen == 128)
+			if (depth == 2 && prefix->prefixlen == 128
+			    && (!src_p || !src_p->prefixlen)) {
 				adj->router_address6 = prefix->u.prefix6;
+			}
 			adjinfo2nexthop6(rinfo->nexthops6, adj);
 		}
 	}
@@ -317,10 +321,13 @@ static int isis_route_info_same(struct i
 	return 1;
 }
 
-struct isis_route_info *isis_route_create(struct prefix *prefix, uint32_t cost,
+struct isis_route_info *isis_route_create(struct prefix *prefix,
+					  struct prefix_ipv6 *src_p,
+					  uint32_t cost,
 					  uint32_t depth,
 					  struct list *adjacencies,
-					  struct isis_area *area, int level)
+					  struct isis_area *area,
+					  struct route_table *table)
 {
 	struct route_node *route_node;
 	struct isis_route_info *rinfo_new, *rinfo_old, *route_info = NULL;
@@ -331,18 +338,12 @@ struct isis_route_info *isis_route_creat
 	/* for debugs */
 	prefix2str(prefix, buff, sizeof(buff));
 
-	rinfo_new = isis_route_info_new(prefix, cost, depth, adjacencies);
-
-	if (family == AF_INET)
-		route_node =
-			route_node_get(area->route_table[level - 1], prefix);
-	else if (family == AF_INET6)
-		route_node =
-			route_node_get(area->route_table6[level - 1], prefix);
-	else {
-		isis_route_info_delete(rinfo_new);
+	if (!table)
 		return NULL;
-	}
+
+	rinfo_new = isis_route_info_new(prefix, src_p, cost,
+					depth, adjacencies);
+	route_node = srcdest_rnode_get(table, prefix, src_p);
 
 	rinfo_old = route_node->info;
 	if (!rinfo_old) {
@@ -352,6 +353,7 @@ struct isis_route_info *isis_route_creat
 		route_info = rinfo_new;
 		UNSET_FLAG(route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);
 	} else {
+		route_unlock_node(route_node);
 		if (isis->debugs & DEBUG_RTE_EVENTS)
 			zlog_debug("ISIS-Rte (%s) route already exists: %s",
 				   area->area_tag, buff);
@@ -378,19 +380,21 @@ struct isis_route_info *isis_route_creat
 	return route_info;
 }
 
-static void isis_route_delete(struct prefix *prefix, struct route_table *table)
+static void isis_route_delete(struct route_node *rode,
+			      struct route_table *table)
 {
-	struct route_node *rode;
 	struct isis_route_info *rinfo;
-	char buff[PREFIX2STR_BUFFER];
+	char buff[SRCDEST2STR_BUFFER];
+	struct prefix *prefix;
+	struct prefix_ipv6 *src_p;
 
 	/* for log */
-	prefix2str(prefix, buff, sizeof(buff));
+	srcdest_rnode2str(rode, buff, sizeof(buff));
 
+	srcdest_rnode_prefixes(rode, (const struct prefix **)&prefix,
+			       (const struct prefix **)&src_p);
 
-	rode = route_node_get(table, prefix);
 	rinfo = rode->info;
-
 	if (rinfo == NULL) {
 		if (isis->debugs & DEBUG_RTE_EVENTS)
 			zlog_debug(
@@ -403,29 +407,36 @@ static void isis_route_delete(struct pre
 		UNSET_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ACTIVE);
 		if (isis->debugs & DEBUG_RTE_EVENTS)
 			zlog_debug("ISIS-Rte: route delete  %s", buff);
-		isis_zebra_route_update(prefix, rinfo);
+		isis_zebra_route_update(prefix, src_p, rinfo);
 	}
 	isis_route_info_delete(rinfo);
 	rode->info = NULL;
-
-	return;
+	route_unlock_node(rode);
 }
 
-/* Validating routes in particular table. */
-static void isis_route_validate_table(struct isis_area *area,
-				      struct route_table *table)
+static void _isis_route_verify_table(struct isis_area *area,
+				     struct route_table *table,
+				     struct route_table **tables)
 {
 	struct route_node *rnode, *drnode;
 	struct isis_route_info *rinfo;
-	char buff[PREFIX2STR_BUFFER];
+	char buff[SRCDEST2STR_BUFFER];
 
-	for (rnode = route_top(table); rnode; rnode = route_next(rnode)) {
+	for (rnode = route_top(table); rnode;
+	     rnode = srcdest_route_next(rnode)) {
 		if (rnode->info == NULL)
 			continue;
 		rinfo = rnode->info;
 
+		struct prefix *dst_p;
+		struct prefix_ipv6 *src_p;
+
+		srcdest_rnode_prefixes(rnode,
+				       (const struct prefix **)&dst_p,
+				       (const struct prefix **)&src_p);
+
 		if (isis->debugs & DEBUG_RTE_EVENTS) {
-			prefix2str(&rnode->p, buff, sizeof(buff));
+			srcdest2str(dst_p, src_p, buff, sizeof(buff));
 			zlog_debug(
 				"ISIS-Rte (%s): route validate: %s %s %s %s",
 				area->area_tag,
@@ -443,50 +454,47 @@ static void isis_route_validate_table(st
 				buff);
 		}
 
-		isis_zebra_route_update(&rnode->p, rinfo);
-		if (!CHECK_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ACTIVE)) {
-			/* Area is either L1 or L2 => we use level route tables
-			 * directly for
-			 * validating => no problems with deleting routes. */
-			if (area->is_type != IS_LEVEL_1_AND_2) {
-				isis_route_delete(&rnode->p, table);
+		isis_zebra_route_update(dst_p, src_p, rinfo);
+
+		if (CHECK_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ACTIVE))
+			continue;
+
+		/* Area is either L1 or L2 => we use level route tables
+		 * directly for
+		 * validating => no problems with deleting routes. */
+		if (!tables) {
+			isis_route_delete(rnode, table);
+			continue;
+		}
+
+		/* If area is L1L2, we work with merge table and
+		 * therefore must
+		 * delete node from level tables as well before deleting
+		 * route info. */
+		for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+			drnode = srcdest_rnode_lookup(tables[level - 1],
+						      dst_p, src_p);
+			if (!drnode)
 				continue;
-			}
-			/* If area is L1L2, we work with merge table and
-			 * therefore must
-			 * delete node from level tables as well before deleting
-			 * route info.
-			 * FIXME: Is it performance problem? There has to be the
-			 * better way.
-			 * Like not to deal with it here at all (see the next
-			 * comment)? */
-			if (rnode->p.family == AF_INET) {
-				drnode = route_node_get(area->route_table[0],
-							&rnode->p);
-				if (drnode->info == rnode->info)
-					drnode->info = NULL;
-				drnode = route_node_get(area->route_table[1],
-							&rnode->p);
-				if (drnode->info == rnode->info)
-					drnode->info = NULL;
-			}
 
-			if (rnode->p.family == AF_INET6) {
-				drnode = route_node_get(area->route_table6[0],
-							&rnode->p);
-				if (drnode->info == rnode->info)
-					drnode->info = NULL;
-				drnode = route_node_get(area->route_table6[1],
-							&rnode->p);
-				if (drnode->info == rnode->info)
-					drnode->info = NULL;
-			}
+			route_unlock_node(drnode);
+
+			if (drnode->info != rnode->info)
+				continue;
 
-			isis_route_delete(&rnode->p, table);
+			drnode->info = NULL;
+			route_unlock_node(drnode);
 		}
+
+		isis_route_delete(rnode, table);
 	}
 }
 
+void isis_route_verify_table(struct isis_area *area, struct route_table *table)
+{
+	return _isis_route_verify_table(area, table, NULL);
+}
+
 /* Function to validate route tables for L1L2 areas. In this case we can't use
  * level route tables directly, we have to merge them at first. L1 routes are
  * preferred over the L2 ones.
@@ -497,87 +505,71 @@ static void isis_route_validate_table(st
  *
  * FIXME: Is it right place to do it at all? Maybe we should push both levels
  * to the RIB with different zebra route types and let RIB handle this? */
-static void isis_route_validate_merge(struct isis_area *area, int family)
+void isis_route_verify_merge(struct isis_area *area,
+			     struct route_table *level1_table,
+			     struct route_table *level2_table)
 {
-	struct route_table *table = NULL;
+	struct route_table *tables[] = { level1_table, level2_table };
 	struct route_table *merge;
 	struct route_node *rnode, *mrnode;
 
-	merge = route_table_init();
-
-	if (family == AF_INET)
-		table = area->route_table[0];
-	else if (family == AF_INET6)
-		table = area->route_table6[0];
-	else {
-		zlog_warn("ISIS-Rte (%s) %s called for unknown family %d",
-			  area->area_tag, __func__, family);
-		route_table_finish(merge);
-		return;
-	}
+	merge = srcdest_table_init();
 
-	for (rnode = route_top(table); rnode; rnode = route_next(rnode)) {
-		if (rnode->info == NULL)
-			continue;
-		mrnode = route_node_get(merge, &rnode->p);
-		mrnode->info = rnode->info;
-	}
+	for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+		for (rnode = route_top(tables[level - 1]); rnode;
+		     rnode = srcdest_route_next(rnode)) {
+			struct isis_route_info *rinfo = rnode->info;
+			if (!rinfo)
+				continue;
 
-	if (family == AF_INET)
-		table = area->route_table[1];
-	else if (family == AF_INET6)
-		table = area->route_table6[1];
+			struct prefix *prefix;
+			struct prefix_ipv6 *src_p;
 
-	for (rnode = route_top(table); rnode; rnode = route_next(rnode)) {
-		if (rnode->info == NULL)
-			continue;
-		mrnode = route_node_get(merge, &rnode->p);
-		if (mrnode->info != NULL)
-			continue;
-		mrnode->info = rnode->info;
+			srcdest_rnode_prefixes(rnode,
+					       (const struct prefix **)&prefix,
+					       (const struct prefix **)&src_p);
+			mrnode = srcdest_rnode_get(merge, prefix, src_p);
+			struct isis_route_info *mrinfo = mrnode->info;
+			if (mrinfo) {
+				route_unlock_node(mrnode);
+				if (CHECK_FLAG(mrinfo->flag,
+					       ISIS_ROUTE_FLAG_ACTIVE)) {
+					/* Clear the ZEBRA_SYNCED flag on the
+					 * L2 route when L1 wins, otherwise L2
+					 * won't get reinstalled when L1
+					 * disappears.
+					 */
+					UNSET_FLAG(
+						rinfo->flag,
+						ISIS_ROUTE_FLAG_ZEBRA_SYNCED
+					);
+					continue;
+				} else {
+					/* Clear the ZEBRA_SYNCED flag on the L1
+					 * route when L2 wins, otherwise L1
+					 * won't get reinstalled when it
+					 * reappears.
+					 */
+					UNSET_FLAG(
+						mrinfo->flag,
+						ISIS_ROUTE_FLAG_ZEBRA_SYNCED
+					);
+				}
+			}
+			mrnode->info = rnode->info;
+		}
 	}
 
-	isis_route_validate_table(area, merge);
+	_isis_route_verify_table(area, merge, tables);
 	route_table_finish(merge);
 }
 
-/* Walk through route tables and propagate necessary changes into RIB. In case
- * of L1L2 area, level tables have to be merged at first. */
-void isis_route_validate(struct isis_area *area)
-{
-	struct listnode *node;
-	struct isis_circuit *circuit;
-
-	if (area->is_type == IS_LEVEL_1)
-		isis_route_validate_table(area, area->route_table[0]);
-	else if (area->is_type == IS_LEVEL_2)
-		isis_route_validate_table(area, area->route_table[1]);
-	else
-		isis_route_validate_merge(area, AF_INET);
-
-	if (area->is_type == IS_LEVEL_1)
-		isis_route_validate_table(area, area->route_table6[0]);
-	else if (area->is_type == IS_LEVEL_2)
-		isis_route_validate_table(area, area->route_table6[1]);
-	else
-		isis_route_validate_merge(area, AF_INET6);
-
-	if (!area->circuit_list) {
-		return;
-	}
-	/* walk all circuits and reset any spf specific flags */
-	for (ALL_LIST_ELEMENTS_RO(area->circuit_list, node, circuit))
-		UNSET_FLAG(circuit->flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF);
-
-	return;
-}
-
 void isis_route_invalidate_table(struct isis_area *area,
 				 struct route_table *table)
 {
 	struct route_node *rode;
 	struct isis_route_info *rinfo;
-	for (rode = route_top(table); rode; rode = route_next(rode)) {
+	for (rode = route_top(table); rode; rode = srcdest_route_next(rode)) {
 		if (rode->info == NULL)
 			continue;
 		rinfo = rode->info;
@@ -585,11 +577,3 @@ void isis_route_invalidate_table(struct
 		UNSET_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ACTIVE);
 	}
 }
-
-void isis_route_invalidate(struct isis_area *area)
-{
-	if (area->is_type & IS_LEVEL_1)
-		isis_route_invalidate_table(area, area->route_table[0]);
-	if (area->is_type & IS_LEVEL_2)
-		isis_route_invalidate_table(area, area->route_table[1]);
-}
diff -urpN frr-frr-5.0.1/isisd/isis_route.h frr-frr-6.0/isisd/isis_route.h
--- frr-frr-5.0.1/isisd/isis_route.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_route.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,14 +50,26 @@ struct isis_route_info {
 	struct list *nexthops6;
 };
 
-struct isis_route_info *isis_route_create(struct prefix *prefix, uint32_t cost,
+struct isis_route_info *isis_route_create(struct prefix *prefix,
+					  struct prefix_ipv6 *src_p,
+					  uint32_t cost,
 					  uint32_t depth,
 					  struct list *adjacencies,
-					  struct isis_area *area, int level);
+					  struct isis_area *area,
+					  struct route_table *table);
 
-void isis_route_validate(struct isis_area *area);
+/* Walk the given table and install new routes to zebra and remove old ones.
+ * route status is tracked using ISIS_ROUTE_FLAG_ACTIVE */
+void isis_route_verify_table(struct isis_area *area,
+			     struct route_table *table);
+
+/* Same as isis_route_verify_table, but merge L1 and L2 routes before */
+void isis_route_verify_merge(struct isis_area *area,
+			     struct route_table *level1_table,
+			     struct route_table *level2_table);
+
+/* Unset ISIS_ROUTE_FLAG_ACTIVE on all routes. Used before running spf. */
 void isis_route_invalidate_table(struct isis_area *area,
 				 struct route_table *table);
-void isis_route_invalidate(struct isis_area *area);
 
 #endif /* _ZEBRA_ISIS_ROUTE_H */
diff -urpN frr-frr-5.0.1/isisd/isis_routemap.c frr-frr-6.0/isisd/isis_routemap.c
--- frr-frr-5.0.1/isisd/isis_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -50,7 +50,7 @@
 #include "isis_routemap.h"
 
 static route_map_result_t route_match_ip_address(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -83,7 +83,7 @@ static struct route_map_rule_cmd route_m
 /* ------------------------------------------------------------*/
 
 static route_map_result_t
-route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_address_prefix_list(void *rule, const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -116,7 +116,7 @@ struct route_map_rule_cmd route_match_ip
 /* ------------------------------------------------------------*/
 
 static route_map_result_t route_match_ipv6_address(void *rule,
-						   struct prefix *prefix,
+						   const struct prefix *prefix,
 						   route_map_object_t type,
 						   void *object)
 {
@@ -149,7 +149,7 @@ static struct route_map_rule_cmd route_m
 /* ------------------------------------------------------------*/
 
 static route_map_result_t
-route_match_ipv6_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ipv6_address_prefix_list(void *rule, const struct prefix *prefix,
 				     route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -181,7 +181,8 @@ struct route_map_rule_cmd route_match_ip
 
 /* ------------------------------------------------------------*/
 
-static route_map_result_t route_set_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_metric(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
diff -urpN frr-frr-5.0.1/isisd/isis_spf.c frr-frr-6.0/isisd/isis_spf.c
--- frr-frr-5.0.1/isisd/isis_spf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_spf.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,8 @@
 #include "spf_backoff.h"
 #include "jhash.h"
 #include "skiplist.h"
+#include "srcdest_table.h"
+#include "lib_errors.h"
 
 #include "isis_constants.h"
 #include "isis_common.h"
@@ -74,17 +76,21 @@ enum vertextype {
 #define VTYPE_ES(t) ((t) == VTYPE_ES)
 #define VTYPE_IP(t) ((t) >= VTYPE_IPREACH_INTERNAL && (t) <= VTYPE_IP6REACH_EXTERNAL)
 
+struct prefix_pair {
+	struct prefix dest;
+	struct prefix_ipv6 src;
+};
+
 /*
  * Triple <N, d(N), {Adj(N)}>
  */
+union isis_N {
+	uint8_t id[ISIS_SYS_ID_LEN + 1];
+	struct prefix_pair ip;
+};
 struct isis_vertex {
 	enum vertextype type;
-
-	union {
-		uint8_t id[ISIS_SYS_ID_LEN + 1];
-		struct prefix prefix;
-	} N;
-
+	union isis_N N;
 	uint32_t d_N;	  /* d(N) Distance from this IS      */
 	uint16_t depth;	/* The depth in the imaginary tree */
 	struct list *Adj_N;    /* {Adj(N)} next hop or neighbor list */
@@ -107,8 +113,13 @@ static unsigned isis_vertex_queue_hash_k
 {
 	struct isis_vertex *vertex = vp;
 
-	if (VTYPE_IP(vertex->type))
-		return prefix_hash_key(&vertex->N.prefix);
+	if (VTYPE_IP(vertex->type)) {
+		uint32_t key;
+
+		key = prefix_hash_key(&vertex->N.ip.dest);
+		key = jhash_1word(prefix_hash_key(&vertex->N.ip.src), key);
+		return key;
+	}
 
 	return jhash(vertex->N.id, ISIS_SYS_ID_LEN + 1, 0x55aa5a5a);
 }
@@ -120,8 +131,13 @@ static int isis_vertex_queue_hash_cmp(co
 	if (va->type != vb->type)
 		return 0;
 
-	if (VTYPE_IP(va->type))
-		return prefix_cmp(&va->N.prefix, &vb->N.prefix) == 0;
+	if (VTYPE_IP(va->type)) {
+		if (prefix_cmp(&va->N.ip.dest, &vb->N.ip.dest))
+			return 0;
+
+		return prefix_cmp((struct prefix *)&va->N.ip.src,
+				  (struct prefix *)&vb->N.ip.src) == 0;
+	}
 
 	return memcmp(va->N.id, vb->N.id, ISIS_SYS_ID_LEN + 1) == 0;
 }
@@ -276,6 +292,7 @@ static void isis_vertex_queue_delete(str
 struct isis_spftree {
 	struct isis_vertex_queue paths; /* the SPT */
 	struct isis_vertex_queue tents; /* TENT */
+	struct route_table *route_table;
 	struct isis_area *area;    /* back pointer to area */
 	unsigned int runcount;     /* number of runs since uptime */
 	time_t last_run_timestamp; /* last run timestamp as wall time for display */
@@ -285,6 +302,7 @@ struct isis_spftree {
 	uint16_t mtid;
 	int family;
 	int level;
+	enum spf_tree_id tree_id;
 };
 
 
@@ -393,6 +411,7 @@ static const char *vtype2string(enum ver
 	return NULL; /* Not reached */
 }
 
+#define VID2STR_BUFFER SRCDEST2STR_BUFFER
 static const char *vid2string(struct isis_vertex *vertex, char *buff, int size)
 {
 	if (VTYPE_IS(vertex->type) || VTYPE_ES(vertex->type)) {
@@ -400,35 +419,37 @@ static const char *vid2string(struct isi
 	}
 
 	if (VTYPE_IP(vertex->type)) {
-		prefix2str((struct prefix *)&vertex->N.prefix, buff, size);
+		srcdest2str(&vertex->N.ip.dest,
+			    &vertex->N.ip.src,
+			    buff, size);
 		return buff;
 	}
 
 	return "UNKNOWN";
 }
 
-static void isis_vertex_id_init(struct isis_vertex *vertex, void *id,
+static void isis_vertex_id_init(struct isis_vertex *vertex, union isis_N *n,
 				enum vertextype vtype)
 {
 	vertex->type = vtype;
 
 	if (VTYPE_IS(vtype) || VTYPE_ES(vtype)) {
-		memcpy(vertex->N.id, (uint8_t *)id, ISIS_SYS_ID_LEN + 1);
+		memcpy(vertex->N.id, n->id, ISIS_SYS_ID_LEN + 1);
 	} else if (VTYPE_IP(vtype)) {
-		memcpy(&vertex->N.prefix, (struct prefix *)id,
-		       sizeof(struct prefix));
+		memcpy(&vertex->N.ip, &n->ip, sizeof(n->ip));
 	} else {
-		zlog_err("WTF!");
+		flog_err(LIB_ERR_DEVELOPMENT, "Unknown Vertex Type");
 	}
 }
 
-static struct isis_vertex *isis_vertex_new(void *id, enum vertextype vtype)
+static struct isis_vertex *isis_vertex_new(union isis_N *n,
+					   enum vertextype vtype)
 {
 	struct isis_vertex *vertex;
 
 	vertex = XCALLOC(MTYPE_ISIS_VERTEX, sizeof(struct isis_vertex));
 
-	isis_vertex_id_init(vertex, id, vtype);
+	isis_vertex_id_init(vertex, n, vtype);
 
 	vertex->Adj_N = list_new();
 	vertex->parents = list_new();
@@ -466,13 +487,10 @@ struct isis_spftree *isis_spftree_new(st
 	struct isis_spftree *tree;
 
 	tree = XCALLOC(MTYPE_ISIS_SPFTREE, sizeof(struct isis_spftree));
-	if (tree == NULL) {
-		zlog_err("ISIS-Spf: isis_spftree_new Out of memory!");
-		return NULL;
-	}
 
 	isis_vertex_queue_init(&tree->tents, "IS-IS SPF tents", true);
 	isis_vertex_queue_init(&tree->paths, "IS-IS SPF paths", false);
+	tree->route_table = srcdest_table_init();
 	tree->area = area;
 	tree->last_run_timestamp = 0;
 	tree->last_run_monotime = 0;
@@ -485,8 +503,10 @@ void isis_spftree_del(struct isis_spftre
 {
 	isis_vertex_queue_free(&spftree->tents);
 	isis_vertex_queue_free(&spftree->paths);
-	XFREE(MTYPE_ISIS_SPFTREE, spftree);
+	route_table_finish(spftree->route_table);
+	spftree->route_table = NULL;
 
+	XFREE(MTYPE_ISIS_SPFTREE, spftree);
 	return;
 }
 
@@ -505,67 +525,44 @@ static void isis_spftree_adj_del(struct
 
 void spftree_area_init(struct isis_area *area)
 {
-	if (area->is_type & IS_LEVEL_1) {
-		if (area->spftree[0] == NULL)
-			area->spftree[0] = isis_spftree_new(area);
-		if (area->spftree6[0] == NULL)
-			area->spftree6[0] = isis_spftree_new(area);
-	}
+	for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+		for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+			if (!(area->is_type & level))
+				continue;
+			if (area->spftree[tree][level - 1])
+				continue;
 
-	if (area->is_type & IS_LEVEL_2) {
-		if (area->spftree[1] == NULL)
-			area->spftree[1] = isis_spftree_new(area);
-		if (area->spftree6[1] == NULL)
-			area->spftree6[1] = isis_spftree_new(area);
+			area->spftree[tree][level - 1] = isis_spftree_new(area);
+		}
 	}
-
-	return;
 }
 
 void spftree_area_del(struct isis_area *area)
 {
-	if (area->is_type & IS_LEVEL_1) {
-		if (area->spftree[0] != NULL) {
-			isis_spftree_del(area->spftree[0]);
-			area->spftree[0] = NULL;
-		}
-		if (area->spftree6[0]) {
-			isis_spftree_del(area->spftree6[0]);
-			area->spftree6[0] = NULL;
-		}
-	}
+	for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+		for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+			if (!(area->is_type & level))
+				continue;
+			if (!area->spftree[tree][level - 1])
+				continue;
 
-	if (area->is_type & IS_LEVEL_2) {
-		if (area->spftree[1] != NULL) {
-			isis_spftree_del(area->spftree[1]);
-			area->spftree[1] = NULL;
-		}
-		if (area->spftree6[1] != NULL) {
-			isis_spftree_del(area->spftree6[1]);
-			area->spftree6[1] = NULL;
+			isis_spftree_del(area->spftree[tree][level - 1]);
 		}
 	}
-
-	return;
 }
 
 void spftree_area_adj_del(struct isis_area *area, struct isis_adjacency *adj)
 {
-	if (area->is_type & IS_LEVEL_1) {
-		if (area->spftree[0] != NULL)
-			isis_spftree_adj_del(area->spftree[0], adj);
-		if (area->spftree6[0] != NULL)
-			isis_spftree_adj_del(area->spftree6[0], adj);
-	}
-
-	if (area->is_type & IS_LEVEL_2) {
-		if (area->spftree[1] != NULL)
-			isis_spftree_adj_del(area->spftree[1], adj);
-		if (area->spftree6[1] != NULL)
-			isis_spftree_adj_del(area->spftree6[1], adj);
+	for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+		for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+			if (!(area->is_type & level))
+				continue;
+			if (!area->spftree[tree][level - 1])
+				continue;
+			isis_spftree_adj_del(area->spftree[tree][level - 1],
+					     adj);
+		}
 	}
-
-	return;
 }
 
 /*
@@ -596,19 +593,19 @@ static struct isis_vertex *isis_spf_add_
 	struct isis_vertex *vertex;
 	struct isis_lsp *lsp;
 #ifdef EXTREME_DEBUG
-	char buff[PREFIX2STR_BUFFER];
+	char buff[VID2STR_BUFFER];
 #endif /* EXTREME_DEBUG */
-	uint8_t id[ISIS_SYS_ID_LEN + 1];
+	union isis_N n;
 
-	memcpy(id, sysid, ISIS_SYS_ID_LEN);
-	LSP_PSEUDO_ID(id) = 0;
+	memcpy(n.id, sysid, ISIS_SYS_ID_LEN);
+	LSP_PSEUDO_ID(n.id) = 0;
 
 	lsp = isis_root_system_lsp(spftree->area, spftree->level, sysid);
 	if (lsp == NULL)
 		zlog_warn("ISIS-Spf: could not find own l%d LSP!",
 			  spftree->level);
 
-	vertex = isis_vertex_new(id,
+	vertex = isis_vertex_new(&n,
 				 spftree->area->oldmetric
 					 ? VTYPE_NONPSEUDO_IS
 					 : VTYPE_NONPSEUDO_TE_IS);
@@ -625,11 +622,12 @@ static struct isis_vertex *isis_spf_add_
 }
 
 static struct isis_vertex *isis_find_vertex(struct isis_vertex_queue *queue,
-					    void *id, enum vertextype vtype)
+					    union isis_N *n,
+					    enum vertextype vtype)
 {
 	struct isis_vertex querier;
 
-	isis_vertex_id_init(&querier, id, vtype);
+	isis_vertex_id_init(&querier, n, vtype);
 	return hash_lookup(queue->hash, &querier);
 }
 
@@ -646,7 +644,7 @@ static struct isis_vertex *isis_spf_add2
 	struct listnode *node;
 	struct isis_adjacency *parent_adj;
 #ifdef EXTREME_DEBUG
-	char buff[PREFIX2STR_BUFFER];
+	char buff[VID2STR_BUFFER];
 #endif
 
 	assert(isis_find_vertex(&spftree->paths, id, vtype) == NULL);
@@ -719,15 +717,16 @@ static void process_N(struct isis_spftre
 {
 	struct isis_vertex *vertex;
 #ifdef EXTREME_DEBUG
-	char buff[PREFIX2STR_BUFFER];
+	char buff[VID2STR_BUFFER];
 #endif
 
 	assert(spftree && parent);
 
-	struct prefix p;
+	struct prefix_pair p;
 	if (vtype >= VTYPE_IPREACH_INTERNAL) {
-		prefix_copy(&p, id);
-		apply_mask(&p);
+		memcpy(&p, id, sizeof(p));
+		apply_mask(&p.dest);
+		apply_mask((struct prefix *)&p.src);
 		id = &p;
 	}
 
@@ -814,6 +813,7 @@ static int isis_spf_process_lsp(struct i
 	enum vertextype vtype;
 	static const uint8_t null_sysid[ISIS_SYS_ID_LEN];
 	struct isis_mt_router_info *mt_router_info = NULL;
+	struct prefix_pair ip_info;
 
 	if (!lsp->tlvs)
 		return ISIS_OK;
@@ -907,12 +907,17 @@ lspfragloop:
 			vtype = i ? VTYPE_IPREACH_EXTERNAL
 				  : VTYPE_IPREACH_INTERNAL;
 
+			memset(&ip_info, 0, sizeof(ip_info));
+			ip_info.dest.family = AF_INET;
+
 			struct isis_oldstyle_ip_reach *r;
 			for (r = (struct isis_oldstyle_ip_reach *)reachs[i]
 					 ->head;
 			     r; r = r->next) {
 				dist = cost + r->metric;
-				process_N(spftree, vtype, (void *)&r->prefix,
+				ip_info.dest.u.prefix4 = r->prefix.prefix;
+				ip_info.dest.prefixlen = r->prefix.prefixlen;
+				process_N(spftree, vtype, &ip_info,
 					  dist, depth + 1, parent);
 			}
 		}
@@ -926,6 +931,9 @@ lspfragloop:
 			ipv4_reachs = isis_lookup_mt_items(
 				&lsp->tlvs->mt_ip_reach, spftree->mtid);
 
+		memset(&ip_info, 0, sizeof(ip_info));
+		ip_info.dest.family = AF_INET;
+
 		struct isis_extended_ip_reach *r;
 		for (r = ipv4_reachs
 				 ? (struct isis_extended_ip_reach *)
@@ -933,7 +941,9 @@ lspfragloop:
 				 : NULL;
 		     r; r = r->next) {
 			dist = cost + r->metric;
-			process_N(spftree, VTYPE_IPREACH_TE, (void *)&r->prefix,
+			ip_info.dest.u.prefix4 = r->prefix.prefix;
+			ip_info.dest.prefixlen = r->prefix.prefixlen;
+			process_N(spftree, VTYPE_IPREACH_TE, &ip_info,
 				  dist, depth + 1, parent);
 		}
 	}
@@ -954,7 +964,28 @@ lspfragloop:
 			dist = cost + r->metric;
 			vtype = r->external ? VTYPE_IP6REACH_EXTERNAL
 					    : VTYPE_IP6REACH_INTERNAL;
-			process_N(spftree, vtype, (void *)&r->prefix, dist,
+			memset(&ip_info, 0, sizeof(ip_info));
+			ip_info.dest.family = AF_INET6;
+			ip_info.dest.u.prefix6 = r->prefix.prefix;
+			ip_info.dest.prefixlen = r->prefix.prefixlen;
+
+			if (r->subtlvs
+			    && r->subtlvs->source_prefix
+			    && r->subtlvs->source_prefix->prefixlen) {
+				if (spftree->tree_id != SPFTREE_DSTSRC) {
+					char buff[VID2STR_BUFFER];
+					zlog_warn("Ignoring dest-src route %s in non dest-src topology",
+						srcdest2str(
+							&ip_info.dest,
+							r->subtlvs->source_prefix,
+							buff, sizeof(buff)
+						)
+					);
+					continue;
+				}
+				ip_info.src = *r->subtlvs->source_prefix;
+			}
+			process_N(spftree, vtype, &ip_info, dist,
 				  depth + 1, parent);
 		}
 	}
@@ -983,7 +1014,7 @@ static int isis_spf_preload_tent(struct
 	struct list *adj_list;
 	struct list *adjdb;
 	struct prefix_ipv4 *ipv4;
-	struct prefix prefix;
+	struct prefix_pair ip_info;
 	int retval = ISIS_OK;
 	uint8_t lsp_id[ISIS_SYS_ID_LEN + 2];
 	static uint8_t null_lsp_id[ISIS_SYS_ID_LEN + 2];
@@ -1007,27 +1038,29 @@ static int isis_spf_preload_tent(struct
 		 * Add IP(v6) addresses of this circuit
 		 */
 		if (spftree->family == AF_INET) {
-			prefix.family = AF_INET;
+			memset(&ip_info, 0, sizeof(ip_info));
+			ip_info.dest.family = AF_INET;
 			for (ALL_LIST_ELEMENTS_RO(circuit->ip_addrs, ipnode,
 						  ipv4)) {
-				prefix.u.prefix4 = ipv4->prefix;
-				prefix.prefixlen = ipv4->prefixlen;
-				apply_mask(&prefix);
+				ip_info.dest.u.prefix4 = ipv4->prefix;
+				ip_info.dest.prefixlen = ipv4->prefixlen;
+				apply_mask(&ip_info.dest);
 				isis_spf_add_local(spftree,
 						   VTYPE_IPREACH_INTERNAL,
-						   &prefix, NULL, 0, parent);
+						   &ip_info, NULL, 0, parent);
 			}
 		}
 		if (spftree->family == AF_INET6) {
-			prefix.family = AF_INET6;
+			memset(&ip_info, 0, sizeof(ip_info));
+			ip_info.dest.family = AF_INET6;
 			for (ALL_LIST_ELEMENTS_RO(circuit->ipv6_non_link,
 						  ipnode, ipv6)) {
-				prefix.prefixlen = ipv6->prefixlen;
-				prefix.u.prefix6 = ipv6->prefix;
-				apply_mask(&prefix);
+				ip_info.dest.u.prefix6 = ipv6->prefix;
+				ip_info.dest.prefixlen = ipv6->prefixlen;
+				apply_mask(&ip_info.dest);
 				isis_spf_add_local(spftree,
 						   VTYPE_IP6REACH_INTERNAL,
-						   &prefix, NULL, 0, parent);
+						   &ip_info, NULL, 0, parent);
 			}
 		}
 		if (circuit->circ_type == CIRCUIT_T_BROADCAST) {
@@ -1210,9 +1243,9 @@ static int isis_spf_preload_tent(struct
 static void add_to_paths(struct isis_spftree *spftree,
 			 struct isis_vertex *vertex)
 {
-	char buff[PREFIX2STR_BUFFER];
+	char buff[VID2STR_BUFFER];
 
-	if (isis_find_vertex(&spftree->paths, vertex->N.id, vertex->type))
+	if (isis_find_vertex(&spftree->paths, &vertex->N, vertex->type))
 		return;
 	isis_vertex_queue_append(&spftree->paths, vertex);
 
@@ -1225,10 +1258,11 @@ static void add_to_paths(struct isis_spf
 
 	if (VTYPE_IP(vertex->type)) {
 		if (listcount(vertex->Adj_N) > 0)
-			isis_route_create((struct prefix *)&vertex->N.prefix,
+			isis_route_create(&vertex->N.ip.dest,
+					  &vertex->N.ip.src,
 					  vertex->d_N, vertex->depth,
 					  vertex->Adj_N, spftree->area,
-					  spftree->level);
+					  spftree->route_table);
 		else if (isis->debugs & DEBUG_SPF_EVENTS)
 			zlog_debug(
 				"ISIS-Spf: no adjacencies do not install route for "
@@ -1241,7 +1275,7 @@ static void add_to_paths(struct isis_spf
 }
 
 static void init_spt(struct isis_spftree *spftree, int mtid, int level,
-		     int family)
+		     int family, enum spf_tree_id tree_id)
 {
 	isis_vertex_queue_clear(&spftree->tents);
 	isis_vertex_queue_clear(&spftree->paths);
@@ -1249,53 +1283,54 @@ static void init_spt(struct isis_spftree
 	spftree->mtid = mtid;
 	spftree->level = level;
 	spftree->family = family;
+	spftree->tree_id = tree_id;
 	return;
 }
 
-static int isis_run_spf(struct isis_area *area, int level, int family,
+static int isis_run_spf(struct isis_area *area, int level,
+			enum spf_tree_id tree_id,
 			uint8_t *sysid, struct timeval *nowtv)
 {
 	int retval = ISIS_OK;
 	struct isis_vertex *vertex;
 	struct isis_vertex *root_vertex;
-	struct isis_spftree *spftree = NULL;
+	struct isis_spftree *spftree = area->spftree[tree_id][level - 1];
 	uint8_t lsp_id[ISIS_SYS_ID_LEN + 2];
 	struct isis_lsp *lsp;
-	struct route_table *table = NULL;
 	struct timeval time_now;
 	unsigned long long start_time, end_time;
-	uint16_t mtid;
+	uint16_t mtid = 0;
 
 	/* Get time that can't roll backwards. */
 	start_time = nowtv->tv_sec;
 	start_time = (start_time * 1000000) + nowtv->tv_usec;
 
-	if (family == AF_INET)
-		spftree = area->spftree[level - 1];
-	else if (family == AF_INET6)
-		spftree = area->spftree6[level - 1];
+	int family = -1;
+	switch (tree_id) {
+	case SPFTREE_IPV4:
+		family = AF_INET;
+		mtid = ISIS_MT_IPV4_UNICAST;
+		break;
+	case SPFTREE_IPV6:
+		family = AF_INET6;
+		mtid = isis_area_ipv6_topology(area);
+		break;
+	case SPFTREE_DSTSRC:
+		family = AF_INET6;
+		mtid = ISIS_MT_IPV6_DSTSRC;
+		break;
+	case SPFTREE_COUNT:
+		assert(!"isis_run_spf should never be called with SPFTREE_COUNT as argument!");
+		return ISIS_WARNING;
+	}
+
 	assert(spftree);
 	assert(sysid);
 
-	/* Make all routes in current route table inactive. */
-	if (family == AF_INET)
-		table = area->route_table[level - 1];
-	else if (family == AF_INET6)
-		table = area->route_table6[level - 1];
-
-	isis_route_invalidate_table(area, table);
-
-	/* We only support ipv4-unicast and ipv6-unicast as topologies for now
-	 */
-	if (family == AF_INET6)
-		mtid = isis_area_ipv6_topology(area);
-	else
-		mtid = ISIS_MT_IPV4_UNICAST;
-
 	/*
 	 * C.2.5 Step 0
 	 */
-	init_spt(spftree, mtid, level, family);
+	init_spt(spftree, mtid, level, family, tree_id);
 	/*              a) */
 	root_vertex = isis_spf_add_root(spftree, sysid);
 	/*              b) */
@@ -1342,7 +1377,6 @@ static int isis_run_spf(struct isis_area
 	}
 
 out:
-	isis_route_validate(area);
 	spftree->runcount++;
 	spftree->last_run_timestamp = time(NULL);
 	spftree->last_run_monotime = monotime(&time_now);
@@ -1353,6 +1387,23 @@ out:
 	return retval;
 }
 
+void isis_spf_verify_routes(struct isis_area *area, struct isis_spftree **trees)
+{
+	if (area->is_type == IS_LEVEL_1) {
+		isis_route_verify_table(area, trees[0]->route_table);
+	} else if (area->is_type == IS_LEVEL_2) {
+		isis_route_verify_table(area, trees[1]->route_table);
+	} else {
+		isis_route_verify_merge(area, trees[0]->route_table,
+					trees[1]->route_table);
+	}
+}
+
+void isis_spf_invalidate_routes(struct isis_spftree *tree)
+{
+	isis_route_invalidate_table(tree->area, tree->route_table);
+}
+
 static int isis_run_spf_cb(struct thread *thread)
 {
 	struct isis_spf_run *run = THREAD_ARG(thread);
@@ -1370,16 +1421,30 @@ static int isis_run_spf_cb(struct thread
 		return ISIS_WARNING;
 	}
 
+	isis_area_invalidate_routes(area, level);
+
 	if (isis->debugs & DEBUG_SPF_EVENTS)
 		zlog_debug("ISIS-Spf (%s) L%d SPF needed, periodic SPF",
 			   area->area_tag, level);
 
 	if (area->ip_circuits)
-		retval = isis_run_spf(area, level, AF_INET, isis->sysid,
+		retval = isis_run_spf(area, level, SPFTREE_IPV4, isis->sysid,
 				      &thread->real);
 	if (area->ipv6_circuits)
-		retval = isis_run_spf(area, level, AF_INET6, isis->sysid,
+		retval = isis_run_spf(area, level, SPFTREE_IPV6, isis->sysid,
 				      &thread->real);
+	if (area->ipv6_circuits
+	    && isis_area_ipv6_dstsrc_enabled(area))
+		retval = isis_run_spf(area, level, SPFTREE_DSTSRC, isis->sysid,
+				      &thread->real);
+
+	isis_area_verify_routes(area);
+
+	/* walk all circuits and reset any spf specific flags */
+	struct listnode *node;
+	struct isis_circuit *circuit;
+	for (ALL_LIST_ELEMENTS_RO(area->circuit_list, node, circuit))
+		UNSET_FLAG(circuit->flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF);
 
 	return retval;
 }
@@ -1396,7 +1461,7 @@ static struct isis_spf_run *isis_run_spf
 
 int isis_spf_schedule(struct isis_area *area, int level)
 {
-	struct isis_spftree *spftree = area->spftree[level - 1];
+	struct isis_spftree *spftree = area->spftree[SPFTREE_IPV4][level - 1];
 	time_t now = monotime(NULL);
 	int diff = now - spftree->last_run_monotime;
 
@@ -1451,7 +1516,7 @@ static void isis_print_paths(struct vty
 {
 	struct listnode *node;
 	struct isis_vertex *vertex;
-	char buff[PREFIX2STR_BUFFER];
+	char buff[VID2STR_BUFFER];
 
 	vty_out(vty,
 		"Vertex               Type         Metric Next-Hop             Interface Parent\n");
@@ -1473,8 +1538,9 @@ static void isis_print_paths(struct vty
 		vty_out(vty, "%-20s %-12s %-6u ",
 			vid2string(vertex, buff, sizeof(buff)),
 			vtype2string(vertex->type), vertex->d_N);
-		for (unsigned int i = 0; i < MAX(listcount(vertex->Adj_N),
-						 listcount(vertex->parents));
+		for (unsigned int i = 0;
+		     i < MAX(vertex->Adj_N ? listcount(vertex->Adj_N) : 0,
+			     vertex->parents ? listcount(vertex->parents) : 0);
 		     i++) {
 			if (anode) {
 				adj = listgetdata(anode);
@@ -1516,6 +1582,39 @@ static void isis_print_paths(struct vty
 	}
 }
 
+static void isis_print_spftree(struct vty *vty, int level,
+			       struct isis_area *area,
+			       enum spf_tree_id tree_id)
+{
+	const char *tree_id_text = NULL;
+
+	switch (tree_id) {
+	case SPFTREE_IPV4:
+		tree_id_text = "that speak IP";
+		break;
+	case SPFTREE_IPV6:
+		tree_id_text = "that speak IPv6";
+		break;
+	case SPFTREE_DSTSRC:
+		tree_id_text = "that support IPv6 dst-src routing";
+		break;
+	case SPFTREE_COUNT:
+		assert(!"isis_print_spftree shouldn't be called with SPFTREE_COUNT as type");
+		return;
+	}
+
+	if (!area->spftree[tree_id][level - 1]
+	    || !isis_vertex_queue_count(
+		    &area->spftree[tree_id][level - 1]->paths))
+		return;
+
+	vty_out(vty, "IS-IS paths to level-%d routers %s\n",
+		level, tree_id_text);
+	isis_print_paths(vty, &area->spftree[tree_id][level - 1]->paths,
+			 isis->sysid);
+	vty_out(vty, "\n");
+}
+
 DEFUN (show_isis_topology,
        show_isis_topology_cmd,
        "show isis topology [<level-1|level-2>]",
@@ -1547,25 +1646,17 @@ DEFUN (show_isis_topology,
 			if ((level & levels) == 0)
 				continue;
 
-			if (area->ip_circuits > 0 && area->spftree[level - 1]
-			    && isis_vertex_queue_count(&area->spftree[level - 1]->paths) > 0) {
-				vty_out(vty,
-					"IS-IS paths to level-%d routers that speak IP\n",
-					level);
-				isis_print_paths(
-					vty, &area->spftree[level - 1]->paths,
-					isis->sysid);
-				vty_out(vty, "\n");
+			if (area->ip_circuits > 0) {
+				isis_print_spftree(vty, level, area,
+						   SPFTREE_IPV4);
 			}
-			if (area->ipv6_circuits > 0 && area->spftree6[level - 1]
-			    && isis_vertex_queue_count(&area->spftree6[level - 1]->paths) > 0) {
-				vty_out(vty,
-					"IS-IS paths to level-%d routers that speak IPv6\n",
-					level);
-				isis_print_paths(
-					vty, &area->spftree6[level - 1]->paths,
-					isis->sysid);
-				vty_out(vty, "\n");
+			if (area->ipv6_circuits > 0) {
+				isis_print_spftree(vty, level, area,
+						   SPFTREE_IPV6);
+			}
+			if (isis_area_ipv6_dstsrc_enabled(area)) {
+				isis_print_spftree(vty, level, area,
+						   SPFTREE_DSTSRC);
 			}
 		}
 
diff -urpN frr-frr-5.0.1/isisd/isis_spf.h frr-frr-6.0/isisd/isis_spf.h
--- frr-frr-5.0.1/isisd/isis_spf.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_spf.h	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,9 @@
 struct isis_spftree;
 
 struct isis_spftree *isis_spftree_new(struct isis_area *area);
+void isis_spf_invalidate_routes(struct isis_spftree *tree);
+void isis_spf_verify_routes(struct isis_area *area,
+			    struct isis_spftree **trees);
 void isis_spftree_del(struct isis_spftree *spftree);
 void spftree_area_init(struct isis_area *area);
 void spftree_area_del(struct isis_area *area);
diff -urpN frr-frr-5.0.1/isisd/isis_te.c frr-frr-6.0/isisd/isis_te.c
--- frr-frr-5.0.1/isisd/isis_te.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_te.c	2018-10-08 14:32:57.000000000 +0200
@@ -87,9 +87,6 @@ struct mpls_te_circuit *mpls_te_circuit_
 
 	mtc = XCALLOC(MTYPE_ISIS_MPLS_TE, sizeof(struct mpls_te_circuit));
 
-	if (mtc == NULL)
-		return NULL;
-
 	mtc->status = disable;
 	mtc->type = STD_TE;
 	mtc->length = 0;
@@ -884,7 +881,7 @@ static uint8_t print_subtlv_use_bw(struc
 static uint8_t print_unknown_tlv(struct sbuf *buf, int indent,
 				 struct subtlv_header *tlvh)
 {
-	int i, rtn = 1;
+	int i, rtn;
 	uint8_t *v = (uint8_t *)tlvh;
 
 	if (tlvh->length != 0) {
diff -urpN frr-frr-5.0.1/isisd/isis_tlvs.c frr-frr-6.0/isisd/isis_tlvs.c
--- frr-frr-5.0.1/isisd/isis_tlvs.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_tlvs.c	2018-10-08 14:32:57.000000000 +0200
@@ -1912,6 +1912,11 @@ static void append_item(struct isis_item
 	dest->count++;
 }
 
+static struct isis_item *last_item(struct isis_item_list *list)
+{
+	return container_of(list->tail, struct isis_item, next);
+}
+
 static int unpack_item(uint16_t mtid, enum isis_tlv_context context,
 		       uint8_t tlv_type, uint8_t len, struct stream *s,
 		       struct sbuf *log, void *dest, int indent)
@@ -3168,6 +3173,21 @@ void isis_tlvs_add_ipv6_reach(struct isi
 	append_item(l, (struct isis_item *)r);
 }
 
+void isis_tlvs_add_ipv6_dstsrc_reach(struct isis_tlvs *tlvs, uint16_t mtid,
+				     struct prefix_ipv6 *dest,
+				     struct prefix_ipv6 *src,
+				     uint32_t metric)
+{
+	isis_tlvs_add_ipv6_reach(tlvs, mtid, dest, metric);
+	struct isis_item_list *l = isis_get_mt_items(&tlvs->mt_ipv6_reach,
+						     mtid);
+
+	struct isis_ipv6_reach *r = (struct isis_ipv6_reach*)last_item(l);
+	r->subtlvs = isis_alloc_subtlvs();
+	r->subtlvs->source_prefix = XCALLOC(MTYPE_ISIS_SUBTLV, sizeof(*src));
+	memcpy(r->subtlvs->source_prefix, src, sizeof(*src));
+}
+
 void isis_tlvs_add_oldstyle_reach(struct isis_tlvs *tlvs, uint8_t *id,
 				  uint8_t metric)
 {
diff -urpN frr-frr-5.0.1/isisd/isis_tlvs.h frr-frr-6.0/isisd/isis_tlvs.h
--- frr-frr-5.0.1/isisd/isis_tlvs.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_tlvs.h	2018-10-08 14:32:57.000000000 +0200
@@ -313,6 +313,10 @@ void isis_tlvs_add_extended_ip_reach(str
 				     struct prefix_ipv4 *dest, uint32_t metric);
 void isis_tlvs_add_ipv6_reach(struct isis_tlvs *tlvs, uint16_t mtid,
 			      struct prefix_ipv6 *dest, uint32_t metric);
+void isis_tlvs_add_ipv6_dstsrc_reach(struct isis_tlvs *tlvs, uint16_t mtid,
+				     struct prefix_ipv6 *dest,
+				     struct prefix_ipv6 *src,
+				     uint32_t metric);
 void isis_tlvs_add_oldstyle_reach(struct isis_tlvs *tlvs, uint8_t *id,
 				  uint8_t metric);
 void isis_tlvs_add_extended_reach(struct isis_tlvs *tlvs, uint16_t mtid,
diff -urpN frr-frr-5.0.1/isisd/isis_zebra.c frr-frr-6.0/isisd/isis_zebra.c
--- frr-frr-5.0.1/isisd/isis_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -247,6 +247,7 @@ static int isis_zebra_link_params(int co
 }
 
 static void isis_zebra_route_add_route(struct prefix *prefix,
+				       struct prefix_ipv6 *src_p,
 				       struct isis_route_info *route_info)
 {
 	struct zapi_route api;
@@ -264,6 +265,10 @@ static void isis_zebra_route_add_route(s
 	api.type = ZEBRA_ROUTE_ISIS;
 	api.safi = SAFI_UNICAST;
 	api.prefix = *prefix;
+	if (src_p && src_p->prefixlen) {
+		api.src_prefix = *src_p;
+		SET_FLAG(api.message, ZAPI_MESSAGE_SRCPFX);
+	}
 	SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);
 	SET_FLAG(api.message, ZAPI_MESSAGE_METRIC);
 	api.metric = route_info->cost;
@@ -322,6 +327,7 @@ static void isis_zebra_route_add_route(s
 }
 
 static void isis_zebra_route_del_route(struct prefix *prefix,
+				       struct prefix_ipv6 *src_p,
 				       struct isis_route_info *route_info)
 {
 	struct zapi_route api;
@@ -334,21 +340,26 @@ static void isis_zebra_route_del_route(s
 	api.type = ZEBRA_ROUTE_ISIS;
 	api.safi = SAFI_UNICAST;
 	api.prefix = *prefix;
+	if (src_p && src_p->prefixlen) {
+		api.src_prefix = *src_p;
+		SET_FLAG(api.message, ZAPI_MESSAGE_SRCPFX);
+	}
 
 	zclient_route_send(ZEBRA_ROUTE_DELETE, zclient, &api);
 	UNSET_FLAG(route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);
 }
 
 void isis_zebra_route_update(struct prefix *prefix,
+			     struct prefix_ipv6 *src_p,
 			     struct isis_route_info *route_info)
 {
 	if (zclient->sock < 0)
 		return;
 
 	if (CHECK_FLAG(route_info->flag, ISIS_ROUTE_FLAG_ACTIVE))
-		isis_zebra_route_add_route(prefix, route_info);
+		isis_zebra_route_add_route(prefix, src_p, route_info);
 	else
-		isis_zebra_route_del_route(prefix, route_info);
+		isis_zebra_route_del_route(prefix, src_p, route_info);
 }
 
 static int isis_zebra_read(int command, struct zclient *zclient,
@@ -359,24 +370,23 @@ static int isis_zebra_read(int command,
 	if (zapi_route_decode(zclient->ibuf, &api) < 0)
 		return -1;
 
-	/* we completely ignore srcdest routes for now. */
-	if (CHECK_FLAG(api.message, ZAPI_MESSAGE_SRCPFX))
-		return 0;
-
 	/*
 	 * Avoid advertising a false default reachability. (A default
 	 * route installed by IS-IS gets redistributed from zebra back
 	 * into IS-IS causing us to start advertising default reachabity
 	 * without this check)
 	 */
-	if (api.prefix.prefixlen == 0 && api.type == ZEBRA_ROUTE_ISIS)
+	if (api.prefix.prefixlen == 0
+	    && api.src_prefix.prefixlen == 0
+	    && api.type == ZEBRA_ROUTE_ISIS) {
 		command = ZEBRA_REDISTRIBUTE_ROUTE_DEL;
+	}
 
 	if (command == ZEBRA_REDISTRIBUTE_ROUTE_ADD)
-		isis_redist_add(api.type, &api.prefix, api.distance,
-				api.metric);
+		isis_redist_add(api.type, &api.prefix, &api.src_prefix,
+				api.distance, api.metric);
 	else
-		isis_redist_delete(api.type, &api.prefix);
+		isis_redist_delete(api.type, &api.prefix, &api.src_prefix);
 
 	return 0;
 }
diff -urpN frr-frr-5.0.1/isisd/isis_zebra.h frr-frr-6.0/isisd/isis_zebra.h
--- frr-frr-5.0.1/isisd/isis_zebra.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isis_zebra.h	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@ void isis_zebra_init(struct thread_maste
 void isis_zebra_stop(void);
 
 void isis_zebra_route_update(struct prefix *prefix,
+			     struct prefix_ipv6 *src_p,
 			     struct isis_route_info *route_info);
 int isis_distribute_list_update(int routetype);
 void isis_zebra_redistribute_set(afi_t afi, int type);
diff -urpN frr-frr-5.0.1/isisd/isisd.c frr-frr-6.0/isisd/isisd.c
--- frr-frr-5.0.1/isisd/isisd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isisd.c	2018-10-08 14:32:57.000000000 +0200
@@ -118,13 +118,9 @@ struct isis_area *isis_area_create(const
 	 */
 	if (area->is_type & IS_LEVEL_1) {
 		area->lspdb[0] = lsp_db_init();
-		area->route_table[0] = route_table_init();
-		area->route_table6[0] = route_table_init();
 	}
 	if (area->is_type & IS_LEVEL_2) {
 		area->lspdb[1] = lsp_db_init();
-		area->route_table[1] = route_table_init();
-		area->route_table6[1] = route_table_init();
 	}
 
 	spftree_area_init(area);
@@ -232,6 +228,10 @@ int isis_area_destroy(struct vty *vty, c
 		area->lspdb[1] = NULL;
 	}
 
+	/* invalidate and verify to delete all routes from zebra */
+	isis_area_invalidate_routes(area, ISIS_LEVEL1 & ISIS_LEVEL2);
+	isis_area_verify_routes(area);
+
 	spftree_area_del(area);
 
 	THREAD_TIMER_OFF(area->spf_timer[0]);
@@ -240,27 +240,6 @@ int isis_area_destroy(struct vty *vty, c
 	spf_backoff_free(area->spf_delay_ietf[0]);
 	spf_backoff_free(area->spf_delay_ietf[1]);
 
-	/* invalidate and validate would delete all routes from zebra */
-	isis_route_invalidate(area);
-	isis_route_validate(area);
-
-	if (area->route_table[0]) {
-		route_table_finish(area->route_table[0]);
-		area->route_table[0] = NULL;
-	}
-	if (area->route_table[1]) {
-		route_table_finish(area->route_table[1]);
-		area->route_table[1] = NULL;
-	}
-	if (area->route_table6[0]) {
-		route_table_finish(area->route_table6[0]);
-		area->route_table6[0] = NULL;
-	}
-	if (area->route_table6[1]) {
-		route_table_finish(area->route_table6[1]);
-		area->route_table6[1] = NULL;
-	}
-
 	isis_redist_area_finish(area);
 
 	for (ALL_LIST_ELEMENTS(area->area_addrs, node, nnode, addr)) {
@@ -1340,10 +1319,16 @@ DEFUN (show_isis_summary,
 			vty_out(vty, "\n");
 
 			vty_out(vty, "    IPv4 route computation:\n");
-			isis_spf_print(area->spftree[level - 1], vty);
+			isis_spf_print(area->spftree[SPFTREE_IPV4][level - 1],
+				       vty);
 
 			vty_out(vty, "    IPv6 route computation:\n");
-			isis_spf_print(area->spftree6[level - 1], vty);
+			isis_spf_print(area->spftree[SPFTREE_IPV6][level - 1],
+				       vty);
+
+			vty_out(vty, "    IPv6 dst-src route computation:\n");
+			isis_spf_print(area->spftree[SPFTREE_DSTSRC][level-1],
+				       vty);
 		}
 	}
 	vty_out(vty, "\n");
@@ -1373,7 +1358,7 @@ static int show_isis_database(struct vty
 	struct isis_area *area;
 	struct isis_lsp *lsp;
 	struct isis_dynhn *dynhn;
-	const char *pos = argv;
+	const char *pos;
 	uint8_t lspid[ISIS_SYS_ID_LEN + 2];
 	char sysid[255];
 	uint8_t number[3];
@@ -1680,29 +1665,42 @@ int isis_area_passwd_hmac_md5_set(struct
 				    passwd, snp_auth);
 }
 
+void isis_area_invalidate_routes(struct isis_area *area, int levels)
+{
+	for (int level = ISIS_LEVEL1; level <= ISIS_LEVEL2; level++) {
+		if (!(level & levels))
+			continue;
+		for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+			isis_spf_invalidate_routes(
+					area->spftree[tree][level - 1]);
+		}
+	}
+}
+
+void isis_area_verify_routes(struct isis_area *area)
+{
+	for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++)
+		isis_spf_verify_routes(area, area->spftree[tree]);
+}
+
 static void area_resign_level(struct isis_area *area, int level)
 {
+	isis_area_invalidate_routes(area, level);
+	isis_area_verify_routes(area);
+
 	if (area->lspdb[level - 1]) {
 		lsp_db_destroy(area->lspdb[level - 1]);
 		area->lspdb[level - 1] = NULL;
 	}
-	if (area->spftree[level - 1]) {
-		isis_spftree_del(area->spftree[level - 1]);
-		area->spftree[level - 1] = NULL;
-	}
-	if (area->spftree6[level - 1]) {
-		isis_spftree_del(area->spftree6[level - 1]);
-		area->spftree6[level - 1] = NULL;
+
+	for (int tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+		if (area->spftree[tree][level - 1]) {
+			isis_spftree_del(area->spftree[tree][level - 1]);
+			area->spftree[tree][level - 1] = NULL;
+		}
 	}
+
 	THREAD_TIMER_OFF(area->spf_timer[level - 1]);
-	if (area->route_table[level - 1]) {
-		route_table_finish(area->route_table[level - 1]);
-		area->route_table[level - 1] = NULL;
-	}
-	if (area->route_table6[level - 1]) {
-		route_table_finish(area->route_table6[level - 1]);
-		area->route_table6[level - 1] = NULL;
-	}
 
 	sched_debug(
 		"ISIS (%s): Resigned from L%d - canceling LSP regeneration timer.",
@@ -1731,10 +1729,6 @@ void isis_area_is_type_set(struct isis_a
 
 		if (area->lspdb[1] == NULL)
 			area->lspdb[1] = lsp_db_init();
-		if (area->route_table[1] == NULL)
-			area->route_table[1] = route_table_init();
-		if (area->route_table6[1] == NULL)
-			area->route_table6[1] = route_table_init();
 		break;
 
 	case IS_LEVEL_1_AND_2:
@@ -1750,10 +1744,6 @@ void isis_area_is_type_set(struct isis_a
 
 		if (area->lspdb[0] == NULL)
 			area->lspdb[0] = lsp_db_init();
-		if (area->route_table[0] == NULL)
-			area->route_table[0] = route_table_init();
-		if (area->route_table6[0] == NULL)
-			area->route_table6[0] = route_table_init();
 		break;
 
 	default:
diff -urpN frr-frr-5.0.1/isisd/isisd.h frr-frr-6.0/isisd/isisd.h
--- frr-frr-5.0.1/isisd/isisd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/isisd.h	2018-10-08 14:32:57.000000000 +0200
@@ -63,13 +63,17 @@ struct isis {
 extern struct isis *isis;
 DECLARE_QOBJ_TYPE(isis_area)
 
+enum spf_tree_id {
+	SPFTREE_IPV4 = 0,
+	SPFTREE_IPV6,
+	SPFTREE_DSTSRC,
+	SPFTREE_COUNT
+};
+
 struct isis_area {
 	struct isis *isis;			       /* back pointer */
 	dict_t *lspdb[ISIS_LEVELS];		       /* link-state dbs */
-	struct isis_spftree *spftree[ISIS_LEVELS];     /* The v4 SPTs */
-	struct route_table *route_table[ISIS_LEVELS];  /* IPv4 routes */
-	struct isis_spftree *spftree6[ISIS_LEVELS];    /* The v6 SPTs */
-	struct route_table *route_table6[ISIS_LEVELS]; /* IPv6 routes */
+	struct isis_spftree *spftree[SPFTREE_COUNT][ISIS_LEVELS];
 #define DEFAULT_LSP_MTU 1497
 	unsigned int lsp_mtu;      /* Size of LSPs to generate */
 	struct list *circuit_list; /* IS-IS circuits */
@@ -144,6 +148,9 @@ struct isis_area *isis_area_lookup(const
 int isis_area_get(struct vty *vty, const char *area_tag);
 void print_debug(struct vty *, int, int);
 
+void isis_area_invalidate_routes(struct isis_area *area, int levels);
+void isis_area_verify_routes(struct isis_area *area);
+
 void isis_area_overload_bit_set(struct isis_area *area, bool overload_bit);
 void isis_area_attached_bit_set(struct isis_area *area, bool attached_bit);
 void isis_area_dynhostname_set(struct isis_area *area, bool dynhostname);
diff -urpN frr-frr-5.0.1/isisd/subdir.am frr-frr-6.0/isisd/subdir.am
--- frr-frr-5.0.1/isisd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/isisd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -15,6 +15,7 @@ isisd_libisis_a_SOURCES = \
 	isisd/isis_csm.c \
 	isisd/isis_dr.c \
 	isisd/isis_dynhn.c \
+	isisd/isis_errors.c \
 	isisd/isis_events.c \
 	isisd/isis_flags.c \
 	isisd/isis_lsp.c \
@@ -44,6 +45,7 @@ noinst_HEADERS += \
 	isisd/isis_csm.h \
 	isisd/isis_dr.h \
 	isisd/isis_dynhn.h \
+	isisd/isis_errors.h \
 	isisd/isis_events.h \
 	isisd/isis_flags.h \
 	isisd/isis_lsp.h \
diff -urpN frr-frr-5.0.1/ldpd/lde.c frr-frr-6.0/ldpd/lde.c
--- frr-frr-5.0.1/ldpd/lde.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/lde.c	2018-10-08 14:32:57.000000000 +0200
@@ -1643,7 +1643,7 @@ static void zclient_sync_init(unsigned s
 	sock_set_nonblock(zclient_sync->sock);
 
 	/* Connect to label manager */
-	while (lm_label_manager_connect(zclient_sync, 0) != 0) {
+	while (lm_label_manager_connect(zclient_sync) != 0) {
 		log_warnx("Error connecting to label manager!");
 		sleep(1);
 	}
diff -urpN frr-frr-5.0.1/ldpd/ldp_debug.c frr-frr-6.0/ldpd/ldp_debug.c
--- frr-frr-5.0.1/ldpd/ldp_debug.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/ldp_debug.c	2018-10-08 14:32:57.000000000 +0200
@@ -41,6 +41,9 @@ int
 ldp_vty_debug(struct vty *vty, const char *negate, const char *type_str,
     const char *dir_str, const char *all)
 {
+	if (type_str == NULL)
+		return (CMD_WARNING_CONFIG_FAILED);
+
 	if (strcmp(type_str, "discovery") == 0) {
 		if (dir_str == NULL)
 			return (CMD_WARNING_CONFIG_FAILED);
diff -urpN frr-frr-5.0.1/ldpd/ldp_vty_cmds.c frr-frr-6.0/ldpd/ldp_vty_cmds.c
--- frr-frr-5.0.1/ldpd/ldp_vty_cmds.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/ldp_vty_cmds.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,7 +29,7 @@
 #include "ldpd/ldp_vty_cmds_clippy.c"
 #endif
 
-DEFUN_NOSH(ldp_mpls_ldp,
+DEFPY_NOSH(ldp_mpls_ldp,
 	ldp_mpls_ldp_cmd,
 	"mpls ldp",
 	"Global MPLS configuration subcommands\n"
@@ -48,21 +48,15 @@ DEFPY  (no_ldp_mpls_ldp,
 	return (ldp_vty_mpls_ldp(vty, "no"));
 }
 
-DEFUN_NOSH(ldp_l2vpn,
+DEFPY_NOSH(ldp_l2vpn,
 	ldp_l2vpn_cmd,
-	"l2vpn WORD type vpls",
+	"l2vpn WORD$l2vpn_name type vpls",
 	"Configure l2vpn commands\n"
 	"L2VPN name\n"
 	"L2VPN type\n"
 	"Virtual Private LAN Service\n")
 {
-	int		 idx = 0;
-	const char	*name;
-
-	argv_find(argv, argc, "WORD", &idx);
-	name = argv[idx]->arg;
-
-	return (ldp_vty_l2vpn(vty, 0, name));
+	return (ldp_vty_l2vpn(vty, NULL, l2vpn_name));
 }
 
 DEFPY  (no_ldp_l2vpn,
@@ -77,20 +71,14 @@ DEFPY  (no_ldp_l2vpn,
 	return (ldp_vty_l2vpn(vty, "no", l2vpn_name));
 }
 
-DEFUN_NOSH(ldp_address_family,
+DEFPY_NOSH(ldp_address_family,
 	ldp_address_family_cmd,
-	"address-family <ipv4|ipv6>",
+	"address-family <ipv4|ipv6>$af",
 	"Configure Address Family and its parameters\n"
 	"IPv4\n"
 	"IPv6\n")
 {
-	int		 idx = 0;
-	const char	*af;
-
-	argv_find(argv, argc, "address-family", &idx);
-	af = argv[idx + 1]->text;
-
-	return (ldp_vty_address_family(vty, 0, af));
+	return (ldp_vty_address_family(vty, NULL, af));
 }
 
 DEFPY  (no_ldp_address_family,
@@ -104,7 +92,7 @@ DEFPY  (no_ldp_address_family,
 	return (ldp_vty_address_family(vty, "no", af));
 }
 
-DEFUN_NOSH(ldp_exit_address_family,
+DEFPY_NOSH(ldp_exit_address_family,
        ldp_exit_address_family_cmd,
        "exit-address-family",
        "Exit from Address Family configuration mode\n")
@@ -361,19 +349,13 @@ DEFPY  (ldp_session_holdtime,
 	return (ldp_vty_af_session_holdtime(vty, no, holdtime));
 }
 
-DEFUN_NOSH(ldp_interface,
+DEFPY_NOSH(ldp_interface,
 	ldp_interface_cmd,
-	"interface IFNAME",
+	"interface IFNAME$ifname",
 	"Enable LDP on an interface and enter interface submode\n"
 	"Interface's name\n")
 {
-	int		 idx = 0;
-	const char	*ifname;
-
-	argv_find(argv, argc, "IFNAME", &idx);
-	ifname = argv[idx]->arg;
-
-	return (ldp_vty_interface(vty, 0, ifname));
+	return (ldp_vty_interface(vty, NULL, ifname));
 }
 
 DEFPY  (no_ldp_interface,
@@ -439,20 +421,14 @@ DEFPY  (ldp_member_interface,
 	return (ldp_vty_l2vpn_interface(vty, no, ifname));
 }
 
-DEFUN_NOSH(ldp_member_pseudowire,
+DEFPY_NOSH(ldp_member_pseudowire,
 	ldp_member_pseudowire_cmd,
-	"member pseudowire IFNAME",
+	"member pseudowire IFNAME$ifname",
 	"L2VPN member configuration\n"
 	"Pseudowire interface\n"
 	"Interface's name\n")
 {
-	int		 idx = 0;
-	const char	*ifname;
-
-	argv_find(argv, argc, "IFNAME", &idx);
-	ifname = argv[idx]->arg;
-
-	return (ldp_vty_l2vpn_pseudowire(vty, 0, ifname));
+	return (ldp_vty_l2vpn_pseudowire(vty, NULL, ifname));
 }
 
 DEFPY  (no_ldp_member_pseudowire,
@@ -759,7 +735,7 @@ DEFPY  (ldp_show_l2vpn_atom_vc,
 	return (ldp_vty_show_atom_vc(vty, peer_str, ifname, vcid_str, json));
 }
 
-DEFUN_NOSH (ldp_show_debugging_mpls_ldp,
+DEFPY_NOSH (ldp_show_debugging_mpls_ldp,
 	    ldp_show_debugging_mpls_ldp_cmd,
 	    "show debugging [mpls ldp]",
 	    "Show running system information\n"
@@ -861,6 +837,7 @@ ldp_vty_init (void)
 	install_element(LDP_IPV6_NODE, &ldp_label_remote_accept_cmd);
 	install_element(LDP_IPV6_NODE, &ldp_ttl_security_disable_cmd);
 	install_element(LDP_IPV6_NODE, &ldp_interface_cmd);
+	install_element(LDP_IPV6_NODE, &no_ldp_interface_cmd);
 	install_element(LDP_IPV6_NODE, &ldp_session_holdtime_cmd);
 	install_element(LDP_IPV6_NODE, &ldp_neighbor_ipv6_targeted_cmd);
 	install_element(LDP_IPV6_NODE, &ldp_exit_address_family_cmd);
diff -urpN frr-frr-5.0.1/ldpd/ldp_vty_conf.c frr-frr-6.0/ldpd/ldp_vty_conf.c
--- frr-frr-5.0.1/ldpd/ldp_vty_conf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/ldp_vty_conf.c	2018-10-08 14:32:57.000000000 +0200
@@ -89,6 +89,9 @@ struct cmd_node ldp_pseudowire_node =
 int
 ldp_get_address(const char *str, int *af, union ldpd_addr *addr)
 {
+	if (!str || !af || !addr)
+		return (-1);
+
 	memset(addr, 0, sizeof(*addr));
 
 	if (inet_pton(AF_INET, str, &addr->v4) == 1) {
@@ -428,6 +431,9 @@ ldp_vty_address_family(struct vty *vty,
 	struct ldpd_af_conf	*af_conf;
 	int			 af;
 
+	if (af_str == NULL)
+		return (CMD_WARNING_CONFIG_FAILED);
+
 	if (strcmp(af_str, "ipv4") == 0) {
 		af = AF_INET;
 		af_conf = &vty_conf->ipv4;
@@ -709,6 +715,11 @@ ldp_vty_interface(struct vty *vty, const
 	struct iface		*iface;
 	struct iface_af		*ia;
 
+	if (ifname == NULL) {
+		vty_out (vty, "%% Missing IF name\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	af = ldp_vty_get_af(vty);
 	iface = if_lookup_name(vty_conf, ifname);
 
@@ -776,8 +787,9 @@ ldp_vty_trans_addr(struct vty *vty, cons
 	if (negate)
 		memset(&af_conf->trans_addr, 0, sizeof(af_conf->trans_addr));
 	else {
-		if (inet_pton(af, addr_str, &af_conf->trans_addr) != 1 ||
-		    bad_addr(af, &af_conf->trans_addr)) {
+		if (addr_str == NULL
+		    || inet_pton(af, addr_str, &af_conf->trans_addr) != 1
+		    || bad_addr(af, &af_conf->trans_addr)) {
 			vty_out (vty, "%% Malformed address\n");
 			return (CMD_SUCCESS);
 		}
@@ -797,7 +809,7 @@ ldp_vty_neighbor_targeted(struct vty *vt
 
 	af = ldp_vty_get_af(vty);
 
-	if (inet_pton(af, addr_str, &addr) != 1 ||
+	if (addr_str == NULL || inet_pton(af, addr_str, &addr) != 1 ||
 	    bad_addr(af, &addr)) {
 		vty_out (vty, "%% Malformed address\n");
 		return (CMD_WARNING_CONFIG_FAILED);
@@ -1018,6 +1030,11 @@ ldp_vty_neighbor_password(struct vty *vt
 	size_t			 password_len;
 	struct nbr_params	*nbrp;
 
+	if (password_str == NULL) {
+		vty_out (vty, "%% Missing password\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	if (bad_addr_v4(lsr_id)) {
 		vty_out (vty, "%% Malformed address\n");
 		return (CMD_WARNING_CONFIG_FAILED);
@@ -1113,6 +1130,11 @@ ldp_vty_l2vpn(struct vty *vty, const cha
 	struct l2vpn_if		*lif;
 	struct l2vpn_pw		*pw;
 
+	if (name_str == NULL) {
+		vty_out (vty, "%% Missing name\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	l2vpn = l2vpn_find(vty_conf, name_str);
 
 	if (negate) {
@@ -1158,8 +1180,13 @@ ldp_vty_l2vpn_bridge(struct vty *vty, co
 
 	if (negate)
 		memset(l2vpn->br_ifname, 0, sizeof(l2vpn->br_ifname));
-	else
+	else {
+		if (ifname == NULL) {
+			vty_out (vty, "%% Missing IF name\n");
+			return (CMD_WARNING_CONFIG_FAILED);
+		}
 		strlcpy(l2vpn->br_ifname, ifname, sizeof(l2vpn->br_ifname));
+	}
 
 	ldp_config_apply(vty, vty_conf);
 
@@ -1187,6 +1214,11 @@ ldp_vty_l2vpn_pwtype(struct vty *vty, co
 	VTY_DECLVAR_CONTEXT(l2vpn, l2vpn);
 	int			 pw_type;
 
+	if (type_str == NULL) {
+		vty_out (vty, "%% Missing type\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	if (strcmp(type_str, "ethernet") == 0)
 		pw_type = PW_TYPE_ETHERNET;
 	else
@@ -1208,6 +1240,11 @@ ldp_vty_l2vpn_interface(struct vty *vty,
 	VTY_DECLVAR_CONTEXT(l2vpn, l2vpn);
 	struct l2vpn_if		*lif;
 
+	if (ifname == NULL) {
+		vty_out (vty, "%% Missing IF name\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	lif = l2vpn_if_find(l2vpn, ifname);
 
 	if (negate) {
@@ -1246,6 +1283,11 @@ ldp_vty_l2vpn_pseudowire(struct vty *vty
 	VTY_DECLVAR_CONTEXT(l2vpn, l2vpn);
 	struct l2vpn_pw		*pw;
 
+	if (ifname == NULL) {
+		vty_out (vty, "%% Missing IF name\n");
+		return (CMD_WARNING_CONFIG_FAILED);
+	}
+
 	pw = l2vpn_pw_find(l2vpn, ifname);
 
 	if (negate) {
@@ -1294,6 +1336,10 @@ ldp_vty_l2vpn_pw_cword(struct vty *vty,
 	if (negate)
 		pw->flags |= F_PW_CWORD_CONF;
 	else {
+		if (!preference_str) {
+			vty_out (vty, "%% Missing preference\n");
+			return (CMD_WARNING_CONFIG_FAILED);
+		}
 		if (preference_str[0] == 'e')
 			pw->flags &= ~F_PW_CWORD_CONF;
 		else
diff -urpN frr-frr-5.0.1/ldpd/ldpd.c frr-frr-6.0/ldpd/ldpd.c
--- frr-frr-5.0.1/ldpd/ldpd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/ldpd.c	2018-10-08 14:32:57.000000000 +0200
@@ -42,6 +42,7 @@
 #include "filter.h"
 #include "qobj.h"
 #include "libfrr.h"
+#include "lib_errors.h"
 
 static void		 ldpd_shutdown(void);
 static pid_t		 start_child(enum ldpd_process, char *, int, int);
@@ -187,6 +188,22 @@ FRR_DAEMON_INFO(ldpd, LDP,
 	.privs = &ldpd_privs,
 )
 
+static int ldp_config_fork_apply(struct thread *t)
+{
+	/*
+	 * So the frr_config_fork() function schedules
+	 * the read of the vty config( if there is a
+	 * non-integrated config ) to be after the
+	 * end of startup and we are starting the
+	 * main process loop.  We need to schedule
+	 * the application of this if necessary
+	 * after the read in of the config.
+	 */
+	ldp_config_apply(NULL, vty_conf);
+
+	return 0;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -195,6 +212,7 @@ main(int argc, char *argv[])
 	int			 pipe_parent2ldpe[2], pipe_parent2ldpe_sync[2];
 	int			 pipe_parent2lde[2], pipe_parent2lde_sync[2];
 	char			*ctl_sock_name;
+	struct thread           *thread = NULL;
 
 	ldpd_process = PROC_MAIN;
 	log_procname = log_procnames[ldpd_process];
@@ -331,7 +349,7 @@ main(int argc, char *argv[])
 	frr_config_fork();
 
 	/* apply configuration */
-	ldp_config_apply(NULL, vty_conf);
+	thread_add_event(master, ldp_config_fork_apply, NULL, 0, &thread);
 
 	/* setup pipes to children */
 	if ((iev_ldpe = calloc(1, sizeof(struct imsgev))) == NULL ||
@@ -406,16 +424,32 @@ ldpd_shutdown(void)
 	free(vty_conf);
 
 	log_debug("waiting for children to terminate");
-	do {
+
+	while (true) {
+		/* Wait for child process. */
 		pid = wait(&status);
 		if (pid == -1) {
-			if (errno != EINTR && errno != ECHILD)
-				fatal("wait");
-		} else if (WIFSIGNALED(status))
+			/* We got interrupted, try again. */
+			if (errno == EINTR)
+				continue;
+			/* No more processes were found. */
+			if (errno != ECHILD)
+				break;
+
+			/* Unhandled errno condition. */
+			fatal("wait");
+			/* UNREACHABLE */
+		}
+
+		/* We found something, lets announce it. */
+		if (WIFSIGNALED(status))
 			log_warnx("%s terminated; signal %d",
-			    (pid == lde_pid) ? "label decision engine" :
-			    "ldp engine", WTERMSIG(status));
-	} while (pid != -1 || (pid == -1 && errno == EINTR));
+				  (pid == lde_pid ? "label decision engine"
+						  : "ldp engine"),
+				  WTERMSIG(status));
+
+		/* Repeat until there are no more child processes. */
+	}
 
 	free(iev_ldpe);
 	free(iev_lde);
@@ -450,8 +484,9 @@ start_child(enum ldpd_process p, char *a
 
 	nullfd = open("/dev/null", O_RDONLY | O_NOCTTY);
 	if (nullfd == -1) {
-		zlog_err("%s: failed to open /dev/null: %s", __func__,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: failed to open /dev/null: %s", __func__,
+			     safe_strerror(errno));
 	} else {
 		dup2(nullfd, 0);
 		dup2(nullfd, 1);
diff -urpN frr-frr-5.0.1/ldpd/ldpd.h frr-frr-6.0/ldpd/ldpd.h
--- frr-frr-5.0.1/ldpd/ldpd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/ldpd.h	2018-10-08 14:32:57.000000000 +0200
@@ -691,7 +691,8 @@ void		 embedscope(struct sockaddr_in6 *)
 void		 recoverscope(struct sockaddr_in6 *);
 void		 addscope(struct sockaddr_in6 *, uint32_t);
 void		 clearscope(struct in6_addr *);
-struct sockaddr	*addr2sa(int af, union ldpd_addr *, uint16_t);
+void		 addr2sa(int af, const union ldpd_addr *, uint16_t,
+		    union sockunion *su);
 void		 sa2addr(struct sockaddr *, int *, union ldpd_addr *,
 		    in_port_t *);
 socklen_t	 sockaddr_len(struct sockaddr *);
diff -urpN frr-frr-5.0.1/ldpd/neighbor.c frr-frr-6.0/ldpd/neighbor.c
--- frr-frr-5.0.1/ldpd/neighbor.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/neighbor.c	2018-10-08 14:32:57.000000000 +0200
@@ -584,8 +584,8 @@ nbr_connect_cb(struct thread *thread)
 int
 nbr_establish_connection(struct nbr *nbr)
 {
-	struct sockaddr_storage	 local_sa;
-	struct sockaddr_storage	 remote_sa;
+	union sockunion		 local_su;
+	union sockunion		 remote_su;
 	struct adj		*adj;
 	struct nbr_params	*nbrp;
 #ifdef __OpenBSD__
@@ -619,16 +619,14 @@ nbr_establish_connection(struct nbr *nbr
 #endif
 	}
 
-	memcpy(&local_sa, addr2sa(nbr->af, &nbr->laddr, 0), sizeof(local_sa));
-	memcpy(&remote_sa, addr2sa(nbr->af, &nbr->raddr, LDP_PORT),
-	    sizeof(local_sa));
+	addr2sa(nbr->af, &nbr->laddr, 0, &local_su);
+	addr2sa(nbr->af, &nbr->raddr, LDP_PORT, &remote_su);
 	if (nbr->af == AF_INET6 && nbr->raddr_scope)
-		addscope((struct sockaddr_in6 *)&remote_sa, nbr->raddr_scope);
+		addscope(&remote_su.sin6, nbr->raddr_scope);
 
-	if (bind(nbr->fd, (struct sockaddr *)&local_sa,
-	    sockaddr_len((struct sockaddr *)&local_sa)) == -1) {
+	if (bind(nbr->fd, &local_su.sa, sockaddr_len(&local_su.sa)) == -1) {
 		log_warn("%s: error while binding socket to %s", __func__,
-		    log_sockaddr((struct sockaddr *)&local_sa));
+			 log_sockaddr(&local_su.sa));
 		close(nbr->fd);
 		return (-1);
 	}
@@ -646,15 +644,15 @@ nbr_establish_connection(struct nbr *nbr
 		send_hello(adj->source.type, adj->source.link.ia,
 		    adj->source.target);
 
-	if (connect(nbr->fd, (struct sockaddr *)&remote_sa,
-	    sockaddr_len((struct sockaddr *)&remote_sa)) == -1) {
+	if (connect(nbr->fd, &remote_su.sa, sockaddr_len(&remote_su.sa))
+	    == -1) {
 		if (errno == EINPROGRESS) {
 			thread_add_write(master, nbr_connect_cb, nbr, nbr->fd,
 					 &nbr->ev_connect);
 			return (0);
 		}
 		log_warn("%s: error while connecting to %s", __func__,
-		    log_sockaddr((struct sockaddr *)&remote_sa));
+			 log_sockaddr(&remote_su.sa));
 		close(nbr->fd);
 		return (-1);
 	}
diff -urpN frr-frr-5.0.1/ldpd/packet.c frr-frr-6.0/ldpd/packet.c
--- frr-frr-5.0.1/ldpd/packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -70,7 +70,7 @@ int
 send_packet(int fd, int af, union ldpd_addr *dst, struct iface_af *ia,
     void *pkt, size_t len)
 {
-	struct sockaddr		*sa;
+	union sockunion su;
 
 	switch (af) {
 	case AF_INET:
@@ -97,10 +97,10 @@ send_packet(int fd, int af, union ldpd_a
 		fatalx("send_packet: unknown af");
 	}
 
-	sa = addr2sa(af, dst, LDP_PORT);
-	if (sendto(fd, pkt, len, 0, sa, sockaddr_len(sa)) == -1) {
+	addr2sa(af, dst, LDP_PORT, &su);
+	if (sendto(fd, pkt, len, 0, &su.sa, sockaddr_len(&su.sa)) == -1) {
 		log_warn("%s: error sending packet to %s", __func__,
-		    log_sockaddr(sa));
+			 log_sockaddr(&su.sa));
 		return (-1);
 	}
 
@@ -144,7 +144,7 @@ disc_recv_packet(struct thread *thread)
 
 	/* reschedule read */
 	*threadp = NULL;
-	thread_add_read(master, disc_recv_packet, threadp, fd, &*threadp);
+	thread_add_read(master, disc_recv_packet, threadp, fd, threadp);
 
 	/* setup buffer */
 	memset(&m, 0, sizeof(m));
diff -urpN frr-frr-5.0.1/ldpd/pfkey.c frr-frr-6.0/ldpd/pfkey.c
--- frr-frr-5.0.1/ldpd/pfkey.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/pfkey.c	2018-10-08 14:32:57.000000000 +0200
@@ -64,17 +64,17 @@ pfkey_send(int sd, uint8_t satype, uint8
 	ssize_t			n;
 	int			len = 0;
 	int			iov_cnt;
-	struct sockaddr_storage	ssrc, sdst, smask, dmask;
-	struct sockaddr		*saptr;
+	struct sockaddr_storage	smask, dmask;
+	union sockunion		su_src, su_dst;
 
 	if (!pid)
 		pid = getpid();
 
 	/* we need clean sockaddr... no ports set */
-	memset(&ssrc, 0, sizeof(ssrc));
 	memset(&smask, 0, sizeof(smask));
-	if ((saptr = addr2sa(af, src, 0)))
-		memcpy(&ssrc, saptr, sizeof(ssrc));
+
+	addr2sa(af, src, 0, &su_src);
+
 	switch (af) {
 	case AF_INET:
 		memset(&((struct sockaddr_in *)&smask)->sin_addr, 0xff, 32/8);
@@ -86,13 +86,13 @@ pfkey_send(int sd, uint8_t satype, uint8
 	default:
 		return (-1);
 	}
-	smask.ss_family = ssrc.ss_family;
-	smask.ss_len = ssrc.ss_len;
+	smask.ss_family = su_src.sa.sa_family;
+	smask.ss_len = sockaddr_len(&su_src.sa);
 
-	memset(&sdst, 0, sizeof(sdst));
 	memset(&dmask, 0, sizeof(dmask));
-	if ((saptr = addr2sa(af, dst, 0)))
-		memcpy(&sdst, saptr, sizeof(sdst));
+
+	addr2sa(af, dst, 0, &su_dst);
+
 	switch (af) {
 	case AF_INET:
 		memset(&((struct sockaddr_in *)&dmask)->sin_addr, 0xff, 32/8);
@@ -104,8 +104,8 @@ pfkey_send(int sd, uint8_t satype, uint8
 	default:
 		return (-1);
 	}
-	dmask.ss_family = sdst.ss_family;
-	dmask.ss_len = sdst.ss_len;
+	dmask.ss_family = su_dst.sa.sa_family;
+	dmask.ss_len = sockaddr_len(&su_dst.sa);
 
 	memset(&smsg, 0, sizeof(smsg));
 	smsg.sadb_msg_version = PF_KEY_V2;
@@ -138,11 +138,13 @@ pfkey_send(int sd, uint8_t satype, uint8
 
 	memset(&sa_src, 0, sizeof(sa_src));
 	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
-	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
+	sa_src.sadb_address_len =
+		(sizeof(sa_src) + ROUNDUP(sockaddr_len(&su_src.sa))) / 8;
 
 	memset(&sa_dst, 0, sizeof(sa_dst));
 	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
-	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
+	sa_dst.sadb_address_len =
+		(sizeof(sa_dst) + ROUNDUP(sockaddr_len(&su_dst.sa))) / 8;
 
 	sa.sadb_sa_auth = aalg;
 	sa.sadb_sa_encrypt = SADB_X_EALG_AES; /* XXX */
@@ -195,8 +197,8 @@ pfkey_send(int sd, uint8_t satype, uint8
 	iov[iov_cnt].iov_base = &sa_dst;
 	iov[iov_cnt].iov_len = sizeof(sa_dst);
 	iov_cnt++;
-	iov[iov_cnt].iov_base = &sdst;
-	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
+	iov[iov_cnt].iov_base = &su_dst;
+	iov[iov_cnt].iov_len = ROUNDUP(sockaddr_len(&su_dst.sa));
 	smsg.sadb_msg_len += sa_dst.sadb_address_len;
 	iov_cnt++;
 
@@ -204,8 +206,8 @@ pfkey_send(int sd, uint8_t satype, uint8
 	iov[iov_cnt].iov_base = &sa_src;
 	iov[iov_cnt].iov_len = sizeof(sa_src);
 	iov_cnt++;
-	iov[iov_cnt].iov_base = &ssrc;
-	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
+	iov[iov_cnt].iov_base = &su_src;
+	iov[iov_cnt].iov_len = ROUNDUP(sockaddr_len(&su_src.sa));
 	smsg.sadb_msg_len += sa_src.sadb_address_len;
 	iov_cnt++;
 
diff -urpN frr-frr-5.0.1/ldpd/socket.c frr-frr-6.0/ldpd/socket.c
--- frr-frr-5.0.1/ldpd/socket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/socket.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,11 +37,10 @@ ldp_create_socket(int af, enum socket_ty
 {
 	int			 fd, domain, proto;
 	union ldpd_addr		 addr;
-	struct sockaddr_storage	 local_sa;
+	union sockunion		 local_su;
 #ifdef __OpenBSD__
 	int			 opt;
 #endif
-	int			 save_errno;
 
 	/* create socket */
 	switch (type) {
@@ -70,38 +69,28 @@ ldp_create_socket(int af, enum socket_ty
 	case LDP_SOCKET_DISC:
 		/* listen on all addresses */
 		memset(&addr, 0, sizeof(addr));
-		memcpy(&local_sa, addr2sa(af, &addr, LDP_PORT),
-		    sizeof(local_sa));
+		addr2sa(af, &addr, LDP_PORT, &local_su);
 		break;
 	case LDP_SOCKET_EDISC:
 	case LDP_SOCKET_SESSION:
 		addr = (ldp_af_conf_get(ldpd_conf, af))->trans_addr;
-		memcpy(&local_sa, addr2sa(af, &addr, LDP_PORT),
-		    sizeof(local_sa));
+		addr2sa(af, &addr, LDP_PORT, &local_su);
 		/* ignore any possible error */
 		sock_set_bindany(fd, 1);
 		break;
 	}
-	if (ldpd_privs.change(ZPRIVS_RAISE))
-		log_warn("%s: could not raise privs", __func__);
-	if (sock_set_reuse(fd, 1) == -1) {
-		if (ldpd_privs.change(ZPRIVS_LOWER))
-			log_warn("%s: could not lower privs", __func__);
-		close(fd);
-		return (-1);
-	}
-	if (bind(fd, (struct sockaddr *)&local_sa,
-	    sockaddr_len((struct sockaddr *)&local_sa)) == -1) {
-		save_errno = errno;
-		if (ldpd_privs.change(ZPRIVS_LOWER))
-			log_warn("%s: could not lower privs", __func__);
-		log_warnx("%s: error binding socket: %s", __func__,
-		    safe_strerror(save_errno));
-		close(fd);
-		return (-1);
+	frr_elevate_privs(&ldpd_privs) {
+		if (sock_set_reuse(fd, 1) == -1) {
+			close(fd);
+			return (-1);
+		}
+		if (bind(fd, &local_su.sa, sockaddr_len(&local_su.sa)) == -1) {
+			log_warnx("%s: error binding socket: %s", __func__,
+			    safe_strerror(errno));
+			close(fd);
+			return (-1);
+		}
 	}
-	if (ldpd_privs.change(ZPRIVS_LOWER))
-		log_warn("%s: could not lower privs", __func__);
 
 	/* set options */
 	switch (af) {
@@ -265,17 +254,13 @@ int
 sock_set_bindany(int fd, int enable)
 {
 #ifdef HAVE_SO_BINDANY
-	if (ldpd_privs.change(ZPRIVS_RAISE))
-		log_warn("%s: could not raise privs", __func__);
-	if (setsockopt(fd, SOL_SOCKET, SO_BINDANY, &enable,
-	    sizeof(int)) < 0) {
-		if (ldpd_privs.change(ZPRIVS_LOWER))
-			log_warn("%s: could not lower privs", __func__);
-		log_warn("%s: error setting SO_BINDANY", __func__);
-		return (-1);
+	frr_elevate_privs(&ldpd_privs) {
+		if (setsockopt(fd, SOL_SOCKET, SO_BINDANY, &enable,
+			       sizeof(int)) < 0) {
+			log_warn("%s: error setting SO_BINDANY", __func__);
+			return (-1);
+		}
 	}
-	if (ldpd_privs.change(ZPRIVS_LOWER))
-		log_warn("%s: could not lower privs", __func__);
 	return (0);
 #elif defined(HAVE_IP_FREEBIND)
 	if (setsockopt(fd, IPPROTO_IP, IP_FREEBIND, &enable, sizeof(int)) < 0) {
@@ -307,16 +292,12 @@ sock_set_md5sig(int fd, int af, union ld
 	if (fd == -1)
 		return (0);
 #if HAVE_DECL_TCP_MD5SIG
-	memcpy(&su, addr2sa(af, addr, 0), sizeof(su));
+	addr2sa(af, addr, 0, &su);
 
-	if (ldpe_privs.change(ZPRIVS_RAISE)) {
-		log_warn("%s: could not raise privs", __func__);
-		return (-1);
+	frr_elevate_privs(&ldpe_privs) {
+		ret = sockopt_tcp_signature(fd, &su, password);
+		save_errno = errno;
 	}
-	ret = sockopt_tcp_signature(fd, &su, password);
-	save_errno = errno;
-	if (ldpe_privs.change(ZPRIVS_LOWER))
-		log_warn("%s: could not lower privs", __func__);
 #endif /* HAVE_TCP_MD5SIG */
 	if (ret < 0)
 		log_warnx("%s: can't set TCP_MD5SIG option on fd %d: %s",
diff -urpN frr-frr-5.0.1/ldpd/util.c frr-frr-6.0/ldpd/util.c
--- frr-frr-5.0.1/ldpd/util.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ldpd/util.c	2018-10-08 14:32:57.000000000 +0200
@@ -305,14 +305,13 @@ clearscope(struct in6_addr *in6)
 	}
 }
 
-struct sockaddr *
-addr2sa(int af, union ldpd_addr *addr, uint16_t port)
+void
+addr2sa(int af, const union ldpd_addr *addr, uint16_t port, union sockunion *su)
 {
-	static struct sockaddr_storage	 ss;
-	struct sockaddr_in		*sa_in = (struct sockaddr_in *)&ss;
-	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)&ss;
+	struct sockaddr_in		*sa_in = &su->sin;
+	struct sockaddr_in6		*sa_in6 = &su->sin6;
 
-	memset(&ss, 0, sizeof(ss));
+	memset(su, 0, sizeof(*su));
 	switch (af) {
 	case AF_INET:
 		sa_in->sin_family = AF_INET;
@@ -333,8 +332,6 @@ addr2sa(int af, union ldpd_addr *addr, u
 	default:
 		fatalx("addr2sa: unknown af");
 	}
-
-	return ((struct sockaddr *)&ss);
 }
 
 void
diff -urpN frr-frr-5.0.1/lib/agentx.c frr-frr-6.0/lib/agentx.c
--- frr-frr-5.0.1/lib/agentx.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/agentx.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "memory.h"
 #include "linklist.h"
 #include "version.h"
+#include "lib_errors.h"
 
 static int agentx_enabled = 0;
 
@@ -141,16 +142,20 @@ static int agentx_log_callback(int major
 		msg[strlen(msg) - 1] = '\0';
 	switch (slm->priority) {
 	case LOG_EMERG:
-		zlog_err("snmp[emerg]: %s", msg ? msg : slm->msg);
+		flog_err(LIB_ERR_SNMP,
+			  "snmp[emerg]: %s", msg ? msg : slm->msg);
 		break;
 	case LOG_ALERT:
-		zlog_err("snmp[alert]: %s", msg ? msg : slm->msg);
+		flog_err(LIB_ERR_SNMP,
+			  "snmp[alert]: %s", msg ? msg : slm->msg);
 		break;
 	case LOG_CRIT:
-		zlog_err("snmp[crit]: %s", msg ? msg : slm->msg);
+		flog_err(LIB_ERR_SNMP,
+			  "snmp[crit]: %s", msg ? msg : slm->msg);
 		break;
 	case LOG_ERR:
-		zlog_err("snmp[err]: %s", msg ? msg : slm->msg);
+		flog_err(LIB_ERR_SNMP,
+			  "snmp[err]: %s", msg ? msg : slm->msg);
 		break;
 	case LOG_WARNING:
 		zlog_warn("snmp[warning]: %s", msg ? msg : slm->msg);
diff -urpN frr-frr-5.0.1/lib/bfd.h frr-frr-6.0/lib/bfd.h
--- frr-frr-5.0.1/lib/bfd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/bfd.h	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #define _ZEBRA_BFD_H
 
 #include "lib/json.h"
+#include "lib/zclient.h"
 
 #define BFD_DEF_MIN_RX 300
 #define BFD_MIN_MIN_RX 50
diff -urpN frr-frr-5.0.1/lib/buffer.c frr-frr-6.0/lib/buffer.c
--- frr-frr-5.0.1/lib/buffer.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/buffer.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,8 @@
 #include "buffer.h"
 #include "log.h"
 #include "network.h"
+#include "lib_errors.h"
+
 #include <stddef.h>
 
 DEFINE_MTYPE_STATIC(LIB, BUFFER, "Buffer")
@@ -272,19 +274,12 @@ buffer_status_t buffer_flush_window(stru
 	if (!b->head)
 		return BUFFER_EMPTY;
 
-	if (height < 1) {
-		zlog_warn(
-			"%s called with non-positive window height %d, forcing to 1",
-			__func__, height);
+	if (height < 1)
 		height = 1;
-	} else if (height >= 2)
+	else if (height >= 2)
 		height--;
-	if (width < 1) {
-		zlog_warn(
-			"%s called with non-positive window width %d, forcing to 1",
-			__func__, width);
+	if (width < 1)
 		width = 1;
-	}
 
 	/* For erase and more data add two to b's buffer_data count.*/
 	if (b->head->next == NULL) {
@@ -332,16 +327,12 @@ buffer_status_t buffer_flush_window(stru
 		{
 			iov_alloc *= 2;
 			if (iov != small_iov) {
-				zlog_warn(
-					"%s: growing iov array to %d; "
-					"width %d, height %d, size %lu",
-					__func__, iov_alloc, width, height,
-					(unsigned long)b->size);
 				iov = XREALLOC(MTYPE_TMP, iov,
 					       iov_alloc * sizeof(*iov));
 			} else {
 				/* This should absolutely never occur. */
-				zlog_err(
+				flog_err_sys(
+					LIB_ERR_SYSTEM_CALL,
 					"%s: corruption detected: iov_small overflowed; "
 					"head %p, tail %p, head->next %p",
 					__func__, (void *)b->head,
@@ -456,9 +447,9 @@ in one shot. */
 	while (written > 0) {
 		struct buffer_data *d;
 		if (!(d = b->head)) {
-			zlog_err(
-				"%s: corruption detected: buffer queue empty, "
-				"but written is %lu",
+			flog_err(
+				LIB_ERR_DEVELOPMENT,
+				"%s: corruption detected: buffer queue empty, but written is %lu",
 				__func__, (unsigned long)written);
 			break;
 		}
diff -urpN frr-frr-5.0.1/lib/clippy.c frr-frr-6.0/lib/clippy.c
--- frr-frr-5.0.1/lib/clippy.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/clippy.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,9 +31,11 @@
 #define pychar wchar_t
 static wchar_t *wconv(const char *s)
 {
-	size_t outlen = mbstowcs(NULL, s, 0);
+	size_t outlen = s ? mbstowcs(NULL, s, 0) : 0;
 	wchar_t *out = malloc((outlen + 1) * sizeof(wchar_t));
-	mbstowcs(out, s, outlen + 1);
+
+	if (outlen > 0)
+		mbstowcs(out, s, outlen);
 	out[outlen] = 0;
 	return out;
 }
diff -urpN frr-frr-5.0.1/lib/command.c frr-frr-6.0/lib/command.c
--- frr-frr-5.0.1/lib/command.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/command.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,17 +25,17 @@
  */
 
 #include <zebra.h>
+#include <lib/version.h>
 
-
+#include "command.h"
+#include "frrstr.h"
 #include "memory.h"
 #include "log.h"
 #include "log_int.h"
-#include <lib/version.h>
 #include "thread.h"
 #include "vector.h"
 #include "linklist.h"
 #include "vty.h"
-#include "command.h"
 #include "workqueue.h"
 #include "vrf.h"
 #include "command_match.h"
@@ -44,9 +44,10 @@
 #include "defaults.h"
 #include "libfrr.h"
 #include "jhash.h"
+#include "hook.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE(LIB, HOST, "Host config")
-DEFINE_MTYPE(LIB, STRVEC, "String vector")
 DEFINE_MTYPE(LIB, COMPLETION, "Completion item")
 
 #define item(x)                                                                \
@@ -85,6 +86,7 @@ const char *node_names[] = {
 	"keychain",		    // KEYCHAIN_NODE,
 	"keychain key",		    // KEYCHAIN_KEY_NODE,
 	"logical-router",	   // LOGICALROUTER_NODE,
+	"static ip",		    // IP_NODE,
 	"vrf",			    // VRF_NODE,
 	"interface",		    // INTERFACE_NODE,
 	"nexthop-group",            // NH_GROUP_NODE,
@@ -119,7 +121,6 @@ const char *node_names[] = {
 	"ldp l2vpn",		    // LDP_L2VPN_NODE,
 	"ldp",			    // LDP_PSEUDOWIRE_NODE,
 	"isis",			    // ISIS_NODE,
-	"static ip",		    // IP_NODE,
 	"ipv4 access list",	 // ACCESS_NODE,
 	"ipv4 prefix list",	 // PREFIX_NODE,
 	"ipv6 access list",	 // ACCESS_IPV6_NODE,
@@ -143,6 +144,8 @@ const char *node_names[] = {
 				     */
 	"bgp ipv6 flowspec",	    /* BGP_FLOWSPECV6_NODE
 				     */
+	"bfd",			 /* BFD_NODE */
+	"bfd peer",		 /* BFD_PEER_NODE */
 };
 /* clang-format on */
 
@@ -259,30 +262,52 @@ void print_version(const char *progname)
 	printf("configured with:\n\t%s\n", FRR_CONFIG_ARGS);
 }
 
-
-/* Utility function to concatenate argv argument into a single string
-   with inserting ' ' character between each argument.  */
 char *argv_concat(struct cmd_token **argv, int argc, int shift)
 {
-	int i;
-	size_t len;
-	char *str;
-	char *p;
-
-	len = 0;
-	for (i = shift; i < argc; i++)
-		len += strlen(argv[i]->arg) + 1;
-	if (!len)
+	int cnt = MAX(argc - shift, 0);
+	const char *argstr[cnt + 1];
+
+	if (!cnt)
+		return NULL;
+
+	for (int i = 0; i < cnt; i++)
+		argstr[i] = argv[i + shift]->arg;
+
+	return frrstr_join(argstr, cnt, " ");
+}
+
+vector cmd_make_strvec(const char *string)
+{
+	if (!string)
+		return NULL;
+
+	const char *copy = string;
+
+	/* skip leading whitespace */
+	while (isspace((int)*copy) && *copy != '\0')
+		copy++;
+
+	/* if the entire string was whitespace or a comment, return */
+	if (*copy == '\0' || *copy == '!' || *copy == '#')
 		return NULL;
-	p = str = XMALLOC(MTYPE_TMP, len);
-	for (i = shift; i < argc; i++) {
-		size_t arglen;
-		memcpy(p, argv[i]->arg, (arglen = strlen(argv[i]->arg)));
-		p += arglen;
-		*p++ = ' ';
+
+	vector result = frrstr_split_vec(copy, "\n\r\t ");
+
+	for (unsigned int i = 0; i < vector_active(result); i++) {
+		if (strlen(vector_slot(result, i)) == 0) {
+			XFREE(MTYPE_TMP, vector_slot(result, i));
+			vector_unset(result, i);
+		}
 	}
-	*(p - 1) = '\0';
-	return str;
+
+	vector_compact(result);
+
+	return result;
+}
+
+void cmd_free_strvec(vector v)
+{
+	frrstr_strvec_free(v);
 }
 
 /**
@@ -332,61 +357,6 @@ void install_node(struct cmd_node *node,
 					  "Command Hash");
 }
 
-/**
- * Tokenizes a string, storing tokens in a vector.
- * Whitespace is ignored.
- *
- * Delimiter string = " \n\r\t".
- *
- * @param string to tokenize
- * @return tokenized string
- */
-vector cmd_make_strvec(const char *string)
-{
-	if (!string)
-		return NULL;
-
-	char *copy, *copystart;
-	copystart = copy = XSTRDUP(MTYPE_TMP, string);
-
-	// skip leading whitespace
-	while (isspace((int)*copy) && *copy != '\0')
-		copy++;
-
-	// if the entire string was whitespace or a comment, return
-	if (*copy == '\0' || *copy == '!' || *copy == '#') {
-		XFREE(MTYPE_TMP, copystart);
-		return NULL;
-	}
-
-	vector strvec = vector_init(VECTOR_MIN_SIZE);
-	const char *delim = " \n\r\t", *tok = NULL;
-	while (copy) {
-		tok = strsep(&copy, delim);
-		if (*tok != '\0')
-			vector_set(strvec, XSTRDUP(MTYPE_STRVEC, tok));
-	}
-
-	XFREE(MTYPE_TMP, copystart);
-	return strvec;
-}
-
-/* Free allocated string vector. */
-void cmd_free_strvec(vector v)
-{
-	unsigned int i;
-	char *cp;
-
-	if (!v)
-		return;
-
-	for (i = 0; i < vector_active(v); i++)
-		if ((cp = vector_slot(v, i)) != NULL)
-			XFREE(MTYPE_STRVEC, cp);
-
-	vector_free(v);
-}
-
 /* Return prompt character of specified node. */
 const char *cmd_prompt(enum node_type node)
 {
@@ -529,87 +499,99 @@ static int config_write_host(struct vty
 	if (cmd_domainname_get())
 		vty_out(vty, "domainname %s\n", cmd_domainname_get());
 
-	if (host.encrypt) {
-		if (host.password_encrypt)
-			vty_out(vty, "password 8 %s\n", host.password_encrypt);
-		if (host.enable_encrypt)
-			vty_out(vty, "enable password 8 %s\n",
-				host.enable_encrypt);
-	} else {
-		if (host.password)
-			vty_out(vty, "password %s\n", host.password);
-		if (host.enable)
-			vty_out(vty, "enable password %s\n", host.enable);
-	}
-
-	if (zlog_default->default_lvl != LOG_DEBUG) {
-		vty_out(vty, "! N.B. The 'log trap' command is deprecated.\n");
-		vty_out(vty, "log trap %s\n",
-			zlog_priority[zlog_default->default_lvl]);
-	}
-
-	if (host.logfile
-	    && (zlog_default->maxlvl[ZLOG_DEST_FILE] != ZLOG_DISABLED)) {
-		vty_out(vty, "log file %s", host.logfile);
-		if (zlog_default->maxlvl[ZLOG_DEST_FILE]
-		    != zlog_default->default_lvl)
-			vty_out(vty, " %s",
-				zlog_priority
-					[zlog_default->maxlvl[ZLOG_DEST_FILE]]);
-		vty_out(vty, "\n");
-	}
-
-	if (zlog_default->maxlvl[ZLOG_DEST_STDOUT] != ZLOG_DISABLED) {
-		vty_out(vty, "log stdout");
-		if (zlog_default->maxlvl[ZLOG_DEST_STDOUT]
-		    != zlog_default->default_lvl)
-			vty_out(vty, " %s",
-				zlog_priority[zlog_default->maxlvl
-						      [ZLOG_DEST_STDOUT]]);
-		vty_out(vty, "\n");
-	}
+	/* The following are all configuration commands that are not sent to
+	 * watchfrr.  For instance watchfrr is hardcoded to log to syslog so
+	 * we would always display 'log syslog informational' in the config
+	 * which would cause other daemons to then switch to syslog when they
+	 * parse frr.conf.
+	 */
+	if (strcmp(zlog_default->protoname, "WATCHFRR")) {
+		if (host.encrypt) {
+			if (host.password_encrypt)
+				vty_out(vty, "password 8 %s\n",
+					host.password_encrypt);
+			if (host.enable_encrypt)
+				vty_out(vty, "enable password 8 %s\n",
+					host.enable_encrypt);
+		} else {
+			if (host.password)
+				vty_out(vty, "password %s\n", host.password);
+			if (host.enable)
+				vty_out(vty, "enable password %s\n",
+					host.enable);
+		}
 
-	if (zlog_default->maxlvl[ZLOG_DEST_MONITOR] == ZLOG_DISABLED)
-		vty_out(vty, "no log monitor\n");
-	else if (zlog_default->maxlvl[ZLOG_DEST_MONITOR]
-		 != zlog_default->default_lvl)
-		vty_out(vty, "log monitor %s\n",
-			zlog_priority[zlog_default->maxlvl[ZLOG_DEST_MONITOR]]);
-
-	if (zlog_default->maxlvl[ZLOG_DEST_SYSLOG] != ZLOG_DISABLED) {
-		vty_out(vty, "log syslog");
-		if (zlog_default->maxlvl[ZLOG_DEST_SYSLOG]
-		    != zlog_default->default_lvl)
-			vty_out(vty, " %s",
+		if (host.logfile
+		    && (zlog_default->maxlvl[ZLOG_DEST_FILE]
+			!= ZLOG_DISABLED)) {
+			vty_out(vty, "log file %s", host.logfile);
+			if (zlog_default->maxlvl[ZLOG_DEST_FILE]
+			    != zlog_default->default_lvl)
+				vty_out(vty, " %s",
+					zlog_priority
+						[zlog_default->maxlvl
+							 [ZLOG_DEST_FILE]]);
+			vty_out(vty, "\n");
+		}
+
+		if (zlog_default->maxlvl[ZLOG_DEST_STDOUT] != ZLOG_DISABLED) {
+			vty_out(vty, "log stdout");
+			if (zlog_default->maxlvl[ZLOG_DEST_STDOUT]
+			    != zlog_default->default_lvl)
+				vty_out(vty, " %s",
+					zlog_priority
+						[zlog_default->maxlvl
+							 [ZLOG_DEST_STDOUT]]);
+			vty_out(vty, "\n");
+		}
+
+		if (zlog_default->maxlvl[ZLOG_DEST_MONITOR] == ZLOG_DISABLED)
+			vty_out(vty, "no log monitor\n");
+		else if (zlog_default->maxlvl[ZLOG_DEST_MONITOR]
+			 != zlog_default->default_lvl)
+			vty_out(vty, "log monitor %s\n",
 				zlog_priority[zlog_default->maxlvl
-						      [ZLOG_DEST_SYSLOG]]);
-		vty_out(vty, "\n");
-	}
+						      [ZLOG_DEST_MONITOR]]);
 
-	if (zlog_default->facility != LOG_DAEMON)
-		vty_out(vty, "log facility %s\n",
-			facility_name(zlog_default->facility));
+		if (zlog_default->maxlvl[ZLOG_DEST_SYSLOG] != ZLOG_DISABLED) {
+			vty_out(vty, "log syslog");
+			if (zlog_default->maxlvl[ZLOG_DEST_SYSLOG]
+			    != zlog_default->default_lvl)
+				vty_out(vty, " %s",
+					zlog_priority[zlog_default->maxlvl
+							      [ZLOG_DEST_SYSLOG]]);
+			vty_out(vty, "\n");
+		}
 
-	if (zlog_default->record_priority == 1)
-		vty_out(vty, "log record-priority\n");
+		if (zlog_default->facility != LOG_DAEMON)
+			vty_out(vty, "log facility %s\n",
+				facility_name(zlog_default->facility));
 
-	if (zlog_default->timestamp_precision > 0)
-		vty_out(vty, "log timestamp precision %d\n",
-			zlog_default->timestamp_precision);
+		if (zlog_default->record_priority == 1)
+			vty_out(vty, "log record-priority\n");
 
-	if (host.advanced)
-		vty_out(vty, "service advanced-vty\n");
+		if (zlog_default->error_code)
+			vty_out(vty, "log error-code\n");
 
-	if (host.encrypt)
-		vty_out(vty, "service password-encryption\n");
+		if (zlog_default->timestamp_precision > 0)
+			vty_out(vty, "log timestamp precision %d\n",
+				zlog_default->timestamp_precision);
 
-	if (host.lines >= 0)
-		vty_out(vty, "service terminal-length %d\n", host.lines);
+		if (host.advanced)
+			vty_out(vty, "service advanced-vty\n");
 
-	if (host.motdfile)
-		vty_out(vty, "banner motd file %s\n", host.motdfile);
-	else if (!host.motd)
-		vty_out(vty, "no banner motd\n");
+		if (host.encrypt)
+			vty_out(vty, "service password-encryption\n");
+
+		if (host.lines >= 0)
+			vty_out(vty, "service terminal-length %d\n",
+				host.lines);
+
+		if (host.motdfile)
+			vty_out(vty, "banner motd file %s\n", host.motdfile);
+		else if (!host.motd)
+			vty_out(vty, "no banner motd\n");
+	}
 
 	if (debug_memstats_at_exit)
 		vty_out(vty, "!\ndebug memstats-at-exit\n");
@@ -1011,6 +993,9 @@ enum node_type node_parent(enum node_typ
 	case LDP_PSEUDOWIRE_NODE:
 		ret = LDP_L2VPN_NODE;
 		break;
+	case BFD_PEER_NODE:
+		ret = BFD_NODE;
+		break;
 	default:
 		ret = CONFIG_NODE;
 		break;
@@ -1164,6 +1149,124 @@ int cmd_execute_command_strict(vector vl
 	return cmd_execute_command_real(vline, FILTER_STRICT, vty, cmd);
 }
 
+/*
+ * Hook for preprocessing command string before executing.
+ *
+ * All subscribers are called with the raw command string that is to be
+ * executed. If any changes are to be made, a new string should be allocated
+ * with MTYPE_TMP and *cmd_out updated to point to this new string. The caller
+ * is then responsible for freeing this string.
+ *
+ * All processing functions must be mutually exclusive in their action, i.e. if
+ * one subscriber decides to modify the command, all others must not modify it
+ * when called. Feeding the output of one processing command into a subsequent
+ * one is not supported.
+ *
+ * This hook is intentionally internal to the command processing system.
+ *
+ * cmd_in
+ *    The raw command string.
+ *
+ * cmd_out
+ *    The result of any processing.
+ */
+DECLARE_HOOK(cmd_execute,
+	     (struct vty *vty, const char *cmd_in, char **cmd_out),
+	     (vty, cmd_in, cmd_out));
+DEFINE_HOOK(cmd_execute, (struct vty *vty, const char *cmd_in, char **cmd_out),
+	    (vty, cmd_in, cmd_out));
+
+/* Hook executed after a CLI command. */
+DECLARE_KOOH(cmd_execute_done, (struct vty *vty, const char *cmd_exec),
+	     (vty, cmd_exec));
+DEFINE_KOOH(cmd_execute_done, (struct vty *vty, const char *cmd_exec),
+	    (vty, cmd_exec));
+
+/*
+ * cmd_execute hook subscriber to handle `|` actions.
+ */
+static int handle_pipe_action(struct vty *vty, const char *cmd_in,
+			      char **cmd_out)
+{
+	/* look for `|` */
+	char *orig, *working, *token, *u;
+	char *pipe = strstr(cmd_in, "| ");
+
+	if (!pipe)
+		return 0;
+
+	/* duplicate string for processing purposes, not including pipe */
+	orig = working = XSTRDUP(MTYPE_TMP, pipe + 2);
+
+	/* retrieve action */
+	token = strsep(&working, " ");
+
+	/* match result to known actions */
+	if (strmatch(token, "include")) {
+		/* the remaining text should be a regexp */
+		char *regexp = working;
+
+		if (!regexp) {
+			vty_out(vty, "%% Need a regexp to filter with\n");
+			goto fail;
+		}
+
+		bool succ = vty_set_include(vty, regexp);
+
+		if (!succ) {
+			vty_out(vty, "%% Bad regexp '%s'\n", regexp);
+			goto fail;
+		}
+		*cmd_out = XSTRDUP(MTYPE_TMP, cmd_in);
+		u = *cmd_out;
+		strsep(&u, "|");
+	} else {
+		vty_out(vty, "%% Unknown action '%s'\n", token);
+		goto fail;
+	}
+
+fail:
+	XFREE(MTYPE_TMP, orig);
+	return 0;
+}
+
+static int handle_pipe_action_done(struct vty *vty, const char *cmd_exec)
+{
+	if (vty->filter)
+		vty_set_include(vty, NULL);
+
+	return 0;
+}
+
+int cmd_execute(struct vty *vty, const char *cmd,
+		const struct cmd_element **matched, int vtysh)
+{
+	int ret;
+	char *cmd_out = NULL;
+	const char *cmd_exec;
+	vector vline;
+
+	hook_call(cmd_execute, vty, cmd, &cmd_out);
+	cmd_exec = cmd_out ? (const char *)cmd_out : cmd;
+
+	vline = cmd_make_strvec(cmd_exec);
+
+	if (vline) {
+		ret = cmd_execute_command(vline, vty, matched, vtysh);
+		cmd_free_strvec(vline);
+	} else {
+		ret = CMD_SUCCESS;
+	}
+
+	hook_call(cmd_execute_done, vty, cmd_exec);
+
+	if (cmd_out)
+		XFREE(MTYPE_TMP, cmd_out);
+
+	return ret;
+}
+
+
 /**
  * Parse one line of config, walking up the parse tree attempting to find a
  * match
@@ -1339,6 +1442,7 @@ void cmd_exit(struct vty *vty)
 	case RMAP_NODE:
 	case PBRMAP_NODE:
 	case VTY_NODE:
+	case BFD_NODE:
 		vty->node = CONFIG_NODE;
 		break;
 	case BGP_IPV4_NODE:
@@ -1380,6 +1484,9 @@ void cmd_exit(struct vty *vty)
 	case LINK_PARAMS_NODE:
 		vty->node = INTERFACE_NODE;
 		break;
+	case BFD_PEER_NODE:
+		vty->node = BFD_NODE;
+		break;
 	default:
 		break;
 	}
@@ -1450,6 +1557,8 @@ DEFUN (config_end,
 	case KEYCHAIN_KEY_NODE:
 	case VTY_NODE:
 	case LINK_PARAMS_NODE:
+	case BFD_NODE:
+	case BFD_PEER_NODE:
 		vty_config_unlock(vty);
 		vty->node = ENABLE_NODE;
 		break;
@@ -1873,7 +1982,7 @@ DEFUN (config_hostname,
 {
 	struct cmd_token *word = argv[1];
 
-	if (!isalpha((int)word->arg[0])) {
+	if (!isalnum((int)word->arg[0])) {
 		vty_out(vty, "Please specify string starting with alphabet\n");
 		return CMD_WARNING_CONFIG_FAILED;
 	}
@@ -2228,6 +2337,8 @@ DEFUN (show_logging,
 	vty_out(vty, "Protocol name: %s\n", zl->protoname);
 	vty_out(vty, "Record priority: %s\n",
 		(zl->record_priority ? "enabled" : "disabled"));
+	vty_out(vty, "Error code: %s\n",
+		(zl->error_code ? "enabled" : "disabled"));
 	vty_out(vty, "Timestamp precision: %d\n", zl->timestamp_precision);
 
 	return CMD_SUCCESS;
@@ -2311,15 +2422,12 @@ static int set_log_file(struct vty *vty,
 		cwd[MAXPATHLEN] = '\0';
 
 		if (getcwd(cwd, MAXPATHLEN) == NULL) {
-			zlog_err("config_log_file: Unable to alloc mem!");
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "config_log_file: Unable to alloc mem!");
 			return CMD_WARNING_CONFIG_FAILED;
 		}
 
-		if ((p = XMALLOC(MTYPE_TMP, strlen(cwd) + strlen(fname) + 2))
-		    == NULL) {
-			zlog_err("config_log_file: Unable to alloc mem!");
-			return CMD_WARNING_CONFIG_FAILED;
-		}
+		p = XMALLOC(MTYPE_TMP, strlen(cwd) + strlen(fname) + 2);
 		sprintf(p, "%s/%s", cwd, fname);
 		fullpath = p;
 	} else
@@ -2331,7 +2439,8 @@ static int set_log_file(struct vty *vty,
 		XFREE(MTYPE_TMP, p);
 
 	if (!ret) {
-		vty_out(vty, "can't open logfile %s\n", fname);
+		if (vty)
+			vty_out(vty, "can't open logfile %s\n", fname);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
@@ -2342,11 +2451,44 @@ static int set_log_file(struct vty *vty,
 
 #if defined(HAVE_CUMULUS)
 	if (zlog_default->maxlvl[ZLOG_DEST_SYSLOG] != ZLOG_DISABLED)
-		zlog_default->maxlvl[ZLOG_DEST_SYSLOG] = ZLOG_DISABLED;
+		zlog_set_level(ZLOG_DEST_SYSLOG, ZLOG_DISABLED);
 #endif
 	return CMD_SUCCESS;
 }
 
+void command_setup_early_logging(const char *dest, const char *level)
+{
+	char *token;
+
+	if (level) {
+		int nlevel = level_match(level);
+
+		if (nlevel != ZLOG_DISABLED)
+			zlog_default->default_lvl = nlevel;
+	}
+
+	if (!dest)
+		return;
+
+	if (strcmp(dest, "stdout") == 0) {
+		zlog_set_level(ZLOG_DEST_STDOUT, zlog_default->default_lvl);
+		return;
+	}
+
+	if (strcmp(dest, "syslog") == 0) {
+		zlog_set_level(ZLOG_DEST_SYSLOG, zlog_default->default_lvl);
+		return;
+	}
+
+	token = strstr(dest, ":");
+	if (token == NULL)
+		return;
+
+	token++;
+
+	set_log_file(NULL, token, zlog_default->default_lvl);
+}
+
 DEFUN (config_log_file,
        config_log_file_cmd,
        "log file FILENAME [<emergencies|alerts|critical|errors|warnings|notifications|informational|debugging>]",
@@ -2368,6 +2510,16 @@ DEFUN (config_log_file,
 				    zlog_default->default_lvl);
 }
 
+static void disable_log_file(void)
+{
+	zlog_reset_file();
+
+	if (host.logfile)
+		XFREE(MTYPE_HOST, host.logfile);
+
+	host.logfile = NULL;
+}
+
 DEFUN (no_config_log_file,
        no_config_log_file_cmd,
        "no log file [FILENAME [LEVEL]]",
@@ -2377,13 +2529,7 @@ DEFUN (no_config_log_file,
        "Logging file name\n"
        "Logging level\n")
 {
-	zlog_reset_file();
-
-	if (host.logfile)
-		XFREE(MTYPE_HOST, host.logfile);
-
-	host.logfile = NULL;
-
+	disable_log_file();
 	return CMD_SUCCESS;
 }
 
@@ -2395,6 +2541,9 @@ DEFUN (config_log_syslog,
        LOG_LEVEL_DESC)
 {
 	int idx_log_levels = 2;
+
+	disable_log_file();
+
 	if (argc == 3) {
 		int level;
 		if ((level = level_match(argv[idx_log_levels]->arg))
@@ -2447,36 +2596,6 @@ DEFUN (no_config_log_facility,
 	return CMD_SUCCESS;
 }
 
-DEFUN_DEPRECATED(
-	config_log_trap, config_log_trap_cmd,
-	"log trap <emergencies|alerts|critical|errors|warnings|notifications|informational|debugging>",
-	"Logging control\n"
-	"(Deprecated) Set logging level and default for all destinations\n" LOG_LEVEL_DESC)
-{
-	int new_level;
-	int i;
-
-	if ((new_level = level_match(argv[2]->arg)) == ZLOG_DISABLED)
-		return CMD_ERR_NO_MATCH;
-
-	zlog_default->default_lvl = new_level;
-	for (i = 0; i < ZLOG_NUM_DESTS; i++)
-		if (zlog_default->maxlvl[i] != ZLOG_DISABLED)
-			zlog_default->maxlvl[i] = new_level;
-	return CMD_SUCCESS;
-}
-
-DEFUN_DEPRECATED(
-	no_config_log_trap, no_config_log_trap_cmd,
-	"no log trap [emergencies|alerts|critical|errors|warnings|notifications|informational|debugging]",
-	NO_STR
-	"Logging control\n"
-	"Permit all logging information\n" LOG_LEVEL_DESC)
-{
-	zlog_default->default_lvl = LOG_DEBUG;
-	return CMD_SUCCESS;
-}
-
 DEFUN (config_log_record_priority,
        config_log_record_priority_cmd,
        "log record-priority",
@@ -2498,6 +2617,17 @@ DEFUN (no_config_log_record_priority,
 	return CMD_SUCCESS;
 }
 
+DEFUN (config_log_error_code,
+       config_log_error_code_cmd,
+       "[no] log error-code",
+       NO_STR
+       "Logging control\n"
+       "Log the error code number where available\n")
+{
+	zlog_default->error_code = !!strcmp(argv[0]->text, "no");
+	return CMD_SUCCESS;
+}
+
 DEFUN (config_log_timestamp_precision,
        config_log_timestamp_precision_cmd,
        "log timestamp precision (0-6)",
@@ -2674,6 +2804,10 @@ void cmd_init(int terminal)
 	uname(&names);
 	qobj_init();
 
+	/* register command preprocessors */
+	hook_register(cmd_execute, handle_pipe_action);
+	hook_register(cmd_execute_done, handle_pipe_action_done);
+
 	varhandlers = list_new();
 
 	/* Allocate initial top vector of commands. */
@@ -2762,11 +2896,10 @@ void cmd_init(int terminal)
 		install_element(CONFIG_NODE, &no_config_log_syslog_cmd);
 		install_element(CONFIG_NODE, &config_log_facility_cmd);
 		install_element(CONFIG_NODE, &no_config_log_facility_cmd);
-		install_element(CONFIG_NODE, &config_log_trap_cmd);
-		install_element(CONFIG_NODE, &no_config_log_trap_cmd);
 		install_element(CONFIG_NODE, &config_log_record_priority_cmd);
 		install_element(CONFIG_NODE,
 				&no_config_log_record_priority_cmd);
+		install_element(CONFIG_NODE, &config_log_error_code_cmd);
 		install_element(CONFIG_NODE,
 				&config_log_timestamp_precision_cmd);
 		install_element(CONFIG_NODE,
@@ -2791,6 +2924,9 @@ void cmd_terminate()
 {
 	struct cmd_node *cmd_node;
 
+	hook_unregister(cmd_execute, handle_pipe_action);
+	hook_unregister(cmd_execute_done, handle_pipe_action_done);
+
 	if (cmdvec) {
 		for (unsigned int i = 0; i < vector_active(cmdvec); i++)
 			if ((cmd_node = vector_slot(cmdvec, i)) != NULL) {
diff -urpN frr-frr-5.0.1/lib/command.h frr-frr-6.0/lib/command.h
--- frr-frr-5.0.1/lib/command.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/command.h	2018-10-08 14:32:57.000000000 +0200
@@ -33,9 +33,6 @@
 DECLARE_MTYPE(HOST)
 DECLARE_MTYPE(COMPLETION)
 
-/* for test-commands.c */
-DECLARE_MTYPE(STRVEC)
-
 /* Host configuration variable */
 struct host {
 	/* Host name of this router. */
@@ -85,6 +82,7 @@ enum node_type {
 	KEYCHAIN_NODE,		 /* Key-chain node. */
 	KEYCHAIN_KEY_NODE,       /* Key-chain key node. */
 	LOGICALROUTER_NODE,      /* Logical-Router node. */
+	IP_NODE,		 /* Static ip route node. */
 	VRF_NODE,		 /* VRF mode node. */
 	INTERFACE_NODE,		 /* Interface mode node. */
 	NH_GROUP_NODE,		 /* Nexthop-Group mode node. */
@@ -119,7 +117,6 @@ enum node_type {
 	LDP_L2VPN_NODE,		 /* LDP L2VPN node */
 	LDP_PSEUDOWIRE_NODE,     /* LDP Pseudowire node */
 	ISIS_NODE,		 /* ISIS protocol mode */
-	IP_NODE,		 /* Static ip route node. */
 	ACCESS_NODE,		 /* Access list node. */
 	PREFIX_NODE,		 /* Prefix list node. */
 	ACCESS_IPV6_NODE,	/* Access list node. */
@@ -142,6 +139,8 @@ enum node_type {
 			  connections.*/
 	BGP_FLOWSPECV4_NODE,	/* BGP IPv4 FLOWSPEC Address-Family */
 	BGP_FLOWSPECV6_NODE,	/* BGP IPv6 FLOWSPEC Address-Family */
+	BFD_NODE,		 /* BFD protocol mode. */
+	BFD_PEER_NODE,		 /* BFD peer configuration mode. */
 	NODE_TYPE_MAX, /* maximum */
 };
 
@@ -223,6 +222,9 @@ struct cmd_node {
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, 0)            \
 	funcdecl_##funcname
 
+#define DEFPY_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
+	DEFPY(funcname, cmdname, cmdstr, helpstr)
+
 #define DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, attr)                   \
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attr, 0)         \
 	funcdecl_##funcname
@@ -243,9 +245,6 @@ struct cmd_node {
 #define DEFUN_HIDDEN(funcname, cmdname, cmdstr, helpstr)                       \
 	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN)
 
-#define DEFUN_DEPRECATED(funcname, cmdname, cmdstr, helpstr)                   \
-	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_DEPRECATED)
-
 /* DEFUN_NOSH for commands that vtysh should ignore */
 #define DEFUN_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
 	DEFUN(funcname, cmdname, cmdstr, helpstr)
@@ -308,6 +307,9 @@ struct cmd_node {
 #define DEFPY(funcname, cmdname, cmdstr, helpstr)                              \
 	DEFUN(funcname, cmdname, cmdstr, helpstr)
 
+#define DEFPY_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
+	DEFUN_NOSH(funcname, cmdname, cmdstr, helpstr)
+
 #define DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, attr)                   \
 	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, attr)
 #endif /* VTYSH_EXTRACT_PL */
@@ -344,6 +346,7 @@ struct cmd_node {
 #define UNDEBUG_STR "Disable debugging functions (see also 'debug')\n"
 #define ROUTER_STR "Enable a routing process\n"
 #define AS_STR "AS number\n"
+#define MAC_STR "MAC address\n"
 #define MBGP_STR "MBGP information\n"
 #define MATCH_STR "Match values from routing table\n"
 #define SET_STR "Set values in destination routing protocol\n"
@@ -419,6 +422,28 @@ extern int command_config_read_one_line(
 					int use_config_node);
 extern int config_from_file(struct vty *, FILE *, unsigned int *line_num);
 extern enum node_type node_parent(enum node_type);
+/*
+ * Execute command under the given vty context.
+ *
+ * vty
+ *    The vty context to execute under.
+ *
+ * cmd
+ *    The command string to execute.
+ *
+ * matched
+ *    If non-null and a match was found, the address of the matched command is
+ *    stored here. No action otherwise.
+ *
+ * vtysh
+ *    Whether or not this is being called from vtysh. If this is nonzero,
+ *    XXX: then what?
+ *
+ * Returns:
+ *    XXX: what does it return
+ */
+extern int cmd_execute(struct vty *vty, const char *cmd,
+		       const struct cmd_element **matched, int vtysh);
 extern int cmd_execute_command(vector, struct vty *,
 			       const struct cmd_element **, int);
 extern int cmd_execute_command_strict(vector, struct vty *,
@@ -460,4 +485,5 @@ extern void
 cmd_variable_handler_register(const struct cmd_variable_handler *cvh);
 extern char *cmd_variable_comp2str(vector comps, unsigned short cols);
 
+extern void command_setup_early_logging(const char *dest, const char *level);
 #endif /* _ZEBRA_COMMAND_H */
diff -urpN frr-frr-5.0.1/lib/command_match.c frr-frr-6.0/lib/command_match.c
--- frr-frr-5.0.1/lib/command_match.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/command_match.c	2018-10-08 14:32:57.000000000 +0200
@@ -608,11 +608,14 @@ static struct cmd_token *disambiguate_to
 static struct list *disambiguate(struct list *first, struct list *second,
 				 vector vline, unsigned int n)
 {
+	assert(first != NULL);
+	assert(second != NULL);
 	// doesn't make sense for these to be inequal length
 	assert(first->count == second->count);
 	assert(first->count == vector_active(vline) - n + 1);
 
-	struct listnode *fnode = listhead(first), *snode = listhead(second);
+	struct listnode *fnode = listhead_unchecked(first),
+			*snode = listhead_unchecked(second);
 	struct cmd_token *ftok = listgetdata(fnode), *stok = listgetdata(snode),
 			 *best = NULL;
 
diff -urpN frr-frr-5.0.1/lib/command_parse.y frr-frr-6.0/lib/command_parse.y
--- frr-frr-5.0.1/lib/command_parse.y	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/command_parse.y	2018-10-08 14:32:57.000000000 +0200
@@ -404,8 +404,8 @@ yyerror (CMD_YYLTYPE *loc, struct parser
   char spacing[256];
   int lineno = 0;
 
-  zlog_err ("%s: FATAL parse error: %s", __func__, msg);
-  zlog_err ("%s: %d:%d-%d of this command definition:", __func__, loc->first_line, loc->first_column, loc->last_column);
+  zlog_notice ("%s: FATAL parse error: %s", __func__, msg);
+  zlog_notice ("%s: %d:%d-%d of this command definition:", __func__, loc->first_line, loc->first_column, loc->last_column);
 
   line = tmpstr;
   do {
@@ -414,7 +414,7 @@ yyerror (CMD_YYLTYPE *loc, struct parser
     if (eol)
       *eol++ = '\0';
 
-    zlog_err ("%s: | %s", __func__, line);
+    zlog_notice ("%s: | %s", __func__, line);
     if (lineno == loc->first_line && lineno == loc->last_line
         && loc->first_column < (int)sizeof(spacing) - 1
         && loc->last_column < (int)sizeof(spacing) - 1) {
@@ -426,7 +426,7 @@ yyerror (CMD_YYLTYPE *loc, struct parser
       memset(spacing, ' ', loc->first_column - 1);
       memset(spacing + loc->first_column - 1, '^', len);
       spacing[loc->first_column - 1 + len] = '\0';
-      zlog_err ("%s: | %s", __func__, spacing);
+      zlog_notice ("%s: | %s", __func__, spacing);
     }
   } while ((line = eol));
   free(tmpstr);
diff -urpN frr-frr-5.0.1/lib/compiler.h frr-frr-6.0/lib/compiler.h
--- frr-frr-5.0.1/lib/compiler.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/compiler.h	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,9 @@
 #if __clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >= 5)
 #  define _RET_NONNULL    , returns_nonnull
 #endif
+#if __has_attribute(fallthrough)
+#  define _FALLTHROUGH __attribute__((fallthrough));
+#endif
 # define _CONSTRUCTOR(x)  constructor(x)
 #elif defined(__GNUC__)
 #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 9)
@@ -34,6 +37,9 @@
 #  define _DESTRUCTOR(x)  destructor(x)
 #  define _ALLOC_SIZE(x)  alloc_size(x)
 #endif
+#if __GNUC__ >= 7
+#  define _FALLTHROUGH __attribute__((fallthrough));
+#endif
 #endif
 
 #ifdef __sun
@@ -55,6 +61,9 @@
 #ifndef _ALLOC_SIZE
 # define _ALLOC_SIZE(x)
 #endif
+#ifndef _FALLTHROUGH
+#define _FALLTHROUGH
+#endif
 
 /*
  * for warnings on macros, put in the macro content like this:
@@ -76,6 +85,7 @@
 
 #else
 #define CPP_WARN(text)
+#define CPP_NOTICE(text)
 #endif
 
 #endif /* _FRR_COMPILER_H */
diff -urpN frr-frr-5.0.1/lib/csv.c frr-frr-6.0/lib/csv.c
--- frr-frr-5.0.1/lib/csv.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/csv.c	2018-10-08 14:32:57.000000000 +0200
@@ -663,8 +663,8 @@ int main()
 
 	log_verbose("Mem: %d\n", get_memory_usage(getpid()));
 	csv_init(&csv, buf, 256);
-	sprintf(hdr1, "%4u", 0);
-	sprintf(hdr2, "%4u", 1);
+	sprintf(hdr1, "%4d", 0);
+	sprintf(hdr2, "%4d", 1);
 	log_verbose("(%zu/%zu/%d/%d)\n", strlen(hdr1), strlen(hdr2), atoi(hdr1),
 		    atoi(hdr2));
 	rec = csv_encode(&csv, 2, hdr1, hdr2);
@@ -676,8 +676,8 @@ int main()
 	}
 	csv_encode(&csv, 2, "pdfadfadfadsadsaddfdfdsfdsd", "35444554545454545");
 	log_verbose("%s\n", buf);
-	sprintf(hdr1, "%4u", csv.csv_len);
-	sprintf(hdr2, "%4u", 1);
+	sprintf(hdr1, "%4d", csv.csv_len);
+	sprintf(hdr2, "%4d", 1);
 	log_verbose("(%zu/%zu/%d/%d)\n", strlen(hdr1), strlen(hdr2), atoi(hdr1),
 		    atoi(hdr2));
 	rec = csv_encode_record(&csv, rec, 2, hdr1, hdr2);
diff -urpN frr-frr-5.0.1/lib/defun_lex.l frr-frr-6.0/lib/defun_lex.l
--- frr-frr-5.0.1/lib/defun_lex.l	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/defun_lex.l	2018-10-08 14:32:57.000000000 +0200
@@ -132,6 +132,7 @@ SPECIAL		[(),]
 "DEFUN_NOSH"			value = strdup(yytext); return DEFUNNY;
 "DEFUN_HIDDEN"			value = strdup(yytext); return DEFUNNY;
 "DEFPY"				value = strdup(yytext); return DEFUNNY;
+"DEFPY_NOSH"			value = strdup(yytext); return DEFUNNY;
 "DEFPY_ATTR"			value = strdup(yytext); return DEFUNNY;
 "DEFPY_HIDDEN"			value = strdup(yytext); return DEFUNNY;
 "ALIAS"				value = strdup(yytext); return DEFUNNY;
diff -urpN frr-frr-5.0.1/lib/ferr.c frr-frr-6.0/lib/ferr.c
--- frr-frr-5.0.1/lib/ferr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/ferr.c	2018-10-08 14:32:57.000000000 +0200
@@ -19,14 +19,22 @@
 #include <string.h>
 #include <pthread.h>
 #include <signal.h>
+#include <inttypes.h>
 
 #include "ferr.h"
 #include "vty.h"
 #include "jhash.h"
 #include "memory.h"
+#include "hash.h"
+#include "command.h"
+#include "json.h"
+#include "linklist.h"
 
 DEFINE_MTYPE_STATIC(LIB, ERRINFO, "error information")
 
+/*
+ * Thread-specific key for temporary storage of allocated ferr.
+ */
 static pthread_key_t errkey;
 
 static void ferr_free(void *arg)
@@ -46,6 +54,160 @@ static void err_key_fini(void)
 	pthread_key_delete(errkey);
 }
 
+/*
+ * Global shared hash table holding reference text for all defined errors.
+ */
+pthread_mutex_t refs_mtx = PTHREAD_MUTEX_INITIALIZER;
+struct hash *refs;
+
+static int ferr_hash_cmp(const void *a, const void *b)
+{
+	const struct log_ref *f_a = a;
+	const struct log_ref *f_b = b;
+
+	return f_a->code == f_b->code;
+}
+
+static inline unsigned int ferr_hash_key(void *a)
+{
+	struct log_ref *f = a;
+
+	return f->code;
+}
+
+void log_ref_add(struct log_ref *ref)
+{
+	uint32_t i = 0;
+
+	pthread_mutex_lock(&refs_mtx);
+	{
+		while (ref[i].code != END_FERR) {
+			hash_get(refs, &ref[i], hash_alloc_intern);
+			i++;
+		}
+	}
+	pthread_mutex_unlock(&refs_mtx);
+}
+
+struct log_ref *log_ref_get(uint32_t code)
+{
+	struct log_ref holder;
+	struct log_ref *ref;
+
+	holder.code = code;
+	pthread_mutex_lock(&refs_mtx);
+	{
+		ref = hash_lookup(refs, &holder);
+	}
+	pthread_mutex_unlock(&refs_mtx);
+
+	return ref;
+}
+
+void log_ref_display(struct vty *vty, uint32_t code, bool json)
+{
+	struct log_ref *ref;
+	struct json_object *top = NULL, *obj = NULL;
+	struct list *errlist;
+	struct listnode *ln;
+
+	if (json)
+		top = json_object_new_object();
+
+	pthread_mutex_lock(&refs_mtx);
+	{
+		errlist = code ? list_new() : hash_to_list(refs);
+	}
+	pthread_mutex_unlock(&refs_mtx);
+
+	if (code) {
+		ref = log_ref_get(code);
+		if (!ref) {
+			vty_out(vty, "Code %"PRIu32" - Unknown\n", code);
+			return;
+		}
+		listnode_add(errlist, ref);
+	}
+
+	for (ALL_LIST_ELEMENTS_RO(errlist, ln, ref)) {
+		if (json) {
+			char key[11];
+
+			snprintf(key, sizeof(key), "%"PRIu32, ref->code);
+			obj = json_object_new_object();
+			json_object_string_add(obj, "title", ref->title);
+			json_object_string_add(obj, "description",
+					       ref->description);
+			json_object_string_add(obj, "suggestion",
+					       ref->suggestion);
+			json_object_object_add(top, key, obj);
+		} else {
+			char pbuf[256];
+			char ubuf[256];
+
+			snprintf(pbuf, sizeof(pbuf), "\nError %"PRIu32" - %s",
+				 ref->code, ref->title);
+			memset(ubuf, '=', strlen(pbuf));
+			ubuf[sizeof(ubuf) - 1] = '\0';
+
+			vty_out(vty, "%s\n%s\n", pbuf, ubuf);
+			vty_out(vty, "Description:\n%s\n\n", ref->description);
+			vty_out(vty, "Recommendation:\n%s\n", ref->suggestion);
+		}
+	}
+
+	if (json) {
+		const char *str = json_object_to_json_string_ext(
+			top, JSON_C_TO_STRING_PRETTY);
+		vty_out(vty, "%s\n", str);
+		json_object_free(top);
+	}
+
+	list_delete_and_null(&errlist);
+}
+
+DEFUN_NOSH(show_error_code,
+	   show_error_code_cmd,
+	   "show error <(1-4294967296)|all> [json]",
+	   SHOW_STR
+	   "Information on errors\n"
+	   "Error code to get info about\n"
+	   "Information on all errors\n"
+	   JSON_STR)
+{
+	bool json = strmatch(argv[argc-1]->text, "json");
+	uint32_t arg = 0;
+
+	if (!strmatch(argv[2]->text, "all"))
+		arg = strtoul(argv[2]->arg, NULL, 10);
+
+	log_ref_display(vty, arg, json);
+	return CMD_SUCCESS;
+}
+
+void log_ref_init(void)
+{
+	pthread_mutex_lock(&refs_mtx);
+	{
+		refs = hash_create(ferr_hash_key, ferr_hash_cmp,
+				   "Error Reference Texts");
+	}
+	pthread_mutex_unlock(&refs_mtx);
+
+	install_element(VIEW_NODE, &show_error_code_cmd);
+}
+
+void log_ref_fini(void)
+{
+	pthread_mutex_lock(&refs_mtx);
+	{
+		hash_clean(refs, NULL);
+		hash_free(refs);
+		refs = NULL;
+	}
+	pthread_mutex_unlock(&refs_mtx);
+}
+
 const struct ferr *ferr_get_last(ferr_r errval)
 {
 	struct ferr *last_error = pthread_getspecific(errkey);
@@ -70,13 +232,6 @@ static ferr_r ferr_set_va(const char *fi
 
 	if (!error) {
 		error = XCALLOC(MTYPE_ERRINFO, sizeof(*error));
-		if (!error) {
-			/* we're screwed */
-			zlog_err("out of memory while allocating error info");
-			raise(SIGSEGV);
-			abort(); /* raise() can return, but raise(SIGSEGV) shall
-				    not */
-		}
 
 		pthread_setspecific(errkey, error);
 	}
diff -urpN frr-frr-5.0.1/lib/ferr.h frr-frr-6.0/lib/ferr.h
--- frr-frr-5.0.1/lib/ferr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/ferr.h	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,8 @@
 #include <limits.h>
 #include <errno.h>
 
+#include "vty.h"
+
 /* return type when this error indication stuff is used.
  *
  * guaranteed to have boolean evaluation to "false" when OK, "true" when error
@@ -93,6 +95,66 @@ struct ferr {
 	char pathname[PATH_MAX];
 };
 
+/* Numeric ranges assigned to daemons for use as error codes. */
+#define BABEL_FERR_START    0x01000001
+#define BABEL_FRRR_END      0x01FFFFFF
+#define BGP_FERR_START      0x02000001
+#define BGP_FERR_END        0x02FFFFFF
+#define EIGRP_FERR_START    0x03000001
+#define EIGRP_FERR_END      0x03FFFFFF
+#define ISIS_FERR_START     0x04000001
+#define ISIS_FERR_END       0x04FFFFFF
+#define LDP_FERR_START      0x05000001
+#define LDP_FERR_END        0x05FFFFFF
+#define LIB_FERR_START      0x06000001
+#define LIB_FERR_END        0x06FFFFFF
+#define NHRP_FERR_START     0x07000001
+#define NHRP_FERR_END       0x07FFFFFF
+#define OSPF_FERR_START     0x08000001
+#define OSPF_FERR_END       0x08FFFFFF
+#define OSPFV3_FERR_START   0x09000001
+#define OSPFV3_FERR_END     0x09FFFFFF
+#define PBR_FERR_START      0x0A000001
+#define PBR_FERR_END        0x0AFFFFFF
+#define PIM_FERR_START      0x0B000001
+#define PIM_FERR_STOP       0x0BFFFFFF
+#define RIP_FERR_START      0x0C000001
+#define RIP_FERR_STOP       0x0CFFFFFF
+#define RIPNG_FERR_START    0x0D000001
+#define RIPNG_FERR_STOP     0x0DFFFFFF
+#define SHARP_FERR_START    0x0E000001
+#define SHARP_FERR_END      0x0EFFFFFF
+#define VTYSH_FERR_START    0x0F000001
+#define VTYSH_FRR_END       0x0FFFFFFF
+#define WATCHFRR_FERR_START 0x10000001
+#define WATCHFRR_FERR_END   0x10FFFFFF
+#define ZEBRA_FERR_START    0xF1000001
+#define ZEBRA_FERR_END      0xF1FFFFFF
+#define END_FERR            0xFFFFFFFF
+
+struct log_ref {
+	/* Unique error code displayed to end user as a reference. -1 means
+	 * this is an uncoded error that does not have reference material. */
+	uint32_t code;
+	/* Ultra brief title */
+	const char *title;
+	/* Brief description of error */
+	const char *description;
+	/* Remedial suggestion */
+	const char *suggestion;
+};
+
+void log_ref_add(struct log_ref *ref);
+struct log_ref *log_ref_get(uint32_t code);
+void log_ref_display(struct vty *vty, uint32_t code, bool json);
+
+/*
+ * This function should be called by the
+ * code in libfrr.c
+ */
+void log_ref_init(void);
+void log_ref_fini(void);
+
 /* get error details.
  *
  * NB: errval/ferr_r does NOT carry the full error information.  It's only
@@ -101,8 +163,10 @@ struct ferr {
  */
 const struct ferr *ferr_get_last(ferr_r errval);
 
-/* can optionally be called at strategic locations.
- * always returns 0. */
+/*
+ * Can optionally be called at strategic locations.
+ * Always returns 0.
+ */
 ferr_r ferr_clear(void);
 
 /* do NOT call these functions directly.  only for macro use! */
diff -urpN frr-frr-5.0.1/lib/filter.c frr-frr-6.0/lib/filter.c
--- frr-frr-5.0.1/lib/filter.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/filter.c	2018-10-08 14:32:57.000000000 +0200
@@ -157,7 +157,7 @@ static const char *filter_type_str(struc
 }
 
 /* If filter match to the prefix then return 1. */
-static int filter_match_cisco(struct filter *mfilter, struct prefix *p)
+static int filter_match_cisco(struct filter *mfilter, const struct prefix *p)
 {
 	struct filter_cisco *filter;
 	struct in_addr mask;
@@ -181,7 +181,7 @@ static int filter_match_cisco(struct fil
 }
 
 /* If filter match to the prefix then return 1. */
-static int filter_match_zebra(struct filter *mfilter, struct prefix *p)
+static int filter_match_zebra(struct filter *mfilter, const struct prefix *p)
 {
 	struct filter_zebra *filter = NULL;
 
@@ -372,10 +372,11 @@ static struct access_list *access_list_g
 }
 
 /* Apply access list to object (which should be struct prefix *). */
-enum filter_type access_list_apply(struct access_list *access, void *object)
+enum filter_type access_list_apply(struct access_list *access,
+				   const void *object)
 {
 	struct filter *filter;
-	struct prefix *p = (struct prefix *)object;
+	const struct prefix *p = (const struct prefix *)object;
 
 	if (access == NULL)
 		return FILTER_DENY;
@@ -549,8 +550,7 @@ static int vty_access_list_remark_unset(
 		access->remark = NULL;
 	}
 
-	if (access->head == NULL && access->tail == NULL
-	    && access->remark == NULL)
+	if (access->head == NULL && access->tail == NULL)
 		access_list_delete(access);
 
 	return CMD_SUCCESS;
diff -urpN frr-frr-5.0.1/lib/filter.h frr-frr-6.0/lib/filter.h
--- frr-frr-5.0.1/lib/filter.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/filter.h	2018-10-08 14:32:57.000000000 +0200
@@ -59,6 +59,7 @@ extern void access_list_reset(void);
 extern void access_list_add_hook(void (*func)(struct access_list *));
 extern void access_list_delete_hook(void (*func)(struct access_list *));
 extern struct access_list *access_list_lookup(afi_t, const char *);
-extern enum filter_type access_list_apply(struct access_list *, void *);
+extern enum filter_type access_list_apply(struct access_list *access,
+					  const void *object);
 
 #endif /* _ZEBRA_FILTER_H */
diff -urpN frr-frr-5.0.1/lib/frr_pthread.c frr-frr-6.0/lib/frr_pthread.c
--- frr-frr-5.0.1/lib/frr_pthread.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/frr_pthread.c	2018-10-08 14:32:57.000000000 +0200
@@ -269,12 +269,37 @@ static int fpt_halt(struct frr_pthread *
 {
 	thread_add_event(fpt->master, &fpt_finish, fpt, 0, NULL);
 	pthread_join(fpt->thread, res);
-	fpt = NULL;
 
 	return 0;
 }
 
-/* entry pthread function & main event loop */
+/*
+ * Entry pthread function & main event loop.
+ *
+ * Upon thread start the following actions occur:
+ *
+ * - frr_pthread's owner field is set to pthread ID.
+ * - All signals are blocked (except for unblockable signals).
+ * - Pthread's threadmaster is set to never handle pending signals
+ * - Poker pipe for poll() is created and queued as I/O source
+ * - The frr_pthread->running_cond condition variable is signalled to indicate
+ *   that the previous actions have completed. It is not safe to assume any of
+ *   the above have occurred before receiving this signal.
+ *
+ * After initialization is completed, the event loop begins running. Each tick,
+ * the following actions are performed before running the usual event system
+ * tick function:
+ *
+ * - Verify that the running boolean is set
+ * - Verify that there are no pending cancellation requests
+ * - Verify that there are tasks scheduled
+ *
+ * So long as the conditions are met, the event loop tick is run and the
+ * returned task is executed.
+ *
+ * If any of these conditions are not met, the event loop exits, closes the
+ * pipes and dies without running any cleanup functions.
+ */
 static void *fpt_run(void *arg)
 {
 	struct frr_pthread *fpt = arg;
@@ -290,6 +315,7 @@ static void *fpt_run(void *arg)
 
 	struct thread task;
 	while (atomic_load_explicit(&fpt->running, memory_order_relaxed)) {
+		pthread_testcancel();
 		if (thread_fetch(fpt->master, &task)) {
 			thread_call(&task);
 		}
diff -urpN frr-frr-5.0.1/lib/frr_zmq.c frr-frr-6.0/lib/frr_zmq.c
--- frr-frr-5.0.1/lib/frr_zmq.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/frr_zmq.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include "memory.h"
 #include "frr_zmq.h"
 #include "log.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, ZEROMQ_CB, "ZeroMQ callback")
 
@@ -140,7 +141,8 @@ static int frrzmq_read_msg(struct thread
 	return 0;
 
 out_err:
-	zlog_err("ZeroMQ read error: %s(%d)", strerror(errno), errno);
+	flog_err(LIB_ERR_ZMQ, "ZeroMQ read error: %s(%d)", strerror(errno),
+		  errno);
 	if (cb->read.cb_error)
 		cb->read.cb_error(cb->read.arg, cb->zmqsock);
 	return 1;
@@ -174,9 +176,10 @@ int funcname_frrzmq_thread_add_read(stru
 		cb = *cbp;
 	else {
 		cb = XCALLOC(MTYPE_ZEROMQ_CB, sizeof(struct frrzmq_cb));
-		cb->write.cancelled = 1;
 		if (!cb)
 			return -1;
+
+		cb->write.cancelled = 1;
 		*cbp = cb;
 	}
 
@@ -252,7 +255,8 @@ static int frrzmq_write_msg(struct threa
 	return 0;
 
 out_err:
-	zlog_err("ZeroMQ write error: %s(%d)", strerror(errno), errno);
+	flog_err(LIB_ERR_ZMQ, "ZeroMQ write error: %s(%d)", strerror(errno),
+		  errno);
 	if (cb->write.cb_error)
 		cb->write.cb_error(cb->write.arg, cb->zmqsock);
 	return 1;
@@ -282,9 +286,10 @@ int funcname_frrzmq_thread_add_write(str
 		cb = *cbp;
 	else {
 		cb = XCALLOC(MTYPE_ZEROMQ_CB, sizeof(struct frrzmq_cb));
-		cb->read.cancelled = 1;
 		if (!cb)
 			return -1;
+
+		cb->read.cancelled = 1;
 		*cbp = cb;
 	}
 
diff -urpN frr-frr-5.0.1/lib/frrstr.c frr-frr-6.0/lib/frrstr.c
--- frr-frr-5.0.1/lib/frrstr.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/lib/frrstr.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,171 @@
+/*
+ * FRR string processing utilities.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Quentin Young
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <string.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <regex.h>
+
+#include "frrstr.h"
+#include "memory.h"
+#include "vector.h"
+
+void frrstr_split(const char *string, const char *delimiter, char ***result,
+		  int *argc)
+{
+	if (!string)
+		return;
+
+	unsigned int sz = 4, idx = 0;
+	char *copy, *copystart;
+	*result = XCALLOC(MTYPE_TMP, sizeof(char *) * sz);
+	copystart = copy = XSTRDUP(MTYPE_TMP, string);
+	*argc = 0;
+
+	const char *tok = NULL;
+
+	while (copy) {
+		tok = strsep(&copy, delimiter);
+		(*result)[idx] = XSTRDUP(MTYPE_TMP, tok);
+		if (++idx == sz)
+			*result = XREALLOC(MTYPE_TMP, *result,
+					   (sz *= 2) * sizeof(char *));
+		(*argc)++;
+	}
+
+	XFREE(MTYPE_TMP, copystart);
+}
+
+vector frrstr_split_vec(const char *string, const char *delimiter)
+{
+	char **result;
+	int argc;
+
+	if (!string)
+		return NULL;
+
+	frrstr_split(string, delimiter, &result, &argc);
+
+	vector v = array_to_vector((void **)result, argc);
+
+	XFREE(MTYPE_TMP, result);
+
+	return v;
+}
+
+char *frrstr_join(const char **parts, int argc, const char *join)
+{
+	int i;
+	char *str;
+	char *p;
+	size_t len = 0;
+	size_t joinlen = join ? strlen(join) : 0;
+
+	if (!argc)
+		return NULL;
+
+	for (i = 0; i < argc; i++)
+		len += strlen(parts[i]);
+	len += argc * joinlen + 1;
+
+	if (!len)
+		return NULL;
+
+	p = str = XMALLOC(MTYPE_TMP, len);
+
+	for (i = 0; i < argc; i++) {
+		size_t arglen = strlen(parts[i]);
+
+		memcpy(p, parts[i], arglen);
+		p += arglen;
+		if (i + 1 != argc && join) {
+			memcpy(p, join, joinlen);
+			p += joinlen;
+		}
+	}
+
+	*p = '\0';
+
+	return str;
+}
+
+char *frrstr_join_vec(vector v, const char *join)
+{
+	char **argv;
+	int argc;
+
+	vector_to_array(v, (void ***)&argv, &argc);
+
+	char *ret = frrstr_join((const char **)argv, argc, join);
+
+	XFREE(MTYPE_TMP, argv);
+
+	return ret;
+}
+
+void frrstr_filter_vec(vector v, regex_t *filter)
+{
+	regmatch_t ignored[1];
+
+	for (unsigned int i = 0; i < vector_active(v); i++) {
+		if (regexec(filter, vector_slot(v, i), 0, ignored, 0)) {
+			XFREE(MTYPE_TMP, vector_slot(v, i));
+			vector_unset(v, i);
+		}
+	}
+}
+
+void frrstr_strvec_free(vector v)
+{
+	unsigned int i;
+	char *cp;
+
+	if (!v)
+		return;
+
+	for (i = 0; i < vector_active(v); i++) {
+		cp = vector_slot(v, i);
+		XFREE(MTYPE_TMP, cp);
+	}
+
+	vector_free(v);
+}
+
+bool begins_with(const char *str, const char *prefix)
+{
+	if (!str || !prefix)
+		return 0;
+
+	size_t lenstr = strlen(str);
+	size_t lenprefix = strlen(prefix);
+
+	if (lenprefix > lenstr)
+		return 0;
+
+	return strncmp(str, prefix, lenprefix) == 0;
+}
+
+int all_digit(const char *str)
+{
+	for (; *str != '\0'; str++)
+		if (!isdigit((int)*str))
+			return 0;
+	return 1;
+}
diff -urpN frr-frr-5.0.1/lib/frrstr.h frr-frr-6.0/lib/frrstr.h
--- frr-frr-5.0.1/lib/frrstr.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/lib/frrstr.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ * FRR string processing utilities.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Quentin Young
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _FRRSTR_H_
+#define _FRRSTR_H_
+
+#include <sys/types.h>
+#include <regex.h>
+#include <stdbool.h>
+
+#include "vector.h"
+
+/*
+ * Tokenizes a string, storing tokens in a vector. Whitespace is ignored.
+ * Delimiter characters are not included.
+ *
+ * string
+ *    The string to split
+ *
+ * delimiter
+ *    Delimiter string, as used in strsep()
+ *
+ * Returns:
+ *    The split string. Each token is allocated with MTYPE_TMP.
+ */
+void frrstr_split(const char *string, const char *delimiter, char ***result,
+		  int *argc);
+vector frrstr_split_vec(const char *string, const char *delimiter);
+
+/*
+ * Concatenate string array into a single string.
+ *
+ * argv
+ *    array of string pointers to concatenate
+ *
+ * argc
+ *    array length
+ *
+ * join
+ *    string to insert between each part, or NULL for nothing
+ *
+ * Returns:
+ *    the joined string, allocated with MTYPE_TMP
+ */
+char *frrstr_join(const char **parts, int argc, const char *join);
+char *frrstr_join_vec(vector v, const char *join);
+
+/*
+ * Filter string vector.
+ * Removes lines that do not contain a match for the provided regex.
+ *
+ * v
+ *    The vector to filter.
+ *
+ * filter
+ *    Regex to filter with.
+ */
+void frrstr_filter_vec(vector v, regex_t *filter);
+
+/*
+ * Free allocated string vector.
+ * Assumes each item is allocated with MTYPE_TMP.
+ *
+ * v
+ *    the vector to free
+ */
+void frrstr_strvec_free(vector v);
+
+/*
+ * Prefix match for string.
+ *
+ * str
+ *    string to check for prefix match
+ *
+ * prefix
+ *    prefix to look for
+ *
+ * Returns:
+ *   true str starts with prefix, false otherwise
+ */
+bool begins_with(const char *str, const char *prefix);
+
+/*
+ * Check the string only contains digit characters.
+ *
+ * str
+ *    string to check for digits
+ *
+ * Returns:
+ *    1 str only contains digit characters, 0 otherwise
+ */
+int all_digit(const char *str);
+
+#endif /* _FRRSTR_H_ */
diff -urpN frr-frr-5.0.1/lib/graph.c frr-frr-6.0/lib/graph.c
--- frr-frr-5.0.1/lib/graph.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/graph.c	2018-10-08 14:32:57.000000000 +0200
@@ -60,7 +60,7 @@ struct graph_node *graph_new_node(struct
 	return node;
 }
 
-static void vector_remove(vector v, unsigned int ix)
+static void graph_vector_remove(vector v, unsigned int ix)
 {
 	if (ix >= v->active)
 		return;
@@ -105,7 +105,7 @@ void graph_delete_node(struct graph *gra
 	// remove node from graph->nodes
 	for (unsigned int i = vector_active(graph->nodes); i--; /**/)
 		if (vector_slot(graph->nodes, i) == node) {
-			vector_remove(graph->nodes, i);
+			graph_vector_remove(graph->nodes, i);
 			break;
 		}
 
@@ -126,13 +126,13 @@ void graph_remove_edge(struct graph_node
 	// remove from from to->from
 	for (unsigned int i = vector_active(to->from); i--; /**/)
 		if (vector_slot(to->from, i) == from) {
-			vector_remove(to->from, i);
+			graph_vector_remove(to->from, i);
 			break;
 		}
 	// remove to from from->to
 	for (unsigned int i = vector_active(from->to); i--; /**/)
 		if (vector_slot(from->to, i) == to) {
-			vector_remove(from->to, i);
+			graph_vector_remove(from->to, i);
 			break;
 		}
 }
diff -urpN frr-frr-5.0.1/lib/hash.c frr-frr-6.0/lib/hash.c
--- frr-frr-5.0.1/lib/hash.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/hash.c	2018-10-08 14:32:57.000000000 +0200
@@ -36,7 +36,6 @@ DEFINE_MTYPE_STATIC(LIB, HASH_INDEX, "Ha
 pthread_mutex_t _hashes_mtx = PTHREAD_MUTEX_INITIALIZER;
 static struct list *_hashes;
 
-/* Allocate a new hash.  */
 struct hash *hash_create_size(unsigned int size,
 			      unsigned int (*hash_key)(void *),
 			      int (*hash_cmp)(const void *, const void *),
@@ -67,7 +66,6 @@ struct hash *hash_create_size(unsigned i
 	return hash;
 }
 
-/* Allocate a new hash with default hash size.  */
 struct hash *hash_create(unsigned int (*hash_key)(void *),
 			 int (*hash_cmp)(const void *, const void *),
 			 const char *name)
@@ -75,9 +73,6 @@ struct hash *hash_create(unsigned int (*
 	return hash_create_size(HASH_INITIAL_SIZE, hash_key, hash_cmp, name);
 }
 
-/* Utility function for hash_get().  When this function is specified
-   as alloc_func, return arugment as it is.  This function is used for
-   intern already allocated value.  */
 void *hash_alloc_intern(void *arg)
 {
 	return arg;
@@ -133,9 +128,6 @@ static void hash_expand(struct hash *has
 	hash->index = new_index;
 }
 
-/* Lookup and return hash backet in hash.  If there is no
-   corresponding hash backet and alloc_func is specified, create new
-   hash backet.  */
 void *hash_get(struct hash *hash, void *data, void *(*alloc_func)(void *))
 {
 	unsigned int key;
@@ -189,13 +181,11 @@ void *hash_get(struct hash *hash, void *
 	return NULL;
 }
 
-/* Hash lookup.  */
 void *hash_lookup(struct hash *hash, void *data)
 {
 	return hash_get(hash, data, NULL);
 }
 
-/* Simple Bernstein hash which is simple and fast for common case */
 unsigned int string_hash_make(const char *str)
 {
 	unsigned int hash = 0;
@@ -206,9 +196,6 @@ unsigned int string_hash_make(const char
 	return hash;
 }
 
-/* This function release registered value from specified hash.  When
-   release is successfully finished, return the data pointer in the
-   hash backet.  */
 void *hash_release(struct hash *hash, void *data)
 {
 	void *ret;
@@ -248,7 +235,6 @@ void *hash_release(struct hash *hash, vo
 	return NULL;
 }
 
-/* Iterator function for hash.  */
 void hash_iterate(struct hash *hash, void (*func)(struct hash_backet *, void *),
 		  void *arg)
 {
@@ -266,7 +252,6 @@ void hash_iterate(struct hash *hash, voi
 		}
 }
 
-/* Iterator function for hash.  */
 void hash_walk(struct hash *hash, int (*func)(struct hash_backet *, void *),
 	       void *arg)
 {
@@ -288,7 +273,6 @@ void hash_walk(struct hash *hash, int (*
 	}
 }
 
-/* Clean up hash.  */
 void hash_clean(struct hash *hash, void (*free_func)(void *))
 {
 	unsigned int i;
@@ -312,8 +296,21 @@ void hash_clean(struct hash *hash, void
 	hash->stats.empty = hash->size;
 }
 
-/* Free hash memory.  You may call hash_clean before call this
-   function.  */
+static void hash_to_list_iter(struct hash_backet *hb, void *arg)
+{
+	struct list *list = arg;
+
+	listnode_add(list, hb->data);
+}
+
+struct list *hash_to_list(struct hash *hash)
+{
+	struct list *list = list_new();
+
+	hash_iterate(hash, hash_to_list_iter, list);
+	return list;
+}
+
 void hash_free(struct hash *hash)
 {
 	pthread_mutex_lock(&_hashes_mtx);
diff -urpN frr-frr-5.0.1/lib/hash.h frr-frr-6.0/lib/hash.h
--- frr-frr-5.0.1/lib/hash.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/hash.h	2018-10-08 14:32:57.000000000 +0200
@@ -36,9 +36,10 @@ DECLARE_MTYPE(HASH_BACKET)
 #define HASHWALK_ABORT -1
 
 struct hash_backet {
-	/* if this backet is the head of the linked listed, len denotes the
-	 * number of
-	 * elements in the list */
+	/*
+	 * if this backet is the head of the linked listed, len denotes the
+	 * number of elements in the list
+	 */
 	int len;
 
 	/* Linked list.  */
@@ -85,29 +86,242 @@ struct hash {
 
 #define hashcount(X) ((X)->count)
 
-extern struct hash *hash_create(unsigned int (*)(void *),
-				int (*)(const void *, const void *),
-				const char *);
-extern struct hash *hash_create_size(unsigned int, unsigned int (*)(void *),
-				     int (*)(const void *, const void *),
-				     const char *);
-
-extern void *hash_get(struct hash *, void *, void *(*)(void *));
-extern void *hash_alloc_intern(void *);
-extern void *hash_lookup(struct hash *, void *);
-extern void *hash_release(struct hash *, void *);
-
-extern void hash_iterate(struct hash *, void (*)(struct hash_backet *, void *),
-			 void *);
-
-extern void hash_walk(struct hash *, int (*)(struct hash_backet *, void *),
-		      void *);
-
-extern void hash_clean(struct hash *, void (*)(void *));
-extern void hash_free(struct hash *);
-
+/*
+ * Create a hash table.
+ *
+ * The created hash table uses chaining and a user-provided comparator function
+ * to resolve collisions. For best performance use a perfect hash function.
+ * Worst case lookup time is O(N) when using a constant hash function. Best
+ * case lookup time is O(1) when using a perfect hash function.
+ *
+ * The initial size of the created hash table is HASH_INITIAL_SIZE.
+ *
+ * hash_key
+ *    hash function to use; should return a unique unsigned integer when called
+ *    with a data item. Collisions are acceptable.
+ *
+ * hash_cmp
+ *    comparison function used for resolving collisions; when called with two
+ *    data items, should return nonzero if the two items are equal and 0
+ *    otherwise
+ *
+ * name
+ *    optional name for the hashtable; this is used when displaying global
+ *    hashtable statistics. If this parameter is NULL the hash's name will be
+ *    set to NULL and the default name will be displayed when showing
+ *    statistics.
+ *
+ * Returns:
+ *    a new hash table
+ */
+extern struct hash *hash_create(unsigned int (*hash_key)(void *),
+				int (*hash_cmp)(const void *, const void *),
+				const char *name);
+
+/*
+ * Create a hash table.
+ *
+ * The created hash table uses chaining and a user-provided comparator function
+ * to resolve collisions. For best performance use a perfect hash function.
+ * Worst case lookup time is O(N) when using a constant hash function. Best
+ * case lookup time is O(1) when using a perfect hash function.
+ *
+ * size
+ *    initial number of hash buckets to allocate; must be a power of 2 or the
+ *    program will assert
+ *
+ * hash_key
+ *    hash function to use; should return a unique unsigned integer when called
+ *    with a data item. Collisions are acceptable.
+ *
+ * hash_cmp
+ *    comparison function used for resolving collisions; when called with two
+ *    data items, should return nonzero if the two items are equal and 0
+ *    otherwise
+ *
+ * name
+ *    optional name for the hashtable; this is used when displaying global
+ *    hashtable statistics. If this parameter is NULL the hash's name will be
+ *    set to NULL and the default name will be displayed when showing
+ *    statistics.
+ *
+ * Returns:
+ *    a new hash table
+ */
+extern struct hash *
+hash_create_size(unsigned int size, unsigned int (*hash_key)(void *),
+		 int (*hash_cmp)(const void *, const void *), const char *name);
+
+/*
+ * Retrieve or insert data from / into a hash table.
+ *
+ * This function is somewhat counterintuitive in its usage. In order to look up
+ * an element from its key, you must provide the data item itself, with the
+ * portions used in the hash function set to the same values as the data item
+ * to retrieve. To insert a data element, either provide the key as just
+ * described and provide alloc_func as descrbied below to allocate the full
+ * data element, or provide the full data element and pass 'hash_alloc_intern'
+ * to alloc_func.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * data
+ *    data to insert or retrieve - A hash backet will not be created if
+ *    the alloc_func returns a NULL pointer and nothing will be added to
+ *    the hash.  As such backet->data will always be non-NULL.
+ *
+ * alloc_func
+ *    function to call if the item is not found in the hash table. This
+ *    function is called with the value of 'data' and should create the data
+ *    item to insert and return a pointer to it. If the data has already been
+ *    completely created and provided in the 'data' parameter, passing
+ *    'hash_alloc_intern' to this parameter will cause 'data' to be inserted.
+ *    If this parameter is NULL, then this call to hash_get is equivalent to
+ *    hash_lookup.
+ *
+ * Returns:
+ *    the data item found or inserted, or NULL if alloc_func is NULL and the
+ *    data is not found
+ */
+extern void *hash_get(struct hash *hash, void *data,
+		      void *(*alloc_func)(void *));
+
+/*
+ * Dummy element allocation function.
+ *
+ * See hash_get for details.
+ *
+ * data
+ *    data to insert into the hash table
+ *
+ * Returns:
+ *    data
+ */
+extern void *hash_alloc_intern(void *data);
+
+/*
+ * Retrieve an item from a hash table.
+ *
+ * This function is equivalent to calling hash_get with alloc_func set to NULL.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * data
+ *    data element with values used for key computation set
+ *
+ * Returns:
+ *    the data element if found, or NULL if not found
+ */
+extern void *hash_lookup(struct hash *hash, void *data);
+
+/*
+ * Remove an element from a hash table.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * data
+ *    data element to remove with values used for key computation set
+ *
+ * Returns:
+ *    the removed element if found, or NULL if not found
+ */
+extern void *hash_release(struct hash *hash, void *data);
+
+/*
+ * Iterate over the elements in a hash table.
+ *
+ * It is safe to delete items passed to the iteration function from the hash
+ * table during iteration.  Please note that adding entries to the hash
+ * during the walk will cause undefined behavior in that some new entries
+ * will be walked and some will not.  So do not do this.
+ *
+ * The backet passed to func will have a non-NULL data pointer.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * func
+ *    function to call with each data item
+ *
+ * arg
+ *    arbitrary argument passed as the second parameter in each call to 'func'
+ */
+extern void hash_iterate(struct hash *hash,
+			 void (*func)(struct hash_backet *, void *), void *arg);
+
+/*
+ * Iterate over the elements in a hash table, stopping on condition.
+ *
+ * It is safe to delete items passed to the iteration function from the hash
+ * table during iteration.  Please note that adding entries to the hash
+ * during the walk will cause undefined behavior in that some new entries
+ * will be walked and some will not.  So do not do this.
+ *
+ * The backet passed to func will have a non-NULL data pointer.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * func
+ *    function to call with each data item. If this function returns
+ *    HASHWALK_ABORT then the iteration stops.
+ *
+ * arg
+ *    arbitrary argument passed as the second parameter in each call to 'func'
+ */
+extern void hash_walk(struct hash *hash,
+		      int (*func)(struct hash_backet *, void *), void *arg);
+
+/*
+ * Remove all elements from a hash table.
+ *
+ * hash
+ *    hash table to operate on
+ *
+ * free_func
+ *    function to call with each removed item; intended to free the data
+ */
+extern void hash_clean(struct hash *hash, void (*free_func)(void *));
+
+/*
+ * Delete a hash table.
+ *
+ * This function assumes the table is empty. Call hash_clean to delete the
+ * hashtable contents if necessary.
+ *
+ * hash
+ *    hash table to delete
+ */
+extern void hash_free(struct hash *hash);
+
+/*
+ * Converts a hash table to an unsorted linked list.
+ * Does not modify the hash table in any way.
+ *
+ * hash
+ *    hash table to convert
+ */
+extern struct list *hash_to_list(struct hash *hash);
+
+/*
+ * Hash a string using the modified Bernstein hash.
+ *
+ * This is not a perfect hash function.
+ *
+ * str
+ *    string to hash
+ *
+ * Returns:
+ *    modified Bernstein hash of the string
+ */
 extern unsigned int string_hash_make(const char *);
 
+/*
+ * Install CLI commands for viewing global hash table statistics.
+ */
 extern void hash_cmd_init(void);
 
 #endif /* _ZEBRA_HASH_H */
diff -urpN frr-frr-5.0.1/lib/if.c frr-frr-6.0/lib/if.c
--- frr-frr-5.0.1/lib/if.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/if.c	2018-10-08 14:32:57.000000000 +0200
@@ -23,6 +23,7 @@
 
 #include "linklist.h"
 #include "vector.h"
+#include "lib_errors.h"
 #include "vty.h"
 #include "command.h"
 #include "vrf.h"
@@ -222,18 +223,6 @@ struct interface *if_lookup_by_index(ifi
 	struct vrf *vrf;
 	struct interface if_tmp;
 
-	if (vrf_id == VRF_UNKNOWN) {
-		struct interface *ifp;
-
-		RB_FOREACH (vrf, vrf_id_head, &vrfs_by_id) {
-			ifp = if_lookup_by_index(ifindex, vrf->vrf_id);
-			if (ifp)
-				return ifp;
-		}
-
-		return NULL;
-	}
-
 	vrf = vrf_lookup_by_id(vrf_id);
 	if (!vrf)
 		return NULL;
@@ -404,7 +393,8 @@ struct interface *if_get_by_name(const c
 	 * this should not be considered as an update
 	 * then create the new interface
 	 */
-	if (ifp->vrf_id != vrf_id && vrf_is_mapped_on_netns(vrf_id))
+	if (ifp->vrf_id != vrf_id && vrf_is_mapped_on_netns(
+					vrf_lookup_by_id(vrf_id)))
 		return if_create(name, vrf_id);
 	/* If it came from the kernel
 	 * or by way of zclient, believe it and update
@@ -482,6 +472,14 @@ int if_is_vrf(struct interface *ifp)
 	return CHECK_FLAG(ifp->status, ZEBRA_INTERFACE_VRF_LOOPBACK);
 }
 
+bool if_is_loopback_or_vrf(struct interface *ifp)
+{
+	if (if_is_loopback(ifp) || if_is_vrf(ifp))
+		return true;
+
+	return false;
+}
+
 /* Does this interface support broadcast ? */
 int if_is_broadcast(struct interface *ifp)
 {
@@ -638,7 +636,7 @@ static struct interface *if_sunwzebra_ge
 }
 #endif /* SUNOS_5 */
 
-DEFUN (interface,
+DEFUN_NOSH (interface,
        interface_cmd,
        "interface IFNAME [vrf NAME]",
        "Select an interface to configure\n"
@@ -664,7 +662,7 @@ DEFUN (interface,
 	/*Pending: need proper vrf name based lookup/(possible creation of VRF)
 	 Imagine forward reference of a vrf by name in this interface config */
 	if (vrfname)
-		VRF_GET_ID(vrf_id, vrfname);
+		VRF_GET_ID(vrf_id, vrfname, false);
 
 #ifdef SUNOS_5
 	ifp = if_sunwzebra_get(ifname, vrf_id);
@@ -681,13 +679,13 @@ DEFUN (interface,
 	return CMD_SUCCESS;
 }
 
-DEFUN_NOSH (no_interface,
-           no_interface_cmd,
-           "no interface IFNAME [vrf NAME]",
-           NO_STR
-           "Delete a pseudo interface's configuration\n"
-           "Interface's name\n"
-           VRF_CMD_HELP_STR)
+DEFUN (no_interface,
+       no_interface_cmd,
+       "no interface IFNAME [vrf NAME]",
+       NO_STR
+       "Delete a pseudo interface's configuration\n"
+       "Interface's name\n"
+       VRF_CMD_HELP_STR)
 {
 	int idx_vrf = 4;
 	const char *ifname = argv[2]->arg;
@@ -698,7 +696,7 @@ DEFUN_NOSH (no_interface,
 	vrf_id_t vrf_id = VRF_DEFAULT;
 
 	if (argc > 3)
-		VRF_GET_ID(vrf_id, vrfname);
+		VRF_GET_ID(vrf_id, vrfname, false);
 
 	ifp = if_lookup_by_name(ifname, vrf_id);
 
@@ -1151,7 +1149,7 @@ const char *if_link_type_str(enum zebra_
 		llts(ZEBRA_LLT_IEEE802154, "IEEE 802.15.4");
 		llts(ZEBRA_LLT_IEEE802154_PHY, "IEEE 802.15.4 Phy");
 	default:
-		zlog_warn("Unknown value %d", llt);
+		flog_err(LIB_ERR_DEVELOPMENT, "Unknown value %d", llt);
 		return "Unknown type!";
 #undef llts
 	}
diff -urpN frr-frr-5.0.1/lib/if.h frr-frr-6.0/lib/if.h
--- frr-frr-5.0.1/lib/if.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/if.h	2018-10-08 14:32:57.000000000 +0200
@@ -297,28 +297,32 @@ DECLARE_QOBJ_TYPE(interface)
 
 #define IFNAME_RB_INSERT(vrf, ifp)                                             \
 	if (RB_INSERT(if_name_head, &vrf->ifaces_by_name, (ifp)))              \
-		zlog_err(                                                      \
+		flog_err(                                                     \
+			LIB_ERR_INTERFACE,                                     \
 			"%s(%s): corruption detected -- interface with this "  \
 			"name exists already in VRF %u!",                      \
 			__func__, (ifp)->name, (ifp)->vrf_id);
 
 #define IFNAME_RB_REMOVE(vrf, ifp)                                             \
 	if (RB_REMOVE(if_name_head, &vrf->ifaces_by_name, (ifp)) == NULL)      \
-		zlog_err(                                                      \
+		flog_err(                                                     \
+			LIB_ERR_INTERFACE,                                     \
 			"%s(%s): corruption detected -- interface with this "  \
 			"name doesn't exist in VRF %u!",                       \
 			__func__, (ifp)->name, (ifp)->vrf_id);
 
 #define IFINDEX_RB_INSERT(vrf, ifp)                                            \
 	if (RB_INSERT(if_index_head, &vrf->ifaces_by_index, (ifp)))            \
-		zlog_err(                                                      \
+		flog_err(                                                     \
+			LIB_ERR_INTERFACE,                                     \
 			"%s(%u): corruption detected -- interface with this "  \
 			"ifindex exists already in VRF %u!",                   \
 			__func__, (ifp)->ifindex, (ifp)->vrf_id);
 
 #define IFINDEX_RB_REMOVE(vrf, ifp)                                            \
 	if (RB_REMOVE(if_index_head, &vrf->ifaces_by_index, (ifp)) == NULL)    \
-		zlog_err(                                                      \
+		flog_err(                                                     \
+			LIB_ERR_INTERFACE,                                     \
 			"%s(%u): corruption detected -- interface with this "  \
 			"ifindex doesn't exist in VRF %u!",                    \
 			__func__, (ifp)->ifindex, (ifp)->vrf_id);
@@ -493,6 +497,7 @@ extern int if_is_operative(struct interf
 extern int if_is_no_ptm_operative(struct interface *);
 extern int if_is_loopback(struct interface *);
 extern int if_is_vrf(struct interface *ifp);
+extern bool if_is_loopback_or_vrf(struct interface *ifp);
 extern int if_is_broadcast(struct interface *);
 extern int if_is_pointopoint(struct interface *);
 extern int if_is_multicast(struct interface *);
diff -urpN frr-frr-5.0.1/lib/imsg.c frr-frr-6.0/lib/imsg.c
--- frr-frr-5.0.1/lib/imsg.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/imsg.c	2018-10-08 14:32:57.000000000 +0200
@@ -77,7 +77,7 @@ ssize_t imsg_read(struct imsgbuf *ibuf)
 		char buf[CMSG_SPACE(sizeof(int) * 1)];
 	} cmsgbuf;
 	struct iovec iov;
-	ssize_t n = -1;
+	ssize_t n;
 	int fd;
 	struct imsg_fd *ifd;
 
@@ -110,7 +110,8 @@ again:
 		return (-1);
 	}
 
-	if ((n = recvmsg(ibuf->fd, &msg, 0)) == -1) {
+	n = recvmsg(ibuf->fd, &msg, 0);
+	if (n == -1) {
 		if (errno == EINTR)
 			goto again;
 		goto fail;
diff -urpN frr-frr-5.0.1/lib/ipaddr.h frr-frr-6.0/lib/ipaddr.h
--- frr-frr-5.0.1/lib/ipaddr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/ipaddr.h	2018-10-08 14:32:57.000000000 +0200
@@ -102,4 +102,14 @@ static inline void ipv4_to_ipv4_mapped_i
 	memcpy((char *)in6 + 12, &in, sizeof(struct in_addr));
 }
 
+/*
+ * convert an ipv4 mapped ipv6 address back to ipv4 address
+ */
+static inline void ipv4_mapped_ipv6_to_ipv4(struct in6_addr *in6,
+					    struct in_addr *in)
+{
+	memset(in, 0, sizeof(struct in_addr));
+	memcpy(in, (char *)in6 + 12, sizeof(struct in_addr));
+}
+
 #endif /* __IPADDR_H__ */
diff -urpN frr-frr-5.0.1/lib/json.h frr-frr-6.0/lib/json.h
--- frr-frr-5.0.1/lib/json.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/json.h	2018-10-08 14:32:57.000000000 +0200
@@ -23,6 +23,20 @@
 
 #if defined(HAVE_JSON_C_JSON_H)
 #include <json-c/json.h>
+
+/*
+ * FRR style JSON iteration.
+ * Usage: JSON_FOREACH(...) { ... }
+ */
+#define JSON_FOREACH(jo, joi, join)                                            \
+	/* struct json_object *jo; */                                          \
+	/* struct json_object_iterator joi; */                                 \
+	/* struct json_object_iterator join; */                                \
+	for ((joi) = json_object_iter_begin((jo)),                             \
+	    (join) = json_object_iter_end((jo));                               \
+	     json_object_iter_equal(&(joi), &(join)) == 0;                     \
+	     json_object_iter_next(&(joi)))
+
 #else
 #include <json/json.h>
 
diff -urpN frr-frr-5.0.1/lib/keychain.c frr-frr-6.0/lib/keychain.c
--- frr-frr-5.0.1/lib/keychain.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/keychain.c	2018-10-08 14:32:57.000000000 +0200
@@ -172,7 +172,7 @@ struct key *key_match_for_accept(const s
 		if (key->accept.start == 0
 		    || (key->accept.start <= now
 			&& (key->accept.end >= now || key->accept.end == -1)))
-			if (strncmp(key->string, auth_str, 16) == 0)
+			if (key->string && (strncmp(key->string, auth_str, 16) == 0))
 				return key;
 	}
 	return NULL;
diff -urpN frr-frr-5.0.1/lib/lib_errors.c frr-frr-6.0/lib/lib_errors.c
--- frr-frr-5.0.1/lib/lib_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/lib/lib_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * Library-specific error messages.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "lib_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_lib_err[] = {
+	{
+		.code = LIB_ERR_PRIVILEGES,
+		.title = "Failure to raise or lower privileges",
+		.description = "FRR attempted to raise or lower its privileges and was unable to do so",
+		.suggestion = "Ensure that you are running FRR as the frr user and that the user has sufficient privileges to properly access root privileges"
+	},
+	{
+		.code = LIB_ERR_VRF_START,
+		.title = "VRF Failure on Start",
+		.description = "Upon startup FRR failed to properly initialize and startup the VRF subsystem",
+		.suggestion = "Ensure that there is sufficient memory to start processes and restart FRR",
+	},
+	{
+		.code = LIB_ERR_SOCKET,
+		.title = "Socket Error",
+		.description = "When attempting to access a socket a system error has occured and we were unable to properly complete the request",
+		.suggestion = "Ensure that there are sufficient system resources available and ensure that the frr user has sufficient permisions to work",
+	},
+	{
+		.code = LIB_ERR_ZAPI_MISSMATCH,
+		.title = "ZAPI Error",
+		.description = "A version miss-match has been detected between zebra and client protocol",
+		.suggestion = "Two different versions of FRR have been installed and the install is not properly setup.  Completely stop FRR, remove it from the system and reinstall.  Typically only developers should see this issue."
+	},
+	{
+		.code = LIB_ERR_ZAPI_ENCODE,
+		.title = "ZAPI Error",
+		.description = "The ZAPI subsystem has detected an encoding issue, between zebra and a client protocol",
+		.suggestion = "Restart FRR"
+	},
+	{
+		.code = LIB_ERR_ZAPI_SOCKET,
+		.title = "ZAPI Error",
+		.description = "The ZAPI subsystem has detected a socket error between zebra and a client",
+		.suggestion = "Restart FRR"
+	},
+	{
+		.code = LIB_ERR_SYSTEM_CALL,
+		.title = "System Call Error",
+		.description = "FRR has detected a error from using a vital system call and has probably already exited",
+		.suggestion = "Ensure permissions are correct for FRR files, users and groups are correct. Additionally check that sufficient system resources are available."
+	},
+	{
+		.code = LIB_ERR_VTY,
+		.title = "VTY Subsystem Error",
+		.description = "FRR has detected a problem with the specified configuration file",
+		.suggestion = "Ensure configuration file exists and has correct permissions for operations Additionally ensure that all config lines are correct as well",
+	},
+	{
+		.code = LIB_ERR_SNMP,
+		.title = "SNMP Subsystem Error",
+		.description = "FRR has detected a problem with the snmp library it uses A callback from this subsystem has indicated some error",
+		.suggestion = "Examine callback message and ensure snmp is properly setup and working"
+	},
+	{
+		.code = LIB_ERR_INTERFACE,
+		.title = "Interface Subsystem Error",
+		.description = "FRR has detected a problem with interface data from the kernel as it deviates from what we would expect to happen via normal netlink messaging",
+		.suggestion = "Open an Issue with all relevant log files and restart FRR"
+	},
+	{
+		.code = LIB_ERR_NS,
+		.title = "NameSpace Subsystem Error",
+		.description = "FRR has detected a problem with NameSpace data from the kernel as it deviates from what we would expect to happen via normal kernel messaging",
+		.suggestion = "Open an Issue with all relevant log files and restart FRR"
+	},
+	{
+		.code = LIB_ERR_DEVELOPMENT,
+		.title = "Developmental Escape Error",
+		.description = "FRR has detected an issue where new development has not properly updated all code paths.",
+		.suggestion = "Open an Issue with all relevant log files"
+	},
+	{
+		.code = LIB_ERR_ZMQ,
+		.title = "ZMQ Subsystem Error",
+		.description = "FRR has detected an issue with the Zero MQ subsystem and ZeroMQ is not working properly now",
+		.suggestion = "Open an Issue with all relevant log files and restart FRR"
+	},
+	{
+		.code = LIB_ERR_UNAVAILABLE,
+		.title = "Feature or system unavailable",
+		.description = "FRR was not compiled with support for a particular feature, or it is not available on the current platform",
+		.suggestion = "Recompile FRR with the feature enabled, or find out what platforms support the feature"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void lib_error_init(void)
+{
+	log_ref_add(ferr_lib_err);
+}
diff -urpN frr-frr-5.0.1/lib/lib_errors.h frr-frr-6.0/lib/lib_errors.h
--- frr-frr-5.0.1/lib/lib_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/lib/lib_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * Library-specific error messages.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __LIB_ERRORS_H__
+#define __LIB_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum lib_log_refs {
+	LIB_ERR_PRIVILEGES = LIB_FERR_START,
+	LIB_ERR_VRF_START,
+	LIB_ERR_SOCKET,
+	LIB_ERR_ZAPI_MISSMATCH,
+	LIB_ERR_ZAPI_ENCODE,
+	LIB_ERR_ZAPI_SOCKET,
+	LIB_ERR_SYSTEM_CALL,
+	LIB_ERR_VTY,
+	LIB_ERR_SNMP,
+	LIB_ERR_INTERFACE,
+	LIB_ERR_NS,
+	LIB_ERR_DEVELOPMENT,
+	LIB_ERR_ZMQ,
+	LIB_ERR_UNAVAILABLE,
+};
+
+extern void lib_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/lib/libfrr.c frr-frr-6.0/lib/libfrr.c
--- frr-frr-5.0.1/lib/libfrr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/libfrr.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "log_int.h"
 #include "module.h"
 #include "network.h"
+#include "lib_errors.h"
 
 DEFINE_HOOK(frr_late_init, (struct thread_master * tm), (tm))
 DEFINE_KOOH(frr_early_fini, (), ())
@@ -47,9 +48,9 @@ const char frr_moduledir[] = MODULE_PATH
 char frr_protoname[256] = "NONE";
 char frr_protonameinst[256] = "NONE";
 
-char config_default[256];
+char config_default[512];
 char frr_zclientpath[256];
-static char pidfile_default[256];
+static char pidfile_default[512];
 static char vtypath_default[256];
 
 bool debug_memstats_at_exit = 0;
@@ -78,6 +79,8 @@ static void opt_extend(const struct opts
 
 #define OPTION_VTYSOCK   1000
 #define OPTION_MODULEDIR 1002
+#define OPTION_LOG       1003
+#define OPTION_LOGLEVEL  1004
 
 static const struct option lo_always[] = {
 	{"help", no_argument, NULL, 'h'},
@@ -86,6 +89,8 @@ static const struct option lo_always[] =
 	{"module", no_argument, NULL, 'M'},
 	{"vty_socket", required_argument, NULL, OPTION_VTYSOCK},
 	{"moduledir", required_argument, NULL, OPTION_MODULEDIR},
+	{"log", required_argument, NULL, OPTION_LOG},
+	{"log-level", required_argument, NULL, OPTION_LOGLEVEL},
 	{NULL}};
 static const struct optspec os_always = {
 	"hvdM:",
@@ -94,7 +99,9 @@ static const struct optspec os_always =
 	"  -d, --daemon       Runs in daemon mode\n"
 	"  -M, --module       Load specified module\n"
 	"      --vty_socket   Override vty socket path\n"
-	"      --moduledir    Override modules directory\n",
+	"      --moduledir    Override modules directory\n"
+	"      --log          Set Logging to stdout, syslog, or file:<name>\n"
+	"      --log-level    Set Logging Level to use, debug, info, warn, etc\n",
 	lo_always};
 
 
@@ -444,6 +451,12 @@ static int frr_opt(int opt)
 			return 1;
 		di->privs->group = optarg;
 		break;
+	case OPTION_LOG:
+		di->early_logging = optarg;
+		break;
+	case OPTION_LOGLEVEL:
+		di->early_loglevel = optarg;
+		break;
 	default:
 		return 1;
 	}
@@ -543,9 +556,8 @@ struct thread_master *frr_init(void)
 
 	openzlog(di->progname, di->logname, di->instance,
 		 LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON);
-#if defined(HAVE_CUMULUS)
-	zlog_set_level(ZLOG_DEST_SYSLOG, zlog_default->default_lvl);
-#endif
+
+	command_setup_early_logging(di->early_logging, di->early_loglevel);
 
 	if (!frr_zclient_addr(&zclient_addr, &zclient_addr_len,
 			      frr_zclientpath)) {
@@ -587,6 +599,9 @@ struct thread_master *frr_init(void)
 	vty_init(master);
 	memory_init();
 
+	log_ref_init();
+	lib_error_init();
+
 	return master;
 }
 
@@ -721,15 +736,42 @@ static void frr_daemonize(void)
 	frr_daemon_wait(fds[0]);
 }
 
+/*
+ * Why is this a thread?
+ *
+ * The read in of config for integrated config happens *after*
+ * thread execution starts( because it is passed in via a vtysh -b -n )
+ * While if you are not using integrated config we want the ability
+ * to read the config in after thread execution starts, so that
+ * we can match this behavior.
+ */
+static int frr_config_read_in(struct thread *t)
+{
+	if (!vty_read_config(di->config_file, config_default) &&
+	    di->backup_config_file) {
+		char *orig = XSTRDUP(MTYPE_TMP, host_config_get());
+
+		zlog_info("Attempting to read backup config file: %s specified",
+			  di->backup_config_file);
+		vty_read_config(di->backup_config_file, config_default);
+
+		host_config_set(orig);
+		XFREE(MTYPE_TMP, orig);
+	}
+	return 0;
+}
+
 void frr_config_fork(void)
 {
 	hook_call(frr_late_init, master);
 
-	vty_read_config(di->config_file, config_default);
-
 	/* Don't start execution if we are in dry-run mode */
-	if (di->dryrun)
+	if (di->dryrun) {
+		frr_config_read_in(NULL);
 		exit(0);
+	}
+
+	thread_add_event(master, frr_config_read_in, NULL, 0, &di->read_in);
 
 	if (di->daemon_mode || di->terminal)
 		frr_daemonize();
@@ -787,8 +829,9 @@ static void frr_terminal_close(int isexi
 
 	nullfd = open("/dev/null", O_RDONLY | O_NOCTTY);
 	if (nullfd == -1) {
-		zlog_err("%s: failed to open /dev/null: %s", __func__,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: failed to open /dev/null: %s", __func__,
+			     safe_strerror(errno));
 	} else {
 		dup2(nullfd, 0);
 		dup2(nullfd, 1);
@@ -813,7 +856,9 @@ static int frr_daemon_ctl(struct thread
 	switch (buf[0]) {
 	case 'S': /* SIGTSTP */
 		vty_stdio_suspend();
-		send(daemon_ctl_sock, "s", 1, 0);
+		if (send(daemon_ctl_sock, "s", 1, 0) < 0)
+			zlog_err("%s send(\"s\") error (SIGTSTP propagation)",
+				 (di && di->name ? di->name : ""));
 		break;
 	case 'R': /* SIGTCNT [implicit] */
 		vty_stdio_resume();
@@ -857,8 +902,9 @@ void frr_run(struct thread_master *maste
 	} else if (di->daemon_mode) {
 		int nullfd = open("/dev/null", O_RDONLY | O_NOCTTY);
 		if (nullfd == -1) {
-			zlog_err("%s: failed to open /dev/null: %s", __func__,
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "%s: failed to open /dev/null: %s",
+				     __func__, safe_strerror(errno));
 		} else {
 			dup2(nullfd, 0);
 			dup2(nullfd, 1);
@@ -895,6 +941,7 @@ void frr_fini(void)
 	/* memory_init -> nothing needed */
 	vty_terminate();
 	cmd_terminate();
+	log_ref_fini();
 	zprivs_terminate(di->privs);
 	/* signal_init -> nothing needed */
 	thread_master_free(master);
diff -urpN frr-frr-5.0.1/lib/libfrr.h frr-frr-6.0/lib/libfrr.h
--- frr-frr-5.0.1/lib/libfrr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/libfrr.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,11 +50,16 @@ struct frr_daemon_info {
 	bool dryrun;
 	bool daemon_mode;
 	bool terminal;
+
+	struct thread *read_in;
 	const char *config_file;
+	const char *backup_config_file;
 	const char *pid_file;
 	const char *vty_path;
 	const char *module_path;
 	const char *pathspace;
+	const char *early_logging;
+	const char *early_loglevel;
 
 	const char *proghelp;
 	void (*printhelp)(FILE *target);
@@ -113,7 +118,7 @@ extern void frr_early_fini(void);
 DECLARE_KOOH(frr_fini, (), ())
 extern void frr_fini(void);
 
-extern char config_default[256];
+extern char config_default[512];
 extern char frr_zclientpath[256];
 extern const char frr_sysconfdir[];
 extern const char frr_vtydir[];
diff -urpN frr-frr-5.0.1/lib/linklist.c frr-frr-6.0/lib/linklist.c
--- frr-frr-5.0.1/lib/linklist.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/linklist.c	2018-10-08 14:32:57.000000000 +0200
@@ -19,6 +19,7 @@
  */
 
 #include <zebra.h>
+#include <stdlib.h>
 
 #include "linklist.h"
 #include "memory.h"
@@ -26,7 +27,6 @@
 DEFINE_MTYPE_STATIC(LIB, LINK_LIST, "Link List")
 DEFINE_MTYPE_STATIC(LIB, LINK_NODE, "Link Node")
 
-/* Allocate new list. */
 struct list *list_new(void)
 {
 	return XCALLOC(MTYPE_LINK_LIST, sizeof(struct list));
@@ -50,7 +50,6 @@ static void listnode_free(struct listnod
 	XFREE(MTYPE_LINK_NODE, node);
 }
 
-/* Add new data to the list. */
 void listnode_add(struct list *list, void *val)
 {
 	struct listnode *node;
@@ -71,12 +70,26 @@ void listnode_add(struct list *list, voi
 	list->count++;
 }
 
-/*
- * Add a node to the list.  If the list was sorted according to the
- * cmp function, insert a new node with the given val such that the
- * list remains sorted.  The new node is always inserted; there is no
- * notion of omitting duplicates.
- */
+void listnode_add_head(struct list *list, void *val)
+{
+	struct listnode *node;
+
+	assert(val != NULL);
+
+	node = listnode_new();
+
+	node->next = list->head;
+	node->data = val;
+
+	if (list->head == NULL)
+		list->head = node;
+	else
+		list->head->prev = node;
+	list->head = node;
+
+	list->count++;
+}
+
 void listnode_add_sort(struct list *list, void *val)
 {
 	struct listnode *n;
@@ -185,39 +198,20 @@ struct listnode *listnode_add_before(str
 	return nn;
 }
 
-/* Move given listnode to tail of the list */
 void listnode_move_to_tail(struct list *l, struct listnode *n)
 {
 	LISTNODE_DETACH(l, n);
 	LISTNODE_ATTACH(l, n);
 }
 
-/* Delete specific date pointer from the list. */
 void listnode_delete(struct list *list, void *val)
 {
-	struct listnode *node;
+	struct listnode *node = listnode_lookup(list, val);
 
-	assert(list);
-	for (node = list->head; node; node = node->next) {
-		if (node->data == val) {
-			if (node->prev)
-				node->prev->next = node->next;
-			else
-				list->head = node->next;
-
-			if (node->next)
-				node->next->prev = node->prev;
-			else
-				list->tail = node->prev;
-
-			list->count--;
-			listnode_free(node);
-			return;
-		}
-	}
+	if (node)
+		list_delete_node(list, node);
 }
 
-/* Return first node's data if it is there.  */
 void *listnode_head(struct list *list)
 {
 	struct listnode *node;
@@ -230,7 +224,6 @@ void *listnode_head(struct list *list)
 	return NULL;
 }
 
-/* Delete all listnode from the list. */
 void list_delete_all_node(struct list *list)
 {
 	struct listnode *node;
@@ -247,7 +240,6 @@ void list_delete_all_node(struct list *l
 	list->count = 0;
 }
 
-/* Delete all listnode then free list itself. */
 void list_delete_and_null(struct list **list)
 {
 	assert(*list);
@@ -261,7 +253,6 @@ void list_delete_original(struct list *l
 	list_delete_and_null(&list);
 }
 
-/* Lookup the node which has given data. */
 struct listnode *listnode_lookup(struct list *list, void *data)
 {
 	struct listnode *node;
@@ -273,7 +264,6 @@ struct listnode *listnode_lookup(struct
 	return NULL;
 }
 
-/* Delete the node from list.  For ospfd and ospf6d. */
 void list_delete_node(struct list *list, struct listnode *node)
 {
 	if (node->prev)
@@ -288,11 +278,48 @@ void list_delete_node(struct list *list,
 	listnode_free(node);
 }
 
-/* ospf_spf.c */
-void list_add_list(struct list *l, struct list *m)
+void list_add_list(struct list *list, struct list *add)
 {
 	struct listnode *n;
 
-	for (n = listhead(m); n; n = listnextnode(n))
-		listnode_add(l, n->data);
+	for (n = listhead(add); n; n = listnextnode(n))
+		listnode_add(list, n->data);
+}
+
+struct list *list_dup(struct list *list)
+{
+	struct list *new = list_new();
+	struct listnode *ln;
+	void *data;
+
+	new->cmp = list->cmp;
+	new->del = list->del;
+
+	for (ALL_LIST_ELEMENTS_RO(list, ln, data))
+		listnode_add(new, data);
+
+	return new;
+}
+
+void list_sort(struct list *list, int (*cmp)(const void **, const void **))
+{
+	struct listnode *ln, *nn;
+	int i = -1;
+	void *data;
+	size_t n = list->count;
+	void **items = XCALLOC(MTYPE_TMP, (sizeof(void *)) * n);
+	int (*realcmp)(const void *, const void *) =
+		(int (*)(const void *, const void *))cmp;
+
+	for (ALL_LIST_ELEMENTS(list, ln, nn, data)) {
+		items[++i] = data;
+		list_delete_node(list, ln);
+	}
+
+	qsort(items, n, sizeof(void *), realcmp);
+
+	for (unsigned int i = 0; i < n; ++i)
+		listnode_add(list, items[i]);
+
+	XFREE(MTYPE_TMP, items);
 }
diff -urpN frr-frr-5.0.1/lib/linklist.h frr-frr-6.0/lib/linklist.h
--- frr-frr-5.0.1/lib/linklist.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/linklist.h	2018-10-08 14:32:57.000000000 +0200
@@ -52,27 +52,188 @@ struct list {
 };
 
 #define listnextnode(X) ((X) ? ((X)->next) : NULL)
+#define listnextnode_unchecked(X) ((X)->next)
 #define listhead(X) ((X) ? ((X)->head) : NULL)
+#define listhead_unchecked(X) ((X)->head)
 #define listtail(X) ((X) ? ((X)->tail) : NULL)
 #define listcount(X) ((X)->count)
 #define list_isempty(X) ((X)->head == NULL && (X)->tail == NULL)
 /* return X->data only if X and X->data are not NULL */
 #define listgetdata(X) (assert(X), assert((X)->data != NULL), (X)->data)
 
-/* Prototypes. */
-extern struct list *
-list_new(void); /* encouraged: set list.del callback on new lists */
-
-extern void listnode_add(struct list *, void *);
-extern void listnode_add_sort(struct list *, void *);
-extern struct listnode *listnode_add_after(struct list *, struct listnode *,
-					   void *);
-extern struct listnode *listnode_add_before(struct list *, struct listnode *,
-					    void *);
-extern void listnode_move_to_tail(struct list *, struct listnode *);
-extern void listnode_delete(struct list *, void *);
-extern struct listnode *listnode_lookup(struct list *, void *);
-extern void *listnode_head(struct list *);
+/*
+ * Create a new linked list.
+ *
+ * Returns:
+ *    the created linked list
+ */
+extern struct list *list_new(void);
+
+/*
+ * Add a new element to the tail of a list.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * data
+ *    element to add
+ */
+extern void listnode_add(struct list *list, void *data);
+
+/*
+ * Add a new element to the beginning of a list.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * data
+ *    element to add
+ */
+extern void listnode_add_head(struct list *list, void *data);
+
+/*
+ * Insert a new element into a list with insertion sort.
+ *
+ * If list->cmp is set, this function is used to determine the position to
+ * insert the new element. If it is not set, this function is equivalent to
+ * listnode_add.
+ *
+ * Runtime is O(N).
+ *
+ * list
+ *    list to operate on
+ *
+ * val
+ *    element to add
+ */
+extern void listnode_add_sort(struct list *list, void *val);
+
+/*
+ * Insert a new element into a list after another element.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * pp
+ *    listnode to insert after
+ *
+ * data
+ *    data to insert
+ *
+ * Returns:
+ *    pointer to newly created listnode that contains the inserted data
+ */
+extern struct listnode *listnode_add_after(struct list *list,
+					   struct listnode *pp, void *data);
+
+/*
+ * Insert a new element into a list before another element.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * pp
+ *    listnode to insert before
+ *
+ * data
+ *    data to insert
+ *
+ * Returns:
+ *    pointer to newly created listnode that contains the inserted data
+ */
+extern struct listnode *listnode_add_before(struct list *list,
+					    struct listnode *pp, void *data);
+
+/*
+ * Move a node to the tail of a list.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * node
+ *    node to move to tail
+ */
+extern void listnode_move_to_tail(struct list *list, struct listnode *node);
+
+/*
+ * Delete an element from a list.
+ *
+ * Runtime is O(N).
+ *
+ * list
+ *    list to operate on
+ *
+ * data
+ *    data to insert into list
+ */
+extern void listnode_delete(struct list *list, void *data);
+
+/*
+ * Find the listnode corresponding to an element in a list.
+ *
+ * list
+ *    list to operate on
+ *
+ * data
+ *    data to search for
+ *
+ * Returns:
+ *    pointer to listnode storing the given data if found, NULL otherwise
+ */
+extern struct listnode *listnode_lookup(struct list *list, void *data);
+
+/*
+ * Retrieve the element at the head of a list.
+ *
+ * list
+ *    list to operate on
+ *
+ * Returns:
+ *    data at head of list, or NULL if list is empty
+ */
+extern void *listnode_head(struct list *list);
+
+/*
+ * Duplicate a list.
+ *
+ * list
+ *    list to duplicate
+ *
+ * Returns:
+ *    copy of the list
+ */
+extern struct list *list_dup(struct list *l);
+
+/*
+ * Sort a list in place.
+ *
+ * The sorting algorithm used is quicksort. Runtimes are equivalent to those of
+ * quicksort plus N. The sort is not stable.
+ *
+ * For portability reasons, the comparison function takes a pointer to pointer
+ * to void. This pointer should be dereferenced to get the actual data pointer.
+ * It is always safe to do this.
+ *
+ * list
+ *    list to sort
+ *
+ * cmp
+ *    comparison function for quicksort. Should return less than, equal to or
+ *    greater than zero if the first argument is less than, equal to or greater
+ *    than the second argument.
+ */
+extern void list_sort(struct list *list,
+		      int (*cmp)(const void **, const void **));
 
 /*
  * The usage of list_delete is being transitioned to pass in
@@ -84,11 +245,30 @@ extern void *listnode_head(struct list *
  * and remove list_delete_original and the list_delete #define
  * Additionally remove list_free entirely
  */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20181001
+#if CONFDATE > 20181001
 CPP_NOTICE("list_delete without double pointer is deprecated, please fixup")
 #endif
-extern void list_delete_and_null(struct list **);
-extern void list_delete_original(struct list *);
+
+/*
+ * Delete a list and NULL its pointer.
+ *
+ * If non-null, list->del is called with each data element.
+ *
+ * plist
+ *    pointer to list pointer; this will be set to NULL after the list has been
+ *    deleted
+ */
+extern void list_delete_and_null(struct list **plist);
+
+/*
+ * Delete a list.
+ *
+ * If non-null, list->del is called with each data element.
+ *
+ * plist
+ *    pointer to list pointer
+ */
+extern void list_delete_original(struct list *list);
 #define list_delete(X)                                                         \
 	list_delete_original((X))                                              \
 		CPP_WARN("Please transition to using list_delete_and_null")
@@ -96,13 +276,43 @@ extern void list_delete_original(struct
 	list_delete_original((X))                                              \
 		CPP_WARN("Please transition tousing list_delete_and_null")
 
-extern void list_delete_all_node(struct list *);
+/*
+ * Delete all nodes from a list without deleting the list itself.
+ *
+ * If non-null, list->del is called with each data element.
+ *
+ * list
+ *    list to operate on
+ */
+extern void list_delete_all_node(struct list *list);
 
-/* For ospfd and ospf6d. */
-extern void list_delete_node(struct list *, struct listnode *);
+/*
+ * Delete a node from a list.
+ *
+ * list->del is not called with the data associated with the node.
+ *
+ * Runtime is O(1).
+ *
+ * list
+ *    list to operate on
+ *
+ * node
+ *    the node to delete
+ */
+extern void list_delete_node(struct list *list, struct listnode *node);
 
-/* For ospf_spf.c */
-extern void list_add_list(struct list *, struct list *);
+/*
+ * Append a list to an existing list.
+ *
+ * Runtime is O(N) where N = listcount(add).
+ *
+ * list
+ *    list to append to
+ *
+ * add
+ *    list to append
+ */
+extern void list_add_list(struct list *list, struct list *add);
 
 /* List iteration macro.
  * Usage: for (ALL_LIST_ELEMENTS (...) { ... }
diff -urpN frr-frr-5.0.1/lib/log.c frr-frr-6.0/lib/log.c
--- frr-frr-5.0.1/lib/log.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/log.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,8 @@
 #include "log_int.h"
 #include "memory.h"
 #include "command.h"
+#include "lib_errors.h"
+
 #ifndef SUNOS_5
 #include <sys/un.h>
 #endif
@@ -631,7 +633,8 @@ void zlog_backtrace(int priority)
 
 	size = backtrace(array, array_size(array));
 	if (size <= 0 || (size_t)size > array_size(array)) {
-		zlog_err(
+		flog_err_sys(
+			LIB_ERR_SYSTEM_CALL,
 			"Cannot get backtrace, returned invalid # of frames %d "
 			"(valid range is between 1 and %lu)",
 			size, (unsigned long)(array_size(array)));
@@ -639,7 +642,8 @@ void zlog_backtrace(int priority)
 	}
 	zlog(priority, "Backtrace for %d stack frames:", size);
 	if (!(strings = backtrace_symbols(array, size))) {
-		zlog_err("Cannot get backtrace symbols (out of memory?)");
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "Cannot get backtrace symbols (out of memory?)");
 		for (i = 0; i < size; i++)
 			zlog(priority, "[bt %d] %p", i, array[i]);
 	} else {
@@ -680,6 +684,23 @@ ZLOG_FUNC(zlog_debug, LOG_DEBUG)
 
 #undef ZLOG_FUNC
 
+void zlog_err_id(uint32_t id, const char *format, ...)
+{
+	va_list args;
+	va_start(args, format);
+	if (zlog_default && zlog_default->error_code) {
+		char newfmt[strlen(format) + 32];
+
+		snprintf(newfmt, sizeof(newfmt), "[EC %"PRIu32"] %s", id,
+			 format);
+		vzlog(LOG_ERR, newfmt, args);
+	} else {
+		vzlog(LOG_ERR, format, args);
+	}
+	va_end(args);
+}
+
+
 void zlog_thread_info(int log_level)
 {
 	struct thread *tc;
@@ -712,10 +733,10 @@ void _zlog_assert_failed(const char *ass
 
 void memory_oom(size_t size, const char *name)
 {
-	zlog_err(
-		"out of memory: failed to allocate %zu bytes for %s"
-		"object",
-		size, name);
+	flog_err_sys(LIB_ERR_SYSTEM_CALL,
+		     "out of memory: failed to allocate %zu bytes for %s"
+		     "object",
+		     size, name);
 	zlog_backtrace(LOG_ERR);
 	abort();
 }
@@ -864,10 +885,16 @@ int zlog_rotate(void)
 		save_errno = errno;
 		umask(oldumask);
 		if (zl->fp == NULL) {
-			zlog_err(
+
+			pthread_mutex_unlock(&loglock);
+
+			flog_err_sys(
+				LIB_ERR_SYSTEM_CALL,
 				"Log rotate failed: cannot open file %s for append: %s",
 				zl->filename, safe_strerror(save_errno));
 			ret = -1;
+
+			pthread_mutex_lock(&loglock);
 		} else {
 			logfile_fd = fileno(zl->fp);
 			zl->maxlvl[ZLOG_DEST_FILE] = level;
@@ -898,10 +925,6 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_ROUTE_ADD),
 	DESC_ENTRY(ZEBRA_ROUTE_DELETE),
 	DESC_ENTRY(ZEBRA_ROUTE_NOTIFY_OWNER),
-	DESC_ENTRY(ZEBRA_IPV4_ROUTE_ADD),
-	DESC_ENTRY(ZEBRA_IPV4_ROUTE_DELETE),
-	DESC_ENTRY(ZEBRA_IPV6_ROUTE_ADD),
-	DESC_ENTRY(ZEBRA_IPV6_ROUTE_DELETE),
 	DESC_ENTRY(ZEBRA_REDISTRIBUTE_ADD),
 	DESC_ENTRY(ZEBRA_REDISTRIBUTE_DELETE),
 	DESC_ENTRY(ZEBRA_REDISTRIBUTE_DEFAULT_ADD),
@@ -940,12 +963,13 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_MPLS_LABELS_DELETE),
 	DESC_ENTRY(ZEBRA_IPMR_ROUTE_STATS),
 	DESC_ENTRY(ZEBRA_LABEL_MANAGER_CONNECT),
-	DESC_ENTRY(ZEBRA_LABEL_MANAGER_CONNECT_ASYNC),
 	DESC_ENTRY(ZEBRA_GET_LABEL_CHUNK),
 	DESC_ENTRY(ZEBRA_RELEASE_LABEL_CHUNK),
 	DESC_ENTRY(ZEBRA_ADVERTISE_ALL_VNI),
 	DESC_ENTRY(ZEBRA_ADVERTISE_DEFAULT_GW),
 	DESC_ENTRY(ZEBRA_ADVERTISE_SUBNET),
+	DESC_ENTRY(ZEBRA_LOCAL_ES_ADD),
+	DESC_ENTRY(ZEBRA_LOCAL_ES_DEL),
 	DESC_ENTRY(ZEBRA_VNI_ADD),
 	DESC_ENTRY(ZEBRA_VNI_DEL),
 	DESC_ENTRY(ZEBRA_L3VNI_ADD),
@@ -983,7 +1007,8 @@ static const struct zebra_desc_table *zr
 	unsigned int i;
 
 	if (zroute >= array_size(route_types)) {
-		zlog_err("unknown zebra route type: %u", zroute);
+		flog_err(LIB_ERR_DEVELOPMENT, "unknown zebra route type: %u",
+			  zroute);
 		return &unknown;
 	}
 	if (zroute == route_types[zroute].type)
@@ -997,7 +1022,9 @@ static const struct zebra_desc_table *zr
 			return &route_types[i];
 		}
 	}
-	zlog_err("internal error: cannot find route type %u in table!", zroute);
+	flog_err(LIB_ERR_DEVELOPMENT,
+		  "internal error: cannot find route type %u in table!",
+		  zroute);
 	return &unknown;
 }
 
@@ -1014,7 +1041,8 @@ char zebra_route_char(unsigned int zrout
 const char *zserv_command_string(unsigned int command)
 {
 	if (command >= array_size(command_types)) {
-		zlog_err("unknown zserv command type: %u", command);
+		flog_err(LIB_ERR_DEVELOPMENT, "unknown zserv command type: %u",
+			  command);
 		return unknown.string;
 	}
 	return command_types[command].string;
diff -urpN frr-frr-5.0.1/lib/log.h frr-frr-6.0/lib/log.h
--- frr-frr-5.0.1/lib/log.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/log.h	2018-10-08 14:32:57.000000000 +0200
@@ -79,12 +79,21 @@ extern void closezlog(void);
 #endif /* __GNUC__ */
 
 /* Handy zlog functions. */
+extern void zlog_err_id(uint32_t id, const char *format, ...)
+	PRINTF_ATTRIBUTE(2, 3);
 extern void zlog_err(const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_warn(const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_info(const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_notice(const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_debug(const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 
+/* For logs which have error codes associated with them */
+#define flog_err(ferr_id, format, ...)                                        \
+	zlog_err_id(ferr_id, format, ##__VA_ARGS__)
+#define flog_err_sys(ferr_id, format, ...)                                     \
+	flog_err(ferr_id, format, ##__VA_ARGS__)
+
+
 extern void zlog_thread_info(int log_level);
 
 /* Set logging level for the given destination.  If the log_level
diff -urpN frr-frr-5.0.1/lib/log_int.h frr-frr-6.0/lib/log_int.h
--- frr-frr-5.0.1/lib/log_int.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/log_int.h	2018-10-08 14:32:57.000000000 +0200
@@ -36,6 +36,7 @@ struct zlog {
 	int facility;	/* as per syslog facility */
 	int record_priority; /* should messages logged through stdio include the
 				priority of the message? */
+	int error_code;
 	int syslog_options;  /* 2nd arg to openlog */
 	int timestamp_precision; /* # of digits of subsecond precision */
 };
diff -urpN frr-frr-5.0.1/lib/memory.c frr-frr-6.0/lib/memory.c
--- frr-frr-5.0.1/lib/memory.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/memory.c	2018-10-08 14:32:57.000000000 +0200
@@ -17,6 +17,12 @@
 #include <zebra.h>
 
 #include <stdlib.h>
+#ifdef HAVE_MALLOC_H
+#include <malloc.h>
+#endif
+#ifdef HAVE_MALLOC_MALLOC_H
+#include <malloc/malloc.h>
+#endif
 
 #include "memory.h"
 #include "log.h"
@@ -28,7 +34,7 @@ DEFINE_MGROUP(LIB, "libfrr")
 DEFINE_MTYPE(LIB, TMP, "Temporary memory")
 DEFINE_MTYPE(LIB, PREFIX_FLOWSPEC, "Prefix Flowspec")
 
-static inline void mt_count_alloc(struct memtype *mt, size_t size)
+static inline void mt_count_alloc(struct memtype *mt, size_t size, void *ptr)
 {
 	size_t oldsize;
 
@@ -41,12 +47,24 @@ static inline void mt_count_alloc(struct
 	if (oldsize != 0 && oldsize != size && oldsize != SIZE_VAR)
 		atomic_store_explicit(&mt->size, SIZE_VAR,
 				      memory_order_relaxed);
+
+#ifdef HAVE_MALLOC_USABLE_SIZE
+	size_t mallocsz = malloc_usable_size(ptr);
+
+	atomic_fetch_add_explicit(&mt->total, mallocsz, memory_order_relaxed);
+#endif
 }
 
-static inline void mt_count_free(struct memtype *mt)
+static inline void mt_count_free(struct memtype *mt, void *ptr)
 {
 	assert(mt->n_alloc);
 	atomic_fetch_sub_explicit(&mt->n_alloc, 1, memory_order_relaxed);
+
+#ifdef HAVE_MALLOC_USABLE_SIZE
+	size_t mallocsz = malloc_usable_size(ptr);
+
+	atomic_fetch_sub_explicit(&mt->total, mallocsz, memory_order_relaxed);
+#endif
 }
 
 static inline void *mt_checkalloc(struct memtype *mt, void *ptr, size_t size)
@@ -58,7 +76,7 @@ static inline void *mt_checkalloc(struct
 		}
 		return NULL;
 	}
-	mt_count_alloc(mt, size);
+	mt_count_alloc(mt, size, ptr);
 	return ptr;
 }
 
@@ -75,19 +93,19 @@ void *qcalloc(struct memtype *mt, size_t
 void *qrealloc(struct memtype *mt, void *ptr, size_t size)
 {
 	if (ptr)
-		mt_count_free(mt);
+		mt_count_free(mt, ptr);
 	return mt_checkalloc(mt, ptr ? realloc(ptr, size) : malloc(size), size);
 }
 
 void *qstrdup(struct memtype *mt, const char *str)
 {
-	return mt_checkalloc(mt, strdup(str), strlen(str) + 1);
+	return str ? mt_checkalloc(mt, strdup(str), strlen(str) + 1) : NULL;
 }
 
 void qfree(struct memtype *mt, void *ptr)
 {
 	if (ptr)
-		mt_count_free(mt);
+		mt_count_free(mt, ptr);
 	free(ptr);
 }
 
diff -urpN frr-frr-5.0.1/lib/memory.h frr-frr-6.0/lib/memory.h
--- frr-frr-5.0.1/lib/memory.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/memory.h	2018-10-08 14:32:57.000000000 +0200
@@ -24,12 +24,20 @@
 
 #define array_size(ar) (sizeof(ar) / sizeof(ar[0]))
 
+#if defined(HAVE_MALLOC_SIZE) && !defined(HAVE_MALLOC_USABLE_SIZE)
+#define malloc_usable_size(x) malloc_size(x)
+#define HAVE_MALLOC_USABLE_SIZE
+#endif
+
 #define SIZE_VAR ~0UL
 struct memtype {
 	struct memtype *next, **ref;
 	const char *name;
 	_Atomic size_t n_alloc;
 	_Atomic size_t size;
+#ifdef HAVE_MALLOC_USABLE_SIZE
+	_Atomic size_t total;
+#endif
 };
 
 struct memgroup {
diff -urpN frr-frr-5.0.1/lib/memory_vty.c frr-frr-6.0/lib/memory_vty.c
--- frr-frr-5.0.1/lib/memory_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/memory_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,9 +21,12 @@
 
 #include <zebra.h>
 /* malloc.h is generally obsolete, however GNU Libc mallinfo wants it. */
-#if (defined(GNU_LINUX) && defined(HAVE_MALLINFO))
+#ifdef HAVE_MALLOC_H
 #include <malloc.h>
-#endif /* HAVE_MALLINFO */
+#endif
+#ifdef HAVE_MALLOC_MALLOC_H
+#include <malloc/malloc.h>
+#endif
 #include <dlfcn.h>
 #include <link.h>
 
@@ -76,12 +79,21 @@ static int qmem_walker(void *arg, struct
 		if (mt->n_alloc != 0) {
 			char size[32];
 			snprintf(size, sizeof(size), "%6zu", mt->size);
-			vty_out(vty, "%-30s: %10zu  %s\n", mt->name,
+
+#ifdef HAVE_MALLOC_USABLE_SIZE
+#define TSTR " %9zu"
+#define TARG , mt->total
+#else
+#define TSTR ""
+#define TARG
+#endif
+			vty_out(vty, "%-30s: %10zu  %-16s"TSTR"\n", mt->name,
 				mt->n_alloc,
 				mt->size == 0 ? ""
 					      : mt->size == SIZE_VAR
 							? "(variably sized)"
-							: size);
+							: size
+				TARG);
 		}
 	}
 	return 0;
diff -urpN frr-frr-5.0.1/lib/module.c frr-frr-6.0/lib/module.c
--- frr-frr-5.0.1/lib/module.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/module.c	2018-10-08 14:32:57.000000000 +0200
@@ -75,7 +75,7 @@ struct frrmod_runtime *frrmod_load(const
 				   size_t err_len)
 {
 	void *handle = NULL;
-	char name[PATH_MAX], fullpath[PATH_MAX], *args;
+	char name[PATH_MAX], fullpath[PATH_MAX * 2], *args;
 	struct frrmod_runtime *rtinfo, **rtinfop;
 	const struct frrmod_info *info;
 
@@ -85,7 +85,7 @@ struct frrmod_runtime *frrmod_load(const
 		*args++ = '\0';
 
 	if (!strchr(name, '/')) {
-		if (!handle && execname) {
+		if (execname) {
 			snprintf(fullpath, sizeof(fullpath), "%s/%s_%s.so", dir,
 				 execname, name);
 			handle = dlopen(fullpath, RTLD_NOW | RTLD_GLOBAL);
diff -urpN frr-frr-5.0.1/lib/mpls.h frr-frr-6.0/lib/mpls.h
--- frr-frr-5.0.1/lib/mpls.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/mpls.h	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 #ifndef _QUAGGA_MPLS_H
 #define _QUAGGA_MPLS_H
 
+#include <zebra.h>
 #include <arpa/inet.h>
 
 #ifdef MPLS_LABEL_MAX
diff -urpN frr-frr-5.0.1/lib/netns_linux.c frr-frr-6.0/lib/netns_linux.c
--- frr-frr-5.0.1/lib/netns_linux.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/netns_linux.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,10 +35,10 @@
 #include "ns.h"
 #include "log.h"
 #include "memory.h"
-
 #include "command.h"
 #include "vty.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, NS, "NetNS Context")
 DEFINE_MTYPE_STATIC(LIB, NS_NAME, "NetNS Name")
@@ -219,15 +219,17 @@ static int ns_enable_internal(struct ns
 		}
 
 		if (!ns_is_enabled(ns)) {
-			zlog_err("Can not enable NS %u: %s!", ns->ns_id,
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "Can not enable NS %u: %s!", ns->ns_id,
+				     safe_strerror(errno));
 			return 0;
 		}
 
 		/* Non default NS. leave */
 		if (ns->ns_id == NS_UNKNOWN) {
-			zlog_err("Can not enable NS %s %u: Invalid NSID",
-				 ns->name, ns->ns_id);
+			flog_err(LIB_ERR_NS,
+				  "Can not enable NS %s %u: Invalid NSID",
+				  ns->name, ns->ns_id);
 			return 0;
 		}
 		if (func)
@@ -435,10 +437,13 @@ char *ns_netns_pathname(struct vty *vty,
 
 	if (!result) {
 		if (vty)
-			vty_out(vty, "Invalid pathname: %s\n",
+			vty_out(vty, "Invalid pathname for %s: %s\n",
+				pathname,
 				safe_strerror(errno));
 		else
-			zlog_warn("Invalid pathname: %s", safe_strerror(errno));
+			zlog_warn("Invalid pathname for %s: %s",
+				  pathname,
+				  safe_strerror(errno));
 		return NULL;
 	}
 	check_base = basename(pathname);
@@ -467,8 +472,9 @@ void ns_init(void)
 	if (have_netns_enabled < 0) {
 		ns_default_ns_fd = open(NS_DEFAULT_NAME, O_RDONLY);
 		if (ns_default_ns_fd == -1)
-			zlog_err("NS initialization failure %d(%s)",
-				 errno, safe_strerror(errno));
+			flog_err(LIB_ERR_NS,
+				  "NS initialization failure %d(%s)", errno,
+				  safe_strerror(errno));
 	} else {
 		ns_default_ns_fd = -1;
 		default_ns = NULL;
@@ -489,7 +495,8 @@ void ns_init_management(ns_id_t default_
 	ns_init();
 	default_ns = ns_get_created_internal(NULL, NULL, default_ns_id);
 	if (!default_ns) {
-		zlog_err("%s: failed to create the default NS!", __func__);
+		flog_err(LIB_ERR_NS, "%s: failed to create the default NS!",
+			  __func__);
 		exit(1);
 	}
 	if (have_netns()) {
@@ -506,7 +513,8 @@ void ns_init_management(ns_id_t default_
 
 	/* Enable the default NS. */
 	if (!ns_enable(default_ns, NULL)) {
-		zlog_err("%s: failed to enable the default NS!", __func__);
+		flog_err(LIB_ERR_NS, "%s: failed to enable the default NS!",
+			  __func__);
 		exit(1);
 	}
 }
diff -urpN frr-frr-5.0.1/lib/nexthop_group.h frr-frr-6.0/lib/nexthop_group.h
--- frr-frr-5.0.1/lib/nexthop_group.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/nexthop_group.h	2018-10-08 14:32:57.000000000 +0200
@@ -56,6 +56,11 @@ void copy_nexthops(struct nexthop **tnh,
 	(nhop);								\
 	(nhop) = nexthop_next(nhop)
 
+#define ALL_NEXTHOPS_PTR(head, nhop)					\
+	(nhop) = ((head)->nexthop);					\
+	(nhop);								\
+	(nhop) = nexthop_next(nhop)
+
 
 struct nexthop_hold {
 	char *nhvrf_name;
diff -urpN frr-frr-5.0.1/lib/pbr.h frr-frr-6.0/lib/pbr.h
--- frr-frr-5.0.1/lib/pbr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/pbr.h	2018-10-08 14:32:57.000000000 +0200
@@ -20,6 +20,12 @@
 #ifndef _PBR_H
 #define _PBR_H
 
+#include <zebra.h>
+#include "stream.h"
+#include "prefix.h"
+
+#define PBR_STR "Policy Based Routing\n"
+
 /*
  * A PBR filter
  *
diff -urpN frr-frr-5.0.1/lib/pid_output.c frr-frr-6.0/lib/pid_output.c
--- frr-frr-5.0.1/lib/pid_output.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/pid_output.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include <log.h>
 #include "version.h"
 #include "network.h"
+#include "lib_errors.h"
 
 #define PIDFILE_MASK 0644
 
@@ -41,8 +42,9 @@ pid_t pid_output(const char *path)
 	oldumask = umask(0777 & ~PIDFILE_MASK);
 	fd = open(path, O_RDWR | O_CREAT, PIDFILE_MASK);
 	if (fd < 0) {
-		zlog_err("Can't create pid lock file %s (%s), exiting", path,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "Can't create pid lock file %s (%s), exiting",
+			     path, safe_strerror(errno));
 		umask(oldumask);
 		exit(1);
 	} else {
@@ -57,19 +59,22 @@ pid_t pid_output(const char *path)
 		lock.l_whence = SEEK_SET;
 
 		if (fcntl(fd, F_SETLK, &lock) < 0) {
-			zlog_err("Could not lock pid_file %s (%s), exiting",
-				 path, safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "Could not lock pid_file %s (%s), exiting",
+				     path, safe_strerror(errno));
 			exit(1);
 		}
 
 		sprintf(buf, "%d\n", (int)pid);
 		pidsize = strlen(buf);
 		if ((tmp = write(fd, buf, pidsize)) != (int)pidsize)
-			zlog_err(
+			flog_err_sys(
+				LIB_ERR_SYSTEM_CALL,
 				"Could not write pid %d to pid_file %s, rc was %d: %s",
 				(int)pid, path, tmp, safe_strerror(errno));
 		else if (ftruncate(fd, pidsize) < 0)
-			zlog_err(
+			flog_err_sys(
+				LIB_ERR_SYSTEM_CALL,
 				"Could not truncate pid_file %s to %u bytes: %s",
 				path, (unsigned int)pidsize,
 				safe_strerror(errno));
diff -urpN frr-frr-5.0.1/lib/plist.c frr-frr-6.0/lib/plist.c
--- frr-frr-5.0.1/lib/plist.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/plist.c	2018-10-08 14:32:57.000000000 +0200
@@ -477,7 +477,7 @@ static void prefix_list_trie_del(struct
 				 struct prefix_list_entry *pentry)
 {
 	size_t depth, maxdepth = plist->master->trie_depth;
-	uint8_t *bytes = &pentry->prefix.u.prefix;
+	uint8_t *bytes = pentry->prefix.u.val;
 	size_t validbits = pentry->prefix.prefixlen;
 	struct pltrie_table *table, **tables[PLC_MAXLEVEL];
 
@@ -565,7 +565,7 @@ static void prefix_list_trie_add(struct
 				 struct prefix_list_entry *pentry)
 {
 	size_t depth = plist->master->trie_depth;
-	uint8_t *bytes = &pentry->prefix.u.prefix;
+	uint8_t *bytes = pentry->prefix.u.val;
 	size_t validbits = pentry->prefix.prefixlen;
 	struct pltrie_table *table;
 
@@ -656,7 +656,7 @@ static const char *prefix_list_type_str(
 }
 
 static int prefix_list_entry_match(struct prefix_list_entry *pentry,
-				   struct prefix *p)
+				   const struct prefix *p)
 {
 	int ret;
 
@@ -683,14 +683,15 @@ static int prefix_list_entry_match(struc
 	return 1;
 }
 
-enum prefix_list_type prefix_list_apply_which_prefix(struct prefix_list *plist,
-						     struct prefix **which,
-						     void *object)
+enum prefix_list_type prefix_list_apply_which_prefix(
+	struct prefix_list *plist,
+	const struct prefix **which,
+	const void *object)
 {
 	struct prefix_list_entry *pentry, *pbest = NULL;
 
-	struct prefix *p = (struct prefix *)object;
-	uint8_t *byte = &p->u.prefix;
+	const struct prefix *p = (const struct prefix *)object;
+	const uint8_t *byte = p->u.val;
 	size_t depth;
 	size_t validbits = p->prefixlen;
 	struct pltrie_table *table;
@@ -774,7 +775,7 @@ static void __attribute__((unused)) pref
 
 			printf("  seq %" PRId64 " %s %s/%d", pentry->seq,
 			       prefix_list_type_str(pentry),
-			       inet_ntop(p->family, &p->u.prefix, buf, BUFSIZ),
+			       inet_ntop(p->family, p->u.val, buf, BUFSIZ),
 			       p->prefixlen);
 			if (pentry->ge)
 				printf(" ge %d", pentry->ge);
@@ -790,7 +791,7 @@ static struct prefix_list_entry *
 prefix_entry_dup_check(struct prefix_list *plist, struct prefix_list_entry *new)
 {
 	size_t depth, maxdepth = plist->master->trie_depth;
-	uint8_t byte, *bytes = &new->prefix.u.prefix;
+	uint8_t byte, *bytes = new->prefix.u.val;
 	size_t validbits = new->prefix.prefixlen;
 	struct pltrie_table *table;
 	struct prefix_list_entry *pentry;
@@ -850,6 +851,11 @@ static int vty_prefix_list_install(struc
 	int lenum = 0;
 	int genum = 0;
 
+	if (name == NULL || prefix == NULL || typestr == NULL) {
+		vty_out(vty, "%% Missing prefix or type\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
 	/* Sequential number. */
 	if (seq)
 		seqnum = (int64_t)atol(seq);
@@ -1140,7 +1146,7 @@ static void vty_show_prefix_entry(struct
 				char buf[BUFSIZ];
 
 				vty_out(vty, "%s/%d",
-					inet_ntop(p->family, &p->u.prefix, buf,
+					inet_ntop(p->family, p->u.val, buf,
 						  BUFSIZ),
 					p->prefixlen);
 
@@ -1247,7 +1253,7 @@ static int vty_show_prefix_list_prefix(s
 				char buf[BUFSIZ];
 
 				vty_out(vty, "%s/%d",
-					inet_ntop(p->family, &p->u.prefix, buf,
+					inet_ntop(p->family, p->u.val, buf,
 						  BUFSIZ),
 					p->prefixlen);
 
@@ -1756,7 +1762,7 @@ static int config_write_prefix_afi(afi_t
 				char buf[BUFSIZ];
 
 				vty_out(vty, "%s/%d",
-					inet_ntop(p->family, &p->u.prefix, buf,
+					inet_ntop(p->family, p->u.val, buf,
 						  BUFSIZ),
 					p->prefixlen);
 
@@ -1795,7 +1801,7 @@ static int config_write_prefix_afi(afi_t
 				char buf[BUFSIZ];
 
 				vty_out(vty, " %s/%d",
-					inet_ntop(p->family, &p->u.prefix, buf,
+					inet_ntop(p->family, p->u.val, buf,
 						  BUFSIZ),
 					p->prefixlen);
 
@@ -1925,7 +1931,7 @@ int prefix_bgp_show_prefix_list(struct v
 			char buf_b[BUFSIZ];
 
 			sprintf(buf_a, "%s/%d",
-				inet_ntop(p->family, &p->u.prefix, buf_b,
+				inet_ntop(p->family, p->u.val, buf_b,
 					  BUFSIZ),
 				p->prefixlen);
 
@@ -1963,7 +1969,7 @@ int prefix_bgp_show_prefix_list(struct v
 			vty_out(vty, "   seq %" PRId64 " %s %s/%d",
 				pentry->seq,
 				prefix_list_type_str(pentry),
-				inet_ntop(p->family, &p->u.prefix, buf, BUFSIZ),
+				inet_ntop(p->family, p->u.val, buf, BUFSIZ),
 				p->prefixlen);
 
 			if (pentry->ge)
diff -urpN frr-frr-5.0.1/lib/plist.h frr-frr-6.0/lib/plist.h
--- frr-frr-5.0.1/lib/plist.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/plist.h	2018-10-08 14:32:57.000000000 +0200
@@ -61,8 +61,9 @@ extern struct prefix_list *prefix_list_l
  * If it is a empty plist return a NULL pointer.
  */
 extern enum prefix_list_type
-prefix_list_apply_which_prefix(struct prefix_list *plist, struct prefix **which,
-			       void *object);
+prefix_list_apply_which_prefix(struct prefix_list *plist,
+			       const struct prefix **which,
+			       const void *object);
 #define prefix_list_apply(A, B) prefix_list_apply_which_prefix((A), NULL, (B))
 
 extern struct prefix_list *prefix_bgp_orf_lookup(afi_t, const char *);
diff -urpN frr-frr-5.0.1/lib/prefix.c frr-frr-6.0/lib/prefix.c
--- frr-frr-5.0.1/lib/prefix.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/prefix.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@
 #include "memory.h"
 #include "log.h"
 #include "jhash.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, PREFIX, "Prefix")
 
@@ -429,6 +430,15 @@ static const struct in6_addr maskbytes6[
 
 #define MASKBIT(offset)  ((0xff << (PNBBY - (offset))) & 0xff)
 
+void prefix_hexdump(const struct prefix *p)
+{
+	char buf[PREFIX_STRLEN];
+
+	zlog_debug("prefix: %s",
+		   prefix2str(p, buf, sizeof(buf)));
+	zlog_hexdump(p, sizeof(struct prefix));
+}
+
 int is_zero_mac(struct ethaddr *mac)
 {
 	int i = 0;
@@ -575,8 +585,8 @@ int prefix_match(const struct prefix *n,
 	}
 
 	/* Set both prefix's head pointer. */
-	np = (const uint8_t *)&n->u.prefix;
-	pp = (const uint8_t *)&p->u.prefix;
+	np = n->u.val;
+	pp = p->u.val;
 
 	offset = n->prefixlen / PNBBY;
 	shift = n->prefixlen % PNBBY;
@@ -600,8 +610,8 @@ int prefix_match_network_statement(const
 	const uint8_t *np, *pp;
 
 	/* Set both prefix's head pointer. */
-	np = (const uint8_t *)&n->u.prefix;
-	pp = (const uint8_t *)&p->u.prefix;
+	np = n->u.val;
+	pp = p->u.val;
 
 	offset = n->prefixlen / PNBBY;
 	shift = n->prefixlen % PNBBY;
@@ -647,8 +657,9 @@ void prefix_copy(struct prefix *dest, co
 		memcpy((void *)dest->u.prefix_flowspec.ptr,
 		       (void *)src->u.prefix_flowspec.ptr, len);
 	} else {
-		zlog_err("prefix_copy(): Unknown address family %d",
-			 src->family);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "prefix_copy(): Unknown address family %d",
+			  src->family);
 		assert(0);
 	}
 }
@@ -733,8 +744,8 @@ int prefix_cmp(const struct prefix *p1,
 				return 1;
 		return 0;
 	}
-	pp1 = (const uint8_t *)&p1->u.prefix;
-	pp2 = (const uint8_t *)&p2->u.prefix;
+	pp1 = p1->u.val;
+	pp2 = p2->u.val;
 
 	if (p1->prefixlen != p2->prefixlen)
 		return 1;
@@ -765,8 +776,8 @@ int prefix_common_bits(const struct pref
 	uint8_t xor ;
 
 	/* Set both prefix's head pointer. */
-	const uint8_t *pp1 = (const uint8_t *)&p1->u.prefix;
-	const uint8_t *pp2 = (const uint8_t *)&p2->u.prefix;
+	const uint8_t *pp1 = p1->u.val;
+	const uint8_t *pp2 = p2->u.val;
 
 	if (p1->family == AF_INET)
 		length = IPV4_MAX_BYTELEN;
@@ -1188,6 +1199,9 @@ int str2prefix(const char *str, struct p
 {
 	int ret;
 
+	if (!str || !p)
+		return 0;
+
 	/* First we try to convert string to struct prefix_ipv4. */
 	ret = str2prefix_ipv4(str, (struct prefix_ipv4 *)p);
 	if (ret)
@@ -1206,54 +1220,109 @@ int str2prefix(const char *str, struct p
 	return 0;
 }
 
-static const char *prefixevpn2str(const struct prefix *p, char *str, int size)
+static const char *prefixevpn_ead2str(const struct prefix_evpn *p, char *str,
+				      int size)
+{
+	snprintf(str, size, "Unsupported EVPN prefix");
+	return str;
+}
+
+static const char *prefixevpn_macip2str(const struct prefix_evpn *p, char *str,
+					int size)
 {
 	uint8_t family;
 	char buf[PREFIX2STR_BUFFER];
 	char buf2[ETHER_ADDR_STRLEN];
 
-	if (p->u.prefix_evpn.route_type == 2) {
-		if (IS_EVPN_PREFIX_IPADDR_NONE((struct prefix_evpn *)p))
-			snprintf(str, size, "[%d]:[%s]/%d",
-				 p->u.prefix_evpn.route_type,
-				 prefix_mac2str(&p->u.prefix_evpn.mac, buf2,
-						sizeof(buf2)),
-				 p->prefixlen);
-		else {
-			family = IS_EVPN_PREFIX_IPADDR_V4(
-					 (struct prefix_evpn *)p)
-					 ? AF_INET
-					 : AF_INET6;
-			snprintf(str, size, "[%d]:[%s]:[%s]/%d",
-				 p->u.prefix_evpn.route_type,
-				 prefix_mac2str(&p->u.prefix_evpn.mac, buf2,
-						sizeof(buf2)),
-				 inet_ntop(family, &p->u.prefix_evpn.ip.ip.addr,
-					   buf, PREFIX2STR_BUFFER),
-				 p->prefixlen);
-		}
-	} else if (p->u.prefix_evpn.route_type == 3) {
-		family = IS_EVPN_PREFIX_IPADDR_V4((struct prefix_evpn *)p)
-				 ? AF_INET
-				 : AF_INET6;
-		snprintf(str, size, "[%d]:[%s]/%d", p->u.prefix_evpn.route_type,
-			 inet_ntop(family, &p->u.prefix_evpn.ip.ip.addr, buf,
-				   PREFIX2STR_BUFFER),
+	if (is_evpn_prefix_ipaddr_none(p))
+		snprintf(str, size, "[%d]:[%s]/%d",
+			 p->prefix.route_type,
+			 prefix_mac2str(&p->prefix.macip_addr.mac,
+					buf2, sizeof(buf2)),
 			 p->prefixlen);
-	} else if (p->u.prefix_evpn.route_type == 5) {
-		family = IS_EVPN_PREFIX_IPADDR_V4((struct prefix_evpn *)p)
+	else {
+		family = is_evpn_prefix_ipaddr_v4(p)
 				 ? AF_INET
 				 : AF_INET6;
-		snprintf(str, size, "[%d]:[%u][%s/%d]/%d",
-			 p->u.prefix_evpn.route_type, p->u.prefix_evpn.eth_tag,
-			 inet_ntop(family, &p->u.prefix_evpn.ip.ip.addr, buf,
-				   PREFIX2STR_BUFFER),
-			 p->u.prefix_evpn.ip_prefix_length, p->prefixlen);
-	} else {
-		sprintf(str, "Unsupported EVPN route type %d",
-			p->u.prefix_evpn.route_type);
+		snprintf(str, size, "[%d]:[%s]:[%s]/%d",
+			 p->prefix.route_type,
+			 prefix_mac2str(&p->prefix.macip_addr.mac,
+					buf2, sizeof(buf2)),
+			 inet_ntop(family,
+				   &p->prefix.macip_addr.ip.ip.addr,
+				   buf, PREFIX2STR_BUFFER),
+			 p->prefixlen);
 	}
+	return str;
+}
+
+static const char *prefixevpn_imet2str(const struct prefix_evpn *p, char *str,
+				       int size)
+{
+	uint8_t family;
+	char buf[PREFIX2STR_BUFFER];
+
+	family = is_evpn_prefix_ipaddr_v4(p)
+			 ? AF_INET
+			 : AF_INET6;
+	snprintf(str, size, "[%d]:[%s]/%d", p->prefix.route_type,
+		 inet_ntop(family,
+			   &p->prefix.imet_addr.ip.ip.addr, buf,
+			   PREFIX2STR_BUFFER),
+		 p->prefixlen);
+	return str;
+}
+
+static const char *prefixevpn_es2str(const struct prefix_evpn *p, char *str,
+				     int size)
+{
+	char buf[ESI_STR_LEN];
 
+	snprintf(str, size, "[%d]:[%s]:[%s]/%d", p->prefix.route_type,
+		 esi_to_str(&p->prefix.es_addr.esi, buf, sizeof(buf)),
+		 inet_ntoa(p->prefix.es_addr.ip.ipaddr_v4),
+		 p->prefixlen);
+	return str;
+}
+
+static const char *prefixevpn_prefix2str(const struct prefix_evpn *p, char *str,
+					 int size)
+{
+	uint8_t family;
+	char buf[PREFIX2STR_BUFFER];
+
+	family = is_evpn_prefix_ipaddr_v4(p)
+			 ? AF_INET
+			 : AF_INET6;
+	snprintf(str, size, "[%d]:[%u][%s/%d]/%d",
+		 p->prefix.route_type,
+		 p->prefix.prefix_addr.eth_tag,
+		 inet_ntop(family,
+			   &p->prefix.prefix_addr.ip.ip.addr, buf,
+			   PREFIX2STR_BUFFER),
+		 p->prefix.prefix_addr.ip_prefix_length,
+		 p->prefixlen);
+	return str;
+}
+
+static const char *prefixevpn2str(const struct prefix_evpn *p, char *str,
+				  int size)
+{
+	switch (p->prefix.route_type) {
+	case 1:
+		return prefixevpn_ead2str(p, str, size);
+	case 2:
+		return prefixevpn_macip2str(p, str, size);
+	case 3:
+		return prefixevpn_imet2str(p, str, size);
+	case 4:
+		return prefixevpn_es2str(p, str, size);
+	case 5:
+		return prefixevpn_prefix2str(p, str, size);
+	default:
+		snprintf(str, size, "Unsupported EVPN prefix");
+		break;
+	}
 	return str;
 }
 
@@ -1277,7 +1346,7 @@ const char *prefix2str(union prefixconst
 		break;
 
 	case AF_EVPN:
-		prefixevpn2str(p, str, size);
+		prefixevpn2str((const struct prefix_evpn *)p, str, size);
 		break;
 
 	case AF_FLOWSPEC:
@@ -1306,17 +1375,6 @@ void prefix_free(struct prefix *p)
 	XFREE(MTYPE_PREFIX, p);
 }
 
-/* Utility function.  Check the string only contains digit
- * character.
- * FIXME str.[c|h] would be better place for this function. */
-int all_digit(const char *str)
-{
-	for (; *str != '\0'; str++)
-		if (!isdigit((int)*str))
-			return 0;
-	return 1;
-}
-
 /* Utility function to convert ipv4 prefixes to Classful prefixes */
 void apply_classful_mask_ipv4(struct prefix_ipv4 *p)
 {
@@ -1490,3 +1548,56 @@ unsigned prefix_hash_key(void *pp)
 		     offsetof(struct prefix, u.prefix) + PSIZE(copy.prefixlen),
 		     0x55aa5a5a);
 }
+
+/* converts to internal representation of esi
+ * returns 1 on success, 0 otherwise
+ * format accepted: aa:aa:aa:aa:aa:aa:aa:aa:aa:aa
+ * if esi parameter is null, then check only
+ */
+int str_to_esi(const char *str, esi_t *esi)
+{
+	int i;
+	unsigned int a[ESI_BYTES];
+
+	if (!str)
+		return 0;
+
+	if (sscanf(str, "%2x:%2x:%2x:%2x:%2x:%2x:%2x:%2x:%2x:%2x",
+		   a + 0, a + 1, a + 2, a + 3,
+		   a + 4, a + 5, a + 6, a + 7,
+		   a + 8, a + 9)
+	    != ESI_BYTES) {
+		/* error in incoming str length */
+		return 0;
+	}
+
+	/* valid ESI */
+	if (!esi)
+		return 1;
+	for (i = 0; i < ESI_BYTES; ++i)
+		esi->val[i] = a[i] & 0xff;
+	return 1;
+}
+
+char *esi_to_str(const esi_t *esi, char *buf, int size)
+{
+	char *ptr;
+
+	if (!esi)
+		return NULL;
+	if (!buf)
+		ptr = (char *)XMALLOC(MTYPE_TMP,
+				      ESI_STR_LEN * sizeof(char));
+	else {
+		assert(size >= ESI_STR_LEN);
+		ptr = buf;
+	}
+
+	snprintf(ptr, ESI_STR_LEN,
+		 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
+		 esi->val[0], esi->val[1], esi->val[2],
+		 esi->val[3], esi->val[4], esi->val[5],
+		 esi->val[6], esi->val[7], esi->val[8],
+		 esi->val[9]);
+	return ptr;
+}
diff -urpN frr-frr-5.0.1/lib/prefix.h frr-frr-6.0/lib/prefix.h
--- frr-frr-5.0.1/lib/prefix.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/prefix.h	2018-10-08 14:32:57.000000000 +0200
@@ -39,6 +39,9 @@
 #define ETH_ALEN 6
 #endif
 
+#define ESI_BYTES 10
+#define ESI_STR_LEN (3 * ESI_BYTES)
+
 #define ETHER_ADDR_STRLEN (3*ETH_ALEN)
 /*
  * there isn't a portable ethernet address type. We define our
@@ -56,26 +59,56 @@ struct ethaddr {
 #define PREFIX_LEN_ROUTE_TYPE_5_IPV4 (18*8)
 #define PREFIX_LEN_ROUTE_TYPE_5_IPV6 (30*8)
 
-/* EVPN address (RFC 7432) */
-struct evpn_addr {
-	uint8_t route_type;
+typedef struct esi_t_ {
+	uint8_t val[10];
+} esi_t;
+
+struct evpn_ead_addr {
+	esi_t esi;
+	uint32_t eth_tag;
+};
+
+struct evpn_macip_addr {
+	uint32_t eth_tag;
 	uint8_t ip_prefix_length;
 	struct ethaddr mac;
+	struct ipaddr ip;
+};
+
+struct evpn_imet_addr {
 	uint32_t eth_tag;
+	uint8_t ip_prefix_length;
+	struct ipaddr ip;
+};
+
+struct evpn_es_addr {
+	esi_t esi;
+	uint8_t ip_prefix_length;
+	struct ipaddr ip;
+};
+
+struct evpn_prefix_addr {
+	uint32_t eth_tag;
+	uint8_t ip_prefix_length;
 	struct ipaddr ip;
-#if 0
-  union
-  {
-    uint8_t addr;
-    struct in_addr v4_addr;
-    struct in6_addr v6_addr;
-  } ip;
-#endif
 };
 
-#define IS_EVPN_PREFIX_IPADDR_NONE(evp)  IS_IPADDR_NONE(&(evp)->prefix.ip)
-#define IS_EVPN_PREFIX_IPADDR_V4(evp)    IS_IPADDR_V4(&(evp)->prefix.ip)
-#define IS_EVPN_PREFIX_IPADDR_V6(evp)    IS_IPADDR_V6(&(evp)->prefix.ip)
+/* EVPN address (RFC 7432) */
+struct evpn_addr {
+	uint8_t route_type;
+	union {
+		struct evpn_ead_addr _ead_addr;
+		struct evpn_macip_addr _macip_addr;
+		struct evpn_imet_addr _imet_addr;
+		struct evpn_es_addr _es_addr;
+		struct evpn_prefix_addr _prefix_addr;
+	} u;
+#define ead_addr u._ead_addr
+#define macip_addr u._macip_addr
+#define imet_addr u._imet_addr
+#define es_addr u._es_addr
+#define prefix_addr u._prefix_addr
+};
 
 /*
  * A struct prefix contains an address family, a prefix length, and an
@@ -177,6 +210,45 @@ struct prefix_evpn {
 	struct evpn_addr prefix __attribute__((aligned(8)));
 };
 
+static inline int is_evpn_prefix_ipaddr_none(const struct prefix_evpn *evp)
+{
+	if (evp->prefix.route_type == 2)
+		return IS_IPADDR_NONE(&(evp)->prefix.macip_addr.ip);
+	if (evp->prefix.route_type == 3)
+		return IS_IPADDR_NONE(&(evp)->prefix.imet_addr.ip);
+	if (evp->prefix.route_type == 4)
+		return IS_IPADDR_NONE(&(evp)->prefix.es_addr.ip);
+	if (evp->prefix.route_type == 5)
+		return IS_IPADDR_NONE(&(evp)->prefix.prefix_addr.ip);
+	return 0;
+}
+
+static inline int is_evpn_prefix_ipaddr_v4(const struct prefix_evpn *evp)
+{
+	if (evp->prefix.route_type == 2)
+		return IS_IPADDR_V4(&(evp)->prefix.macip_addr.ip);
+	if (evp->prefix.route_type == 3)
+		return IS_IPADDR_V4(&(evp)->prefix.imet_addr.ip);
+	if (evp->prefix.route_type == 4)
+		return IS_IPADDR_V4(&(evp)->prefix.es_addr.ip);
+	if (evp->prefix.route_type == 5)
+		return IS_IPADDR_V4(&(evp)->prefix.prefix_addr.ip);
+	return 0;
+}
+
+static inline int is_evpn_prefix_ipaddr_v6(const struct prefix_evpn *evp)
+{
+	if (evp->prefix.route_type == 2)
+		return IS_IPADDR_V6(&(evp)->prefix.macip_addr.ip);
+	if (evp->prefix.route_type == 3)
+		return IS_IPADDR_V6(&(evp)->prefix.imet_addr.ip);
+	if (evp->prefix.route_type == 4)
+		return IS_IPADDR_V6(&(evp)->prefix.es_addr.ip);
+	if (evp->prefix.route_type == 5)
+		return IS_IPADDR_V6(&(evp)->prefix.prefix_addr.ip);
+	return 0;
+}
+
 /* Prefix for a generic pointer */
 struct prefix_ptr {
 	uint8_t family;
@@ -369,6 +441,11 @@ extern char *prefix_mac2str(const struct
 
 extern unsigned prefix_hash_key(void *pp);
 
+extern int str_to_esi(const char *str, esi_t *esi);
+extern char *esi_to_str(const esi_t *esi, char *buf, int size);
+extern void prefix_hexdump(const struct prefix *p);
+extern void prefix_evpn_hexdump(const struct prefix_evpn *p);
+
 static inline int ipv6_martian(struct in6_addr *addr)
 {
 	struct in6_addr localhost_addr;
@@ -381,7 +458,6 @@ static inline int ipv6_martian(struct in
 	return 0;
 }
 
-extern int all_digit(const char *);
 extern int macstr2prefix_evpn(const char *str, struct prefix_evpn *p);
 
 /* NOTE: This routine expects the address argument in network byte order. */
@@ -419,5 +495,4 @@ static inline int is_host_route(struct p
 		return (p->prefixlen == IPV6_MAX_BITLEN);
 	return 0;
 }
-
 #endif /* _ZEBRA_PREFIX_H */
diff -urpN frr-frr-5.0.1/lib/privs.c frr-frr-6.0/lib/privs.c
--- frr-frr-5.0.1/lib/privs.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/privs.c	2018-10-08 14:32:57.000000000 +0200
@@ -696,6 +696,41 @@ static int getgrouplist(const char *user
 }
 #endif /* HAVE_GETGROUPLIST */
 
+struct zebra_privs_t *_zprivs_raise(struct zebra_privs_t *privs,
+				    const char *funcname)
+{
+	int save_errno = errno;
+
+	if (!privs)
+		return NULL;
+
+	errno = 0;
+	if (privs->change(ZPRIVS_RAISE)) {
+		zlog_err("%s: Failed to raise privileges (%s)",
+			 funcname, safe_strerror(errno));
+	}
+	errno = save_errno;
+	privs->raised_in_funcname = funcname;
+	return privs;
+}
+
+void _zprivs_lower(struct zebra_privs_t **privs)
+{
+	int save_errno = errno;
+
+	if (!*privs)
+		return;
+
+	errno = 0;
+	if ((*privs)->change(ZPRIVS_LOWER)) {
+		zlog_err("%s: Failed to lower privileges (%s)",
+			 (*privs)->raised_in_funcname, safe_strerror(errno));
+	}
+	errno = save_errno;
+	(*privs)->raised_in_funcname = NULL;
+	*privs = NULL;
+}
+
 void zprivs_preinit(struct zebra_privs_t *zprivs)
 {
 	struct passwd *pwentry = NULL;
@@ -824,6 +859,19 @@ void zprivs_init(struct zebra_privs_t *z
 
 #ifdef HAVE_CAPABILITIES
 	zprivs_caps_init(zprivs);
+
+	/*
+	 * If we have initialized the system with no requested
+	 * capabilities, change will not have been set
+	 * to anything by zprivs_caps_init, As such
+	 * we should make sure that when we attempt
+	 * to raize privileges that we actually have
+	 * a do nothing function to call instead of a
+	 * crash :).
+	 */
+	if (!zprivs->change)
+		zprivs->change = zprivs_change_null;
+
 #else  /* !HAVE_CAPABILITIES */
 	/* we dont have caps. we'll need to maintain rid and saved uid
 	 * and change euid back to saved uid (who we presume has all neccessary
diff -urpN frr-frr-5.0.1/lib/privs.h frr-frr-6.0/lib/privs.h
--- frr-frr-5.0.1/lib/privs.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/privs.h	2018-10-08 14:32:57.000000000 +0200
@@ -62,6 +62,7 @@ struct zebra_privs_t {
 	int (*change)(zebra_privs_ops_t); /* change privileges, 0 on success */
 	zebra_privs_current_t (*current_state)(
 		void); /* current privilege state */
+	const char *raised_in_funcname;
 };
 
 struct zprivs_ids_t {
@@ -81,4 +82,42 @@ extern void zprivs_terminate(struct zebr
 /* query for runtime uid's and gid's, eg vty needs this */
 extern void zprivs_get_ids(struct zprivs_ids_t *);
 
+/*
+ * Wrapper around zprivs, to be used as:
+ *   frr_elevate_privs(&privs) {
+ *     ... code ...
+ *     if (error)
+ *       break;         -- break can be used to get out of the block
+ *     ... code ...
+ *   }
+ *
+ * The argument to frr_elevate_privs() can be NULL to leave privileges as-is
+ * (mostly useful for conditional privilege-raising, i.e.:)
+ *   frr_elevate_privs(cond ? &privs : NULL) {}
+ *
+ * NB: The code block is always executed, regardless of whether privileges
+ * could be raised or not, or whether NULL was given or not.  This is fully
+ * intentional;  the user may have configured some RBAC or similar that we
+ * are not aware of, but that allows our code to proceed without privileges.
+ *
+ * The point of this wrapper is to prevent accidental bugs where privileges
+ * are elevated but then not dropped.  This can happen when, for example, a
+ * "return", "goto" or "break" in the middle of the elevated-privilege code
+ * skips past the privilege dropping call.
+ *
+ * The macro below uses variable cleanup to drop privileges as soon as the
+ * code block is left in any way (and thus the _privs variable goes out of
+ * scope.)  _once is just a trick to run the loop exactly once.
+ */
+extern struct zebra_privs_t *_zprivs_raise(struct zebra_privs_t *privs,
+					   const char *funcname);
+extern void _zprivs_lower(struct zebra_privs_t **privs);
+
+#define frr_elevate_privs(privs)                                               \
+	for (struct zebra_privs_t *_once = NULL,                               \
+				  *_privs __attribute__(                       \
+					  (unused, cleanup(_zprivs_lower))) =  \
+					  _zprivs_raise(privs, __func__);      \
+	     _once == NULL; _once = (void *)1)
+
 #endif /* _ZEBRA_PRIVS_H */
diff -urpN frr-frr-5.0.1/lib/ptm_lib.c frr-frr-6.0/lib/ptm_lib.c
--- frr-frr-5.0.1/lib/ptm_lib.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/ptm_lib.c	2018-10-08 14:32:57.000000000 +0200
@@ -60,10 +60,10 @@ static csv_record_t *_ptm_lib_encode_hea
 	char client_buf[32];
 	csv_record_t *rec1;
 
-	sprintf(msglen_buf, "%4u", msglen);
-	sprintf(vers_buf, "%4u", version);
-	sprintf(type_buf, "%4u", type);
-	sprintf(cmdid_buf, "%4u", cmd_id);
+	sprintf(msglen_buf, "%4d", msglen);
+	sprintf(vers_buf, "%4d", version);
+	sprintf(type_buf, "%4d", type);
+	sprintf(cmdid_buf, "%4d", cmd_id);
 	snprintf(client_buf, 17, "%16.16s", client_name);
 	if (rec) {
 		rec1 = csv_encode_record(csv, rec, 5, msglen_buf, vers_buf,
diff -urpN frr-frr-5.0.1/lib/route_types.txt frr-frr-6.0/lib/route_types.txt
--- frr-frr-5.0.1/lib/route_types.txt	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/route_types.txt	2018-10-08 14:32:57.000000000 +0200
@@ -81,6 +81,7 @@ ZEBRA_ROUTE_BGP_DIRECT_EXT, bgp-direct-t
 ZEBRA_ROUTE_BABEL,      babel,     babeld, 'A', 1, 1, 1,     "Babel"
 ZEBRA_ROUTE_SHARP,      sharp,     sharpd, 'D', 1, 1, 1,     "SHARP"
 ZEBRA_ROUTE_PBR,        pbr,       pbrd,   'F', 1, 1, 0,     "PBR"
+ZEBRA_ROUTE_BFD,        bfd,       bfdd,   '-', 0, 0, 0,     "BFD"
 ZEBRA_ROUTE_ALL,        wildcard,  none,   '-', 0, 0, 0,     "-"
 
 
@@ -107,3 +108,4 @@ ZEBRA_ROUTE_VNC_DIRECT,    "VNC direct (
 ZEBRA_ROUTE_BABEL,  "Babel routing protocol (Babel)"
 ZEBRA_ROUTE_SHARP, "Super Happy Advanced Routing Protocol (sharpd)"
 ZEBRA_ROUTE_PBR, "Policy Based Routing (PBR)"
+ZEBRA_ROUTE_BFD, "Bidirectional Fowarding Detection (BFD)"
diff -urpN frr-frr-5.0.1/lib/routemap.c frr-frr-6.0/lib/routemap.c
--- frr-frr-5.0.1/lib/routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -751,7 +751,7 @@ struct route_map *route_map_lookup_by_na
 	return map;
 }
 
-int route_map_mark_updated(const char *name, int del_later)
+int route_map_mark_updated(const char *name)
 {
 	struct route_map *map;
 	int ret = -1;
@@ -781,7 +781,7 @@ int route_map_mark_updated(const char *n
 	return (ret);
 }
 
-int route_map_clear_updated(struct route_map *map)
+static int route_map_clear_updated(struct route_map *map)
 {
 	int ret = -1;
 
@@ -807,7 +807,7 @@ static struct route_map *route_map_get(c
 	return map;
 }
 
-void route_map_walk_update_list(int (*route_map_update_fn)(char *name))
+void route_map_walk_update_list(void (*route_map_update_fn)(char *name))
 {
 	struct route_map *node;
 	struct route_map *nnode = NULL;
@@ -1387,7 +1387,7 @@ int route_map_delete_set(struct route_ma
 
 static route_map_result_t
 route_map_apply_match(struct route_map_rule_list *match_list,
-		      struct prefix *prefix, route_map_object_t type,
+		      const struct prefix *prefix, route_map_object_t type,
 		      void *object)
 {
 	route_map_result_t ret = RMAP_NOMATCH;
@@ -1417,7 +1417,8 @@ route_map_apply_match(struct route_map_r
 }
 
 /* Apply route map to the object. */
-route_map_result_t route_map_apply(struct route_map *map, struct prefix *prefix,
+route_map_result_t route_map_apply(struct route_map *map,
+				   const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	static int recursion = 0;
@@ -1544,7 +1545,7 @@ static void route_map_clear_reference(st
 	struct route_map_dep *dep = (struct route_map_dep *)backet->data;
 	char *rmap_name;
 
-	if (dep && arg) {
+	if (arg) {
 		rmap_name =
 			(char *)hash_release(dep->dep_rmap_hash, (void *)arg);
 		if (rmap_name) {
@@ -1600,9 +1601,8 @@ static void route_map_print_dependency(s
 	char *rmap_name = (char *)backet->data;
 	char *dep_name = (char *)data;
 
-	if (rmap_name)
-		zlog_debug("%s: Dependency for %s: %s", __FUNCTION__, dep_name,
-			   rmap_name);
+	zlog_debug("%s: Dependency for %s: %s", __FUNCTION__, dep_name,
+		   rmap_name);
 }
 
 static int route_map_dep_update(struct hash *dephash, const char *dep_name,
@@ -1724,18 +1724,14 @@ static struct hash *route_map_get_dep_ha
 
 static void route_map_process_dependency(struct hash_backet *backet, void *data)
 {
-	char *rmap_name;
+	char *rmap_name = (char *)backet->data;
 	route_map_event_t type = (route_map_event_t)(ptrdiff_t)data;
 
-	rmap_name = (char *)backet->data;
-
-	if (rmap_name) {
-		if (rmap_debug)
-			zlog_debug("%s: Notifying %s of dependency",
-				   __FUNCTION__, rmap_name);
-		if (route_map_master.event_hook)
-			(*route_map_master.event_hook)(type, rmap_name);
-	}
+	if (rmap_debug)
+		zlog_debug("%s: Notifying %s of dependency",
+			   __FUNCTION__, rmap_name);
+	if (route_map_master.event_hook)
+		(*route_map_master.event_hook)(type, rmap_name);
 }
 
 void route_map_upd8_dependency(route_map_event_t type, const char *arg,
@@ -2740,6 +2736,15 @@ void route_map_finish(void)
 	vector_free(route_set_vec);
 	route_set_vec = NULL;
 
+	/*
+	 * All protocols are setting these to NULL
+	 * by default on shutdown( route_map_finish )
+	 * Why are we making them do this work?
+	 */
+	route_map_master.add_hook = NULL;
+	route_map_master.delete_hook = NULL;
+	route_map_master.event_hook = NULL;
+
 	/* cleanup route_map */
 	while (route_map_master.head) {
 		struct route_map *map = route_map_master.head;
diff -urpN frr-frr-5.0.1/lib/routemap.h frr-frr-6.0/lib/routemap.h
--- frr-frr-5.0.1/lib/routemap.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/routemap.h	2018-10-08 14:32:57.000000000 +0200
@@ -87,8 +87,10 @@ struct route_map_rule_cmd {
 	const char *str;
 
 	/* Function for value set or match. */
-	route_map_result_t (*func_apply)(void *, struct prefix *,
-					 route_map_object_t, void *);
+	route_map_result_t (*func_apply)(void *rule,
+					 const struct prefix *prefix,
+					 route_map_object_t type,
+					 void *object);
 
 	/* Compile argument and return result as void *. */
 	void *(*func_compile)(const char *);
@@ -167,6 +169,12 @@ DECLARE_QOBJ_TYPE(route_map)
 
 /* Prototypes. */
 extern void route_map_init(void);
+
+/*
+ * This should only be called on shutdown
+ * Additionally this function sets the hooks to NULL
+ * before any processing is done.
+ */
 extern void route_map_finish(void);
 
 /* Add match statement to route map. */
@@ -208,16 +216,15 @@ extern struct route_map *route_map_looku
 
 /* Apply route map to the object. */
 extern route_map_result_t route_map_apply(struct route_map *map,
-					  struct prefix *,
+					  const struct prefix *prefix,
 					  route_map_object_t object_type,
 					  void *object);
 
 extern void route_map_add_hook(void (*func)(const char *));
 extern void route_map_delete_hook(void (*func)(const char *));
 extern void route_map_event_hook(void (*func)(route_map_event_t, const char *));
-extern int route_map_mark_updated(const char *name, int deleted);
-extern int route_map_clear_updated(struct route_map *rmap);
-extern void route_map_walk_update_list(int (*update_fn)(char *name));
+extern int route_map_mark_updated(const char *name);
+extern void route_map_walk_update_list(void (*update_fn)(char *name));
 extern void route_map_upd8_dependency(route_map_event_t type, const char *arg,
 				      const char *rmap_name);
 extern void route_map_notify_dependencies(const char *affected_name,
diff -urpN frr-frr-5.0.1/lib/sbuf.c frr-frr-6.0/lib/sbuf.c
--- frr-frr-5.0.1/lib/sbuf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/sbuf.c	2018-10-08 14:32:57.000000000 +0200
@@ -63,13 +63,12 @@ void sbuf_push(struct sbuf *buf, int ind
 	int written;
 
 	if (!buf->fixed) {
-		char dummy;
 		int written1, written2;
 		size_t new_size;
 
-		written1 = snprintf(&dummy, 0, "%*s", indent, "");
+		written1 = indent;
 		va_start(args, format);
-		written2 = vsnprintf(&dummy, 0, format, args);
+		written2 = vsnprintf(NULL, 0, format, args);
 		va_end(args);
 
 		new_size = buf->size;
diff -urpN frr-frr-5.0.1/lib/sigevent.c frr-frr-6.0/lib/sigevent.c
--- frr-frr-5.0.1/lib/sigevent.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/sigevent.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 #include <sigevent.h>
 #include <log.h>
 #include <memory.h>
+#include <lib_errors.h>
 
 #ifdef SA_SIGINFO
 #ifdef HAVE_UCONTEXT_H
@@ -83,7 +84,8 @@ int quagga_sigevent_process(void)
 	sigdelset(&newmask, SIGKILL);
 
 	if ((sigprocmask(SIG_BLOCK, &newmask, &oldmask)) < 0) {
-		zlog_err("quagga_signal_timer: couldnt block signals!");
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "quagga_signal_timer: couldnt block signals!");
 		return -1;
 	}
 #endif /* SIGEVENT_BLOCK_SIGNALS */
@@ -119,8 +121,6 @@ int quagga_sigevent_process(void)
 int quagga_signal_timer(struct thread *t)
 {
 	struct quagga_sigevent_master_t *sigm;
-	struct quagga_signal_t *sig;
-	int i;
 
 	sigm = THREAD_ARG(t);
 	sigm->t = NULL;
diff -urpN frr-frr-5.0.1/lib/skiplist.c frr-frr-6.0/lib/skiplist.c
--- frr-frr-5.0.1/lib/skiplist.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/skiplist.c	2018-10-08 14:32:57.000000000 +0200
@@ -60,6 +60,7 @@
 #include "log.h"
 #include "vty.h"
 #include "skiplist.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, SKIP_LIST, "Skip List")
 DEFINE_MTYPE_STATIC(LIB, SKIP_LIST_NODE, "Skip Node")
@@ -182,7 +183,8 @@ int skiplist_insert(register struct skip
 
 	/* DEBUG */
 	if (!key) {
-		zlog_err("%s: key is 0, value is %p", __func__, value);
+		flog_err(LIB_ERR_DEVELOPMENT, "%s: key is 0, value is %p",
+			  __func__, value);
 	}
 
 	p = l->header;
diff -urpN frr-frr-5.0.1/lib/smux.c frr-frr-6.0/lib/smux.c
--- frr-frr-5.0.1/lib/smux.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/smux.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1416 +0,0 @@
-/* SNMP support
- * Copyright (C) 1999 Kunihiro Ishiguro <kunihiro@zebra.org>
- *
- * This file is part of GNU Zebra.
- *
- * GNU Zebra is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * GNU Zebra is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <zebra.h>
-
-#ifdef SNMP_SMUX
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-
-#include "log.h"
-#include "thread.h"
-#include "linklist.h"
-#include "command.h"
-#include <lib/version.h>
-#include "memory.h"
-#include "sockunion.h"
-#include "smux.h"
-
-#define SMUX_PORT_DEFAULT 199
-
-#define SMUXMAXPKTSIZE    1500
-#define SMUXMAXSTRLEN      256
-
-#define SMUX_OPEN       (ASN_APPLICATION | ASN_CONSTRUCTOR | 0)
-#define SMUX_CLOSE      (ASN_APPLICATION | ASN_PRIMITIVE | 1)
-#define SMUX_RREQ       (ASN_APPLICATION | ASN_CONSTRUCTOR | 2)
-#define SMUX_RRSP       (ASN_APPLICATION | ASN_PRIMITIVE | 3)
-#define SMUX_SOUT       (ASN_APPLICATION | ASN_PRIMITIVE | 4)
-
-#define SMUX_GET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0)
-#define SMUX_GETNEXT    (ASN_CONTEXT | ASN_CONSTRUCTOR | 1)
-#define SMUX_GETRSP     (ASN_CONTEXT | ASN_CONSTRUCTOR | 2)
-#define SMUX_SET	(ASN_CONTEXT | ASN_CONSTRUCTOR | 3)
-#define SMUX_TRAP	(ASN_CONTEXT | ASN_CONSTRUCTOR | 4)
-
-#define SMUX_MAX_FAILURE 3
-
-/* SNMP tree. */
-struct subtree {
-	/* Tree's oid. */
-	oid name[MAX_OID_LEN];
-	uint8_t name_len;
-
-	/* List of the variables. */
-	struct variable *variables;
-
-	/* Length of the variables list. */
-	int variables_num;
-
-	/* Width of the variables list. */
-	int variables_width;
-
-	/* Registered flag. */
-	int registered;
-};
-
-#define min(A,B) ((A) < (B) ? (A) : (B))
-
-enum smux_event { SMUX_SCHEDULE, SMUX_CONNECT, SMUX_READ };
-
-void smux_event(enum smux_event, int);
-
-
-/* SMUX socket. */
-int smux_sock = -1;
-
-/* SMUX subtree list. */
-struct list *treelist;
-
-/* SMUX oid. */
-oid *smux_oid = NULL;
-size_t smux_oid_len;
-
-/* SMUX password. */
-char *smux_passwd = NULL;
-
-/* SMUX read threads. */
-struct thread *smux_read_thread;
-
-/* SMUX connect thrads. */
-struct thread *smux_connect_thread;
-
-/* SMUX debug flag. */
-int debug_smux = 0;
-
-/* SMUX failure count. */
-int fail = 0;
-
-/* SMUX node. */
-static struct cmd_node smux_node = {
-	SMUX_NODE, "" /* SMUX has no interface. */
-};
-
-/* thread master */
-static struct thread_master *smux_master;
-
-static int oid_compare_part(oid *o1, int o1_len, oid *o2, int o2_len)
-{
-	int i;
-
-	for (i = 0; i < min(o1_len, o2_len); i++) {
-		if (o1[i] < o2[i])
-			return -1;
-		else if (o1[i] > o2[i])
-			return 1;
-	}
-	if (o1_len < o2_len)
-		return -1;
-
-	return 0;
-}
-
-static void smux_oid_dump(const char *prefix, const oid *oid, size_t oid_len)
-{
-	unsigned int i;
-	int first = 1;
-	char buf[MAX_OID_LEN * 3];
-
-	buf[0] = '\0';
-
-	for (i = 0; i < oid_len; i++) {
-		sprintf(buf + strlen(buf), "%s%d", first ? "" : ".",
-			(int)oid[i]);
-		first = 0;
-	}
-	zlog_debug("%s: %s", prefix, buf);
-}
-
-static int smux_socket(void)
-{
-	int ret;
-	struct addrinfo hints, *res0, *res;
-	int gai;
-	int sock = 0;
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = PF_UNSPEC;
-	hints.ai_socktype = SOCK_STREAM;
-	gai = getaddrinfo(NULL, "smux", &hints, &res0);
-	if (gai == EAI_SERVICE) {
-		char servbuf[NI_MAXSERV];
-		sprintf(servbuf, "%d", SMUX_PORT_DEFAULT);
-		servbuf[sizeof(servbuf) - 1] = '\0';
-		gai = getaddrinfo(NULL, servbuf, &hints, &res0);
-	}
-	if (gai) {
-		zlog_warn("Cannot locate loopback service smux");
-		return -1;
-	}
-	for (res = res0; res; res = res->ai_next) {
-		if (res->ai_family != AF_INET && res->ai_family != AF_INET6)
-			continue;
-
-		sock = socket(res->ai_family, res->ai_socktype,
-			      res->ai_protocol);
-		if (sock < 0)
-			continue;
-		sockopt_reuseaddr(sock);
-		sockopt_reuseport(sock);
-		ret = connect(sock, res->ai_addr, res->ai_addrlen);
-		if (ret < 0) {
-			close(sock);
-			sock = -1;
-			continue;
-		}
-		break;
-	}
-	freeaddrinfo(res0);
-	if (sock < 0)
-		zlog_warn("Can't connect to SNMP agent with SMUX");
-	return sock;
-}
-
-static void smux_getresp_send(oid objid[], size_t objid_len, long reqid,
-			      long errstat, long errindex, uint8_t val_type,
-			      void *arg, size_t arg_len)
-{
-	uint8_t buf[BUFSIZ];
-	uint8_t *ptr, *h1, *h1e, *h2, *h2e;
-	size_t len, length;
-
-	ptr = buf;
-	len = BUFSIZ;
-	length = len;
-
-	if (debug_smux) {
-		zlog_debug("SMUX GETRSP send");
-		zlog_debug("SMUX GETRSP reqid: %ld", reqid);
-	}
-
-	h1 = ptr;
-	/* Place holder h1 for complete sequence */
-	ptr = asn_build_sequence(ptr, &len, (uint8_t)SMUX_GETRSP, 0);
-	h1e = ptr;
-
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER), &reqid,
-		sizeof(reqid));
-
-	if (debug_smux)
-		zlog_debug("SMUX GETRSP errstat: %ld", errstat);
-
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-		&errstat, sizeof(errstat));
-	if (debug_smux)
-		zlog_debug("SMUX GETRSP errindex: %ld", errindex);
-
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-		&errindex, sizeof(errindex));
-
-	h2 = ptr;
-	/* Place holder h2 for one variable */
-	ptr = asn_build_sequence(ptr, &len,
-				 (uint8_t)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
-	h2e = ptr;
-
-	ptr = snmp_build_var_op(ptr, objid, &objid_len, val_type, arg_len, arg,
-				&len);
-
-	/* Now variable size is known, fill in size */
-	asn_build_sequence(h2, &length,
-			   (uint8_t)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
-			   ptr - h2e);
-
-	/* Fill in size of whole sequence */
-	asn_build_sequence(h1, &length, (uint8_t)SMUX_GETRSP, ptr - h1e);
-
-	if (debug_smux)
-		zlog_debug("SMUX getresp send: %td", (ptr - buf));
-
-	send(smux_sock, buf, (ptr - buf), 0);
-}
-
-static uint8_t *smux_var(uint8_t *ptr, size_t len, oid objid[],
-			 size_t *objid_len, size_t *var_val_len,
-			 uint8_t *var_val_type, void **var_value)
-{
-	uint8_t type;
-	uint8_t val_type;
-	size_t val_len;
-	uint8_t *val;
-
-	if (debug_smux)
-		zlog_debug("SMUX var parse: len %zd", len);
-
-	/* Parse header. */
-	ptr = asn_parse_header(ptr, &len, &type);
-
-	if (debug_smux) {
-		zlog_debug("SMUX var parse: type %d len %zd", type, len);
-		zlog_debug("SMUX var parse: type must be %d",
-			   (ASN_SEQUENCE | ASN_CONSTRUCTOR));
-	}
-
-	/* Parse var option. */
-	*objid_len = MAX_OID_LEN;
-	ptr = snmp_parse_var_op(ptr, objid, objid_len, &val_type, &val_len,
-				&val, &len);
-
-	if (var_val_len)
-		*var_val_len = val_len;
-
-	if (var_value)
-		*var_value = (void *)val;
-
-	if (var_val_type)
-		*var_val_type = val_type;
-
-	/* Requested object id length is objid_len. */
-	if (debug_smux)
-		smux_oid_dump("Request OID", objid, *objid_len);
-
-	if (debug_smux)
-		zlog_debug("SMUX val_type: %d", val_type);
-
-	/* Check request value type. */
-	if (debug_smux)
-		switch (val_type) {
-		case ASN_NULL:
-			/* In case of SMUX_GET or SMUX_GET_NEXT val_type is set
-			   to
-			   ASN_NULL. */
-			zlog_debug("ASN_NULL");
-			break;
-
-		case ASN_INTEGER:
-			zlog_debug("ASN_INTEGER");
-			break;
-		case ASN_COUNTER:
-		case ASN_GAUGE:
-		case ASN_TIMETICKS:
-		case ASN_UINTEGER:
-			zlog_debug("ASN_COUNTER");
-			break;
-		case ASN_COUNTER64:
-			zlog_debug("ASN_COUNTER64");
-			break;
-		case ASN_IPADDRESS:
-			zlog_debug("ASN_IPADDRESS");
-			break;
-		case ASN_OCTET_STR:
-			zlog_debug("ASN_OCTET_STR");
-			break;
-		case ASN_OPAQUE:
-		case ASN_NSAP:
-		case ASN_OBJECT_ID:
-			zlog_debug("ASN_OPAQUE");
-			break;
-		case SNMP_NOSUCHOBJECT:
-			zlog_debug("SNMP_NOSUCHOBJECT");
-			break;
-		case SNMP_NOSUCHINSTANCE:
-			zlog_debug("SNMP_NOSUCHINSTANCE");
-			break;
-		case SNMP_ENDOFMIBVIEW:
-			zlog_debug("SNMP_ENDOFMIBVIEW");
-			break;
-		case ASN_BIT_STR:
-			zlog_debug("ASN_BIT_STR");
-			break;
-		default:
-			zlog_debug("Unknown type");
-			break;
-		}
-	return ptr;
-}
-
-/* NOTE: all 3 functions (smux_set, smux_get & smux_getnext) are based on
-   ucd-snmp smux and as such suppose, that the peer receives in the message
-   only one variable. Fortunately, IBM seems to do the same in AIX. */
-
-static int smux_set(oid *reqid, size_t *reqid_len, uint8_t val_type, void *val,
-		    size_t val_len, int action)
-{
-	int j;
-	struct subtree *subtree;
-	struct variable *v;
-	int subresult;
-	oid *suffix;
-	size_t suffix_len;
-	int result;
-	uint8_t *statP = NULL;
-	WriteMethod *write_method = NULL;
-	struct listnode *node, *nnode;
-
-	/* Check */
-	for (ALL_LIST_ELEMENTS(treelist, node, nnode, subtree)) {
-		subresult = oid_compare_part(reqid, *reqid_len, subtree->name,
-					     subtree->name_len);
-
-		/* Subtree matched. */
-		if (subresult == 0) {
-			/* Prepare suffix. */
-			suffix = reqid + subtree->name_len;
-			suffix_len = *reqid_len - subtree->name_len;
-			result = subresult;
-
-			/* Check variables. */
-			for (j = 0; j < subtree->variables_num; j++) {
-				v = &subtree->variables[j];
-
-				/* Always check suffix */
-				result = oid_compare_part(suffix, suffix_len,
-							  v->name, v->namelen);
-
-				/* This is exact match so result must be zero.
-				 */
-				if (result == 0) {
-					if (debug_smux)
-						zlog_debug(
-							"SMUX function call index is %d",
-							v->magic);
-
-					statP = (*v->findVar)(
-						v, suffix, &suffix_len, 1,
-						&val_len, &write_method);
-
-					if (write_method) {
-						return (*write_method)(
-							action, val, val_type,
-							val_len, statP, suffix,
-							suffix_len);
-					} else {
-						return SNMP_ERR_READONLY;
-					}
-				}
-
-				/* If above execution is failed or oid is small
-				   (so
-				   there is no further match). */
-				if (result < 0)
-					return SNMP_ERR_NOSUCHNAME;
-			}
-		}
-	}
-	return SNMP_ERR_NOSUCHNAME;
-}
-
-static int smux_get(oid *reqid, size_t *reqid_len, int exact, uint8_t *val_type,
-		    void **val, size_t *val_len)
-{
-	int j;
-	struct subtree *subtree;
-	struct variable *v;
-	int subresult;
-	oid *suffix;
-	size_t suffix_len;
-	int result;
-	WriteMethod *write_method = NULL;
-	struct listnode *node, *nnode;
-
-	/* Check */
-	for (ALL_LIST_ELEMENTS(treelist, node, nnode, subtree)) {
-		subresult = oid_compare_part(reqid, *reqid_len, subtree->name,
-					     subtree->name_len);
-
-		/* Subtree matched. */
-		if (subresult == 0) {
-			/* Prepare suffix. */
-			suffix = reqid + subtree->name_len;
-			suffix_len = *reqid_len - subtree->name_len;
-			result = subresult;
-
-			/* Check variables. */
-			for (j = 0; j < subtree->variables_num; j++) {
-				v = &subtree->variables[j];
-
-				/* Always check suffix */
-				result = oid_compare_part(suffix, suffix_len,
-							  v->name, v->namelen);
-
-				/* This is exact match so result must be zero.
-				 */
-				if (result == 0) {
-					if (debug_smux)
-						zlog_debug(
-							"SMUX function call index is %d",
-							v->magic);
-
-					*val = (*v->findVar)(
-						v, suffix, &suffix_len, exact,
-						val_len, &write_method);
-
-					/* There is no instance. */
-					if (*val == NULL)
-						return SNMP_NOSUCHINSTANCE;
-
-					/* Call is suceed. */
-					*val_type = v->type;
-
-					return 0;
-				}
-
-				/* If above execution is failed or oid is small
-				   (so
-				   there is no further match). */
-				if (result < 0)
-					return SNMP_ERR_NOSUCHNAME;
-			}
-		}
-	}
-	return SNMP_ERR_NOSUCHNAME;
-}
-
-static int smux_getnext(oid *reqid, size_t *reqid_len, int exact,
-			uint8_t *val_type, void **val, size_t *val_len)
-{
-	int j;
-	oid save[MAX_OID_LEN];
-	int savelen = 0;
-	struct subtree *subtree;
-	struct variable *v;
-	int subresult;
-	oid *suffix;
-	size_t suffix_len;
-	int result;
-	WriteMethod *write_method = NULL;
-	struct listnode *node, *nnode;
-
-
-	/* Save incoming request. */
-	oid_copy(save, reqid, *reqid_len);
-	savelen = *reqid_len;
-
-	/* Check */
-	for (ALL_LIST_ELEMENTS(treelist, node, nnode, subtree)) {
-		subresult = oid_compare_part(reqid, *reqid_len, subtree->name,
-					     subtree->name_len);
-
-		/* If request is in the tree. The agent has to make sure we
-		   only receive requests we have registered for. */
-		/* Unfortunately, that's not true. In fact, a SMUX subagent has
-		   to
-		   behave as if it manages the whole SNMP MIB tree itself. It's
-		   the
-		   duty of the master agent to collect the best answer and
-		   return it
-		   to the manager. See RFC 1227 chapter 3.1.6 for the glory
-		   details
-		   :-). ucd-snmp really behaves bad here as it actually might
-		   ask
-		   multiple times for the same GETNEXT request as it throws away
-		   the
-		   answer when it expects it in a different subtree and might
-		   come
-		   back later with the very same request. --jochen */
-
-		if (subresult <= 0) {
-			/* Prepare suffix. */
-			suffix = reqid + subtree->name_len;
-			suffix_len = *reqid_len - subtree->name_len;
-			if (subresult < 0) {
-				oid_copy(reqid, subtree->name,
-					 subtree->name_len);
-				*reqid_len = subtree->name_len;
-			}
-			for (j = 0; j < subtree->variables_num; j++) {
-				result = subresult;
-				v = &subtree->variables[j];
-
-				/* Next then check result >= 0. */
-				if (result == 0)
-					result = oid_compare_part(
-						suffix, suffix_len, v->name,
-						v->namelen);
-
-				if (result <= 0) {
-					if (debug_smux)
-						zlog_debug(
-							"SMUX function call index is %d",
-							v->magic);
-					if (result < 0) {
-						oid_copy(suffix, v->name,
-							 v->namelen);
-						suffix_len = v->namelen;
-					}
-					*val = (*v->findVar)(
-						v, suffix, &suffix_len, exact,
-						val_len, &write_method);
-					*reqid_len =
-						suffix_len + subtree->name_len;
-					if (*val) {
-						*val_type = v->type;
-						return 0;
-					}
-				}
-			}
-		}
-	}
-	memcpy(reqid, save, savelen * sizeof(oid));
-	*reqid_len = savelen;
-
-	return SNMP_ERR_NOSUCHNAME;
-}
-
-/* GET message header. */
-static uint8_t *smux_parse_get_header(uint8_t *ptr, size_t *len, long *reqid)
-{
-	uint8_t type;
-	long errstat;
-	long errindex;
-
-	/* Request ID. */
-	ptr = asn_parse_int(ptr, len, &type, reqid, sizeof(*reqid));
-
-	if (debug_smux)
-		zlog_debug("SMUX GET reqid: %d len: %d", (int)*reqid,
-			   (int)*len);
-
-	/* Error status. */
-	ptr = asn_parse_int(ptr, len, &type, &errstat, sizeof(errstat));
-
-	if (debug_smux)
-		zlog_debug("SMUX GET errstat %ld len: %zd", errstat, *len);
-
-	/* Error index. */
-	ptr = asn_parse_int(ptr, len, &type, &errindex, sizeof(errindex));
-
-	if (debug_smux)
-		zlog_debug("SMUX GET errindex %ld len: %zd", errindex, *len);
-
-	return ptr;
-}
-
-static void smux_parse_set(uint8_t *ptr, size_t len, int action)
-{
-	long reqid;
-	oid oid[MAX_OID_LEN];
-	size_t oid_len;
-	uint8_t val_type;
-	void *val;
-	size_t val_len;
-	int ret;
-
-	if (debug_smux)
-		zlog_debug("SMUX SET(%s) message parse: len %zd",
-			   (RESERVE1 == action)
-				   ? "RESERVE1"
-				   : ((FREE == action) ? "FREE" : "COMMIT"),
-			   len);
-
-	/* Parse SET message header. */
-	ptr = smux_parse_get_header(ptr, &len, &reqid);
-
-	/* Parse SET message object ID. */
-	ptr = smux_var(ptr, len, oid, &oid_len, &val_len, &val_type, &val);
-
-	ret = smux_set(oid, &oid_len, val_type, val, val_len, action);
-	if (debug_smux)
-		zlog_debug("SMUX SET ret %d", ret);
-
-	/* Return result. */
-	if (RESERVE1 == action)
-		smux_getresp_send(oid, oid_len, reqid, ret, 3, ASN_NULL, NULL,
-				  0);
-}
-
-static void smux_parse_get(uint8_t *ptr, size_t len, int exact)
-{
-	long reqid;
-	oid oid[MAX_OID_LEN];
-	size_t oid_len;
-	uint8_t val_type;
-	void *val;
-	size_t val_len;
-	int ret;
-
-	if (debug_smux)
-		zlog_debug("SMUX GET message parse: len %zd", len);
-
-	/* Parse GET message header. */
-	ptr = smux_parse_get_header(ptr, &len, &reqid);
-
-	/* Parse GET message object ID. We needn't the value come */
-	ptr = smux_var(ptr, len, oid, &oid_len, NULL, NULL, NULL);
-
-	/* Traditional getstatptr. */
-	if (exact)
-		ret = smux_get(oid, &oid_len, exact, &val_type, &val, &val_len);
-	else
-		ret = smux_getnext(oid, &oid_len, exact, &val_type, &val,
-				   &val_len);
-
-	/* Return result. */
-	if (ret == 0)
-		smux_getresp_send(oid, oid_len, reqid, 0, 0, val_type, val,
-				  val_len);
-	else
-		smux_getresp_send(oid, oid_len, reqid, ret, 3, ASN_NULL, NULL,
-				  0);
-}
-
-/* Parse SMUX_CLOSE message. */
-static void smux_parse_close(uint8_t *ptr, int len)
-{
-	long reason = 0;
-
-	while (len--) {
-		reason = (reason << 8) | (long)*ptr;
-		ptr++;
-	}
-	zlog_info("SMUX_CLOSE with reason: %ld", reason);
-}
-
-/* SMUX_RRSP message. */
-static void smux_parse_rrsp(uint8_t *ptr, size_t len)
-{
-	uint8_t val;
-	long errstat;
-
-	ptr = asn_parse_int(ptr, &len, &val, &errstat, sizeof(errstat));
-
-	if (debug_smux)
-		zlog_debug("SMUX_RRSP value: %d errstat: %ld", val, errstat);
-}
-
-/* Parse SMUX message. */
-static int smux_parse(uint8_t *ptr, size_t len)
-{
-	/* This buffer we'll use for SOUT message. We could allocate it with
-	   malloc and save only static pointer/lenght, but IMHO static
-	   buffer is a faster solusion. */
-	static uint8_t sout_save_buff[SMUXMAXPKTSIZE];
-	static int sout_save_len = 0;
-
-	int len_income = len; /* see note below: YYY */
-	uint8_t type;
-	uint8_t rollback;
-
-	rollback = ptr[2]; /* important only for SMUX_SOUT */
-
-process_rest: /* see note below: YYY */
-
-	/* Parse SMUX message type and subsequent length. */
-	ptr = asn_parse_header(ptr, &len, &type);
-
-	if (debug_smux)
-		zlog_debug("SMUX message received type: %d rest len: %zd", type,
-			   len);
-
-	switch (type) {
-	case SMUX_OPEN:
-		/* Open must be not send from SNMP agent. */
-		zlog_warn("SMUX_OPEN received: resetting connection.");
-		return -1;
-		break;
-	case SMUX_RREQ:
-		/* SMUX_RREQ message is invalid for us. */
-		zlog_warn("SMUX_RREQ received: resetting connection.");
-		return -1;
-		break;
-	case SMUX_SOUT:
-		/* SMUX_SOUT message is now valied for us. */
-		if (debug_smux)
-			zlog_debug("SMUX_SOUT(%s)",
-				   rollback ? "rollback" : "commit");
-
-		if (sout_save_len > 0) {
-			smux_parse_set(sout_save_buff, sout_save_len,
-				       rollback ? FREE : COMMIT);
-			sout_save_len = 0;
-		} else
-			zlog_warn("SMUX_SOUT sout_save_len=%d - invalid",
-				  (int)sout_save_len);
-
-		if (len_income > 3) {
-			/* YYY: this strange code has to solve the "slow peer"
-			   problem: When agent sends SMUX_SOUT message it
-			   doesn't
-			   wait any responce and may send some next message to
-			   subagent. Then the peer in 'smux_read()' will recieve
-			   from socket the 'concatenated' buffer, contaning both
-			   SMUX_SOUT message and the next one
-			   (SMUX_GET/SMUX_GETNEXT/SMUX_GET). So we should check:
-			   if
-			   the buffer is longer than 3 ( length of SMUX_SOUT ),
-			   we
-			   must process the rest of it.  This effect may be
-			   observed
-			   if 'debug_smux' is set to '1' */
-			ptr++;
-			len = len_income - 3;
-			goto process_rest;
-		}
-		break;
-	case SMUX_GETRSP:
-		/* SMUX_GETRSP message is invalid for us. */
-		zlog_warn("SMUX_GETRSP received: resetting connection.");
-		return -1;
-		break;
-	case SMUX_CLOSE:
-		/* Close SMUX connection. */
-		if (debug_smux)
-			zlog_debug("SMUX_CLOSE");
-		smux_parse_close(ptr, len);
-		return -1;
-		break;
-	case SMUX_RRSP:
-		/* This is response for register message. */
-		if (debug_smux)
-			zlog_debug("SMUX_RRSP");
-		smux_parse_rrsp(ptr, len);
-		break;
-	case SMUX_GET:
-		/* Exact request for object id. */
-		if (debug_smux)
-			zlog_debug("SMUX_GET");
-		smux_parse_get(ptr, len, 1);
-		break;
-	case SMUX_GETNEXT:
-		/* Next request for object id. */
-		if (debug_smux)
-			zlog_debug("SMUX_GETNEXT");
-		smux_parse_get(ptr, len, 0);
-		break;
-	case SMUX_SET:
-		/* SMUX_SET is supported with some limitations. */
-		if (debug_smux)
-			zlog_debug("SMUX_SET");
-
-		/* save the data for future SMUX_SOUT */
-		memcpy(sout_save_buff, ptr, len);
-		sout_save_len = len;
-		smux_parse_set(ptr, len, RESERVE1);
-		break;
-	default:
-		zlog_info("Unknown type: %d", type);
-		break;
-	}
-	return 0;
-}
-
-/* SMUX message read function. */
-static int smux_read(struct thread *t)
-{
-	int sock;
-	int len;
-	uint8_t buf[SMUXMAXPKTSIZE];
-	int ret;
-
-	/* Clear thread. */
-	sock = THREAD_FD(t);
-	smux_read_thread = NULL;
-
-	if (debug_smux)
-		zlog_debug("SMUX read start");
-
-	/* Read message from SMUX socket. */
-	len = recv(sock, buf, SMUXMAXPKTSIZE, 0);
-
-	if (len < 0) {
-		zlog_warn("Can't read all SMUX packet: %s",
-			  safe_strerror(errno));
-		close(sock);
-		smux_sock = -1;
-		smux_event(SMUX_CONNECT, 0);
-		return -1;
-	}
-
-	if (len == 0) {
-		zlog_warn("SMUX connection closed: %d", sock);
-		close(sock);
-		smux_sock = -1;
-		smux_event(SMUX_CONNECT, 0);
-		return -1;
-	}
-
-	if (debug_smux)
-		zlog_debug("SMUX read len: %d", len);
-
-	/* Parse the message. */
-	ret = smux_parse(buf, len);
-
-	if (ret < 0) {
-		close(sock);
-		smux_sock = -1;
-		smux_event(SMUX_CONNECT, 0);
-		return -1;
-	}
-
-	/* Regiser read thread. */
-	smux_event(SMUX_READ, sock);
-
-	return 0;
-}
-
-static int smux_open(int sock)
-{
-	uint8_t buf[BUFSIZ];
-	uint8_t *ptr;
-	size_t len;
-	long version;
-	const char progname[] = FRR_SMUX_NAME "-" FRR_VERSION;
-
-	if (debug_smux) {
-		smux_oid_dump("SMUX open oid", smux_oid, smux_oid_len);
-		zlog_debug("SMUX open progname: %s", progname);
-		zlog_debug("SMUX open password: %s", smux_passwd);
-	}
-
-	ptr = buf;
-	len = BUFSIZ;
-
-	/* SMUX Header.  As placeholder. */
-	ptr = asn_build_header(ptr, &len, (uint8_t)SMUX_OPEN, 0);
-
-	/* SMUX Open. */
-	version = 0;
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-		&version, sizeof(version));
-
-	/* SMUX connection oid. */
-	ptr = asn_build_objid(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID),
-		smux_oid, smux_oid_len);
-
-	/* SMUX connection description. */
-	ptr = asn_build_string(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
-		(const uint8_t *)progname, strlen(progname));
-
-	/* SMUX connection password. */
-	ptr = asn_build_string(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
-		(uint8_t *)smux_passwd, strlen(smux_passwd));
-
-	/* Fill in real SMUX header.  We exclude ASN header size (2). */
-	len = BUFSIZ;
-	asn_build_header(buf, &len, (uint8_t)SMUX_OPEN, (ptr - buf) - 2);
-
-	return send(sock, buf, (ptr - buf), 0);
-}
-
-/* `ename` is ignored. Instead of using the provided enterprise OID,
-   the SMUX peer is used. This keep compatibility with the previous
-   versions of Quagga.
-
-   All other fields are used as they are intended. */
-int smux_trap(struct variable *vp, size_t vp_len, const oid *ename,
-	      size_t enamelen, const oid *name, size_t namelen,
-	      const oid *iname, size_t inamelen,
-	      const struct trap_object *trapobj, size_t trapobjlen,
-	      uint8_t sptrap)
-{
-	unsigned int i;
-	uint8_t buf[BUFSIZ];
-	uint8_t *ptr;
-	size_t len, length;
-	struct in_addr addr;
-	unsigned long val;
-	uint8_t *h1, *h1e;
-
-	ptr = buf;
-	len = BUFSIZ;
-	length = len;
-
-	/* When SMUX connection is not established. */
-	if (smux_sock < 0)
-		return 0;
-
-	/* SMUX header. */
-	ptr = asn_build_header(ptr, &len, (uint8_t)SMUX_TRAP, 0);
-
-	/* Sub agent enterprise oid. */
-	ptr = asn_build_objid(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID),
-		smux_oid, smux_oid_len);
-
-	/* IP address. */
-	addr.s_addr = 0;
-	ptr = asn_build_string(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_IPADDRESS),
-		(uint8_t *)&addr, sizeof(addr));
-
-	/* Generic trap integer. */
-	val = SNMP_TRAP_ENTERPRISESPECIFIC;
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-		(long *)&val, sizeof(val));
-
-	/* Specific trap integer. */
-	val = sptrap;
-	ptr = asn_build_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-		(long *)&val, sizeof(val));
-
-	/* Timeticks timestamp. */
-	val = 0;
-	ptr = asn_build_unsigned_int(
-		ptr, &len,
-		(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_TIMETICKS), &val,
-		sizeof(val));
-
-	/* Variables. */
-	h1 = ptr;
-	ptr = asn_build_sequence(ptr, &len,
-				 (uint8_t)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
-
-
-	/* Iteration for each objects. */
-	h1e = ptr;
-	for (i = 0; i < trapobjlen; i++) {
-		int ret;
-		oid oid[MAX_OID_LEN];
-		size_t oid_len;
-		void *val;
-		size_t val_len;
-		uint8_t val_type;
-
-		/* Make OID. */
-		if (trapobj[i].namelen > 0) {
-			oid_copy(oid, name, namelen);
-			oid_copy(oid + namelen, trapobj[i].name,
-				 trapobj[i].namelen);
-			oid_copy(oid + namelen + trapobj[i].namelen, iname,
-				 inamelen);
-			oid_len = namelen + trapobj[i].namelen + inamelen;
-		} else {
-			oid_copy(oid, name, namelen);
-			oid_copy(oid + namelen, trapobj[i].name,
-				 trapobj[i].namelen * (-1));
-			oid_len = namelen + trapobj[i].namelen * (-1);
-		}
-
-		if (debug_smux) {
-			smux_oid_dump("Trap", name, namelen);
-			if (trapobj[i].namelen < 0)
-				smux_oid_dump("Trap", trapobj[i].name,
-					      (-1) * (trapobj[i].namelen));
-			else {
-				smux_oid_dump("Trap", trapobj[i].name,
-					      (trapobj[i].namelen));
-				smux_oid_dump("Trap", iname, inamelen);
-			}
-			smux_oid_dump("Trap", oid, oid_len);
-			zlog_info("BUFSIZ: %d // oid_len: %lu", BUFSIZ,
-				  (unsigned long)oid_len);
-		}
-
-		ret = smux_get(oid, &oid_len, 1, &val_type, &val, &val_len);
-
-		if (debug_smux)
-			zlog_debug("smux_get result %d", ret);
-
-		if (ret == 0)
-			ptr = snmp_build_var_op(ptr, oid, &oid_len, val_type,
-						val_len, val, &len);
-	}
-
-	/* Now variable size is known, fill in size */
-	asn_build_sequence(h1, &length,
-			   (uint8_t)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
-			   ptr - h1e);
-
-	/* Fill in size of whole sequence */
-	len = BUFSIZ;
-	asn_build_header(buf, &len, (uint8_t)SMUX_TRAP, (ptr - buf) - 2);
-
-	return send(smux_sock, buf, (ptr - buf), 0);
-}
-
-static int smux_register(int sock)
-{
-	uint8_t buf[BUFSIZ];
-	uint8_t *ptr;
-	int ret;
-	size_t len;
-	long priority;
-	long operation;
-	struct subtree *subtree;
-	struct listnode *node, *nnode;
-
-	ret = 0;
-
-	for (ALL_LIST_ELEMENTS(treelist, node, nnode, subtree)) {
-		ptr = buf;
-		len = BUFSIZ;
-
-		/* SMUX RReq Header. */
-		ptr = asn_build_header(ptr, &len, (uint8_t)SMUX_RREQ, 0);
-
-		/* Register MIB tree. */
-		ptr = asn_build_objid(ptr, &len,
-				      (uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE
-						| ASN_OBJECT_ID),
-				      subtree->name, subtree->name_len);
-
-		/* Priority. */
-		priority = -1;
-		ptr = asn_build_int(
-			ptr, &len,
-			(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			&priority, sizeof(priority));
-
-		/* Operation. */
-		operation = 2; /* Register R/W */
-		ptr = asn_build_int(
-			ptr, &len,
-			(uint8_t)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			&operation, sizeof(operation));
-
-		if (debug_smux) {
-			smux_oid_dump("SMUX register oid", subtree->name,
-				      subtree->name_len);
-			zlog_debug("SMUX register priority: %ld", priority);
-			zlog_debug("SMUX register operation: %ld", operation);
-		}
-
-		len = BUFSIZ;
-		asn_build_header(buf, &len, (uint8_t)SMUX_RREQ,
-				 (ptr - buf) - 2);
-		ret = send(sock, buf, (ptr - buf), 0);
-		if (ret < 0)
-			return ret;
-	}
-	return ret;
-}
-
-/* Try to connect to SNMP agent. */
-static int smux_connect(struct thread *t)
-{
-	int ret;
-
-	if (debug_smux)
-		zlog_debug("SMUX connect try %d", fail + 1);
-
-	/* Clear thread poner of myself. */
-	smux_connect_thread = NULL;
-
-	/* Make socket.  Try to connect. */
-	smux_sock = smux_socket();
-	if (smux_sock < 0) {
-		if (++fail < SMUX_MAX_FAILURE)
-			smux_event(SMUX_CONNECT, 0);
-		return 0;
-	}
-
-	/* Send OPEN PDU. */
-	ret = smux_open(smux_sock);
-	if (ret < 0) {
-		zlog_warn("SMUX open message send failed: %s",
-			  safe_strerror(errno));
-		close(smux_sock);
-		smux_sock = -1;
-		if (++fail < SMUX_MAX_FAILURE)
-			smux_event(SMUX_CONNECT, 0);
-		return -1;
-	}
-
-	/* Send any outstanding register PDUs. */
-	ret = smux_register(smux_sock);
-	if (ret < 0) {
-		zlog_warn("SMUX register message send failed: %s",
-			  safe_strerror(errno));
-		close(smux_sock);
-		smux_sock = -1;
-		if (++fail < SMUX_MAX_FAILURE)
-			smux_event(SMUX_CONNECT, 0);
-		return -1;
-	}
-
-	/* Everything goes fine. */
-	smux_event(SMUX_READ, smux_sock);
-
-	return 0;
-}
-
-/* Clear all SMUX related resources. */
-static void smux_stop(void)
-{
-	if (smux_read_thread) {
-		thread_cancel(smux_read_thread);
-		smux_read_thread = NULL;
-	}
-
-	if (smux_connect_thread) {
-		thread_cancel(smux_connect_thread);
-		smux_connect_thread = NULL;
-	}
-
-	if (smux_sock >= 0) {
-		close(smux_sock);
-		smux_sock = -1;
-	}
-}
-
-
-void smux_event(enum smux_event event, int sock)
-{
-	switch (event) {
-	case SMUX_SCHEDULE:
-		smux_connect_thread = NULL;
-		thread_add_event(smux_master, smux_connect, NULL, 0,
-				 &smux_connect_thread);
-		break;
-	case SMUX_CONNECT:
-		smux_connect_thread = NULL;
-		thread_add_timer(smux_master, smux_connect, NULL, 10,
-				 &smux_connect_thread);
-		break;
-	case SMUX_READ:
-		smux_read_thread = NULL;
-		thread_add_read(smux_master, smux_read, NULL, sock,
-				&smux_read_thread);
-		break;
-	default:
-		break;
-	}
-}
-
-static int smux_str2oid(const char *str, oid *oid, size_t *oid_len)
-{
-	int len;
-	int val;
-
-	len = 0;
-	val = 0;
-	*oid_len = 0;
-
-	if (*str == '.')
-		str++;
-	if (*str == '\0')
-		return 0;
-
-	while (1) {
-		if (!isdigit(*str))
-			return -1;
-
-		while (isdigit(*str)) {
-			val *= 10;
-			val += (*str - '0');
-			str++;
-		}
-
-		if (*str == '\0')
-			break;
-		if (*str != '.')
-			return -1;
-
-		oid[len++] = val;
-		val = 0;
-		str++;
-	}
-
-	oid[len++] = val;
-	*oid_len = len;
-
-	return 0;
-}
-
-static oid *smux_oid_dup(oid *objid, size_t objid_len)
-{
-	oid *new;
-
-	new = XMALLOC(MTYPE_TMP, sizeof(oid) * objid_len);
-	oid_copy(new, objid, objid_len);
-
-	return new;
-}
-
-static int smux_peer_oid(struct vty *vty, const char *oid_str,
-			 const char *passwd_str)
-{
-	int ret;
-	oid oid[MAX_OID_LEN];
-	size_t oid_len;
-
-	ret = smux_str2oid(oid_str, oid, &oid_len);
-	if (ret != 0) {
-		vty_out(vty, "object ID malformed\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (smux_oid) {
-		free(smux_oid);
-		smux_oid = NULL;
-	}
-
-	/* careful, smux_passwd might point to string constant */
-	if (smux_passwd) {
-		free(smux_passwd);
-		smux_passwd = NULL;
-	}
-
-	smux_oid = smux_oid_dup(oid, oid_len);
-	smux_oid_len = oid_len;
-
-	if (passwd_str)
-		smux_passwd = strdup(passwd_str);
-	else
-		smux_passwd = strdup("");
-
-	return 0;
-}
-
-static int smux_peer_default(void)
-{
-	if (smux_oid) {
-		free(smux_oid);
-		smux_oid = NULL;
-	}
-
-	/* careful, smux_passwd might be pointing at string constant */
-	if (smux_passwd) {
-		free(smux_passwd);
-		smux_passwd = NULL;
-	}
-
-	return CMD_SUCCESS;
-}
-
-DEFUN (smux_peer,
-       smux_peer_cmd,
-       "smux peer OID",
-       "SNMP MUX protocol settings\n"
-       "SNMP MUX peer settings\n"
-       "Object ID used in SMUX peering\n")
-{
-	int idx_oid = 2;
-	if (smux_peer_oid(vty, argv[idx_oid]->arg, NULL) == 0) {
-		smux_start();
-		return CMD_SUCCESS;
-	} else
-		return CMD_WARNING_CONFIG_FAILED;
-}
-
-DEFUN (smux_peer_password,
-       smux_peer_password_cmd,
-       "smux peer OID PASSWORD",
-       "SNMP MUX protocol settings\n"
-       "SNMP MUX peer settings\n"
-       "SMUX peering object ID\n"
-       "SMUX peering password\n")
-{
-	int idx_oid = 2;
-	if (smux_peer_oid(vty, argv[idx_oid]->arg, argv[3]->rg) == 0) {
-		smux_start();
-		return CMD_SUCCESS;
-	} else
-		return CMD_WARNING_CONFIG_FAILED;
-}
-
-DEFUN (no_smux_peer,
-       no_smux_peer_cmd,
-       "no smux peer [OID [PASSWORD]]",
-       NO_STR
-       "SNMP MUX protocol settings\n"
-       "SNMP MUX peer settings\n"
-       "SMUX peering object ID\n"
-       "SMUX peering password\n")
-{
-	smux_stop();
-	return smux_peer_default();
-}
-
-static int config_write_smux(struct vty *vty)
-{
-	int first = 1;
-	unsigned int i;
-
-	if (smux_oid) {
-		vty_out(vty, "smux peer ");
-		for (i = 0; i < smux_oid_len; i++) {
-			vty_out(vty, "%s%d", first ? "" : ".",
-				(int)smux_oid[i]);
-			first = 0;
-		}
-		vty_out(vty, " %s\n", smux_passwd);
-	}
-	return 0;
-}
-
-/* Register subtree to smux master tree. */
-void smux_register_mib(const char *descr, struct variable *var, size_t width,
-		       int num, oid name[], size_t namelen)
-{
-	struct subtree *tree;
-
-	tree = (struct subtree *)malloc(sizeof(struct subtree));
-	oid_copy(tree->name, name, namelen);
-	tree->name_len = namelen;
-	tree->variables = var;
-	tree->variables_num = num;
-	tree->variables_width = width;
-	tree->registered = 0;
-	listnode_add_sort(treelist, tree);
-}
-
-/* Compare function to keep treelist sorted */
-static int smux_tree_cmp(struct subtree *tree1, struct subtree *tree2)
-{
-	return oid_compare(tree1->name, tree1->name_len, tree2->name,
-			   tree2->name_len);
-}
-
-/* Initialize some values then schedule first SMUX connection. */
-void smux_init(struct thread_master *tm)
-{
-	assert(tm);
-	/* copy callers thread master */
-	smux_master = tm;
-
-	/* Make MIB tree. */
-	treelist = list_new();
-	treelist->cmp = (int (*)(void *, void *))smux_tree_cmp;
-
-	/* Install commands. */
-	install_node(&smux_node, config_write_smux);
-
-	install_element(CONFIG_NODE, &smux_peer_cmd);
-	install_element(CONFIG_NODE, &smux_peer_password_cmd);
-	install_element(CONFIG_NODE, &no_smux_peer_cmd);
-	install_element(CONFIG_NODE, &no_smux_peer_oid_cmd);
-	install_element(CONFIG_NODE, &no_smux_peer_oid_password_cmd);
-}
-
-void smux_start(void)
-{
-	/* Close any existing connections. */
-	smux_stop();
-
-	/* Schedule first connection. */
-	smux_event(SMUX_SCHEDULE, 0);
-}
-#endif /* SNMP_SMUX */
diff -urpN frr-frr-5.0.1/lib/sockopt.c frr-frr-6.0/lib/sockopt.c
--- frr-frr-5.0.1/lib/sockopt.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/sockopt.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@
 #include "log.h"
 #include "sockopt.h"
 #include "sockunion.h"
+#include "lib_errors.h"
 
 void setsockopt_so_recvbuf(int sock, int size)
 {
@@ -61,8 +62,9 @@ int getsockopt_so_sendbuf(const int sock
 	int ret = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&optval,
 			     &optlen);
 	if (ret < 0) {
-		zlog_err("fd %d: can't getsockopt SO_SNDBUF: %d (%s)", sock,
-			 errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "fd %d: can't getsockopt SO_SNDBUF: %d (%s)", sock,
+			     errno, safe_strerror(errno));
 		return ret;
 	}
 	return optval;
@@ -73,9 +75,9 @@ static void *getsockopt_cmsg_data(struct
 	struct cmsghdr *cmsg;
 	void *ptr = NULL;
 
-	for (cmsg = ZCMSG_FIRSTHDR(msgh); cmsg != NULL;
+	for (cmsg = CMSG_FIRSTHDR(msgh); cmsg != NULL;
 	     cmsg = CMSG_NXTHDR(msgh, cmsg))
-		if (cmsg->cmsg_level == level && cmsg->cmsg_type)
+		if (cmsg->cmsg_level == level && cmsg->cmsg_type == type)
 			return (ptr = CMSG_DATA(cmsg));
 
 	return NULL;
@@ -457,8 +459,7 @@ int setsockopt_ifindex(int af, int sock,
  */
 static ifindex_t getsockopt_ipv4_ifindex(struct msghdr *msgh)
 {
-	/* XXX: initialize to zero?  (Always overwritten, so just cosmetic.) */
-	ifindex_t ifindex = -1;
+	ifindex_t ifindex;
 
 #if defined(IP_PKTINFO)
 	/* Linux pktinfo based ifindex retrieval */
@@ -466,7 +467,11 @@ static ifindex_t getsockopt_ipv4_ifindex
 
 	pktinfo = (struct in_pktinfo *)getsockopt_cmsg_data(msgh, IPPROTO_IP,
 							    IP_PKTINFO);
-	/* XXX Can pktinfo be NULL?  Clean up post 0.98. */
+
+	/* getsockopt_ifindex() will forward this, being 0 "not found" */
+	if (pktinfo == NULL)
+		return 0;
+
 	ifindex = pktinfo->ipi_ifindex;
 
 #elif defined(IP_RECVIF)
@@ -575,31 +580,7 @@ int sockopt_tcp_rtt(int sock)
 
 int sockopt_tcp_signature(int sock, union sockunion *su, const char *password)
 {
-#if defined(HAVE_TCP_MD5_LINUX24) && defined(GNU_LINUX)
-/* Support for the old Linux 2.4 TCP-MD5 patch, taken from Hasso Tepper's
- * version of the Quagga patch (based on work by Rick Payne, and Bruce
- * Simpson)
- */
-#define TCP_MD5_AUTH 13
-#define TCP_MD5_AUTH_ADD 1
-#define TCP_MD5_AUTH_DEL 2
-	struct tcp_rfc2385_cmd {
-		uint8_t command;  /* Command - Add/Delete */
-		uint32_t address; /* IPV4 address associated */
-		uint8_t keylen;   /* MD5 Key len (do NOT assume 0 terminated
-				      ascii) */
-		void *key;	 /* MD5 Key */
-	} cmd;
-	struct in_addr *addr = &su->sin.sin_addr;
-
-	cmd.command = (password != NULL ? TCP_MD5_AUTH_ADD : TCP_MD5_AUTH_DEL);
-	cmd.address = addr->s_addr;
-	cmd.keylen = (password != NULL ? strlen(password) : 0);
-	cmd.key = password;
-
-	return setsockopt(sock, IPPROTO_TCP, TCP_MD5_AUTH, &cmd, sizeof cmd);
-
-#elif HAVE_DECL_TCP_MD5SIG
+#if HAVE_DECL_TCP_MD5SIG
 	int ret;
 #ifndef GNU_LINUX
 	/*
@@ -667,8 +648,10 @@ int sockopt_tcp_signature(int sock, unio
 		if (ENOENT == errno)
 			ret = 0;
 		else
-			zlog_err("sockopt_tcp_signature: setsockopt(%d): %s",
-				 sock, safe_strerror(errno));
+			flog_err_sys(
+				LIB_ERR_SYSTEM_CALL,
+				"sockopt_tcp_signature: setsockopt(%d): %s",
+				sock, safe_strerror(errno));
 	}
 	return ret;
 #else  /* HAVE_TCP_MD5SIG */
diff -urpN frr-frr-5.0.1/lib/sockunion.c frr-frr-6.0/lib/sockunion.c
--- frr-frr-5.0.1/lib/sockunion.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/sockunion.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,6 +26,7 @@
 #include "memory.h"
 #include "log.h"
 #include "jhash.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, SOCKUNION, "Socket union")
 
@@ -46,6 +47,9 @@ int str2sockunion(const char *str, union
 {
 	int ret;
 
+	if (str == NULL)
+		return -1;
+
 	memset(su, 0, sizeof(union sockunion));
 
 	ret = inet_pton(AF_INET, str, &su->sin.sin_addr);
@@ -362,14 +366,10 @@ int sockopt_mark_default(int sock, int m
 #ifdef SO_MARK
 	int ret;
 
-	if (cap->change(ZPRIVS_RAISE))
-		zlog_err("routing_socket: Can't raise privileges");
-
-	ret = setsockopt(sock, SOL_SOCKET, SO_MARK, &mark, sizeof(mark));
-
-	if (cap->change(ZPRIVS_LOWER))
-		zlog_err("routing_socket: Can't lower privileges");
-
+	frr_elevate_privs(cap) {
+		ret = setsockopt(sock, SOL_SOCKET, SO_MARK, &mark,
+				 sizeof(mark));
+	}
 	return ret;
 #else
 	return 0;
diff -urpN frr-frr-5.0.1/lib/spf_backoff.c frr-frr-6.0/lib/spf_backoff.c
--- frr-frr-5.0.1/lib/spf_backoff.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/spf_backoff.c	2018-10-08 14:32:57.000000000 +0200
@@ -143,7 +143,7 @@ static int spf_backoff_holddown_elapsed(
 
 long spf_backoff_schedule(struct spf_backoff *backoff)
 {
-	long rv;
+	long rv = 0;
 	struct timeval now;
 
 	gettimeofday(&now, NULL);
@@ -176,9 +176,6 @@ long spf_backoff_schedule(struct spf_bac
 		else
 			rv = backoff->long_delay;
 		break;
-	default:
-		zlog_warn("SPF Back-off(%s) in unknown state", backoff->name);
-		rv = backoff->init_delay;
 	}
 
 	backoff_debug(
diff -urpN frr-frr-5.0.1/lib/srcdest_table.c frr-frr-6.0/lib/srcdest_table.c
--- frr-frr-5.0.1/lib/srcdest_table.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/srcdest_table.c	2018-10-08 14:32:57.000000000 +0200
@@ -127,7 +127,7 @@ route_table_delegate_t _srcdest_srcnode_
 
 /* NB: read comments in code for refcounting before using! */
 static struct route_node *srcdest_srcnode_get(struct route_node *rn,
-					      struct prefix_ipv6 *src_p)
+					      const struct prefix_ipv6 *src_p)
 {
 	struct srcdest_rnode *srn;
 
@@ -158,11 +158,12 @@ static struct route_node *srcdest_srcnod
 		route_unlock_node(rn);
 	}
 
-	return route_node_get(srn->src_table, (struct prefix *)src_p);
+	return route_node_get(srn->src_table, (const struct prefix *)src_p);
 }
 
-static struct route_node *srcdest_srcnode_lookup(struct route_node *rn,
-						 struct prefix_ipv6 *src_p)
+static struct route_node *srcdest_srcnode_lookup(
+	struct route_node *rn,
+	const struct prefix_ipv6 *src_p)
 {
 	struct srcdest_rnode *srn;
 
@@ -180,7 +181,7 @@ static struct route_node *srcdest_srcnod
 	if (!srn->src_table)
 		return NULL;
 
-	return route_node_lookup(srn->src_table, (struct prefix *)src_p);
+	return route_node_lookup(srn->src_table, (const struct prefix *)src_p);
 }
 
 /* ----- exported functions ----- */
@@ -233,25 +234,25 @@ struct route_node *srcdest_route_next(st
 }
 
 struct route_node *srcdest_rnode_get(struct route_table *table,
-				     union prefixptr dst_pu,
-				     struct prefix_ipv6 *src_p)
+				     union prefixconstptr dst_pu,
+				     const struct prefix_ipv6 *src_p)
 {
-	struct prefix_ipv6 *dst_p = dst_pu.p6;
+	const struct prefix_ipv6 *dst_p = dst_pu.p6;
 	struct route_node *rn;
 
-	rn = route_node_get(table, (struct prefix *)dst_p);
+	rn = route_node_get(table, (const struct prefix *)dst_p);
 	return srcdest_srcnode_get(rn, src_p);
 }
 
 struct route_node *srcdest_rnode_lookup(struct route_table *table,
-					union prefixptr dst_pu,
-					struct prefix_ipv6 *src_p)
+					union prefixconstptr dst_pu,
+					const struct prefix_ipv6 *src_p)
 {
-	struct prefix_ipv6 *dst_p = dst_pu.p6;
+	const struct prefix_ipv6 *dst_p = dst_pu.p6;
 	struct route_node *rn;
 	struct route_node *srn;
 
-	rn = route_node_lookup_maynull(table, (struct prefix *)dst_p);
+	rn = route_node_lookup_maynull(table, (const struct prefix *)dst_p);
 	srn = srcdest_srcnode_lookup(rn, src_p);
 
 	if (rn != NULL && rn == srn && !rn->info) {
@@ -263,8 +264,8 @@ struct route_node *srcdest_rnode_lookup(
 	return srn;
 }
 
-void srcdest_rnode_prefixes(struct route_node *rn, struct prefix **p,
-			    struct prefix **src_p)
+void srcdest_rnode_prefixes(struct route_node *rn, const struct prefix **p,
+			    const struct prefix **src_p)
 {
 	if (rnode_is_srcnode(rn)) {
 		struct route_node *dst_rn = rn->table->info;
@@ -280,13 +281,12 @@ void srcdest_rnode_prefixes(struct route
 	}
 }
 
-const char *srcdest_rnode2str(struct route_node *rn, char *str, int size)
+const char *srcdest2str(const struct prefix *dst_p,
+			const struct prefix_ipv6 *src_p,
+			char *str, int size)
 {
-	struct prefix *dst_p, *src_p;
 	char dst_buf[PREFIX_STRLEN], src_buf[PREFIX_STRLEN];
 
-	srcdest_rnode_prefixes(rn, &dst_p, &src_p);
-
 	snprintf(str, size, "%s%s%s",
 		 prefix2str(dst_p, dst_buf, sizeof(dst_buf)),
 		 (src_p && src_p->prefixlen) ? " from " : "",
@@ -295,3 +295,11 @@ const char *srcdest_rnode2str(struct rou
 			 : "");
 	return str;
 }
+
+const char *srcdest_rnode2str(struct route_node *rn, char *str, int size)
+{
+	const struct prefix *dst_p, *src_p;
+
+	srcdest_rnode_prefixes(rn, &dst_p, &src_p);
+	return srcdest2str(dst_p, (struct prefix_ipv6*)src_p, str, size);
+}
diff -urpN frr-frr-5.0.1/lib/srcdest_table.h frr-frr-6.0/lib/srcdest_table.h
--- frr-frr-5.0.1/lib/srcdest_table.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/srcdest_table.h	2018-10-08 14:32:57.000000000 +0200
@@ -56,13 +56,17 @@ extern route_table_delegate_t _srcdest_s
 
 extern struct route_table *srcdest_table_init(void);
 extern struct route_node *srcdest_rnode_get(struct route_table *table,
-					    union prefixptr dst_pu,
-					    struct prefix_ipv6 *src_p);
+					    union prefixconstptr dst_pu,
+					    const struct prefix_ipv6 *src_p);
 extern struct route_node *srcdest_rnode_lookup(struct route_table *table,
-					       union prefixptr dst_pu,
-					       struct prefix_ipv6 *src_p);
-extern void srcdest_rnode_prefixes(struct route_node *rn, struct prefix **p,
-				   struct prefix **src_p);
+					       union prefixconstptr dst_pu,
+					       const struct prefix_ipv6 *src_p);
+extern void srcdest_rnode_prefixes(struct route_node *rn,
+				   const struct prefix **p,
+				   const struct prefix **src_p);
+extern const char *srcdest2str(const struct prefix *dst_p,
+			       const struct prefix_ipv6 *src_p,
+			       char *str, int size);
 extern const char *srcdest_rnode2str(struct route_node *rn, char *str,
 				     int size);
 extern struct route_node *srcdest_route_next(struct route_node *rn);
diff -urpN frr-frr-5.0.1/lib/stream.c frr-frr-6.0/lib/stream.c
--- frr-frr-5.0.1/lib/stream.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/stream.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,15 +21,16 @@
 
 #include <zebra.h>
 #include <stddef.h>
+#include <pthread.h>
 
 #include "stream.h"
 #include "memory.h"
 #include "network.h"
 #include "prefix.h"
 #include "log.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, STREAM, "Stream")
-DEFINE_MTYPE_STATIC(LIB, STREAM_DATA, "Stream data")
 DEFINE_MTYPE_STATIC(LIB, STREAM_FIFO, "Stream FIFO")
 
 /* Tests whether a position is valid */
@@ -99,16 +100,10 @@ struct stream *stream_new(size_t size)
 
 	assert(size > 0);
 
-	s = XCALLOC(MTYPE_STREAM, sizeof(struct stream));
-
-	if (s == NULL)
-		return s;
-
-	if ((s->data = XMALLOC(MTYPE_STREAM_DATA, size)) == NULL) {
-		XFREE(MTYPE_STREAM, s);
-		return NULL;
-	}
+	s = XMALLOC(MTYPE_STREAM, sizeof(struct stream) + size);
 
+	s->getp = s->endp = 0;
+	s->next = NULL;
 	s->size = size;
 	return s;
 }
@@ -119,7 +114,6 @@ void stream_free(struct stream *s)
 	if (!s)
 		return;
 
-	XFREE(MTYPE_STREAM_DATA, s->data);
 	XFREE(MTYPE_STREAM, s);
 }
 
@@ -169,27 +163,33 @@ struct stream *stream_dupcat(struct stre
 	return new;
 }
 
-size_t stream_resize(struct stream *s, size_t newsize)
+size_t stream_resize_inplace(struct stream **sptr, size_t newsize)
 {
-	uint8_t *newdata;
-	STREAM_VERIFY_SANE(s);
+	struct stream *orig = *sptr;
 
-	newdata = XREALLOC(MTYPE_STREAM_DATA, s->data, newsize);
+	STREAM_VERIFY_SANE(orig);
 
-	if (newdata == NULL)
-		return s->size;
+	orig = XREALLOC(MTYPE_STREAM, orig, sizeof(struct stream) + newsize);
 
-	s->data = newdata;
-	s->size = newsize;
+	orig->size = newsize;
 
-	if (s->endp > s->size)
-		s->endp = s->size;
-	if (s->getp > s->endp)
-		s->getp = s->endp;
+	if (orig->endp > orig->size)
+		orig->endp = orig->size;
+	if (orig->getp > orig->endp)
+		orig->getp = orig->endp;
 
-	STREAM_VERIFY_SANE(s);
+	STREAM_VERIFY_SANE(orig);
 
-	return s->size;
+	*sptr = orig;
+	return orig->size;
+}
+
+size_t __attribute__((deprecated))stream_resize_orig(struct stream *s,
+						     size_t newsize)
+{
+	assert("stream_resize: Switch code to use stream_resize_inplace" == NULL);
+
+	return stream_resize_inplace(&s, newsize);
 }
 
 size_t stream_get_getp(struct stream *s)
@@ -1101,12 +1101,17 @@ struct stream_fifo *stream_fifo_new(void
 	struct stream_fifo *new;
 
 	new = XCALLOC(MTYPE_STREAM_FIFO, sizeof(struct stream_fifo));
+	pthread_mutex_init(&new->mtx, NULL);
 	return new;
 }
 
 /* Add new stream to fifo. */
 void stream_fifo_push(struct stream_fifo *fifo, struct stream *s)
 {
+#if defined DEV_BUILD
+	size_t max, curmax;
+#endif
+
 	if (fifo->tail)
 		fifo->tail->next = s;
 	else
@@ -1114,8 +1119,24 @@ void stream_fifo_push(struct stream_fifo
 
 	fifo->tail = s;
 	fifo->tail->next = NULL;
-
-	fifo->count++;
+#if !defined DEV_BUILD
+	atomic_fetch_add_explicit(&fifo->count, 1, memory_order_release);
+#else
+	max = atomic_fetch_add_explicit(&fifo->count, 1, memory_order_release);
+	curmax = atomic_load_explicit(&fifo->max_count, memory_order_relaxed);
+	if (max > curmax)
+		atomic_store_explicit(&fifo->max_count, max,
+				      memory_order_relaxed);
+#endif
+}
+
+void stream_fifo_push_safe(struct stream_fifo *fifo, struct stream *s)
+{
+	pthread_mutex_lock(&fifo->mtx);
+	{
+		stream_fifo_push(fifo, s);
+	}
+	pthread_mutex_unlock(&fifo->mtx);
 }
 
 /* Delete first stream from fifo. */
@@ -1131,7 +1152,8 @@ struct stream *stream_fifo_pop(struct st
 		if (fifo->head == NULL)
 			fifo->tail = NULL;
 
-		fifo->count--;
+		atomic_fetch_sub_explicit(&fifo->count, 1,
+					  memory_order_release);
 
 		/* ensure stream is scrubbed of references to this fifo */
 		s->next = NULL;
@@ -1140,12 +1162,37 @@ struct stream *stream_fifo_pop(struct st
 	return s;
 }
 
-/* Return first fifo entry. */
+struct stream *stream_fifo_pop_safe(struct stream_fifo *fifo)
+{
+	struct stream *ret;
+
+	pthread_mutex_lock(&fifo->mtx);
+	{
+		ret = stream_fifo_pop(fifo);
+	}
+	pthread_mutex_unlock(&fifo->mtx);
+
+	return ret;
+}
+
 struct stream *stream_fifo_head(struct stream_fifo *fifo)
 {
 	return fifo->head;
 }
 
+struct stream *stream_fifo_head_safe(struct stream_fifo *fifo)
+{
+	struct stream *ret;
+
+	pthread_mutex_lock(&fifo->mtx);
+	{
+		ret = stream_fifo_head(fifo);
+	}
+	pthread_mutex_unlock(&fifo->mtx);
+
+	return ret;
+}
+
 void stream_fifo_clean(struct stream_fifo *fifo)
 {
 	struct stream *s;
@@ -1156,11 +1203,26 @@ void stream_fifo_clean(struct stream_fif
 		stream_free(s);
 	}
 	fifo->head = fifo->tail = NULL;
-	fifo->count = 0;
+	atomic_store_explicit(&fifo->count, 0, memory_order_release);
+}
+
+void stream_fifo_clean_safe(struct stream_fifo *fifo)
+{
+	pthread_mutex_lock(&fifo->mtx);
+	{
+		stream_fifo_clean(fifo);
+	}
+	pthread_mutex_unlock(&fifo->mtx);
+}
+
+size_t stream_fifo_count_safe(struct stream_fifo *fifo)
+{
+	return atomic_load_explicit(&fifo->count, memory_order_acquire);
 }
 
 void stream_fifo_free(struct stream_fifo *fifo)
 {
 	stream_fifo_clean(fifo);
+	pthread_mutex_destroy(&fifo->mtx);
 	XFREE(MTYPE_STREAM_FIFO, fifo);
 }
diff -urpN frr-frr-5.0.1/lib/stream.h frr-frr-6.0/lib/stream.h
--- frr-frr-5.0.1/lib/stream.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/stream.h	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,9 @@
 #ifndef _ZEBRA_STREAM_H
 #define _ZEBRA_STREAM_H
 
+#include <pthread.h>
+
+#include "frratomic.h"
 #include "mpls.h"
 #include "prefix.h"
 
@@ -95,19 +98,27 @@
 struct stream {
 	struct stream *next;
 
-	/* Remainder is ***private*** to stream
+	/*
+	 * Remainder is ***private*** to stream
 	 * direct access is frowned upon!
 	 * Use the appropriate functions/macros
 	 */
-	size_t getp;	 /* next get position */
-	size_t endp;	 /* last valid data position */
-	size_t size;	 /* size of data segment */
-	unsigned char *data; /* data pointer */
+	size_t getp;	       /* next get position */
+	size_t endp;	       /* last valid data position */
+	size_t size;	       /* size of data segment */
+	unsigned char data[0]; /* data pointer */
 };
 
 /* First in first out queue structure. */
 struct stream_fifo {
-	size_t count;
+	/* lock for mt-safe operations */
+	pthread_mutex_t mtx;
+
+	/* number of streams in this fifo */
+	_Atomic size_t count;
+#if defined DEV_BUILD
+	_Atomic size_t max_count;
+#endif
 
 	struct stream *head;
 	struct stream *tail;
@@ -123,7 +134,7 @@ struct stream_fifo {
 #define STREAM_CONCAT_REMAIN(S1, S2, size) ((size) - (S1)->endp - (S2)->endp)
 
 /* deprecated macros - do not use in new code */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20181128
+#if CONFDATE > 20181128
 CPP_NOTICE("lib: time to remove deprecated stream.h macros")
 #endif
 #define STREAM_PNT(S)   stream_pnt((S))
@@ -144,7 +155,14 @@ extern struct stream *stream_new(size_t)
 extern void stream_free(struct stream *);
 extern struct stream *stream_copy(struct stream *, struct stream *src);
 extern struct stream *stream_dup(struct stream *);
-extern size_t stream_resize(struct stream *, size_t);
+
+#if CONFDATE > 20190821
+CPP_NOTICE("lib: time to remove stream_resize_orig")
+#endif
+extern size_t stream_resize_orig(struct stream *s, size_t newsize);
+#define stream_resize stream_resize_orig
+extern size_t stream_resize_inplace(struct stream **sptr, size_t newsize);
+
 extern size_t stream_get_getp(struct stream *);
 extern size_t stream_get_endp(struct stream *);
 extern size_t stream_get_size(struct stream *);
@@ -240,12 +258,94 @@ extern int stream_empty(struct stream *)
 /* deprecated */
 extern uint8_t *stream_pnt(struct stream *);
 
-/* Stream fifo. */
+/*
+ * Operations on struct stream_fifo.
+ *
+ * Each function has a safe variant, which ensures that the operation performed
+ * is atomic with respect to the operations performed by all other safe
+ * variants. In other words, the safe variants lock the stream_fifo's mutex
+ * before performing their action. These are provided for convenience when
+ * using stream_fifo in a multithreaded context, to alleviate the need for the
+ * caller to implement their own synchronization around the stream_fifo.
+ *
+ * The following functions do not have safe variants. The caller must ensure
+ * that these operations are performed safely in a multithreaded context:
+ * - stream_fifo_new
+ * - stream_fifo_free
+ */
+
+/*
+ * Create a new stream_fifo.
+ *
+ * Returns:
+ *    newly created stream_fifo
+ */
 extern struct stream_fifo *stream_fifo_new(void);
+
+/*
+ * Push a stream onto a stream_fifo.
+ *
+ * fifo
+ *    the stream_fifo to push onto
+ *
+ * s
+ *    the stream to push onto the stream_fifo
+ */
 extern void stream_fifo_push(struct stream_fifo *fifo, struct stream *s);
+extern void stream_fifo_push_safe(struct stream_fifo *fifo, struct stream *s);
+
+/*
+ * Pop a stream off a stream_fifo.
+ *
+ * fifo
+ *    the stream_fifo to pop from
+ *
+ * Returns:
+ *    the next stream in the stream_fifo
+ */
 extern struct stream *stream_fifo_pop(struct stream_fifo *fifo);
+extern struct stream *stream_fifo_pop_safe(struct stream_fifo *fifo);
+
+/*
+ * Retrieve the next stream from a stream_fifo without popping it.
+ *
+ * fifo
+ *    the stream_fifo to operate on
+ *
+ * Returns:
+ *    the next stream that would be returned from stream_fifo_pop
+ */
 extern struct stream *stream_fifo_head(struct stream_fifo *fifo);
+extern struct stream *stream_fifo_head_safe(struct stream_fifo *fifo);
+
+/*
+ * Remove all streams from a stream_fifo.
+ *
+ * fifo
+ *    the stream_fifo to clean
+ */
 extern void stream_fifo_clean(struct stream_fifo *fifo);
+extern void stream_fifo_clean_safe(struct stream_fifo *fifo);
+
+/*
+ * Retrieve number of streams on a stream_fifo.
+ *
+ * fifo
+ *    the stream_fifo to retrieve the count for
+ *
+ * Returns:
+ *    the number of streams on the stream_fifo
+ */
+extern size_t stream_fifo_count_safe(struct stream_fifo *fifo);
+
+/*
+ * Free a stream_fifo.
+ *
+ * Calls stream_fifo_clean, then deinitializes the stream_fifo and frees it.
+ *
+ * fifo
+ *    the stream_fifo to free
+ */
 extern void stream_fifo_free(struct stream_fifo *fifo);
 
 /* This is here because "<< 24" is particularly problematic in C.
diff -urpN frr-frr-5.0.1/lib/subdir.am frr-frr-6.0/lib/subdir.am
--- frr-frr-5.0.1/lib/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -2,7 +2,7 @@
 # libfrr
 #
 lib_LTLIBRARIES += lib/libfrr.la
-lib_libfrr_la_LDFLAGS = -version-info 0:0:0 
+lib_libfrr_la_LDFLAGS = -version-info 0:0:0
 lib_libfrr_la_LIBADD = @LIBCAP@
 
 lib_libfrr_la_SOURCES = \
@@ -21,6 +21,7 @@ lib_libfrr_la_SOURCES = \
 	lib/ferr.c \
 	lib/filter.c \
 	lib/frr_pthread.c \
+	lib/frrstr.c \
 	lib/getopt.c \
 	lib/getopt1.c \
 	lib/grammar_sandbox.c \
@@ -34,6 +35,7 @@ lib_libfrr_la_SOURCES = \
 	lib/jhash.c \
 	lib/json.c \
 	lib/keychain.c \
+	lib/lib_errors.c \
 	lib/libfrr.c \
 	lib/linklist.c \
 	lib/log.c \
@@ -105,6 +107,7 @@ pkginclude_HEADERS += \
 	lib/freebsd-queue.h \
 	lib/frr_pthread.h \
 	lib/frratomic.h \
+	lib/frrstr.h \
 	lib/getopt.h \
 	lib/graph.h \
 	lib/hash.h \
@@ -116,6 +119,7 @@ pkginclude_HEADERS += \
 	lib/jhash.h \
 	lib/json.h \
 	lib/keychain.h \
+	lib/lib_errors.h \
 	lib/libfrr.h \
 	lib/libospf.h \
 	lib/linklist.h \
@@ -146,7 +150,6 @@ pkginclude_HEADERS += \
 	lib/sha256.h \
 	lib/sigevent.h \
 	lib/skiplist.h \
-	lib/smux.h \
 	lib/sockopt.h \
 	lib/sockunion.h \
 	lib/spf_backoff.h \
@@ -190,12 +193,11 @@ if SNMP
 lib_LTLIBRARIES += lib/libfrrsnmp.la
 endif
 
-lib_libfrrsnmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+lib_libfrrsnmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 lib_libfrrsnmp_la_LDFLAGS = -version-info 0:0:0
 lib_libfrrsnmp_la_LIBADD = lib/libfrr.la $(SNMP_LIBS)
 lib_libfrrsnmp_la_SOURCES = \
 	lib/agentx.c \
-	lib/smux.c \
 	lib/snmp.c \
 	# end
 
@@ -233,8 +235,8 @@ lib_grammar_sandbox_SOURCES = \
 lib_grammar_sandbox_LDADD = \
 	lib/libfrr.la
 
-lib_clippy_CPPFLAGS = $(AM_CPPFLAGS) -D_GNU_SOURCE -DBUILDING_CLIPPY
-lib_clippy_CFLAGS = $(PYTHON_CFLAGS)
+lib_clippy_CPPFLAGS = $(AM_CPPFLAGS) -D_GNU_SOURCE -DBUILDING_CLIPPY @SAN_CLIPPY_FLAGS@
+lib_clippy_CFLAGS = $(PYTHON_CFLAGS) @SAN_CLIPPY_FLAGS@
 lib_clippy_LDADD = $(PYTHON_LIBS)
 lib_clippy_SOURCES = \
 	lib/clippy.c \
diff -urpN frr-frr-5.0.1/lib/table.h frr-frr-6.0/lib/table.h
--- frr-frr-5.0.1/lib/table.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/table.h	2018-10-08 14:32:57.000000000 +0200
@@ -178,35 +178,37 @@ struct route_table_iter_t_ {
 extern struct route_table *route_table_init(void);
 
 extern struct route_table *
-route_table_init_with_delegate(route_table_delegate_t *);
+route_table_init_with_delegate(route_table_delegate_t *delegate);
 
 extern route_table_delegate_t *route_table_get_default_delegate(void);
 
-extern void route_table_finish(struct route_table *);
-extern struct route_node *route_top(struct route_table *);
-extern struct route_node *route_next(struct route_node *);
-extern struct route_node *route_next_until(struct route_node *,
-					   const struct route_node *);
-extern struct route_node *route_node_get(struct route_table *const,
-					 union prefixconstptr);
-extern struct route_node *route_node_lookup(const struct route_table *,
-					    union prefixconstptr);
-extern struct route_node *route_node_lookup_maynull(const struct route_table *,
-						    union prefixconstptr);
-extern struct route_node *route_node_match(const struct route_table *,
-					   union prefixconstptr);
-extern struct route_node *route_node_match_ipv4(const struct route_table *,
-						const struct in_addr *);
-extern struct route_node *route_node_match_ipv6(const struct route_table *,
-						const struct in6_addr *);
-
-extern unsigned long route_table_count(const struct route_table *);
-
-extern struct route_node *route_node_create(route_table_delegate_t *,
-					    struct route_table *);
-extern void route_node_delete(struct route_node *);
-extern void route_node_destroy(route_table_delegate_t *, struct route_table *,
-			       struct route_node *);
+extern void route_table_finish(struct route_table *table);
+extern struct route_node *route_top(struct route_table *table);
+extern struct route_node *route_next(struct route_node *node);
+extern struct route_node *route_next_until(struct route_node *node,
+					   const struct route_node *limit);
+extern struct route_node *route_node_get(struct route_table *const table,
+					 union prefixconstptr pu);
+extern struct route_node *route_node_lookup(const struct route_table *table,
+					    union prefixconstptr pu);
+extern struct route_node *
+route_node_lookup_maynull(const struct route_table *table,
+			  union prefixconstptr pu);
+extern struct route_node *route_node_match(const struct route_table *table,
+					   union prefixconstptr pu);
+extern struct route_node *route_node_match_ipv4(const struct route_table *table,
+						const struct in_addr *addr);
+extern struct route_node *route_node_match_ipv6(const struct route_table *table,
+						const struct in6_addr *addr);
+
+extern unsigned long route_table_count(const struct route_table *table);
+
+extern struct route_node *route_node_create(route_table_delegate_t *delegate,
+					    struct route_table *table);
+extern void route_node_delete(struct route_node *node);
+extern void route_node_destroy(route_table_delegate_t *delegate,
+			       struct route_table *table,
+			       struct route_node *node);
 
 extern struct route_node *route_table_get_next(const struct route_table *table,
 					       union prefixconstptr pu);
diff -urpN frr-frr-5.0.1/lib/thread.c frr-frr-6.0/lib/thread.c
--- frr-frr-5.0.1/lib/thread.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/thread.c	2018-10-08 14:32:57.000000000 +0200
@@ -36,6 +36,7 @@
 
 DEFINE_MTYPE_STATIC(LIB, THREAD, "Thread")
 DEFINE_MTYPE_STATIC(LIB, THREAD_MASTER, "Thread master")
+DEFINE_MTYPE_STATIC(LIB, THREAD_POLL, "Thread Poll Info")
 DEFINE_MTYPE_STATIC(LIB, THREAD_STATS, "Thread stats")
 
 #if defined(__APPLE__)
@@ -60,7 +61,7 @@ static struct list *masters;
 /* CLI start ---------------------------------------------------------------- */
 static unsigned int cpu_record_hash_key(struct cpu_thread_history *a)
 {
-	int size = sizeof(&a->func);
+	int size = sizeof(a->func);
 
 	return jhash(&a->func, size, 0);
 }
@@ -296,6 +297,47 @@ DEFUN (show_thread_cpu,
 	return CMD_SUCCESS;
 }
 
+static void show_thread_poll_helper(struct vty *vty, struct thread_master *m)
+{
+	const char *name = m->name ? m->name : "main";
+	char underline[strlen(name) + 1];
+	uint32_t i;
+
+	memset(underline, '-', sizeof(underline));
+	underline[sizeof(underline) - 1] = '\0';
+
+	vty_out(vty, "\nShowing poll FD's for %s\n", name);
+	vty_out(vty, "----------------------%s\n", underline);
+	vty_out(vty, "Count: %u\n", (uint32_t)m->handler.pfdcount);
+	for (i = 0; i < m->handler.pfdcount; i++)
+		vty_out(vty, "\t%6d fd:%6d events:%2d revents:%2d\n", i,
+			m->handler.pfds[i].fd,
+			m->handler.pfds[i].events,
+			m->handler.pfds[i].revents);
+}
+
+DEFUN (show_thread_poll,
+       show_thread_poll_cmd,
+       "show thread poll",
+       SHOW_STR
+       "Thread information\n"
+       "Show poll FD's and information\n")
+{
+	struct listnode *node;
+	struct thread_master *m;
+
+	pthread_mutex_lock(&masters_mtx);
+	{
+		for (ALL_LIST_ELEMENTS_RO(masters, node, m)) {
+			show_thread_poll_helper(vty, m);
+		}
+	}
+	pthread_mutex_unlock(&masters_mtx);
+
+	return CMD_SUCCESS;
+}
+
+
 DEFUN (clear_thread_cpu,
        clear_thread_cpu_cmd,
        "clear thread cpu [FILTER]",
@@ -325,6 +367,7 @@ DEFUN (clear_thread_cpu,
 void thread_cmd_init(void)
 {
 	install_element(VIEW_NODE, &show_thread_cpu_cmd);
+	install_element(VIEW_NODE, &show_thread_poll_cmd);
 	install_element(ENABLE_NODE, &clear_thread_cpu_cmd);
 }
 /* CLI end ------------------------------------------------------------------ */
@@ -381,19 +424,11 @@ struct thread_master *thread_master_crea
 	/* Initialize I/O task data structures */
 	getrlimit(RLIMIT_NOFILE, &limit);
 	rv->fd_limit = (int)limit.rlim_cur;
-	rv->read =
-		XCALLOC(MTYPE_THREAD, sizeof(struct thread *) * rv->fd_limit);
-	if (rv->read == NULL) {
-		XFREE(MTYPE_THREAD_MASTER, rv);
-		return NULL;
-	}
-	rv->write =
-		XCALLOC(MTYPE_THREAD, sizeof(struct thread *) * rv->fd_limit);
-	if (rv->write == NULL) {
-		XFREE(MTYPE_THREAD, rv->read);
-		XFREE(MTYPE_THREAD_MASTER, rv);
-		return NULL;
-	}
+	rv->read = XCALLOC(MTYPE_THREAD_POLL,
+			   sizeof(struct thread *) * rv->fd_limit);
+
+	rv->write = XCALLOC(MTYPE_THREAD_POLL,
+			    sizeof(struct thread *) * rv->fd_limit);
 
 	rv->cpu_record = hash_create_size(
 		8, (unsigned int (*)(void *))cpu_record_hash_key,
@@ -497,17 +532,23 @@ static struct thread *thread_trim_head(s
 	return NULL;
 }
 
+#define THREAD_UNUSED_DEPTH 10
+
 /* Move thread to unuse list. */
 static void thread_add_unuse(struct thread_master *m, struct thread *thread)
 {
 	assert(m != NULL && thread != NULL);
 	assert(thread->next == NULL);
 	assert(thread->prev == NULL);
-	thread->ref = NULL;
 
-	thread->type = THREAD_UNUSED;
 	thread->hist->total_active--;
-	thread_list_add(&m->unuse, thread);
+	memset(thread, 0, sizeof(struct thread));
+	thread->type = THREAD_UNUSED;
+
+	if (m->unuse.count < THREAD_UNUSED_DEPTH)
+		thread_list_add(&m->unuse, thread);
+	else
+		XFREE(MTYPE_THREAD, thread);
 }
 
 /* Free all unused thread. */
@@ -538,7 +579,7 @@ static void thread_array_free(struct thr
 			m->alloc--;
 		}
 	}
-	XFREE(MTYPE_THREAD, thread_array);
+	XFREE(MTYPE_THREAD_POLL, thread_array);
 }
 
 static void thread_queue_free(struct thread_master *m, struct pqueue *queue)
@@ -740,6 +781,7 @@ struct thread *funcname_thread_add_read_
 {
 	struct thread *thread = NULL;
 
+	assert(fd >= 0 && fd < m->fd_limit);
 	pthread_mutex_lock(&m->mtx);
 	{
 		if (t_ptr
@@ -1139,17 +1181,19 @@ void thread_cancel_event(struct thread_m
  */
 void thread_cancel(struct thread *thread)
 {
-	assert(thread->master->owner == pthread_self());
+	struct thread_master *master = thread->master;
+
+	assert(master->owner == pthread_self());
 
-	pthread_mutex_lock(&thread->master->mtx);
+	pthread_mutex_lock(&master->mtx);
 	{
 		struct cancel_req *cr =
 			XCALLOC(MTYPE_TMP, sizeof(struct cancel_req));
 		cr->thread = thread;
-		listnode_add(thread->master->cancel_req, cr);
-		do_thread_cancel(thread->master);
+		listnode_add(master->cancel_req, cr);
+		do_thread_cancel(master);
 	}
-	pthread_mutex_unlock(&thread->master->mtx);
+	pthread_mutex_unlock(&master->mtx);
 }
 
 /**
diff -urpN frr-frr-5.0.1/lib/vector.c frr-frr-6.0/lib/vector.c
--- frr-frr-5.0.1/lib/vector.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vector.c	2018-10-08 14:32:57.000000000 +0200
@@ -153,6 +153,27 @@ void vector_unset(vector v, unsigned int
 	}
 }
 
+void vector_remove(vector v, unsigned int ix)
+{
+	if (ix >= v->active)
+		return;
+
+	int n = (--v->active) - ix;
+
+	memmove(&v->index[ix], &v->index[ix + 1], n * sizeof(void *));
+	v->index[v->active] = NULL;
+}
+
+void vector_compact(vector v)
+{
+	for (unsigned int i = 0; i < vector_active(v); ++i) {
+		if (vector_slot(v, i) == NULL) {
+			vector_remove(v, i);
+			--i;
+		}
+	}
+}
+
 void vector_unset_value(vector v, void *val)
 {
 	size_t i;
@@ -181,3 +202,19 @@ unsigned int vector_count(vector v)
 
 	return count;
 }
+
+void vector_to_array(vector v, void ***dest, int *argc)
+{
+	*dest = XCALLOC(MTYPE_TMP, sizeof(void *) * v->active);
+	memcpy(*dest, v->index, sizeof(void *) * v->active);
+	*argc = v->active;
+}
+
+vector array_to_vector(void **src, int argc)
+{
+	vector v = vector_init(VECTOR_MIN_SIZE);
+
+	for (int i = 0; i < argc; i++)
+		vector_set_index(v, i, src[i]);
+	return v;
+}
diff -urpN frr-frr-5.0.1/lib/vector.h frr-frr-6.0/lib/vector.h
--- frr-frr-5.0.1/lib/vector.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vector.h	2018-10-08 14:32:57.000000000 +0200
@@ -52,6 +52,8 @@ extern int vector_set(vector v, void *va
 extern int vector_set_index(vector v, unsigned int i, void *val);
 extern void vector_unset(vector v, unsigned int i);
 extern void vector_unset_value(vector v, void *val);
+extern void vector_remove(vector v, unsigned int ix);
+extern void vector_compact(vector v);
 
 extern unsigned int vector_count(vector v);
 extern void vector_free(vector v);
@@ -59,5 +61,6 @@ extern vector vector_copy(vector v);
 
 extern void *vector_lookup(vector, unsigned int);
 extern void *vector_lookup_ensure(vector, unsigned int);
-
+extern void vector_to_array(vector v, void ***dest, int *argc);
+extern vector array_to_vector(void **src, int argc);
 #endif /* _ZEBRA_VECTOR_H */
diff -urpN frr-frr-5.0.1/lib/version.h.in frr-frr-6.0/lib/version.h.in
--- frr-frr-5.0.1/lib/version.h.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/version.h.in	2018-10-08 14:32:57.000000000 +0200
@@ -47,10 +47,10 @@
 #define FRR_CONFIG_ARGS "@CONFIG_ARGS@"
 
 #define FRR_DEFAULT_MOTD \
-	"\r\n" \
-	"Hello, this is " FRR_FULL_NAME " (version " FRR_VERSION ").\r\n" \
-	FRR_COPYRIGHT "\r\n" \
-	GIT_INFO "\r\n"
+	"\n" \
+	"Hello, this is " FRR_FULL_NAME " (version " FRR_VERSION ").\n" \
+	FRR_COPYRIGHT "\n" \
+	GIT_INFO "\n"
 
 pid_t pid_output (const char *);
 
diff -urpN frr-frr-5.0.1/lib/vrf.c frr-frr-6.0/lib/vrf.c
--- frr-frr-5.0.1/lib/vrf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vrf.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "ns.h"
 #include "privs.h"
 #include "nexthop_group.h"
+#include "lib_errors.h"
 
 /* default VRF ID value used when VRF backend is not NETNS */
 #define VRF_DEFAULT_INTERNAL 0
@@ -341,91 +342,103 @@ void *vrf_info_lookup(vrf_id_t vrf_id)
 }
 
 /*
- * VRF bit-map
+ * VRF hash for storing set or not.
  */
+struct vrf_bit_set {
+	vrf_id_t vrf_id;
+	bool set;
+};
 
-#define VRF_BITMAP_NUM_OF_GROUPS            1024
-#define VRF_BITMAP_NUM_OF_BITS_IN_GROUP (UINT32_MAX / VRF_BITMAP_NUM_OF_GROUPS)
-#define VRF_BITMAP_NUM_OF_BYTES_IN_GROUP                                       \
-	(VRF_BITMAP_NUM_OF_BITS_IN_GROUP / CHAR_BIT + 1) /* +1 for ensure */
-
-#define VRF_BITMAP_GROUP(_id) ((_id) / VRF_BITMAP_NUM_OF_BITS_IN_GROUP)
-#define VRF_BITMAP_BIT_OFFSET(_id) ((_id) % VRF_BITMAP_NUM_OF_BITS_IN_GROUP)
-
-#define VRF_BITMAP_INDEX_IN_GROUP(_bit_offset) ((_bit_offset) / CHAR_BIT)
-#define VRF_BITMAP_FLAG(_bit_offset)                                           \
-	(((uint8_t)1) << ((_bit_offset) % CHAR_BIT))
+static unsigned int vrf_hash_bitmap_key(void *data)
+{
+	struct vrf_bit_set *bit = data;
 
-struct vrf_bitmap {
-	uint8_t *groups[VRF_BITMAP_NUM_OF_GROUPS];
-};
+	return bit->vrf_id;
+}
+
+static int vrf_hash_bitmap_cmp(const void *a, const void *b)
+{
+	const struct vrf_bit_set *bit1 = a;
+	const struct vrf_bit_set *bit2 = b;
+
+	return bit1->vrf_id == bit2->vrf_id;
+}
+
+static void *vrf_hash_bitmap_alloc(void *data)
+{
+	struct vrf_bit_set *copy = data;
+	struct vrf_bit_set *bit;
+
+	bit = XMALLOC(MTYPE_VRF_BITMAP, sizeof(*bit));
+	bit->vrf_id = copy->vrf_id;
+
+	return bit;
+}
+
+static void vrf_hash_bitmap_free(void *data)
+{
+	struct vrf_bit_set *bit = data;
+
+	XFREE(MTYPE_VRF_BITMAP, bit);
+}
 
 vrf_bitmap_t vrf_bitmap_init(void)
 {
-	return (vrf_bitmap_t)XCALLOC(MTYPE_VRF_BITMAP,
-				     sizeof(struct vrf_bitmap));
+	return hash_create_size(32, vrf_hash_bitmap_key, vrf_hash_bitmap_cmp,
+				"VRF BIT HASH");
 }
 
 void vrf_bitmap_free(vrf_bitmap_t bmap)
 {
-	struct vrf_bitmap *bm = (struct vrf_bitmap *)bmap;
-	int i;
+	struct hash *vrf_hash = bmap;
 
-	if (bmap == VRF_BITMAP_NULL)
+	if (vrf_hash == NULL)
 		return;
 
-	for (i = 0; i < VRF_BITMAP_NUM_OF_GROUPS; i++)
-		if (bm->groups[i])
-			XFREE(MTYPE_VRF_BITMAP, bm->groups[i]);
-
-	XFREE(MTYPE_VRF_BITMAP, bm);
+	hash_clean(vrf_hash, vrf_hash_bitmap_free);
+	hash_free(vrf_hash);
 }
 
 void vrf_bitmap_set(vrf_bitmap_t bmap, vrf_id_t vrf_id)
 {
-	struct vrf_bitmap *bm = (struct vrf_bitmap *)bmap;
-	uint8_t group = VRF_BITMAP_GROUP(vrf_id);
-	uint8_t offset = VRF_BITMAP_BIT_OFFSET(vrf_id);
+	struct vrf_bit_set lookup = { .vrf_id = vrf_id };
+	struct hash *vrf_hash = bmap;
+	struct vrf_bit_set *bit;
 
-	if (bmap == VRF_BITMAP_NULL || vrf_id == VRF_UNKNOWN)
+	if (vrf_hash == NULL || vrf_id == VRF_UNKNOWN)
 		return;
 
-	if (bm->groups[group] == NULL)
-		bm->groups[group] = XCALLOC(MTYPE_VRF_BITMAP,
-					    VRF_BITMAP_NUM_OF_BYTES_IN_GROUP);
-
-	SET_FLAG(bm->groups[group][VRF_BITMAP_INDEX_IN_GROUP(offset)],
-		 VRF_BITMAP_FLAG(offset));
+	bit = hash_get(vrf_hash, &lookup, vrf_hash_bitmap_alloc);
+	bit->set = true;
 }
 
 void vrf_bitmap_unset(vrf_bitmap_t bmap, vrf_id_t vrf_id)
 {
-	struct vrf_bitmap *bm = (struct vrf_bitmap *)bmap;
-	uint8_t group = VRF_BITMAP_GROUP(vrf_id);
-	uint8_t offset = VRF_BITMAP_BIT_OFFSET(vrf_id);
+	struct vrf_bit_set lookup = { .vrf_id = vrf_id };
+	struct hash *vrf_hash = bmap;
+	struct vrf_bit_set *bit;
 
-	if (bmap == VRF_BITMAP_NULL || vrf_id == VRF_UNKNOWN
-	    || bm->groups[group] == NULL)
+	if (vrf_hash == NULL || vrf_id == VRF_UNKNOWN)
 		return;
 
-	UNSET_FLAG(bm->groups[group][VRF_BITMAP_INDEX_IN_GROUP(offset)],
-		   VRF_BITMAP_FLAG(offset));
+	bit = hash_get(vrf_hash, &lookup, vrf_hash_bitmap_alloc);
+	bit->set = false;
 }
 
 int vrf_bitmap_check(vrf_bitmap_t bmap, vrf_id_t vrf_id)
 {
-	struct vrf_bitmap *bm = (struct vrf_bitmap *)bmap;
-	uint8_t group = VRF_BITMAP_GROUP(vrf_id);
-	uint8_t offset = VRF_BITMAP_BIT_OFFSET(vrf_id);
+	struct vrf_bit_set lookup = { .vrf_id = vrf_id };
+	struct hash *vrf_hash = bmap;
+	struct vrf_bit_set *bit;
 
-	if (bmap == VRF_BITMAP_NULL || vrf_id == VRF_UNKNOWN
-	    || bm->groups[group] == NULL)
+	if (vrf_hash == NULL || vrf_id == VRF_UNKNOWN)
 		return 0;
 
-	return CHECK_FLAG(bm->groups[group][VRF_BITMAP_INDEX_IN_GROUP(offset)],
-			  VRF_BITMAP_FLAG(offset))
-		       ? 1
-		       : 0;
+	bit = hash_lookup(vrf_hash, &lookup);
+	if (bit)
+		return bit->set;
+
+	return 0;
 }
 
 static void vrf_autocomplete(vector comps, struct cmd_token *token)
@@ -466,13 +479,15 @@ void vrf_init(int (*create)(struct vrf *
 	/* The default VRF always exists. */
 	default_vrf = vrf_get(VRF_DEFAULT, VRF_DEFAULT_NAME);
 	if (!default_vrf) {
-		zlog_err("vrf_init: failed to create the default VRF!");
+		flog_err(LIB_ERR_VRF_START,
+			  "vrf_init: failed to create the default VRF!");
 		exit(1);
 	}
 
 	/* Enable the default VRF. */
 	if (!vrf_enable(default_vrf)) {
-		zlog_err("vrf_init: failed to enable the default VRF!");
+		flog_err(LIB_ERR_VRF_START,
+			  "vrf_init: failed to enable the default VRF!");
 		exit(1);
 	}
 
@@ -542,20 +557,23 @@ int vrf_socket(int domain, int type, int
 
 	ret = vrf_switch_to_netns(vrf_id);
 	if (ret < 0)
-		zlog_err("%s: Can't switch to VRF %u (%s)", __func__, vrf_id,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: Can't switch to VRF %u (%s)",
+			     __func__, vrf_id, safe_strerror(errno));
+
 	if (ret > 0 && interfacename && vrf_default_accepts_vrf(type)) {
 		zlog_err("VRF socket not used since net.ipv4.%s_l3mdev_accept != 0",
 			  (type == SOCK_STREAM ? "tcp" : "udp"));
 		errno = EEXIST; /* not sure if this is the best error... */
 		return -2;
 	}
+
 	ret = socket(domain, type, protocol);
 	save_errno = errno;
 	ret2 = vrf_switchback_to_initial();
 	if (ret2 < 0)
-		zlog_err("%s: Can't switchback from VRF %u (%s)", __func__,
-			 vrf_id, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: Can't switchback from VRF %u (%s)", __func__,
+			     vrf_id, safe_strerror(errno));
 	errno = save_errno;
 	if (ret <= 0)
 		return ret;
@@ -628,7 +646,7 @@ int vrf_netns_handler_create(struct vty
 	}
 	if (vrf->ns_ctxt != NULL) {
 		ns = (struct ns *)vrf->ns_ctxt;
-		if (ns && 0 != strcmp(ns->name, pathname)) {
+		if (!strcmp(ns->name, pathname)) {
 			if (vty)
 				vty_out(vty,
 					"VRF %u already configured with NETNS %s\n",
@@ -661,8 +679,7 @@ int vrf_netns_handler_create(struct vty
 	ns->vrf_ctxt = (void *)vrf;
 	vrf->ns_ctxt = (void *)ns;
 	/* update VRF netns NAME */
-	if (vrf)
-		strlcpy(vrf->data.l.netns_name, basename(pathname), NS_NAMSIZ);
+	strlcpy(vrf->data.l.netns_name, basename(pathname), NS_NAMSIZ);
 
 	if (!ns_enable(ns, vrf_update_vrf_id)) {
 		if (vty)
@@ -677,10 +694,8 @@ int vrf_netns_handler_create(struct vty
 	return CMD_SUCCESS;
 }
 
-int vrf_is_mapped_on_netns(vrf_id_t vrf_id)
+int vrf_is_mapped_on_netns(struct vrf *vrf)
 {
-	struct vrf *vrf = vrf_lookup_by_id(vrf_id);
-
 	if (!vrf || vrf->data.l.netns_name[0] == '\0')
 		return 0;
 	if (vrf->vrf_id == VRF_DEFAULT)
@@ -712,12 +727,12 @@ DEFUN_NOSH (vrf,
 	return vrf_handler_create(vty, vrfname, NULL);
 }
 
-DEFUN_NOSH (no_vrf,
-           no_vrf_cmd,
-           "no vrf NAME",
-           NO_STR
-           "Delete a pseudo VRF's configuration\n"
-           "VRF's name\n")
+DEFUN (no_vrf,
+       no_vrf_cmd,
+       "no vrf NAME",
+       NO_STR
+       "Delete a pseudo VRF's configuration\n"
+       "VRF's name\n")
 {
 	const char *vrfname = argv[2]->arg;
 
@@ -746,10 +761,10 @@ DEFUN_NOSH (no_vrf,
 struct cmd_node vrf_node = {VRF_NODE, "%s(config-vrf)# ", 1};
 
 DEFUN_NOSH (vrf_netns,
-	    vrf_netns_cmd,
-	    "netns NAME",
-	    "Attach VRF to a Namespace\n"
-	    "The file name in " NS_RUN_DIR ", or a full pathname\n")
+       vrf_netns_cmd,
+       "netns NAME",
+       "Attach VRF to a Namespace\n"
+       "The file name in " NS_RUN_DIR ", or a full pathname\n")
 {
 	int idx_name = 1, ret;
 	char *pathname = ns_netns_pathname(vty, argv[idx_name]->arg);
@@ -759,20 +774,14 @@ DEFUN_NOSH (vrf_netns,
 	if (!pathname)
 		return CMD_WARNING_CONFIG_FAILED;
 
-	if (vrf_daemon_privs &&
-	    vrf_daemon_privs->change(ZPRIVS_RAISE))
-		zlog_err("%s: Can't raise privileges", __func__);
-
-	ret = vrf_netns_handler_create(vty, vrf, pathname,
-				       NS_UNKNOWN, NS_UNKNOWN);
-
-	if (vrf_daemon_privs &&
-	    vrf_daemon_privs->change(ZPRIVS_LOWER))
-		zlog_err("%s: Can't lower privileges", __func__);
+	frr_elevate_privs(vrf_daemon_privs) {
+		ret = vrf_netns_handler_create(vty, vrf, pathname,
+					       NS_UNKNOWN, NS_UNKNOWN);
+	}
 	return ret;
 }
 
-DEFUN (no_vrf_netns,
+DEFUN_NOSH (no_vrf_netns,
 	no_vrf_netns_cmd,
 	"no netns [NAME]",
 	NO_STR
@@ -888,7 +897,7 @@ int vrf_bind(vrf_id_t vrf_id, int fd, ch
 
 	if (fd < 0 || name == NULL)
 		return fd;
-	if (vrf_is_mapped_on_netns(vrf_id))
+	if (vrf_is_mapped_on_netns(vrf_lookup_by_id(vrf_id)))
 		return fd;
 #ifdef SO_BINDTODEVICE
 	ret = setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, name, strlen(name)+1);
@@ -906,14 +915,15 @@ int vrf_getaddrinfo(const char *node, co
 
 	ret = vrf_switch_to_netns(vrf_id);
 	if (ret < 0)
-		zlog_err("%s: Can't switch to VRF %u (%s)", __func__, vrf_id,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: Can't switch to VRF %u (%s)",
+			     __func__, vrf_id, safe_strerror(errno));
 	ret = getaddrinfo(node, service, hints, res);
 	save_errno = errno;
 	ret2 = vrf_switchback_to_initial();
 	if (ret2 < 0)
-		zlog_err("%s: Can't switchback from VRF %u (%s)", __func__,
-			 vrf_id, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: Can't switchback from VRF %u (%s)", __func__,
+			     vrf_id, safe_strerror(errno));
 	errno = save_errno;
 	return ret;
 }
@@ -924,16 +934,17 @@ int vrf_ioctl(vrf_id_t vrf_id, int d, un
 
 	ret = vrf_switch_to_netns(vrf_id);
 	if (ret < 0) {
-		zlog_err("%s: Can't switch to VRF %u (%s)", __func__, vrf_id,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: Can't switch to VRF %u (%s)",
+			     __func__, vrf_id, safe_strerror(errno));
 		return 0;
 	}
 	rc = ioctl(d, request, params);
 	saved_errno = errno;
 	ret = vrf_switchback_to_initial();
 	if (ret < 0)
-		zlog_err("%s: Can't switchback from VRF %u (%s)", __func__,
-			 vrf_id, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: Can't switchback from VRF %u (%s)", __func__,
+			     vrf_id, safe_strerror(errno));
 	errno = saved_errno;
 	return rc;
 }
@@ -945,14 +956,15 @@ int vrf_sockunion_socket(const union soc
 
 	ret = vrf_switch_to_netns(vrf_id);
 	if (ret < 0)
-		zlog_err("%s: Can't switch to VRF %u (%s)", __func__, vrf_id,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: Can't switch to VRF %u (%s)",
+			     __func__, vrf_id, safe_strerror(errno));
 	ret = sockunion_socket(su);
 	save_errno = errno;
 	ret2 = vrf_switchback_to_initial();
 	if (ret2 < 0)
-		zlog_err("%s: Can't switchback from VRF %u (%s)", __func__,
-			 vrf_id, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: Can't switchback from VRF %u (%s)", __func__,
+			     vrf_id, safe_strerror(errno));
 	errno = save_errno;
 
 	if (ret <= 0)
diff -urpN frr-frr-5.0.1/lib/vrf.h frr-frr-6.0/lib/vrf.h
--- frr-frr-5.0.1/lib/vrf.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vrf.h	2018-10-08 14:32:57.000000000 +0200
@@ -111,15 +111,23 @@ extern struct vrf *vrf_get(vrf_id_t, con
 extern const char *vrf_id_to_name(vrf_id_t vrf_id);
 extern vrf_id_t vrf_name_to_id(const char *);
 
-#define VRF_GET_ID(V, NAME)                                                    \
+#define VRF_GET_ID(V, NAME, USE_JSON)                                          \
 	do {                                                                   \
 		struct vrf *vrf;                                               \
 		if (!(vrf = vrf_lookup_by_name(NAME))) {                       \
-			vty_out(vty, "%% VRF %s not found\n", NAME);           \
+			if (USE_JSON) {                                        \
+				vty_out(vty, "{}\n");                          \
+			} else {                                               \
+				vty_out(vty, "%% VRF %s not found\n", NAME);   \
+			}                                                      \
 			return CMD_WARNING;                                    \
 		}                                                              \
 		if (vrf->vrf_id == VRF_UNKNOWN) {                              \
-			vty_out(vty, "%% VRF %s not active\n", NAME);          \
+			if (USE_JSON) {                                        \
+				vty_out(vty, "{}\n");                          \
+			} else {                                               \
+				vty_out(vty, "%% VRF %s not active\n", NAME);  \
+			}                                                      \
 			return CMD_WARNING;                                    \
 		}                                                              \
 		(V) = vrf->vrf_id;                                             \
@@ -229,7 +237,7 @@ extern vrf_id_t vrf_get_default_id(void)
 #define VRF_DEFAULT vrf_get_default_id()
 
 /* VRF is mapped on netns or not ? */
-int vrf_is_mapped_on_netns(vrf_id_t vrf_id);
+int vrf_is_mapped_on_netns(struct vrf *vrf);
 
 /* VRF switch from NETNS */
 extern int vrf_switch_to_netns(vrf_id_t vrf_id);
diff -urpN frr-frr-5.0.1/lib/vty.c frr-frr-6.0/lib/vty.c
--- frr-frr-5.0.1/lib/vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,10 +21,14 @@
 
 #include <zebra.h>
 
+#include <lib/version.h>
+#include <sys/types.h>
+#include <regex.h>
+#include <stdio.h>
+
 #include "linklist.h"
 #include "thread.h"
 #include "buffer.h"
-#include <lib/version.h>
 #include "command.h"
 #include "sockunion.h"
 #include "memory.h"
@@ -35,6 +39,8 @@
 #include "privs.h"
 #include "network.h"
 #include "libfrr.h"
+#include "frrstr.h"
+#include "lib_errors.h"
 
 #include <arpa/telnet.h>
 #include <termios.h>
@@ -109,6 +115,33 @@ void vty_endframe(struct vty *vty, const
 	vty->frame_pos = 0;
 }
 
+bool vty_set_include(struct vty *vty, const char *regexp)
+{
+	int errcode;
+	bool ret = true;
+	char errbuf[256];
+
+	if (!regexp) {
+		if (vty->filter) {
+			regfree(&vty->include);
+			vty->filter = false;
+		}
+		return true;
+	}
+
+	errcode = regcomp(&vty->include, regexp,
+			  REG_EXTENDED | REG_NEWLINE | REG_NOSUB);
+	if (errcode) {
+		ret = false;
+		regerror(ret, &vty->include, errbuf, sizeof(errbuf));
+		vty_out(vty, "%% Regex compilation error: %s", errbuf);
+	} else {
+		vty->filter = true;
+	}
+
+	return ret;
+}
+
 /* VTY standard output function. */
 int vty_out(struct vty *vty, const char *format, ...)
 {
@@ -117,58 +150,124 @@ int vty_out(struct vty *vty, const char
 	int size = 1024;
 	char buf[1024];
 	char *p = NULL;
+	char *filtered;
 
 	if (vty->frame_pos) {
 		vty->frame_pos = 0;
 		vty_out(vty, "%s", vty->frame);
 	}
 
-	if (vty_shell(vty)) {
-		va_start(args, format);
-		vprintf(format, args);
-		va_end(args);
-	} else {
-		/* Try to write to initial buffer.  */
-		va_start(args, format);
-		len = vsnprintf(buf, sizeof(buf), format, args);
-		va_end(args);
-
-		/* Initial buffer is not enough.  */
-		if (len < 0 || len >= size) {
-			while (1) {
-				if (len > -1)
-					size = len + 1;
-				else
-					size = size * 2;
-
-				p = XREALLOC(MTYPE_VTY_OUT_BUF, p, size);
-				if (!p)
-					return -1;
-
-				va_start(args, format);
-				len = vsnprintf(p, size, format, args);
-				va_end(args);
+	/* Try to write to initial buffer.  */
+	va_start(args, format);
+	len = vsnprintf(buf, sizeof(buf), format, args);
+	va_end(args);
 
-				if (len > -1 && len < size)
-					break;
-			}
+	/* Initial buffer is not enough.  */
+	if (len < 0 || len >= size) {
+		while (1) {
+			if (len > -1)
+				size = len + 1;
+			else
+				size = size * 2;
+
+			p = XREALLOC(MTYPE_VTY_OUT_BUF, p, size);
+			if (!p)
+				return -1;
+
+			va_start(args, format);
+			len = vsnprintf(p, size, format, args);
+			va_end(args);
+
+			if (len > -1 && len < size)
+				break;
 		}
+	}
 
-		/* When initial buffer is enough to store all output.  */
-		if (!p)
-			p = buf;
-
-		/* Pointer p must point out buffer. */
-		if (vty->type != VTY_TERM)
-			buffer_put(vty->obuf, (uint8_t *)p, len);
-		else
-			buffer_put_crlf(vty->obuf, (uint8_t *)p, len);
+	/* When initial buffer is enough to store all output.  */
+	if (!p)
+		p = buf;
+
+	/* filter buffer */
+	if (vty->filter) {
+		vector lines = frrstr_split_vec(p, "\n");
+
+		/* Place first value in the cache */
+		char *firstline = vector_slot(lines, 0);
+		buffer_put(vty->lbuf, (uint8_t *) firstline, strlen(firstline));
+
+		/* If our split returned more than one entry, time to filter */
+		if (vector_active(lines) > 1) {
+			/*
+			 * returned string is MTYPE_TMP so it matches the MTYPE
+			 * of everything else in the vector
+			 */
+			char *bstr = buffer_getstr(vty->lbuf);
+			buffer_reset(vty->lbuf);
+			XFREE(MTYPE_TMP, lines->index[0]);
+			vector_set_index(lines, 0, bstr);
+			frrstr_filter_vec(lines, &vty->include);
+			vector_compact(lines);
+			/*
+			 * Consider the string "foo\n". If the regex is an empty string
+			 * and the line ended with a newline, then the vector will look
+			 * like:
+			 *
+			 * [0]: 'foo'
+			 * [1]: ''
+			 *
+			 * If the regex isn't empty, the vector will look like:
+			 *
+			 * [0]: 'foo'
+			 *
+			 * In this case we'd like to preserve the newline, so we add
+			 * the empty string [1] as in the first example.
+			 */
+			if (p[strlen(p) - 1] == '\n' && vector_active(lines) > 0
+			    && strlen(vector_slot(lines, vector_active(lines) - 1)))
+				vector_set(lines, XSTRDUP(MTYPE_TMP, ""));
+
+			filtered = frrstr_join_vec(lines, "\n");
+		}
+		else {
+			filtered = NULL;
+		}
+
+		frrstr_strvec_free(lines);
+
+	} else {
+		filtered = p;
+	}
 
-		/* If p is not different with buf, it is allocated buffer.  */
-		if (p != buf)
-			XFREE(MTYPE_VTY_OUT_BUF, p);
+	if (!filtered)
+		goto done;
+
+	switch (vty->type) {
+	case VTY_TERM:
+		/* print with crlf replacement */
+		buffer_put_crlf(vty->obuf, (uint8_t *)filtered,
+				strlen(filtered));
+		break;
+	case VTY_SHELL:
+		fprintf(vty->of, "%s", filtered);
+		fflush(vty->of);
+		break;
+	case VTY_SHELL_SERV:
+	case VTY_FILE:
+	default:
+		/* print without crlf replacement */
+		buffer_put(vty->obuf, (uint8_t *)filtered, strlen(filtered));
+		break;
 	}
 
+done:
+
+	if (vty->filter && filtered)
+		XFREE(MTYPE_TMP, filtered);
+
+	/* If p is not different with buf, it is allocated buffer.  */
+	if (p != buf)
+		XFREE(MTYPE_VTY_OUT_BUF, p);
+
 	return len;
 }
 
@@ -218,6 +317,7 @@ static int vty_log_out(struct vty *vty,
 		zlog_warn("%s: write failed to vty client fd %d, closing: %s",
 			  __func__, vty->fd, safe_strerror(errno));
 		buffer_reset(vty->obuf);
+		buffer_reset(vty->lbuf);
 		/* cannot call vty_close, because a parent routine may still try
 		   to access the vty struct */
 		vty->status = VTY_CLOSE;
@@ -316,20 +416,6 @@ vty_dont_lflow_ahead (struct vty *vty)
 }
 #endif /* 0 */
 
-/* Allocate new vty struct. */
-struct vty *vty_new()
-{
-	struct vty *new = XCALLOC(MTYPE_VTY, sizeof(struct vty));
-
-	new->fd = new->wfd = -1;
-	new->obuf = buffer_new(0); /* Use default buffer size. */
-	new->buf = XCALLOC(MTYPE_VTY, VTY_BUFSIZ);
-	new->error_buf = XCALLOC(MTYPE_VTY, VTY_BUFSIZ);
-	new->max = VTY_BUFSIZ;
-
-	return new;
-}
-
 /* Authentication of vty */
 static void vty_auth(struct vty *vty, char *buf)
 {
@@ -391,10 +477,11 @@ static void vty_auth(struct vty *vty, ch
 static int vty_command(struct vty *vty, char *buf)
 {
 	int ret;
-	vector vline;
 	const char *protocolname;
 	char *cp = NULL;
 
+	assert(vty);
+
 	/*
 	 * Log non empty command lines
 	 */
@@ -412,26 +499,21 @@ static int vty_command(struct vty *vty,
 
 		/* format the base vty info */
 		snprintf(vty_str, sizeof(vty_str), "vty[??]@%s", vty->address);
-		if (vty)
-			for (i = 0; i < vector_active(vtyvec); i++)
-				if (vty == vector_slot(vtyvec, i)) {
-					snprintf(vty_str, sizeof(vty_str),
-						 "vty[%d]@%s", i, vty->address);
-					break;
-				}
+
+		for (i = 0; i < vector_active(vtyvec); i++)
+			if (vty == vector_slot(vtyvec, i)) {
+				snprintf(vty_str, sizeof(vty_str), "vty[%d]@%s",
+					 i, vty->address);
+				break;
+			}
 
 		/* format the prompt */
 		snprintf(prompt_str, sizeof(prompt_str), cmd_prompt(vty->node),
 			 vty_str);
 
 		/* now log the command */
-		zlog_err("%s%s", prompt_str, buf);
+		zlog_notice("%s%s", prompt_str, buf);
 	}
-	/* Split readline string up into the vector */
-	vline = cmd_make_strvec(buf);
-
-	if (vline == NULL)
-		return CMD_SUCCESS;
 
 #ifdef CONSUMED_TIME_CHECK
 	{
@@ -442,7 +524,7 @@ static int vty_command(struct vty *vty,
 		GETRUSAGE(&before);
 #endif /* CONSUMED_TIME_CHECK */
 
-		ret = cmd_execute_command(vline, vty, NULL, 0);
+		ret = cmd_execute(vty, buf, NULL, 0);
 
 		/* Get the name of the protocol if any */
 		protocolname = frr_protoname;
@@ -475,7 +557,6 @@ static int vty_command(struct vty *vty,
 			vty_out(vty, "%% Command incomplete.\n");
 			break;
 		}
-	cmd_free_strvec(vline);
 
 	return ret;
 }
@@ -734,6 +815,8 @@ static void vty_end_config(struct vty *v
 	case KEYCHAIN_KEY_NODE:
 	case VTY_NODE:
 	case BGP_EVPN_VNI_NODE:
+	case BFD_NODE:
+	case BFD_PEER_NODE:
 		vty_config_unlock(vty);
 		vty->node = ENABLE_NODE;
 		break;
@@ -1130,6 +1213,8 @@ static void vty_stop_input(struct vty *v
 	case KEYCHAIN_NODE:
 	case KEYCHAIN_KEY_NODE:
 	case VTY_NODE:
+	case BFD_NODE:
+	case BFD_PEER_NODE:
 		vty_config_unlock(vty);
 		vty->node = ENABLE_NODE;
 		break;
@@ -1245,9 +1330,9 @@ static int vty_telnet_option(struct vty
 					TELNET_NAWS_SB_LEN,
 					(unsigned long)vty->sb_len);
 			else if (sizeof(vty->sb_buf) < TELNET_NAWS_SB_LEN)
-				zlog_err(
-					"Bug detected: sizeof(vty->sb_buf) %lu < %d, "
-					"too small to handle the telnet NAWS option",
+				flog_err(
+					LIB_ERR_DEVELOPMENT,
+					"Bug detected: sizeof(vty->sb_buf) %lu < %d, too small to handle the telnet NAWS option",
 					(unsigned long)sizeof(vty->sb_buf),
 					TELNET_NAWS_SB_LEN);
 			else {
@@ -1336,6 +1421,7 @@ static void vty_escape_map(unsigned char
 static void vty_buffer_reset(struct vty *vty)
 {
 	buffer_reset(vty->obuf);
+	buffer_reset(vty->lbuf);
 	vty_prompt(vty);
 	vty_redraw_line(vty);
 }
@@ -1364,6 +1450,7 @@ static int vty_read(struct thread *threa
 				"%s: read error on vty client fd %d, closing: %s",
 				__func__, vty->fd, safe_strerror(errno));
 			buffer_reset(vty->obuf);
+			buffer_reset(vty->lbuf);
 		}
 		vty->status = VTY_CLOSE;
 	}
@@ -1568,6 +1655,7 @@ static int vty_flush(struct thread *thre
 			0; /* disable monitoring to avoid infinite recursion */
 		zlog_warn("buffer_flush failed on vty client fd %d, closing",
 			  vty->fd);
+		buffer_reset(vty->lbuf);
 		buffer_reset(vty->obuf);
 		vty_close(vty);
 		return 0;
@@ -1591,6 +1679,23 @@ static int vty_flush(struct thread *thre
 	return 0;
 }
 
+/* Allocate new vty struct. */
+struct vty *vty_new()
+{
+	struct vty *new = XCALLOC(MTYPE_VTY, sizeof(struct vty));
+
+	new->fd = new->wfd = -1;
+	new->of = stdout;
+	new->lbuf = buffer_new(0);
+	new->obuf = buffer_new(0); /* Use default buffer size. */
+	new->buf = XCALLOC(MTYPE_VTY, VTY_BUFSIZ);
+	new->error_buf = XCALLOC(MTYPE_VTY, VTY_BUFSIZ);
+	new->max = VTY_BUFSIZ;
+
+	return new;
+}
+
+
 /* allocate and initialise vty */
 static struct vty *vty_new_init(int vty_sock)
 {
@@ -1868,7 +1973,8 @@ static void vty_serv_sock_addrinfo(const
 	ret = getaddrinfo(hostname, port_str, &req, &ainfo);
 
 	if (ret != 0) {
-		zlog_err("getaddrinfo failed: %s", gai_strerror(ret));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL, "getaddrinfo failed: %s",
+			     gai_strerror(ret));
 		exit(1);
 	}
 
@@ -1928,8 +2034,9 @@ static void vty_serv_un(const char *path
 	/* Make UNIX domain socket. */
 	sock = socket(AF_UNIX, SOCK_STREAM, 0);
 	if (sock < 0) {
-		zlog_err("Cannot create unix stream socket: %s",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "Cannot create unix stream socket: %s",
+			     safe_strerror(errno));
 		return;
 	}
 
@@ -1947,15 +2054,16 @@ static void vty_serv_un(const char *path
 
 	ret = bind(sock, (struct sockaddr *)&serv, len);
 	if (ret < 0) {
-		zlog_err("Cannot bind path %s: %s", path, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "Cannot bind path %s: %s", path,
+			     safe_strerror(errno));
 		close(sock); /* Avoid sd leak. */
 		return;
 	}
 
 	ret = listen(sock, 5);
 	if (ret < 0) {
-		zlog_err("listen(fd %d) failed: %s", sock,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "listen(fd %d) failed: %s", sock,
+			     safe_strerror(errno));
 		close(sock); /* Avoid sd leak. */
 		return;
 	}
@@ -1970,8 +2078,9 @@ static void vty_serv_un(const char *path
 	if ((int)ids.gid_vty > 0) {
 		/* set group of socket */
 		if (chown(path, -1, ids.gid_vty)) {
-			zlog_err("vty_serv_un: could chown socket, %s",
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "vty_serv_un: could chown socket, %s",
+				     safe_strerror(errno));
 		}
 	}
 
@@ -2039,6 +2148,7 @@ static int vtysh_flush(struct vty *vty)
 			0; /* disable monitoring to avoid infinite recursion */
 		zlog_warn("%s: write error to fd %d, closing", __func__,
 			  vty->fd);
+		buffer_reset(vty->lbuf);
 		buffer_reset(vty->obuf);
 		vty_close(vty);
 		return -1;
@@ -2075,6 +2185,7 @@ static int vtysh_read(struct thread *thr
 				"%s: read failed on vtysh client fd %d, closing: %s",
 				__func__, sock, safe_strerror(errno));
 		}
+		buffer_reset(vty->lbuf);
 		buffer_reset(vty->obuf);
 		vty_close(vty);
 #ifdef VTYSH_DEBUG
@@ -2180,6 +2291,7 @@ void vty_close(struct vty *vty)
 
 	/* Free input buffer. */
 	buffer_free(vty->obuf);
+	buffer_free(vty->lbuf);
 
 	/* Free command history. */
 	for (i = 0; i < VTY_MAXHIST; i++)
@@ -2200,9 +2312,9 @@ void vty_close(struct vty *vty)
 	 * additionally, we'd need to replace these fds with /dev/null. */
 	if (vty->wfd > STDERR_FILENO && vty->wfd != vty->fd)
 		close(vty->wfd);
-	if (vty->fd > STDERR_FILENO) {
+	if (vty->fd > STDERR_FILENO)
 		close(vty->fd);
-	} else
+	if (vty->fd == STDIN_FILENO)
 		was_stdio = true;
 
 	if (vty->buf)
@@ -2231,6 +2343,7 @@ static int vty_timeout(struct thread *th
 	vty->v_timeout = 0;
 
 	/* Clear buffer*/
+	buffer_reset(vty->lbuf);
 	buffer_reset(vty->obuf);
 	vty_out(vty, "\nVty connection is timed out.\n");
 
@@ -2298,8 +2411,9 @@ static void vty_read_file(FILE *confp)
 		nl = strchr(vty->error_buf, '\n');
 		if (nl)
 			*nl = '\0';
-		zlog_err("ERROR: %s on config line %u: %s", message, line_num,
-			 vty->error_buf);
+		flog_err(LIB_ERR_VTY,
+			  "ERROR: %s on config line %u: %s", message, line_num,
+			  vty->error_buf);
 	}
 
 	vty_close(vty);
@@ -2360,18 +2474,20 @@ static FILE *vty_use_backup_config(const
 }
 
 /* Read up configuration file from file_name. */
-void vty_read_config(const char *config_file, char *config_default_dir)
+bool vty_read_config(const char *config_file, char *config_default_dir)
 {
 	char cwd[MAXPATHLEN];
 	FILE *confp = NULL;
 	const char *fullpath;
 	char *tmp = NULL;
+	bool read_success = false;
 
 	/* If -f flag specified. */
 	if (config_file != NULL) {
 		if (!IS_DIRECTORY_SEP(config_file[0])) {
 			if (getcwd(cwd, MAXPATHLEN) == NULL) {
-				zlog_err(
+				flog_err_sys(
+					LIB_ERR_SYSTEM_CALL,
 					"Failure to determine Current Working Directory %d!",
 					errno);
 				exit(1);
@@ -2386,7 +2502,7 @@ void vty_read_config(const char *config_
 		confp = fopen(fullpath, "r");
 
 		if (confp == NULL) {
-			zlog_err("%s: failed to open configuration file %s: %s",
+			zlog_warn("%s: failed to open configuration file %s: %s, checking backup",
 				 __func__, fullpath, safe_strerror(errno));
 
 			confp = vty_use_backup_config(fullpath);
@@ -2394,8 +2510,9 @@ void vty_read_config(const char *config_
 				zlog_warn(
 					"WARNING: using backup configuration file!");
 			else {
-				zlog_err("can't open configuration file [%s]",
-					 config_file);
+				flog_err(LIB_ERR_VTY,
+					  "can't open configuration file [%s]",
+					  config_file);
 				exit(1);
 			}
 		}
@@ -2423,15 +2540,17 @@ void vty_read_config(const char *config_
 
 		if (strstr(config_default_dir, "vtysh") == NULL) {
 			ret = stat(integrate_default, &conf_stat);
-			if (ret >= 0)
+			if (ret >= 0) {
+				read_success = true;
 				goto tmp_free_and_out;
+			}
 		}
 #endif /* VTYSH */
 		confp = fopen(config_default_dir, "r");
 		if (confp == NULL) {
-			zlog_err("%s: failed to open configuration file %s: %s",
-				 __func__, config_default_dir,
-				 safe_strerror(errno));
+			zlog_warn("%s: failed to open configuration file %s: %s, checking backup",
+				  __func__, config_default_dir,
+				  safe_strerror(errno));
 
 			confp = vty_use_backup_config(config_default_dir);
 			if (confp) {
@@ -2439,8 +2558,9 @@ void vty_read_config(const char *config_
 					"WARNING: using backup configuration file!");
 				fullpath = config_default_dir;
 			} else {
-				zlog_err("can't open configuration file [%s]",
-					 config_default_dir);
+				flog_err(LIB_ERR_VTY,
+					  "can't open configuration file [%s]",
+					  config_default_dir);
 				goto tmp_free_and_out;
 			}
 		} else
@@ -2448,6 +2568,7 @@ void vty_read_config(const char *config_
 	}
 
 	vty_read_file(confp);
+	read_success = true;
 
 	fclose(confp);
 
@@ -2456,6 +2577,8 @@ void vty_read_config(const char *config_
 tmp_free_and_out:
 	if (tmp)
 		XFREE(MTYPE_TMP, tmp);
+
+	return read_success;
 }
 
 /* Small utility function which output log to the VTY. */
@@ -2909,6 +3032,7 @@ void vty_reset()
 
 	for (i = 0; i < vector_active(vtyvec); i++)
 		if ((vty = vector_slot(vtyvec, i)) != NULL) {
+			buffer_reset(vty->lbuf);
 			buffer_reset(vty->obuf);
 			vty->status = VTY_CLOSE;
 			vty_close(vty);
@@ -2949,12 +3073,14 @@ static void vty_save_cwd(void)
 		 * Hence not worrying about it too much.
 		 */
 		if (!chdir(SYSCONFDIR)) {
-			zlog_err("Failure to chdir to %s, errno: %d",
-				 SYSCONFDIR, errno);
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "Failure to chdir to %s, errno: %d",
+				     SYSCONFDIR, errno);
 			exit(-1);
 		}
 		if (getcwd(cwd, MAXPATHLEN) == NULL) {
-			zlog_err("Failure to getcwd, errno: %d", errno);
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "Failure to getcwd, errno: %d", errno);
 			exit(-1);
 		}
 	}
diff -urpN frr-frr-5.0.1/lib/vty.h frr-frr-6.0/lib/vty.h
--- frr-frr-5.0.1/lib/vty.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/vty.h	2018-10-08 14:32:57.000000000 +0200
@@ -21,6 +21,9 @@
 #ifndef _ZEBRA_VTY_H
 #define _ZEBRA_VTY_H
 
+#include <sys/types.h>
+#include <regex.h>
+
 #include "thread.h"
 #include "log.h"
 #include "sockunion.h"
@@ -38,6 +41,13 @@ struct vty {
 	/* output FD, to support stdin/stdout combination */
 	int wfd;
 
+	/* File output, used for VTYSH only */
+	FILE *of;
+	FILE *of_saved;
+
+	/* whether we are using pager or not */
+	bool is_paged;
+
 	/* Is this vty connect to file or not */
 	enum { VTY_TERM, VTY_FILE, VTY_SHELL, VTY_SHELL_SERV } type;
 
@@ -47,6 +57,13 @@ struct vty {
 	/* Failure count */
 	int fail;
 
+	/* Output filer regex */
+	bool filter;
+	regex_t include;
+
+	/* Line buffer */
+	struct buffer *lbuf;
+
 	/* Output buffer. */
 	struct buffer *obuf;
 
@@ -223,8 +240,9 @@ extern struct vty *vty_stdio(void (*atcl
 extern int vty_out(struct vty *, const char *, ...) PRINTF_ATTRIBUTE(2, 3);
 extern void vty_frame(struct vty *, const char *, ...) PRINTF_ATTRIBUTE(2, 3);
 extern void vty_endframe(struct vty *, const char *);
+bool vty_set_include(struct vty *vty, const char *regexp);
 
-extern void vty_read_config(const char *, char *);
+extern bool vty_read_config(const char *, char *);
 extern void vty_time_print(struct vty *, int);
 extern void vty_serv_sock(const char *, unsigned short, const char *);
 extern void vty_close(struct vty *);
diff -urpN frr-frr-5.0.1/lib/workqueue.c frr-frr-6.0/lib/workqueue.c
--- frr-frr-5.0.1/lib/workqueue.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/workqueue.c	2018-10-08 14:32:57.000000000 +0200
@@ -81,9 +81,6 @@ struct work_queue *work_queue_new(struct
 
 	new = XCALLOC(MTYPE_WORK_QUEUE, sizeof(struct work_queue));
 
-	if (new == NULL)
-		return new;
-
 	new->name = XSTRDUP(MTYPE_WORK_QUEUE_NAME, queue_name);
 	new->master = m;
 	SET_FLAG(new->flags, WQ_UNPLUGGED);
@@ -152,10 +149,7 @@ void work_queue_add(struct work_queue *w
 
 	assert(wq);
 
-	if (!(item = work_queue_item_new(wq))) {
-		zlog_err("%s: unable to get new queue item", __func__);
-		return;
-	}
+	item = work_queue_item_new(wq);
 
 	item->data = data;
 	work_queue_item_enqueue(wq, item);
@@ -245,10 +239,11 @@ int work_queue_run(struct thread *thread
 	char yielded = 0;
 
 	wq = THREAD_ARG(thread);
-	wq->thread = NULL;
 
 	assert(wq);
 
+	wq->thread = NULL;
+
 	/* calculate cycle granularity:
 	 * list iteration == 1 run
 	 * listnode processing == 1 cycle
diff -urpN frr-frr-5.0.1/lib/workqueue.h frr-frr-6.0/lib/workqueue.h
--- frr-frr-5.0.1/lib/workqueue.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/workqueue.h	2018-10-08 14:32:57.000000000 +0200
@@ -154,7 +154,7 @@ extern struct work_queue *work_queue_new
  * The usage of work_queue_free is being transitioned to pass
  * in the double pointer to remove use after free's.
  */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20190205
+#if CONFDATE > 20190205
 CPP_NOTICE("work_queue_free without double pointer is deprecated, please fixup")
 #endif
 extern void work_queue_free_and_null(struct work_queue **);
diff -urpN frr-frr-5.0.1/lib/zclient.c frr-frr-6.0/lib/zclient.c
--- frr-frr-5.0.1/lib/zclient.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/zclient.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@
 #include "sockopt.h"
 #include "pbr.h"
 #include "nexthop_group.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(LIB, ZCLIENT, "Zclient")
 DEFINE_MTYPE_STATIC(LIB, REDIST_INST, "Redistribution instance IDs")
@@ -212,9 +213,9 @@ int zclient_socket_connect(struct zclien
 
 	set_cloexec(sock);
 
-	zclient->privs->change(ZPRIVS_RAISE);
-	setsockopt_so_sendbuf(sock, 1048576);
-	zclient->privs->change(ZPRIVS_LOWER);
+	frr_elevate_privs(zclient->privs) {
+		setsockopt_so_sendbuf(sock, 1048576);
+	}
 
 	/* Connect to zebra. */
 	ret = connect(sock, (struct sockaddr *)&zclient_addr, zclient_addr_len);
@@ -312,9 +313,9 @@ int zclient_read_header(struct stream *s
 	STREAM_GETW(s, *cmd);
 
 	if (*version != ZSERV_VERSION || *marker != ZEBRA_HEADER_MARKER) {
-		zlog_err(
-			"%s: socket %d version mismatch, marker %d, version %d",
-			__func__, sock, *marker, *version);
+		flog_err(LIB_ERR_ZAPI_MISSMATCH,
+			  "%s: socket %d version mismatch, marker %d, version %d",
+			  __func__, sock, *marker, *version);
 		return -1;
 	}
 
@@ -675,11 +676,11 @@ int zclient_send_rnh(struct zclient *zcl
  * "xdr_encode"-like interface that allows daemon (client) to send
  * a message to zebra server for a route that needs to be
  * added/deleted to the kernel. Info about the route is specified
- * by the caller in a struct zapi_ipv4. zapi_ipv4_read() then writes
+ * by the caller in a struct zapi_route. zapi_route_encode() then writes
  * the info down the zclient socket using the stream_* functions.
  *
  * The corresponding read ("xdr_decode") function on the server
- * side is zread_ipv4_add()/zread_ipv4_delete().
+ * side is zapi_route_decode().
  *
  *  0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
@@ -706,21 +707,16 @@ int zclient_send_rnh(struct zclient *zcl
  * is set to 1 and a nexthop of type NEXTHOP_TYPE_BLACKHOLE is the sole
  * nexthop.
  *
- * The original struct zapi_ipv4, zapi_ipv4_route() and zread_ipv4_*()
- * infrastructure was built around the traditional (32-bit "gate OR
- * ifindex") nexthop data unit. A special encoding can be used to feed
- * onlink (64-bit "gate AND ifindex") nexthops into zapi_ipv4_route()
- * using the same zapi_ipv4 structure. This is done by setting zapi_ipv4
- * fields as follows:
+ * The original struct zapi_route_*() infrastructure was built around
+ * the traditional (32-bit "gate OR ifindex") nexthop data unit.
+ * A special encoding can be used to feed onlink (64-bit "gate AND ifindex")
+ * nexthops into zapi_route_encode() using the same zapi_route structure.
+ * This is done by setting zapi_route fields as follows:
  *  - .message |= ZAPI_MESSAGE_NEXTHOP | ZAPI_MESSAGE_ONLINK
  *  - .nexthop_num == .ifindex_num
  *  - .nexthop and .ifindex are filled with gate and ifindex parts of
  *    each compound nexthop, both in the same order
  *
- * zapi_ipv4_route() will produce two nexthop data units for each such
- * interleaved 64-bit nexthop. On the zserv side of the socket it will be
- * mapped to a singlle NEXTHOP_TYPE_IPV4_IFINDEX_OL RIB nexthop structure.
- *
  * If ZAPI_MESSAGE_DISTANCE is set, the distance value is written as a 1
  * byte value.
  *
@@ -733,226 +729,6 @@ int zclient_send_rnh(struct zclient *zcl
  *
  * XXX: No attention paid to alignment.
  */
-int zapi_ipv4_route(uint8_t cmd, struct zclient *zclient, struct prefix_ipv4 *p,
-		    struct zapi_ipv4 *api)
-{
-	int i;
-	int psize;
-	struct stream *s;
-
-	/* Reset stream. */
-	s = zclient->obuf;
-	stream_reset(s);
-
-	/* Some checks for labeled-unicast. The current expectation is that each
-	 * nexthop is accompanied by a label in the case of labeled-unicast.
-	 */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL)
-	    && CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		/* We expect prefixes installed with labels and the number to
-		 * match
-		 * the number of nexthops.
-		 */
-		assert(api->label_num == api->nexthop_num);
-	}
-
-	zclient_create_header(s, cmd, api->vrf_id);
-
-	/* Put type and nexthop. */
-	stream_putc(s, api->type);
-	stream_putw(s, api->instance);
-	stream_putl(s, api->flags);
-	stream_putc(s, api->message);
-	stream_putw(s, api->safi);
-
-	/* Put prefix information. */
-	psize = PSIZE(p->prefixlen);
-	stream_putc(s, p->prefixlen);
-	stream_write(s, (uint8_t *)&p->prefix, psize);
-
-	/* Nexthop, ifindex, distance and metric information. */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		stream_putc(s, api->nexthop_num + api->ifindex_num);
-
-		for (i = 0; i < api->nexthop_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IPV4);
-			stream_put_in_addr(s, api->nexthop[i]);
-			/* For labeled-unicast, each nexthop is followed by
-			 * label. */
-			if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL))
-				stream_putl(s, api->label[i]);
-		}
-		for (i = 0; i < api->ifindex_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IFINDEX);
-			stream_putl(s, api->ifindex[i]);
-		}
-	}
-
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_DISTANCE))
-		stream_putc(s, api->distance);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_METRIC))
-		stream_putl(s, api->metric);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_TAG))
-		stream_putl(s, api->tag);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_MTU))
-		stream_putl(s, api->mtu);
-
-	/* Put length at the first point of the stream. */
-	stream_putw_at(s, 0, stream_get_endp(s));
-
-	return zclient_send_message(zclient);
-}
-
-int zapi_ipv4_route_ipv6_nexthop(uint8_t cmd, struct zclient *zclient,
-				 struct prefix_ipv4 *p, struct zapi_ipv6 *api)
-{
-	int i;
-	int psize;
-	struct stream *s;
-
-	/* Reset stream. */
-	s = zclient->obuf;
-	stream_reset(s);
-
-	/* Some checks for labeled-unicast. The current expectation is that each
-	 * nexthop is accompanied by a label in the case of labeled-unicast.
-	 */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL)
-	    && CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		/* We expect prefixes installed with labels and the number to
-		 * match
-		 * the number of nexthops.
-		 */
-		assert(api->label_num == api->nexthop_num);
-	}
-
-	zclient_create_header(s, cmd, api->vrf_id);
-
-	/* Put type and nexthop. */
-	stream_putc(s, api->type);
-	stream_putw(s, api->instance);
-	stream_putl(s, api->flags);
-	stream_putc(s, api->message);
-	stream_putw(s, api->safi);
-
-	/* Put prefix information. */
-	psize = PSIZE(p->prefixlen);
-	stream_putc(s, p->prefixlen);
-	stream_write(s, (uint8_t *)&p->prefix, psize);
-
-	/* Nexthop, ifindex, distance and metric information. */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		stream_putc(s, api->nexthop_num + api->ifindex_num);
-
-		for (i = 0; i < api->nexthop_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IPV6);
-			stream_write(s, (uint8_t *)api->nexthop[i], 16);
-			/* For labeled-unicast, each nexthop is followed by
-			 * label. */
-			if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL))
-				stream_putl(s, api->label[i]);
-		}
-		for (i = 0; i < api->ifindex_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IFINDEX);
-			stream_putl(s, api->ifindex[i]);
-		}
-	}
-
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_DISTANCE))
-		stream_putc(s, api->distance);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_METRIC))
-		stream_putl(s, api->metric);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_TAG))
-		stream_putl(s, api->tag);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_MTU))
-		stream_putl(s, api->mtu);
-
-	/* Put length at the first point of the stream. */
-	stream_putw_at(s, 0, stream_get_endp(s));
-
-	return zclient_send_message(zclient);
-}
-
-int zapi_ipv6_route(uint8_t cmd, struct zclient *zclient, struct prefix_ipv6 *p,
-		    struct prefix_ipv6 *src_p, struct zapi_ipv6 *api)
-{
-	int i;
-	int psize;
-	struct stream *s;
-
-	/* either we have !SRCPFX && src_p == NULL, or SRCPFX && src_p != NULL
-	 */
-	assert(!(api->message & ZAPI_MESSAGE_SRCPFX) == !src_p);
-
-	/* Reset stream. */
-	s = zclient->obuf;
-	stream_reset(s);
-
-	/* Some checks for labeled-unicast. The current expectation is that each
-	 * nexthop is accompanied by a label in the case of labeled-unicast.
-	 */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL)
-	    && CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		/* We expect prefixes installed with labels and the number to
-		 * match
-		 * the number of nexthops.
-		 */
-		assert(api->label_num == api->nexthop_num);
-	}
-
-	zclient_create_header(s, cmd, api->vrf_id);
-
-	/* Put type and nexthop. */
-	stream_putc(s, api->type);
-	stream_putw(s, api->instance);
-	stream_putl(s, api->flags);
-	stream_putc(s, api->message);
-	stream_putw(s, api->safi);
-
-	/* Put prefix information. */
-	psize = PSIZE(p->prefixlen);
-	stream_putc(s, p->prefixlen);
-	stream_write(s, (uint8_t *)&p->prefix, psize);
-
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_SRCPFX)) {
-		psize = PSIZE(src_p->prefixlen);
-		stream_putc(s, src_p->prefixlen);
-		stream_write(s, (uint8_t *)&src_p->prefix, psize);
-	}
-
-	/* Nexthop, ifindex, distance and metric information. */
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_NEXTHOP)) {
-		stream_putc(s, api->nexthop_num + api->ifindex_num);
-
-		for (i = 0; i < api->nexthop_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IPV6);
-			stream_write(s, (uint8_t *)api->nexthop[i], 16);
-			/* For labeled-unicast, each nexthop is followed by
-			 * label. */
-			if (CHECK_FLAG(api->message, ZAPI_MESSAGE_LABEL))
-				stream_putl(s, api->label[i]);
-		}
-		for (i = 0; i < api->ifindex_num; i++) {
-			stream_putc(s, NEXTHOP_TYPE_IFINDEX);
-			stream_putl(s, api->ifindex[i]);
-		}
-	}
-
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_DISTANCE))
-		stream_putc(s, api->distance);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_METRIC))
-		stream_putl(s, api->metric);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_TAG))
-		stream_putl(s, api->tag);
-	if (CHECK_FLAG(api->message, ZAPI_MESSAGE_MTU))
-		stream_putl(s, api->mtu);
-
-	/* Put length at the first point of the stream. */
-	stream_putw_at(s, 0, stream_get_endp(s));
-
-	return zclient_send_message(zclient);
-}
-
 int zclient_route_send(uint8_t cmd, struct zclient *zclient,
 		       struct zapi_route *api)
 {
@@ -975,8 +751,6 @@ int zapi_route_encode(uint8_t cmd, struc
 	stream_putl(s, api->flags);
 	stream_putc(s, api->message);
 	stream_putc(s, api->safi);
-	if (CHECK_FLAG(api->flags, ZEBRA_FLAG_EVPN_ROUTE))
-		stream_put(s, &(api->rmac), sizeof(struct ethaddr));
 
 	/* Put prefix information. */
 	stream_putc(s, api->prefix.family);
@@ -1047,12 +821,12 @@ int zapi_route_encode(uint8_t cmd, struc
 					char buf[PREFIX2STR_BUFFER];
 					prefix2str(&api->prefix, buf,
 						   sizeof(buf));
-					zlog_err(
-						"%s: prefix %s: can't encode "
-						"%u labels (maximum is %u)",
-						__func__, buf,
-						api_nh->label_num,
-						MPLS_MAX_LABELS);
+					flog_err(LIB_ERR_ZAPI_ENCODE,
+						  "%s: prefix %s: can't encode "
+						  "%u labels (maximum is %u)",
+						  __func__, buf,
+						  api_nh->label_num,
+						  MPLS_MAX_LABELS);
 					return -1;
 				}
 
@@ -1061,6 +835,11 @@ int zapi_route_encode(uint8_t cmd, struc
 					   api_nh->label_num
 						   * sizeof(mpls_label_t));
 			}
+
+			/* Router MAC for EVPN routes. */
+			if (CHECK_FLAG(api->flags, ZEBRA_FLAG_EVPN_ROUTE))
+				stream_put(s, &(api_nh->rmac),
+					   sizeof(struct ethaddr));
 		}
 	}
 
@@ -1101,8 +880,6 @@ int zapi_route_decode(struct stream *s,
 	STREAM_GETL(s, api->flags);
 	STREAM_GETC(s, api->message);
 	STREAM_GETC(s, api->safi);
-	if (CHECK_FLAG(api->flags, ZEBRA_FLAG_EVPN_ROUTE))
-		STREAM_GET(&(api->rmac), s, sizeof(struct ethaddr));
 
 	/* Prefix. */
 	STREAM_GETC(s, api->prefix.family);
@@ -1212,6 +989,11 @@ int zapi_route_decode(struct stream *s,
 					   api_nh->label_num
 						   * sizeof(mpls_label_t));
 			}
+
+			/* Router MAC for EVPN routes. */
+			if (CHECK_FLAG(api->flags, ZEBRA_FLAG_EVPN_ROUTE))
+				stream_get(&(api_nh->rmac), s,
+					   sizeof(struct ethaddr));
 		}
 	}
 
@@ -1665,10 +1447,10 @@ static void link_params_set_value(struct
 		for (i = 0; i < bwclassnum && i < MAX_CLASS_TYPE; i++)
 			iflp->unrsv_bw[i] = stream_getf(s);
 		if (i < bwclassnum)
-			zlog_err(
-				"%s: received %d > %d (MAX_CLASS_TYPE) bw entries"
-				" - outdated library?",
-				__func__, bwclassnum, MAX_CLASS_TYPE);
+			flog_err(LIB_ERR_ZAPI_MISSMATCH,
+				  "%s: received %d > %d (MAX_CLASS_TYPE) bw entries"
+				  " - outdated library?",
+				  __func__, bwclassnum, MAX_CLASS_TYPE);
 	}
 	iflp->admin_grp = stream_getl(s);
 	iflp->rmt_as = stream_getl(s);
@@ -1697,8 +1479,9 @@ struct interface *zebra_interface_link_p
 	struct interface *ifp = if_lookup_by_index(ifindex, VRF_DEFAULT);
 
 	if (ifp == NULL) {
-		zlog_err("%s: unknown ifindex %u, shouldn't happen", __func__,
-			 ifindex);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "%s: unknown ifindex %u, shouldn't happen", __func__,
+			  ifindex);
 		return NULL;
 	}
 
@@ -2033,7 +1816,8 @@ static int zclient_read_sync_response(st
 				   size);
 	}
 	if (ret != 0) {
-		zlog_err("%s: Invalid Sync Message Reply", __func__);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			 "%s: Invalid Sync Message Reply", __func__);
 		return -1;
 	}
 
@@ -2046,29 +1830,24 @@ static int zclient_read_sync_response(st
  * immediately reads the answer from the input buffer.
  *
  * @param zclient Zclient used to connect to label manager (zebra)
- * @param async Synchronous (0) or asynchronous (1) operation
  * @result Result of response
  */
-int lm_label_manager_connect(struct zclient *zclient, int async)
+int lm_label_manager_connect(struct zclient *zclient)
 {
 	int ret;
 	struct stream *s;
 	uint8_t result;
-	uint16_t cmd = async ? ZEBRA_LABEL_MANAGER_CONNECT_ASYNC :
-			       ZEBRA_LABEL_MANAGER_CONNECT;
 
 	if (zclient_debug)
 		zlog_debug("Connecting to Label Manager (LM)");
 
-	if (zclient->sock < 0) {
-		zlog_debug("%s: invalid zclient socket", __func__);
+	if (zclient->sock < 0)
 		return -1;
-	}
 
 	/* send request */
 	s = zclient->obuf;
 	stream_reset(s);
-	zclient_create_header(s, cmd, VRF_DEFAULT);
+	zclient_create_header(s, ZEBRA_LABEL_MANAGER_CONNECT, VRF_DEFAULT);
 
 	/* proto */
 	stream_putc(s, zclient->redist_default);
@@ -2080,13 +1859,13 @@ int lm_label_manager_connect(struct zcli
 
 	ret = writen(zclient->sock, s->data, stream_get_endp(s));
 	if (ret < 0) {
-		zlog_err("Can't write to zclient sock");
+		flog_err(LIB_ERR_ZAPI_SOCKET, "Can't write to zclient sock");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
 	}
 	if (ret == 0) {
-		zlog_err("Zclient sock closed");
+		flog_err(LIB_ERR_ZAPI_SOCKET, "Zclient sock closed");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
@@ -2094,11 +1873,8 @@ int lm_label_manager_connect(struct zcli
 	if (zclient_debug)
 		zlog_debug("LM connect request sent (%d bytes)", ret);
 
-	if (async)
-		return 0;
-
 	/* read response */
-	if (zclient_read_sync_response(zclient, cmd)
+	if (zclient_read_sync_response(zclient, ZEBRA_LABEL_MANAGER_CONNECT)
 	    != 0)
 		return -1;
 
@@ -2110,13 +1886,13 @@ int lm_label_manager_connect(struct zcli
 
 	/* sanity */
 	if (proto != zclient->redist_default)
-		zlog_err(
-			"Wrong proto (%u) in LM connect response. Should be %u",
-			proto, zclient->redist_default);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Wrong proto (%u) in LM connect response. Should be %u",
+			  proto, zclient->redist_default);
 	if (instance != zclient->instance)
-		zlog_err(
-			"Wrong instId (%u) in LM connect response. Should be %u",
-			instance, zclient->instance);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Wrong instId (%u) in LM connect response. Should be %u",
+			  instance, zclient->instance);
 
 	/* result code */
 	result = stream_getc(s);
@@ -2205,13 +1981,15 @@ int lm_get_label_chunk(struct zclient *z
 
 	ret = writen(zclient->sock, s->data, stream_get_endp(s));
 	if (ret < 0) {
-		zlog_err("Can't write to zclient sock");
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "Can't write to zclient sock");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
 	}
 	if (ret == 0) {
-		zlog_err("Zclient sock closed");
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "Zclient sock closed");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
@@ -2232,11 +2010,13 @@ int lm_get_label_chunk(struct zclient *z
 
 	/* sanities */
 	if (proto != zclient->redist_default)
-		zlog_err("Wrong proto (%u) in get chunk response. Should be %u",
-			 proto, zclient->redist_default);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Wrong proto (%u) in get chunk response. Should be %u",
+			  proto, zclient->redist_default);
 	if (instance != zclient->instance)
-		zlog_err("Wrong instId (%u) in get chunk response Should be %u",
-			 instance, zclient->instance);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Wrong instId (%u) in get chunk response Should be %u",
+			  instance, zclient->instance);
 
 	/* keep */
 	response_keep = stream_getc(s);
@@ -2246,14 +2026,15 @@ int lm_get_label_chunk(struct zclient *z
 
 	/* not owning this response */
 	if (keep != response_keep) {
-		zlog_err(
-			"Invalid Label chunk: %u - %u, keeps mismatch %u != %u",
-			*start, *end, keep, response_keep);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Invalid Label chunk: %u - %u, keeps mismatch %u != %u",
+			  *start, *end, keep, response_keep);
 	}
 	/* sanity */
 	if (*start > *end || *start < MPLS_LABEL_UNRESERVED_MIN
 	    || *end > MPLS_LABEL_UNRESERVED_MAX) {
-		zlog_err("Invalid Label chunk: %u - %u", *start, *end);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "Invalid Label chunk: %u - %u", *start, *end);
 		return -1;
 	}
 
@@ -2303,13 +2084,14 @@ int lm_release_label_chunk(struct zclien
 
 	ret = writen(zclient->sock, s->data, stream_get_endp(s));
 	if (ret < 0) {
-		zlog_err("Can't write to zclient sock");
+		flog_err(LIB_ERR_ZAPI_SOCKET, "Can't write to zclient sock");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
 	}
 	if (ret == 0) {
-		zlog_err("Zclient sock connection closed");
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "Zclient sock connection closed");
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
@@ -2412,13 +2194,15 @@ int tm_get_table_chunk(struct zclient *z
 
 	ret = writen(zclient->sock, s->data, stream_get_endp(s));
 	if (ret < 0) {
-		zlog_err("%s: can't write to zclient->sock", __func__);
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "%s: can't write to zclient->sock", __func__);
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
 	}
 	if (ret == 0) {
-		zlog_err("%s: zclient->sock connection closed", __func__);
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "%s: zclient->sock connection closed", __func__);
 		close(zclient->sock);
 		zclient->sock = -1;
 		return -1;
@@ -2504,7 +2288,8 @@ int zebra_send_pw(struct zclient *zclien
 		stream_write(s, (uint8_t *)&pw->nexthop.ipv6, 16);
 		break;
 	default:
-		zlog_err("%s: unknown af", __func__);
+		flog_err(LIB_ERR_ZAPI_ENCODE,
+			  "%s: unknown af", __func__);
 		return -1;
 	}
 
@@ -2606,15 +2391,16 @@ static int zclient_read(struct thread *t
 	command = stream_getw(zclient->ibuf);
 
 	if (marker != ZEBRA_HEADER_MARKER || version != ZSERV_VERSION) {
-		zlog_err(
-			"%s: socket %d version mismatch, marker %d, version %d",
-			__func__, zclient->sock, marker, version);
+		flog_err(LIB_ERR_ZAPI_MISSMATCH,
+			  "%s: socket %d version mismatch, marker %d, version %d",
+			  __func__, zclient->sock, marker, version);
 		return zclient_failed(zclient);
 	}
 
 	if (length < ZEBRA_HEADER_SIZE) {
-		zlog_err("%s: socket %d message length %u is less than %d ",
-			 __func__, zclient->sock, length, ZEBRA_HEADER_SIZE);
+		flog_err(LIB_ERR_ZAPI_MISSMATCH,
+			  "%s: socket %d message length %u is less than %d ",
+			  __func__, zclient->sock, length, ZEBRA_HEADER_SIZE);
 		return zclient_failed(zclient);
 	}
 
@@ -2762,6 +2548,16 @@ static int zclient_read(struct thread *t
 		if (zclient->fec_update)
 			(*zclient->fec_update)(command, zclient, length);
 		break;
+	case ZEBRA_LOCAL_ES_ADD:
+		if (zclient->local_es_add)
+			(*zclient->local_es_add)(command, zclient, length,
+						 vrf_id);
+		break;
+	case ZEBRA_LOCAL_ES_DEL:
+		if (zclient->local_es_del)
+			(*zclient->local_es_del)(command, zclient, length,
+						 vrf_id);
+		break;
 	case ZEBRA_VNI_ADD:
 		if (zclient->local_vni_add)
 			(*zclient->local_vni_add)(command, zclient, length,
diff -urpN frr-frr-5.0.1/lib/zclient.h frr-frr-6.0/lib/zclient.h
--- frr-frr-5.0.1/lib/zclient.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/zclient.h	2018-10-08 14:32:57.000000000 +0200
@@ -73,10 +73,6 @@ typedef enum {
 	ZEBRA_ROUTE_ADD,
 	ZEBRA_ROUTE_DELETE,
 	ZEBRA_ROUTE_NOTIFY_OWNER,
-	ZEBRA_IPV4_ROUTE_ADD,
-	ZEBRA_IPV4_ROUTE_DELETE,
-	ZEBRA_IPV6_ROUTE_ADD,
-	ZEBRA_IPV6_ROUTE_DELETE,
 	ZEBRA_REDISTRIBUTE_ADD,
 	ZEBRA_REDISTRIBUTE_DELETE,
 	ZEBRA_REDISTRIBUTE_DEFAULT_ADD,
@@ -108,6 +104,7 @@ typedef enum {
 	ZEBRA_VRF_LABEL,
 	ZEBRA_INTERFACE_VRF_UPDATE,
 	ZEBRA_BFD_CLIENT_REGISTER,
+	ZEBRA_BFD_CLIENT_DEREGISTER,
 	ZEBRA_INTERFACE_ENABLE_RADV,
 	ZEBRA_INTERFACE_DISABLE_RADV,
 	ZEBRA_IPV4_NEXTHOP_LOOKUP_MRIB,
@@ -116,7 +113,6 @@ typedef enum {
 	ZEBRA_MPLS_LABELS_DELETE,
 	ZEBRA_IPMR_ROUTE_STATS,
 	ZEBRA_LABEL_MANAGER_CONNECT,
-	ZEBRA_LABEL_MANAGER_CONNECT_ASYNC,
 	ZEBRA_GET_LABEL_CHUNK,
 	ZEBRA_RELEASE_LABEL_CHUNK,
 	ZEBRA_FEC_REGISTER,
@@ -125,6 +121,8 @@ typedef enum {
 	ZEBRA_ADVERTISE_DEFAULT_GW,
 	ZEBRA_ADVERTISE_SUBNET,
 	ZEBRA_ADVERTISE_ALL_VNI,
+	ZEBRA_LOCAL_ES_ADD,
+	ZEBRA_LOCAL_ES_DEL,
 	ZEBRA_VNI_ADD,
 	ZEBRA_VNI_DEL,
 	ZEBRA_L3VNI_ADD,
@@ -238,6 +236,10 @@ struct zclient {
 	int (*redistribute_route_del)(int, struct zclient *, uint16_t,
 				      vrf_id_t);
 	int (*fec_update)(int, struct zclient *, uint16_t);
+	int (*local_es_add)(int command, struct zclient *zclient,
+			    uint16_t length, vrf_id_t vrf_id);
+	int (*local_es_del)(int command, struct zclient *zclient,
+			    uint16_t length, vrf_id_t vrf_id);
 	int (*local_vni_add)(int, struct zclient *, uint16_t, vrf_id_t);
 	int (*local_vni_del)(int, struct zclient *, uint16_t, vrf_id_t);
 	int (*local_l3vni_add)(int, struct zclient *, uint16_t, vrf_id_t);
@@ -280,7 +282,7 @@ struct zclient {
  */
 #define ZAPI_MESSAGE_TABLEID  0x80
 
-#define ZSERV_VERSION 5
+#define ZSERV_VERSION 6
 /* Zserv protocol message header */
 struct zmsghdr {
 	uint16_t length;
@@ -303,6 +305,8 @@ struct zapi_nexthop {
 	/* MPLS labels for BGP-LU or Segment Routing */
 	uint8_t label_num;
 	mpls_label_t labels[MPLS_MAX_LABELS];
+
+	struct ethaddr rmac;
 };
 
 /*
@@ -343,39 +347,6 @@ struct zapi_route {
 	vrf_id_t vrf_id;
 
 	uint32_t tableid;
-
-	struct ethaddr rmac;
-};
-
-/* Zebra IPv4 route message API. */
-struct zapi_ipv4 {
-	uint8_t type;
-	unsigned short instance;
-
-	uint32_t flags;
-
-	uint8_t message;
-
-	safi_t safi;
-
-	uint8_t nexthop_num;
-	struct in_addr **nexthop;
-
-	uint8_t ifindex_num;
-	ifindex_t *ifindex;
-
-	uint8_t label_num;
-	unsigned int *label;
-
-	uint8_t distance;
-
-	uint32_t metric;
-
-	route_tag_t tag;
-
-	uint32_t mtu;
-
-	vrf_id_t vrf_id;
 };
 
 struct zapi_pw {
@@ -443,6 +414,8 @@ enum zapi_iptable_notify_owner {
 /* Zebra MAC types */
 #define ZEBRA_MACIP_TYPE_STICKY                0x01 /* Sticky MAC*/
 #define ZEBRA_MACIP_TYPE_GW                    0x02 /* gateway (SVI) mac*/
+#define ZEBRA_MACIP_TYPE_ROUTER_FLAG           0x04 /* Router Flag - proxy NA */
+#define ZEBRA_MACIP_TYPE_OVERRIDE_FLAG         0x08 /* Override Flag */
 
 struct zclient_options {
 	bool receive_notify;
@@ -452,7 +425,7 @@ struct zclient_options {
 extern struct zclient *zclient_new(struct thread_master *);
 
 /* clang-format off */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20181101
+#if CONFDATE > 20181101
 CPP_NOTICE("zclient_new_notify can take over or zclient_new now");
 #endif
 /* clang-format on */
@@ -592,15 +565,6 @@ extern struct interface *zebra_interface
 extern void zebra_interface_if_set_value(struct stream *, struct interface *);
 extern void zebra_router_id_update_read(struct stream *s, struct prefix *rid);
 
-/* clang-format off */
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180823
-CPP_NOTICE("zapi_ipv4_route, zapi_ipv6_route, zapi_ipv4_route_ipv6_nexthop as well as the zapi_ipv4 and zapi_ipv6 data structures should be removed now");
-#endif
-/* clang-format on */
-
-extern int zapi_ipv4_route(uint8_t, struct zclient *, struct prefix_ipv4 *,
-			   struct zapi_ipv4 *) __attribute__((deprecated));
-
 extern struct interface *zebra_interface_link_params_read(struct stream *);
 extern size_t zebra_interface_link_params_write(struct stream *,
 						struct interface *);
@@ -609,7 +573,7 @@ extern int zclient_send_get_label_chunk(
 	uint8_t		keep,
 	uint32_t	chunk_size);
 
-extern int lm_label_manager_connect(struct zclient *zclient, int async);
+extern int lm_label_manager_connect(struct zclient *zclient);
 extern int lm_get_label_chunk(struct zclient *zclient, uint8_t keep,
 			      uint32_t chunk_size, uint32_t *start,
 			      uint32_t *end);
@@ -627,45 +591,6 @@ extern void zebra_read_pw_status_update(
 					zebra_size_t length, vrf_id_t vrf_id,
 					struct zapi_pw_status *pw);
 
-/* IPv6 prefix add and delete function prototype. */
-
-struct zapi_ipv6 {
-	uint8_t type;
-	unsigned short instance;
-
-	uint32_t flags;
-
-	uint8_t message;
-
-	safi_t safi;
-
-	uint8_t nexthop_num;
-	struct in6_addr **nexthop;
-
-	uint8_t ifindex_num;
-	ifindex_t *ifindex;
-
-	uint8_t label_num;
-	unsigned int *label;
-
-	uint8_t distance;
-
-	uint32_t metric;
-
-	route_tag_t tag;
-
-	uint32_t mtu;
-
-	vrf_id_t vrf_id;
-};
-
-extern int zapi_ipv6_route(uint8_t cmd, struct zclient *zclient,
-			   struct prefix_ipv6 *p, struct prefix_ipv6 *src_p,
-			   struct zapi_ipv6 *api) __attribute__((deprecated));
-extern int zapi_ipv4_route_ipv6_nexthop(uint8_t, struct zclient *,
-					struct prefix_ipv4 *,
-					struct zapi_ipv6 *)
-	__attribute__((deprecated));
 extern int zclient_route_send(uint8_t, struct zclient *, struct zapi_route *);
 extern int zclient_send_rnh(struct zclient *zclient, int command,
 			    struct prefix *p, bool exact_match,
diff -urpN frr-frr-5.0.1/lib/zebra.h frr-frr-6.0/lib/zebra.h
--- frr-frr-5.0.1/lib/zebra.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/lib/zebra.h	2018-10-08 14:32:57.000000000 +0200
@@ -242,23 +242,6 @@ size_t strlcpy(char *__restrict dest,
 	       const char *__restrict src, size_t destsize);
 #endif
 
-#ifdef HAVE_BROKEN_CMSG_FIRSTHDR
-/* This bug is present in Solaris 8 and pre-patch Solaris 9 <sys/socket.h>;
-   please refer to http://bugzilla.quagga.net/show_bug.cgi?id=142 */
-
-/* Check that msg_controllen is large enough. */
-#define ZCMSG_FIRSTHDR(mhdr)                                                   \
-	(((size_t)((mhdr)->msg_controllen) >= sizeof(struct cmsghdr))          \
-		 ? CMSG_FIRSTHDR(mhdr)                                         \
-		 : (struct cmsghdr *)NULL)
-
-#warning "CMSG_FIRSTHDR is broken on this platform, using a workaround"
-
-#else  /* HAVE_BROKEN_CMSG_FIRSTHDR */
-#define ZCMSG_FIRSTHDR(M) CMSG_FIRSTHDR(M)
-#endif /* HAVE_BROKEN_CMSG_FIRSTHDR */
-
-
 /* GCC have printf type attribute check.  */
 #ifdef __GNUC__
 #define PRINTF_ATTRIBUTE(a,b) __attribute__ ((__format__ (__printf__, a, b)))
@@ -365,6 +348,22 @@ struct in_pktinfo {
 		_a < _b ? _a : _b;                                             \
 	})
 
+#ifndef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+#endif
+
+#ifndef container_of
+#define container_of(ptr, type, member)                                        \
+	({                                                                     \
+		const typeof(((type *)0)->member) *__mptr = (ptr);             \
+		(type *)((char *)__mptr - offsetof(type, member));             \
+	})
+#endif
+
 #define ZEBRA_NUM_OF(x) (sizeof (x) / sizeof (x[0]))
 
 /* For old definition. */
@@ -381,6 +380,12 @@ struct in_pktinfo {
  */
 #define ZEBRA_HEADER_MARKER              254
 
+/*
+ * The compiler.h header is used for anyone using the CPP_NOTICE
+ * since this is universally needed, let's add it to zebra.h
+ */
+#include "compiler.h"
+
 /* Zebra route's types are defined in route_types.h */
 #include "route_types.h"
 
@@ -414,6 +419,7 @@ extern const char *zserv_command_string(
 #define ZEBRA_FLAG_SCOPE_LINK         0x100
 #define ZEBRA_FLAG_FIB_OVERRIDE       0x200
 #define ZEBRA_FLAG_EVPN_ROUTE         0x400
+#define ZEBRA_FLAG_RR_USE_DISTANCE    0x800
 /* ZEBRA_FLAG_BLACKHOLE was 0x04 */
 /* ZEBRA_FLAG_REJECT was 0x80 */
 
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_cache.c frr-frr-6.0/nhrpd/nhrp_cache.c
--- frr-frr-5.0.1/nhrpd/nhrp_cache.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_cache.c	2018-10-08 14:32:57.000000000 +0200
@@ -48,17 +48,16 @@ static void *nhrp_cache_alloc(void *data
 	struct nhrp_cache *p, *key = data;
 
 	p = XMALLOC(MTYPE_NHRP_CACHE, sizeof(struct nhrp_cache));
-	if (p) {
-		*p = (struct nhrp_cache){
-			.cur.type = NHRP_CACHE_INVALID,
-			.new.type = NHRP_CACHE_INVALID,
-			.remote_addr = key->remote_addr,
-			.ifp = key->ifp,
-			.notifier_list =
-				NOTIFIER_LIST_INITIALIZER(&p->notifier_list),
-		};
-		nhrp_cache_counts[p->cur.type]++;
-	}
+
+	*p = (struct nhrp_cache){
+		.cur.type = NHRP_CACHE_INVALID,
+		.new.type = NHRP_CACHE_INVALID,
+		.remote_addr = key->remote_addr,
+		.ifp = key->ifp,
+		.notifier_list =
+		NOTIFIER_LIST_INITIALIZER(&p->notifier_list),
+	};
+	nhrp_cache_counts[p->cur.type]++;
 
 	return p;
 }
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_errors.c frr-frr-6.0/nhrpd/nhrp_errors.c
--- frr-frr-5.0.1/nhrpd/nhrp_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/nhrpd/nhrp_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * NHRP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "nhrp_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_nhrp_err[] = {
+	{
+		.code = NHRP_ERR_SWAN,
+		.title = "NHRP Strong Swan Error",
+		.description = "NHRP has detected a error with the Strongswan code",
+		.suggestion = "Ensure that StrongSwan is configured correctly.  Restart StrongSwan and FRR"
+	},
+	{
+		.code = NHRP_ERR_RESOLVER,
+		.title = "NHRP DNS Resolution",
+		.description = "NHRP has detected an error in an attempt to resolve a hostname",
+		.suggestion = "Ensure that DNS is working properly and the hostname is configured in dns.  If you are still seeing this error, open an issue"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void nhrp_error_init(void)
+{
+	log_ref_add(ferr_nhrp_err);
+}
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_errors.h frr-frr-6.0/nhrpd/nhrp_errors.h
--- frr-frr-5.0.1/nhrpd/nhrp_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/nhrpd/nhrp_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * NHRP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __NHRP_ERRORS_H__
+#define __NHRP_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum nhrp_log_refs {
+	NHRP_ERR_SWAN = NHRP_FERR_START,
+	NHRP_ERR_RESOLVER,
+};
+
+extern void nhrp_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_event.c frr-frr-6.0/nhrpd/nhrp_event.c
--- frr-frr-5.0.1/nhrpd/nhrp_event.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_event.c	2018-10-08 14:32:57.000000000 +0200
@@ -59,7 +59,7 @@ static void evmgr_recv_message(struct ev
 		buf[len] = 0;
 
 		debugf(NHRP_DEBUG_EVENT, "evmgr: msg: %s", buf);
-		if (sscanf(buf, "eventid=%d", &eventid) != 1)
+		if (sscanf(buf, "eventid=%" SCNu32, &eventid) != 1)
 			continue;
 		if (sscanf(buf, "result=%63s", result) != 1)
 			continue;
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_interface.c frr-frr-6.0/nhrpd/nhrp_interface.c
--- frr-frr-5.0.1/nhrpd/nhrp_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,8 +25,6 @@ static int nhrp_if_new_hook(struct inter
 	afi_t afi;
 
 	nifp = XCALLOC(MTYPE_NHRP_IF, sizeof(struct nhrp_interface));
-	if (!nifp)
-		return 0;
 
 	ifp->info = nifp;
 	nifp->ifp = ifp;
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_main.c frr-frr-6.0/nhrpd/nhrp_main.c
--- frr-frr-5.0.1/nhrpd/nhrp_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -23,6 +23,7 @@
 
 #include "nhrpd.h"
 #include "netlink.h"
+#include "nhrp_errors.h"
 
 DEFINE_MGROUP(NHRPD, "NHRP")
 
@@ -128,6 +129,7 @@ int main(int argc, char **argv)
 
 	/* Library inits. */
 	master = frr_init();
+	nhrp_error_init();
 	vrf_init(NULL, NULL, NULL, NULL);
 	nhrp_interface_init();
 	resolver_init();
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_nhs.c frr-frr-6.0/nhrpd/nhrp_nhs.c
--- frr-frr-5.0.1/nhrpd/nhrp_nhs.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_nhs.c	2018-10-08 14:32:57.000000000 +0200
@@ -324,8 +324,6 @@ int nhrp_nhs_add(struct interface *ifp,
 	}
 
 	nhs = XMALLOC(MTYPE_NHRP_NHS, sizeof(struct nhrp_nhs));
-	if (!nhs)
-		return NHRP_ERR_NO_MEMORY;
 
 	*nhs = (struct nhrp_nhs){
 		.afi = afi,
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_packet.c frr-frr-6.0/nhrpd/nhrp_packet.c
--- frr-frr-5.0.1/nhrpd/nhrp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -164,7 +164,7 @@ struct nhrp_cie_header *nhrp_cie_pull(st
 	if (!cie)
 		return NULL;
 
-	if (cie->nbma_address_len + cie->nbma_subaddress_len) {
+	if (cie->nbma_address_len + cie->nbma_subaddress_len > 0) {
 		sockunion_set(nbma, afi2family(htons(hdr->afnum)),
 			      zbuf_pulln(zb,
 					 cie->nbma_address_len
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_peer.c frr-frr-6.0/nhrpd/nhrp_peer.c
--- frr-frr-5.0.1/nhrpd/nhrp_peer.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_peer.c	2018-10-08 14:32:57.000000000 +0200
@@ -165,18 +165,18 @@ static void *nhrp_peer_create(void *data
 	struct nhrp_peer *p, *key = data;
 
 	p = XMALLOC(MTYPE_NHRP_PEER, sizeof(*p));
-	if (p) {
-		*p = (struct nhrp_peer){
-			.ref = 0,
-			.ifp = key->ifp,
-			.vc = key->vc,
-			.notifier_list =
-				NOTIFIER_LIST_INITIALIZER(&p->notifier_list),
-		};
-		nhrp_vc_notify_add(p->vc, &p->vc_notifier, nhrp_peer_vc_notify);
-		nhrp_interface_notify_add(p->ifp, &p->ifp_notifier,
-					  nhrp_peer_ifp_notify);
-	}
+
+	*p = (struct nhrp_peer){
+		.ref = 0,
+		.ifp = key->ifp,
+		.vc = key->vc,
+		.notifier_list =
+		NOTIFIER_LIST_INITIALIZER(&p->notifier_list),
+	};
+	nhrp_vc_notify_add(p->vc, &p->vc_notifier, nhrp_peer_vc_notify);
+	nhrp_interface_notify_add(p->ifp, &p->ifp_notifier,
+				  nhrp_peer_ifp_notify);
+
 	return p;
 }
 
diff -urpN frr-frr-5.0.1/nhrpd/nhrp_vc.c frr-frr-6.0/nhrpd/nhrp_vc.c
--- frr-frr-5.0.1/nhrpd/nhrp_vc.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/nhrp_vc.c	2018-10-08 14:32:57.000000000 +0200
@@ -48,14 +48,13 @@ static void *nhrp_vc_alloc(void *data)
 	struct nhrp_vc *vc, *key = data;
 
 	vc = XMALLOC(MTYPE_NHRP_VC, sizeof(struct nhrp_vc));
-	if (vc) {
-		*vc = (struct nhrp_vc){
-			.local.nbma = key->local.nbma,
-			.remote.nbma = key->remote.nbma,
-			.notifier_list =
-				NOTIFIER_LIST_INITIALIZER(&vc->notifier_list),
-		};
-	}
+
+	*vc = (struct nhrp_vc){
+		.local.nbma = key->local.nbma,
+		.remote.nbma = key->remote.nbma,
+		.notifier_list =
+		NOTIFIER_LIST_INITIALIZER(&vc->notifier_list),
+	};
 
 	return vc;
 }
@@ -118,8 +117,6 @@ int nhrp_vc_ipsec_updown(uint32_t child_
 			return 0;
 
 		sa = XMALLOC(MTYPE_NHRP_VC, sizeof(struct child_sa));
-		if (!sa)
-			return 0;
 
 		*sa = (struct child_sa){
 			.id = child_id,
diff -urpN frr-frr-5.0.1/nhrpd/resolver.c frr-frr-6.0/nhrpd/resolver.c
--- frr-frr-5.0.1/nhrpd/resolver.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/resolver.c	2018-10-08 14:32:57.000000000 +0200
@@ -12,7 +12,10 @@
 
 #include "vector.h"
 #include "thread.h"
+#include "lib_errors.h"
+
 #include "nhrpd.h"
+#include "nhrp_errors.h"
 
 struct resolver_state {
 	ares_channel channel;
@@ -164,7 +167,7 @@ static void ares_address_cb(void *arg, i
 		return;
 	}
 
-	for (i = 0; he->h_addr_list[i] != NULL && i < ZEBRA_NUM_OF(addr); i++) {
+	for (i = 0; i < ZEBRA_NUM_OF(addr) && he->h_addr_list[i] != NULL; i++) {
 		memset(&addr[i], 0, sizeof(addr[i]));
 		addr[i].sa.sa_family = he->h_addrtype;
 		switch (he->h_addrtype) {
@@ -191,9 +194,9 @@ void resolver_resolve(struct resolver_qu
 				       union sockunion *))
 {
 	if (query->callback != NULL) {
-		zlog_err(
-			"Trying to resolve '%s', but previous query was not finished yet",
-			hostname);
+		flog_err(NHRP_ERR_RESOLVER,
+			  "Trying to resolve '%s', but previous query was not finished yet",
+			  hostname);
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/nhrpd/subdir.am frr-frr-6.0/nhrpd/subdir.am
--- frr-frr-5.0.1/nhrpd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -13,6 +13,7 @@ nhrpd_nhrpd_SOURCES = \
 	nhrpd/netlink_arp.c \
 	nhrpd/netlink_gre.c \
 	nhrpd/nhrp_cache.c \
+	nhrpd/nhrp_errors.c \
 	nhrpd/nhrp_event.c \
 	nhrpd/nhrp_interface.c \
 	nhrpd/nhrp_main.c \
@@ -34,6 +35,7 @@ noinst_HEADERS += \
 	nhrpd/debug.h \
 	nhrpd/list.h \
 	nhrpd/netlink.h \
+	nhrpd/nhrp_errors.h \
 	nhrpd/nhrp_protocol.h \
 	nhrpd/nhrpd.h \
 	nhrpd/os.h \
diff -urpN frr-frr-5.0.1/nhrpd/vici.c frr-frr-6.0/nhrpd/vici.c
--- frr-frr-5.0.1/nhrpd/vici.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/vici.c	2018-10-08 14:32:57.000000000 +0200
@@ -14,9 +14,11 @@
 #include "thread.h"
 #include "zbuf.h"
 #include "log.h"
-#include "nhrpd.h"
+#include "lib_errors.h"
 
+#include "nhrpd.h"
 #include "vici.h"
+#include "nhrp_errors.h"
 
 #define ERRNO_IO_RETRY(EN) (((EN) == EAGAIN) || ((EN) == EWOULDBLOCK) || ((EN) == EINTR))
 
@@ -212,9 +214,9 @@ static void parse_sa_message(struct vici
 					if (str2sockunion(buf,
 							  &sactx->local.host)
 					    < 0)
-						zlog_err(
-							"VICI: bad strongSwan local-host: %s",
-							buf);
+						flog_err(NHRP_ERR_SWAN,
+							  "VICI: bad strongSwan local-host: %s",
+							  buf);
 			} else if (blob_equal(key, "local-id")
 				   && ctx->nsections == 1) {
 				sactx->local.id = *val;
@@ -230,9 +232,9 @@ static void parse_sa_message(struct vici
 					if (str2sockunion(buf,
 							  &sactx->remote.host)
 					    < 0)
-						zlog_err(
-							"VICI: bad strongSwan remote-host: %s",
-							buf);
+						flog_err(NHRP_ERR_SWAN,
+							  "VICI: bad strongSwan remote-host: %s",
+							  buf);
 			} else if (blob_equal(key, "remote-id")
 				   && ctx->nsections == 1) {
 				sactx->remote.id = *val;
@@ -275,7 +277,7 @@ static void parse_cmd_response(struct vi
 	case VICI_KEY_VALUE:
 		if (blob_equal(key, "errmsg")
 		    && blob2buf(val, buf, sizeof(buf)))
-			zlog_err("VICI: strongSwan: %s", buf);
+			flog_err(NHRP_ERR_SWAN, "VICI: strongSwan: %s", buf);
 		break;
 	default:
 		break;
@@ -287,6 +289,7 @@ static void vici_recv_sa(struct vici_con
 	char buf[32];
 	struct handle_sa_ctx ctx = {
 		.event = event,
+		.msgctx.nsections = 0
 	};
 
 	vici_parse_message(vici, msg, parse_sa_message, &ctx.msgctx);
@@ -305,7 +308,7 @@ static void vici_recv_message(struct vic
 	uint32_t msglen;
 	uint8_t msgtype;
 	struct blob name;
-	struct vici_message_ctx ctx;
+	struct vici_message_ctx ctx = { .nsections = 0 };
 
 	msglen = zbuf_get_be32(msg);
 	msgtype = zbuf_get8(msg);
@@ -333,7 +336,7 @@ static void vici_recv_message(struct vic
 		break;
 	case VICI_EVENT_UNKNOWN:
 	case VICI_CMD_UNKNOWN:
-		zlog_err(
+		flog_err(NHRP_ERR_SWAN,
 			"VICI: StrongSwan does not support mandatory events (unpatched?)");
 		break;
 	case VICI_EVENT_CONFIRM:
diff -urpN frr-frr-5.0.1/nhrpd/zbuf.c frr-frr-6.0/nhrpd/zbuf.c
--- frr-frr-5.0.1/nhrpd/zbuf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/nhrpd/zbuf.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,8 +25,6 @@ struct zbuf *zbuf_alloc(size_t size)
 	struct zbuf *zb;
 
 	zb = XMALLOC(MTYPE_ZBUF_DATA, sizeof(*zb) + size);
-	if (!zb)
-		return NULL;
 
 	zbuf_init(zb, zb + 1, size, 0);
 	zb->allocated = 1;
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_abr.c frr-frr-6.0/ospf6d/ospf6_abr.c
--- frr-frr-5.0.1/ospf6d/ospf6_abr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_abr.c	2018-10-08 14:32:57.000000000 +0200
@@ -161,9 +161,10 @@ int ospf6_abr_originate_summary_to_area(
 	    && route->type != OSPF6_DEST_TYPE_RANGE
 	    && ((route->type != OSPF6_DEST_TYPE_ROUTER)
 		|| !CHECK_FLAG(route->path.router_bits, OSPF6_ROUTER_BIT_E))) {
-		if (is_debug)
-			zlog_debug(
-				"Route type is none of network, range nor ASBR, ignore");
+#if 0
+		zlog_debug(
+			"Route type is none of network, range nor ASBR, ignore");
+#endif
 		return 0;
 	}
 
@@ -177,16 +178,17 @@ int ospf6_abr_originate_summary_to_area(
 
 	/* do not generate if the path's area is the same as target area */
 	if (route->path.area_id == area->area_id) {
-		if (is_debug)
-			zlog_debug("The route is in the area itself, ignore");
+#if 0
+		zlog_debug("The route is in the area itself, ignore");
+#endif
 		return 0;
 	}
 
 	/* do not generate if the nexthops belongs to the target area */
 	if (ospf6_abr_nexthops_belong_to_area(route, area)) {
-		if (is_debug)
-			zlog_debug(
-				"The route's nexthop is in the same area, ignore");
+#if 0
+		zlog_debug("The route's nexthop is in the same area, ignore");
+#endif
 		return 0;
 	}
 
@@ -216,11 +218,31 @@ int ospf6_abr_originate_summary_to_area(
 		summary_table = area->summary_router;
 	} else {
 		if (IS_OSPF6_DEBUG_ABR
-		    || IS_OSPF6_DEBUG_ORIGINATE(INTER_PREFIX)) {
+		    || IS_OSPF6_DEBUG_ORIGINATE(INTER_PREFIX))
 			is_debug++;
+
+		if (route->type == OSPF6_DEST_TYPE_NETWORK &&
+		    route->path.origin.type ==
+		    htons(OSPF6_LSTYPE_INTER_PREFIX)) {
+			if (!CHECK_FLAG(route->flag, OSPF6_ROUTE_BEST)) {
+				if (is_debug) {
+					inet_ntop(AF_INET,
+						  &(ADV_ROUTER_IN_PREFIX(
+							&route->prefix)), buf,
+						  sizeof(buf));
+					zlog_debug(
+						"%s: route %s with cost %u is not best, ignore."
+						, __PRETTY_FUNCTION__, buf,
+						route->path.cost);
+				}
+				return 0;
+			}
+		}
+
+		if (is_debug) {
 			prefix2str(&route->prefix, buf, sizeof(buf));
-			zlog_debug("Originating summary in area %s for %s",
-				   area->name, buf);
+			zlog_debug("Originating summary in area %s for %s cost %u",
+				   area->name, buf, route->path.cost);
 		}
 		summary_table = area->summary_prefix;
 	}
@@ -621,6 +643,11 @@ void ospf6_abr_originate_summary(struct
 
 	if (route->type == OSPF6_DEST_TYPE_NETWORK) {
 		oa = ospf6_area_lookup(route->path.area_id, ospf6);
+		if (!oa) {
+			zlog_err("OSPFv6 area lookup failed");
+			return;
+		}
+
 		range = ospf6_route_lookup_bestmatch(&route->prefix,
 						     oa->range_table);
 		if (range) {
@@ -679,12 +706,142 @@ void ospf6_abr_defaults_to_stub(struct o
 	ospf6_route_delete(def);
 }
 
+void ospf6_abr_old_path_update(struct ospf6_route *old_route,
+			       struct ospf6_route *route,
+			       struct ospf6_route_table *table)
+{
+	struct ospf6_path *o_path = NULL;
+	struct listnode *anode, *anext;
+	struct listnode *nnode, *rnode, *rnext;
+	struct ospf6_nexthop *nh, *rnh;
+
+	for (ALL_LIST_ELEMENTS(old_route->paths, anode, anext, o_path)) {
+		if (o_path->area_id != route->path.area_id ||
+		    (memcmp(&(o_path)->origin, &(route)->path.origin,
+			    sizeof(struct ospf6_ls_origin)) != 0))
+			continue;
+
+		if ((o_path->cost == route->path.cost) &&
+		    (o_path->u.cost_e2 == route->path.u.cost_e2))
+			continue;
+
+		for (ALL_LIST_ELEMENTS_RO(o_path->nh_list, nnode, nh)) {
+			for (ALL_LIST_ELEMENTS(old_route->nh_list, rnode,
+					       rnext, rnh)) {
+				if (!ospf6_nexthop_is_same(rnh, nh))
+					continue;
+				listnode_delete(old_route->nh_list, rnh);
+				ospf6_nexthop_delete(rnh);
+			}
+
+		}
+
+		listnode_delete(old_route->paths, o_path);
+		ospf6_path_free(o_path);
+
+		for (ALL_LIST_ELEMENTS(old_route->paths, anode,
+				       anext, o_path)) {
+			ospf6_merge_nexthops(old_route->nh_list,
+					     o_path->nh_list);
+		}
+
+		if (IS_OSPF6_DEBUG_ABR || IS_OSPF6_DEBUG_EXAMIN(INTER_PREFIX))
+			zlog_debug("%s: paths %u nh %u", __PRETTY_FUNCTION__,
+				   old_route->paths ?
+				   listcount(old_route->paths) : 0,
+				   old_route->nh_list ?
+				   listcount(old_route->nh_list) : 0);
+
+		if (table->hook_add)
+			(*table->hook_add)(old_route);
+
+		if (old_route->path.origin.id == route->path.origin.id &&
+		    old_route->path.origin.adv_router ==
+		    route->path.origin.adv_router) {
+			struct ospf6_path *h_path;
+
+			h_path = (struct ospf6_path *)
+			listgetdata(listhead(old_route->paths));
+			old_route->path.origin.type = h_path->origin.type;
+			old_route->path.origin.id = h_path->origin.id;
+			old_route->path.origin.adv_router =
+				h_path->origin.adv_router;
+		}
+	}
+}
+
+void ospf6_abr_old_route_remove(struct ospf6_lsa *lsa,
+				struct ospf6_route *old,
+				struct ospf6_route_table *table)
+{
+	if (listcount(old->paths) > 1) {
+		struct listnode *anode, *anext, *nnode, *rnode, *rnext;
+		struct ospf6_path *o_path;
+		struct ospf6_nexthop *nh, *rnh;
+		bool nh_updated = false;
+		char buf[PREFIX2STR_BUFFER];
+
+		for (ALL_LIST_ELEMENTS(old->paths, anode, anext, o_path)) {
+			if (o_path->origin.adv_router != lsa->header->adv_router
+			    && o_path->origin.id != lsa->header->id)
+				continue;
+			for (ALL_LIST_ELEMENTS_RO(o_path->nh_list, nnode, nh)) {
+				for (ALL_LIST_ELEMENTS(old->nh_list,
+							rnode, rnext, rnh)) {
+					if (!ospf6_nexthop_is_same(rnh, nh))
+						continue;
+					listnode_delete(old->nh_list, rnh);
+					ospf6_nexthop_delete(rnh);
+				}
+			}
+			listnode_delete(old->paths, o_path);
+			ospf6_path_free(o_path);
+			nh_updated = true;
+		}
+
+		if (nh_updated) {
+			if (listcount(old->paths)) {
+				if (IS_OSPF6_DEBUG_ABR ||
+				    IS_OSPF6_DEBUG_EXAMIN(INTER_PREFIX)) {
+					prefix2str(&old->prefix, buf,
+						   sizeof(buf));
+					zlog_debug("%s: old %s updated nh %u",
+						   __PRETTY_FUNCTION__, buf,
+						   old->nh_list ?
+						   listcount(old->nh_list) : 0);
+				}
+
+				if (table->hook_add)
+					(*table->hook_add)(old);
+
+				if ((old->path.origin.id == lsa->header->id) &&
+				    (old->path.origin.adv_router
+						 == lsa->header->adv_router)) {
+					struct ospf6_path *h_path;
+
+					h_path = (struct ospf6_path *)
+						listgetdata(
+							listhead(old->paths));
+					old->path.origin.type =
+						h_path->origin.type;
+					old->path.origin.id = h_path->origin.id;
+					old->path.origin.adv_router =
+						h_path->origin.adv_router;
+				}
+			} else
+				ospf6_route_remove(old, table);
+		}
+	} else
+		ospf6_route_remove(old, table);
+
+}
+
 /* RFC 2328 16.2. Calculating the inter-area routes */
 void ospf6_abr_examin_summary(struct ospf6_lsa *lsa, struct ospf6_area *oa)
 {
 	struct prefix prefix, abr_prefix;
 	struct ospf6_route_table *table = NULL;
-	struct ospf6_route *range, *route, *old = NULL;
+	struct ospf6_route *range, *route, *old = NULL, *old_route;
 	struct ospf6_route *abr_entry;
 	uint8_t type = 0;
 	char options[3] = {0, 0, 0};
@@ -695,14 +852,18 @@ void ospf6_abr_examin_summary(struct osp
 	int is_debug = 0;
 	struct ospf6_inter_prefix_lsa *prefix_lsa = NULL;
 	struct ospf6_inter_router_lsa *router_lsa = NULL;
-	struct ospf6_path *path;
+	bool old_entry_updated = false;
+	struct ospf6_path *path, *o_path, *ecmp_path;
+	struct listnode *anode;
+	char adv_router[16];
 
 	memset(&prefix, 0, sizeof(prefix));
 
 	if (lsa->header->type == htons(OSPF6_LSTYPE_INTER_PREFIX)) {
 		if (IS_OSPF6_DEBUG_EXAMIN(INTER_PREFIX)) {
 			is_debug++;
-			zlog_debug("Examin %s in area %s", lsa->name, oa->name);
+			zlog_debug("%s: Examin %s in area %s",
+				   __PRETTY_FUNCTION__, lsa->name, oa->name);
 		}
 
 		prefix_lsa =
@@ -710,7 +871,8 @@ void ospf6_abr_examin_summary(struct osp
 				lsa->header);
 		prefix.family = AF_INET6;
 		prefix.prefixlen = prefix_lsa->prefix.prefix_length;
-		ospf6_prefix_in6_addr(&prefix.u.prefix6, &prefix_lsa->prefix);
+		ospf6_prefix_in6_addr(&prefix.u.prefix6, prefix_lsa,
+				      &prefix_lsa->prefix);
 		if (is_debug)
 			prefix2str(&prefix, buf, sizeof(buf));
 		table = oa->ospf6->route_table;
@@ -720,7 +882,8 @@ void ospf6_abr_examin_summary(struct osp
 	} else if (lsa->header->type == htons(OSPF6_LSTYPE_INTER_ROUTER)) {
 		if (IS_OSPF6_DEBUG_EXAMIN(INTER_ROUTER)) {
 			is_debug++;
-			zlog_debug("Examin %s in area %s", lsa->name, oa->name);
+			zlog_debug("%s: Examin %s in area %s",
+				   __PRETTY_FUNCTION__, lsa->name, oa->name);
 		}
 
 		router_lsa =
@@ -749,10 +912,39 @@ void ospf6_abr_examin_summary(struct osp
 	while (route && ospf6_route_is_prefix(&prefix, route)) {
 		if (route->path.area_id == oa->area_id
 		    && route->path.origin.type == lsa->header->type
-		    && route->path.origin.id == lsa->header->id
-		    && route->path.origin.adv_router == lsa->header->adv_router
-		    && !CHECK_FLAG(route->flag, OSPF6_ROUTE_WAS_REMOVED))
-			old = route;
+		    && !CHECK_FLAG(route->flag, OSPF6_ROUTE_WAS_REMOVED)) {
+			/* LSA adv. router could be part of route's
+			 * paths list. Find the existing path and set
+			 * old as the route.
+			 */
+			if (listcount(route->paths) > 1) {
+				struct listnode *anode;
+				struct ospf6_path *o_path;
+
+				for (ALL_LIST_ELEMENTS_RO(route->paths, anode,
+							  o_path)) {
+					inet_ntop(AF_INET,
+						  &o_path->origin.adv_router,
+						  adv_router,
+						  sizeof(adv_router));
+					if (o_path->origin.id == lsa->header->id
+					    && o_path->origin.adv_router ==
+					    lsa->header->adv_router) {
+						old = route;
+
+						if (is_debug)
+							zlog_debug("%s: old entry found in paths, adv_router %s",
+							__PRETTY_FUNCTION__,
+							adv_router);
+
+						break;
+					}
+				}
+			} else if (route->path.origin.id == lsa->header->id &&
+				   route->path.origin.adv_router ==
+				   lsa->header->adv_router)
+				old = route;
+		}
 		route = ospf6_route_next(route);
 	}
 	if (route)
@@ -763,21 +955,23 @@ void ospf6_abr_examin_summary(struct osp
 		if (is_debug)
 			zlog_debug("cost is LS_INFINITY, ignore");
 		if (old)
-			ospf6_route_remove(old, table);
+			ospf6_abr_old_route_remove(lsa, old, table);
 		return;
 	}
 	if (OSPF6_LSA_IS_MAXAGE(lsa)) {
 		if (is_debug)
-			zlog_debug("LSA is MaxAge, ignore");
+			zlog_debug("%s: LSA %s is MaxAge, ignore",
+				   __PRETTY_FUNCTION__, lsa->name);
 		if (old)
-			ospf6_route_remove(old, table);
+			ospf6_abr_old_route_remove(lsa, old, table);
 		return;
 	}
 
 	/* (2) if the LSA is self-originated, ignore */
 	if (lsa->header->adv_router == oa->ospf6->router_id) {
 		if (is_debug)
-			zlog_debug("LSA is self-originated, ignore");
+			zlog_debug("LSA %s is self-originated, ignore",
+				   lsa->name);
 		if (old)
 			ospf6_route_remove(old, table);
 		return;
@@ -845,9 +1039,24 @@ void ospf6_abr_examin_summary(struct osp
 	    || CHECK_FLAG(abr_entry->flag, OSPF6_ROUTE_REMOVE)
 	    || !CHECK_FLAG(abr_entry->path.router_bits, OSPF6_ROUTER_BIT_B)) {
 		if (is_debug)
-			zlog_debug("ABR router entry does not exist, ignore");
-		if (old)
-			ospf6_route_remove(old, table);
+			zlog_debug("%s: ABR router entry does not exist, ignore",
+				   __PRETTY_FUNCTION__);
+		if (old) {
+			if (old->type == OSPF6_DEST_TYPE_ROUTER &&
+			    oa->intra_brouter_calc) {
+				if (is_debug)
+					zlog_debug(
+						   "%s: intra_brouter_calc is on, skip brouter remove: %s (%p)",
+						   __PRETTY_FUNCTION__, buf,
+						   (void *)old);
+			} else {
+				if (is_debug)
+					zlog_debug("%s: remove old entry: %s %p ",
+						   __PRETTY_FUNCTION__, buf,
+						   (void *)old);
+				ospf6_route_remove(old, table);
+			}
+		}
 		return;
 	}
 
@@ -870,7 +1079,7 @@ void ospf6_abr_examin_summary(struct osp
 	}
 
 	/* Check input prefix-list */
-	if (PREFIX_LIST_IN(oa))
+	if (PREFIX_LIST_IN(oa)) {
 		if (prefix_list_apply(PREFIX_LIST_IN(oa), &prefix)
 		    != PREFIX_PERMIT) {
 			if (is_debug)
@@ -879,14 +1088,12 @@ void ospf6_abr_examin_summary(struct osp
 				ospf6_route_remove(old, table);
 			return;
 		}
+	}
 
 	/* (5),(6): the path preference is handled by the sorting
 	   in the routing table. Always install the path by substituting
 	   old route (if any). */
-	if (old)
-		route = ospf6_route_copy(old);
-	else
-		route = ospf6_route_create();
+	route = ospf6_route_create();
 
 	route->type = type;
 	route->prefix = prefix;
@@ -902,12 +1109,9 @@ void ospf6_abr_examin_summary(struct osp
 	route->path.type = OSPF6_PATH_TYPE_INTER;
 	route->path.cost = abr_entry->path.cost + cost;
 
+	/* copy brouter rechable nexthops into the route. */
 	ospf6_route_copy_nexthops(route, abr_entry);
 
-	path = ospf6_path_dup(&route->path);
-	ospf6_copy_nexthops(path->nh_list, abr_entry->nh_list);
-	listnode_add_sort(route->paths, path);
-
 	/* (7) If the routes are identical, copy the next hops over to existing
 	   route. ospf6's route table implementation will otherwise string both
 	   routes, but keep the older one as the best route since the routes
@@ -915,26 +1119,103 @@ void ospf6_abr_examin_summary(struct osp
 	*/
 	old = ospf6_route_lookup(&prefix, table);
 
-	if (old && (ospf6_route_cmp(route, old) == 0)) {
-		ospf6_route_merge_nexthops(old, route);
+	for (old_route = old; old_route; old_route = old_route->next) {
+		if (!ospf6_route_is_same(old_route, route) ||
+			(old_route->type != route->type) ||
+			(old_route->path.type != route->path.type))
+			continue;
+
+		if ((ospf6_route_cmp(route, old_route) != 0)) {
+			if (is_debug) {
+				prefix2str(&prefix, buf, sizeof(buf));
+				zlog_debug("%s: old %p %s cost %u new route cost %u are not same",
+					   __PRETTY_FUNCTION__,
+					   (void *)old_route, buf,
+					   old_route->path.cost,
+					   route->path.cost);
+			}
+
+			/* Check new route's adv. router is same in one of
+			 * the paths with differed cost, if so remove the
+			 * old path as later new route will be added.
+			 */
+			if (listcount(old_route->paths) > 1)
+				ospf6_abr_old_path_update(old_route, route,
+							  table);
+			continue;
+		}
+
+		ospf6_route_merge_nexthops(old_route, route);
+		old_entry_updated = true;
+
+		for (ALL_LIST_ELEMENTS_RO(old_route->paths, anode,
+						  o_path)) {
+			if (o_path->area_id == route->path.area_id &&
+			    (memcmp(&(o_path)->origin, &(route)->path.origin,
+				    sizeof(struct ospf6_ls_origin)) == 0))
+				break;
+		}
+
+		/* New adv. router for a existing path add to paths list */
+		if (o_path == NULL) {
+			ecmp_path = ospf6_path_dup(&route->path);
+
+			/* Add a nh_list to new ecmp path */
+			ospf6_copy_nexthops(ecmp_path->nh_list, route->nh_list);
+
+			/* Add the new path to route's path list */
+			listnode_add_sort(old_route->paths, ecmp_path);
+
+			if (is_debug) {
+				prefix2str(&route->prefix, buf, sizeof(buf));
+				inet_ntop(AF_INET,
+					  &ecmp_path->origin.adv_router,
+					  adv_router, sizeof(adv_router));
+				zlog_debug("%s: route %s cost %u another path %s added with nh %u, effective paths %u nh %u",
+						__PRETTY_FUNCTION__, buf,
+						old_route->path.cost,
+						adv_router,
+						listcount(ecmp_path->nh_list),
+						old_route->paths ?
+						listcount(old_route->paths) : 0,
+						listcount(old_route->nh_list));
+			}
+		} else {
+			/* adv. router exists in the list, update the nhs */
+			list_delete_all_node(o_path->nh_list);
+			ospf6_copy_nexthops(o_path->nh_list, route->nh_list);
+		}
 
 		if (is_debug)
-			zlog_debug("%s: Update route: %s old cost %u new cost %u nh count %u",
-				   __PRETTY_FUNCTION__,
-				   buf, old->path.cost, route->path.cost,
+			zlog_debug("%s: Update route: %s %p old cost %u new cost %u nh %u",
+				   __PRETTY_FUNCTION__, buf, (void *)old_route,
+				   old_route->path.cost, route->path.cost,
 				   listcount(route->nh_list));
 
-		/* Update RIB/FIB */
+		/* For Inter-Prefix route: Update RIB/FIB,
+		 * For Inter-Router trigger summary update
+		 */
 		if (table->hook_add)
-			(*table->hook_add)(old);
+			(*table->hook_add)(old_route);
 
 		/* Delete new route */
 		ospf6_route_delete(route);
-	} else {
-		if (is_debug)
-			zlog_debug("%s: Install route: %s cost %u nh count %u",
+		break;
+	}
+
+	if (old_entry_updated == false) {
+		if (is_debug) {
+			inet_ntop(AF_INET, &route->path.origin.adv_router,
+				  adv_router, sizeof(adv_router));
+			zlog_debug("%s: Install route: %s cost %u nh %u adv_router %s ",
 				   __PRETTY_FUNCTION__, buf, route->path.cost,
-				   listcount(route->nh_list));
+				   listcount(route->nh_list), adv_router);
+		}
+
+		path = ospf6_path_dup(&route->path);
+		ospf6_copy_nexthops(path->nh_list, abr_entry->nh_list);
+		listnode_add_sort(route->paths, path);
+
 		/* ospf6_ia_add_nw_route (table, &prefix, route); */
 		ospf6_route_add(route, table);
 	}
@@ -1011,7 +1292,7 @@ static char *ospf6_inter_area_prefix_lsa
 			(struct ospf6_inter_prefix_lsa *)OSPF6_LSA_HEADER_END(
 				lsa->header);
 
-		ospf6_prefix_in6_addr(&in6, &prefix_lsa->prefix);
+		ospf6_prefix_in6_addr(&in6, prefix_lsa, &prefix_lsa->prefix);
 		if (buf) {
 			inet_ntop(AF_INET6, &in6, buf, buflen);
 			sprintf(&buf[strlen(buf)], "/%d",
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_abr.h frr-frr-6.0/ospf6d/ospf6_abr.h
--- frr-frr-5.0.1/ospf6d/ospf6_abr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_abr.h	2018-10-08 14:32:57.000000000 +0200
@@ -76,7 +76,12 @@ extern void ospf6_abr_prefix_resummarize
 extern int config_write_ospf6_debug_abr(struct vty *vty);
 extern void install_element_ospf6_debug_abr(void);
 extern int ospf6_abr_config_write(struct vty *vty);
-
+extern void ospf6_abr_old_route_remove(struct ospf6_lsa *lsa,
+				       struct ospf6_route *old,
+				       struct ospf6_route_table *table);
+extern void ospf6_abr_old_path_update(struct ospf6_route *old_route,
+				      struct ospf6_route *route,
+				      struct ospf6_route_table *table);
 extern void ospf6_abr_init(void);
 
 #endif /*OSPF6_ABR_H*/
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_area.h frr-frr-6.0/ospf6d/ospf6_area.h
--- frr-frr-5.0.1/ospf6d/ospf6_area.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_area.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,6 +50,9 @@ struct ospf6_area {
 	/* Area type */
 	int no_summary;
 
+	/* Brouter traversal protection */
+	int intra_brouter_calc;
+
 	/* OSPF interface list */
 	struct list *if_list;
 
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_asbr.c frr-frr-6.0/ospf6d/ospf6_asbr.c
--- frr-frr-5.0.1/ospf6d/ospf6_asbr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_asbr.c	2018-10-08 14:32:57.000000000 +0200
@@ -260,12 +260,12 @@ void ospf6_asbr_update_route_ecmp_path(s
 					listnode_delete(old_route->nh_list,
 							rnh);
 					ospf6_nexthop_delete(rnh);
-					route_updated = true;
 				}
 			}
 
 			listnode_delete(old_route->paths, o_path);
 			ospf6_path_free(o_path);
+			route_updated = true;
 
 			/* Current route's path (adv_router info) is similar
 			 * to route being added.
@@ -273,6 +273,19 @@ void ospf6_asbr_update_route_ecmp_path(s
 			 * Update FIB with effective NHs.
 			 */
 			if (listcount(old_route->paths)) {
+				for (ALL_LIST_ELEMENTS(old_route->paths,
+						anode, anext, o_path)) {
+					ospf6_merge_nexthops(
+						old_route->nh_list,
+						o_path->nh_list);
+				}
+				/* Update RIB/FIB with effective
+				 * nh_list
+				 */
+				if (ospf6->route_table->hook_add)
+					(*ospf6->route_table->hook_add)
+						(old_route);
+
 				if (old_route->path.origin.id
 					    == route->path.origin.id
 				    && old_route->path.origin.adv_router
@@ -290,23 +303,6 @@ void ospf6_asbr_update_route_ecmp_path(s
 					old_route->path.origin.adv_router =
 						h_path->origin.adv_router;
 				}
-
-				if (route_updated) {
-					for (ALL_LIST_ELEMENTS(old_route->paths,
-							       anode, anext,
-							       o_path)) {
-						ospf6_merge_nexthops(
-							old_route->nh_list,
-							o_path->nh_list);
-					}
-					/* Update RIB/FIB with effective
-					 * nh_list
-					 */
-					if (ospf6->route_table->hook_add)
-						(*ospf6->route_table->hook_add)(
-							old_route);
-					break;
-				}
 			} else {
 				if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL)) {
 					prefix2str(&old_route->prefix, buf,
@@ -319,7 +315,6 @@ void ospf6_asbr_update_route_ecmp_path(s
 				}
 				ospf6_route_remove(old_route,
 						   ospf6->route_table);
-				break;
 			}
 		}
 		if (route_updated)
@@ -374,13 +369,6 @@ void ospf6_asbr_update_route_ecmp_path(s
 				/* Add a nh_list to new ecmp path */
 				ospf6_copy_nexthops(ecmp_path->nh_list,
 						    route->nh_list);
-				/* Merge nexthop to existing route's nh_list */
-				ospf6_route_merge_nexthops(old_route, route);
-
-				/* Update RIB/FIB */
-				if (ospf6->route_table->hook_add)
-					(*ospf6->route_table->hook_add)(
-						old_route);
 
 				/* Add the new path to route's path list */
 				listnode_add_sort(old_route->paths, ecmp_path);
@@ -400,46 +388,52 @@ void ospf6_asbr_update_route_ecmp_path(s
 						listcount(old_route->nh_list));
 				}
 			} else {
-				for (ALL_LIST_ELEMENTS_RO(o_path->nh_list,
-							  nnode, nh)) {
-					for (ALL_LIST_ELEMENTS(
-						     old_route->nh_list, rnode,
-						     rnext, rnh)) {
-						if (!ospf6_nexthop_is_same(rnh,
-									   nh))
-							continue;
-
-						listnode_delete(
-							old_route->nh_list,
-							rnh);
-						ospf6_nexthop_delete(rnh);
-					}
-				}
 				list_delete_all_node(o_path->nh_list);
 				ospf6_copy_nexthops(o_path->nh_list,
 						    route->nh_list);
+			}
 
-				/* Merge nexthop to existing route's nh_list */
-				ospf6_route_merge_nexthops(old_route, route);
+			/* Reset nexthop lists, rebuild from brouter table
+			 * for each adv. router.
+			 */
+			list_delete_all_node(old_route->nh_list);
 
-				if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL)) {
-					prefix2str(&route->prefix, buf,
-						   sizeof(buf));
-					zlog_debug(
-						"%s: existing route %s with effective nh count %u",
-						__PRETTY_FUNCTION__, buf,
-						old_route->nh_list
-							? listcount(
-								  old_route
-									  ->nh_list)
-							: 0);
+			for (ALL_LIST_ELEMENTS_RO(old_route->paths, anode,
+						  o_path)) {
+				struct ospf6_route *asbr_entry;
+
+				asbr_entry = ospf6_route_lookup(
+							&o_path->ls_prefix,
+							ospf6->brouter_table);
+				if (asbr_entry == NULL) {
+					if (IS_OSPF6_DEBUG_EXAMIN(
+							AS_EXTERNAL)) {
+						prefix2str(&old_route->prefix,
+							   buf, sizeof(buf));
+						zlog_debug("%s: ls_prfix %s asbr_entry not found.",
+							   __PRETTY_FUNCTION__,
+							   buf);
+					}
+					continue;
 				}
+				ospf6_route_merge_nexthops(old_route,
+							   asbr_entry);
+			}
 
-				/* Update RIB/FIB */
-				if (ospf6->route_table->hook_add)
-					(*ospf6->route_table->hook_add)(
-						old_route);
+			if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL)) {
+				prefix2str(&route->prefix, buf, sizeof(buf));
+				zlog_debug("%s: route %s with effective paths %u nh %u",
+					   __PRETTY_FUNCTION__, buf,
+					   old_route->paths ?
+					   listcount(old_route->paths) : 0,
+					   old_route->nh_list ?
+					   listcount(old_route->nh_list) : 0);
 			}
+
+			/* Update RIB/FIB */
+			if (ospf6->route_table->hook_add)
+				(*ospf6->route_table->hook_add)(old_route);
+
 			/* Delete the new route its info added to existing
 			 * route.
 			 */
@@ -503,14 +497,16 @@ void ospf6_asbr_lsa_add(struct ospf6_lsa
 	route->type = OSPF6_DEST_TYPE_NETWORK;
 	route->prefix.family = AF_INET6;
 	route->prefix.prefixlen = external->prefix.prefix_length;
-	ospf6_prefix_in6_addr(&route->prefix.u.prefix6, &external->prefix);
+	ospf6_prefix_in6_addr(&route->prefix.u.prefix6, external,
+			      &external->prefix);
 
 	route->path.area_id = asbr_entry->path.area_id;
 	route->path.origin.type = lsa->header->type;
 	route->path.origin.id = lsa->header->id;
 	route->path.origin.adv_router = lsa->header->adv_router;
-
 	route->path.prefix_options = external->prefix.prefix_options;
+	memcpy(&route->path.ls_prefix, &asbr_id, sizeof(struct prefix));
+
 	if (CHECK_FLAG(external->bits_metric, OSPF6_ASBR_BIT_E)) {
 		route->path.type = OSPF6_PATH_TYPE_EXTERNAL2;
 		route->path.metric_type = 2;
@@ -581,7 +577,7 @@ void ospf6_asbr_lsa_remove(struct ospf6_
 	route_to_del->type = OSPF6_DEST_TYPE_NETWORK;
 	route_to_del->prefix.family = AF_INET6;
 	route_to_del->prefix.prefixlen = external->prefix.prefix_length;
-	ospf6_prefix_in6_addr(&route_to_del->prefix.u.prefix6,
+	ospf6_prefix_in6_addr(&route_to_del->prefix.u.prefix6, external,
 			      &external->prefix);
 
 	route_to_del->path.origin.type = lsa->header->type;
@@ -608,7 +604,7 @@ void ospf6_asbr_lsa_remove(struct ospf6_
 	memset(&prefix, 0, sizeof(struct prefix));
 	prefix.family = AF_INET6;
 	prefix.prefixlen = external->prefix.prefix_length;
-	ospf6_prefix_in6_addr(&prefix.u.prefix6, &external->prefix);
+	ospf6_prefix_in6_addr(&prefix.u.prefix6, external, &external->prefix);
 
 	route = ospf6_route_lookup(&prefix, ospf6->route_table);
 	if (route == NULL) {
@@ -1349,7 +1345,8 @@ static void ospf6_redistribute_show_conf
 
 /* Routemap Functions */
 static route_map_result_t
-ospf6_routemap_rule_match_address_prefixlist(void *rule, struct prefix *prefix,
+ospf6_routemap_rule_match_address_prefixlist(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -1388,7 +1385,7 @@ struct route_map_rule_cmd ospf6_routemap
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t
-ospf6_routemap_rule_match_interface(void *rule, struct prefix *prefix,
+ospf6_routemap_rule_match_interface(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	struct interface *ifp;
@@ -1426,7 +1423,7 @@ struct route_map_rule_cmd ospf6_routemap
 
 /* Match function for matching route tags */
 static route_map_result_t ospf6_routemap_rule_match_tag(void *rule,
-							struct prefix *prefix,
+							const struct prefix *p,
 							route_map_object_t type,
 							void *object)
 {
@@ -1446,7 +1443,7 @@ static struct route_map_rule_cmd ospf6_r
 };
 
 static route_map_result_t
-ospf6_routemap_rule_set_metric_type(void *rule, struct prefix *prefix,
+ospf6_routemap_rule_set_metric_type(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	char *metric_type = rule;
@@ -1482,7 +1479,7 @@ struct route_map_rule_cmd ospf6_routemap
 };
 
 static route_map_result_t
-ospf6_routemap_rule_set_metric(void *rule, struct prefix *prefix,
+ospf6_routemap_rule_set_metric(void *rule, const struct prefix *prefix,
 			       route_map_object_t type, void *object)
 {
 	char *metric = rule;
@@ -1517,7 +1514,7 @@ struct route_map_rule_cmd ospf6_routemap
 };
 
 static route_map_result_t
-ospf6_routemap_rule_set_forwarding(void *rule, struct prefix *prefix,
+ospf6_routemap_rule_set_forwarding(void *rule, const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	char *forwarding = rule;
@@ -1555,7 +1552,7 @@ struct route_map_rule_cmd ospf6_routemap
 };
 
 static route_map_result_t ospf6_routemap_rule_set_tag(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *p,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -1710,7 +1707,8 @@ static char *ospf6_as_external_lsa_get_p
 			lsa->header);
 
 		if (pos == 0) {
-			ospf6_prefix_in6_addr(&in6, &external->prefix);
+			ospf6_prefix_in6_addr(&in6, external,
+					      &external->prefix);
 			prefix_length = external->prefix.prefix_length;
 		} else {
 			in6 = *((struct in6_addr
@@ -1863,9 +1861,6 @@ void ospf6_asbr_redistribute_reset(void)
 void ospf6_asbr_terminate(void)
 {
 	/* Cleanup route maps */
-	route_map_add_hook(NULL);
-	route_map_delete_hook(NULL);
-	route_map_event_hook(NULL);
 	route_map_finish();
 }
 
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_bfd.c frr-frr-6.0/ospf6d/ospf6_bfd.c
--- frr-frr-5.0.1/ospf6d/ospf6_bfd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_bfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -276,11 +276,14 @@ void ospf6_bfd_info_nbr_create(struct os
  */
 void ospf6_bfd_write_config(struct vty *vty, struct ospf6_interface *oi)
 {
+#if HAVE_BFDD == 0
 	struct bfd_info *bfd_info;
+#endif /* ! HAVE_BFDD */
 
 	if (!oi->bfd_info)
 		return;
 
+#if HAVE_BFDD == 0
 	bfd_info = (struct bfd_info *)oi->bfd_info;
 
 	if (CHECK_FLAG(bfd_info->flags, BFD_FLAG_PARAM_CFG))
@@ -288,6 +291,7 @@ void ospf6_bfd_write_config(struct vty *
 			bfd_info->detect_mult, bfd_info->required_min_rx,
 			bfd_info->desired_min_tx);
 	else
+#endif /* ! HAVE_BFDD */
 		vty_out(vty, " ipv6 ospf6 bfd\n");
 }
 
@@ -329,7 +333,12 @@ DEFUN (ipv6_ospf6_bfd,
 	return CMD_SUCCESS;
 }
 
-DEFUN (ipv6_ospf6_bfd_param,
+#if HAVE_BFDD > 0
+DEFUN_HIDDEN(
+#else
+DEFUN(
+#endif /* HAVE_BFDD */
+       ipv6_ospf6_bfd_param,
        ipv6_ospf6_bfd_param_cmd,
        "ipv6 ospf6 bfd (2-255) (50-60000) (50-60000)",
        IP6_STR
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_flood.c frr-frr-6.0/ospf6d/ospf6_flood.c
--- frr-frr-5.0.1/ospf6d/ospf6_flood.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_flood.c	2018-10-08 14:32:57.000000000 +0200
@@ -330,6 +330,8 @@ void ospf6_flood_interface(struct ospf6_
 						zlog_debug(
 							"Requesting the same, remove it, next neighbor");
 					if (req == on->last_ls_req) {
+						/* sanity check refcount */
+						assert(req->lock >= 2);
 						ospf6_lsa_unlock(req);
 						on->last_ls_req = NULL;
 					}
@@ -349,8 +351,9 @@ void ospf6_flood_interface(struct ospf6_
 						ospf6_lsa_unlock(req);
 						on->last_ls_req = NULL;
 					}
-					ospf6_lsdb_remove(req,
-							  on->request_list);
+					if (req)
+						ospf6_lsdb_remove(req,
+							on->request_list);
 					ospf6_check_nbr_loading(on);
 					/* fall through */
 				}
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_interface.c frr-frr-6.0/ospf6d/ospf6_interface.c
--- frr-frr-5.0.1/ospf6d/ospf6_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -180,12 +180,6 @@ struct ospf6_interface *ospf6_interface_
 	oi = (struct ospf6_interface *)XCALLOC(MTYPE_OSPF6_IF,
 					       sizeof(struct ospf6_interface));
 
-	if (!oi) {
-		zlog_err("Can't malloc ospf6_interface for ifindex %d",
-			 ifp->ifindex);
-		return (struct ospf6_interface *)NULL;
-	}
-
 	oi->area = (struct ospf6_area *)NULL;
 	oi->neighbor_list = list_new();
 	oi->neighbor_list->cmp = ospf6_neighbor_cmp;
@@ -864,7 +858,6 @@ static int ospf6_interface_show(struct v
 	struct prefix *p;
 	struct listnode *i;
 	char strbuf[PREFIX2STR_BUFFER], drouter[32], bdrouter[32];
-	const char *updown[3] = {"down", "up", NULL};
 	const char *type;
 	struct timeval res, now;
 	char duration[32];
@@ -881,7 +874,7 @@ static int ospf6_interface_show(struct v
 		type = "UNKNOWN";
 
 	vty_out(vty, "%s is %s, type %s\n", ifp->name,
-		updown[if_is_operative(ifp)], type);
+		(if_is_operative(ifp) ? "up" : "down"), type);
 	vty_out(vty, "  Interface ID: %d\n", ifp->ifindex);
 
 	if (ifp->info == NULL) {
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_intra.c frr-frr-6.0/ospf6d/ospf6_intra.c
--- frr-frr-5.0.1/ospf6d/ospf6_intra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_intra.c	2018-10-08 14:32:57.000000000 +0200
@@ -1314,17 +1314,62 @@ int ospf6_intra_prefix_lsa_originate_tra
 	return 0;
 }
 
+static void ospf6_intra_prefix_update_route_origin(struct ospf6_route *oa_route)
+{
+	struct ospf6_path *h_path;
+	struct ospf6_route *g_route, *nroute;
+
+	/* Update Global ospf6 route path */
+	g_route = ospf6_route_lookup(&oa_route->prefix,
+				     ospf6->route_table);
+
+	assert(g_route);
+
+	for (ospf6_route_lock(g_route); g_route &&
+	     ospf6_route_is_prefix(&oa_route->prefix, g_route);
+	     g_route = nroute) {
+		nroute = ospf6_route_next(g_route);
+		if (g_route->type != oa_route->type)
+			continue;
+		if (g_route->path.area_id != oa_route->path.area_id)
+			continue;
+		if (g_route->path.type != OSPF6_PATH_TYPE_INTRA)
+			continue;
+		if (g_route->path.cost != oa_route->path.cost)
+			continue;
+
+		if (ospf6_route_is_same_origin(g_route, oa_route)) {
+			h_path = (struct ospf6_path *)listgetdata(
+				listhead(g_route->paths));
+			g_route->path.origin.type = h_path->origin.type;
+			g_route->path.origin.id = h_path->origin.id;
+			g_route->path.origin.adv_router =
+				h_path->origin.adv_router;
+			break;
+		}
+	}
+
+	h_path = (struct ospf6_path *)listgetdata(
+				listhead(oa_route->paths));
+	oa_route->path.origin.type = h_path->origin.type;
+	oa_route->path.origin.id = h_path->origin.id;
+	oa_route->path.origin.adv_router = h_path->origin.adv_router;
+}
+
 void ospf6_intra_prefix_route_ecmp_path(struct ospf6_area *oa,
 					struct ospf6_route *old,
 					struct ospf6_route *route)
 {
-	struct ospf6_route *old_route;
+	struct ospf6_route *old_route, *ls_entry;
 	struct ospf6_path *ecmp_path, *o_path = NULL;
 	struct listnode *anode, *anext;
 	struct listnode *nnode, *rnode, *rnext;
 	struct ospf6_nexthop *nh, *rnh;
 	char buf[PREFIX2STR_BUFFER];
 	bool route_found = false;
+	struct interface *ifp;
+	struct ospf6_lsa *lsa;
+	struct ospf6_intra_prefix_lsa *intra_prefix_lsa;
 
 	/* check for old entry match with new route origin,
 	 * delete old entry.
@@ -1361,7 +1406,7 @@ void ospf6_intra_prefix_route_ecmp_path(
 					   o_path->cost, route->path.cost);
 			}
 
-			/* Remove selected current rout path's nh from
+			/* Remove selected current path's nh from
 			 * effective nh list.
 			 */
 			for (ALL_LIST_ELEMENTS_RO(o_path->nh_list, nnode, nh)) {
@@ -1385,22 +1430,6 @@ void ospf6_intra_prefix_route_ecmp_path(
 			 * Update FIB with effective NHs.
 			 */
 			if (listcount(old_route->paths)) {
-				if (old_route->path.origin.id ==
-					route->path.origin.id &&
-					old_route->path.origin.adv_router ==
-						route->path.origin.adv_router) {
-					struct ospf6_path *h_path;
-
-					h_path = (struct ospf6_path *)
-					listgetdata(listhead(old_route->paths));
-					old_route->path.origin.type =
-						h_path->origin.type;
-					old_route->path.origin.id =
-						h_path->origin.id;
-					old_route->path.origin.adv_router =
-						h_path->origin.adv_router;
-				}
-
 				if (route_updated) {
 					for (ALL_LIST_ELEMENTS(old_route->paths,
 							anode, anext, o_path)) {
@@ -1415,6 +1444,14 @@ void ospf6_intra_prefix_route_ecmp_path(
 					if (oa->route_table->hook_add)
 						(*oa->route_table->hook_add)
 							(old_route);
+
+					if (old_route->path.origin.id ==
+					route->path.origin.id &&
+					old_route->path.origin.adv_router ==
+						route->path.origin.adv_router) {
+						ospf6_intra_prefix_update_route_origin(
+								old_route);
+					}
 					break;
 				}
 			} else {
@@ -1426,8 +1463,12 @@ void ospf6_intra_prefix_route_ecmp_path(
 						   old_route->path.cost,
 						   route->path.cost);
 				}
-				ospf6_route_remove(old_route,
+				if (oa->route_table->hook_remove)
+					ospf6_route_remove(old_route,
 						   oa->route_table);
+				else
+					SET_FLAG(old_route->flag,
+						 OSPF6_ROUTE_REMOVE);
 				break;
 			}
 		}
@@ -1467,72 +1508,101 @@ void ospf6_intra_prefix_route_ecmp_path(
 				/* Add a nh_list to new ecmp path */
 				ospf6_copy_nexthops(ecmp_path->nh_list,
 						    route->nh_list);
-				/* Merge nexthop to existing route's nh_list */
-				ospf6_route_merge_nexthops(old_route, route);
 				/* Add the new path to route's path list */
 				listnode_add_sort(old_route->paths, ecmp_path);
 
-				UNSET_FLAG(old_route->flag, OSPF6_ROUTE_REMOVE);
-				SET_FLAG(old_route->flag, OSPF6_ROUTE_CHANGE);
-				/* Update RIB/FIB */
-				if (oa->route_table->hook_add)
-					(*oa->route_table->hook_add)
-						(old_route);
 				if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
 					prefix2str(&route->prefix, buf,
 						   sizeof(buf));
-					zlog_debug("%s: route %s %p another path added with nh %u, effective paths %u nh %u",
+					zlog_debug(
+						"%s: route %s %p another path added with nh %u, effective paths %u nh %u",
 						__PRETTY_FUNCTION__, buf,
 						(void *)old_route,
 						listcount(ecmp_path->nh_list),
 						old_route->paths ?
-						listcount(old_route->paths)
-						: 0,
+						listcount(old_route->paths) : 0,
 						listcount(old_route->nh_list));
-				}
-			} else {
-				for (ALL_LIST_ELEMENTS_RO(o_path->nh_list,
-							  nnode, nh)) {
-					for (ALL_LIST_ELEMENTS(
-							old_route->nh_list,
-							rnode, rnext, rnh)) {
-						if (!ospf6_nexthop_is_same(rnh,
-									   nh))
-							continue;
 
-						listnode_delete(
-							old_route->nh_list,
-							rnh);
-						ospf6_nexthop_delete(rnh);
-					}
 				}
+			} else {
 				list_delete_all_node(o_path->nh_list);
 				ospf6_copy_nexthops(o_path->nh_list,
 					    route->nh_list);
 
-				/* Merge nexthop to existing route's nh_list */
-				ospf6_route_merge_nexthops(old_route,
-							   route);
+			}
 
-				if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
-					prefix2str(&route->prefix,
-						   buf, sizeof(buf));
-					zlog_debug("%s: existing route %s %p with effective paths %u nh count %u",
-						   __PRETTY_FUNCTION__, buf,
-						   (void *)old_route,
-						   listcount(old_route->paths),
-						   old_route->nh_list ?
-						   listcount(old_route->nh_list)
-						   : 0);
+			list_delete_all_node(old_route->nh_list);
+
+			for (ALL_LIST_ELEMENTS_RO(old_route->paths, anode,
+						  o_path)) {
+				ls_entry = ospf6_route_lookup(
+							&o_path->ls_prefix,
+							oa->spf_table);
+				if (ls_entry == NULL) {
+					if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX))
+						zlog_debug("%s: ls_prfix %s ls_entry not found.",
+							   __PRETTY_FUNCTION__,
+							   buf);
+					continue;
 				}
+				lsa = ospf6_lsdb_lookup(o_path->origin.type,
+						o_path->origin.id,
+						o_path->origin.adv_router,
+						oa->lsdb);
+				if (lsa == NULL) {
+					if (IS_OSPF6_DEBUG_EXAMIN(
+								INTRA_PREFIX)) {
+						struct prefix adv_prefix;
+
+						ospf6_linkstate_prefix(
+						o_path->origin.adv_router,
+						o_path->origin.id, &adv_prefix);
+						prefix2str(&adv_prefix, buf,
+							   sizeof(buf));
+						zlog_debug("%s: adv_router %s lsa not found",
+							   __PRETTY_FUNCTION__,
+							   buf);
+					}
+					continue;
+				}
+				intra_prefix_lsa =
+					(struct ospf6_intra_prefix_lsa *)
+					OSPF6_LSA_HEADER_END(lsa->header);
+
+				if (intra_prefix_lsa->ref_adv_router
+				     == oa->ospf6->router_id) {
+					ifp = if_lookup_prefix(
+							&old_route->prefix,
+							VRF_DEFAULT);
+					if (ifp)
+						ospf6_route_add_nexthop(
+								old_route,
+								ifp->ifindex,
+								NULL);
+				} else {
+					ospf6_route_merge_nexthops(old_route,
+								   ls_entry);
+				}
+			}
 
-				UNSET_FLAG(old_route->flag, OSPF6_ROUTE_REMOVE);
-				SET_FLAG(old_route->flag, OSPF6_ROUTE_CHANGE);
-				/* Update ospf6 route table and RIB/FIB */
-				if (oa->route_table->hook_add)
-					(*oa->route_table->hook_add)
-						(old_route);
+			if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
+				prefix2str(&route->prefix, buf, sizeof(buf));
+				zlog_debug("%s: route %s %p with final effective paths %u nh%u",
+					   __PRETTY_FUNCTION__, buf,
+					   (void *)old_route,
+					   old_route->paths ?
+					   listcount(old_route->paths) : 0,
+					   listcount(old_route->nh_list));
 			}
+
+			/* used in intra_route_calculation() to add to
+			 * global ospf6 route table.
+			 */
+			UNSET_FLAG(old_route->flag, OSPF6_ROUTE_REMOVE);
+			SET_FLAG(old_route->flag, OSPF6_ROUTE_ADD);
+			/* Update ospf6 route table and RIB/FIB */
+			if (oa->route_table->hook_add)
+				(*oa->route_table->hook_add)(old_route);
 			/* Delete the new route its info added to existing
 			 * route.
 			 */
@@ -1630,7 +1700,8 @@ void ospf6_intra_prefix_lsa_add(struct o
 		memset(&route->prefix, 0, sizeof(struct prefix));
 		route->prefix.family = AF_INET6;
 		route->prefix.prefixlen = op->prefix_length;
-		ospf6_prefix_in6_addr(&route->prefix.u.prefix6, op);
+		ospf6_prefix_in6_addr(&route->prefix.u.prefix6,
+				      intra_prefix_lsa, op);
 
 		route->type = OSPF6_DEST_TYPE_NETWORK;
 		route->path.origin.type = lsa->header->type;
@@ -1642,7 +1713,8 @@ void ospf6_intra_prefix_lsa_add(struct o
 		route->path.metric_type = 1;
 		route->path.cost =
 			ls_entry->path.cost + ntohs(op->prefix_metric);
-
+		memcpy(&route->path.ls_prefix, &ls_prefix,
+		       sizeof(struct prefix));
 		if (direct_connect) {
 			ifp = if_lookup_prefix(&route->prefix, VRF_DEFAULT);
 			if (ifp)
@@ -1660,20 +1732,21 @@ void ospf6_intra_prefix_lsa_add(struct o
 		if (old && (ospf6_route_cmp(route, old) == 0)) {
 			if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
 				prefix2str(&route->prefix, buf, sizeof(buf));
-				zlog_debug(" Update route: %s old cost %u new cost %u nh count %u paths %u",
-					   buf,
+				zlog_debug("%s Update route: %s old cost %u new cost %u paths %u nh %u",
+					   __PRETTY_FUNCTION__, buf,
 					   old->path.cost, route->path.cost,
-					   listcount(route->nh_list),
-					   listcount(route->paths));
+					   listcount(route->paths),
+					   listcount(route->nh_list));
 			}
 			ospf6_intra_prefix_route_ecmp_path(oa, old, route);
 		} else {
 			if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
 				prefix2str(&route->prefix, buf, sizeof(buf));
-				zlog_debug("  route %s add with cost %u nh %u paths %u",
-					   buf, route->path.cost,
-					   listcount(route->nh_list),
-					   listcount(route->paths));
+				zlog_debug("%s route %s add with cost %u paths %u nh %u",
+					   __PRETTY_FUNCTION__, buf,
+					   route->path.cost,
+					   listcount(route->paths),
+					   listcount(route->nh_list));
 			}
 			ospf6_route_add(route, oa->route_table);
 		}
@@ -1684,12 +1757,102 @@ void ospf6_intra_prefix_lsa_add(struct o
 		zlog_debug("Trailing garbage ignored");
 }
 
+static void ospf6_intra_prefix_lsa_remove_update_route(struct ospf6_lsa *lsa,
+						  struct ospf6_area *oa,
+						  struct ospf6_route *route)
+{
+	struct listnode *anode, *anext;
+	struct listnode *nnode, *rnode, *rnext;
+	struct ospf6_nexthop *nh, *rnh;
+	struct ospf6_path *o_path;
+	bool nh_updated = false;
+	char buf[PREFIX2STR_BUFFER];
+
+	/* Iterate all paths of route to find maching
+	 * with LSA remove info.
+	 * If route->path is same, replace
+	 * from paths list.
+	 */
+	for (ALL_LIST_ELEMENTS(route->paths, anode, anext, o_path)) {
+		if ((o_path->origin.type != lsa->header->type) ||
+		    (o_path->origin.adv_router != lsa->header->adv_router) ||
+		    (o_path->origin.id != lsa->header->id))
+			continue;
+
+		if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
+			prefix2str(&route->prefix, buf, sizeof(buf));
+			zlog_debug(
+				"%s: route %s path found with cost %u nh %u to remove.",
+				__PRETTY_FUNCTION__, buf, o_path->cost,
+				listcount(o_path->nh_list));
+		}
+
+		/* Remove found path's nh_list from
+		 * the route's nh_list.
+		 */
+		for (ALL_LIST_ELEMENTS_RO(o_path->nh_list, nnode, nh)) {
+			for (ALL_LIST_ELEMENTS(route->nh_list, rnode,
+					       rnext, rnh)) {
+				if (!ospf6_nexthop_is_same(rnh, nh))
+					continue;
+				listnode_delete(route->nh_list, rnh);
+				ospf6_nexthop_delete(rnh);
+			}
+		}
+		/* Delete the path from route's
+		 * path list
+		 */
+		listnode_delete(route->paths, o_path);
+		ospf6_path_free(o_path);
+		nh_updated = true;
+		break;
+	}
+
+	if (nh_updated) {
+		/* Iterate all paths and merge nexthop,
+		 * unlesss any of the nexthop similar to
+		 * ones deleted as part of path deletion.
+		 */
+		for (ALL_LIST_ELEMENTS(route->paths, anode, anext, o_path))
+			ospf6_merge_nexthops(route->nh_list, o_path->nh_list);
+
+
+		if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
+			prefix2str(&route->prefix, buf, sizeof(buf));
+			zlog_debug("%s: route %s update paths %u nh %u",
+				   __PRETTY_FUNCTION__, buf,
+				   route->paths ? listcount(route->paths) : 0,
+				   route->nh_list ? listcount(route->nh_list)
+				   : 0);
+		}
+
+		/* Update Global Route table and
+		 * RIB/FIB with effective
+		 * nh_list
+		 */
+		if (oa->route_table->hook_add)
+			(*oa->route_table->hook_add)(route);
+
+		/* route's primary path is similar
+		 * to LSA, replace route's primary
+		 * path with route's paths list
+		 * head.
+		 */
+		if ((route->path.origin.id == lsa->header->id) &&
+		    (route->path.origin.adv_router ==
+				lsa->header->adv_router)) {
+			ospf6_intra_prefix_update_route_origin(route);
+		}
+	}
+
+}
+
 void ospf6_intra_prefix_lsa_remove(struct ospf6_lsa *lsa)
 {
 	struct ospf6_area *oa;
 	struct ospf6_intra_prefix_lsa *intra_prefix_lsa;
 	struct prefix prefix;
-	struct ospf6_route *route, *nroute, *route_to_del;
+	struct ospf6_route *route, *nroute;
 	int prefix_num;
 	struct ospf6_prefix *op;
 	char *start, *current, *end;
@@ -1717,26 +1880,10 @@ void ospf6_intra_prefix_lsa_remove(struc
 			break;
 		prefix_num--;
 
-		route_to_del = ospf6_route_create();
-
-		memset(&route_to_del->prefix, 0, sizeof(struct prefix));
-		route_to_del->prefix.family = AF_INET6;
-		route_to_del->prefix.prefixlen = op->prefix_length;
-		ospf6_prefix_in6_addr(&route_to_del->prefix.u.prefix6, op);
-
-		route_to_del->type = OSPF6_DEST_TYPE_NETWORK;
-		route_to_del->path.origin.type = lsa->header->type;
-		route_to_del->path.origin.id = lsa->header->id;
-		route_to_del->path.origin.adv_router = lsa->header->adv_router;
-		route_to_del->path.prefix_options = op->prefix_options;
-		route_to_del->path.area_id = oa->area_id;
-		route_to_del->path.type = OSPF6_PATH_TYPE_INTRA;
-		route_to_del->path.metric_type = 1;
-
 		memset(&prefix, 0, sizeof(struct prefix));
 		prefix.family = AF_INET6;
 		prefix.prefixlen = op->prefix_length;
-		ospf6_prefix_in6_addr(&prefix.u.prefix6, op);
+		ospf6_prefix_in6_addr(&prefix.u.prefix6, intra_prefix_lsa, op);
 
 		route = ospf6_route_lookup(&prefix, oa->route_table);
 		if (route == NULL)
@@ -1757,134 +1904,8 @@ void ospf6_intra_prefix_lsa_remove(struc
 			 * after removal of one of the path.
 			 */
 			if (listcount(route->paths) > 1) {
-				struct listnode *anode, *anext;
-				struct listnode *nnode, *rnode, *rnext;
-				struct ospf6_nexthop *nh, *rnh;
-				struct ospf6_path *o_path;
-				bool nh_updated = false;
-
-				/* Iterate all paths of route to find maching
-				 * with LSA remove info.
-				 * If route->path is same, replace
-				 * from paths list.
-				 */
-				for (ALL_LIST_ELEMENTS(route->paths, anode,
-						       anext, o_path)) {
-					if ((o_path->origin.type !=
-					     lsa->header->type) ||
-					    (o_path->origin.adv_router !=
-					     lsa->header->adv_router) ||
-					    (o_path->origin.id !=
-					     lsa->header->id))
-						continue;
-
-					if (IS_OSPF6_DEBUG_EXAMIN
-						(INTRA_PREFIX)) {
-						prefix2str(&prefix, buf,
-							   sizeof(buf));
-						zlog_debug(
-							"%s: route %s path found with cost %u nh %u to remove.",
-							__PRETTY_FUNCTION__,
-							buf, o_path->cost,
-							listcount(
-							o_path->nh_list));
-					}
-					/* Remove old route from global
-					 * ospf6 route table.
-					 * nh_update section will add
-					 * back with effective nh.
-					 */
-					if (oa->route_table->hook_remove)
-						(*oa->route_table->hook_remove)
-							(route);
-					/* Remove found path's nh_list from
-					 * the route's nh_list.
-					 */
-					for (ALL_LIST_ELEMENTS_RO(
-							o_path->nh_list,
-								nnode, nh)) {
-						for (ALL_LIST_ELEMENTS(
-							route->nh_list,
-							rnode, rnext, rnh)) {
-							if (
-							!ospf6_nexthop_is_same(
-								rnh, nh))
-								continue;
-							listnode_delete(
-								route->nh_list,
-								rnh);
-							ospf6_nexthop_delete(
-									rnh);
-						}
-					}
-					/* Delete the path from route's
-					 * path list
-					 */
-					listnode_delete(route->paths, o_path);
-					ospf6_path_free(o_path);
-					nh_updated = true;
-					break;
-				}
-
-				if (nh_updated) {
-
-					/* Iterate all paths and merge nexthop,
-					 * unlesss any of the nexthop similar to
-					 * ones deleted as part of path
-					 * deletion.
-					 */
-					for (ALL_LIST_ELEMENTS(route->paths,
-							anode, anext, o_path)) {
-						ospf6_merge_nexthops(
-								route->nh_list,
-							     o_path->nh_list);
-					}
-
-					if (IS_OSPF6_DEBUG_EXAMIN(
-								INTRA_PREFIX)) {
-						prefix2str(&route->prefix, buf,
-							   sizeof(buf));
-						assert(route->nh_list);
-						zlog_debug("%s: route %s update paths %u nh %u"
-							, __PRETTY_FUNCTION__,
-							buf,
-							listcount(route->paths),
-							listcount(
-							route->nh_list));
-					}
-
-					/* route's primary path is similar
-					 * to LSA, replace route's primary
-					 * path with route's paths list
-					 * head.
-					 */
-					if ((route->path.origin.id ==
-							lsa->header->id) &&
-						(route->path.origin.adv_router
-						 == lsa->header->adv_router)) {
-						struct ospf6_path *h_path;
-
-						h_path = (struct ospf6_path *)
-						listgetdata(listhead(
-								route->paths));
-						route->path.origin.type =
-							h_path->origin.type;
-						route->path.origin.id =
-							h_path->origin.id;
-						route->path.origin.adv_router =
-						h_path->origin.adv_router;
-					}
-
-					/* Update Global Route table and
-					 * RIB/FIB with effective
-					 * nh_list
-					 */
-					if (oa->route_table->hook_add)
-						(*oa->route_table->hook_add)
-							(route);
-				}
-				continue;
-
+				ospf6_intra_prefix_lsa_remove_update_route(
+							lsa, oa, route);
 			} else {
 
 				if (route->path.origin.type != lsa->header->type
@@ -1896,9 +1917,11 @@ void ospf6_intra_prefix_lsa_remove(struc
 				if (IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX)) {
 					prefix2str(&route->prefix, buf,
 						   sizeof(buf));
-					zlog_debug("route remove %s with path %u cost %u nh %u",
-						   buf, route->path.type,
+					zlog_debug("%s: route remove %s with path type %u cost %u paths %u nh %u",
+						   __PRETTY_FUNCTION__, buf,
+						   route->path.type,
 						   route->path.cost,
+						   listcount(route->paths),
 						   listcount(route->nh_list));
 				}
 				ospf6_route_remove(route, oa->route_table);
@@ -1906,8 +1929,6 @@ void ospf6_intra_prefix_lsa_remove(struc
 		}
 		if (route)
 			ospf6_route_unlock(route);
-
-		ospf6_route_delete(route_to_del);
 	}
 
 	if (current != end && IS_OSPF6_DEBUG_EXAMIN(INTRA_PREFIX))
@@ -2019,6 +2040,8 @@ static void ospf6_brouter_debug_print(st
 	zlog_info("  options: %s router-bits: %s metric-type: %d metric: %d/%d",
 		  options, capa, brouter->path.metric_type, brouter->path.cost,
 		  brouter->path.u.cost_e2);
+	zlog_info(" paths %u nh %u", listcount(brouter->paths),
+		   listcount(brouter->nh_list));
 }
 
 void ospf6_intra_brouter_calculation(struct ospf6_area *oa)
@@ -2029,8 +2052,10 @@ void ospf6_intra_brouter_calculation(str
 	uint32_t brouter_id;
 	char brouter_name[16];
 
-	if (IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(oa->area_id))
-		zlog_info("border-router calculation for area %s", oa->name);
+	if (IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(oa->area_id) ||
+	    IS_OSPF6_DEBUG_ROUTE(MEMORY))
+		zlog_info("%s: border-router calculation for area %s",
+			  __PRETTY_FUNCTION__, oa->name);
 
 	hook_add = oa->ospf6->brouter_table->hook_add;
 	hook_remove = oa->ospf6->brouter_table->hook_remove;
@@ -2096,6 +2121,7 @@ void ospf6_intra_brouter_calculation(str
 
 	for (brouter = ospf6_route_head(oa->ospf6->brouter_table); brouter;
 	     brouter = nbrouter) {
+
 		/*
 		 * brouter may have been "deleted" in the last loop iteration.
 		 * If this is the case there is still 1 final refcount lock
@@ -2104,6 +2130,8 @@ void ospf6_intra_brouter_calculation(str
 		 * skip processing the deleted route.
 		 */
 		if (brouter->lock == 1) {
+			if (IS_OSPF6_DEBUG_ROUTE(MEMORY))
+				ospf6_brouter_debug_print(brouter);
 			nbrouter = ospf6_route_next(brouter);
 			continue;
 		} else {
@@ -2155,8 +2183,14 @@ void ospf6_intra_brouter_calculation(str
 				       brouter_id)
 			    || IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(
 				       oa->area_id))
-				zlog_info("brouter %s disappears via area %s",
-					  brouter_name, oa->name);
+				zlog_info("%s: brouter %s disappears via area %s",
+					  __PRETTY_FUNCTION__, brouter_name,
+					  oa->name);
+			/* This is used to protect nbrouter from removed from
+			 * the table. For an example, ospf6_abr_examin_summary,
+			 * removes brouters which are marked for remove.
+			 */
+			oa->intra_brouter_calc = 1;
 			ospf6_route_remove(brouter, oa->ospf6->brouter_table);
 			brouter = NULL;
 		} else if (CHECK_FLAG(brouter->flag, OSPF6_ROUTE_ADD)
@@ -2166,8 +2200,9 @@ void ospf6_intra_brouter_calculation(str
 				       brouter_id)
 			    || IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(
 				       oa->area_id))
-				zlog_info("brouter %s appears via area %s",
-					  brouter_name, oa->name);
+				zlog_info("%s: brouter %s appears via area %s",
+					  __PRETTY_FUNCTION__, brouter_name,
+					  oa->name);
 
 			/* newly added */
 			if (hook_add)
@@ -2187,11 +2222,14 @@ void ospf6_intra_brouter_calculation(str
 			UNSET_FLAG(brouter->flag, OSPF6_ROUTE_ADD);
 			UNSET_FLAG(brouter->flag, OSPF6_ROUTE_CHANGE);
 		}
+		/* Reset for nbrouter */
+		oa->intra_brouter_calc = 0;
 	}
 
-	if (IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(oa->area_id))
-		zlog_info("border-router calculation for area %s: done",
-			  oa->name);
+	if (IS_OSPF6_DEBUG_BROUTER_SPECIFIC_AREA_ID(oa->area_id) ||
+	    IS_OSPF6_DEBUG_ROUTE(MEMORY))
+		zlog_info("%s: border-router calculation for area %s: done",
+			  __PRETTY_FUNCTION__, oa->name);
 }
 
 struct ospf6_lsa_handler router_handler = {.lh_type = OSPF6_LSTYPE_ROUTER,
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_message.c frr-frr-6.0/ospf6d/ospf6_message.c
--- frr-frr-5.0.1/ospf6d/ospf6_message.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_message.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,6 +26,7 @@
 #include "command.h"
 #include "thread.h"
 #include "linklist.h"
+#include "lib_errors.h"
 
 #include "ospf6_proto.h"
 #include "ospf6_lsa.h"
@@ -1503,14 +1504,6 @@ int ospf6_iobuf_size(unsigned int size)
 
 	recvnew = XMALLOC(MTYPE_OSPF6_MESSAGE, size);
 	sendnew = XMALLOC(MTYPE_OSPF6_MESSAGE, size);
-	if (recvnew == NULL || sendnew == NULL) {
-		if (recvnew)
-			XFREE(MTYPE_OSPF6_MESSAGE, recvnew);
-		if (sendnew)
-			XFREE(MTYPE_OSPF6_MESSAGE, sendnew);
-		zlog_debug("Could not allocate I/O buffer of size %d.", size);
-		return iobuflen;
-	}
 
 	if (recvbuf)
 		XFREE(MTYPE_OSPF6_MESSAGE, recvbuf);
@@ -1566,7 +1559,8 @@ int ospf6_receive(struct thread *thread)
 	/* receive message */
 	len = ospf6_recvmsg(&src, &dst, &ifindex, iovector);
 	if (len > iobuflen) {
-		zlog_err("Excess message read");
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "Excess message read");
 		return 0;
 	}
 
@@ -1714,7 +1708,7 @@ static void ospf6_send(struct in6_addr *
 	/* send message */
 	len = ospf6_sendmsg(src, dst, &oi->interface->ifindex, iovector);
 	if (len != ntohs(oh->length))
-		zlog_err("Could not send entire message");
+		flog_err(LIB_ERR_DEVELOPMENT, "Could not send entire message");
 }
 
 static uint32_t ospf6_packet_max(struct ospf6_interface *oi)
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_neighbor.c frr-frr-6.0/ospf6d/ospf6_neighbor.c
--- frr-frr-5.0.1/ospf6d/ospf6_neighbor.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_neighbor.c	2018-10-08 14:32:57.000000000 +0200
@@ -84,10 +84,6 @@ struct ospf6_neighbor *ospf6_neighbor_cr
 
 	on = (struct ospf6_neighbor *)XMALLOC(MTYPE_OSPF6_NEIGHBOR,
 					      sizeof(struct ospf6_neighbor));
-	if (on == NULL) {
-		zlog_warn("neighbor: malloc failed");
-		return NULL;
-	}
 
 	memset(on, 0, sizeof(struct ospf6_neighbor));
 	inet_ntop(AF_INET, &router_id, buf, sizeof(buf));
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_neighbor.h frr-frr-6.0/ospf6d/ospf6_neighbor.h
--- frr-frr-5.0.1/ospf6d/ospf6_neighbor.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_neighbor.h	2018-10-08 14:32:57.000000000 +0200
@@ -35,7 +35,7 @@ extern unsigned char conf_debug_ospf6_ne
 /* Neighbor structure */
 struct ospf6_neighbor {
 	/* Neighbor Router ID String */
-	char name[32];
+	char name[36];
 
 	/* OSPFv3 Interface this neighbor belongs to */
 	struct ospf6_interface *ospf6_if;
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_network.c frr-frr-6.0/ospf6d/ospf6_network.c
--- frr-frr-5.0.1/ospf6d/ospf6_network.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_network.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 #include "sockunion.h"
 #include "sockopt.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "libospf.h"
 #include "ospf6_proto.h"
@@ -75,18 +76,14 @@ static void ospf6_set_checksum(void)
 /* Make ospf6d's server socket. */
 int ospf6_serv_sock(void)
 {
-	if (ospf6d_privs.change(ZPRIVS_RAISE))
-		zlog_err("ospf6_serv_sock: could not raise privs");
+	frr_elevate_privs(&ospf6d_privs) {
 
-	ospf6_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_OSPFIGP);
-	if (ospf6_sock < 0) {
-		zlog_warn("Network: can't create OSPF6 socket.");
-		if (ospf6d_privs.change(ZPRIVS_LOWER))
-			zlog_err("ospf_sock_init: could not lower privs");
-		return -1;
+		ospf6_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_OSPFIGP);
+		if (ospf6_sock < 0) {
+			zlog_warn("Network: can't create OSPF6 socket.");
+			return -1;
+		}
 	}
-	if (ospf6d_privs.change(ZPRIVS_LOWER))
-		zlog_err("ospf_sock_init: could not lower privs");
 
 /* set socket options */
 #if 1
@@ -120,8 +117,10 @@ int ospf6_sso(ifindex_t ifindex, struct
 	ret = setsockopt(ospf6_sock, IPPROTO_IPV6, option, &mreq6,
 			 sizeof(mreq6));
 	if (ret < 0) {
-		zlog_err("Network: setsockopt (%d) on ifindex %d failed: %s",
-			 option, ifindex, safe_strerror(errno));
+		flog_err_sys(
+			LIB_ERR_SOCKET,
+			"Network: setsockopt (%d) on ifindex %d failed: %s",
+			option, ifindex, safe_strerror(errno));
 		return ret;
 	}
 
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_proto.c frr-frr-6.0/ospf6d/ospf6_proto.c
--- frr-frr-5.0.1/ospf6d/ospf6_proto.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_proto.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,16 @@
 
 #include "ospf6_proto.h"
 
+void ospf6_prefix_in6_addr(struct in6_addr *in6, const void *prefix_buf,
+			   const struct ospf6_prefix *p)
+{
+	ptrdiff_t in6_off = (caddr_t)p->addr - (caddr_t)prefix_buf;
+
+	memset(in6, 0, sizeof(struct in6_addr));
+	memcpy(in6, (uint8_t *)prefix_buf + in6_off,
+	       OSPF6_PREFIX_SPACE(p->prefix_length));
+}
+
 void ospf6_prefix_apply_mask(struct ospf6_prefix *op)
 {
 	uint8_t *pnt, mask;
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_proto.h frr-frr-6.0/ospf6d/ospf6_proto.h
--- frr-frr-5.0.1/ospf6d/ospf6_proto.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_proto.h	2018-10-08 14:32:57.000000000 +0200
@@ -84,13 +84,8 @@ struct ospf6_prefix {
 #define OSPF6_PREFIX_NEXT(x)                                                   \
 	((struct ospf6_prefix *)((caddr_t)(x) + OSPF6_PREFIX_SIZE(x)))
 
-#define ospf6_prefix_in6_addr(in6, op)                                         \
-	do {                                                                   \
-		memset(in6, 0, sizeof(struct in6_addr));                       \
-		memcpy(in6, (caddr_t)(op) + sizeof(struct ospf6_prefix),       \
-		       OSPF6_PREFIX_SPACE((op)->prefix_length));               \
-	} while (0)
-
+extern void ospf6_prefix_in6_addr(struct in6_addr *in6, const void *prefix_buf,
+				  const struct ospf6_prefix *p);
 extern void ospf6_prefix_apply_mask(struct ospf6_prefix *op);
 extern void ospf6_prefix_options_printbuf(uint8_t prefix_options, char *buf,
 					  int size);
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_route.c frr-frr-6.0/ospf6d/ospf6_route.c
--- frr-frr-5.0.1/ospf6d/ospf6_route.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_route.c	2018-10-08 14:32:57.000000000 +0200
@@ -574,8 +574,8 @@ static void route_table_assert(struct os
 	if (link_error == 0 && num == table->count)
 		return;
 
-	zlog_err("PANIC !!");
-	zlog_err("Something has gone wrong with ospf6_route_table[%p]", table);
+	flog_err(LIB_ERR_DEVELOPMENT, "PANIC !!");
+	flog_err(LIB_ERR_DEVELOPMENT, "Something has gone wrong with ospf6_route_table[%p]", table);
 	zlog_debug("table count = %d, real number = %d", table->count, num);
 	zlog_debug("DUMP START");
 	for (r = ospf6_route_head(table); r; r = ospf6_route_next(r)) {
@@ -611,9 +611,10 @@ struct ospf6_route *ospf6_route_add(stru
 		prefix2str(&route->prefix, buf, sizeof(buf));
 
 	if (IS_OSPF6_DEBUG_ROUTE(MEMORY))
-		zlog_debug("%s %p: route add %p: %s",
+		zlog_debug("%s %p: route add %p: %s paths %u nh %u",
 			   ospf6_route_table_name(table), (void *)table,
-			   (void *)route, buf);
+			   (void *)route, buf, listcount(route->paths),
+			   listcount(route->nh_list));
 	else if (IS_OSPF6_DEBUG_ROUTE(TABLE))
 		zlog_debug("%s: route add: %s", ospf6_route_table_name(table),
 			   buf);
@@ -664,11 +665,13 @@ struct ospf6_route *ospf6_route_add(stru
 
 		if (IS_OSPF6_DEBUG_ROUTE(MEMORY))
 			zlog_debug(
-				"%s %p: route add %p cost %u nh %u: update of %p old cost %u nh %u",
+				"%s %p: route add %p cost %u paths %u nh %u: update of %p cost %u paths %u nh %u",
 				ospf6_route_table_name(table), (void *)table,
 				(void *)route, route->path.cost,
+				listcount(route->paths),
 				listcount(route->nh_list), (void *)old,
-				old->path.cost, listcount(old->nh_list));
+				old->path.cost, listcount(old->paths),
+				listcount(old->nh_list));
 		else if (IS_OSPF6_DEBUG_ROUTE(TABLE))
 			zlog_debug("%s: route add: update",
 				   ospf6_route_table_name(table));
@@ -922,10 +925,11 @@ struct ospf6_route *ospf6_route_next(str
 	struct ospf6_route *next = route->next;
 
 	if (IS_OSPF6_DEBUG_ROUTE(MEMORY))
-		zlog_info("%s %p: route next: %p<-[%p]->%p",
+		zlog_info("%s %p: route next: %p<-[%p]->%p , route ref count %u",
 			  ospf6_route_table_name(route->table),
 			  (void *)route->table, (void *)route->prev,
-			  (void *)route, (void *)route->next);
+			  (void *)route, (void *)route->next,
+			  route->lock);
 
 	ospf6_route_unlock(route);
 	if (next)
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_route.h frr-frr-6.0/ospf6d/ospf6_route.h
--- frr-frr-5.0.1/ospf6d/ospf6_route.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_route.h	2018-10-08 14:32:57.000000000 +0200
@@ -91,6 +91,9 @@ struct ospf6_path {
 	/* Cost */
 	uint8_t metric_type;
 	uint32_t cost;
+
+	struct prefix ls_prefix;
+
 	union {
 		uint32_t cost_e2;
 		uint32_t cost_config;
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_spf.c frr-frr-6.0/ospf6d/ospf6_spf.c
--- frr-frr-5.0.1/ospf6d/ospf6_spf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_spf.c	2018-10-08 14:32:57.000000000 +0200
@@ -30,6 +30,7 @@
 #include "pqueue.h"
 #include "linklist.h"
 #include "thread.h"
+#include "lib_errors.h"
 
 #include "ospf6_lsa.h"
 #include "ospf6_lsdb.h"
@@ -272,7 +273,8 @@ static void ospf6_nexthop_calc(struct os
 	ifindex = (VERTEX_IS_TYPE(NETWORK, v) ? ospf6_spf_get_ifindex_from_nh(v)
 					      : ROUTER_LSDESC_GET_IFID(lsdesc));
 	if (ifindex == 0) {
-		zlog_err("No nexthop ifindex at vertex %s", v->name);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "No nexthop ifindex at vertex %s", v->name);
 		return;
 	}
 
@@ -677,6 +679,10 @@ void ospf6_spf_schedule(struct ospf6 *os
 {
 	unsigned long delay, elapsed, ht;
 
+	/* OSPF instance does not exist. */
+	if (ospf6 == NULL)
+		return;
+
 	ospf6_set_spf_reason(ospf6, reason);
 
 	if (IS_OSPF6_DEBUG_SPF(PROCESS) || IS_OSPF6_DEBUG_SPF(TIME)) {
@@ -686,10 +692,6 @@ void ospf6_spf_schedule(struct ospf6 *os
 			   rbuf);
 	}
 
-	/* OSPF instance does not exist. */
-	if (ospf6 == NULL)
-		return;
-
 	/* SPF calculation timer is already scheduled. */
 	if (ospf6->t_spf_calc) {
 		if (IS_OSPF6_DEBUG_SPF(PROCESS) || IS_OSPF6_DEBUG_SPF(TIME))
@@ -1012,16 +1014,10 @@ struct ospf6_lsa *ospf6_create_single_ro
 
 	/* Allocate memory for this LSA */
 	new_header = XMALLOC(MTYPE_OSPF6_LSA_HEADER, total_lsa_length);
-	if (!new_header)
-		return NULL;
 
 	/* LSA information structure */
 	lsa = (struct ospf6_lsa *)XCALLOC(MTYPE_OSPF6_LSA,
 					  sizeof(struct ospf6_lsa));
-	if (!lsa) {
-		free(new_header);
-		return NULL;
-	}
 
 	lsa->header = (struct ospf6_lsa_header *)new_header;
 
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_top.c frr-frr-6.0/ospf6d/ospf6_top.c
--- frr-frr-5.0.1/ospf6d/ospf6_top.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_top.c	2018-10-08 14:32:57.000000000 +0200
@@ -97,7 +97,8 @@ static void ospf6_top_route_hook_remove(
 
 static void ospf6_top_brouter_hook_add(struct ospf6_route *route)
 {
-	if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL)) {
+	if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL) ||
+	    IS_OSPF6_DEBUG_BROUTER) {
 		uint32_t brouter_id;
 		char brouter_name[16];
 
@@ -116,15 +117,17 @@ static void ospf6_top_brouter_hook_add(s
 
 static void ospf6_top_brouter_hook_remove(struct ospf6_route *route)
 {
-	if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL)) {
+	if (IS_OSPF6_DEBUG_EXAMIN(AS_EXTERNAL) ||
+	    IS_OSPF6_DEBUG_BROUTER) {
 		uint32_t brouter_id;
 		char brouter_name[16];
 
 		brouter_id = ADV_ROUTER_IN_PREFIX(&route->prefix);
 		inet_ntop(AF_INET, &brouter_id, brouter_name,
 			  sizeof(brouter_name));
-		zlog_debug("%s: brouter %s del with nh count %u",
-			   __PRETTY_FUNCTION__, brouter_name,
+		zlog_debug("%s: brouter %p %s del with adv router %x nh %u",
+			   __PRETTY_FUNCTION__, (void *)route, brouter_name,
+			   route->path.origin.adv_router,
 			   listcount(route->nh_list));
 	}
 	route->flag |= OSPF6_ROUTE_REMOVE;
@@ -422,13 +425,13 @@ DEFUN(no_ospf6_router_id,
 	return CMD_SUCCESS;
 }
 
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180828
+#if CONFDATE > 20180828
 CPP_NOTICE("ospf6: `router-id A.B.C.D` deprecated 2017/08/28")
 #endif
 ALIAS_HIDDEN(ospf6_router_id, ospf6_router_id_hdn_cmd, "router-id A.B.C.D",
 	     "Configure OSPF6 Router-ID\n" V4NOTATION_STR)
 
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180828
+#if CONFDATE > 20180828
 CPP_NOTICE("ospf6: `no router-id A.B.C.D` deprecated 2017/08/28")
 #endif
 ALIAS_HIDDEN(no_ospf6_router_id, no_ospf6_router_id_hdn_cmd,
diff -urpN frr-frr-5.0.1/ospf6d/ospf6_zebra.c frr-frr-6.0/ospf6d/ospf6_zebra.c
--- frr-frr-5.0.1/ospf6d/ospf6_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@
 #include "zclient.h"
 #include "memory.h"
 #include "lib/bfd.h"
+#include "lib_errors.h"
 
 #include "ospf6_proto.h"
 #include "ospf6_top.h"
@@ -362,9 +363,10 @@ static void ospf6_zebra_route_update(int
 		ret = zclient_route_send(ZEBRA_ROUTE_ADD, zclient, &api);
 
 	if (ret < 0)
-		zlog_err("zclient_route_send() %s failed: %s",
-			 (type == REM ? "delete" : "add"),
-			 safe_strerror(errno));
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "zclient_route_send() %s failed: %s",
+			  (type == REM ? "delete" : "add"),
+			  safe_strerror(errno));
 
 	return;
 }
diff -urpN frr-frr-5.0.1/ospf6d/ospf6d.c frr-frr-6.0/ospf6d/ospf6d.c
--- frr-frr-5.0.1/ospf6d/ospf6d.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/ospf6d.c	2018-10-08 14:32:57.000000000 +0200
@@ -97,7 +97,7 @@ DEFUN_NOSH (show_debugging_ospf6,
 	    DEBUG_STR
 	    OSPF6_STR)
 {
-	vty_out(vty, "OSPF6 debugging status:");
+	vty_out(vty, "OSPF6 debugging status:\n");
 
 	config_write_ospf6_debug(vty);
 
diff -urpN frr-frr-5.0.1/ospf6d/subdir.am frr-frr-6.0/ospf6d/subdir.am
--- frr-frr-5.0.1/ospf6d/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospf6d/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -61,6 +61,6 @@ ospf6d_ospf6d_SOURCES = \
 	# end
 
 ospf6d_ospf6d_snmp_la_SOURCES = ospf6d/ospf6_snmp.c
-ospf6d_ospf6d_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+ospf6d_ospf6d_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 ospf6d_ospf6d_snmp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 ospf6d_ospf6d_snmp_la_LIBADD = lib/libfrrsnmp.la
diff -urpN frr-frr-5.0.1/ospfclient/ospf_apiclient.c frr-frr-6.0/ospfclient/ospf_apiclient.c
--- frr-frr-5.0.1/ospfclient/ospf_apiclient.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfclient/ospf_apiclient.c	2018-10-08 14:32:57.000000000 +0200
@@ -46,6 +46,7 @@
 #include "ospfd/ospf_lsdb.h"
 #include "ospfd/ospf_neighbor.h"
 #include "ospfd/ospf_dump.h"
+#include "ospfd/ospf_route.h"
 #include "ospfd/ospf_zebra.h"
 #include "ospfd/ospf_api.h"
 
@@ -570,10 +571,7 @@ static void ospf_apiclient_handle_lsa_up
 	/* Extract LSA from message */
 	lsalen = ntohs(cn->data.length);
 	lsa = XMALLOC(MTYPE_OSPF_APICLIENT, lsalen);
-	if (!lsa) {
-		fprintf(stderr, "LSA update: Cannot allocate memory for LSA\n");
-		return;
-	}
+
 	memcpy(lsa, &(cn->data), lsalen);
 
 	/* Invoke registered update callback function */
@@ -598,10 +596,7 @@ static void ospf_apiclient_handle_lsa_de
 	/* Extract LSA from message */
 	lsalen = ntohs(cn->data.length);
 	lsa = XMALLOC(MTYPE_OSPF_APICLIENT, lsalen);
-	if (!lsa) {
-		fprintf(stderr, "LSA delete: Cannot allocate memory for LSA\n");
-		return;
-	}
+
 	memcpy(lsa, &(cn->data), lsalen);
 
 	/* Invoke registered update callback function */
diff -urpN frr-frr-5.0.1/ospfd/ospf_api.c frr-frr-6.0/ospfd/ospf_api.c
--- frr-frr-5.0.1/ospfd/ospf_api.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_api.c	2018-10-08 14:32:57.000000000 +0200
@@ -510,17 +510,18 @@ struct msg *new_msg_originate_request(ui
 	struct msg_originate_request *omsg;
 	unsigned int omsglen;
 	char buf[OSPF_API_MAX_MSG_SIZE];
+	size_t off_data = offsetof(struct msg_originate_request, data);
+	size_t data_maxs = sizeof(buf) - off_data;
+	struct lsa_header *omsg_data = (struct lsa_header *)&buf[off_data];
 
 	omsg = (struct msg_originate_request *)buf;
 	omsg->ifaddr = ifaddr;
 	omsg->area_id = area_id;
 
 	omsglen = ntohs(data->length);
-	if (omsglen
-	    > sizeof(buf) - offsetof(struct msg_originate_request, data))
-		omsglen = sizeof(buf)
-			  - offsetof(struct msg_originate_request, data);
-	memcpy(&omsg->data, data, omsglen);
+	if (omsglen > data_maxs)
+		omsglen = data_maxs;
+	memcpy(omsg_data, data, omsglen);
 	omsglen += sizeof(struct msg_originate_request)
 		   - sizeof(struct lsa_header);
 
@@ -630,6 +631,9 @@ struct msg *new_msg_lsa_change_notify(ui
 	uint8_t buf[OSPF_API_MAX_MSG_SIZE];
 	struct msg_lsa_change_notify *nmsg;
 	unsigned int len;
+	size_t off_data = offsetof(struct msg_lsa_change_notify, data);
+	size_t data_maxs = sizeof(buf) - off_data;
+	struct lsa_header *nmsg_data = (struct lsa_header *)&buf[off_data];
 
 	assert(data);
 
@@ -640,10 +644,9 @@ struct msg *new_msg_lsa_change_notify(ui
 	memset(&nmsg->pad, 0, sizeof(nmsg->pad));
 
 	len = ntohs(data->length);
-	if (len > sizeof(buf) - offsetof(struct msg_lsa_change_notify, data))
-		len = sizeof(buf)
-		      - offsetof(struct msg_lsa_change_notify, data);
-	memcpy(&nmsg->data, data, len);
+	if (len > data_maxs)
+		len = data_maxs;
+	memcpy(nmsg_data, data, len);
 	len += sizeof(struct msg_lsa_change_notify) - sizeof(struct lsa_header);
 
 	return msg_new(msgtype, nmsg, seqnum, len);
diff -urpN frr-frr-5.0.1/ospfd/ospf_apiserver.c frr-frr-6.0/ospfd/ospf_apiserver.c
--- frr-frr-5.0.1/ospfd/ospf_apiserver.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_apiserver.c	2018-10-08 14:32:57.000000000 +0200
@@ -1176,13 +1176,11 @@ int ospf_apiserver_handle_register_event
 
 	apiserv->filter =
 		XMALLOC(MTYPE_OSPF_APISERVER_MSGFILTER, ntohs(msg->hdr.msglen));
-	if (apiserv->filter) {
-		/* copy it over. */
-		memcpy(apiserv->filter, &rmsg->filter, ntohs(msg->hdr.msglen));
-		rc = OSPF_API_OK;
-	} else {
-		rc = OSPF_API_NOMEMORY;
-	}
+
+	/* copy it over. */
+	memcpy(apiserv->filter, &rmsg->filter, ntohs(msg->hdr.msglen));
+	rc = OSPF_API_OK;
+
 	/* Send a reply back to client with return code */
 	rc = ospf_apiserver_send_reply(apiserv, seqnum, rc);
 	return rc;
@@ -1427,19 +1425,7 @@ struct ospf_lsa *ospf_apiserver_opaque_l
 	newlsa->length = htons(length);
 
 	/* Create OSPF LSA. */
-	if ((new = ospf_lsa_new()) == NULL) {
-		zlog_warn("ospf_apiserver_opaque_lsa_new: ospf_lsa_new() ?");
-		stream_free(s);
-		return NULL;
-	}
-
-	if ((new->data = ospf_lsa_data_new(length)) == NULL) {
-		zlog_warn(
-			"ospf_apiserver_opaque_lsa_new: ospf_lsa_data_new() ?");
-		ospf_lsa_unlock(&new);
-		stream_free(s);
-		return NULL;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	new->area = area;
 	new->oi = oi;
@@ -1741,6 +1727,8 @@ struct ospf_lsa *ospf_apiserver_lsa_refr
 	struct ospf_lsa *new = NULL;
 	struct ospf *ospf;
 
+	assert(lsa);
+
 	ospf = ospf_lookup_by_vrf_id(VRF_DEFAULT);
 	assert(ospf);
 
@@ -1751,6 +1739,7 @@ struct ospf_lsa *ospf_apiserver_lsa_refr
 			dump_lsa_key(lsa));
 		lsa->data->ls_age =
 			htons(OSPF_LSA_MAXAGE); /* Flush it anyway. */
+		goto out;
 	}
 
 	if (IS_LSA_MAXAGE(lsa)) {
diff -urpN frr-frr-5.0.1/ospfd/ospf_asbr.c frr-frr-6.0/ospfd/ospf_asbr.c
--- frr-frr-5.0.1/ospfd/ospf_asbr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_asbr.c	2018-10-08 14:32:57.000000000 +0200
@@ -73,26 +73,6 @@ void ospf_external_route_remove(struct o
 		  p->prefixlen);
 }
 
-/* Lookup external route. */
-struct ospf_route *ospf_external_route_lookup(struct ospf *ospf,
-					      struct prefix_ipv4 *p)
-{
-	struct route_node *rn;
-
-	rn = route_node_lookup(ospf->old_external_route, (struct prefix *)p);
-	if (rn) {
-		route_unlock_node(rn);
-		if (rn->info)
-			return rn->info;
-	}
-
-	zlog_warn("Route[%s/%d]: lookup, no such prefix", inet_ntoa(p->prefix),
-		  p->prefixlen);
-
-	return NULL;
-}
-
-
 /* Add an External info for AS-external-LSA. */
 struct external_info *ospf_external_info_new(uint8_t type,
 					     unsigned short instance)
diff -urpN frr-frr-5.0.1/ospfd/ospf_asbr.h frr-frr-6.0/ospfd/ospf_asbr.h
--- frr-frr-5.0.1/ospfd/ospf_asbr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_asbr.h	2018-10-08 14:32:57.000000000 +0200
@@ -68,8 +68,6 @@ extern void ospf_external_info_delete(st
 extern struct external_info *ospf_external_info_lookup(struct ospf *, uint8_t,
 						       unsigned short,
 						       struct prefix_ipv4 *);
-extern struct ospf_route *ospf_external_route_lookup(struct ospf *,
-						     struct prefix_ipv4 *);
 extern void ospf_asbr_status_update(struct ospf *, uint8_t);
 
 extern void ospf_redistribute_withdraw(struct ospf *, uint8_t, unsigned short);
diff -urpN frr-frr-5.0.1/ospfd/ospf_ase.c frr-frr-6.0/ospfd/ospf_ase.c
--- frr-frr-5.0.1/ospfd/ospf_ase.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_ase.c	2018-10-08 14:32:57.000000000 +0200
@@ -288,6 +288,7 @@ int ospf_ase_calculate_route(struct ospf
 	struct prefix_ipv4 asbr, p;
 	struct route_node *rn;
 	struct ospf_route *new, * or ;
+	char buf1[INET_ADDRSTRLEN];
 	int ret;
 
 	assert(lsa);
@@ -304,10 +305,14 @@ int ospf_ase_calculate_route(struct ospf
 		return 0;
 	}
 
-	if (IS_DEBUG_OSPF(lsa, LSA))
+	if (IS_DEBUG_OSPF(lsa, LSA)) {
+		snprintf(buf1, INET_ADDRSTRLEN, "%s",
+			 inet_ntoa(al->header.adv_router));
 		zlog_debug(
-			"Route[External]: Calculate AS-external-LSA to %s/%d",
-			inet_ntoa(al->header.id), ip_masklen(al->mask));
+			"Route[External]: Calculate AS-external-LSA to %s/%d adv_router %s",
+			inet_ntoa(al->header.id), ip_masklen(al->mask), buf1);
+	}
+
 	/* (1) If the cost specified by the LSA is LSInfinity, or if the
 	       LSA's LS age is equal to MaxAge, then examine the next LSA. */
 	if ((metric = GET_METRIC(al->e[0].metric)) >= OSPF_LS_INFINITY) {
@@ -459,8 +464,9 @@ int ospf_ase_calculate_route(struct ospf
 
 	if (!rn || (or = rn->info) == NULL) {
 		if (IS_DEBUG_OSPF(lsa, LSA))
-			zlog_debug("Route[External]: Adding a new route %s/%d",
-				   inet_ntoa(p.prefix), p.prefixlen);
+			zlog_debug("Route[External]: Adding a new route %s/%d with paths %u",
+				   inet_ntoa(p.prefix), p.prefixlen,
+				   listcount(asbr_route->paths));
 
 		ospf_route_add(ospf->new_external_route, &p, new, asbr_route);
 
@@ -543,7 +549,7 @@ static int ospf_ase_route_match_same(str
 				     struct ospf_route *newor)
 {
 	struct route_node *rn;
-	struct ospf_route * or ;
+	struct ospf_route *or;
 	struct ospf_path *op;
 	struct ospf_path *newop;
 	struct listnode *n1;
@@ -559,6 +565,9 @@ static int ospf_ase_route_match_same(str
 	route_unlock_node(rn);
 
 	or = rn->info;
+
+	assert(or);
+
 	if (or->path_type != newor->path_type)
 		return 0;
 
@@ -577,12 +586,14 @@ static int ospf_ase_route_match_same(str
 		return 0;
 	}
 
+	assert(or->paths);
+
 	if (or->paths->count != newor->paths->count)
 		return 0;
 
 	/* Check each path. */
 	for (n1 = listhead(or->paths), n2 = listhead(newor->paths); n1 && n2;
-	     n1 = listnextnode(n1), n2 = listnextnode(n2)) {
+	     n1 = listnextnode_unchecked(n1), n2 = listnextnode_unchecked(n2)) {
 		op = listgetdata(n1);
 		newop = listgetdata(n2);
 
diff -urpN frr-frr-5.0.1/ospfd/ospf_bfd.c frr-frr-6.0/ospfd/ospf_bfd.c
--- frr-frr-5.0.1/ospfd/ospf_bfd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_bfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -290,17 +290,21 @@ void ospf_bfd_info_nbr_create(struct osp
 void ospf_bfd_write_config(struct vty *vty, struct ospf_if_params *params)
 
 {
+#if HAVE_BFDD == 0
 	struct bfd_info *bfd_info;
+#endif /* ! HAVE_BFDD */
 
 	if (!params->bfd_info)
 		return;
 
+#if HAVE_BFDD == 0
 	bfd_info = (struct bfd_info *)params->bfd_info;
 
 	if (CHECK_FLAG(bfd_info->flags, BFD_FLAG_PARAM_CFG))
 		vty_out(vty, " ip ospf bfd %d %d %d\n", bfd_info->detect_mult,
 			bfd_info->required_min_rx, bfd_info->desired_min_tx);
 	else
+#endif /* ! HAVE_BFDD */
 		vty_out(vty, " ip ospf bfd\n");
 }
 
@@ -373,7 +377,12 @@ DEFUN (ip_ospf_bfd,
 	return CMD_SUCCESS;
 }
 
-DEFUN (ip_ospf_bfd_param,
+#if HAVE_BFDD > 0
+DEFUN_HIDDEN(
+#else
+DEFUN(
+#endif /* HAVE_BFDD */
+       ip_ospf_bfd_param,
        ip_ospf_bfd_param_cmd,
        "ip ospf bfd (2-255) (50-60000) (50-60000)",
        "IP Information\n"
@@ -407,14 +416,21 @@ DEFUN (ip_ospf_bfd_param,
 
 DEFUN (no_ip_ospf_bfd,
        no_ip_ospf_bfd_cmd,
+#if HAVE_BFDD > 0
+       "no ip ospf bfd",
+#else
        "no ip ospf bfd [(2-255) (50-60000) (50-60000)]",
+#endif /* HAVE_BFDD */
        NO_STR
        "IP Information\n"
        "OSPF interface commands\n"
        "Disables BFD support\n"
+#if HAVE_BFDD == 0
        "Detect Multiplier\n"
        "Required min receive interval\n"
-       "Desired min transmit interval\n")
+       "Desired min transmit interval\n"
+#endif /* !HAVE_BFDD */
+)
 {
 	VTY_DECLVAR_CONTEXT(interface, ifp);
 	struct ospf_if_params *params;
diff -urpN frr-frr-5.0.1/ospfd/ospf_dump.c frr-frr-6.0/ospfd/ospf_dump.c
--- frr-frr-5.0.1/ospfd/ospf_dump.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_dump.c	2018-10-08 14:32:57.000000000 +0200
@@ -146,8 +146,6 @@ void ospf_nbr_state_message(struct ospf_
 	else
 		state = ISM_DROther;
 
-	memset(buf, 0, size);
-
 	snprintf(buf, size, "%s/%s",
 		 lookup_msg(ospf_nsm_state_msg, nbr->state, NULL),
 		 lookup_msg(ospf_ism_state_msg, state, NULL));
@@ -201,17 +199,17 @@ const char *ospf_timeval_dump(struct tim
 	}
 
 	if (w > 99)
-		snprintf(buf, size, "%ldw%1ldd", w, d);
+		snprintf(buf, size, "%luw%1lud", w, d);
 	else if (w)
-		snprintf(buf, size, "%ldw%1ldd%02ldh", w, d, h);
+		snprintf(buf, size, "%luw%1lud%02luh", w, d, h);
 	else if (d)
-		snprintf(buf, size, "%1ldd%02ldh%02ldm", d, h, m);
+		snprintf(buf, size, "%1lud%02luh%02lum", d, h, m);
 	else if (h)
-		snprintf(buf, size, "%ldh%02ldm%02lds", h, m, (long)t->tv_sec);
+		snprintf(buf, size, "%luh%02lum%02lds", h, m, (long)t->tv_sec);
 	else if (m)
-		snprintf(buf, size, "%ldm%02lds", m, (long)t->tv_sec);
+		snprintf(buf, size, "%lum%02lds", m, (long)t->tv_sec);
 	else if (ms)
-		snprintf(buf, size, "%ld.%03lds", (long)t->tv_sec, ms);
+		snprintf(buf, size, "%ld.%03lus", (long)t->tv_sec, ms);
 	else
 		snprintf(buf, size, "%ld usecs", (long)t->tv_usec);
 
@@ -254,8 +252,6 @@ static void ospf_packet_hello_dump(struc
 
 static char *ospf_dd_flags_dump(uint8_t flags, char *buf, size_t size)
 {
-	memset(buf, 0, size);
-
 	snprintf(buf, size, "%s|%s|%s", (flags & OSPF_DD_FLAG_I) ? "I" : "-",
 		 (flags & OSPF_DD_FLAG_M) ? "M" : "-",
 		 (flags & OSPF_DD_FLAG_MS) ? "MS" : "-");
@@ -265,8 +261,6 @@ static char *ospf_dd_flags_dump(uint8_t
 
 static char *ospf_router_lsa_flags_dump(uint8_t flags, char *buf, size_t size)
 {
-	memset(buf, 0, size);
-
 	snprintf(buf, size, "%s|%s|%s",
 		 (flags & ROUTER_LSA_VIRTUAL) ? "V" : "-",
 		 (flags & ROUTER_LSA_EXTERNAL) ? "E" : "-",
@@ -1689,7 +1683,7 @@ static int config_write_debug(struct vty
 		return CMD_SUCCESS;
 
 	if (ospf->instance)
-		sprintf(str, " %d", ospf->instance);
+		sprintf(str, " %u", ospf->instance);
 
 	/* debug ospf ism (status|events|timers). */
 	if (IS_CONF_DEBUG_OSPF(ism, ISM) == OSPF_DEBUG_ISM)
diff -urpN frr-frr-5.0.1/ospfd/ospf_errors.c frr-frr-6.0/ospfd/ospf_errors.c
--- frr-frr-5.0.1/ospfd/ospf_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/ospfd/ospf_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+ * OSPF-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *		Chirag Shah
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "ospf_errors.h"
+
+static struct log_ref ferr_ospf_err[] = {
+	{
+		.code = OSPF_ERR_PKT_PROCESS,
+		.title = "Failure to process a packet",
+		.description = "OSPF attempted to process a received packet but could not",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_ROUTER_LSA_MISMATCH,
+		.title = "Failure to process Router LSA",
+		.description = "OSPF attempted to process a Router LSA but Advertising ID mismatch with link id",
+		.suggestion = "Check OSPF network config for any config issue, If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_DOMAIN_CORRUPT,
+		.title = "OSPF Domain Corruption",
+		.description = "OSPF attempted to process a Router LSA but Advertising ID mismatch with link id",
+		.suggestion = "Check OSPF network Database for corrupted LSA, If the problem persists, shutdown OSPF domain and report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_INIT_FAIL,
+		.title = "OSPF Initialization failure",
+		.description = "OSPF failed to initialized OSPF default insance",
+		.suggestion = "Ensure there is adequate memory on the device. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_SR_INVALID_DB,
+		.title = "OSPF SR Invalid DB",
+		.description = "OSPF Segment Routing Database is invalid",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_SR_NODE_CREATE,
+		.title = "OSPF SR hash node creation failed",
+		.description = "OSPF Segment Routing node creation failed",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_SR_INVALID_LSA_ID,
+		.title = "OSPF SR Invalid LSA ID",
+		.description = "OSPF Segment Routing invalid lsa id",
+		.suggestion = "Restart OSPF instance, If the problem persists, report the problem for troubleshooting"
+	},
+	{
+		.code = OSPF_ERR_SR_INVALID_ALGORITHM,
+		.title = "OSPF SR Invalid Algorithm",
+		.description = "OSPF Segment Routing invalid Algorithm",
+		.suggestion = "Most likely a bug. If the problem persists, report the problem for troubleshooting"
+	},
+
+	{
+		.code = END_FERR,
+	}
+};
+
+void ospf_error_init(void)
+{
+	log_ref_add(ferr_ospf_err);
+}
diff -urpN frr-frr-5.0.1/ospfd/ospf_errors.h frr-frr-6.0/ospfd/ospf_errors.h
--- frr-frr-5.0.1/ospfd/ospf_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/ospfd/ospf_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * OSPF-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *		Chirag Shah
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __OSPF_ERRORS_H__
+#define __OSPF_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum ospf_log_refs {
+	OSPF_ERR_PKT_PROCESS = OSPF_FERR_START,
+	OSPF_ERR_ROUTER_LSA_MISMATCH,
+	OSPF_ERR_DOMAIN_CORRUPT,
+	OSPF_ERR_INIT_FAIL,
+	OSPF_ERR_SR_INVALID_DB,
+	OSPF_ERR_SR_NODE_CREATE,
+	OSPF_ERR_SR_INVALID_LSA_ID,
+	OSPF_ERR_SR_INVALID_ALGORITHM,
+};
+
+extern void ospf_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/ospfd/ospf_ext.c frr-frr-6.0/ospfd/ospf_ext.c
--- frr-frr-5.0.1/ospfd/ospf_ext.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_ext.c	2018-10-08 14:32:57.000000000 +0200
@@ -545,11 +545,6 @@ static int ospf_ext_link_new_if(struct i
 	}
 
 	new = XCALLOC(MTYPE_OSPF_EXT_PARAMS, sizeof(struct ext_itf));
-	if (new == NULL) {
-		zlog_warn("EXT (%s): XCALLOC: %s", __func__,
-			  safe_strerror(errno));
-		return rc;
-	}
 
 	/* initialize new information and link back the interface */
 	new->ifp = ifp;
@@ -982,20 +977,7 @@ static struct ospf_lsa *ospf_ext_pref_ls
 	lsah->length = htons(length);
 
 	/* Now, create an OSPF LSA instance. */
-	new = ospf_lsa_new();
-	if (new == NULL) {
-		zlog_warn("EXT (%s): ospf_lsa_new() error", __func__);
-		stream_free(s);
-		return NULL;
-	}
-	new->data = ospf_lsa_data_new(length);
-	if (new->data == NULL) {
-		zlog_warn("EXT (%s): ospf_lsa_data_new() error", __func__);
-		ospf_lsa_unlock(&new);
-		new = NULL;
-		stream_free(s);
-		return NULL;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	/* Segment Routing belongs only to default VRF */
 	new->vrf_id = VRF_DEFAULT;
@@ -1061,20 +1043,7 @@ static struct ospf_lsa *ospf_ext_link_ls
 	lsah->length = htons(length);
 
 	/* Now, create an OSPF LSA instance. */
-	new = ospf_lsa_new();
-	if (new == NULL) {
-		zlog_warn("EXT (%s): ospf_lsa_new() error", __func__);
-		stream_free(s);
-		return NULL;
-	}
-	new->data = ospf_lsa_data_new(length);
-	if (new->data == NULL) {
-		zlog_warn("EXT (%s): ospf_lsa_data_new() error", __func__);
-		ospf_lsa_unlock(&new);
-		new = NULL;
-		stream_free(s);
-		return NULL;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	/* Segment Routing belongs only to default VRF */
 	new->vrf_id = VRF_DEFAULT;
@@ -1125,7 +1094,7 @@ static int ospf_ext_pref_lsa_originate1(
 	if (IS_DEBUG_OSPF(lsa, LSA_GENERATE)) {
 		char area_id[INET_ADDRSTRLEN];
 
-		strncpy(area_id, inet_ntoa(area->area_id), INET_ADDRSTRLEN);
+		inet_ntop(AF_INET, &area->area_id, area_id, sizeof(area_id));
 		zlog_debug(
 			"EXT (%s): LSA[Type%u:%s]: Originate Opaque-LSA "
 			"Extended Prefix Opaque LSA: Area(%s), Link(%s)",
@@ -1175,7 +1144,7 @@ static int ospf_ext_link_lsa_originate1(
 	if (IS_DEBUG_OSPF(lsa, LSA_GENERATE)) {
 		char area_id[INET_ADDRSTRLEN];
 
-		strncpy(area_id, inet_ntoa(area->area_id), INET_ADDRSTRLEN);
+		inet_ntop(AF_INET, &area->area_id, area_id, sizeof(area_id));
 		zlog_debug(
 			"EXT (%s): LSA[Type%u:%s]: Originate Opaque-LSA "
 			"Extended Link Opaque LSA: Area(%s), Link(%s)",
diff -urpN frr-frr-5.0.1/ospfd/ospf_flood.c frr-frr-6.0/ospfd/ospf_flood.c
--- frr-frr-5.0.1/ospfd/ospf_flood.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_flood.c	2018-10-08 14:32:57.000000000 +0200
@@ -91,7 +91,7 @@ struct external_info *ospf_external_info
 	p.prefix = lsa->data->id;
 	p.prefixlen = ip_masklen(al->mask);
 
-	for (type = 0; type <= ZEBRA_ROUTE_MAX; type++) {
+	for (type = 0; type < ZEBRA_ROUTE_MAX; type++) {
 		int redist_on = 0;
 
 		redist_on =
@@ -319,7 +319,7 @@ int ospf_flood(struct ospf *ospf, struct
 
 	/* Do some internal house keeping that is needed here */
 	SET_FLAG(new->flags, OSPF_LSA_RECEIVED);
-	ospf_lsa_is_self_originated(ospf, new); /* Let it set the flag */
+	(void)ospf_lsa_is_self_originated(ospf, new); /* Let it set the flag */
 
 	/* Install the new LSA in the link state database
 	   (replacing the current database copy).  This may cause the
@@ -810,8 +810,7 @@ struct ospf_lsa *ospf_ls_request_new(str
 {
 	struct ospf_lsa *new;
 
-	new = ospf_lsa_new();
-	new->data = ospf_lsa_data_new(OSPF_LSA_HEADER_SIZE);
+	new = ospf_lsa_new_and_data(OSPF_LSA_HEADER_SIZE);
 	memcpy(new->data, lsah, OSPF_LSA_HEADER_SIZE);
 
 	return new;
diff -urpN frr-frr-5.0.1/ospfd/ospf_interface.c frr-frr-6.0/ospfd/ospf_interface.c
--- frr-frr-5.0.1/ospfd/ospf_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -263,6 +263,9 @@ struct ospf_interface *ospf_if_new(struc
 	ospf_opaque_type9_lsa_init(oi);
 
 	oi->ospf = ospf;
+
+	ospf_if_stream_set(oi);
+
 	QOBJ_REG(oi, ospf_interface);
 
 	if (IS_DEBUG_OSPF_EVENT)
@@ -322,6 +325,9 @@ void ospf_if_free(struct ospf_interface
 {
 	ospf_if_down(oi);
 
+	if (oi->obuf)
+		ospf_fifo_free(oi->obuf);
+
 	assert(oi->state == ISM_Down);
 
 	ospf_opaque_type9_lsa_term(oi);
@@ -496,9 +502,8 @@ void ospf_if_stream_unset(struct ospf_in
 	struct ospf *ospf = oi->ospf;
 
 	if (oi->obuf) {
-		ospf_fifo_free(oi->obuf);
-		oi->obuf = NULL;
-
+		/* flush the interface packet queue */
+		ospf_fifo_flush(oi->obuf);
 		/*reset protocol stats */
 		ospf_if_reset_stats(oi);
 
@@ -518,9 +523,6 @@ static struct ospf_if_params *ospf_new_i
 
 	oip = XCALLOC(MTYPE_OSPF_IF_PARAMS, sizeof(struct ospf_if_params));
 
-	if (!oip)
-		return NULL;
-
 	UNSET_IF_PARAM(oip, output_cost_cmd);
 	UNSET_IF_PARAM(oip, transmit_delay);
 	UNSET_IF_PARAM(oip, retransmit_interval);
@@ -781,7 +783,6 @@ int ospf_if_up(struct ospf_interface *oi
 	if (oi->type == OSPF_IFTYPE_LOOPBACK)
 		OSPF_ISM_EVENT_SCHEDULE(oi, ISM_LoopInd);
 	else {
-		ospf_if_stream_set(oi);
 		OSPF_ISM_EVENT_SCHEDULE(oi, ISM_InterfaceUp);
 	}
 
@@ -853,7 +854,7 @@ struct ospf_interface *ospf_vl_new(struc
 			"ospf_vl_new(): creating pseudo zebra interface vrf id %u",
 			ospf->vrf_id);
 
-	snprintf(ifname, sizeof(ifname), "VLINK%d", vlink_count);
+	snprintf(ifname, sizeof(ifname), "VLINK%u", vlink_count);
 	vi = if_create(ifname, ospf->vrf_id);
 	/*
 	 * if_create sets ZEBRA_INTERFACE_LINKDETECTION
diff -urpN frr-frr-5.0.1/ospfd/ospf_lsa.c frr-frr-6.0/ospfd/ospf_lsa.c
--- frr-frr-5.0.1/ospfd/ospf_lsa.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_lsa.c	2018-10-08 14:32:57.000000000 +0200
@@ -167,6 +167,16 @@ struct ospf_lsa *ospf_lsa_new()
 	return new;
 }
 
+struct ospf_lsa *ospf_lsa_new_and_data(size_t size)
+{
+	struct ospf_lsa *new;
+
+	new = ospf_lsa_new();
+	new->data = ospf_lsa_data_new(size);
+
+	return new;
+}
+
 /* Duplicate OSPF LSA. */
 struct ospf_lsa *ospf_lsa_dup(struct ospf_lsa *lsa)
 {
@@ -406,7 +416,7 @@ static uint16_t ospf_link_cost(struct os
 }
 
 /* Set a link information. */
-static char link_info_set(struct stream *s, struct in_addr id,
+static char link_info_set(struct stream **s, struct in_addr id,
 			  struct in_addr data, uint8_t type, uint8_t tos,
 			  uint16_t cost)
 {
@@ -415,11 +425,11 @@ static char link_info_set(struct stream
 	 * more.
 	 * we try accomodate those here.
 	 */
-	if (STREAM_WRITEABLE(s) < OSPF_ROUTER_LSA_LINK_SIZE) {
+	if (STREAM_WRITEABLE(*s) < OSPF_ROUTER_LSA_LINK_SIZE) {
 		size_t ret = OSPF_MAX_LSA_SIZE;
 
 		/* Can we enlarge the stream still? */
-		if (STREAM_SIZE(s) == OSPF_MAX_LSA_SIZE) {
+		if (STREAM_SIZE(*s) == OSPF_MAX_LSA_SIZE) {
 			/* we futz the size here for simplicity, really we need
 			 * to account
 			 * for just:
@@ -431,30 +441,31 @@ static char link_info_set(struct stream
 			 *
 			 * Simpler just to subtract OSPF_MAX_LSA_SIZE though.
 			 */
-			ret = stream_resize(
+			ret = stream_resize_inplace(
 				s, OSPF_MAX_PACKET_SIZE - OSPF_MAX_LSA_SIZE);
 		}
 
 		if (ret == OSPF_MAX_LSA_SIZE) {
 			zlog_warn(
 				"%s: Out of space in LSA stream, left %zd, size %zd",
-				__func__, STREAM_WRITEABLE(s), STREAM_SIZE(s));
+				__func__, STREAM_WRITEABLE(*s),
+				STREAM_SIZE(*s));
 			return 0;
 		}
 	}
 
 	/* TOS based routing is not supported. */
-	stream_put_ipv4(s, id.s_addr);   /* Link ID. */
-	stream_put_ipv4(s, data.s_addr); /* Link Data. */
-	stream_putc(s, type);		 /* Link Type. */
-	stream_putc(s, tos);		 /* TOS = 0. */
-	stream_putw(s, cost);		 /* Link Cost. */
+	stream_put_ipv4(*s, id.s_addr);   /* Link ID. */
+	stream_put_ipv4(*s, data.s_addr); /* Link Data. */
+	stream_putc(*s, type);		  /* Link Type. */
+	stream_putc(*s, tos);		  /* TOS = 0. */
+	stream_putw(*s, cost);		  /* Link Cost. */
 
 	return 1;
 }
 
 /* Describe Point-to-Point link (Section 12.4.1.1). */
-static int lsa_link_ptop_set(struct stream *s, struct ospf_interface *oi)
+static int lsa_link_ptop_set(struct stream **s, struct ospf_interface *oi)
 {
 	int links = 0;
 	struct ospf_neighbor *nbr;
@@ -500,7 +511,7 @@ static int lsa_link_ptop_set(struct stre
 }
 
 /* Describe Broadcast Link. */
-static int lsa_link_broadcast_set(struct stream *s, struct ospf_interface *oi)
+static int lsa_link_broadcast_set(struct stream **s, struct ospf_interface *oi)
 {
 	struct ospf_neighbor *dr;
 	struct in_addr id, mask;
@@ -546,7 +557,7 @@ static int lsa_link_broadcast_set(struct
 	}
 }
 
-static int lsa_link_loopback_set(struct stream *s, struct ospf_interface *oi)
+static int lsa_link_loopback_set(struct stream **s, struct ospf_interface *oi)
 {
 	struct in_addr id, mask;
 
@@ -560,7 +571,8 @@ static int lsa_link_loopback_set(struct
 }
 
 /* Describe Virtual Link. */
-static int lsa_link_virtuallink_set(struct stream *s, struct ospf_interface *oi)
+static int lsa_link_virtuallink_set(struct stream **s,
+				    struct ospf_interface *oi)
 {
 	struct ospf_neighbor *nbr;
 	uint16_t cost = ospf_link_cost(oi);
@@ -583,7 +595,7 @@ static int lsa_link_virtuallink_set(stru
 12.4.1.4.*/
 /* from "edward rrr" <edward_rrr@hotmail.com>
    http://marc.theaimsgroup.com/?l=zebra&m=100739222210507&w=2 */
-static int lsa_link_ptomp_set(struct stream *s, struct ospf_interface *oi)
+static int lsa_link_ptomp_set(struct stream **s, struct ospf_interface *oi)
 {
 	int links = 0;
 	struct route_node *rn;
@@ -624,7 +636,7 @@ static int lsa_link_ptomp_set(struct str
 }
 
 /* Set router-LSA link information. */
-static int router_lsa_link_set(struct stream *s, struct ospf_area *area)
+static int router_lsa_link_set(struct stream **s, struct ospf_area *area)
 {
 	struct listnode *node;
 	struct ospf_interface *oi;
@@ -667,28 +679,28 @@ static int router_lsa_link_set(struct st
 }
 
 /* Set router-LSA body. */
-static void ospf_router_lsa_body_set(struct stream *s, struct ospf_area *area)
+static void ospf_router_lsa_body_set(struct stream **s, struct ospf_area *area)
 {
 	unsigned long putp;
 	uint16_t cnt;
 
 	/* Set flags. */
-	stream_putc(s, router_lsa_flags(area));
+	stream_putc(*s, router_lsa_flags(area));
 
 	/* Set Zero fields. */
-	stream_putc(s, 0);
+	stream_putc(*s, 0);
 
 	/* Keep pointer to # links. */
-	putp = stream_get_endp(s);
+	putp = stream_get_endp(*s);
 
 	/* Forward word */
-	stream_putw(s, 0);
+	stream_putw(*s, 0);
 
 	/* Set all link information. */
 	cnt = router_lsa_link_set(s, area);
 
 	/* Set # of links here. */
-	stream_putw_at(s, putp, cnt);
+	stream_putw_at(*s, putp, cnt);
 }
 
 static int ospf_stub_router_timer(struct thread *t)
@@ -773,7 +785,7 @@ static struct ospf_lsa *ospf_router_lsa_
 		       OSPF_ROUTER_LSA, ospf->router_id, ospf->router_id);
 
 	/* Set router-LSA body fields. */
-	ospf_router_lsa_body_set(s, area);
+	ospf_router_lsa_body_set(&s, area);
 
 	/* Set length. */
 	length = stream_get_endp(s);
@@ -781,17 +793,13 @@ static struct ospf_lsa *ospf_router_lsa_
 	lsah->length = htons(length);
 
 	/* Now, create OSPF LSA instance. */
-	if ((new = ospf_lsa_new()) == NULL) {
-		zlog_err("%s: Unable to create new lsa", __func__);
-		return NULL;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	new->area = area;
 	SET_FLAG(new->flags, OSPF_LSA_SELF | OSPF_LSA_SELF_CHECKED);
 	new->vrf_id = area->ospf->vrf_id;
 
 	/* Copy LSA data to store, discard stream. */
-	new->data = ospf_lsa_data_new(length);
 	memcpy(new->data, lsah, length);
 	stream_free(s);
 
@@ -997,17 +1005,13 @@ static struct ospf_lsa *ospf_network_lsa
 	lsah->length = htons(length);
 
 	/* Create OSPF LSA instance. */
-	if ((new = ospf_lsa_new()) == NULL) {
-		zlog_err("%s: ospf_lsa_new returned NULL", __func__);
-		return NULL;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	new->area = oi->area;
 	SET_FLAG(new->flags, OSPF_LSA_SELF | OSPF_LSA_SELF_CHECKED);
 	new->vrf_id = oi->ospf->vrf_id;
 
 	/* Copy LSA to store. */
-	new->data = ospf_lsa_data_new(length);
 	memcpy(new->data, lsah, length);
 	stream_free(s);
 
@@ -1181,13 +1185,12 @@ static struct ospf_lsa *ospf_summary_lsa
 	lsah->length = htons(length);
 
 	/* Create OSPF LSA instance. */
-	new = ospf_lsa_new();
+	new = ospf_lsa_new_and_data(length);
 	new->area = area;
 	SET_FLAG(new->flags, OSPF_LSA_SELF | OSPF_LSA_SELF_CHECKED);
 	new->vrf_id = area->ospf->vrf_id;
 
 	/* Copy LSA to store. */
-	new->data = ospf_lsa_data_new(length);
 	memcpy(new->data, lsah, length);
 	stream_free(s);
 
@@ -1323,13 +1326,12 @@ static struct ospf_lsa *ospf_summary_asb
 	lsah->length = htons(length);
 
 	/* Create OSPF LSA instance. */
-	new = ospf_lsa_new();
+	new = ospf_lsa_new_and_data(length);
 	new->area = area;
 	SET_FLAG(new->flags, OSPF_LSA_SELF | OSPF_LSA_SELF_CHECKED);
 	new->vrf_id = area->ospf->vrf_id;
 
 	/* Copy LSA to store. */
-	new->data = ospf_lsa_data_new(length);
 	memcpy(new->data, lsah, length);
 	stream_free(s);
 
@@ -1629,14 +1631,13 @@ static struct ospf_lsa *ospf_external_ls
 	lsah->length = htons(length);
 
 	/* Now, create OSPF LSA instance. */
-	new = ospf_lsa_new();
+	new = ospf_lsa_new_and_data(length);
 	new->area = NULL;
 	SET_FLAG(new->flags,
 		 OSPF_LSA_SELF | OSPF_LSA_APPROVED | OSPF_LSA_SELF_CHECKED);
 	new->vrf_id = ospf->vrf_id;
 
 	/* Copy LSA data to store, discard stream. */
-	new->data = ospf_lsa_data_new(length);
 	memcpy(new->data, lsah, length);
 	stream_free(s);
 
@@ -1889,7 +1890,7 @@ struct ospf_lsa *ospf_translated_nssa_re
 			zlog_debug(
 				"ospf_translated_nssa_refresh(): no Type-7 found for "
 				"Type-5 LSA Id %s",
-				inet_ntoa(type5->data->id));
+				type5 ? inet_ntoa(type5->data->id) : "(null)");
 		return NULL;
 	}
 
@@ -1899,7 +1900,7 @@ struct ospf_lsa *ospf_translated_nssa_re
 			zlog_debug(
 				"ospf_translated_nssa_refresh(): No translated Type-5 "
 				"found for Type-7 with Id %s",
-				inet_ntoa(type7->data->id));
+				type7 ? inet_ntoa(type7->data->id) : "(null)");
 		return NULL;
 	}
 
@@ -1912,7 +1913,7 @@ struct ospf_lsa *ospf_translated_nssa_re
 			zlog_debug(
 				"ospf_translated_nssa_refresh(): Could not translate "
 				"Type-7 for %s to Type-5",
-				inet_ntoa(type7->data->id));
+				type7 ? inet_ntoa(type7->data->id) : "(null)");
 		return NULL;
 	}
 
@@ -2582,7 +2583,8 @@ struct ospf_lsa *ospf_lsa_install(struct
 		lsdb = ospf->lsdb;
 		break;
 	default:
-		lsdb = lsa->area->lsdb;
+		if (lsa->area)
+			lsdb = lsa->area->lsdb;
 		break;
 	}
 
@@ -2911,24 +2913,17 @@ void ospf_lsa_maxage(struct ospf *ospf,
 	lsa_prefix.prefixlen = sizeof(lsa_prefix.u.ptr) * CHAR_BIT;
 	lsa_prefix.u.ptr = (uintptr_t)lsa;
 
-	if ((rn = route_node_get(ospf->maxage_lsa,
-				 (struct prefix *)&lsa_prefix))
-	    != NULL) {
-		if (rn->info != NULL) {
-			if (IS_DEBUG_OSPF(lsa, LSA_FLOODING))
-				zlog_debug(
-					"LSA[%s]: found LSA (%p) in table for LSA %p %d",
-					dump_lsa_key(lsa), rn->info,
-					(void *)lsa, lsa_prefix.prefixlen);
-			route_unlock_node(rn);
-		} else {
-			rn->info = ospf_lsa_lock(lsa);
-			SET_FLAG(lsa->flags, OSPF_LSA_IN_MAXAGE);
-		}
+	rn = route_node_get(ospf->maxage_lsa, (struct prefix *)&lsa_prefix);
+	if (rn->info != NULL) {
+		if (IS_DEBUG_OSPF(lsa, LSA_FLOODING))
+			zlog_debug(
+				   "LSA[%s]: found LSA (%p) in table for LSA %p %d",
+				   dump_lsa_key(lsa), rn->info,
+				   (void *)lsa, lsa_prefix.prefixlen);
+		route_unlock_node(rn);
 	} else {
-		zlog_err("Unable to allocate memory for maxage lsa %s\n",
-			 dump_lsa_key(lsa));
-		assert(0);
+		rn->info = ospf_lsa_lock(lsa);
+		SET_FLAG(lsa->flags, OSPF_LSA_IN_MAXAGE);
 	}
 
 	if (IS_DEBUG_OSPF(lsa, LSA_FLOODING))
diff -urpN frr-frr-5.0.1/ospfd/ospf_lsa.h frr-frr-6.0/ospfd/ospf_lsa.h
--- frr-frr-5.0.1/ospfd/ospf_lsa.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_lsa.h	2018-10-08 14:32:57.000000000 +0200
@@ -235,6 +235,7 @@ extern int ospf_check_nbr_status(struct
 
 /* Prototype for LSA primitive. */
 extern struct ospf_lsa *ospf_lsa_new(void);
+extern struct ospf_lsa *ospf_lsa_new_and_data(size_t size);
 extern struct ospf_lsa *ospf_lsa_dup(struct ospf_lsa *);
 extern void ospf_lsa_free(struct ospf_lsa *);
 extern struct ospf_lsa *ospf_lsa_lock(struct ospf_lsa *);
diff -urpN frr-frr-5.0.1/ospfd/ospf_main.c frr-frr-6.0/ospfd/ospf_main.c
--- frr-frr-5.0.1/ospfd/ospf_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -49,9 +49,11 @@
 #include "ospfd/ospf_lsdb.h"
 #include "ospfd/ospf_neighbor.h"
 #include "ospfd/ospf_dump.h"
+#include "ospfd/ospf_route.h"
 #include "ospfd/ospf_zebra.h"
 #include "ospfd/ospf_vty.h"
 #include "ospfd/ospf_bfd.h"
+#include "ospfd/ospf_errors.h"
 
 /* ospfd privileges */
 zebra_capabilities_t _caps_p[] = {ZCAP_NET_RAW, ZCAP_BIND, ZCAP_NET_ADMIN,
@@ -206,12 +208,16 @@ int main(int argc, char **argv)
 	ospf_route_map_init();
 	ospf_opaque_init();
 
+	/* OSPF errors init */
+	ospf_error_init();
+
 	/* Need to initialize the default ospf structure, so the interface mode
 	   commands can be duly processed if they are received before 'router
 	   ospf',
 	   when quagga(ospfd) is restarted */
 	if (!ospf_get_instance(instance)) {
-		zlog_err("OSPF instance init failed: %s", strerror(errno));
+		flog_err(OSPF_ERR_INIT_FAIL, "OSPF instance init failed: %s",
+			  strerror(errno));
 		exit(1);
 	}
 
diff -urpN frr-frr-5.0.1/ospfd/ospf_network.c frr-frr-6.0/ospfd/ospf_network.c
--- frr-frr-5.0.1/ospfd/ospf_network.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_network.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,6 +29,7 @@
 #include "log.h"
 #include "sockopt.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_network.h"
@@ -185,66 +186,51 @@ int ospf_sock_init(struct ospf *ospf)
 		/* silently return since VRF is not ready */
 		return -1;
 	}
-	if (ospfd_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("ospf_sock_init: could not raise privs, %s",
-			 safe_strerror(errno));
-	}
-
-	ospf_sock = vrf_socket(AF_INET, SOCK_RAW, IPPROTO_OSPFIGP, ospf->vrf_id,
-			       ospf->name);
-	if (ospf_sock < 0) {
-		int save_errno = errno;
-
-		if (ospfd_privs.change(ZPRIVS_LOWER))
-			zlog_err("ospf_sock_init: could not lower privs, %s",
+	frr_elevate_privs(&ospfd_privs) {
+		ospf_sock = vrf_socket(AF_INET, SOCK_RAW, IPPROTO_OSPFIGP,
+				       ospf->vrf_id, ospf->name);
+		if (ospf_sock < 0) {
+			zlog_err("ospf_read_sock_init: socket: %s",
 				 safe_strerror(errno));
-		zlog_err("ospf_read_sock_init: socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
+			exit(1);
+		}
 
 #ifdef IP_HDRINCL
-	/* we will include IP header with packet */
-	ret = setsockopt(ospf_sock, IPPROTO_IP, IP_HDRINCL, &hincl,
-			 sizeof(hincl));
-	if (ret < 0) {
-		int save_errno = errno;
-
-		zlog_warn("Can't set IP_HDRINCL option for fd %d: %s",
-			  ospf_sock, safe_strerror(save_errno));
-		close(ospf_sock);
-		goto out;
-	}
+		/* we will include IP header with packet */
+		ret = setsockopt(ospf_sock, IPPROTO_IP, IP_HDRINCL, &hincl,
+				 sizeof(hincl));
+		if (ret < 0) {
+			zlog_warn("Can't set IP_HDRINCL option for fd %d: %s",
+				  ospf_sock, safe_strerror(errno));
+			close(ospf_sock);
+			break;
+		}
 #elif defined(IPTOS_PREC_INTERNETCONTROL)
 #warning "IP_HDRINCL not available on this system"
 #warning "using IPTOS_PREC_INTERNETCONTROL"
-	ret = setsockopt_ipv4_tos(ospf_sock, IPTOS_PREC_INTERNETCONTROL);
-	if (ret < 0) {
-		int save_errno = errno;
-
-		zlog_warn("can't set sockopt IP_TOS %d to socket %d: %s", tos,
-			  ospf_sock, safe_strerror(save_errno));
-		close(ospf_sock); /* Prevent sd leak. */
-		goto out;
-	}
+		ret = setsockopt_ipv4_tos(ospf_sock,
+					  IPTOS_PREC_INTERNETCONTROL);
+		if (ret < 0) {
+			zlog_warn("can't set sockopt IP_TOS %d to socket %d: %s",
+				  tos, ospf_sock, safe_strerror(errno));
+			close(ospf_sock); /* Prevent sd leak. */
+			break;
+		}
 #else /* !IPTOS_PREC_INTERNETCONTROL */
 #warning "IP_HDRINCL not available, nor is IPTOS_PREC_INTERNETCONTROL"
-	zlog_warn("IP_HDRINCL option not available");
+		zlog_warn("IP_HDRINCL option not available");
 #endif /* IP_HDRINCL */
 
-	ret = setsockopt_ifindex(AF_INET, ospf_sock, 1);
+		ret = setsockopt_ifindex(AF_INET, ospf_sock, 1);
 
-	if (ret < 0)
-		zlog_warn("Can't set pktinfo option for fd %d", ospf_sock);
+		if (ret < 0)
+			zlog_warn("Can't set pktinfo option for fd %d",
+				  ospf_sock);
 
-	setsockopt_so_sendbuf(ospf_sock, bufsize);
-	setsockopt_so_recvbuf(ospf_sock, bufsize);
+		setsockopt_so_sendbuf(ospf_sock, bufsize);
+		setsockopt_so_recvbuf(ospf_sock, bufsize);
+	}
 
 	ospf->fd = ospf_sock;
-out:
-	if (ospfd_privs.change(ZPRIVS_LOWER)) {
-		zlog_err("ospf_sock_init: could not lower privs, %s",
-			 safe_strerror(errno));
-	}
 	return ret;
 }
diff -urpN frr-frr-5.0.1/ospfd/ospf_opaque.c frr-frr-6.0/ospfd/ospf_opaque.c
--- frr-frr-5.0.1/ospfd/ospf_opaque.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_opaque.c	2018-10-08 14:32:57.000000000 +0200
@@ -399,13 +399,8 @@ int ospf_register_opaque_functab(
 			}
 	}
 
-	if ((new = XCALLOC(MTYPE_OSPF_OPAQUE_FUNCTAB,
-			   sizeof(struct ospf_opaque_functab)))
-	    == NULL) {
-		zlog_warn("ospf_register_opaque_functab: XMALLOC: %s",
-			  safe_strerror(errno));
-		goto out;
-	}
+	new = XCALLOC(MTYPE_OSPF_OPAQUE_FUNCTAB,
+		      sizeof(struct ospf_opaque_functab));
 
 	new->opaque_type = opaque_type;
 	new->oipt = NULL;
@@ -554,13 +549,8 @@ register_opaque_info_per_type(struct osp
 	struct ospf *top;
 	struct opaque_info_per_type *oipt;
 
-	if ((oipt = XCALLOC(MTYPE_OPAQUE_INFO_PER_TYPE,
-			    sizeof(struct opaque_info_per_type)))
-	    == NULL) {
-		zlog_warn("register_opaque_info_per_type: XMALLOC: %s",
-			  safe_strerror(errno));
-		goto out;
-	}
+	oipt = XCALLOC(MTYPE_OPAQUE_INFO_PER_TYPE,
+		       sizeof(struct opaque_info_per_type));
 
 	switch (new->data->type) {
 	case OSPF_OPAQUE_LINK_LSA:
@@ -711,13 +701,9 @@ register_opaque_info_per_id(struct opaqu
 {
 	struct opaque_info_per_id *oipi;
 
-	if ((oipi = XCALLOC(MTYPE_OPAQUE_INFO_PER_ID,
-			    sizeof(struct opaque_info_per_id)))
-	    == NULL) {
-		zlog_warn("register_opaque_info_per_id: XMALLOC: %s",
-			  safe_strerror(errno));
-		goto out;
-	}
+	oipi = XCALLOC(MTYPE_OPAQUE_INFO_PER_ID,
+		       sizeof(struct opaque_info_per_id));
+
 	oipi->opaque_id = GET_OPAQUE_ID(ntohl(new->data->id.s_addr));
 	oipi->t_opaque_lsa_self = NULL;
 	oipi->opqctl_type = oipt;
@@ -725,7 +711,6 @@ register_opaque_info_per_id(struct opaqu
 
 	listnode_add(oipt->id_list, oipi);
 
-out:
 	return oipi;
 }
 
diff -urpN frr-frr-5.0.1/ospfd/ospf_packet.c frr-frr-6.0/ospfd/ospf_packet.c
--- frr-frr-5.0.1/ospfd/ospf_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "checksum.h"
 #include "md5.h"
 #include "vrf.h"
+#include "ospf_errors.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_network.h"
@@ -144,8 +145,6 @@ void ospf_packet_free(struct ospf_packet
 		stream_free(op->s);
 
 	XFREE(MTYPE_OSPF_PACKET, op);
-
-	op = NULL;
 }
 
 struct ospf_fifo *ospf_fifo_new()
@@ -232,7 +231,8 @@ void ospf_fifo_free(struct ospf_fifo *fi
 void ospf_packet_add(struct ospf_interface *oi, struct ospf_packet *op)
 {
 	if (!oi->obuf) {
-		zlog_err(
+		flog_err(
+			OSPF_ERR_PKT_PROCESS,
 			"ospf_packet_add(interface %s in state %d [%s], packet type %s, "
 			"destination %s) called with NULL obuf, ignoring "
 			"(please report this bug)!\n",
@@ -255,7 +255,8 @@ static void ospf_packet_add_top(struct o
 				struct ospf_packet *op)
 {
 	if (!oi->obuf) {
-		zlog_err(
+		flog_err(
+			OSPF_ERR_PKT_PROCESS,
 			"ospf_packet_add(interface %s in state %d [%s], packet type %s, "
 			"destination %s) called with NULL obuf, ignoring "
 			"(please report this bug)!\n",
@@ -1741,7 +1742,7 @@ static struct list *ospf_ls_upd_list_lsa
 		}
 
 		/* Create OSPF LSA instance. */
-		lsa = ospf_lsa_new();
+		lsa = ospf_lsa_new_and_data(length);
 
 		lsa->vrf_id = oi->ospf->vrf_id;
 		/* We may wish to put some error checking if type NSSA comes in
@@ -1760,7 +1761,6 @@ static struct list *ospf_ls_upd_list_lsa
 			break;
 		}
 
-		lsa->data = ospf_lsa_data_new(length);
 		memcpy(lsa->data, lsah, length);
 
 		if (IS_DEBUG_OSPF_EVENT)
@@ -1917,17 +1917,18 @@ static void ospf_ls_upd(struct ospf *osp
 				char buf2[INET_ADDRSTRLEN];
 				char buf3[INET_ADDRSTRLEN];
 
-				zlog_err(
-					"Incoming Router-LSA from %s with "
-					"Adv-ID[%s] != LS-ID[%s]",
-					inet_ntop(AF_INET, &ospfh->router_id,
-						  buf1, INET_ADDRSTRLEN),
-					inet_ntop(AF_INET, &lsa->data->id, buf2,
-						  INET_ADDRSTRLEN),
-					inet_ntop(AF_INET,
-						  &lsa->data->adv_router, buf3,
-						  INET_ADDRSTRLEN));
-				zlog_err(
+				flog_err(OSPF_ERR_ROUTER_LSA_MISMATCH,
+					  "Incoming Router-LSA from %s with "
+					  "Adv-ID[%s] != LS-ID[%s]",
+					  inet_ntop(AF_INET, &ospfh->router_id,
+						    buf1, INET_ADDRSTRLEN),
+					  inet_ntop(AF_INET, &lsa->data->id,
+						    buf2, INET_ADDRSTRLEN),
+					  inet_ntop(AF_INET,
+						    &lsa->data->adv_router,
+						    buf3, INET_ADDRSTRLEN));
+				flog_err(
+					OSPF_ERR_DOMAIN_CORRUPT,
 					"OSPF domain compromised by attack or corruption. "
 					"Verify correct operation of -ALL- OSPF routers.");
 				DISCARD_LSA(lsa, 0);
diff -urpN frr-frr-5.0.1/ospfd/ospf_ri.c frr-frr-6.0/ospfd/ospf_ri.c
--- frr-frr-5.0.1/ospfd/ospf_ri.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_ri.c	2018-10-08 14:32:57.000000000 +0200
@@ -516,12 +516,13 @@ static void unset_sr_node_msd(void)
 	TLV_LEN(OspfRI.sr_info.msd) = htons(0);
 }
 
-static void unset_param(struct tlv_header *tlv)
+static void unset_param(void *tlv_buffer)
 {
+	struct tlv_header *tlv = (struct tlv_header *)tlv_buffer;
 
 	tlv->type = 0;
 	/* Fill the Value to 0 */
-	memset(TLV_DATA(tlv), 0, TLV_BODY_SIZE(tlv));
+	memset(TLV_DATA(tlv_buffer), 0, TLV_BODY_SIZE(tlv));
 	tlv->length = 0;
 
 	return;
@@ -774,18 +775,7 @@ static struct ospf_lsa *ospf_router_info
 	lsah->length = htons(length);
 
 	/* Now, create an OSPF LSA instance. */
-	if ((new = ospf_lsa_new()) == NULL) {
-		zlog_warn("ospf_router_info_lsa_new: ospf_lsa_new() ?");
-		stream_free(s);
-		return NULL;
-	}
-	if ((new->data = ospf_lsa_data_new(length)) == NULL) {
-		zlog_warn("ospf_router_info_lsa_new: ospf_lsa_data_new() ?");
-		ospf_lsa_unlock(&new);
-		new = NULL;
-		stream_free(s);
-		return new;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	new->area = OspfRI.area; /* Area must be null if the Opaque type is AS
 				    scope, fulfill otherwise */
@@ -1571,7 +1561,7 @@ DEFUN (no_pce_address,
        "PCE address in IPv4 address format\n")
 {
 
-	unset_param(&OspfRI.pce_info.pce_address.header);
+	unset_param(&OspfRI.pce_info.pce_address);
 
 	/* Refresh RI LSA if already engaged */
 	if (CHECK_FLAG(OspfRI.flags, RIFLG_LSA_ENGAGED))
@@ -1621,7 +1611,7 @@ DEFUN (no_pce_path_scope,
        "32-bit Hexadecimal value\n")
 {
 
-	unset_param(&OspfRI.pce_info.pce_address.header);
+	unset_param(&OspfRI.pce_info.pce_address);
 
 	/* Refresh RI LSA if already engaged */
 	if (CHECK_FLAG(OspfRI.flags, RIFLG_LSA_ENGAGED))
@@ -1648,7 +1638,7 @@ DEFUN (pce_domain,
 	if (!ospf_ri_enabled(vty))
 		return CMD_WARNING_CONFIG_FAILED;
 
-	if (sscanf(argv[idx_number]->arg, "%d", &as) != 1) {
+	if (sscanf(argv[idx_number]->arg, "%" SCNu32, &as) != 1) {
 		vty_out(vty, "pce_domain: fscanf: %s\n", safe_strerror(errno));
 		return CMD_WARNING_CONFIG_FAILED;
 	}
@@ -1683,7 +1673,7 @@ DEFUN (no_pce_domain,
 	uint32_t as;
 	struct ospf_pce_info *pce = &OspfRI.pce_info;
 
-	if (sscanf(argv[idx_number]->arg, "%d", &as) != 1) {
+	if (sscanf(argv[idx_number]->arg, "%" SCNu32, &as) != 1) {
 		vty_out(vty, "no_pce_domain: fscanf: %s\n",
 			safe_strerror(errno));
 		return CMD_WARNING_CONFIG_FAILED;
@@ -1717,7 +1707,7 @@ DEFUN (pce_neigbhor,
 	if (!ospf_ri_enabled(vty))
 		return CMD_WARNING_CONFIG_FAILED;
 
-	if (sscanf(argv[idx_number]->arg, "%d", &as) != 1) {
+	if (sscanf(argv[idx_number]->arg, "%" SCNu32, &as) != 1) {
 		vty_out(vty, "pce_neighbor: fscanf: %s\n",
 			safe_strerror(errno));
 		return CMD_WARNING_CONFIG_FAILED;
@@ -1753,7 +1743,7 @@ DEFUN (no_pce_neighbor,
 	uint32_t as;
 	struct ospf_pce_info *pce = &OspfRI.pce_info;
 
-	if (sscanf(argv[idx_number]->arg, "%d", &as) != 1) {
+	if (sscanf(argv[idx_number]->arg, "%" SCNu32, &as) != 1) {
 		vty_out(vty, "no_pce_neighbor: fscanf: %s\n",
 			safe_strerror(errno));
 		return CMD_WARNING_CONFIG_FAILED;
@@ -1810,7 +1800,7 @@ DEFUN (no_pce_cap_flag,
        "Disable PCE capabilities\n")
 {
 
-	unset_param(&OspfRI.pce_info.pce_cap_flag.header);
+	unset_param(&OspfRI.pce_info.pce_cap_flag);
 
 	/* Refresh RI LSA if already engaged */
 	if (CHECK_FLAG(OspfRI.flags, RIFLG_LSA_ENGAGED))
diff -urpN frr-frr-5.0.1/ospfd/ospf_route.c frr-frr-6.0/ospfd/ospf_route.c
--- frr-frr-5.0.1/ospfd/ospf_route.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_route.c	2018-10-08 14:32:57.000000000 +0200
@@ -170,8 +170,8 @@ int ospf_route_match_same(struct route_t
 			/* Check each path. */
 			for (n1 = listhead(or->paths),
 			    n2 = listhead(newor->paths);
-			     n1 && n2;
-			     n1 = listnextnode(n1), n2 = listnextnode(n2)) {
+			     n1 && n2; n1 = listnextnode_unchecked(n1),
+			    n2 = listnextnode_unchecked(n2)) {
 				op = listgetdata(n1);
 				newop = listgetdata(n2);
 
diff -urpN frr-frr-5.0.1/ospfd/ospf_routemap.c frr-frr-6.0/ospfd/ospf_routemap.c
--- frr-frr-5.0.1/ospfd/ospf_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -32,6 +32,7 @@
 #include "log.h"
 #include "plist.h"
 #include "vrf.h"
+#include "frrstr.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_asbr.h"
@@ -117,7 +118,7 @@ static void ospf_route_map_event(route_m
 /* `match ip netxthop ' */
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_ip_nexthop(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -162,7 +163,7 @@ struct route_map_rule_cmd route_match_ip
 /* `match ip next-hop prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_next_hop_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_next_hop_prefix_list(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -204,7 +205,7 @@ struct route_map_rule_cmd route_match_ip
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_ip_address(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -243,7 +244,7 @@ struct route_map_rule_cmd route_match_ip
 
 /* `match ip address prefix-list PREFIX_LIST' */
 static route_map_result_t
-route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_address_prefix_list(void *rule, const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -279,7 +280,7 @@ struct route_map_rule_cmd route_match_ip
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_interface(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -317,7 +318,8 @@ struct route_map_rule_cmd route_match_in
 	route_match_interface_free};
 
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_tag(void *rule,
+					  const struct prefix *prefix,
 					  route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -347,7 +349,8 @@ struct ospf_metric {
 
 /* `set metric METRIC' */
 /* Set metric to attribute. */
-static route_map_result_t route_set_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_metric(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -426,7 +429,7 @@ struct route_map_rule_cmd route_set_metr
 /* `set metric-type TYPE' */
 /* Set metric-type to attribute. */
 static route_map_result_t route_set_metric_type(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -475,7 +478,7 @@ struct route_map_rule_cmd route_set_metr
 	route_set_metric_type_free,
 };
 
-static route_map_result_t route_set_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_tag(void *rule, const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
diff -urpN frr-frr-5.0.1/ospfd/ospf_snmp.c frr-frr-6.0/ospfd/ospf_snmp.c
--- frr-frr-5.0.1/ospfd/ospf_snmp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_snmp.c	2018-10-08 14:32:57.000000000 +0200
@@ -47,6 +47,7 @@
 #include "ospfd/ospf_flood.h"
 #include "ospfd/ospf_ism.h"
 #include "ospfd/ospf_dump.h"
+#include "ospfd/ospf_route.h"
 #include "ospfd/ospf_zebra.h"
 
 /* OSPF2-MIB. */
@@ -1626,7 +1627,7 @@ static struct ospf_interface *ospfIfLook
 		len = *length - v->namelen;
 		if (len >= IN_ADDR_SIZE)
 			len = IN_ADDR_SIZE;
-		if (len <= 0)
+		if (len == 0)
 			ifaddr_next = 1;
 
 		oid2in_addr(name + v->namelen, len, ifaddr);
@@ -1990,7 +1991,7 @@ ospfVirtIfLookup(struct variable *v, oid
 		first = 0;
 
 		len = *length - v->namelen;
-		if (len <= 0)
+		if (len == 0)
 			first = 1;
 		if (len > IN_ADDR_SIZE)
 			len = IN_ADDR_SIZE;
@@ -2176,7 +2177,7 @@ static struct ospf_neighbor *ospfNbrLook
 		first = 0;
 		len = *length - v->namelen;
 
-		if (len <= 0)
+		if (len == 0)
 			first = 1;
 
 		if (len > IN_ADDR_SIZE)
diff -urpN frr-frr-5.0.1/ospfd/ospf_spf.c frr-frr-6.0/ospfd/ospf_spf.c
--- frr-frr-5.0.1/ospfd/ospf_spf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_spf.c	2018-10-08 14:32:57.000000000 +0200
@@ -154,9 +154,6 @@ static struct vertex_parent *vertex_pare
 
 	new = XMALLOC(MTYPE_OSPF_VERTEX_PARENT, sizeof(struct vertex_parent));
 
-	if (new == NULL)
-		return NULL;
-
 	new->parent = v;
 	new->backlink = backlink;
 	new->nexthop = hop;
diff -urpN frr-frr-5.0.1/ospfd/ospf_sr.c frr-frr-6.0/ospfd/ospf_sr.c
--- frr-frr-5.0.1/ospfd/ospf_sr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_sr.c	2018-10-08 14:32:57.000000000 +0200
@@ -48,6 +48,7 @@
 #include "vty.h"
 #include "zclient.h"
 #include <lib/json.h>
+#include "ospf_errors.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_interface.h"
@@ -128,12 +129,6 @@ static struct sr_node *sr_node_new(struc
 	/* Allocate Segment Routing node memory */
 	new = XCALLOC(MTYPE_OSPF_SR_PARAMS, sizeof(struct sr_node));
 
-	/* Sanity Check */
-	if (new == NULL) {
-		zlog_err("SR (%s): Abort! can't create new SR node", __func__);
-		return NULL;
-	}
-
 	/* Default Algorithm, SRGB and MSD */
 	for (int i = 0; i < ALGORITHM_COUNT; i++)
 		new->algo[i] = SR_ALGORITHM_UNSET;
@@ -735,9 +730,6 @@ static struct sr_link *get_ext_link_sid(
 
 	srl = XCALLOC(MTYPE_OSPF_SR_PARAMS, sizeof(struct sr_link));
 
-	if (srl == NULL)
-		return NULL;
-
 	/* Initialize TLV browsing */
 	length = ntohs(tlvh->length) - EXT_TLV_LINK_SIZE;
 	sub_tlvh = (struct tlv_header *)((char *)(tlvh) + TLV_HDR_SIZE
@@ -820,9 +812,6 @@ static struct sr_prefix *get_ext_prefix_
 
 	srp = XCALLOC(MTYPE_OSPF_SR_PARAMS, sizeof(struct sr_prefix));
 
-	if (srp == NULL)
-		return NULL;
-
 	/* Initialize TLV browsing */
 	length = ntohs(tlvh->length) - EXT_TLV_PREFIX_SIZE;
 	sub_tlvh = (struct tlv_header *)((char *)(tlvh) + TLV_HDR_SIZE
@@ -832,8 +821,9 @@ static struct sr_prefix *get_ext_prefix_
 		case EXT_SUBTLV_PREFIX_SID:
 			psid = (struct ext_subtlv_prefix_sid *)sub_tlvh;
 			if (psid->algorithm != SR_ALGORITHM_SPF) {
-				zlog_err("SR (%s): Unsupported Algorithm",
-					 __func__);
+				flog_err(OSPF_ERR_SR_INVALID_ALGORITHM,
+					  "SR (%s): Unsupported Algorithm",
+					  __func__);
 				XFREE(MTYPE_OSPF_SR_PARAMS, srp);
 				return NULL;
 			}
@@ -1112,7 +1102,8 @@ void ospf_sr_ri_lsa_update(struct ospf_l
 		return;
 
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR DataBase", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR DataBase", __func__);
 		return;
 	}
 
@@ -1122,17 +1113,18 @@ void ospf_sr_ri_lsa_update(struct ospf_l
 
 	/* Sanity check */
 	if (srn == NULL) {
-		zlog_err("SR (%s): Abort! can't create SR node in hash table",
-			 __func__);
+		flog_err(OSPF_ERR_SR_NODE_CREATE,
+			  "SR (%s): Abort! can't create SR node in hash table",
+			  __func__);
 		return;
 	}
 
 	if ((srn->instance != 0) && (srn->instance != ntohl(lsah->id.s_addr))) {
-		zlog_err(
-			"SR (%s): Abort! Wrong "
-			"LSA ID 4.0.0.%u for SR node %s/%u",
-			__func__, GET_OPAQUE_ID(ntohl(lsah->id.s_addr)),
-			inet_ntoa(lsah->adv_router), srn->instance);
+		flog_err(OSPF_ERR_SR_INVALID_LSA_ID,
+			  "SR (%s): Abort! Wrong "
+			  "LSA ID 4.0.0.%u for SR node %s/%u",
+			  __func__, GET_OPAQUE_ID(ntohl(lsah->id.s_addr)),
+			  inet_ntoa(lsah->adv_router), srn->instance);
 		return;
 	}
 
@@ -1221,7 +1213,8 @@ void ospf_sr_ri_lsa_delete(struct ospf_l
 
 	/* Sanity check */
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR Data Base", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR Data Base", __func__);
 		return;
 	}
 
@@ -1230,15 +1223,18 @@ void ospf_sr_ri_lsa_delete(struct ospf_l
 
 	/* Sanity check */
 	if (srn == NULL) {
-		zlog_err("SR (%s): Abort! no entry in SRDB for SR Node %s",
-			 __func__, inet_ntoa(lsah->adv_router));
+		flog_err(OSPF_ERR_SR_NODE_CREATE,
+			  "SR (%s): Abort! no entry in SRDB for SR Node %s",
+			  __func__, inet_ntoa(lsah->adv_router));
 		return;
 	}
 
 	if ((srn->instance != 0) && (srn->instance != ntohl(lsah->id.s_addr))) {
-		zlog_err("SR (%s): Abort! Wrong LSA ID 4.0.0.%u for SR node %s",
-			 __func__, GET_OPAQUE_ID(ntohl(lsah->id.s_addr)),
-			 inet_ntoa(lsah->adv_router));
+		flog_err(
+			OSPF_ERR_SR_INVALID_LSA_ID,
+			"SR (%s): Abort! Wrong LSA ID 4.0.0.%u for SR node %s",
+			__func__, GET_OPAQUE_ID(ntohl(lsah->id.s_addr)),
+			inet_ntoa(lsah->adv_router));
 		return;
 	}
 
@@ -1264,7 +1260,8 @@ void ospf_sr_ext_link_lsa_update(struct
 
 	/* Sanity check */
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR DataBase", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR DataBase", __func__);
 		return;
 	}
 
@@ -1275,8 +1272,9 @@ void ospf_sr_ext_link_lsa_update(struct
 
 	/* Sanity check */
 	if (srn == NULL) {
-		zlog_err("SR (%s): Abort! can't create SR node in hash table",
-			 __func__);
+		flog_err(OSPF_ERR_SR_NODE_CREATE,
+			  "SR (%s): Abort! can't create SR node in hash table",
+			  __func__);
 		return;
 	}
 
@@ -1314,7 +1312,8 @@ void ospf_sr_ext_link_lsa_delete(struct
 
 	/* Sanity check */
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR DataBase", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR DataBase", __func__);
 		return;
 	}
 
@@ -1371,7 +1370,8 @@ void ospf_sr_ext_prefix_lsa_update(struc
 
 	/* Sanity check */
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR DataBase", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR DataBase", __func__);
 		return;
 	}
 
@@ -1382,8 +1382,9 @@ void ospf_sr_ext_prefix_lsa_update(struc
 
 	/* Sanity check */
 	if (srn == NULL) {
-		zlog_err("SR (%s): Abort! can't create SR node in hash table",
-			 __func__);
+		flog_err(OSPF_ERR_SR_NODE_CREATE,
+			  "SR (%s): Abort! can't create SR node in hash table",
+			  __func__);
 		return;
 	}
 
@@ -1422,7 +1423,8 @@ void ospf_sr_ext_prefix_lsa_delete(struc
 
 	/* Sanity check */
 	if (OspfSR.neighbors == NULL) {
-		zlog_err("SR (%s): Abort! no valid SR DataBase", __func__);
+		flog_err(OSPF_ERR_SR_INVALID_DB,
+			  "SR (%s): Abort! no valid SR DataBase", __func__);
 		return;
 	}
 
@@ -1536,10 +1538,6 @@ static void ospf_sr_nhlfe_update(struct
 	struct sr_nhlfe old;
 	int rc;
 
-	/* Sanity Check */
-	if (srn == NULL)
-		return;
-
 	if (IS_DEBUG_OSPF_SR)
 		zlog_debug("  |-  Update Prefix for SR Node %s",
 			   inet_ntoa(srn->adv_router));
diff -urpN frr-frr-5.0.1/ospfd/ospf_te.c frr-frr-6.0/ospfd/ospf_te.c
--- frr-frr-5.0.1/ospfd/ospf_te.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_te.c	2018-10-08 14:32:57.000000000 +0200
@@ -857,11 +857,6 @@ static int ospf_mpls_te_new_if(struct in
 	}
 
 	new = XCALLOC(MTYPE_OSPF_MPLS_TE, sizeof(struct mpls_te_link));
-	if (new == NULL) {
-		zlog_warn("ospf_mpls_te_new_if: XMALLOC: %s",
-			  safe_strerror(errno));
-		return rc;
-	}
 
 	new->instance = get_mpls_te_instance_value();
 	new->ifp = ifp;
@@ -1206,18 +1201,7 @@ static struct ospf_lsa *ospf_mpls_te_lsa
 	lsah->length = htons(length);
 
 	/* Now, create an OSPF LSA instance. */
-	if ((new = ospf_lsa_new()) == NULL) {
-		zlog_warn("%s: ospf_lsa_new() ?", __func__);
-		stream_free(s);
-		return NULL;
-	}
-	if ((new->data = ospf_lsa_data_new(length)) == NULL) {
-		zlog_warn("%s: ospf_lsa_data_new() ?", __func__);
-		ospf_lsa_unlock(&new);
-		new = NULL;
-		stream_free(s);
-		return new;
-	}
+	new = ospf_lsa_new_and_data(length);
 
 	new->vrf_id = ospf->vrf_id;
 	if (area && area->ospf)
@@ -1451,6 +1435,8 @@ static struct ospf_lsa *ospf_mpls_te_lsa
 		zlog_warn("ospf_mpls_te_lsa_refresh: Invalid parameter?");
 		lsa->data->ls_age =
 			htons(OSPF_LSA_MAXAGE); /* Flush it anyway. */
+		ospf_opaque_lsa_flush_schedule(lsa);
+		return NULL;
 	}
 
 	/* Check if lp was not disable in the interval */
@@ -1463,8 +1449,7 @@ static struct ospf_lsa *ospf_mpls_te_lsa
 
 	/* If the lsa's age reached to MaxAge, start flushing procedure. */
 	if (IS_LSA_MAXAGE(lsa)) {
-		if (lp)
-			UNSET_FLAG(lp->flags, LPFLG_LSA_ENGAGED);
+		UNSET_FLAG(lp->flags, LPFLG_LSA_ENGAGED);
 		ospf_opaque_lsa_flush_schedule(lsa);
 		return NULL;
 	}
@@ -2050,12 +2035,11 @@ static uint16_t ospf_mpls_te_show_link_s
 					      struct tlv_header *tlvh0,
 					      uint16_t subtotal, uint16_t total)
 {
-	struct tlv_header *tlvh, *next;
+	struct tlv_header *tlvh;
 	uint16_t sum = subtotal;
 
 	for (tlvh = tlvh0; sum < total;
-	     tlvh = (next ? next : TLV_HDR_NEXT(tlvh))) {
-		next = NULL;
+	     tlvh = TLV_HDR_NEXT(tlvh)) {
 		switch (ntohs(tlvh->type)) {
 		case TE_LINK_SUBTLV_LINK_TYPE:
 			sum += show_vty_link_subtlv_link_type(vty, tlvh);
diff -urpN frr-frr-5.0.1/ospfd/ospf_vty.c frr-frr-6.0/ospfd/ospf_vty.c
--- frr-frr-5.0.1/ospfd/ospf_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -72,13 +72,11 @@ int str2area_id(const char *str, struct
 	return 0;
 }
 
-void area_id2str(char *buf, int length, struct in_addr *area_id,
-		 int area_id_fmt)
+static void area_id2str(char *buf, int length, struct in_addr *area_id,
+			int area_id_fmt)
 {
-	memset(buf, 0, length);
-
 	if (area_id_fmt == OSPF_AREA_ID_FMT_DOTTEDQUAD)
-		strncpy(buf, inet_ntoa(*area_id), length);
+		inet_ntop(AF_INET, area_id, buf, length);
 	else
 		sprintf(buf, "%lu", (unsigned long)ntohl(area_id->s_addr));
 }
@@ -2338,27 +2336,6 @@ DEFUN (no_ospf_timers_lsa_min_arrival,
 	return CMD_SUCCESS;
 }
 
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180708
-CPP_NOTICE("ospf: `timers lsa arrival (0-1000)` deprecated 2017/07/08")
-#endif
-ALIAS_HIDDEN(ospf_timers_lsa_min_arrival, ospf_timers_lsa_arrival_cmd,
-	     "timers lsa arrival (0-1000)",
-	     "adjust routing timers\n"
-	     "throttling link state advertisement delays\n"
-	     "ospf minimum arrival interval delay\n"
-	     "delay (msec) between accepted lsas\n");
-
-#if defined(VERSION_TYPE_DEV) && CONFDATE > 20180708
-CPP_NOTICE("ospf: `no timers lsa arrival (0-1000)` deprecated 2017/07/08")
-#endif
-ALIAS_HIDDEN(no_ospf_timers_lsa_min_arrival, no_ospf_timers_lsa_arrival_cmd,
-	     "no timers lsa arrival (0-1000)", NO_STR
-	     "adjust routing timers\n"
-	     "throttling link state advertisement delays\n"
-	     "ospf minimum arrival interval delay\n"
-	     "delay (msec) between accepted lsas\n");
-
-
 DEFUN (ospf_neighbor,
        ospf_neighbor_cmd,
        "neighbor A.B.C.D [priority (0-255) [poll-interval (1-65535)]]",
@@ -2414,8 +2391,8 @@ DEFUN (ospf_neighbor_poll_interval,
 	int idx_poll = 3;
 	int idx_pri = 5;
 	struct in_addr nbr_addr;
-	unsigned int priority = OSPF_NEIGHBOR_PRIORITY_DEFAULT;
-	unsigned int interval = OSPF_POLL_INTERVAL_DEFAULT;
+	unsigned int priority;
+	unsigned int interval;
 
 	if (!inet_aton(argv[idx_ipv4]->arg, &nbr_addr)) {
 		vty_out(vty, "Please specify Neighbor ID by A.B.C.D\n");
@@ -2424,8 +2401,8 @@ DEFUN (ospf_neighbor_poll_interval,
 
 	interval = strtoul(argv[idx_poll]->arg, NULL, 10);
 
-	if (argc > 4)
-		priority = strtoul(argv[idx_pri]->arg, NULL, 10);
+	priority = argc > 4 ? strtoul(argv[idx_pri]->arg, NULL, 10)
+			    : OSPF_NEIGHBOR_PRIORITY_DEFAULT;
 
 	ospf_nbr_nbma_set(ospf, nbr_addr);
 	ospf_nbr_nbma_poll_interval_set(ospf, nbr_addr, interval);
@@ -4811,16 +4788,19 @@ static void show_ip_ospf_nbr_nbma_detail
 		vty_out(vty, "    Poll interval %d\n", nbr_nbma->v_poll);
 
 	/* Show poll-interval timer. */
-	if (use_json) {
-		long time_store;
-		time_store = monotime_until(&nbr_nbma->t_poll->u.sands, NULL)
-			     / 1000LL;
-		json_object_int_add(json_sub, "pollIntervalTimerDueMsec",
-				    time_store);
-	} else
-		vty_out(vty, "    Poll timer due in %s\n",
-			ospf_timer_dump(nbr_nbma->t_poll, timebuf,
-					sizeof(timebuf)));
+	if (nbr_nbma->t_poll) {
+		if (use_json) {
+			long time_store;
+			time_store = monotime_until(&nbr_nbma->t_poll->u.sands,
+						    NULL) / 1000LL;
+			json_object_int_add(json_sub,
+					    "pollIntervalTimerDueMsec",
+					    time_store);
+		} else
+			vty_out(vty, "    Poll timer due in %s\n",
+				ospf_timer_dump(nbr_nbma->t_poll, timebuf,
+						sizeof(timebuf)));
+	}
 
 	/* Show poll-interval timer thread. */
 	if (use_json) {
@@ -8084,9 +8064,6 @@ DEFUN (ospf_redistribute_source,
 	struct ospf_redist *red;
 	int idx = 0;
 
-	if (!ospf)
-		return CMD_SUCCESS;
-
 	/* Get distribute source. */
 	source = proto_redistnum(AFI_IP, argv[idx_protocol]->text);
 	if (source < 0)
@@ -8169,15 +8146,14 @@ DEFUN (ospf_redistribute_instance_source
 	unsigned short instance;
 	struct ospf_redist *red;
 
-	if (!ospf)
-		return CMD_SUCCESS;
-
 	source = proto_redistnum(AFI_IP, argv[idx_ospf_table]->text);
 
-	instance = strtoul(argv[idx_number]->arg, NULL, 10);
+	if (source < 0) {
+		vty_out(vty, "Unknown instance redistribution\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
 
-	if (!ospf)
-		return CMD_SUCCESS;
+	instance = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	if ((source == ZEBRA_ROUTE_OSPF) && !ospf->instance) {
 		vty_out(vty,
@@ -8469,9 +8445,6 @@ DEFUN (no_ospf_distance_ospf,
 	VTY_DECLVAR_INSTANCE_CONTEXT(ospf, ospf);
 	int idx = 0;
 
-	if (!ospf)
-		return CMD_SUCCESS;
-
 	if (argv_find(argv, argc, "intra-area", &idx) || argc == 3)
 		idx = ospf->distance_intra = 0;
 	if (argv_find(argv, argc, "inter-area", &idx) || argc == 3)
@@ -8525,9 +8498,6 @@ DEFUN (ospf_distance_source,
   int idx_number = 1;
   int idx_ipv4_prefixlen = 2;
 
-  if (!ospf)
-    return CMD_SUCCESS;
-
   ospf_distance_set (vty, ospf, argv[idx_number]->arg, argv[idx_ipv4_prefixlen]->arg, NULL);
 
   return CMD_SUCCESS;
@@ -8545,9 +8515,6 @@ DEFUN (no_ospf_distance_source,
   int idx_number = 2;
   int idx_ipv4_prefixlen = 3;
 
-  if (!ospf)
-    return CMD_SUCCESS;
-
   ospf_distance_unset (vty, ospf, argv[idx_number]->arg, argv[idx_ipv4_prefixlen]->arg, NULL);
 
   return CMD_SUCCESS;
@@ -8566,9 +8533,6 @@ DEFUN (ospf_distance_source_access_list,
   int idx_ipv4_prefixlen = 2;
   int idx_word = 3;
 
-  if (!ospf)
-    return CMD_SUCCESS;
-
   ospf_distance_set (vty, ospf, argv[idx_number]->arg, argv[idx_ipv4_prefixlen]->arg, argv[idx_word]->arg);
 
   return CMD_SUCCESS;
@@ -8588,9 +8552,6 @@ DEFUN (no_ospf_distance_source_access_li
   int idx_ipv4_prefixlen = 3;
   int idx_word = 4;
 
-  if (!ospf)
-    return CMD_SUCCESS;
-
   ospf_distance_unset (vty, ospf, argv[idx_number]->arg, argv[idx_ipv4_prefixlen]->arg, argv[idx_word]->arg);
 
   return CMD_SUCCESS;
@@ -9788,10 +9749,7 @@ static int config_write_interface_one(st
 				else
 					vty_out(vty, " ip ospf");
 
-
-				size_t buflen = MAX(strlen("4294967295"),
-						    strlen("255.255.255.255"));
-				char buf[buflen];
+				char buf[INET_ADDRSTRLEN];
 
 				area_id2str(buf, sizeof(buf), &params->if_area,
 					    params->if_area_id_fmt);
@@ -9803,7 +9761,7 @@ static int config_write_interface_one(st
 			}
 
 			/* bfd  print. */
-			if (params->bfd_info)
+			if (params && params->bfd_info)
 				ospf_bfd_write_config(vty, params);
 
 			/* MTU ignore print. */
@@ -9866,12 +9824,10 @@ static int config_write_network_area(str
 		if (rn->info) {
 			struct ospf_network *n = rn->info;
 
-			memset(buf, 0, INET_ADDRSTRLEN);
-
 			/* Create Area ID string by specified Area ID format. */
 			if (n->area_id_fmt == OSPF_AREA_ID_FMT_DOTTEDQUAD)
-				strncpy((char *)buf, inet_ntoa(n->area_id),
-					INET_ADDRSTRLEN);
+				inet_ntop(AF_INET, &n->area_id, (char *)buf,
+					  sizeof(buf));
 			else
 				sprintf((char *)buf, "%lu",
 					(unsigned long int)ntohl(
@@ -9896,7 +9852,7 @@ static int config_write_ospf_area(struct
 	for (ALL_LIST_ELEMENTS_RO(ospf->areas, node, area)) {
 		struct route_node *rn1;
 
-		area_id2str((char *)buf, INET_ADDRSTRLEN, &area->area_id,
+		area_id2str((char *)buf, sizeof(buf), &area->area_id,
 			    area->area_id_fmt);
 
 		if (area->auth_type != OSPF_AUTH_NULL) {
@@ -10031,8 +9987,6 @@ static int config_write_virtual_link(str
 		struct ospf_interface *oi;
 
 		if (vl_data != NULL) {
-			memset(buf, 0, INET_ADDRSTRLEN);
-
 			area_id2str(buf, sizeof(buf), &vl_data->vl_area_id,
 				    vl_data->vl_area_id_fmt);
 			oi = vl_data->vl_oi;
@@ -10686,8 +10640,6 @@ void ospf_vty_init(void)
 	install_element(OSPF_NODE, &no_ospf_timers_min_ls_interval_cmd);
 	install_element(OSPF_NODE, &ospf_timers_lsa_min_arrival_cmd);
 	install_element(OSPF_NODE, &no_ospf_timers_lsa_min_arrival_cmd);
-	install_element(OSPF_NODE, &ospf_timers_lsa_arrival_cmd);
-	install_element(OSPF_NODE, &no_ospf_timers_lsa_arrival_cmd);
 
 	/* refresh timer commands */
 	install_element(OSPF_NODE, &ospf_refresh_timer_cmd);
diff -urpN frr-frr-5.0.1/ospfd/ospf_vty.h frr-frr-6.0/ospfd/ospf_vty.h
--- frr-frr-5.0.1/ospfd/ospf_vty.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_vty.h	2018-10-08 14:32:57.000000000 +0200
@@ -53,6 +53,5 @@ extern void ospf_vty_init(void);
 extern void ospf_vty_show_init(void);
 extern void ospf_vty_clear_init(void);
 extern int str2area_id(const char *, struct in_addr *, int *);
-extern void area_id2str(char *, int, struct in_addr *, int);
 
 #endif /* _QUAGGA_OSPF_VTY_H */
diff -urpN frr-frr-5.0.1/ospfd/ospf_zebra.c frr-frr-6.0/ospfd/ospf_zebra.c
--- frr-frr-5.0.1/ospfd/ospf_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospf_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -111,10 +111,11 @@ static int ospf_interface_add(int comman
 
 	if (IS_DEBUG_OSPF(zebra, ZEBRA_INTERFACE))
 		zlog_debug(
-			"Zebra: interface add %s vrf %s[%u] index %d flags %llx metric %d mtu %d",
+			"Zebra: interface add %s vrf %s[%u] index %d flags %llx metric %d mtu %d speed %u",
 			ifp->name, ospf_vrf_id_to_name(ifp->vrf_id),
 			ifp->vrf_id, ifp->ifindex,
-			(unsigned long long)ifp->flags, ifp->metric, ifp->mtu);
+			(unsigned long long)ifp->flags, ifp->metric, ifp->mtu,
+			ifp->speed);
 
 	assert(ifp->info);
 
@@ -128,6 +129,8 @@ static int ospf_interface_add(int comman
 	if (!ospf)
 		return 0;
 
+	ospf_if_recalculate_output_cost(ifp);
+
 	ospf_if_update(ospf, ifp);
 
 	hook_call(ospf_if_update, ifp);
@@ -448,14 +451,17 @@ void ospf_zebra_add(struct ospf *ospf, s
 		count++;
 
 		if (IS_DEBUG_OSPF(zebra, ZEBRA_REDISTRIBUTE)) {
-			char buf[2][PREFIX2STR_BUFFER];
+			char buf[2][INET_ADDRSTRLEN];
+			struct interface *ifp;
+
+			ifp = if_lookup_by_index(path->ifindex, ospf->vrf_id);
 
 			zlog_debug(
-				"Zebra: Route add %s nexthop %s, ifindex=%d",
+				"Zebra: Route add %s nexthop %s, ifindex=%d %s",
 				prefix2str(p, buf[0], sizeof(buf[0])),
 			        inet_ntop(AF_INET, &path->nexthop,
 					  buf[1], sizeof(buf[1])),
-				path->ifindex);
+				path->ifindex, ifp ? ifp->name : " ");
 		}
 	}
 	api.nexthop_num = count;
@@ -670,6 +676,16 @@ int ospf_redistribute_set(struct ospf *o
 	struct ospf_redist *red;
 
 	red = ospf_redist_lookup(ospf, type, instance);
+
+	if (red == NULL) {
+		zlog_err(
+			 "Redistribute[%s][%d]: Lookup failed  Type[%d] , Metric[%d]",
+			 ospf_redist_string(type), instance,
+			 metric_type(ospf, type, instance),
+			 metric_value(ospf, type, instance));
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
 	if (ospf_is_type_redistributed(ospf, type, instance)) {
 		if (mtype != red->dmetric.type) {
 			red->dmetric.type = mtype;
diff -urpN frr-frr-5.0.1/ospfd/ospfd.c frr-frr-6.0/ospfd/ospfd.c
--- frr-frr-5.0.1/ospfd/ospfd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/ospfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@
 #include "bfd.h"
 #include "libfrr.h"
 #include "defaults.h"
+#include "lib_errors.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_network.h"
@@ -51,10 +52,10 @@
 #include "ospfd/ospf_spf.h"
 #include "ospfd/ospf_packet.h"
 #include "ospfd/ospf_dump.h"
+#include "ospfd/ospf_route.h"
 #include "ospfd/ospf_zebra.h"
 #include "ospfd/ospf_abr.h"
 #include "ospfd/ospf_flood.h"
-#include "ospfd/ospf_route.h"
 #include "ospfd/ospf_ase.h"
 
 
@@ -243,13 +244,14 @@ static struct ospf *ospf_new(unsigned sh
 			zlog_debug(
 				"%s: Create new ospf instance with vrf_name %s vrf_id %u",
 				__PRETTY_FUNCTION__, name, new->vrf_id);
-		if (vrf)
-			ospf_vrf_link(new, vrf);
 	} else {
 		new->vrf_id = VRF_DEFAULT;
 		vrf = vrf_lookup_by_id(VRF_DEFAULT);
-		ospf_vrf_link(new, vrf);
 	}
+
+	if (vrf)
+		ospf_vrf_link(new, vrf);
+
 	ospf_zebra_vrf_register(new);
 
 	new->abr_type = OSPF_ABR_DEFAULT;
@@ -560,9 +562,6 @@ void ospf_terminate(void)
 		ospf_finish(ospf);
 
 	/* Cleanup route maps */
-	route_map_add_hook(NULL);
-	route_map_delete_hook(NULL);
-	route_map_event_hook(NULL);
 	route_map_finish();
 
 	/* reverse prefix_list_init */
@@ -2089,25 +2088,17 @@ static int ospf_vrf_enable(struct vrf *v
 				old_vrf_id);
 
 		if (old_vrf_id != ospf->vrf_id) {
-			if (ospfd_privs.change(ZPRIVS_RAISE)) {
-				zlog_err(
-					"ospf_sock_init: could not raise privs, %s",
-					safe_strerror(errno));
-			}
-
-			/* stop zebra redist to us for old vrf */
-			zclient_send_dereg_requests(zclient, old_vrf_id);
+			frr_elevate_privs(&ospfd_privs) {
+				/* stop zebra redist to us for old vrf */
+				zclient_send_dereg_requests(zclient,
+							    old_vrf_id);
 
-			ospf_set_redist_vrf_bitmaps(ospf);
+				ospf_set_redist_vrf_bitmaps(ospf);
 
-			/* start zebra redist to us for new vrf */
-			ospf_zebra_vrf_register(ospf);
+				/* start zebra redist to us for new vrf */
+				ospf_zebra_vrf_register(ospf);
 
-			ret = ospf_sock_init(ospf);
-			if (ospfd_privs.change(ZPRIVS_LOWER)) {
-				zlog_err(
-					"ospf_sock_init: could not lower privs, %s",
-					safe_strerror(errno));
+				ret = ospf_sock_init(ospf);
 			}
 			if (ret < 0 || ospf->fd <= 0)
 				return 0;
diff -urpN frr-frr-5.0.1/ospfd/subdir.am frr-frr-6.0/ospfd/subdir.am
--- frr-frr-5.0.1/ospfd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ospfd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -20,6 +20,7 @@ ospfd_libfrrospf_a_SOURCES = \
 	ospfd/ospf_bfd.c \
 	ospfd/ospf_dump.c \
 	ospfd/ospf_dump_api.c \
+	ospfd/ospf_errors.c \
 	ospfd/ospf_ext.c \
 	ospfd/ospf_flood.c \
 	ospfd/ospf_ia.c \
@@ -68,6 +69,7 @@ noinst_HEADERS += \
 	ospfd/ospf_apiserver.h \
 	ospfd/ospf_ase.h \
 	ospfd/ospf_bfd.h \
+	ospfd/ospf_errors.h \
 	ospfd/ospf_ext.h \
 	ospfd/ospf_flood.h \
 	ospfd/ospf_ia.h \
@@ -89,7 +91,7 @@ ospfd_ospfd_LDADD = ospfd/libfrrospf.a l
 ospfd_ospfd_SOURCES = ospfd/ospf_main.c
 
 ospfd_ospfd_snmp_la_SOURCES = ospfd/ospf_snmp.c
-ospfd_ospfd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+ospfd_ospfd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 ospfd_ospfd_snmp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 ospfd_ospfd_snmp_la_LIBADD = lib/libfrrsnmp.la
 
diff -urpN frr-frr-5.0.1/pbrd/pbr_nht.c frr-frr-6.0/pbrd/pbr_nht.c
--- frr-frr-5.0.1/pbrd/pbr_nht.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pbrd/pbr_nht.c	2018-10-08 14:32:57.000000000 +0200
@@ -192,7 +192,7 @@ static void *pbr_nhgc_alloc(void *p)
 	new = XCALLOC(MTYPE_PBR_NHG, sizeof(*new));
 
 	strcpy(new->name, pnhgc->name);
-	new->table_id = pbr_nht_get_next_tableid();
+	new->table_id = pbr_nht_get_next_tableid(false);
 
 	DEBUGD(&pbr_dbg_nht, "%s: NHT: %s assigned Table ID: %u",
 	       __PRETTY_FUNCTION__, new->name, new->table_id);
@@ -218,6 +218,9 @@ void pbr_nhgroup_add_cb(const char *name
 
 	pnhgc = pbr_nht_add_group(name);
 
+	if (!pnhgc)
+		return;
+
 	DEBUGD(&pbr_dbg_nht, "%s: Added nexthop-group %s", __PRETTY_FUNCTION__,
 	       name);
 
@@ -234,6 +237,13 @@ void pbr_nhgroup_add_nexthop_cb(const st
 	struct pbr_nexthop_cache pnhc_find = {};
 	struct pbr_nexthop_cache *pnhc;
 
+	if (!pbr_nht_get_next_tableid(true)) {
+		zlog_warn(
+			"%s: Exhausted all table identifiers; cannot create nexthop-group cache for nexthop-group '%s'",
+			__PRETTY_FUNCTION__, nhgc->name);
+		return;
+	}
+
 	/* find pnhgc by name */
 	strlcpy(pnhgc_find.name, nhgc->name, sizeof(pnhgc_find.name));
 	pnhgc = hash_get(pbr_nhg_hash, &pnhgc_find, pbr_nhgc_alloc);
@@ -268,7 +278,7 @@ void pbr_nhgroup_del_nexthop_cb(const st
 
 	/* find pnhgc by name */
 	strlcpy(pnhgc_find.name, nhgc->name, sizeof(pnhgc_find.name));
-	pnhgc = hash_get(pbr_nhg_hash, &pnhgc_find, pbr_nhgc_alloc);
+	pnhgc = hash_lookup(pbr_nhg_hash, &pnhgc_find);
 
 	/* delete pnhc from pnhgc->nhh */
 	pnhc_find.nexthop = (struct nexthop *)nhop;
@@ -487,6 +497,14 @@ void pbr_nht_add_individual_nexthop(stru
 	memset(&find, 0, sizeof(find));
 	pbr_nht_nexthop_make_name(pbrms->parent->name, PBR_NHC_NAMELEN,
 				  pbrms->seqno, find.name);
+
+	if (!pbr_nht_get_next_tableid(true)) {
+		zlog_warn(
+			"%s: Exhausted all table identifiers; cannot create nexthop-group cache for nexthop-group '%s'",
+			__PRETTY_FUNCTION__, find.name);
+		return;
+	}
+
 	if (!pbrms->internal_nhg_name)
 		pbrms->internal_nhg_name = XSTRDUP(MTYPE_TMP, find.name);
 
@@ -547,11 +565,18 @@ struct pbr_nexthop_group_cache *pbr_nht_
 	struct pbr_nexthop_group_cache *pnhgc;
 	struct pbr_nexthop_group_cache lookup;
 
+	if (!pbr_nht_get_next_tableid(true)) {
+		zlog_warn(
+			"%s: Exhausted all table identifiers; cannot create nexthop-group cache for nexthop-group '%s'",
+			__PRETTY_FUNCTION__, name);
+		return NULL;
+	}
+
 	nhgc = nhgc_find(name);
 
 	if (!nhgc) {
-		zlog_warn("%s: Could not find group %s to add",
-			  __PRETTY_FUNCTION__, name);
+		DEBUGD(&pbr_dbg_nht, "%s: Could not find nhgc with name: %s\n",
+		       __PRETTY_FUNCTION__, name);
 		return NULL;
 	}
 
@@ -709,8 +734,7 @@ static int pbr_nhg_hash_equal(const void
 	return !strcmp(nhgc1->name, nhgc2->name);
 }
 
-
-uint32_t pbr_nht_get_next_tableid(void)
+uint32_t pbr_nht_get_next_tableid(bool peek)
 {
 	uint32_t i;
 	bool found = false;
@@ -723,7 +747,7 @@ uint32_t pbr_nht_get_next_tableid(void)
 	}
 
 	if (found) {
-		nhg_tableid[i] = true;
+		nhg_tableid[i] = !peek;
 		return i;
 	} else
 		return 0;
diff -urpN frr-frr-5.0.1/pbrd/pbr_nht.h frr-frr-6.0/pbrd/pbr_nht.h
--- frr-frr-5.0.1/pbrd/pbr_nht.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pbrd/pbr_nht.h	2018-10-08 14:32:57.000000000 +0200
@@ -56,9 +56,13 @@ extern void pbr_nht_write_table_range(st
 extern void pbr_nht_set_tableid_range(uint32_t low, uint32_t high);
 
 /*
- * Get the next tableid to use for installation
+ * Get the next tableid to use for installation.
+ *
+ * peek
+ *    If set to true, retrieves the next ID without marking it used. The next
+ *    call will return the same ID.
  */
-extern uint32_t pbr_nht_get_next_tableid(void);
+extern uint32_t pbr_nht_get_next_tableid(bool peek);
 /*
  * Get the next rule number to use for installation
  */
diff -urpN frr-frr-5.0.1/pbrd/pbr_vty.c frr-frr-6.0/pbrd/pbr_vty.c
--- frr-frr-5.0.1/pbrd/pbr_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pbrd/pbr_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,8 +26,8 @@
 #include "nexthop.h"
 #include "nexthop_group.h"
 #include "log.h"
-#include "json.h"
 #include "debug.h"
+#include "pbr.h"
 
 #include "pbrd/pbr_nht.h"
 #include "pbrd/pbr_map.h"
@@ -38,7 +38,7 @@
 #include "pbrd/pbr_vty_clippy.c"
 #endif
 
-DEFUN_NOSH(pbr_map, pbr_map_cmd, "pbr-map WORD seq (1-1000)",
+DEFUN_NOSH(pbr_map, pbr_map_cmd, "pbr-map WORD seq (1-700)",
 	   "Create pbr-map or enter pbr-map command mode\n"
 	   "The name of the PBR MAP\n"
 	   "Sequence to insert in existing pbr-map entry\n"
@@ -54,7 +54,7 @@ DEFUN_NOSH(pbr_map, pbr_map_cmd, "pbr-ma
 	return CMD_SUCCESS;
 }
 
-DEFUN_NOSH(no_pbr_map, no_pbr_map_cmd, "no pbr-map WORD [seq (1-65535)]",
+DEFUN_NOSH(no_pbr_map, no_pbr_map_cmd, "no pbr-map WORD [seq (1-700)]",
 	   NO_STR
 	   "Delete pbr-map\n"
 	   "The name of the PBR MAP\n"
@@ -85,6 +85,34 @@ DEFUN_NOSH(no_pbr_map, no_pbr_map_cmd, "
 	return CMD_SUCCESS;
 }
 
+DEFPY(pbr_set_table_range,
+      pbr_set_table_range_cmd,
+      "[no] pbr table range (10000-4294966272)$lb (10000-4294966272)$ub",
+      NO_STR
+      PBR_STR
+      "Set table ID range\n"
+      "Set table ID range\n"
+      "Lower bound for table ID range\n"
+      "Upper bound for table ID range\n")
+{
+	/* upper bound is 2^32 - 2^10 */
+	int ret = CMD_WARNING;
+	const int minrange = 1000;
+
+	/* validate given bounds */
+	if (lb > ub)
+		vty_out(vty, "%% Lower bound must be less than upper bound\n");
+	else if (ub - lb < minrange)
+		vty_out(vty, "%% Range breadth must be at least %d\n", minrange);
+	else {
+		ret = CMD_SUCCESS;
+		pbr_nht_set_tableid_range((uint32_t) lb, (uint32_t) ub);
+	}
+
+	return ret;
+}
+
+
 DEFPY(pbr_map_match_src, pbr_map_match_src_cmd,
 	"[no] match src-ip <A.B.C.D/M|X:X::X:X/M>$prefix",
 	NO_STR
@@ -355,10 +383,9 @@ DEFPY (pbr_policy,
 
 DEFPY (show_pbr,
 	show_pbr_cmd,
-	"show pbr [json$json]",
+	"show pbr",
 	SHOW_STR
-	"Policy Based Routing\n"
-	JSON_STR)
+	PBR_STR)
 {
 	pbr_nht_write_table_range(vty);
 	pbr_nht_write_rule_range(vty);
@@ -368,13 +395,12 @@ DEFPY (show_pbr,
 
 DEFPY (show_pbr_map,
 	show_pbr_map_cmd,
-	"show pbr map [NAME$name] [detail$detail] [json$json]",
+	"show pbr map [NAME$name] [detail$detail]",
 	SHOW_STR
-	"Policy Based Routing\n"
+	PBR_STR
 	"PBR Map\n"
 	"PBR Map Name\n"
-	"Detailed information\n"
-	JSON_STR)
+	"Detailed information\n")
 {
 	struct pbr_map_sequence *pbrms;
 	struct pbr_map *pbrm;
@@ -439,7 +465,7 @@ DEFPY(show_pbr_nexthop_group,
       show_pbr_nexthop_group_cmd,
       "show pbr nexthop-groups [WORD$word]",
       SHOW_STR
-      "Policy Based Routing\n"
+      PBR_STR
       "Nexthop Groups\n"
       "Optional Name of the nexthop group\n")
 {
@@ -450,12 +476,11 @@ DEFPY(show_pbr_nexthop_group,
 
 DEFPY (show_pbr_interface,
 	show_pbr_interface_cmd,
-	"show pbr interface [NAME$name] [json$json]",
+	"show pbr interface [NAME$name]",
 	SHOW_STR
-	"Policy Based Routing\n"
+	PBR_STR
 	"PBR Interface\n"
-	"PBR Interface Name\n"
-	JSON_STR)
+	"PBR Interface Name\n")
 {
 	struct interface *ifp;
 	struct vrf *vrf;
@@ -489,7 +514,6 @@ DEFPY (show_pbr_interface,
 }
 
 /* PBR debugging CLI ------------------------------------------------------- */
-/* clang-format off */
 
 static struct cmd_node debug_node = {DEBUG_NODE, "", 1};
 
@@ -498,7 +522,7 @@ DEFPY(debug_pbr,
       "[no] debug pbr [{map$map|zebra$zebra|nht$nht|events$events}]",
       NO_STR
       DEBUG_STR
-      "Policy Based Routing\n"
+      PBR_STR
       "Policy maps\n"
       "PBRD <-> Zebra communications\n"
       "Nexthop tracking\n"
@@ -527,7 +551,7 @@ DEFUN_NOSH(show_debugging_pbr,
 	   "show debugging [pbr]",
 	   SHOW_STR
 	   DEBUG_STR
-	   "Policy Based Routing\n")
+	   PBR_STR)
 {
 	vty_out(vty, "PBR debugging status:\n");
 
@@ -536,7 +560,6 @@ DEFUN_NOSH(show_debugging_pbr,
 	return CMD_SUCCESS;
 }
 
-/* clang-format on */
 /* ------------------------------------------------------------------------- */
 
 
@@ -557,6 +580,9 @@ static int pbr_interface_config_write(st
 				vty_frame(vty, "interface %s vrf %s\n",
 					  ifp->name, vrf->name);
 
+			if (ifp->desc)
+				vty_out(vty, " description %s\n", ifp->desc);
+
 			pbr_map_write_interfaces(vty, ifp);
 
 			vty_endframe(vty, "!\n");
@@ -634,6 +660,7 @@ void pbr_vty_init(void)
 
 	install_element(CONFIG_NODE, &pbr_map_cmd);
 	install_element(CONFIG_NODE, &no_pbr_map_cmd);
+	install_element(CONFIG_NODE, &pbr_set_table_range_cmd);
 	install_element(INTERFACE_NODE, &pbr_policy_cmd);
 	install_element(PBRMAP_NODE, &pbr_map_match_src_cmd);
 	install_element(PBRMAP_NODE, &pbr_map_match_dst_cmd);
diff -urpN frr-frr-5.0.1/pbrd/pbr_zebra.c frr-frr-6.0/pbrd/pbr_zebra.c
--- frr-frr-5.0.1/pbrd/pbr_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pbrd/pbr_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -54,12 +54,6 @@ struct pbr_interface *pbr_if_new(struct
 
 	pbr_ifp = XCALLOC(MTYPE_PBR_INTERFACE, sizeof(*pbr_ifp));
 
-	if (!pbr_ifp) {
-		zlog_err("%s: PBR XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*pbr_ifp));
-		return 0;
-	}
-
 	ifp->info = pbr_ifp;
 	return pbr_ifp;
 }
diff -urpN frr-frr-5.0.1/pimd/COMMANDS frr-frr-6.0/pimd/COMMANDS
--- frr-frr-5.0.1/pimd/COMMANDS	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/COMMANDS	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@ verification commands:
        show ip igmp groups retransmissions	IGMP group retransmission
        show ip igmp sources			IGMP sources information
        show ip igmp sources retransmissions	IGMP source retransmission
+       show ip igmp statistics			IGMP statistics information
        show ip pim address			PIM interface address
        show ip pim assert			PIM interface assert
        show ip pim assert-internal		PIM interface internal assert state
diff -urpN frr-frr-5.0.1/pimd/mtracebis.c frr-frr-6.0/pimd/mtracebis.c
--- frr-frr-5.0.1/pimd/mtracebis.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/mtracebis.c	2018-10-08 14:32:57.000000000 +0200
@@ -266,6 +266,8 @@ static int recv_response(int fd, int *ho
 	int mtrace_len;
 	int responses;
 	unsigned short sum;
+	size_t mtrace_off;
+	size_t ip_len;
 
 	recvd = recvfrom(fd, mtrace_buf, IP_AND_MTRACE_BUF_LEN, 0, NULL, 0);
 
@@ -292,13 +294,20 @@ static int recv_response(int fd, int *ho
 	if (sum != in_cksum(ip, ip->ip_hl * 4))
 		return -1;
 
-	mtrace = (struct igmp_mtrace *)(mtrace_buf + (4 * ip->ip_hl));
-
-	mtrace_len = ntohs(ip->ip_len) - ip->ip_hl * 4;
+	/* Header overflow check */
+	mtrace_off = 4 * ip->ip_hl;
+	if (mtrace_off > MTRACE_BUF_LEN)
+		return -1;
 
-	if (mtrace_len < (int)MTRACE_HDR_SIZE)
+	/* Underflow/overflow check */
+	ip_len = ntohs(ip->ip_len);
+	if (ip_len < mtrace_off || ip_len < MTRACE_HDR_SIZE
+	    || ip_len > MTRACE_BUF_LEN)
 		return -1;
 
+	mtrace_len = ip_len - mtrace_off;
+	mtrace = (struct igmp_mtrace *)(mtrace_buf + mtrace_off);
+
 	sum = mtrace->checksum;
 	mtrace->checksum = 0;
 	if (sum != in_cksum(mtrace, mtrace_len)) {
@@ -332,7 +341,7 @@ static int wait_for_response(int fd, int
 {
 	fd_set readfds;
 	struct timeval timeout;
-	int ret = -1;
+	int ret;
 	long msec, rmsec, tmsec;
 
 	FD_ZERO(&readfds);
diff -urpN frr-frr-5.0.1/pimd/mtracebis_netlink.c frr-frr-6.0/pimd/mtracebis_netlink.c
--- frr-frr-5.0.1/pimd/mtracebis_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/mtracebis_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -489,7 +489,6 @@ int rtnl_listen(struct rtnl_handle *rtnl
 
 int rtnl_from_file(FILE *rtnl, rtnl_filter_t handler, void *jarg)
 {
-	int status;
 	struct sockaddr_nl nladdr;
 	char buf[8192];
 	struct nlmsghdr *h = (void *)buf;
@@ -500,37 +499,43 @@ int rtnl_from_file(FILE *rtnl, rtnl_filt
 	nladdr.nl_groups = 0;
 
 	while (1) {
-		int err, len;
-		int l;
+		int err;
+		size_t l, rl, arl;
 
-		status = fread(&buf, 1, sizeof(*h), rtnl);
+		rl = sizeof(*h);
+		arl = fread(&buf, 1, rl, rtnl);
 
-		if (status < 0) {
-			if (errno == EINTR)
-				continue;
-			perror("rtnl_from_file: fread");
+		if (arl != rl) {
+			if (arl == 0)
+				return 0;
+
+			if (ferror(rtnl))
+				fprintf(stderr, "%s: header read failed\n",
+					__func__);
+			else
+				fprintf(stderr, "%s: truncated header\n",
+					__func__);
 			return -1;
 		}
-		if (status == 0)
-			return 0;
 
-		len = h->nlmsg_len;
-		l = len - sizeof(*h);
+		l = h->nlmsg_len > rl ? h->nlmsg_len - rl : 0;
 
-		if (l < 0 || len > (int)sizeof(buf)) {
-			fprintf(stderr, "!!!malformed message: len=%d @%lu\n",
-				len, ftell(rtnl));
+		if (l == 0 || (l + (size_t)NLMSG_HDRLEN) > sizeof(buf)) {
+			fprintf(stderr, "%s: malformed message: len=%zu @%lu\n",
+				__func__, (size_t)h->nlmsg_len, ftell(rtnl));
 			return -1;
 		}
 
-		status = fread(NLMSG_DATA(h), 1, NLMSG_ALIGN(l), rtnl);
+		rl = NLMSG_ALIGN(l);
+		arl = fread(NLMSG_DATA(h), 1, rl, rtnl);
 
-		if (status < 0) {
-			perror("rtnl_from_file: fread");
-			return -1;
-		}
-		if (status < l) {
-			fprintf(stderr, "rtnl-from_file: truncated message\n");
+		if (arl != rl) {
+			if (ferror(rtnl))
+				fprintf(stderr, "%s: msg read failed\n",
+					__func__);
+			else
+				fprintf(stderr, "%s: truncated message\n",
+					__func__);
 			return -1;
 		}
 
diff -urpN frr-frr-5.0.1/pimd/pim_bfd.c frr-frr-6.0/pimd/pim_bfd.c
--- frr-frr-5.0.1/pimd/pim_bfd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_bfd.c	2018-10-08 14:32:57.000000000 +0200
@@ -51,10 +51,12 @@ void pim_bfd_write_config(struct vty *vt
 	if (!bfd_info)
 		return;
 
+#if HAVE_BFDD == 0
 	if (CHECK_FLAG(bfd_info->flags, BFD_FLAG_PARAM_CFG))
 		vty_out(vty, " ip pim bfd %d %d %d\n", bfd_info->detect_mult,
 			bfd_info->required_min_rx, bfd_info->desired_min_tx);
 	else
+#endif /* ! HAVE_BFDD */
 		vty_out(vty, " ip pim bfd\n");
 }
 
@@ -99,9 +101,9 @@ void pim_bfd_info_nbr_create(struct pim_
 /*
  * pim_bfd_info_free - Free BFD info structure
  */
-void pim_bfd_info_free(void **bfd_info)
+void pim_bfd_info_free(struct bfd_info **bfd_info)
 {
-	bfd_info_free((struct bfd_info **)bfd_info);
+	bfd_info_free(bfd_info);
 }
 
 static void pim_bfd_reg_dereg_nbr(struct pim_neighbor *nbr, int command)
@@ -151,7 +153,7 @@ int pim_bfd_reg_dereg_all_nbr(struct int
 		if (command != ZEBRA_BFD_DEST_DEREGISTER)
 			pim_bfd_info_nbr_create(pim_ifp, neigh);
 		else
-			bfd_info_free((struct bfd_info **)&neigh->bfd_info);
+			pim_bfd_info_free((struct bfd_info **)&neigh->bfd_info);
 
 		pim_bfd_reg_dereg_nbr(neigh, command);
 	}
@@ -170,7 +172,7 @@ void pim_bfd_trigger_event(struct pim_in
 		pim_bfd_info_nbr_create(pim_ifp, nbr);
 		pim_bfd_reg_dereg_nbr(nbr, ZEBRA_BFD_DEST_REGISTER);
 	} else {
-		pim_bfd_info_free((void *)&nbr->bfd_info);
+		pim_bfd_info_free(&nbr->bfd_info);
 		pim_bfd_reg_dereg_nbr(nbr, ZEBRA_BFD_DEST_DEREGISTER);
 	}
 }
diff -urpN frr-frr-5.0.1/pimd/pim_bfd.h frr-frr-6.0/pimd/pim_bfd.h
--- frr-frr-5.0.1/pimd/pim_bfd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_bfd.h	2018-10-08 14:32:57.000000000 +0200
@@ -36,5 +36,5 @@ void pim_bfd_trigger_event(struct pim_in
 			   struct pim_neighbor *nbr, uint8_t nbr_up);
 void pim_bfd_info_nbr_create(struct pim_interface *pim_ifp,
 			     struct pim_neighbor *neigh);
-void pim_bfd_info_free(void **bfd_info);
+void pim_bfd_info_free(struct bfd_info **bfd_info);
 #endif /* _PIM_BFD_H */
diff -urpN frr-frr-5.0.1/pimd/pim_br.c frr-frr-6.0/pimd/pim_br.c
--- frr-frr-5.0.1/pimd/pim_br.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_br.c	2018-10-08 14:32:57.000000000 +0200
@@ -64,11 +64,6 @@ void pim_br_set_pmbr(struct prefix_sg *s
 
 	if (!pim_br) {
 		pim_br = XCALLOC(MTYPE_PIM_BR, sizeof(*pim_br));
-		if (!pim_br) {
-			zlog_err("PIM XCALLOC(%zu) failure", sizeof(*pim_br));
-			return;
-		}
-
 		pim_br->sg = *sg;
 
 		listnode_add(pim_br_list, pim_br);
@@ -100,9 +95,4 @@ void pim_br_clear_pmbr(struct prefix_sg
 void pim_br_init(void)
 {
 	pim_br_list = list_new();
-	if (!pim_br_list) {
-		zlog_err("%s: Failure to create pim_br_list",
-			 __PRETTY_FUNCTION__);
-		return;
-	}
 }
diff -urpN frr-frr-5.0.1/pimd/pim_cmd.c frr-frr-6.0/pimd/pim_cmd.c
--- frr-frr-5.0.1/pimd/pim_cmd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_cmd.c	2018-10-08 14:32:57.000000000 +0200
@@ -323,8 +323,8 @@ static void pim_show_assert_winner_metri
 	char addr_str[INET_ADDRSTRLEN];
 	struct pim_assert_metric *am;
 	struct in_addr ifaddr;
-	char pref_str[5];
-	char metr_str[7];
+	char pref_str[16];
+	char metr_str[16];
 
 	ifaddr = pim_ifp->primary_address;
 
@@ -1294,6 +1294,76 @@ static void pim_show_interfaces_single(s
 	}
 }
 
+static void igmp_show_statistics(struct pim_instance *pim, struct vty *vty,
+				 const char *ifname, uint8_t uj)
+{
+	struct interface *ifp;
+	struct igmp_stats rx_stats;
+
+	igmp_stats_init(&rx_stats);
+
+	FOR_ALL_INTERFACES (pim->vrf, ifp) {
+		struct pim_interface *pim_ifp;
+		struct listnode *sock_node;
+		struct igmp_sock *igmp;
+
+		pim_ifp = ifp->info;
+
+		if (!pim_ifp)
+			continue;
+
+		if (ifname && strcmp(ifname, ifp->name))
+			continue;
+
+		for (ALL_LIST_ELEMENTS_RO(pim_ifp->igmp_socket_list, sock_node,
+					  igmp)) {
+			igmp_stats_add(&rx_stats, &igmp->rx_stats);
+		}
+	}
+	if (uj) {
+		json_object *json = NULL;
+		json_object *json_row = NULL;
+
+		json = json_object_new_object();
+		json_row = json_object_new_object();
+
+		json_object_string_add(json_row, "name", ifname ? ifname :
+				       "global");
+		json_object_int_add(json_row, "queryV1", rx_stats.query_v1);
+		json_object_int_add(json_row, "queryV2", rx_stats.query_v2);
+		json_object_int_add(json_row, "queryV3", rx_stats.query_v3);
+		json_object_int_add(json_row, "leaveV3", rx_stats.leave_v2);
+		json_object_int_add(json_row, "reportV1", rx_stats.report_v1);
+		json_object_int_add(json_row, "reportV2", rx_stats.report_v2);
+		json_object_int_add(json_row, "reportV3", rx_stats.report_v3);
+		json_object_int_add(json_row, "mtraceResponse",
+				    rx_stats.mtrace_rsp);
+		json_object_int_add(json_row, "mtraceRequest",
+				    rx_stats.mtrace_req);
+		json_object_int_add(json_row, "unsupported",
+				    rx_stats.unsupported);
+		json_object_object_add(json, ifname ? ifname : "global",
+				       json_row);
+		vty_out(vty, "%s\n", json_object_to_json_string_ext(
+					     json, JSON_C_TO_STRING_PRETTY));
+		json_object_free(json);
+	} else {
+		vty_out(vty, "IGMP RX statistics\n");
+		vty_out(vty, "Interface       : %s\n",
+			ifname ? ifname : "global");
+		vty_out(vty, "V1 query        : %u\n", rx_stats.query_v1);
+		vty_out(vty, "V2 query        : %u\n", rx_stats.query_v2);
+		vty_out(vty, "V3 query        : %u\n", rx_stats.query_v3);
+		vty_out(vty, "V2 leave        : %u\n", rx_stats.leave_v2);
+		vty_out(vty, "V1 report       : %u\n", rx_stats.report_v1);
+		vty_out(vty, "V2 report       : %u\n", rx_stats.report_v2);
+		vty_out(vty, "V3 report       : %u\n", rx_stats.report_v3);
+		vty_out(vty, "mtrace response : %u\n", rx_stats.mtrace_rsp);
+		vty_out(vty, "mtrace request  : %u\n", rx_stats.mtrace_req);
+		vty_out(vty, "unsupported     : %u\n", rx_stats.unsupported);
+	}
+}
+
 static void pim_show_interfaces(struct pim_instance *pim, struct vty *vty,
 				uint8_t uj)
 {
@@ -1968,7 +2038,7 @@ static void pim_show_state(struct pim_in
 		} else {
 			vty_out(vty, "%-9d %-15s  %-15s  %-7s  ",
 				c_oil->installed, src_str, grp_str,
-				ifp_in->name);
+				in_ifname);
 		}
 
 		for (oif_vif_index = 0; oif_vif_index < MAXVIFS;
@@ -2725,9 +2795,6 @@ static int pim_print_pnc_cache_walkcb(st
 	ifindex_t first_ifindex;
 	struct interface *ifp = NULL;
 
-	if (!pnc)
-		return CMD_SUCCESS;
-
 	for (nh_node = pnc->nexthop; nh_node; nh_node = nh_node->next) {
 		first_ifindex = nh_node->ifindex;
 		ifp = if_lookup_by_index(first_ifindex, pim->vrf_id);
@@ -3527,6 +3594,33 @@ DEFUN (show_ip_igmp_sources_retransmissi
 	return CMD_SUCCESS;
 }
 
+DEFUN (show_ip_igmp_statistics,
+       show_ip_igmp_statistics_cmd,
+       "show ip igmp [vrf NAME] statistics [interface WORD] [json]",
+       SHOW_STR
+       IP_STR
+       IGMP_STR
+       VRF_CMD_HELP_STR
+       "IGMP statistics\n"
+       "interface\n"
+       "IGMP interface\n"
+       JSON_STR)
+{
+	int idx = 2;
+	struct vrf *vrf = pim_cmd_lookup_vrf(vty, argv, argc, &idx);
+	uint8_t uj = use_json(argc, argv);
+
+	if (!vrf)
+		return CMD_WARNING;
+
+	if (argv_find(argv, argc, "WORD", &idx))
+		igmp_show_statistics(vrf->info, vty, argv[idx]->arg, uj);
+	else
+		igmp_show_statistics(vrf->info, vty, NULL, uj);
+
+	return CMD_SUCCESS;
+}
+
 DEFUN (show_ip_pim_assert,
        show_ip_pim_assert_cmd,
        "show ip pim [vrf NAME] assert",
@@ -4155,7 +4249,7 @@ DEFUN (show_ip_pim_nexthop_lookup,
        "Source/RP address\n"
        "Multicast Group address\n")
 {
-	struct pim_nexthop_cache pnc;
+	struct pim_nexthop_cache *pnc = NULL;
 	struct prefix nht_p;
 	int result = 0;
 	struct in_addr src_addr, grp_addr;
@@ -4167,6 +4261,7 @@ DEFUN (show_ip_pim_nexthop_lookup,
 	char grp_str[PREFIX_STRLEN];
 	int idx = 2;
 	struct vrf *vrf = pim_cmd_lookup_vrf(vty, argv, argc, &idx);
+	struct pim_rpf rpf;
 
 	if (!vrf)
 		return CMD_WARNING;
@@ -4204,7 +4299,6 @@ DEFUN (show_ip_pim_nexthop_lookup,
 				      grp_addr))
 		return CMD_SUCCESS;
 
-	memset(&pnc, 0, sizeof(struct pim_nexthop_cache));
 	nht_p.family = AF_INET;
 	nht_p.prefixlen = IPV4_MAX_BITLEN;
 	nht_p.u.prefix4 = vif_source;
@@ -4213,12 +4307,18 @@ DEFUN (show_ip_pim_nexthop_lookup,
 	grp.u.prefix4 = grp_addr;
 	memset(&nexthop, 0, sizeof(nexthop));
 
-	if (pim_find_or_track_nexthop(vrf->info, &nht_p, NULL, NULL, &pnc))
-		result = pim_ecmp_nexthop_search(vrf->info, &pnc, &nexthop,
+	memset(&rpf, 0, sizeof(struct pim_rpf));
+	rpf.rpf_addr.family = AF_INET;
+	rpf.rpf_addr.prefixlen = IPV4_MAX_BITLEN;
+	rpf.rpf_addr.u.prefix4 = vif_source;
+
+	pnc = pim_nexthop_cache_find(vrf->info, &rpf);
+	if (pnc)
+		result = pim_ecmp_nexthop_search(vrf->info, pnc, &nexthop,
 						 &nht_p, &grp, 0);
 	else
-		result = pim_ecmp_nexthop_lookup(vrf->info, &nexthop,
-						 vif_source, &nht_p, &grp, 0);
+		result = pim_ecmp_nexthop_lookup(vrf->info, &nexthop, &nht_p,
+						 &grp, 0);
 
 	if (!result) {
 		vty_out(vty,
@@ -4331,9 +4431,9 @@ static void pim_cmd_show_ip_multicast_he
 	vty_out(vty, "\n");
 	vty_out(vty, "Upstream Join Timer: %d secs\n", qpim_t_periodic);
 	vty_out(vty, "Join/Prune Holdtime: %d secs\n", PIM_JP_HOLDTIME);
-	vty_out(vty, "PIM ECMP: %s\n", qpim_ecmp_enable ? "Enable" : "Disable");
+	vty_out(vty, "PIM ECMP: %s\n", pim->ecmp_enable ? "Enable" : "Disable");
 	vty_out(vty, "PIM ECMP Rebalance: %s\n",
-		qpim_ecmp_rebalance_enable ? "Enable" : "Disable");
+		pim->ecmp_rebalance_enable ? "Enable" : "Disable");
 
 	vty_out(vty, "\n");
 
@@ -4407,8 +4507,8 @@ static void show_mroute(struct pim_insta
 	json_object *json_source = NULL;
 	json_object *json_oil = NULL;
 	json_object *json_ifp_out = NULL;
-	int found_oif = 0;
-	int first = 1;
+	int found_oif;
+	int first;
 	char grp_str[INET_ADDRSTRLEN];
 	char src_str[INET_ADDRSTRLEN];
 	char in_ifname[INTERFACE_NAMSIZ + 1];
@@ -5003,11 +5103,6 @@ static int pim_rp_cmd_worker(struct pim_
 
 	result = pim_rp_new(pim, rp, group, plist);
 
-	if (result == PIM_MALLOC_FAIL) {
-		vty_out(vty, "%% Out of memory\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
 	if (result == PIM_GROUP_BAD_ADDRESS) {
 		vty_out(vty, "%% Bad group address specified: %s\n", group);
 		return CMD_WARNING_CONFIG_FAILED;
@@ -5637,7 +5732,7 @@ DEFUN (ip_pim_ecmp,
        "Enable PIM ECMP \n")
 {
 	PIM_DECLVAR_CONTEXT(vrf, pim);
-	qpim_ecmp_enable = 1;
+	pim->ecmp_enable = true;
 
 	return CMD_SUCCESS;
 }
@@ -5651,7 +5746,7 @@ DEFUN (no_ip_pim_ecmp,
        "Disable PIM ECMP \n")
 {
 	PIM_DECLVAR_CONTEXT(vrf, pim);
-	qpim_ecmp_enable = 0;
+	pim->ecmp_enable = false;
 
 	return CMD_SUCCESS;
 }
@@ -5665,8 +5760,8 @@ DEFUN (ip_pim_ecmp_rebalance,
        "Enable PIM ECMP Rebalance\n")
 {
 	PIM_DECLVAR_CONTEXT(vrf, pim);
-	qpim_ecmp_enable = 1;
-	qpim_ecmp_rebalance_enable = 1;
+	pim->ecmp_enable = true;
+	pim->ecmp_rebalance_enable = true;
 
 	return CMD_SUCCESS;
 }
@@ -5681,7 +5776,7 @@ DEFUN (no_ip_pim_ecmp_rebalance,
        "Disable PIM ECMP Rebalance\n")
 {
 	PIM_DECLVAR_CONTEXT(vrf, pim);
-	qpim_ecmp_rebalance_enable = 0;
+	pim->ecmp_rebalance_enable = false;
 
 	return CMD_SUCCESS;
 }
@@ -5694,7 +5789,8 @@ static int pim_cmd_igmp_start(struct vty
 	pim_ifp = ifp->info;
 
 	if (!pim_ifp) {
-		pim_ifp = pim_if_new(ifp, 1 /* igmp=true */, 0 /* pim=false */);
+		pim_ifp = pim_if_new(ifp, 1 /* igmp=true */, 0 /* pim=false */,
+				     false);
 		if (!pim_ifp) {
 			vty_out(vty, "Could not enable IGMP on interface %s\n",
 				ifp->name);
@@ -6305,7 +6401,8 @@ static int pim_cmd_interface_add(struct
 	struct pim_interface *pim_ifp = ifp->info;
 
 	if (!pim_ifp) {
-		pim_ifp = pim_if_new(ifp, 0 /* igmp=false */, 1 /* pim=true */);
+		pim_ifp = pim_if_new(ifp, 0 /* igmp=false */, 1 /* pim=true */,
+				     false);
 		if (!pim_ifp) {
 			return 0;
 		}
@@ -7444,7 +7541,12 @@ DEFUN (no_ip_pim_bfd,
 	return CMD_SUCCESS;
 }
 
-DEFUN (ip_pim_bfd_param,
+#if HAVE_BFDD > 0
+DEFUN_HIDDEN(
+#else
+DEFUN(
+#endif /* HAVE_BFDD */
+       ip_pim_bfd_param,
        ip_pim_bfd_param_cmd,
        "ip pim bfd (2-255) (50-60000) (50-60000)",
        IP_STR
@@ -7482,12 +7584,14 @@ DEFUN (ip_pim_bfd_param,
 	return CMD_SUCCESS;
 }
 
+#if HAVE_BFDD == 0
 ALIAS(no_ip_pim_bfd, no_ip_pim_bfd_param_cmd,
       "no ip pim bfd (2-255) (50-60000) (50-60000)", NO_STR IP_STR PIM_STR
       "Enables BFD support\n"
       "Detect Multiplier\n"
       "Required min receive interval\n"
       "Desired min transmit interval\n")
+#endif /* !HAVE_BFDD */
 
 static int ip_msdp_peer_cmd_worker(struct pim_instance *pim, struct vty *vty,
 				   const char *peer, const char *local)
@@ -8644,6 +8748,7 @@ void pim_cmd_init(void)
 	install_element(VIEW_NODE, &show_ip_igmp_groups_retransmissions_cmd);
 	install_element(VIEW_NODE, &show_ip_igmp_sources_cmd);
 	install_element(VIEW_NODE, &show_ip_igmp_sources_retransmissions_cmd);
+	install_element(VIEW_NODE, &show_ip_igmp_statistics_cmd);
 	install_element(VIEW_NODE, &show_ip_pim_assert_cmd);
 	install_element(VIEW_NODE, &show_ip_pim_assert_internal_cmd);
 	install_element(VIEW_NODE, &show_ip_pim_assert_metric_cmd);
@@ -8802,5 +8907,7 @@ void pim_cmd_init(void)
 	install_element(INTERFACE_NODE, &ip_pim_bfd_cmd);
 	install_element(INTERFACE_NODE, &ip_pim_bfd_param_cmd);
 	install_element(INTERFACE_NODE, &no_ip_pim_bfd_cmd);
+#if HAVE_BFDD == 0
 	install_element(INTERFACE_NODE, &no_ip_pim_bfd_param_cmd);
+#endif /* !HAVE_BFDD */
 }
diff -urpN frr-frr-5.0.1/pimd/pim_errors.c frr-frr-6.0/pimd/pim_errors.c
--- frr-frr-5.0.1/pimd/pim_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/pimd/pim_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * PIM-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "pim_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_pim_err[] = {
+	{
+		.code = PIM_ERR_MSDP_PACKET,
+		.title = "PIM MSDP Packet Error",
+		.description = "PIM has received a packet from a peer that does not correctly decode",
+		.suggestion = "Check MSDP peer and ensure it is correctly working"
+	},
+	{
+		.code = PIM_ERR_CONFIG,
+		.title = "PIM Configuration Error",
+		.description = "PIM has detected a configuration error",
+		.suggestion = "Ensure the configuration is correct and apply correct configuration"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void pim_error_init(void)
+{
+	log_ref_add(ferr_pim_err);
+}
diff -urpN frr-frr-5.0.1/pimd/pim_errors.h frr-frr-6.0/pimd/pim_errors.h
--- frr-frr-5.0.1/pimd/pim_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/pimd/pim_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * PIM-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __PIM_ERRORS_H__
+#define __PIM_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum pim_log_refs {
+	PIM_ERR_MSDP_PACKET = PIM_FERR_START,
+	PIM_ERR_CONFIG,
+};
+
+extern void pim_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/pimd/pim_iface.c frr-frr-6.0/pimd/pim_iface.c
--- frr-frr-5.0.1/pimd/pim_iface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_iface.c	2018-10-08 14:32:57.000000000 +0200
@@ -46,6 +46,7 @@
 #include "pim_rp.h"
 #include "pim_nht.h"
 #include "pim_jp_agg.h"
+#include "pim_igmp_join.h"
 
 static void pim_if_igmp_join_del_all(struct interface *ifp);
 static int igmp_join_sock(const char *ifname, ifindex_t ifindex,
@@ -62,38 +63,17 @@ void pim_if_init(struct pim_instance *pi
 
 void pim_if_terminate(struct pim_instance *pim)
 {
-	// Nothing to do at this moment
-	return;
-}
-
-static void *if_list_clean(struct pim_interface *pim_ifp)
-{
-	struct pim_ifchannel *ch;
-
-	if (pim_ifp->igmp_join_list)
-		list_delete_and_null(&pim_ifp->igmp_join_list);
-
-	if (pim_ifp->igmp_socket_list)
-		list_delete_and_null(&pim_ifp->igmp_socket_list);
-
-	if (pim_ifp->pim_neighbor_list)
-		list_delete_and_null(&pim_ifp->pim_neighbor_list);
-
-	if (pim_ifp->upstream_switch_list)
-		list_delete_and_null(&pim_ifp->upstream_switch_list);
+	struct interface *ifp;
 
-	if (pim_ifp->sec_addr_list)
-		list_delete_and_null(&pim_ifp->sec_addr_list);
+	FOR_ALL_INTERFACES (pim->vrf, ifp) {
+		struct pim_interface *pim_ifp = ifp->info;
 
-	while (!RB_EMPTY(pim_ifchannel_rb, &pim_ifp->ifchannel_rb)) {
-		ch = RB_ROOT(pim_ifchannel_rb, &pim_ifp->ifchannel_rb);
+		if (!pim_ifp)
+			continue;
 
-		pim_ifchannel_delete(ch);
+		pim_if_delete(ifp);
 	}
-
-	XFREE(MTYPE_PIM_INTERFACE, pim_ifp);
-
-	return 0;
+	return;
 }
 
 static void pim_sec_addr_free(struct pim_secondary_addr *sec_addr)
@@ -128,7 +108,8 @@ static int pim_sec_addr_comp(const void
 	return 0;
 }
 
-struct pim_interface *pim_if_new(struct interface *ifp, int igmp, int pim)
+struct pim_interface *pim_if_new(struct interface *ifp, int igmp, int pim,
+				 bool ispimreg)
 {
 	struct pim_interface *pim_ifp;
 
@@ -136,10 +117,6 @@ struct pim_interface *pim_if_new(struct
 	zassert(!ifp->info);
 
 	pim_ifp = XCALLOC(MTYPE_PIM_INTERFACE, sizeof(*pim_ifp));
-	if (!pim_ifp) {
-		zlog_err("PIM XCALLOC(%zu) failure", sizeof(*pim_ifp));
-		return 0;
-	}
 
 	pim_ifp->options = 0;
 	pim_ifp->pim = pim_get_pim_instance(ifp->vrf_id);
@@ -177,38 +154,18 @@ struct pim_interface *pim_if_new(struct
 
 	/* list of struct igmp_sock */
 	pim_ifp->igmp_socket_list = list_new();
-	if (!pim_ifp->igmp_socket_list) {
-		zlog_err("%s: failure: igmp_socket_list=list_new()",
-			 __PRETTY_FUNCTION__);
-		return if_list_clean(pim_ifp);
-	}
 	pim_ifp->igmp_socket_list->del = (void (*)(void *))igmp_sock_free;
 
 	/* list of struct pim_neighbor */
 	pim_ifp->pim_neighbor_list = list_new();
-	if (!pim_ifp->pim_neighbor_list) {
-		zlog_err("%s: failure: pim_neighbor_list=list_new()",
-			 __PRETTY_FUNCTION__);
-		return if_list_clean(pim_ifp);
-	}
 	pim_ifp->pim_neighbor_list->del = (void (*)(void *))pim_neighbor_free;
 
 	pim_ifp->upstream_switch_list = list_new();
-	if (!pim_ifp->upstream_switch_list) {
-		zlog_err("%s: failure: upstream_switch_list=list_new()",
-			 __PRETTY_FUNCTION__);
-		return if_list_clean(pim_ifp);
-	}
 	pim_ifp->upstream_switch_list->del =
 		(void (*)(void *))pim_jp_agg_group_list_free;
 	pim_ifp->upstream_switch_list->cmp = pim_jp_agg_group_list_cmp;
 
 	pim_ifp->sec_addr_list = list_new();
-	if (!pim_ifp->sec_addr_list) {
-		zlog_err("%s: failure: secondary addresslist",
-			 __PRETTY_FUNCTION__);
-		return if_list_clean(pim_ifp);
-	}
 	pim_ifp->sec_addr_list->del = (void (*)(void *))pim_sec_addr_free;
 	pim_ifp->sec_addr_list->cmp =
 		(int (*)(void *, void *))pim_sec_addr_comp;
@@ -219,7 +176,7 @@ struct pim_interface *pim_if_new(struct
 
 	pim_sock_reset(ifp);
 
-	pim_if_add_vif(ifp);
+	pim_if_add_vif(ifp, ispimreg);
 
 	return pim_ifp;
 }
@@ -395,8 +352,6 @@ static int pim_sec_addr_add(struct pim_i
 	}
 
 	sec_addr = XCALLOC(MTYPE_PIM_SEC_ADDR, sizeof(*sec_addr));
-	if (!sec_addr)
-		return changed;
 
 	changed = 1;
 	sec_addr->addr = *addr;
@@ -672,7 +627,7 @@ void pim_if_addr_add(struct connected *i
 	  address assigned, then try to create a vif_index.
 	*/
 	if (pim_ifp->mroute_vif_index < 0) {
-		pim_if_add_vif(ifp);
+		pim_if_add_vif(ifp, false);
 	}
 	pim_ifchannel_scan_forward_start(ifp);
 }
@@ -805,7 +760,7 @@ void pim_if_addr_add_all(struct interfac
 	 * address assigned, then try to create a vif_index.
 	 */
 	if (pim_ifp->mroute_vif_index < 0) {
-		pim_if_add_vif(ifp);
+		pim_if_add_vif(ifp, false);
 	}
 	pim_ifchannel_scan_forward_start(ifp);
 
@@ -970,7 +925,7 @@ static int pim_iface_next_vif_index(stru
 
   see also pim_if_find_vifindex_by_ifindex()
  */
-int pim_if_add_vif(struct interface *ifp)
+int pim_if_add_vif(struct interface *ifp, bool ispimreg)
 {
 	struct pim_interface *pim_ifp = ifp->info;
 	struct in_addr ifaddr;
@@ -992,8 +947,7 @@ int pim_if_add_vif(struct interface *ifp
 	}
 
 	ifaddr = pim_ifp->primary_address;
-	if (ifp->ifindex != PIM_OIF_PIM_REGISTER_VIF
-	    && PIM_INADDR_IS_ANY(ifaddr)) {
+	if (!ispimreg && PIM_INADDR_IS_ANY(ifaddr)) {
 		zlog_warn(
 			"%s: could not get address for interface %s ifindex=%d",
 			__PRETTY_FUNCTION__, ifp->name, ifp->ifindex);
@@ -1241,8 +1195,18 @@ static int igmp_join_sock(const char *if
 		return -1;
 	}
 
-	if (pim_socket_join_source(join_fd, ifindex, group_addr, source_addr,
-				   ifname)) {
+	if (pim_igmp_join_source(join_fd, ifindex, group_addr, source_addr)) {
+		char group_str[INET_ADDRSTRLEN];
+		char source_str[INET_ADDRSTRLEN];
+		pim_inet4_dump("<grp?>", group_addr, group_str,
+			       sizeof(group_str));
+		pim_inet4_dump("<src?>", source_addr, source_str,
+			       sizeof(source_str));
+		zlog_warn(
+			"%s: setsockopt(fd=%d) failure for IGMP group %s source %s ifindex %d on interface %s: errno=%d: %s",
+			__PRETTY_FUNCTION__, join_fd, group_str, source_str,
+			ifindex, ifname, errno, safe_strerror(errno));
+
 		close(join_fd);
 		return -2;
 	}
@@ -1266,6 +1230,7 @@ static struct igmp_join *igmp_join_new(s
 	if (join_fd < 0) {
 		char group_str[INET_ADDRSTRLEN];
 		char source_str[INET_ADDRSTRLEN];
+
 		pim_inet4_dump("<grp?>", group_addr, group_str,
 			       sizeof(group_str));
 		pim_inet4_dump("<src?>", source_addr, source_str,
@@ -1277,20 +1242,6 @@ static struct igmp_join *igmp_join_new(s
 	}
 
 	ij = XCALLOC(MTYPE_PIM_IGMP_JOIN, sizeof(*ij));
-	if (!ij) {
-		char group_str[INET_ADDRSTRLEN];
-		char source_str[INET_ADDRSTRLEN];
-		pim_inet4_dump("<grp?>", group_addr, group_str,
-			       sizeof(group_str));
-		pim_inet4_dump("<src?>", source_addr, source_str,
-			       sizeof(source_str));
-		zlog_err(
-			"%s: XCALLOC(%zu) failure for IGMP group %s source %s on interface %s",
-			__PRETTY_FUNCTION__, sizeof(*ij), group_str, source_str,
-			ifp->name);
-		close(join_fd);
-		return 0;
-	}
 
 	ij->sock_fd = join_fd;
 	ij->group_addr = group_addr;
@@ -1316,9 +1267,6 @@ ferr_r pim_if_igmp_join_add(struct inter
 
 	if (!pim_ifp->igmp_join_list) {
 		pim_ifp->igmp_join_list = list_new();
-		if (!pim_ifp->igmp_join_list) {
-			return ferr_cfg_invalid("Insufficient memory");
-		}
 		pim_ifp->igmp_join_list->del = (void (*)(void *))igmp_join_free;
 	}
 
@@ -1520,7 +1468,7 @@ void pim_if_create_pimreg(struct pim_ins
 		pim->regiface = if_create(pimreg_name, pim->vrf_id);
 		pim->regiface->ifindex = PIM_OIF_PIM_REGISTER_VIF;
 
-		pim_if_new(pim->regiface, 0, 0);
+		pim_if_new(pim->regiface, 0, 0, true);
 	}
 }
 
@@ -1547,27 +1495,12 @@ int pim_if_connected_to_source(struct in
 	return 0;
 }
 
-int pim_if_is_loopback(struct pim_instance *pim, struct interface *ifp)
+bool pim_if_is_vrf_device(struct interface *ifp)
 {
-	if (if_is_loopback(ifp))
-		return 1;
+	if (if_is_vrf(ifp))
+		return true;
 
-	if (strcmp(ifp->name, pim->vrf->name) == 0)
-		return 1;
-
-	return 0;
-}
-
-int pim_if_is_vrf_device(struct interface *ifp)
-{
-	struct vrf *vrf;
-
-	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
-		if (strncmp(ifp->name, vrf->name, strlen(ifp->name)) == 0)
-			return 1;
-	}
-
-	return 0;
+	return false;
 }
 
 int pim_if_ifchannel_count(struct pim_interface *pim_ifp)
diff -urpN frr-frr-5.0.1/pimd/pim_iface.h frr-frr-6.0/pimd/pim_iface.h
--- frr-frr-5.0.1/pimd/pim_iface.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_iface.h	2018-10-08 14:32:57.000000000 +0200
@@ -154,7 +154,8 @@ struct pim_interface {
 void pim_if_init(struct pim_instance *pim);
 void pim_if_terminate(struct pim_instance *pim);
 
-struct pim_interface *pim_if_new(struct interface *ifp, int igmp, int pim);
+struct pim_interface *pim_if_new(struct interface *ifp, int igmp, int pim,
+				 bool ispimreg);
 void pim_if_delete(struct interface *ifp);
 void pim_if_addr_add(struct connected *ifc);
 void pim_if_addr_del(struct connected *ifc, int force_prim_as_any);
@@ -163,7 +164,7 @@ void pim_if_addr_del_all(struct interfac
 void pim_if_addr_del_all_igmp(struct interface *ifp);
 void pim_if_addr_del_all_pim(struct interface *ifp);
 
-int pim_if_add_vif(struct interface *ifp);
+int pim_if_add_vif(struct interface *ifp, bool ispimreg);
 int pim_if_del_vif(struct interface *ifp);
 void pim_if_add_vif_all(struct pim_instance *pim);
 void pim_if_del_vif_all(struct pim_instance *pim);
@@ -207,9 +208,7 @@ void pim_if_create_pimreg(struct pim_ins
 int pim_if_connected_to_source(struct interface *ifp, struct in_addr src);
 int pim_update_source_set(struct interface *ifp, struct in_addr source);
 
-int pim_if_is_loopback(struct pim_instance *pim, struct interface *ifp);
-
-int pim_if_is_vrf_device(struct interface *ifp);
+bool pim_if_is_vrf_device(struct interface *ifp);
 
 int pim_if_ifchannel_count(struct pim_interface *pim_ifp);
 #endif /* PIM_IFACE_H */
diff -urpN frr-frr-5.0.1/pimd/pim_ifchannel.c frr-frr-6.0/pimd/pim_ifchannel.c
--- frr-frr-5.0.1/pimd/pim_ifchannel.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_ifchannel.c	2018-10-08 14:32:57.000000000 +0200
@@ -124,11 +124,6 @@ static void pim_ifchannel_find_new_child
 	}
 }
 
-void pim_ifchannel_free(struct pim_ifchannel *ch)
-{
-	XFREE(MTYPE_PIM_IFCHANNEL, ch);
-}
-
 void pim_ifchannel_delete(struct pim_ifchannel *ch)
 {
 	struct pim_interface *pim_ifp;
@@ -141,9 +136,8 @@ void pim_ifchannel_delete(struct pim_ifc
 			mask = PIM_OIF_FLAG_PROTO_IGMP;
 
 		/* SGRpt entry could have empty oil */
-		if (ch->upstream->channel_oil)
-			pim_channel_del_oif(ch->upstream->channel_oil,
-					    ch->interface, mask);
+		pim_channel_del_oif(ch->upstream->channel_oil, ch->interface,
+				    mask);
 		/*
 		 * Do we have any S,G's that are inheriting?
 		 * Nuke from on high too.
@@ -180,7 +174,16 @@ void pim_ifchannel_delete(struct pim_ifc
 	   ifchannel list is empty before deleting upstream_del
 	   ref count will take care of it.
 	*/
-	pim_upstream_del(pim_ifp->pim, ch->upstream, __PRETTY_FUNCTION__);
+	if (ch->upstream->ref_count > 0)
+		pim_upstream_del(pim_ifp->pim, ch->upstream,
+			__PRETTY_FUNCTION__);
+
+	else
+		zlog_warn("%s: Avoiding deletion of upstream with ref_count %d "
+			"from ifchannel(%s): %s", __PRETTY_FUNCTION__,
+			ch->upstream->ref_count, ch->interface->name,
+			ch->sg_str);
+
 	ch->upstream = NULL;
 
 	THREAD_OFF(ch->t_ifjoin_expiry_timer);
@@ -198,7 +201,7 @@ void pim_ifchannel_delete(struct pim_ifc
 		zlog_debug("%s: ifchannel entry %s is deleted ",
 			   __PRETTY_FUNCTION__, ch->sg_str);
 
-	pim_ifchannel_free(ch);
+	XFREE(MTYPE_PIM_IFCHANNEL, ch);
 }
 
 void pim_ifchannel_delete_all(struct interface *ifp)
@@ -525,12 +528,6 @@ struct pim_ifchannel *pim_ifchannel_add(
 	pim_ifp = ifp->info;
 
 	ch = XCALLOC(MTYPE_PIM_IFCHANNEL, sizeof(*ch));
-	if (!ch) {
-		zlog_warn(
-			"%s: pim_ifchannel_new() failure for (S,G)=%s on interface %s",
-			__PRETTY_FUNCTION__, pim_str_sg_dump(sg), ifp->name);
-		return NULL;
-	}
 
 	ch->flags = 0;
 	if ((source_flags & PIM_ENCODE_RPT_BIT)
@@ -561,26 +558,6 @@ struct pim_ifchannel *pim_ifchannel_add(
 	up = pim_upstream_add(pim_ifp->pim, sg, NULL, up_flags,
 			      __PRETTY_FUNCTION__, ch);
 
-	if (!up) {
-		zlog_err(
-			"%s: could not attach upstream (S,G)=%s on interface %s",
-			__PRETTY_FUNCTION__, pim_str_sg_dump(sg), ifp->name);
-
-		if (ch->parent)
-			listnode_delete(ch->parent->sources, ch);
-
-		pim_ifchannel_remove_children(ch);
-		if (ch->sources)
-			list_delete_and_null(&ch->sources);
-
-		THREAD_OFF(ch->t_ifjoin_expiry_timer);
-		THREAD_OFF(ch->t_ifjoin_prune_pending_timer);
-		THREAD_OFF(ch->t_ifassert_timer);
-
-		RB_REMOVE(pim_ifchannel_rb, &pim_ifp->ifchannel_rb, ch);
-		XFREE(MTYPE_PIM_IFCHANNEL, ch);
-		return NULL;
-	}
 	ch->upstream = up;
 
 	listnode_add_sort(up->ifchannels, ch);
diff -urpN frr-frr-5.0.1/pimd/pim_ifchannel.h frr-frr-6.0/pimd/pim_ifchannel.h
--- frr-frr-5.0.1/pimd/pim_ifchannel.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_ifchannel.h	2018-10-08 14:32:57.000000000 +0200
@@ -114,7 +114,6 @@ RB_HEAD(pim_ifchannel_rb, pim_ifchannel)
 RB_PROTOTYPE(pim_ifchannel_rb, pim_ifchannel, pim_ifp_rb,
 	     pim_ifchannel_compare);
 
-void pim_ifchannel_free(struct pim_ifchannel *ch);
 void pim_ifchannel_delete(struct pim_ifchannel *ch);
 void pim_ifchannel_delete_all(struct interface *ifp);
 void pim_ifchannel_membership_clear(struct interface *ifp);
diff -urpN frr-frr-5.0.1/pimd/pim_igmp.c frr-frr-6.0/pimd/pim_igmp.c
--- frr-frr-5.0.1/pimd/pim_igmp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmp.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include "if.h"
 #include "hash.h"
 #include "jhash.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_igmp.h"
@@ -96,7 +97,8 @@ static int igmp_sock_open(struct in_addr
 	}
 
 	if (!join) {
-		zlog_err(
+		flog_err_sys(
+			LIB_ERR_SOCKET,
 			"IGMP socket fd=%d could not join any group on interface address %s",
 			fd, inet_ntoa(ifaddr));
 		close(fd);
@@ -303,6 +305,21 @@ static int igmp_recv_query(struct igmp_s
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	switch (query_version) {
+	case 1:
+		igmp->rx_stats.query_v1++;
+		break;
+	case 2:
+		igmp->rx_stats.query_v2++;
+		break;
+	case 3:
+		igmp->rx_stats.query_v3++;
+		break;
+	default:
+		igmp->rx_stats.unsupported++;
+	}
+
 	/*
 	 * RFC 3376 defines some guidelines on operating in backwards
 	 * compatibility with older versions of IGMP but there are some gaps in
@@ -400,6 +417,9 @@ static int igmp_v1_recv_report(struct ig
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.report_v1++;
+
 	if (PIM_DEBUG_IGMP_TRACE) {
 		zlog_warn("%s %s: FIXME WRITEME", __FILE__,
 			  __PRETTY_FUNCTION__);
@@ -524,6 +544,9 @@ int pim_igmp_packet(struct igmp_sock *ig
 
 	zlog_warn("Ignoring unsupported IGMP message type: %d", msg_type);
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.unsupported++;
+
 	return -1;
 }
 
@@ -676,7 +699,8 @@ static void sock_close(struct igmp_sock
 	THREAD_OFF(igmp->t_igmp_read);
 
 	if (close(igmp->fd)) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"Failure closing IGMP socket %s fd=%d on interface %s: errno=%d: %s",
 			inet_ntoa(igmp->ifaddr), igmp->fd,
 			igmp->interface->name, errno, safe_strerror(errno));
@@ -839,18 +863,8 @@ static struct igmp_sock *igmp_sock_new(i
 	}
 
 	igmp = XCALLOC(MTYPE_PIM_IGMP_SOCKET, sizeof(*igmp));
-	if (!igmp) {
-		zlog_warn("%s %s: XCALLOC() failure", __FILE__,
-			  __PRETTY_FUNCTION__);
-		return 0;
-	}
 
 	igmp->igmp_group_list = list_new();
-	if (!igmp->igmp_group_list) {
-		zlog_err("%s %s: failure: igmp_group_list = list_new()",
-			 __FILE__, __PRETTY_FUNCTION__);
-		return 0;
-	}
 	igmp->igmp_group_list->del = (void (*)(void *))igmp_group_free;
 
 	snprintf(hash_name, 64, "IGMP %s hash", ifp->name);
@@ -867,6 +881,8 @@ static struct igmp_sock *igmp_sock_new(i
 		pim_ifp->igmp_default_robustness_variable;
 	igmp->sock_creation = pim_time_monotonic_sec();
 
+	igmp_stats_init(&igmp->rx_stats);
+
 	if (mtrace_only) {
 		igmp->mtrace_only = mtrace_only;
 		return igmp;
@@ -896,10 +912,9 @@ static int pim_igmp_read(struct thread *
 	socklen_t fromlen = sizeof(from);
 	socklen_t tolen = sizeof(to);
 	ifindex_t ifindex = -1;
-	int cont = 1;
 	int len;
 
-	while (cont) {
+	while (1) {
 		len = pim_socket_recvfromto(igmp->fd, buf, sizeof(buf), &from,
 					    &fromlen, &to, &tolen, &ifindex);
 		if (len < 0) {
@@ -948,12 +963,6 @@ struct igmp_sock *pim_igmp_sock_add(stru
 	}
 
 	igmp = igmp_sock_new(fd, ifaddr, ifp, mtrace_only);
-	if (!igmp) {
-		zlog_err("%s %s: igmp_sock_new() failure", __FILE__,
-			 __PRETTY_FUNCTION__);
-		close(fd);
-		return 0;
-	}
 
 	igmp_read_on(igmp);
 
@@ -1107,19 +1116,8 @@ struct igmp_group *igmp_add_group_by_add
 	*/
 
 	group = XCALLOC(MTYPE_PIM_IGMP_GROUP, sizeof(*group));
-	if (!group) {
-		zlog_warn("%s %s: XCALLOC() failure", __FILE__,
-			  __PRETTY_FUNCTION__);
-		return NULL; /* error, not found, could not create */
-	}
 
 	group->group_source_list = list_new();
-	if (!group->group_source_list) {
-		zlog_warn("%s %s: list_new() failure", __FILE__,
-			  __PRETTY_FUNCTION__);
-		XFREE(MTYPE_PIM_IGMP_GROUP, group); /* discard group */
-		return NULL; /* error, not found, could not initialize */
-	}
 	group->group_source_list->del = (void (*)(void *))igmp_source_free;
 
 	group->t_group_timer = NULL;
diff -urpN frr-frr-5.0.1/pimd/pim_igmp.h frr-frr-6.0/pimd/pim_igmp.h
--- frr-frr-5.0.1/pimd/pim_igmp.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmp.h	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 #include <zebra.h>
 #include "vty.h"
 #include "linklist.h"
+#include "pim_igmp_stats.h"
 
 /*
   The following sizes are likely to support
@@ -94,6 +95,8 @@ struct igmp_sock {
 
 	struct list *igmp_group_list; /* list of struct igmp_group */
 	struct hash *igmp_group_hash;
+
+	struct igmp_stats rx_stats;
 };
 
 struct igmp_sock *pim_igmp_sock_lookup_ifaddr(struct list *igmp_sock_list,
diff -urpN frr-frr-5.0.1/pimd/pim_igmp_join.h frr-frr-6.0/pimd/pim_igmp_join.h
--- frr-frr-5.0.1/pimd/pim_igmp_join.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmp_join.h	2018-10-08 14:32:57.000000000 +0200
@@ -60,8 +60,6 @@ static int pim_igmp_join_source(int fd,
 
 	return setsockopt(fd, SOL_IP, MCAST_JOIN_SOURCE_GROUP, &req,
 			  sizeof(req));
-
-	return 0;
 }
 
 #endif /* PIM_IGMP_JOIN_H */
diff -urpN frr-frr-5.0.1/pimd/pim_igmp_mtrace.c frr-frr-6.0/pimd/pim_igmp_mtrace.c
--- frr-frr-5.0.1/pimd/pim_igmp_mtrace.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmp_mtrace.c	2018-10-08 14:32:57.000000000 +0200
@@ -671,6 +671,9 @@ int igmp_mtrace_recv_qry_req(struct igmp
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.mtrace_req++;
+
 	if (PIM_DEBUG_MTRACE)
 		mtrace_debug(pim_ifp, mtracep, igmp_msg_len);
 
@@ -814,7 +817,7 @@ int igmp_mtrace_recv_qry_req(struct igmp
 		 * Previous-hop router not known,
 		 * packet is sent to an appropriate multicast address
 		 */
-		inet_aton(MCAST_ALL_ROUTERS, &nh_addr);
+		(void)inet_aton(MCAST_ALL_ROUTERS, &nh_addr);
 	}
 
 	/* 6.2.2 8. If this router is the Rendez-vous Point */
@@ -881,6 +884,9 @@ int igmp_mtrace_recv_response(struct igm
 
 	mtracep->checksum = checksum;
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.mtrace_rsp++;
+
 	if (PIM_DEBUG_MTRACE)
 		mtrace_debug(pim_ifp, mtracep, igmp_msg_len);
 
diff -urpN frr-frr-5.0.1/pimd/pim_igmp_stats.c frr-frr-6.0/pimd/pim_igmp_stats.c
--- frr-frr-5.0.1/pimd/pim_igmp_stats.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/pimd/pim_igmp_stats.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * PIM for FRRouting
+ * Copyright (C) 2018  Mladen Sablic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "pim_igmp_stats.h"
+
+void igmp_stats_init(struct igmp_stats *stats)
+{
+	memset(stats, 0, sizeof(struct igmp_stats));
+}
+
+void igmp_stats_add(struct igmp_stats *a, struct igmp_stats *b)
+{
+	if (!a || !b)
+		return;
+
+	a->query_v1 += b->query_v1;
+	a->query_v2 += b->query_v2;
+	a->query_v3 += b->query_v3;
+	a->report_v1 += b->report_v1;
+	a->report_v2 += b->report_v2;
+	a->report_v3 += b->report_v3;
+	a->leave_v2 += b->leave_v2;
+	a->mtrace_rsp += b->mtrace_rsp;
+	a->mtrace_req += b->mtrace_req;
+	a->unsupported += b->unsupported;
+}
diff -urpN frr-frr-5.0.1/pimd/pim_igmp_stats.h frr-frr-6.0/pimd/pim_igmp_stats.h
--- frr-frr-5.0.1/pimd/pim_igmp_stats.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/pimd/pim_igmp_stats.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ * PIM for FRRouting
+ * Copyright (C) 2018  Mladen Sablic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef PIM_IGMP_STATS_H
+#define PIM_IGMP_STATS_H
+
+#include <zebra.h>
+
+struct igmp_stats {
+	uint32_t	query_v1;
+	uint32_t	query_v2;
+	uint32_t	query_v3;
+	uint32_t	report_v1;
+	uint32_t	report_v2;
+	uint32_t	report_v3;
+	uint32_t	leave_v2;
+	uint32_t	mtrace_rsp;
+	uint32_t	mtrace_req;
+	uint32_t	unsupported;
+};
+
+void igmp_stats_init(struct igmp_stats *stats);
+void igmp_stats_add(struct igmp_stats *a, struct igmp_stats *b);
+
+#endif /* PIM_IGMP_STATS_H */
diff -urpN frr-frr-5.0.1/pimd/pim_igmpv2.c frr-frr-6.0/pimd/pim_igmpv2.c
--- frr-frr-5.0.1/pimd/pim_igmpv2.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmpv2.c	2018-10-08 14:32:57.000000000 +0200
@@ -121,6 +121,9 @@ int igmp_v2_recv_report(struct igmp_sock
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.report_v2++;
+
 	memcpy(&group_addr, igmp_msg + 4, sizeof(struct in_addr));
 
 	if (PIM_DEBUG_IGMP_PACKETS) {
@@ -167,6 +170,9 @@ int igmp_v2_recv_leave(struct igmp_sock
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.leave_v2++;
+
 	memcpy(&group_addr, igmp_msg + 4, sizeof(struct in_addr));
 
 	if (PIM_DEBUG_IGMP_PACKETS) {
diff -urpN frr-frr-5.0.1/pimd/pim_igmpv3.c frr-frr-6.0/pimd/pim_igmpv3.c
--- frr-frr-5.0.1/pimd/pim_igmpv3.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_igmpv3.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,6 +21,7 @@
 #include "log.h"
 #include "memory.h"
 #include "if.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_iface.h"
@@ -457,11 +458,6 @@ struct igmp_source *source_new(struct ig
 	}
 
 	src = XCALLOC(MTYPE_PIM_IGMP_GROUP_SOURCE, sizeof(*src));
-	if (!src) {
-		zlog_warn("%s %s: XCALLOC() failure", __FILE__,
-			  __PRETTY_FUNCTION__);
-		return 0; /* error, not found, could not create */
-	}
 
 	src->t_source_timer = NULL;
 	src->source_group = group; /* back pointer */
@@ -491,9 +487,6 @@ static struct igmp_source *add_source_by
 	}
 
 	src = source_new(group, src_addr);
-	if (!src) {
-		return 0;
-	}
 
 	return src;
 }
@@ -584,10 +577,6 @@ static void isex_excl(struct igmp_group
 			/* E.4: if not found, create source with timer=GMI:
 			 * (A-X-Y) */
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 			zassert(!source->t_source_timer); /* timer == 0 */
 			igmp_source_reset_gmi(group->group_igmp_sock, group,
 					      source);
@@ -642,10 +631,6 @@ static void isex_incl(struct igmp_group
 			/* I.4: if not found, create source with timer=0 (B-A)
 			 */
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 			zassert(!source->t_source_timer); /* (B-A) timer=0 */
 		}
 
@@ -725,10 +710,6 @@ static void toin_incl(struct igmp_group
 		} else {
 			/* If not found, create new source */
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 		}
 
 		/* (B)=GMI */
@@ -770,10 +751,6 @@ static void toin_excl(struct igmp_group
 		} else {
 			/* If not found, create new source */
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 		}
 
 		/* (A)=GMI */
@@ -859,10 +836,6 @@ static void toex_incl(struct igmp_group
 			/* If source not found, create source with timer=0:
 			 * (B-A)=0 */
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 			zassert(!source->t_source_timer); /* (B-A) timer=0 */
 		}
 
@@ -922,10 +895,6 @@ static void toex_excl(struct igmp_group
 			 * (A-X-Y)=Group Timer */
 			long group_timer_msec;
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 
 			zassert(!source->t_source_timer); /* timer == 0 */
 			group_timer_msec = igmp_group_timer_remain_msec(group);
@@ -1436,10 +1405,6 @@ static void block_excl(struct igmp_group
 			 * (A-X-Y)=Group Timer */
 			long group_timer_msec;
 			source = source_new(group, *src_addr);
-			if (!source) {
-				/* ugh, internal malloc failure, skip source */
-				continue;
-			}
 
 			zassert(!source->t_source_timer); /* timer == 0 */
 			group_timer_msec = igmp_group_timer_remain_msec(group);
@@ -1619,7 +1584,8 @@ void igmp_v3_send_query(struct igmp_grou
 
 	msg_size = IGMP_V3_SOURCES_OFFSET + (num_sources << 2);
 	if (msg_size > query_buf_size) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_DEVELOPMENT,
 			"%s %s: unable to send: msg_size=%zd larger than query_buf_size=%d",
 			__FILE__, __PRETTY_FUNCTION__, msg_size,
 			query_buf_size);
@@ -1900,6 +1866,9 @@ int igmp_v3_recv_report(struct igmp_sock
 		return -1;
 	}
 
+	/* Collecting IGMP Rx stats */
+	igmp->rx_stats.report_v3++;
+
 	num_groups = ntohs(
 		*(uint16_t *)(igmp_msg + IGMP_V3_REPORT_NUMGROUPS_OFFSET));
 	if (num_groups < 1) {
diff -urpN frr-frr-5.0.1/pimd/pim_instance.c frr-frr-6.0/pimd/pim_instance.c
--- frr-frr-5.0.1/pimd/pim_instance.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_instance.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 
 #include "hash.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_ssm.h"
@@ -35,13 +36,6 @@
 
 static void pim_instance_terminate(struct pim_instance *pim)
 {
-	/* Traverse and cleanup rpf_hash */
-	if (pim->rpf_hash) {
-		hash_clean(pim->rpf_hash, (void *)pim_rp_list_hash_clean);
-		hash_free(pim->rpf_hash);
-		pim->rpf_hash = NULL;
-	}
-
 	if (pim->ssm_info) {
 		pim_ssm_terminate(pim->ssm_info);
 		pim->ssm_info = NULL;
@@ -54,10 +48,17 @@ static void pim_instance_terminate(struc
 
 	pim_upstream_terminate(pim);
 
-	pim_oil_terminate(pim);
+	/* Traverse and cleanup rpf_hash */
+	if (pim->rpf_hash) {
+		hash_clean(pim->rpf_hash, (void *)pim_rp_list_hash_clean);
+		hash_free(pim->rpf_hash);
+		pim->rpf_hash = NULL;
+	}
 
 	pim_if_terminate(pim);
 
+	pim_oil_terminate(pim);
+
 	pim_msdp_exit(pim);
 
 	XFREE(MTYPE_PIM_PIM_INSTANCE, pim);
@@ -69,14 +70,14 @@ static struct pim_instance *pim_instance
 	char hash_name[64];
 
 	pim = XCALLOC(MTYPE_PIM_PIM_INSTANCE, sizeof(struct pim_instance));
-	if (!pim)
-		return NULL;
 
 	pim_if_init(pim);
 
 	pim->keep_alive_time = PIM_KEEPALIVE_PERIOD;
 	pim->rp_keep_alive_time = PIM_RP_KEEPALIVE_PERIOD;
 
+	pim->ecmp_enable = false;
+	pim->ecmp_rebalance_enable = false;
 
 	pim->vrf_id = vrf->vrf_id;
 	pim->vrf = vrf;
@@ -94,18 +95,8 @@ static struct pim_instance *pim_instance
 		zlog_debug("%s: NHT rpf hash init ", __PRETTY_FUNCTION__);
 
 	pim->ssm_info = pim_ssm_init();
-	if (!pim->ssm_info) {
-		pim_instance_terminate(pim);
-		return NULL;
-	}
 
 	pim->static_routes = list_new();
-	if (!pim->static_routes) {
-		zlog_err("%s %s: failure: static_routes=list_new()", __FILE__,
-			 __PRETTY_FUNCTION__);
-		pim_instance_terminate(pim);
-		return NULL;
-	}
 	pim->static_routes->del = (void (*)(void *))pim_static_route_free;
 
 	pim->send_v6_secondary = 1;
@@ -138,14 +129,6 @@ static int pim_vrf_new(struct vrf *vrf)
 	struct pim_instance *pim = pim_instance_init(vrf);
 
 	zlog_debug("VRF Created: %s(%u)", vrf->name, vrf->vrf_id);
-	if (pim == NULL) {
-		zlog_err("%s %s: pim class init failure ", __FILE__,
-			 __PRETTY_FUNCTION__);
-		/*
-		 * We will crash and burn otherwise
-		 */
-		exit(1);
-	}
 
 	vrf->info = (void *)pim;
 
diff -urpN frr-frr-5.0.1/pimd/pim_instance.h frr-frr-6.0/pimd/pim_instance.h
--- frr-frr-5.0.1/pimd/pim_instance.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_instance.h	2018-10-08 14:32:57.000000000 +0200
@@ -95,6 +95,9 @@ struct pim_instance {
 	unsigned int keep_alive_time;
 	unsigned int rp_keep_alive_time;
 
+	bool ecmp_enable;
+	bool ecmp_rebalance_enable;
+
 	/* If we need to rescan all our upstreams */
 	struct thread *rpf_cache_refresher;
 	int64_t rpf_cache_refresh_requests;
diff -urpN frr-frr-5.0.1/pimd/pim_jp_agg.c frr-frr-6.0/pimd/pim_jp_agg.c
--- frr-frr-5.0.1/pimd/pim_jp_agg.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_jp_agg.c	2018-10-08 14:32:57.000000000 +0200
@@ -329,7 +329,6 @@ void pim_jp_agg_single_upstream_send(str
 
 	if (first) {
 		groups = list_new();
-
 		jag.sources = list_new();
 
 		listnode_add(groups, &jag);
diff -urpN frr-frr-5.0.1/pimd/pim_main.c frr-frr-6.0/pimd/pim_main.c
--- frr-frr-5.0.1/pimd/pim_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -47,6 +47,7 @@
 #include "pim_msdp.h"
 #include "pim_iface.h"
 #include "pim_bfd.h"
+#include "pim_errors.h"
 
 extern struct host host;
 
@@ -108,6 +109,7 @@ int main(int argc, char **argv, char **e
 	/*
 	 * Initializations
 	 */
+	pim_error_init();
 	pim_vrf_init();
 	access_list_init();
 	prefix_list_init();
diff -urpN frr-frr-5.0.1/pimd/pim_mroute.c frr-frr-6.0/pimd/pim_mroute.c
--- frr-frr-5.0.1/pimd/pim_mroute.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_mroute.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 #include "vty.h"
 #include "plist.h"
 #include "sockopt.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_rpf.h"
@@ -55,27 +56,22 @@ static int pim_mroute_set(struct pim_ins
 	 * We need to create the VRF table for the pim mroute_socket
 	 */
 	if (pim->vrf_id != VRF_DEFAULT) {
-		if (pimd_privs.change(ZPRIVS_RAISE))
-			zlog_err(
-				"pim_mroute_socket_enable: could not raise privs, %s",
-				safe_strerror(errno));
+		frr_elevate_privs(&pimd_privs) {
 
-		opt = pim->vrf->data.l.table_id;
-		err = setsockopt(pim->mroute_socket, IPPROTO_IP, MRT_TABLE,
-				 &opt, opt_len);
-		if (err) {
-			zlog_warn(
-				"%s %s: failure: setsockopt(fd=%d,IPPROTO_IP, MRT_TABLE=%d): errno=%d: %s",
-				__FILE__, __PRETTY_FUNCTION__,
-				pim->mroute_socket, opt, errno,
-				safe_strerror(errno));
-			return -1;
-		}
+			opt = pim->vrf->data.l.table_id;
+			err = setsockopt(pim->mroute_socket, IPPROTO_IP,
+					 MRT_TABLE,
+					 &opt, opt_len);
+			if (err) {
+				zlog_warn(
+					  "%s %s: failure: setsockopt(fd=%d,IPPROTO_IP, MRT_TABLE=%d): errno=%d: %s",
+					  __FILE__, __PRETTY_FUNCTION__,
+					  pim->mroute_socket, opt, errno,
+					  safe_strerror(errno));
+				return -1;
+			}
 
-		if (pimd_privs.change(ZPRIVS_LOWER))
-			zlog_err(
-				"pim_mroute_socket_enable: could not lower privs, %s",
-				safe_strerror(errno));
+		}
 	}
 
 	opt = enable ? MRT_INIT : MRT_DONE;
@@ -152,13 +148,13 @@ static int pim_mroute_msg_nocache(int fd
 	struct pim_rpf *rpg;
 	struct prefix_sg sg;
 
-	rpg = RP(pim_ifp->pim, msg->im_dst);
+	rpg = pim_ifp ? RP(pim_ifp->pim, msg->im_dst) : NULL;
 	/*
 	 * If the incoming interface is unknown OR
 	 * the Interface type is SSM we don't need to
 	 * do anything here
 	 */
-	if ((pim_rpf_addr_is_inaddr_none(rpg)) || (!pim_ifp)
+	if (!rpg || (pim_rpf_addr_is_inaddr_none(rpg))
 	    || (!(PIM_I_am_DR(pim_ifp)))) {
 		if (PIM_DEBUG_MROUTE_DETAIL)
 			zlog_debug(
@@ -278,7 +274,7 @@ static int pim_mroute_msg_wholepkt(int f
 
 	pim_ifp = up->rpf.source_nexthop.interface->info;
 
-	rpg = RP(pim_ifp->pim, sg.grp);
+	rpg = pim_ifp ? RP(pim_ifp->pim, sg.grp) : NULL;
 
 	if ((pim_rpf_addr_is_inaddr_none(rpg)) || (!pim_ifp)
 	    || (!(PIM_I_am_DR(pim_ifp)))) {
@@ -708,32 +704,29 @@ int pim_mroute_socket_enable(struct pim_
 {
 	int fd;
 
-	if (pimd_privs.change(ZPRIVS_RAISE))
-		zlog_err("pim_mroute_socket_enable: could not raise privs, %s",
-			 safe_strerror(errno));
-
-	fd = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);
-
-	if (fd < 0) {
-		zlog_warn("Could not create mroute socket: errno=%d: %s", errno,
-			  safe_strerror(errno));
-		return -2;
-	}
+	frr_elevate_privs(&pimd_privs) {
+
+		fd = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);
+
+		if (fd < 0) {
+			zlog_warn("Could not create mroute socket: errno=%d: %s",
+				  errno,
+				  safe_strerror(errno));
+			return -2;
+		}
 
 #ifdef SO_BINDTODEVICE
-	if (pim->vrf->vrf_id != VRF_DEFAULT
-	    && setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, pim->vrf->name,
-			  strlen(pim->vrf->name))) {
-		zlog_warn("Could not setsockopt SO_BINDTODEVICE: %s",
-			  safe_strerror(errno));
-		close(fd);
-		return -3;
-	}
+		if (pim->vrf->vrf_id != VRF_DEFAULT
+		    && setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,
+				  pim->vrf->name, strlen(pim->vrf->name))) {
+			zlog_warn("Could not setsockopt SO_BINDTODEVICE: %s",
+				  safe_strerror(errno));
+			close(fd);
+			return -3;
+		}
 #endif
 
-	if (pimd_privs.change(ZPRIVS_LOWER))
-		zlog_err("pim_mroute_socket_enable: could not lower privs, %s",
-			 safe_strerror(errno));
+	}
 
 	pim->mroute_socket = fd;
 	if (pim_mroute_set(pim, 1)) {
diff -urpN frr-frr-5.0.1/pimd/pim_msdp.c frr-frr-6.0/pimd/pim_msdp.c
--- frr-frr-5.0.1/pimd/pim_msdp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_msdp.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@
 #include <lib/thread.h>
 #include <lib/vty.h>
 #include <lib/plist.h>
+#include <lib/lib_errors.h>
 
 #include "pimd.h"
 #include "pim_cmd.h"
@@ -228,6 +229,8 @@ static void pim_msdp_sa_upstream_update(
 /* release all mem associated with a sa */
 static void pim_msdp_sa_free(struct pim_msdp_sa *sa)
 {
+	pim_msdp_sa_state_timer_setup(sa, false);
+
 	XFREE(MTYPE_PIM_MSDP_SA, sa);
 }
 
@@ -238,11 +241,6 @@ static struct pim_msdp_sa *pim_msdp_sa_n
 	struct pim_msdp_sa *sa;
 
 	sa = XCALLOC(MTYPE_PIM_MSDP_SA, sizeof(*sa));
-	if (!sa) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*sa));
-		return NULL;
-	}
 
 	sa->pim = pim;
 	sa->sg = *sg;
@@ -252,11 +250,6 @@ static struct pim_msdp_sa *pim_msdp_sa_n
 
 	/* insert into misc tables for easy access */
 	sa = hash_get(pim->msdp.sa_hash, sa, hash_alloc_intern);
-	if (!sa) {
-		zlog_err("%s: PIM hash get failure", __PRETTY_FUNCTION__);
-		pim_msdp_sa_free(sa);
-		return NULL;
-	}
 	listnode_add_sort(pim->msdp.sa_list, sa);
 
 	if (PIM_DEBUG_MSDP_EVENTS) {
@@ -525,7 +518,8 @@ static void pim_msdp_sa_local_del_on_up_
 			 * the flow. Accounting for such cases requires lot of
 			 * changes; perhaps
 			 * address this in the next release? - XXX  */
-			zlog_err(
+			flog_err(
+				  LIB_ERR_DEVELOPMENT,
 				"MSDP sa %s SPT teardown is causing the local entry to be removed",
 				sa->sg_str);
 			return;
@@ -1072,11 +1066,6 @@ static enum pim_msdp_err pim_msdp_peer_n
 	pim_msdp_enable(pim);
 
 	mp = XCALLOC(MTYPE_PIM_MSDP_PEER, sizeof(*mp));
-	if (!mp) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*mp));
-		return PIM_MSDP_ERR_OOM;
-	}
 
 	mp->pim = pim;
 	mp->peer = peer_addr;
@@ -1170,6 +1159,12 @@ enum pim_msdp_err pim_msdp_peer_add(stru
 /* release all mem associated with a peer */
 static void pim_msdp_peer_free(struct pim_msdp_peer *mp)
 {
+	/*
+	 * Let's make sure we are not running when we delete
+	 * the underlying data structure
+	 */
+	pim_msdp_peer_stop_tcp_conn(mp, false);
+
 	if (mp->ibuf) {
 		stream_free(mp->ibuf);
 	}
@@ -1181,6 +1176,8 @@ static void pim_msdp_peer_free(struct pi
 	if (mp->mesh_group_name) {
 		XFREE(MTYPE_PIM_MSDP_MG_NAME, mp->mesh_group_name);
 	}
+
+	mp->pim = NULL;
 	XFREE(MTYPE_PIM_MSDP_PEER, mp);
 }
 
@@ -1247,8 +1244,10 @@ static int pim_msdp_peer_comp(const void
 }
 
 /************************** Mesh group management **************************/
-static void pim_msdp_mg_free(struct pim_instance *pim, struct pim_msdp_mg *mg)
+static void pim_msdp_mg_free(struct pim_instance *pim)
 {
+	struct pim_msdp_mg *mg = pim->msdp.mg;
+
 	/* If the mesh-group has valid member or src_ip don't delete it */
 	if (!mg || mg->mbr_cnt || (mg->src_ip.s_addr != INADDR_ANY)) {
 		return;
@@ -1263,8 +1262,7 @@ static void pim_msdp_mg_free(struct pim_
 	if (mg->mbr_list)
 		list_delete_and_null(&mg->mbr_list);
 
-	XFREE(MTYPE_PIM_MSDP_MG, mg);
-	pim->msdp.mg = NULL;
+	XFREE(MTYPE_PIM_MSDP_MG, pim->msdp.mg);
 }
 
 static struct pim_msdp_mg *pim_msdp_mg_new(const char *mesh_group_name)
@@ -1272,11 +1270,6 @@ static struct pim_msdp_mg *pim_msdp_mg_n
 	struct pim_msdp_mg *mg;
 
 	mg = XCALLOC(MTYPE_PIM_MSDP_MG, sizeof(*mg));
-	if (!mg) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*mg));
-		return NULL;
-	}
 
 	mg->mesh_group_name = XSTRDUP(MTYPE_PIM_MSDP_MG_NAME, mesh_group_name);
 	mg->mbr_list = list_new();
@@ -1309,7 +1302,7 @@ enum pim_msdp_err pim_msdp_mg_del(struct
 	mg->src_ip.s_addr = INADDR_ANY;
 
 	/* free up the mesh-group */
-	pim_msdp_mg_free(pim, mg);
+	pim_msdp_mg_free(pim);
 	return PIM_MSDP_ERR_NONE;
 }
 
@@ -1390,13 +1383,6 @@ enum pim_msdp_err pim_msdp_mg_mbr_add(st
 	}
 
 	mbr = XCALLOC(MTYPE_PIM_MSDP_MG_MBR, sizeof(*mbr));
-	if (!mbr) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*mbr));
-		/* if there are no references to the mg free it */
-		pim_msdp_mg_free(pim, mg);
-		return PIM_MSDP_ERR_OOM;
-	}
 	mbr->mbr_ip = mbr_ip;
 	listnode_add_sort(mg->mbr_list, mbr);
 
@@ -1455,7 +1441,7 @@ enum pim_msdp_err pim_msdp_mg_mbr_del(st
 
 	pim_msdp_mg_mbr_do_del(mg, mbr);
 	/* if there are no references to the mg free it */
-	pim_msdp_mg_free(pim, mg);
+	pim_msdp_mg_free(pim);
 
 	return PIM_MSDP_ERR_NONE;
 }
@@ -1492,7 +1478,7 @@ enum pim_msdp_err pim_msdp_mg_src_del(st
 		mg->src_ip.s_addr = INADDR_ANY;
 		pim_msdp_mg_src_do_del(pim);
 		/* if there are no references to the mg free it */
-		pim_msdp_mg_free(pim, mg);
+		pim_msdp_mg_free(pim);
 	}
 	return PIM_MSDP_ERR_NONE;
 }
@@ -1611,9 +1597,14 @@ void pim_msdp_init(struct pim_instance *
 /* counterpart to MSDP init; XXX: unused currently */
 void pim_msdp_exit(struct pim_instance *pim)
 {
+	pim_msdp_sa_adv_timer_setup(pim, false);
+
 	/* XXX: stop listener and delete all peer sessions */
 
+	pim_msdp_mg_free(pim);
+
 	if (pim->msdp.peer_hash) {
+		hash_clean(pim->msdp.peer_hash, NULL);
 		hash_free(pim->msdp.peer_hash);
 		pim->msdp.peer_hash = NULL;
 	}
@@ -1623,6 +1614,7 @@ void pim_msdp_exit(struct pim_instance *
 	}
 
 	if (pim->msdp.sa_hash) {
+		hash_clean(pim->msdp.sa_hash, NULL);
 		hash_free(pim->msdp.sa_hash);
 		pim->msdp.sa_hash = NULL;
 	}
@@ -1630,4 +1622,8 @@ void pim_msdp_exit(struct pim_instance *
 	if (pim->msdp.sa_list) {
 		list_delete_and_null(&pim->msdp.sa_list);
 	}
+
+	if (pim->msdp.work_obuf)
+		stream_free(pim->msdp.work_obuf);
+	pim->msdp.work_obuf = NULL;
 }
diff -urpN frr-frr-5.0.1/pimd/pim_msdp_packet.c frr-frr-6.0/pimd/pim_msdp_packet.c
--- frr-frr-5.0.1/pimd/pim_msdp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_msdp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -23,9 +23,11 @@
 #include <lib/stream.h>
 #include <lib/thread.h>
 #include <lib/vty.h>
+#include <lib/lib_errors.h>
 
 #include "pimd.h"
 #include "pim_str.h"
+#include "pim_errors.h"
 
 #include "pim_msdp.h"
 #include "pim_msdp_packet.h"
@@ -145,7 +147,8 @@ static void pim_msdp_connect_check(struc
 
 	/* If getsockopt is fail, this is fatal error. */
 	if (ret < 0) {
-		zlog_err("can't get sockopt for nonblocking connect");
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "can't get sockopt for nonblocking connect");
 		pim_msdp_peer_reset_tcp_conn(mp, "connect-failed");
 		return;
 	}
@@ -481,8 +484,9 @@ static void pim_msdp_pkt_sa_rx_one(struc
 
 	if (prefix_len != 32) {
 		/* ignore SA update if the prefix length is not 32 */
-		zlog_err("rxed sa update with invalid prefix length %d",
-			 prefix_len);
+		flog_err(PIM_ERR_MSDP_PACKET,
+			  "rxed sa update with invalid prefix length %d",
+			  prefix_len);
 		return;
 	}
 	if (PIM_DEBUG_MSDP_PACKETS) {
diff -urpN frr-frr-5.0.1/pimd/pim_msdp_socket.c frr-frr-6.0/pimd/pim_msdp_socket.c
--- frr-frr-5.0.1/pimd/pim_msdp_socket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_msdp_socket.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,9 +26,11 @@
 #include <lib/vty.h>
 #include <lib/if.h>
 #include <lib/vrf.h>
+#include <lib/lib_errors.h>
 
 #include "pimd.h"
 #include "pim_sock.h"
+#include "pim_errors.h"
 
 #include "pim_msdp.h"
 #include "pim_msdp_socket.h"
@@ -41,16 +43,18 @@ static void pim_msdp_update_sock_send_bu
 	socklen_t optlen = sizeof(optval);
 
 	if (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &optval, &optlen) < 0) {
-		zlog_err("getsockopt of SO_SNDBUF failed %s\n",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "getsockopt of SO_SNDBUF failed %s\n",
+			     safe_strerror(errno));
 		return;
 	}
 
 	if (optval < size) {
 		if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size))
 		    < 0) {
-			zlog_err("Couldn't increase send buffer: %s\n",
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET,
+				     "Couldn't increase send buffer: %s\n",
+				     safe_strerror(errno));
 		}
 	}
 }
@@ -70,7 +74,8 @@ static int pim_msdp_sock_accept(struct t
 	/* re-register accept thread */
 	accept_sock = THREAD_FD(thread);
 	if (accept_sock < 0) {
-		zlog_err("accept_sock is negative value %d", accept_sock);
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "accept_sock is negative value %d", accept_sock);
 		return -1;
 	}
 	pim->msdp.listener.thread = NULL;
@@ -80,8 +85,8 @@ static int pim_msdp_sock_accept(struct t
 	/* accept client connection. */
 	msdp_sock = sockunion_accept(accept_sock, &su);
 	if (msdp_sock < 0) {
-		zlog_err("pim_msdp_sock_accept failed (%s)",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "pim_msdp_sock_accept failed (%s)",
+			     safe_strerror(errno));
 		return -1;
 	}
 
@@ -90,8 +95,9 @@ static int pim_msdp_sock_accept(struct t
 	if (!mp || !PIM_MSDP_PEER_IS_LISTENER(mp)) {
 		++pim->msdp.rejected_accepts;
 		if (PIM_DEBUG_MSDP_EVENTS) {
-			zlog_err("msdp peer connection refused from %s",
-				 sockunion2str(&su, buf, SU_ADDRSTRLEN));
+			flog_err(PIM_ERR_MSDP_PACKET,
+				  "msdp peer connection refused from %s",
+				  sockunion2str(&su, buf, SU_ADDRSTRLEN));
 		}
 		close(msdp_sock);
 		return -1;
@@ -106,7 +112,7 @@ static int pim_msdp_sock_accept(struct t
 	 * with this one */
 	if (mp->fd >= 0) {
 		if (PIM_DEBUG_MSDP_EVENTS) {
-			zlog_err(
+			zlog_notice(
 				"msdp peer new connection from %s stop old connection",
 				sockunion2str(&su, buf, SU_ADDRSTRLEN));
 		}
@@ -135,7 +141,8 @@ int pim_msdp_sock_listen(struct pim_inst
 
 	sock = socket(AF_INET, SOCK_STREAM, 0);
 	if (sock < 0) {
-		zlog_err("socket: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "socket: %s",
+			     safe_strerror(errno));
 		return sock;
 	}
 
@@ -154,42 +161,38 @@ int pim_msdp_sock_listen(struct pim_inst
 		struct interface *ifp =
 			if_lookup_by_name(pim->vrf->name, pim->vrf_id);
 		if (!ifp) {
-			zlog_err("%s: Unable to lookup vrf interface: %s",
-				 __PRETTY_FUNCTION__, pim->vrf->name);
+			flog_err(LIB_ERR_INTERFACE,
+				  "%s: Unable to lookup vrf interface: %s",
+				  __PRETTY_FUNCTION__, pim->vrf->name);
 			close(sock);
 			return -1;
 		}
 		if (pim_socket_bind(sock, ifp)) {
-			zlog_err("%s: Unable to bind to socket: %s",
-				 __PRETTY_FUNCTION__, safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET,
+				     "%s: Unable to bind to socket: %s",
+				     __PRETTY_FUNCTION__, safe_strerror(errno));
 			close(sock);
 			return -1;
 		}
 	}
 
-	if (pimd_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("pim_msdp_socket: could not raise privs, %s",
-			 safe_strerror(errno));
-	}
-
-	/* bind to well known TCP port */
-	rc = bind(sock, (struct sockaddr *)&sin, socklen);
-
-	if (pimd_privs.change(ZPRIVS_LOWER)) {
-		zlog_err("pim_msdp_socket: could not lower privs, %s",
-			 safe_strerror(errno));
+	frr_elevate_privs(&pimd_privs) {
+		/* bind to well known TCP port */
+		rc = bind(sock, (struct sockaddr *)&sin, socklen);
 	}
 
 	if (rc < 0) {
-		zlog_err("pim_msdp_socket bind to port %d: %s",
-			 ntohs(sin.sin_port), safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "pim_msdp_socket bind to port %d: %s",
+			     ntohs(sin.sin_port), safe_strerror(errno));
 		close(sock);
 		return rc;
 	}
 
 	rc = listen(sock, 3 /* backlog */);
 	if (rc < 0) {
-		zlog_err("pim_msdp_socket listen: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "pim_msdp_socket listen: %s",
+			     safe_strerror(errno));
 		close(sock);
 		return rc;
 	}
@@ -219,7 +222,7 @@ int pim_msdp_sock_connect(struct pim_msd
 	 * with this one */
 	if (mp->fd >= 0) {
 		if (PIM_DEBUG_MSDP_EVENTS) {
-			zlog_err(
+			zlog_notice(
 				"msdp duplicate connect to %s nuke old connection",
 				mp->key_str);
 		}
@@ -229,8 +232,9 @@ int pim_msdp_sock_connect(struct pim_msd
 	/* Make socket for the peer. */
 	mp->fd = sockunion_socket(&mp->su_peer);
 	if (mp->fd < 0) {
-		zlog_err("pim_msdp_socket socket failure: %s",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "pim_msdp_socket socket failure: %s",
+			     safe_strerror(errno));
 		return -1;
 	}
 
@@ -238,13 +242,15 @@ int pim_msdp_sock_connect(struct pim_msd
 		struct interface *ifp =
 			if_lookup_by_name(mp->pim->vrf->name, mp->pim->vrf_id);
 		if (!ifp) {
-			zlog_err("%s: Unable to lookup vrf interface: %s",
-				 __PRETTY_FUNCTION__, mp->pim->vrf->name);
+			flog_err(LIB_ERR_INTERFACE,
+				  "%s: Unable to lookup vrf interface: %s",
+				  __PRETTY_FUNCTION__, mp->pim->vrf->name);
 			return -1;
 		}
 		if (pim_socket_bind(mp->fd, ifp)) {
-			zlog_err("%s: Unable to bind to socket: %s",
-				 __PRETTY_FUNCTION__, safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET,
+				     "%s: Unable to bind to socket: %s",
+				     __PRETTY_FUNCTION__, safe_strerror(errno));
 			close(mp->fd);
 			mp->fd = -1;
 			return -1;
@@ -261,8 +267,9 @@ int pim_msdp_sock_connect(struct pim_msd
 	/* source bind */
 	rc = sockunion_bind(mp->fd, &mp->su_local, 0, &mp->su_local);
 	if (rc < 0) {
-		zlog_err("pim_msdp_socket connect bind failure: %s",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "pim_msdp_socket connect bind failure: %s",
+			     safe_strerror(errno));
 		close(mp->fd);
 		mp->fd = -1;
 		return rc;
diff -urpN frr-frr-5.0.1/pimd/pim_msg.c frr-frr-6.0/pimd/pim_msg.c
--- frr-frr-5.0.1/pimd/pim_msg.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_msg.c	2018-10-08 14:32:57.000000000 +0200
@@ -114,7 +114,7 @@ size_t pim_msg_get_jp_group_size(struct
 	size += sizeof(struct pim_encoded_source_ipv4) * sources->count;
 
 	js = listgetdata(listhead(sources));
-	if (js && js->up->sg.src.s_addr == INADDR_ANY) {
+	if (js && js->up->sg.src.s_addr == INADDR_ANY && js->is_join) {
 		struct pim_upstream *child, *up;
 		struct listnode *up_node;
 
diff -urpN frr-frr-5.0.1/pimd/pim_neighbor.c frr-frr-6.0/pimd/pim_neighbor.c
--- frr-frr-5.0.1/pimd/pim_neighbor.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_neighbor.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 #include "if.h"
 #include "vty.h"
 #include "plist.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_neighbor.h"
@@ -305,11 +306,6 @@ pim_neighbor_new(struct interface *ifp,
 	zassert(pim_ifp);
 
 	neigh = XCALLOC(MTYPE_PIM_NEIGHBOR, sizeof(*neigh));
-	if (!neigh) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*neigh));
-		return 0;
-	}
 
 	neigh->creation = pim_time_monotonic_sec();
 	neigh->source_addr = source_addr;
@@ -414,6 +410,9 @@ void pim_neighbor_free(struct pim_neighb
 	list_delete_and_null(&neigh->upstream_jp_agg);
 	THREAD_OFF(neigh->jp_timer);
 
+	if (neigh->bfd_info)
+		pim_bfd_info_free(&neigh->bfd_info);
+
 	XFREE(MTYPE_PIM_NEIGHBOR, neigh);
 }
 
@@ -801,7 +800,8 @@ void pim_neighbor_update(struct pim_neig
 
 	if (neigh->prefix_list == addr_list) {
 		if (addr_list) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_DEVELOPMENT,
 				"%s: internal error: trying to replace same prefix list=%p",
 				__PRETTY_FUNCTION__, (void *)addr_list);
 		}
diff -urpN frr-frr-5.0.1/pimd/pim_nht.c frr-frr-6.0/pimd/pim_nht.c
--- frr-frr-5.0.1/pimd/pim_nht.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_nht.c	2018-10-08 14:32:57.000000000 +0200
@@ -92,10 +92,6 @@ static struct pim_nexthop_cache *pim_nex
 
 	pnc = XCALLOC(MTYPE_PIM_NEXTHOP_CACHE,
 		      sizeof(struct pim_nexthop_cache));
-	if (!pnc) {
-		zlog_err("%s: NHT PIM XCALLOC failure ", __PRETTY_FUNCTION__);
-		return NULL;
-	}
 	pnc->rpf.rpf_addr.family = rpf_addr->rpf_addr.family;
 	pnc->rpf.rpf_addr.prefixlen = rpf_addr->rpf_addr.prefixlen;
 	pnc->rpf.rpf_addr.u.prefix4.s_addr =
@@ -140,14 +136,6 @@ int pim_find_or_track_nexthop(struct pim
 	pnc = pim_nexthop_cache_find(pim, &rpf);
 	if (!pnc) {
 		pnc = pim_nexthop_cache_add(pim, &rpf);
-		if (!pnc) {
-			char rpf_str[PREFIX_STRLEN];
-			pim_addr_dump("<nht-pnc?>", addr, rpf_str,
-				      sizeof(rpf_str));
-			zlog_warn("%s: pnc node allocation failed. addr %s ",
-				  __PRETTY_FUNCTION__, rpf_str);
-			return 0;
-		}
 		pim_sendmsg_zebra_rnh(pim, zclient, pnc,
 				      ZEBRA_NEXTHOP_REGISTER);
 		if (PIM_DEBUG_PIM_NHT) {
@@ -168,7 +156,7 @@ int pim_find_or_track_nexthop(struct pim
 	if (up != NULL)
 		hash_get(pnc->upstream_hash, up, hash_alloc_intern);
 
-	if (pnc && CHECK_FLAG(pnc->flags, PIM_NEXTHOP_VALID)) {
+	if (CHECK_FLAG(pnc->flags, PIM_NEXTHOP_VALID)) {
 		memcpy(out_pnc, pnc, sizeof(struct pim_nexthop_cache));
 		return 1;
 	}
@@ -312,59 +300,9 @@ static int pim_update_upstream_nh_helper
 		}
 	}
 
-	if (rpf_result == PIM_RPF_CHANGED) {
-		struct pim_neighbor *nbr;
-
-		nbr = pim_neighbor_find(old.source_nexthop.interface,
-					old.rpf_addr.u.prefix4);
-		if (nbr)
-			pim_jp_agg_remove_group(nbr->upstream_jp_agg, up);
-
-		/*
-		 * We have detected a case where we might need to rescan
-		 * the inherited o_list so do it.
-		 */
-		if (up->channel_oil && up->channel_oil->oil_inherited_rescan) {
-			pim_upstream_inherited_olist_decide(pim, up);
-			up->channel_oil->oil_inherited_rescan = 0;
-		}
-
-		if (up->join_state == PIM_UPSTREAM_JOINED) {
-			/*
-			 * If we come up real fast we can be here
-			 * where the mroute has not been installed
-			 * so install it.
-			 */
-			if (up->channel_oil && !up->channel_oil->installed)
-				pim_mroute_add(up->channel_oil,
-					       __PRETTY_FUNCTION__);
-
-			/*
-			 * RFC 4601: 4.5.7.  Sending (S,G) Join/Prune Messages
-			 *
-			 * Transitions from Joined State
-			 *
-			 * RPF'(S,G) changes not due to an Assert
-			 *
-			 * The upstream (S,G) state machine remains in Joined
-			 * state. Send Join(S,G) to the new upstream
-			 * neighbor, which is the new value of RPF'(S,G).
-			 * Send Prune(S,G) to the old upstream neighbor, which
-			 * is the old value of RPF'(S,G).  Set the Join
-			 * Timer (JT) to expire after t_periodic seconds.
-			 */
-			pim_jp_agg_switch_interface(&old, &up->rpf, up);
-
-			pim_upstream_join_timer_restart(up, &old);
-		} /* up->join_state == PIM_UPSTREAM_JOINED */
+	if (rpf_result == PIM_RPF_CHANGED)
+		pim_zebra_upstream_rpf_changed(pim, up, &old);
 
-		/*
-		 * FIXME can join_desired actually be changed by
-		 * pim_rpf_update() returning PIM_RPF_CHANGED ?
-		 */
-		pim_upstream_update_join_desired(pim, up);
-
-	} /* PIM_RPF_CHANGED */
 
 	if (PIM_DEBUG_PIM_NHT) {
 		zlog_debug("%s: NHT upstream %s(%s) old ifp %s new ifp %s",
@@ -379,25 +317,9 @@ static int pim_update_upstream_nh_helper
 static int pim_update_upstream_nh(struct pim_instance *pim,
 				  struct pim_nexthop_cache *pnc)
 {
-	struct listnode *node;
-	struct interface *ifp;
-
 	hash_walk(pnc->upstream_hash, pim_update_upstream_nh_helper, pim);
 
-	FOR_ALL_INTERFACES (pim->vrf, ifp)
-		if (ifp->info) {
-			struct pim_interface *pim_ifp = ifp->info;
-			struct pim_iface_upstream_switch *us;
-
-			for (ALL_LIST_ELEMENTS_RO(pim_ifp->upstream_switch_list,
-						  node, us)) {
-				struct pim_rpf rpf;
-				rpf.source_nexthop.interface = ifp;
-				rpf.rpf_addr.u.prefix4 = us->address;
-				pim_joinprune_send(&rpf, us->us);
-				pim_jp_agg_clear_group(us->us);
-			}
-		}
+	pim_zebra_update_all_interfaces(pim);
 
 	return 0;
 }
@@ -430,16 +352,21 @@ int pim_ecmp_nexthop_search(struct pim_i
 			    struct pim_nexthop *nexthop, struct prefix *src,
 			    struct prefix *grp, int neighbor_needed)
 {
-	struct pim_neighbor *nbr = NULL;
+	struct pim_neighbor *nbrs[MULTIPATH_NUM], *nbr = NULL;
+	struct interface *ifps[MULTIPATH_NUM];
 	struct nexthop *nh_node = NULL;
 	ifindex_t first_ifindex;
 	struct interface *ifp = NULL;
 	uint32_t hash_val = 0, mod_val = 0;
 	uint8_t nh_iter = 0, found = 0;
+	uint32_t i, num_nbrs = 0;
 
 	if (!pnc || !pnc->nexthop_num || !nexthop)
 		return 0;
 
+	memset(&nbrs, 0, sizeof(nbrs));
+	memset(&ifps, 0, sizeof(ifps));
+
 	// Current Nexthop is VALID, check to stay on the current path.
 	if (nexthop->interface && nexthop->interface->info
 	    && nexthop->mrib_nexthop_addr.u.prefix4.s_addr
@@ -449,7 +376,7 @@ int pim_ecmp_nexthop_search(struct pim_i
 		   metric is less than nexthop update.
 		 */
 
-		if (qpim_ecmp_rebalance_enable == 0) {
+		if (pim->ecmp_rebalance_enable == 0) {
 			uint8_t curr_route_valid = 0;
 			// Check if current nexthop is present in new updated
 			// Nexthop list.
@@ -499,16 +426,41 @@ int pim_ecmp_nexthop_search(struct pim_i
 			}
 		}
 	}
-	if (qpim_ecmp_enable) {
+
+	/*
+	 * Look up all interfaces and neighbors,
+	 * store for later usage
+	 */
+	for (nh_node = pnc->nexthop, i = 0; nh_node;
+	     nh_node = nh_node->next, i++) {
+		ifps[i] = if_lookup_by_index(nh_node->ifindex, pim->vrf_id);
+		if (ifps[i]) {
+			nbrs[i] = pim_neighbor_find(ifps[i],
+						    nh_node->gate.ipv4);
+			if (nbrs[i] || pim_if_connected_to_source(ifps[i],
+
+								  src->u.prefix4))
+				num_nbrs++;
+		}
+	}
+	if (pim->ecmp_enable) {
+		uint32_t consider = pnc->nexthop_num;
+
+		if (neighbor_needed && num_nbrs < consider)
+			consider = num_nbrs;
+
+		if (consider == 0)
+			return 0;
+
 		// PIM ECMP flag is enable then choose ECMP path.
 		hash_val = pim_compute_ecmp_hash(src, grp);
-		mod_val = hash_val % pnc->nexthop_num;
+		mod_val = hash_val % consider;
 	}
 
 	for (nh_node = pnc->nexthop; nh_node && (found == 0);
 	     nh_node = nh_node->next) {
 		first_ifindex = nh_node->ifindex;
-		ifp = if_lookup_by_index(first_ifindex, pim->vrf_id);
+		ifp = ifps[nh_iter];
 		if (!ifp) {
 			if (PIM_DEBUG_PIM_NHT) {
 				char addr_str[INET_ADDRSTRLEN];
@@ -544,7 +496,7 @@ int pim_ecmp_nexthop_search(struct pim_i
 
 		if (neighbor_needed
 		    && !pim_if_connected_to_source(ifp, src->u.prefix4)) {
-			nbr = pim_neighbor_find(ifp, nh_node->gate.ipv4);
+			nbr = nbrs[nh_iter];
 			if (!nbr && !if_is_loopback(ifp)) {
 				if (PIM_DEBUG_PIM_NHT)
 					zlog_debug(
@@ -586,7 +538,7 @@ int pim_ecmp_nexthop_search(struct pim_i
 					"%s: (%s,%s)(%s) selected nhop interface %s addr %s mod_val %u iter %d ecmp %d",
 					__PRETTY_FUNCTION__, buf2, buf3,
 					pim->vrf->name, ifp->name, buf, mod_val,
-					nh_iter, qpim_ecmp_enable);
+					nh_iter, pim->ecmp_enable);
 			}
 		}
 		nh_iter++;
@@ -657,11 +609,20 @@ int pim_parse_nexthop_update(int command
 			nexthop = nexthop_from_zapi_nexthop(&nhr.nexthops[i]);
 			switch (nexthop->type) {
 			case NEXTHOP_TYPE_IPV4:
-			case NEXTHOP_TYPE_IFINDEX:
 			case NEXTHOP_TYPE_IPV4_IFINDEX:
 			case NEXTHOP_TYPE_IPV6:
 			case NEXTHOP_TYPE_BLACKHOLE:
 				break;
+			case NEXTHOP_TYPE_IFINDEX:
+				/*
+				 * Connected route (i.e. no nexthop), use
+				 * RPF address from nexthop cache (i.e.
+				 * destination) as PIM nexthop.
+				 */
+				nexthop->type = NEXTHOP_TYPE_IPV4_IFINDEX;
+				nexthop->gate.ipv4 =
+					pnc->rpf.rpf_addr.u.prefix4;
+				break;
 			case NEXTHOP_TYPE_IPV6_IFINDEX:
 				ifp1 = if_lookup_by_index(nexthop->ifindex,
 							  pim->vrf_id);
@@ -770,22 +731,23 @@ int pim_parse_nexthop_update(int command
 }
 
 int pim_ecmp_nexthop_lookup(struct pim_instance *pim,
-			    struct pim_nexthop *nexthop, struct in_addr addr,
-			    struct prefix *src, struct prefix *grp,
-			    int neighbor_needed)
+			    struct pim_nexthop *nexthop, struct prefix *src,
+			    struct prefix *grp, int neighbor_needed)
 {
 	struct pim_zlookup_nexthop nexthop_tab[MULTIPATH_NUM];
-	struct pim_neighbor *nbr = NULL;
+	struct pim_neighbor *nbrs[MULTIPATH_NUM], *nbr = NULL;
 	int num_ifindex;
-	struct interface *ifp;
+	struct interface *ifps[MULTIPATH_NUM], *ifp;
 	int first_ifindex;
 	int found = 0;
 	uint8_t i = 0;
 	uint32_t hash_val = 0, mod_val = 0;
+	uint32_t num_nbrs = 0;
+	char addr_str[PREFIX_STRLEN];
 
 	if (PIM_DEBUG_PIM_NHT) {
-		char addr_str[INET_ADDRSTRLEN];
-		pim_inet4_dump("<addr?>", addr, addr_str, sizeof(addr_str));
+		pim_inet4_dump("<addr?>", src->u.prefix4, addr_str,
+			       sizeof(addr_str));
 		zlog_debug("%s: Looking up: %s(%s), last lookup time: %lld",
 			   __PRETTY_FUNCTION__, addr_str, pim->vrf->name,
 			   nexthop->last_lookup_time);
@@ -793,44 +755,66 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 
 	memset(nexthop_tab, 0,
 	       sizeof(struct pim_zlookup_nexthop) * MULTIPATH_NUM);
-	num_ifindex = zclient_lookup_nexthop(pim, nexthop_tab, MULTIPATH_NUM,
-					     addr, PIM_NEXTHOP_LOOKUP_MAX);
+	num_ifindex =
+		zclient_lookup_nexthop(pim, nexthop_tab, MULTIPATH_NUM,
+				       src->u.prefix4, PIM_NEXTHOP_LOOKUP_MAX);
 	if (num_ifindex < 1) {
-		if (PIM_DEBUG_PIM_NHT) {
-			char addr_str[INET_ADDRSTRLEN];
-			pim_inet4_dump("<addr?>", addr, addr_str,
-				       sizeof(addr_str));
+		if (PIM_DEBUG_PIM_NHT)
 			zlog_warn(
 				"%s: could not find nexthop ifindex for address %s(%s)",
 				__PRETTY_FUNCTION__, addr_str, pim->vrf->name);
-		}
 		return 0;
 	}
 
+	memset(&nbrs, 0, sizeof(nbrs));
+	memset(&ifps, 0, sizeof(ifps));
+
+	/*
+	 * Look up all interfaces and neighbors,
+	 * store for later usage
+	 */
+	for (i = 0; i < num_ifindex; i++) {
+		ifps[i] = if_lookup_by_index(nexthop_tab[i].ifindex,
+					     pim->vrf_id);
+		if (ifps[i]) {
+			nbrs[i] = pim_neighbor_find(
+				ifps[i], nexthop_tab[i].nexthop_addr.u.prefix4);
+			if (nbrs[i]
+			    || pim_if_connected_to_source(ifps[i],
+							  src->u.prefix4))
+				num_nbrs++;
+		}
+	}
+
 	// If PIM ECMP enable then choose ECMP path.
-	if (qpim_ecmp_enable) {
+	if (pim->ecmp_enable) {
+		uint32_t consider = num_ifindex;
+
+		if (neighbor_needed && num_nbrs < consider)
+			consider = num_nbrs;
+
+		if (consider == 0)
+			return 0;
+
 		hash_val = pim_compute_ecmp_hash(src, grp);
-		mod_val = hash_val % num_ifindex;
+		mod_val = hash_val % consider;
 		if (PIM_DEBUG_PIM_NHT_DETAIL)
 			zlog_debug("%s: hash_val %u mod_val %u",
 				   __PRETTY_FUNCTION__, hash_val, mod_val);
 	}
 
+	i = 0;
 	while (!found && (i < num_ifindex)) {
 		first_ifindex = nexthop_tab[i].ifindex;
 
-		ifp = if_lookup_by_index(first_ifindex, pim->vrf_id);
+		ifp = ifps[i];
 		if (!ifp) {
-			if (PIM_DEBUG_PIM_NHT) {
-				char addr_str[INET_ADDRSTRLEN];
-				pim_inet4_dump("<addr?>", addr, addr_str,
-					       sizeof(addr_str));
+			if (PIM_DEBUG_PIM_NHT)
 				zlog_debug(
 					"%s %s: could not find interface for ifindex %d (address %s(%s))",
 					__FILE__, __PRETTY_FUNCTION__,
 					first_ifindex, addr_str,
 					pim->vrf->name);
-			}
 			if (i == mod_val)
 				mod_val++;
 			i++;
@@ -838,24 +822,20 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 		}
 
 		if (!ifp->info) {
-			if (PIM_DEBUG_PIM_NHT) {
-				char addr_str[INET_ADDRSTRLEN];
-				pim_inet4_dump("<addr?>", addr, addr_str,
-					       sizeof(addr_str));
+			if (PIM_DEBUG_PIM_NHT)
 				zlog_debug(
 					"%s: multicast not enabled on input interface %s(%s) (ifindex=%d, RPF for source %s)",
 					__PRETTY_FUNCTION__, ifp->name,
 					pim->vrf->name, first_ifindex,
 					addr_str);
-			}
 			if (i == mod_val)
 				mod_val++;
 			i++;
 			continue;
 		}
-		if (neighbor_needed && !pim_if_connected_to_source(ifp, addr)) {
-			nbr = pim_neighbor_find(
-				ifp, nexthop_tab[i].nexthop_addr.u.prefix4);
+		if (neighbor_needed
+		    && !pim_if_connected_to_source(ifp, src->u.prefix4)) {
+			nbr = nbrs[i];
 			if (PIM_DEBUG_PIM_NHT_DETAIL)
 				zlog_debug("ifp name: %s(%s), pim nbr: %p",
 					   ifp->name, pim->vrf->name, nbr);
@@ -863,16 +843,11 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 				if (i == mod_val)
 					mod_val++;
 				i++;
-				if (PIM_DEBUG_PIM_NHT) {
-					char addr_str[INET_ADDRSTRLEN];
-					pim_inet4_dump("<addr?>", addr,
-						       addr_str,
-						       sizeof(addr_str));
+				if (PIM_DEBUG_PIM_NHT)
 					zlog_debug(
 						"%s: NBR not found on input interface %s(%s) (RPF for source %s)",
 						__PRETTY_FUNCTION__, ifp->name,
 						pim->vrf->name, addr_str);
-				}
 				continue;
 			}
 		}
@@ -880,12 +855,10 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 		if (i == mod_val) {
 			if (PIM_DEBUG_PIM_NHT) {
 				char nexthop_str[PREFIX_STRLEN];
-				char addr_str[INET_ADDRSTRLEN];
+
 				pim_addr_dump("<nexthop?>",
 					      &nexthop_tab[i].nexthop_addr,
 					      nexthop_str, sizeof(nexthop_str));
-				pim_inet4_dump("<addr?>", addr, addr_str,
-					       sizeof(addr_str));
 				zlog_debug(
 					"%s: found nhop %s for addr %s interface %s(%s) metric %d dist %d",
 					__PRETTY_FUNCTION__, nexthop_str,
@@ -893,7 +866,7 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 					nexthop_tab[i].route_metric,
 					nexthop_tab[i].protocol_distance);
 			}
-			/* update nextop data */
+			/* update nexthop data */
 			nexthop->interface = ifp;
 			nexthop->mrib_nexthop_addr =
 				nexthop_tab[i].nexthop_addr;
@@ -901,7 +874,7 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 				nexthop_tab[i].protocol_distance;
 			nexthop->mrib_route_metric =
 				nexthop_tab[i].route_metric;
-			nexthop->last_lookup = addr;
+			nexthop->last_lookup = src->u.prefix4;
 			nexthop->last_lookup_time = pim_time_monotonic_usec();
 			nexthop->nbr = nbr;
 			found = 1;
@@ -916,59 +889,36 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 }
 
 int pim_ecmp_fib_lookup_if_vif_index(struct pim_instance *pim,
-				     struct in_addr addr, struct prefix *src,
-				     struct prefix *grp)
+				     struct prefix *src, struct prefix *grp)
 {
-	struct pim_zlookup_nexthop nexthop_tab[MULTIPATH_NUM];
-	int num_ifindex;
+	struct pim_nexthop nhop;
 	int vif_index;
-	ifindex_t first_ifindex;
-	uint32_t hash_val = 0, mod_val = 0;
+	ifindex_t ifindex;
+	char addr_str[PREFIX_STRLEN];
 
-	memset(nexthop_tab, 0,
-	       sizeof(struct pim_zlookup_nexthop) * MULTIPATH_NUM);
-	num_ifindex = zclient_lookup_nexthop(pim, nexthop_tab, MULTIPATH_NUM,
-					     addr, PIM_NEXTHOP_LOOKUP_MAX);
-	if (num_ifindex < 1) {
-		if (PIM_DEBUG_PIM_NHT) {
-			char addr_str[INET_ADDRSTRLEN];
-			pim_inet4_dump("<addr?>", addr, addr_str,
-				       sizeof(addr_str));
+	if (PIM_DEBUG_PIM_NHT)
+		pim_inet4_dump("<addr?>", src->u.prefix4, addr_str,
+			       sizeof(addr_str));
+	if (!pim_ecmp_nexthop_lookup(pim, &nhop, src, grp, 0)) {
+		if (PIM_DEBUG_PIM_NHT)
 			zlog_debug(
 				"%s: could not find nexthop ifindex for address %s(%s)",
 				__PRETTY_FUNCTION__, addr_str, pim->vrf->name);
-		}
 		return -1;
 	}
 
-	// If PIM ECMP enable then choose ECMP path.
-	if (qpim_ecmp_enable) {
-		hash_val = pim_compute_ecmp_hash(src, grp);
-		mod_val = hash_val % num_ifindex;
-		if (PIM_DEBUG_PIM_NHT_DETAIL)
-			zlog_debug("%s: hash_val %u mod_val %u",
-				   __PRETTY_FUNCTION__, hash_val, mod_val);
-	}
-
-	first_ifindex = nexthop_tab[mod_val].ifindex;
-
-	if (PIM_DEBUG_PIM_NHT) {
-		char addr_str[INET_ADDRSTRLEN];
-		pim_inet4_dump("<ifaddr?>", addr, addr_str, sizeof(addr_str));
+	ifindex = nhop.interface->ifindex;
+	if (PIM_DEBUG_PIM_NHT)
 		zlog_debug(
 			"%s: found nexthop ifindex=%d (interface %s(%s)) for address %s",
-			__PRETTY_FUNCTION__, first_ifindex,
-			ifindex2ifname(first_ifindex, pim->vrf_id),
+			__PRETTY_FUNCTION__, ifindex,
+			ifindex2ifname(ifindex, pim->vrf_id),
 			pim->vrf->name, addr_str);
-	}
 
-	vif_index = pim_if_find_vifindex_by_ifindex(pim, first_ifindex);
+	vif_index = pim_if_find_vifindex_by_ifindex(pim, ifindex);
 
 	if (vif_index < 0) {
 		if (PIM_DEBUG_PIM_NHT) {
-			char addr_str[INET_ADDRSTRLEN];
-			pim_inet4_dump("<addr?>", addr, addr_str,
-				       sizeof(addr_str));
 			zlog_debug(
 				"%s: low vif_index=%d(%s) < 1 nexthop for address %s",
 				__PRETTY_FUNCTION__, vif_index, pim->vrf->name,
diff -urpN frr-frr-5.0.1/pimd/pim_nht.h frr-frr-6.0/pimd/pim_nht.h
--- frr-frr-5.0.1/pimd/pim_nht.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_nht.h	2018-10-08 14:32:57.000000000 +0200
@@ -61,13 +61,11 @@ int pim_ecmp_nexthop_search(struct pim_i
 			    struct pim_nexthop *nexthop, struct prefix *src,
 			    struct prefix *grp, int neighbor_needed);
 int pim_ecmp_nexthop_lookup(struct pim_instance *pim,
-			    struct pim_nexthop *nexthop, struct in_addr addr,
-			    struct prefix *src, struct prefix *grp,
-			    int neighbor_needed);
+			    struct pim_nexthop *nexthop, struct prefix *src,
+			    struct prefix *grp, int neighbor_needed);
 void pim_sendmsg_zebra_rnh(struct pim_instance *pim, struct zclient *zclient,
 			   struct pim_nexthop_cache *pnc, int command);
 void pim_resolve_upstream_nh(struct pim_instance *pim, struct prefix *nht_p);
 int pim_ecmp_fib_lookup_if_vif_index(struct pim_instance *pim,
-				     struct in_addr addr, struct prefix *src,
-				     struct prefix *grp);
+				     struct prefix *src, struct prefix *grp);
 #endif
diff -urpN frr-frr-5.0.1/pimd/pim_oil.c frr-frr-6.0/pimd/pim_oil.c
--- frr-frr-5.0.1/pimd/pim_oil.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_oil.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,20 +37,20 @@
 
 char *pim_channel_oil_dump(struct channel_oil *c_oil, char *buf, size_t size)
 {
+	char *out;
 	struct prefix_sg sg;
 	int i;
 
-	memset(buf, 0, size);
 	sg.src = c_oil->oil.mfcc_origin;
 	sg.grp = c_oil->oil.mfcc_mcastgrp;
-	sprintf(buf, "%s IIF: %d, OIFS: ", pim_str_sg_dump(&sg),
-		c_oil->oil.mfcc_parent);
+	snprintf(buf, size, "%s IIF: %d, OIFS: ", pim_str_sg_dump(&sg),
+		 c_oil->oil.mfcc_parent);
 
+	out = buf + strlen(buf);
 	for (i = 0; i < MAXVIFS; i++) {
 		if (c_oil->oil.mfcc_ttls[i] != 0) {
-			char buf1[10];
-			sprintf(buf1, "%d ", i);
-			strcat(buf, buf1);
+			snprintf(out, buf + size - out, "%d ", i);
+			out += strlen(out);
 		}
 	}
 
@@ -108,11 +108,6 @@ void pim_oil_init(struct pim_instance *p
 						 pim_oil_equal, hash_name);
 
 	pim->channel_oil_list = list_new();
-	if (!pim->channel_oil_list) {
-		zlog_err("%s %s: failure: channel_oil_list=list_new()",
-			 __FILE__, __PRETTY_FUNCTION__);
-		return;
-	}
 	pim->channel_oil_list->del = (void (*)(void *))pim_channel_oil_free;
 	pim->channel_oil_list->cmp =
 		(int (*)(void *, void *))pim_channel_oil_compare;
@@ -183,10 +178,6 @@ struct channel_oil *pim_channel_oil_add(
 	}
 
 	c_oil = XCALLOC(MTYPE_PIM_CHANNEL_OIL, sizeof(*c_oil));
-	if (!c_oil) {
-		zlog_err("PIM XCALLOC(%zu) failure", sizeof(*c_oil));
-		return NULL;
-	}
 
 	c_oil->oil.mfcc_mcastgrp = sg->grp;
 	c_oil->oil.mfcc_origin = sg->src;
diff -urpN frr-frr-5.0.1/pimd/pim_pim.c frr-frr-6.0/pimd/pim_pim.c
--- frr-frr-5.0.1/pimd/pim_pim.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_pim.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,6 +38,7 @@
 #include "pim_assert.h"
 #include "pim_msg.h"
 #include "pim_register.h"
+#include "pim_errors.h"
 
 static int on_pim_hello_send(struct thread *t);
 static int pim_hello_send(struct interface *ifp, uint16_t holdtime);
@@ -115,8 +116,9 @@ void pim_sock_delete(struct interface *i
 		  delete_message);
 
 	if (!ifp->info) {
-		zlog_err("%s: %s: but PIM not enabled on interface %s (!)",
-			 __PRETTY_FUNCTION__, delete_message, ifp->name);
+		flog_err(PIM_ERR_CONFIG,
+			  "%s: %s: but PIM not enabled on interface %s (!)",
+			  __PRETTY_FUNCTION__, delete_message, ifp->name);
 		return;
 	}
 
@@ -330,8 +332,9 @@ static int pim_sock_read(struct thread *
 		if (!ifp || !ifp->info) {
 			if (PIM_DEBUG_PIM_PACKETS)
 				zlog_debug(
-					"%s: Received incoming pim packet on interface not yet configured for pim",
-					__PRETTY_FUNCTION__);
+					"%s: Received incoming pim packet on interface(%s:%d) not yet configured for pim",
+					__PRETTY_FUNCTION__,
+					ifp ? ifp->name : "Unknown", ifindex);
 			goto done;
 		}
 		int fail = pim_pim_packet(ifp, buf, len);
@@ -521,7 +524,7 @@ int pim_msg_send(int fd, struct in_addr
 	socklen_t tolen;
 	unsigned char buffer[10000];
 	unsigned char *msg_start;
-	uint8_t ttl = MAXTTL;
+	uint8_t ttl;
 	struct pim_msg_header *header;
 	struct ip *ip;
 
@@ -653,7 +656,7 @@ static int pim_hello_send(struct interfa
 {
 	struct pim_interface *pim_ifp = ifp->info;
 
-	if (pim_if_is_loopback(pim_ifp->pim, ifp))
+	if (if_is_loopback_or_vrf(ifp))
 		return 0;
 
 	if (hello_send(ifp, holdtime)) {
@@ -755,7 +758,7 @@ void pim_hello_restart_triggered(struct
 	/*
 	 * No need to ever start loopback or vrf device hello's
 	 */
-	if (pim_if_is_loopback(pim_ifp->pim, ifp))
+	if (if_is_loopback_or_vrf(ifp))
 		return;
 
 	/*
diff -urpN frr-frr-5.0.1/pimd/pim_routemap.c frr-frr-6.0/pimd/pim_routemap.c
--- frr-frr-5.0.1/pimd/pim_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,34 +26,18 @@
 
 #include "pimd.h"
 
-
-static void pim_route_map_mark_update(const char *rmap_name)
-{
-	// placeholder
-	return;
-}
-
 static void pim_route_map_add(const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 0) == 0)
-		pim_route_map_mark_update(rmap_name);
-
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
 }
 
 static void pim_route_map_delete(const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 1) == 0)
-		pim_route_map_mark_update(rmap_name);
-
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_DELETED);
 }
 
 static void pim_route_map_event(route_map_event_t event, const char *rmap_name)
 {
-	if (route_map_mark_updated(rmap_name, 0) == 0)
-		pim_route_map_mark_update(rmap_name);
-
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
 }
 
@@ -68,8 +52,5 @@ void pim_route_map_init(void)
 
 void pim_route_map_terminate(void)
 {
-	route_map_add_hook(NULL);
-	route_map_delete_hook(NULL);
-	route_map_event_hook(NULL);
 	route_map_finish();
 }
diff -urpN frr-frr-5.0.1/pimd/pim_rp.c frr-frr-6.0/pimd/pim_rp.c
--- frr-frr-5.0.1/pimd/pim_rp.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_rp.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "plist.h"
 #include "nexthop.h"
 #include "table.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_vty.h"
@@ -56,12 +57,17 @@ void pim_rp_list_hash_clean(void *data)
 	hash_clean(pnc->upstream_hash, NULL);
 	hash_free(pnc->upstream_hash);
 	pnc->upstream_hash = NULL;
+	if (pnc->nexthop)
+		nexthops_free(pnc->nexthop);
 
 	XFREE(MTYPE_PIM_NEXTHOP_CACHE, pnc);
 }
 
 static void pim_rp_info_free(struct rp_info *rp_info)
 {
+	if (rp_info->plist)
+		XFREE(MTYPE_PIM_FILTER_NAME, rp_info->plist);
+
 	XFREE(MTYPE_PIM_RP, rp_info);
 }
 
@@ -99,31 +105,16 @@ void pim_rp_init(struct pim_instance *pi
 	struct route_node *rn;
 
 	pim->rp_list = list_new();
-	if (!pim->rp_list) {
-		zlog_err("Unable to alloc rp_list");
-		return;
-	}
 	pim->rp_list->del = (void (*)(void *))pim_rp_info_free;
 	pim->rp_list->cmp = pim_rp_list_cmp;
 
 	pim->rp_table = route_table_init();
-	if (!pim->rp_table) {
-		zlog_err("Unable to alloc rp_table");
-		list_delete_and_null(&pim->rp_list);
-		return;
-	}
 
 	rp_info = XCALLOC(MTYPE_PIM_RP, sizeof(*rp_info));
 
-	if (!rp_info) {
-		zlog_err("Unable to alloc rp_info");
-		route_table_finish(pim->rp_table);
-		list_delete_and_null(&pim->rp_list);
-		return;
-	}
-
 	if (!str2prefix("224.0.0.0/4", &rp_info->group)) {
-		zlog_err("Unable to convert 224.0.0.0/4 to prefix");
+		flog_err(LIB_ERR_DEVELOPMENT,
+			  "Unable to convert 224.0.0.0/4 to prefix");
 		list_delete_and_null(&pim->rp_list);
 		route_table_finish(pim->rp_table);
 		XFREE(MTYPE_PIM_RP, rp_info);
@@ -137,14 +128,6 @@ void pim_rp_init(struct pim_instance *pi
 	listnode_add(pim->rp_list, rp_info);
 
 	rn = route_node_get(pim->rp_table, &rp_info->group);
-	if (!rn) {
-		zlog_err("Failure to get route node for pim->rp_table");
-		list_delete_and_null(&pim->rp_list);
-		route_table_finish(pim->rp_table);
-		XFREE(MTYPE_PIM_RP, rp_info);
-		return;
-	}
-
 	rn->info = rp_info;
 	if (PIM_DEBUG_TRACE)
 		zlog_debug(
@@ -201,7 +184,7 @@ static int pim_rp_prefix_list_used(struc
  */
 static struct rp_info *pim_rp_find_exact(struct pim_instance *pim,
 					 struct in_addr rp,
-					 struct prefix *group)
+					 const struct prefix *group)
 {
 	struct listnode *node;
 	struct rp_info *rp_info;
@@ -219,13 +202,13 @@ static struct rp_info *pim_rp_find_exact
  * Given a group, return the rp_info for that group
  */
 static struct rp_info *pim_rp_find_match_group(struct pim_instance *pim,
-					       struct prefix *group)
+					       const struct prefix *group)
 {
 	struct listnode *node;
 	struct rp_info *best = NULL;
 	struct rp_info *rp_info;
 	struct prefix_list *plist;
-	struct prefix *p, *bp;
+	const struct prefix *p, *bp;
 	struct route_node *rn;
 
 	bp = NULL;
@@ -252,7 +235,8 @@ static struct rp_info *pim_rp_find_match
 
 	rn = route_node_match(pim->rp_table, group);
 	if (!rn) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_DEVELOPMENT,
 			"%s: BUG We should have found default group information\n",
 			__PRETTY_FUNCTION__);
 		return best;
@@ -365,8 +349,6 @@ int pim_rp_new(struct pim_instance *pim,
 	struct route_node *rn;
 
 	rp_info = XCALLOC(MTYPE_PIM_RP, sizeof(*rp_info));
-	if (!rp_info)
-		return PIM_MALLOC_FAIL;
 
 	if (group_range == NULL)
 		result = str2prefix("224.0.0.0/4", &rp_info->group);
@@ -486,10 +468,9 @@ int pim_rp_new(struct pim_instance *pim,
 					    &rp_all->group, 1))
 					return PIM_RP_NO_PATH;
 			} else {
-				if (pim_nexthop_lookup(
+				if (!pim_ecmp_nexthop_lookup(
 					    pim, &rp_all->rp.source_nexthop,
-					    rp_all->rp.rpf_addr.u.prefix4, 1)
-				    != 0)
+					    &nht_p, &rp_all->group, 1))
 					return PIM_RP_NO_PATH;
 			}
 			pim_rp_check_interfaces(pim, rp_all);
@@ -534,12 +515,6 @@ int pim_rp_new(struct pim_instance *pim,
 
 	listnode_add_sort(pim->rp_list, rp_info);
 	rn = route_node_get(pim->rp_table, &rp_info->group);
-	if (!rn) {
-		char buf[PREFIX_STRLEN];
-		zlog_err("Failure to get route node for pim->rp_table: %s",
-			 prefix2str(&rp_info->group, buf, sizeof(buf)));
-		return PIM_MALLOC_FAIL;
-	}
 	rn->info = rp_info;
 
 	if (PIM_DEBUG_TRACE) {
@@ -571,9 +546,8 @@ int pim_rp_new(struct pim_instance *pim,
 					     &nht_p, &rp_info->group, 1))
 			return PIM_RP_NO_PATH;
 	} else {
-		if (pim_nexthop_lookup(pim, &rp_info->rp.source_nexthop,
-				       rp_info->rp.rpf_addr.u.prefix4, 1)
-		    != 0)
+		if (!pim_ecmp_nexthop_lookup(pim, &rp_info->rp.source_nexthop,
+					     &nht_p, &rp_info->group, 1))
 			return PIM_RP_NO_PATH;
 	}
 
@@ -617,7 +591,6 @@ int pim_rp_del(struct pim_instance *pim,
 
 	if (rp_info->plist) {
 		XFREE(MTYPE_PIM_FILTER_NAME, rp_info->plist);
-		rp_info->plist = NULL;
 		was_plist = true;
 	}
 
@@ -651,7 +624,9 @@ int pim_rp_del(struct pim_instance *pim,
 		rn = route_node_get(pim->rp_table, &rp_info->group);
 		if (rn) {
 			if (rn->info != rp_info)
-				zlog_err("WTF matey");
+				flog_err(
+					LIB_ERR_DEVELOPMENT,
+					"Expected rn->info to be equal to rp_info");
 
 			if (PIM_DEBUG_TRACE) {
 				char buf[PREFIX_STRLEN];
@@ -702,9 +677,9 @@ void pim_rp_setup(struct pim_instance *p
 					"%s: NHT Local Nexthop not found for RP %s ",
 					__PRETTY_FUNCTION__, buf);
 			}
-			if (!pim_nexthop_lookup(
-				    pim, &rp_info->rp.source_nexthop,
-				    rp_info->rp.rpf_addr.u.prefix4, 1))
+			if (!pim_ecmp_nexthop_lookup(pim,
+						     &rp_info->rp.source_nexthop,
+						      &nht_p, &rp_info->group, 1))
 				if (PIM_DEBUG_PIM_NHT_RP)
 					zlog_debug(
 						"Unable to lookup nexthop for rp specified");
@@ -869,8 +844,9 @@ struct pim_rpf *pim_rp_g(struct pim_inst
 					__PRETTY_FUNCTION__, buf, buf1);
 			}
 			pim_rpf_set_refresh_time(pim);
-			pim_nexthop_lookup(pim, &rp_info->rp.source_nexthop,
-					   rp_info->rp.rpf_addr.u.prefix4, 1);
+			(void)pim_ecmp_nexthop_lookup(
+				pim, &rp_info->rp.source_nexthop, &nht_p,
+				&rp_info->group, 1);
 		}
 		return (&rp_info->rp);
 	}
diff -urpN frr-frr-5.0.1/pimd/pim_rpf.c frr-frr-6.0/pimd/pim_rpf.c
--- frr-frr-5.0.1/pimd/pim_rpf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_rpf.c	2018-10-08 14:32:57.000000000 +0200
@@ -77,7 +77,7 @@ int pim_nexthop_lookup(struct pim_instan
 			pim_addr_dump("<nexthop?>", &nexthop->mrib_nexthop_addr,
 				      nexthop_str, sizeof(nexthop_str));
 			zlog_debug(
-				"%s: Using last lookup for %s at %lld, %" PRId64 " addr%s",
+				"%s: Using last lookup for %s at %lld, %" PRId64 " addr %s",
 				__PRETTY_FUNCTION__, addr_str,
 				nexthop->last_lookup_time,
 				pim->last_route_change_time, nexthop_str);
@@ -170,7 +170,7 @@ int pim_nexthop_lookup(struct pim_instan
 				nexthop_tab[i].route_metric,
 				nexthop_tab[i].protocol_distance);
 		}
-		/* update nextop data */
+		/* update nexthop data */
 		nexthop->interface = ifp;
 		nexthop->mrib_nexthop_addr = nexthop_tab[i].nexthop_addr;
 		nexthop->mrib_metric_preference =
@@ -203,6 +203,7 @@ enum pim_rpf_result pim_rpf_update(struc
 	struct prefix nht_p;
 	struct pim_nexthop_cache pnc;
 	struct prefix src, grp;
+	bool neigh_needed = true;
 
 	saved.source_nexthop = rpf->source_nexthop;
 	saved.rpf_addr = rpf->rpf_addr;
@@ -226,23 +227,20 @@ enum pim_rpf_result pim_rpf_update(struc
 	grp.prefixlen = IPV4_MAX_BITLEN;
 	grp.u.prefix4 = up->sg.grp;
 	memset(&pnc, 0, sizeof(struct pim_nexthop_cache));
+
+	if ((up->sg.src.s_addr == INADDR_ANY && I_am_RP(pim, up->sg.grp)) ||
+	    PIM_UPSTREAM_FLAG_TEST_FHR(up->flags))
+		neigh_needed = FALSE;
 	if (pim_find_or_track_nexthop(pim, &nht_p, up, NULL, &pnc)) {
 		if (pnc.nexthop_num) {
-			if (!pim_ecmp_nexthop_search(
-				    pim, &pnc, &up->rpf.source_nexthop, &src,
-				    &grp,
-				    !PIM_UPSTREAM_FLAG_TEST_FHR(up->flags)
-					    && !PIM_UPSTREAM_FLAG_TEST_SRC_IGMP(
-						       up->flags)))
+			if (!pim_ecmp_nexthop_search(pim, &pnc,
+						     &up->rpf.source_nexthop,
+						     &src, &grp, neigh_needed))
 				return PIM_RPF_FAILURE;
 		}
 	} else {
-		if (!pim_ecmp_nexthop_lookup(
-			    pim, &rpf->source_nexthop, up->upstream_addr, &src,
-			    &grp,
-			    !PIM_UPSTREAM_FLAG_TEST_FHR(up->flags)
-				    && !PIM_UPSTREAM_FLAG_TEST_SRC_IGMP(
-					       up->flags)))
+		if (!pim_ecmp_nexthop_lookup(pim, &rpf->source_nexthop, &src,
+					     &grp, neigh_needed))
 			return PIM_RPF_FAILURE;
 	}
 
diff -urpN frr-frr-5.0.1/pimd/pim_sock.c frr-frr-6.0/pimd/pim_sock.c
--- frr-frr-5.0.1/pimd/pim_sock.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_sock.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,12 +33,12 @@
 #include "if.h"
 #include "vrf.h"
 #include "sockopt.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_mroute.h"
 #include "pim_sock.h"
 #include "pim_str.h"
-#include "pim_igmp_join.h"
 
 /* GLOBAL VARS */
 
@@ -46,15 +46,11 @@ int pim_socket_raw(int protocol)
 {
 	int fd;
 
-	if (pimd_privs.change(ZPRIVS_RAISE))
-		zlog_err("pim_sockek_raw: could not raise privs, %s",
-			 safe_strerror(errno));
-
-	fd = socket(AF_INET, SOCK_RAW, protocol);
-
-	if (pimd_privs.change(ZPRIVS_LOWER))
-		zlog_err("pim_socket_raw: could not lower privs, %s",
-			 safe_strerror(errno));
+	frr_elevate_privs(&pimd_privs) {
+
+		fd = socket(AF_INET, SOCK_RAW, protocol);
+
+	}
 
 	if (fd < 0) {
 		zlog_warn("Could not create raw socket: errno=%d: %s", errno,
@@ -69,17 +65,13 @@ void pim_socket_ip_hdr(int fd)
 {
 	const int on = 1;
 
-	if (pimd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __PRETTY_FUNCTION__,
-			 safe_strerror(errno));
-
-	if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)))
-		zlog_err("%s: Could not turn on IP_HDRINCL option: %s",
-			 __PRETTY_FUNCTION__, safe_strerror(errno));
-
-	if (pimd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __PRETTY_FUNCTION__,
-			 safe_strerror(errno));
+	frr_elevate_privs(&pimd_privs) {
+
+		if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)))
+			zlog_err("%s: Could not turn on IP_HDRINCL option: %s",
+				 __PRETTY_FUNCTION__, safe_strerror(errno));
+
+	}
 }
 
 /*
@@ -91,16 +83,12 @@ int pim_socket_bind(int fd, struct inter
 	int ret = 0;
 #ifdef SO_BINDTODEVICE
 
-	if (pimd_privs.change(ZPRIVS_RAISE))
-		zlog_err("%s: could not raise privs, %s", __PRETTY_FUNCTION__,
-			 safe_strerror(errno));
-
-	ret = setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, ifp->name,
-			 strlen(ifp->name));
-
-	if (pimd_privs.change(ZPRIVS_LOWER))
-		zlog_err("%s: could not lower privs, %s", __PRETTY_FUNCTION__,
-			 safe_strerror(errno));
+	frr_elevate_privs(&pimd_privs) {
+
+		ret = setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, ifp->name,
+				 strlen(ifp->name));
+
+	}
 
 #endif
 	return ret;
@@ -162,7 +150,8 @@ int pim_socket_mcast(int protocol, struc
 				fd, errno, safe_strerror(errno));
 		}
 #else
-		zlog_err(
+		flog_err(
+			LIB_ERR_DEVELOPMENT,
 			"%s %s: Missing IP_PKTINFO and IP_RECVDSTADDR: unable to get dst addr from recvmsg()",
 			__FILE__, __PRETTY_FUNCTION__);
 		close(fd);
@@ -299,7 +288,8 @@ int pim_socket_join(int fd, struct in_ad
 			       sizeof(ifaddr_str)))
 			sprintf(ifaddr_str, "<ifaddr?>");
 
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"Failure socket joining fd=%d group %s on interface address %s: errno=%d: %s",
 			fd, group_str, ifaddr_str, errno, safe_strerror(errno));
 		return ret;
@@ -322,26 +312,6 @@ int pim_socket_join(int fd, struct in_ad
 	return ret;
 }
 
-int pim_socket_join_source(int fd, ifindex_t ifindex, struct in_addr group_addr,
-			   struct in_addr source_addr, const char *ifname)
-{
-	if (pim_igmp_join_source(fd, ifindex, group_addr, source_addr)) {
-		char group_str[INET_ADDRSTRLEN];
-		char source_str[INET_ADDRSTRLEN];
-		pim_inet4_dump("<grp?>", group_addr, group_str,
-			       sizeof(group_str));
-		pim_inet4_dump("<src?>", source_addr, source_str,
-			       sizeof(source_str));
-		zlog_warn(
-			"%s: setsockopt(fd=%d) failure for IGMP group %s source %s ifindex %d on interface %s: errno=%d: %s",
-			__PRETTY_FUNCTION__, fd, group_str, source_str, ifindex,
-			ifname, errno, safe_strerror(errno));
-		return -1;
-	}
-
-	return 0;
-}
-
 int pim_socket_recvfromto(int fd, uint8_t *buf, size_t len,
 			  struct sockaddr_in *from, socklen_t *fromlen,
 			  struct sockaddr_in *to, socklen_t *tolen,
diff -urpN frr-frr-5.0.1/pimd/pim_sock.h frr-frr-6.0/pimd/pim_sock.h
--- frr-frr-5.0.1/pimd/pim_sock.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_sock.h	2018-10-08 14:32:57.000000000 +0200
@@ -42,8 +42,6 @@ int pim_socket_mcast(int protocol, struc
 		     uint8_t loop);
 int pim_socket_join(int fd, struct in_addr group, struct in_addr ifaddr,
 		    ifindex_t ifindex);
-int pim_socket_join_source(int fd, ifindex_t ifindex, struct in_addr group_addr,
-			   struct in_addr source_addr, const char *ifname);
 int pim_socket_recvfromto(int fd, uint8_t *buf, size_t len,
 			  struct sockaddr_in *from, socklen_t *fromlen,
 			  struct sockaddr_in *to, socklen_t *tolen,
diff -urpN frr-frr-5.0.1/pimd/pim_ssm.c frr-frr-6.0/pimd/pim_ssm.c
--- frr-frr-5.0.1/pimd/pim_ssm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_ssm.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include <lib/vty.h>
 #include <lib/vrf.h>
 #include <lib/plist.h>
+#include <lib/lib_errors.h>
 
 #include "pimd.h"
 #include "pim_ssm.h"
@@ -72,8 +73,9 @@ static int pim_is_grp_standard_ssm(struc
 
 	if (first) {
 		if (!str2prefix(PIM_SSM_STANDARD_RANGE, &group_ssm))
-			zlog_err("%s: Failure to Read Group Address: %s",
-				 __PRETTY_FUNCTION__, PIM_SSM_STANDARD_RANGE);
+			flog_err(LIB_ERR_DEVELOPMENT,
+				  "%s: Failure to Read Group Address: %s",
+				  __PRETTY_FUNCTION__, PIM_SSM_STANDARD_RANGE);
 
 		first = 0;
 	}
@@ -146,6 +148,11 @@ void *pim_ssm_init(void)
 
 void pim_ssm_terminate(struct pim_ssm *ssm)
 {
-	if (ssm && ssm->plist_name)
+	if (!ssm)
+		return;
+
+	if (ssm->plist_name)
 		XFREE(MTYPE_PIM_FILTER_NAME, ssm->plist_name);
+
+	XFREE(MTYPE_PIM_SSM_INFO, ssm);
 }
diff -urpN frr-frr-5.0.1/pimd/pim_ssmpingd.c frr-frr-6.0/pimd/pim_ssmpingd.c
--- frr-frr-5.0.1/pimd/pim_ssmpingd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_ssmpingd.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include "memory.h"
 #include "sockopt.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_ssmpingd.h"
@@ -82,8 +83,9 @@ static int ssmpingd_socket(struct in_add
 
 	fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (fd < 0) {
-		zlog_err("%s: could not create socket: errno=%d: %s",
-			 __PRETTY_FUNCTION__, errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: could not create socket: errno=%d: %s",
+			     __PRETTY_FUNCTION__, errno, safe_strerror(errno));
 		return -1;
 	}
 
@@ -124,7 +126,8 @@ static int ssmpingd_socket(struct in_add
 				safe_strerror(errno));
 		}
 #else
-		zlog_err(
+		flog_err(
+			LIB_ERR_DEVELOPMENT,
 			"%s %s: missing IP_PKTINFO and IP_RECVDSTADDR: unable to get dst addr from recvmsg()",
 			__FILE__, __PRETTY_FUNCTION__);
 		close(fd);
@@ -348,12 +351,6 @@ static struct ssmpingd_sock *ssmpingd_ne
 
 	if (!pim->ssmpingd_list) {
 		pim->ssmpingd_list = list_new();
-		if (!pim->ssmpingd_list) {
-			zlog_err(
-				"%s %s: failure: qpim_ssmpingd_list=list_new()",
-				__FILE__, __PRETTY_FUNCTION__);
-			return 0;
-		}
 		pim->ssmpingd_list->del = (void (*)(void *))ssmpingd_free;
 	}
 
@@ -369,15 +366,6 @@ static struct ssmpingd_sock *ssmpingd_ne
 	}
 
 	ss = XCALLOC(MTYPE_PIM_SSMPINGD, sizeof(*ss));
-	if (!ss) {
-		char source_str[INET_ADDRSTRLEN];
-		pim_inet4_dump("<src?>", source_addr, source_str,
-			       sizeof(source_str));
-		zlog_err("%s: XCALLOC(%zu) failure for ssmpingd source %s",
-			 __PRETTY_FUNCTION__, sizeof(*ss), source_str);
-		close(sock_fd);
-		return 0;
-	}
 
 	ss->pim = pim;
 	ss->sock_fd = sock_fd;
diff -urpN frr-frr-5.0.1/pimd/pim_static.c frr-frr-6.0/pimd/pim_static.c
--- frr-frr-5.0.1/pimd/pim_static.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_static.c	2018-10-08 14:32:57.000000000 +0200
@@ -39,14 +39,7 @@ void pim_static_route_free(struct static
 
 static struct static_route *static_route_alloc()
 {
-	struct static_route *s_route;
-
-	s_route = XCALLOC(MTYPE_PIM_STATIC_ROUTE, sizeof(*s_route));
-	if (!s_route) {
-		zlog_err("PIM XCALLOC(%zu) failure", sizeof(*s_route));
-		return 0;
-	}
-	return s_route;
+	return XCALLOC(MTYPE_PIM_STATIC_ROUTE, sizeof(struct static_route));
 }
 
 static struct static_route *static_route_new(unsigned int iif, unsigned int oif,
@@ -55,9 +48,6 @@ static struct static_route *static_route
 {
 	struct static_route *s_route;
 	s_route = static_route_alloc();
-	if (!s_route) {
-		return 0;
-	}
 
 	s_route->group = group;
 	s_route->source = source;
diff -urpN frr-frr-5.0.1/pimd/pim_time.c frr-frr-6.0/pimd/pim_time.c
--- frr-frr-5.0.1/pimd/pim_time.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_time.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 
 #include "log.h"
 #include "thread.h"
+#include "lib_errors.h"
 
 #include "pim_time.h"
 
@@ -34,8 +35,9 @@ static int gettime_monotonic(struct time
 
 	result = gettimeofday(tv, 0);
 	if (result) {
-		zlog_err("%s: gettimeofday() failure: errno=%d: %s",
-			 __PRETTY_FUNCTION__, errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: gettimeofday() failure: errno=%d: %s",
+			     __PRETTY_FUNCTION__, errno, safe_strerror(errno));
 	}
 
 	return result;
@@ -50,8 +52,9 @@ int64_t pim_time_monotonic_sec()
 	struct timeval now_tv;
 
 	if (gettime_monotonic(&now_tv)) {
-		zlog_err("%s: gettime_monotonic() failure: errno=%d: %s",
-			 __PRETTY_FUNCTION__, errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: gettime_monotonic() failure: errno=%d: %s",
+			     __PRETTY_FUNCTION__, errno, safe_strerror(errno));
 		return -1;
 	}
 
@@ -68,8 +71,9 @@ int64_t pim_time_monotonic_dsec()
 	int64_t now_dsec;
 
 	if (gettime_monotonic(&now_tv)) {
-		zlog_err("%s: gettime_monotonic() failure: errno=%d: %s",
-			 __PRETTY_FUNCTION__, errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: gettime_monotonic() failure: errno=%d: %s",
+			     __PRETTY_FUNCTION__, errno, safe_strerror(errno));
 		return -1;
 	}
 
@@ -85,8 +89,9 @@ int64_t pim_time_monotonic_usec(void)
 	int64_t now_dsec;
 
 	if (gettime_monotonic(&now_tv)) {
-		zlog_err("%s: gettime_monotonic() failure: errno=%d: %s",
-			 __PRETTY_FUNCTION__, errno, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s: gettime_monotonic() failure: errno=%d: %s",
+			     __PRETTY_FUNCTION__, errno, safe_strerror(errno));
 		return -1;
 	}
 
diff -urpN frr-frr-5.0.1/pimd/pim_tlv.c frr-frr-6.0/pimd/pim_tlv.c
--- frr-frr-5.0.1/pimd/pim_tlv.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_tlv.c	2018-10-08 14:32:57.000000000 +0200
@@ -757,12 +757,6 @@ int pim_tlv_parse_addr_list(const char *
 		 */
 		if (!*hello_option_addr_list) {
 			*hello_option_addr_list = list_new();
-			if (!*hello_option_addr_list) {
-				zlog_err(
-					"%s %s: failure: hello_option_addr_list=list_new()",
-					__FILE__, __PRETTY_FUNCTION__);
-				return -2;
-			}
 			(*hello_option_addr_list)->del =
 				(void (*)(void *))prefix_free;
 		}
@@ -773,12 +767,6 @@ int pim_tlv_parse_addr_list(const char *
 		{
 			struct prefix *p;
 			p = prefix_new();
-			if (!p) {
-				zlog_err("%s %s: failure: prefix_new()",
-					 __FILE__, __PRETTY_FUNCTION__);
-				FREE_ADDR_LIST(*hello_option_addr_list);
-				return -3;
-			}
 			prefix_copy(p, &tmp);
 			listnode_add(*hello_option_addr_list, p);
 		}
diff -urpN frr-frr-5.0.1/pimd/pim_upstream.c frr-frr-6.0/pimd/pim_upstream.c
--- frr-frr-5.0.1/pimd/pim_upstream.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_upstream.c	2018-10-08 14:32:57.000000000 +0200
@@ -140,12 +140,6 @@ static struct pim_upstream *pim_upstream
 	return NULL;
 }
 
-void pim_upstream_free(struct pim_upstream *up)
-{
-	XFREE(MTYPE_PIM_UPSTREAM, up);
-	up = NULL;
-}
-
 static void upstream_channel_oil_detach(struct pim_upstream *up)
 {
 	if (up->channel_oil) {
@@ -161,6 +155,8 @@ static void upstream_channel_oil_detach(
 struct pim_upstream *pim_upstream_del(struct pim_instance *pim,
 				      struct pim_upstream *up, const char *name)
 {
+	struct listnode *node, *nnode;
+	struct pim_ifchannel *ch;
 	bool notify_msdp = false;
 	struct prefix nht_p;
 
@@ -171,6 +167,8 @@ struct pim_upstream *pim_upstream_del(st
 			up->ref_count, up->flags,
 			up->channel_oil->oil_ref_count);
 
+	 assert(up->ref_count > 0);
+
 	--up->ref_count;
 
 	if (up->ref_count >= 1)
@@ -196,24 +194,22 @@ struct pim_upstream *pim_upstream_del(st
 	up->rpf.source_nexthop.interface = NULL;
 
 	if (up->sg.src.s_addr != INADDR_ANY) {
-		wheel_remove_item(pim->upstream_sg_wheel, up);
+		if (pim->upstream_sg_wheel)
+			wheel_remove_item(pim->upstream_sg_wheel, up);
 		notify_msdp = true;
 	}
 
-	pim_upstream_remove_children(pim, up);
-	if (up->sources)
-		list_delete_and_null(&up->sources);
-
 	pim_mroute_del(up->channel_oil, __PRETTY_FUNCTION__);
 	upstream_channel_oil_detach(up);
 
+	for (ALL_LIST_ELEMENTS(up->ifchannels, node, nnode, ch))
+		pim_ifchannel_delete(ch);
 	list_delete_and_null(&up->ifchannels);
 
-	/*
-	  notice that listnode_delete() can't be moved
-	  into pim_upstream_free() because the later is
-	  called by list_delete_all_node()
-	*/
+	pim_upstream_remove_children(pim, up);
+	if (up->sources)
+		list_delete_and_null(&up->sources);
+
 	if (up->parent && up->parent->sources)
 		listnode_delete(up->parent->sources, up);
 	up->parent = NULL;
@@ -237,7 +233,7 @@ struct pim_upstream *pim_upstream_del(st
 	}
 	pim_delete_tracked_nexthop(pim, &nht_p, up, NULL);
 
-	pim_upstream_free(up);
+	XFREE(MTYPE_PIM_UPSTREAM, up);
 
 	return NULL;
 }
@@ -610,11 +606,6 @@ static struct pim_upstream *pim_upstream
 	struct pim_upstream *up;
 
 	up = XCALLOC(MTYPE_PIM_UPSTREAM, sizeof(*up));
-	if (!up) {
-		zlog_err("%s: PIM XCALLOC(%zu) failure", __PRETTY_FUNCTION__,
-			 sizeof(*up));
-		return NULL;
-	}
 
 	up->sg = *sg;
 	pim_str_sg_set(sg, up->sg_str);
@@ -1545,12 +1536,23 @@ unsigned int pim_upstream_hash_key(void
 
 void pim_upstream_terminate(struct pim_instance *pim)
 {
-	if (pim->upstream_list)
+	struct listnode *node, *nnode;
+	struct pim_upstream *up;
+
+	if (pim->upstream_list) {
+		for (ALL_LIST_ELEMENTS(pim->upstream_list, node, nnode, up))
+			pim_upstream_del(pim, up, __PRETTY_FUNCTION__);
+
 		list_delete_and_null(&pim->upstream_list);
+	}
 
 	if (pim->upstream_hash)
 		hash_free(pim->upstream_hash);
 	pim->upstream_hash = NULL;
+
+	if (pim->upstream_sg_wheel)
+		wheel_delete(pim->upstream_sg_wheel);
+	pim->upstream_sg_wheel = NULL;
 }
 
 int pim_upstream_equal(const void *arg1, const void *arg2)
@@ -1773,6 +1775,5 @@ void pim_upstream_init(struct pim_instan
 					      pim_upstream_equal, hash_name);
 
 	pim->upstream_list = list_new();
-	pim->upstream_list->del = (void (*)(void *))pim_upstream_free;
 	pim->upstream_list->cmp = pim_upstream_compare;
 }
diff -urpN frr-frr-5.0.1/pimd/pim_upstream.h frr-frr-6.0/pimd/pim_upstream.h
--- frr-frr-5.0.1/pimd/pim_upstream.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_upstream.h	2018-10-08 14:32:57.000000000 +0200
@@ -137,7 +137,6 @@ struct pim_upstream {
 	int64_t state_transition; /* Record current state uptime */
 };
 
-void pim_upstream_free(struct pim_upstream *up);
 struct pim_upstream *pim_upstream_find(struct pim_instance *pim,
 				       struct prefix_sg *sg);
 struct pim_upstream *pim_upstream_find_or_add(struct prefix_sg *sg,
diff -urpN frr-frr-5.0.1/pimd/pim_vty.c frr-frr-6.0/pimd/pim_vty.c
--- frr-frr-5.0.1/pimd/pim_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -214,10 +214,10 @@ int pim_global_config_write_worker(struc
 				spaces);
 		++writes;
 	}
-	if (qpim_ecmp_rebalance_enable) {
+	if (pim->ecmp_rebalance_enable) {
 		vty_out(vty, "%sip pim ecmp rebalance\n", spaces);
 		++writes;
-	} else if (qpim_ecmp_enable) {
+	} else if (pim->ecmp_enable) {
 		vty_out(vty, "%sip pim ecmp\n", spaces);
 		++writes;
 	}
@@ -258,6 +258,11 @@ int pim_interface_config_write(struct vt
 					  ifp->name, vrf->name);
 			++writes;
 
+			if (ifp->desc) {
+				vty_out(vty, " description %s\n", ifp->desc);
+				++writes;
+			}
+
 			if (ifp->info) {
 				struct pim_interface *pim_ifp = ifp->info;
 
@@ -313,15 +318,6 @@ int pim_interface_config_write(struct vt
 					++writes;
 				}
 
-				/* IF ip igmp query-interval */
-				if (pim_ifp->igmp_default_query_interval
-				    != IGMP_GENERAL_QUERY_INTERVAL) {
-					vty_out(vty,
-						" ip igmp query-interval %d\n",
-						pim_ifp->igmp_default_query_interval);
-					++writes;
-				}
-
 				/* IF ip igmp query-max-response-time */
 				if (pim_ifp->igmp_query_max_response_time_dsec
 				    != IGMP_QUERY_MAX_RESPONSE_TIME_DSEC) {
@@ -331,6 +327,15 @@ int pim_interface_config_write(struct vt
 					++writes;
 				}
 
+				/* IF ip igmp query-interval */
+				if (pim_ifp->igmp_default_query_interval
+				    != IGMP_GENERAL_QUERY_INTERVAL) {
+					vty_out(vty,
+						" ip igmp query-interval %d\n",
+						pim_ifp->igmp_default_query_interval);
+					++writes;
+				}
+
 				/* IF ip igmp join */
 				if (pim_ifp->igmp_join_list) {
 					struct listnode *node;
diff -urpN frr-frr-5.0.1/pimd/pim_zebra.c frr-frr-6.0/pimd/pim_zebra.c
--- frr-frr-5.0.1/pimd/pim_zebra.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -69,6 +69,7 @@ static int pim_zebra_if_add(int command,
 			    zebra_size_t length, vrf_id_t vrf_id)
 {
 	struct interface *ifp;
+	struct pim_instance *pim;
 
 	/*
 	  zebra api adds/dels interfaces using the same call
@@ -78,6 +79,7 @@ static int pim_zebra_if_add(int command,
 	if (!ifp)
 		return 0;
 
+	pim = pim_get_pim_instance(vrf_id);
 	if (PIM_DEBUG_ZEBRA) {
 		zlog_debug(
 			"%s: %s index %d(%u) flags %ld metric %d mtu %d operative %d",
@@ -86,8 +88,19 @@ static int pim_zebra_if_add(int command,
 			if_is_operative(ifp));
 	}
 
-	if (if_is_operative(ifp))
+	if (if_is_operative(ifp)) {
+		struct pim_interface *pim_ifp;
+
+		pim_ifp = ifp->info;
+		/*
+		 * If we have a pim_ifp already and this is an if_add
+		 * that means that we probably have a vrf move event
+		 * If that is the case, set the proper vrfness.
+		 */
+		if (pim_ifp)
+			pim_ifp->pim = pim;
 		pim_if_addr_add_all(ifp);
+	}
 
 	/*
 	 * If we are a vrf device that is up, open up the pim_socket for
@@ -99,7 +112,7 @@ static int pim_zebra_if_add(int command,
 		struct pim_interface *pim_ifp;
 
 		if (!ifp->info) {
-			pim_ifp = pim_if_new(ifp, 0, 0);
+			pim_ifp = pim_if_new(ifp, 0, 0, false);
 			ifp->info = pim_ifp;
 		}
 
@@ -145,6 +158,7 @@ static int pim_zebra_if_del(int command,
 static int pim_zebra_if_state_up(int command, struct zclient *zclient,
 				 zebra_size_t length, vrf_id_t vrf_id)
 {
+	struct pim_instance *pim;
 	struct interface *ifp;
 	uint32_t table_id;
 
@@ -164,7 +178,19 @@ static int pim_zebra_if_state_up(int com
 			if_is_operative(ifp));
 	}
 
+	pim = pim_get_pim_instance(vrf_id);
 	if (if_is_operative(ifp)) {
+		struct pim_interface *pim_ifp;
+
+		pim_ifp = ifp->info;
+		/*
+		 * If we have a pim_ifp already and this is an if_add
+		 * that means that we probably have a vrf move event
+		 * If that is the case, set the proper vrfness.
+		 */
+		if (pim_ifp)
+			pim_ifp->pim = pim;
+
 		/*
 		  pim_if_addr_add_all() suffices for bringing up both IGMP and
 		  PIM
@@ -176,7 +202,7 @@ static int pim_zebra_if_state_up(int com
 	 * If we have a pimreg device callback and it's for a specific
 	 * table set the master appropriately
 	 */
-	if (sscanf(ifp->name, "pimreg%d", &table_id) == 1) {
+	if (sscanf(ifp->name, "pimreg%" SCNu32, &table_id) == 1) {
 		struct vrf *vrf;
 		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
 			if ((table_id == vrf->data.l.table_id)
@@ -274,6 +300,7 @@ static int pim_zebra_if_address_add(int
 	struct connected *c;
 	struct prefix *p;
 	struct pim_interface *pim_ifp;
+	struct pim_instance *pim;
 
 	/*
 	  zebra api notifies address adds/dels events by using the same call
@@ -327,8 +354,12 @@ static int pim_zebra_if_address_add(int
 	}
 
 	pim_if_addr_add(c);
-	if (pim_ifp)
+	if (pim_ifp) {
+		pim = pim_get_pim_instance(vrf_id);
+		pim_ifp->pim = pim;
+
 		pim_rp_check_on_if_add(pim_ifp);
+	}
 
 	if (if_is_loopback(c->ifp)) {
 		struct vrf *vrf = vrf_lookup_by_id(VRF_DEFAULT);
@@ -394,13 +425,91 @@ static int pim_zebra_if_address_del(int
 	return 0;
 }
 
+void pim_zebra_update_all_interfaces(struct pim_instance *pim)
+{
+	struct interface *ifp;
+
+	FOR_ALL_INTERFACES (pim->vrf, ifp) {
+		struct pim_interface *pim_ifp = ifp->info;
+		struct pim_iface_upstream_switch *us;
+		struct listnode *node;
+
+		if (!pim_ifp)
+			continue;
+
+		for (ALL_LIST_ELEMENTS_RO(pim_ifp->upstream_switch_list, node,
+					  us)) {
+			struct pim_rpf rpf;
+
+			rpf.source_nexthop.interface = ifp;
+			rpf.rpf_addr.u.prefix4 = us->address;
+			pim_joinprune_send(&rpf, us->us);
+			pim_jp_agg_clear_group(us->us);
+		}
+	}
+}
+
+void pim_zebra_upstream_rpf_changed(struct pim_instance *pim,
+				    struct pim_upstream *up,
+				    struct pim_rpf *old)
+{
+	struct pim_neighbor *nbr;
+
+	nbr = pim_neighbor_find(old->source_nexthop.interface,
+				old->rpf_addr.u.prefix4);
+	if (nbr)
+		pim_jp_agg_remove_group(nbr->upstream_jp_agg, up);
+
+	/*
+	 * We have detected a case where we might need
+	 * to rescan the inherited o_list so do it.
+	 */
+	if (up->channel_oil->oil_inherited_rescan) {
+		pim_upstream_inherited_olist_decide(pim, up);
+		up->channel_oil->oil_inherited_rescan = 0;
+	}
+
+	if (up->join_state == PIM_UPSTREAM_JOINED) {
+		/*
+		 * If we come up real fast we can be here
+		 * where the mroute has not been installed
+		 * so install it.
+		 */
+		if (!up->channel_oil->installed)
+			pim_mroute_add(up->channel_oil, __PRETTY_FUNCTION__);
+
+		/*
+		 * RFC 4601: 4.5.7.  Sending (S,G)
+		 * Join/Prune Messages
+		 *
+		 * Transitions from Joined State
+		 *
+		 * RPF'(S,G) changes not due to an Assert
+		 *
+		 * The upstream (S,G) state machine remains
+		 * in Joined state. Send Join(S,G) to the new
+		 * upstream neighbor, which is the new value
+		 * of RPF'(S,G).  Send Prune(S,G) to the old
+		 * upstream neighbor, which is the old value
+		 * of RPF'(S,G).  Set the Join Timer (JT) to
+		 * expire after t_periodic seconds.
+		 */
+		pim_jp_agg_switch_interface(old, &up->rpf, up);
+
+		pim_upstream_join_timer_restart(up, old);
+	} /* up->join_state == PIM_UPSTREAM_JOINED */
+
+	/* FIXME can join_desired actually be changed by
+	   pim_rpf_update()
+	   returning PIM_RPF_CHANGED ? */
+	pim_upstream_update_join_desired(pim, up);
+}
+
 static void scan_upstream_rpf_cache(struct pim_instance *pim)
 {
 	struct listnode *up_node;
 	struct listnode *up_nextnode;
-	struct listnode *node;
 	struct pim_upstream *up;
-	struct interface *ifp;
 
 	for (ALL_LIST_ELEMENTS(pim->upstream_list, up_node, up_nextnode, up)) {
 		enum pim_rpf_result rpf_result;
@@ -419,80 +528,12 @@ static void scan_upstream_rpf_cache(stru
 		if (rpf_result == PIM_RPF_FAILURE)
 			continue;
 
-		if (rpf_result == PIM_RPF_CHANGED) {
-			struct pim_neighbor *nbr;
-
-			nbr = pim_neighbor_find(old.source_nexthop.interface,
-						old.rpf_addr.u.prefix4);
-			if (nbr)
-				pim_jp_agg_remove_group(nbr->upstream_jp_agg,
-							up);
-
-			/*
-			 * We have detected a case where we might need
-			 * to rescan
-			 * the inherited o_list so do it.
-			 */
-			if (up->channel_oil->oil_inherited_rescan) {
-				pim_upstream_inherited_olist_decide(pim, up);
-				up->channel_oil->oil_inherited_rescan = 0;
-			}
-
-			if (up->join_state == PIM_UPSTREAM_JOINED) {
-				/*
-				 * If we come up real fast we can be here
-				 * where the mroute has not been installed
-				 * so install it.
-				 */
-				if (!up->channel_oil->installed)
-					pim_mroute_add(up->channel_oil,
-						       __PRETTY_FUNCTION__);
-
-				/*
-				 * RFC 4601: 4.5.7.  Sending (S,G)
-				 * Join/Prune Messages
-				 *
-				 * Transitions from Joined State
-				 *
-				 * RPF'(S,G) changes not due to an Assert
-				 *
-				 * The upstream (S,G) state machine remains
-				 * in Joined state. Send Join(S,G) to the new
-				 * upstream neighbor, which is the new value
-				 * of RPF'(S,G).  Send Prune(S,G) to the old
-				 * upstream neighbor, which is the old value
-				 * of RPF'(S,G).  Set the Join Timer (JT) to
-				 * expire after t_periodic seconds.
-				 */
-				pim_jp_agg_switch_interface(&old, &up->rpf, up);
-
-				pim_upstream_join_timer_restart(up, &old);
-			} /* up->join_state == PIM_UPSTREAM_JOINED */
-
-			/* FIXME can join_desired actually be changed by
-			   pim_rpf_update()
-			   returning PIM_RPF_CHANGED ? */
-			pim_upstream_update_join_desired(pim, up);
-
-		} /* PIM_RPF_CHANGED */
+		if (rpf_result == PIM_RPF_CHANGED)
+			pim_zebra_upstream_rpf_changed(pim, up, &old);
 
 	} /* for (qpim_upstream_list) */
 
-	FOR_ALL_INTERFACES (pim->vrf, ifp)
-		if (ifp->info) {
-			struct pim_interface *pim_ifp = ifp->info;
-			struct pim_iface_upstream_switch *us;
-
-			for (ALL_LIST_ELEMENTS_RO(pim_ifp->upstream_switch_list,
-						  node, us)) {
-				struct pim_rpf rpf;
-
-				rpf.source_nexthop.interface = ifp;
-				rpf.rpf_addr.u.prefix4 = us->address;
-				pim_joinprune_send(&rpf, us->us);
-				pim_jp_agg_clear_group(us->us);
-			}
-		}
+	pim_zebra_update_all_interfaces(pim);
 }
 
 void pim_scan_individual_oil(struct channel_oil *c_oil, int in_vif_index)
@@ -530,7 +571,7 @@ void pim_scan_individual_oil(struct chan
 				__PRETTY_FUNCTION__, source_str, group_str);
 		}
 		input_iface_vif_index = pim_ecmp_fib_lookup_if_vif_index(
-			c_oil->pim, vif_source, &src, &grp);
+			c_oil->pim, &src, &grp);
 	}
 
 	if (input_iface_vif_index < 1) {
@@ -706,8 +747,6 @@ static void pim_zebra_connected(struct z
 
 void pim_zebra_init(void)
 {
-	int i;
-
 	/* Socket for receiving updates from Zebra daemon */
 	zclient = zclient_new_notify(master, &zclient_options_default);
 
@@ -723,31 +762,7 @@ void pim_zebra_init(void)
 
 	zclient_init(zclient, ZEBRA_ROUTE_PIM, 0, &pimd_privs);
 	if (PIM_DEBUG_PIM_TRACE) {
-		zlog_info("zclient_init cleared redistribution request");
-	}
-
-	/* Request all redistribution */
-	for (i = 0; i < ZEBRA_ROUTE_MAX; i++) {
-		if (i == zclient->redist_default)
-			continue;
-		vrf_bitmap_set(zclient->redist[AFI_IP][i], pimg->vrf_id);
-		;
-		if (PIM_DEBUG_PIM_TRACE) {
-			zlog_debug("%s: requesting redistribution for %s (%i)",
-				   __PRETTY_FUNCTION__, zebra_route_string(i),
-				   i);
-		}
-	}
-
-	/* Request default information */
-	zclient_redistribute_default(ZEBRA_REDISTRIBUTE_DEFAULT_ADD, zclient,
-				     pimg->vrf_id);
-
-	if (PIM_DEBUG_PIM_TRACE) {
-		zlog_info("%s: requesting default information redistribution",
-			  __PRETTY_FUNCTION__);
-
-		zlog_notice("%s: zclient update socket initialized",
+		zlog_notice("%s: zclient socket initialized",
 			    __PRETTY_FUNCTION__);
 	}
 
@@ -863,6 +878,7 @@ void igmp_source_forward_reevaluate_all(
 void igmp_source_forward_start(struct pim_instance *pim,
 			       struct igmp_source *source)
 {
+	struct pim_interface *pim_oif;
 	struct igmp_group *group;
 	struct prefix_sg sg;
 	int result;
@@ -888,10 +904,20 @@ void igmp_source_forward_start(struct pi
 	}
 
 	group = source->source_group;
+	pim_oif = group->group_igmp_sock->interface->info;
+	if (!pim_oif) {
+		if (PIM_DEBUG_IGMP_TRACE) {
+			zlog_debug(
+				   "%s: multicast not enabled on oif=%s ?",
+				   __PRETTY_FUNCTION__,
+				   source->source_group->group_igmp_sock
+				   ->interface->name);
+		}
+		return;
+	}
 
 	if (!source->source_channel_oil) {
 		struct in_addr vif_source;
-		struct pim_interface *pim_oif;
 		struct prefix nht_p, src, grp;
 		struct pim_nexthop_cache out_pnc;
 		struct pim_nexthop nexthop;
@@ -948,8 +974,8 @@ void igmp_source_forward_start(struct pi
 			}
 		} else
 			input_iface_vif_index =
-				pim_ecmp_fib_lookup_if_vif_index(
-					pim, vif_source, &src, &grp);
+				pim_ecmp_fib_lookup_if_vif_index(pim, &src,
+								 &grp);
 
 		if (PIM_DEBUG_ZEBRA) {
 			char buf2[INET_ADDRSTRLEN];
@@ -978,19 +1004,6 @@ void igmp_source_forward_start(struct pi
 		  source and receiver attached to the same interface. See TODO
 		  T22.
 		*/
-		pim_oif =
-			source->source_group->group_igmp_sock->interface->info;
-		if (!pim_oif) {
-			if (PIM_DEBUG_IGMP_TRACE) {
-				zlog_debug(
-					"%s: multicast not enabled on oif=%s ?",
-					__PRETTY_FUNCTION__,
-					source->source_group->group_igmp_sock
-						->interface->name);
-			}
-			return;
-		}
-
 		if (input_iface_vif_index == pim_oif->mroute_vif_index) {
 			/* ignore request for looped MFC entry */
 			if (PIM_DEBUG_IGMP_TRACE) {
@@ -1031,12 +1044,15 @@ void igmp_source_forward_start(struct pi
 		return;
 	}
 
+	if (!(PIM_I_am_DR(pim_oif)))
+		return;
+
 	/*
 	  Feed IGMPv3-gathered local membership information into PIM
 	  per-interface (S,G) state.
 	 */
 	if (!pim_ifchannel_local_membership_add(
-		    group->group_igmp_sock->interface, &sg)) {
+						group->group_igmp_sock->interface, &sg)) {
 		if (PIM_DEBUG_MROUTE)
 			zlog_warn("%s: Failure to add local membership for %s",
 				  __PRETTY_FUNCTION__, pim_str_sg_dump(&sg));
@@ -1148,7 +1164,7 @@ void pim_forward_start(struct pim_ifchan
 		/* Register addr with Zebra NHT */
 		nht_p.family = AF_INET;
 		nht_p.prefixlen = IPV4_MAX_BITLEN;
-		nht_p.u.prefix4.s_addr = up->upstream_addr.s_addr;
+		nht_p.u.prefix4 = up->upstream_addr;
 		grp.family = AF_INET;
 		grp.prefixlen = IPV4_MAX_BITLEN;
 		grp.u.prefix4 = up->sg.grp;
@@ -1199,8 +1215,8 @@ void pim_forward_start(struct pim_ifchan
 			}
 		} else
 			input_iface_vif_index =
-				pim_ecmp_fib_lookup_if_vif_index(
-					pim, up->upstream_addr, &src, &grp);
+				pim_ecmp_fib_lookup_if_vif_index(pim, &src,
+								 &grp);
 
 		if (input_iface_vif_index < 1) {
 			if (PIM_DEBUG_PIM_TRACE) {
diff -urpN frr-frr-5.0.1/pimd/pim_zebra.h frr-frr-6.0/pimd/pim_zebra.h
--- frr-frr-5.0.1/pimd/pim_zebra.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_zebra.h	2018-10-08 14:32:57.000000000 +0200
@@ -46,4 +46,9 @@ void pim_forward_stop(struct pim_ifchann
 
 void sched_rpf_cache_refresh(struct pim_instance *pim);
 struct zclient *pim_zebra_zclient_get(void);
+
+void pim_zebra_update_all_interfaces(struct pim_instance *pim);
+void pim_zebra_upstream_rpf_changed(struct pim_instance *pim,
+				    struct pim_upstream *up,
+				    struct pim_rpf *old);
 #endif /* PIM_ZEBRA_H */
diff -urpN frr-frr-5.0.1/pimd/pim_zlookup.c frr-frr-6.0/pimd/pim_zlookup.c
--- frr-frr-5.0.1/pimd/pim_zlookup.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pim_zlookup.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@
 #include "thread.h"
 #include "prefix.h"
 #include "vty.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_iface.h"
@@ -122,7 +123,8 @@ void zclient_lookup_new(void)
 {
 	zlookup = zclient_new_notify(master, &zclient_options_default);
 	if (!zlookup) {
-		zlog_err("%s: zclient_new() failure", __PRETTY_FUNCTION__);
+		flog_err(LIB_ERR_ZAPI_SOCKET, "%s: zclient_new() failure",
+			  __PRETTY_FUNCTION__);
 		return;
 	}
 
@@ -168,8 +170,9 @@ static int zclient_read_nexthop(struct p
 		err = zclient_read_header(s, zlookup->sock, &length, &marker,
 					  &version, &vrf_id, &command);
 		if (err < 0) {
-			zlog_err("%s: zclient_read_header() failed",
-				 __PRETTY_FUNCTION__);
+			flog_err(LIB_ERR_ZAPI_MISSMATCH,
+				  "%s: zclient_read_header() failed",
+				  __PRETTY_FUNCTION__);
 			zclient_lookup_failed(zlookup);
 			return -1;
 		}
@@ -215,24 +218,30 @@ static int zclient_read_nexthop(struct p
 				tab_size, addr_str, pim->vrf->name);
 			return num_ifindex;
 		}
+		nexthop_tab[num_ifindex].protocol_distance = distance;
+		nexthop_tab[num_ifindex].route_metric = metric;
 		switch (nexthop_type) {
 		case NEXTHOP_TYPE_IFINDEX:
+			nexthop_tab[num_ifindex].ifindex = stream_getl(s);
+			/*
+			 * Connected route (i.e. no nexthop), use
+			 * address passed in as PIM nexthop.  This will
+			 * allow us to work in cases where we are
+			 * trying to find a route for this box.
+			 */
+			nexthop_tab[num_ifindex].nexthop_addr.family = AF_INET;
+			nexthop_tab[num_ifindex].nexthop_addr.prefixlen =
+				IPV4_MAX_BITLEN;
+			nexthop_tab[num_ifindex].nexthop_addr.u.prefix4 =
+				addr;
+			++num_ifindex;
+			break;
 		case NEXTHOP_TYPE_IPV4_IFINDEX:
 		case NEXTHOP_TYPE_IPV4:
 			nexthop_tab[num_ifindex].nexthop_addr.family = AF_INET;
-			if (nexthop_type == NEXTHOP_TYPE_IPV4_IFINDEX
-			    || nexthop_type == NEXTHOP_TYPE_IPV4) {
-				nexthop_tab[num_ifindex]
-					.nexthop_addr.u.prefix4.s_addr =
-					stream_get_ipv4(s);
-			} else {
-				nexthop_tab[num_ifindex]
-					.nexthop_addr.u.prefix4.s_addr =
-					PIM_NET_INADDR_ANY;
-			}
+			nexthop_tab[num_ifindex].nexthop_addr.u.prefix4.s_addr =
+				stream_get_ipv4(s);
 			nexthop_tab[num_ifindex].ifindex = stream_getl(s);
-			nexthop_tab[num_ifindex].protocol_distance = distance;
-			nexthop_tab[num_ifindex].route_metric = metric;
 			++num_ifindex;
 			break;
 		case NEXTHOP_TYPE_IPV6_IFINDEX:
@@ -306,14 +315,15 @@ static int zclient_lookup_nexthop_once(s
 
 	/* Check socket. */
 	if (zlookup->sock < 0) {
-		zlog_err("%s: zclient lookup socket is not connected",
-			 __PRETTY_FUNCTION__);
+		flog_err(LIB_ERR_ZAPI_SOCKET,
+			  "%s: zclient lookup socket is not connected",
+			  __PRETTY_FUNCTION__);
 		zclient_lookup_failed(zlookup);
 		return -1;
 	}
 
 	if (pim->vrf->vrf_id == VRF_UNKNOWN) {
-		zlog_err(
+		zlog_notice(
 			"%s: VRF: %s does not fully exist yet, delaying lookup",
 			__PRETTY_FUNCTION__, pim->vrf->name);
 		return -1;
@@ -327,15 +337,17 @@ static int zclient_lookup_nexthop_once(s
 
 	ret = writen(zlookup->sock, s->data, stream_get_endp(s));
 	if (ret < 0) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"%s: writen() failure: %d writing to zclient lookup socket",
 			__PRETTY_FUNCTION__, errno);
 		zclient_lookup_failed(zlookup);
 		return -2;
 	}
 	if (ret == 0) {
-		zlog_err("%s: connection closed on zclient lookup socket",
-			 __PRETTY_FUNCTION__);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s: connection closed on zclient lookup socket",
+			     __PRETTY_FUNCTION__);
 		zclient_lookup_failed(zlookup);
 		return -3;
 	}
@@ -503,7 +515,8 @@ int pim_zlookup_sg_statistics(struct cha
 	count = stream_get_endp(s);
 	ret = writen(zlookup->sock, s->data, count);
 	if (ret <= 0) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"%s: writen() failure: %d writing to zclient lookup socket",
 			__PRETTY_FUNCTION__, errno);
 		return -1;
@@ -522,8 +535,9 @@ int pim_zlookup_sg_statistics(struct cha
 		err = zclient_read_header(s, zlookup->sock, &length, &marker,
 					  &version, &vrf_id, &command);
 		if (err < 0) {
-			zlog_err("%s: zclient_read_header() failed",
-				 __PRETTY_FUNCTION__);
+			flog_err(LIB_ERR_ZAPI_MISSMATCH,
+				  "%s: zclient_read_header() failed",
+				  __PRETTY_FUNCTION__);
 			zclient_lookup_failed(zlookup);
 			return -1;
 		}
@@ -538,7 +552,8 @@ int pim_zlookup_sg_statistics(struct cha
 
 			more.src = c_oil->oil.mfcc_origin;
 			more.grp = c_oil->oil.mfcc_mcastgrp;
-			zlog_err(
+			flog_err(
+				LIB_ERR_ZAPI_MISSMATCH,
 				"%s: Received wrong %s(%s) information requested",
 				__PRETTY_FUNCTION__, pim_str_sg_dump(&more),
 				c_oil->pim->vrf->name);
diff -urpN frr-frr-5.0.1/pimd/pimd.c frr-frr-6.0/pimd/pimd.c
--- frr-frr-5.0.1/pimd/pimd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pimd.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@
 #include "hash.h"
 #include "jhash.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "pimd.h"
 #include "pim_cmd.h"
@@ -53,8 +54,6 @@ int qpim_t_periodic =
 struct pim_assert_metric qpim_infinite_assert_metric;
 long qpim_rpf_cache_refresh_delay_msec = 50;
 int qpim_packet_process = PIM_DEFAULT_PACKET_PROCESS;
-uint8_t qpim_ecmp_enable = 0;
-uint8_t qpim_ecmp_rebalance_enable = 0;
 struct pim_instance *pimg = NULL;
 
 int32_t qpim_register_suppress_time = PIM_REGISTER_SUPPRESSION_TIME_DEFAULT;
@@ -81,14 +80,13 @@ static void pim_free()
 	pim_route_map_terminate();
 
 	zclient_lookup_free();
-
-	zprivs_terminate(&pimd_privs);
 }
 
 void pim_init()
 {
 	if (!inet_aton(PIM_ALL_PIM_ROUTERS, &qpim_all_pim_routers_addr)) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_SOCKET,
 			"%s %s: could not solve %s to group address: errno=%d: %s",
 			__FILE__, __PRETTY_FUNCTION__, PIM_ALL_PIM_ROUTERS,
 			errno, safe_strerror(errno));
diff -urpN frr-frr-5.0.1/pimd/pimd.h frr-frr-6.0/pimd/pimd.h
--- frr-frr-5.0.1/pimd/pimd.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/pimd.h	2018-10-08 14:32:57.000000000 +0200
@@ -117,7 +117,6 @@
 
 /* PIM error codes */
 #define PIM_SUCCESS                0
-#define PIM_MALLOC_FAIL           -1
 #define PIM_GROUP_BAD_ADDRESS     -2
 #define PIM_GROUP_OVERLAP         -3
 #define PIM_GROUP_PFXLIST_OVERLAP -4
diff -urpN frr-frr-5.0.1/pimd/subdir.am frr-frr-6.0/pimd/subdir.am
--- frr-frr-5.0.1/pimd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/pimd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -15,11 +15,13 @@ pimd_libpim_a_SOURCES = \
 	pimd/pim_bfd.c \
 	pimd/pim_br.c \
 	pimd/pim_cmd.c \
+	pimd/pim_errors.c \
 	pimd/pim_hello.c \
 	pimd/pim_iface.c \
 	pimd/pim_ifchannel.c \
 	pimd/pim_igmp.c \
 	pimd/pim_igmp_mtrace.c \
+	pimd/pim_igmp_stats.c \
 	pimd/pim_igmpv2.c \
 	pimd/pim_igmpv3.c \
 	pimd/pim_instance.c \
@@ -63,12 +65,14 @@ noinst_HEADERS += \
 	pimd/pim_bfd.h \
 	pimd/pim_br.h \
 	pimd/pim_cmd.h \
+	pimd/pim_errors.h \
 	pimd/pim_hello.h \
 	pimd/pim_iface.h \
 	pimd/pim_ifchannel.h \
 	pimd/pim_igmp.h \
 	pimd/pim_igmp_join.h \
 	pimd/pim_igmp_mtrace.h \
+	pimd/pim_igmp_stats.h \
 	pimd/pim_igmpv2.h \
 	pimd/pim_igmpv3.h \
 	pimd/pim_instance.h \
diff -urpN frr-frr-5.0.1/redhat/daemons frr-frr-6.0/redhat/daemons
--- frr-frr-5.0.1/redhat/daemons	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/redhat/daemons	2018-10-08 14:32:57.000000000 +0200
@@ -51,6 +51,9 @@ eigrpd=no
 babeld=no
 sharpd=no
 pbrd=no
+staticd=no
+bfdd=no
+
 #
 # Command line options for the daemons
 #
@@ -68,6 +71,8 @@ eigrpd_options=("-A 127.0.0.1")
 babeld_options=("-A 127.0.0.1")
 sharpd_options=("-A 127.0.0.1")
 pbrd_options=("-A 127.0.0.1")
+staticd_options=("-A 127.0.0.1")
+bfdd_options=("-A 127.0.0.1")
 
 #
 # If the vtysh_enable is yes, then the unified config is read
diff -urpN frr-frr-5.0.1/redhat/frr.init frr-frr-6.0/redhat/frr.init
--- frr-frr-5.0.1/redhat/frr.init	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/redhat/frr.init	2018-10-08 14:32:57.000000000 +0200
@@ -7,7 +7,7 @@
 #
 # chkconfig: 2345 15 85
 #
-# description: FRRouting (FRR) is a routing suite for IP routing protocols 
+# description: FRRouting (FRR) is a routing suite for IP routing protocols
 #              like BGP, OSPF, RIP and others. This script contols the main
 #              daemon "frr" as well as the individual protocol daemons.
 #
@@ -20,7 +20,7 @@
 # Default-Start: 2 3 4 5
 # Default-Stop: 0 1 6
 # Short-Description: Start/Stop the FRR Routing daemons
-# Description: FRRouting (FRR) is a routing suite for IP routing protocols 
+# Description: FRRouting (FRR) is a routing suite for IP routing protocols
 #              like BGP, OSPF, RIP and others. This script contols the main
 #              daemon "frr" as well as the individual protocol daemons.
 ### END INIT INFO
@@ -33,7 +33,7 @@ V_PATH=/var/run/frr
 # Local Daemon selection may be done by using /etc/frr/daemons.
 # See /usr/share/doc/frr/README.Debian.gz for further information.
 # Keep zebra first and do not list watchfrr!
-DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd pimd pbrd ldpd nhrpd eigrpd babeld"
+DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd pimd pbrd ldpd nhrpd eigrpd babeld staticd sharpd bfdd"
 MAX_INSTANCES=5
 RELOAD_SCRIPT=/usr/lib/frr/frr-reload.py
 
diff -urpN frr-frr-5.0.1/redhat/frr.logrotate frr-frr-6.0/redhat/frr.logrotate
--- frr-frr-5.0.1/redhat/frr.logrotate	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/redhat/frr.logrotate	2018-10-08 14:32:57.000000000 +0200
@@ -86,3 +86,10 @@
     endscript
 }
 
+/var/log/frr/bfdd.log {
+    notifempty
+    missingok
+    postrotate
+    /bin/kill -USR1 `cat /var/run/frr/bfdd.pid 2> /dev/null` 2> /dev/null || true
+    endscript
+}
diff -urpN frr-frr-5.0.1/redhat/frr.service frr-frr-6.0/redhat/frr.service
--- frr-frr-5.0.1/redhat/frr.service	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/redhat/frr.service	2018-10-08 14:32:57.000000000 +0200
@@ -9,7 +9,7 @@ Type=forking
 NotifyAccess=all
 StartLimitInterval=3m
 StartLimitBurst=3
-TimeoutSec=1m
+TimeoutSec=2m
 WatchdogSec=60s
 RestartSec=5
 Restart=on-abnormal
diff -urpN frr-frr-5.0.1/redhat/frr.spec.in frr-frr-6.0/redhat/frr.spec.in
--- frr-frr-5.0.1/redhat/frr.spec.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/redhat/frr.spec.in	2018-10-08 14:32:57.000000000 +0200
@@ -10,41 +10,44 @@
 
 #################### FRRouting (FRR) configure options #####################
 # with-feature options
-%{!?with_pam:           %global  with_pam           0 }
-%{!?with_ospfclient:    %global  with_ospfclient    1 }
-%{!?with_ospfapi:       %global  with_ospfapi       1 }
-%{!?with_rtadv:         %global  with_rtadv         1 }
-%{!?with_ldpd:          %global  with_ldpd          1 }
-%{!?with_nhrpd:         %global  with_nhrpd         1 }
-%{!?with_eigrpd:        %global  with_eigrpd        1 }
 %{!?with_babeld:        %global  with_babeld        1 }
-%{!?with_shared:        %global  with_shared        1 }
-%{!?with_multipath:     %global  with_multipath     256 }
-%{!?frr_user:           %global  frr_user           frr }
-%{!?vty_group:          %global  vty_group          frrvty }
-%{!?with_fpm:           %global  with_fpm           1 }
-%{!?with_watchfrr:      %global  with_watchfrr      1 }
+%{!?with_bfdd:          %global  with_bfdd          1 }
 %{!?with_bgp_vnc:       %global  with_bgp_vnc       0 }
+%{!?with_cumulus:       %global  with_cumulus       0 }
+%{!?with_eigrpd:        %global  with_eigrpd        1 }
+%{!?with_fpm:           %global  with_fpm           1 }
+%{!?with_ldpd:          %global  with_ldpd          1 }
+%{!?with_multipath:     %global  with_multipath     256 }
+%{!?with_nhrpd:         %global  with_nhrpd         1 }
+%{!?with_ospfapi:       %global  with_ospfapi       1 }
+%{!?with_ospfclient:    %global  with_ospfclient    1 }
+%{!?with_pam:           %global  with_pam           0 }
+%{!?with_pbrd:          %global  with_pbrd          1 }
 %{!?with_pimd:          %global  with_pimd          1 }
 %{!?with_rpki:          %global  with_rpki          0 }
-%{!?with_pbrd:          %global  with_pbrd          1 }
+%{!?with_rtadv:         %global  with_rtadv         1 }
+%{!?with_watchfrr:      %global  with_watchfrr      1 }
+
+# user and group
+%{!?frr_user:           %global  frr_user           frr }
+%{!?vty_group:          %global  vty_group          frrvty }
 
 # path defines
-%define     _sysconfdir   /etc/frr
-%define     _sbindir      /usr/lib/frr
-%define     zeb_src       %{_builddir}/%{name}-%{frrversion}
-%define     zeb_rh_src    %{zeb_src}/redhat
-%define     zeb_docs      %{zeb_src}/doc
-%define     frr_tools     %{zeb_src}/tools
+%define     configdir   %{_sysconfdir}/%{name}
+%define     _sbindir    /usr/lib/frr
+%define     zeb_src     %{_builddir}/%{name}-%{frrversion}
+%define     zeb_rh_src  %{zeb_src}/redhat
+%define     zeb_docs    %{zeb_src}/doc
+%define     frr_tools   %{zeb_src}/tools
 
 # defines for configure
-%define     _localstatedir  /var/run/frr
+%define     rundir  %{_localstatedir}/run/%{name}
 
 # define for sphinx-build binary
 %if 0%{?rhel} && 0%{?rhel} < 7
-%define     sphinx sphinx-build2.7
+    %define sphinx sphinx-build2.7
 %else
-%define     sphinx sphinx-build
+    %define sphinx sphinx-build
 %endif
 ############################################################################
 
@@ -55,26 +58,22 @@
 
 #### Check for systemd or init.d (upstart)
 # Check for init.d (upstart) as used in CentOS 6 or systemd (ie CentOS 7)
-%if 0%{?fedora} >= 15 || 0%{?rhel} >= 7 || 0%{?suse_version} >= 1210
+%if 0%{?fedora} || 0%{?rhel} >= 7 || 0%{?suse_version} >= 1210
     %global initsystem systemd
 %else
-%if (0%{?fedora} && 0%{?fedora} < 15) || (0%{?rhel} && 0%{?rhel} < 7)
+%if 0%{?rhel} && 0%{?rhel} < 7
     %global initsystem upstart
 %else
     %{expand: %%global initsystem %(if [[ `/sbin/init --version 2> /dev/null` =~ upstart ]]; then echo upstart; elif [[ `readlink -f /sbin/init` = /usr/lib/systemd/systemd ]]; then echo systemd; elif [[ `systemctl` =~ -\.mount ]]; then echo systemd; fi)}
 %endif
 %endif
-#
-# If init system is systemd, then always disable watchfrr
-#
+
+# If init system is systemd, then always enable watchfrr
 %if "%{initsystem}" == "systemd"
-    # Note: For systems with systemd, watchfrr will NOT be built. Systemd
-    # takes over the role of restarting crashed processes. Value will
-    # be overwritten with 0 below for systemd independent on the setting here
     %global with_watchfrr 1
 %endif
 
-#### Check for RedHat 6.x or CentOS 6.x - they are too old to support PIM. 
+#### Check for RedHat 6.x or CentOS 6.x - they are too old to support PIM.
 ####   Always disable it on these old systems unconditionally
 #
 # if CentOS / RedHat and version < 7, then disable PIMd (too old, won't work)
@@ -87,54 +86,57 @@
 %{!?frr_gid:            %global  frr_gid            92 }
 %{!?vty_gid:            %global  vty_gid            85 }
 
-%define     daemon_list zebra ripd ospfd bgpd isisd ripngd ospf6d pbrd
+%define daemon_list zebra ripd ospfd bgpd isisd ripngd ospf6d pbrd staticd bfdd
 
 %if %{with_ldpd}
-%define     daemon_ldpd ldpd
+    %define daemon_ldpd ldpd
 %else
-%define     daemon_ldpd ""
+    %define daemon_ldpd ""
 %endif
 
 %if %{with_pimd}
-%define     daemon_pimd pimd
+    %define daemon_pimd pimd
 %else
-%define     daemon_pimd ""
+    %define daemon_pimd ""
 %endif
 
 %if %{with_pbrd}
-%define     daemon_pbrd pbrd
+    %define daemon_pbrd pbrd
 %else
-%define     daemon_pbrd ""
+    %define daemon_pbrd ""
 %endif
 
 %if %{with_nhrpd}
-%define         daemon_nhrpd	nhrpd
+    %define daemon_nhrpd nhrpd
 %else
-%define		daemon_nhrpd	""
+    %define daemon_nhrpd ""
 %endif
 
 %if %{with_eigrpd}
-%define         daemon_eigrpd	eigrpd
+    %define daemon_eigrpd eigrpd
 %else
-%define		daemon_eigrpd	""
+    %define daemon_eigrpd ""
 %endif
 
 %if %{with_babeld}
-%define         daemon_babeld	babeld
+    %define daemon_babeld babeld
 %else
-%define		daemon_babeld	""
+    %define daemon_babeld ""
 %endif
 
 %if %{with_watchfrr}
-%define     daemon_watchfrr watchfrr
+    %define daemon_watchfrr watchfrr
 %else
-%define     daemon_watchfrr ""
+    %define daemon_watchfrr ""
 %endif
 
-%define     all_daemons %{daemon_list} %{daemon_ldpd} %{daemon_pimd} %{daemon_nhrpd} %{daemon_eigrpd} %{daemon_babeld} %{daemon_watchfrr} %{daemon_pbrd}
+%if %{with_bfdd}
+    %define daemon_bfdd bfdd
+%else
+    %define daemon_bfdd ""
+%endif
 
-# allow build dir to be kept
-%{!?keep_build:         %global  keep_build         0 }
+%define all_daemons %{daemon_list} %{daemon_ldpd} %{daemon_pimd} %{daemon_nhrpd} %{daemon_eigrpd} %{daemon_babeld} %{daemon_watchfrr} %{daemon_pbrd} %{daemon_bfdd}
 
 #release sub-revision (the two digits after the CONFDATE)
 %{!?release_rev:        %global  release_rev        01 }
@@ -145,54 +147,64 @@ Version:        %{rpmversion}
 Release:        @CONFDATE@%{release_rev}%{?dist}
 License:        GPLv2+
 Group:          System Environment/Daemons
-Source0:        http://www.frrouting.org/releases/frr/%{name}-%{frrversion}.tar.gz
-URL:            http://www.frrouting.org
-Requires(pre):  /sbin/install-info
-Requires(preun): /sbin/install-info
-Requires(post): /sbin/install-info
-BuildRequires:  gcc patch libcap-devel
-BuildRequires:  readline readline-devel ncurses ncurses-devel
-BuildRequires:  json-c-devel bison >= 2.7 flex make
-BuildRequires:  c-ares-devel texinfo
+Source0:        https://github.com/FRRouting/frr/archive/%{name}-%{frrversion}.tar.gz
+URL:            https://www.frrouting.org
+Requires(pre):  shadow-utils
+Requires(preun): info
+Requires(post): info
+BuildRequires:  bison >= 2.7
+BuildRequires:  c-ares-devel
+BuildRequires:  flex
+BuildRequires:  gcc
+BuildRequires:  json-c-devel
+BuildRequires:  libcap-devel
+BuildRequires:  make
+BuildRequires:  ncurses-devel
+BuildRequires:  readline-devel
+BuildRequires:  texinfo
 %if 0%{?rhel} && 0%{?rhel} < 7
 #python27-devel is available from ius community repo for RedHat/CentOS 6
-BuildRequires:  python27-devel python27-sphinx
+BuildRequires:  python27-devel
+BuildRequires:  python27-sphinx
 %else
-BuildRequires:  python-devel >= 2.7 python-sphinx
+BuildRequires:  python-devel >= 2.7
+BuildRequires:  python-sphinx
 %endif
-Requires:       ncurses json-c initscripts
 %if %{with_pam}
 BuildRequires:  pam-devel
-Requires:       pam
 %endif
 %if %{with_rpki}
 BuildRequires:  librtr-devel >= 0.5
-Requires:       librtr >= 0.5
 %endif
 %if "%{initsystem}" == "systemd"
-BuildRequires:      systemd systemd-devel
+BuildRequires:      systemd
+BuildRequires:      systemd-devel
 Requires(post):     systemd
 Requires(preun):    systemd
 Requires(postun):   systemd
 %else
+Requires(post):     chkconfig
+Requires(preun):    chkconfig
 # Initscripts > 5.60 is required for IPv6 support
 Requires(pre):      initscripts >= 5.60
+Requires:           initscripts
 %endif
 Provides:           routingdaemon = %{version}-%{release}
-BuildRoot:          %{_tmppath}/%{name}-%{version}-root
 Obsoletes:          gated mrt zebra frr-sysvinit
 Conflicts:          bird
 
+
 %description
 FRRouting is a free software that manages TCP/IP based routing
 protocol. It takes multi-server and multi-thread approach to resolve
 the current complexity of the Internet.
 
 FRRouting supports BGP4, OSPFv2, OSPFv3, ISIS, RIP, RIPng, PIM, LDP
-NHRP, Babel, PBR and EIGRP.
+NHRP, Babel, PBR, EIGRP and BFD.
 
 FRRouting is a fork of Quagga.
 
+
 %package contrib
 Summary: contrib tools for frr
 Group: System Environment/Daemons
@@ -200,15 +212,17 @@ Group: System Environment/Daemons
 %description contrib
 Contributed/3rd party tools which may be of use with frr.
 
+
 %package pythontools
 Summary: python tools for frr
 BuildRequires: python
-Requires: python python-ipaddr
+Requires: python-ipaddr
 Group: System Environment/Daemons
 
 %description pythontools
 Contributed python 2.7 tools which may be of use with frr.
 
+
 %package devel
 Summary: Header and object files for frr development
 Group: System Environment/Daemons
@@ -218,8 +232,10 @@ Requires: %{name} = %{version}-%{release
 The frr-devel package contains the header and object files neccessary for
 developing OSPF-API and frr applications.
 
+
 %prep
-%setup  -q -n frr-%{frrversion}
+%setup -q -n frr-%{frrversion}
+
 
 %build
 
@@ -235,15 +251,11 @@ developing OSPF-API and frr applications
 
 %configure \
     --sbindir=%{_sbindir} \
-    --sysconfdir=%{_sysconfdir} \
-    --libdir=%{_libdir} \
-    --libexecdir=%{_libexecdir} \
-    --localstatedir=%{_localstatedir} \
+    --sysconfdir=%{configdir} \
+    --localstatedir=%{rundir} \
+    --disable-static \
     --disable-werror \
     --enable-irdp \
-%if !%{with_shared}
-    --disable-shared \
-%endif
 %if %{with_multipath}
     --enable-multipath=%{with_multipath} \
 %endif
@@ -254,14 +266,14 @@ developing OSPF-API and frr applications
     --disable-ospfclient\
 %endif
 %if %{with_ospfapi}
-    --enable-ospfapi=yes \
+    --enable-ospfapi \
 %else
-    --enable-ospfapi=no \
+    --disable-ospfapi \
 %endif
 %if %{with_rtadv}
-    --enable-rtadv=yes \
+    --enable-rtadv \
 %else
-    --enable-rtadv=no \
+    --disable-rtadv \
 %endif
 %if %{with_ldpd}
     --enable-ldpd \
@@ -279,29 +291,29 @@ developing OSPF-API and frr applications
     --disable-pbrd \
 %endif
 %if %{with_nhrpd}
-	--enable-nhrpd \
+    --enable-nhrpd \
 %else
-	--disable-nhrpd \
+    --disable-nhrpd \
 %endif
 %if %{with_eigrpd}
-	--enable-eigrpd \
+    --enable-eigrpd \
 %else
-	--disable-eigrpd \
+    --disable-eigrpd \
 %endif
 %if %{with_babeld}
-	--enable-babeld \
+    --enable-babeld \
 %else
-	--disable-babeld \
+    --disable-babeld \
 %endif
 %if %{with_pam}
     --with-libpam \
 %endif
 %if 0%{?frr_user:1}
-    --enable-user=%frr_user \
-    --enable-group=%frr_user \
+    --enable-user=%{frr_user} \
+    --enable-group=%{frr_user} \
 %endif
 %if 0%{?vty_group:1}
-    --enable-vty-group=%vty_group \
+    --enable-vty-group=%{vty_group} \
 %endif
 %if %{with_fpm}
     --enable-fpm \
@@ -313,19 +325,28 @@ developing OSPF-API and frr applications
 %else
     --disable-watchfrr \
 %endif
+%if %{with_cumulus}
+    --enable-cumulus \
+%endif
 %if %{with_bgp_vnc}
     --enable-bgp-vnc \
 %else
     --disable-bgp-vnc \
 %endif
-    --enable-isisd=yes \
+    --enable-isisd \
 %if "%{initsystem}" == "systemd"
-    --enable-systemd=yes \
+    --enable-systemd \
 %endif
 %if %{with_rpki}
     --enable-rpki \
+%else
+    --disable-rpki \
+%endif
+%if %{with_bfdd}
+    --enable-bfdd
+%else
+    --disable-bfdd
 %endif
-    --enable-poll=yes
 
 make %{?_smp_mflags} MAKEINFO="makeinfo --no-split" SPHINXBUILD=%{sphinx}
 
@@ -333,9 +354,10 @@ pushd doc
 make SPHINXBUILD=%{sphinx} info
 popd
 
+
 %install
-mkdir -p %{buildroot}/etc/{frr,sysconfig,logrotate.d,pam.d,default} \
-         %{buildroot}/var/log/frr %{buildroot}%{_infodir}
+mkdir -p %{buildroot}%{_sysconfdir}/{frr,sysconfig,logrotate.d,pam.d,default} \
+         %{buildroot}%{_localstatedir}/log/frr %{buildroot}%{_infodir}
 make DESTDIR=%{buildroot} INSTALL="install -p" CP="cp -p" SPHINXBUILD=%{sphinx} install
 
 # Remove this file, as it is uninstalled and causes errors when building on RH9
@@ -344,53 +366,51 @@ rm -rf %{buildroot}/usr/share/info/dir
 # Remove debian init script if it was installed
 rm -f %{buildroot}%{_sbindir}/frr
 
-# kill bogus libtool files for modules
-rm -f %{buildroot}%{_libdir}/frr/modules/*.la
+# kill bogus libtool files
+rm -vf %{buildroot}%{_libdir}/frr/modules/*.la
+rm -vf %{buildroot}%{_libdir}/*.la
 
 # install /etc sources
 %if "%{initsystem}" == "systemd"
 mkdir -p %{buildroot}%{_unitdir}
-install -m644 %{zeb_rh_src}/frr.service \
-    %{buildroot}%{_unitdir}/frr.service
-install %{zeb_rh_src}/frr.init \
-    %{buildroot}%{_sbindir}/frr
-%else
-mkdir -p %{buildroot}/etc/rc.d/init.d
-install %{zeb_rh_src}/frr.init \
-    %{buildroot}%{_sbindir}/frr
-ln -s %{_sbindir}/frr \
-    %{buildroot}/etc/rc.d/init.d/frr
-%endif
-
-install %{zeb_rh_src}/daemons %{buildroot}/etc/frr
-install -m644 %{zeb_rh_src}/frr.pam \
-    %{buildroot}/etc/pam.d/frr
-install -m644 %{zeb_rh_src}/frr.logrotate \
-    %{buildroot}/etc/logrotate.d/frr
-install -d -m750  %{buildroot}/var/run/frr
+install -m644 %{zeb_rh_src}/frr.service %{buildroot}%{_unitdir}/frr.service
+install %{zeb_rh_src}/frr.init %{buildroot}%{_sbindir}/frr
+%else
+mkdir -p %{buildroot}%{_initddir}
+install %{zeb_rh_src}/frr.init %{buildroot}%{_sbindir}/frr
+ln -s %{_sbindir}/frr %{buildroot}%{_initddir}/frr
+%endif
+
+install %{zeb_rh_src}/daemons %{buildroot}%{_sysconfdir}/frr
+# add rpki module to daemon
+%if %{with_rpki}
+    sed -i -e 's/^\(bgpd_options=\)\(.*\)\(".*\)/\1\2 -M rpki\3/' %{buildroot}%{_sysconfdir}/frr/daemons
+%endif
+install -m644 %{zeb_rh_src}/frr.pam %{buildroot}%{_sysconfdir}/pam.d/frr
+install -m644 %{zeb_rh_src}/frr.logrotate %{buildroot}%{_sysconfdir}/logrotate.d/frr
+install -d -m750 %{buildroot}%{rundir}
+
 
 %pre
 # add vty_group
 %if 0%{?vty_group:1}
-if getent group %vty_group > /dev/null ; then : ; else \
- /usr/sbin/groupadd -r -g %vty_gid %vty_group > /dev/null || : ; fi
+    getent group %{vty_group} >/dev/null || groupadd -r -g %{vty_gid} %{vty_group}
 %endif
 
 # add frr user and group
 %if 0%{?frr_user:1}
-# Ensure that frr_gid gets correctly allocated
-if getent group %frr_user >/dev/null; then : ; else \
- /usr/sbin/groupadd -g %frr_gid %frr_user > /dev/null || : ; \
-fi
-if getent passwd %frr_user >/dev/null ; then : ; else \
- /usr/sbin/useradd  -u %frr_uid -g %frr_gid \
-  -M -r -s /sbin/nologin -c "FRRouting suite" \
-  -d %_localstatedir %frr_user 2> /dev/null || : ; \
-fi
-%if 0%{?vty_group:1}
-/usr/sbin/usermod -a -G %vty_group %frr_user
-%endif
+    # Ensure that frr_gid gets correctly allocated
+    getent group %{frr_user} >/dev/null || groupadd -g %{frr_gid} %{frr_user}
+    getent passwd %{frr_user} >/dev/null || \
+    useradd -r -u %{frr_uid} -g %{frr_user} \
+        -s /sbin/nologin -c "FRRouting suite" \
+        -d %{rundir} %{frr_user}
+
+    %if 0%{?vty_group:1}
+        usermod -a -G %{vty_group} %{frr_user}
+    %endif
 %endif
+exit 0
 
 
 %post
@@ -399,100 +419,105 @@ fi
 
 zebra_spec_add_service ()
 {
-    # Add port /etc/services entry if it isn't already there 
-    if [ -f /etc/services ] && \
-        ! %__sed -e 's/#.*$//' /etc/services | %__grep -wq $1 ; then
-        echo "$1        $2          # $3"  >> /etc/services
+    # Add port /etc/services entry if it isn't already there
+    if [ -f %{_sysconfdir}/services ] && \
+        ! %__sed -e 's/#.*$//' %{_sysconfdir}/services | %__grep -wq $1 ; then
+        echo "$1        $2          # $3"  >> %{_sysconfdir}/services
     fi
 }
 
 zebra_spec_add_service zebrasrv 2600/tcp "zebra service"
 zebra_spec_add_service zebra    2601/tcp "zebra vty"
+zebra_spec_add_service staticd  2616/tcp "staticd vty"
 zebra_spec_add_service ripd     2602/tcp "RIPd vty"
 zebra_spec_add_service ripngd   2603/tcp "RIPngd vty"
 zebra_spec_add_service ospfd    2604/tcp "OSPFd vty"
 zebra_spec_add_service bgpd     2605/tcp "BGPd vty"
 zebra_spec_add_service ospf6d   2606/tcp "OSPF6d vty"
+zebra_spec_add_service isisd    2608/tcp "ISISd vty"
 %if %{with_ospfapi}
-zebra_spec_add_service ospfapi  2607/tcp "OSPF-API"
+    zebra_spec_add_service ospfapi  2607/tcp "OSPF-API"
 %endif
-zebra_spec_add_service isisd    2608/tcp "ISISd vty"
 %if %{with_babeld}
-zebra_spec_add_service babeld   2609/tcp "BABELd vty"
+    zebra_spec_add_service babeld   2609/tcp "BABELd vty"
 %endif
 %if %{with_nhrpd}
-zebra_spec_add_service nhrpd    2610/tcp "NHRPd vty"
+    zebra_spec_add_service nhrpd    2610/tcp "NHRPd vty"
 %endif
 %if %{with_pimd}
-zebra_spec_add_service pimd     2611/tcp "PIMd vty"
+    zebra_spec_add_service pimd     2611/tcp "PIMd vty"
 %endif
 %if %{with_pbrd}
-zebra_spec_add_service pbrd     2615/tcp "PBRd vty"
+    zebra_spec_add_service pbrd     2615/tcp "PBRd vty"
 %endif
 %if %{with_ldpd}
-zebra_spec_add_service ldpd     2612/tcp "LDPd vty"
+    zebra_spec_add_service ldpd     2612/tcp "LDPd vty"
 %endif
 %if %{with_eigrpd}
-zebra_spec_add_service eigrpd   2613/tcp "EIGRPd vty"
+    zebra_spec_add_service eigrpd   2613/tcp "EIGRPd vty"
+%endif
+%if %{with_bfdd}
+    zebra_spec_add_service bfdd     2617/tcp "BFDd vty"
 %endif
 
 %if "%{initsystem}" == "systemd"
-for daemon in %all_daemons ; do
-    %systemd_post frr.service
-done
+    for daemon in %all_daemons ; do
+        %systemd_post frr.service
+    done
 %else
-/sbin/chkconfig --add frr
+    /sbin/chkconfig --add frr
 %endif
 
 # Fix bad path in previous config files
 #  Config files won't get replaced by default, so we do this ugly hack to fix it
-%__sed -i 's|/etc/init.d/|%{_sbindir}/|g' %{_sysconfdir}/daemons 2> /dev/null || true
+%__sed -i 's|/etc/init.d/|%{_sbindir}/|g' %{configdir}/daemons 2> /dev/null || true
 
 # With systemd, watchfrr is mandatory. Fix config to make sure it's enabled if
 # we install or upgrade to a frr built with systemd
 %if "%{initsystem}" == "systemd"
-    %__sed -i 's|watchfrr_enable=no|watchfrr_enable=yes|g' %{_sysconfdir}/daemons 2> /dev/null || true
+    %__sed -i 's|watchfrr_enable=no|watchfrr_enable=yes|g' %{configdir}/daemons 2> /dev/null || true
 %endif
 
 /sbin/install-info %{_infodir}/frr.info.gz %{_infodir}/dir
 
 # Create dummy files if they don't exist so basic functions can be used.
-if [ ! -e %{_sysconfdir}/zebra.conf ]; then
-    echo "hostname `hostname`" > %{_sysconfdir}/zebra.conf
+if [ ! -e %{configdir}/zebra.conf ]; then
+    echo "hostname `hostname`" > %{configdir}/zebra.conf
 %if 0%{?frr_user:1}
-    chown %frr_user:%frr_user %{_sysconfdir}/zebra.conf*
+    chown %{frr_user}:%{frr_user} %{configdir}/zebra.conf*
 %endif
-    chmod 640 %{_sysconfdir}/zebra.conf*
+    chmod 640 %{configdir}/zebra.conf*
 fi
 for daemon in %{all_daemons} ; do
     if [ x"${daemon}" != x"" ] ; then
-        if [ ! -e %{_sysconfdir}/${daemon}.conf ]; then
-            touch %{_sysconfdir}/${daemon}.conf
+        if [ ! -e %{configdir}/${daemon}.conf ]; then
+            touch %{configdir}/${daemon}.conf
             %if 0%{?frr_user:1}
-                chown %frr_user:%frr_user %{_sysconfdir}/${daemon}.conf*
+                chown %{frr_user}:%{frr_user} %{configdir}/${daemon}.conf*
             %endif
         fi
     fi
 done
 %if 0%{?frr_user:1}
-    chown %frr_user:%frr_user %{_sysconfdir}/daemons
+    chown %{frr_user}:%{frr_user} %{configdir}/daemons
 %endif
 
 %if %{with_watchfrr}
     # No config for watchfrr - this is part of /etc/sysconfig/frr
-    rm -f %{_sysconfdir}/watchfrr.*
+    rm -f %{configdir}/watchfrr.*
 %endif
 
-if [ ! -e %{_sysconfdir}/vtysh.conf ]; then
-    touch %{_sysconfdir}/vtysh.conf
-    chmod 640 %{_sysconfdir}/vtysh.conf
+if [ ! -e %{configdir}/vtysh.conf ]; then
+    touch %{configdir}/vtysh.conf
+    chmod 640 %{configdir}/vtysh.conf
 %if 0%{?frr_user:1}
-%if 0%{?vty_group:1}
-    chown %{frr_user}:%{vty_group} %{_sysconfdir}/vtysh.conf*
-%endif
+    %if 0%{?vty_group:1}
+        chown %{frr_user}:%{vty_group} %{configdir}/vtysh.conf*
+    %endif
 %endif
 fi
 
+
 %postun
 if [ "$1" -ge 1 ]; then
     #
@@ -507,11 +532,12 @@ if [ "$1" -ge 1 ]; then
         ##
         ## init.d Version
         ##
-        /etc/rc.d/init.d/frr restart >/dev/null 2>&1
+        service frr restart >/dev/null 2>&1
     %endif
     :
 fi
 
+
 %preun
 %if "%{initsystem}" == "systemd"
     ##
@@ -525,37 +551,33 @@ fi
     ## init.d Version
     ##
     if [ $1 -eq 0 ] ; then
-        /etc/rc.d/init.d/frr stop  >/dev/null 2>&1
+        service frr stop  >/dev/null 2>&1
         /sbin/chkconfig --del frr
     fi
 %endif
 /sbin/install-info --delete %{_infodir}/frr.info.gz %{_infodir}/dir
 
-%clean
-%if !0%{?keep_build:1}
-rm -rf %{buildroot}
-%endif
 
 %files
-%defattr(-,root,root)
 %doc */*.sample* AUTHORS COPYING
 %doc doc/mpls
-%doc ChangeLog INSTALL NEWS README REPORTING-BUGS SERVICES
+%doc ChangeLog NEWS README
 %if 0%{?frr_user:1}
-%dir %attr(751,%frr_user,%frr_user) %{_sysconfdir}
-%dir %attr(750,%frr_user,%frr_user) /var/log/frr 
-%dir %attr(751,%frr_user,%frr_user) /var/run/frr
-%else
-%dir %attr(750,root,root) %{_sysconfdir}
-%dir %attr(750,root,root) /var/log/frr
-%dir %attr(750,root,root) /var/run/frr
+    %dir %attr(751,%{frr_user},%{frr_user}) %{configdir}
+    %dir %attr(750,%{frr_user},%{frr_user}) %{_localstatedir}/log/frr
+    %dir %attr(751,%{frr_user},%{frr_user}) %{rundir}
+%else
+    %dir %attr(750,root,root) %{configdir}
+    %dir %attr(750,root,root) %{_localstatedir}/log/frr
+    %dir %attr(750,root,root) %{rundir}
 %endif
 %if 0%{?vty_group:1}
-%attr(750,%frr_user,%vty_group) %{_sysconfdir}/vtysh.conf.sample
+    %attr(750,%{frr_user},%{vty_group}) %{configdir}/vtysh.conf.sample
 %endif
 %{_infodir}/frr.info.gz
 %{_mandir}/man*/*
 %{_sbindir}/zebra
+%{_sbindir}/staticd
 %{_sbindir}/ospfd
 %{_sbindir}/ripd
 %{_sbindir}/bgpd
@@ -584,64 +606,70 @@ rm -rf %{buildroot}
 %if %{with_babeld}
     %{_sbindir}/babeld
 %endif
-%if %{with_shared}
-%{_libdir}/lib*.so
-%{_libdir}/lib*.so.0
-%attr(755,root,root) %{_libdir}/lib*.so.0.*
+%if %{with_bfdd}
+    %{_sbindir}/bfdd
 %endif
+%{_libdir}/lib*.so.0
+%{_libdir}/lib*.so.0.*
 %if %{with_fpm}
-%attr(755,root,root) %{_libdir}/frr/modules/zebra_fpm.so
+    %{_libdir}/frr/modules/zebra_fpm.so
 %endif
 %if %{with_rpki}
-%attr(755,root,root) %{_libdir}/frr/modules/bgpd_rpki.so
+    %{_libdir}/frr/modules/bgpd_rpki.so
 %endif
-%attr(755,root,root) %{_libdir}/frr/modules/zebra_irdp.so
+%{_libdir}/frr/modules/zebra_irdp.so
 %{_bindir}/*
-%config(noreplace) /etc/frr/[!v]*.conf*
-%config(noreplace) %attr(750,%frr_user,%frr_user) /etc/frr/daemons
+%config(noreplace) %{configdir}/[!v]*.conf*
+%config(noreplace) %attr(750,%{frr_user},%{frr_user}) %{configdir}/daemons
 %if "%{initsystem}" == "systemd"
-    %attr(644,root,root) %{_unitdir}/frr.service
-    %{_sbindir}/frr
+    %{_unitdir}/frr.service
 %else
-    /etc/rc.d/init.d/frr
-    %{_sbindir}/frr
+    %{_initddir}/frr
 %endif
-%config(noreplace) /etc/pam.d/frr
-%config(noreplace) %attr(640,root,root) /etc/logrotate.d/*
+%{_sbindir}/frr
+%config(noreplace) %{_sysconfdir}/pam.d/frr
+%config(noreplace) %{_sysconfdir}/logrotate.d/frr
 %{_sbindir}/frr-reload
 
+
 %files contrib
-%defattr(-,root,root)
 %doc tools
 
+
 %files pythontools
-%defattr(-,root,root)
 %{_sbindir}/frr-reload.py
 %{_sbindir}/frr-reload.pyc
 %{_sbindir}/frr-reload.pyo
 
+
 %files devel
-%defattr(-,root,root)
+%{_libdir}/lib*.so
 %if %{with_ospfclient}
-%{_sbindir}/ospfclient
+    %{_sbindir}/ospfclient
 %endif
-%{_libdir}/*.a
-%{_libdir}/*.la
-%dir %attr(755,root,root) %{_includedir}/%{name}
-%{_includedir}/%name/*.h
-%dir %attr(755,root,root) %{_includedir}/%{name}/ospfd
-%{_includedir}/%name/ospfd/*.h
+%dir %{_includedir}/%{name}
+%{_includedir}/%{name}/*.h
+%dir %{_includedir}/%{name}/ospfd
+%{_includedir}/%{name}/ospfd/*.h
 %if %{with_ospfapi}
-%dir %attr(755,root,root) %{_includedir}/%{name}/ospfapi
-%{_includedir}/%name/ospfapi/*.h
+    %dir %{_includedir}/%{name}/ospfapi
+    %{_includedir}/%{name}/ospfapi/*.h
 %endif
 %if %{with_eigrpd}
-%dir %attr(755,root,root) %{_includedir}/%{name}/eigrpd
-%{_includedir}/%name/eigrpd/*.h
+    %dir %{_includedir}/%{name}/eigrpd
+    %{_includedir}/%{name}/eigrpd/*.h
 %endif
 
+
 %changelog
-* Thu Jul  5 2018 Martin Winter <mwinter@opensourcerouting.org> - %{version}
+* Sun Oct  7 2018 Martin Winter <mwinter@opensourcerouting.org> - %{version}
+- Staticd: New daemon responsible for management of static routes
+- ISISd: Implement dst-src routing as per draft-ietf-isis-ipv6-dst-src-routing
+- BFDd: new daemon for BFD (Bidrectional Forwarding Detection). Responsiblei
+  for notifying link changes to make routing protocols converge faster.
+- various bug fixes
+
+* Thu Jul  5 2018 Martin Winter <mwinter@opensourcerouting.org> - 5.0.1
 - Support Automake 1.16.1
 - BGPd: Support for flowspec ICMP, DSCP, packet length, fragment and tcp flags
 - BGPd: fix rpki validation for ipv6
@@ -662,6 +690,9 @@ rm -rf %{buildroot}
 - BGPD: Flowspec
 - PBRD: Add a new Policy Based Routing Daemon
 
+* Sun May 28 2018 Rafael Zalamena <rzalamena@opensourcerouting.org> - %{version}
+- Add BFDd support
+
 * Sun May 20 2018 Martin Winter <mwinter@opensourcerouting.org> - 4.0.1
 - Fixed RPKI RPM build
 
@@ -695,13 +726,13 @@ rm -rf %{buildroot}
 - new subpackage frr-pythontools with python 2.7 restart script
 - remove PIMd from CentOS/RedHat 6 RPM packages (won't work - too old)
 - converted to single frr init script (not per daemon) based on debian init script
-- created systemd service file for systemd based systems (which uses init script) 
+- created systemd service file for systemd based systems (which uses init script)
 - Various other RPM package fixes for FRR 2.0
 
 * Fri Jan  6 2017 Martin Winter <mwinter@opensourcerouting.org>
 - Renamed to frr for FRRouting fork of Quagga
 
-* Thu Feb 11 2016 Paul Jakma <paul@jakma.org> 
+* Thu Feb 11 2016 Paul Jakma <paul@jakma.org>
 - remove with_ipv6 conditionals, always build v6
 - Fix UTF-8 char in spec changelog
 - remove quagga.pam.stack, long deprecated.
@@ -712,7 +743,7 @@ rm -rf %{buildroot}
 - Remove support for old fedora 4/5
 - Fix for package nameing
 - Fix Weekdays of previous changelogs (bogus dates)
-- Add conditional logic to only build tex footnotes with supported texi2html 
+- Add conditional logic to only build tex footnotes with supported texi2html
 - Added pimd to files section and fix double listing of /var/lib*/quagga
 - Numerous fixes to unify upstart/systemd startup into same spec file
 - Only allow use of watchfrr for non-systemd systems. no need with systemd
@@ -805,7 +836,7 @@ rm -rf %{buildroot}
 - walk up tree - 17218
 - ospfd NSSA fixes - 16681
 - ospfd nsm fixes - 16824
-- ospfd OLSA fixes and new feature - 16823 
+- ospfd OLSA fixes and new feature - 16823
 - KAME and ifindex fixes - 16525
 - spec file changes to allow redhat files to be in tree
 
@@ -863,7 +894,7 @@ rm -rf %{buildroot}
 * Tue Feb  6 2001 Tim Powers <timp@redhat.com>
 - built for Powertools
 
-* Sun Feb  4 2001 Pekka Savola <pekkas@netcore.fi> 
+* Sun Feb  4 2001 Pekka Savola <pekkas@netcore.fi>
 - Hacked up from PLD Linux 0.90-1, Mandrake 0.90-1mdk and one from zebra.org.
 - Update to 0.91a
 - Very heavy modifications to init.d/*, .spec, pam, i18n, logrotate, etc.
diff -urpN frr-frr-5.0.1/ripd/rip_errors.c frr-frr-6.0/ripd/rip_errors.c
--- frr-frr-5.0.1/ripd/rip_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/ripd/rip_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ * RIP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "rip_errors.h"
+
+static struct log_ref ferr_rip_err[] = {
+	{
+		.code = RIP_ERR_PACKET,
+		.title = "RIP Packet Error",
+		.description = "RIP has detected a packet encode/decode issue",
+		.suggestion = "Gather log files from both sides and open a Issue"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+
+void rip_error_init(void)
+{
+	log_ref_add(ferr_rip_err);
+}
diff -urpN frr-frr-5.0.1/ripd/rip_errors.h frr-frr-6.0/ripd/rip_errors.h
--- frr-frr-5.0.1/ripd/rip_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/ripd/rip_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * RIP-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __RIP_ERRORS_H__
+#define __RIP_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum rip_log_refs {
+	RIP_ERR_PACKET = RIP_FERR_START,
+	RIP_ERR_CONFIG,
+};
+
+extern void rip_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/ripd/rip_interface.c frr-frr-6.0/ripd/rip_interface.c
--- frr-frr-5.0.1/ripd/rip_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/rip_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "filter.h"
 #include "sockopt.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "zebra/connected.h"
 
@@ -514,14 +515,12 @@ static void rip_interface_reset(struct r
 
 	ri->v2_broadcast = 0;
 
-	if (ri->auth_str) {
-		free(ri->auth_str);
-		ri->auth_str = NULL;
-	}
-	if (ri->key_chain) {
-		free(ri->key_chain);
-		ri->key_chain = NULL;
-	}
+	if (ri->auth_str)
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->auth_str);
+
+	if (ri->key_chain)
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->key_chain);
+
 
 	ri->list[RIP_FILTER_IN] = NULL;
 	ri->list[RIP_FILTER_OUT] = NULL;
@@ -825,7 +824,8 @@ static int rip_enable_if_add(const char
 	if (ret >= 0)
 		return -1;
 
-	vector_set(rip_enable_interface, strdup(ifname));
+	vector_set(rip_enable_interface,
+		   XSTRDUP(MTYPE_RIP_INTERFACE_STRING, ifname));
 
 	rip_enable_apply_all(); /* TODOVJ */
 
@@ -843,7 +843,7 @@ static int rip_enable_if_delete(const ch
 		return -1;
 
 	str = vector_slot(rip_enable_interface, index);
-	free(str);
+	XFREE(MTYPE_RIP_INTERFACE_STRING, str);
 	vector_unset(rip_enable_interface, index);
 
 	rip_enable_apply_all(); /* TODOVJ */
@@ -865,8 +865,9 @@ static int rip_interface_wakeup(struct t
 
 	/* Join to multicast group. */
 	if (rip_multicast_join(ifp, rip->sock) < 0) {
-		zlog_err("multicast join failed, interface %s not running",
-			 ifp->name);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "multicast join failed, interface %s not running",
+			     ifp->name);
 		return 0;
 	}
 
@@ -1062,7 +1063,7 @@ void rip_clean_network()
 	/* rip_enable_interface. */
 	for (i = 0; i < vector_active(rip_enable_interface); i++)
 		if ((str = vector_slot(rip_enable_interface, i)) != NULL) {
-			free(str);
+			XFREE(MTYPE_RIP_INTERFACE_STRING, str);
 			vector_slot(rip_enable_interface, i) = NULL;
 		}
 }
@@ -1110,7 +1111,8 @@ static int rip_passive_nondefault_set(st
 	if (rip_passive_nondefault_lookup(ifname) >= 0)
 		return CMD_WARNING_CONFIG_FAILED;
 
-	vector_set(Vrip_passive_nondefault, strdup(ifname));
+	vector_set(Vrip_passive_nondefault,
+		   XSTRDUP(MTYPE_RIP_INTERFACE_STRING, ifname));
 
 	rip_passive_interface_apply_all();
 
@@ -1127,7 +1129,7 @@ static int rip_passive_nondefault_unset(
 		return CMD_WARNING_CONFIG_FAILED;
 
 	str = vector_slot(Vrip_passive_nondefault, i);
-	free(str);
+	XFREE(MTYPE_RIP_INTERFACE_STRING, str);
 	vector_unset(Vrip_passive_nondefault, i);
 
 	rip_passive_interface_apply_all();
@@ -1143,7 +1145,7 @@ void rip_passive_nondefault_clean(void)
 
 	for (i = 0; i < vector_active(Vrip_passive_nondefault); i++)
 		if ((str = vector_slot(Vrip_passive_nondefault, i)) != NULL) {
-			free(str);
+			XFREE(MTYPE_RIP_INTERFACE_STRING, str);
 			vector_slot(Vrip_passive_nondefault, i) = NULL;
 		}
 	rip_passive_interface_apply_all();
@@ -1529,9 +1531,9 @@ DEFUN (ip_rip_authentication_string,
 	}
 
 	if (ri->auth_str)
-		free(ri->auth_str);
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->auth_str);
 
-	ri->auth_str = strdup(argv[idx_line]->arg);
+	ri->auth_str = XSTRDUP(MTYPE_RIP_INTERFACE_STRING, argv[idx_line]->arg);
 
 	return CMD_SUCCESS;
 }
@@ -1552,9 +1554,7 @@ DEFUN (no_ip_rip_authentication_string,
 	ri = ifp->info;
 
 	if (ri->auth_str)
-		free(ri->auth_str);
-
-	ri->auth_str = NULL;
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->auth_str);
 
 	return CMD_SUCCESS;
 }
@@ -1581,9 +1581,10 @@ DEFUN (ip_rip_authentication_key_chain,
 	}
 
 	if (ri->key_chain)
-		free(ri->key_chain);
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->key_chain);
 
-	ri->key_chain = strdup(argv[idx_line]->arg);
+	ri->key_chain =
+		XSTRDUP(MTYPE_RIP_INTERFACE_STRING, argv[idx_line]->arg);
 
 	return CMD_SUCCESS;
 }
@@ -1604,9 +1605,7 @@ DEFUN (no_ip_rip_authentication_key_chai
 	ri = ifp->info;
 
 	if (ri->key_chain)
-		free(ri->key_chain);
-
-	ri->key_chain = NULL;
+		XFREE(MTYPE_RIP_INTERFACE_STRING, ri->key_chain);
 
 	return CMD_SUCCESS;
 }
diff -urpN frr-frr-5.0.1/ripd/rip_main.c frr-frr-6.0/ripd/rip_main.c
--- frr-frr-5.0.1/ripd/rip_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/rip_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,8 +37,12 @@
 #include "libfrr.h"
 
 #include "ripd/ripd.h"
+#include "ripd/rip_errors.h"
 
 /* ripd options. */
+#if CONFDATE > 20190521
+	CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
 static struct option longopts[] = {{"retain", no_argument, NULL, 'r'}, {0}};
 
 /* ripd privileges */
@@ -58,9 +62,6 @@ struct zebra_privs_t ripd_privs = {
 	.cap_num_p = 2,
 	.cap_num_i = 0};
 
-/* Route retain mode flag. */
-int retain_mode = 0;
-
 /* Master of threads. */
 struct thread_master *master;
 
@@ -85,8 +86,7 @@ static void sigint(void)
 {
 	zlog_notice("Terminating on signal");
 
-	if (!retain_mode)
-		rip_clean();
+	rip_clean();
 
 	rip_zclient_stop();
 	frr_fini();
@@ -127,13 +127,17 @@ FRR_DAEMON_INFO(ripd, RIP, .vty_port = R
 
 		.privs = &ripd_privs, )
 
+#if CONFDATE > 20190521
+CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
+#define DEPRECATED_OPTIONS "r"
+
 /* Main routine of ripd. */
 int main(int argc, char **argv)
 {
 	frr_preinit(&ripd_di, argc, argv);
-	frr_opt_add(
-		"r", longopts,
-		"  -r, --retain       When program terminates, retain added route by ripd.\n");
+
+	frr_opt_add("" DEPRECATED_OPTIONS, longopts, "");
 
 	/* Command line option parse. */
 	while (1) {
@@ -141,15 +145,19 @@ int main(int argc, char **argv)
 
 		opt = frr_getopt(argc, argv, NULL);
 
+		if (opt && opt < 128 && strchr(DEPRECATED_OPTIONS, opt)) {
+			fprintf(stderr,
+				"The -%c option no longer exists.\nPlease refer to the manual.\n",
+				opt);
+			continue;
+		}
+
 		if (opt == EOF)
 			break;
 
 		switch (opt) {
 		case 0:
 			break;
-		case 'r':
-			retain_mode = 1;
-			break;
 		default:
 			frr_help_exit(1);
 			break;
@@ -160,6 +168,7 @@ int main(int argc, char **argv)
 	master = frr_init();
 
 	/* Library initialization. */
+	rip_error_init();
 	keychain_init();
 	vrf_init(NULL, NULL, NULL, NULL);
 
diff -urpN frr-frr-5.0.1/ripd/rip_memory.c frr-frr-6.0/ripd/rip_memory.c
--- frr-frr-5.0.1/ripd/rip_memory.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/rip_memory.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,6 +29,7 @@ DEFINE_MGROUP(RIPD, "ripd")
 DEFINE_MTYPE(RIPD, RIP, "RIP structure")
 DEFINE_MTYPE(RIPD, RIP_INFO, "RIP route info")
 DEFINE_MTYPE(RIPD, RIP_INTERFACE, "RIP interface")
+DEFINE_MTYPE(RIPD, RIP_INTERFACE_STRING, "RIP Interface String")
 DEFINE_MTYPE(RIPD, RIP_PEER, "RIP peer")
 DEFINE_MTYPE(RIPD, RIP_OFFSET_LIST, "RIP offset list")
 DEFINE_MTYPE(RIPD, RIP_DISTANCE, "RIP distance")
diff -urpN frr-frr-5.0.1/ripd/rip_memory.h frr-frr-6.0/ripd/rip_memory.h
--- frr-frr-5.0.1/ripd/rip_memory.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/rip_memory.h	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@ DECLARE_MGROUP(RIPD)
 DECLARE_MTYPE(RIP)
 DECLARE_MTYPE(RIP_INFO)
 DECLARE_MTYPE(RIP_INTERFACE)
+DECLARE_MTYPE(RIP_INTERFACE_STRING)
 DECLARE_MTYPE(RIP_PEER)
 DECLARE_MTYPE(RIP_OFFSET_LIST)
 DECLARE_MTYPE(RIP_DISTANCE)
diff -urpN frr-frr-5.0.1/ripd/rip_routemap.c frr-frr-6.0/ripd/rip_routemap.c
--- frr-frr-5.0.1/ripd/rip_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/rip_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -58,7 +58,8 @@ static void rip_route_map_update(const c
 
 /* `match metric METRIC' */
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_metric(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -111,7 +112,7 @@ struct route_map_rule_cmd route_match_me
 /* `match interface IFNAME' */
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_interface(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -159,7 +160,7 @@ struct route_map_rule_cmd route_match_in
 
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_ip_next_hop(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -206,7 +207,7 @@ static struct route_map_rule_cmd route_m
 /* `match ip next-hop prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_next_hop_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_next_hop_prefix_list(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -251,7 +252,7 @@ static struct route_map_rule_cmd route_m
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_ip_address(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -290,7 +291,7 @@ static struct route_map_rule_cmd route_m
 /* `match ip address prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_address_prefix_list(void *rule, const struct prefix *prefix,
 				   route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -324,7 +325,7 @@ static struct route_map_rule_cmd route_m
 
 /* `match tag TAG' */
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_tag(void *rule, const struct prefix *p,
 					  route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -354,7 +355,8 @@ static struct route_map_rule_cmd route_m
 /* `set metric METRIC' */
 
 /* Set metric to attribute. */
-static route_map_result_t route_set_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_metric(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -453,7 +455,7 @@ static struct route_map_rule_cmd route_s
 
 /* Set nexthop to object.  ojbect must be pointer to struct attr. */
 static route_map_result_t route_set_ip_nexthop(void *rule,
-					       struct prefix *prefix,
+					       const struct prefix *prefix,
 					       route_map_object_t type,
 					       void *object)
 {
@@ -505,7 +507,7 @@ static struct route_map_rule_cmd route_s
 /* `set tag TAG' */
 
 /* Set tag to object.  ojbect must be pointer to struct attr. */
-static route_map_result_t route_set_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_tag(void *rule, const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
diff -urpN frr-frr-5.0.1/ripd/ripd.c frr-frr-6.0/ripd/ripd.c
--- frr-frr-5.0.1/ripd/ripd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/ripd.c	2018-10-08 14:32:57.000000000 +0200
@@ -40,9 +40,11 @@
 #include "md5.h"
 #include "keychain.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "ripd/ripd.h"
 #include "ripd/rip_debug.h"
+#include "ripd/rip_errors.h"
 
 DEFINE_QOBJ_TYPE(rip)
 
@@ -799,11 +801,11 @@ static int rip_auth_simple_password(stru
 				    struct interface *ifp)
 {
 	struct rip_interface *ri;
-	char *auth_str = (char *)&rte->prefix;
+	char *auth_str = (char *)rte + offsetof(struct rte, prefix);
 	int i;
 
 	/* reject passwords with zeros in the middle of the string */
-	for (i = strlen(auth_str); i < 16; i++) {
+	for (i = strnlen(auth_str, 16); i < 16; i++) {
 		if (auth_str[i] != '\0')
 			return 0;
 	}
@@ -828,7 +830,7 @@ static int rip_auth_simple_password(stru
 		struct key *key;
 
 		keychain = keychain_lookup(ri->key_chain);
-		if (keychain == NULL)
+		if (keychain == NULL || keychain->key == NULL)
 			return 0;
 
 		key = key_match_for_accept(keychain, auth_str);
@@ -902,7 +904,7 @@ static int rip_auth_md5(struct rip_packe
 			return 0;
 
 		key = key_lookup_for_accept(keychain, md5->keyid);
-		if (key == NULL)
+		if (key == NULL || key->string == NULL)
 			return 0;
 
 		strncpy(auth_str, key->string, RIP_AUTH_MD5_SIZE);
@@ -1056,9 +1058,9 @@ static void rip_auth_md5_set(struct stre
 
 	/* Check packet length. */
 	if (len < (RIP_HEADER_SIZE + RIP_RTE_SIZE)) {
-		zlog_err(
-			"rip_auth_md5_set(): packet length %ld is less than minimum length.",
-			len);
+		flog_err(RIP_ERR_PACKET,
+			  "rip_auth_md5_set(): packet length %ld is less than minimum length.",
+			  len);
 		return;
 	}
 
@@ -1339,7 +1341,8 @@ static int rip_create_socket(void)
 	/* Make datagram socket. */
 	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (sock < 0) {
-		zlog_err("Cannot create UDP socket: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "Cannot create UDP socket: %s",
+			     safe_strerror(errno));
 		exit(1);
 	}
 
@@ -1354,27 +1357,20 @@ static int rip_create_socket(void)
 	setsockopt_ipv4_tos(sock, IPTOS_PREC_INTERNETCONTROL);
 #endif
 
-	if (ripd_privs.change(ZPRIVS_RAISE))
-		zlog_err("rip_create_socket: could not raise privs");
-	setsockopt_so_recvbuf(sock, RIP_UDP_RCV_BUF);
-	if ((ret = bind(sock, (struct sockaddr *)&addr, sizeof(addr))) < 0)
-
-	{
-		int save_errno = errno;
-		if (ripd_privs.change(ZPRIVS_LOWER))
-			zlog_err("rip_create_socket: could not lower privs");
-
-		zlog_err("%s: Can't bind socket %d to %s port %d: %s", __func__,
-			 sock, inet_ntoa(addr.sin_addr),
-			 (int)ntohs(addr.sin_port), safe_strerror(save_errno));
+	frr_elevate_privs(&ripd_privs) {
+		setsockopt_so_recvbuf(sock, RIP_UDP_RCV_BUF);
+		if ((ret = bind(sock, (struct sockaddr *)&addr, sizeof(addr)))
+		    < 0) {
+			zlog_err("%s: Can't bind socket %d to %s port %d: %s",
+				 __func__, sock, inet_ntoa(addr.sin_addr),
+				 (int)ntohs(addr.sin_port),
+				 safe_strerror(errno));
 
-		close(sock);
-		return ret;
+			close(sock);
+			return ret;
+		}
 	}
 
-	if (ripd_privs.change(ZPRIVS_LOWER))
-		zlog_err("rip_create_socket: could not lower privs");
-
 	return sock;
 }
 
@@ -1641,7 +1637,7 @@ static void rip_request_process(struct r
 		}
 		packet->command = RIP_RESPONSE;
 
-		rip_send_packet((uint8_t *)packet, size, from, ifc);
+		(void)rip_send_packet((uint8_t *)packet, size, from, ifc);
 	}
 	rip_global_queries++;
 }
@@ -2101,6 +2097,8 @@ void rip_output_process(struct connected
 		/* to be passed to auth functions later */
 		rip_auth_prepare_str_send(ri, key, auth_str,
 					  RIP_AUTH_SIMPLE_SIZE);
+		if (strlen(auth_str) == 0)
+			return;
 	}
 
 	if (version == RIPv1) {
@@ -2810,6 +2808,7 @@ DEFUN_NOSH (router_rip,
 			return CMD_WARNING_CONFIG_FAILED;
 		}
 	}
+
 	VTY_PUSH_CONTEXT(RIP_NODE, rip);
 
 	return CMD_SUCCESS;
diff -urpN frr-frr-5.0.1/ripd/subdir.am frr-frr-6.0/ripd/subdir.am
--- frr-frr-5.0.1/ripd/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -13,6 +13,7 @@ endif
 
 ripd_librip_a_SOURCES = \
 	ripd/rip_debug.c \
+	ripd/rip_errors.c \
 	ripd/rip_interface.c \
 	ripd/rip_memory.c \
 	ripd/rip_offset.c \
@@ -24,6 +25,7 @@ ripd_librip_a_SOURCES = \
 
 noinst_HEADERS += \
 	ripd/rip_debug.h \
+	ripd/rip_errors.h \
 	ripd/rip_interface.h \
 	ripd/rip_memory.h \
 	ripd/ripd.h \
@@ -35,7 +37,7 @@ ripd_ripd_SOURCES = \
 	# end
 
 ripd_ripd_snmp_la_SOURCES = ripd/rip_snmp.c
-ripd_ripd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+ripd_ripd_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 ripd_ripd_snmp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 ripd_ripd_snmp_la_LIBADD = lib/libfrrsnmp.la
 
diff -urpN frr-frr-5.0.1/ripngd/ripng_interface.c frr-frr-6.0/ripngd/ripng_interface.c
--- frr-frr-5.0.1/ripngd/ripng_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripngd/ripng_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "thread.h"
 #include "privs.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "ripngd/ripngd.h"
 #include "ripngd/ripng_debug.h"
@@ -71,15 +72,14 @@ static int ripng_multicast_join(struct i
 		 * While this is bogus, privs are available and easy to use
 		 * for this call as a workaround.
 		 */
-		if (ripngd_privs.change(ZPRIVS_RAISE))
-			zlog_err("ripng_multicast_join: could not raise privs");
+		frr_elevate_privs(&ripngd_privs) {
 
-		ret = setsockopt(ripng->sock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
-				 (char *)&mreq, sizeof(mreq));
-		save_errno = errno;
+			ret = setsockopt(ripng->sock, IPPROTO_IPV6,
+					 IPV6_JOIN_GROUP,
+					 (char *)&mreq, sizeof(mreq));
+			save_errno = errno;
 
-		if (ripngd_privs.change(ZPRIVS_LOWER))
-			zlog_err("ripng_multicast_join: could not lower privs");
+		}
 
 		if (ret < 0 && save_errno == EADDRINUSE) {
 			/*
@@ -492,7 +492,7 @@ static int ripng_enable_network_lookup_i
 
 	for (ALL_LIST_ELEMENTS_RO(ifp->connected, node, connected)) {
 		struct prefix *p;
-		struct route_node *node;
+		struct route_node *n;
 
 		p = connected->address;
 
@@ -501,10 +501,10 @@ static int ripng_enable_network_lookup_i
 			address.prefix = p->u.prefix6;
 			address.prefixlen = IPV6_MAX_BITLEN;
 
-			node = route_node_match(ripng_enable_network,
-						(struct prefix *)&address);
-			if (node) {
-				route_unlock_node(node);
+			n = route_node_match(ripng_enable_network,
+					     (struct prefix *)&address);
+			if (n) {
+				route_unlock_node(n);
 				return 1;
 			}
 		}
@@ -642,8 +642,9 @@ static int ripng_interface_wakeup(struct
 
 	/* Join to multicast group. */
 	if (ripng_multicast_join(ifp) < 0) {
-		zlog_err("multicast join failed, interface %s not running",
-			 ifp->name);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "multicast join failed, interface %s not running",
+			     ifp->name);
 		return 0;
 	}
 
diff -urpN frr-frr-5.0.1/ripngd/ripng_main.c frr-frr-6.0/ripngd/ripng_main.c
--- frr-frr-5.0.1/ripngd/ripng_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripngd/ripng_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -40,6 +40,9 @@
 #include "ripngd/ripngd.h"
 
 /* RIPngd options. */
+#if CONFDATE > 20190521
+	CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
 struct option longopts[] = {{"retain", no_argument, NULL, 'r'}, {0}};
 
 /* ripngd privileges */
@@ -60,11 +63,6 @@ struct zebra_privs_t ripngd_privs = {
 	.cap_num_i = 0};
 
 
-/* RIPngd program name */
-
-/* Route retain mode flag. */
-int retain_mode = 0;
-
 /* Master of threads. */
 struct thread_master *master;
 
@@ -88,8 +86,7 @@ static void sigint(void)
 {
 	zlog_notice("Terminating on signal");
 
-	if (!retain_mode)
-		ripng_clean();
+	ripng_clean();
 
 	ripng_zebra_stop();
 	frr_fini();
@@ -130,28 +127,36 @@ FRR_DAEMON_INFO(ripngd, RIPNG, .vty_port
 
 		.privs = &ripngd_privs, )
 
+#if CONFDATE > 20190521
+CPP_NOTICE("-r / --retain has reached deprecation EOL, remove")
+#endif
+#define DEPRECATED_OPTIONS "r"
+
 /* RIPngd main routine. */
 int main(int argc, char **argv)
 {
 	frr_preinit(&ripngd_di, argc, argv);
-	frr_opt_add(
-		"r", longopts,
-		"  -r, --retain       When program terminates, retain added route by ripd.\n");
+
+	frr_opt_add("" DEPRECATED_OPTIONS, longopts, "");
 
 	while (1) {
 		int opt;
 
 		opt = frr_getopt(argc, argv, NULL);
 
+		if (opt && opt < 128 && strchr(DEPRECATED_OPTIONS, opt)) {
+			fprintf(stderr,
+				"The -%c option no longer exists.\nPlease refer to the manual.\n",
+				opt);
+			continue;
+		}
+
 		if (opt == EOF)
 			break;
 
 		switch (opt) {
 		case 0:
 			break;
-		case 'r':
-			retain_mode = 1;
-			break;
 		default:
 			frr_help_exit(1);
 			break;
diff -urpN frr-frr-5.0.1/ripngd/ripng_routemap.c frr-frr-6.0/ripngd/ripng_routemap.c
--- frr-frr-5.0.1/ripngd/ripng_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripngd/ripng_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,7 +38,8 @@ struct rip_metric_modifier {
 
 /* `match metric METRIC' */
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_metric(void *rule,
+					     const struct prefix *prefix,
 					     route_map_object_t type,
 					     void *object)
 {
@@ -86,7 +87,7 @@ static struct route_map_rule_cmd route_m
 /* `match interface IFNAME' */
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_interface(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -128,7 +129,8 @@ static struct route_map_rule_cmd route_m
 
 /* `match tag TAG' */
 /* Match function return 1 if match is success else return zero. */
-static route_map_result_t route_match_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_tag(void *rule,
+					  const struct prefix *prefix,
 					  route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -157,7 +159,8 @@ static struct route_map_rule_cmd route_m
 /* `set metric METRIC' */
 
 /* Set metric to attribute. */
-static route_map_result_t route_set_metric(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_metric(void *rule,
+					   const struct prefix *prefix,
 					   route_map_object_t type,
 					   void *object)
 {
@@ -254,7 +257,7 @@ static struct route_map_rule_cmd route_s
 
 /* Set nexthop to object.  ojbect must be pointer to struct attr. */
 static route_map_result_t route_set_ipv6_nexthop_local(void *rule,
-						       struct prefix *prefix,
+						       const struct prefix *p,
 						       route_map_object_t type,
 						       void *object)
 {
@@ -307,7 +310,8 @@ static struct route_map_rule_cmd route_s
 /* `set tag TAG' */
 
 /* Set tag to object.  ojbect must be pointer to struct attr. */
-static route_map_result_t route_set_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_tag(void *rule,
+					const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
diff -urpN frr-frr-5.0.1/ripngd/ripngd.c frr-frr-6.0/ripngd/ripngd.c
--- frr-frr-5.0.1/ripngd/ripngd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/ripngd/ripngd.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "routemap.h"
 #include "if_rmap.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "ripngd/ripngd.h"
 #include "ripngd/ripng_route.h"
@@ -94,7 +95,7 @@ static int ripng_make_socket(void)
 
 	sock = socket(AF_INET6, SOCK_DGRAM, 0);
 	if (sock < 0) {
-		zlog_err("Can't make ripng socket");
+		flog_err_sys(LIB_ERR_SOCKET, "Can't make ripng socket");
 		return sock;
 	}
 
@@ -124,18 +125,14 @@ static int ripng_make_socket(void)
 #endif /* SIN6_LEN */
 	ripaddr.sin6_port = htons(RIPNG_PORT_DEFAULT);
 
-	if (ripngd_privs.change(ZPRIVS_RAISE))
-		zlog_err("ripng_make_socket: could not raise privs");
-
-	ret = bind(sock, (struct sockaddr *)&ripaddr, sizeof(ripaddr));
-	if (ret < 0) {
-		zlog_err("Can't bind ripng socket: %s.", safe_strerror(errno));
-		if (ripngd_privs.change(ZPRIVS_LOWER))
-			zlog_err("ripng_make_socket: could not lower privs");
-		goto error;
+	frr_elevate_privs(&ripngd_privs) {
+		ret = bind(sock, (struct sockaddr *)&ripaddr, sizeof(ripaddr));
+		if (ret < 0) {
+			zlog_err("Can't bind ripng socket: %s.",
+				 safe_strerror(errno));
+			goto error;
+		}
 	}
-	if (ripngd_privs.change(ZPRIVS_LOWER))
-		zlog_err("ripng_make_socket: could not lower privs");
 	return sock;
 
 error:
@@ -202,12 +199,14 @@ int ripng_send_packet(caddr_t buf, int b
 
 	if (ret < 0) {
 		if (to)
-			zlog_err("RIPng send fail on %s to %s: %s", ifp->name,
-				 inet6_ntoa(to->sin6_addr),
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET,
+				     "RIPng send fail on %s to %s: %s",
+				     ifp->name, inet6_ntoa(to->sin6_addr),
+				     safe_strerror(errno));
 		else
-			zlog_err("RIPng send fail on %s: %s", ifp->name,
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SOCKET,
+				     "RIPng send fail on %s: %s", ifp->name,
+				     safe_strerror(errno));
 	}
 
 	return ret;
@@ -246,7 +245,7 @@ static int ripng_recv_packet(int sock, u
 	if (ret < 0)
 		return ret;
 
-	for (cmsgptr = ZCMSG_FIRSTHDR(&msg); cmsgptr != NULL;
+	for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;
 	     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {
 		/* I want interface index which this packet comes from. */
 		if (cmsgptr->cmsg_level == IPPROTO_IPV6
@@ -1516,9 +1515,10 @@ int ripng_write_rte(int num, struct stre
 	}
 
 	/* Write routing table entry. */
-	if (!nexthop)
+	if (!nexthop) {
+		assert(p);
 		stream_write(s, (uint8_t *)&p->prefix, sizeof(struct in6_addr));
-	else
+	} else
 		stream_write(s, (uint8_t *)nexthop, sizeof(struct in6_addr));
 	stream_putw(s, tag);
 	if (p)
diff -urpN frr-frr-5.0.1/sharpd/sharp_main.c frr-frr-6.0/sharpd/sharp_main.c
--- frr-frr-5.0.1/sharpd/sharp_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/sharpd/sharp_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -51,7 +51,6 @@ uint32_t installed_routes = 0;
 uint32_t removed_routes = 0;
 
 zebra_capabilities_t _caps_p[] = {
-	ZCAP_NET_RAW, ZCAP_BIND, ZCAP_NET_ADMIN,
 };
 
 struct zebra_privs_t sharp_privs = {
@@ -149,6 +148,7 @@ int main(int argc, char **argv, char **e
 
 	vrf_init(NULL, NULL, NULL, NULL);
 
+	access_list_init();
 	route_map_init();
 
 	sharp_zebra_init();
diff -urpN frr-frr-5.0.1/snapcraft/README.usage.md frr-frr-6.0/snapcraft/README.usage.md
--- frr-frr-5.0.1/snapcraft/README.usage.md	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/snapcraft/README.usage.md	2018-10-08 14:32:57.000000000 +0200
@@ -18,7 +18,7 @@ ie for `ospf6d` (OSPFv3):
     systemctl enable snap.frr.ospf6d.service
 
 The daemons are: `ripd`, `ripngd`, `ospfd`, `ospf6d`, `isisd`, `bgpd`, 
-`pimd`, `zebra`
+`pimd`, `ldpd`, `eigrpd`, `babeld`, `nhrpd`, `bfdd`, `zebra`
 
 Commands defined by this snap
 -----------------------------
@@ -31,7 +31,7 @@ Commands defined by this snap
 - `frr.readme`:
 	Returns this document `cat README_usage.md`
 - `frr.set`:
-	Allows to enable `FPM` module. See FPM section below
+	Allows to enable `FPM` and/or disable RPKIi module. See Module section below
 
 and for debugging defined at this time (May get removed later - do not 
 depend on them). These are mainly intended to debug the Snap
@@ -53,7 +53,19 @@ depend on them). These are mainly intend
 - `frr.pimd-debug`:
 	Starts pimd daemon in foreground
 - `frr.ldpd-debug`:
-    Starts ldpd daemon in foreground
+        Starts ldpd daemon in foreground
+- `frr.nhrpd-debug`:
+        Starts nhrpd daemon in foreground
+- `frr.babeld-debug`:
+        Starts babeld daemon in foreground
+- `frr.eigrpd-debug`:
+        Starts eigrpd daemon in foreground
+- `frr.pbrd-debug`:
+        Starts pbrd daemon in foreground
+- `frr.staticd-debug`:
+        Starts staticd daemon in foreground
+- `frr.bfdd-debug`:
+        Starts bfdd daemon in foreground
 
 MPLS (LDP)
 ----------
@@ -88,13 +100,13 @@ are named `eth0`, `eth1` and `eth2`, the
 These settings require either a reboot or a manual configuration with
 `sysctl` as well.
 
-FPM Module
+Modules
 ----------
-The `frr.set` allows to turn FPM module on or off.
+The `frr.set` allows to turn FPM module ond the RPKI module on or off.
 
     frr.set fpm {disable|protobuf|netlink}
     
-    Disables FPM or enables FPM with selected mode
+    Disables FPM or enables FPM with selected mode (default: disabled)
 
 By default, the FPM module is disabled, but installed with netlink and
 protobuf support. To enable the FPM module, use the `frr.set fpm protobuf`
@@ -102,13 +114,24 @@ or `frr.set fpm netlink` command. The co
 for the next restart of zebra. Please reboot or restart zebra after
 changing the mode to become effective.
 
+    frr.set rpki {enable|disable}
+   
+    Disables or enables BGP RPKI (default: enabled)
+
+By default, the RPKI module is enabled. To disable the RPKI module
+use the `frr.set rpki disable` command. The command will only enable
+the module after the next restart of the bgp daemon. Please reboot or 
+restart bgpd after changing the mode to become effective.
+(Normally, there is no need to disable the module as it has no effect
+if there are no RPKI configurations in BGP)
+
 FAQ
 ---
 - frr.vtysh displays `--MORE--` on long output. How to suppress this?
     - Define `VTYSH_PAGER` to `cat` (default is `more`). (Ie add 
       `export VTYSH_PAGER=cat` to the end of your `.profile`)
 
-- ospfd / ospf6d are not running after installation
+- bfdd / ospfd / ospf6d / nhrpd are not running after installation
     - Installing a new snap starts the daemons, but at this time they
       may not have the required privileged access. Make sure you 
       issue the `snap connect` command as given above (can be verified
diff -urpN frr-frr-5.0.1/snapcraft/scripts/Makefile frr-frr-6.0/snapcraft/scripts/Makefile
--- frr-frr-5.0.1/snapcraft/scripts/Makefile	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/snapcraft/scripts/Makefile	2018-10-08 14:32:57.000000000 +0200
@@ -15,6 +15,8 @@ install:
 	install -D -m 0755 babeld-service $(DESTDIR)/bin/
 	install -D -m 0755 eigrpd-service $(DESTDIR)/bin/
 	install -D -m 0755 pbrd-service $(DESTDIR)/bin/
+	install -D -m 0755 staticd-service $(DESTDIR)/bin/
+	install -D -m 0755 bfdd-service $(DESTDIR)/bin/
 	install -D -m 0755 set-options $(DESTDIR)/bin/
 	install -D -m 0755 show_version $(DESTDIR)/bin/
 
diff -urpN frr-frr-5.0.1/snapcraft/scripts/bfdd-service frr-frr-6.0/snapcraft/scripts/bfdd-service
--- frr-frr-5.0.1/snapcraft/scripts/bfdd-service	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/snapcraft/scripts/bfdd-service	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+set -e -x
+
+if ! [ -e $SNAP_DATA/bfdd.conf ]; then
+    cp $SNAP/etc/frr/bfdd.conf.default $SNAP_DATA/bfdd.conf
+fi
+exec $SNAP/sbin/bfdd \
+    -f $SNAP_DATA/bfdd.conf \
+    --pid_file $SNAP_DATA/bfdd.pid \
+    --socket $SNAP_DATA/zsock \
+    --vty_socket $SNAP_DATA \
+    --bfdctl $SNAP_DATA/bfdd.sock
+
diff -urpN frr-frr-5.0.1/snapcraft/scripts/bgpd-service frr-frr-6.0/snapcraft/scripts/bgpd-service
--- frr-frr-5.0.1/snapcraft/scripts/bgpd-service	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/snapcraft/scripts/bgpd-service	2018-10-08 14:32:57.000000000 +0200
@@ -5,9 +5,16 @@ set -e -x
 if ! [ -e $SNAP_DATA/bgpd.conf ]; then
     cp $SNAP/etc/frr/bgpd.conf.default $SNAP_DATA/bgpd.conf
 fi
+# If no RPKI option is specified, then we create a default
+# with RPKI enabled
+if ! [ -e $SNAP_DATA/rpki.conf ]; then
+    echo "-M rpki" > $SNAP_DATA/rpki.conf
+fi
+EXTRA_OPTIONS="`cat $SNAP_DATA/rpki.conf`"
 exec $SNAP/sbin/bgpd \
     -f $SNAP_DATA/bgpd.conf \
     --pid_file $SNAP_DATA/bgpd.pid \
     --socket $SNAP_DATA/zsock \
-    --vty_socket $SNAP_DATA
+    --vty_socket $SNAP_DATA \
+    --moduledir $SNAP/lib/frr/modules $EXTRA_OPTIONS
 
diff -urpN frr-frr-5.0.1/snapcraft/scripts/set-options frr-frr-6.0/snapcraft/scripts/set-options
--- frr-frr-5.0.1/snapcraft/scripts/set-options	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/snapcraft/scripts/set-options	2018-10-08 14:32:57.000000000 +0200
@@ -28,11 +28,34 @@ case $1 in
                 ;;
         esac
         ;;
+    rpki)
+        case $2 in
+            disable)
+                echo "" > $SNAP_DATA/rpki.conf
+                echo "RPKI module disabled. Please restart FRR"
+                ;;
+            enable)
+                echo "-M rpki" > $SNAP_DATA/rpki.conf
+                echo "RPKI module enabled. Please restart FRR"
+                ;;
+            *)
+                echo "Usage:"
+                echo "    ${SNAP_NAME}.set rpki {disable|enable}"
+                echo ""
+                echo "    Disables BGP RPKI module or enables it (default: enabled)"
+                echo "    Mode will be saved for next restart of bgpd, but bgpd"
+                echo "    is not automatically restarted"
+                exit 1
+                ;;
+        esac
+        ;;
     *)
         echo "Usage:"
         echo "    ${SNAP_NAME}.set fpm {disable|protobuf|netlink}"
+        echo "    ${SNAP_NAME}.set rpki {disable|enable}"
         echo ""
-        echo "    Disables FPM or enables FPM with selected mode"
+        echo "    fpm: Disables FPM or enables FPM with selected mode"
+        echo "    rpki: Disables BGP RPKI or enables it (default: enabled)"
         exit 1
         ;;
 esac
diff -urpN frr-frr-5.0.1/snapcraft/scripts/staticd-service frr-frr-6.0/snapcraft/scripts/staticd-service
--- frr-frr-5.0.1/snapcraft/scripts/staticd-service	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/snapcraft/scripts/staticd-service	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+set -e -x
+
+if ! [ -e $SNAP_DATA/staticd.conf ]; then
+    if [ -e $SNAP_DATA/zebra.conf ]; then
+        # if we have a zebra.conf, but no staticd conf, then we use
+        # this file as the default config for staticd
+        cp $SNAP_DATA/zebra.conf $SNAP_DATA/staticd.conf
+    else
+        # new config, start with template
+        cp $SNAP/etc/frr/staticd.conf $SNAP_DATA/staticd.conf
+    fi
+fi
+exec $SNAP/sbin/staticd \
+    -f $SNAP_DATA/staticd.conf \
+    --pid_file $SNAP_DATA/staticd.pid \
+    --socket $SNAP_DATA/zsock \
+    --vty_socket $SNAP_DATA
+
diff -urpN frr-frr-5.0.1/snapcraft/snapcraft.yaml.in frr-frr-6.0/snapcraft/snapcraft.yaml.in
--- frr-frr-5.0.1/snapcraft/snapcraft.yaml.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/snapcraft/snapcraft.yaml.in	2018-10-08 14:32:57.000000000 +0200
@@ -1,10 +1,10 @@
 name: frr
 version: @VERSION@
-summary: FRRouting BGP/OSPFv2/OSPFv3/ISIS/RIP/RIPng/PIM/LDP routing daemon
-description: BGP/OSPFv2/OSPFv3/ISIS/RIP/RIPng/PIM routing daemon
+summary: FRRouting BGP/OSPFv2/OSPFv3/ISIS/RIP/RIPng/PIM/LDP/EIGRP/BFD routing daemon
+description: BGP/OSPFv2/OSPFv3/ISIS/RIP/RIPng/PIM/LDP/EIGRP/BFD routing daemon
  FRRouting (FRR) is free software which manages TCP/IP based routing 
  protocols. It supports BGP4, BGP4+, OSPFv2, OSPFv3, IS-IS, RIPv1, RIPv2, 
- RIPng, PIM, LDP, Babel, EIGRP and PBR (Policy-based routing) as well as
+ RIPng, PIM, LDP, Babel, EIGRP, PBR (Policy-based routing) and BFD as well as
  the IPv6 versions of these.
  FRRouting (frr) is a fork of Quagga.
 confinement: strict
@@ -113,6 +113,20 @@ apps:
             - network
             - network-bind
             - network-control
+    staticd:
+        command: bin/staticd-service
+        daemon: simple
+        plugs:
+            - network
+            - network-bind
+            - network-control
+    bfdd:
+        command: bin/bfdd-service
+        daemon: simple
+        plugs:
+            - network
+            - network-bind
+            - network-control
     set:
         command: bin/set-options
     zebra-debug:
@@ -122,7 +136,7 @@ apps:
             - network-bind
             - network-control
     bgpd-debug:
-        command: sbin/bgpd -f $SNAP_DATA/bgpd.conf --pid_file $SNAP_DATA/bgpd.pid --socket $SNAP_DATA/zsock --vty_socket $SNAP_DATA
+        command: sbin/bgpd -f $SNAP_DATA/bgpd.conf --pid_file $SNAP_DATA/bgpd.pid --socket $SNAP_DATA/zsock --vty_socket $SNAP_DATA --moduledir $SNAP/lib/frr/modules `cat $SNAP_DATA/rpki.conf 2> /dev/null`
         plugs:
             - network
             - network-bind
@@ -193,10 +207,41 @@ apps:
             - network
             - network-bind
             - network-control
+    staticd-debug:
+        command: sbin/staticd -f $SNAP_DATA/staticd.conf --pid_file $SNAP_DATA/staticd.pid --socket $SNAP_DATA/zsock --vty_socket $SNAP_DATA
+        plugs:
+            - network
+            - network-bind
+            - network-control
+    bfdd-debug:
+        command: sbin/bfdd -f $SNAP_DATA/bfdd.conf --pid_file $SNAP_DATA/bfdd.pid --socket $SNAP_DATA/zsock --vty_socket $SNAP_DATA --bfdctl $SNAP_DATA/bfdd.sock
+        plugs:
+            - network
+            - network-bind
+            - network-control
 
 parts:
+    rtrlib:
+        build-packages:
+           - cmake
+           - make
+           - gcc
+           - libssh-dev
+        stage-packages:
+           - libssh-4
+        prime:
+           - lib/x86_64-linux-gnu/librtr.so*
+           - usr/lib/x86_64-linux-gnu/libssh.so*
+        source: https://github.com/rtrlib/rtrlib.git
+        source-type: git
+        source-tag: v0.5.0
+        plugin: cmake
+        configflags:
+           - -DCMAKE_BUILD_TYPE=Release
     frr: 
-        build-packages: 
+        after: [rtrlib]
+        build-packages:
+           - gcc
            - autoconf
            - automake
            - libtool
@@ -221,6 +266,7 @@ parts:
            - flex
            - python3-dev
            - protobuf-c-compiler
+           - python3-sphinx
         stage-packages:
            - coreutils
            - iproute2
@@ -250,6 +296,7 @@ parts:
             - --enable-ldpd
             - --enable-fpm
             - --enable-protobuf
+            - --enable-rpki
             - --enable-configfile-mask=0640
             - --enable-logfile-mask=0640 
             - --localstatedir=/var/run
@@ -274,6 +321,7 @@ parts:
             babeld.conf.default: etc/frr/babeld.conf.default
             eigrpd.conf.default: etc/frr/eigrpd.conf.default
             pbrd.conf.default: etc/frr/pbrd.conf.default
+            bfdd.conf.default: etc/frr/bfdd.conf.default
             vtysh.conf.default: etc/frr/vtysh.conf.default
     frr-scripts:
         plugin: make
diff -urpN frr-frr-5.0.1/staticd/.gitignore frr-frr-6.0/staticd/.gitignore
--- frr-frr-5.0.1/staticd/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,2 @@
+libstatic.a
+staticd
diff -urpN frr-frr-5.0.1/staticd/Makefile frr-frr-6.0/staticd/Makefile
--- frr-frr-5.0.1/staticd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/Makefile	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,10 @@
+all: ALWAYS
+	@$(MAKE) -s -C .. staticd/staticd
+%: ALWAYS
+	@$(MAKE) -s -C .. staticd/$@
+
+Makefile:
+	#nothing
+ALWAYS:
+.PHONY: ALWAYS makefiles
+.SUFFIXES:
diff -urpN frr-frr-5.0.1/staticd/static_main.c frr-frr-6.0/staticd/static_main.c
--- frr-frr-5.0.1/staticd/static_main.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,154 @@
+/*
+ * STATICd - main code
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include <lib/version.h>
+#include "getopt.h"
+#include "thread.h"
+#include "command.h"
+#include "log.h"
+#include "memory.h"
+#include "privs.h"
+#include "sigevent.h"
+#include "libfrr.h"
+#include "vrf.h"
+#include "nexthop.h"
+#include "filter.h"
+
+#include "static_vrf.h"
+#include "static_vty.h"
+#include "static_routes.h"
+#include "static_zebra.h"
+
+char backup_config_file[256];
+
+bool mpls_enabled;
+
+zebra_capabilities_t _caps_p[] = {
+};
+
+struct zebra_privs_t static_privs = {
+#if defined(FRR_USER) && defined(FRR_GROUP)
+	.user = FRR_USER,
+	.group = FRR_GROUP,
+#endif
+#if defined(VTY_GROUP)
+	.vty_group = VTY_GROUP,
+#endif
+	.caps_p = _caps_p,
+	.cap_num_p = array_size(_caps_p),
+	.cap_num_i = 0};
+
+struct option longopts[] = { { 0 } };
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* SIGHUP handler. */
+static void sighup(void)
+{
+	zlog_info("SIGHUP received");
+}
+
+/* SIGINT / SIGTERM handler. */
+static void sigint(void)
+{
+	zlog_notice("Terminating on signal");
+
+	exit(0);
+}
+
+/* SIGUSR1 handler. */
+static void sigusr1(void)
+{
+	zlog_rotate();
+}
+
+struct quagga_signal_t static_signals[] = {
+	{
+		.signal = SIGHUP,
+		.handler = &sighup,
+	},
+	{
+		.signal = SIGUSR1,
+		.handler = &sigusr1,
+	},
+	{
+		.signal = SIGINT,
+		.handler = &sigint,
+	},
+	{
+		.signal = SIGTERM,
+		.handler = &sigint,
+	},
+};
+
+#define STATIC_VTY_PORT 2616
+
+FRR_DAEMON_INFO(staticd, STATIC, .vty_port = STATIC_VTY_PORT,
+
+		.proghelp = "Implementation of STATIC.",
+
+		.signals = static_signals,
+		.n_signals = array_size(static_signals),
+
+		.privs = &static_privs,
+)
+
+int main(int argc, char **argv, char **envp)
+{
+	frr_preinit(&staticd_di, argc, argv);
+	frr_opt_add("", longopts, "");
+
+	while (1) {
+		int opt;
+
+		opt = frr_getopt(argc, argv, NULL);
+
+		if (opt == EOF)
+			break;
+
+		switch (opt) {
+		case 0:
+			break;
+		default:
+			frr_help_exit(1);
+			break;
+		}
+	}
+
+	master = frr_init();
+
+	access_list_init();
+	static_vrf_init();
+
+	static_zebra_init();
+	static_vty_init();
+
+	snprintf(backup_config_file, sizeof(backup_config_file),
+		 "%s/zebra.conf", frr_sysconfdir);
+	staticd_di.backup_config_file = backup_config_file;
+
+	frr_config_fork();
+	frr_run(master);
+
+	/* Not reached. */
+	return 0;
+}
diff -urpN frr-frr-5.0.1/staticd/static_memory.c frr-frr-6.0/staticd/static_memory.c
--- frr-frr-5.0.1/staticd/static_memory.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_memory.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * static memory code.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include <memory.h>
+
+#include "staticd/static_memory.h"
+
+DEFINE_MGROUP(STATIC, "staticd")
+
+DEFINE_MTYPE(STATIC, STATIC_ROUTE, "Static Route");
diff -urpN frr-frr-5.0.1/staticd/static_memory.h frr-frr-6.0/staticd/static_memory.h
--- frr-frr-5.0.1/staticd/static_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_memory.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * static memory code.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef __STATIC_MEMORY_H__
+
+#include "memory.h"
+
+DECLARE_MGROUP(STATIC)
+
+DECLARE_MTYPE(STATIC_ROUTE);
+
+#endif
diff -urpN frr-frr-5.0.1/staticd/static_nht.c frr-frr-6.0/staticd/static_nht.c
--- frr-frr-5.0.1/staticd/static_nht.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_nht.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+ * Static NHT code.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include "prefix.h"
+#include "table.h"
+#include "vrf.h"
+#include "nexthop.h"
+
+#include "static_vrf.h"
+#include "static_routes.h"
+#include "static_zebra.h"
+#include "static_nht.h"
+
+void static_nht_update(struct prefix *p, uint32_t nh_num, afi_t afi,
+		       vrf_id_t nh_vrf_id)
+{
+	struct route_table *stable;
+	struct static_route *si;
+	struct static_vrf *svrf;
+	struct route_node *rn;
+	struct vrf *vrf;
+	bool orig;
+	bool reinstall;
+
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		svrf = vrf->info;
+		if (!svrf)
+			continue;
+
+		stable = static_vrf_static_table(afi, SAFI_UNICAST, svrf);
+		if (!stable)
+			continue;
+
+		for (rn = route_top(stable); rn; rn = route_next(rn)) {
+			reinstall = false;
+			for (si = rn->info; si; si = si->next) {
+				if (si->nh_vrf_id != nh_vrf_id)
+					continue;
+
+				if (si->type != STATIC_IPV4_GATEWAY
+				    && si->type != STATIC_IPV4_GATEWAY_IFNAME
+				    && si->type != STATIC_IPV6_GATEWAY
+				    && si->type != STATIC_IPV6_GATEWAY_IFNAME)
+					continue;
+
+				orig = si->nh_valid;
+				if (p->family == AF_INET
+				    && p->u.prefix4.s_addr
+					       == si->addr.ipv4.s_addr)
+					si->nh_valid = !!nh_num;
+
+				if (p->family == AF_INET6
+				    && memcmp(&p->u.prefix6, &si->addr.ipv6, 16)
+					       == 0)
+					si->nh_valid = !!nh_num;
+
+				if (orig != si->nh_valid)
+					reinstall = true;
+
+				if (reinstall) {
+					static_zebra_route_add(
+						rn, si, vrf->vrf_id,
+						SAFI_UNICAST, true);
+					reinstall = false;
+				}
+			}
+		}
+	}
+}
diff -urpN frr-frr-5.0.1/staticd/static_nht.h frr-frr-6.0/staticd/static_nht.h
--- frr-frr-5.0.1/staticd/static_nht.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_nht.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * Static NHT header.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef __STATIC_NHT_H__
+#define __STATIC_NHT_H__
+
+extern void static_nht_update(struct prefix *p, uint32_t nh_num,
+			      afi_t afi, vrf_id_t vrf_id);
+#endif
diff -urpN frr-frr-5.0.1/staticd/static_routes.c frr-frr-6.0/staticd/static_routes.c
--- frr-frr-5.0.1/staticd/static_routes.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_routes.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,506 @@
+/*
+ * STATICd - route code
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include <lib/nexthop.h>
+#include <lib/memory.h>
+#include <lib/srcdest_table.h>
+#include <lib/if.h>
+#include <lib/vty.h>
+#include <lib/vrf.h>
+#include <lib/memory.h>
+
+#include "static_vrf.h"
+#include "static_routes.h"
+#include "static_memory.h"
+#include "static_zebra.h"
+
+/* Install static route into rib. */
+static void static_install_route(struct route_node *rn,
+				 struct static_route *si_changed, safi_t safi)
+{
+	struct static_route *si;
+
+	for (si = rn->info; si; si = si->next)
+		static_zebra_nht_register(si, true);
+
+	si = rn->info;
+	if (si)
+		static_zebra_route_add(rn, si_changed, si->vrf_id, safi, true);
+
+}
+
+/* Uninstall static route from RIB. */
+static void static_uninstall_route(vrf_id_t vrf_id, safi_t safi,
+				   struct route_node *rn,
+				   struct static_route *si_changed)
+{
+
+	if (rn->info)
+		static_zebra_route_add(rn, si_changed, vrf_id, safi, true);
+	else
+		static_zebra_route_add(rn, si_changed, vrf_id, safi, false);
+}
+
+int static_add_route(afi_t afi, safi_t safi, uint8_t type, struct prefix *p,
+		     struct prefix_ipv6 *src_p, union g_addr *gate,
+		     const char *ifname, enum static_blackhole_type bh_type,
+		     route_tag_t tag, uint8_t distance, struct static_vrf *svrf,
+		     struct static_vrf *nh_svrf,
+		     struct static_nh_label *snh_label,
+		     uint32_t table_id)
+{
+	struct route_node *rn;
+	struct static_route *si;
+	struct static_route *pp;
+	struct static_route *cp;
+	struct static_route *update = NULL;
+	struct route_table *stable = svrf->stable[afi][safi];
+
+	if (!stable)
+		return -1;
+
+	if (!gate && (type == STATIC_IPV4_GATEWAY
+		      || type == STATIC_IPV4_GATEWAY_IFNAME
+		      || type == STATIC_IPV6_GATEWAY
+		      || type == STATIC_IPV6_GATEWAY_IFNAME))
+		return -1;
+
+	if (!ifname
+	    && (type == STATIC_IFNAME || type == STATIC_IPV4_GATEWAY_IFNAME
+		|| type == STATIC_IPV6_GATEWAY_IFNAME))
+		return -1;
+
+	/* Lookup static route prefix. */
+	rn = srcdest_rnode_get(stable, p, src_p);
+
+	/* Do nothing if there is a same static route.  */
+	for (si = rn->info; si; si = si->next) {
+		if (type == si->type
+		    && (!gate
+			|| ((afi == AFI_IP
+			     && IPV4_ADDR_SAME(&gate->ipv4, &si->addr.ipv4))
+			    || (afi == AFI_IP6
+				&& IPV6_ADDR_SAME(gate, &si->addr.ipv6))))
+		    && (!strcmp(ifname ? ifname : "", si->ifname))) {
+			if ((distance == si->distance) && (tag == si->tag)
+			    && (table_id == si->table_id)
+			    && !memcmp(&si->snh_label, snh_label,
+				       sizeof(struct static_nh_label))
+			    && si->bh_type == bh_type) {
+				route_unlock_node(rn);
+				return 0;
+			}
+			update = si;
+		}
+	}
+
+	/* Distance or tag or label changed, delete existing first. */
+	if (update)
+		static_delete_route(afi, safi, type, p, src_p, gate, ifname,
+				    update->tag, update->distance, svrf,
+				    &update->snh_label, table_id);
+
+	/* Make new static route structure. */
+	si = XCALLOC(MTYPE_STATIC_ROUTE, sizeof(struct static_route));
+
+	si->type = type;
+	si->distance = distance;
+	si->bh_type = bh_type;
+	si->tag = tag;
+	si->vrf_id = svrf->vrf->vrf_id;
+	si->nh_vrf_id = nh_svrf->vrf->vrf_id;
+	strcpy(si->nh_vrfname, nh_svrf->vrf->name);
+	si->table_id = table_id;
+
+	if (ifname)
+		strlcpy(si->ifname, ifname, sizeof(si->ifname));
+	si->ifindex = IFINDEX_INTERNAL;
+
+	switch (type) {
+	case STATIC_IPV4_GATEWAY:
+	case STATIC_IPV4_GATEWAY_IFNAME:
+		si->addr.ipv4 = gate->ipv4;
+		break;
+	case STATIC_IPV6_GATEWAY:
+	case STATIC_IPV6_GATEWAY_IFNAME:
+		si->addr.ipv6 = gate->ipv6;
+		break;
+	case STATIC_IFNAME:
+		break;
+	}
+
+	/* Save labels, if any. */
+	memcpy(&si->snh_label, snh_label, sizeof(struct static_nh_label));
+
+	/*
+	 * Add new static route information to the tree with sort by
+	 * distance value and gateway address.
+	 */
+	for (pp = NULL, cp = rn->info; cp; pp = cp, cp = cp->next) {
+		if (si->distance < cp->distance)
+			break;
+		if (si->distance > cp->distance)
+			continue;
+		if (si->type == STATIC_IPV4_GATEWAY
+		    && cp->type == STATIC_IPV4_GATEWAY) {
+			if (ntohl(si->addr.ipv4.s_addr)
+			    < ntohl(cp->addr.ipv4.s_addr))
+				break;
+			if (ntohl(si->addr.ipv4.s_addr)
+			    > ntohl(cp->addr.ipv4.s_addr))
+				continue;
+		}
+	}
+
+	/* Make linked list. */
+	if (pp)
+		pp->next = si;
+	else
+		rn->info = si;
+	if (cp)
+		cp->prev = si;
+	si->prev = pp;
+	si->next = cp;
+
+	/* check whether interface exists in system & install if it does */
+	if (!ifname)
+		static_install_route(rn, si, safi);
+	else {
+		struct interface *ifp;
+
+		ifp = if_lookup_by_name(ifname, nh_svrf->vrf->vrf_id);
+		if (ifp && ifp->ifindex != IFINDEX_INTERNAL) {
+			si->ifindex = ifp->ifindex;
+			static_install_route(rn, si, safi);
+		} else
+			zlog_warn("Static Route using %s interface not installed because the interface does not exist in specified vrf",
+				  ifname);
+	}
+
+	return 1;
+}
+
+int static_delete_route(afi_t afi, safi_t safi, uint8_t type, struct prefix *p,
+			struct prefix_ipv6 *src_p, union g_addr *gate,
+			const char *ifname, route_tag_t tag, uint8_t distance,
+			struct static_vrf *svrf,
+			struct static_nh_label *snh_label,
+			uint32_t table_id)
+{
+	struct route_node *rn;
+	struct static_route *si;
+	struct route_table *stable;
+
+	/* Lookup table.  */
+	stable = static_vrf_static_table(afi, safi, svrf);
+	if (!stable)
+		return -1;
+
+	/* Lookup static route prefix. */
+	rn = srcdest_rnode_lookup(stable, p, src_p);
+	if (!rn)
+		return 0;
+
+	/* Find same static route is the tree */
+	for (si = rn->info; si; si = si->next)
+		if (type == si->type
+		    && (!gate
+			|| ((afi == AFI_IP
+			     && IPV4_ADDR_SAME(&gate->ipv4, &si->addr.ipv4))
+			    || (afi == AFI_IP6
+				&& IPV6_ADDR_SAME(gate, &si->addr.ipv6))))
+		    && (!strcmp(ifname ? ifname : "", si->ifname))
+		    && (!tag || (tag == si->tag))
+		    && (table_id == si->table_id)
+		    && (!snh_label->num_labels
+			|| !memcmp(&si->snh_label, snh_label,
+				   sizeof(struct static_nh_label))))
+			break;
+
+	/* Can't find static route. */
+	if (!si) {
+		route_unlock_node(rn);
+		return 0;
+	}
+
+	static_zebra_nht_register(si, false);
+
+	/* Unlink static route from linked list. */
+	if (si->prev)
+		si->prev->next = si->next;
+	else
+		rn->info = si->next;
+	if (si->next)
+		si->next->prev = si->prev;
+
+	/*
+	 * If we have other si nodes then route replace
+	 * else delete the route
+	 */
+	static_uninstall_route(si->vrf_id, safi, rn, si);
+	route_unlock_node(rn);
+
+	/* Free static route configuration. */
+	XFREE(MTYPE_STATIC_ROUTE, si);
+
+	route_unlock_node(rn);
+
+	return 1;
+}
+
+static void static_ifindex_update_af(struct interface *ifp, bool up, afi_t afi,
+				     safi_t safi)
+{
+	struct route_table *stable;
+	struct route_node *rn;
+	struct static_route *si;
+	struct vrf *vrf;
+
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		struct static_vrf *svrf;
+
+		svrf = vrf->info;
+
+		stable = static_vrf_static_table(afi, safi, svrf);
+		if (!stable)
+			continue;
+
+		for (rn = route_top(stable); rn; rn = srcdest_route_next(rn)) {
+			for (si = rn->info; si; si = si->next) {
+				if (!si->ifname[0])
+					continue;
+				if (up) {
+					if (strcmp(si->ifname, ifp->name))
+						continue;
+					si->ifindex = ifp->ifindex;
+				} else {
+					if (si->ifindex != ifp->ifindex)
+						continue;
+					si->ifindex = IFINDEX_INTERNAL;
+				}
+
+				static_install_route(rn, si, safi);
+			}
+		}
+	}
+}
+
+/*
+ * This function looks at a svrf's stable and notices if any of the
+ * nexthops we are using are part of the vrf coming up.
+ * If we are using them then cleanup the nexthop vrf id
+ * to be the new value and then re-installs them
+ *
+ *
+ * stable -> The table we are looking at.
+ * svrf -> The newly changed vrf.
+ * afi -> The afi to look at
+ * safi -> the safi to look at
+ */
+static void static_fixup_vrf(struct static_vrf *svrf,
+			     struct route_table *stable, afi_t afi, safi_t safi)
+{
+	struct route_node *rn;
+	struct static_route *si;
+	struct interface *ifp;
+
+	for (rn = route_top(stable); rn; rn = route_next(rn)) {
+		for (si = rn->info; si; si = si->next) {
+			if (strcmp(svrf->vrf->name, si->nh_vrfname) != 0)
+				continue;
+
+			si->nh_vrf_id = svrf->vrf->vrf_id;
+			if (si->ifindex) {
+				ifp = if_lookup_by_name(si->ifname,
+							si->nh_vrf_id);
+				if (ifp)
+					si->ifindex = ifp->ifindex;
+				else
+					continue;
+			}
+
+			static_install_route(rn, si, safi);
+		}
+	}
+}
+
+/*
+ * This function enables static routes in a svrf as it
+ * is coming up.  It sets the new vrf_id as appropriate.
+ *
+ * svrf -> The svrf that is being brought up and enabled by the kernel
+ * stable -> The stable we are looking at.
+ * afi -> the afi in question
+ * safi -> the safi in question
+ */
+static void static_enable_vrf(struct static_vrf *svrf,
+			      struct route_table *stable,
+			      afi_t afi, safi_t safi)
+{
+	struct route_node *rn;
+	struct static_route *si;
+	struct interface *ifp;
+	struct vrf *vrf = svrf->vrf;
+
+	for (rn = route_top(stable); rn; rn = route_next(rn)) {
+		for (si = rn->info; si; si = si->next) {
+			si->vrf_id = vrf->vrf_id;
+			if (si->ifindex) {
+				ifp = if_lookup_by_name(si->ifname,
+							si->nh_vrf_id);
+				if (ifp)
+					si->ifindex = ifp->ifindex;
+				else
+					continue;
+			}
+			static_install_route(rn, si, safi);
+		}
+	}
+}
+
+/*
+ * When a vrf is being enabled by the kernel, go through all the
+ * static routes in the system that use this vrf (both nexthops vrfs
+ * and the routes vrf )
+ *
+ * enable_svrf -> the vrf being enabled
+ */
+void static_fixup_vrf_ids(struct static_vrf *enable_svrf)
+{
+	struct route_table *stable;
+	struct vrf *vrf;
+	afi_t afi;
+	safi_t safi;
+
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		struct static_vrf *svrf;
+
+		svrf = vrf->info;
+		/* Install any static routes configured for this VRF. */
+		for (afi = AFI_IP; afi < AFI_MAX; afi++) {
+			for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
+				stable = svrf->stable[afi][safi];
+				if (!stable)
+					continue;
+
+				static_fixup_vrf(enable_svrf, stable,
+						 afi, safi);
+
+				if (enable_svrf == svrf)
+					static_enable_vrf(svrf, stable,
+							  afi, safi);
+			}
+		}
+	}
+}
+
+/*
+ * Look at the specified stable and if any of the routes in
+ * this table are using the svrf as the nexthop, uninstall
+ * those routes.
+ *
+ * svrf -> the vrf being disabled
+ * stable -> the table we need to look at.
+ * afi -> the afi in question
+ * safi -> the safi in question
+ */
+static void static_cleanup_vrf(struct static_vrf *svrf,
+			       struct route_table *stable,
+			       afi_t afi, safi_t safi)
+{
+	struct route_node *rn;
+	struct static_route *si;
+
+	for (rn = route_top(stable); rn; rn = route_next(rn)) {
+		for (si = rn->info; si; si = si->next) {
+			if (strcmp(svrf->vrf->name, si->nh_vrfname) != 0)
+				continue;
+
+			static_uninstall_route(si->vrf_id, safi, rn, si);
+		}
+	}
+}
+
+/*
+ * Look at all static routes in this table and uninstall
+ * them.
+ *
+ * stable -> The table to uninstall from
+ * afi -> The afi in question
+ * safi -> the safi in question
+ */
+static void static_disable_vrf(struct route_table *stable,
+			       afi_t afi, safi_t safi)
+{
+	struct route_node *rn;
+	struct static_route *si;
+
+	for (rn = route_top(stable); rn; rn = route_next(rn))
+		for (si = rn->info; si; si = si->next)
+			static_uninstall_route(si->vrf_id, safi, rn, si);
+}
+
+/*
+ * When the disable_svrf is shutdown by the kernel, we call
+ * this function and it cleans up all static routes using
+ * this vrf as a nexthop as well as all static routes
+ * in it's stables.
+ *
+ * disable_svrf - The vrf being disabled
+ */
+void static_cleanup_vrf_ids(struct static_vrf *disable_svrf)
+{
+	struct vrf *vrf;
+	afi_t afi;
+	safi_t safi;
+
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		struct static_vrf *svrf;
+
+		svrf = vrf->info;
+
+		/* Uninstall any static routes configured for this VRF. */
+		for (afi = AFI_IP; afi < AFI_MAX; afi++) {
+			for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
+				struct route_table *stable;
+
+				stable = svrf->stable[afi][safi];
+				if (!stable)
+					continue;
+
+				static_cleanup_vrf(disable_svrf, stable,
+						   afi, safi);
+
+				if (disable_svrf == svrf)
+					static_disable_vrf(stable, afi, safi);
+			}
+		}
+	}
+}
+
+/* called from if_{add,delete}_update, i.e. when ifindex becomes [in]valid */
+void static_ifindex_update(struct interface *ifp, bool up)
+{
+	static_ifindex_update_af(ifp, up, AFI_IP, SAFI_UNICAST);
+	static_ifindex_update_af(ifp, up, AFI_IP, SAFI_MULTICAST);
+	static_ifindex_update_af(ifp, up, AFI_IP6, SAFI_UNICAST);
+	static_ifindex_update_af(ifp, up, AFI_IP6, SAFI_MULTICAST);
+}
diff -urpN frr-frr-5.0.1/staticd/static_routes.h frr-frr-6.0/staticd/static_routes.h
--- frr-frr-5.0.1/staticd/static_routes.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_routes.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+ * STATICd - static routes header
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef __STATIC_ROUTES_H__
+#define __STATIC_ROUTES_H__
+
+#include "lib/mpls.h"
+
+/* Static route label information */
+struct static_nh_label {
+	uint8_t num_labels;
+	uint8_t reserved[3];
+	mpls_label_t label[MPLS_MAX_LABELS];
+};
+
+enum static_blackhole_type {
+	STATIC_BLACKHOLE_DROP = 0,
+	STATIC_BLACKHOLE_NULL,
+	STATIC_BLACKHOLE_REJECT
+};
+
+typedef enum {
+	STATIC_IFNAME,
+	STATIC_IPV4_GATEWAY,
+	STATIC_IPV4_GATEWAY_IFNAME,
+	STATIC_BLACKHOLE,
+	STATIC_IPV6_GATEWAY,
+	STATIC_IPV6_GATEWAY_IFNAME,
+} static_types;
+
+/* Static route information. */
+struct static_route {
+	/* For linked list. */
+	struct static_route *prev;
+	struct static_route *next;
+
+	/* VRF identifier. */
+	vrf_id_t vrf_id;
+	vrf_id_t nh_vrf_id;
+	char nh_vrfname[VRF_NAMSIZ + 1];
+
+	/* Administrative distance. */
+	uint8_t distance;
+
+	/* Tag */
+	route_tag_t tag;
+
+	/* Flag for this static route's type. */
+	static_types type;
+
+	/*
+	 * Nexthop value.
+	 */
+	enum static_blackhole_type bh_type;
+	union g_addr addr;
+	ifindex_t ifindex;
+	bool nh_registered;
+	bool nh_valid;
+
+	char ifname[INTERFACE_NAMSIZ + 1];
+
+	/* Label information */
+	struct static_nh_label snh_label;
+
+	uint32_t table_id;
+};
+
+extern bool mpls_enabled;
+
+extern struct zebra_privs_t static_privs;
+
+void static_fixup_vrf_ids(struct static_vrf *svrf);
+
+extern int static_add_route(afi_t afi, safi_t safi, uint8_t type,
+			    struct prefix *p, struct prefix_ipv6 *src_p,
+			    union g_addr *gate, const char *ifname,
+			    enum static_blackhole_type bh_type, route_tag_t tag,
+			    uint8_t distance, struct static_vrf *svrf,
+			    struct static_vrf *nh_svrf,
+			    struct static_nh_label *snh_label,
+			    uint32_t table_id);
+
+extern int static_delete_route(afi_t afi, safi_t safi, uint8_t type,
+			       struct prefix *p, struct prefix_ipv6 *src_p,
+			       union g_addr *gate, const char *ifname,
+			       route_tag_t tag, uint8_t distance,
+			       struct static_vrf *svrf,
+			       struct static_nh_label *snh_label,
+			       uint32_t table_id);
+
+extern void static_cleanup_vrf_ids(struct static_vrf *disable_svrf);
+
+extern void static_ifindex_update(struct interface *ifp, bool up);
+#endif
diff -urpN frr-frr-5.0.1/staticd/static_vrf.c frr-frr-6.0/staticd/static_vrf.c
--- frr-frr-5.0.1/staticd/static_vrf.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_vrf.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,202 @@
+/*
+ * STATICd - vrf code
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include "vrf.h"
+#include "nexthop.h"
+#include "table.h"
+#include "srcdest_table.h"
+
+#include "static_memory.h"
+#include "static_vrf.h"
+#include "static_routes.h"
+#include "static_vty.h"
+
+static void zebra_stable_node_cleanup(struct route_table *table,
+				      struct route_node *node)
+{
+	struct static_route *si, *next;
+
+	if (node->info)
+		for (si = node->info; si; si = next) {
+			next = si->next;
+			XFREE(MTYPE_STATIC_ROUTE, si);
+		}
+}
+
+static struct static_vrf *static_vrf_alloc(void)
+{
+	struct route_table *table;
+	struct static_vrf *svrf;
+	safi_t safi;
+	afi_t afi;
+
+	svrf = XCALLOC(MTYPE_TMP, sizeof(struct static_vrf));
+
+	for (afi = AFI_IP; afi <= AFI_IP6; afi++) {
+		for (safi = SAFI_UNICAST; safi <= SAFI_MULTICAST; safi++) {
+			if (afi == AFI_IP6)
+				table = srcdest_table_init();
+			else
+				table = route_table_init();
+			table->cleanup = zebra_stable_node_cleanup;
+			svrf->stable[afi][safi] = table;
+		}
+	}
+	return svrf;
+}
+
+static int static_vrf_new(struct vrf *vrf)
+{
+	struct static_vrf *svrf;
+
+	svrf = static_vrf_alloc();
+	vrf->info = svrf;
+	svrf->vrf = vrf;
+
+	return 0;
+}
+
+static int static_vrf_enable(struct vrf *vrf)
+{
+	static_fixup_vrf_ids(vrf->info);
+
+	/*
+	 * We may have static routes that are now possible to
+	 * insert into the appropriate tables
+	 */
+	static_config_install_delayed_routes(vrf->info);
+
+	return 0;
+}
+
+static int static_vrf_disable(struct vrf *vrf)
+{
+	return 0;
+}
+
+static int static_vrf_delete(struct vrf *vrf)
+{
+	struct route_table *table;
+	struct static_vrf *svrf;
+	safi_t safi;
+	afi_t afi;
+
+	svrf = vrf->info;
+	for (afi = AFI_IP; afi <= AFI_IP6; afi++) {
+		for (safi = SAFI_UNICAST; safi <= SAFI_MULTICAST; safi++) {
+			table = svrf->stable[afi][safi];
+			route_table_finish(table);
+			svrf->stable[afi][safi] = NULL;
+		}
+	}
+	return 0;
+}
+
+/* Lookup the static routing table in a VRF. */
+struct route_table *static_vrf_static_table(afi_t afi, safi_t safi,
+					    struct static_vrf *svrf)
+{
+	if (!svrf)
+		return NULL;
+
+	if (afi >= AFI_MAX || safi >= SAFI_MAX)
+		return NULL;
+
+	return svrf->stable[afi][safi];
+}
+
+struct static_vrf *static_vrf_lookup_by_id(vrf_id_t vrf_id)
+{
+	struct vrf *vrf;
+
+	vrf = vrf_lookup_by_id(vrf_id);
+	if (vrf)
+		return ((struct static_vrf *)vrf->info);
+
+	return NULL;
+}
+
+struct static_vrf *static_vrf_lookup_by_name(const char *name)
+{
+	struct vrf *vrf;
+
+	if (!name)
+		name = VRF_DEFAULT_NAME;
+
+	vrf = vrf_lookup_by_name(name);
+	if (vrf)
+		return ((struct static_vrf *)vrf->info);
+
+	return NULL;
+}
+
+static int static_vrf_config_write(struct vty *vty)
+{
+	struct vrf *vrf;
+
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		if (vrf->vrf_id != VRF_DEFAULT)
+			vty_frame(vty, "vrf %s\n", vrf->name);
+
+		static_config(vty, vrf->info, AFI_IP,
+			      SAFI_UNICAST, "ip route");
+		static_config(vty, vrf->info, AFI_IP,
+			      SAFI_MULTICAST, "ip mroute");
+		static_config(vty, vrf->info, AFI_IP6,
+			      SAFI_UNICAST, "ipv6 route");
+
+		if (vrf->vrf_id != VRF_DEFAULT)
+			vty_endframe(vty, "!\n");
+	}
+
+	return 0;
+}
+
+int static_vrf_has_config(struct static_vrf *svrf)
+{
+	struct route_table *table;
+	safi_t safi;
+	afi_t afi;
+
+	/*
+	 * NOTE: This is a don't care for the default VRF, but we go through
+	 * the motions to keep things consistent.
+	 */
+	for (afi = AFI_IP; afi < AFI_MAX; afi++) {
+		for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
+			table = svrf->stable[afi][safi];
+			if (!table)
+				continue;
+			if (route_table_count(table))
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+void static_vrf_init(void)
+{
+	vrf_init(static_vrf_new, static_vrf_enable,
+		 static_vrf_disable, static_vrf_delete);
+
+	vrf_cmd_init(static_vrf_config_write, &static_privs);
+}
diff -urpN frr-frr-5.0.1/staticd/static_vrf.h frr-frr-6.0/staticd/static_vrf.h
--- frr-frr-5.0.1/staticd/static_vrf.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_vrf.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * STATICd - vrf header
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef __STATIC_VRF_H__
+#define __STATIC_VRF_H__
+
+struct static_vrf {
+	struct vrf *vrf;
+
+	struct route_table *stable[AFI_MAX][SAFI_MAX];
+};
+
+struct static_vrf *static_vrf_lookup_by_name(const char *vrf_name);
+struct static_vrf *static_vrf_lookup_by_id(vrf_id_t vrf_id);
+
+int static_vrf_has_config(struct static_vrf *svrf);
+
+void static_vrf_init(void);
+
+struct route_table *static_vrf_static_table(afi_t afi, safi_t safi,
+					    struct static_vrf *svrf);
+#endif
diff -urpN frr-frr-5.0.1/staticd/static_vty.c frr-frr-6.0/staticd/static_vty.c
--- frr-frr-5.0.1/staticd/static_vty.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,1414 @@
+/*
+ * STATICd - vty code
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include "command.h"
+#include "vty.h"
+#include "vrf.h"
+#include "prefix.h"
+#include "nexthop.h"
+#include "table.h"
+#include "srcdest_table.h"
+#include "mpls.h"
+
+#include "static_vrf.h"
+#include "static_memory.h"
+#include "static_vty.h"
+#include "static_routes.h"
+#ifndef VTYSH_EXTRACT_PL
+#include "staticd/static_vty_clippy.c"
+#endif
+
+static struct static_vrf *static_vty_get_unknown_vrf(struct vty *vty,
+						     const char *vrf_name)
+{
+	struct static_vrf *svrf;
+	struct vrf *vrf;
+
+	svrf = static_vrf_lookup_by_name(vrf_name);
+
+	if (svrf)
+		return svrf;
+
+	vrf = vrf_get(VRF_UNKNOWN, vrf_name);
+	if (!vrf) {
+		vty_out(vty, "%% Could not create vrf %s\n", vrf_name);
+		return NULL;
+	}
+	svrf = vrf->info;
+	if (!svrf) {
+		vty_out(vty, "%% Could not create vrf-info %s\n",
+			vrf_name);
+		return NULL;
+	}
+	/* Mark as having FRR configuration */
+	vrf_set_user_cfged(vrf);
+
+	return svrf;
+}
+
+struct static_hold_route {
+	char *vrf_name;
+	char *nhvrf_name;
+	afi_t afi;
+	safi_t safi;
+	char *dest_str;
+	char *mask_str;
+	char *src_str;
+	char *gate_str;
+	char *ifname;
+	char *flag_str;
+	char *tag_str;
+	char *distance_str;
+	char *label_str;
+	char *table_str;
+
+	/* processed & masked destination, used for config display */
+	struct prefix dest;
+};
+
+static struct list *static_list;
+
+static int static_list_compare_helper(const char *s1, const char *s2)
+{
+	/* Are Both NULL */
+	if (s1 == s2)
+		return 0;
+
+	if (!s1 && s2)
+		return -1;
+
+	if (s1 && !s2)
+		return 1;
+
+	return strcmp(s1, s2);
+}
+
+static void static_list_delete(struct static_hold_route *shr)
+{
+	if (shr->vrf_name)
+		XFREE(MTYPE_STATIC_ROUTE, shr->vrf_name);
+	if (shr->nhvrf_name)
+		XFREE(MTYPE_STATIC_ROUTE, shr->nhvrf_name);
+	if (shr->dest_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->dest_str);
+	if (shr->mask_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->mask_str);
+	if (shr->src_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->src_str);
+	if (shr->gate_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->gate_str);
+	if (shr->ifname)
+		XFREE(MTYPE_STATIC_ROUTE, shr->ifname);
+	if (shr->flag_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->flag_str);
+	if (shr->tag_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->tag_str);
+	if (shr->distance_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->distance_str);
+	if (shr->label_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->label_str);
+	if (shr->table_str)
+		XFREE(MTYPE_STATIC_ROUTE, shr->table_str);
+
+	XFREE(MTYPE_STATIC_ROUTE, shr);
+}
+
+static int static_list_compare(void *arg1, void *arg2)
+{
+	struct static_hold_route *shr1 = arg1;
+	struct static_hold_route *shr2 = arg2;
+	int ret;
+
+	ret = strcmp(shr1->vrf_name, shr2->vrf_name);
+	if (ret)
+		return ret;
+
+	ret = strcmp(shr1->nhvrf_name, shr2->nhvrf_name);
+	if (ret)
+		return ret;
+
+	ret = shr1->afi - shr2->afi;
+	if (ret)
+		return ret;
+
+	ret = shr1->safi - shr2->safi;
+	if (ret)
+		return ret;
+
+	ret = prefix_cmp(&shr1->dest, &shr2->dest);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->src_str, shr2->src_str);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->gate_str, shr2->gate_str);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->ifname, shr2->ifname);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->flag_str, shr2->flag_str);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->tag_str, shr2->tag_str);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->distance_str,
+					 shr2->distance_str);
+	if (ret)
+		return ret;
+
+	ret = static_list_compare_helper(shr1->table_str,
+					 shr2->table_str);
+	if (ret)
+		return ret;
+
+	return static_list_compare_helper(shr1->label_str, shr2->label_str);
+}
+
+
+/* General function for static route. */
+static int zebra_static_route_holdem(
+	struct static_vrf *svrf, struct static_vrf *nh_svrf, afi_t afi,
+	safi_t safi, const char *negate, struct prefix *dest,
+	const char *dest_str, const char *mask_str, const char *src_str,
+	const char *gate_str, const char *ifname, const char *flag_str,
+	const char *tag_str, const char *distance_str, const char *label_str,
+	const char *table_str)
+{
+	struct static_hold_route *shr, *lookup;
+	struct listnode *node;
+
+	zlog_warn("Static Route to %s not installed currently because dependent config not fully available",
+		  dest_str);
+
+	shr = XCALLOC(MTYPE_STATIC_ROUTE, sizeof(*shr));
+	shr->vrf_name = XSTRDUP(MTYPE_STATIC_ROUTE, svrf->vrf->name);
+	shr->nhvrf_name = XSTRDUP(MTYPE_STATIC_ROUTE, nh_svrf->vrf->name);
+	shr->afi = afi;
+	shr->safi = safi;
+	if (dest)
+		prefix_copy(&shr->dest, dest);
+	if (dest_str)
+		shr->dest_str = XSTRDUP(MTYPE_STATIC_ROUTE, dest_str);
+	if (mask_str)
+		shr->mask_str = XSTRDUP(MTYPE_STATIC_ROUTE, mask_str);
+	if (src_str)
+		shr->src_str = XSTRDUP(MTYPE_STATIC_ROUTE, src_str);
+	if (gate_str)
+		shr->gate_str = XSTRDUP(MTYPE_STATIC_ROUTE, gate_str);
+	if (ifname)
+		shr->ifname = XSTRDUP(MTYPE_STATIC_ROUTE, ifname);
+	if (flag_str)
+		shr->flag_str = XSTRDUP(MTYPE_STATIC_ROUTE, flag_str);
+	if (tag_str)
+		shr->tag_str = XSTRDUP(MTYPE_STATIC_ROUTE, tag_str);
+	if (distance_str)
+		shr->distance_str = XSTRDUP(MTYPE_STATIC_ROUTE, distance_str);
+	if (label_str)
+		shr->label_str = XSTRDUP(MTYPE_STATIC_ROUTE, label_str);
+	if (table_str)
+		shr->table_str = XSTRDUP(MTYPE_STATIC_ROUTE, table_str);
+
+	for (ALL_LIST_ELEMENTS_RO(static_list, node, lookup)) {
+		if (static_list_compare(shr, lookup) == 0)
+			break;
+	}
+
+	if (lookup) {
+		if (negate) {
+			listnode_delete(static_list, lookup);
+			static_list_delete(shr);
+			static_list_delete(lookup);
+
+			return CMD_SUCCESS;
+		}
+
+		/*
+		 * If a person enters the same line again
+		 * we need to silently accept it
+		 */
+		goto shr_cleanup;
+	}
+
+	if (!negate) {
+		listnode_add_sort(static_list, shr);
+		return CMD_SUCCESS;
+	}
+
+ shr_cleanup:
+	XFREE(MTYPE_STATIC_ROUTE, shr->nhvrf_name);
+	XFREE(MTYPE_STATIC_ROUTE, shr->vrf_name);
+	XFREE(MTYPE_STATIC_ROUTE, shr);
+
+	return CMD_SUCCESS;
+}
+
+static int static_route_leak(
+	struct vty *vty, struct static_vrf *svrf, struct static_vrf *nh_svrf,
+	afi_t afi, safi_t safi, const char *negate, const char *dest_str,
+	const char *mask_str, const char *src_str, const char *gate_str,
+	const char *ifname, const char *flag_str, const char *tag_str,
+	const char *distance_str, const char *label_str, const char *table_str)
+{
+	int ret;
+	uint8_t distance;
+	struct prefix p, src;
+	struct prefix_ipv6 *src_p = NULL;
+	union g_addr gate;
+	union g_addr *gatep = NULL;
+	struct in_addr mask;
+	enum static_blackhole_type bh_type = 0;
+	route_tag_t tag = 0;
+	uint8_t type;
+	struct static_nh_label snh_label;
+	uint32_t table_id = 0;
+
+	ret = str2prefix(dest_str, &p);
+	if (ret <= 0) {
+		if (vty)
+			vty_out(vty, "%% Malformed address\n");
+		else
+			zlog_warn("%s: Malformed address: %s",
+				  __PRETTY_FUNCTION__, dest_str);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	switch (afi) {
+	case AFI_IP:
+		/* Cisco like mask notation. */
+		if (mask_str) {
+			ret = inet_aton(mask_str, &mask);
+			if (ret == 0) {
+				if (vty)
+					vty_out(vty, "%% Malformed address\n");
+				else
+					zlog_warn("%s: Malformed address: %s",
+						  __PRETTY_FUNCTION__,
+						  mask_str);
+				return CMD_WARNING_CONFIG_FAILED;
+			}
+			p.prefixlen = ip_masklen(mask);
+		}
+		break;
+	case AFI_IP6:
+		/* srcdest routing */
+		if (src_str) {
+			ret = str2prefix(src_str, &src);
+			if (ret <= 0 || src.family != AF_INET6) {
+				if (vty)
+					vty_out(vty,
+						"%% Malformed source address\n");
+				else
+					zlog_warn(
+						"%s: Malformed source address: %s",
+						__PRETTY_FUNCTION__, src_str);
+				return CMD_WARNING_CONFIG_FAILED;
+			}
+			src_p = (struct prefix_ipv6 *)&src;
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* Apply mask for given prefix. */
+	apply_mask(&p);
+
+	if (svrf->vrf->vrf_id == VRF_UNKNOWN
+	    || nh_svrf->vrf->vrf_id == VRF_UNKNOWN) {
+		vrf_set_user_cfged(svrf->vrf);
+		return zebra_static_route_holdem(
+			svrf, nh_svrf, afi, safi, negate, &p, dest_str,
+			mask_str, src_str, gate_str, ifname, flag_str, tag_str,
+			distance_str, label_str, table_str);
+	}
+
+	if (table_str) {
+		/* table configured. check consistent with vrf config
+		 */
+		if (svrf->vrf->data.l.table_id != RT_TABLE_MAIN) {
+			if (vty)
+				vty_out(vty,
+				    "%% Table %s overlaps vrf table %u\n",
+				    table_str, svrf->vrf->data.l.table_id);
+			else
+				zlog_warn(
+				    "%s: Table %s overlaps vrf table %u",
+				    __PRETTY_FUNCTION__,
+				    table_str, svrf->vrf->data.l.table_id);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	/* Administrative distance. */
+	if (distance_str)
+		distance = atoi(distance_str);
+	else
+		distance = ZEBRA_STATIC_DISTANCE_DEFAULT;
+
+	/* tag */
+	if (tag_str)
+		tag = strtoul(tag_str, NULL, 10);
+
+	/* Labels */
+	memset(&snh_label, 0, sizeof(struct static_nh_label));
+	if (label_str) {
+		if (!mpls_enabled) {
+			if (vty)
+				vty_out(vty,
+					"%% MPLS not turned on in kernel, ignoring command\n");
+			else
+				zlog_warn(
+					"%s: MPLS not turned on in kernel ignoring static route to %s",
+					__PRETTY_FUNCTION__, dest_str);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+		int rc = mpls_str2label(label_str, &snh_label.num_labels,
+					snh_label.label);
+		if (rc < 0) {
+			switch (rc) {
+			case -1:
+				if (vty)
+					vty_out(vty, "%% Malformed label(s)\n");
+				else
+					zlog_warn(
+						"%s: Malformed labels specified for route %s",
+						__PRETTY_FUNCTION__, dest_str);
+				break;
+			case -2:
+				if (vty)
+					vty_out(vty,
+						"%% Cannot use reserved label(s) (%d-%d)\n",
+						MPLS_LABEL_RESERVED_MIN,
+						MPLS_LABEL_RESERVED_MAX);
+				else
+					zlog_warn(
+						"%s: Cannot use reserved labels (%d-%d) for %s",
+						__PRETTY_FUNCTION__,
+						MPLS_LABEL_RESERVED_MIN,
+						MPLS_LABEL_RESERVED_MAX,
+						dest_str);
+				break;
+			case -3:
+				if (vty)
+					vty_out(vty,
+						"%% Too many labels. Enter %d or fewer\n",
+						MPLS_MAX_LABELS);
+				else
+					zlog_warn(
+						"%s: Too many labels, Enter %d or fewer for %s",
+						__PRETTY_FUNCTION__,
+						MPLS_MAX_LABELS, dest_str);
+				break;
+			}
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	/* TableID */
+	if (table_str)
+		table_id = atol(table_str);
+
+	/* Null0 static route.  */
+	if (ifname != NULL) {
+		if (strncasecmp(ifname, "Null0", strlen(ifname)) == 0
+		    || strncasecmp(ifname, "reject", strlen(ifname)) == 0
+		    || strncasecmp(ifname, "blackhole", strlen(ifname)) == 0) {
+			if (vty)
+				vty_out(vty,
+					"%% Nexthop interface cannot be Null0, reject or blackhole\n");
+			else
+				zlog_warn(
+					"%s: Nexthop interface cannot be Null0, reject or blackhole for %s",
+					__PRETTY_FUNCTION__, dest_str);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	/* Route flags */
+	if (flag_str) {
+		switch (flag_str[0]) {
+		case 'r':
+			bh_type = STATIC_BLACKHOLE_REJECT;
+			break;
+		case 'b':
+			bh_type = STATIC_BLACKHOLE_DROP;
+			break;
+		case 'N':
+			bh_type = STATIC_BLACKHOLE_NULL;
+			break;
+		default:
+			if (vty)
+				vty_out(vty, "%% Malformed flag %s \n",
+					flag_str);
+			else
+				zlog_warn("%s: Malformed flag %s for %s",
+					  __PRETTY_FUNCTION__, flag_str,
+					  dest_str);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	if (gate_str) {
+		if (inet_pton(afi2family(afi), gate_str, &gate) != 1) {
+			if (vty)
+				vty_out(vty,
+					"%% Malformed nexthop address %s\n",
+					gate_str);
+			else
+				zlog_warn(
+					"%s: Malformed nexthop address %s for %s",
+					__PRETTY_FUNCTION__, gate_str,
+					dest_str);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+		gatep = &gate;
+	}
+
+	if (gate_str == NULL && ifname == NULL)
+		type = STATIC_BLACKHOLE;
+	else if (gate_str && ifname) {
+		if (afi == AFI_IP)
+			type = STATIC_IPV4_GATEWAY_IFNAME;
+		else
+			type = STATIC_IPV6_GATEWAY_IFNAME;
+	} else if (ifname)
+		type = STATIC_IFNAME;
+	else {
+		if (afi == AFI_IP)
+			type = STATIC_IPV4_GATEWAY;
+		else
+			type = STATIC_IPV6_GATEWAY;
+	}
+
+	if (!negate) {
+		static_add_route(afi, safi, type, &p, src_p, gatep, ifname,
+				 bh_type, tag, distance, svrf, nh_svrf,
+				 &snh_label, table_id);
+		/* Mark as having FRR configuration */
+		vrf_set_user_cfged(svrf->vrf);
+	} else {
+		static_delete_route(afi, safi, type, &p, src_p, gatep, ifname,
+				    tag, distance, svrf, &snh_label, table_id);
+		/* If no other FRR config for this VRF, mark accordingly. */
+		if (!static_vrf_has_config(svrf))
+			vrf_reset_user_cfged(svrf->vrf);
+	}
+
+	return CMD_SUCCESS;
+}
+
+static int static_route(struct vty *vty, afi_t afi, safi_t safi,
+			const char *negate, const char *dest_str,
+			const char *mask_str, const char *src_str,
+			const char *gate_str, const char *ifname,
+			const char *flag_str, const char *tag_str,
+			const char *distance_str, const char *vrf_name,
+			const char *label_str, const char *table_str)
+{
+	struct static_vrf *svrf;
+
+	/* VRF id */
+	svrf = static_vrf_lookup_by_name(vrf_name);
+
+	/* When trying to delete, the VRF must exist. */
+	if (negate && !svrf) {
+		vty_out(vty, "%% vrf %s is not defined\n", vrf_name);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	/* When trying to create, create the VRF if it doesn't exist.
+	 * Note: The VRF isn't active until we hear about it from the kernel.
+	 */
+	if (!svrf) {
+		svrf = static_vty_get_unknown_vrf(vty, vrf_name);
+		if (!svrf)
+			return CMD_WARNING_CONFIG_FAILED;
+	}
+	return static_route_leak(
+		vty, svrf, svrf, afi, safi, negate, dest_str, mask_str, src_str,
+		gate_str, ifname, flag_str, tag_str, distance_str, label_str,
+		table_str);
+}
+
+void static_config_install_delayed_routes(struct static_vrf *svrf)
+{
+	struct listnode *node, *nnode;
+	struct static_hold_route *shr;
+	struct static_vrf *osvrf, *nh_svrf;
+	int installed;
+
+	for (ALL_LIST_ELEMENTS(static_list, node, nnode, shr)) {
+		osvrf = static_vrf_lookup_by_name(shr->vrf_name);
+		nh_svrf = static_vrf_lookup_by_name(shr->nhvrf_name);
+
+		if (osvrf != svrf && nh_svrf != svrf)
+			continue;
+
+		if (osvrf->vrf->vrf_id == VRF_UNKNOWN
+		    || nh_svrf->vrf->vrf_id == VRF_UNKNOWN)
+			continue;
+
+		installed = static_route_leak(
+			NULL, osvrf, nh_svrf, shr->afi, shr->safi, NULL,
+			shr->dest_str, shr->mask_str, shr->src_str,
+			shr->gate_str, shr->ifname, shr->flag_str, shr->tag_str,
+			shr->distance_str, shr->label_str, shr->table_str);
+
+		if (installed != CMD_SUCCESS)
+			zlog_debug(
+				"%s: Attempt to install %s as a route and it was rejected",
+				__PRETTY_FUNCTION__, shr->dest_str);
+		listnode_delete(static_list, shr);
+		static_list_delete(shr);
+	}
+}
+
+/* Write static route configuration. */
+int static_config(struct vty *vty, struct static_vrf *svrf, afi_t afi,
+		  safi_t safi, const char *cmd)
+{
+	struct static_hold_route *shr;
+	struct listnode *node;
+	char spacing[100];
+	struct route_node *rn;
+	struct static_route *si;
+	struct route_table *stable;
+	char buf[SRCDEST2STR_BUFFER];
+	int write = 0;
+
+	stable = svrf->stable[afi][safi];
+	if (stable == NULL)
+		return write;
+
+	sprintf(spacing, "%s%s", (svrf->vrf->vrf_id == VRF_DEFAULT) ? "" : " ",
+		cmd);
+
+	/*
+	 * Static routes for vrfs not fully inited
+	 */
+	for (ALL_LIST_ELEMENTS_RO(static_list, node, shr)) {
+		if (shr->afi != afi || shr->safi != safi)
+			continue;
+
+		if (strcmp(svrf->vrf->name, shr->vrf_name) != 0)
+			continue;
+
+		char dest_str[PREFIX_STRLEN];
+
+		prefix2str(&shr->dest, dest_str, sizeof(dest_str));
+
+		vty_out(vty, "%s ", spacing);
+		if (shr->dest_str)
+			vty_out(vty, "%s ", dest_str);
+		if (shr->src_str)
+			vty_out(vty, "from %s ", shr->src_str);
+		if (shr->gate_str)
+			vty_out(vty, "%s ", shr->gate_str);
+		if (shr->ifname)
+			vty_out(vty, "%s ", shr->ifname);
+		if (shr->flag_str)
+			vty_out(vty, "%s ", shr->flag_str);
+		if (shr->tag_str)
+			vty_out(vty, "tag %s ", shr->tag_str);
+		if (shr->distance_str)
+			vty_out(vty, "%s ", shr->distance_str);
+		if (shr->label_str)
+			vty_out(vty, "label %s ", shr->label_str);
+		if (shr->table_str)
+			vty_out(vty, "table %s", shr->table_str);
+		if (strcmp(shr->vrf_name, shr->nhvrf_name) != 0)
+			vty_out(vty, "nexthop-vrf %s", shr->nhvrf_name);
+		vty_out(vty, "\n");
+	}
+
+	for (rn = route_top(stable); rn; rn = srcdest_route_next(rn))
+		for (si = rn->info; si; si = si->next) {
+			vty_out(vty, "%s %s", spacing,
+				srcdest_rnode2str(rn, buf, sizeof(buf)));
+
+			switch (si->type) {
+			case STATIC_IPV4_GATEWAY:
+				vty_out(vty, " %s", inet_ntoa(si->addr.ipv4));
+				break;
+			case STATIC_IPV6_GATEWAY:
+				vty_out(vty, " %s",
+					inet_ntop(AF_INET6, &si->addr.ipv6, buf,
+						  sizeof(buf)));
+				break;
+			case STATIC_IFNAME:
+				vty_out(vty, " %s", si->ifname);
+				break;
+			case STATIC_BLACKHOLE:
+				switch (si->bh_type) {
+				case STATIC_BLACKHOLE_DROP:
+					vty_out(vty, " blackhole");
+					break;
+				case STATIC_BLACKHOLE_NULL:
+					vty_out(vty, " Null0");
+					break;
+				case STATIC_BLACKHOLE_REJECT:
+					vty_out(vty, " reject");
+					break;
+				}
+				break;
+			case STATIC_IPV4_GATEWAY_IFNAME:
+				vty_out(vty, " %s %s",
+					inet_ntop(AF_INET, &si->addr.ipv4, buf,
+						  sizeof(buf)),
+					si->ifname);
+				break;
+			case STATIC_IPV6_GATEWAY_IFNAME:
+				vty_out(vty, " %s %s",
+					inet_ntop(AF_INET6, &si->addr.ipv6, buf,
+						  sizeof(buf)),
+					si->ifname);
+				break;
+			}
+
+			if (si->tag)
+				vty_out(vty, " tag %" ROUTE_TAG_PRI, si->tag);
+
+			if (si->distance != ZEBRA_STATIC_DISTANCE_DEFAULT)
+				vty_out(vty, " %d", si->distance);
+
+			/* Label information */
+			if (si->snh_label.num_labels)
+				vty_out(vty, " label %s",
+					mpls_label2str(si->snh_label.num_labels,
+						       si->snh_label.label, buf,
+						       sizeof(buf), 0));
+
+			if (si->nh_vrf_id != si->vrf_id)
+				vty_out(vty, " nexthop-vrf %s", si->nh_vrfname);
+
+			/*
+			 * table ID from VRF overrides configured
+			 */
+			if (si->table_id &&
+			    svrf->vrf->data.l.table_id == RT_TABLE_MAIN)
+				vty_out(vty, " table %u", si->table_id);
+
+			vty_out(vty, "\n");
+
+			write = 1;
+		}
+	return write;
+}
+
+/* Static unicast routes for multicast RPF lookup. */
+DEFPY (ip_mroute_dist,
+       ip_mroute_dist_cmd,
+       "[no] ip mroute A.B.C.D/M$prefix <A.B.C.D$gate|INTERFACE$ifname> [(1-255)$distance]",
+       NO_STR
+       IP_STR
+       "Configure static unicast route into MRIB for multicast RPF lookup\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Nexthop address\n"
+       "Nexthop interface name\n"
+       "Distance\n")
+{
+	return static_route(vty, AFI_IP, SAFI_MULTICAST, no, prefix_str,
+			    NULL, NULL, gate_str, ifname, NULL, NULL,
+			    distance_str, NULL, NULL, NULL);
+}
+
+/* Static route configuration.  */
+DEFPY(ip_route_blackhole,
+      ip_route_blackhole_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask>                        \
+	<reject|blackhole>$flag                                               \
+	[{                                                                    \
+	  tag (1-4294967295)                                                  \
+	  |(1-255)$distance                                                   \
+	  |vrf NAME                                                           \
+	  |label WORD                                                         \
+          |table (1-4294967295)                                               \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "Emit an ICMP unreachable when matched\n"
+      "Silently discard pkts when matched\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n")
+{
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route(vty, AFI_IP, SAFI_UNICAST, no, prefix,
+			    mask_str, NULL, NULL, NULL, flag, tag_str,
+			    distance_str, vrf, label, table_str);
+}
+
+DEFPY(ip_route_blackhole_vrf,
+      ip_route_blackhole_vrf_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask>                        \
+	<reject|blackhole>$flag                                               \
+	[{                                                                    \
+	  tag (1-4294967295)                                                  \
+	  |(1-255)$distance                                                   \
+	  |label WORD                                                         \
+	  |table (1-4294967295)                                               \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "Emit an ICMP unreachable when matched\n"
+      "Silently discard pkts when matched\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n")
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	struct static_vrf *svrf = vrf->info;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	/*
+	 * Coverity is complaining that prefix could
+	 * be dereferenced, but we know that prefix will
+	 * valid.  Add an assert to make it happy
+	 */
+	assert(prefix);
+	return static_route_leak(vty, svrf, svrf, AFI_IP, SAFI_UNICAST,
+				 no, prefix, mask_str, NULL, NULL, NULL,
+				 flag, tag_str, distance_str, label, table_str);
+}
+
+DEFPY(ip_route_address_interface,
+      ip_route_address_interface_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
+	A.B.C.D$gate                                   \
+	INTERFACE$ifname                               \
+	[{                                             \
+	  tag (1-4294967295)                           \
+	  |(1-255)$distance                            \
+	  |vrf NAME                                    \
+	  |label WORD                                  \
+	  |table (1-4294967295)                        \
+	  |nexthop-vrf NAME                            \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "IP gateway address\n"
+      "IP gateway interface name. Specify 'Null0' (case-insensitive) for a \
+      null route.\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	struct static_vrf *svrf;
+	struct static_vrf *nh_svrf;
+	const char *flag = NULL;
+
+	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
+		flag = "Null0";
+		ifname = NULL;
+	}
+
+	svrf = static_vty_get_unknown_vrf(vty, vrf);
+	if (!svrf) {
+		vty_out(vty, "%% vrf %s is not defined\n", vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
+		NULL, gate_str, ifname, flag, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ip_route_address_interface_vrf,
+      ip_route_address_interface_vrf_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
+	A.B.C.D$gate                                   \
+	INTERFACE$ifname                               \
+	[{                                             \
+	  tag (1-4294967295)                           \
+	  |(1-255)$distance                            \
+	  |label WORD                                  \
+	  |table (1-4294967295)                        \
+	  |nexthop-vrf NAME                            \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "IP gateway address\n"
+      "IP gateway interface name. Specify 'Null0' (case-insensitive) for a \
+      null route.\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	const char *flag = NULL;
+	struct static_vrf *svrf = vrf->info;
+	struct static_vrf *nh_svrf;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
+		flag = "Null0";
+		ifname = NULL;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
+		NULL, gate_str, ifname, flag, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ip_route,
+      ip_route_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
+	<A.B.C.D$gate|INTERFACE$ifname>                \
+	[{                                             \
+	  tag (1-4294967295)                           \
+	  |(1-255)$distance                            \
+	  |vrf NAME                                    \
+	  |label WORD                                  \
+	  |table (1-4294967295)                        \
+	  |nexthop-vrf NAME                            \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "IP gateway address\n"
+      "IP gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	struct static_vrf *svrf;
+	struct static_vrf *nh_svrf;
+	const char *flag = NULL;
+
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
+		flag = "Null0";
+		ifname = NULL;
+	}
+
+	svrf = static_vty_get_unknown_vrf(vty, vrf);
+	if (!svrf) {
+		vty_out(vty, "%% vrf %s is not defined\n", vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
+		NULL, gate_str, ifname, flag, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ip_route_vrf,
+      ip_route_vrf_cmd,
+      "[no] ip route\
+	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
+	<A.B.C.D$gate|INTERFACE$ifname>                \
+	[{                                             \
+	  tag (1-4294967295)                           \
+	  |(1-255)$distance                            \
+	  |label WORD                                  \
+	  |table (1-4294967295)                        \
+	  |nexthop-vrf NAME                            \
+          }]",
+      NO_STR IP_STR
+      "Establish static routes\n"
+      "IP destination prefix (e.g. 10.0.0.0/8)\n"
+      "IP destination prefix\n"
+      "IP destination prefix mask\n"
+      "IP gateway address\n"
+      "IP gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this route\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	struct static_vrf *svrf = vrf->info;
+	struct static_vrf *nh_svrf;
+	const char *flag = NULL;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
+		flag = "Null0";
+		ifname = NULL;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
+		NULL, gate_str, ifname, flag, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ipv6_route_blackhole,
+      ipv6_route_blackhole_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          <Null0|reject|blackhole>$flag                    \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |vrf NAME                                      \
+            |label WORD                                    \
+            |table (1-4294967295)                          \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "Null interface\n"
+      "Emit an ICMP unreachable when matched\n"
+      "Silently discard pkts when matched\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n")
+{
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route(vty, AFI_IP6, SAFI_UNICAST, no, prefix_str,
+			    NULL, from_str, NULL, NULL, flag, tag_str,
+			    distance_str, vrf, label, table_str);
+}
+
+DEFPY(ipv6_route_blackhole_vrf,
+      ipv6_route_blackhole_vrf_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          <Null0|reject|blackhole>$flag                    \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |label WORD                                    \
+            |table (1-4294967295)                          \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "Null interface\n"
+      "Emit an ICMP unreachable when matched\n"
+      "Silently discard pkts when matched\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n")
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	struct static_vrf *svrf = vrf->info;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	/*
+	 * Coverity is complaining that prefix could
+	 * be dereferenced, but we know that prefix will
+	 * valid.  Add an assert to make it happy
+	 */
+	assert(prefix);
+	return static_route_leak(
+		vty, svrf, svrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
+		from_str, NULL, NULL, flag, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ipv6_route_address_interface,
+      ipv6_route_address_interface_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          X:X::X:X$gate                                    \
+          INTERFACE$ifname                                 \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |vrf NAME                                      \
+            |label WORD                                    \
+	    |table (1-4294967295)                          \
+            |nexthop-vrf NAME                              \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "IPv6 gateway address\n"
+      "IPv6 gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	struct static_vrf *svrf;
+	struct static_vrf *nh_svrf;
+
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	svrf = static_vty_get_unknown_vrf(vty, vrf);
+	if (!svrf) {
+		vty_out(vty, "%% vrf %s is not defined\n", vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
+		from_str, gate_str, ifname, NULL, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ipv6_route_address_interface_vrf,
+      ipv6_route_address_interface_vrf_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          X:X::X:X$gate                                    \
+          INTERFACE$ifname                                 \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |label WORD                                    \
+	    |table (1-4294967295)                          \
+            |nexthop-vrf NAME                              \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "IPv6 gateway address\n"
+      "IPv6 gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	struct static_vrf *svrf = vrf->info;
+	struct static_vrf *nh_svrf;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
+		from_str, gate_str, ifname, NULL, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ipv6_route,
+      ipv6_route_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          <X:X::X:X$gate|INTERFACE$ifname>                 \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |vrf NAME                                      \
+            |label WORD                                    \
+	    |table (1-4294967295)                          \
+            |nexthop-vrf NAME                              \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "IPv6 gateway address\n"
+      "IPv6 gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      VRF_CMD_HELP_STR
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	struct static_vrf *svrf;
+	struct static_vrf *nh_svrf;
+
+	if (table_str && vrf && !vrf_is_mapped_on_netns(vrf_lookup_by_name(vrf))) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	svrf = static_vty_get_unknown_vrf(vty, vrf);
+	if (!svrf) {
+		vty_out(vty, "%% vrf %s is not defined\n", vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
+		from_str, gate_str, ifname, NULL, tag_str, distance_str, label,
+		table_str);
+}
+
+DEFPY(ipv6_route_vrf,
+      ipv6_route_vrf_cmd,
+      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
+          <X:X::X:X$gate|INTERFACE$ifname>                 \
+          [{                                               \
+            tag (1-4294967295)                             \
+            |(1-255)$distance                              \
+            |label WORD                                    \
+	    |table (1-4294967295)                          \
+            |nexthop-vrf NAME                              \
+          }]",
+      NO_STR
+      IPV6_STR
+      "Establish static routes\n"
+      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+      "IPv6 source-dest route\n"
+      "IPv6 source prefix\n"
+      "IPv6 gateway address\n"
+      "IPv6 gateway interface name\n"
+      "Set tag for this route\n"
+      "Tag value\n"
+      "Distance value for this prefix\n"
+      MPLS_LABEL_HELPSTR
+      "Table to configure\n"
+      "The table number to configure\n"
+      VRF_CMD_HELP_STR)
+{
+	VTY_DECLVAR_CONTEXT(vrf, vrf);
+	struct static_vrf *svrf = vrf->info;
+	struct static_vrf *nh_svrf;
+
+	if (table_str && !vrf_is_mapped_on_netns(vrf)) {
+		vty_out(vty,
+			"%% table param only available when running on netns-based vrfs\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (nexthop_vrf)
+		nh_svrf = static_vty_get_unknown_vrf(vty, nexthop_vrf);
+	else
+		nh_svrf = svrf;
+
+	if (!nh_svrf) {
+		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	return static_route_leak(
+		vty, svrf, nh_svrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
+		from_str, gate_str, ifname, NULL, tag_str, distance_str, label,
+		table_str);
+}
+
+void static_vty_init(void)
+{
+	install_element(CONFIG_NODE, &ip_mroute_dist_cmd);
+
+	install_element(CONFIG_NODE, &ip_route_blackhole_cmd);
+	install_element(VRF_NODE, &ip_route_blackhole_vrf_cmd);
+	install_element(CONFIG_NODE, &ip_route_address_interface_cmd);
+	install_element(VRF_NODE, &ip_route_address_interface_vrf_cmd);
+	install_element(CONFIG_NODE, &ip_route_cmd);
+	install_element(VRF_NODE, &ip_route_vrf_cmd);
+
+	install_element(CONFIG_NODE, &ipv6_route_blackhole_cmd);
+	install_element(VRF_NODE, &ipv6_route_blackhole_vrf_cmd);
+	install_element(CONFIG_NODE, &ipv6_route_address_interface_cmd);
+	install_element(VRF_NODE, &ipv6_route_address_interface_vrf_cmd);
+	install_element(CONFIG_NODE, &ipv6_route_cmd);
+	install_element(VRF_NODE, &ipv6_route_vrf_cmd);
+
+	static_list = list_new();
+	static_list->cmp = (int (*)(void *, void *))static_list_compare;
+	static_list->del = (void (*)(void *))static_list_delete;
+}
diff -urpN frr-frr-5.0.1/staticd/static_vty.h frr-frr-6.0/staticd/static_vty.h
--- frr-frr-5.0.1/staticd/static_vty.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_vty.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ * STATICd - vty header
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef __STATIC_VTY_H__
+#define __STATIC_VTY_H__
+
+void static_config_install_delayed_routes(struct static_vrf *svrf);
+
+int static_config(struct vty *vty, struct static_vrf *svrf,
+		  afi_t afi, safi_t safi, const char *cmd);
+
+void static_vty_init(void);
+#endif
diff -urpN frr-frr-5.0.1/staticd/static_zebra.c frr-frr-6.0/staticd/static_zebra.c
--- frr-frr-5.0.1/staticd/static_zebra.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_zebra.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,480 @@
+/*
+ * Zebra connect code.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include <zebra.h>
+
+#include "thread.h"
+#include "command.h"
+#include "network.h"
+#include "prefix.h"
+#include "routemap.h"
+#include "table.h"
+#include "srcdest_table.h"
+#include "stream.h"
+#include "memory.h"
+#include "zclient.h"
+#include "filter.h"
+#include "plist.h"
+#include "log.h"
+#include "nexthop.h"
+#include "nexthop_group.h"
+#include "hash.h"
+#include "jhash.h"
+
+#include "static_vrf.h"
+#include "static_routes.h"
+#include "static_zebra.h"
+#include "static_nht.h"
+#include "static_vty.h"
+
+/* Zebra structure to hold current status. */
+struct zclient *zclient;
+static struct hash *static_nht_hash;
+
+static struct interface *zebra_interface_if_lookup(struct stream *s)
+{
+	char ifname_tmp[INTERFACE_NAMSIZ];
+
+	/* Read interface name. */
+	stream_get(ifname_tmp, s, INTERFACE_NAMSIZ);
+
+	/* And look it up. */
+	return if_lookup_by_name(ifname_tmp, VRF_DEFAULT);
+}
+
+/* Inteface addition message from zebra. */
+static int interface_add(int command, struct zclient *zclient,
+			       zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct interface *ifp;
+
+	ifp = zebra_interface_add_read(zclient->ibuf, vrf_id);
+
+	if (!ifp)
+		return 0;
+
+	static_ifindex_update(ifp, true);
+	return 0;
+}
+
+static int interface_delete(int command, struct zclient *zclient,
+			    zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct interface *ifp;
+	struct stream *s;
+
+	s = zclient->ibuf;
+	/* zebra_interface_state_read () updates interface structure in iflist
+	 */
+	ifp = zebra_interface_state_read(s, vrf_id);
+
+	if (ifp == NULL)
+		return 0;
+
+	if_set_index(ifp, IFINDEX_INTERNAL);
+
+	static_ifindex_update(ifp, false);
+	return 0;
+}
+
+static int interface_address_add(int command, struct zclient *zclient,
+				 zebra_size_t length, vrf_id_t vrf_id)
+{
+	zebra_interface_address_read(command, zclient->ibuf, vrf_id);
+
+	return 0;
+}
+
+static int interface_address_delete(int command, struct zclient *zclient,
+				    zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct connected *c;
+
+	c = zebra_interface_address_read(command, zclient->ibuf, vrf_id);
+
+	if (!c)
+		return 0;
+
+	connected_free(c);
+	return 0;
+}
+
+static int interface_state_up(int command, struct zclient *zclient,
+			      zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct interface *ifp;
+
+	ifp = zebra_interface_if_lookup(zclient->ibuf);
+
+	if (ifp && if_is_vrf(ifp)) {
+		struct static_vrf *svrf = static_vrf_lookup_by_id(vrf_id);
+
+		static_fixup_vrf_ids(svrf);
+		static_config_install_delayed_routes(svrf);
+	}
+
+	return 0;
+}
+
+static int interface_state_down(int command, struct zclient *zclient,
+				zebra_size_t length, vrf_id_t vrf_id)
+{
+	zebra_interface_state_read(zclient->ibuf, vrf_id);
+
+	return 0;
+}
+
+static int route_notify_owner(int command, struct zclient *zclient,
+			      zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct prefix p;
+	enum zapi_route_notify_owner note;
+	uint32_t table_id;
+	char buf[PREFIX_STRLEN];
+
+	prefix2str(&p, buf, sizeof(buf));
+
+	if (!zapi_route_notify_decode(zclient->ibuf, &p, &table_id, &note))
+		return -1;
+
+	switch (note) {
+	case ZAPI_ROUTE_FAIL_INSTALL:
+		zlog_warn("%s: Route %s failed to install for table: %u",
+			  __PRETTY_FUNCTION__, buf, table_id);
+		break;
+	case ZAPI_ROUTE_BETTER_ADMIN_WON:
+		zlog_warn("%s: Route %s over-ridden by better route for table: %u",
+			  __PRETTY_FUNCTION__, buf, table_id);
+		break;
+	case ZAPI_ROUTE_INSTALLED:
+		break;
+	case ZAPI_ROUTE_REMOVED:
+		break;
+	case ZAPI_ROUTE_REMOVE_FAIL:
+		zlog_warn("%s: Route %s failure to remove for table: %u",
+			  __PRETTY_FUNCTION__, buf, table_id);
+		break;
+	}
+
+	return 0;
+}
+static void zebra_connected(struct zclient *zclient)
+{
+	zclient_send_reg_requests(zclient, VRF_DEFAULT);
+}
+
+struct static_nht_data {
+	struct prefix *nh;
+
+	vrf_id_t nh_vrf_id;
+
+	uint32_t refcount;
+	uint8_t nh_num;
+};
+
+static int static_zebra_nexthop_update(int command, struct zclient *zclient,
+				       zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct static_nht_data *nhtd, lookup;
+	struct zapi_route nhr;
+	afi_t afi = AFI_IP;
+
+	if (!zapi_nexthop_update_decode(zclient->ibuf, &nhr)) {
+		zlog_warn("Failure to decode nexthop update message");
+		return 1;
+	}
+
+	if (nhr.prefix.family == AF_INET6)
+		afi = AFI_IP6;
+
+	memset(&lookup, 0, sizeof(lookup));
+	lookup.nh = &nhr.prefix;
+	lookup.nh_vrf_id = vrf_id;
+
+	nhtd = hash_lookup(static_nht_hash, &lookup);
+
+	if (nhtd) {
+		nhtd->nh_num = nhr.nexthop_num;
+
+		static_nht_update(&nhr.prefix, nhr.nexthop_num, afi,
+				  nhtd->nh_vrf_id);
+	} else
+		zlog_err("No nhtd?");
+
+	return 1;
+}
+
+static void static_zebra_capabilities(struct zclient_capabilities *cap)
+{
+	mpls_enabled = cap->mpls_enabled;
+}
+
+static unsigned int static_nht_hash_key(void *data)
+{
+	struct static_nht_data *nhtd = data;
+	unsigned int key = 0;
+
+	key = prefix_hash_key(nhtd->nh);
+	return jhash_1word(nhtd->nh_vrf_id, key);
+}
+
+static int static_nht_hash_cmp(const void *d1, const void *d2)
+{
+	const struct static_nht_data *nhtd1 = d1;
+	const struct static_nht_data *nhtd2 = d2;
+
+	if (nhtd1->nh_vrf_id != nhtd2->nh_vrf_id)
+		return 0;
+
+	return prefix_same(nhtd1->nh, nhtd2->nh);
+}
+
+static void *static_nht_hash_alloc(void *data)
+{
+	struct static_nht_data *copy = data;
+	struct static_nht_data *new;
+
+	new = XMALLOC(MTYPE_TMP, sizeof(*new));
+
+	new->nh = prefix_new();
+	prefix_copy(new->nh, copy->nh);
+	new->refcount = 0;
+	new->nh_num = 0;
+	new->nh_vrf_id = copy->nh_vrf_id;
+
+	return new;
+}
+
+static void static_nht_hash_free(void *data)
+{
+	struct static_nht_data *nhtd = data;
+
+	prefix_free(nhtd->nh);
+	XFREE(MTYPE_TMP, nhtd);
+}
+
+void static_zebra_nht_register(struct static_route *si, bool reg)
+{
+	struct static_nht_data *nhtd, lookup;
+	uint32_t cmd;
+	struct prefix p;
+	afi_t afi = AFI_IP;
+
+	cmd = (reg) ?
+		ZEBRA_NEXTHOP_REGISTER : ZEBRA_NEXTHOP_UNREGISTER;
+
+	if (si->nh_registered && reg)
+		return;
+
+	if (!si->nh_registered && !reg)
+		return;
+
+	memset(&p, 0, sizeof(p));
+	switch (si->type) {
+	case STATIC_IFNAME:
+	case STATIC_BLACKHOLE:
+		return;
+	case STATIC_IPV4_GATEWAY:
+	case STATIC_IPV4_GATEWAY_IFNAME:
+		p.family = AF_INET;
+		p.prefixlen = IPV4_MAX_BITLEN;
+		p.u.prefix4 = si->addr.ipv4;
+		afi = AFI_IP;
+		break;
+	case STATIC_IPV6_GATEWAY:
+	case STATIC_IPV6_GATEWAY_IFNAME:
+		p.family = AF_INET6;
+		p.prefixlen = IPV6_MAX_BITLEN;
+		p.u.prefix6 = si->addr.ipv6;
+		afi = AFI_IP6;
+		break;
+	}
+
+	memset(&lookup, 0, sizeof(lookup));
+	lookup.nh = &p;
+	lookup.nh_vrf_id = si->nh_vrf_id;
+
+	si->nh_registered = reg;
+
+	if (reg) {
+		nhtd = hash_get(static_nht_hash, &lookup,
+				static_nht_hash_alloc);
+		nhtd->refcount++;
+
+		if (nhtd->refcount > 1) {
+			static_nht_update(nhtd->nh, nhtd->nh_num,
+					  afi, si->nh_vrf_id);
+			return;
+		}
+	} else {
+		nhtd = hash_lookup(static_nht_hash, &lookup);
+		if (!nhtd)
+			return;
+
+		nhtd->refcount--;
+		if (nhtd->refcount >= 1)
+			return;
+
+		hash_release(static_nht_hash, nhtd);
+		static_nht_hash_free(nhtd);
+	}
+
+	if (zclient_send_rnh(zclient, cmd, &p, false, si->nh_vrf_id) < 0)
+		zlog_warn("%s: Failure to send nexthop to zebra",
+			  __PRETTY_FUNCTION__);
+}
+
+extern void static_zebra_route_add(struct route_node *rn,
+				   struct static_route *si_changed,
+				   vrf_id_t vrf_id, safi_t safi, bool install)
+{
+	struct static_route *si = rn->info;
+	const struct prefix *p, *src_pp;
+	struct zapi_nexthop *api_nh;
+	struct zapi_route api;
+	uint32_t nh_num = 0;
+
+	p = src_pp = NULL;
+	srcdest_rnode_prefixes(rn, &p, &src_pp);
+
+	memset(&api, 0, sizeof(api));
+	api.vrf_id = vrf_id;
+	api.type = ZEBRA_ROUTE_STATIC;
+	api.safi = safi;
+	memcpy(&api.prefix, p, sizeof(api.prefix));
+
+	if (src_pp) {
+		SET_FLAG(api.message, ZAPI_MESSAGE_SRCPFX);
+		memcpy(&api.src_prefix, src_pp, sizeof(api.src_prefix));
+	}
+	SET_FLAG(api.flags, ZEBRA_FLAG_RR_USE_DISTANCE);
+	SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);
+	if (si_changed->distance) {
+		SET_FLAG(api.message, ZAPI_MESSAGE_DISTANCE);
+		api.distance = si_changed->distance;
+	}
+	if (si_changed->tag) {
+		SET_FLAG(api.message, ZAPI_MESSAGE_TAG);
+		api.tag = si_changed->tag;
+	}
+	if (si_changed->table_id != 0) {
+		SET_FLAG(api.message, ZAPI_MESSAGE_TABLEID);
+		api.tableid = si_changed->table_id;
+	}
+	for (/*loaded above*/; si; si = si->next) {
+		api_nh = &api.nexthops[nh_num];
+		if (si->nh_vrf_id == VRF_UNKNOWN)
+			continue;
+
+		if (si->distance != si_changed->distance)
+			continue;
+
+		api_nh->vrf_id = si->nh_vrf_id;
+		switch (si->type) {
+		case STATIC_IFNAME:
+			if (si->ifindex == IFINDEX_INTERNAL)
+				continue;
+			api_nh->ifindex = si->ifindex;
+			api_nh->type = NEXTHOP_TYPE_IFINDEX;
+			break;
+		case STATIC_IPV4_GATEWAY:
+			if (!si->nh_valid)
+				continue;
+			api_nh->type = NEXTHOP_TYPE_IPV4;
+			api_nh->gate = si->addr;
+			break;
+		case STATIC_IPV4_GATEWAY_IFNAME:
+			if (si->ifindex == IFINDEX_INTERNAL)
+				continue;
+			api_nh->ifindex = si->ifindex;
+			api_nh->type = NEXTHOP_TYPE_IPV4_IFINDEX;
+			api_nh->gate = si->addr;
+			break;
+		case STATIC_IPV6_GATEWAY:
+			if (!si->nh_valid)
+				continue;
+			api_nh->type = NEXTHOP_TYPE_IPV6;
+			api_nh->gate = si->addr;
+			break;
+		case STATIC_IPV6_GATEWAY_IFNAME:
+			if (si->ifindex == IFINDEX_INTERNAL)
+				continue;
+			api_nh->type = NEXTHOP_TYPE_IPV6_IFINDEX;
+			api_nh->ifindex = si->ifindex;
+			api_nh->gate = si->addr;
+			break;
+		case STATIC_BLACKHOLE:
+			api_nh->type = NEXTHOP_TYPE_BLACKHOLE;
+			switch (si->bh_type) {
+			case STATIC_BLACKHOLE_DROP:
+			case STATIC_BLACKHOLE_NULL:
+				api_nh->bh_type = BLACKHOLE_NULL;
+				break;
+			case STATIC_BLACKHOLE_REJECT:
+				api_nh->bh_type = BLACKHOLE_REJECT;
+			}
+			break;
+		}
+
+		if (si->snh_label.num_labels) {
+			int i;
+
+			SET_FLAG(api.message, ZAPI_MESSAGE_LABEL);
+			api_nh->label_num = si->snh_label.num_labels;
+			for (i = 0; i < api_nh->label_num; i++)
+				api_nh->labels[i] = si->snh_label.label[i];
+		}
+		nh_num++;
+	}
+
+	api.nexthop_num = nh_num;
+
+	/*
+	 * If we have been given an install but nothing is valid
+	 * go ahead and delete the route for double plus fun
+	 */
+	if (!nh_num && install)
+		install = false;
+
+	zclient_route_send(install ?
+			   ZEBRA_ROUTE_ADD : ZEBRA_ROUTE_DELETE,
+			   zclient, &api);
+}
+void static_zebra_init(void)
+{
+	struct zclient_options opt = { .receive_notify = true };
+
+	zclient = zclient_new_notify(master, &opt);
+
+	zclient_init(zclient, ZEBRA_ROUTE_STATIC, 0, &static_privs);
+	zclient->zebra_capabilities = static_zebra_capabilities;
+	zclient->zebra_connected = zebra_connected;
+	zclient->interface_add = interface_add;
+	zclient->interface_delete = interface_delete;
+	zclient->interface_up = interface_state_up;
+	zclient->interface_down = interface_state_down;
+	zclient->interface_address_add = interface_address_add;
+	zclient->interface_address_delete = interface_address_delete;
+	zclient->route_notify_owner = route_notify_owner;
+	zclient->nexthop_update = static_zebra_nexthop_update;
+
+	static_nht_hash = hash_create(static_nht_hash_key,
+				      static_nht_hash_cmp,
+				      "Static Nexthop Tracking hash");
+}
diff -urpN frr-frr-5.0.1/staticd/static_zebra.h frr-frr-6.0/staticd/static_zebra.h
--- frr-frr-5.0.1/staticd/static_zebra.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/static_zebra.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ * Zebra connect library for staticd
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ */
+#ifndef __STATIC_ZEBRA_H__
+#define __STATIC_ZEBRA_H__
+
+extern struct thread_master *master;
+
+extern void static_zebra_nht_register(struct static_route *si, bool reg);
+
+extern void static_zebra_route_add(struct route_node *rn,
+				   struct static_route *si_changed,
+				   vrf_id_t vrf_id, safi_t safi, bool install);
+extern void static_zebra_init(void);
+#endif
diff -urpN frr-frr-5.0.1/staticd/staticd.conf.sample frr-frr-6.0/staticd/staticd.conf.sample
--- frr-frr-5.0.1/staticd/staticd.conf.sample	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/staticd.conf.sample	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,3 @@
+!
+!
+log stdout
diff -urpN frr-frr-5.0.1/staticd/subdir.am frr-frr-6.0/staticd/subdir.am
--- frr-frr-5.0.1/staticd/subdir.am	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/staticd/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,33 @@
+#
+# staticd
+#
+
+if STATICD
+noinst_LIBRARIES += staticd/libstatic.a
+sbin_PROGRAMS += staticd/staticd
+dist_examples_DATA += staticd/staticd.conf.sample
+endif
+
+staticd_libstatic_a_SOURCES = \
+	staticd/static_memory.c \
+	staticd/static_nht.c \
+	staticd/static_routes.c \
+	staticd/static_zebra.c \
+	staticd/static_vrf.c \
+	staticd/static_vty.c \
+	# end
+
+noinst_HEADERS += \
+	staticd/static_memory.h \
+	staticd/static_nht.h \
+	staticd/static_zebra.h \
+	staticd/static_routes.h \
+	staticd/static_vty.h \
+	staticd/static_vrf.h \
+	# end
+
+staticd/static_vty_clippy.c: $(CLIPPY_DEPS)
+staticd/static_vty.$(OBJEXT): staticd/static_vty_clippy.c
+
+staticd_staticd_SOURCES = staticd/static_main.c
+staticd_staticd_LDADD = staticd/libstatic.a lib/libfrr.la @LIBCAP@
diff -urpN frr-frr-5.0.1/tests/.gitignore frr-frr-6.0/tests/.gitignore
--- frr-frr-5.0.1/tests/.gitignore	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/.gitignore	2018-10-08 14:32:57.000000000 +0200
@@ -19,7 +19,9 @@ TAGS
 .arch-inventory
 .arch-ids
 __pycache__
+.pytest_cache
 /bgpd/test_aspath
+/bgpd/test_bgp_table
 /bgpd/test_capability
 /bgpd/test_ecommunity
 /bgpd/test_mp_attr
diff -urpN frr-frr-5.0.1/tests/Makefile.am frr-frr-6.0/tests/Makefile.am
--- frr-frr-5.0.1/tests/Makefile.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -3,7 +3,7 @@ include ../common.am
 PYTHON ?= python
 
 AUTOMAKE_OPTIONS = subdir-objects
-AM_CPPFLAGS = \
+AM_CPPFLAGS += \
 	-I.. \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/lib \
@@ -21,7 +21,8 @@ TESTS_BGPD = \
 	bgpd/test_peer_attr \
 	bgpd/test_ecommunity \
 	bgpd/test_mp_attr \
-	bgpd/test_mpath
+	bgpd/test_mpath \
+	bgpd/test_bgp_table
 else
 TESTS_BGPD =
 endif
@@ -143,6 +144,7 @@ bgpd_test_peer_attr_SOURCES = bgpd/test_
 bgpd_test_ecommunity_SOURCES = bgpd/test_ecommunity.c
 bgpd_test_mp_attr_SOURCES = bgpd/test_mp_attr.c
 bgpd_test_mpath_SOURCES = bgpd/test_mpath.c
+bgpd_test_bgp_table_SOURCES = bgpd/test_bgp_table.c
 isisd_test_fuzz_isis_tlv_SOURCES = isisd/test_fuzz_isis_tlv.c
 nodist_isisd_test_fuzz_isis_tlv_SOURCES = isisd/test_fuzz_isis_tlv_tests.h
 BUILT_SOURCES=isisd/test_fuzz_isis_tlv_tests.h
@@ -186,6 +188,7 @@ bgpd_test_peer_attr_LDADD = $(BGP_TEST_L
 bgpd_test_ecommunity_LDADD = $(BGP_TEST_LDADD)
 bgpd_test_mp_attr_LDADD = $(BGP_TEST_LDADD)
 bgpd_test_mpath_LDADD = $(BGP_TEST_LDADD)
+bgpd_test_bgp_table_LDADD = $(BGP_TEST_LDADD)
 isisd_test_fuzz_isis_tlv_LDADD = $(ISISD_TEST_LDADD)
 isisd_test_isis_vertex_queue_LDADD = $(ISISD_TEST_LDADD)
 ospf6d_test_lsdb_LDADD = $(OSPF6_TEST_LDADD)
@@ -220,6 +223,7 @@ EXTRA_DIST = \
     lib/test_ttable.refout \
     lib/test_zlog.py \
     lib/test_graph.py \
+    lib/test_graph.refout \
     ospf6d/test_lsdb.py \
     ospf6d/test_lsdb.in \
     ospf6d/test_lsdb.refout \
diff -urpN frr-frr-5.0.1/tests/bgpd/test_bgp_table.c frr-frr-6.0/tests/bgpd/test_bgp_table.c
--- frr-frr-5.0.1/tests/bgpd/test_bgp_table.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/tests/bgpd/test_bgp_table.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,192 @@
+/*
+ * BGP Routing table range lookup test
+ * Copyright (C) 2012 OSR.
+ * Copyright (C) 2018 Marcel Rthke (marcel.roethke@haw-hamburg.de), for HAW
+ * Hamburg
+ *
+ * This file is part of FRRouting
+ *
+ * Quagga is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * Quagga is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "prefix.h"
+#include "table.h"
+#include "bgpd/bgp_table.h"
+#include "linklist.h"
+
+/*
+ * test_node_t
+ *
+ * Information that is kept for each node in the radix tree.
+ */
+struct test_node_t {
+
+	/*
+	 * Human readable representation of the string. Allocated using
+	 * malloc()/dup().
+	 */
+	char *prefix_str;
+};
+
+/*
+ * add_node
+ *
+ * Add the given prefix (passed in as a string) to the given table.
+ */
+static void add_node(struct bgp_table *table, const char *prefix_str)
+{
+	struct prefix_ipv4 p;
+	struct test_node_t *node;
+	struct bgp_node *rn;
+
+	assert(prefix_str);
+
+	if (str2prefix_ipv4(prefix_str, &p) <= 0)
+		assert(0);
+
+	rn = bgp_node_get(table, (struct prefix *)&p);
+	if (rn->info) {
+		assert(0);
+		return;
+	}
+
+	node = malloc(sizeof(struct test_node_t));
+	assert(node);
+	node->prefix_str = strdup(prefix_str);
+	assert(node->prefix_str);
+	rn->info = node;
+}
+
+static void print_range_result(struct list *list)
+{
+
+	struct listnode *listnode;
+	struct bgp_node *bnode;
+
+	for (ALL_LIST_ELEMENTS_RO(list, listnode, bnode)) {
+		char buf[PREFIX2STR_BUFFER];
+
+		prefix2str(&bnode->p, buf, PREFIX2STR_BUFFER);
+		printf("%s\n", buf);
+	}
+}
+
+static void check_lookup_result(struct list *list, va_list arglist)
+{
+	char *prefix_str;
+	unsigned int prefix_count = 0;
+
+	printf("Searching results\n");
+	while ((prefix_str = va_arg(arglist, char *))) {
+		struct listnode *listnode;
+		struct bgp_node *bnode;
+		struct prefix p;
+		bool found = false;
+
+		prefix_count++;
+		printf("Searching for %s\n", prefix_str);
+
+		if (str2prefix(prefix_str, &p) <= 0)
+			assert(0);
+
+		for (ALL_LIST_ELEMENTS_RO(list, listnode, bnode)) {
+			if (prefix_same(&bnode->p, &p))
+				found = true;
+		}
+
+		assert(found);
+	}
+
+	printf("Checking for unexpected result items\n");
+	printf("Expecting %d found %d\n", prefix_count, listcount(list));
+	assert(prefix_count == listcount(list));
+}
+
+static void do_test(struct bgp_table *table, const char *prefix,
+		    uint32_t maxlen, ...)
+{
+	va_list arglist;
+	struct list *list = list_new();
+	struct prefix p;
+
+	list->del = (void (*)(void *))bgp_unlock_node;
+
+	va_start(arglist, maxlen);
+	printf("\nDoing lookup for %s-%d\n", prefix, maxlen);
+	if (str2prefix(prefix, &p) <= 0)
+		assert(0);
+	bgp_table_range_lookup(table, &p, maxlen, list);
+	print_range_result(list);
+
+	check_lookup_result(list, arglist);
+
+	list_delete_and_null(&list);
+
+	va_end(arglist);
+
+	printf("Checks successfull\n");
+}
+
+/*
+ * test_range_lookup
+ */
+static void test_range_lookup(void)
+{
+	struct bgp_table *table = bgp_table_init(NULL, AFI_IP, SAFI_UNICAST);
+
+	printf("Testing bgp_table_range_lookup\n");
+
+	printf("Setup bgp_table");
+	const char *prefixes[] = {"1.16.0.0/16",   "1.16.128.0/18",
+				  "1.16.192.0/18", "1.16.64.0/19",
+				  "1.16.160.0/19", "1.16.32.0/20",
+				  "1.16.32.0/21",  "16.0.0.0/16"};
+
+	int num_prefixes = sizeof(prefixes) / sizeof(prefixes[0]);
+
+	for (int i = 0; i < num_prefixes; i++)
+		add_node(table, prefixes[i]);
+
+	do_test(table, "1.16.0.0/17", 20, "1.16.64.0/19", "1.16.32.0/20", NULL);
+	do_test(table, "1.16.128.0/17", 20, "1.16.128.0/18", "1.16.192.0/18",
+		"1.16.160.0/19", NULL);
+
+	do_test(table, "1.16.128.0/17", 20, "1.16.128.0/18", "1.16.192.0/18",
+		"1.16.160.0/19", NULL);
+
+	do_test(table, "1.16.0.0/16", 18, "1.16.0.0/16", "1.16.128.0/18",
+		"1.16.192.0/18", NULL);
+
+	do_test(table, "1.16.0.0/16", 21, "1.16.0.0/16", "1.16.128.0/18",
+		"1.16.192.0/18", "1.16.64.0/19", "1.16.160.0/19",
+		"1.16.32.0/20", "1.16.32.0/21", NULL);
+
+	do_test(table, "1.17.0.0/16", 20, NULL);
+
+	do_test(table, "128.0.0.0/8", 16, NULL);
+
+	do_test(table, "16.0.0.0/8", 16, "16.0.0.0/16", NULL);
+
+	do_test(table, "0.0.0.0/3", 21, "1.16.0.0/16", "1.16.128.0/18",
+		"1.16.192.0/18", "1.16.64.0/19", "1.16.160.0/19",
+		"1.16.32.0/20", "1.16.32.0/21", "16.0.0.0/16", NULL);
+}
+
+int main(void)
+{
+	test_range_lookup();
+}
diff -urpN frr-frr-5.0.1/tests/bgpd/test_bgp_table.py frr-frr-6.0/tests/bgpd/test_bgp_table.py
--- frr-frr-5.0.1/tests/bgpd/test_bgp_table.py	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/tests/bgpd/test_bgp_table.py	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,7 @@
+import frrtest
+
+class TestTable(frrtest.TestMultiOut):
+    program = './test_bgp_table'
+
+for i in range(6):
+    TestTable.onesimple('Checks successfull')
diff -urpN frr-frr-5.0.1/tests/bgpd/test_capability.c frr-frr-6.0/tests/bgpd/test_capability.c
--- frr-frr-5.0.1/tests/bgpd/test_capability.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/bgpd/test_capability.c	2018-10-08 14:32:57.000000000 +0200
@@ -821,6 +821,7 @@ static void parse_test(struct peer *peer
 	switch (type) {
 	case CAPABILITY:
 		len += 2; /* to cover the OPT-Param header */
+		_FALLTHROUGH
 	case OPT_PARAM:
 		printf("len: %u\n", len);
 		/* peek_for_as4 wants getp at capibility*/
diff -urpN frr-frr-5.0.1/tests/bgpd/test_mp_attr.c frr-frr-6.0/tests/bgpd/test_mp_attr.c
--- frr-frr-5.0.1/tests/bgpd/test_mp_attr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/bgpd/test_mp_attr.c	2018-10-08 14:32:57.000000000 +0200
@@ -945,6 +945,24 @@ static struct test_segment mp_unreach_se
 	},
 	{NULL, NULL, {0}, 0, 0}};
 
+static struct test_segment mp_prefix_sid[] = {
+	{
+		"PREFIX-SID",
+		"PREFIX-SID Test 1",
+		{
+			0x01, 0x00, 0x07,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x02,
+			0x03, 0x00, 0x08, 0x00,
+			0x00, 0x0a, 0x1b, 0xfe,
+			0x00, 0x00, 0x0a
+		},
+		.len = 21,
+		.parses = SHOULD_PARSE,
+	},
+	{NULL, NULL, { 0 }, 0, 0},
+};
+
 /* nlri_parse indicates 0 on successful parse, and -1 otherwise.
  * attr_parse indicates BGP_ATTR_PARSE_PROCEED/0 on success,
  * and BGP_ATTR_PARSE_ERROR/-1 or lower negative ret on err.
@@ -1000,10 +1018,20 @@ static void parse_test(struct peer *peer
 
 	printf("%s: %s\n", t->name, t->desc);
 
-	if (type == BGP_ATTR_MP_REACH_NLRI)
+	switch (type) {
+	case BGP_ATTR_MP_REACH_NLRI:
 		parse_ret = bgp_mp_reach_parse(&attr_args, &nlri);
-	else
+		break;
+	case BGP_ATTR_MP_UNREACH_NLRI:
 		parse_ret = bgp_mp_unreach_parse(&attr_args, &nlri);
+		break;
+	case BGP_ATTR_PREFIX_SID:
+		parse_ret = bgp_attr_prefix_sid(t->len, &attr_args, &nlri);
+		break;
+	default:
+		printf("unknown type");
+		return;
+	}
 	if (!parse_ret) {
 		iana_afi_t pkt_afi;
 		iana_safi_t pkt_safi;
@@ -1022,7 +1050,7 @@ static void parse_test(struct peer *peer
 	if (!parse_ret) {
 		if (type == BGP_ATTR_MP_REACH_NLRI)
 			nlri_ret = bgp_nlri_parse(peer, &attr, &nlri, 0);
-		else
+		else if (type == BGP_ATTR_MP_UNREACH_NLRI)
 			nlri_ret = bgp_nlri_parse(peer, &attr, &nlri, 1);
 	}
 	handle_result(peer, t, parse_ret, nlri_ret);
@@ -1085,6 +1113,10 @@ int main(void)
 		parse_test(peer, &mp_unreach_segments[i++],
 			   BGP_ATTR_MP_UNREACH_NLRI);
 
+	i = 0;
+	while (mp_prefix_sid[i].name)
+		parse_test(peer, &mp_prefix_sid[i++],
+			   BGP_ATTR_PREFIX_SID);
 	printf("failures: %d\n", failed);
 	return failed;
 }
diff -urpN frr-frr-5.0.1/tests/bgpd/test_mpath.c frr-frr-6.0/tests/bgpd/test_mpath.c
--- frr-frr-5.0.1/tests/bgpd/test_mpath.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/bgpd/test_mpath.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,6 +37,7 @@
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_nexthop.h"
 #include "bgpd/bgp_mpath.h"
+#include "bgpd/bgp_evpn.h"
 
 #define VT100_RESET "\x1b[0m"
 #define VT100_RED "\x1b[31m"
@@ -103,6 +104,7 @@ static struct bgp *bgp_create_fake(as_t
 	bgp->group = list_new();
 	// bgp->group->cmp = (int (*)(void *, void *)) peer_group_cmp;
 
+	bgp_evpn_init(bgp);
 	for (afi = AFI_IP; afi < AFI_MAX; afi++)
 		for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
 			bgp->route[afi][safi] = bgp_table_init(bgp, afi, safi);
diff -urpN frr-frr-5.0.1/tests/bgpd/test_peer_attr.c frr-frr-6.0/tests/bgpd/test_peer_attr.c
--- frr-frr-5.0.1/tests/bgpd/test_peer_attr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/bgpd/test_peer_attr.c	2018-10-08 14:32:57.000000000 +0200
@@ -1388,7 +1388,7 @@ static void bgp_startup(void)
 	bgp_master_init(master);
 	bgp_option_set(BGP_OPT_NO_LISTEN);
 	vrf_init(NULL, NULL, NULL, NULL);
-	bgp_init(0);
+	bgp_init();
 	bgp_pthreads_run();
 }
 
diff -urpN frr-frr-5.0.1/tests/isisd/test_fuzz_isis_tlv.py frr-frr-6.0/tests/isisd/test_fuzz_isis_tlv.py
--- frr-frr-5.0.1/tests/isisd/test_fuzz_isis_tlv.py	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/isisd/test_fuzz_isis_tlv.py	2018-10-08 14:32:57.000000000 +0200
@@ -2,10 +2,21 @@ import frrtest
 
 import pytest
 import platform
+import socket
 
-if platform.uname()[0] == 'SunOS':
+
+##
+# on musl, ntop compresses a single :0: -> :: which is against RFC
+##
+def inet_ntop_broken():
+    addr = '1:2:3:4:0:6:7:8'
+    return socket.inet_ntop(socket.AF_INET6,
+                            socket.inet_pton(socket.AF_INET6, addr)) != addr
+
+
+if platform.uname()[0] == 'SunOS' or inet_ntop_broken():
     class TestFuzzIsisTLV:
-        @pytest.mark.skipif(True, reason='Test unsupported on SunOS')
+        @pytest.mark.skipif(True, reason='Test unsupported')
         def test_exit_cleanly(self):
             pass
 else:
Binary files frr-frr-5.0.1/tests/isisd/test_fuzz_isis_tlv_tests.h.gz and frr-frr-6.0/tests/isisd/test_fuzz_isis_tlv_tests.h.gz differ
diff -urpN frr-frr-5.0.1/tests/isisd/test_isis_vertex_queue.c frr-frr-6.0/tests/isisd/test_isis_vertex_queue.c
--- frr-frr-5.0.1/tests/isisd/test_isis_vertex_queue.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/isisd/test_isis_vertex_queue.c	2018-10-08 14:32:57.000000000 +0200
@@ -16,43 +16,42 @@ static size_t vertex_count;
 
 static void setup_test_vertices(void)
 {
-	struct prefix p = {
-		.family = AF_UNSPEC
+	union isis_N nid, nip = {
+		.ip.dest.family = AF_UNSPEC
 	};
-	uint8_t node_id[7];
 
 	vertices = XMALLOC(MTYPE_TMP, sizeof(*vertices) * 16);
 
-	p.family = AF_INET;
-	p.prefixlen = 24;
-	inet_pton(AF_INET, "192.168.1.0", &p.u.prefix4);
-	vertices[vertex_count] = isis_vertex_new(&p, VTYPE_IPREACH_TE);
+	nip.ip.dest.family = AF_INET;
+	nip.ip.dest.prefixlen = 24;
+	inet_pton(AF_INET, "192.168.1.0", &nip.ip.dest.u.prefix4);
+	vertices[vertex_count] = isis_vertex_new(&nip, VTYPE_IPREACH_TE);
 	vertices[vertex_count]->d_N = 20;
 	vertex_count++;
 
-	p.family = AF_INET;
-	p.prefixlen = 24;
-	inet_pton(AF_INET, "192.168.2.0", &p.u.prefix4);
-	vertices[vertex_count] = isis_vertex_new(&p, VTYPE_IPREACH_TE);
+	nip.ip.dest.family = AF_INET;
+	nip.ip.dest.prefixlen = 24;
+	inet_pton(AF_INET, "192.168.2.0", &nip.ip.dest.u.prefix4);
+	vertices[vertex_count] = isis_vertex_new(&nip, VTYPE_IPREACH_TE);
 	vertices[vertex_count]->d_N = 20;
 	vertex_count++;
 
-	memset(node_id, 0, sizeof(node_id));
-	node_id[6] = 1;
-	vertices[vertex_count] = isis_vertex_new(node_id, VTYPE_PSEUDO_TE_IS);
+	memset(nid.id, 0, sizeof(nid.id));
+	nid.id[6] = 1;
+	vertices[vertex_count] = isis_vertex_new(&nid, VTYPE_PSEUDO_TE_IS);
 	vertices[vertex_count]->d_N = 15;
 	vertex_count++;
 
-	memset(node_id, 0, sizeof(node_id));
-	node_id[5] = 2;
-	vertices[vertex_count] = isis_vertex_new(node_id, VTYPE_NONPSEUDO_TE_IS);
+	memset(nid.id, 0, sizeof(nid.id));
+	nid.id[5] = 2;
+	vertices[vertex_count] = isis_vertex_new(&nid, VTYPE_NONPSEUDO_TE_IS);
 	vertices[vertex_count]->d_N = 15;
 	vertex_count++;
 
-	p.family = AF_INET;
-	p.prefixlen = 24;
-	inet_pton(AF_INET, "192.168.3.0", &p.u.prefix4);
-	vertices[vertex_count] = isis_vertex_new(&p, VTYPE_IPREACH_TE);
+	nip.ip.dest.family = AF_INET;
+	nip.ip.dest.prefixlen = 24;
+	inet_pton(AF_INET, "192.168.3.0", &nip.ip.dest.u.prefix4);
+	vertices[vertex_count] = isis_vertex_new(&nip, VTYPE_IPREACH_TE);
 	vertices[vertex_count]->d_N = 20;
 	vertex_count++;
 };
@@ -76,23 +75,23 @@ static void test_ordered(void)
 	assert(isis_vertex_queue_count(&q) == vertex_count);
 
 	for (size_t i = 0; i < vertex_count; i++) {
-		assert(isis_find_vertex(&q, vertices[i]->N.id, vertices[i]->type) == vertices[i]);
+		assert(isis_find_vertex(&q, &vertices[i]->N, vertices[i]->type) == vertices[i]);
 	}
 
 	assert(isis_vertex_queue_pop(&q) == vertices[2]);
-	assert(isis_find_vertex(&q, vertices[2]->N.id, vertices[2]->type) == NULL);
+	assert(isis_find_vertex(&q, &vertices[2]->N, vertices[2]->type) == NULL);
 
 	assert(isis_vertex_queue_pop(&q) == vertices[3]);
-	assert(isis_find_vertex(&q, vertices[3]->N.id, vertices[3]->type) == NULL);
+	assert(isis_find_vertex(&q, &vertices[3]->N, vertices[3]->type) == NULL);
 
 	assert(isis_vertex_queue_pop(&q) == vertices[0]);
-	assert(isis_find_vertex(&q, vertices[0]->N.id, vertices[0]->type) == NULL);
+	assert(isis_find_vertex(&q, &vertices[0]->N, vertices[0]->type) == NULL);
 
 	assert(isis_vertex_queue_pop(&q) == vertices[1]);
-	assert(isis_find_vertex(&q, vertices[1]->N.id, vertices[1]->type) == NULL);
+	assert(isis_find_vertex(&q, &vertices[1]->N, vertices[1]->type) == NULL);
 
 	isis_vertex_queue_delete(&q, vertices[4]);
-	assert(isis_find_vertex(&q, vertices[4]->N.id, vertices[4]->type) == NULL);
+	assert(isis_find_vertex(&q, &vertices[4]->N, vertices[4]->type) == NULL);
 
 	assert(isis_vertex_queue_count(&q) == 0);
 	assert(isis_vertex_queue_pop(&q) == NULL);
diff -urpN frr-frr-5.0.1/tests/lib/cli/test_commands.c frr-frr-6.0/tests/lib/cli/test_commands.c
--- frr-frr-5.0.1/tests/lib/cli/test_commands.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/cli/test_commands.c	2018-10-08 14:32:57.000000000 +0200
@@ -130,7 +130,7 @@ static void test_load(void)
 			line[strlen(line) - 1] = '\0';
 		if (line[0] == '#')
 			continue;
-		vector_set(test_cmds, XSTRDUP(MTYPE_STRVEC, line));
+		vector_set(test_cmds, XSTRDUP(MTYPE_TMP, line));
 	}
 }
 
@@ -181,7 +181,7 @@ static void test_terminate(void)
 
 	vty_terminate();
 	for (i = 0; i < vector_active(test_cmds); i++)
-		XFREE(MTYPE_STRVEC, vector_slot(test_cmds, i));
+		XFREE(MTYPE_TMP, vector_slot(test_cmds, i));
 	vector_free(test_cmds);
 	cmd_terminate();
 }
diff -urpN frr-frr-5.0.1/tests/lib/test_checksum.c frr-frr-6.0/tests/lib/test_checksum.c
--- frr-frr-5.0.1/tests/lib/test_checksum.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_checksum.c	2018-10-08 14:32:57.000000000 +0200
@@ -506,7 +506,7 @@ int main(int argc, char **argv)
 			printf("verify: lib failed\n");
 
 		if (ospfd != lib) {
-			printf("Mismatch in values at size %u\n"
+			printf("Mismatch in values at size %d\n"
 			       "ospfd: 0x%04x\tc0: %d\tc1: %d\tx: %d\ty: %d\n"
 			       "isisd: 0x%04x\tc0: %d\tc1: %d\tx: %d\ty: %d\n"
 			       "lib: 0x%04x\n",
diff -urpN frr-frr-5.0.1/tests/lib/test_graph.c frr-frr-6.0/tests/lib/test_graph.c
--- frr-frr-5.0.1/tests/lib/test_graph.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_graph.c	2018-10-08 14:32:57.000000000 +0200
@@ -46,7 +46,7 @@ int main(int argc, char **argv)
 
 	/* create vertices */
 	for (unsigned int i = 0; i < NUMNODES; i++) {
-		snprintf(names[i], sizeof(names[i]), "%d", i);
+		snprintf(names[i], sizeof(names[i]), "%u", i);
 		gn[i] = graph_new_node(g, names[i], NULL);
 	}
 
diff -urpN frr-frr-5.0.1/tests/lib/test_heavy_thread.c frr-frr-6.0/tests/lib/test_heavy_thread.c
--- frr-frr-5.0.1/tests/lib/test_heavy_thread.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_heavy_thread.c	2018-10-08 14:32:57.000000000 +0200
@@ -110,16 +110,9 @@ DEFUN (clear_foo,
 
 	str = argv_concat(argv, argc, 0);
 
-	if ((ws = XMALLOC(MTYPE_TMP, sizeof(*ws))) == NULL) {
-		zlog_err("%s: unable to allocate work_state", __func__);
-		return CMD_WARNING;
-	}
+	ws = XMALLOC(MTYPE_TMP, sizeof(*ws));
 
-	if (!(ws->str = XSTRDUP(MTYPE_TMP, str))) {
-		zlog_err("%s: unable to xstrdup", __func__);
-		XFREE(MTYPE_TMP, ws);
-		return CMD_WARNING;
-	}
+	ws->str = XSTRDUP(MTYPE_TMP, str);
 
 	ws->vty = vty;
 	ws->i = ITERS_FIRST;
diff -urpN frr-frr-5.0.1/tests/lib/test_heavy_wq.c frr-frr-6.0/tests/lib/test_heavy_wq.c
--- frr-frr-5.0.1/tests/lib/test_heavy_wq.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_heavy_wq.c	2018-10-08 14:32:57.000000000 +0200
@@ -60,18 +60,10 @@ static void heavy_wq_add(struct vty *vty
 {
 	struct heavy_wq_node *hn;
 
-	if ((hn = XCALLOC(MTYPE_WQ_NODE, sizeof(struct heavy_wq_node)))
-	    == NULL) {
-		zlog_err("%s: unable to allocate hn", __func__);
-		return;
-	}
+	hn = XCALLOC(MTYPE_WQ_NODE, sizeof(struct heavy_wq_node));
 
 	hn->i = i;
-	if (!(hn->str = XSTRDUP(MTYPE_WQ_NODE_STR, str))) {
-		zlog_err("%s: unable to xstrdup", __func__);
-		XFREE(MTYPE_WQ_NODE, hn);
-		return;
-	}
+	hn->str = XSTRDUP(MTYPE_WQ_NODE_STR, str);
 
 	work_queue_add(heavy_wq, hn);
 
@@ -149,10 +141,7 @@ DEFUN (clear_foo,
 
 static int heavy_wq_init()
 {
-	if (!(heavy_wq = work_queue_new(master, "heavy_work_queue"))) {
-		zlog_err("%s: could not get new work queue!", __func__);
-		return -1;
-	}
+	heavy_wq = work_queue_new(master, "heavy_work_queue");
 
 	heavy_wq->spec.workfunc = &slow_func;
 	heavy_wq->spec.errorfunc = &slow_func_err;
diff -urpN frr-frr-5.0.1/tests/lib/test_privs.c frr-frr-6.0/tests/lib/test_privs.c
--- frr-frr-5.0.1/tests/lib/test_privs.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_privs.c	2018-10-08 14:32:57.000000000 +0200
@@ -113,10 +113,9 @@ int main(int argc, char **argv)
 	((test_privs.current_state() == ZPRIVS_RAISED) ? "Raised" : "Lowered")
 
 	printf("%s\n", PRIV_STATE());
-	test_privs.change(ZPRIVS_RAISE);
-
-	printf("%s\n", PRIV_STATE());
-	test_privs.change(ZPRIVS_LOWER);
+	frr_elevate_privs(&test_privs) {
+		printf("%s\n", PRIV_STATE());
+	}
 
 	printf("%s\n", PRIV_STATE());
 	zprivs_get_ids(&ids);
@@ -126,10 +125,9 @@ int main(int argc, char **argv)
 
 	/* but these should continue to work... */
 	printf("%s\n", PRIV_STATE());
-	test_privs.change(ZPRIVS_RAISE);
-
-	printf("%s\n", PRIV_STATE());
-	test_privs.change(ZPRIVS_LOWER);
+	frr_elevate_privs(&test_privs) {
+		printf("%s\n", PRIV_STATE());
+	}
 
 	printf("%s\n", PRIV_STATE());
 	zprivs_get_ids(&ids);
diff -urpN frr-frr-5.0.1/tests/lib/test_srcdest_table.c frr-frr-6.0/tests/lib/test_srcdest_table.c
--- frr-frr-5.0.1/tests/lib/test_srcdest_table.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_srcdest_table.c	2018-10-08 14:32:57.000000000 +0200
@@ -104,9 +104,7 @@ static unsigned int log_key(void *data)
 
 static int log_cmp(const void *a, const void *b)
 {
-	if (a == NULL && b != NULL)
-		return 0;
-	if (b == NULL && a != NULL)
+	if (a == NULL || b == NULL)
 		return 0;
 
 	return !memcmp(a, b, 2 * sizeof(struct prefix));
@@ -230,7 +228,8 @@ static void test_dump(struct test_state
 }
 
 static void test_failed(struct test_state *test, const char *message,
-			struct prefix_ipv6 *dst_p, struct prefix_ipv6 *src_p)
+			const struct prefix_ipv6 *dst_p,
+			const struct prefix_ipv6 *src_p)
 {
 	char *route_id = format_srcdest(dst_p, src_p);
 
@@ -252,7 +251,7 @@ static void test_state_verify(struct tes
 	/* Verify that there are no elements in the table which have never
 	 * been added */
 	for (rn = route_top(test->table); rn; rn = srcdest_route_next(rn)) {
-		struct prefix_ipv6 *dst_p, *src_p;
+		const struct prefix_ipv6 *dst_p, *src_p;
 
 		/* While we are iterating, we hold a lock on the current
 		 * route_node,
@@ -290,10 +289,10 @@ static void test_state_verify(struct tes
 				expected_lock++;
 
 			if (rn->lock != expected_lock) {
-				struct prefix_ipv6 *dst_p, *src_p;
+				const struct prefix_ipv6 *dst_p, *src_p;
 				srcdest_rnode_prefixes(
-					rn, (struct prefix **)&dst_p,
-					(struct prefix **)&src_p);
+					rn, (const struct prefix **)&dst_p,
+					(const struct prefix **)&src_p);
 
 				test_failed(
 					test,
@@ -307,8 +306,8 @@ static void test_state_verify(struct tes
 
 		assert(rn->info == (void *)0xdeadbeef);
 
-		srcdest_rnode_prefixes(rn, (struct prefix **)&dst_p,
-				       (struct prefix **)&src_p);
+		srcdest_rnode_prefixes(rn, (const struct prefix **)&dst_p,
+				       (const struct prefix **)&src_p);
 		memcpy(&hash_entry[0], dst_p, sizeof(*dst_p));
 		if (src_p)
 			memcpy(&hash_entry[1], src_p, sizeof(*src_p));
@@ -379,7 +378,7 @@ static void test_state_del_one_route(str
 	which_route = prng_rand(prng) % test->log->count;
 
 	struct route_node *rn;
-	struct prefix *dst_p, *src_p;
+	const struct prefix *dst_p, *src_p;
 	struct prefix_ipv6 dst6_p, src6_p;
 
 	for (rn = route_top(test->table); rn; rn = srcdest_route_next(rn)) {
@@ -393,7 +392,8 @@ static void test_state_del_one_route(str
 	}
 
 	assert(rn);
-	srcdest_rnode_prefixes(rn, &dst_p, &src_p);
+	srcdest_rnode_prefixes(rn, (const struct prefix **)&dst_p,
+			       (const struct prefix **)&src_p);
 	memcpy(&dst6_p, dst_p, sizeof(dst6_p));
 	if (src_p)
 		memcpy(&src6_p, src_p, sizeof(src6_p));
diff -urpN frr-frr-5.0.1/tests/lib/test_stream.c frr-frr-6.0/tests/lib/test_stream.c
--- frr-frr-5.0.1/tests/lib/test_stream.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_stream.c	2018-10-08 14:32:57.000000000 +0200
@@ -57,7 +57,7 @@ int main(void)
 
 	print_stream(s);
 
-	stream_resize(s, stream_get_endp(s));
+	stream_resize_inplace(&s, stream_get_endp(s));
 
 	print_stream(s);
 
diff -urpN frr-frr-5.0.1/tests/lib/test_timer_performance.c frr-frr-6.0/tests/lib/test_timer_performance.c
--- frr-frr-5.0.1/tests/lib/test_timer_performance.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/lib/test_timer_performance.c	2018-10-08 14:32:57.000000000 +0200
@@ -92,9 +92,9 @@ int main(int argc, char **argv)
 	t_remove = 1000 * (tv_stop.tv_sec - tv_lap.tv_sec);
 	t_remove += (tv_stop.tv_usec - tv_lap.tv_usec) / 1000;
 
-	printf("Scheduling %d random timers took %ld.%03ld seconds.\n",
+	printf("Scheduling %d random timers took %lu.%03lu seconds.\n",
 	       SCHEDULE_TIMERS, t_schedule / 1000, t_schedule % 1000);
-	printf("Removing %d random timers took %ld.%03ld seconds.\n",
+	printf("Removing %d random timers took %lu.%03lu seconds.\n",
 	       REMOVE_TIMERS, t_remove / 1000, t_remove % 1000);
 	fflush(stdout);
 
diff -urpN frr-frr-5.0.1/tests/test_lblmgr.c frr-frr-6.0/tests/test_lblmgr.c
--- frr-frr-5.0.1/tests/test_lblmgr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tests/test_lblmgr.c	2018-10-08 14:32:57.000000000 +0200
@@ -55,7 +55,7 @@ static int zebra_send_label_manager_conn
 
 	printf("Connect to Label Manager\n");
 
-	ret = lm_label_manager_connect(zclient, 0);
+	ret = lm_label_manager_connect(zclient);
 	printf("Label Manager connection result: %u \n", ret);
 	if (ret != 0) {
 		fprintf(stderr, "Error %d connecting to Label Manager %s\n",
diff -urpN frr-frr-5.0.1/tools/checkpatch.pl frr-frr-6.0/tools/checkpatch.pl
--- frr-frr-5.0.1/tools/checkpatch.pl	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/checkpatch.pl	2018-10-08 14:32:57.000000000 +0200
@@ -4181,7 +4181,9 @@ sub process {
 				} elsif ($op eq ',') {
 					my $rtrim_before = 0;
 					my $space_after = 0;
-					if ($ctx =~ /Wx./) {
+					if ($line=~/\#\s*define/) {
+						# ignore , spacing in macros
+					} elsif ($ctx =~ /Wx./) {
 						if (ERROR("SPACING",
 							  "space prohibited before that '$op' $at\n" . $hereptr)) {
 							$line_fixed = 1;
@@ -4847,6 +4849,7 @@ sub process {
 			my $ctx = '';
 			my $has_flow_statement = 0;
 			my $has_arg_concat = 0;
+			my $complex = 0;
 			($dstat, $dcond, $ln, $cnt, $off) =
 				ctx_statement_block($linenr, $realcnt, 0);
 			$ctx = $dstat;
@@ -4865,6 +4868,7 @@ sub process {
 				$define_args = substr($define_args, 1, length($define_args) - 2);
 				$define_args =~ s/\s*//g;
 				@def_args = split(",", $define_args);
+				$complex = 1;
 			}
 
 			$dstat =~ s/$;//g;
@@ -4932,7 +4936,7 @@ sub process {
 				} elsif ($dstat =~ /;/) {
 					ERROR("MULTISTATEMENT_MACRO_USE_DO_WHILE",
 					      "Macros with multiple statements should be enclosed in a do - while loop\n" . "$herectx");
-				} else {
+				} elsif ($complex) {
 					ERROR("COMPLEX_MACRO",
 					      "Macros with complex values should be enclosed in parentheses\n" . "$herectx");
 				}
diff -urpN frr-frr-5.0.1/tools/checkpatch.sh frr-frr-6.0/tools/checkpatch.sh
--- frr-frr-5.0.1/tools/checkpatch.sh	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/checkpatch.sh	2018-10-08 14:32:57.000000000 +0200
@@ -72,12 +72,13 @@ else
   echo "Done."
   for file in ${tmp1}/*_cp; do
     if [ -a ${tmp2}/$(basename $file) ]; then
-      result=$(diff $file ${tmp2}/$(basename $file) | grep -A3 "ERROR\|WARNING" | grep -A2 -B2 "${tmp1}")
+      result=$(diff $file ${tmp2}/$(basename $file) | awk '/< ERROR|< WARNING/,/^< $|^< #|^<[^ ]/ { print $0; ++n }; END { exit n }')
     else
-      result=$(cat $file | grep -A3 "ERROR\|WARNING" | grep -A2 -B2 "${tmp1}")
+      result=$(cat $file | awk '/ERROR|WARNING/,/^$/ { print $0; ++n }; END { exit n }')
     fi
-    if [ "$?" -eq "0" ]; then
-      echo "Report for $(basename $file _cp)" 1>&2
+    ni="$?"
+    if [ "$ni" -ne "0" ]; then
+      echo "Report for $(basename $file _cp) | $ni issues" 1>&2
       echo "===============================================" 1>&2
       echo "$result" 1>&2
       if echo $result | grep -q "ERROR"; then
diff -urpN frr-frr-5.0.1/tools/etc/frr/daemons frr-frr-6.0/tools/etc/frr/daemons
--- frr-frr-5.0.1/tools/etc/frr/daemons	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/etc/frr/daemons	2018-10-08 14:32:57.000000000 +0200
@@ -35,3 +35,4 @@ eigrpd=no
 babeld=no
 sharpd=no
 pbrd=no
+bfdd=no
diff -urpN frr-frr-5.0.1/tools/etc/frr/daemons.conf frr-frr-6.0/tools/etc/frr/daemons.conf
--- frr-frr-5.0.1/tools/etc/frr/daemons.conf	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/etc/frr/daemons.conf	2018-10-08 14:32:57.000000000 +0200
@@ -18,6 +18,8 @@ eigrpd_options="  --daemon -A 127.0.0.1"
 babeld_options="  --daemon -A 127.0.0.1"
 sharpd_options="  --daemon -A 127.0.0.1"
 pbrd_options="  --daemon -A 127.0.0.1"
+staticd_options="  --daemon -A 127.0.0.1"
+bfdd_options="  --daemon -A 127.0.0.1"
 
 # The list of daemons to watch is automatically generated by the init script.
 watchfrr_enable=yes
diff -urpN frr-frr-5.0.1/tools/frr frr-frr-6.0/tools/frr
--- frr-frr-5.0.1/tools/frr	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/frr	2018-10-08 14:32:57.000000000 +0200
@@ -21,7 +21,7 @@ V_PATH=/var/run/frr
 # Local Daemon selection may be done by using /etc/frr/daemons.
 # See /usr/share/doc/frr/README.Debian.gz for further information.
 # Keep zebra first and do not list watchfrr!
-DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd babeld pimd ldpd nhrpd eigrpd sharpd pbrd"
+DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd babeld pimd ldpd nhrpd eigrpd sharpd pbrd staticd bfdd"
 MAX_INSTANCES=5
 RELOAD_SCRIPT=/usr/lib/frr/frr-reload.py
 
@@ -170,6 +170,22 @@ start()
                `eval echo "$""$1""_options"`
            fi
         fi
+
+	# Start the staticd automatically
+	if [ "$1" = "zebra" ]; then
+	    echo -n "starting staticd since zebra is running"
+	    if ! check_daemon staticd ; then
+		echo -n " (binary does not exist)"
+		return;
+	    fi
+
+	    ${SSD} \
+		--start \
+		--pidfile=`pidfile staticd` \
+		--exec "$D_PATH/staticd" \
+		-- \
+		`eval echo "$"staticd"_options"`
+	fi
 }
 
 # Stop the daemon given in the parameter, printing its name to the terminal.
@@ -210,6 +226,11 @@ stop()
         echo -n " $inst"
         rm -f `pidfile $inst`
         rm -f `vtyfile $inst`
+
+	if [ "$1" = "zebra" ]; then
+	    echo -n "Stopping staticd since zebra is running"
+	    stop staticd
+	fi
     fi
 }
 
@@ -574,7 +595,11 @@ case "$1" in
 
     reload)
        # Just apply the commands that have changed, no restart necessary
-       [ ! -x "$RELOAD_SCRIPT" ] && echo "frr-reload script not available" && exit 0
+       if [ ! -x "$RELOAD_SCRIPT" ]; then
+          echo "Please install frr-pythontools package. Required for reload"
+          exit 0
+       fi
+
        NEW_CONFIG_FILE="${2:-$C_PATH/frr.conf}"
        [ ! -r $NEW_CONFIG_FILE ] && echo "Unable to read new configuration file $NEW_CONFIG_FILE" && exit 1
        echo "Applying only incremental changes to running configuration from frr.conf"
diff -urpN frr-frr-5.0.1/tools/frr-reload.py frr-frr-6.0/tools/frr-reload.py
--- frr-frr-5.0.1/tools/frr-reload.py	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/frr-reload.py	2018-10-08 14:32:57.000000000 +0200
@@ -403,7 +403,7 @@ end
                 self.save_contexts(ctx_keys, current_context_lines)
                 new_ctx = True
 
-            elif line == "end":
+            elif line in ["end", "exit-vrf"]:
                 self.save_contexts(ctx_keys, current_context_lines)
                 log.debug('LINE %-50s: exiting old context, %-50s', line, ctx_keys)
 
@@ -413,7 +413,7 @@ end
                 ctx_keys = []
                 current_context_lines = []
 
-            elif line in ["exit-address-family", "exit", "exit-vnc", "exit-vni"]:
+            elif line in ["exit-address-family", "exit", "exit-vnc"]:
                 # if this exit is for address-family ipv4 unicast, ignore the pop
                 if main_ctx_key:
                     self.save_contexts(ctx_keys, current_context_lines)
@@ -423,6 +423,15 @@ end
                     current_context_lines = []
                     log.debug('LINE %-50s: popping from subcontext to ctx%-50s', line, ctx_keys)
 
+            elif line == "exit-vni":
+                if sub_main_ctx_key:
+                    self.save_contexts(ctx_keys, current_context_lines)
+
+                    # Start a new context
+                    ctx_keys = copy.deepcopy(sub_main_ctx_key)
+                    current_context_lines = []
+                    log.debug('LINE %-50s: popping from sub-subcontext to ctx%-50s', line, ctx_keys)
+
             elif new_ctx is True:
                 if not main_ctx_key:
                     ctx_keys = [line, ]
@@ -436,11 +445,7 @@ end
             elif (line.startswith("address-family ") or
                   line.startswith("vnc defaults") or
                   line.startswith("vnc l2-group") or
-                  line.startswith("vnc nve-group") or
-                  (line.startswith("vni ") and
-                   len(ctx_keys) == 2 and
-                   ctx_keys[0].startswith('router bgp') and
-                   ctx_keys[1] == 'address-family l2vpn evpn')):
+                  line.startswith("vnc nve-group")):
                 main_ctx_key = []
 
                 # Save old context first
@@ -458,6 +463,18 @@ end
                 else:
                     ctx_keys.append(line)
 
+            elif ((line.startswith("vni ") and
+                   len(ctx_keys) == 2 and
+                   ctx_keys[0].startswith('router bgp') and
+                   ctx_keys[1] == 'address-family l2vpn evpn')):
+
+                # Save old context first
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines = []
+                sub_main_ctx_key = copy.deepcopy(ctx_keys)
+                log.debug('LINE %-50s: entering sub-sub-context, append to ctx_keys', line)
+                ctx_keys.append(line)
+
             else:
                 # Continuing in an existing context, add non-commented lines to it
                 current_context_lines.append(line)
diff -urpN frr-frr-5.0.1/tools/frr.service frr-frr-6.0/tools/frr.service
--- frr-frr-5.0.1/tools/frr.service	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/frr.service	2018-10-08 14:32:57.000000000 +0200
@@ -10,7 +10,7 @@ Type=forking
 NotifyAccess=all
 StartLimitInterval=3m
 StartLimitBurst=3
-TimeoutSec=1m
+TimeoutSec=2m
 WatchdogSec=60s
 RestartSec=5
 Restart=on-abnormal
diff -urpN frr-frr-5.0.1/tools/lsan-suppressions.txt frr-frr-6.0/tools/lsan-suppressions.txt
--- frr-frr-5.0.1/tools/lsan-suppressions.txt	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/lsan-suppressions.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-leak:clippy
-leak:PyObject_Malloc
-leak:PyObject_Realloc
-leak:PyList_Append
-leak:malloc
diff -urpN frr-frr-5.0.1/tools/start-stop-daemon.c frr-frr-6.0/tools/start-stop-daemon.c
--- frr-frr-5.0.1/tools/start-stop-daemon.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/tools/start-stop-daemon.c	2018-10-08 14:32:57.000000000 +0200
@@ -258,11 +258,11 @@ static void add_namespace(const char *pa
 		nsname = cur;
 	}
 
-	if (!memcmp(nsdirname, "ipcns/", strlen("ipcns/")))
+	if (!strncmp(nsdirname, "ipcns/", strlen("ipcns/")))
 		nstype = CLONE_NEWIPC;
-	else if (!memcmp(nsdirname, "netns/", strlen("netns/")))
+	else if (!strncmp(nsdirname, "netns/", strlen("netns/")))
 		nstype = CLONE_NEWNET;
-	else if (!memcmp(nsdirname, "utcns/", strlen("utcns/")))
+	else if (!strncmp(nsdirname, "utcns/", strlen("utcns/")))
 		nstype = CLONE_NEWUTS;
 	else
 		badusage("invalid namepspace path");
@@ -1024,14 +1024,18 @@ int main(int argc, char **argv)
 			close(i);
 		/* change tty */
 		fd = open("/dev/tty", O_RDWR);
-		ioctl(fd, TIOCNOTTY, 0);
-		close(fd);
+		if (fd >= 0) {
+			ioctl(fd, TIOCNOTTY, 0);
+			close(fd);
+		}
 		chdir("/");
 		umask(022);    /* set a default for dumb programs */
 		setpgid(0, 0); /* set the process group */
 		fd = open("/dev/null", O_RDWR); /* stdin */
-		dup(fd);			/* stdout */
-		dup(fd);			/* stderr */
+		if (fd >= 0) {
+			dup(fd);		/* stdout */
+			dup(fd);		/* stderr */
+		}
 	}
 	if (nicelevel) {
 		errno = 0;
diff -urpN frr-frr-5.0.1/tools/zprivs.cocci frr-frr-6.0/tools/zprivs.cocci
--- frr-frr-5.0.1/tools/zprivs.cocci	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/tools/zprivs.cocci	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,76 @@
+@@
+identifier change;
+identifier end;
+expression E, f, g;
+iterator name frr_elevate_privs;
+@@
+
+- if (E.change(ZPRIVS_RAISE))
+-   f;
++ frr_elevate_privs(&E) {
+  <+...
+-   goto end;
++   break;
+  ...+>
+- end:
+- if (E.change(ZPRIVS_LOWER))
+-   g;
++ }
+
+@@
+identifier change, errno, safe_strerror, exit;
+expression E, f1, f2, f3, ret, fn;
+iterator name frr_elevate_privs;
+@@
+
+  if (E.change(ZPRIVS_RAISE))
+    f1;
+  ...
+  if (...) {
+-   int save_errno = errno;
+    ...
+-   if (E.change(ZPRIVS_LOWER))
+-     f2;
+    ...
+-   safe_strerror(save_errno)
++   safe_strerror(errno)
+    ...
+    \( return ret; \| exit(ret); \)
+  }
+  ...
+  if (E.change(ZPRIVS_LOWER))
+    f3;
+
+@@
+identifier change;
+expression E, f1, f2, f3, ret;
+iterator name frr_elevate_privs;
+@@
+
+  if (E.change(ZPRIVS_RAISE))
+    f1;
+  ...
+  if (...) {
+    ...
+-   if (E.change(ZPRIVS_LOWER))
+-     f2;
+    ...
+    return ret;
+  }
+  ...
+  if (E.change(ZPRIVS_LOWER))
+    f3;
+
+@@
+identifier change;
+expression E, f, g;
+iterator name frr_elevate_privs;
+@@
+
+- if (E.change(ZPRIVS_RAISE))
+-   f;
++ frr_elevate_privs(&E) {
+  ...
+- if (E.change(ZPRIVS_LOWER))
+-   g;
++ }
diff -urpN frr-frr-5.0.1/update-autotools frr-frr-6.0/update-autotools
--- frr-frr-5.0.1/update-autotools	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/update-autotools	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-#! /bin/sh
-#
-# When local system does not have the latest autoconf/automake
-#        -- Kunihiro Ishiguro <kunihiro@zebra.org>
-#
-
-rm -f config.cache Makefile.in aclocal.m4 config.h.in configure
-rm -rf config.guess config.sub ltmain.sh
-rm -rf autom4te.cache
-
-echo "This $0 script is deprecated, and will be removed at some stage."
-echo "Please use the 'autoreconf' command included with autoconf."
-
-echo "TOOLS VERIONS:"
-for tool in autoheader autoconf libtool libtoolize aclocal automake; do
-  $tool --version | head -1
-done
-
-echo "ACLOCAL:"
-aclocal -I m4
-echo "AUTOHEADER:"
-autoheader
-echo "AUTOCONF:"
-autoconf
-echo "LIBTOOLIZE:"
-libtoolize -c
-echo "AUTOMAKE"
-automake --gnu --add-missing --copy
diff -urpN frr-frr-5.0.1/vtysh/Makefile.am frr-frr-6.0/vtysh/Makefile.am
--- frr-frr-5.0.1/vtysh/Makefile.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/Makefile.am	2018-10-08 14:32:57.000000000 +0200
@@ -1,5 +1,6 @@
 ## Process this file with Automake to create Makefile.in
 
+include ../common.am
 
 if ENABLE_BGP_VNC
 BGP_VNC_RFP_SRCDIR   = @top_srcdir@/@LIBRFP@
@@ -16,14 +17,12 @@ BGP_VNC_RFAPI_INCDIR =
 BGP_VNC_RFAPI_SRCDIR =
 BGP_VNC_RFAPI_SRC    =
 endif
-AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/lib -I$(top_builddir)/lib \
+AM_CPPFLAGS += -I$(top_srcdir) -I$(top_srcdir)/lib -I$(top_builddir)/lib \
 	$(BGP_VNC_RFAPI_INCDIR) $(BGP_VNC_RFP_INCDIR)
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 
 LIBS = @LIBS@ @CURSES@ @LIBPAM@
 
-AM_CFLAGS = $(WERROR)
-
 bin_PROGRAMS = vtysh
 
 vtysh_SOURCES = vtysh_main.c vtysh.c vtysh_user.c vtysh_config.c
@@ -147,11 +146,19 @@ vtysh_scan += $(top_srcdir)/pbrd/pbr_vty
 vtysh_scan += $(top_srcdir)/pbrd/pbr_debug.c
 endif
 
+if STATICD
+vtysh_scan += $(top_srcdir)/staticd/static_vty.c
+endif
+
+if BFDD
+vtysh_scan += $(top_srcdir)/bfdd/bfdd_vty.c
+endif
+
 vtysh_cmd_FILES = $(vtysh_scan) \
 		  $(top_srcdir)/lib/keychain.c $(top_srcdir)/lib/routemap.c \
 		  $(top_srcdir)/lib/filter.c $(top_srcdir)/lib/plist.c \
 		  $(top_srcdir)/lib/distribute.c $(top_srcdir)/lib/if_rmap.c \
-		  $(top_srcdir)/lib/vrf.c \
+		  $(top_srcdir)/lib/vrf.c $(top_srcdir)/lib/if.c \
 		  $(top_srcdir)/lib/vty.c $(top_srcdir)/zebra/debug.c \
 		  $(top_srcdir)/lib/logicalrouter.c \
 		  $(top_srcdir)/lib/nexthop_group.c \
diff -urpN frr-frr-5.0.1/vtysh/extract.pl.in frr-frr-6.0/vtysh/extract.pl.in
--- frr-frr-5.0.1/vtysh/extract.pl.in	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/extract.pl.in	2018-10-08 14:32:57.000000000 +0200
@@ -85,7 +85,10 @@ foreach (@ARGV) {
             $protocol = "VTYSH_RMAP";
         }
         elsif ($file =~ /lib\/vrf\.c$/) {
-            $protocol = "VTYSH_ALL";
+            $protocol = "VTYSH_VRF";
+        }
+        elsif ($file =~ /lib\/if\.c$/) {
+            $protocol = "VTYSH_INTERFACE";
         }
         elsif ($file =~ /lib\/logicalrouter\.c$/) {
             $protocol = "VTYSH_ALL";
diff -urpN frr-frr-5.0.1/vtysh/vtysh.c frr-frr-6.0/vtysh/vtysh.c
--- frr-frr-5.0.1/vtysh/vtysh.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/vtysh.c	2018-10-08 14:32:57.000000000 +0200
@@ -44,19 +44,18 @@
 #include "vrf.h"
 #include "libfrr.h"
 #include "command_graph.h"
+#include "frrstr.h"
+#include "json.h"
 
 DEFINE_MTYPE_STATIC(MVTYSH, VTYSH_CMD, "Vtysh cmd copy")
 
-/* Destination for vtysh output */
-FILE *outputfile;
-
 /* Struct VTY. */
 struct vty *vty;
 
 /* VTY shell pager name. */
 char *vtysh_pager_name = NULL;
 
-/* VTY shell client structure. */
+/* VTY shell client structure */
 struct vtysh_client {
 	int fd;
 	const char *name;
@@ -65,6 +64,60 @@ struct vtysh_client {
 	struct vtysh_client *next;
 };
 
+/* Some utility functions for working on vtysh-specific vty tasks */
+
+static FILE *vty_open_pager(struct vty *vty)
+{
+	if (vty->is_paged)
+		return vty->of;
+
+	if (!vtysh_pager_name)
+		return NULL;
+
+	vty->of_saved = vty->of;
+	vty->of = popen(vtysh_pager_name, "w");
+	if (vty->of == NULL) {
+		vty->of = vty->of_saved;
+		perror("popen");
+		exit(1);
+	}
+
+	vty->is_paged = true;
+
+	return vty->of;
+}
+
+static int vty_close_pager(struct vty *vty)
+{
+	if (!vty->is_paged)
+		return 0;
+
+	fflush(vty->of);
+	if (pclose(vty->of) == -1) {
+		perror("pclose");
+		exit(1);
+	}
+
+	vty->of = vty->of_saved;
+	vty->is_paged = false;
+
+	return 0;
+}
+
+void vtysh_pager_init(void)
+{
+	char *pager_defined;
+
+	pager_defined = getenv("VTYSH_PAGER");
+
+	if (pager_defined)
+		vtysh_pager_name = strdup(pager_defined);
+	else
+		vtysh_pager_name = strdup(VTYSH_PAGER);
+}
+
+/* --- */
+
 struct vtysh_client vtysh_client[] = {
 	{.fd = -1, .name = "zebra", .flag = VTYSH_ZEBRA, .next = NULL},
 	{.fd = -1, .name = "ripd", .flag = VTYSH_RIPD, .next = NULL},
@@ -81,37 +134,51 @@ struct vtysh_client vtysh_client[] = {
 	{.fd = -1, .name = "sharpd", .flag = VTYSH_SHARPD, .next = NULL},
 	{.fd = -1, .name = "watchfrr", .flag = VTYSH_WATCHFRR, .next = NULL},
 	{.fd = -1, .name = "pbrd", .flag = VTYSH_PBRD, .next = NULL},
+	{.fd = -1, .name = "staticd", .flag = VTYSH_STATICD, .next = NULL},
+	{.fd = -1, .name = "bfdd", .flag = VTYSH_BFDD, .next = NULL},
 };
 
 enum vtysh_write_integrated vtysh_write_integrated =
 	WRITE_INTEGRATED_UNSPECIFIED;
 
+static int vtysh_reconnect(struct vtysh_client *vclient);
+
 static void vclient_close(struct vtysh_client *vclient)
 {
 	if (vclient->fd >= 0) {
-		fprintf(stderr,
+		vty_out(vty,
 			"Warning: closing connection to %s because of an I/O error!\n",
 			vclient->name);
 		close(vclient->fd);
-		vclient->fd = -1;
+		/* indicate as candidate for reconnect */
+		vclient->fd = VTYSH_WAS_ACTIVE;
 	}
 }
 
-/* Return true if str begins with prefix, else return false */
-static int begins_with(const char *str, const char *prefix)
-{
-	if (!str || !prefix)
-		return 0;
-	size_t lenstr = strlen(str);
-	size_t lenprefix = strlen(prefix);
-	if (lenprefix > lenstr)
-		return 0;
-	return strncmp(str, prefix, lenprefix) == 0;
-}
-
+/*
+ * Send a CLI command to a client and read the response.
+ *
+ * Output will be printed to vty->of. If you want to suppress output, set that
+ * to NULL.
+ *
+ * vclient
+ *    the client to send the command to
+ *
+ * line
+ *    the command to send
+ *
+ * callback
+ *    if non-null, this will be called with each line of output received from
+ *    the client passed in the second parameter
+ *
+ * cbarg
+ *    optional first argument to pass to callback
+ *
+ * Returns:
+ *    a status code
+ */
 static int vtysh_client_run(struct vtysh_client *vclient, const char *line,
-			    FILE *fp, void (*callback)(void *, const char *),
-			    void *cbarg)
+			    void (*callback)(void *, const char *), void *cbarg)
 {
 	int ret;
 	char stackbuf[4096];
@@ -120,29 +187,48 @@ static int vtysh_client_run(struct vtysh
 	char *bufvalid, *end = NULL;
 	char terminator[3] = {0, 0, 0};
 
+	/* vclinet was previously active, try to reconnect */
+	if (vclient->fd == VTYSH_WAS_ACTIVE) {
+		ret = vtysh_reconnect(vclient);
+		if (ret < 0)
+			goto out_err;
+	}
+
 	if (vclient->fd < 0)
 		return CMD_SUCCESS;
 
 	ret = write(vclient->fd, line, strlen(line) + 1);
-	if (ret <= 0)
-		goto out_err;
+	if (ret <= 0) {
+		/* close connection and try to reconnect */
+		vclient_close(vclient);
+		ret = vtysh_reconnect(vclient);
+		if (ret < 0)
+			goto out_err;
+		/* retry line */
+		ret = write(vclient->fd, line, strlen(line) + 1);
+		if (ret <= 0)
+			goto out_err;
+	}
 
 	bufvalid = buf;
 	do {
 		ssize_t nread =
-			read(vclient->fd, bufvalid, buf + bufsz - bufvalid);
+			read(vclient->fd, bufvalid, buf + bufsz - bufvalid - 1);
 
 		if (nread < 0 && (errno == EINTR || errno == EAGAIN))
 			continue;
 
 		if (nread <= 0) {
-			fprintf(stderr, "vtysh: error reading from %s: %s (%d)",
+			vty_out(vty, "vtysh: error reading from %s: %s (%d)",
 				vclient->name, safe_strerror(errno), errno);
 			goto out_err;
 		}
 
 		bufvalid += nread;
 
+		/* Null terminate so we may pass this to *printf later. */
+		bufvalid[0] = '\0';
+
 		/*
 		 * We expect string output from daemons, so instead of looking
 		 * for the full 3 null bytes of the terminator, we check for
@@ -176,7 +262,7 @@ static int vtysh_client_run(struct vtysh
 			else if (end)
 				/* no nl, end of input, but some text left */
 				eol = end;
-			else if (bufvalid == buf + bufsz) {
+			else if (bufvalid == buf + bufsz - 1) {
 				/*
 				 * no nl, no end of input, no buffer space;
 				 * realloc
@@ -205,12 +291,10 @@ static int vtysh_client_run(struct vtysh
 			/* eol is at line end now, either \n => \0 or \0\0\0 */
 			assert(eol && eol <= bufvalid);
 
-			if (fp) {
-				fputs(buf, fp);
-				fputc('\n', fp);
-			}
-			if (callback)
-				callback(cbarg, buf);
+			if (vty->of)
+				vty_out(vty, "%s\n", buf);
+
+			callback(cbarg, buf);
 
 			/* shift back data and adjust bufvalid */
 			memmove(buf, eol, bufvalid - eol);
@@ -221,8 +305,8 @@ static int vtysh_client_run(struct vtysh
 
 		/* else if no callback, dump raw */
 		if (!callback) {
-			if (fp)
-				fwrite(buf, 1, textlen, fp);
+			if (vty->of)
+				vty_out(vty, "%s", buf);
 			memmove(buf, buf + textlen, bufvalid - buf - textlen);
 			bufvalid -= textlen;
 			if (end)
@@ -259,7 +343,7 @@ out:
 }
 
 static int vtysh_client_run_all(struct vtysh_client *head_client,
-				const char *line, int continue_on_err, FILE *fp,
+				const char *line, int continue_on_err,
 				void (*callback)(void *, const char *),
 				void *cbarg)
 {
@@ -268,7 +352,7 @@ static int vtysh_client_run_all(struct v
 	int correct_instance = 0, wrong_instance = 0;
 
 	for (client = head_client; client; client = client->next) {
-		rc = vtysh_client_run(client, line, fp, callback, cbarg);
+		rc = vtysh_client_run(client, line, callback, cbarg);
 		if (rc == CMD_NOT_MY_INSTANCE) {
 			wrong_instance++;
 			continue;
@@ -281,8 +365,8 @@ static int vtysh_client_run_all(struct v
 			rc_all = rc;
 		}
 	}
-	if (wrong_instance && !correct_instance && fp) {
-		fprintf(fp,
+	if (wrong_instance && !correct_instance) {
+		vty_out(vty,
 			"%% [%s]: command ignored as it targets an instance that is not running\n",
 			head_client->name);
 		rc_all = CMD_WARNING_CONFIG_FAILED;
@@ -290,12 +374,34 @@ static int vtysh_client_run_all(struct v
 	return rc_all;
 }
 
+/*
+ * Execute command against all daemons.
+ *
+ * head_client
+ *    where to start walking in the daemon list
+ *
+ * line
+ *    the specific command to execute
+ *
+ * Returns:
+ *    a status code
+ */
 static int vtysh_client_execute(struct vtysh_client *head_client,
-				const char *line, FILE *fp)
+				const char *line)
 {
-	return vtysh_client_run_all(head_client, line, 0, fp, NULL, NULL);
+	return vtysh_client_run_all(head_client, line, 0, NULL, NULL);
 }
 
+/*
+ * Retrieve all running config from daemons and parse it with the vtysh config
+ * parser. Returned output is not displayed to the user.
+ *
+ * head_client
+ *    where to start walking in the daemon list
+ *
+ * line
+ *    the specific command to execute
+ */
 static void vtysh_client_config(struct vtysh_client *head_client, char *line)
 {
 	/* watchfrr currently doesn't load any config, and has some hardcoded
@@ -305,20 +411,12 @@ static void vtysh_client_config(struct v
 	if (head_client->flag == VTYSH_WATCHFRR)
 		return;
 
-	vtysh_client_run_all(head_client, line, 1, NULL,
-			     vtysh_config_parse_line, NULL);
-}
-
-void vtysh_pager_init(void)
-{
-	char *pager_defined;
-
-	pager_defined = getenv("VTYSH_PAGER");
-
-	if (pager_defined)
-		vtysh_pager_name = strdup(pager_defined);
-	else
-		vtysh_pager_name = strdup(VTYSH_PAGER);
+	/* suppress output to user */
+	vty->of_saved = vty->of;
+	vty->of = NULL;
+	vtysh_client_run_all(head_client, line, 1, vtysh_config_parse_line,
+			     NULL);
+	vty->of = vty->of_saved;
 }
 
 /* Command execution over the vty interface. */
@@ -328,8 +426,6 @@ static int vtysh_execute_func(const char
 	unsigned int i;
 	vector vline;
 	const struct cmd_element *cmd;
-	FILE *fp = NULL;
-	int closepager = 0;
 	int tried = 0;
 	int saved_ret, saved_node;
 
@@ -341,32 +437,34 @@ static int vtysh_execute_func(const char
 
 	if (user_mode) {
 		if (strncmp("en", vector_slot(vline, 0), 2) == 0) {
-			fprintf(stdout, "%% Command not allowed: enable\n");
+			cmd_free_strvec(vline);
+			vty_out(vty, "%% Command not allowed: enable\n");
 			return CMD_WARNING;
 		}
 	}
 
-	saved_ret = ret = cmd_execute_command(vline, vty, &cmd, 1);
+	saved_ret = ret = cmd_execute(vty, line, &cmd, 1);
 	saved_node = vty->node;
 
-	/* If command doesn't succeeded in current node, try to walk up in node
-	 * tree.
-	 * Changing vty->node is enough to try it just out without actual walkup
-	 * in
-	 * the vtysh. */
+	/*
+	 * If command doesn't succeeded in current node, try to walk up in node
+	 * tree. Changing vty->node is enough to try it just out without actual
+	 * walkup in the vtysh.
+	 */
 	while (ret != CMD_SUCCESS && ret != CMD_SUCCESS_DAEMON
 	       && ret != CMD_WARNING && ret != CMD_WARNING_CONFIG_FAILED
 	       && vty->node > CONFIG_NODE) {
 		vty->node = node_parent(vty->node);
-		ret = cmd_execute_command(vline, vty, &cmd, 1);
+		ret = cmd_execute(vty, line, &cmd, 1);
 		tried++;
 	}
 
 	vty->node = saved_node;
 
-	/* If command succeeded in any other node than current (tried > 0) we
-	 * have
-	 * to move into node in the vtysh where it succeeded. */
+	/*
+	 * If command succeeded in any other node than current (tried > 0) we
+	 * have to move into node in the vtysh where it succeeded.
+	 */
 	if (ret == CMD_SUCCESS || ret == CMD_SUCCESS_DAEMON
 	    || ret == CMD_WARNING) {
 		if ((saved_node == BGP_VPNV4_NODE
@@ -406,9 +504,10 @@ static int vtysh_execute_func(const char
 			vtysh_execute("configure terminal");
 		}
 	}
-	/* If command didn't succeed in any node, continue with return value
-	 * from
-	 * first try. */
+	/*
+	 * If command didn't succeed in any node, continue with return value
+	 * from first try.
+	 */
 	else if (tried) {
 		ret = saved_ret;
 	}
@@ -420,16 +519,16 @@ static int vtysh_execute_func(const char
 	case CMD_WARNING:
 	case CMD_WARNING_CONFIG_FAILED:
 		if (vty->type == VTY_FILE)
-			fprintf(stdout, "Warning...\n");
+			vty_out(vty, "Warning...\n");
 		break;
 	case CMD_ERR_AMBIGUOUS:
-		fprintf(stdout, "%% Ambiguous command: %s\n", line);
+		vty_out(vty, "%% Ambiguous command: %s\n", line);
 		break;
 	case CMD_ERR_NO_MATCH:
-		fprintf(stdout, "%% Unknown command: %s\n", line);
+		vty_out(vty, "%% Unknown command: %s\n", line);
 		break;
 	case CMD_ERR_INCOMPLETE:
-		fprintf(stdout, "%% Command incomplete: %s\n", line);
+		vty_out(vty, "%% Command incomplete: %s\n", line);
 		break;
 	case CMD_SUCCESS_DAEMON: {
 		/*
@@ -437,21 +536,13 @@ static int vtysh_execute_func(const char
 		 * problems if exited from vtysh at all. This hack shouldn't
 		 * cause any problem but is really ugly.
 		 */
-		fp = outputfile;
-		if (pager && vtysh_pager_name && outputfile == stdout
-		    && (strncmp(line, "exit", 4) != 0)) {
-			fp = popen(vtysh_pager_name, "w");
-			if (fp == NULL) {
-				perror("popen failed for pager");
-				fp = outputfile;
-			} else
-				closepager = 1;
-		}
+		if (pager && strncmp(line, "exit", 4))
+			vty_open_pager(vty);
 
 		if (!strcmp(cmd->string, "configure terminal")) {
 			for (i = 0; i < array_size(vtysh_client); i++) {
 				cmd_stat = vtysh_client_execute(
-					&vtysh_client[i], line, fp);
+					&vtysh_client[i], line);
 				if (cmd_stat == CMD_WARNING)
 					break;
 			}
@@ -460,14 +551,10 @@ static int vtysh_execute_func(const char
 				line = "end";
 				vline = cmd_make_strvec(line);
 
+
 				if (vline == NULL) {
-					if (pager && vtysh_pager_name && fp
-					    && fp != outputfile && closepager) {
-						if (pclose(fp) == -1) {
-							perror("pclose failed for pager");
-						}
-						fp = NULL;
-					}
+					if (vty->is_paged)
+						vty_close_pager(vty);
 					return CMD_SUCCESS;
 				}
 
@@ -487,6 +574,13 @@ static int vtysh_execute_func(const char
 			if (cmd->daemon & vtysh_client[i].flag) {
 				if (vtysh_client[i].fd < 0
 				    && (cmd->daemon == vtysh_client[i].flag)) {
+					for (vc = &vtysh_client[i]; vc;
+					     vc = vc->next)
+						if (vc->fd < 0)
+							vtysh_reconnect(vc);
+				}
+				if (vtysh_client[i].fd < 0
+				    && (cmd->daemon == vtysh_client[i].flag)) {
 					bool any_inst = false;
 					for (vc = &vtysh_client[i]; vc;
 					     vc = vc->next)
@@ -500,7 +594,7 @@ static int vtysh_execute_func(const char
 					}
 				}
 				cmd_stat = vtysh_client_execute(
-					&vtysh_client[i], line, fp);
+					&vtysh_client[i], line);
 				if (cmd_stat != CMD_SUCCESS)
 					break;
 			}
@@ -512,12 +606,9 @@ static int vtysh_execute_func(const char
 			(*cmd->func)(cmd, vty, 0, NULL);
 	}
 	}
-	if (pager && vtysh_pager_name && fp && closepager && fp != outputfile) {
-		if (pclose(fp) == -1) {
-			perror("pclose failed for pager");
-		}
-		fp = NULL;
-	}
+	if (vty->is_paged)
+		vty_close_pager(vty);
+
 	return cmd_stat;
 }
 
@@ -594,19 +685,19 @@ int vtysh_mark_file(const char *filename
 		switch (vty->node) {
 		case LDP_IPV4_IFACE_NODE:
 			if (strncmp(vty_buf_copy, "   ", 3)) {
-				fprintf(outputfile, "  end\n");
+				vty_out(vty, "  end\n");
 				vty->node = LDP_IPV4_NODE;
 			}
 			break;
 		case LDP_IPV6_IFACE_NODE:
 			if (strncmp(vty_buf_copy, "   ", 3)) {
-				fprintf(outputfile, "  end\n");
+				vty_out(vty, "  end\n");
 				vty->node = LDP_IPV6_NODE;
 			}
 			break;
 		case LDP_PSEUDOWIRE_NODE:
 			if (strncmp(vty_buf_copy, "  ", 2)) {
-				fprintf(outputfile, " end\n");
+				vty_out(vty, " end\n");
 				vty->node = LDP_L2VPN_NODE;
 			}
 			break;
@@ -615,7 +706,7 @@ int vtysh_mark_file(const char *filename
 		}
 
 		if (vty_buf_trimmed[0] == '!' || vty_buf_trimmed[0] == '#') {
-			fprintf(outputfile, "%s", vty->buf);
+			vty_out(vty, "%s", vty->buf);
 			continue;
 		}
 
@@ -623,12 +714,14 @@ int vtysh_mark_file(const char *filename
 		vline = cmd_make_strvec(vty->buf);
 
 		if (vline == NULL) {
-			fprintf(outputfile, "%s", vty->buf);
+			vty_out(vty, "%s", vty->buf);
 			continue;
 		}
 
-		/* Ignore the "end" lines, we will generate these where
-		 * appropriate */
+		/*
+		 * Ignore the "end" lines, we will generate these where
+		 * appropriate
+		 */
 		if (strlen(vty_buf_trimmed) == 3
 		    && strncmp("end", vty_buf_trimmed, 3) == 0) {
 			cmd_free_strvec(vline);
@@ -638,11 +731,11 @@ int vtysh_mark_file(const char *filename
 		prev_node = vty->node;
 		saved_ret = ret = cmd_execute_command_strict(vline, vty, &cmd);
 
-		/* If command doesn't succeeded in current node, try to walk up
-		 * in node tree.
-		 * Changing vty->node is enough to try it just out without
-		 * actual walkup in
-		 * the vtysh. */
+		/*
+		 * If command doesn't succeeded in current node, try to walk up
+		 * in node tree. Changing vty->node is enough to try it just
+		 * out without actual walkup in the vtysh.
+		 */
 		while (ret != CMD_SUCCESS && ret != CMD_SUCCESS_DAEMON
 		       && ret != CMD_WARNING && ret != CMD_WARNING_CONFIG_FAILED
 		       && vty->node > CONFIG_NODE) {
@@ -651,9 +744,11 @@ int vtysh_mark_file(const char *filename
 			tried++;
 		}
 
-		/* If command succeeded in any other node than current (tried >
-		 * 0) we have
-		 * to move into node in the vtysh where it succeeded. */
+		/*
+		 * If command succeeded in any other node than current (tried >
+		 * 0) we have to move into node in the vtysh where it
+		 * succeeded.
+		 */
 		if (ret == CMD_SUCCESS || ret == CMD_SUCCESS_DAEMON
 		    || ret == CMD_WARNING) {
 			if ((prev_node == BGP_VPNV4_NODE
@@ -668,20 +763,21 @@ int vtysh_mark_file(const char *filename
 			     || prev_node == BGP_IPV6M_NODE
 			     || prev_node == BGP_EVPN_NODE)
 			    && (tried == 1)) {
-				fprintf(outputfile, "exit-address-family\n");
+				vty_out(vty, "exit-address-family\n");
 			} else if ((prev_node == BGP_EVPN_VNI_NODE)
 				   && (tried == 1)) {
-				fprintf(outputfile, "exit-vni\n");
+				vty_out(vty, "exit-vni\n");
 			} else if ((prev_node == KEYCHAIN_KEY_NODE)
 				   && (tried == 1)) {
-				fprintf(outputfile, "exit\n");
+				vty_out(vty, "exit\n");
 			} else if (tried) {
-				fprintf(outputfile, "end\n");
+				vty_out(vty, "end\n");
 			}
 		}
-		/* If command didn't succeed in any node, continue with return
-		 * value from
-		 * first try. */
+		/*
+		 * If command didn't succeed in any node, continue with return
+		 * value from first try.
+		 */
 		else if (tried) {
 			ret = saved_ret;
 			vty->node = prev_node;
@@ -720,22 +816,14 @@ int vtysh_mark_file(const char *filename
 			XFREE(MTYPE_VTYSH_CMD, vty_buf_copy);
 			return CMD_ERR_INCOMPLETE;
 		case CMD_SUCCESS:
-			fprintf(stdout, "%s", vty->buf);
+			vty_out(vty, "%s", vty->buf);
 			break;
 		case CMD_SUCCESS_DAEMON: {
-			unsigned int i;
-			int cmd_stat = CMD_SUCCESS;
+			int cmd_stat;
 
-			fprintf(outputfile, "%s", vty->buf);
-			for (i = 0; i < array_size(vtysh_client); i++) {
-				if (cmd->daemon & vtysh_client[i].flag) {
-					cmd_stat = vtysh_client_execute(
-						&vtysh_client[i], vty->buf,
-						outputfile);
-					if (cmd_stat != CMD_SUCCESS)
-						break;
-				}
-			}
+			vty_out(vty, "%s", vty->buf);
+			cmd_stat = vtysh_client_execute(&vtysh_client[0],
+							vty->buf);
 			if (cmd_stat != CMD_SUCCESS)
 				break;
 
@@ -745,7 +833,7 @@ int vtysh_mark_file(const char *filename
 		}
 	}
 	/* This is the end */
-	fprintf(outputfile, "\nend\n");
+	vty_out(vty, "\nend\n");
 	vty_close(vty);
 	XFREE(MTYPE_VTYSH_CMD, vty_buf_copy);
 
@@ -761,6 +849,7 @@ int vtysh_config_from_file(struct vty *v
 	int ret;
 	const struct cmd_element *cmd;
 	int lineno = 0;
+	/* once we have an error, we remember & return that */
 	int retcode = CMD_SUCCESS;
 
 	while (fgets(vty->buf, VTY_BUFSIZ, fp)) {
@@ -774,30 +863,25 @@ int vtysh_config_from_file(struct vty *v
 			if (vty->type == VTY_FILE)
 				fprintf(stderr, "line %d: Warning[%d]...: %s\n",
 					lineno, vty->node, vty->buf);
-			retcode = ret; /* once we have an error, we remember &
-					  return that */
+			retcode = ret;
+
 			break;
 		case CMD_ERR_AMBIGUOUS:
 			fprintf(stderr,
 				"line %d: %% Ambiguous command[%d]: %s\n",
 				lineno, vty->node, vty->buf);
-			retcode = CMD_ERR_AMBIGUOUS; /* once we have an error,
-							we remember & return
-							that */
+			retcode = CMD_ERR_AMBIGUOUS;
 			break;
 		case CMD_ERR_NO_MATCH:
 			fprintf(stderr, "line %d: %% Unknown command[%d]: %s",
 				lineno, vty->node, vty->buf);
-			retcode = CMD_ERR_NO_MATCH; /* once we have an error, we
-						       remember & return that */
+			retcode = CMD_ERR_NO_MATCH;
 			break;
 		case CMD_ERR_INCOMPLETE:
 			fprintf(stderr,
 				"line %d: %% Command incomplete[%d]: %s\n",
 				lineno, vty->node, vty->buf);
-			retcode = CMD_ERR_INCOMPLETE; /* once we have an error,
-							 we remember & return
-							 that */
+			retcode = CMD_ERR_INCOMPLETE;
 			break;
 		case CMD_SUCCESS_DAEMON: {
 			unsigned int i;
@@ -806,20 +890,15 @@ int vtysh_config_from_file(struct vty *v
 			for (i = 0; i < array_size(vtysh_client); i++) {
 				if (cmd->daemon & vtysh_client[i].flag) {
 					cmd_stat = vtysh_client_execute(
-						&vtysh_client[i], vty->buf,
-						outputfile);
+						&vtysh_client[i], vty->buf);
 					/*
 					 * CMD_WARNING - Can mean that the
-					 * command was
-					 * parsed successfully but it was
-					 * already entered
-					 * in a few spots.  As such if we
-					 * receive a
+					 * command was parsed successfully but
+					 * it was already entered in a few
+					 * spots. As such if we receive a
 					 * CMD_WARNING from a daemon we
-					 * shouldn't stop
-					 * talking to the other daemons for the
-					 * particular
-					 * command.
+					 * shouldn't stop talking to the other
+					 * daemons for the particular command.
 					 */
 					if (cmd_stat != CMD_SUCCESS
 					    && cmd_stat != CMD_WARNING) {
@@ -845,27 +924,29 @@ int vtysh_config_from_file(struct vty *v
 	return (retcode);
 }
 
-/* We don't care about the point of the cursor when '?' is typed. */
-static int vtysh_rl_describe(void)
+/*
+ * Function processes cli commands terminated with '?' character when entered
+ * through either 'vtysh' or 'vtysh -c' interfaces.
+ */
+static int vtysh_process_questionmark(const char *input, int input_len)
 {
-	int ret;
+	int ret, width = 0;
 	unsigned int i;
-	vector vline;
-	vector describe;
-	int width;
+	vector vline, describe;
 	struct cmd_token *token;
 
-	vline = cmd_make_strvec(rl_line_buffer);
+	if (!input)
+		return 1;
+
+	vline = cmd_make_strvec(input);
 
 	/* In case of '> ?'. */
 	if (vline == NULL) {
 		vline = vector_init(1);
 		vector_set(vline, NULL);
-	} else if (rl_end && isspace((int)rl_line_buffer[rl_end - 1]))
+	} else if (input_len && isspace((int)input[input_len - 1]))
 		vector_set(vline, NULL);
 
-	fprintf(stdout, "\n");
-
 	describe = cmd_describe_command(vline, vty, &ret);
 
 	/* Ambiguous and no match error. */
@@ -873,7 +954,7 @@ static int vtysh_rl_describe(void)
 	case CMD_ERR_AMBIGUOUS:
 		cmd_free_strvec(vline);
 		vector_free(describe);
-		fprintf(stdout, "%% Ambiguous command.\n");
+		vty_out(vty, "%% Ambiguous command.\n");
 		rl_on_new_line();
 		return 0;
 		break;
@@ -881,7 +962,7 @@ static int vtysh_rl_describe(void)
 		cmd_free_strvec(vline);
 		if (describe)
 			vector_free(describe);
-		fprintf(stdout, "%% There is no matched command.\n");
+		vty_out(vty, "%% There is no matched command.\n");
 		rl_on_new_line();
 		return 0;
 		break;
@@ -903,10 +984,10 @@ static int vtysh_rl_describe(void)
 	for (i = 0; i < vector_active(describe); i++)
 		if ((token = vector_slot(describe, i)) != NULL) {
 			if (!token->desc)
-				fprintf(stdout, "  %-s\n", token->text);
+				vty_out(vty, "  %-s\n", token->text);
 			else
-				fprintf(stdout, "  %-*s  %s\n", width,
-					token->text, token->desc);
+				vty_out(vty, "  %-*s  %s\n", width, token->text,
+					token->desc);
 
 			if (IS_VARYING_TOKEN(token->type)) {
 				const char *ref = vector_slot(
@@ -921,7 +1002,7 @@ static int vtysh_rl_describe(void)
 
 					char *ac = cmd_variable_comp2str(
 						varcomps, cols);
-					fprintf(stdout, "%s\n", ac);
+					vty_out(vty, "%s\n", ac);
 					XFREE(MTYPE_TMP, ac);
 				}
 
@@ -932,9 +1013,61 @@ static int vtysh_rl_describe(void)
 	cmd_free_strvec(vline);
 	vector_free(describe);
 
+	return 0;
+}
+
+/*
+ * Entry point for user commands terminated with '?' character and typed through
+ * the usual vtysh's stdin interface. This is the function being registered with
+ * readline() api's.
+ */
+static int vtysh_rl_describe(int a, int b)
+{
+	int ret;
+
+	vty_out(vty, "\n");
+
+	ret = vtysh_process_questionmark(rl_line_buffer, rl_end);
 	rl_on_new_line();
 
-	return 0;
+	return ret;
+}
+
+/*
+ * Function in charged of processing vtysh instructions terminating with '?'
+ * character and received through the 'vtysh -c' interface. If user's
+ * instruction is well-formatted, we will call the same processing routine
+ * utilized by the traditional vtysh's stdin interface.
+ */
+int vtysh_execute_command_questionmark(char *input)
+{
+	int input_len, qmark_count = 0;
+	const char *str;
+
+	if (!(input && *input))
+		return 1;
+
+	/* Finding out question_mark count and strlen */
+	for (str = input; *str; ++str) {
+		if (*str == '?')
+			qmark_count++;
+	}
+	input_len = str - input;
+
+	/*
+	 * Verify that user's input terminates in '?' and that patterns such as
+	 * 'cmd ? subcmd ?' are prevented.
+	 */
+	if (qmark_count != 1 || input[input_len - 1] != '?')
+		return 1;
+
+	/*
+	 * Questionmark-processing function is not expecting to receive '?'
+	 * character in input string.
+	 */
+	input[input_len - 1] = '\0';
+
+	return vtysh_process_questionmark(input, input_len - 1);
 }
 
 /* Result of cmd_complete_command() call will be stored here
@@ -967,8 +1100,10 @@ static char *command_generator(const cha
 	}
 
 	if (matched && matched[index])
-		/* this is free()'d by readline, but we leak 1 count of
-		 * MTYPE_COMPLETION */
+		/*
+		 * this is free()'d by readline, but we leak 1 count of
+		 * MTYPE_COMPLETION
+		 */
 		return matched[index++];
 
 	XFREE(MTYPE_TMP, matched);
@@ -1121,6 +1256,18 @@ struct cmd_node link_params_node = {
 static struct cmd_node rpki_node = {RPKI_NODE, "%s(config-rpki)# ", 1};
 #endif
 
+#if HAVE_BFDD > 0
+static struct cmd_node bfd_node = {
+	BFD_NODE,
+	"%s(config-bfd)# ",
+};
+
+static struct cmd_node bfd_peer_node = {
+	BFD_PEER_NODE,
+	"%s(config-bfd-peer)# ",
+};
+#endif /* HAVE_BFDD */
+
 /* Defined in lib/vty.c */
 extern struct cmd_node vty_node;
 
@@ -1288,24 +1435,6 @@ DEFUNSH(VTYSH_BGPD,
 	return CMD_SUCCESS;
 }
 
-DEFUNSH(VTYSH_BGPD,
-	rpki_exit,
-	rpki_exit_cmd,
-	"exit",
-	"Exit current mode and down to previous mode\n")
-{
-	vty->node = CONFIG_NODE;
-	return CMD_SUCCESS;
-}
-
-DEFUNSH(VTYSH_BGPD,
-	rpki_quit,
-	rpki_quit_cmd,
-	"quit",
-	"Exit current mode and down to previous mode\n")
-{
-	return rpki_exit(self, vty, argc, argv);
-}
 #endif
 
 DEFUNSH(VTYSH_BGPD, address_family_evpn, address_family_evpn_cmd,
@@ -1537,7 +1666,7 @@ DEFUNSH(VTYSH_RMAP, vtysh_route_map, vty
 }
 
 DEFUNSH(VTYSH_PBRD, vtysh_pbr_map, vtysh_pbr_map_cmd,
-	"pbr-map NAME seq (1-1000)",
+	"pbr-map NAME seq (1-700)",
 	"Create pbr-map or enter pbr-map command mode\n"
 	"The name of the PBR MAP\n"
 	"Sequence to insert to/delete from existing pbr-map entry\n"
@@ -1547,7 +1676,33 @@ DEFUNSH(VTYSH_PBRD, vtysh_pbr_map, vtysh
 	return CMD_SUCCESS;
 }
 
-DEFSH(VTYSH_PBRD, vtysh_no_pbr_map_cmd, "no pbr-map WORD [seq (1-65535)]",
+#if HAVE_BFDD > 0
+DEFUNSH(VTYSH_BFDD, bfd_enter, bfd_enter_cmd, "bfd", "Configure BFD peers\n")
+{
+	vty->node = BFD_NODE;
+	return CMD_SUCCESS;
+}
+
+DEFUNSH(VTYSH_BFDD, bfd_peer_enter, bfd_peer_enter_cmd,
+	"peer <A.B.C.D|X:X::X:X> [{multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME|vrf NAME}]",
+	"Configure peer\n"
+	"IPv4 peer address\n"
+	"IPv6 peer address\n"
+	"Configure multihop\n"
+	"Configure local address\n"
+	"IPv4 local address\n"
+	"IPv6 local address\n"
+	INTERFACE_STR
+	"Configure interface name to use\n"
+	"Configure VRF\n"
+	"Configure VRF name\n")
+{
+	vty->node = BFD_PEER_NODE;
+	return CMD_SUCCESS;
+}
+#endif /* HAVE_BFDD */
+
+DEFSH(VTYSH_PBRD, vtysh_no_pbr_map_cmd, "no pbr-map WORD [seq (1-700)]",
 	NO_STR
 	"Delete pbr-map\n"
 	"The name of  the PBR MAP\n"
@@ -1616,6 +1771,8 @@ static int vtysh_exit(struct vty *vty)
 	case PBRMAP_NODE:
 	case VTY_NODE:
 	case KEYCHAIN_NODE:
+	case BFD_NODE:
+	case RPKI_NODE:
 		vtysh_execute("end");
 		vtysh_execute("configure terminal");
 		vty->node = CONFIG_NODE;
@@ -1659,6 +1816,9 @@ static int vtysh_exit(struct vty *vty)
 	case LINK_PARAMS_NODE:
 		vty->node = INTERFACE_NODE;
 		break;
+	case BFD_PEER_NODE:
+		vty->node = BFD_NODE;
+		break;
 	default:
 		break;
 	}
@@ -1706,8 +1866,24 @@ DEFUNSH(VTYSH_BGPD, exit_vnc_config, exi
 	    || vty->node == BGP_VNC_L2_GROUP_NODE)
 		vty->node = BGP_NODE;
 	return CMD_SUCCESS;
+
 }
 
+#if defined(HAVE_RPKI)
+DEFUNSH(VTYSH_BGPD, rpki_exit, rpki_exit_cmd, "exit",
+	"Exit current mode and down to previous mode\n")
+{
+	vtysh_exit(vty);
+	return CMD_SUCCESS;
+}
+
+DEFUNSH(VTYSH_BGPD, rpki_quit, rpki_quit_cmd, "quit",
+	"Exit current mode and down to previous mode\n")
+{
+	return rpki_exit(self, vty, argc, argv);
+}
+#endif /* HAVE_RPKI */
+
 DEFUNSH(VTYSH_PIMD|VTYSH_ZEBRA, exit_vrf_config, exit_vrf_config_cmd, "exit-vrf",
 	"Exit from VRF configuration mode\n")
 {
@@ -1855,6 +2031,17 @@ DEFUNSH(VTYSH_ISISD, vtysh_quit_isisd, v
 	return vtysh_exit_isisd(self, vty, argc, argv);
 }
 
+#if HAVE_BFDD > 0
+DEFUNSH(VTYSH_BFDD, vtysh_exit_bfdd, vtysh_exit_bfdd_cmd, "exit",
+	"Exit current mode and down to previous mode\n")
+{
+	return vtysh_exit(vty);
+}
+
+ALIAS(vtysh_exit_bfdd, vtysh_quit_bfdd_cmd, "quit",
+      "Exit current mode and down to previous mode\n")
+#endif
+
 DEFUNSH(VTYSH_ALL, vtysh_exit_line_vty, vtysh_exit_line_vty_cmd, "exit",
 	"Exit current mode and down to previous mode\n")
 {
@@ -1885,18 +2072,6 @@ DEFUNSH(VTYSH_ZEBRA, vtysh_pseudowire, v
 	return CMD_SUCCESS;
 }
 
-/* TODO Implement "no interface command in isisd. */
-DEFSH(VTYSH_ZEBRA | VTYSH_RIPD | VTYSH_RIPNGD | VTYSH_OSPFD | VTYSH_OSPF6D
-	      | VTYSH_EIGRPD,
-      vtysh_no_interface_cmd, "no interface IFNAME", NO_STR
-      "Delete a pseudo interface's configuration\n"
-      "Interface's name\n")
-
-DEFSH(VTYSH_ZEBRA, vtysh_no_interface_vrf_cmd, "no interface IFNAME vrf NAME",
-      NO_STR
-      "Delete a pseudo interface's configuration\n"
-      "Interface's name\n" VRF_CMD_HELP_STR)
-
 DEFUNSH(VTYSH_ZEBRA, vtysh_logicalrouter, vtysh_logicalrouter_cmd,
 	"logical-router (1-65535) ns NAME",
 	"Enable a logical-router\n"
@@ -1937,9 +2112,16 @@ DEFUNSH(VTYSH_VRF, vtysh_vrf, vtysh_vrf_
 	return CMD_SUCCESS;
 }
 
-DEFSH(VTYSH_ZEBRA, vtysh_no_vrf_cmd, "no vrf NAME", NO_STR
-      "Delete a pseudo vrf's configuration\n"
-      "VRF's name\n")
+DEFSH(VTYSH_ZEBRA, vtysh_vrf_netns_cmd,
+      "netns NAME",
+      "Attach VRF to a Namespace\n"
+      "The file name in " NS_RUN_DIR ", or a full pathname\n")
+
+DEFSH(VTYSH_ZEBRA, vtysh_no_vrf_netns_cmd,
+      "no netns [NAME]",
+      NO_STR
+      "Detach VRF from a Namespace\n"
+      "The file name in " NS_RUN_DIR ", or a full pathname\n")
 
 DEFUNSH(VTYSH_NS, vtysh_exit_logicalrouter,
 	vtysh_exit_logicalrouter_cmd, "exit",
@@ -1979,17 +2161,6 @@ DEFUNSH(VTYSH_VRF, vtysh_quit_nexthop_gr
 	return vtysh_exit_nexthop_group(self, vty, argc, argv);
 }
 
-/* TODO Implement interface description commands in ripngd, ospf6d
- * and isisd. */
-DEFSH(VTYSH_ZEBRA | VTYSH_RIPD | VTYSH_OSPFD | VTYSH_EIGRPD,
-      vtysh_interface_desc_cmd, "description LINE...",
-      "Interface specific description\n"
-      "Characters describing this interface\n")
-
-DEFSH(VTYSH_ZEBRA | VTYSH_RIPD | VTYSH_OSPFD | VTYSH_EIGRPD,
-      vtysh_no_interface_desc_cmd, "no description",
-      NO_STR "Interface specific description\n")
-
 DEFUNSH(VTYSH_INTERFACE, vtysh_exit_interface, vtysh_exit_interface_cmd, "exit",
 	"Exit current mode and down to previous mode\n")
 {
@@ -2002,6 +2173,28 @@ DEFUNSH(VTYSH_INTERFACE, vtysh_quit_inte
 	return vtysh_exit_interface(self, vty, argc, argv);
 }
 
+DEFUN (vtysh_show_poll,
+       vtysh_show_poll_cmd,
+       "show thread poll",
+       SHOW_STR
+       "Thread information\n"
+       "Thread Poll Information\n")
+{
+	unsigned int i;
+	int ret = CMD_SUCCESS;
+	char line[100];
+
+	snprintf(line, sizeof(line), "do show thread poll\n");
+	for (i = 0; i < array_size(vtysh_client); i++)
+		if (vtysh_client[i].fd >= 0) {
+			vty_out(vty, "Thread statistics for %s:\n",
+				vtysh_client[i].name);
+			ret = vtysh_client_execute(&vtysh_client[i], line);
+			vty_out(vty, "\n");
+		}
+	return ret;
+}
+
 DEFUN (vtysh_show_thread,
        vtysh_show_thread_cmd,
        "show thread cpu [FILTER]",
@@ -2021,11 +2214,10 @@ DEFUN (vtysh_show_thread,
 	snprintf(line, sizeof(line), "do show thread cpu %s\n", filter);
 	for (i = 0; i < array_size(vtysh_client); i++)
 		if (vtysh_client[i].fd >= 0) {
-			fprintf(stdout, "Thread statistics for %s:\n",
+			vty_out(vty, "Thread statistics for %s:\n",
 				vtysh_client[i].name);
-			ret = vtysh_client_execute(&vtysh_client[i], line,
-						   outputfile);
-			fprintf(stdout, "\n");
+			ret = vtysh_client_execute(&vtysh_client[i], line);
+			vty_out(vty, "\n");
 		}
 	return ret;
 }
@@ -2042,11 +2234,10 @@ DEFUN (vtysh_show_work_queues,
 
 	for (i = 0; i < array_size(vtysh_client); i++)
 		if (vtysh_client[i].fd >= 0) {
-			fprintf(stdout, "Work queue statistics for %s:\n",
+			vty_out(vty, "Work queue statistics for %s:\n",
 				vtysh_client[i].name);
-			ret = vtysh_client_execute(&vtysh_client[i], line,
-						   outputfile);
-			fprintf(stdout, "\n");
+			ret = vtysh_client_execute(&vtysh_client[i], line);
+			vty_out(vty, "\n");
 		}
 
 	return ret;
@@ -2075,8 +2266,7 @@ DEFUN (vtysh_show_work_queues_daemon,
 			break;
 	}
 
-	ret = vtysh_client_execute(&vtysh_client[i], "show work-queues\n",
-				   outputfile);
+	ret = vtysh_client_execute(&vtysh_client[i], "show work-queues\n");
 
 	return ret;
 }
@@ -2103,10 +2293,9 @@ static int show_per_daemon(const char *l
 
 	for (i = 0; i < array_size(vtysh_client); i++)
 		if (vtysh_client[i].fd >= 0) {
-			fprintf(outputfile, headline, vtysh_client[i].name);
-			ret = vtysh_client_execute(&vtysh_client[i], line,
-						   outputfile);
-			fprintf(stdout, "\n");
+			vty_out(vty, headline, vtysh_client[i].name);
+			ret = vtysh_client_execute(&vtysh_client[i], line);
+			vty_out(vty, "\n");
 		}
 
 	return ret;
@@ -2140,21 +2329,43 @@ DEFUN (vtysh_show_debugging_hashtable,
        "Statistics about hash tables\n"
        "Statistics about hash tables\n")
 {
-	fprintf(stdout, "\n");
-	fprintf(stdout,
+	vty_out(vty, "\n");
+	vty_out(vty,
 		"Load factor (LF) - average number of elements across all buckets\n");
-	fprintf(stdout,
+	vty_out(vty,
 		"Full load factor (FLF) - average number of elements across full buckets\n\n");
-	fprintf(stdout,
+	vty_out(vty,
 		"Standard deviation (SD) is calculated for both the LF and FLF\n");
-	fprintf(stdout,
+	vty_out(vty,
 		"and indicates the typical deviation of bucket chain length\n");
-	fprintf(stdout, "from the value in the corresponding load factor.\n\n");
+	vty_out(vty, "from the value in the corresponding load factor.\n\n");
 
 	return show_per_daemon("do show debugging hashtable\n",
 			       "Hashtable statistics for %s:\n");
 }
 
+DEFUN (vtysh_show_error_code,
+       vtysh_show_error_code_cmd,
+       "show error <(1-4294967296)|all> [json]",
+       SHOW_STR
+       "Information on errors\n"
+       "Error code to get info about\n"
+       "Information on all errors\n"
+       JSON_STR)
+{
+	char *fcmd = argv_concat(argv, argc, 0);
+	char cmd[256];
+	int rv;
+
+	snprintf(cmd, sizeof(cmd), "do %s", fcmd);
+
+	/* FIXME: Needs to determine which daemon to send to via code ranges */
+	rv = show_per_daemon(cmd, "");
+
+	XFREE(MTYPE_TMP, fcmd);
+	return rv;
+}
+
 /* Memory */
 DEFUN (vtysh_show_memory,
        vtysh_show_memory_cmd,
@@ -2263,10 +2474,11 @@ DEFUNSH(VTYSH_ALL, vtysh_log_syslog, vty
 }
 
 DEFUNSH(VTYSH_ALL, no_vtysh_log_syslog, no_vtysh_log_syslog_cmd,
-	"no log syslog [LEVEL]", NO_STR
+	"no log syslog [<emergencies|alerts|critical|errors|warnings|notifications|informational|debugging>]",
+	NO_STR
 	"Logging control\n"
 	"Cancel logging to syslog\n"
-	"Logging level\n")
+	LOG_LEVEL_DESC)
 {
 	return CMD_SUCCESS;
 }
@@ -2288,24 +2500,6 @@ DEFUNSH(VTYSH_ALL, no_vtysh_log_facility
 	return CMD_SUCCESS;
 }
 
-DEFUNSH_DEPRECATED(
-	VTYSH_ALL, vtysh_log_trap, vtysh_log_trap_cmd,
-	"log trap <emergencies|alerts|critical|errors|warnings|notifications|informational|debugging>",
-	"Logging control\n"
-	"(Deprecated) Set logging level and default for all destinations\n" LOG_LEVEL_DESC)
-{
-	return CMD_SUCCESS;
-}
-
-DEFUNSH_DEPRECATED(VTYSH_ALL, no_vtysh_log_trap, no_vtysh_log_trap_cmd,
-		   "no log trap [LEVEL]", NO_STR
-		   "Logging control\n"
-		   "Permit all logging information\n"
-		   "Logging level\n")
-{
-	return CMD_SUCCESS;
-}
-
 DEFUNSH(VTYSH_ALL, vtysh_log_record_priority, vtysh_log_record_priority_cmd,
 	"log record-priority",
 	"Logging control\n"
@@ -2414,19 +2608,10 @@ DEFUN (vtysh_write_terminal,
 {
 	unsigned int i;
 	char line[] = "do write terminal\n";
-	FILE *fp = outputfile;
 
-	if (fp == stdout && vtysh_pager_name) {
-		fp = popen(vtysh_pager_name, "w");
-		if (fp == NULL) {
-			perror("popen");
-			exit(1);
-		}
-	}
-
-	fprintf(outputfile, "Building configuration...\n");
-	fprintf(outputfile, "\nCurrent configuration:\n");
-	fprintf(outputfile, "!\n");
+	vty_out(vty, "Building configuration...\n");
+	vty_out(vty, "\nCurrent configuration:\n");
+	vty_out(vty, "!\n");
 
 	for (i = 0; i < array_size(vtysh_client); i++)
 		if ((argc < 3)
@@ -2434,20 +2619,12 @@ DEFUN (vtysh_write_terminal,
 			vtysh_client_config(&vtysh_client[i], line);
 
 	/* Integrate vtysh specific configuration. */
+	vty_open_pager(vty);
 	vtysh_config_write();
+	vtysh_config_dump();
+	vty_close_pager(vty);
+	vty_out(vty, "end\n");
 
-	vtysh_config_dump(fp);
-
-	if (vtysh_pager_name && fp && fp != outputfile) {
-		fflush(fp);
-		if (pclose(fp) == -1) {
-			perror("pclose");
-			exit(1);
-		}
-		fp = NULL;
-	}
-
-	fprintf(outputfile, "end\n");
 	return CMD_SUCCESS;
 }
 
@@ -2499,8 +2676,13 @@ static void backup_config_file(const cha
 	strcat(integrate_sav, CONF_BACKUP_EXT);
 
 	/* Move current configuration file to backup config file. */
-	unlink(integrate_sav);
-	rename(fbackup, integrate_sav);
+	if (unlink(integrate_sav) != 0) {
+		vty_out(vty, "Warning: %s unlink failed\n", integrate_sav);
+	}
+	if (rename(fbackup, integrate_sav) != 0) {
+		vty_out(vty, "Error renaming %s to %s\n", fbackup,
+			integrate_sav);
+	}
 	free(integrate_sav);
 }
 
@@ -2510,19 +2692,23 @@ int vtysh_write_config_integrated(void)
 	char line[] = "do write terminal\n";
 	FILE *fp;
 	int fd;
+#ifdef FRR_USER
 	struct passwd *pwentry;
+#endif
+#ifdef FRR_GROUP
 	struct group *grentry;
+#endif
 	uid_t uid = -1;
 	gid_t gid = -1;
 	struct stat st;
 	int err = 0;
 
-	fprintf(stdout, "Building Configuration...\n");
+	vty_out(vty, "Building Configuration...\n");
 
 	backup_config_file(frr_config);
 	fp = fopen(frr_config, "w");
 	if (fp == NULL) {
-		fprintf(stdout,
+		vty_out(vty,
 			"%% Error: failed to open configuration file %s: %s\n",
 			frr_config, safe_strerror(errno));
 		return CMD_WARNING_CONFIG_FAILED;
@@ -2533,7 +2719,10 @@ int vtysh_write_config_integrated(void)
 		vtysh_client_config(&vtysh_client[i], line);
 
 	vtysh_config_write();
-	vtysh_config_dump(fp);
+	vty->of_saved = vty->of;
+	vty->of = fp;
+	vtysh_config_dump();
+	vty->of = vty->of_saved;
 
 	if (fchmod(fd, CONFIGFILE_MASK) != 0) {
 		printf("%% Warning: can't chmod configuration file %s: %s\n",
@@ -2616,8 +2805,7 @@ DEFUN (vtysh_write_memory,
 	char line[] = "do write memory\n";
 	unsigned int i;
 
-	fprintf(outputfile,
-		"Note: this version of vtysh never writes vtysh.conf\n");
+	vty_out(vty, "Note: this version of vtysh never writes vtysh.conf\n");
 
 	/* If integrated frr.conf explicitely set. */
 	if (want_config_integrated()) {
@@ -2632,8 +2820,7 @@ DEFUN (vtysh_write_memory,
 		if (i < array_size(vtysh_client) && vtysh_client[i].fd != -1) {
 			used_watchfrr = true;
 			ret = vtysh_client_execute(&vtysh_client[i],
-						   "do write integrated",
-						   outputfile);
+						   "do write integrated");
 		}
 
 		/*
@@ -2649,10 +2836,10 @@ DEFUN (vtysh_write_memory,
 		return ret;
 	}
 
-	fprintf(outputfile, "Building Configuration...\n");
+	vty_out(vty, "Building Configuration...\n");
 
 	for (i = 0; i < array_size(vtysh_client); i++)
-		ret = vtysh_client_execute(&vtysh_client[i], line, outputfile);
+		ret = vtysh_client_execute(&vtysh_client[i], line);
 
 	return ret;
 }
@@ -2681,7 +2868,7 @@ DEFUN (vtysh_terminal_length,
 
 	lines = strtol(argv[idx_number]->arg, &endptr, 10);
 	if (lines < 0 || lines > 512 || *endptr != '\0') {
-		fprintf(outputfile, "length is malformed\n");
+		vty_out(vty, "length is malformed\n");
 		return CMD_WARNING;
 	}
 
@@ -2724,8 +2911,8 @@ DEFUN (vtysh_show_daemons,
 
 	for (i = 0; i < array_size(vtysh_client); i++)
 		if (vtysh_client[i].fd >= 0)
-			fprintf(outputfile, " %s", vtysh_client[i].name);
-	fprintf(outputfile, "\n");
+			vty_out(vty, " %s", vtysh_client[i].name);
+	vty_out(vty, "\n");
 
 	return CMD_SUCCESS;
 }
@@ -2922,11 +3109,11 @@ DEFUN (vtysh_output_file,
        "Path to dump output to\n")
 {
 	const char *path = argv[argc - 1]->arg;
-	outputfile = fopen(path, "a");
-	if (!outputfile) {
-		fprintf(stdout, "Failed to open file '%s': %s\n", path,
+	vty->of = fopen(path, "a");
+	if (!vty->of) {
+		vty_out(vty, "Failed to open file '%s': %s\n", path,
 			safe_strerror(errno));
-		outputfile = stdout;
+		vty->of = stdout;
 	}
 	return CMD_SUCCESS;
 }
@@ -2939,9 +3126,9 @@ DEFUN (no_vtysh_output_file,
        "Direct vtysh output to file\n"
        "Path to dump output to\n")
 {
-	if (outputfile != stdout) {
-		fclose(outputfile);
-		outputfile = stdout;
+	if (vty->of != stdout) {
+		fclose(vty->of);
+		vty->of = stdout;
 	}
 	return CMD_SUCCESS;
 }
@@ -2965,7 +3152,7 @@ DEFUN(find,
 		for (unsigned int j = 0; j < vector_active(clis); j++) {
 			cli = vector_slot(clis, j);
 			if (strcasestr(cli->string, text))
-				fprintf(stdout, "  (%s)  %s\n",
+				vty_out(vty, "  (%s)  %s\n",
 					node_names[node->node], cli->string);
 		}
 	}
@@ -3061,6 +3248,22 @@ static int vtysh_connect(struct vtysh_cl
 	return 0;
 }
 
+static int vtysh_reconnect(struct vtysh_client *vclient)
+{
+	int ret;
+
+	fprintf(stderr, "Warning: connecting to %s...", vclient->name);
+	ret = vtysh_connect(vclient);
+	if (ret < 0) {
+		fprintf(stderr, "failed!\n");
+		return ret;
+	}
+	fprintf(stderr, "success!\n");
+	if (vtysh_client_execute(vclient, "enable") < 0)
+		return -1;
+	return vtysh_execute_no_pager("end");
+}
+
 /* Return true if str ends with suffix, else return false */
 static int ends_with(const char *str, const char *suffix)
 {
@@ -3213,9 +3416,12 @@ static void vtysh_autocomplete(vector co
 	snprintf(accmd, sizeof(accmd), "autocomplete %d %s %s", token->type,
 		 token->text, token->varname ? token->varname : "-");
 
+	vty->of_saved = vty->of;
+	vty->of = NULL;
 	for (i = 0; i < array_size(vtysh_client); i++)
-		vtysh_client_run_all(&vtysh_client[i], accmd, 1, NULL,
-				     vtysh_ac_line, comps);
+		vtysh_client_run_all(&vtysh_client[i], accmd, 1, vtysh_ac_line,
+				     comps);
+	vty->of = vty->of_saved;
 }
 
 static const struct cmd_variable_handler vtysh_var_handler[] = {
@@ -3227,8 +3433,8 @@ static const struct cmd_variable_handler
 
 void vtysh_uninit()
 {
-	if (outputfile != stdout)
-		fclose(outputfile);
+	if (vty->of != stdout)
+		fclose(vty->of);
 }
 
 void vtysh_init_vty(void)
@@ -3239,7 +3445,7 @@ void vtysh_init_vty(void)
 	vty->node = VIEW_NODE;
 
 	/* set default output */
-	outputfile = stdout;
+	vty->of = stdout;
 
 	/* Initialize commands. */
 	cmd_init(0);
@@ -3292,6 +3498,10 @@ void vtysh_init_vty(void)
 #if defined(HAVE_RPKI)
 	install_node(&rpki_node, NULL);
 #endif
+#if HAVE_BFDD > 0
+	install_node(&bfd_node, NULL);
+	install_node(&bfd_peer_node, NULL);
+#endif /* HAVE_BFDD */
 
 	struct cmd_node *node;
 	for (unsigned int i = 0; i < vector_active(cmdvec); i++) {
@@ -3386,6 +3596,21 @@ void vtysh_init_vty(void)
 	install_element(RMAP_NODE, &vtysh_quit_rmap_cmd);
 	install_element(PBRMAP_NODE, &vtysh_exit_pbr_map_cmd);
 	install_element(PBRMAP_NODE, &vtysh_quit_pbr_map_cmd);
+#if HAVE_BFDD > 0
+	/* Enter node. */
+	install_element(CONFIG_NODE, &bfd_enter_cmd);
+	install_element(BFD_NODE, &bfd_peer_enter_cmd);
+
+	/* Exit/quit node. */
+	install_element(BFD_NODE, &vtysh_exit_bfdd_cmd);
+	install_element(BFD_NODE, &vtysh_quit_bfdd_cmd);
+	install_element(BFD_PEER_NODE, &vtysh_exit_bfdd_cmd);
+	install_element(BFD_PEER_NODE, &vtysh_quit_bfdd_cmd);
+
+	/* End/exit all. */
+	install_element(BFD_NODE, &vtysh_end_all_cmd);
+	install_element(BFD_PEER_NODE, &vtysh_end_all_cmd);
+#endif /* HAVE_BFDD */
 	install_element(VTY_NODE, &vtysh_exit_line_vty_cmd);
 	install_element(VTY_NODE, &vtysh_quit_line_vty_cmd);
 
@@ -3429,8 +3654,6 @@ void vtysh_init_vty(void)
 	install_element(PBRMAP_NODE, &vtysh_end_all_cmd);
 	install_element(VTY_NODE, &vtysh_end_all_cmd);
 
-	install_element(INTERFACE_NODE, &vtysh_interface_desc_cmd);
-	install_element(INTERFACE_NODE, &vtysh_no_interface_desc_cmd);
 	install_element(INTERFACE_NODE, &vtysh_end_all_cmd);
 	install_element(INTERFACE_NODE, &vtysh_exit_interface_cmd);
 	install_element(LINK_PARAMS_NODE, &exit_link_params_cmd);
@@ -3534,17 +3757,16 @@ void vtysh_init_vty(void)
 	install_element(KEYCHAIN_NODE, &key_chain_cmd);
 	install_element(KEYCHAIN_KEY_NODE, &key_chain_cmd);
 	install_element(CONFIG_NODE, &vtysh_interface_cmd);
-	install_element(CONFIG_NODE, &vtysh_no_interface_cmd);
-	install_element(CONFIG_NODE, &vtysh_no_interface_vrf_cmd);
 	install_element(CONFIG_NODE, &vtysh_pseudowire_cmd);
 	install_element(INTERFACE_NODE, &vtysh_link_params_cmd);
 	install_element(ENABLE_NODE, &vtysh_show_running_config_cmd);
 	install_element(ENABLE_NODE, &vtysh_copy_running_config_cmd);
 
+	install_element(CONFIG_NODE, &vtysh_vrf_cmd);
+	install_element(VRF_NODE, &vtysh_vrf_netns_cmd);
+	install_element(VRF_NODE, &vtysh_no_vrf_netns_cmd);
 	install_element(VRF_NODE, &exit_vrf_config_cmd);
 
-	install_element(CONFIG_NODE, &vtysh_vrf_cmd);
-	install_element(CONFIG_NODE, &vtysh_no_vrf_cmd);
 	install_element(CONFIG_NODE, &vtysh_no_nexthop_group_cmd);
 
 	/* "write terminal" command. */
@@ -3580,6 +3802,7 @@ void vtysh_init_vty(void)
 
 	/* debugging */
 	install_element(VIEW_NODE, &vtysh_show_debugging_cmd);
+	install_element(VIEW_NODE, &vtysh_show_error_code_cmd);
 	install_element(VIEW_NODE, &vtysh_show_debugging_hashtable_cmd);
 	install_element(ENABLE_NODE, &vtysh_debug_all_cmd);
 	install_element(CONFIG_NODE, &vtysh_debug_all_cmd);
@@ -3590,6 +3813,7 @@ void vtysh_init_vty(void)
 	install_element(VIEW_NODE, &vtysh_show_work_queues_cmd);
 	install_element(VIEW_NODE, &vtysh_show_work_queues_daemon_cmd);
 	install_element(VIEW_NODE, &vtysh_show_thread_cmd);
+	install_element(VIEW_NODE, &vtysh_show_poll_cmd);
 
 	/* Logging */
 	install_element(VIEW_NODE, &vtysh_show_logging_cmd);
@@ -3603,8 +3827,6 @@ void vtysh_init_vty(void)
 	install_element(CONFIG_NODE, &no_vtysh_log_monitor_cmd);
 	install_element(CONFIG_NODE, &vtysh_log_syslog_cmd);
 	install_element(CONFIG_NODE, &no_vtysh_log_syslog_cmd);
-	install_element(CONFIG_NODE, &vtysh_log_trap_cmd);
-	install_element(CONFIG_NODE, &no_vtysh_log_trap_cmd);
 	install_element(CONFIG_NODE, &vtysh_log_facility_cmd);
 	install_element(CONFIG_NODE, &no_vtysh_log_facility_cmd);
 	install_element(CONFIG_NODE, &vtysh_log_record_priority_cmd);
diff -urpN frr-frr-5.0.1/vtysh/vtysh.h frr-frr-6.0/vtysh/vtysh.h
--- frr-frr-5.0.1/vtysh/vtysh.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/vtysh.h	2018-10-08 14:32:57.000000000 +0200
@@ -24,32 +24,36 @@
 #include "memory.h"
 DECLARE_MGROUP(MVTYSH)
 
-#define VTYSH_ZEBRA     0x0001
-#define VTYSH_RIPD      0x0002
-#define VTYSH_RIPNGD    0x0004
-#define VTYSH_OSPFD     0x0008
-#define VTYSH_OSPF6D    0x0010
-#define VTYSH_BGPD      0x0020
-#define VTYSH_ISISD     0x0040
-#define VTYSH_PIMD      0x0080
-#define VTYSH_LDPD      0x0100
-#define VTYSH_WATCHFRR  0x0200
-#define VTYSH_NHRPD     0x0400
-#define VTYSH_EIGRPD    0x0800
-#define VTYSH_BABELD    0x1000
-#define VTYSH_SHARPD    0x2000
-#define VTYSH_PBRD      0x4000
+#define VTYSH_ZEBRA     0x00001
+#define VTYSH_RIPD      0x00002
+#define VTYSH_RIPNGD    0x00004
+#define VTYSH_OSPFD     0x00008
+#define VTYSH_OSPF6D    0x00010
+#define VTYSH_BGPD      0x00020
+#define VTYSH_ISISD     0x00040
+#define VTYSH_PIMD      0x00080
+#define VTYSH_LDPD      0x00100
+#define VTYSH_WATCHFRR  0x00200
+#define VTYSH_NHRPD     0x00400
+#define VTYSH_EIGRPD    0x00800
+#define VTYSH_BABELD    0x01000
+#define VTYSH_SHARPD    0x02000
+#define VTYSH_PBRD      0x04000
+#define VTYSH_STATICD   0x08000
+#define VTYSH_BFDD      0x10000
+
+#define VTYSH_WAS_ACTIVE (-2)
 
 /* commands in REALLYALL are crucial to correct vtysh operation */
 #define VTYSH_REALLYALL	  ~0U
 /* watchfrr is not in ALL since library CLI functions should not be
  * run on it (logging & co. should stay in a fixed/frozen config, and
  * things like prefix lists are not even initialised) */
-#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_NHRPD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_SHARPD|VTYSH_PBRD
+#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_NHRPD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_SHARPD|VTYSH_PBRD|VTYSH_STATICD|VTYSH_BFDD
 #define VTYSH_RMAP	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_EIGRPD|VTYSH_SHARPD
 #define VTYSH_INTERFACE	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_ISISD|VTYSH_PIMD|VTYSH_NHRPD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_PBRD
 #define VTYSH_NS          VTYSH_ZEBRA
-#define VTYSH_VRF	  VTYSH_ZEBRA|VTYSH_PIMD
+#define VTYSH_VRF	  VTYSH_ZEBRA|VTYSH_PIMD|VTYSH_STATICD
 
 enum vtysh_write_integrated {
 	WRITE_INTEGRATED_UNSPECIFIED,
@@ -71,6 +75,7 @@ void vtysh_user_init(void);
 
 int vtysh_execute(const char *);
 int vtysh_execute_no_pager(const char *);
+int vtysh_execute_command_questionmark(char *input);
 
 char *vtysh_prompt(void);
 
@@ -87,7 +92,7 @@ int vtysh_write_config_integrated(void);
 
 void vtysh_config_parse_line(void *, const char *);
 
-void vtysh_config_dump(FILE *);
+void vtysh_config_dump(void);
 
 void vtysh_config_init(void);
 
diff -urpN frr-frr-5.0.1/vtysh/vtysh_config.c frr-frr-6.0/vtysh/vtysh_config.c
--- frr-frr-5.0.1/vtysh/vtysh_config.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/vtysh_config.c	2018-10-08 14:32:57.000000000 +0200
@@ -179,6 +179,9 @@ void vtysh_config_parse_line(void *arg,
 					   strlen(" ip multicast boundary"))
 				   == 0) {
 				config_add_line_end(config->line, line);
+			} else if (strncmp(line, " ip igmp query-interval",
+					   strlen(" ip igmp query-interval")) == 0) {
+				config_add_line_end(config->line, line);
 			} else if (config->index == LINK_PARAMS_NODE
 				   && strncmp(line, "  exit-link-params",
 					      strlen("  exit"))
@@ -315,6 +318,8 @@ void vtysh_config_parse_line(void *arg,
 			config = config_get(PROTOCOL_NODE, line);
 		else if (strncmp(line, "mpls", strlen("mpls")) == 0)
 			config = config_get(MPLS_NODE, line);
+		else if (strncmp(line, "bfd", strlen("bfd")) == 0)
+			config = config_get(BFD_NODE, line);
 		else {
 			if (strncmp(line, "log", strlen("log")) == 0
 			    || strncmp(line, "hostname", strlen("hostname"))
@@ -342,7 +347,7 @@ void vtysh_config_parse_line(void *arg,
 	 || (I) == MPLS_NODE)
 
 /* Display configuration to file pointer. */
-void vtysh_config_dump(FILE *fp)
+void vtysh_config_dump(void)
 {
 	struct listnode *node, *nnode;
 	struct listnode *mnode, *mnnode;
@@ -351,12 +356,10 @@ void vtysh_config_dump(FILE *fp)
 	char *line;
 	unsigned int i;
 
-	for (ALL_LIST_ELEMENTS(config_top, node, nnode, line)) {
-		fprintf(fp, "%s\n", line);
-		fflush(fp);
-	}
-	fprintf(fp, "!\n");
-	fflush(fp);
+	for (ALL_LIST_ELEMENTS(config_top, node, nnode, line))
+		vty_out(vty, "%s\n", line);
+
+	vty_out(vty, "!\n");
 
 	for (i = 0; i < vector_active(configvec); i++)
 		if ((master = vector_slot(configvec, i)) != NULL) {
@@ -373,23 +376,16 @@ void vtysh_config_dump(FILE *fp)
 				    && list_isempty(config->line))
 					continue;
 
-				fprintf(fp, "%s\n", config->name);
-				fflush(fp);
+				vty_out(vty, "%s\n", config->name);
 
 				for (ALL_LIST_ELEMENTS(config->line, mnode,
-						       mnnode, line)) {
-					fprintf(fp, "%s\n", line);
-					fflush(fp);
-				}
-				if (!NO_DELIMITER(i)) {
-					fprintf(fp, "!\n");
-					fflush(fp);
-				}
-			}
-			if (NO_DELIMITER(i)) {
-				fprintf(fp, "!\n");
-				fflush(fp);
+						       mnnode, line))
+					vty_out(vty, "%s\n", line);
+				if (!NO_DELIMITER(i))
+					vty_out(vty, "!\n");
 			}
+			if (NO_DELIMITER(i))
+				vty_out(vty, "!\n");
 		}
 
 	for (i = 0; i < vector_active(configvec); i++)
diff -urpN frr-frr-5.0.1/vtysh/vtysh_main.c frr-frr-6.0/vtysh/vtysh_main.c
--- frr-frr-5.0.1/vtysh/vtysh_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/vtysh/vtysh_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -52,8 +52,8 @@ static gid_t elevgid, realgid;
 #define FRR_CONFIG_NAME "frr.conf"
 
 /* Configuration file name and directory. */
-static char vtysh_config[MAXPATHLEN];
-char frr_config[MAXPATHLEN];
+static char vtysh_config[MAXPATHLEN * 3];
+char frr_config[MAXPATHLEN * 3];
 char vtydir[MAXPATHLEN];
 static char history_file[MAXPATHLEN];
 
@@ -356,7 +356,7 @@ int main(int argc, char **argv, char **e
 			break;
 		case OPTION_CONFDIR:
 			ditch_suid = 1; /* option disables SUID */
-			strlcpy(sysconfdir, optarg, sizeof(sysconfdir));
+			snprintf(sysconfdir, sizeof(sysconfdir), "%s/", optarg);
 			break;
 		case 'N':
 			if (strchr(optarg, '/') || strchr(optarg, '.')) {
@@ -471,7 +471,8 @@ int main(int argc, char **argv, char **e
 	}
 
 	if (dryrun && cmd && cmd->line) {
-		vtysh_execute("enable");
+		if (!user_mode)
+			vtysh_execute("enable");
 		while (cmd) {
 			struct cmd_rec *cr;
 			char *cmdnow = cmd->line, *next;
@@ -527,6 +528,14 @@ int main(int argc, char **argv, char **e
 	suid_off();
 
 	if (writeconfig) {
+		if (user_mode) {
+			fprintf(stderr,
+				"writeconfig cannot be used when running as an unprivileged user.\n");
+			if (no_error)
+				exit(0);
+			else
+				exit(1);
+		}
 		vtysh_execute("enable");
 		return vtysh_write_config_integrated();
 	}
@@ -573,7 +582,8 @@ int main(int argc, char **argv, char **e
 	/* If eval mode. */
 	if (cmd && cmd->line) {
 		/* Enter into enable node. */
-		vtysh_execute("enable");
+		if (!user_mode)
+			vtysh_execute("enable");
 
 		while (cmd != NULL) {
 			int ret;
@@ -611,7 +621,17 @@ int main(int argc, char **argv, char **e
 			if (logfile)
 				log_it(cmd->line);
 
-			ret = vtysh_execute_no_pager(cmd->line);
+			/*
+			 * Parsing logic for regular commands will be different
+			 * than for those commands requiring further
+			 * processing, such as cli instructions terminating
+			 * with question-mark character.
+			 */
+			if (!vtysh_execute_command_questionmark(cmd->line))
+				ret = CMD_SUCCESS;
+			else
+				ret = vtysh_execute_no_pager(cmd->line);
+
 			if (!no_error
 			    && !(ret == CMD_SUCCESS || ret == CMD_SUCCESS_DAEMON
 				 || ret == CMD_WARNING))
@@ -653,7 +673,8 @@ int main(int argc, char **argv, char **e
 	vty_hello(vty);
 
 	/* Enter into enable node. */
-	vtysh_execute("enable");
+	if (!user_mode)
+		vtysh_execute("enable");
 
 	/* Preparation for longjmp() in sigtstp(). */
 	sigsetjmp(jmpbuf, 1);
diff -urpN frr-frr-5.0.1/watchfrr/subdir.am frr-frr-6.0/watchfrr/subdir.am
--- frr-frr-5.0.1/watchfrr/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/watchfrr/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -8,10 +8,12 @@ endif
 
 noinst_HEADERS += \
 	watchfrr/watchfrr.h \
+	watchfrr/watchfrr_errors.h \
 	# end
 
 watchfrr_watchfrr_LDADD = lib/libfrr.la @LIBCAP@
 watchfrr_watchfrr_SOURCES = \
 	watchfrr/watchfrr.c \
+	watchfrr/watchfrr_errors.c \
 	watchfrr/watchfrr_vty.c \
 	# end
diff -urpN frr-frr-5.0.1/watchfrr/watchfrr.c frr-frr-6.0/watchfrr/watchfrr.c
--- frr-frr-5.0.1/watchfrr/watchfrr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/watchfrr/watchfrr.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@
 #include "command.h"
 #include "memory_vty.h"
 #include "libfrr.h"
+#include "lib_errors.h"
 
 #include <getopt.h>
 #include <sys/un.h>
@@ -35,6 +36,7 @@
 #include <systemd.h>
 
 #include "watchfrr.h"
+#include "watchfrr_errors.h"
 
 #ifndef MIN
 #define MIN(X,Y) (((X) <= (Y)) ? (X) : (Y))
@@ -247,8 +249,9 @@ static pid_t run_background(char *shell_
 
 	switch (child = fork()) {
 	case -1:
-		zlog_err("fork failed, cannot run command [%s]: %s", shell_cmd,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "fork failed, cannot run command [%s]: %s",
+			     shell_cmd, safe_strerror(errno));
 		return -1;
 	case 0:
 		/* Child process. */
@@ -262,14 +265,16 @@ static pid_t run_background(char *shell_
 			char dashc[] = "-c";
 			char *const argv[4] = {shell, dashc, shell_cmd, NULL};
 			execv("/bin/sh", argv);
-			zlog_err("execv(/bin/sh -c '%s') failed: %s", shell_cmd,
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "execv(/bin/sh -c '%s') failed: %s",
+				     shell_cmd, safe_strerror(errno));
 			_exit(127);
 		}
 	default:
 		/* Parent process: we will reap the child later. */
-		zlog_err("Forked background command [pid %d]: %s", (int)child,
-			 shell_cmd);
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "Forked background command [pid %d]: %s",
+			     (int)child, shell_cmd);
 		return child;
 	}
 }
@@ -309,6 +314,9 @@ static int restart_kill(struct thread *t
 static struct restart_info *find_child(pid_t child)
 {
 	struct daemon *dmn;
+	if (gs.restart.pid == child)
+		return &gs.restart;
+
 	for (dmn = gs.daemons; dmn; dmn = dmn->next) {
 		if (dmn->restart.pid == child)
 			return &dmn->restart;
@@ -326,7 +334,8 @@ static void sigchild(void)
 
 	switch (child = waitpid(-1, &status, WNOHANG)) {
 	case -1:
-		zlog_err("waitpid failed: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL, "waitpid failed: %s",
+			     safe_strerror(errno));
 		return;
 	case 0:
 		zlog_warn("SIGCHLD received, but waitpid did not reap a child");
@@ -349,7 +358,8 @@ static void sigchild(void)
 		 * completed. */
 		gettimeofday(&restart->time, NULL);
 	} else {
-		zlog_err(
+		flog_err_sys(
+			LIB_ERR_SYSTEM_CALL,
 			"waitpid returned status for an unknown child process %d",
 			(int)child);
 		name = "(unknown)";
@@ -370,8 +380,10 @@ static void sigchild(void)
 			zlog_debug("%s %s process %d exited normally", what,
 				   name, (int)child);
 	} else
-		zlog_err("cannot interpret %s %s process %d wait status 0x%x",
-			 what, name, (int)child, status);
+		flog_err_sys(
+			LIB_ERR_SYSTEM_CALL,
+			"cannot interpret %s %s process %d wait status 0x%x",
+			what, name, (int)child, status);
 	phase_check();
 }
 
@@ -481,8 +493,9 @@ static int wakeup_init(struct thread *t_
 	dmn->t_wakeup = NULL;
 	if (try_connect(dmn) < 0) {
 		SET_WAKEUP_DOWN(dmn);
-		zlog_err("%s state -> down : initial connection attempt failed",
-			 dmn->name);
+		flog_err(WATCHFRR_ERR_CONNECTION,
+			  "%s state -> down : initial connection attempt failed",
+			  dmn->name);
 		dmn->state = DAEMON_DOWN;
 	}
 	return 0;
@@ -491,7 +504,8 @@ static int wakeup_init(struct thread *t_
 static void daemon_down(struct daemon *dmn, const char *why)
 {
 	if (IS_UP(dmn) || (dmn->state == DAEMON_INIT))
-		zlog_err("%s state -> down : %s", dmn->name, why);
+		flog_err(WATCHFRR_ERR_CONNECTION,
+			  "%s state -> down : %s", dmn->name, why);
 	else if (gs.loglevel > LOG_DEBUG)
 		zlog_debug("%s still down : %s", dmn->name, why);
 	if (IS_UP(dmn))
@@ -684,21 +698,23 @@ static int try_connect(struct daemon *dm
 	   of creating a socket. */
 	if (access(addr.sun_path, W_OK) < 0) {
 		if (errno != ENOENT)
-			zlog_err("%s: access to socket %s denied: %s",
-				 dmn->name, addr.sun_path,
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "%s: access to socket %s denied: %s",
+				     dmn->name, addr.sun_path,
+				     safe_strerror(errno));
 		return -1;
 	}
 
 	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-		zlog_err("%s(%s): cannot make socket: %s", __func__,
-			 addr.sun_path, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s(%s): cannot make socket: %s",
+			     __func__, addr.sun_path, safe_strerror(errno));
 		return -1;
 	}
 
 	if (set_nonblocking(sock) < 0 || set_cloexec(sock) < 0) {
-		zlog_err("%s(%s): set_nonblocking/cloexec(%d) failed", __func__,
-			 addr.sun_path, sock);
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "%s(%s): set_nonblocking/cloexec(%d) failed",
+			     __func__, addr.sun_path, sock);
 		close(sock);
 		return -1;
 	}
@@ -735,8 +751,9 @@ static int try_connect(struct daemon *dm
 static int phase_hanging(struct thread *t_hanging)
 {
 	gs.t_phase_hanging = NULL;
-	zlog_err("Phase [%s] hanging for %ld seconds, aborting phased restart",
-		 phase_str[gs.phase], PHASE_TIMEOUT);
+	flog_err(WATCHFRR_ERR_CONNECTION,
+		  "Phase [%s] hanging for %ld seconds, aborting phased restart",
+		  phase_str[gs.phase], PHASE_TIMEOUT);
 	gs.phase = PHASE_NONE;
 	return 0;
 }
@@ -850,10 +867,10 @@ static int wakeup_unresponsive(struct th
 
 	dmn->t_wakeup = NULL;
 	if (dmn->state != DAEMON_UNRESPONSIVE)
-		zlog_err(
-			"%s: no longer unresponsive (now %s), "
-			"wakeup should have been cancelled!",
-			dmn->name, state_str[dmn->state]);
+		flog_err(WATCHFRR_ERR_CONNECTION,
+			  "%s: no longer unresponsive (now %s), "
+			  "wakeup should have been cancelled!",
+			  dmn->name, state_str[dmn->state]);
 	else {
 		SET_WAKEUP_UNRESPONSIVE(dmn);
 		try_restart(dmn);
@@ -867,10 +884,10 @@ static int wakeup_no_answer(struct threa
 
 	dmn->t_wakeup = NULL;
 	dmn->state = DAEMON_UNRESPONSIVE;
-	zlog_err(
-		"%s state -> unresponsive : no response yet to ping "
-		"sent %ld seconds ago",
-		dmn->name, gs.timeout);
+	flog_err(WATCHFRR_ERR_CONNECTION,
+		  "%s state -> unresponsive : no response yet to ping "
+		  "sent %ld seconds ago",
+		  dmn->name, gs.timeout);
 	SET_WAKEUP_UNRESPONSIVE(dmn);
 	try_restart(dmn);
 	return 0;
@@ -1149,6 +1166,7 @@ int main(int argc, char **argv)
 	gs.restart.interval = gs.min_restart_interval;
 
 	master = frr_init();
+	watchfrr_error_init();
 
 	zlog_set_level(ZLOG_DEST_MONITOR, ZLOG_DISABLED);
 	if (watchfrr_di.daemon_mode) {
diff -urpN frr-frr-5.0.1/watchfrr/watchfrr_errors.c frr-frr-6.0/watchfrr/watchfrr_errors.c
--- frr-frr-5.0.1/watchfrr/watchfrr_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/watchfrr/watchfrr_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ * Watchfrr-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "watchfrr_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_watchfrr_err[] = {
+	{
+		.code = WATCHFRR_ERR_CONNECTION,
+		.title = "WATCHFRR Connection Error",
+		.description = "WATCHFRR has detected a connectivity issue with one of the FRR daemons",
+		.suggestion = "Ensure that FRR is still running and if not please open an Issue"
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+void watchfrr_error_init(void)
+{
+	log_ref_add(ferr_watchfrr_err);
+}
diff -urpN frr-frr-5.0.1/watchfrr/watchfrr_errors.h frr-frr-6.0/watchfrr/watchfrr_errors.h
--- frr-frr-5.0.1/watchfrr/watchfrr_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/watchfrr/watchfrr_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * Watchfrr-specific error messages.
+ * Copyright (C) 2018 Cumulus Networks, Inc.
+ *               Donald Sharp
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __WATCHFRR_ERRORS_H__
+#define __WATCHFRR_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum watchfrr_log_refs {
+	WATCHFRR_ERR_CONNECTION = WATCHFRR_FERR_START,
+};
+
+extern void watchfrr_error_init(void);
+
+#endif
diff -urpN frr-frr-5.0.1/zebra/GNOME-PRODUCT-ZEBRA-MIB frr-frr-6.0/zebra/GNOME-PRODUCT-ZEBRA-MIB
--- frr-frr-5.0.1/zebra/GNOME-PRODUCT-ZEBRA-MIB	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/GNOME-PRODUCT-ZEBRA-MIB	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-GNOME-PRODUCT-ZEBRA-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-	MODULE-IDENTITY,
-	OBJECT-IDENTITY
-		FROM SNMPv2-SMI
-	gnomeProducts
-		FROM GNOME-SMI;
-
-zebra MODULE-IDENTITY
-	LAST-UPDATED "200004250000Z"
-	ORGANIZATION "GNOME project"
-	CONTACT-INFO
-		"GNU Network Object Model Environment project
-		
-		see http://www.gnome.org for contact persons of a particular
-		area or subproject of GNOME.
-
-		Administrative contact for MIB module:
-
-		Jochen Friedrich
-		Wingertstr. 70/1
-		68809 Neulussheim
-		Germany 
-
-		email: snmp@gnome.org"
-	DESCRIPTION
-		"The product registrations for the various zebra subdeamons.
-		These registrations are guaranteed to be unique and are used
-		for SMUX registration by default (if not overridden manually)."
-	::= { gnomeProducts 2 }
-
-zserv OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"zserv is part of the zebra project which again is a GNU
-		endorsed internet routing program.
-		zserv is the main zebra process which implements routing
-		entries with the kernel and handles routing updates between
-		other routing protocols."
-	::= { zebra 1 }
-
-bgpd OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"bgpd is part of the zebra project which again is a GNU
-		endorsed internet routing program."
-	::= { zebra 2 }
-
-ripd OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"ripd is part of the zebra project which again is a GNU
-		endorsed internet routing program."
-	::= { zebra 3 }
-
-ripngd OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"ripngd is part of the zebra project which again is a GNU
-		endorsed internet routing program."
-	::= { zebra 4 }
-
-ospfd OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"ospfd is part of the zebra project which again is a GNU
-		endorsed internet routing program."
-	::= { zebra 5 }
-
-ospf6d OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"ospf6d is part of the zebra project which again is a GNU
-		endorsed internet routing program."
-	::= { zebra 6 }
-
-END
diff -urpN frr-frr-5.0.1/zebra/GNOME-SMI frr-frr-6.0/zebra/GNOME-SMI
--- frr-frr-5.0.1/zebra/GNOME-SMI	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/GNOME-SMI	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-GNOME-SMI DEFINITIONS ::= BEGIN
-
-IMPORTS
-	MODULE-IDENTITY,
-	OBJECT-IDENTITY,
-	enterprises
-		FROM SNMPv2-SMI;
-
-gnome MODULE-IDENTITY
-	LAST-UPDATED "9809010000Z"
-	ORGANIZATION "GNOME project"
-	CONTACT-INFO
-		"GNU Network Object Model Environment project
-		
-		see http://www.gnome.org for contact persons of a particular
-		area or subproject of GNOME.
-
-		Administrative contact for MIB module:
-
-		Jochen Friedrich
-		Wingertstr. 70/1
-		68809 Neulussheim
-		Germany 
-
-		email: snmp@gnome.org"
-	DESCRIPTION
-		"The Structure of GNOME."
-	::= { enterprises 3317 }	-- assigned by IANA
-
-gnomeProducts OBJECT-IDENTITY
-	STATUS	current
-	DESCRIPTION
-		"gnomeProducts is the root OBJECT IDENTIFIER from
-		which sysObjectID values are assigned."
-	::= { gnome 1 }
-
-gnomeMgmt OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"gnomeMgmt defines the subtree for production GNOME related
-		MIB registrations."
-	::= { gnome 2 }
-
-gnomeTest OBJECT-IDENTITY
-	STATUS  current
-	DESCRIPTION
-		"gnomeTest defines the subtree for testing GNOME related
-		MIB registrations."
-	::= { gnome 3 }
-
--- more to come if necessary.
-
-END
diff -urpN frr-frr-5.0.1/zebra/client_main.c frr-frr-6.0/zebra/client_main.c
--- frr-frr-5.0.1/zebra/client_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/client_main.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-/*
- * GNU Zebra client test main routine.
- * Copyright (C) 1997 Kunihiro Ishiguro
- *
- * This file is part of GNU Zebra.
- *
- * GNU Zebra is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * GNU Zebra is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <zebra.h>
-
-#include "prefix.h"
-#include "stream.h"
-#include "zclient.h"
-#include "thread.h"
-#include "table.h"
-#include "zebra/rib.h"
-#include "zebra/zserv.h"
-
-struct thread *master;
-
-/* Zebra client structure. */
-struct zclient *zclient = NULL;
-
-/* Zebra socket. */
-int sock;
-
-/* IPv4 route add and delete test. */
-void zebra_test_ipv4(int command, int type, char *prefix, char *gateway,
-		     uint8_t distance)
-{
-	struct zapi_ipv4 api;
-	struct prefix_ipv4 p;
-	struct in_addr gate;
-	struct in_addr *gpnt;
-
-	str2prefix_ipv4(prefix, &p);
-	if (!inet_aton(gateway, &gate)) {
-		printf("Gateway specified: %s is illegal\n", gateway);
-		return;
-	}
-
-	gpnt = &gate;
-
-	api.vrf_id = VRF_DEFAULT;
-	api.type = type;
-	api.flags = 0;
-
-	api.message = 0;
-	SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);
-	api.nexthop_num = 1;
-	api.nexthop = &gpnt;
-	api.ifindex_num = 0;
-	if (distance) {
-		SET_FLAG(api.message, ZAPI_MESSAGE_DISTANCE);
-		api.distance = distance;
-	}
-
-
-	switch (command) {
-	case ZEBRA_IPV4_ROUTE_ADD:
-		zapi_ipv4_add(zclient, &p, &api);
-		break;
-	case ZEBRA_IPV4_ROUTE_DELETE:
-		zapi_ipv4_delete(zclient, &p, &api);
-		break;
-	}
-}
-
-/* IPv6 route add and delete test. */
-void zebra_test_v6(int sock)
-{
-	struct prefix_ipv6 p;
-	struct in6_addr nexthop;
-
-	str2prefix_ipv6("3ffe:506::2/128", &p);
-	inet_pton(AF_INET6, "::1", &nexthop);
-
-	/* zebra_ipv6_add (sock, ZEBRA_ROUTE_STATIC, 0, &p, &nexthop, 1); */
-
-	sleep(5);
-	/* zebra_ipv6_delete (sock, ZEBRA_ROUTE_STATIC, 0, &p, &nexthop, 1); */
-}
-
-/* Print out usage and exit. */
-void usage_exit()
-{
-	fprintf(stderr, "Usage: client filename\n");
-	exit(1);
-}
-
-struct zebra_info {
-	char *str;
-	int type;
-} zebra_type[] = {{"static", ZEBRA_ROUTE_STATIC},
-		  {"rip", ZEBRA_ROUTE_RIP},
-		  {"ripng", ZEBRA_ROUTE_RIPNG},
-		  {"ospf", ZEBRA_ROUTE_OSPF},
-		  {"ospf6", ZEBRA_ROUTE_OSPF6},
-		  {"bgp", ZEBRA_ROUTE_BGP},
-		  {"nhrp", ZEBRA_ROUTE_NHRP},
-		  {"pim", ZEBRA_ROUTE_PIM},
-		  {NULL, 0}};
-
-/* Zebra route simulator. */
-void zebra_sim(FILE *fp)
-{
-	char buf[BUFSIZ];
-	char distance_str[BUFSIZ];
-	uint8_t distance;
-
-	while (fgets(buf, sizeof buf, fp)) {
-		int i;
-		int ret;
-		int type;
-		char str[BUFSIZ], command[BUFSIZ], prefix[BUFSIZ],
-			gateway[BUFSIZ];
-
-		distance = 0;
-
-		if (*buf == '#')
-			continue;
-
-		type = ZEBRA_ROUTE_STATIC;
-
-		ret = sscanf(buf, "%s %s %s %s %s\n", command, str, prefix,
-			     gateway, distance_str);
-
-		if (ret == 5) {
-			distance = atoi(distance_str);
-		} else {
-			ret = sscanf(buf, "%s %s %s %s\n", command, str, prefix,
-				     gateway);
-
-			if (ret != 4)
-				continue;
-		}
-
-		i = 0;
-		while (zebra_type[i++].str) {
-			if (strcmp(zebra_type[i].str, str) == 0) {
-				type = zebra_type[i].type;
-				break;
-			}
-		}
-
-		if (strcmp(command, "add") == 0) {
-			zebra_test_ipv4(ZEBRA_IPV4_ROUTE_ADD, type, prefix,
-					gateway, distance);
-			printf("%s", buf);
-			continue;
-		}
-
-		if (strcmp(command, "del") == 0) {
-			zebra_test_ipv4(ZEBRA_IPV4_ROUTE_DELETE, type, prefix,
-					gateway, distance);
-			printf("%s", buf);
-			continue;
-		}
-	}
-}
-
-/* Test zebra client main routine. */
-int main(int argc, char **argv)
-{
-	struct thread_master *master;
-	FILE *fp;
-
-	if (argc == 1)
-		usage_exit();
-
-	master = thread_master_create(NULL);
-	/* Establish connection to zebra. */
-	zclient = zclient_new_notify(master, &zclient_options_default);
-	zclient->enable = 1;
-	zclient_socket_connect(zclient);
-
-	/* Open simulation file. */
-	fp = fopen(argv[1], "r");
-	if (fp == NULL) {
-		fprintf(stderr,
-			"%% Can't open configuration file %s due to '%s'\n",
-			argv[1], safe_strerror(errno));
-		exit(1);
-	}
-
-	/* Do main work. */
-	zebra_sim(fp);
-
-	sleep(100);
-
-	fclose(fp);
-	close(sock);
-
-	return 0;
-}
diff -urpN frr-frr-5.0.1/zebra/connected.c frr-frr-6.0/zebra/connected.c
--- frr-frr-5.0.1/zebra/connected.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/connected.c	2018-10-08 14:32:57.000000000 +0200
@@ -403,10 +403,10 @@ void connected_down(struct interface *if
 	 * head.
 	 */
 	rib_delete(afi, SAFI_UNICAST, ifp->vrf_id, ZEBRA_ROUTE_CONNECT, 0, 0,
-		   &p, NULL, &nh, 0, 0, false, NULL);
+		   &p, NULL, &nh, 0, 0, 0, false);
 
 	rib_delete(afi, SAFI_MULTICAST, ifp->vrf_id, ZEBRA_ROUTE_CONNECT, 0, 0,
-		   &p, NULL, &nh, 0, 0, false, NULL);
+		   &p, NULL, &nh, 0, 0, 0, false);
 
 	if (IS_ZEBRA_DEBUG_RIB_DETAILED) {
 		char buf[PREFIX_STRLEN];
@@ -564,7 +564,7 @@ void connected_delete_ipv6(struct interf
 	if (broad) {
 		memset(&d, 0, sizeof(struct prefix));
 		d.family = AF_INET6;
-		IPV6_ADDR_COPY(&d.u.prefix, broad);
+		IPV6_ADDR_COPY(&d.u.prefix6, broad);
 		d.prefixlen = prefixlen;
 		ifc = connected_check_ptp(ifp, &p, &d);
 	} else
diff -urpN frr-frr-5.0.1/zebra/connected.h frr-frr-6.0/zebra/connected.h
--- frr-frr-5.0.1/zebra/connected.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/connected.h	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,12 @@
 #ifndef _ZEBRA_CONNECTED_H
 #define _ZEBRA_CONNECTED_H
 
+#include <zebra.h>
+#include <stdint.h>
+
+#include "lib/if.h"
+#include "lib/prefix.h"
+
 extern struct connected *connected_check(struct interface *ifp,
 					 union prefixconstptr p);
 extern struct connected *connected_check_ptp(struct interface *ifp,
diff -urpN frr-frr-5.0.1/zebra/debug.h frr-frr-6.0/zebra/debug.h
--- frr-frr-5.0.1/zebra/debug.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/debug.h	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,8 @@
 #ifndef _ZEBRA_DEBUG_H
 #define _ZEBRA_DEBUG_H
 
+#include "lib/vty.h"
+
 /* Debug flags. */
 #define ZEBRA_DEBUG_EVENT   0x01
 
diff -urpN frr-frr-5.0.1/zebra/if_ioctl.c frr-frr-6.0/zebra/if_ioctl.c
--- frr-frr-5.0.1/zebra/if_ioctl.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/if_ioctl.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,9 +33,11 @@
 #include "log.h"
 #include "vrf.h"
 #include "vty.h"
+#include "lib_errors.h"
 
 #include "zebra/interface.h"
 #include "zebra/rib.h"
+#include "zebra/rt.h"
 
 #include <ifaddrs.h>
 
@@ -175,13 +177,15 @@ static int if_getaddrs(void)
 
 	ret = getifaddrs(&ifap);
 	if (ret != 0) {
-		zlog_err("getifaddrs(): %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL, "getifaddrs(): %s",
+			     safe_strerror(errno));
 		return -1;
 	}
 
 	for (ifapfree = ifap; ifap; ifap = ifap->ifa_next) {
 		if (ifap->ifa_addr == NULL) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_INTERFACE,
 				"%s: nonsensical ifaddr with NULL ifa_addr, ifname %s",
 				__func__,
 				(ifap->ifa_name ? ifap->ifa_name : "(null)"));
@@ -190,8 +194,9 @@ static int if_getaddrs(void)
 
 		ifp = if_lookup_by_name(ifap->ifa_name, VRF_DEFAULT);
 		if (ifp == NULL) {
-			zlog_err("if_getaddrs(): Can't lookup interface %s\n",
-				 ifap->ifa_name);
+			flog_err(LIB_ERR_INTERFACE,
+				  "if_getaddrs(): Can't lookup interface %s\n",
+				  ifap->ifa_name);
 			continue;
 		}
 
diff -urpN frr-frr-5.0.1/zebra/if_ioctl_solaris.c frr-frr-6.0/zebra/if_ioctl_solaris.c
--- frr-frr-5.0.1/zebra/if_ioctl_solaris.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/if_ioctl_solaris.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "privs.h"
 #include "vrf.h"
 #include "vty.h"
+#include "lib_errors.h"
 
 #include "zebra/interface.h"
 #include "zebra/ioctl_solaris.h"
@@ -58,29 +59,26 @@ static int interface_list_ioctl(int af)
 	size_t needed, lastneeded = 0;
 	char *buf = NULL;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&zserv_privs) {
+		sock = socket(af, SOCK_DGRAM, 0);
+	}
 
-	sock = socket(af, SOCK_DGRAM, 0);
 	if (sock < 0) {
 		zlog_warn("Can't make %s socket stream: %s",
 			  (af == AF_INET ? "AF_INET" : "AF_INET6"),
 			  safe_strerror(errno));
-
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-
 		return -1;
 	}
 
-calculate_lifc_len: /* must hold privileges to enter here */
-	lifn.lifn_family = af;
-	lifn.lifn_flags = LIFC_NOXMIT; /* we want NOXMIT interfaces too */
-	ret = ioctl(sock, SIOCGLIFNUM, &lifn);
-	save_errno = errno;
+calculate_lifc_len:
+	frr_elevate_privs(&zserv_privs) {
+		lifn.lifn_family = af;
+		lifn.lifn_flags = LIFC_NOXMIT;
+		/* we want NOXMIT interfaces too */
+		ret = ioctl(sock, SIOCGLIFNUM, &lifn);
+		save_errno = errno;
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	}
 
 	if (ret < 0) {
 		zlog_warn("interface_list_ioctl: SIOCGLIFNUM failed %s",
@@ -100,11 +98,7 @@ calculate_lifc_len: /* must hold privile
 	if (needed > lastneeded || needed < lastneeded / 2) {
 		if (buf != NULL)
 			XFREE(MTYPE_TMP, buf);
-		if ((buf = XMALLOC(MTYPE_TMP, needed)) == NULL) {
-			zlog_warn("interface_list_ioctl: malloc failed");
-			close(sock);
-			return -1;
-		}
+		buf = XMALLOC(MTYPE_TMP, needed);
 	}
 	lastneeded = needed;
 
@@ -113,27 +107,18 @@ calculate_lifc_len: /* must hold privile
 	lifconf.lifc_len = needed;
 	lifconf.lifc_buf = buf;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-
-	ret = ioctl(sock, SIOCGLIFCONF, &lifconf);
+	frr_elevate_privs(&zserv_privs) {
+		ret = ioctl(sock, SIOCGLIFCONF, &lifconf);
+	}
 
 	if (ret < 0) {
 		if (errno == EINVAL)
-			goto calculate_lifc_len; /* deliberately hold privileges
-						    */
+			goto calculate_lifc_len;
 
 		zlog_warn("SIOCGLIFCONF: %s", safe_strerror(errno));
-
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-
 		goto end;
 	}
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
-
 	/* Allocate interface. */
 	lifreq = lifconf.lifc_req;
 
diff -urpN frr-frr-5.0.1/zebra/if_netlink.c frr-frr-6.0/zebra/if_netlink.c
--- frr-frr-5.0.1/zebra/if_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/if_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -52,6 +52,7 @@
 #include "vrf.h"
 #include "vrf_int.h"
 #include "mpls.h"
+#include "lib_errors.h"
 
 #include "vty.h"
 #include "zebra/zserv.h"
@@ -79,9 +80,9 @@ static void set_ifindex(struct interface
 	if (((oifp = if_lookup_by_index_per_ns(zns, ifi_index)) != NULL)
 	    && (oifp != ifp)) {
 		if (ifi_index == IFINDEX_INTERNAL)
-			zlog_err(
-				"Netlink is setting interface %s ifindex to reserved "
-				"internal value %u",
+			flog_err(
+				LIB_ERR_INTERFACE,
+				"Netlink is setting interface %s ifindex to reserved internal value %u",
 				ifp->name, ifi_index);
 		else {
 			if (IS_ZEBRA_DEBUG_KERNEL)
@@ -89,9 +90,9 @@ static void set_ifindex(struct interface
 					"interface index %d was renamed from %s to %s",
 					ifi_index, oifp->name, ifp->name);
 			if (if_is_up(oifp))
-				zlog_err(
-					"interface rename detected on up interface: index %d "
-					"was renamed from %s to %s, results are uncertain!",
+				flog_err(
+					LIB_ERR_INTERFACE,
+					"interface rename detected on up interface: index %d was renamed from %s to %s, results are uncertain!",
 					ifi_index, oifp->name, ifp->name);
 			if_delete_update(oifp);
 		}
@@ -309,8 +310,8 @@ static void netlink_vrf_change(struct nl
 		vrf = vrf_get((vrf_id_t)ifi->ifi_index,
 			      name); // It would create vrf
 		if (!vrf) {
-			zlog_err("VRF %s id %u not created", name,
-				 ifi->ifi_index);
+			flog_err(LIB_ERR_INTERFACE, "VRF %s id %u not created",
+				  name, ifi->ifi_index);
 			return;
 		}
 
@@ -331,8 +332,9 @@ static void netlink_vrf_change(struct nl
 
 		/* Enable the created VRF. */
 		if (!vrf_enable(vrf)) {
-			zlog_err("Failed to enable VRF %s id %u", name,
-				 ifi->ifi_index);
+			flog_err(LIB_ERR_INTERFACE,
+				  "Failed to enable VRF %s id %u", name,
+				  ifi->ifi_index);
 			return;
 		}
 
@@ -373,20 +375,20 @@ static int get_iflink_speed(struct inter
 	ifdata.ifr_data = (caddr_t)&ecmd;
 
 	/* use ioctl to get IP address of an interface */
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	sd = vrf_socket(PF_INET, SOCK_DGRAM, IPPROTO_IP, interface->vrf_id,
-			NULL);
-	if (sd < 0) {
-		if (IS_ZEBRA_DEBUG_KERNEL)
-			zlog_debug("Failure to read interface %s speed: %d %s",
-				   ifname, errno, safe_strerror(errno));
-		return 0;
-	}
+	frr_elevate_privs(&zserv_privs) {
+		sd = vrf_socket(PF_INET, SOCK_DGRAM, IPPROTO_IP,
+				interface->vrf_id,
+				NULL);
+		if (sd < 0) {
+			if (IS_ZEBRA_DEBUG_KERNEL)
+				zlog_debug("Failure to read interface %s speed: %d %s",
+					   ifname, errno, safe_strerror(errno));
+			return 0;
+		}
 	/* Get the current link state for the interface */
-	rc = vrf_ioctl(interface->vrf_id, sd, SIOCETHTOOL, (char *)&ifdata);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+		rc = vrf_ioctl(interface->vrf_id, sd, SIOCETHTOOL,
+			       (char *)&ifdata);
+	}
 	if (rc < 0) {
 		if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug(
@@ -557,10 +559,11 @@ static int netlink_bridge_interface(stru
 	return 0;
 }
 
-/* Called from interface_lookup_netlink().  This function is only used
-   during bootstrap. */
-static int netlink_interface(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			     ns_id_t ns_id, int startup)
+/*
+ * Called from interface_lookup_netlink().  This function is only used
+ * during bootstrap.
+ */
+static int netlink_interface(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct ifinfomsg *ifi;
@@ -585,8 +588,13 @@ static int netlink_interface(struct sock
 		return 0;
 
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct ifinfomsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size: %d %zu",
+			 __PRETTY_FUNCTION__,
+			 h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct ifinfomsg)));
 		return -1;
+	}
 
 	/* We are interested in some AF_BRIDGE notifications. */
 	if (ifi->ifi_family == AF_BRIDGE)
@@ -597,7 +605,6 @@ static int netlink_interface(struct sock
 	memset(linkinfo, 0, sizeof linkinfo);
 	netlink_parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 
-#ifdef IFLA_WIRELESS
 	/* check for wireless messages to ignore */
 	if ((tb[IFLA_WIRELESS] != NULL) && (ifi->ifi_change == 0)) {
 		if (IS_ZEBRA_DEBUG_KERNEL)
@@ -605,7 +612,6 @@ static int netlink_interface(struct sock
 				   __func__);
 		return 0;
 	}
-#endif /* IFLA_WIRELESS */
 
 	if (tb[IFLA_IFNAME] == NULL)
 		return -1;
@@ -620,10 +626,8 @@ static int netlink_interface(struct sock
 		if (linkinfo[IFLA_INFO_KIND])
 			kind = RTA_DATA(linkinfo[IFLA_INFO_KIND]);
 
-#if HAVE_DECL_IFLA_INFO_SLAVE_KIND
 		if (linkinfo[IFLA_INFO_SLAVE_KIND])
 			slave_kind = RTA_DATA(linkinfo[IFLA_INFO_SLAVE_KIND]);
-#endif
 
 		netlink_determine_zebra_iftype(kind, &zif_type);
 	}
@@ -874,8 +878,7 @@ int kernel_address_delete_ipv6(struct in
 	return netlink_address(RTM_DELADDR, AF_INET6, ifp, ifc);
 }
 
-int netlink_interface_addr(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			   ns_id_t ns_id, int startup)
+int netlink_interface_addr(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct ifaddrmsg *ifa;
@@ -890,22 +893,32 @@ int netlink_interface_addr(struct sockad
 	zns = zebra_ns_lookup(ns_id);
 	ifa = NLMSG_DATA(h);
 
-	if (ifa->ifa_family != AF_INET && ifa->ifa_family != AF_INET6)
+	if (ifa->ifa_family != AF_INET && ifa->ifa_family != AF_INET6) {
+		zlog_warn(
+			"Invalid address family: %u received from kernel interface addr change: %u",
+			ifa->ifa_family, h->nlmsg_type);
 		return 0;
+	}
 
 	if (h->nlmsg_type != RTM_NEWADDR && h->nlmsg_type != RTM_DELADDR)
 		return 0;
 
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct ifaddrmsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size: %d %zu",
+			 __PRETTY_FUNCTION__,
+			 h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct ifaddrmsg)));
 		return -1;
+	}
 
 	memset(tb, 0, sizeof tb);
 	netlink_parse_rtattr(tb, IFA_MAX, IFA_RTA(ifa), len);
 
 	ifp = if_lookup_by_index_per_ns(zns, ifa->ifa_index);
 	if (ifp == NULL) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_INTERFACE,
 			"netlink_interface_addr can't find interface by index %d",
 			ifa->ifa_index);
 		return -1;
@@ -980,11 +993,17 @@ int netlink_interface_addr(struct sockad
 	if (tb[IFA_LABEL])
 		label = (char *)RTA_DATA(tb[IFA_LABEL]);
 
-	if (ifp && label && strcmp(ifp->name, label) == 0)
+	if (label && strcmp(ifp->name, label) == 0)
 		label = NULL;
 
 	/* Register interface address to the interface. */
 	if (ifa->ifa_family == AF_INET) {
+		if (ifa->ifa_prefixlen > IPV4_MAX_BITLEN) {
+			zlog_err(
+				"Invalid prefix length: %u received from kernel interface addr change: %u",
+				ifa->ifa_prefixlen, h->nlmsg_type);
+			return -1;
+		}
 		if (h->nlmsg_type == RTM_NEWADDR)
 			connected_add_ipv4(ifp, flags, (struct in_addr *)addr,
 					   ifa->ifa_prefixlen,
@@ -995,6 +1014,12 @@ int netlink_interface_addr(struct sockad
 				ifa->ifa_prefixlen, (struct in_addr *)broad);
 	}
 	if (ifa->ifa_family == AF_INET6) {
+		if (ifa->ifa_prefixlen > IPV6_MAX_BITLEN) {
+			zlog_err(
+				"Invalid prefix length: %u received from kernel interface addr change: %u",
+				ifa->ifa_prefixlen, h->nlmsg_type);
+			return -1;
+		}
 		if (h->nlmsg_type == RTM_NEWADDR) {
 			/* Only consider valid addresses; we'll not get a
 			 * notification from
@@ -1078,8 +1103,7 @@ static void if_netlink_check_ifp_instanc
 	 */
 }
 
-int netlink_link_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			ns_id_t ns_id, int startup)
+int netlink_link_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct ifinfomsg *ifi;
@@ -1109,9 +1133,21 @@ int netlink_link_change(struct sockaddr_
 		return 0;
 	}
 
+	if (!(ifi->ifi_family == AF_UNSPEC || ifi->ifi_family == AF_BRIDGE
+	      || ifi->ifi_family == AF_INET6)) {
+		zlog_warn(
+			"Invalid address family: %u received from kernel link change: %u",
+			ifi->ifi_family, h->nlmsg_type);
+		return 0;
+	}
+
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct ifinfomsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size %d %zu",
+			 __PRETTY_FUNCTION__, h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct ifinfomsg)));
 		return -1;
+	}
 
 	/* We are interested in some AF_BRIDGE notifications. */
 	if (ifi->ifi_family == AF_BRIDGE)
@@ -1122,7 +1158,6 @@ int netlink_link_change(struct sockaddr_
 	memset(linkinfo, 0, sizeof linkinfo);
 	netlink_parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 
-#ifdef IFLA_WIRELESS
 	/* check for wireless messages to ignore */
 	if ((tb[IFLA_WIRELESS] != NULL) && (ifi->ifi_change == 0)) {
 		if (IS_ZEBRA_DEBUG_KERNEL)
@@ -1130,7 +1165,6 @@ int netlink_link_change(struct sockaddr_
 				   __func__);
 		return 0;
 	}
-#endif /* IFLA_WIRELESS */
 
 	if (tb[IFLA_IFNAME] == NULL)
 		return -1;
@@ -1142,10 +1176,8 @@ int netlink_link_change(struct sockaddr_
 		if (linkinfo[IFLA_INFO_KIND])
 			kind = RTA_DATA(linkinfo[IFLA_INFO_KIND]);
 
-#if HAVE_DECL_IFLA_INFO_SLAVE_KIND
 		if (linkinfo[IFLA_INFO_SLAVE_KIND])
 			slave_kind = RTA_DATA(linkinfo[IFLA_INFO_SLAVE_KIND]);
-#endif
 
 		netlink_determine_zebra_iftype(kind, &zif_type);
 	}
@@ -1213,6 +1245,12 @@ int netlink_link_change(struct sockaddr_
 			/* Update interface information. */
 			set_ifindex(ifp, ifi->ifi_index, zns);
 			ifp->flags = ifi->ifi_flags & 0x0000fffff;
+			if (!tb[IFLA_MTU]) {
+				zlog_warn(
+					"RTM_NEWLINK for interface %s(%u) without MTU set",
+					name, ifi->ifi_index);
+				return 0;
+			}
 			ifp->mtu6 = ifp->mtu = *(int *)RTA_DATA(tb[IFLA_MTU]);
 			ifp->metric = 0;
 			ifp->ptm_status = ZEBRA_PTM_STATUS_UNKNOWN;
@@ -1262,6 +1300,12 @@ int netlink_link_change(struct sockaddr_
 					bridge_ifindex, ifi->ifi_flags);
 
 			set_ifindex(ifp, ifi->ifi_index, zns);
+			if (!tb[IFLA_MTU]) {
+				zlog_warn(
+					"RTM_NEWLINK for interface %s(%u) without MTU set",
+					name, ifi->ifi_index);
+				return 0;
+			}
 			ifp->mtu6 = ifp->mtu = *(int *)RTA_DATA(tb[IFLA_MTU]);
 			ifp->metric = 0;
 
diff -urpN frr-frr-5.0.1/zebra/if_netlink.h frr-frr-6.0/zebra/if_netlink.h
--- frr-frr-5.0.1/zebra/if_netlink.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/if_netlink.h	2018-10-08 14:32:57.000000000 +0200
@@ -23,10 +23,9 @@
 
 #ifdef HAVE_NETLINK
 
-extern int netlink_interface_addr(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				  ns_id_t ns_id, int startup);
-extern int netlink_link_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			       ns_id_t ns_id, int startup);
+extern int netlink_interface_addr(struct nlmsghdr *h, ns_id_t ns_id,
+				  int startup);
+extern int netlink_link_change(struct nlmsghdr *h, ns_id_t ns_id, int startup);
 extern int interface_lookup_netlink(struct zebra_ns *zns);
 
 #endif /* HAVE_NETLINK */
diff -urpN frr-frr-5.0.1/zebra/interface.c frr-frr-6.0/zebra/interface.c
--- frr-frr-5.0.1/zebra/interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 #include <zebra.h>
 
 #include "if.h"
+#include "lib_errors.h"
 #include "vty.h"
 #include "sockunion.h"
 #include "prefix.h"
@@ -48,7 +49,6 @@
 #include "zebra/rt_netlink.h"
 #include "zebra/interface.h"
 #include "zebra/zebra_vxlan.h"
-#include "zebra/zebra_static.h"
 
 #define ZEBRA_PTM_SUPPORT
 
@@ -577,7 +577,6 @@ void if_add_update(struct interface *ifp
 				"interface %s vrf %u index %d becomes active.",
 				ifp->name, ifp->vrf_id, ifp->ifindex);
 
-		static_ifindex_update(ifp, true);
 	} else {
 		if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("interface %s vrf %u index %d is added.",
@@ -720,7 +719,8 @@ void if_delete_update(struct interface *
 	struct zebra_if *zif;
 
 	if (if_is_up(ifp)) {
-		zlog_err(
+		flog_err(
+			LIB_ERR_INTERFACE,
 			"interface %s vrf %u index %d is still up while being deleted.",
 			ifp->name, ifp->vrf_id, ifp->ifindex);
 		return;
@@ -736,8 +736,6 @@ void if_delete_update(struct interface *
 		zlog_debug("interface %s vrf %u index %d is now inactive.",
 			   ifp->name, ifp->vrf_id, ifp->ifindex);
 
-	static_ifindex_update(ifp, false);
-
 	/* Delete connected routes from the kernel. */
 	if_delete_connected(ifp);
 
@@ -777,8 +775,6 @@ void if_handle_vrf_change(struct interfa
 
 	old_vrf_id = ifp->vrf_id;
 
-	static_ifindex_update(ifp, false);
-
 	/* Uninstall connected routes. */
 	if_uninstall_connected(ifp);
 
@@ -803,8 +799,6 @@ void if_handle_vrf_change(struct interfa
 	if (if_is_operative(ifp))
 		if_install_connected(ifp);
 
-	static_ifindex_update(ifp, true);
-
 	/* Due to connected route change, schedule RIB processing for both old
 	 * and new VRF.
 	 */
@@ -1228,8 +1222,13 @@ static void if_dump_vty(struct vty *vty,
 				br_slave->bridge_ifindex);
 	}
 
-	if (zebra_if->link_ifindex != IFINDEX_INTERNAL)
-		vty_out(vty, "  Link ifindex %u\n", zebra_if->link_ifindex);
+	if (zebra_if->link_ifindex != IFINDEX_INTERNAL) {
+		vty_out(vty, "  Link ifindex %u", zebra_if->link_ifindex);
+		if (zebra_if->link)
+			vty_out(vty, "(%s)\n", zebra_if->link->name);
+		else
+			vty_out(vty, "(Unknown)\n");
+	}
 
 	if (HAS_LINK_PARAMS(ifp)) {
 		int i;
@@ -1406,7 +1405,7 @@ DEFUN (show_interface,
 	interface_update_stats();
 
 	if (argc > 2)
-		VRF_GET_ID(vrf_id, argv[3]->arg);
+		VRF_GET_ID(vrf_id, argv[3]->arg, false);
 
 	/* All interface print. */
 	vrf = vrf_lookup_by_id(vrf_id);
@@ -1455,7 +1454,7 @@ DEFUN (show_interface_name_vrf,
 
 	interface_update_stats();
 
-	VRF_GET_ID(vrf_id, argv[idx_name]->arg);
+	VRF_GET_ID(vrf_id, argv[idx_name]->arg, false);
 
 	/* Specified interface print. */
 	ifp = if_lookup_by_name(argv[idx_ifname]->arg, vrf_id);
@@ -1549,7 +1548,7 @@ DEFUN (show_interface_desc,
 	vrf_id_t vrf_id = VRF_DEFAULT;
 
 	if (argc > 3)
-		VRF_GET_ID(vrf_id, argv[4]->arg);
+		VRF_GET_ID(vrf_id, argv[4]->arg, false);
 
 	if_show_description(vty, vrf_id);
 
diff -urpN frr-frr-5.0.1/zebra/ioctl.c frr-frr-6.0/zebra/ioctl.c
--- frr-frr-5.0.1/zebra/ioctl.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/ioctl.c	2018-10-08 14:32:57.000000000 +0200
@@ -27,6 +27,7 @@
 #include "ioctl.h"
 #include "log.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "vty.h"
 #include "zebra/rib.h"
@@ -54,22 +55,16 @@ int if_ioctl(unsigned long request, cadd
 	int ret;
 	int err = 0;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	sock = socket(AF_INET, SOCK_DGRAM, 0);
-	if (sock < 0) {
-		int save_errno = errno;
-
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_err("Cannot create UDP socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
-	if ((ret = ioctl(sock, request, buffer)) < 0)
-		err = errno;
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+		if (sock < 0) {
+			zlog_err("Cannot create UDP socket: %s",
+				 safe_strerror(errno));
+			exit(1);
+		}
+		if ((ret = ioctl(sock, request, buffer)) < 0)
+			err = errno;
+	}
 	close(sock);
 
 	if (ret < 0) {
@@ -86,23 +81,17 @@ int vrf_if_ioctl(unsigned long request,
 	int ret;
 	int err = 0;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	sock = vrf_socket(AF_INET, SOCK_DGRAM, 0, vrf_id, NULL);
-	if (sock < 0) {
-		int save_errno = errno;
-
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_err("Cannot create UDP socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
+	frr_elevate_privs(&zserv_privs) {
+		sock = vrf_socket(AF_INET, SOCK_DGRAM, 0, vrf_id, NULL);
+		if (sock < 0) {
+			zlog_err("Cannot create UDP socket: %s",
+				 safe_strerror(errno));
+			exit(1);
+		}
+		ret = vrf_ioctl(vrf_id, sock, request, buffer);
+		if (ret < 0)
+			err = errno;
 	}
-	ret = vrf_ioctl(vrf_id, sock, request, buffer);
-	if (ret < 0)
-		err = errno;
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	close(sock);
 
 	if (ret < 0) {
@@ -119,23 +108,17 @@ static int if_ioctl_ipv6(unsigned long r
 	int ret;
 	int err = 0;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	sock = socket(AF_INET6, SOCK_DGRAM, 0);
-	if (sock < 0) {
-		int save_errno = errno;
-
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_err("Cannot create IPv6 datagram socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
-
-	if ((ret = ioctl(sock, request, buffer)) < 0)
-		err = errno;
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		sock = socket(AF_INET6, SOCK_DGRAM, 0);
+		if (sock < 0) {
+			zlog_err("Cannot create IPv6 datagram socket: %s",
+				 safe_strerror(errno));
+			exit(1);
+		}
+
+		if ((ret = ioctl(sock, request, buffer)) < 0)
+			err = errno;
+	}
 	close(sock);
 
 	if (ret < 0) {
@@ -413,8 +396,9 @@ void if_get_flags(struct interface *ifp)
 
 	ret = vrf_if_ioctl(SIOCGIFFLAGS, (caddr_t)&ifreq, ifp->vrf_id);
 	if (ret < 0) {
-		zlog_err("vrf_if_ioctl(SIOCGIFFLAGS) failed: %s",
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "vrf_if_ioctl(SIOCGIFFLAGS) failed: %s",
+			     safe_strerror(errno));
 		return;
 	}
 #ifdef HAVE_BSD_LINK_DETECT /* Detect BSD link-state at start-up */
@@ -431,8 +415,9 @@ void if_get_flags(struct interface *ifp)
 
 		/* Seems not all interfaces implement this ioctl */
 		if (if_ioctl(SIOCGIFMEDIA, (caddr_t)&ifmr) < 0)
-			zlog_err("if_ioctl(SIOCGIFMEDIA) failed: %s",
-				 safe_strerror(errno));
+			flog_err_sys(LIB_ERR_SYSTEM_CALL,
+				     "if_ioctl(SIOCGIFMEDIA) failed: %s",
+				     safe_strerror(errno));
 		else if (ifmr.ifm_status & IFM_AVALID) /* Link state is valid */
 		{
 			if (ifmr.ifm_status & IFM_ACTIVE)
diff -urpN frr-frr-5.0.1/zebra/ioctl_solaris.c frr-frr-6.0/zebra/ioctl_solaris.c
--- frr-frr-5.0.1/zebra/ioctl_solaris.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/ioctl_solaris.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "privs.h"
 #include "vty.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "zebra/rib.h"
 #include "zebra/rt.h"
@@ -57,24 +58,19 @@ int if_ioctl(unsigned long request, cadd
 	int ret;
 	int err;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&zserv_privs) {
 
-	sock = socket(AF_INET, SOCK_DGRAM, 0);
-	if (sock < 0) {
-		int save_errno = errno;
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_err("Cannot create UDP socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
+		sock = socket(AF_INET, SOCK_DGRAM, 0);
+		if (sock < 0) {
+			zlog_err("Cannot create UDP socket: %s",
+				 safe_strerror(errno));
+			exit(1);
+		}
 
-	if ((ret = ioctl(sock, request, buffer)) < 0)
-		err = errno;
+		if ((ret = ioctl(sock, request, buffer)) < 0)
+			err = errno;
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	}
 
 	close(sock);
 
@@ -92,24 +88,19 @@ int if_ioctl_ipv6(unsigned long request,
 	int ret;
 	int err;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&zserv_privs) {
 
-	sock = socket(AF_INET6, SOCK_DGRAM, 0);
-	if (sock < 0) {
-		int save_errno = errno;
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_err("Cannot create IPv6 datagram socket: %s",
-			 safe_strerror(save_errno));
-		exit(1);
-	}
+		sock = socket(AF_INET6, SOCK_DGRAM, 0);
+		if (sock < 0) {
+			zlog_err("Cannot create IPv6 datagram socket: %s",
+				 safe_strerror(errno));
+			exit(1);
+		}
 
-	if ((ret = ioctl(sock, request, buffer)) < 0)
-		err = errno;
+		if ((ret = ioctl(sock, request, buffer)) < 0)
+			err = errno;
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	}
 
 	close(sock);
 
diff -urpN frr-frr-5.0.1/zebra/ipforward_proc.c frr-frr-6.0/zebra/ipforward_proc.c
--- frr-frr-5.0.1/zebra/ipforward_proc.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/ipforward_proc.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 
 #include "log.h"
 #include "privs.h"
+#include "lib_errors.h"
 
 #include "zebra/ipforward.h"
 
@@ -76,24 +77,19 @@ int ipforward_on(void)
 {
 	FILE *fp;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges, %s", safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
 
-	fp = fopen(proc_ipv4_forwarding, "w");
+		fp = fopen(proc_ipv4_forwarding, "w");
 
-	if (fp == NULL) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges, %s",
-				 safe_strerror(errno));
-		return -1;
-	}
+		if (fp == NULL) {
+			return -1;
+		}
 
-	fprintf(fp, "1\n");
+		fprintf(fp, "1\n");
 
-	fclose(fp);
+		fclose(fp);
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges, %s", safe_strerror(errno));
+	}
 
 	return ipforward();
 }
@@ -102,24 +98,19 @@ int ipforward_off(void)
 {
 	FILE *fp;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges, %s", safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
 
-	fp = fopen(proc_ipv4_forwarding, "w");
+		fp = fopen(proc_ipv4_forwarding, "w");
 
-	if (fp == NULL) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges, %s",
-				 safe_strerror(errno));
-		return -1;
-	}
+		if (fp == NULL) {
+			return -1;
+		}
 
-	fprintf(fp, "0\n");
+		fprintf(fp, "0\n");
 
-	fclose(fp);
+		fclose(fp);
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges, %s", safe_strerror(errno));
+	}
 
 	return ipforward();
 }
@@ -153,24 +144,19 @@ int ipforward_ipv6_on(void)
 {
 	FILE *fp;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges, %s", safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
 
-	fp = fopen(proc_ipv6_forwarding, "w");
+		fp = fopen(proc_ipv6_forwarding, "w");
 
-	if (fp == NULL) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges, %s",
-				 safe_strerror(errno));
-		return -1;
-	}
+		if (fp == NULL) {
+			return -1;
+		}
 
-	fprintf(fp, "1\n");
+		fprintf(fp, "1\n");
 
-	fclose(fp);
+		fclose(fp);
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges, %s", safe_strerror(errno));
+	}
 
 	return ipforward_ipv6();
 }
@@ -180,24 +166,19 @@ int ipforward_ipv6_off(void)
 {
 	FILE *fp;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges, %s", safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
 
-	fp = fopen(proc_ipv6_forwarding, "w");
+		fp = fopen(proc_ipv6_forwarding, "w");
 
-	if (fp == NULL) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges, %s",
-				 safe_strerror(errno));
-		return -1;
-	}
+		if (fp == NULL) {
+			return -1;
+		}
 
-	fprintf(fp, "0\n");
+		fprintf(fp, "0\n");
 
-	fclose(fp);
+		fclose(fp);
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges, %s", safe_strerror(errno));
+	}
 
 	return ipforward_ipv6();
 }
diff -urpN frr-frr-5.0.1/zebra/ipforward_solaris.c frr-frr-6.0/zebra/ipforward_solaris.c
--- frr-frr-5.0.1/zebra/ipforward_solaris.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/ipforward_solaris.c	2018-10-08 14:32:57.000000000 +0200
@@ -25,6 +25,7 @@
 
 #include "log.h"
 #include "prefix.h"
+#include "lib_errors.h"
 
 #include "privs.h"
 #include "zebra/ipforward.h"
@@ -69,10 +70,10 @@ static int solaris_nd(const int cmd, con
 	else if (cmd == ND_GET)
 		snprintf(nd_buf, ND_BUFFER_SIZE, "%s", parameter);
 	else {
-		zlog_err(
-			"internal error - inappropriate command given to "
-			"solaris_nd()%s:%d",
-			__FILE__, __LINE__);
+		flog_err_sys(LIB_ERR_SYSTEM_CALL,
+			     "internal error - inappropriate command given to "
+			     "solaris_nd()%s:%d",
+			     __FILE__, __LINE__);
 		return -1;
 	}
 
@@ -81,27 +82,21 @@ static int solaris_nd(const int cmd, con
 	strioctl.ic_len = ND_BUFFER_SIZE;
 	strioctl.ic_dp = nd_buf;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("solaris_nd: Can't raise privileges");
-	if ((fd = open(device, O_RDWR)) < 0) {
-		zlog_warn("failed to open device %s - %s", device,
-			  safe_strerror(errno));
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("solaris_nd: Can't lower privileges");
-		return -1;
-	}
-	if (ioctl(fd, I_STR, &strioctl) < 0) {
-		int save_errno = errno;
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("solaris_nd: Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		if ((fd = open(device, O_RDWR)) < 0) {
+			zlog_warn("failed to open device %s - %s", device,
+				  safe_strerror(errno));
+			return -1;
+		}
+		if (ioctl(fd, I_STR, &strioctl) < 0) {
+			close(fd);
+			zlog_warn("ioctl I_STR failed on device %s - %s",
+				  device,
+				  safe_strerror(errno));
+			return -1;
+		}
 		close(fd);
-		zlog_warn("ioctl I_STR failed on device %s - %s", device,
-			  safe_strerror(save_errno));
-		return -1;
 	}
-	close(fd);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("solaris_nd: Can't lower privileges");
 
 	if (cmd == ND_GET) {
 		errno = 0;
diff -urpN frr-frr-5.0.1/zebra/ipforward_sysctl.c frr-frr-6.0/zebra/ipforward_sysctl.c
--- frr-frr-5.0.1/zebra/ipforward_sysctl.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/ipforward_sysctl.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,6 +26,7 @@
 #include "zebra/ipforward.h"
 
 #include "log.h"
+#include "lib_errors.h"
 
 #define MIB_SIZ 4
 
@@ -53,16 +54,12 @@ int ipforward_on(void)
 	int ipforwarding = 1;
 
 	len = sizeof ipforwarding;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	if (sysctl(mib, MIB_SIZ, NULL, NULL, &ipforwarding, len) < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_warn("Can't set ipforwarding on");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		if (sysctl(mib, MIB_SIZ, NULL, NULL, &ipforwarding, len) < 0) {
+			zlog_warn("Can't set ipforwarding on");
+			return -1;
+		}
 	}
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	return ipforwarding;
 }
 
@@ -72,16 +69,12 @@ int ipforward_off(void)
 	int ipforwarding = 0;
 
 	len = sizeof ipforwarding;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	if (sysctl(mib, MIB_SIZ, NULL, NULL, &ipforwarding, len) < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_warn("Can't set ipforwarding on");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		if (sysctl(mib, MIB_SIZ, NULL, NULL, &ipforwarding, len) < 0) {
+			zlog_warn("Can't set ipforwarding on");
+			return -1;
+		}
 	}
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	return ipforwarding;
 }
 
@@ -100,16 +93,12 @@ int ipforward_ipv6(void)
 	int ip6forwarding = 0;
 
 	len = sizeof ip6forwarding;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	if (sysctl(mib_ipv6, MIB_SIZ, &ip6forwarding, &len, 0, 0) < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_warn("can't get ip6forwarding value");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		if (sysctl(mib_ipv6, MIB_SIZ, &ip6forwarding, &len, 0, 0) < 0) {
+			zlog_warn("can't get ip6forwarding value");
+			return -1;
+		}
 	}
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	return ip6forwarding;
 }
 
@@ -119,16 +108,13 @@ int ipforward_ipv6_on(void)
 	int ip6forwarding = 1;
 
 	len = sizeof ip6forwarding;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	if (sysctl(mib_ipv6, MIB_SIZ, NULL, NULL, &ip6forwarding, len) < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_warn("can't get ip6forwarding value");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		if (sysctl(mib_ipv6, MIB_SIZ, NULL, NULL, &ip6forwarding, len)
+		    < 0) {
+			zlog_warn("can't get ip6forwarding value");
+			return -1;
+		}
 	}
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	return ip6forwarding;
 }
 
@@ -138,16 +124,13 @@ int ipforward_ipv6_off(void)
 	int ip6forwarding = 0;
 
 	len = sizeof ip6forwarding;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	if (sysctl(mib_ipv6, MIB_SIZ, NULL, NULL, &ip6forwarding, len) < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("Can't lower privileges");
-		zlog_warn("can't get ip6forwarding value");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		if (sysctl(mib_ipv6, MIB_SIZ, NULL, NULL, &ip6forwarding, len)
+		    < 0) {
+			zlog_warn("can't get ip6forwarding value");
+			return -1;
+		}
 	}
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 	return ip6forwarding;
 }
 
diff -urpN frr-frr-5.0.1/zebra/irdp_interface.c frr-frr-6.0/zebra/irdp_interface.c
--- frr-frr-5.0.1/zebra/irdp_interface.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/irdp_interface.c	2018-10-08 14:32:57.000000000 +0200
@@ -1,7 +1,13 @@
 /*
  *
- * Copyright (C) 2000  Robert Olsson.
- * Swedish University of Agricultural Sciences
+ * Copyright (C) 1997, 2000
+ * Portions:
+ *   Swedish University of Agricultural Sciences
+ *   Robert Olsson
+ *   Kunihiro Ishiguro
+ *
+ * Thanks to Jens Laas at Swedish University of Agricultural Sciences
+ * for reviewing and tests.
  *
  * This file is part of GNU Zebra.
  *
@@ -20,19 +26,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/*
- * This work includes work with the following copywrite:
- *
- * Copyright (C) 1997, 2000 Kunihiro Ishiguro
- *
- */
-
-/*
- * Thanks to Jens Ls at Swedish University of Agricultural Sciences
- * for reviewing and tests.
- */
-
-
 #include <zebra.h>
 
 #include "if.h"
diff -urpN frr-frr-5.0.1/zebra/irdp_main.c frr-frr-6.0/zebra/irdp_main.c
--- frr-frr-5.0.1/zebra/irdp_main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/irdp_main.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,7 +28,7 @@
  */
 
 /*
- * Thanks to Jens Ls at Swedish University of Agricultural Sciences
+ * Thanks to Jens Laas at Swedish University of Agricultural Sciences
  * for reviewing and tests.
  */
 
@@ -51,6 +51,7 @@
 #include "thread.h"
 #include "privs.h"
 #include "libfrr.h"
+#include "lib_errors.h"
 #include "version.h"
 #include "zebra/interface.h"
 #include "zebra/rtadv.h"
@@ -80,16 +81,12 @@ int irdp_sock_init(void)
 	int save_errno;
 	int sock;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("irdp_sock_init: could not raise privs, %s",
-			 safe_strerror(errno));
-
-	sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
-	save_errno = errno;
-
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("irdp_sock_init: could not lower privs, %s",
-			 safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
+
+		sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
+		save_errno = errno;
+
+	}
 
 	if (sock < 0) {
 		zlog_warn("IRDP: can't create irdp socket %s",
diff -urpN frr-frr-5.0.1/zebra/irdp_packet.c frr-frr-6.0/zebra/irdp_packet.c
--- frr-frr-5.0.1/zebra/irdp_packet.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/irdp_packet.c	2018-10-08 14:32:57.000000000 +0200
@@ -28,39 +28,39 @@
  */
 
 /*
- * Thanks to Jens Ls at Swedish University of Agricultural Sciences
+ * Thanks to Jens Laas at Swedish University of Agricultural Sciences
  * for reviewing and tests.
  */
 
 
 #include <zebra.h>
+#include <netinet/ip_icmp.h>
 
-
-#include "if.h"
-#include "vty.h"
-#include "sockunion.h"
-#include "prefix.h"
+#include "checksum.h"
 #include "command.h"
-#include "memory.h"
-#include "zebra_memory.h"
-#include "stream.h"
-#include "ioctl.h"
 #include "connected.h"
+#include "if.h"
+#include "ioctl.h"
 #include "log.h"
-#include "zclient.h"
+#include "log.h"
+#include "memory.h"
+#include "prefix.h"
+#include "sockopt.h"
+#include "sockunion.h"
+#include "sockunion.h"
+#include "stream.h"
 #include "thread.h"
+#include "vty.h"
+#include "zclient.h"
+
+#include "zebra_memory.h"
 #include "zebra/interface.h"
 #include "zebra/rtadv.h"
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
 #include "zebra/redistribute.h"
 #include "zebra/irdp.h"
-#include <netinet/ip_icmp.h>
-#include "if.h"
-#include "checksum.h"
-#include "sockunion.h"
-#include "log.h"
-#include "sockopt.h"
+#include "zebra/zebra_errors.h"
 
 
 /* GLOBAL VARS */
@@ -95,13 +95,15 @@ static void parse_irdp_packet(char *p, i
 	src = ip->ip_src;
 
 	if (len != iplen) {
-		zlog_err("IRDP: RX length doesnt match IP length");
+		flog_err(ZEBRA_ERR_IRDP_LEN_MISMATCH,
+			  "IRDP: RX length doesnt match IP length");
 		return;
 	}
 
 	if (iplen < ICMP_MINLEN) {
-		zlog_err("IRDP: RX ICMP packet too short from %s\n",
-			 inet_ntoa(src));
+		flog_err(ZEBRA_ERR_IRDP_LEN_MISMATCH,
+			  "IRDP: RX ICMP packet too short from %s\n",
+			  inet_ntoa(src));
 		return;
 	}
 
@@ -110,8 +112,9 @@ static void parse_irdp_packet(char *p, i
 	 +
 	 len of IP-header) 14+20 */
 	if (iplen > IRDP_RX_BUF - 34) {
-		zlog_err("IRDP: RX ICMP packet too long from %s\n",
-			 inet_ntoa(src));
+		flog_err(ZEBRA_ERR_IRDP_LEN_MISMATCH,
+			  "IRDP: RX ICMP packet too long from %s\n",
+			  inet_ntoa(src));
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/zebra/kernel_netlink.c frr-frr-6.0/zebra/kernel_netlink.c
--- frr-frr-5.0.1/zebra/kernel_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/kernel_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -20,6 +20,11 @@
 
 #include <zebra.h>
 
+#if defined(HANDLE_NETLINK_FUZZING)
+#include <stdio.h>
+#include <string.h>
+#endif /* HANDLE_NETLINK_FUZZING */
+
 #ifdef HAVE_NETLINK
 
 #include "linklist.h"
@@ -36,6 +41,7 @@
 #include "nexthop.h"
 #include "vrf.h"
 #include "mpls.h"
+#include "lib_errors.h"
 
 #include "zebra/zserv.h"
 #include "zebra/zebra_ns.h"
@@ -46,6 +52,7 @@
 #include "zebra/rt_netlink.h"
 #include "zebra/if_netlink.h"
 #include "zebra/rule_netlink.h"
+#include "zebra/zebra_errors.h"
 
 #ifndef SO_RCVBUFFORCE
 #define SO_RCVBUFFORCE  (33)
@@ -129,11 +136,21 @@ extern uint32_t nl_rcvbufsize;
 
 extern struct zebra_privs_t zserv_privs;
 
-int netlink_talk_filter(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			ns_id_t ns_id, int startup)
+int netlink_talk_filter(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
-	zlog_warn("netlink_talk: ignoring message type 0x%04x NS %u",
-		  h->nlmsg_type, ns_id);
+	/*
+	 * This is an error condition that must be handled during
+	 * development.
+	 *
+	 * The netlink_talk_filter function is used for communication
+	 * down the netlink_cmd pipe and we are expecting
+	 * an ack being received.  So if we get here
+	 * then we did not receive the ack and instead
+	 * received some other message in an unexpected
+	 * way.
+	 */
+	zlog_debug("%s: ignoring message type 0x%04x(%s) NS %u", __func__,
+		   h->nlmsg_type, nl_msg_type_to_str(h->nlmsg_type), ns_id);
 	return 0;
 }
 
@@ -146,31 +163,33 @@ static int netlink_recvbuf(struct nlsock
 
 	ret = getsockopt(nl->sock, SOL_SOCKET, SO_RCVBUF, &oldsize, &oldlen);
 	if (ret < 0) {
-		zlog_err("Can't get %s receive buffer size: %s", nl->name,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "Can't get %s receive buffer size: %s", nl->name,
+			     safe_strerror(errno));
 		return -1;
 	}
 
 	/* Try force option (linux >= 2.6.14) and fall back to normal set */
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("routing_socket: Can't raise privileges");
-	ret = setsockopt(nl->sock, SOL_SOCKET, SO_RCVBUFFORCE, &nl_rcvbufsize,
-			 sizeof(nl_rcvbufsize));
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("routing_socket: Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ret = setsockopt(nl->sock, SOL_SOCKET, SO_RCVBUFFORCE,
+				 &nl_rcvbufsize,
+				 sizeof(nl_rcvbufsize));
+	}
 	if (ret < 0)
 		ret = setsockopt(nl->sock, SOL_SOCKET, SO_RCVBUF,
 				 &nl_rcvbufsize, sizeof(nl_rcvbufsize));
 	if (ret < 0) {
-		zlog_err("Can't set %s receive buffer size: %s", nl->name,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "Can't set %s receive buffer size: %s", nl->name,
+			     safe_strerror(errno));
 		return -1;
 	}
 
 	ret = getsockopt(nl->sock, SOL_SOCKET, SO_RCVBUF, &newsize, &newlen);
 	if (ret < 0) {
-		zlog_err("Can't get %s receive buffer size: %s", nl->name,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "Can't get %s receive buffer size: %s", nl->name,
+			     safe_strerror(errno));
 		return -1;
 	}
 
@@ -187,33 +206,26 @@ static int netlink_socket(struct nlsock
 	struct sockaddr_nl snl;
 	int sock;
 	int namelen;
-	int save_errno;
 
-	if (zserv_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("Can't raise privileges");
-		return -1;
-	}
-
-	sock = ns_socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE, ns_id);
-	if (sock < 0) {
-		zlog_err("Can't open %s socket: %s", nl->name,
-			 safe_strerror(errno));
-		return -1;
-	}
+	frr_elevate_privs(&zserv_privs) {
+		sock = ns_socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE, ns_id);
+		if (sock < 0) {
+			zlog_err("Can't open %s socket: %s", nl->name,
+				 safe_strerror(errno));
+			return -1;
+		}
 
-	memset(&snl, 0, sizeof snl);
-	snl.nl_family = AF_NETLINK;
-	snl.nl_groups = groups;
+		memset(&snl, 0, sizeof snl);
+		snl.nl_family = AF_NETLINK;
+		snl.nl_groups = groups;
 
-	/* Bind the socket to the netlink structure for anything. */
-	ret = bind(sock, (struct sockaddr *)&snl, sizeof snl);
-	save_errno = errno;
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+		/* Bind the socket to the netlink structure for anything. */
+		ret = bind(sock, (struct sockaddr *)&snl, sizeof snl);
+	}
 
 	if (ret < 0) {
 		zlog_err("Can't bind %s socket to group 0x%x: %s", nl->name,
-			 snl.nl_groups, safe_strerror(save_errno));
+			 snl.nl_groups, safe_strerror(errno));
 		close(sock);
 		return -1;
 	}
@@ -222,8 +234,8 @@ static int netlink_socket(struct nlsock
 	namelen = sizeof snl;
 	ret = getsockname(sock, (struct sockaddr *)&snl, (socklen_t *)&namelen);
 	if (ret < 0 || namelen != sizeof snl) {
-		zlog_err("Can't get %s socket name: %s", nl->name,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "Can't get %s socket name: %s",
+			     nl->name, safe_strerror(errno));
 		close(sock);
 		return -1;
 	}
@@ -233,46 +245,131 @@ static int netlink_socket(struct nlsock
 	return ret;
 }
 
-static int netlink_information_fetch(struct sockaddr_nl *snl,
-				     struct nlmsghdr *h, ns_id_t ns_id,
+static int netlink_information_fetch(struct nlmsghdr *h, ns_id_t ns_id,
 				     int startup)
 {
-	/* JF: Ignore messages that aren't from the kernel */
-	if (snl->nl_pid != 0) {
-		zlog_err("Ignoring message from pid %u", snl->nl_pid);
-		return 0;
-	}
-
+	/*
+	 * When we handle new message types here
+	 * because we are starting to install them
+	 * then lets check the netlink_install_filter
+	 * and see if we should add the corresponding
+	 * allow through entry there.
+	 * Probably not needed to do but please
+	 * think about it.
+	 */
 	switch (h->nlmsg_type) {
 	case RTM_NEWROUTE:
-		return netlink_route_change(snl, h, ns_id, startup);
+		return netlink_route_change(h, ns_id, startup);
 	case RTM_DELROUTE:
-		return netlink_route_change(snl, h, ns_id, startup);
+		return netlink_route_change(h, ns_id, startup);
 	case RTM_NEWLINK:
-		return netlink_link_change(snl, h, ns_id, startup);
+		return netlink_link_change(h, ns_id, startup);
 	case RTM_DELLINK:
-		return netlink_link_change(snl, h, ns_id, startup);
+		return netlink_link_change(h, ns_id, startup);
 	case RTM_NEWADDR:
-		return netlink_interface_addr(snl, h, ns_id, startup);
+		return netlink_interface_addr(h, ns_id, startup);
 	case RTM_DELADDR:
-		return netlink_interface_addr(snl, h, ns_id, startup);
+		return netlink_interface_addr(h, ns_id, startup);
 	case RTM_NEWNEIGH:
-		return netlink_neigh_change(snl, h, ns_id);
+		return netlink_neigh_change(h, ns_id);
 	case RTM_DELNEIGH:
-		return netlink_neigh_change(snl, h, ns_id);
+		return netlink_neigh_change(h, ns_id);
 	case RTM_NEWRULE:
-		return netlink_rule_change(snl, h, ns_id, startup);
+		return netlink_rule_change(h, ns_id, startup);
 	case RTM_DELRULE:
-		return netlink_rule_change(snl, h, ns_id, startup);
+		return netlink_rule_change(h, ns_id, startup);
 	default:
-		if (IS_ZEBRA_DEBUG_KERNEL)
-			zlog_debug("Unknown netlink nlmsg_type %d vrf %u\n",
-				   h->nlmsg_type, ns_id);
+		/*
+		 * If we have received this message then
+		 * we have made a mistake during development
+		 * and we need to write some code to handle
+		 * this message type or not ask for
+		 * it to be sent up to us
+		 */
+		flog_err(ZEBRA_ERR_UNKNOWN_NLMSG,
+			  "Unknown netlink nlmsg_type %s(%d) vrf %u\n",
+			  nl_msg_type_to_str(h->nlmsg_type), h->nlmsg_type,
+			  ns_id);
 		break;
 	}
 	return 0;
 }
 
+#if defined(HANDLE_NETLINK_FUZZING)
+/* Using globals here to avoid adding function parameters */
+
+/* Keep distinct filenames for netlink fuzzy collection */
+static unsigned int netlink_file_counter = 1;
+
+/* File name to read fuzzed netlink from */
+static char netlink_fuzz_file[MAXPATHLEN] = "";
+
+/* Flag for whether to read from file or not */
+bool netlink_read;
+
+/**
+ * netlink_read_init() - Starts the message parser
+ * @fname:      Filename to read.
+ */
+void netlink_read_init(const char *fname)
+{
+	snprintf(netlink_fuzz_file, MAXPATHLEN, "%s", fname);
+	/* Creating this fake socket for testing purposes */
+	struct zebra_ns *zns = zebra_ns_lookup(NS_DEFAULT);
+
+	netlink_parse_info(netlink_information_fetch, &zns->netlink, zns, 1, 0);
+}
+
+/**
+ * netlink_write_incoming() - Writes all data received from netlink to a file
+ * @buf:        Data from netlink.
+ * @size:       Size of data.
+ * @counter:    Counter for keeping filenames distinct.
+ */
+static void netlink_write_incoming(const char *buf, const unsigned int size,
+				   unsigned int counter)
+{
+	char fname[MAXPATHLEN];
+	FILE *f;
+
+	snprintf(fname, MAXPATHLEN, "%s/%s_%u", DAEMON_VTY_DIR, "netlink",
+		 counter);
+	frr_elevate_privs(&zserv_privs) {
+		f = fopen(fname, "w");
+	}
+	if (f) {
+		fwrite(buf, 1, size, f);
+		fclose(f);
+	}
+}
+
+/**
+ * netlink_read_file() - Reads netlink data from file
+ * @buf:        Netlink buffer being overwritten.
+ * @fname:      File name to read from.
+ *
+ * Return:      Size of file.
+ */
+static long netlink_read_file(char *buf, const char *fname)
+{
+	FILE *f;
+	long file_bytes = -1;
+
+	frr_elevate_privs(&zserv_privs) {
+		f = fopen(fname, "r");
+	}
+	if (f) {
+		fseek(f, 0, SEEK_END);
+		file_bytes = ftell(f);
+		rewind(f);
+		fread(buf, NL_RCV_PKT_BUF_SIZE, 1, f);
+		fclose(f);
+	}
+	return file_bytes;
+}
+
+#endif /* HANDLE_NETLINK_FUZZING */
+
 static int kernel_read(struct thread *thread)
 {
 	struct zebra_ns *zns = (struct zebra_ns *)THREAD_ARG(thread);
@@ -284,31 +381,69 @@ static int kernel_read(struct thread *th
 	return 0;
 }
 
-/* Filter out messages from self that occur on listener socket,
+/*
+ * Filter out messages from self that occur on listener socket,
  * caused by our actions on the command socket
+ *
+ * When we add new Netlink message types we probably
+ * do not need to add them here as that we are filtering
+ * on the routes we actually care to receive( which is rarer
+ * then the normal course of operations).  We are intentionally
+ * allowing some messages from ourselves through
+ * ( I'm looking at you Interface based netlink messages )
+ * so that we only had to write one way to handle incoming
+ * address add/delete changes.
  */
 static void netlink_install_filter(int sock, __u32 pid)
 {
+	/*
+	 * BPF_JUMP instructions and where you jump to are based upon
+	 * 0 as being the next statement.  So count from 0.  Writing
+	 * this down because every time I look at this I have to
+	 * re-remember it.
+	 */
 	struct sock_filter filter[] = {
-		/* 0: ldh [4]	          */
-		BPF_STMT(BPF_LD | BPF_ABS | BPF_H,
-			 offsetof(struct nlmsghdr, nlmsg_type)),
-		/* 1: jeq 0x18 jt 5 jf next  */
-		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_NEWROUTE), 3, 0),
-		/* 2: jeq 0x19 jt 5 jf next  */
-		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_DELROUTE), 2, 0),
-		/* 3: jeq 0x19 jt 5 jf next  */
-		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_NEWNEIGH), 1, 0),
-		/* 4: jeq 0x19 jt 5 jf 8  */
-		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_DELNEIGH), 0, 3),
-		/* 5: ldw [12]		  */
+		/*
+		 * Logic:
+		 *   if (nlmsg_pid == pid) {
+		 *       if (the incoming nlmsg_type ==
+		 *           RTM_NEWADDR | RTM_DELADDR)
+		 *           keep this message
+		 *       else
+		 *           skip this message
+		 *   } else
+		 *       keep this netlink message
+		 */
+		/*
+		 * 0: Load the nlmsg_pid into the BPF register
+		 */
 		BPF_STMT(BPF_LD | BPF_ABS | BPF_W,
 			 offsetof(struct nlmsghdr, nlmsg_pid)),
-		/* 6: jeq XX  jt 7 jf 8   */
-		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htonl(pid), 0, 1),
-		/* 7: ret 0    (skip)     */
+		/*
+		 * 1: Compare to pid
+		 */
+		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htonl(pid), 0, 4),
+		/*
+		 * 2: Load the nlmsg_type into BPF register
+		 */
+		BPF_STMT(BPF_LD | BPF_ABS | BPF_H,
+			 offsetof(struct nlmsghdr, nlmsg_type)),
+		/*
+		 * 3: Compare to RTM_NEWADDR
+		 */
+		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_NEWADDR), 2, 0),
+		/*
+		 * 4: Compare to RTM_DELADDR
+		 */
+		BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, htons(RTM_DELADDR), 1, 0),
+		/*
+		 * 5: This is the end state of we want to skip the
+		 *    message
+		 */
 		BPF_STMT(BPF_RET | BPF_K, 0),
-		/* 8: ret 0xffff (keep)   */
+		/* 6: This is the end state of we want to keep
+		 *     the message
+		 */
 		BPF_STMT(BPF_RET | BPF_K, 0xffff),
 	};
 
@@ -332,8 +467,20 @@ void netlink_parse_rtattr(struct rtattr
 	}
 }
 
-int addattr_l(struct nlmsghdr *n, unsigned int maxlen, int type, void *data,
-	      unsigned int alen)
+/**
+ * netlink_parse_rtattr_nested() - Parses a nested route attribute
+ * @tb:         Pointer to array for storing rtattr in.
+ * @max:        Max number to store.
+ * @rta:        Pointer to rtattr to look for nested items in.
+ */
+void netlink_parse_rtattr_nested(struct rtattr **tb, int max,
+				 struct rtattr *rta)
+{
+	netlink_parse_rtattr(tb, max, RTA_DATA(rta), RTA_PAYLOAD(rta));
+}
+
+int addattr_l(struct nlmsghdr *n, unsigned int maxlen, int type,
+	      const void *data, unsigned int alen)
 {
 	int len;
 	struct rtattr *rta;
@@ -357,8 +504,8 @@ int addattr_l(struct nlmsghdr *n, unsign
 	return 0;
 }
 
-int rta_addattr_l(struct rtattr *rta, unsigned int maxlen, int type, void *data,
-		  unsigned int alen)
+int rta_addattr_l(struct rtattr *rta, unsigned int maxlen, int type,
+		  const void *data, unsigned int alen)
 {
 	unsigned int len;
 	struct rtattr *subrta;
@@ -440,6 +587,75 @@ const char *nl_rttype_to_str(uint8_t rtt
 	return lookup_msg(rttype_str, rttype, "");
 }
 
+#define NL_OK(nla, len)                                                        \
+	((len) >= (int)sizeof(struct nlattr)                                   \
+	 && (nla)->nla_len >= sizeof(struct nlattr)                            \
+	 && (nla)->nla_len <= (len))
+#define NL_NEXT(nla, attrlen)                                                  \
+	((attrlen) -= RTA_ALIGN((nla)->nla_len),                               \
+	 (struct nlattr *)(((char *)(nla)) + RTA_ALIGN((nla)->nla_len)))
+#define NL_RTA(r)                                                              \
+	((struct nlattr *)(((char *)(r))                                       \
+			   + NLMSG_ALIGN(sizeof(struct nlmsgerr))))
+
+static void netlink_parse_nlattr(struct nlattr **tb, int max,
+				 struct nlattr *nla, int len)
+{
+	while (NL_OK(nla, len)) {
+		if (nla->nla_type <= max)
+			tb[nla->nla_type] = nla;
+		nla = NL_NEXT(nla, len);
+	}
+}
+
+static void netlink_parse_extended_ack(struct nlmsghdr *h)
+{
+	struct nlattr *tb[NLMSGERR_ATTR_MAX + 1];
+	const struct nlmsgerr *err =
+		(const struct nlmsgerr *)((uint8_t *)h
+					  + NLMSG_ALIGN(
+						    sizeof(struct nlmsghdr)));
+	const struct nlmsghdr *err_nlh = NULL;
+	uint32_t hlen = sizeof(*err);
+	const char *msg = NULL;
+	uint32_t off = 0;
+
+	if (!(h->nlmsg_flags & NLM_F_CAPPED))
+		hlen += h->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr));
+
+	memset(tb, 0, sizeof(tb));
+	netlink_parse_nlattr(tb, NLMSGERR_ATTR_MAX, NL_RTA(h), hlen);
+
+	if (tb[NLMSGERR_ATTR_MSG])
+		msg = (const char *)RTA_DATA(tb[NLMSGERR_ATTR_MSG]);
+
+	if (tb[NLMSGERR_ATTR_OFFS]) {
+		off = *(uint32_t *)RTA_DATA(tb[NLMSGERR_ATTR_OFFS]);
+
+		if (off > h->nlmsg_len) {
+			zlog_err("Invalid offset for NLMSGERR_ATTR_OFFS\n");
+		} else if (!(h->nlmsg_flags & NLM_F_CAPPED)) {
+			/*
+			 * Header of failed message
+			 * we are not doing anything currently with it
+			 * but noticing it for later.
+			 */
+			err_nlh = &err->msg;
+			zlog_warn("%s: Received %d extended Ack",
+				  __PRETTY_FUNCTION__, err_nlh->nlmsg_type);
+		}
+	}
+
+	if (msg && *msg != '\0') {
+		bool is_err = !!err->error;
+
+		if (is_err)
+			zlog_err("Extended Error: %s", msg);
+		else
+			zlog_warn("Extended Warning: %s", msg);
+	}
+}
+
 /*
  * netlink_parse_info
  *
@@ -453,8 +669,7 @@ const char *nl_rttype_to_str(uint8_t rtt
  * startup -> Are we reading in under startup conditions? passed to
  *            the filter.
  */
-int netlink_parse_info(int (*filter)(struct sockaddr_nl *, struct nlmsghdr *,
-				     ns_id_t, int),
+int netlink_parse_info(int (*filter)(struct nlmsghdr *, ns_id_t, int),
 		       struct nlsock *nl, struct zebra_ns *zns, int count,
 		       int startup)
 {
@@ -464,7 +679,7 @@ int netlink_parse_info(int (*filter)(str
 	int read_in = 0;
 
 	while (1) {
-		char buf[NL_PKT_BUF_SIZE];
+		char buf[NL_RCV_PKT_BUF_SIZE];
 		struct iovec iov = {.iov_base = buf, .iov_len = sizeof buf};
 		struct sockaddr_nl snl;
 		struct msghdr msg = {.msg_name = (void *)&snl,
@@ -476,14 +691,26 @@ int netlink_parse_info(int (*filter)(str
 		if (count && read_in >= count)
 			return 0;
 
+#if defined(HANDLE_NETLINK_FUZZING)
+		/* Check if reading and filename is set */
+		if (netlink_read && '\0' != netlink_fuzz_file[0]) {
+			zlog_debug("Reading netlink fuzz file");
+			status = netlink_read_file(buf, netlink_fuzz_file);
+			snl.nl_pid = 0;
+		} else {
+			status = recvmsg(nl->sock, &msg, 0);
+		}
+#else
 		status = recvmsg(nl->sock, &msg, 0);
+#endif /* HANDLE_NETLINK_FUZZING */
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
 			if (errno == EWOULDBLOCK || errno == EAGAIN)
 				break;
-			zlog_err("%s recvmsg overrun: %s", nl->name,
-				 safe_strerror(errno));
+			flog_err(ZEBRA_ERR_RECVMSG_OVERRUN,
+				  "%s recvmsg overrun: %s", nl->name,
+				  safe_strerror(errno));
 			/*
 			 *  In this case we are screwed.
 			 *  There is no good way to
@@ -494,13 +721,14 @@ int netlink_parse_info(int (*filter)(str
 		}
 
 		if (status == 0) {
-			zlog_err("%s EOF", nl->name);
+			flog_err_sys(LIB_ERR_SOCKET, "%s EOF", nl->name);
 			return -1;
 		}
 
 		if (msg.msg_namelen != sizeof snl) {
-			zlog_err("%s sender address length error: length %d",
-				 nl->name, msg.msg_namelen);
+			flog_err(ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+				  "%s sender address length error: length %d",
+				  nl->name, msg.msg_namelen);
 			return -1;
 		}
 
@@ -510,9 +738,17 @@ int netlink_parse_info(int (*filter)(str
 			zlog_hexdump(buf, status);
 		}
 
+#if defined(HANDLE_NETLINK_FUZZING)
+		if (!netlink_read) {
+			zlog_debug("Writing incoming netlink message");
+			netlink_write_incoming(buf, status,
+					       netlink_file_counter++);
+		}
+#endif /* HANDLE_NETLINK_FUZZING */
+
 		read_in++;
 		for (h = (struct nlmsghdr *)buf;
-		     NLMSG_OK(h, (unsigned int)status);
+		     (status >= 0 && NLMSG_OK(h, (unsigned int)status));
 		     h = NLMSG_NEXT(h, status)) {
 			/* Finish of reading. */
 			if (h->nlmsg_type == NLMSG_DONE)
@@ -525,6 +761,23 @@ int netlink_parse_info(int (*filter)(str
 				int errnum = err->error;
 				int msg_type = err->msg.nlmsg_type;
 
+				if (h->nlmsg_len
+				    < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
+					zlog_err("%s error: message truncated",
+						 nl->name);
+					return -1;
+				}
+
+				/*
+				 * Parse the extended information before
+				 * we actually handle it.
+				 * At this point in time we do not
+				 * do anything other than report the
+				 * issue.
+				 */
+				if (h->nlmsg_flags & NLM_F_ACK_TLVS)
+					netlink_parse_extended_ack(h);
+
 				/* If the error field is zero, then this is an
 				 * ACK */
 				if (err->error == 0) {
@@ -548,8 +801,10 @@ int netlink_parse_info(int (*filter)(str
 
 				if (h->nlmsg_len
 				    < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
-					zlog_err("%s error: message truncated",
-						 nl->name);
+					flog_err(
+						ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+						"%s error: message truncated",
+						nl->name);
 					return -1;
 				}
 
@@ -601,7 +856,8 @@ int netlink_parse_info(int (*filter)(str
 							err->msg.nlmsg_seq,
 							err->msg.nlmsg_pid);
 				} else
-					zlog_err(
+					flog_err(
+						ZEBRA_ERR_UNEXPECTED_MESSAGE,
 						"%s error: %s, type=%s(%u), seq=%u, pid=%u",
 						nl->name,
 						safe_strerror(-errnum),
@@ -621,38 +877,34 @@ int netlink_parse_info(int (*filter)(str
 					h->nlmsg_type, h->nlmsg_len,
 					h->nlmsg_seq, h->nlmsg_pid);
 
-			/* skip unsolicited messages originating from command
-			 * socket
-			 * linux sets the originators port-id for {NEW|DEL}ADDR
-			 * messages,
-			 * so this has to be checked here. */
-			if (nl != &zns->netlink_cmd
-			    && h->nlmsg_pid == zns->netlink_cmd.snl.nl_pid
-			    && (h->nlmsg_type != RTM_NEWADDR
-				&& h->nlmsg_type != RTM_DELADDR)) {
-				if (IS_ZEBRA_DEBUG_KERNEL)
-					zlog_debug(
-						"netlink_parse_info: %s packet comes from %s",
-						zns->netlink_cmd.name,
-						nl->name);
+
+			/*
+			 * Ignore messages that maybe sent from
+			 * other actors besides the kernel
+			 */
+			if (snl.nl_pid != 0) {
+				zlog_debug("Ignoring message from pid %u",
+					   snl.nl_pid);
 				continue;
 			}
 
-			error = (*filter)(&snl, h, zns->ns_id, startup);
+			error = (*filter)(h, zns->ns_id, startup);
 			if (error < 0) {
-				zlog_err("%s filter function error", nl->name);
+				zlog_warn("%s filter function error", nl->name);
 				ret = error;
 			}
 		}
 
 		/* After error care. */
 		if (msg.msg_flags & MSG_TRUNC) {
-			zlog_err("%s error: message truncated", nl->name);
+			flog_err(ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+				  "%s error: message truncated", nl->name);
 			continue;
 		}
 		if (status) {
-			zlog_err("%s error: data remnant size %d", nl->name,
-				 status);
+			flog_err(ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+				  "%s error: data remnant size %d", nl->name,
+				  status);
 			return -1;
 		}
 	}
@@ -672,16 +924,15 @@ int netlink_parse_info(int (*filter)(str
  * startup  -> Are we reading in under startup conditions
  *             This is passed through eventually to filter.
  */
-int netlink_talk(int (*filter)(struct sockaddr_nl *, struct nlmsghdr *, ns_id_t,
-			       int startup),
+int netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
 		 struct nlmsghdr *n, struct nlsock *nl, struct zebra_ns *zns,
 		 int startup)
 {
-	int status;
+	int status = 0;
 	struct sockaddr_nl snl;
 	struct iovec iov;
 	struct msghdr msg;
-	int save_errno;
+	int save_errno = 0;
 
 	memset(&snl, 0, sizeof snl);
 	memset(&iov, 0, sizeof iov);
@@ -699,9 +950,6 @@ int netlink_talk(int (*filter)(struct so
 	n->nlmsg_seq = ++nl->seq;
 	n->nlmsg_pid = nl->snl.nl_pid;
 
-	/* Request an acknowledgement by setting NLM_F_ACK */
-	n->nlmsg_flags |= NLM_F_ACK;
-
 	if (IS_ZEBRA_DEBUG_KERNEL)
 		zlog_debug(
 			"netlink_talk: %s type %s(%u), len=%d seq=%u flags 0x%x",
@@ -710,12 +958,10 @@ int netlink_talk(int (*filter)(struct so
 			n->nlmsg_flags);
 
 	/* Send message to netlink interface. */
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	status = sendmsg(nl->sock, &msg, 0);
-	save_errno = errno;
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		status = sendmsg(nl->sock, &msg, 0);
+		save_errno = errno;
+	}
 
 	if (IS_ZEBRA_DEBUG_KERNEL_MSGDUMP_SEND) {
 		zlog_debug("%s: >> netlink message dump [sent]", __func__);
@@ -723,8 +969,8 @@ int netlink_talk(int (*filter)(struct so
 	}
 
 	if (status < 0) {
-		zlog_err("netlink_talk sendmsg() error: %s",
-			 safe_strerror(save_errno));
+		flog_err_sys(LIB_ERR_SOCKET, "netlink_talk sendmsg() error: %s",
+			     safe_strerror(save_errno));
 		return -1;
 	}
 
@@ -743,11 +989,11 @@ int netlink_request(struct nlsock *nl, s
 {
 	int ret;
 	struct sockaddr_nl snl;
-	int save_errno;
 
 	/* Check netlink socket. */
 	if (nl->sock < 0) {
-		zlog_err("%s socket isn't active.", nl->name);
+		flog_err_sys(LIB_ERR_SOCKET, "%s socket isn't active.",
+			     nl->name);
 		return -1;
 	}
 
@@ -760,21 +1006,14 @@ int netlink_request(struct nlsock *nl, s
 	snl.nl_family = AF_NETLINK;
 
 	/* Raise capabilities and send message, then lower capabilities. */
-	if (zserv_privs.change(ZPRIVS_RAISE)) {
-		zlog_err("Can't raise privileges");
-		return -1;
+	frr_elevate_privs(&zserv_privs) {
+		ret = sendto(nl->sock, (void *)n, n->nlmsg_len, 0,
+			     (struct sockaddr *)&snl, sizeof snl);
 	}
 
-	ret = sendto(nl->sock, (void *)n, n->nlmsg_len, 0,
-		     (struct sockaddr *)&snl, sizeof snl);
-	save_errno = errno;
-
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
-
 	if (ret < 0) {
 		zlog_err("%s sendto failed: %s", nl->name,
-			 safe_strerror(save_errno));
+			 safe_strerror(errno));
 		return -1;
 	}
 
@@ -786,40 +1025,86 @@ int netlink_request(struct nlsock *nl, s
 void kernel_init(struct zebra_ns *zns)
 {
 	unsigned long groups;
+#if defined SOL_NETLINK
+	int one, ret;
+#endif
 
-	/* Initialize netlink sockets */
-	groups = RTMGRP_LINK | RTMGRP_IPV4_ROUTE | RTMGRP_IPV4_IFADDR
-		 | RTMGRP_IPV6_ROUTE | RTMGRP_IPV6_IFADDR | RTMGRP_IPV4_MROUTE
-		 | RTMGRP_NEIGH
-		 | RTNLGRP_IPV4_RULE | RTNLGRP_IPV6_RULE;
+	/*
+	 * Initialize netlink sockets
+	 *
+	 * If RTMGRP_XXX exists use that, but at some point
+	 * I think the kernel developers realized that
+	 * keeping track of all the different values would
+	 * lead to confusion, so we need to convert the
+	 * RTNLGRP_XXX to a bit position for ourself
+	 */
+	groups = RTMGRP_LINK                   |
+		RTMGRP_IPV4_ROUTE              |
+		RTMGRP_IPV4_IFADDR             |
+		RTMGRP_IPV6_ROUTE              |
+		RTMGRP_IPV6_IFADDR             |
+		RTMGRP_IPV4_MROUTE             |
+		RTMGRP_NEIGH                   |
+		(1 << (RTNLGRP_IPV4_RULE - 1)) |
+		(1 << (RTNLGRP_IPV6_RULE - 1));
 
 	snprintf(zns->netlink.name, sizeof(zns->netlink.name),
 		 "netlink-listen (NS %u)", zns->ns_id);
 	zns->netlink.sock = -1;
-	netlink_socket(&zns->netlink, groups, zns->ns_id);
+	if (netlink_socket(&zns->netlink, groups, zns->ns_id) < 0) {
+		zlog_err("Failure to create %s socket",
+			 zns->netlink.name);
+		exit(-1);
+	}
 
 	snprintf(zns->netlink_cmd.name, sizeof(zns->netlink_cmd.name),
 		 "netlink-cmd (NS %u)", zns->ns_id);
 	zns->netlink_cmd.sock = -1;
-	netlink_socket(&zns->netlink_cmd, 0, zns->ns_id);
+	if (netlink_socket(&zns->netlink_cmd, 0, zns->ns_id) < 0) {
+		zlog_err("Failure to create %s socket",
+			 zns->netlink_cmd.name);
+		exit(-1);
+	}
+
+	/*
+	 * SOL_NETLINK is not available on all platforms yet
+	 * apparently.  It's in bits/socket.h which I am not
+	 * sure that we want to pull into our build system.
+	 */
+#if defined SOL_NETLINK
+	/*
+	 * Let's tell the kernel that we want to receive extended
+	 * ACKS over our command socket
+	 */
+	one = 1;
+	ret = setsockopt(zns->netlink_cmd.sock, SOL_NETLINK, NETLINK_EXT_ACK,
+			 &one, sizeof(one));
+
+	if (ret < 0)
+		zlog_notice("Registration for extended ACK failed : %d %s",
+			    errno, safe_strerror(errno));
+#endif
 
 	/* Register kernel socket. */
-	if (zns->netlink.sock > 0) {
-		/* Only want non-blocking on the netlink event socket */
-		if (fcntl(zns->netlink.sock, F_SETFL, O_NONBLOCK) < 0)
-			zlog_err("Can't set %s socket flags: %s",
-				 zns->netlink.name, safe_strerror(errno));
-
-		/* Set receive buffer size if it's set from command line */
-		if (nl_rcvbufsize)
-			netlink_recvbuf(&zns->netlink, nl_rcvbufsize);
-
-		netlink_install_filter(zns->netlink.sock,
-				       zns->netlink_cmd.snl.nl_pid);
-		zns->t_netlink = NULL;
-		thread_add_read(zebrad.master, kernel_read, zns,
-				zns->netlink.sock, &zns->t_netlink);
-	}
+	if (fcntl(zns->netlink.sock, F_SETFL, O_NONBLOCK) < 0)
+		flog_err_sys(LIB_ERR_SOCKET, "Can't set %s socket flags: %s",
+			     zns->netlink.name, safe_strerror(errno));
+
+	if (fcntl(zns->netlink_cmd.sock, F_SETFL, O_NONBLOCK) < 0)
+		zlog_err("Can't set %s socket error: %s(%d)",
+			 zns->netlink_cmd.name, safe_strerror(errno), errno);
+
+	/* Set receive buffer size if it's set from command line */
+	if (nl_rcvbufsize)
+		netlink_recvbuf(&zns->netlink, nl_rcvbufsize);
+
+	assert(zns->netlink.sock >= 0);
+	netlink_install_filter(zns->netlink.sock,
+			       zns->netlink_cmd.snl.nl_pid);
+	zns->t_netlink = NULL;
+
+	thread_add_read(zebrad.master, kernel_read, zns,
+			zns->netlink.sock, &zns->t_netlink);
 
 	rt_netlink_init();
 }
diff -urpN frr-frr-5.0.1/zebra/kernel_netlink.h frr-frr-6.0/zebra/kernel_netlink.h
--- frr-frr-5.0.1/zebra/kernel_netlink.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/kernel_netlink.h	2018-10-08 14:32:57.000000000 +0200
@@ -23,14 +23,17 @@
 
 #ifdef HAVE_NETLINK
 
+#define NL_RCV_PKT_BUF_SIZE     32768
 #define NL_PKT_BUF_SIZE         8192
 
 extern void netlink_parse_rtattr(struct rtattr **tb, int max,
 				 struct rtattr *rta, int len);
+extern void netlink_parse_rtattr_nested(struct rtattr **tb, int max,
+					struct rtattr *rta);
 extern int addattr_l(struct nlmsghdr *n, unsigned int maxlen, int type,
-		     void *data, unsigned int alen);
+		     const void *data, unsigned int alen);
 extern int rta_addattr_l(struct rtattr *rta, unsigned int maxlen, int type,
-			 void *data, unsigned int alen);
+			 const void *data, unsigned int alen);
 extern int addattr16(struct nlmsghdr *n, unsigned int maxlen, int type,
 		     uint16_t data);
 extern int addattr32(struct nlmsghdr *n, unsigned int maxlen, int type,
@@ -44,14 +47,15 @@ extern const char *nl_rtproto_to_str(uin
 extern const char *nl_family_to_str(uint8_t family);
 extern const char *nl_rttype_to_str(uint8_t rttype);
 
-extern int netlink_parse_info(int (*filter)(struct sockaddr_nl *,
-					    struct nlmsghdr *, ns_id_t, int),
+#if defined(HANDLE_NETLINK_FUZZING)
+extern bool netlink_read;
+extern void netlink_read_init(const char *fname);
+#endif /* HANDLE_NETLINK_FUZZING */
+extern int netlink_parse_info(int (*filter)(struct nlmsghdr *, ns_id_t, int),
 			      struct nlsock *nl, struct zebra_ns *zns,
 			      int count, int startup);
-extern int netlink_talk_filter(struct sockaddr_nl *, struct nlmsghdr *, ns_id_t,
-			       int startup);
-extern int netlink_talk(int (*filter)(struct sockaddr_nl *, struct nlmsghdr *,
-				      ns_id_t, int startup),
+extern int netlink_talk_filter(struct nlmsghdr *h, ns_id_t ns, int startup);
+extern int netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
 			struct nlmsghdr *n, struct nlsock *nl,
 			struct zebra_ns *zns, int startup);
 extern int netlink_request(struct nlsock *nl, struct nlmsghdr *n);
diff -urpN frr-frr-5.0.1/zebra/kernel_socket.c frr-frr-6.0/zebra/kernel_socket.c
--- frr-frr-5.0.1/zebra/kernel_socket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/kernel_socket.c	2018-10-08 14:32:57.000000000 +0200
@@ -39,6 +39,7 @@
 #include "rib.h"
 #include "privs.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "zebra/rt.h"
 #include "zebra/interface.h"
@@ -46,6 +47,7 @@
 #include "zebra/debug.h"
 #include "zebra/kernel_socket.h"
 #include "zebra/rib.h"
+#include "zebra/zebra_errors.h"
 
 extern struct zebra_privs_t zserv_privs;
 
@@ -407,8 +409,9 @@ int ifm_read(struct if_msghdr *ifm)
 
 	/* paranoia: sanity check structure */
 	if (ifm->ifm_msglen < sizeof(struct if_msghdr)) {
-		zlog_err("ifm_read: ifm->ifm_msglen %d too short\n",
-			 ifm->ifm_msglen);
+		flog_err(ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+			  "ifm_read: ifm->ifm_msglen %d too short\n",
+			  ifm->ifm_msglen);
 		return -1;
 	}
 
@@ -1043,7 +1046,7 @@ void rtm_read(struct rt_msghdr *rtm)
 		if (rtm->rtm_type == RTM_CHANGE)
 			rib_delete(AFI_IP, SAFI_UNICAST, VRF_DEFAULT,
 				   ZEBRA_ROUTE_KERNEL, 0, zebra_flags, &p, NULL,
-				   NULL, 0, 0, true, NULL);
+				   NULL, 0, 0, 0, true);
 
 		if (!nh.type) {
 			nh.type = NEXTHOP_TYPE_IPV4;
@@ -1058,7 +1061,7 @@ void rtm_read(struct rt_msghdr *rtm)
 		else
 			rib_delete(AFI_IP, SAFI_UNICAST, VRF_DEFAULT,
 				   ZEBRA_ROUTE_KERNEL, 0, zebra_flags, &p, NULL,
-				   &nh, 0, 0, true, NULL);
+				   &nh, 0, 0, 0, true);
 	}
 	if (dest.sa.sa_family == AF_INET6) {
 		/* One day we might have a debug section here like one in the
@@ -1089,7 +1092,7 @@ void rtm_read(struct rt_msghdr *rtm)
 		if (rtm->rtm_type == RTM_CHANGE)
 			rib_delete(AFI_IP6, SAFI_UNICAST, VRF_DEFAULT,
 				   ZEBRA_ROUTE_KERNEL, 0, zebra_flags, &p, NULL,
-				   NULL, 0, 0, true, NULL);
+				   NULL, 0, 0, 0, true);
 
 		if (!nh.type) {
 			nh.type = ifindex ? NEXTHOP_TYPE_IPV6_IFINDEX
@@ -1106,7 +1109,7 @@ void rtm_read(struct rt_msghdr *rtm)
 		else
 			rib_delete(AFI_IP6, SAFI_UNICAST, VRF_DEFAULT,
 				   ZEBRA_ROUTE_KERNEL, 0, zebra_flags, &p, NULL,
-				   &nh, 0, 0, true, NULL);
+				   &nh, 0, 0, 0, true);
 	}
 }
 
@@ -1382,15 +1385,11 @@ static int kernel_read(struct thread *th
 /* Make routing socket. */
 static void routing_socket(struct zebra_ns *zns)
 {
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("routing_socket: Can't raise privileges");
-
-	routing_sock =
-		ns_socket(AF_ROUTE, SOCK_RAW, 0, zns->ns_id);
+	frr_elevate_privs(&zserv_privs) {
+		routing_sock = ns_socket(AF_ROUTE, SOCK_RAW, 0, zns->ns_id);
+	}
 
 	if (routing_sock < 0) {
-		if (zserv_privs.change(ZPRIVS_LOWER))
-			zlog_err("routing_socket: Can't lower privileges");
 		zlog_warn("Can't init kernel routing socket");
 		return;
 	}
@@ -1402,9 +1401,6 @@ static void routing_socket(struct zebra_
 	/*if (fcntl (routing_sock, F_SETFL, O_NONBLOCK) < 0)
 	  zlog_warn ("Can't set O_NONBLOCK to routing socket");*/
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("routing_socket: Can't lower privileges");
-
 	/* kernel_read needs rewrite. */
 	thread_add_read(zebrad.master, kernel_read, NULL, routing_sock, NULL);
 }
diff -urpN frr-frr-5.0.1/zebra/label_manager.c frr-frr-6.0/zebra/label_manager.c
--- frr-frr-5.0.1/zebra/label_manager.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/label_manager.c	2018-10-08 14:32:57.000000000 +0200
@@ -21,12 +21,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <zebra.h>
 #include <stdio.h>
 #include <string.h>
 #include <sys/types.h>
 
-#include "zebra.h"
-#include "zserv.h"
 #include "lib/log.h"
 #include "lib/memory.h"
 #include "lib/mpls.h"
@@ -35,7 +34,9 @@
 #include "lib/zclient.h"
 #include "lib/libfrr.h"
 
-#include "label_manager.h"
+#include "zebra/zserv.h"
+#include "zebra/label_manager.h"
+#include "zebra/zebra_errors.h"
 
 #define CONNECTION_DELAY 5
 
@@ -82,8 +83,9 @@ static int relay_response_back(void)
 	ret = zclient_read_header(src, zclient->sock, &size, &marker, &version,
 				  &vrf_id, &resp_cmd);
 	if (ret < 0 && errno != EAGAIN) {
-		zlog_err("Error reading Label Manager response: %s",
-			 strerror(errno));
+		flog_err(ZEBRA_ERR_LM_RESPONSE,
+			  "Error reading Label Manager response: %s",
+			  strerror(errno));
 		return -1;
 	}
 	zlog_debug("Label Manager response received, %d bytes", size);
@@ -99,9 +101,10 @@ static int relay_response_back(void)
 	proto_str = zebra_route_string(proto);
 
 	/* lookup the client to relay the msg to */
-	zserv = zebra_find_client(proto, instance);
+	zserv = zserv_find_client(proto, instance);
 	if (!zserv) {
-		zlog_err(
+		flog_err(
+			ZEBRA_ERR_LM_NO_SUCH_CLIENT,
 			"Error relaying LM response: can't find client %s, instance %u",
 			proto_str, instance);
 		return -1;
@@ -116,8 +119,9 @@ static int relay_response_back(void)
 	/* send response back */
 	ret = writen(zserv->sock, dst->data, stream_get_endp(dst));
 	if (ret <= 0) {
-		zlog_err("Error relaying LM response to %s instance %u: %s",
-			 proto_str, instance, strerror(errno));
+		flog_err(ZEBRA_ERR_LM_RELAY_FAILED,
+			  "Error relaying LM response to %s instance %u: %s",
+			  proto_str, instance, strerror(errno));
 		return -1;
 	}
 	zlog_debug("Relayed LM response (%d bytes) to %s instance %u", ret,
@@ -183,7 +187,8 @@ int zread_relay_label_manager_request(in
 	unsigned short instance;
 
 	if (zclient->sock < 0) {
-		zlog_err("Unable to relay LM request: no socket");
+		flog_err(ZEBRA_ERR_LM_NO_SOCKET,
+			  "Unable to relay LM request: no socket");
 		reply_error(cmd, zserv, vrf_id);
 		return -1;
 	}
@@ -211,8 +216,9 @@ int zread_relay_label_manager_request(in
 
 	/* check & set client instance if unset */
 	if (zserv->instance && zserv->instance != instance) {
-		zlog_err("Client instance(%u) != msg instance(%u)",
-			 zserv->instance, instance);
+		flog_err(ZEBRA_ERR_LM_BAD_INSTANCE,
+			  "Client instance(%u) != msg instance(%u)",
+			  zserv->instance, instance);
 		return -1;
 	}
 
@@ -221,9 +227,8 @@ int zread_relay_label_manager_request(in
 	zserv->proto = proto;
 
 	/* in case there's any incoming message enqueued, read and forward it */
-	if (zserv->is_synchronous)
-		while (ret == 0)
-			ret = relay_response_back();
+	while (ret == 0)
+		ret = relay_response_back();
 
 	/* get the msg buffer used toward the 'master' Label Manager */
 	dst = zclient->obuf;
@@ -234,8 +239,9 @@ int zread_relay_label_manager_request(in
 	/* Send request to external label manager */
 	ret = writen(zclient->sock, dst->data, stream_get_endp(dst));
 	if (ret <= 0) {
-		zlog_err("Error relaying LM request from %s instance %u: %s",
-			 proto_str, instance, strerror(errno));
+		flog_err(ZEBRA_ERR_LM_RELAY_FAILED,
+			  "Error relaying LM request from %s instance %u: %s",
+			  proto_str, instance, strerror(errno));
 		reply_error(cmd, zserv, vrf_id);
 		return -1;
 	}
@@ -263,7 +269,8 @@ static int lm_zclient_connect(struct thr
 		return 0;
 
 	if (zclient_socket_connect(zclient) < 0) {
-		zlog_err("Error connecting synchronous zclient!");
+		flog_err(ZEBRA_ERR_LM_CLIENT_CONNECTION_FAILED,
+			  "Error connecting synchronous zclient!");
 		thread_add_timer(zebrad.master, lm_zclient_connect, zclient,
 				 CONNECTION_DELAY, &zclient->t_connect);
 		return -1;
@@ -351,7 +358,7 @@ void label_manager_init(char *lm_zserv_p
 
 	obuf = stream_new(ZEBRA_MAX_PACKET_SIZ);
 
-	hook_register(zapi_client_close, release_daemon_label_chunks);
+	hook_register(zserv_client_close, release_daemon_label_chunks);
 }
 
 /**
@@ -385,8 +392,6 @@ struct label_manager_chunk *assign_label
 	}
 	/* otherwise create a new one */
 	lmc = XCALLOC(MTYPE_LM_CHUNK, sizeof(struct label_manager_chunk));
-	if (!lmc)
-		return NULL;
 
 	if (list_isempty(lbl_mgr.lc_list))
 		lmc->start = MPLS_LABEL_UNRESERVED_MIN;
@@ -396,8 +401,9 @@ struct label_manager_chunk *assign_label
 				     ->end
 			     + 1;
 	if (lmc->start > MPLS_LABEL_UNRESERVED_MAX - size + 1) {
-		zlog_err("Reached max labels. Start: %u, size: %u", lmc->start,
-			 size);
+		flog_err(ZEBRA_ERR_LM_EXHAUSTED_LABELS,
+			  "Reached max labels. Start: %u, size: %u", lmc->start,
+			  size);
 		XFREE(MTYPE_LM_CHUNK, lmc);
 		return NULL;
 	}
@@ -435,7 +441,8 @@ int release_label_chunk(uint8_t proto, u
 		if (lmc->end != end)
 			continue;
 		if (lmc->proto != proto || lmc->instance != instance) {
-			zlog_err("%s: Daemon mismatch!!", __func__);
+			flog_err(ZEBRA_ERR_LM_DAEMON_MISMATCH,
+				  "%s: Daemon mismatch!!", __func__);
 			continue;
 		}
 		lmc->proto = NO_PROTO;
@@ -445,7 +452,8 @@ int release_label_chunk(uint8_t proto, u
 		break;
 	}
 	if (ret != 0)
-		zlog_err("%s: Label chunk not released!!", __func__);
+		flog_err(ZEBRA_ERR_LM_UNRELEASED_CHUNK,
+			  "%s: Label chunk not released!!", __func__);
 
 	return ret;
 }
diff -urpN frr-frr-5.0.1/zebra/main.c frr-frr-6.0/zebra/main.c
--- frr-frr-5.0.1/zebra/main.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/main.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,7 +37,9 @@
 #include "logicalrouter.h"
 #include "libfrr.h"
 #include "routemap.h"
+#include "frr_pthread.h"
 
+#include "zebra/zebra_errors.h"
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
 #include "zebra/debug.h"
@@ -51,6 +53,11 @@
 #include "zebra/label_manager.h"
 #include "zebra/zebra_netns_notify.h"
 #include "zebra/zebra_rnh.h"
+#include "zebra/zebra_pbr.h"
+
+#if defined(HANDLE_NETLINK_FUZZING)
+#include "zebra/kernel_netlink.h"
+#endif /* HANDLE_NETLINK_FUZZING */
 
 #define ZEBRA_PTM_SUPPORT
 
@@ -75,24 +82,29 @@ int allow_delete = 0;
 /* Don't delete kernel route. */
 int keep_kernel_mode = 0;
 
+bool v6_rr_semantics = false;
+
 #ifdef HAVE_NETLINK
 /* Receive buffer size for netlink socket */
 uint32_t nl_rcvbufsize = 4194304;
 #endif /* HAVE_NETLINK */
 
+#define OPTION_V6_RR_SEMANTICS 2000
 /* Command line options. */
-struct option longopts[] = {{"batch", no_argument, NULL, 'b'},
-			    {"allow_delete", no_argument, NULL, 'a'},
-			    {"keep_kernel", no_argument, NULL, 'k'},
-			    {"socket", required_argument, NULL, 'z'},
-			    {"ecmp", required_argument, NULL, 'e'},
-			    {"label_socket", no_argument, NULL, 'l'},
-			    {"retain", no_argument, NULL, 'r'},
+struct option longopts[] = {
+	{"batch", no_argument, NULL, 'b'},
+	{"allow_delete", no_argument, NULL, 'a'},
+	{"keep_kernel", no_argument, NULL, 'k'},
+	{"socket", required_argument, NULL, 'z'},
+	{"ecmp", required_argument, NULL, 'e'},
+	{"label_socket", no_argument, NULL, 'l'},
+	{"retain", no_argument, NULL, 'r'},
 #ifdef HAVE_NETLINK
-			    {"vrfwnetns", no_argument, NULL, 'n'},
-			    {"nl-bufsize", required_argument, NULL, 's'},
+	{"vrfwnetns", no_argument, NULL, 'n'},
+	{"nl-bufsize", required_argument, NULL, 's'},
+	{"v6-rr-semantics", no_argument, NULL, OPTION_V6_RR_SEMANTICS},
 #endif /* HAVE_NETLINK */
-			    {0}};
+	{0}};
 
 zebra_capabilities_t _caps_p[] = {
 	ZCAP_NET_ADMIN, ZCAP_SYS_ADMIN, ZCAP_NET_RAW,
@@ -127,11 +139,16 @@ static void sigint(void)
 {
 	struct vrf *vrf;
 	struct zebra_vrf *zvrf;
+	struct listnode *ln, *nn;
+	struct zserv *client;
 
 	zlog_notice("Terminating on signal");
 
 	frr_early_fini();
 
+	for (ALL_LIST_ELEMENTS(zebrad.client_list, ln, nn, client))
+		zserv_close_client(client);
+
 	list_delete_all_node(zebrad.client_list);
 	zebra_ptm_finish();
 
@@ -206,8 +223,11 @@ int main(int argc, char **argv)
 	struct sockaddr_storage dummy;
 	socklen_t dummylen;
 #if defined(HANDLE_ZAPI_FUZZING)
-	char *fuzzing = NULL;
-#endif
+	char *zapi_fuzzing = NULL;
+#endif /* HANDLE_ZAPI_FUZZING */
+#if defined(HANDLE_NETLINK_FUZZING)
+	char *netlink_fuzzing = NULL;
+#endif /* HANDLE_NETLINK_FUZZING */
 
 	vrf_configure_backend(VRF_BACKEND_VRF_LITE);
 	logicalrouter_configure_backend(LOGICALROUTER_BACKEND_NETNS);
@@ -221,24 +241,31 @@ int main(int argc, char **argv)
 #endif
 #if defined(HANDLE_ZAPI_FUZZING)
 		"c:"
-#endif
+#endif /* HANDLE_ZAPI_FUZZING */
+#if defined(HANDLE_NETLINK_FUZZING)
+		"w:"
+#endif /* HANDLE_NETLINK_FUZZING */
 		,
 		longopts,
-		"  -b, --batch        Runs in batch mode\n"
-		"  -a, --allow_delete Allow other processes to delete zebra routes\n"
-		"  -z, --socket       Set path of zebra socket\n"
-		"  -e, --ecmp         Specify ECMP to use.\n"
-		"  -l, --label_socket Socket to external label manager\n"
-		"  -k, --keep_kernel  Don't delete old routes which installed by zebra.\n"
-		"  -r, --retain       When program terminates, retain added route by zebra.\n"
+		"  -b, --batch           Runs in batch mode\n"
+		"  -a, --allow_delete    Allow other processes to delete zebra routes\n"
+		"  -z, --socket          Set path of zebra socket\n"
+		"  -e, --ecmp            Specify ECMP to use.\n"
+		"  -l, --label_socket    Socket to external label manager\n"
+		"  -k, --keep_kernel     Don't delete old routes which were installed by zebra.\n"
+		"  -r, --retain          When program terminates, retain added route by zebra.\n"
 #ifdef HAVE_NETLINK
-		"  -n, --vrfwnetns    Set VRF with NetNS\n"
-		"  -s, --nl-bufsize   Set netlink receive buffer size\n"
+		"  -n, --vrfwnetns       Use NetNS as VRF backend\n"
+		"  -s, --nl-bufsize      Set netlink receive buffer size\n"
+		"      --v6-rr-semantics Use v6 RR semantics\n"
 #endif /* HAVE_NETLINK */
 #if defined(HANDLE_ZAPI_FUZZING)
-		"  -c <file>          Bypass normal startup use this file for tetsting of zapi"
-#endif
-		);
+		"  -c <file>             Bypass normal startup and use this file for testing of zapi\n"
+#endif /* HANDLE_ZAPI_FUZZING */
+#if defined(HANDLE_NETLINK_FUZZING)
+		"  -w <file>             Bypass normal startup and use this file for testing of netlink input\n"
+#endif /* HANDLE_NETLINK_FUZZING */
+	);
 
 	while (1) {
 		int opt = frr_getopt(argc, argv, NULL);
@@ -262,7 +289,8 @@ int main(int argc, char **argv)
 			multipath_num = atoi(optarg);
 			if (multipath_num > MULTIPATH_NUM
 			    || multipath_num <= 0) {
-				zlog_err(
+				flog_err(
+					ZEBRA_ERR_BAD_MULTIPATH_NUM,
 					"Multipath Number specified must be less than %d and greater than 0",
 					MULTIPATH_NUM);
 				return 1;
@@ -292,12 +320,25 @@ int main(int argc, char **argv)
 			logicalrouter_configure_backend(
 				LOGICALROUTER_BACKEND_OFF);
 			break;
+		case OPTION_V6_RR_SEMANTICS:
+			v6_rr_semantics = true;
+			break;
 #endif /* HAVE_NETLINK */
 #if defined(HANDLE_ZAPI_FUZZING)
 		case 'c':
-			fuzzing = optarg;
+			zapi_fuzzing = optarg;
 			break;
-#endif
+#endif /* HANDLE_ZAPI_FUZZING */
+#if defined(HANDLE_NETLINK_FUZZING)
+		case 'w':
+			netlink_fuzzing = optarg;
+			/* This ensures we are aren't writing any of the
+			 * startup netlink messages that happen when we
+			 * just want to read.
+			 */
+			netlink_read = true;
+			break;
+#endif /* HANDLE_NETLINK_FUZZING */
 		default:
 			frr_help_exit(1);
 			break;
@@ -333,17 +374,11 @@ int main(int argc, char **argv)
 	zebra_mpls_init();
 	zebra_mpls_vty_init();
 	zebra_pw_vty_init();
+	zebra_pbr_init();
 
 /* For debug purpose. */
 /* SET_FLAG (zebra_debug_event, ZEBRA_DEBUG_EVENT); */
 
-#if defined(HANDLE_ZAPI_FUZZING)
-	if (fuzzing) {
-		zserv_read_file(fuzzing);
-		exit(0);
-	}
-#endif
-
 	/* Process the configuration file. Among other configuration
 	*  directives we can meet those installing static routes. Such
 	*  requests will not be executed immediately, but queued in
@@ -367,14 +402,34 @@ int main(int argc, char **argv)
 	/* Needed for BSD routing socket. */
 	pid = getpid();
 
-	/* This must be done only after locking pidfile (bug #403). */
-	zebra_zserv_socket_init(zserv_path);
+	/* Intialize pthread library */
+	frr_pthread_init();
+
+	/* Start Zebra API server */
+	zserv_start(zserv_path);
 
 	/* Init label manager */
 	label_manager_init(lblmgr_path);
 
 	/* RNH init */
 	zebra_rnh_init();
+	
+	/* Error init */
+	zebra_error_init();
+
+#if defined(HANDLE_ZAPI_FUZZING)
+	if (zapi_fuzzing) {
+		zserv_read_file(zapi_fuzzing);
+		exit(0);
+	}
+#endif /* HANDLE_ZAPI_FUZZING */
+#if defined(HANDLE_NETLINK_FUZZING)
+	if (netlink_fuzzing) {
+		netlink_read_init(netlink_fuzzing);
+		exit(0);
+	}
+#endif /* HANDLE_NETLINK_FUZZING */
+
 
 	frr_run(zebrad.master);
 
diff -urpN frr-frr-5.0.1/zebra/redistribute.c frr-frr-6.0/zebra/redistribute.c
--- frr-frr-5.0.1/zebra/redistribute.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/redistribute.c	2018-10-08 14:32:57.000000000 +0200
@@ -113,7 +113,7 @@ static void zebra_redistribute(struct zs
 
 	for (rn = route_top(table); rn; rn = srcdest_route_next(rn))
 		RNODE_FOREACH_RE (rn, newre) {
-			struct prefix *dst_p, *src_p;
+			const struct prefix *dst_p, *src_p;
 			char buf[PREFIX_STRLEN];
 
 			srcdest_rnode_prefixes(rn, &dst_p, &src_p);
@@ -147,7 +147,7 @@ static void zebra_redistribute(struct zs
 
 /* Either advertise a route for redistribution to registered clients or */
 /* withdraw redistribution if add cannot be done for client */
-void redistribute_update(struct prefix *p, struct prefix *src_p,
+void redistribute_update(const struct prefix *p, const struct prefix *src_p,
 			 struct route_entry *re, struct route_entry *prev_re)
 {
 	struct listnode *node, *nnode;
@@ -216,7 +216,7 @@ void redistribute_update(struct prefix *
 	}
 }
 
-void redistribute_delete(struct prefix *p, struct prefix *src_p,
+void redistribute_delete(const struct prefix *p, const struct prefix *src_p,
 			 struct route_entry *re)
 {
 	struct listnode *node, *nnode;
@@ -274,7 +274,7 @@ void zebra_redistribute_add(ZAPI_HANDLER
 			__func__, zebra_route_string(client->proto), afi,
 			zebra_route_string(type), zvrf_id(zvrf), instance);
 
-	if (afi == 0 || afi > AFI_MAX) {
+	if (afi == 0 || afi >= AFI_MAX) {
 		zlog_warn("%s: Specified afi %d does not exist",
 			  __PRETTY_FUNCTION__, afi);
 		return;
@@ -320,7 +320,7 @@ void zebra_redistribute_delete(ZAPI_HAND
 	STREAM_GETC(msg, type);
 	STREAM_GETW(msg, instance);
 
-	if (afi == 0 || afi > AFI_MAX) {
+	if (afi == 0 || afi >= AFI_MAX) {
 		zlog_warn("%s: Specified afi %d does not exist",
 			  __PRETTY_FUNCTION__, afi);
 		return;
@@ -597,7 +597,7 @@ int zebra_del_import_table_entry(struct
 
 	rib_delete(afi, SAFI_UNICAST, re->vrf_id, ZEBRA_ROUTE_TABLE, re->table,
 		   re->flags, &p, NULL, re->ng.nexthop,
-		   zebrad.rtm_table_default, re->metric, false, NULL);
+		   zebrad.rtm_table_default, re->metric, re->distance, false);
 
 	return 0;
 }
@@ -715,7 +715,7 @@ int zebra_import_table_config(struct vty
 	return write;
 }
 
-void zebra_import_table_rm_update()
+void zebra_import_table_rm_update(const char *rmap)
 {
 	afi_t afi;
 	int i;
@@ -730,9 +730,8 @@ void zebra_import_table_rm_update()
 				continue;
 
 			rmap_name = zebra_get_import_table_route_map(afi, i);
-			if (!rmap_name)
-				return;
-
+			if ((!rmap_name) || (strcmp(rmap_name, rmap) != 0))
+				continue;
 			table = zebra_vrf_other_route_table(afi, i,
 							    VRF_DEFAULT);
 			for (rn = route_top(table); rn; rn = route_next(rn)) {
diff -urpN frr-frr-5.0.1/zebra/redistribute.h frr-frr-6.0/zebra/redistribute.h
--- frr-frr-5.0.1/zebra/redistribute.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/redistribute.h	2018-10-08 14:32:57.000000000 +0200
@@ -36,9 +36,11 @@ extern void zebra_redistribute_default_a
 extern void zebra_redistribute_default_delete(ZAPI_HANDLER_ARGS);
 /* ----------------- */
 
-extern void redistribute_update(struct prefix *, struct prefix *,
+extern void redistribute_update(const struct prefix *p,
+				const struct prefix *src_p,
 				struct route_entry *, struct route_entry *);
-extern void redistribute_delete(struct prefix *, struct prefix *,
+extern void redistribute_delete(const struct prefix *p,
+				const struct prefix *src_p,
 				struct route_entry *);
 
 extern void zebra_interface_up_update(struct interface *);
@@ -69,6 +71,5 @@ extern int is_zebra_import_table_enabled
 
 extern int zebra_import_table_config(struct vty *);
 
-extern void zebra_import_table_rm_update(void);
-
+extern void zebra_import_table_rm_update(const char *rmap);
 #endif /* _ZEBRA_REDISTRIBUTE_H */
diff -urpN frr-frr-5.0.1/zebra/rib.h frr-frr-6.0/zebra/rib.h
--- frr-frr-5.0.1/zebra/rib.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rib.h	2018-10-08 14:32:57.000000000 +0200
@@ -289,10 +289,8 @@ extern int rib_lookup_ipv4_route(struct
 
 extern int is_zebra_valid_kernel_table(uint32_t table_id);
 extern int is_zebra_main_routing_table(uint32_t table_id);
-extern int zebra_check_addr(struct prefix *p);
+extern int zebra_check_addr(const struct prefix *p);
 
-extern void rib_addnode(struct route_node *rn, struct route_entry *re,
-			int process);
 extern void rib_delnode(struct route_node *rn, struct route_entry *re);
 extern void rib_install_kernel(struct route_node *rn, struct route_entry *re,
 			       struct route_entry *old);
@@ -313,8 +311,8 @@ extern int rib_add_multipath(afi_t afi,
 extern void rib_delete(afi_t afi, safi_t safi, vrf_id_t vrf_id, int type,
 		       unsigned short instance, int flags, struct prefix *p,
 		       struct prefix_ipv6 *src_p, const struct nexthop *nh,
-		       uint32_t table_id, uint32_t metric, bool fromkernel,
-		       struct ethaddr *rmac);
+		       uint32_t table_id, uint32_t metric, uint8_t distance,
+		       bool fromkernel);
 
 extern struct route_entry *rib_match(afi_t afi, safi_t safi, vrf_id_t vrf_id,
 				     union g_addr *addr,
@@ -327,6 +325,8 @@ extern struct route_entry *rib_lookup_ip
 					   vrf_id_t vrf_id);
 
 extern void rib_update(vrf_id_t vrf_id, rib_update_event_t event);
+extern void rib_update_table(struct route_table *table,
+			     rib_update_event_t event);
 extern void rib_sweep_route(void);
 extern void rib_sweep_table(struct route_table *table);
 extern void rib_close_table(struct route_table *table);
@@ -451,10 +451,8 @@ DECLARE_HOOK(rib_update, (struct route_n
 
 
 extern void zebra_vty_init(void);
-extern int static_config(struct vty *vty, struct zebra_vrf *zvrf, afi_t afi,
-			 safi_t safi, const char *cmd);
-extern void static_config_install_delayed_routes(struct zebra_vrf *zvrf);
 
 extern pid_t pid;
 
+extern bool v6_rr_semantics;
 #endif /*_ZEBRA_RIB_H */
diff -urpN frr-frr-5.0.1/zebra/router-id.c frr-frr-6.0/zebra/router-id.c
--- frr-frr-5.0.1/zebra/router-id.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/router-id.c	2018-10-08 14:32:57.000000000 +0200
@@ -226,7 +226,7 @@ DEFUN (router_id,
 	rid.family = AF_INET;
 
 	if (argc > 2)
-		VRF_GET_ID(vrf_id, argv[idx_name]->arg);
+		VRF_GET_ID(vrf_id, argv[idx_name]->arg, false);
 
 	router_id_set(&rid, vrf_id);
 
@@ -251,7 +251,7 @@ DEFUN (no_router_id,
 	rid.family = AF_INET;
 
 	if (argc > 3)
-		VRF_GET_ID(vrf_id, argv[idx_name]->arg);
+		VRF_GET_ID(vrf_id, argv[idx_name]->arg, false);
 
 	router_id_set(&rid, vrf_id);
 
diff -urpN frr-frr-5.0.1/zebra/rt.h frr-frr-6.0/zebra/rt.h
--- frr-frr-5.0.1/zebra/rt.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rt.h	2018-10-08 14:32:57.000000000 +0200
@@ -42,11 +42,17 @@
  */
 
 
-enum southbound_results {
-	SOUTHBOUND_INSTALL_SUCCESS,
-	SOUTHBOUND_INSTALL_FAILURE,
-	SOUTHBOUND_DELETE_SUCCESS,
-	SOUTHBOUND_DELETE_FAILURE,
+enum dp_results {
+	DP_INSTALL_SUCCESS,
+	DP_INSTALL_FAILURE,
+	DP_DELETE_SUCCESS,
+	DP_DELETE_FAILURE,
+};
+
+enum dp_req_result {
+	DP_REQUEST_QUEUED,
+	DP_REQUEST_SUCCESS,
+	DP_REQUEST_FAILURE,
 };
 
 /*
@@ -60,18 +66,21 @@ enum southbound_results {
  * semantics so we will end up with a delete than
  * a re-add.
  */
-extern void kernel_route_rib(struct route_node *rn, struct prefix *p,
-			     struct prefix *src_p, struct route_entry *old,
-			     struct route_entry *new);
+extern enum dp_req_result kernel_route_rib(struct route_node *rn,
+					   const struct prefix *p,
+					   const struct prefix *src_p,
+					   struct route_entry *old,
+					   struct route_entry *new);
 
 /*
  * So route install/failure may not be immediately known
  * so let's separate it out and allow the result to
  * be passed back up.
  */
-extern void kernel_route_rib_pass_fail(struct route_node *rn, struct prefix *p,
+extern void kernel_route_rib_pass_fail(struct route_node *rn,
+				       const struct prefix *p,
 				       struct route_entry *re,
-				       enum southbound_results res);
+				       enum dp_results res);
 
 extern int kernel_address_add_ipv4(struct interface *, struct connected *);
 extern int kernel_address_delete_ipv4(struct interface *, struct connected *);
@@ -82,9 +91,9 @@ extern int kernel_neigh_update(int cmd,
 extern int kernel_interface_set_master(struct interface *master,
 				       struct interface *slave);
 
-extern void kernel_add_lsp(zebra_lsp_t *lsp);
-extern void kernel_upd_lsp(zebra_lsp_t *lsp);
-extern void kernel_del_lsp(zebra_lsp_t *lsp);
+extern enum dp_req_result kernel_add_lsp(zebra_lsp_t *lsp);
+extern enum dp_req_result kernel_upd_lsp(zebra_lsp_t *lsp);
+extern enum dp_req_result kernel_del_lsp(zebra_lsp_t *lsp);
 
 /*
  * Add the ability to pass back up the lsp install/delete
@@ -95,7 +104,7 @@ extern void kernel_del_lsp(zebra_lsp_t *
  * the install/failure to set/unset flags and to notify
  * as needed.
  */
-extern void kernel_lsp_pass_fail(zebra_lsp_t *lsp, enum southbound_results res);
+extern void kernel_lsp_pass_fail(zebra_lsp_t *lsp, enum dp_results res);
 
 extern int mpls_kernel_init(void);
 
@@ -113,7 +122,7 @@ extern int kernel_del_mac(struct interfa
 			  int local);
 
 extern int kernel_add_neigh(struct interface *ifp, struct ipaddr *ip,
-			    struct ethaddr *mac);
+			    struct ethaddr *mac, uint8_t flags);
 extern int kernel_del_neigh(struct interface *ifp, struct ipaddr *ip);
 
 /*
diff -urpN frr-frr-5.0.1/zebra/rt_netlink.c frr-frr-6.0/zebra/rt_netlink.c
--- frr-frr-5.0.1/zebra/rt_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rt_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -246,9 +246,35 @@ static vrf_id_t vrf_lookup_by_table(uint
 	return VRF_DEFAULT;
 }
 
+/**
+ * @parse_encap_mpls() - Parses encapsulated mpls attributes
+ * @tb:         Pointer to rtattr to look for nested items in.
+ * @labels:     Pointer to store labels in.
+ *
+ * Return:      Number of mpls labels found.
+ */
+static int parse_encap_mpls(struct rtattr *tb, mpls_label_t *labels)
+{
+	struct rtattr *tb_encap[MPLS_IPTUNNEL_MAX + 1] = {0};
+	mpls_lse_t *lses = NULL;
+	int num_labels = 0;
+	uint32_t ttl = 0;
+	uint32_t bos = 0;
+	uint32_t exp = 0;
+	mpls_label_t label = 0;
+
+	netlink_parse_rtattr_nested(tb_encap, MPLS_IPTUNNEL_MAX, tb);
+	lses = (mpls_lse_t *)RTA_DATA(tb_encap[MPLS_IPTUNNEL_DST]);
+	while (!bos && num_labels < MPLS_MAX_LABELS) {
+		mpls_lse_decode(lses[num_labels], &label, &ttl, &exp, &bos);
+		labels[num_labels++] = label;
+	}
+
+	return num_labels;
+}
+
 /* Looking up routing table by netlink interface. */
-static int netlink_route_change_read_unicast(struct sockaddr_nl *snl,
-					     struct nlmsghdr *h, ns_id_t ns_id,
+static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
 					     int startup)
 {
 	int len;
@@ -275,6 +301,10 @@ static int netlink_route_change_read_uni
 	void *src = NULL;     /* IPv6 srcdest   source prefix */
 	enum blackhole_type bh_type = BLACKHOLE_UNSPEC;
 
+	/* MPLS labels */
+	mpls_label_t labels[MPLS_MAX_LABELS] = {0};
+	int num_labels = 0;
+
 	rtm = NLMSG_DATA(h);
 
 	if (startup && h->nlmsg_type != RTM_NEWROUTE)
@@ -296,8 +326,12 @@ static int netlink_route_change_read_uni
 	}
 
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct rtmsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size %d %zu",
+			 __PRETTY_FUNCTION__, h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct rtmsg)));
 		return -1;
+	}
 
 	memset(tb, 0, sizeof tb);
 	netlink_parse_rtattr(tb, RTA_MAX, RTM_RTA(rtm), len);
@@ -381,29 +415,46 @@ static int netlink_route_change_read_uni
 
 	if (rtm->rtm_family == AF_INET) {
 		p.family = AF_INET;
+		if (rtm->rtm_dst_len > IPV4_MAX_BITLEN) {
+			zlog_err(
+				"Invalid destination prefix length: %u received from kernel route change",
+				rtm->rtm_dst_len);
+			return -1;
+		}
 		memcpy(&p.u.prefix4, dest, 4);
 		p.prefixlen = rtm->rtm_dst_len;
 
-		src_p.prefixlen =
-			0; // Forces debug below to not display anything
+		if (rtm->rtm_src_len != 0) {
+			char buf[PREFIX_STRLEN];
+			zlog_warn("unsupported IPv4 sourcedest route (dest %s vrf %u)",
+				  prefix2str(&p, buf, sizeof(buf)), vrf_id);
+			return 0;
+		}
+
+		/* Force debug below to not display anything for source */
+		src_p.prefixlen = 0;
 	} else if (rtm->rtm_family == AF_INET6) {
 		p.family = AF_INET6;
+		if (rtm->rtm_dst_len > IPV6_MAX_BITLEN) {
+			zlog_err(
+				"Invalid destination prefix length: %u received from kernel route change",
+				rtm->rtm_dst_len);
+			return -1;
+		}
 		memcpy(&p.u.prefix6, dest, 16);
 		p.prefixlen = rtm->rtm_dst_len;
 
 		src_p.family = AF_INET6;
+		if (rtm->rtm_src_len > IPV6_MAX_BITLEN) {
+			zlog_err(
+				"Invalid source prefix length: %u received from kernel route change",
+				rtm->rtm_src_len);
+			return -1;
+		}
 		memcpy(&src_p.prefix, src, 16);
 		src_p.prefixlen = rtm->rtm_src_len;
 	}
 
-	if (rtm->rtm_src_len != 0) {
-		char buf[PREFIX_STRLEN];
-		zlog_warn(
-			"unsupported IPv[4|6] sourcedest route (dest %s vrf %u)",
-			prefix2str(&p, buf, sizeof(buf)), vrf_id);
-		return 0;
-	}
-
 	/*
 	 * For ZEBRA_ROUTE_KERNEL types:
 	 *
@@ -480,14 +531,27 @@ static int netlink_route_change_read_uni
 				memcpy(&nh.gate, gate, sz);
 
 			if (index) {
-				ifp = if_lookup_by_index(index, VRF_UNKNOWN);
+				ifp = if_lookup_by_index_per_ns(
+						zebra_ns_lookup(ns_id),
+						index);
 				if (ifp)
 					nh_vrf_id = ifp->vrf_id;
 			}
 			nh.vrf_id = nh_vrf_id;
 
+			if (tb[RTA_ENCAP] && tb[RTA_ENCAP_TYPE]
+			    && *(uint16_t *)RTA_DATA(tb[RTA_ENCAP_TYPE])
+				       == LWTUNNEL_ENCAP_MPLS) {
+				num_labels =
+					parse_encap_mpls(tb[RTA_ENCAP], labels);
+			}
+
+			if (num_labels)
+				nexthop_add_labels(&nh, ZEBRA_LSP_STATIC,
+						   num_labels, labels);
+
 			rib_add(afi, SAFI_UNICAST, vrf_id, proto, 0, flags, &p,
-				NULL, &nh, table, metric, mtu, distance, tag);
+				&src_p, &nh, table, metric, mtu, distance, tag);
 		} else {
 			/* This is a multipath route */
 
@@ -510,6 +574,7 @@ static int netlink_route_change_read_uni
 			re->tag = tag;
 
 			for (;;) {
+				struct nexthop *nh = NULL;
 				vrf_id_t nh_vrf_id;
 				if (len < (int)sizeof(*rtnh)
 				    || rtnh->rtnh_len > len)
@@ -523,8 +588,9 @@ static int netlink_route_change_read_uni
 					 * using the last one looked
 					 * up right now
 					 */
-					ifp = if_lookup_by_index(index,
-								 VRF_UNKNOWN);
+					ifp = if_lookup_by_index_per_ns(
+							zebra_ns_lookup(ns_id),
+							index);
 					if (ifp)
 						nh_vrf_id = ifp->vrf_id;
 					else {
@@ -546,35 +612,49 @@ static int netlink_route_change_read_uni
 					if (tb[RTA_GATEWAY])
 						gate = RTA_DATA(
 							tb[RTA_GATEWAY]);
+					if (tb[RTA_ENCAP] && tb[RTA_ENCAP_TYPE]
+					    && *(uint16_t *)RTA_DATA(
+						       tb[RTA_ENCAP_TYPE])
+						       == LWTUNNEL_ENCAP_MPLS) {
+						num_labels = parse_encap_mpls(
+							tb[RTA_ENCAP], labels);
+					}
 				}
 
 				if (gate) {
 					if (rtm->rtm_family == AF_INET) {
 						if (index)
-							route_entry_nexthop_ipv4_ifindex_add(
+							nh = route_entry_nexthop_ipv4_ifindex_add(
 								re, gate,
 								prefsrc, index,
 								nh_vrf_id);
 						else
-							route_entry_nexthop_ipv4_add(
+							nh = route_entry_nexthop_ipv4_add(
 								re, gate,
 								prefsrc,
 								nh_vrf_id);
 					} else if (rtm->rtm_family
 						   == AF_INET6) {
 						if (index)
-							route_entry_nexthop_ipv6_ifindex_add(
+							nh = route_entry_nexthop_ipv6_ifindex_add(
 								re, gate, index,
 								nh_vrf_id);
 						else
-							route_entry_nexthop_ipv6_add(
+							nh = route_entry_nexthop_ipv6_add(
 								re, gate,
 								nh_vrf_id);
 					}
 				} else
-					route_entry_nexthop_ifindex_add(
+					nh = route_entry_nexthop_ifindex_add(
 						re, index, nh_vrf_id);
 
+				if (nh && num_labels)
+					nexthop_add_labels(nh, ZEBRA_LSP_STATIC,
+							   num_labels, labels);
+
+				if (rtnh->rtnh_len == 0)
+					break;
+
 				len -= NLMSG_ALIGN(rtnh->rtnh_len);
 				rtnh = RTNH_NEXT(rtnh);
 			}
@@ -585,8 +665,8 @@ static int netlink_route_change_read_uni
 			if (re->nexthop_num == 0)
 				XFREE(MTYPE_RE, re);
 			else
-				rib_add_multipath(afi, SAFI_UNICAST, &p, NULL,
-						  re);
+				rib_add_multipath(afi, SAFI_UNICAST, &p,
+						  &src_p, re);
 		}
 	} else {
 		if (!tb[RTA_MULTIPATH]) {
@@ -618,12 +698,14 @@ static int netlink_route_change_read_uni
 			if (gate)
 				memcpy(&nh.gate, gate, sz);
 			rib_delete(afi, SAFI_UNICAST, vrf_id, proto, 0, flags,
-				   &p, NULL, &nh, table, metric, true, NULL);
+				   &p, &src_p, &nh, table, metric, distance,
+				   true);
 		} else {
 			/* XXX: need to compare the entire list of nexthops
 			 * here for NLM_F_APPEND stupidity */
 			rib_delete(afi, SAFI_UNICAST, vrf_id, proto, 0, flags,
-				   &p, NULL, NULL, table, metric, true, NULL);
+				   &p, &src_p, NULL, table, metric, distance,
+				   true);
 		}
 	}
 
@@ -632,8 +714,7 @@ static int netlink_route_change_read_uni
 
 static struct mcast_route_data *mroute = NULL;
 
-static int netlink_route_change_read_multicast(struct sockaddr_nl *snl,
-					       struct nlmsghdr *h,
+static int netlink_route_change_read_multicast(struct nlmsghdr *h,
 					       ns_id_t ns_id, int startup)
 {
 	int len;
@@ -696,6 +777,9 @@ static int netlink_route_change_read_mul
 			oif[oif_count] = rtnh->rtnh_ifindex;
 			oif_count++;
 
+			if (rtnh->rtnh_len == 0)
+				break;
+
 			len -= NLMSG_ALIGN(rtnh->rtnh_len);
 			rtnh = RTNH_NEXT(rtnh);
 		}
@@ -709,21 +793,22 @@ static int netlink_route_change_read_mul
 			ifp = if_lookup_by_index(oif[count], vrf);
 			char temp[256];
 
-			sprintf(temp, "%s ", ifp->name);
+			sprintf(temp, "%s(%d) ", ifp ? ifp->name : "Unknown",
+				oif[count]);
 			strcat(oif_list, temp);
 		}
 		struct zebra_vrf *zvrf = zebra_vrf_lookup_by_id(vrf);
 		ifp = if_lookup_by_index(iif, vrf);
-		zlog_debug(
-			"MCAST VRF: %s(%d) %s (%s,%s) IIF: %s OIF: %s jiffies: %lld",
-			zvrf->vrf->name, vrf, nl_msg_type_to_str(h->nlmsg_type),
-			sbuf, gbuf, ifp->name, oif_list, m->lastused);
+		zlog_debug("MCAST VRF: %s(%d) %s (%s,%s) IIF: %s(%d) OIF: %s jiffies: %lld",
+			   zvrf->vrf->name, vrf,
+			   nl_msg_type_to_str(h->nlmsg_type),
+			   sbuf, gbuf, ifp ? ifp->name : "Unknown", iif,
+			   oif_list, m->lastused);
 	}
 	return 0;
 }
 
-int netlink_route_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			 ns_id_t ns_id, int startup)
+int netlink_route_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct rtmsg *rtm;
@@ -736,6 +821,13 @@ int netlink_route_change(struct sockaddr
 		return 0;
 	}
 
+	if (!(rtm->rtm_family == AF_INET || rtm->rtm_family == AF_INET6)) {
+		zlog_warn(
+			"Invalid address family: %u received from kernel route change: %u",
+			rtm->rtm_family, h->nlmsg_type);
+		return 0;
+	}
+
 	/* Connected route. */
 	if (IS_ZEBRA_DEBUG_KERNEL)
 		zlog_debug("%s %s %s proto %s NS %u",
@@ -744,19 +836,20 @@ int netlink_route_change(struct sockaddr
 			   nl_rttype_to_str(rtm->rtm_type),
 			   nl_rtproto_to_str(rtm->rtm_protocol), ns_id);
 
-	/* We don't care about change notifications for the MPLS table. */
-	/* TODO: Revisit this. */
-	if (rtm->rtm_family == AF_MPLS)
-		return 0;
 
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct rtmsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size: %d %zu",
+			 __PRETTY_FUNCTION__,
+			 h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct rtmsg)));
 		return -1;
+	}
 
 	if (rtm->rtm_type == RTN_MULTICAST)
-		netlink_route_change_read_multicast(snl, h, ns_id, startup);
+		netlink_route_change_read_multicast(h, ns_id, startup);
 	else
-		netlink_route_change_read_unicast(snl, h, ns_id, startup);
+		netlink_route_change_read_unicast(h, ns_id, startup);
 	return 0;
 }
 
@@ -1238,14 +1331,6 @@ static void _netlink_route_build_multipa
 				"netlink_route_multipath() (%s): "
 				"nexthop via if %u",
 				routedesc, nexthop->ifindex);
-	} else if (nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX) {
-		if (IS_ZEBRA_DEBUG_KERNEL)
-			zlog_debug(
-				"netlink_route_multipath() (%s): "
-				"nexthop via if %u",
-				routedesc, nexthop->ifindex);
-	} else {
-		rtnh->rtnh_ifindex = 0;
 	}
 }
 
@@ -1289,8 +1374,8 @@ _netlink_mpls_build_multipath(const char
  * @param zvrf: The vrf we are in
  * @param tableid: The table we are working on
  */
-static void _netlink_route_debug(int cmd, struct prefix *p,
-				 int family, struct zebra_vrf *zvrf,
+static void _netlink_route_debug(int cmd, const struct prefix *p,
+				 int family, vrf_id_t vrfid,
 				 uint32_t tableid)
 {
 	if (IS_ZEBRA_DEBUG_KERNEL) {
@@ -1299,7 +1384,7 @@ static void _netlink_route_debug(int cmd
 			"netlink_route_multipath(): %s %s vrf %u(%u)",
 			nl_msg_type_to_str(cmd),
 			prefix2str(p, buf, sizeof(buf)),
-			zvrf_id(zvrf), tableid);
+			vrfid, tableid);
 	}
 }
 
@@ -1321,8 +1406,7 @@ static int netlink_neigh_update(int cmd,
 
 	struct zebra_ns *zns = zebra_ns_lookup(ns_id);
 
-	memset(&req.n, 0, sizeof(req.n));
-	memset(&req.ndm, 0, sizeof(req.ndm));
+	memset(&req, 0, sizeof(req));
 
 	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ndmsg));
 	req.n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;
@@ -1343,8 +1427,9 @@ static int netlink_neigh_update(int cmd,
 
 /* Routing table change via netlink interface. */
 /* Update flag indicates whether this is a "replace" or not. */
-static int netlink_route_multipath(int cmd, struct prefix *p,
-				   struct prefix *src_p, struct route_entry *re,
+static int netlink_route_multipath(int cmd, const struct prefix *p,
+				   const struct prefix *src_p,
+				   struct route_entry *re,
 				   int update)
 {
 	int bytelen;
@@ -1419,7 +1504,7 @@ static int netlink_route_multipath(int c
 		addattr32(&req.n, sizeof req, RTA_TABLE, re->table);
 	}
 
-	_netlink_route_debug(cmd, p, family, zvrf, re->table);
+	_netlink_route_debug(cmd, p, family, zvrf_id(zvrf), re->table);
 
 	/*
 	 * If we are not updating the route and we have received
@@ -1667,6 +1752,7 @@ skip:
 
 int kernel_get_ipmr_sg_stats(struct zebra_vrf *zvrf, void *in)
 {
+	uint32_t actual_table;
 	int suc = 0;
 	struct mcast_route_data *mr = (struct mcast_route_data *)in;
 	struct {
@@ -1679,8 +1765,7 @@ int kernel_get_ipmr_sg_stats(struct zebr
 	struct zebra_ns *zns;
 
 	zns = zvrf->zns;
-	memset(&req.n, 0, sizeof(req.n));
-	memset(&req.ndm, 0, sizeof(req.ndm));
+	memset(&req, 0, sizeof(req));
 
 	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ndmsg));
 	req.n.nlmsg_flags = NLM_F_REQUEST;
@@ -1693,7 +1778,23 @@ int kernel_get_ipmr_sg_stats(struct zebr
 	addattr_l(&req.n, sizeof(req), RTA_OIF, &mroute->ifindex, 4);
 	addattr_l(&req.n, sizeof(req), RTA_SRC, &mroute->sg.src.s_addr, 4);
 	addattr_l(&req.n, sizeof(req), RTA_DST, &mroute->sg.grp.s_addr, 4);
-	addattr_l(&req.n, sizeof(req), RTA_TABLE, &zvrf->table_id, 4);
+	/*
+	 * What?
+	 *
+	 * So during the namespace cleanup we started storing
+	 * the zvrf table_id for the default table as RT_TABLE_MAIN
+	 * which is what the normal routing table for ip routing is.
+	 * This change caused this to break our lookups of sg data
+	 * because prior to this change the zvrf->table_id was 0
+	 * and when the pim multicast kernel code saw a 0,
+	 * it was auto-translated to RT_TABLE_DEFAULT.  But since
+	 * we are now passing in RT_TABLE_MAIN there is no auto-translation
+	 * and the kernel goes screw you and the delicious cookies you
+	 * are trying to give me.  So now we have this little hack.
+	 */
+	actual_table = (zvrf->table_id == RT_TABLE_MAIN) ? RT_TABLE_DEFAULT :
+		zvrf->table_id;
+	addattr_l(&req.n, sizeof(req), RTA_TABLE, &actual_table, 4);
 
 	suc = netlink_talk(netlink_route_change_read_multicast, &req.n,
 			   &zns->netlink_cmd, zns, 0);
@@ -1702,16 +1803,18 @@ int kernel_get_ipmr_sg_stats(struct zebr
 	return suc;
 }
 
-void kernel_route_rib(struct route_node *rn, struct prefix *p,
-		      struct prefix *src_p, struct route_entry *old,
-		      struct route_entry *new)
+enum dp_req_result kernel_route_rib(struct route_node *rn,
+				    const struct prefix *p,
+				    const struct prefix *src_p,
+				    struct route_entry *old,
+				    struct route_entry *new)
 {
 	int ret = 0;
 
 	assert(old || new);
 
 	if (new) {
-		if (p->family == AF_INET)
+		if (p->family == AF_INET || v6_rr_semantics)
 			ret = netlink_route_multipath(RTM_NEWROUTE, p, src_p,
 						      new, (old) ? 1 : 0);
 		else {
@@ -1734,18 +1837,20 @@ void kernel_route_rib(struct route_node
 						      new, 0);
 		}
 		kernel_route_rib_pass_fail(rn, p, new,
-					   (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-						  : SOUTHBOUND_INSTALL_FAILURE);
-		return;
+					   (!ret) ? DP_INSTALL_SUCCESS
+						  : DP_INSTALL_FAILURE);
+		return DP_REQUEST_SUCCESS;
 	}
 
 	if (old) {
 		ret = netlink_route_multipath(RTM_DELROUTE, p, src_p, old, 0);
 
 		kernel_route_rib_pass_fail(rn, p, old,
-					   (!ret) ? SOUTHBOUND_DELETE_SUCCESS
-						  : SOUTHBOUND_DELETE_FAILURE);
+					   (!ret) ? DP_DELETE_SUCCESS
+						  : DP_DELETE_FAILURE);
 	}
+
+	return DP_REQUEST_SUCCESS;
 }
 
 int kernel_neigh_update(int add, int ifindex, uint32_t addr, char *lla,
@@ -1772,8 +1877,7 @@ static int netlink_vxlan_flood_list_upda
 	struct zebra_vrf *zvrf = zebra_vrf_lookup_by_id(ifp->vrf_id);
 
 	zns = zvrf->zns;
-	memset(&req.n, 0, sizeof(req.n));
-	memset(&req.ndm, 0, sizeof(req.ndm));
+	memset(&req, 0, sizeof(req));
 
 	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ndmsg));
 	req.n.nlmsg_flags = NLM_F_REQUEST;
@@ -1826,8 +1930,7 @@ int kernel_del_vtep(vni_t vni, struct in
 	((struct rtattr *)(((char *)(r)) + NLMSG_ALIGN(sizeof(struct ndmsg))))
 #endif
 
-static int netlink_macfdb_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				 int len, ns_id_t ns_id)
+static int netlink_macfdb_change(struct nlmsghdr *h, int len, ns_id_t ns_id)
 {
 	struct ndmsg *ndm;
 	struct interface *ifp;
@@ -1962,8 +2065,7 @@ static int netlink_macfdb_change(struct
 	return zebra_vxlan_local_mac_del(ifp, br_if, &mac, vid);
 }
 
-static int netlink_macfdb_table(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				ns_id_t ns_id, int startup)
+static int netlink_macfdb_table(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct ndmsg *ndm;
@@ -1981,7 +2083,7 @@ static int netlink_macfdb_table(struct s
 	if (ndm->ndm_family != AF_BRIDGE)
 		return 0;
 
-	return netlink_macfdb_change(snl, h, len, ns_id);
+	return netlink_macfdb_change(h, len, ns_id);
 }
 
 /* Request for MAC FDB information from the kernel */
@@ -2088,8 +2190,7 @@ static int netlink_macfdb_update(struct
 		return -1;
 	}
 
-	memset(&req.n, 0, sizeof(req.n));
-	memset(&req.ndm, 0, sizeof(req.ndm));
+	memset(&req, 0, sizeof(req));
 
 	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ndmsg));
 	req.n.nlmsg_flags = NLM_F_REQUEST;
@@ -2138,8 +2239,7 @@ static int netlink_macfdb_update(struct
 	(NUD_PERMANENT | NUD_NOARP | NUD_REACHABLE | NUD_PROBE | NUD_STALE     \
 	 | NUD_DELAY)
 
-static int netlink_ipneigh_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				  int len, ns_id_t ns_id)
+static int netlink_ipneigh_change(struct nlmsghdr *h, int len, ns_id_t ns_id)
 {
 	struct ndmsg *ndm;
 	struct interface *ifp;
@@ -2152,6 +2252,7 @@ static int netlink_ipneigh_change(struct
 	char buf2[INET6_ADDRSTRLEN];
 	int mac_present = 0;
 	uint8_t ext_learned;
+	uint8_t router_flag;
 
 	ndm = NLMSG_DATA(h);
 
@@ -2242,6 +2343,7 @@ static int netlink_ipneigh_change(struct
 		}
 
 		ext_learned = (ndm->ndm_flags & NTF_EXT_LEARNED) ? 1 : 0;
+		router_flag = (ndm->ndm_flags & NTF_ROUTER) ? 1 : 0;
 
 		if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug(
@@ -2264,7 +2366,7 @@ static int netlink_ipneigh_change(struct
 		if (ndm->ndm_state & NUD_VALID)
 			return zebra_vxlan_handle_kernel_neigh_update(
 				ifp, link_if, &ip, &mac, ndm->ndm_state,
-				ext_learned);
+				ext_learned, router_flag);
 
 		return zebra_vxlan_handle_kernel_neigh_del(ifp, link_if, &ip);
 	}
@@ -2282,8 +2384,7 @@ static int netlink_ipneigh_change(struct
 	return zebra_vxlan_handle_kernel_neigh_del(ifp, link_if, &ip);
 }
 
-static int netlink_neigh_table(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			       ns_id_t ns_id, int startup)
+static int netlink_neigh_table(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	int len;
 	struct ndmsg *ndm;
@@ -2301,7 +2402,7 @@ static int netlink_neigh_table(struct so
 	if (ndm->ndm_family != AF_INET && ndm->ndm_family != AF_INET6)
 		return 0;
 
-	return netlink_neigh_change(snl, h, len);
+	return netlink_neigh_change(h, len);
 }
 
 /* Request for IP neighbor information from the kernel */
@@ -2361,8 +2462,7 @@ int netlink_neigh_read_for_vlan(struct z
 	return ret;
 }
 
-int netlink_neigh_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			 ns_id_t ns_id)
+int netlink_neigh_change(struct nlmsghdr *h, ns_id_t ns_id)
 {
 	int len;
 	struct ndmsg *ndm;
@@ -2372,25 +2472,36 @@ int netlink_neigh_change(struct sockaddr
 
 	/* Length validity. */
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct ndmsg));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size %d %zu",
+			 __PRETTY_FUNCTION__, h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct ndmsg)));
 		return -1;
+	}
 
 	/* Is this a notification for the MAC FDB or IP neighbor table? */
 	ndm = NLMSG_DATA(h);
 	if (ndm->ndm_family == AF_BRIDGE)
-		return netlink_macfdb_change(snl, h, len, ns_id);
+		return netlink_macfdb_change(h, len, ns_id);
 
 	if (ndm->ndm_type != RTN_UNICAST)
 		return 0;
 
 	if (ndm->ndm_family == AF_INET || ndm->ndm_family == AF_INET6)
-		return netlink_ipneigh_change(snl, h, len, ns_id);
+		return netlink_ipneigh_change(h, len, ns_id);
+	else {
+		zlog_warn(
+			"Invalid address family: %u received from kernel neighbor change: %u",
+			ndm->ndm_family, h->nlmsg_type);
+		return 0;
+	}
 
 	return 0;
 }
 
 static int netlink_neigh_update2(struct interface *ifp, struct ipaddr *ip,
-				 struct ethaddr *mac, uint32_t flags, int cmd)
+				 struct ethaddr *mac, uint8_t flags,
+				 uint16_t state, int cmd)
 {
 	struct {
 		struct nlmsghdr n;
@@ -2405,8 +2516,7 @@ static int netlink_neigh_update2(struct
 	struct zebra_vrf *zvrf = zebra_vrf_lookup_by_id(ifp->vrf_id);
 
 	zns = zvrf->zns;
-	memset(&req.n, 0, sizeof(req.n));
-	memset(&req.ndm, 0, sizeof(req.ndm));
+	memset(&req, 0, sizeof(req));
 
 	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ndmsg));
 	req.n.nlmsg_flags = NLM_F_REQUEST;
@@ -2414,11 +2524,10 @@ static int netlink_neigh_update2(struct
 		req.n.nlmsg_flags |= (NLM_F_CREATE | NLM_F_REPLACE);
 	req.n.nlmsg_type = cmd; // RTM_NEWNEIGH or RTM_DELNEIGH
 	req.ndm.ndm_family = IS_IPADDR_V4(ip) ? AF_INET : AF_INET6;
-	req.ndm.ndm_state = flags;
+	req.ndm.ndm_state = state;
 	req.ndm.ndm_ifindex = ifp->ifindex;
 	req.ndm.ndm_type = RTN_UNICAST;
-	req.ndm.ndm_flags = NTF_EXT_LEARNED;
-
+	req.ndm.ndm_flags = flags;
 
 	ipa_len = IS_IPADDR_V4(ip) ? IPV4_MAX_BYTELEN : IPV6_MAX_BYTELEN;
 	addattr_l(&req.n, sizeof(req), NDA_DST, &ip->ip.addr, ipa_len);
@@ -2426,12 +2535,12 @@ static int netlink_neigh_update2(struct
 		addattr_l(&req.n, sizeof(req), NDA_LLADDR, mac, 6);
 
 	if (IS_ZEBRA_DEBUG_KERNEL)
-		zlog_debug("Tx %s family %s IF %s(%u) Neigh %s MAC %s",
+		zlog_debug("Tx %s family %s IF %s(%u) Neigh %s MAC %s flags 0x%x",
 			   nl_msg_type_to_str(cmd),
 			   nl_family_to_str(req.ndm.ndm_family), ifp->name,
 			   ifp->ifindex, ipaddr2str(ip, buf, sizeof(buf)),
 			   mac ? prefix_mac2str(mac, buf2, sizeof(buf2))
-			       : "null");
+			       : "null", flags);
 
 	return netlink_talk(netlink_talk_filter, &req.n, &zns->netlink_cmd, zns,
 			    0);
@@ -2452,14 +2561,15 @@ int kernel_del_mac(struct interface *ifp
 }
 
 int kernel_add_neigh(struct interface *ifp, struct ipaddr *ip,
-		     struct ethaddr *mac)
+		     struct ethaddr *mac, uint8_t flags)
 {
-	return netlink_neigh_update2(ifp, ip, mac, NUD_NOARP, RTM_NEWNEIGH);
+	return netlink_neigh_update2(ifp, ip, mac, flags,
+				     NUD_NOARP, RTM_NEWNEIGH);
 }
 
 int kernel_del_neigh(struct interface *ifp, struct ipaddr *ip)
 {
-	return netlink_neigh_update2(ifp, ip, NULL, 0, RTM_DELNEIGH);
+	return netlink_neigh_update2(ifp, ip, NULL, 0, 0, RTM_DELNEIGH);
 }
 
 /*
diff -urpN frr-frr-5.0.1/zebra/rt_netlink.h frr-frr-6.0/zebra/rt_netlink.h
--- frr-frr-5.0.1/zebra/rt_netlink.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rt_netlink.h	2018-10-08 14:32:57.000000000 +0200
@@ -59,12 +59,10 @@ void rt_netlink_init(void);
 
 extern int netlink_mpls_multipath(int cmd, zebra_lsp_t *lsp);
 
-extern int netlink_route_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				ns_id_t ns_id, int startup);
+extern int netlink_route_change(struct nlmsghdr *h, ns_id_t ns_id, int startup);
 extern int netlink_route_read(struct zebra_ns *zns);
 
-extern int netlink_neigh_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				ns_id_t ns_id);
+extern int netlink_neigh_change(struct nlmsghdr *h, ns_id_t ns_id);
 extern int netlink_macfdb_read(struct zebra_ns *zns);
 extern int netlink_macfdb_read_for_bridge(struct zebra_ns *zns,
 					  struct interface *ifp,
diff -urpN frr-frr-5.0.1/zebra/rt_socket.c frr-frr-6.0/zebra/rt_socket.c
--- frr-frr-5.0.1/zebra/rt_socket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rt_socket.c	2018-10-08 14:32:57.000000000 +0200
@@ -33,6 +33,7 @@
 #include "log.h"
 #include "privs.h"
 #include "vxlan.h"
+#include "lib_errors.h"
 
 #include "zebra/debug.h"
 #include "zebra/rib.h"
@@ -88,7 +89,8 @@ static int kernel_rtm_add_labels(struct
 #endif
 
 /* Interface between zebra message and rtm message. */
-static int kernel_rtm_ipv4(int cmd, struct prefix *p, struct route_entry *re)
+static int kernel_rtm_ipv4(int cmd, const struct prefix *p,
+			   struct route_entry *re)
 
 {
 	struct sockaddr_in *mask = NULL;
@@ -210,7 +212,8 @@ static int kernel_rtm_ipv4(int cmd, stru
 			 */
 			case ZEBRA_ERR_RTEXIST:
 				if (cmd != RTM_ADD)
-					zlog_err(
+					flog_err(
+						LIB_ERR_SYSTEM_CALL,
 						"%s: rtm_write() returned %d for command %d",
 						__func__, error, cmd);
 				continue;
@@ -223,7 +226,8 @@ static int kernel_rtm_ipv4(int cmd, stru
 			case ZEBRA_ERR_RTNOEXIST:
 			case ZEBRA_ERR_RTUNREACH:
 			default:
-				zlog_err(
+				flog_err(
+					LIB_ERR_SYSTEM_CALL,
 					"%s: %s: rtm_write() unexpectedly returned %d for command %s",
 					__func__,
 					prefix2str(p, prefix_buf,
@@ -272,7 +276,8 @@ static int sin6_masklen(struct in6_addr
 #endif /* SIN6_LEN */
 
 /* Interface between zebra message and rtm message. */
-static int kernel_rtm_ipv6(int cmd, struct prefix *p, struct route_entry *re)
+static int kernel_rtm_ipv6(int cmd, const struct prefix *p,
+			   struct route_entry *re)
 {
 	struct sockaddr_in6 *mask;
 	struct sockaddr_in6 sin_dest, sin_mask, sin_gate;
@@ -374,7 +379,7 @@ static int kernel_rtm_ipv6(int cmd, stru
 	return 0; /*XXX*/
 }
 
-static int kernel_rtm(int cmd, struct prefix *p, struct route_entry *re)
+static int kernel_rtm(int cmd, const struct prefix *p, struct route_entry *re)
 {
 	switch (PREFIX_FAMILY(p)) {
 	case AF_INET:
@@ -385,40 +390,42 @@ static int kernel_rtm(int cmd, struct pr
 	return 0;
 }
 
-void kernel_route_rib(struct route_node *rn, struct prefix *p,
-		      struct prefix *src_p, struct route_entry *old,
-		      struct route_entry *new)
+enum dp_req_result kernel_route_rib(struct route_node *rn,
+				    const struct prefix *p,
+				    const struct prefix *src_p,
+				    struct route_entry *old,
+				    struct route_entry *new)
 {
 	int route = 0;
 
 	if (src_p && src_p->prefixlen) {
-		zlog_err("route add: IPv6 sourcedest routes unsupported!");
-		return;
+		zlog_warn("%s: IPv6 sourcedest routes unsupported!", __func__);
+		return DP_REQUEST_FAILURE;
 	}
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&zserv_privs) {
 
-	if (old)
-		route |= kernel_rtm(RTM_DELETE, p, old);
+		if (old)
+			route |= kernel_rtm(RTM_DELETE, p, old);
 
-	if (new)
-		route |= kernel_rtm(RTM_ADD, p, new);
+		if (new)
+			route |= kernel_rtm(RTM_ADD, p, new);
 
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	}
 
 	if (new) {
 		kernel_route_rib_pass_fail(
 			rn, p, new,
-			(!route) ? SOUTHBOUND_INSTALL_SUCCESS
-				 : SOUTHBOUND_INSTALL_FAILURE);
+			(!route) ? DP_INSTALL_SUCCESS
+				 : DP_INSTALL_FAILURE);
 	} else {
 		kernel_route_rib_pass_fail(rn, p, old,
 					   (!route)
-						   ? SOUTHBOUND_DELETE_SUCCESS
-						   : SOUTHBOUND_DELETE_FAILURE);
+						   ? DP_DELETE_SUCCESS
+						   : DP_DELETE_FAILURE);
 	}
+
+	return DP_REQUEST_SUCCESS;
 }
 
 int kernel_neigh_update(int add, int ifindex, uint32_t addr, char *lla,
@@ -456,7 +463,7 @@ int kernel_del_mac(struct interface *ifp
 }
 
 int kernel_add_neigh(struct interface *ifp, struct ipaddr *ip,
-		     struct ethaddr *mac)
+		     struct ethaddr *mac, uint8_t flags)
 {
 	return 0;
 }
diff -urpN frr-frr-5.0.1/zebra/rtadv.c frr-frr-6.0/zebra/rtadv.c
--- frr-frr-5.0.1/zebra/rtadv.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rtadv.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "privs.h"
 #include "vrf.h"
 #include "ns.h"
+#include "lib_errors.h"
 
 #include "zebra/interface.h"
 #include "zebra/rtadv.h"
@@ -123,7 +124,7 @@ static int rtadv_recv_packet(struct zebr
 	if (ret < 0)
 		return ret;
 
-	for (cmsgptr = ZCMSG_FIRSTHDR(&msg); cmsgptr != NULL;
+	for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;
 	     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {
 		/* I want interface index which this packet comes from. */
 		if (cmsgptr->cmsg_level == IPPROTO_IPV6
@@ -180,7 +181,7 @@ static void rtadv_send_packet(int sock,
 		adata = calloc(1, CMSG_SPACE(sizeof(struct in6_pktinfo)));
 
 		if (adata == NULL) {
-			zlog_err(
+			zlog_warn(
 				"rtadv_send_packet: can't malloc control data");
 			exit(-1);
 		}
@@ -362,7 +363,7 @@ static void rtadv_send_packet(int sock,
 	iov.iov_base = buf;
 	iov.iov_len = len;
 
-	cmsgptr = ZCMSG_FIRSTHDR(&msg);
+	cmsgptr = CMSG_FIRSTHDR(&msg);
 	cmsgptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
 	cmsgptr->cmsg_level = IPPROTO_IPV6;
 	cmsgptr->cmsg_type = IPV6_PKTINFO;
@@ -373,9 +374,10 @@ static void rtadv_send_packet(int sock,
 
 	ret = sendmsg(sock, &msg, 0);
 	if (ret < 0) {
-		zlog_err("%s(%u): Tx RA failed, socket %u error %d (%s)",
-			 ifp->name, ifp->ifindex, sock, errno,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "%s(%u): Tx RA failed, socket %u error %d (%s)",
+			     ifp->name, ifp->ifindex, sock, errno,
+			     safe_strerror(errno));
 	} else
 		zif->ra_sent++;
 }
@@ -518,7 +520,7 @@ static void rtadv_process_advert(uint8_t
 
 	/* Create entry for neighbor if not known. */
 	p.family = AF_INET6;
-	IPV6_ADDR_COPY(&p.u.prefix, &addr->sin6_addr);
+	IPV6_ADDR_COPY(&p.u.prefix6, &addr->sin6_addr);
 	p.prefixlen = IPV6_MAX_PREFIXLEN;
 
 	if (!nbr_connected_check(ifp, &p))
@@ -624,19 +626,15 @@ static int rtadv_read(struct thread *thr
 
 static int rtadv_make_socket(ns_id_t ns_id)
 {
-	int sock;
+	int sock = -1;
 	int ret = 0;
 	struct icmp6_filter filter;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("rtadv_make_socket: could not raise privs, %s",
-			 safe_strerror(errno));
-
-	sock = ns_socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, ns_id);
-
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("rtadv_make_socket: could not lower privs, %s",
-			 safe_strerror(errno));
+	frr_elevate_privs(&zserv_privs) {
+
+		sock = ns_socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, ns_id);
+
+	}
 
 	if (sock < 0) {
 		return -1;
diff -urpN frr-frr-5.0.1/zebra/rule_netlink.c frr-frr-6.0/zebra/rule_netlink.c
--- frr-frr-5.0.1/zebra/rule_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rule_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -142,27 +142,31 @@ static int netlink_rule_update(int cmd,
  * goes in the rule to denote relative ordering; it may or may not be the
  * same as the rule's user-defined sequence number.
  */
-void kernel_add_pbr_rule(struct zebra_pbr_rule *rule)
+enum dp_req_result kernel_add_pbr_rule(struct zebra_pbr_rule *rule)
 {
 	int ret = 0;
 
 	ret = netlink_rule_update(RTM_NEWRULE, rule);
 	kernel_pbr_rule_add_del_status(rule,
-				       (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-					      : SOUTHBOUND_INSTALL_FAILURE);
+				       (!ret) ? DP_INSTALL_SUCCESS
+					      : DP_INSTALL_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 /*
  * Uninstall specified rule for a specific interface.
  */
-void kernel_del_pbr_rule(struct zebra_pbr_rule *rule)
+enum dp_req_result kernel_del_pbr_rule(struct zebra_pbr_rule *rule)
 {
 	int ret = 0;
 
 	ret = netlink_rule_update(RTM_DELRULE, rule);
 	kernel_pbr_rule_add_del_status(rule,
-				       (!ret) ? SOUTHBOUND_DELETE_SUCCESS
-					      : SOUTHBOUND_DELETE_FAILURE);
+				       (!ret) ? DP_DELETE_SUCCESS
+					      : DP_DELETE_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 /*
@@ -172,8 +176,7 @@ void kernel_del_pbr_rule(struct zebra_pb
  * notification of interest. The expectation is that if this corresponds
  * to a PBR rule added by FRR, it will be readded.
  */
-int netlink_rule_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-			ns_id_t ns_id, int startup)
+int netlink_rule_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
 	struct zebra_ns *zns;
 	struct fib_rule_hdr *frh;
@@ -193,12 +196,20 @@ int netlink_rule_change(struct sockaddr_
 		return 0;
 
 	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct fib_rule_hdr));
-	if (len < 0)
+	if (len < 0) {
+		zlog_err("%s: Message received from netlink is of a broken size: %d %zu",
+			 __PRETTY_FUNCTION__, h->nlmsg_len,
+			 (size_t)NLMSG_LENGTH(sizeof(struct fib_rule_hdr)));
 		return -1;
+	}
 
 	frh = NLMSG_DATA(h);
-	if (frh->family != AF_INET && frh->family != AF_INET6)
+	if (frh->family != AF_INET && frh->family != AF_INET6) {
+		zlog_warn(
+			"Invalid address family: %u received from kernel rule change: %u",
+			frh->family, h->nlmsg_type);
 		return 0;
+	}
 	if (frh->action != FR_ACT_TO_TBL)
 		return 0;
 
diff -urpN frr-frr-5.0.1/zebra/rule_netlink.h frr-frr-6.0/zebra/rule_netlink.h
--- frr-frr-5.0.1/zebra/rule_netlink.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rule_netlink.h	2018-10-08 14:32:57.000000000 +0200
@@ -29,8 +29,7 @@
 /*
  * Handle netlink notification informing a rule add or delete.
  */
-extern int netlink_rule_change(struct sockaddr_nl *snl, struct nlmsghdr *h,
-				ns_id_t ns_id, int startup);
+extern int netlink_rule_change(struct nlmsghdr *h, ns_id_t ns_id, int startup);
 
 /*
  * Get to know existing PBR rules in the kernel - typically called at startup.
diff -urpN frr-frr-5.0.1/zebra/rule_socket.c frr-frr-6.0/zebra/rule_socket.c
--- frr-frr-5.0.1/zebra/rule_socket.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/rule_socket.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,6 +29,7 @@
 #include "if.h"
 #include "prefix.h"
 #include "vrf.h"
+#include "lib_errors.h"
 
 #include "zebra/zserv.h"
 #include "zebra/zebra_ns.h"
@@ -41,11 +42,18 @@
 #include "zebra/rule_netlink.h"
 #include "zebra/zebra_pbr.h"
 
-void kernel_add_pbr_rule(struct zebra_pbr_rule *rule)
+enum dp_req_result kernel_add_pbr_rule(struct zebra_pbr_rule *rule)
 {
+	flog_err(LIB_ERR_UNAVAILABLE, "%s not Implemented for this platform",
+		  __PRETTY_FUNCTION__);
+	return DP_REQUEST_FAILURE;
 }
-void kernel_del_pbr_rule(struct zebra_pbr_rule *rule)
+
+enum dp_req_result kernel_del_pbr_rule(struct zebra_pbr_rule *rule)
 {
+	flog_err(LIB_ERR_UNAVAILABLE, "%s not Implemented for this platform",
+		  __PRETTY_FUNCTION__);
+	return DP_REQUEST_FAILURE;
 }
 
 #endif
diff -urpN frr-frr-5.0.1/zebra/subdir.am frr-frr-6.0/zebra/subdir.am
--- frr-frr-5.0.1/zebra/subdir.am	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/subdir.am	2018-10-08 14:32:57.000000000 +0200
@@ -63,7 +63,6 @@ zebra_zebra_SOURCES = \
 	zebra/zebra_rib.c \
 	zebra/zebra_rnh.c \
 	zebra/zebra_routemap.c \
-	zebra/zebra_static.c \
 	zebra/zebra_vrf.c \
 	zebra/zebra_vty.c \
 	zebra/zebra_vxlan.c \
@@ -72,6 +71,7 @@ zebra_zebra_SOURCES = \
 	zebra/zebra_netns_notify.c \
 	zebra/table_manager.c \
 	zebra/zapi_msg.c \
+	zebra/zebra_errors.c \
 	# end
 
 zebra/zebra_vty_clippy.c: $(CLIPPY_DEPS)
@@ -108,7 +108,6 @@ noinst_HEADERS += \
 	zebra/zebra_pw.h \
 	zebra/zebra_rnh.h \
 	zebra/zebra_routemap.h \
-	zebra/zebra_static.h \
 	zebra/zebra_vrf.h \
 	zebra/zebra_vxlan.h \
 	zebra/zebra_vxlan_private.h \
@@ -117,6 +116,7 @@ noinst_HEADERS += \
 	zebra/zebra_netns_notify.h \
 	zebra/table_manager.h \
 	zebra/zapi_msg.h \
+	zebra/zebra_errors.h \
 	# end
 
 zebra_zebra_irdp_la_SOURCES = \
@@ -127,7 +127,7 @@ zebra_zebra_irdp_la_SOURCES = \
 zebra_zebra_irdp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 
 zebra_zebra_snmp_la_SOURCES = zebra/zebra_snmp.c
-zebra_zebra_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS)
+zebra_zebra_snmp_la_CFLAGS = $(WERROR) $(SNMP_CFLAGS) -std=gnu99
 zebra_zebra_snmp_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
 zebra_zebra_snmp_la_LIBADD = lib/libfrrsnmp.la
 
@@ -141,13 +141,3 @@ if DEV_BUILD
 zebra_zebra_fpm_la_SOURCES += zebra/zebra_fpm_dt.c
 endif
 endif
-
-EXTRA_DIST += \
-	zebra/GNOME-SMI \
-	zebra/GNOME-PRODUCT-ZEBRA-MIB \
-	# end
-
-# -- unmaintained --
-# noinst_PROGRAMS += zebra/client
-# zebra_client_SOURCES = zebra/client_main.c
-# zebra_client_LDADD = lib/libfrr.la
diff -urpN frr-frr-5.0.1/zebra/table_manager.c frr-frr-6.0/zebra/table_manager.c
--- frr-frr-5.0.1/zebra/table_manager.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/table_manager.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "zebra/zebra_vrf.h"
 #include "zebra/label_manager.h" /* for NO_PROTO */
 #include "zebra/table_manager.h"
+#include "zebra/zebra_errors.h"
 
 /* routing table identifiers
  *
@@ -78,7 +79,7 @@ void table_manager_enable(ns_id_t ns_id)
 		return;
 	tbl_mgr.lc_list = list_new();
 	tbl_mgr.lc_list->del = delete_table_chunk;
-	hook_register(zapi_client_close, release_daemon_table_chunks);
+	hook_register(zserv_client_close, release_daemon_table_chunks);
 }
 
 /**
@@ -146,8 +147,9 @@ struct table_manager_chunk *assign_table
 #endif /* SUNOS_5 */
 	tmc->start = start;
 	if (RT_TABLE_ID_UNRESERVED_MAX - size  + 1 < start) {
-		zlog_err("Reached max table id. Start/Size %u/%u",
-			 start, size);
+		flog_err(ZEBRA_ERR_TM_EXHAUSTED_IDS,
+			  "Reached max table id. Start/Size %u/%u", start,
+			  size);
 		XFREE(MTYPE_TM_CHUNK, tmc);
 		return NULL;
 	}
@@ -184,7 +186,8 @@ int release_table_chunk(uint8_t proto, u
 		if (tmc->end != end)
 			continue;
 		if (tmc->proto != proto || tmc->instance != instance) {
-			zlog_err("%s: Daemon mismatch!!", __func__);
+			flog_err(ZEBRA_ERR_TM_DAEMON_MISMATCH,
+				  "%s: Daemon mismatch!!", __func__);
 			continue;
 		}
 		tmc->proto = NO_PROTO;
@@ -193,7 +196,8 @@ int release_table_chunk(uint8_t proto, u
 		break;
 	}
 	if (ret != 0)
-		zlog_err("%s: Table chunk not released!!", __func__);
+		flog_err(ZEBRA_ERR_TM_UNRELEASED_CHUNK,
+			  "%s: Table chunk not released!!", __func__);
 
 	return ret;
 }
diff -urpN frr-frr-5.0.1/zebra/zapi_msg.c frr-frr-6.0/zebra/zapi_msg.c
--- frr-frr-5.0.1/zebra/zapi_msg.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zapi_msg.c	2018-10-08 14:32:57.000000000 +0200
@@ -162,7 +162,7 @@ int zsend_interface_add(struct zserv *cl
 	zserv_encode_interface(s, ifp);
 
 	client->ifadd_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Interface deletion from zebra daemon. */
@@ -174,7 +174,7 @@ int zsend_interface_delete(struct zserv
 	zserv_encode_interface(s, ifp);
 
 	client->ifdel_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 int zsend_vrf_add(struct zserv *client, struct zebra_vrf *zvrf)
@@ -185,7 +185,7 @@ int zsend_vrf_add(struct zserv *client,
 	zserv_encode_vrf(s, zvrf);
 
 	client->vrfadd_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* VRF deletion from zebra daemon. */
@@ -198,7 +198,7 @@ int zsend_vrf_delete(struct zserv *clien
 	zserv_encode_vrf(s, zvrf);
 
 	client->vrfdel_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 int zsend_interface_link_params(struct zserv *client, struct interface *ifp)
@@ -230,7 +230,7 @@ int zsend_interface_link_params(struct z
 	/* Write packet size. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Interface address is added/deleted. Send ZEBRA_INTERFACE_ADDRESS_ADD or
@@ -309,7 +309,7 @@ int zsend_interface_address(int cmd, str
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	client->connected_rt_add_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 static int zsend_interface_nbr_address(int cmd, struct zserv *client,
@@ -340,7 +340,7 @@ static int zsend_interface_nbr_address(i
 	/* Write packet size. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Interface address addition. */
@@ -438,7 +438,7 @@ int zsend_interface_vrf_update(struct zs
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	client->if_vrfchg_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Add new nbr connected IPv6 address */
@@ -448,7 +448,7 @@ void nbr_connected_add_ipv6(struct inter
 	struct prefix p;
 
 	p.family = AF_INET6;
-	IPV6_ADDR_COPY(&p.u.prefix, address);
+	IPV6_ADDR_COPY(&p.u.prefix6, address);
 	p.prefixlen = IPV6_MAX_PREFIXLEN;
 
 	ifc = listnode_head(ifp->nbr_connected);
@@ -473,7 +473,7 @@ void nbr_connected_delete_ipv6(struct in
 	struct prefix p;
 
 	p.family = AF_INET6;
-	IPV6_ADDR_COPY(&p.u.prefix, address);
+	IPV6_ADDR_COPY(&p.u.prefix6, address);
 	p.prefixlen = IPV6_MAX_PREFIXLEN;
 
 	ifc = nbr_connected_check(ifp, &p);
@@ -511,16 +511,18 @@ int zsend_interface_update(int cmd, stru
 	else
 		client->ifdown_cnt++;
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
-int zsend_redistribute_route(int cmd, struct zserv *client, struct prefix *p,
-			     struct prefix *src_p, struct route_entry *re)
+int zsend_redistribute_route(int cmd, struct zserv *client,
+			     const struct prefix *p,
+			     const struct prefix *src_p, struct route_entry *re)
 {
 	struct zapi_route api;
 	struct zapi_nexthop *api_nh;
 	struct nexthop *nexthop;
 	int count = 0;
+	afi_t afi;
 
 	memset(&api, 0, sizeof(api));
 	api.vrf_id = re->vrf_id;
@@ -528,6 +530,24 @@ int zsend_redistribute_route(int cmd, st
 	api.instance = re->instance;
 	api.flags = re->flags;
 
+	afi = family2afi(p->family);
+	switch (afi) {
+	case AFI_IP:
+		if (cmd == ZEBRA_REDISTRIBUTE_ROUTE_ADD)
+			client->redist_v4_add_cnt++;
+		else
+			client->redist_v4_del_cnt++;
+		break;
+	case AFI_IP6:
+		if (cmd == ZEBRA_REDISTRIBUTE_ROUTE_ADD)
+			client->redist_v6_add_cnt++;
+		else
+			client->redist_v6_del_cnt++;
+		break;
+	default:
+		break;
+	}
+
 	/* Prefix. */
 	api.prefix = *p;
 	if (src_p) {
@@ -602,7 +622,7 @@ int zsend_redistribute_route(int cmd, st
 			   zebra_route_string(api.type), api.vrf_id,
 			   buf_prefix);
 	}
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -655,25 +675,31 @@ static int zsend_ipv4_nexthop_lookup_mri
 
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
-int zsend_route_notify_owner(struct route_entry *re, struct prefix *p,
-			     enum zapi_route_notify_owner note)
+/*
+ * Common utility send route notification, called from a path using a
+ * route_entry and from a path using a dataplane context.
+ */
+static int route_notify_internal(const struct prefix *p, int type,
+				 uint16_t instance, vrf_id_t vrf_id,
+				 uint32_t table_id,
+				 enum zapi_route_notify_owner note)
 {
 	struct zserv *client;
 	struct stream *s;
 	uint8_t blen;
 
-	client = zebra_find_client(re->type, re->instance);
+	client = zserv_find_client(type, instance);
 	if (!client || !client->notify_owner) {
 		if (IS_ZEBRA_DEBUG_PACKET) {
 			char buff[PREFIX_STRLEN];
 
 			zlog_debug(
 				"Not Notifying Owner: %u about prefix %s(%u) %d vrf: %u",
-				re->type, prefix2str(p, buff, sizeof(buff)),
-				re->table, note, re->vrf_id);
+				type, prefix2str(p, buff, sizeof(buff)),
+				table_id, note, vrf_id);
 		}
 		return 0;
 	}
@@ -682,14 +708,14 @@ int zsend_route_notify_owner(struct rout
 		char buff[PREFIX_STRLEN];
 
 		zlog_debug("Notifying Owner: %u about prefix %s(%u) %d vrf: %u",
-			   re->type, prefix2str(p, buff, sizeof(buff)),
-			   re->table, note, re->vrf_id);
+			   type, prefix2str(p, buff, sizeof(buff)),
+			   table_id, note, vrf_id);
 	}
 
 	s = stream_new(ZEBRA_MAX_PACKET_SIZ);
 	stream_reset(s);
 
-	zclient_create_header(s, ZEBRA_ROUTE_NOTIFY_OWNER, re->vrf_id);
+	zclient_create_header(s, ZEBRA_ROUTE_NOTIFY_OWNER, vrf_id);
 
 	stream_put(s, &note, sizeof(note));
 
@@ -699,11 +725,18 @@ int zsend_route_notify_owner(struct rout
 	stream_putc(s, p->prefixlen);
 	stream_put(s, &p->u.prefix, blen);
 
-	stream_putl(s, re->table);
+	stream_putl(s, table_id);
 
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
+}
+
+int zsend_route_notify_owner(struct route_entry *re, const struct prefix *p,
+			     enum zapi_route_notify_owner note)
+{
+	return (route_notify_internal(p, re->type, re->instance, re->vrf_id,
+				      re->table, note));
 }
 
 void zsend_rule_notify_owner(struct zebra_pbr_rule *rule,
@@ -739,7 +772,7 @@ void zsend_rule_notify_owner(struct zebr
 
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
 
 void zsend_ipset_notify_owner(struct zebra_pbr_ipset *ipset,
@@ -769,7 +802,7 @@ void zsend_ipset_notify_owner(struct zeb
 	stream_put(s, ipset->ipset_name, ZEBRA_IPSET_NAME_SIZE);
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
 
 void zsend_ipset_entry_notify_owner(struct zebra_pbr_ipset_entry *ipset,
@@ -799,7 +832,7 @@ void zsend_ipset_entry_notify_owner(stru
 	stream_put(s, ipset->backpointer->ipset_name, ZEBRA_IPSET_NAME_SIZE);
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
 
 void zsend_iptable_notify_owner(struct zebra_pbr_iptable *iptable,
@@ -828,7 +861,7 @@ void zsend_iptable_notify_owner(struct z
 	stream_putl(s, iptable->unique);
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
 
 /* Router-id is updated. Send ZEBRA_ROUTER_ID_ADD to client. */
@@ -855,7 +888,7 @@ int zsend_router_id_update(struct zserv
 	/* Write packet size. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -873,7 +906,7 @@ int zsend_pw_update(struct zserv *client
 	/* Put length at the first point of the stream. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Send response to a get label chunk request to client */
@@ -952,7 +985,7 @@ static int zsend_assign_table_chunk_resp
 	/* Write packet size. */
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 static int zsend_table_manager_connect_response(struct zserv *client,
@@ -968,7 +1001,7 @@ static int zsend_table_manager_connect_r
 
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* Inbound message handling ------------------------------------------------ */
@@ -989,6 +1022,7 @@ static void zread_rnh_register(ZAPI_HAND
 	unsigned short l = 0;
 	uint8_t flags = 0;
 	uint16_t type = cmd2type[hdr->command];
+	bool exist;
 
 	if (IS_ZEBRA_DEBUG_NHT)
 		zlog_debug(
@@ -1025,12 +1059,16 @@ static void zread_rnh_register(ZAPI_HAND
 			STREAM_GET(&p.u.prefix6, s, IPV6_MAX_BYTELEN);
 			l += IPV6_MAX_BYTELEN;
 		} else {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_UNKNOWN_FAMILY,
 				"rnh_register: Received unknown family type %d\n",
 				p.family);
 			return;
 		}
-		rnh = zebra_add_rnh(&p, zvrf_id(zvrf), type);
+		rnh = zebra_add_rnh(&p, zvrf_id(zvrf), type, &exist);
+		if (!rnh)
+			return;
+
 		if (type == RNH_NEXTHOP_TYPE) {
 			if (flags
 			    && !CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED))
@@ -1050,7 +1088,9 @@ static void zread_rnh_register(ZAPI_HAND
 
 		zebra_add_rnh_client(rnh, client, type, zvrf_id(zvrf));
 		/* Anything not AF_INET/INET6 has been filtered out above */
-		zebra_evaluate_rnh(zvrf_id(zvrf), p.family, 1, type, &p);
+		if (!exist)
+			zebra_evaluate_rnh(zvrf_id(zvrf), p.family, 1, type,
+					   &p);
 	}
 
 stream_failure:
@@ -1103,7 +1143,8 @@ static void zread_rnh_unregister(ZAPI_HA
 			STREAM_GET(&p.u.prefix6, s, IPV6_MAX_BYTELEN);
 			l += IPV6_MAX_BYTELEN;
 		} else {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_UNKNOWN_FAMILY,
 				"rnh_register: Received unknown family type %d\n",
 				p.family);
 			return;
@@ -1139,7 +1180,8 @@ static void zread_fec_register(ZAPI_HAND
 	 * registration
 	 */
 	if (hdr->length < ZEBRA_MIN_FEC_LENGTH) {
-		zlog_err(
+		flog_err(
+			ZEBRA_ERR_IRDP_LEN_MISMATCH,
 			"fec_register: Received a fec register of hdr->length %d, it is of insufficient size to properly decode",
 			hdr->length);
 		return;
@@ -1150,7 +1192,8 @@ static void zread_fec_register(ZAPI_HAND
 		memset(&p, 0, sizeof(p));
 		STREAM_GETW(s, p.family);
 		if (p.family != AF_INET && p.family != AF_INET6) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_UNKNOWN_FAMILY,
 				"fec_register: Received unknown family type %d\n",
 				p.family);
 			return;
@@ -1197,7 +1240,8 @@ static void zread_fec_unregister(ZAPI_HA
 	 * fec unregistration
 	 */
 	if (hdr->length < ZEBRA_MIN_FEC_LENGTH) {
-		zlog_err(
+		flog_err(
+			ZEBRA_ERR_IRDP_LEN_MISMATCH,
 			"fec_unregister: Received a fec unregister of hdr->length %d, it is of insufficient size to properly decode",
 			hdr->length);
 		return;
@@ -1211,7 +1255,8 @@ static void zread_fec_unregister(ZAPI_HA
 		memset(&p, 0, sizeof(p));
 		STREAM_GETW(s, p.family);
 		if (p.family != AF_INET && p.family != AF_INET6) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_UNKNOWN_FAMILY,
 				"fec_unregister: Received unknown family type %d\n",
 				p.family);
 			return;
@@ -1392,7 +1437,7 @@ static void zread_route_add(ZAPI_HANDLER
 					       &(api_nh->gate.ipv4),
 					       sizeof(struct in_addr));
 					zebra_vxlan_evpn_vrf_route_add(
-						vrf_id, &api.rmac, &vtep_ip,
+						vrf_id, &api_nh->rmac, &vtep_ip,
 						&api.prefix);
 				}
 				break;
@@ -1425,7 +1470,7 @@ static void zread_route_add(ZAPI_HANDLER
 					       &(api_nh->gate.ipv6),
 					       sizeof(struct in6_addr));
 					zebra_vxlan_evpn_vrf_route_add(
-						vrf_id, &api.rmac, &vtep_ip,
+						vrf_id, &api_nh->rmac, &vtep_ip,
 						&api.prefix);
 				}
 				break;
@@ -1532,7 +1577,7 @@ static void zread_route_del(ZAPI_HANDLER
 
 	rib_delete(afi, api.safi, zvrf_id(zvrf), api.type, api.instance,
 		   api.flags, &api.prefix, src_p, NULL, table_id, api.metric,
-		   false, &api.rmac);
+		   api.distance, false);
 
 	/* Stats */
 	switch (api.prefix.family) {
@@ -1545,202 +1590,6 @@ static void zread_route_del(ZAPI_HANDLER
 	}
 }
 
-/* This function support multiple nexthop. */
-/*
- * Parse the ZEBRA_IPV4_ROUTE_ADD sent from client. Update re and
- * add kernel route.
- */
-static void zread_ipv4_add(ZAPI_HANDLER_ARGS)
-{
-	int i;
-	struct route_entry *re;
-	struct prefix p;
-	uint8_t message;
-	struct in_addr nhop_addr;
-	uint8_t nexthop_num;
-	uint8_t nexthop_type;
-	struct stream *s;
-	ifindex_t ifindex;
-	safi_t safi;
-	int ret;
-	enum lsp_types_t label_type = ZEBRA_LSP_NONE;
-	mpls_label_t label;
-	struct nexthop *nexthop;
-	enum blackhole_type bh_type = BLACKHOLE_NULL;
-
-	/* Get input stream.  */
-	s = msg;
-
-	/* Allocate new re. */
-	re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
-
-	/* Type, flags, message. */
-	STREAM_GETC(s, re->type);
-	if (re->type > ZEBRA_ROUTE_MAX) {
-		zlog_warn("%s: Specified route type %d is not a legal value\n",
-			  __PRETTY_FUNCTION__, re->type);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GETW(s, re->instance);
-	STREAM_GETL(s, re->flags);
-	STREAM_GETC(s, message);
-	STREAM_GETW(s, safi);
-	re->uptime = time(NULL);
-
-	/* IPv4 prefix. */
-	memset(&p, 0, sizeof(struct prefix_ipv4));
-	p.family = AF_INET;
-	STREAM_GETC(s, p.prefixlen);
-	if (p.prefixlen > IPV4_MAX_BITLEN) {
-		zlog_warn(
-			"%s: Specified prefix length %d is greater than what v4 can be",
-			__PRETTY_FUNCTION__, p.prefixlen);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GET(&p.u.prefix4, s, PSIZE(p.prefixlen));
-
-	/* VRF ID */
-	re->vrf_id = zvrf_id(zvrf);
-
-	/* Nexthop parse. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_NEXTHOP)) {
-		STREAM_GETC(s, nexthop_num);
-		zserv_nexthop_num_warn(__func__, (const struct prefix *)&p,
-				       nexthop_num);
-
-		if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL))
-			label_type = lsp_type_from_re_type(client->proto);
-
-		for (i = 0; i < nexthop_num; i++) {
-			STREAM_GETC(s, nexthop_type);
-
-			switch (nexthop_type) {
-			case NEXTHOP_TYPE_IFINDEX:
-				STREAM_GETL(s, ifindex);
-				route_entry_nexthop_ifindex_add(re, ifindex,
-								re->vrf_id);
-				break;
-			case NEXTHOP_TYPE_IPV4:
-				STREAM_GET(&nhop_addr.s_addr, s,
-					   IPV4_MAX_BYTELEN);
-				nexthop = route_entry_nexthop_ipv4_add(
-					re, &nhop_addr, NULL, re->vrf_id);
-				/*
-				 * For labeled-unicast, each nexthop is followed
-				 * by the label.
-				 */
-				if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL)) {
-					STREAM_GETL(s, label);
-					nexthop_add_labels(nexthop, label_type,
-							   1, &label);
-				}
-				break;
-			case NEXTHOP_TYPE_IPV4_IFINDEX:
-				STREAM_GET(&nhop_addr.s_addr, s,
-					   IPV4_MAX_BYTELEN);
-				STREAM_GETL(s, ifindex);
-				route_entry_nexthop_ipv4_ifindex_add(
-					re, &nhop_addr, NULL, ifindex,
-					re->vrf_id);
-				break;
-			case NEXTHOP_TYPE_IPV6:
-				zlog_warn(
-					"%s: Please use ZEBRA_ROUTE_ADD if you want to pass v6 nexthops",
-					__PRETTY_FUNCTION__);
-				nexthops_free(re->ng.nexthop);
-				XFREE(MTYPE_RE, re);
-				return;
-			case NEXTHOP_TYPE_BLACKHOLE:
-				route_entry_nexthop_blackhole_add(re, bh_type);
-				break;
-			default:
-				zlog_warn(
-					"%s: Specified nexthop type: %d does not exist",
-					__PRETTY_FUNCTION__, nexthop_type);
-				nexthops_free(re->ng.nexthop);
-				XFREE(MTYPE_RE, re);
-				return;
-			}
-		}
-	}
-
-	/* Distance. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_DISTANCE))
-		STREAM_GETC(s, re->distance);
-
-	/* Metric. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_METRIC))
-		STREAM_GETL(s, re->metric);
-
-	/* Tag */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_TAG))
-		STREAM_GETL(s, re->tag);
-	else
-		re->tag = 0;
-
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_MTU))
-		STREAM_GETL(s, re->mtu);
-	else
-		re->mtu = 0;
-
-	/* Table */
-	re->table = zvrf->table_id;
-
-	ret = rib_add_multipath(AFI_IP, safi, &p, NULL, re);
-
-	/* Stats */
-	if (ret > 0)
-		client->v4_route_add_cnt++;
-	else if (ret < 0)
-		client->v4_route_upd8_cnt++;
-
-	return;
-
-stream_failure:
-	nexthops_free(re->ng.nexthop);
-	XFREE(MTYPE_RE, re);
-}
-
-/* Zebra server IPv4 prefix delete function. */
-static void zread_ipv4_delete(ZAPI_HANDLER_ARGS)
-{
-	struct stream *s;
-	struct zapi_ipv4 api;
-	struct prefix p;
-	uint32_t table_id;
-
-	s = msg;
-
-	/* Type, flags, message. */
-	STREAM_GETC(s, api.type);
-	STREAM_GETW(s, api.instance);
-	STREAM_GETL(s, api.flags);
-	STREAM_GETC(s, api.message);
-	STREAM_GETW(s, api.safi);
-
-	/* IPv4 prefix. */
-	memset(&p, 0, sizeof(struct prefix));
-	p.family = AF_INET;
-	STREAM_GETC(s, p.prefixlen);
-	if (p.prefixlen > IPV4_MAX_BITLEN) {
-		zlog_warn("%s: Passed in prefixlen %d is impossible",
-			  __PRETTY_FUNCTION__, p.prefixlen);
-		return;
-	}
-	STREAM_GET(&p.u.prefix4, s, PSIZE(p.prefixlen));
-
-	table_id = zvrf->table_id;
-
-	rib_delete(AFI_IP, api.safi, zvrf_id(zvrf), api.type, api.instance,
-		   api.flags, &p, NULL, NULL, table_id, 0, false, NULL);
-	client->v4_route_del_cnt++;
-
-stream_failure:
-	return;
-}
-
 /* MRIB Nexthop lookup for IPv4. */
 static void zread_ipv4_nexthop_lookup_mrib(ZAPI_HANDLER_ARGS)
 {
@@ -1755,418 +1604,6 @@ stream_failure:
 	return;
 }
 
-/* Zebra server IPv6 prefix add function. */
-static void zread_ipv4_route_ipv6_nexthop_add(ZAPI_HANDLER_ARGS)
-{
-	unsigned int i;
-	struct stream *s;
-	struct in6_addr nhop_addr;
-	struct route_entry *re;
-	uint8_t message;
-	uint8_t nexthop_num;
-	uint8_t nexthop_type;
-	struct prefix p;
-	safi_t safi;
-	static struct in6_addr nexthops[MULTIPATH_NUM];
-	static unsigned int ifindices[MULTIPATH_NUM];
-	int ret;
-	static mpls_label_t labels[MULTIPATH_NUM];
-	enum lsp_types_t label_type = ZEBRA_LSP_NONE;
-	mpls_label_t label;
-	struct nexthop *nexthop;
-	enum blackhole_type bh_type = BLACKHOLE_NULL;
-
-	/* Get input stream.  */
-	s = msg;
-
-	memset(&nhop_addr, 0, sizeof(struct in6_addr));
-
-	/* Allocate new re. */
-	re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
-
-	/* Type, flags, message. */
-	STREAM_GETC(s, re->type);
-	if (re->type > ZEBRA_ROUTE_MAX) {
-		zlog_warn("%s: Specified route type: %d is not a legal value\n",
-			  __PRETTY_FUNCTION__, re->type);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GETW(s, re->instance);
-	STREAM_GETL(s, re->flags);
-	STREAM_GETC(s, message);
-	STREAM_GETW(s, safi);
-	re->uptime = time(NULL);
-
-	/* IPv4 prefix. */
-	memset(&p, 0, sizeof(struct prefix_ipv4));
-	p.family = AF_INET;
-	STREAM_GETC(s, p.prefixlen);
-	if (p.prefixlen > IPV4_MAX_BITLEN) {
-		zlog_warn(
-			"%s: Prefix Length %d is greater than what a v4 address can use",
-			__PRETTY_FUNCTION__, p.prefixlen);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GET(&p.u.prefix4, s, PSIZE(p.prefixlen));
-
-	/* VRF ID */
-	re->vrf_id = zvrf_id(zvrf);
-
-	/*
-	 * We need to give nh-addr, nh-ifindex with the same next-hop object
-	 * to the re to ensure that IPv6 multipathing works; need to coalesce
-	 * these. Clients should send the same number of paired set of
-	 * next-hop-addr/next-hop-ifindices.
-	 */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_NEXTHOP)) {
-		unsigned int nh_count = 0;
-		unsigned int if_count = 0;
-		unsigned int max_nh_if = 0;
-
-		STREAM_GETC(s, nexthop_num);
-		zserv_nexthop_num_warn(__func__, (const struct prefix *)&p,
-				       nexthop_num);
-
-		if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL))
-			label_type = lsp_type_from_re_type(client->proto);
-
-		for (i = 0; i < nexthop_num; i++) {
-			STREAM_GETC(s, nexthop_type);
-
-			switch (nexthop_type) {
-			case NEXTHOP_TYPE_IPV6:
-				STREAM_GET(&nhop_addr, s, 16);
-				if (nh_count < MULTIPATH_NUM) {
-					/*
-					 * For labeled-unicast, each nexthop is
-					 * followed by the label.
-					 */
-					if (CHECK_FLAG(message,
-						       ZAPI_MESSAGE_LABEL)) {
-						STREAM_GETL(s, label);
-						labels[nh_count] = label;
-					}
-					nexthops[nh_count] = nhop_addr;
-					nh_count++;
-				}
-				break;
-			case NEXTHOP_TYPE_IFINDEX:
-				if (if_count < multipath_num)
-					STREAM_GETL(s, ifindices[if_count++]);
-				break;
-			case NEXTHOP_TYPE_BLACKHOLE:
-				route_entry_nexthop_blackhole_add(re, bh_type);
-				break;
-			default:
-				zlog_warn(
-					"%s: Please use ZEBRA_ROUTE_ADD if you want to pass non v6 nexthops",
-					__PRETTY_FUNCTION__);
-				nexthops_free(re->ng.nexthop);
-				XFREE(MTYPE_RE, re);
-				return;
-			}
-		}
-
-		max_nh_if = (nh_count > if_count) ? nh_count : if_count;
-		for (i = 0; i < max_nh_if; i++) {
-			if ((i < nh_count)
-			    && !IN6_IS_ADDR_UNSPECIFIED(&nexthops[i])) {
-				if ((i < if_count) && ifindices[i])
-					nexthop =
-						route_entry_nexthop_ipv6_ifindex_add(
-							re, &nexthops[i],
-							ifindices[i],
-							re->vrf_id);
-				else
-					nexthop = route_entry_nexthop_ipv6_add(
-						re, &nexthops[i], re->vrf_id);
-
-				if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL))
-					nexthop_add_labels(nexthop, label_type,
-							   1, &labels[i]);
-			} else {
-				if ((i < if_count) && ifindices[i])
-					route_entry_nexthop_ifindex_add(
-						re, ifindices[i], re->vrf_id);
-			}
-		}
-	}
-
-	/* Distance. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_DISTANCE))
-		STREAM_GETC(s, re->distance);
-
-	/* Metric. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_METRIC))
-		STREAM_GETL(s, re->metric);
-
-	/* Tag */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_TAG))
-		STREAM_GETL(s, re->tag);
-	else
-		re->tag = 0;
-
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_MTU))
-		STREAM_GETL(s, re->mtu);
-	else
-		re->mtu = 0;
-
-	/* Table */
-	re->table = zvrf->table_id;
-
-	ret = rib_add_multipath(AFI_IP6, safi, &p, NULL, re);
-	/* Stats */
-	if (ret > 0)
-		client->v4_route_add_cnt++;
-	else if (ret < 0)
-		client->v4_route_upd8_cnt++;
-
-	return;
-
-stream_failure:
-	nexthops_free(re->ng.nexthop);
-	XFREE(MTYPE_RE, re);
-}
-
-static void zread_ipv6_add(ZAPI_HANDLER_ARGS)
-{
-	unsigned int i;
-	struct stream *s;
-	struct in6_addr nhop_addr;
-	ifindex_t ifindex;
-	struct route_entry *re;
-	uint8_t message;
-	uint8_t nexthop_num;
-	uint8_t nexthop_type;
-	struct prefix p;
-	struct prefix_ipv6 src_p, *src_pp;
-	safi_t safi;
-	static struct in6_addr nexthops[MULTIPATH_NUM];
-	static unsigned int ifindices[MULTIPATH_NUM];
-	int ret;
-	static mpls_label_t labels[MULTIPATH_NUM];
-	enum lsp_types_t label_type = ZEBRA_LSP_NONE;
-	mpls_label_t label;
-	struct nexthop *nexthop;
-	enum blackhole_type bh_type = BLACKHOLE_NULL;
-
-	/* Get input stream.  */
-	s = msg;
-
-	memset(&nhop_addr, 0, sizeof(struct in6_addr));
-
-	/* Allocate new re. */
-	re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
-
-	/* Type, flags, message. */
-	STREAM_GETC(s, re->type);
-	if (re->type > ZEBRA_ROUTE_MAX) {
-		zlog_warn("%s: Specified route type: %d is not a legal value\n",
-			  __PRETTY_FUNCTION__, re->type);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GETW(s, re->instance);
-	STREAM_GETL(s, re->flags);
-	STREAM_GETC(s, message);
-	STREAM_GETW(s, safi);
-	re->uptime = time(NULL);
-
-	/* IPv6 prefix. */
-	memset(&p, 0, sizeof(p));
-	p.family = AF_INET6;
-	STREAM_GETC(s, p.prefixlen);
-	if (p.prefixlen > IPV6_MAX_BITLEN) {
-		zlog_warn(
-			"%s: Specified prefix length %d is to large for v6 prefix",
-			__PRETTY_FUNCTION__, p.prefixlen);
-		XFREE(MTYPE_RE, re);
-		return;
-	}
-	STREAM_GET(&p.u.prefix6, s, PSIZE(p.prefixlen));
-
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_SRCPFX)) {
-		memset(&src_p, 0, sizeof(src_p));
-		src_p.family = AF_INET6;
-		STREAM_GETC(s, src_p.prefixlen);
-		if (src_p.prefixlen > IPV6_MAX_BITLEN) {
-			zlog_warn(
-				"%s: Specified src prefix length %d is to large for v6 prefix",
-				__PRETTY_FUNCTION__, src_p.prefixlen);
-			XFREE(MTYPE_RE, re);
-			return;
-		}
-		STREAM_GET(&src_p.prefix, s, PSIZE(src_p.prefixlen));
-		src_pp = &src_p;
-	} else
-		src_pp = NULL;
-
-	/* VRF ID */
-	re->vrf_id = zvrf_id(zvrf);
-
-	/*
-	 * We need to give nh-addr, nh-ifindex with the same next-hop object
-	 * to the re to ensure that IPv6 multipathing works; need to coalesce
-	 * these. Clients should send the same number of paired set of
-	 * next-hop-addr/next-hop-ifindices.
-	 */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_NEXTHOP)) {
-		unsigned int nh_count = 0;
-		unsigned int if_count = 0;
-		unsigned int max_nh_if = 0;
-
-		STREAM_GETC(s, nexthop_num);
-		zserv_nexthop_num_warn(__func__, (const struct prefix *)&p,
-				       nexthop_num);
-
-		if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL))
-			label_type = lsp_type_from_re_type(client->proto);
-
-		for (i = 0; i < nexthop_num; i++) {
-			STREAM_GETC(s, nexthop_type);
-
-			switch (nexthop_type) {
-			case NEXTHOP_TYPE_IPV6:
-				STREAM_GET(&nhop_addr, s, 16);
-				if (nh_count < MULTIPATH_NUM) {
-					/*
-					 * For labeled-unicast, each nexthop is
-					 * followed by label.
-					 */
-					if (CHECK_FLAG(message,
-						       ZAPI_MESSAGE_LABEL)) {
-						STREAM_GETL(s, label);
-						labels[nh_count] = label;
-					}
-					nexthops[nh_count++] = nhop_addr;
-				}
-				break;
-			case NEXTHOP_TYPE_IPV6_IFINDEX:
-				STREAM_GET(&nhop_addr, s, 16);
-				STREAM_GETL(s, ifindex);
-				route_entry_nexthop_ipv6_ifindex_add(
-					re, &nhop_addr, ifindex, re->vrf_id);
-				break;
-			case NEXTHOP_TYPE_IFINDEX:
-				if (if_count < multipath_num)
-					STREAM_GETL(s, ifindices[if_count++]);
-				break;
-			case NEXTHOP_TYPE_BLACKHOLE:
-				route_entry_nexthop_blackhole_add(re, bh_type);
-				break;
-			default:
-				zlog_warn(
-					"%s: Please use ZEBRA_ROUTE_ADD if you want to pass non v6 nexthops",
-					__PRETTY_FUNCTION__);
-				nexthops_free(re->ng.nexthop);
-				XFREE(MTYPE_RE, re);
-				return;
-			}
-		}
-
-		max_nh_if = (nh_count > if_count) ? nh_count : if_count;
-		for (i = 0; i < max_nh_if; i++) {
-			if ((i < nh_count)
-			    && !IN6_IS_ADDR_UNSPECIFIED(&nexthops[i])) {
-				if ((i < if_count) && ifindices[i])
-					nexthop =
-						route_entry_nexthop_ipv6_ifindex_add(
-							re, &nexthops[i],
-							ifindices[i],
-							re->vrf_id);
-				else
-					nexthop = route_entry_nexthop_ipv6_add(
-						re, &nexthops[i], re->vrf_id);
-				if (CHECK_FLAG(message, ZAPI_MESSAGE_LABEL))
-					nexthop_add_labels(nexthop, label_type,
-							   1, &labels[i]);
-			} else {
-				if ((i < if_count) && ifindices[i])
-					route_entry_nexthop_ifindex_add(
-						re, ifindices[i], re->vrf_id);
-			}
-		}
-	}
-
-	/* Distance. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_DISTANCE))
-		STREAM_GETC(s, re->distance);
-
-	/* Metric. */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_METRIC))
-		STREAM_GETL(s, re->metric);
-
-	/* Tag */
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_TAG))
-		STREAM_GETL(s, re->tag);
-	else
-		re->tag = 0;
-
-	if (CHECK_FLAG(message, ZAPI_MESSAGE_MTU))
-		STREAM_GETL(s, re->mtu);
-	else
-		re->mtu = 0;
-
-	re->table = zvrf->table_id;
-
-	ret = rib_add_multipath(AFI_IP6, safi, &p, src_pp, re);
-	/* Stats */
-	if (ret > 0)
-		client->v6_route_add_cnt++;
-	else if (ret < 0)
-		client->v6_route_upd8_cnt++;
-
-	return;
-
-stream_failure:
-	nexthops_free(re->ng.nexthop);
-	XFREE(MTYPE_RE, re);
-}
-
-/* Zebra server IPv6 prefix delete function. */
-static void zread_ipv6_delete(ZAPI_HANDLER_ARGS)
-{
-	struct stream *s;
-	struct zapi_ipv6 api;
-	struct prefix p;
-	struct prefix_ipv6 src_p, *src_pp;
-
-	s = msg;
-
-	/* Type, flags, message. */
-	STREAM_GETC(s, api.type);
-	STREAM_GETW(s, api.instance);
-	STREAM_GETL(s, api.flags);
-	STREAM_GETC(s, api.message);
-	STREAM_GETW(s, api.safi);
-
-	/* IPv4 prefix. */
-	memset(&p, 0, sizeof(struct prefix));
-	p.family = AF_INET6;
-	STREAM_GETC(s, p.prefixlen);
-	STREAM_GET(&p.u.prefix6, s, PSIZE(p.prefixlen));
-
-	if (CHECK_FLAG(api.message, ZAPI_MESSAGE_SRCPFX)) {
-		memset(&src_p, 0, sizeof(struct prefix_ipv6));
-		src_p.family = AF_INET6;
-		STREAM_GETC(s, src_p.prefixlen);
-		STREAM_GET(&src_p.prefix, s, PSIZE(src_p.prefixlen));
-		src_pp = &src_p;
-	} else
-		src_pp = NULL;
-
-	rib_delete(AFI_IP6, api.safi, zvrf_id(zvrf), api.type, api.instance,
-		   api.flags, &p, src_pp, NULL, client->rtm_table, 0, false,
-		   NULL);
-
-	client->v6_route_del_cnt++;
-
-stream_failure:
-	return;
-}
-
 /* Register zebra server router-id information.  Send current router-id */
 static void zread_router_id_add(ZAPI_HANDLER_ARGS)
 {
@@ -2195,7 +1632,7 @@ static void zsend_capabilities(struct zs
 	stream_putl(s, multipath_num);
 
 	stream_putw_at(s, 0, stream_get_endp(s));
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
 
 /* Tie up route-type and client->sock */
@@ -2213,7 +1650,7 @@ static void zread_hello(ZAPI_HANDLER_ARG
 		client->notify_owner = true;
 
 	/* accept only dynamic routing protocols */
-	if ((proto < ZEBRA_ROUTE_MAX) && (proto > ZEBRA_ROUTE_STATIC)) {
+	if ((proto < ZEBRA_ROUTE_MAX) && (proto > ZEBRA_ROUTE_CONNECT)) {
 		zlog_notice(
 			"client %d says hello and bids fair to announce only %s routes vrf=%u",
 			client->sock, zebra_route_string(proto),
@@ -2344,8 +1781,9 @@ static void zread_table_manager_connect(
 
 	/* accept only dynamic routing protocols */
 	if ((proto >= ZEBRA_ROUTE_MAX) || (proto <= ZEBRA_ROUTE_STATIC)) {
-		zlog_err("client %d has wrong protocol %s", client->sock,
-			 zebra_route_string(proto));
+		flog_err(ZEBRA_ERR_TM_WRONG_PROTO,
+			  "client %d has wrong protocol %s", client->sock,
+			  zebra_route_string(proto));
 		zsend_table_manager_connect_response(client, vrf_id, 1);
 		return;
 	}
@@ -2383,10 +1821,10 @@ static void zread_label_manager_connect(
 
 	/* accept only dynamic routing protocols */
 	if ((proto >= ZEBRA_ROUTE_MAX) || (proto <= ZEBRA_ROUTE_STATIC)) {
-		zlog_err("client %d has wrong protocol %s", client->sock,
-			 zebra_route_string(proto));
-		if (client->is_synchronous)
-			zsend_label_manager_connect_response(client, vrf_id, 1);
+		flog_err(ZEBRA_ERR_TM_WRONG_PROTO,
+			  "client %d has wrong protocol %s", client->sock,
+			  zebra_route_string(proto));
+		zsend_label_manager_connect_response(client, vrf_id, 1);
 		return;
 	}
 	zlog_notice("client %d with vrf %u instance %u connected as %s",
@@ -2404,12 +1842,33 @@ static void zread_label_manager_connect(
 		" Label Manager client connected: sock %d, proto %s, vrf %u instance %u",
 		client->sock, zebra_route_string(proto), vrf_id, instance);
 	/* send response back */
-	if (client->is_synchronous)
-		zsend_label_manager_connect_response(client, vrf_id, 0);
+	zsend_label_manager_connect_response(client, vrf_id, 0);
 
 stream_failure:
 	return;
 }
+static int msg_client_id_mismatch(const char *op, struct zserv *client,
+				  uint8_t proto, unsigned int instance)
+{
+	if (proto != client->proto) {
+		flog_err(ZEBRA_ERR_PROTO_OR_INSTANCE_MISMATCH,
+			  "%s: msg vs client proto mismatch, client=%u msg=%u",
+			  op, client->proto, proto);
+		/* TODO: fail when BGP sets proto and instance */
+		/* return 1; */
+	}
+
+	if (instance != client->instance) {
+		flog_err(
+			ZEBRA_ERR_PROTO_OR_INSTANCE_MISMATCH,
+			"%s: msg vs client instance mismatch, client=%u msg=%u",
+			op, client->instance, instance);
+		/* TODO: fail when BGP sets proto and instance */
+		/* return 1; */
+	}
+
+	return 0;
+}
 
 static void zread_get_label_chunk(struct zserv *client, struct stream *msg,
 				  vrf_id_t vrf_id)
@@ -2430,15 +1889,21 @@ static void zread_get_label_chunk(struct
 	STREAM_GETC(s, keep);
 	STREAM_GETL(s, size);
 
-	lmc = assign_label_chunk(proto, instance, keep, size);
+	/* detect client vs message (proto,instance) mismatch */
+	if (msg_client_id_mismatch("Get-label-chunk", client, proto, instance))
+		return;
+
+	lmc = assign_label_chunk(client->proto, client->instance, keep, size);
 	if (!lmc)
-		zlog_err(
+		flog_err(
+			ZEBRA_ERR_LM_CANNOT_ASSIGN_CHUNK,
 			"Unable to assign Label Chunk of size %u to %s instance %u",
-			size, zebra_route_string(proto), instance);
+			size, zebra_route_string(client->proto),
+			client->instance);
 	else
 		zlog_debug("Assigned Label Chunk %u - %u to %s instance %u",
 			   lmc->start, lmc->end,
-			   zebra_route_string(proto), instance);
+			   zebra_route_string(client->proto), client->instance);
 	/* send response back */
 	zsend_assign_label_chunk_response(client, vrf_id, lmc);
 
@@ -2462,7 +1927,12 @@ static void zread_release_label_chunk(st
 	STREAM_GETL(s, start);
 	STREAM_GETL(s, end);
 
-	release_label_chunk(proto, instance, start, end);
+	/* detect client vs message (proto,instance) mismatch */
+	if (msg_client_id_mismatch("Release-label-chunk", client, proto,
+				   instance))
+		return;
+
+	release_label_chunk(client->proto, client->instance, start, end);
 
 stream_failure:
 	return;
@@ -2470,8 +1940,8 @@ stream_failure:
 static void zread_label_manager_request(ZAPI_HANDLER_ARGS)
 {
 	/* to avoid sending other messages like ZERBA_INTERFACE_UP */
-	client->is_synchronous = hdr->command ==
-				 ZEBRA_LABEL_MANAGER_CONNECT;
+	if (hdr->command == ZEBRA_LABEL_MANAGER_CONNECT)
+		client->is_synchronous = 1;
 
 	/* external label manager */
 	if (lm_is_external)
@@ -2479,10 +1949,16 @@ static void zread_label_manager_request(
 						  zvrf_id(zvrf));
 	/* this is a label manager */
 	else {
-		if (hdr->command == ZEBRA_LABEL_MANAGER_CONNECT ||
-		    hdr->command == ZEBRA_LABEL_MANAGER_CONNECT_ASYNC)
+		if (hdr->command == ZEBRA_LABEL_MANAGER_CONNECT)
 			zread_label_manager_connect(client, msg, zvrf_id(zvrf));
 		else {
+			/* Sanity: don't allow 'unidentified' requests */
+			if (!client->proto) {
+				flog_err(
+					ZEBRA_ERR_LM_ALIENS,
+					"Got label request from an unidentified client");
+				return;
+			}
 			if (hdr->command == ZEBRA_GET_LABEL_CHUNK)
 				zread_get_label_chunk(client, msg,
 						      zvrf_id(zvrf));
@@ -2507,8 +1983,9 @@ static void zread_get_table_chunk(struct
 
 	tmc = assign_table_chunk(client->proto, client->instance, size);
 	if (!tmc)
-		zlog_err("%s: Unable to assign Table Chunk of size %u",
-			 __func__, size);
+		flog_err(ZEBRA_ERR_TM_CANNOT_ASSIGN_CHUNK,
+			  "%s: Unable to assign Table Chunk of size %u",
+			  __func__, size);
 	else
 		zlog_debug("Assigned Table Chunk %u - %u", tmc->start,
 			   tmc->end);
@@ -2545,7 +2022,8 @@ static void zread_table_manager_request(
 	else {
 		/* Sanity: don't allow 'unidentified' requests */
 		if (!client->proto) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_TM_ALIENS,
 				"Got table request from an unidentified client");
 			return;
 		}
@@ -2769,7 +2247,9 @@ static inline void zread_rule(ZAPI_HANDL
 		STREAM_GETL(s, ifindex);
 
 		if (ifindex) {
-			zpr.ifp = if_lookup_by_index(ifindex, VRF_UNKNOWN);
+			zpr.ifp = if_lookup_by_index_per_ns(
+						zvrf->zns,
+						ifindex);
 			if (!zpr.ifp) {
 				zlog_debug("Failed to lookup ifindex: %u",
 					   ifindex);
@@ -2930,11 +2410,6 @@ void (*zserv_handlers[])(ZAPI_HANDLER_AR
 	[ZEBRA_INTERFACE_DELETE] = zread_interface_delete,
 	[ZEBRA_ROUTE_ADD] = zread_route_add,
 	[ZEBRA_ROUTE_DELETE] = zread_route_del,
-	[ZEBRA_IPV4_ROUTE_ADD] = zread_ipv4_add,
-	[ZEBRA_IPV4_ROUTE_DELETE] = zread_ipv4_delete,
-	[ZEBRA_IPV4_ROUTE_IPV6_NEXTHOP_ADD] = zread_ipv4_route_ipv6_nexthop_add,
-	[ZEBRA_IPV6_ROUTE_ADD] = zread_ipv6_add,
-	[ZEBRA_IPV6_ROUTE_DELETE] = zread_ipv6_delete,
 	[ZEBRA_REDISTRIBUTE_ADD] = zebra_redistribute_add,
 	[ZEBRA_REDISTRIBUTE_DELETE] = zebra_redistribute_delete,
 	[ZEBRA_REDISTRIBUTE_DEFAULT_ADD] = zebra_redistribute_default_add,
@@ -2948,6 +2423,9 @@ void (*zserv_handlers[])(ZAPI_HANDLER_AR
 	[ZEBRA_BFD_DEST_UPDATE] = zebra_ptm_bfd_dst_register,
 	[ZEBRA_BFD_DEST_REGISTER] = zebra_ptm_bfd_dst_register,
 	[ZEBRA_BFD_DEST_DEREGISTER] = zebra_ptm_bfd_dst_deregister,
+#if HAVE_BFDD > 0
+	[ZEBRA_BFD_DEST_REPLAY] = zebra_ptm_bfd_dst_replay,
+#endif /* HAVE_BFDD */
 	[ZEBRA_VRF_UNREGISTER] = zread_vrf_unregister,
 	[ZEBRA_VRF_LABEL] = zread_vrf_label,
 	[ZEBRA_BFD_CLIENT_REGISTER] = zebra_ptm_bfd_client_register,
@@ -2962,7 +2440,6 @@ void (*zserv_handlers[])(ZAPI_HANDLER_AR
 	[ZEBRA_MPLS_LABELS_DELETE] = zread_mpls_labels,
 	[ZEBRA_IPMR_ROUTE_STATS] = zebra_ipmr_route_stats,
 	[ZEBRA_LABEL_MANAGER_CONNECT] = zread_label_manager_request,
-	[ZEBRA_LABEL_MANAGER_CONNECT_ASYNC] = zread_label_manager_request,
 	[ZEBRA_GET_LABEL_CHUNK] = zread_label_manager_request,
 	[ZEBRA_RELEASE_LABEL_CHUNK] = zread_label_manager_request,
 	[ZEBRA_FEC_REGISTER] = zread_fec_register,
@@ -2992,14 +2469,54 @@ void (*zserv_handlers[])(ZAPI_HANDLER_AR
 	[ZEBRA_IPTABLE_DELETE] = zread_iptable,
 };
 
-void zserv_handle_commands(struct zserv *client, struct zmsghdr *hdr,
-			   struct stream *msg, struct zebra_vrf *zvrf)
+#if defined(HANDLE_ZAPI_FUZZING)
+extern struct zebra_privs_t zserv_privs;
+
+static void zserv_write_incoming(struct stream *orig, uint16_t command)
 {
-	if (hdr->command > array_size(zserv_handlers)
-	    || zserv_handlers[hdr->command] == NULL)
-		zlog_info("Zebra received unknown command %d", hdr->command);
-	else
-		zserv_handlers[hdr->command](client, hdr, msg, zvrf);
+	char fname[MAXPATHLEN];
+	struct stream *copy;
+	int fd = -1;
 
-	stream_free(msg);
+	copy = stream_dup(orig);
+	stream_set_getp(copy, 0);
+
+	snprintf(fname, MAXPATHLEN, "%s/%u", DAEMON_VTY_DIR, command);
+
+	frr_elevate_privs(&zserv_privs) {
+		fd = open(fname, O_CREAT | O_WRONLY | O_EXCL, 0644);
+	}
+	stream_flush(copy, fd);
+	close(fd);
+	stream_free(copy);
+}
+#endif
+
+void zserv_handle_commands(struct zserv *client, struct stream *msg)
+{
+	struct zmsghdr hdr;
+	struct zebra_vrf *zvrf;
+
+	zapi_parse_header(msg, &hdr);
+
+#if defined(HANDLE_ZAPI_FUZZING)
+	zserv_write_incoming(msg, hdr.command);
+#endif
+
+	hdr.length -= ZEBRA_HEADER_SIZE;
+
+	/* lookup vrf */
+	zvrf = zebra_vrf_lookup_by_id(hdr.vrf_id);
+	if (!zvrf) {
+		if (IS_ZEBRA_DEBUG_PACKET && IS_ZEBRA_DEBUG_RECV)
+			zlog_warn("ZAPI message specifies unknown VRF: %d",
+				  hdr.vrf_id);
+		return;
+	}
+
+	if (hdr.command >= array_size(zserv_handlers)
+	    || zserv_handlers[hdr.command] == NULL)
+		zlog_info("Zebra received unknown command %d", hdr.command);
+	else
+		zserv_handlers[hdr.command](client, &hdr, msg, zvrf);
 }
diff -urpN frr-frr-5.0.1/zebra/zapi_msg.h frr-frr-6.0/zebra/zapi_msg.h
--- frr-frr-5.0.1/zebra/zapi_msg.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zapi_msg.h	2018-10-08 14:32:57.000000000 +0200
@@ -28,6 +28,7 @@
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
 #include "zebra/zebra_pbr.h"
+#include "zebra/zebra_errors.h"
 
 /*
  * This is called to process inbound ZAPI messages.
@@ -35,17 +36,10 @@
  * client
  *    the client datastructure
  *
- * hdr
- *    the message header
- *
  * msg
- *    the message contents, without the header
- *
- * zvrf
- *    the vrf
+ *    the message
  */
-extern void zserv_handle_commands(struct zserv *client, struct zmsghdr *hdr,
-				  struct stream *msg, struct zebra_vrf *zvrf);
+extern void zserv_handle_commands(struct zserv *client, struct stream *msg);
 
 extern int zsend_vrf_add(struct zserv *zclient, struct zebra_vrf *zvrf);
 extern int zsend_vrf_delete(struct zserv *zclient, struct zebra_vrf *zvrf);
@@ -63,7 +57,8 @@ extern void nbr_connected_delete_ipv6(st
 extern int zsend_interface_update(int cmd, struct zserv *client,
 				  struct interface *ifp);
 extern int zsend_redistribute_route(int cmd, struct zserv *zclient,
-				    struct prefix *p, struct prefix *src_p,
+				    const struct prefix *p,
+				    const struct prefix *src_p,
 				    struct route_entry *re);
 extern int zsend_router_id_update(struct zserv *zclient, struct prefix *p,
 				  vrf_id_t vrf_id);
@@ -72,7 +67,8 @@ extern int zsend_interface_vrf_update(st
 extern int zsend_interface_link_params(struct zserv *zclient,
 				       struct interface *ifp);
 extern int zsend_pw_update(struct zserv *client, struct zebra_pw *pw);
-extern int zsend_route_notify_owner(struct route_entry *re, struct prefix *p,
+extern int zsend_route_notify_owner(struct route_entry *re,
+				    const struct prefix *p,
 				    enum zapi_route_notify_owner note);
 
 extern void zsend_rule_notify_owner(struct zebra_pbr_rule *rule,
diff -urpN frr-frr-5.0.1/zebra/zebra_errors.c frr-frr-6.0/zebra/zebra_errors.c
--- frr-frr-5.0.1/zebra/zebra_errors.c	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/zebra/zebra_errors.c	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,278 @@
+/*
+ * Zebra-specific error messages.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Quentin Young
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include "lib/ferr.h"
+#include "zebra_errors.h"
+
+/* clang-format off */
+static struct log_ref ferr_zebra_err[] = {
+	{
+		.code = ZEBRA_ERR_LM_RESPONSE,
+		.title = "Error reading response from label manager",
+		.description = "Zebra could not read the ZAPI header from the label manager",
+		.suggestion = "Wait for the error to resolve on its own. If it does not resolve, restart Zebra.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_NO_SUCH_CLIENT,
+		.title = "Label manager could not find ZAPI client",
+		.description = "Zebra was unable to find a ZAPI client matching the given protocol and instance number.",
+		.suggestion = "Ensure clients which use the label manager are properly configured and running.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_RELAY_FAILED,
+		.title = "Zebra could not relay label manager response",
+		.description = "Zebra found the client and instance to relay the label manager response or request to, but was not able to do so, possibly because the connection was closed.",
+		.suggestion = "Ensure clients which use the label manager are properly configured and running.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_BAD_INSTANCE,
+		.title = "Mismatch between ZAPI instance and encoded message instance",
+		.description = "While relaying a request to the external label manager, Zebra noticed that the instance number encoded in the message did not match the client instance number.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_EXHAUSTED_LABELS,
+		.title = "Zebra label manager used all available labels",
+		.description = "Zebra is unable to assign additional label chunks because it has exhausted its assigned label range.",
+		.suggestion = "Make the label range bigger and restart Zebra.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_DAEMON_MISMATCH,
+		.title = "Daemon mismatch when releasing label chunks",
+		.description = "Zebra noticed a mismatch between a label chunk and a protocol daemon number or instance when releasing unused label chunks.",
+		.suggestion = "Ignore this error.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_UNRELEASED_CHUNK,
+		.title = "Zebra did not free any label chunks",
+		.description = "Zebra's chunk cleanup procedure ran, but no label chunks were released.",
+		.suggestion = "Ignore this error.",
+	},
+	{
+		.code = ZEBRA_ERR_DP_INVALID_RC,
+		.title = "Dataplane returned invalid status code",
+		.description = "The underlying dataplane responded to a Zebra message or other interaction with an unrecognized, unknown or invalid status code.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_WQ_NONEXISTENT,
+		.title = "A necessary work queue does not exist.",
+		.description = "A necessary work queue does not exist.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_FEC_ADD_FAILED,
+		.title = "Failed to add FEC for MPLS client",
+		.description = "A client requested a label binding for a new FEC, but Zebra was unable to add the FEC to its internal table.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_FEC_RM_FAILED,
+		.title = "Failed to remove FEC for MPLS client",
+		.description = "Zebra was unable to find and remove a FEC in its internal table.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_IRDP_LEN_MISMATCH,
+		.title = "IRDP message length mismatch",
+		.description = "The length encoded in the IP TLV does not match the length of the packet received.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_RNH_UNKNOWN_FAMILY,
+		.title = "Attempted to perform nexthop update for unknown address family",
+		.description = "Zebra attempted to perform a nexthop update for unknown address family",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_DP_INSTALL_FAIL,
+		.title = "Dataplane installation failure",
+		.description = "Installation of routes to underlying dataplane failed.",
+		.suggestion = "Check all configuration parameters for correctness.",
+	},
+	{
+		.code = ZEBRA_ERR_TABLE_LOOKUP_FAILED,
+		.title = "Zebra table lookup failed",
+		.description = "Zebra attempted to look up a table for a particular address family and subsequent address family, but didn't find anything.",
+		.suggestion = "If you entered a command to trigger this error, make sure you entered the arguments correctly. Check your config file for any potential errors. If these look correct, seek help.",
+	},
+	{
+		.code = ZEBRA_ERR_NETLINK_NOT_AVAILABLE,
+		.title = "Netlink backend not available",
+		.description = "FRR was not compiled with support for Netlink. Any operations that require Netlink will fail.",
+		.suggestion = "Recompile FRR with Netlink, or install a package that supports this feature.",
+	},
+	{
+		.code = ZEBRA_ERR_PROTOBUF_NOT_AVAILABLE,
+		.title = "Protocol Buffers backend not available",
+		.description = "FRR was not compiled with support for Protocol Buffers. Any operations that require Protobuf will fail.",
+		.suggestion = "Recompile FRR with Protobuf support, or install a package that supports this feature.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_EXHAUSTED_IDS,
+		.title = "Table manager used all available IDs",
+		.description = "Zebra's table manager used up all IDs available to it and can't assign any more.",
+		.suggestion = "Reconfigure Zebra with a larger range of table IDs.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_DAEMON_MISMATCH,
+		.title = "Daemon mismatch when releasing table chunks",
+		.description = "Zebra noticed a mismatch between a table ID chunk and a protocol daemon number instance when releasing unused table chunks.",
+		.suggestion = "Ignore this error.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_UNRELEASED_CHUNK,
+		.title = "Zebra did not free any table chunks",
+		.description = "Zebra's table chunk cleanup procedure ran, but no table chunks were released.",
+		.suggestion = "Ignore this error.",
+	},
+	{
+		.code = ZEBRA_ERR_UNKNOWN_FAMILY,
+		.title = "Address family specifier unrecognized",
+		.description = "Zebra attempted to process information from somewhere that included an address family specifier, but did not recognize the provided specifier.",
+		.suggestion = "Ensure that your configuration is correct. If it is, notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_WRONG_PROTO,
+		.title = "Incorrect protocol for table manager client",
+		.description = "Zebra's table manager only accepts connections from daemons managing dynamic routing protocols, but received a connection attempt from a daemon that does not meet this criterion.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_PROTO_OR_INSTANCE_MISMATCH,
+		.title = "Mismatch between message and client protocol and/or instance",
+		.description = "Zebra detected a mismatch between a client's protocol and/or instance numbers versus those stored in a message transiting its socket.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_CANNOT_ASSIGN_CHUNK,
+		.title = "Label manager unable to assign label chunk",
+		.description = "Zebra's label manager was unable to assign a label chunk to client.",
+		.suggestion = "Ensure that Zebra has a sufficient label range available and that there is not a range collision.",
+	},
+	{
+		.code = ZEBRA_ERR_LM_ALIENS,
+		.title = "Label request from unidentified client",
+		.description = "Zebra's label manager received a label request from an unidentified client.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_CANNOT_ASSIGN_CHUNK,
+		.title = "Table manager unable to assign table chunk",
+		.description = "Zebra's table manager was unable to assign a table chunk to a client.",
+		.suggestion = "Ensure that Zebra has sufficient table ID range available and that there is not a range collision.",
+	},
+	{
+		.code = ZEBRA_ERR_TM_ALIENS,
+		.title = "Table request from unidentified client",
+		.description = "Zebra's table manager received a table request from an unidentified client.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_RECVBUF,
+		.title = "Cannot set receive buffer size",
+		.description = "Socket receive buffer size could not be set in the kernel",
+		.suggestion = "Ignore this error.",
+	},
+	{
+		.code = ZEBRA_ERR_UNKNOWN_NLMSG,
+		.title = "Unknown Netlink message type",
+		.description = "Zebra received a Netlink message with an unrecognized type field.",
+		.suggestion = "Verify that you are running the latest version of FRR to ensure kernel compatibility. If the problem persists, notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_RECVMSG_OVERRUN,
+		.title = "Receive buffer overrun",
+		.description = "The kernel's buffer for a socket has been overrun, rendering the socket invalid.",
+		.suggestion = "Zebra will restart itself. Notify a developer if this issue shows up frequently.",
+	},
+	{
+		.code = ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+		.title = "Netlink message length mismatch",
+		.description = "Zebra received a Netlink message with incorrect length fields.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+		.title = "Netlink message length mismatch",
+		.description = "Zebra received a Netlink message with incorrect length fields.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_UNEXPECTED_MESSAGE,
+		.title = "Received unexpected response from kernel",
+		.description = "Received unexpected response from the kernel via Netlink.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_NETLINK_BAD_SEQUENCE,
+		.title = "Bad sequence number in Netlink message",
+		.description = "Zebra received a Netlink message with a bad sequence number.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_BAD_MULTIPATH_NUM,
+		.title = "Multipath number was out of valid range",
+		.description = "Multipath number specified to Zebra must be in the appropriate range",
+		.suggestion = "Provide a multipath number that is within its accepted range",
+	},
+	{
+		.code = ZEBRA_ERR_PREFIX_PARSE_ERROR,
+		.title = "String could not be parsed as IP prefix",
+		.description = "There was an attempt to parse a string as an IPv4 or IPv6 prefix, but the string could not be parsed and this operation failed.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_MAC_ADD_FAILED,
+		.title = "Failed to add MAC address to interface",
+		.description = "Zebra attempted to assign a MAC address to a vxlan interface but failed",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_VNI_DEL_FAILED,
+		.title = "Failed to delete VNI",
+		.description = "Zebra attempted to delete a VNI entry and failed",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_VTEP_ADD_FAILED,
+		.title = "Adding remote VTEP failed",
+		.description = "Zebra attempted to add a remote VTEP and failed.",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = ZEBRA_ERR_VNI_ADD_FAILED,
+		.title = "Adding VNI failed",
+		.description = "Zebra attempted to add a VNI hash to an interface and failed",
+		.suggestion = "Notify a developer.",
+	},
+	{
+		.code = END_FERR,
+	}
+};
+/* clang-format on */
+
+
+void zebra_error_init(void)
+{
+	log_ref_add(ferr_zebra_err);
+}
diff -urpN frr-frr-5.0.1/zebra/zebra_errors.h frr-frr-6.0/zebra/zebra_errors.h
--- frr-frr-5.0.1/zebra/zebra_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ frr-frr-6.0/zebra/zebra_errors.h	2018-10-08 14:32:57.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * Zebra-specific error messages.
+ * Copyright (C) 2018  Cumulus Networks, Inc.
+ *                     Quentin Young
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __ZEBRA_ERRORS_H__
+#define __ZEBRA_ERRORS_H__
+
+#include "lib/ferr.h"
+
+enum zebra_log_refs {
+	ZEBRA_ERR_LM_RESPONSE = ZEBRA_FERR_START,
+	ZEBRA_ERR_LM_NO_SUCH_CLIENT,
+	ZEBRA_ERR_LM_RELAY_FAILED,
+	ZEBRA_ERR_LM_NO_SOCKET,
+	ZEBRA_ERR_LM_BAD_INSTANCE,
+	ZEBRA_ERR_LM_RELAY_REQUEST_FAILED,
+	ZEBRA_ERR_LM_CLIENT_CONNECTION_FAILED,
+	ZEBRA_ERR_LM_EXHAUSTED_LABELS,
+	ZEBRA_ERR_LM_DAEMON_MISMATCH,
+	ZEBRA_ERR_LM_UNRELEASED_CHUNK,
+	ZEBRA_ERR_DP_INVALID_RC,
+	ZEBRA_ERR_WQ_NONEXISTENT,
+	ZEBRA_ERR_FEC_ADD_FAILED,
+	ZEBRA_ERR_FEC_RM_FAILED,
+	ZEBRA_ERR_IRDP_LEN_MISMATCH,
+	ZEBRA_ERR_RNH_UNKNOWN_FAMILY,
+	ZEBRA_ERR_DP_INSTALL_FAIL,
+	ZEBRA_ERR_TABLE_LOOKUP_FAILED,
+	ZEBRA_ERR_NETLINK_NOT_AVAILABLE,
+	ZEBRA_ERR_PROTOBUF_NOT_AVAILABLE,
+	ZEBRA_ERR_TM_EXHAUSTED_IDS,
+	ZEBRA_ERR_TM_DAEMON_MISMATCH,
+	ZEBRA_ERR_TM_UNRELEASED_CHUNK,
+	ZEBRA_ERR_UNKNOWN_FAMILY,
+	ZEBRA_ERR_TM_WRONG_PROTO,
+	ZEBRA_ERR_PROTO_OR_INSTANCE_MISMATCH,
+	ZEBRA_ERR_LM_CANNOT_ASSIGN_CHUNK,
+	ZEBRA_ERR_LM_ALIENS,
+	ZEBRA_ERR_TM_CANNOT_ASSIGN_CHUNK,
+	ZEBRA_ERR_TM_ALIENS,
+	ZEBRA_ERR_RECVBUF,
+	ZEBRA_ERR_UNKNOWN_NLMSG,
+	ZEBRA_ERR_RECVMSG_OVERRUN,
+	ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+	ZEBRA_ERR_UNEXPECTED_MESSAGE,
+	ZEBRA_ERR_NETLINK_BAD_SEQUENCE,
+	ZEBRA_ERR_BAD_MULTIPATH_NUM,
+	ZEBRA_ERR_PREFIX_PARSE_ERROR,
+	ZEBRA_ERR_MAC_ADD_FAILED,
+	ZEBRA_ERR_VNI_DEL_FAILED,
+	ZEBRA_ERR_VTEP_ADD_FAILED,
+	ZEBRA_ERR_VNI_ADD_FAILED,
+};
+
+void zebra_error_init(void);
+
+#endif /* __ZEBRA_ERRORS_H__ */
diff -urpN frr-frr-5.0.1/zebra/zebra_fpm.c frr-frr-6.0/zebra/zebra_fpm.c
--- frr-frr-5.0.1/zebra/zebra_fpm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_fpm.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,6 +35,7 @@
 #include "zebra/zserv.h"
 #include "zebra/zebra_ns.h"
 #include "zebra/zebra_vrf.h"
+#include "zebra/zebra_errors.h"
 
 #include "fpm/fpm.h"
 #include "zebra_fpm_private.h"
@@ -1517,7 +1518,9 @@ static inline void zfpm_init_message_for
 
 	if (!strcmp("netlink", format)) {
 		if (!have_netlink) {
-			zlog_err("FPM netlink message format is not available");
+			flog_err(
+				ZEBRA_ERR_NETLINK_NOT_AVAILABLE,
+				"FPM netlink message format is not available");
 			return;
 		}
 		zfpm_g->message_format = ZFPM_MSG_FORMAT_NETLINK;
@@ -1526,7 +1529,8 @@ static inline void zfpm_init_message_for
 
 	if (!strcmp("protobuf", format)) {
 		if (!have_protobuf) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_PROTOBUF_NOT_AVAILABLE,
 				"FPM protobuf message format is not available");
 			return;
 		}
diff -urpN frr-frr-5.0.1/zebra/zebra_mpls.c frr-frr-6.0/zebra/zebra_mpls.c
--- frr-frr-5.0.1/zebra/zebra_mpls.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mpls.c	2018-10-08 14:32:57.000000000 +0200
@@ -38,12 +38,14 @@
 
 #include "zebra/rib.h"
 #include "zebra/rt.h"
+#include "zebra/interface.h"
 #include "zebra/zserv.h"
 #include "zebra/redistribute.h"
 #include "zebra/debug.h"
 #include "zebra/zebra_memory.h"
 #include "zebra/zebra_vrf.h"
 #include "zebra/zebra_mpls.h"
+#include "zebra/zebra_errors.h"
 
 DEFINE_MTYPE_STATIC(ZEBRA, LSP, "MPLS LSP object")
 DEFINE_MTYPE_STATIC(ZEBRA, FEC, "MPLS FEC object")
@@ -463,7 +465,7 @@ static int fec_send(zebra_fec_t *fec, st
 	stream_put_prefix(s, &rn->p);
 	stream_putl(s, fec->label);
 	stream_putw_at(s, 0, stream_get_endp(s));
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -549,8 +551,6 @@ static zebra_fec_t *fec_add(struct route
 
 	if (!fec) {
 		fec = XCALLOC(MTYPE_FEC, sizeof(zebra_fec_t));
-		if (!fec)
-			return NULL;
 
 		rn->info = fec;
 		fec->rn = rn;
@@ -704,6 +704,7 @@ static int nhlfe_nexthop_active(zebra_nh
 {
 	struct nexthop *nexthop;
 	struct interface *ifp;
+	struct zebra_ns *zns;
 
 	nexthop = nhlfe->nexthop;
 	if (!nexthop) // unexpected
@@ -721,7 +722,8 @@ static int nhlfe_nexthop_active(zebra_nh
 		 * which will not be in the default
 		 * VRF.  So let's look in all of them
 		 */
-		ifp = if_lookup_by_index(nexthop->ifindex, VRF_UNKNOWN);
+		zns = zebra_ns_lookup(NS_DEFAULT);
+		ifp = if_lookup_by_index_per_ns(zns, nexthop->ifindex);
 		if (ifp && if_is_operative(ifp))
 			SET_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE);
 		else
@@ -860,7 +862,7 @@ static void lsp_uninstall_from_kernel(st
 
 	lsp = (zebra_lsp_t *)backet->data;
 	if (CHECK_FLAG(lsp->flags, LSP_FLAG_INSTALLED))
-		kernel_del_lsp(lsp);
+		(void)kernel_del_lsp(lsp);
 }
 
 /*
@@ -914,17 +916,35 @@ static wq_item_status lsp_process(struct
 		if (newbest) {
 
 			UNSET_FLAG(lsp->flags, LSP_FLAG_CHANGED);
-			kernel_add_lsp(lsp);
-
-			zvrf->lsp_installs++;
+			switch (kernel_add_lsp(lsp)) {
+			case DP_REQUEST_QUEUED:
+				flog_err(
+					ZEBRA_ERR_DP_INVALID_RC,
+					"No current DataPlane interfaces can return this, please fix");
+				break;
+			case DP_REQUEST_FAILURE:
+				break;
+			case DP_REQUEST_SUCCESS:
+				zvrf->lsp_installs++;
+				break;
+			}
 		}
 	} else {
 		/* Installed, may need an update and/or delete. */
 		if (!newbest) {
 
-			kernel_del_lsp(lsp);
-
-			zvrf->lsp_removals++;
+			switch (kernel_del_lsp(lsp)) {
+			case DP_REQUEST_QUEUED:
+				flog_err(
+					ZEBRA_ERR_DP_INVALID_RC,
+					"No current DataPlane interfaces can return this, please fix");
+				break;
+			case DP_REQUEST_FAILURE:
+				break;
+			case DP_REQUEST_SUCCESS:
+				zvrf->lsp_removals++;
+				break;
+			}
 		} else if (CHECK_FLAG(lsp->flags, LSP_FLAG_CHANGED)) {
 			zebra_nhlfe_t *nhlfe;
 			struct nexthop *nexthop;
@@ -953,9 +973,18 @@ static wq_item_status lsp_process(struct
 				}
 			}
 
-			kernel_upd_lsp(lsp);
-
-			zvrf->lsp_installs++;
+			switch (kernel_upd_lsp(lsp)) {
+			case DP_REQUEST_QUEUED:
+				flog_err(
+					ZEBRA_ERR_DP_INVALID_RC,
+					"No current DataPlane interfaces can return this, please fix");
+				break;
+			case DP_REQUEST_FAILURE:
+				break;
+			case DP_REQUEST_SUCCESS:
+				zvrf->lsp_installs++;
+				break;
+			}
 		}
 	}
 
@@ -1026,7 +1055,8 @@ static int lsp_processq_add(zebra_lsp_t
 		return 0;
 
 	if (zebrad.lsp_process_q == NULL) {
-		zlog_err("%s: work_queue does not exist!", __func__);
+		flog_err(ZEBRA_ERR_WQ_NONEXISTENT,
+			  "%s: work_queue does not exist!", __func__);
 		return -1;
 	}
 
@@ -1157,8 +1187,6 @@ static zebra_nhlfe_t *nhlfe_add(zebra_ls
 		return NULL;
 
 	nhlfe = XCALLOC(MTYPE_NHLFE, sizeof(zebra_nhlfe_t));
-	if (!nhlfe)
-		return NULL;
 
 	nhlfe->lsp = lsp;
 	nhlfe->type = lsp_type;
@@ -1670,7 +1698,8 @@ static int mpls_processq_init(struct zeb
 {
 	zebra->lsp_process_q = work_queue_new(zebra->master, "LSP processing");
 	if (!zebra->lsp_process_q) {
-		zlog_err("%s: could not initialise work queue!", __func__);
+		flog_err(ZEBRA_ERR_WQ_NONEXISTENT,
+			  "%s: could not initialise work queue!", __func__);
 		return -1;
 	}
 
@@ -1687,7 +1716,7 @@ static int mpls_processq_init(struct zeb
 
 /* Public functions */
 
-void kernel_lsp_pass_fail(zebra_lsp_t *lsp, enum southbound_results res)
+void kernel_lsp_pass_fail(zebra_lsp_t *lsp, enum dp_results res)
 {
 	struct nexthop *nexthop;
 	zebra_nhlfe_t *nhlfe;
@@ -1696,12 +1725,12 @@ void kernel_lsp_pass_fail(zebra_lsp_t *l
 		return;
 
 	switch (res) {
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		UNSET_FLAG(lsp->flags, LSP_FLAG_INSTALLED);
 		clear_nhlfe_installed(lsp);
 		zlog_warn("LSP Install Failure: %u", lsp->ile.in_label);
 		break;
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		SET_FLAG(lsp->flags, LSP_FLAG_INSTALLED);
 		for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next) {
 			nexthop = nhlfe->nexthop;
@@ -1712,11 +1741,11 @@ void kernel_lsp_pass_fail(zebra_lsp_t *l
 			SET_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB);
 		}
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		UNSET_FLAG(lsp->flags, LSP_FLAG_INSTALLED);
 		clear_nhlfe_installed(lsp);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		zlog_warn("LSP Deletion Failure: %u", lsp->ile.in_label);
 		break;
 	}
@@ -1805,7 +1834,8 @@ int zebra_mpls_fec_register(struct zebra
 		fec = fec_add(table, p, MPLS_INVALID_LABEL, 0, label_index);
 		if (!fec) {
 			prefix2str(p, buf, BUFSIZ);
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_FEC_ADD_FAILED,
 				"Failed to add FEC %s upon register, client %s",
 				buf, zebra_route_string(client->proto));
 			return -1;
@@ -1885,8 +1915,9 @@ int zebra_mpls_fec_unregister(struct zeb
 	fec = fec_find(table, p);
 	if (!fec) {
 		prefix2str(p, buf, BUFSIZ);
-		zlog_err("Failed to find FEC %s upon unregister, client %s",
-			 buf, zebra_route_string(client->proto));
+		flog_err(ZEBRA_ERR_FEC_RM_FAILED,
+			  "Failed to find FEC %s upon unregister, client %s",
+			  buf, zebra_route_string(client->proto));
 		return -1;
 	}
 
@@ -2016,7 +2047,8 @@ int zebra_mpls_static_fec_add(struct zeb
 			      MPLS_INVALID_LABEL_INDEX);
 		if (!fec) {
 			prefix2str(p, buf, BUFSIZ);
-			zlog_err("Failed to add FEC %s upon config", buf);
+			flog_err(ZEBRA_ERR_FEC_ADD_FAILED,
+				  "Failed to add FEC %s upon config", buf);
 			return -1;
 		}
 
@@ -2063,7 +2095,8 @@ int zebra_mpls_static_fec_del(struct zeb
 	fec = fec_find(table, p);
 	if (!fec) {
 		prefix2str(p, buf, BUFSIZ);
-		zlog_err("Failed to find FEC %s upon delete", buf);
+		flog_err(ZEBRA_ERR_FEC_RM_FAILED,
+			  "Failed to find FEC %s upon delete", buf);
 		return -1;
 	}
 
@@ -2413,7 +2446,7 @@ void mpls_ldp_lsp_uninstall_all(struct h
 	struct hash *lsp_table;
 
 	lsp = (zebra_lsp_t *)backet->data;
-	if (!lsp || !lsp->nhlfe_list)
+	if (!lsp->nhlfe_list)
 		return;
 
 	lsp_table = ctxt;
@@ -2731,10 +2764,13 @@ void zebra_mpls_print_lsp_table(struct v
 
 				switch (nexthop->type) {
 				case NEXTHOP_TYPE_IFINDEX: {
+					struct zebra_ns *zns;
 					struct interface *ifp;
 
-					ifp = if_lookup_by_index(
-						nexthop->ifindex, VRF_UNKNOWN);
+					zns = zebra_ns_lookup(NS_DEFAULT);
+					ifp = if_lookup_by_index_per_ns(
+							zns,
+							nexthop->ifindex);
 					vty_out(vty, "%15s", ifp->name);
 					break;
 				}
@@ -2916,5 +2952,5 @@ void zebra_mpls_init(void)
 	if (!mpls_processq_init(&zebrad))
 		mpls_enabled = 1;
 
-	hook_register(zapi_client_close, zebra_mpls_cleanup_fecs_for_client);
+	hook_register(zserv_client_close, zebra_mpls_cleanup_fecs_for_client);
 }
diff -urpN frr-frr-5.0.1/zebra/zebra_mpls_netlink.c frr-frr-6.0/zebra/zebra_mpls_netlink.c
--- frr-frr-5.0.1/zebra/zebra_mpls_netlink.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mpls_netlink.c	2018-10-08 14:32:57.000000000 +0200
@@ -29,20 +29,22 @@
 /*
  * Install Label Forwarding entry into the kernel.
  */
-void kernel_add_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_add_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp || !lsp->best_nhlfe) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_INSTALL_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_INSTALL_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = netlink_mpls_multipath(RTM_NEWROUTE, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-				    : SOUTHBOUND_INSTALL_FAILURE);
+			     (!ret) ? DP_INSTALL_SUCCESS
+				    : DP_INSTALL_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 /*
@@ -56,44 +58,48 @@ void kernel_add_lsp(zebra_lsp_t *lsp)
  * through the metric field (before kernel-MPLS). This shouldn't be an issue
  * any longer, so REPLACE can be reintroduced.
  */
-void kernel_upd_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_upd_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp || !lsp->best_nhlfe) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_INSTALL_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_INSTALL_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = netlink_mpls_multipath(RTM_NEWROUTE, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-				    : SOUTHBOUND_INSTALL_FAILURE);
+			     (!ret) ? DP_INSTALL_SUCCESS
+				    : DP_INSTALL_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 /*
  * Delete Label Forwarding entry from the kernel.
  */
-void kernel_del_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_del_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_DELETE_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_DELETE_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	if (!CHECK_FLAG(lsp->flags, LSP_FLAG_INSTALLED)) {
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_DELETE_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_DELETE_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = netlink_mpls_multipath(RTM_DELROUTE, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_DELETE_SUCCESS
-				    : SOUTHBOUND_DELETE_FAILURE);
+			     (!ret) ? DP_DELETE_SUCCESS
+				    : DP_DELETE_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 int mpls_kernel_init(void)
diff -urpN frr-frr-5.0.1/zebra/zebra_mpls_null.c frr-frr-6.0/zebra/zebra_mpls_null.c
--- frr-frr-5.0.1/zebra/zebra_mpls_null.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mpls_null.c	2018-10-08 14:32:57.000000000 +0200
@@ -24,18 +24,21 @@
 
 #if !defined(HAVE_NETLINK) && !defined(OPEN_BSD)
 
-void kernel_add_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_add_lsp(zebra_lsp_t *lsp)
 {
-	return;
+	return DP_REQUEST_SUCCESS;
 }
-void kernel_upd_lsp(zebra_lsp_t *lsp)
+
+enum dp_req_result kernel_upd_lsp(zebra_lsp_t *lsp)
 {
-	return;
+	return DP_REQUEST_SUCCESS;
 }
-void kernel_del_lsp(zebra_lsp_t *lsp)
+
+enum dp_req_result kernel_del_lsp(zebra_lsp_t *lsp)
 {
-	return;
+	return DP_REQUEST_SUCCESS;
 }
+
 int mpls_kernel_init(void)
 {
 	return -1;
diff -urpN frr-frr-5.0.1/zebra/zebra_mpls_openbsd.c frr-frr-6.0/zebra/zebra_mpls_openbsd.c
--- frr-frr-5.0.1/zebra/zebra_mpls_openbsd.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mpls_openbsd.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "prefix.h"
 #include "interface.h"
 #include "log.h"
+#include "lib_errors.h"
 
 extern struct zebra_privs_t zserv_privs;
 
@@ -116,14 +117,13 @@ static int kernel_send_rtmsg_v4(int acti
 			hdr.rtm_mpls = MPLS_OP_SWAP;
 	}
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ret = writev(kr_state.fd, iov, iovcnt);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ret = writev(kr_state.fd, iov, iovcnt);
+	}
 
 	if (ret == -1)
-		zlog_err("%s: %s", __func__, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: %s", __func__,
+			     safe_strerror(errno));
 
 	return ret;
 }
@@ -224,14 +224,13 @@ static int kernel_send_rtmsg_v6(int acti
 			hdr.rtm_mpls = MPLS_OP_SWAP;
 	}
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ret = writev(kr_state.fd, iov, iovcnt);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ret = writev(kr_state.fd, iov, iovcnt);
+	}
 
 	if (ret == -1)
-		zlog_err("%s: %s", __func__, safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "%s: %s", __func__,
+			     safe_strerror(errno));
 
 	return ret;
 }
@@ -285,58 +284,62 @@ static int kernel_lsp_cmd(int action, ze
 	return (0);
 }
 
-void kernel_add_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_add_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp || !lsp->best_nhlfe) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_INSTALL_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_INSTALL_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = kernel_lsp_cmd(RTM_ADD, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-				    : SOUTHBOUND_INSTALL_FAILURE);
+			     (!ret) ? DP_INSTALL_SUCCESS
+				    : DP_INSTALL_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
-void kernel_upd_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_upd_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp || !lsp->best_nhlfe) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_INSTALL_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_INSTALL_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = kernel_lsp_cmd(RTM_CHANGE, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_INSTALL_SUCCESS
-				    : SOUTHBOUND_INSTALL_FAILURE);
-	return;
+			     (!ret) ? DP_INSTALL_SUCCESS
+				    : DP_INSTALL_FAILURE);
+	return DP_REQUEST_SUCCESS;
 }
 
-void kernel_del_lsp(zebra_lsp_t *lsp)
+enum dp_req_result kernel_del_lsp(zebra_lsp_t *lsp)
 {
 	int ret;
 
 	if (!lsp) { // unexpected
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_DELETE_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_DELETE_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	if (!CHECK_FLAG(lsp->flags, LSP_FLAG_INSTALLED)) {
-		kernel_lsp_pass_fail(lsp, SOUTHBOUND_DELETE_FAILURE);
-		return;
+		kernel_lsp_pass_fail(lsp, DP_DELETE_FAILURE);
+		return DP_REQUEST_FAILURE;
 	}
 
 	ret = kernel_lsp_cmd(RTM_DELETE, lsp);
 
 	kernel_lsp_pass_fail(lsp,
-			     (!ret) ? SOUTHBOUND_DELETE_SUCCESS
-				    : SOUTHBOUND_DELETE_FAILURE);
+			     (!ret) ? DP_DELETE_SUCCESS
+				    : DP_DELETE_FAILURE);
+
+	return DP_REQUEST_SUCCESS;
 }
 
 static int kmpw_install(struct zebra_pw *pw)
@@ -356,8 +359,8 @@ static int kmpw_install(struct zebra_pw
 		imr.imr_type = IMR_TYPE_ETHERNET_TAGGED;
 		break;
 	default:
-		zlog_err("%s: unhandled pseudowire type (%#X)", __func__,
-			 pw->type);
+		zlog_warn("%s: unhandled pseudowire type (%#X)", __func__,
+			  pw->type);
 		return -1;
 	}
 
@@ -378,8 +381,8 @@ static int kmpw_install(struct zebra_pw
 		sa_in6->sin6_addr = pw->nexthop.ipv6;
 		break;
 	default:
-		zlog_err("%s: unhandled pseudowire address-family (%u)",
-			 __func__, pw->af);
+		zlog_warn("%s: unhandled pseudowire address-family (%u)",
+			  __func__, pw->af);
 		return -1;
 	}
 	memcpy(&imr.imr_nexthop, (struct sockaddr *)&ss,
@@ -394,7 +397,8 @@ static int kmpw_install(struct zebra_pw
 	strlcpy(ifr.ifr_name, pw->ifname, sizeof(ifr.ifr_name));
 	ifr.ifr_data = (caddr_t)&imr;
 	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr) == -1) {
-		zlog_err("ioctl SIOCSETMPWCFG: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL, "ioctl SIOCSETMPWCFG: %s",
+			     safe_strerror(errno));
 		return -1;
 	}
 
@@ -411,7 +415,8 @@ static int kmpw_uninstall(struct zebra_p
 	strlcpy(ifr.ifr_name, pw->ifname, sizeof(ifr.ifr_name));
 	ifr.ifr_data = (caddr_t)&imr;
 	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr) == -1) {
-		zlog_err("ioctl SIOCSETMPWCFG: %s", safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SYSTEM_CALL, "ioctl SIOCSETMPWCFG: %s",
+			     safe_strerror(errno));
 		return -1;
 	}
 
diff -urpN frr-frr-5.0.1/zebra/zebra_mpls_vty.c frr-frr-6.0/zebra/zebra_mpls_vty.c
--- frr-frr-5.0.1/zebra/zebra_mpls_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mpls_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -37,7 +37,6 @@
 #include "zebra/zebra_rnh.h"
 #include "zebra/redistribute.h"
 #include "zebra/zebra_routemap.h"
-#include "zebra/zebra_static.h"
 
 static int zebra_mpls_transit_lsp(struct vty *vty, int add_cmd,
 				  const char *inlabel_str, const char *gate_str,
diff -urpN frr-frr-5.0.1/zebra/zebra_mroute.c frr-frr-6.0/zebra/zebra_mroute.c
--- frr-frr-5.0.1/zebra/zebra_mroute.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_mroute.c	2018-10-08 14:32:57.000000000 +0200
@@ -67,5 +67,5 @@ stream_failure:
 	stream_putl(s, suc);
 
 	stream_putw_at(s, 0, stream_get_endp(s));
-	zebra_server_send_message(client, s);
+	zserv_send_message(client, s);
 }
diff -urpN frr-frr-5.0.1/zebra/zebra_netns_id.c frr-frr-6.0/zebra/zebra_netns_id.c
--- frr-frr-5.0.1/zebra/zebra_netns_id.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_netns_id.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,6 +22,7 @@
 #include "ns.h"
 #include "vrf.h"
 #include "log.h"
+#include "lib_errors.h"
 
 #if defined(HAVE_NETLINK)
 
@@ -34,7 +35,8 @@
 #include "kernel_netlink.h"
 #endif /* defined(HAVE_NETLINK) */
 
-#include "zebra_netns_id.h"
+#include "zebra/zebra_netns_id.h"
+#include "zebra/zebra_errors.h"
 
 /* default NS ID value used when VRF backend is not NETNS */
 #define NS_DEFAULT_INTERNAL 0
@@ -86,8 +88,8 @@ static int send_receive(int sock, struct
 	ret = sendto(sock, (const void *)nlh, (size_t)nlh->nlmsg_len, 0,
 		     (struct sockaddr *)&snl, (socklen_t)sizeof(snl));
 	if (ret < 0) {
-		zlog_err("netlink( %u) sendmsg() error: %s", sock,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "netlink( %u) sendmsg() error: %s",
+			     sock, safe_strerror(errno));
 		return -1;
 	}
 
@@ -107,16 +109,20 @@ static int send_receive(int sock, struct
 	};
 	ret = recvmsg(sock, &msg, 0);
 	if (ret < 0) {
-		zlog_err("netlink recvmsg: error %d (errno %u)", ret, errno);
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "netlink recvmsg: error %d (errno %u)", ret,
+			     errno);
 		return -1;
 	}
 	if (msg.msg_flags & MSG_TRUNC) {
-		zlog_err("netlink recvmsg : error message truncated");
+		flog_err(ZEBRA_ERR_NETLINK_LENGTH_ERROR,
+			  "netlink recvmsg : error message truncated");
 		return -1;
 	}
 	/* nlh already points to buf */
 	if (nlh->nlmsg_seq != seq) {
-		zlog_err(
+		flog_err(
+			ZEBRA_ERR_NETLINK_BAD_SEQUENCE,
 			"netlink recvmsg: bad sequence number %x (expected %x)",
 			seq, nlh->nlmsg_seq);
 		return -1;
@@ -170,8 +176,8 @@ ns_id_t zebra_ns_id_get(const char *netn
 	/* netlink socket */
 	sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
 	if (sock < 0) {
-		zlog_err("netlink( %u) socket() error: %s", sock,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET, "netlink( %u) socket() error: %s",
+			     sock, safe_strerror(errno));
 		close(fd);
 		return NS_UNKNOWN;
 	}
@@ -181,8 +187,9 @@ ns_id_t zebra_ns_id_get(const char *netn
 	snl.nl_pid = 0; /* AUTO PID */
 	ret = bind(sock, (struct sockaddr *)&snl, sizeof(snl));
 	if (ret < 0) {
-		zlog_err("netlink( %u) socket() bind error: %s", sock,
-			 safe_strerror(errno));
+		flog_err_sys(LIB_ERR_SOCKET,
+			     "netlink( %u) socket() bind error: %s", sock,
+			     safe_strerror(errno));
 		close(sock);
 		close(fd);
 		return NS_UNKNOWN;
@@ -255,7 +262,8 @@ ns_id_t zebra_ns_id_get(const char *netn
 
 	if (ret <= 0) {
 		if (errno != EEXIST && ret != 0) {
-			zlog_err(
+			flog_err(
+				LIB_ERR_SOCKET,
 				"netlink( %u) recvfrom() error 2 when reading: %s",
 				fd, safe_strerror(errno));
 			close(sock);
@@ -307,7 +315,7 @@ ns_id_t zebra_ns_id_get(const char *netn
 			nlh = (struct nlmsghdr *)((char *)nlh
 						  + NETLINK_ALIGN(
 							    nlh->nlmsg_len));
-		} while (len != 0 && return_nsid != NS_UNKNOWN && ret == 0);
+		} while (len != 0 && ret == 0);
 	}
 
 	close(fd);
diff -urpN frr-frr-5.0.1/zebra/zebra_netns_notify.c frr-frr-6.0/zebra/zebra_netns_notify.c
--- frr-frr-5.0.1/zebra/zebra_netns_notify.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_netns_notify.c	2018-10-08 14:32:57.000000000 +0200
@@ -34,6 +34,7 @@
 #include "ns.h"
 #include "command.h"
 #include "memory.h"
+#include "lib_errors.h"
 
 #include "zserv.h"
 #include "zebra_memory.h"
@@ -75,11 +76,11 @@ static void zebra_ns_notify_create_conte
 	if (netnspath == NULL)
 		return;
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ns_id = zebra_ns_id_get(netnspath);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ns_id = zebra_ns_id_get(netnspath);
+	}
+	if (ns_id == NS_UNKNOWN)
+		return;
 	ns_id_external = ns_map_nsid_with_external(ns_id, true);
 	/* if VRF with NS ID already present */
 	vrf = vrf_lookup_by_id((vrf_id_t)ns_id_external);
@@ -94,15 +95,14 @@ static void zebra_ns_notify_create_conte
 		ns_map_nsid_with_external(ns_id, false);
 		return;
 	}
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ret = vrf_netns_handler_create(NULL, vrf, netnspath,
-				       ns_id_external, ns_id);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ret = vrf_netns_handler_create(NULL, vrf, netnspath,
+					       ns_id_external, ns_id);
+	}
 	if (ret != CMD_SUCCESS) {
 		zlog_warn("NS notify : failed to create NS %s", netnspath);
 		ns_map_nsid_with_external(ns_id, false);
+		vrf_delete(vrf);
 		return;
 	}
 	zlog_info("NS notify : created VRF %s NS %s", name, netnspath);
@@ -165,20 +165,16 @@ static int zebra_ns_ready_read(struct th
 	netnspath = zns_info->netnspath;
 	if (--zns_info->retries == 0)
 		stop_retry = 1;
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	err = ns_switch_to_netns(netnspath);
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		err = ns_switch_to_netns(netnspath);
+	}
 	if (err < 0)
 		return zebra_ns_continue_read(zns_info, stop_retry);
 
 	/* go back to default ns */
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	err = ns_switchback_to_initial();
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		err = ns_switchback_to_initial();
+	}
 	if (err < 0)
 		return zebra_ns_continue_read(zns_info, stop_retry);
 
@@ -212,6 +208,18 @@ static int zebra_ns_notify_read(struct t
 			continue;
 		if (event->mask & IN_DELETE)
 			return zebra_ns_delete(event->name);
+
+		if (offsetof(struct inotify_event, name) + event->len
+		    >= sizeof(buf)) {
+			zlog_err("NS notify read: buffer underflow");
+			break;
+		}
+
+		if (strnlen(event->name, event->len) == event->len) {
+			zlog_err("NS notify error: bad event name");
+			break;
+		}
+
 		netnspath = ns_netns_pathname(NULL, event->name);
 		if (!netnspath)
 			continue;
diff -urpN frr-frr-5.0.1/zebra/zebra_ns.c frr-frr-6.0/zebra/zebra_ns.c
--- frr-frr-5.0.1/zebra/zebra_ns.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_ns.c	2018-10-08 14:32:57.000000000 +0200
@@ -26,6 +26,7 @@
 #include "lib/logicalrouter.h"
 #include "lib/prefix.h"
 #include "lib/memory.h"
+#include "lib/lib_errors.h"
 
 #include "rtadv.h"
 #include "zebra_ns.h"
@@ -55,10 +56,15 @@ static struct zebra_ns *dzns;
 static inline int zebra_ns_table_entry_compare(const struct zebra_ns_table *e1,
 					       const struct zebra_ns_table *e2)
 {
-	if (e1->tableid == e2->tableid)
-		return (e1->afi - e2->afi);
-
-	return e1->tableid - e2->tableid;
+	if (e1->tableid < e2->tableid)
+		return -1;
+	if (e1->tableid > e2->tableid)
+		return 1;
+	if (e1->ns_id < e2->ns_id)
+		return -1;
+	if (e1->ns_id > e2->ns_id)
+		return 1;
+	return (e1->afi - e2->afi);
 }
 
 static int logicalrouter_config_write(struct vty *vty);
@@ -177,6 +183,7 @@ struct route_table *zebra_ns_find_table(
 	memset(&finder, 0, sizeof(finder));
 	finder.afi = afi;
 	finder.tableid = tableid;
+	finder.ns_id = zns->ns_id;
 	znst = RB_FIND(zebra_ns_table_head, &zns->ns_tables, &finder);
 
 	if (znst)
@@ -193,9 +200,11 @@ unsigned long zebra_ns_score_proto(uint8
 
 	zns = zebra_ns_lookup(NS_DEFAULT);
 
-	RB_FOREACH (znst, zebra_ns_table_head, &zns->ns_tables)
+	RB_FOREACH (znst, zebra_ns_table_head, &zns->ns_tables) {
+		if (znst->ns_id != NS_DEFAULT)
+			continue;
 		cnt += rib_score_proto_table(proto, instance, znst->table);
-
+	}
 	return cnt;
 }
 
@@ -206,8 +215,11 @@ void zebra_ns_sweep_route(void)
 
 	zns = zebra_ns_lookup(NS_DEFAULT);
 
-	RB_FOREACH (znst, zebra_ns_table_head, &zns->ns_tables)
+	RB_FOREACH (znst, zebra_ns_table_head, &zns->ns_tables) {
+		if (znst->ns_id != NS_DEFAULT)
+			continue;
 		rib_sweep_table(znst->table);
+	}
 }
 
 struct route_table *zebra_ns_get_table(struct zebra_ns *zns,
@@ -221,6 +233,7 @@ struct route_table *zebra_ns_get_table(s
 	memset(&finder, 0, sizeof(finder));
 	finder.afi = afi;
 	finder.tableid = tableid;
+	finder.ns_id = zns->ns_id;
 	znst = RB_FIND(zebra_ns_table_head, &zns->ns_tables, &finder);
 
 	if (znst)
@@ -229,6 +242,7 @@ struct route_table *zebra_ns_get_table(s
 	znst = XCALLOC(MTYPE_ZEBRA_NS, sizeof(*znst));
 	znst->tableid = tableid;
 	znst->afi = afi;
+	znst->ns_id = zns->ns_id;
 	znst->table =
 		(afi == AFI_IP6) ? srcdest_table_init() : route_table_init();
 
@@ -257,7 +271,7 @@ static void zebra_ns_free_table(struct z
 
 int zebra_ns_disable(ns_id_t ns_id, void **info)
 {
-	struct zebra_ns_table *znst;
+	struct zebra_ns_table *znst, *tmp;
 	struct zebra_ns *zns = (struct zebra_ns *)(*info);
 
 	hash_clean(zns->rules_hash, zebra_pbr_rules_free);
@@ -271,9 +285,9 @@ int zebra_ns_disable(ns_id_t ns_id, void
 		   zebra_pbr_iptable_free);
 	hash_free(zns->iptable_hash);
 
-	while (!RB_EMPTY(zebra_ns_table_head, &zns->ns_tables)) {
-		znst = RB_ROOT(zebra_ns_table_head, &zns->ns_tables);
-
+	RB_FOREACH_SAFE (znst, zebra_ns_table_head, &zns->ns_tables, tmp) {
+		if (znst->ns_id != ns_id)
+			continue;
 		RB_REMOVE(zebra_ns_table_head, &zns->ns_tables, znst);
 		zebra_ns_free_table(znst);
 	}
@@ -301,11 +315,9 @@ int zebra_ns_init(void)
 
 	dzns = zebra_ns_alloc();
 
-	if (zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
-	ns_id = zebra_ns_id_get_default();
-	if (zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
+	frr_elevate_privs(&zserv_privs) {
+		ns_id = zebra_ns_id_get_default();
+	}
 	ns_id_external = ns_map_nsid_with_external(ns_id, true);
 	ns_init_management(ns_id_external, ns_id);
 
diff -urpN frr-frr-5.0.1/zebra/zebra_ns.h frr-frr-6.0/zebra/zebra_ns.h
--- frr-frr-5.0.1/zebra/zebra_ns.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_ns.h	2018-10-08 14:32:57.000000000 +0200
@@ -43,6 +43,7 @@ struct zebra_ns_table {
 
 	uint32_t tableid;
 	afi_t afi;
+	ns_id_t ns_id;
 
 	struct route_table *table;
 };
diff -urpN frr-frr-5.0.1/zebra/zebra_pbr.c frr-frr-6.0/zebra/zebra_pbr.c
--- frr-frr-5.0.1/zebra/zebra_pbr.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_pbr.c	2018-10-08 14:32:57.000000000 +0200
@@ -30,6 +30,7 @@
 #include "zebra/rt.h"
 #include "zebra/zapi_msg.h"
 #include "zebra/zebra_memory.h"
+#include "zebra/zserv.h"
 
 /* definitions */
 DEFINE_MTYPE_STATIC(ZEBRA, PBR_IPTABLE_IFNAME, "PBR interface list")
@@ -135,7 +136,7 @@ void zebra_pbr_rules_free(void *arg)
 
 	rule = (struct zebra_pbr_rule *)arg;
 
-	kernel_del_pbr_rule(rule);
+	(void)kernel_del_pbr_rule(rule);
 	XFREE(MTYPE_TMP, rule);
 }
 
@@ -443,7 +444,7 @@ void zebra_pbr_add_rule(struct zebra_ns
 		pbr_rule_lookup_unique(zns, rule->rule.unique, rule->ifp);
 
 	(void)hash_get(zns->rules_hash, rule, pbr_rule_alloc_intern);
-	kernel_add_pbr_rule(rule);
+	(void)kernel_add_pbr_rule(rule);
 	/*
 	 * Rule Replace semantics, if we have an old, install the
 	 * new rule, look above, and then delete the old
@@ -457,7 +458,7 @@ void zebra_pbr_del_rule(struct zebra_ns
 	struct zebra_pbr_rule *lookup;
 
 	lookup = hash_lookup(zns->rules_hash, rule);
-	kernel_del_pbr_rule(rule);
+	(void)kernel_del_pbr_rule(rule);
 
 	if (lookup) {
 		hash_release(zns->rules_hash, lookup);
@@ -474,7 +475,7 @@ static void zebra_pbr_cleanup_rules(stru
 	int *sock = data;
 
 	if (rule->sock == *sock) {
-		kernel_del_pbr_rule(rule);
+		(void)kernel_del_pbr_rule(rule);
 		hash_release(zns->rules_hash, rule);
 		XFREE(MTYPE_TMP, rule);
 	}
@@ -524,6 +525,8 @@ static int zebra_pbr_client_close_cleanu
 	int sock = client->sock;
 	struct zebra_ns *zns = zebra_ns_lookup(NS_DEFAULT);
 
+	if (!sock)
+		return 0;
 	hash_iterate(zns->rules_hash, zebra_pbr_cleanup_rules, &sock);
 	hash_iterate(zns->iptable_hash,
 		     zebra_pbr_cleanup_iptable, &sock);
@@ -536,7 +539,7 @@ static int zebra_pbr_client_close_cleanu
 
 void zebra_pbr_init(void)
 {
-	hook_register(zapi_client_close, zebra_pbr_client_close_cleanup);
+	hook_register(zserv_client_close, zebra_pbr_client_close_cleanup);
 }
 
 static void *pbr_ipset_alloc_intern(void *arg)
@@ -562,8 +565,8 @@ void zebra_pbr_create_ipset(struct zebra
 	ret = hook_call(zebra_pbr_ipset_wrap_script_update,
 		  zns, 1, ipset);
 	kernel_pbr_ipset_add_del_status(ipset,
-					ret ? SOUTHBOUND_INSTALL_SUCCESS
-					: SOUTHBOUND_INSTALL_FAILURE);
+					ret ? DP_INSTALL_SUCCESS
+					: DP_INSTALL_FAILURE);
 }
 
 void zebra_pbr_destroy_ipset(struct zebra_ns *zns,
@@ -646,8 +649,8 @@ void zebra_pbr_add_ipset_entry(struct ze
 	ret = hook_call(zebra_pbr_ipset_entry_wrap_script_update,
 		  zns, 1, ipset);
 	kernel_pbr_ipset_entry_add_del_status(ipset,
-					ret ? SOUTHBOUND_INSTALL_SUCCESS
-					: SOUTHBOUND_INSTALL_FAILURE);
+					ret ? DP_INSTALL_SUCCESS
+					: DP_INSTALL_FAILURE);
 }
 
 void zebra_pbr_del_ipset_entry(struct zebra_ns *zns,
@@ -689,8 +692,8 @@ void zebra_pbr_add_iptable(struct zebra_
 		       pbr_iptable_alloc_intern);
 	ret = hook_call(zebra_pbr_iptable_wrap_script_update, zns, 1, iptable);
 	kernel_pbr_iptable_add_del_status(iptable,
-					  ret ? SOUTHBOUND_INSTALL_SUCCESS
-					  : SOUTHBOUND_INSTALL_FAILURE);
+					  ret ? DP_INSTALL_SUCCESS
+					  : DP_INSTALL_FAILURE);
 }
 
 void zebra_pbr_del_iptable(struct zebra_ns *zns,
@@ -721,19 +724,19 @@ void zebra_pbr_del_iptable(struct zebra_
  * Handle success or failure of rule (un)install in the kernel.
  */
 void kernel_pbr_rule_add_del_status(struct zebra_pbr_rule *rule,
-				    enum southbound_results res)
+				    enum dp_results res)
 {
 	switch (res) {
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		zsend_rule_notify_owner(rule, ZAPI_RULE_INSTALLED);
 		break;
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		zsend_rule_notify_owner(rule, ZAPI_RULE_FAIL_INSTALL);
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		zsend_rule_notify_owner(rule, ZAPI_RULE_REMOVED);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		zsend_rule_notify_owner(rule, ZAPI_RULE_FAIL_REMOVE);
 		break;
 	}
@@ -743,19 +746,19 @@ void kernel_pbr_rule_add_del_status(stru
  * Handle success or failure of ipset (un)install in the kernel.
  */
 void kernel_pbr_ipset_add_del_status(struct zebra_pbr_ipset *ipset,
-				    enum southbound_results res)
+				    enum dp_results res)
 {
 	switch (res) {
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		zsend_ipset_notify_owner(ipset, ZAPI_IPSET_INSTALLED);
 		break;
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		zsend_ipset_notify_owner(ipset, ZAPI_IPSET_FAIL_INSTALL);
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		zsend_ipset_notify_owner(ipset, ZAPI_IPSET_REMOVED);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		zsend_ipset_notify_owner(ipset, ZAPI_IPSET_FAIL_REMOVE);
 		break;
 	}
@@ -766,22 +769,22 @@ void kernel_pbr_ipset_add_del_status(str
  */
 void kernel_pbr_ipset_entry_add_del_status(
 			struct zebra_pbr_ipset_entry *ipset,
-			enum southbound_results res)
+			enum dp_results res)
 {
 	switch (res) {
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		zsend_ipset_entry_notify_owner(ipset,
 					       ZAPI_IPSET_ENTRY_INSTALLED);
 		break;
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		zsend_ipset_entry_notify_owner(ipset,
 					       ZAPI_IPSET_ENTRY_FAIL_INSTALL);
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		zsend_ipset_entry_notify_owner(ipset,
 					       ZAPI_IPSET_ENTRY_REMOVED);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		zsend_ipset_entry_notify_owner(ipset,
 					       ZAPI_IPSET_ENTRY_FAIL_REMOVE);
 		break;
@@ -792,20 +795,20 @@ void kernel_pbr_ipset_entry_add_del_stat
  * Handle success or failure of ipset (un)install in the kernel.
  */
 void kernel_pbr_iptable_add_del_status(struct zebra_pbr_iptable *iptable,
-				       enum southbound_results res)
+				       enum dp_results res)
 {
 	switch (res) {
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		zsend_iptable_notify_owner(iptable, ZAPI_IPTABLE_INSTALLED);
 		break;
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		zsend_iptable_notify_owner(iptable, ZAPI_IPTABLE_FAIL_INSTALL);
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		zsend_iptable_notify_owner(iptable,
 					   ZAPI_IPTABLE_REMOVED);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		zsend_iptable_notify_owner(iptable,
 					   ZAPI_IPTABLE_FAIL_REMOVE);
 		break;
@@ -829,6 +832,7 @@ struct zebra_pbr_ipset_entry_unique_disp
 struct zebra_pbr_env_display {
 	struct zebra_ns *zns;
 	struct vty *vty;
+	char *name;
 };
 
 static const char *zebra_pbr_prefix2str(union prefixconstptr pu,
@@ -1034,6 +1038,7 @@ void zebra_pbr_show_ipset_list(struct vt
 	}
 	uniqueipset.zns = zns;
 	uniqueipset.vty = vty;
+	uniqueipset.name = NULL;
 	hash_walk(zns->ipset_hash, zebra_pbr_show_ipset_walkcb,
 		  &uniqueipset);
 }
@@ -1057,19 +1062,25 @@ static int zebra_pbr_rule_lookup_fwmark_
 	return HASHWALK_CONTINUE;
 }
 
-static int zebra_pbr_show_iptable_walkcb(struct hash_backet *backet, void *arg)
+static void zebra_pbr_show_iptable_unit(struct zebra_pbr_iptable *iptable,
+				       struct vty *vty,
+				       struct zebra_ns *zns)
 {
-	struct zebra_pbr_iptable *iptable =
-		(struct zebra_pbr_iptable *)backet->data;
-	struct zebra_pbr_env_display *env = (struct zebra_pbr_env_display *)arg;
-	struct vty *vty = env->vty;
-	struct zebra_ns *zns = env->zns;
 	int ret;
 	uint64_t pkts = 0, bytes = 0;
 
 	vty_out(vty, "IPtable %s action %s (%u)\n", iptable->ipset_name,
 		iptable->action == ZEBRA_IPTABLES_DROP ? "drop" : "redirect",
 		iptable->unique);
+	if (iptable->type == IPSET_NET_PORT ||
+	    iptable->type == IPSET_NET_PORT_NET) {
+		if (!(iptable->filter_bm & MATCH_ICMP_SET)) {
+			if (iptable->filter_bm & PBR_FILTER_DST_PORT)
+				vty_out(vty, "\t lookup dst port\n");
+			else if (iptable->filter_bm & PBR_FILTER_SRC_PORT)
+				vty_out(vty, "\t lookup src port\n");
+		}
+	}
 	if (iptable->pkt_len_min || iptable->pkt_len_max) {
 		if (!iptable->pkt_len_max)
 			vty_out(vty, "\t pkt len %u\n",
@@ -1126,17 +1137,34 @@ static int zebra_pbr_show_iptable_walkcb
 				prfl.fwmark);
 		}
 	}
+}
+
+static int zebra_pbr_show_iptable_walkcb(struct hash_backet *backet, void *arg)
+{
+	struct zebra_pbr_iptable *iptable =
+		(struct zebra_pbr_iptable *)backet->data;
+	struct zebra_pbr_env_display *env = (struct zebra_pbr_env_display *)arg;
+	struct vty *vty = env->vty;
+	struct zebra_ns *zns = env->zns;
+	char *iptable_name = env->name;
+
+	if (!iptable_name)
+		zebra_pbr_show_iptable_unit(iptable, vty, zns);
+	else if (!strncmp(iptable_name,
+			  iptable->ipset_name,
+			  ZEBRA_IPSET_NAME_SIZE))
+		zebra_pbr_show_iptable_unit(iptable, vty, zns);
 	return HASHWALK_CONTINUE;
 }
 
-void zebra_pbr_show_iptable(struct vty *vty)
+void zebra_pbr_show_iptable(struct vty *vty, char *iptable_name)
 {
 	struct zebra_ns *zns = zebra_ns_lookup(NS_DEFAULT);
 	struct zebra_pbr_env_display env;
 
 	env.vty = vty;
 	env.zns = zns;
-
+	env.name = iptable_name;
 	hash_walk(zns->iptable_hash, zebra_pbr_show_iptable_walkcb,
 		  &env);
 }
diff -urpN frr-frr-5.0.1/zebra/zebra_pbr.h frr-frr-6.0/zebra/zebra_pbr.h
--- frr-frr-5.0.1/zebra/zebra_pbr.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_pbr.h	2018-10-08 14:32:57.000000000 +0200
@@ -175,37 +175,37 @@ void zebra_pbr_del_iptable(struct zebra_
  * forwarding plane may not coincide, hence the API requires a separate
  * rule priority - maps to preference/FRA_PRIORITY on Linux.
  */
-extern void kernel_add_pbr_rule(struct zebra_pbr_rule *rule);
+extern enum dp_req_result kernel_add_pbr_rule(struct zebra_pbr_rule *rule);
 
 /*
  * Uninstall specified rule for a specific interface.
  */
-extern void kernel_del_pbr_rule(struct zebra_pbr_rule *rule);
+extern enum dp_req_result kernel_del_pbr_rule(struct zebra_pbr_rule *rule);
 
 /*
  * Get to know existing PBR rules in the kernel - typically called at startup.
  */
 extern void kernel_read_pbr_rules(struct zebra_ns *zns);
 
-enum southbound_results;
+enum dp_results;
 /*
  * Handle success or failure of rule (un)install in the kernel.
  */
 extern void kernel_pbr_rule_add_del_status(struct zebra_pbr_rule *rule,
-					   enum southbound_results res);
+					   enum dp_results res);
 
 /*
  * Handle success or failure of ipset kinds (un)install in the kernel.
  */
 extern void kernel_pbr_ipset_add_del_status(struct zebra_pbr_ipset *ipset,
-					   enum southbound_results res);
+					   enum dp_results res);
 
 extern void kernel_pbr_ipset_entry_add_del_status(
 				struct zebra_pbr_ipset_entry *ipset,
-				enum southbound_results res);
+				enum dp_results res);
 
 extern void kernel_pbr_iptable_add_del_status(struct zebra_pbr_iptable *iptable,
-			      enum southbound_results res);
+			      enum dp_results res);
 
 /*
  * Handle rule delete notification from kernel.
@@ -235,7 +235,7 @@ extern int zebra_pbr_iptable_hash_equal(
 
 extern void zebra_pbr_init(void);
 extern void zebra_pbr_show_ipset_list(struct vty *vty, char *ipsetname);
-extern void zebra_pbr_show_iptable(struct vty *vty);
+extern void zebra_pbr_show_iptable(struct vty *vty, char *iptable);
 extern void zebra_pbr_iptable_update_interfacelist(struct stream *s,
 				   struct zebra_pbr_iptable *zpi);
 size_t zebra_pbr_tcpflags_snprintf(char *buffer, size_t len,
diff -urpN frr-frr-5.0.1/zebra/zebra_ptm.c frr-frr-6.0/zebra/zebra_ptm.c
--- frr-frr-5.0.1/zebra/zebra_ptm.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_ptm.c	2018-10-08 14:32:57.000000000 +0200
@@ -19,25 +19,38 @@
  */
 
 #include <zebra.h>
+
 #include <sys/un.h> /* for sockaddr_un */
 #include <net/if.h>
+
+#include "bfd.h"
+#include "buffer.h"
+#include "command.h"
+#include "if.h"
+#include "network.h"
+#include "ptm_lib.h"
+#include "rib.h"
+#include "stream.h"
+#include "version.h"
+#include "vrf.h"
 #include "vty.h"
-#include "zebra/zserv.h"
-#include "zebra/interface.h"
+
 #include "zebra/debug.h"
+#include "zebra/interface.h"
+#include "zebra/zebra_errors.h"
 #include "zebra/zebra_ptm.h"
-#include "if.h"
-#include "command.h"
-#include "stream.h"
-#include "ptm_lib.h"
-#include "network.h"
-#include "buffer.h"
 #include "zebra/zebra_ptm_redistribute.h"
-#include "bfd.h"
-#include "vrf.h"
-#include "rib.h"
+#include "zebra/zserv.h"
 #include "zebra_vrf.h"
-#include "version.h"
+
+/*
+ * Choose the BFD implementation that we'll use.
+ *
+ * There are two implementations:
+ * - PTM BFD: which uses an external daemon;
+ * - bfdd: FRR's own BFD daemon;
+ */
+#if HAVE_BFDD == 0
 
 #define ZEBRA_PTM_RECONNECT_TIME_INITIAL 1 /* initial reconnect is 1s */
 #define ZEBRA_PTM_RECONNECT_TIME_MAX     300
@@ -126,7 +139,7 @@ void zebra_ptm_init(void)
 
 	ptm_cb.ptm_sock = -1;
 
-	hook_register(zapi_client_close, zebra_ptm_bfd_client_deregister);
+	hook_register(zserv_client_close, zebra_ptm_bfd_client_deregister);
 }
 
 void zebra_ptm_finish(void)
@@ -298,6 +311,9 @@ DEFUN (zebra_ptm_enable_if,
 	int old_ptm_enable;
 	int send_linkdown = 0;
 
+	if_data = ifp->info;
+	if_data->ptm_enable = ZEBRA_IF_PTM_ENABLE_UNSPEC;
+
 	if (ifp->ifindex == IFINDEX_INTERNAL) {
 		return CMD_SUCCESS;
 	}
@@ -317,9 +333,6 @@ DEFUN (zebra_ptm_enable_if,
 		}
 	}
 
-	if_data = ifp->info;
-	if_data->ptm_enable = ZEBRA_IF_PTM_ENABLE_UNSPEC;
-
 	return CMD_SUCCESS;
 }
 
@@ -491,15 +504,17 @@ static int zebra_ptm_handle_bfd_msg(void
 			dest_str, src_str);
 
 	if (str2prefix(dest_str, &dest_prefix) == 0) {
-		zlog_err("%s: Peer addr %s not found", __func__, dest_str);
+		flog_err(ZEBRA_ERR_PREFIX_PARSE_ERROR,
+			  "%s: Peer addr %s not found", __func__, dest_str);
 		return -1;
 	}
 
 	memset(&src_prefix, 0, sizeof(struct prefix));
 	if (strcmp(ZEBRA_PTM_INVALID_SRC_IP, src_str)) {
 		if (str2prefix(src_str, &src_prefix) == 0) {
-			zlog_err("%s: Local addr %s not found", __func__,
-				 src_str);
+			flog_err(ZEBRA_ERR_PREFIX_PARSE_ERROR,
+				  "%s: Local addr %s not found", __func__,
+				  src_str);
 			return -1;
 		}
 	}
@@ -593,8 +608,8 @@ static int zebra_ptm_handle_msg_cb(void
 		ifp = if_lookup_by_name_all_vrf(port_str);
 
 		if (!ifp) {
-			zlog_err("%s: %s not found in interface list", __func__,
-				 port_str);
+			zlog_warn("%s: %s not found in interface list",
+				  __func__, port_str);
 			return -1;
 		}
 	}
@@ -615,7 +630,7 @@ static int zebra_ptm_handle_msg_cb(void
 
 int zebra_ptm_sock_read(struct thread *thread)
 {
-	int sock, done = 0;
+	int sock;
 	int rc;
 
 	errno = 0;
@@ -625,28 +640,24 @@ int zebra_ptm_sock_read(struct thread *t
 		return -1;
 
 	/* PTM communicates in CSV format */
-	while (!done) {
+	do {
 		rc = ptm_lib_process_msg(ptm_hdl, sock, ptm_cb.in_data,
 					 ZEBRA_PTM_MAX_SOCKBUF, NULL);
-		if (rc <= 0)
-			break;
-	}
+	} while (rc > 0);
 
-	if (rc <= 0) {
-		if (((rc == 0) && !errno)
-		    || (errno && (errno != EWOULDBLOCK) && (errno != EAGAIN))) {
-			zlog_warn("%s routing socket error: %s(%d) bytes %d",
-				  __func__, safe_strerror(errno), errno, rc);
-
-			close(ptm_cb.ptm_sock);
-			ptm_cb.ptm_sock = -1;
-			zebra_ptm_reset_status(0);
-			ptm_cb.t_timer = NULL;
-			thread_add_timer(zebrad.master, zebra_ptm_connect, NULL,
-					 ptm_cb.reconnect_time,
-					 &ptm_cb.t_timer);
-			return (-1);
-		}
+	if (((rc == 0) && !errno)
+	    || (errno && (errno != EWOULDBLOCK) && (errno != EAGAIN))) {
+		zlog_warn("%s routing socket error: %s(%d) bytes %d",
+			  __func__, safe_strerror(errno), errno, rc);
+
+		close(ptm_cb.ptm_sock);
+		ptm_cb.ptm_sock = -1;
+		zebra_ptm_reset_status(0);
+		ptm_cb.t_timer = NULL;
+		thread_add_timer(zebrad.master, zebra_ptm_connect, NULL,
+				 ptm_cb.reconnect_time,
+				 &ptm_cb.t_timer);
+		return (-1);
 	}
 
 	ptm_cb.t_read = NULL;
@@ -1021,8 +1032,8 @@ int zebra_ptm_bfd_client_deregister(stru
 		return 0;
 
 	if (IS_ZEBRA_DEBUG_EVENT)
-		zlog_err("bfd_client_deregister msg for client %s",
-			 zebra_route_string(proto));
+		zlog_warn("bfd_client_deregister msg for client %s",
+			  zebra_route_string(proto));
 
 	if (ptm_cb.ptm_sock == -1) {
 		ptm_cb.t_timer = NULL;
@@ -1145,3 +1156,434 @@ void zebra_ptm_if_write(struct vty *vty,
 	if (zebra_ifp->ptm_enable == ZEBRA_IF_PTM_ENABLE_OFF)
 		vty_out(vty, " no ptm-enable\n");
 }
+
+#else /* HAVE_BFDD */
+
+#include "zebra/zebra_memory.h"
+
+/*
+ * Data structures.
+ */
+struct ptm_process {
+	struct zserv *pp_zs;
+	pid_t pp_pid;
+
+	TAILQ_ENTRY(ptm_process) pp_entry;
+};
+TAILQ_HEAD(ppqueue, ptm_process) ppqueue;
+
+DEFINE_MTYPE_STATIC(ZEBRA, ZEBRA_PTM_BFD_PROCESS,
+		    "PTM BFD process registration table.");
+
+/*
+ * Prototypes.
+ */
+static struct ptm_process *pp_new(pid_t pid, struct zserv *zs);
+static struct ptm_process *pp_lookup_byzs(struct zserv *zs);
+static void pp_free(struct ptm_process *pp);
+static void pp_free_all(void);
+
+static void zebra_ptm_send_bfdd(struct stream *msg);
+static void zebra_ptm_send_clients(struct stream *msg);
+static int _zebra_ptm_bfd_client_deregister(struct zserv *zs);
+static void _zebra_ptm_reroute(struct zserv *zs, struct stream *msg,
+			       uint32_t command);
+
+
+/*
+ * Process PID registration.
+ */
+static struct ptm_process *pp_new(pid_t pid, struct zserv *zs)
+{
+	struct ptm_process *pp;
+
+#ifdef PTM_DEBUG
+	/* Sanity check: more than one client can't have the same PID. */
+	TAILQ_FOREACH(pp, &ppqueue, pp_entry) {
+		if (pp->pp_pid == pid && pp->pp_zs != zs)
+			zlog_err("%s:%d pid and client pointer doesn't match",
+				 __FILE__, __LINE__);
+	}
+#endif /* PTM_DEBUG */
+
+	/* Lookup for duplicates. */
+	pp = pp_lookup_byzs(zs);
+	if (pp != NULL)
+		return pp;
+
+	/* Allocate and register new process. */
+	pp = XCALLOC(MTYPE_ZEBRA_PTM_BFD_PROCESS, sizeof(*pp));
+	if (pp == NULL)
+		return NULL;
+
+	pp->pp_pid = pid;
+	pp->pp_zs = zs;
+	TAILQ_INSERT_HEAD(&ppqueue, pp, pp_entry);
+
+	return pp;
+}
+
+static struct ptm_process *pp_lookup_byzs(struct zserv *zs)
+{
+	struct ptm_process *pp;
+
+	TAILQ_FOREACH(pp, &ppqueue, pp_entry) {
+		if (pp->pp_zs != zs)
+			continue;
+
+		break;
+	}
+
+	return pp;
+}
+
+static void pp_free(struct ptm_process *pp)
+{
+	if (pp == NULL)
+		return;
+
+	TAILQ_REMOVE(&ppqueue, pp, pp_entry);
+	XFREE(MTYPE_ZEBRA_PTM_BFD_PROCESS, pp);
+}
+
+static void pp_free_all(void)
+{
+	struct ptm_process *pp;
+
+	while (!TAILQ_EMPTY(&ppqueue)) {
+		pp = TAILQ_FIRST(&ppqueue);
+		pp_free(pp);
+	}
+}
+
+
+/*
+ * Use the FRR's internal daemon implementation.
+ */
+static void zebra_ptm_send_bfdd(struct stream *msg)
+{
+	struct listnode *node;
+	struct zserv *client;
+	struct stream *msgc;
+
+	/* Create copy for replication. */
+	msgc = stream_dup(msg);
+	if (msgc == NULL) {
+		zlog_warn("%s: not enough memory", __func__);
+		return;
+	}
+
+	/* Send message to all running BFDd daemons. */
+	for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client)) {
+		if (client->proto != ZEBRA_ROUTE_BFD)
+			continue;
+
+		zserv_send_message(client, msg);
+
+		/* Allocate more messages. */
+		msg = stream_dup(msgc);
+		if (msg == NULL) {
+			zlog_warn("%s: not enough memory", __func__);
+			return;
+		}
+	}
+
+	stream_free(msgc);
+	stream_free(msg);
+}
+
+static void zebra_ptm_send_clients(struct stream *msg)
+{
+	struct listnode *node;
+	struct zserv *client;
+	struct stream *msgc;
+
+	/* Create copy for replication. */
+	msgc = stream_dup(msg);
+	if (msgc == NULL) {
+		zlog_warn("%s: not enough memory", __func__);
+		return;
+	}
+
+	/* Send message to all running client daemons. */
+	for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client)) {
+		switch (client->proto) {
+		case ZEBRA_ROUTE_BGP:
+		case ZEBRA_ROUTE_OSPF:
+		case ZEBRA_ROUTE_OSPF6:
+		case ZEBRA_ROUTE_PIM:
+			break;
+
+		default:
+			/* NOTHING: skip this daemon. */
+			continue;
+		}
+
+		zserv_send_message(client, msg);
+
+		/* Allocate more messages. */
+		msg = stream_dup(msgc);
+		if (msg == NULL) {
+			zlog_warn("%s: not enough memory", __func__);
+			return;
+		}
+	}
+
+	stream_free(msgc);
+	stream_free(msg);
+}
+
+static int _zebra_ptm_bfd_client_deregister(struct zserv *zs)
+{
+	struct stream *msg;
+	struct ptm_process *pp;
+
+	/* Filter daemons that must receive this treatment. */
+	switch (zs->proto) {
+	case ZEBRA_ROUTE_BGP:
+	case ZEBRA_ROUTE_OSPF:
+	case ZEBRA_ROUTE_OSPF6:
+	case ZEBRA_ROUTE_PIM:
+		break;
+
+	case ZEBRA_ROUTE_BFD:
+		/* Don't try to send BFDd messages to itself. */
+		return 0;
+
+	default:
+		/* Unsupported daemon. */
+		return 0;
+	}
+
+	/* Find daemon pid by zebra connection pointer. */
+	pp = pp_lookup_byzs(zs);
+	if (pp == NULL) {
+		zlog_err("%s:%d failed to find process pid registration",
+			 __FILE__, __LINE__);
+		return -1;
+	}
+
+	/* Generate, send message and free() daemon related data. */
+	msg = stream_new(ZEBRA_MAX_PACKET_SIZ);
+	if (msg == NULL) {
+		zlog_warn("%s: not enough memory", __func__);
+		return 0;
+	}
+
+	/*
+	 * The message type will be BFD_DEST_REPLY so we can use only
+	 * one callback at the `bfdd` side, however the real command
+	 * number will be included right after the zebra header.
+	 */
+	zclient_create_header(msg, ZEBRA_BFD_DEST_REPLAY, 0);
+	stream_putl(msg, ZEBRA_BFD_CLIENT_DEREGISTER);
+
+	/* Put process PID. */
+	stream_putl(msg, pp->pp_pid);
+
+	/* Update the data pointers. */
+	stream_putw_at(msg, 0, stream_get_endp(msg));
+
+	zebra_ptm_send_bfdd(msg);
+
+	pp_free(pp);
+
+	return 0;
+}
+
+void zebra_ptm_init(void)
+{
+	/* Initialize the ptm process information list. */
+	TAILQ_INIT(&ppqueue);
+
+	/*
+	 * Send deregistration messages to BFD daemon when some other
+	 * daemon closes. This will help avoid sending daemons
+	 * unnecessary notification messages.
+	 */
+	hook_register(zserv_client_close, _zebra_ptm_bfd_client_deregister);
+}
+
+void zebra_ptm_finish(void)
+{
+	/* Remove the client disconnect hook and free all memory. */
+	hook_unregister(zserv_client_close, _zebra_ptm_bfd_client_deregister);
+	pp_free_all();
+}
+
+
+/*
+ * Message handling.
+ */
+static void _zebra_ptm_reroute(struct zserv *zs, struct stream *msg,
+			       uint32_t command)
+{
+	struct stream *msgc;
+	size_t zmsglen, zhdrlen;
+	pid_t ppid;
+
+	/*
+	 * Don't modify message in the zebra API. In order to do that we
+	 * need to allocate a new message stream and copy the message
+	 * provided by zebra.
+	 */
+	msgc = stream_new(ZEBRA_MAX_PACKET_SIZ);
+	if (msgc == NULL) {
+		zlog_warn("%s: not enough memory", __func__);
+		return;
+	}
+
+	/* Calculate our header size plus the message contents. */
+	zhdrlen = ZEBRA_HEADER_SIZE + sizeof(uint32_t);
+	zmsglen = msg->endp - msg->getp;
+	memcpy(msgc->data + zhdrlen, msg->data + msg->getp, zmsglen);
+
+	/*
+	 * The message type will be BFD_DEST_REPLY so we can use only
+	 * one callback at the `bfdd` side, however the real command
+	 * number will be included right after the zebra header.
+	 */
+	zclient_create_header(msgc, ZEBRA_BFD_DEST_REPLAY, 0);
+	stream_putl(msgc, command);
+
+	/* Update the data pointers. */
+	msgc->getp = 0;
+	msgc->endp = zhdrlen + zmsglen;
+	stream_putw_at(msgc, 0, stream_get_endp(msgc));
+
+	zebra_ptm_send_bfdd(msgc);
+
+	/* Registrate process PID for shutdown hook. */
+	STREAM_GETL(msg, ppid);
+	pp_new(ppid, zs);
+
+	return;
+
+stream_failure:
+	zlog_err("%s:%d failed to registrate client pid", __FILE__, __LINE__);
+}
+
+void zebra_ptm_bfd_dst_register(ZAPI_HANDLER_ARGS)
+{
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("bfd_dst_register msg from client %s: length=%d",
+			   zebra_route_string(client->proto), hdr->length);
+
+	_zebra_ptm_reroute(client, msg, ZEBRA_BFD_DEST_REGISTER);
+}
+
+void zebra_ptm_bfd_dst_deregister(ZAPI_HANDLER_ARGS)
+{
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("bfd_dst_deregister msg from client %s: length=%d",
+			   zebra_route_string(client->proto), hdr->length);
+
+	_zebra_ptm_reroute(client, msg, ZEBRA_BFD_DEST_DEREGISTER);
+}
+
+void zebra_ptm_bfd_client_register(ZAPI_HANDLER_ARGS)
+{
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("bfd_client_register msg from client %s: length=%d",
+			   zebra_route_string(client->proto), hdr->length);
+
+	_zebra_ptm_reroute(client, msg, ZEBRA_BFD_CLIENT_REGISTER);
+}
+
+void zebra_ptm_bfd_dst_replay(ZAPI_HANDLER_ARGS)
+{
+	struct stream *msgc;
+	size_t zmsglen, zhdrlen;
+	uint32_t cmd;
+
+	/*
+	 * NOTE:
+	 * Replay messages with HAVE_BFDD are meant to be replayed to
+	 * the client daemons. These messages are composed and
+	 * originated from the `bfdd` daemon.
+	 */
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("bfd_dst_update msg from client %s: length=%d",
+			   zebra_route_string(client->proto), hdr->length);
+
+	/*
+	 * Client messages must be re-routed, otherwise do the `bfdd`
+	 * special treatment.
+	 */
+	if (client->proto != ZEBRA_ROUTE_BFD) {
+		_zebra_ptm_reroute(client, msg, ZEBRA_BFD_DEST_REPLAY);
+		return;
+	}
+
+	/* Figure out if this is an DEST_UPDATE or DEST_REPLAY. */
+	if (stream_getl2(msg, &cmd) == false) {
+		zlog_err("%s: expected at least 4 bytes (command)", __func__);
+		return;
+	}
+
+	/*
+	 * Don't modify message in the zebra API. In order to do that we
+	 * need to allocate a new message stream and copy the message
+	 * provided by zebra.
+	 */
+	msgc = stream_new(ZEBRA_MAX_PACKET_SIZ);
+	if (msgc == NULL) {
+		zlog_warn("%s: not enough memory", __func__);
+		return;
+	}
+
+	/* Calculate our header size plus the message contents. */
+	if (cmd != ZEBRA_BFD_DEST_REPLAY) {
+		zhdrlen = ZEBRA_HEADER_SIZE;
+		zmsglen = msg->endp - msg->getp;
+		memcpy(msgc->data + zhdrlen, msg->data + msg->getp, zmsglen);
+
+		zclient_create_header(msgc, cmd, zvrf_id(zvrf));
+
+		msgc->getp = 0;
+		msgc->endp = zhdrlen + zmsglen;
+	} else
+		zclient_create_header(msgc, cmd, zvrf_id(zvrf));
+
+	/* Update the data pointers. */
+	stream_putw_at(msgc, 0, stream_get_endp(msgc));
+
+	zebra_ptm_send_clients(msgc);
+}
+
+/*
+ * Unused functions.
+ */
+void zebra_ptm_if_init(struct zebra_if *zifp __attribute__((__unused__)))
+{
+	/* NOTHING */
+}
+
+int zebra_ptm_get_enable_state(void)
+{
+	return 0;
+}
+
+void zebra_ptm_show_status(struct vty *vty __attribute__((__unused__)),
+			   struct interface *ifp __attribute__((__unused__)))
+{
+	/* NOTHING */
+}
+
+void zebra_ptm_write(struct vty *vty __attribute__((__unused__)))
+{
+	/* NOTHING */
+}
+
+void zebra_ptm_if_write(struct vty *vty __attribute__((__unused__)),
+			struct zebra_if *zifp __attribute__((__unused__)))
+{
+	/* NOTHING */
+}
+void zebra_ptm_if_set_ptm_state(struct interface *i __attribute__((__unused__)),
+				struct zebra_if *zi __attribute__((__unused__)))
+{
+	/* NOTHING */
+}
+
+#endif /* HAVE_BFDD */
diff -urpN frr-frr-5.0.1/zebra/zebra_ptm.h frr-frr-6.0/zebra/zebra_ptm.h
--- frr-frr-5.0.1/zebra/zebra_ptm.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_ptm.h	2018-10-08 14:32:57.000000000 +0200
@@ -69,6 +69,9 @@ int zebra_ptm_get_enable_state(void);
 void zebra_ptm_bfd_dst_register(ZAPI_HANDLER_ARGS);
 void zebra_ptm_bfd_dst_deregister(ZAPI_HANDLER_ARGS);
 void zebra_ptm_bfd_client_register(ZAPI_HANDLER_ARGS);
+#if HAVE_BFDD > 0
+void zebra_ptm_bfd_dst_replay(ZAPI_HANDLER_ARGS);
+#endif /* HAVE_BFDD */
 
 void zebra_ptm_show_status(struct vty *vty, struct interface *ifp);
 void zebra_ptm_if_init(struct zebra_if *zebra_ifp);
diff -urpN frr-frr-5.0.1/zebra/zebra_ptm_redistribute.c frr-frr-6.0/zebra/zebra_ptm_redistribute.c
--- frr-frr-5.0.1/zebra/zebra_ptm_redistribute.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_ptm_redistribute.c	2018-10-08 14:32:57.000000000 +0200
@@ -66,7 +66,7 @@ static int zsend_interface_bfd_update(in
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	client->if_bfd_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 void zebra_interface_bfd_update(struct interface *ifp, struct prefix *dp,
@@ -101,7 +101,7 @@ static int zsend_bfd_peer_replay(int cmd
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	client->bfd_peer_replay_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 void zebra_bfd_peer_replay_req(void)
diff -urpN frr-frr-5.0.1/zebra/zebra_pw.c frr-frr-6.0/zebra/zebra_pw.c
--- frr-frr-5.0.1/zebra/zebra_pw.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_pw.c	2018-10-08 14:32:57.000000000 +0200
@@ -292,7 +292,7 @@ void zebra_pw_init(struct zebra_vrf *zvr
 	RB_INIT(zebra_pw_head, &zvrf->pseudowires);
 	RB_INIT(zebra_static_pw_head, &zvrf->static_pseudowires);
 
-	hook_register(zapi_client_close, zebra_pw_client_close);
+	hook_register(zserv_client_close, zebra_pw_client_close);
 }
 
 void zebra_pw_exit(struct zebra_vrf *zvrf)
@@ -308,15 +308,14 @@ void zebra_pw_exit(struct zebra_vrf *zvr
 
 DEFUN_NOSH (pseudowire_if,
 	    pseudowire_if_cmd,
-	    "[no] pseudowire IFNAME",
-	    NO_STR
+	    "pseudowire IFNAME",
 	    "Static pseudowire configuration\n"
 	    "Pseudowire name\n")
 {
 	struct zebra_vrf *zvrf;
 	struct zebra_pw *pw;
-	int idx = 0;
 	const char *ifname;
+	int idx = 0;
 
 	zvrf = vrf_info_lookup(VRF_DEFAULT);
 	if (!zvrf)
@@ -324,19 +323,13 @@ DEFUN_NOSH (pseudowire_if,
 
 	argv_find(argv, argc, "IFNAME", &idx);
 	ifname = argv[idx]->arg;
+
 	pw = zebra_pw_find(zvrf, ifname);
 	if (pw && pw->protocol != ZEBRA_ROUTE_STATIC) {
 		vty_out(vty, "%% Pseudowire is not static\n");
 		return CMD_WARNING;
 	}
 
-	if (argv_find(argv, argc, "no", &idx)) {
-		if (!pw)
-			return CMD_SUCCESS;
-		zebra_pw_del(zvrf, pw);
-		return CMD_SUCCESS;
-	}
-
 	if (!pw)
 		pw = zebra_pw_add(zvrf, ifname, ZEBRA_ROUTE_STATIC, NULL);
 	VTY_PUSH_CONTEXT(PW_NODE, pw);
@@ -344,6 +337,37 @@ DEFUN_NOSH (pseudowire_if,
 	return CMD_SUCCESS;
 }
 
+DEFUN (no_pseudowire_if,
+       no_pseudowire_if_cmd,
+       "no pseudowire IFNAME",
+       NO_STR
+       "Static pseudowire configuration\n"
+       "Pseudowire name\n")
+{
+	struct zebra_vrf *zvrf;
+	struct zebra_pw *pw;
+	const char *ifname;
+	int idx = 0;
+
+	zvrf = vrf_info_lookup(VRF_DEFAULT);
+	if (!zvrf)
+		return CMD_WARNING;
+
+	argv_find(argv, argc, "IFNAME", &idx);
+	ifname = argv[idx]->arg;
+
+	pw = zebra_pw_find(zvrf, ifname);
+	if (pw) {
+		if (pw->protocol != ZEBRA_ROUTE_STATIC) {
+			vty_out(vty, "%% Pseudowire is not static\n");
+			return CMD_WARNING;
+		}
+		zebra_pw_del(zvrf, pw);
+	}
+
+	return CMD_SUCCESS;
+}
+
 DEFUN (pseudowire_labels,
        pseudowire_labels_cmd,
        "[no] mpls label local (16-1048575) remote (16-1048575)",
@@ -531,6 +555,7 @@ void zebra_pw_vty_init(void)
 	install_default(PW_NODE);
 
 	install_element(CONFIG_NODE, &pseudowire_if_cmd);
+	install_element(CONFIG_NODE, &no_pseudowire_if_cmd);
 	install_element(PW_NODE, &pseudowire_labels_cmd);
 	install_element(PW_NODE, &pseudowire_neighbor_cmd);
 	install_element(PW_NODE, &pseudowire_control_word_cmd);
diff -urpN frr-frr-5.0.1/zebra/zebra_rib.c frr-frr-6.0/zebra/zebra_rib.c
--- frr-frr-5.0.1/zebra/zebra_rib.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_rib.c	2018-10-08 14:32:57.000000000 +0200
@@ -20,37 +20,38 @@
 
 #include <zebra.h>
 
-#include "if.h"
-#include "prefix.h"
-#include "table.h"
-#include "memory.h"
-#include "zebra_memory.h"
 #include "command.h"
+#include "if.h"
+#include "linklist.h"
 #include "log.h"
 #include "log_int.h"
-#include "sockunion.h"
-#include "linklist.h"
-#include "thread.h"
-#include "workqueue.h"
+#include "memory.h"
+#include "mpls.h"
+#include "nexthop.h"
+#include "prefix.h"
 #include "prefix.h"
 #include "routemap.h"
-#include "nexthop.h"
-#include "vrf.h"
-#include "mpls.h"
+#include "sockunion.h"
 #include "srcdest_table.h"
+#include "table.h"
+#include "thread.h"
+#include "vrf.h"
+#include "workqueue.h"
 
+#include "zebra/connected.h"
+#include "zebra/debug.h"
+#include "zebra/interface.h"
+#include "zebra/redistribute.h"
 #include "zebra/rib.h"
 #include "zebra/rt.h"
+#include "zebra/zapi_msg.h"
+#include "zebra/zebra_errors.h"
+#include "zebra/zebra_memory.h"
 #include "zebra/zebra_ns.h"
-#include "zebra/zebra_vrf.h"
-#include "zebra/redistribute.h"
-#include "zebra/zebra_routemap.h"
-#include "zebra/debug.h"
 #include "zebra/zebra_rnh.h"
-#include "zebra/interface.h"
-#include "zebra/connected.h"
+#include "zebra/zebra_routemap.h"
+#include "zebra/zebra_vrf.h"
 #include "zebra/zebra_vxlan.h"
-#include "zebra/zapi_msg.h"
 
 DEFINE_HOOK(rib_update, (struct route_node * rn, const char *reason),
 	    (rn, reason))
@@ -156,7 +157,7 @@ int is_zebra_main_routing_table(uint32_t
 	return 0;
 }
 
-int zebra_check_addr(struct prefix *p)
+int zebra_check_addr(const struct prefix *p)
 {
 	if (p->family == AF_INET) {
 		uint32_t addr;
@@ -325,7 +326,7 @@ struct nexthop *route_entry_nexthop_blac
 	return nexthop;
 }
 
-static void nexthop_set_resolved(afi_t afi, struct nexthop *newhop,
+static void nexthop_set_resolved(afi_t afi, const struct nexthop *newhop,
 				 struct nexthop *nexthop)
 {
 	struct nexthop *resolved_hop;
@@ -843,7 +844,7 @@ static unsigned nexthop_active_check(str
 	route_map_result_t ret = RMAP_MATCH;
 	int family;
 	char buf[SRCDEST2STR_BUFFER];
-	struct prefix *p, *src_p;
+	const struct prefix *p, *src_p;
 	srcdest_rnode_prefixes(rn, &p, &src_p);
 
 	if (rn->p.family == AF_INET)
@@ -1012,9 +1013,9 @@ int zebra_rib_labeled_unicast(struct rou
 	return 1;
 }
 
-void kernel_route_rib_pass_fail(struct route_node *rn, struct prefix *p,
+void kernel_route_rib_pass_fail(struct route_node *rn, const struct prefix *p,
 				struct route_entry *re,
-				enum southbound_results res)
+				enum dp_results res)
 {
 	struct nexthop *nexthop;
 	char buf[PREFIX_STRLEN];
@@ -1023,7 +1024,7 @@ void kernel_route_rib_pass_fail(struct r
 	dest = rib_dest_from_rnode(rn);
 
 	switch (res) {
-	case SOUTHBOUND_INSTALL_SUCCESS:
+	case DP_INSTALL_SUCCESS:
 		dest->selected_fib = re;
 		for (ALL_NEXTHOPS(re->ng, nexthop)) {
 			if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
@@ -1036,7 +1037,7 @@ void kernel_route_rib_pass_fail(struct r
 		}
 		zsend_route_notify_owner(re, p, ZAPI_ROUTE_INSTALLED);
 		break;
-	case SOUTHBOUND_INSTALL_FAILURE:
+	case DP_INSTALL_FAILURE:
 		/*
 		 * I am not sure this is the right thing to do here
 		 * but the code always set selected_fib before
@@ -1048,7 +1049,7 @@ void kernel_route_rib_pass_fail(struct r
 		zlog_warn("%u:%s: Route install failed", re->vrf_id,
 			  prefix2str(p, buf, sizeof(buf)));
 		break;
-	case SOUTHBOUND_DELETE_SUCCESS:
+	case DP_DELETE_SUCCESS:
 		/*
 		 * The case where selected_fib is not re is
 		 * when we have received a system route
@@ -1063,7 +1064,7 @@ void kernel_route_rib_pass_fail(struct r
 
 		zsend_route_notify_owner(re, p, ZAPI_ROUTE_REMOVED);
 		break;
-	case SOUTHBOUND_DELETE_FAILURE:
+	case DP_DELETE_FAILURE:
 		/*
 		 * Should we set this to NULL if the
 		 * delete fails?
@@ -1085,7 +1086,7 @@ void rib_install_kernel(struct route_nod
 {
 	struct nexthop *nexthop;
 	rib_table_info_t *info = srcdest_rnode_table_info(rn);
-	struct prefix *p, *src_p;
+	const struct prefix *p, *src_p;
 	struct zebra_vrf *zvrf = vrf_info_lookup(re->vrf_id);
 
 	srcdest_rnode_prefixes(rn, &p, &src_p);
@@ -1123,8 +1124,21 @@ void rib_install_kernel(struct route_nod
 	 * the kernel.
 	 */
 	hook_call(rib_update, rn, "installing in kernel");
-	kernel_route_rib(rn, p, src_p, old, re);
-	zvrf->installs++;
+	switch (kernel_route_rib(rn, p, src_p, old, re)) {
+	case DP_REQUEST_QUEUED:
+		flog_err(
+			ZEBRA_ERR_DP_INVALID_RC,
+			"No current known DataPlane interfaces can return this, please fix");
+		break;
+	case DP_REQUEST_FAILURE:
+		flog_err(
+			ZEBRA_ERR_DP_INSTALL_FAIL,
+			"No current known Rib Install Failure cases, please fix");
+		break;
+	case DP_REQUEST_SUCCESS:
+		zvrf->installs++;
+		break;
+	}
 
 	return;
 }
@@ -1134,7 +1148,7 @@ void rib_uninstall_kernel(struct route_n
 {
 	struct nexthop *nexthop;
 	rib_table_info_t *info = srcdest_rnode_table_info(rn);
-	struct prefix *p, *src_p;
+	const struct prefix *p, *src_p;
 	struct zebra_vrf *zvrf = vrf_info_lookup(re->vrf_id);
 
 	srcdest_rnode_prefixes(rn, &p, &src_p);
@@ -1150,9 +1164,22 @@ void rib_uninstall_kernel(struct route_n
 	 * the kernel.
 	 */
 	hook_call(rib_update, rn, "uninstalling from kernel");
-	kernel_route_rib(rn, p, src_p, re, NULL);
-	if (zvrf)
-		zvrf->removals++;
+	switch (kernel_route_rib(rn, p, src_p, re, NULL)) {
+	case DP_REQUEST_QUEUED:
+		flog_err(
+			ZEBRA_ERR_DP_INVALID_RC,
+			"No current known DataPlane interfaces can return this, please fix");
+		break;
+	case DP_REQUEST_FAILURE:
+		flog_err(
+			ZEBRA_ERR_DP_INSTALL_FAIL,
+			"No current known RIB Install Failure cases, please fix");
+		break;
+	case DP_REQUEST_SUCCESS:
+		if (zvrf)
+			zvrf->removals++;
+		break;
+	}
 
 	return;
 }
@@ -1176,7 +1203,8 @@ static void rib_uninstall(struct route_n
 	}
 
 	if (CHECK_FLAG(re->flags, ZEBRA_FLAG_SELECTED)) {
-		struct prefix *p, *src_p;
+		const struct prefix *p, *src_p;
+
 		srcdest_rnode_prefixes(rn, &p, &src_p);
 
 		redistribute_delete(p, src_p, re);
@@ -1410,18 +1438,14 @@ static void rib_process_update_fib(struc
 				if (new != old)
 					zlog_debug(
 						"%u:%s: Deleting route rn %p, re %p (type %d) "
-						"old %p (type %d) - %s",
+						"old %p (type %d) - nexthop inactive",
 						zvrf_id(zvrf), buf, rn, new,
-						new->type, old, old->type,
-						nh_active ? "install failed"
-							  : "nexthop inactive");
+						new->type, old, old->type);
 				else
 					zlog_debug(
-						"%u:%s: Deleting route rn %p, re %p (type %d) - %s",
+						"%u:%s: Deleting route rn %p, re %p (type %d) - nexthop inactive",
 						zvrf_id(zvrf), buf, rn, new,
-						new->type,
-						nh_active ? "install failed"
-							  : "nexthop inactive");
+						new->type);
 			}
 
 			/* If labeled-unicast route, uninstall transit LSP. */
@@ -1477,17 +1501,37 @@ static struct route_entry *rib_choose_be
 
 	/* filter route selection in following order:
 	 * - connected beats other types
+	 * - if both connected, loopback or vrf wins
 	 * - lower distance beats higher
 	 * - lower metric beats higher for equal distance
 	 * - last, hence oldest, route wins tie break.
 	 */
 
-	/* Connected routes. Pick the last connected
+	/* Connected routes. Check to see if either are a vrf
+	 * or loopback interface.  If not, pick the last connected
 	 * route of the set of lowest metric connected routes.
 	 */
 	if (alternate->type == ZEBRA_ROUTE_CONNECT) {
-		if (current->type != ZEBRA_ROUTE_CONNECT
-		    || alternate->metric <= current->metric)
+		if (current->type != ZEBRA_ROUTE_CONNECT)
+			return alternate;
+
+		/* both are connected.  are either loop or vrf? */
+		struct nexthop *nexthop = NULL;
+
+		for (ALL_NEXTHOPS(alternate->ng, nexthop)) {
+			if (if_is_loopback_or_vrf(if_lookup_by_index(
+				    nexthop->ifindex, alternate->vrf_id)))
+				return alternate;
+		}
+
+		for (ALL_NEXTHOPS(current->ng, nexthop)) {
+			if (if_is_loopback_or_vrf(if_lookup_by_index(
+				    nexthop->ifindex, current->vrf_id)))
+				return current;
+		}
+
+		/* Neither are loop or vrf so pick best metric  */
+		if (alternate->metric <= current->metric)
 			return alternate;
 
 		return current;
@@ -1522,7 +1566,8 @@ static void rib_process(struct route_nod
 	char buf[SRCDEST2STR_BUFFER];
 	rib_dest_t *dest;
 	struct zebra_vrf *zvrf = NULL;
-	struct prefix *p, *src_p;
+	const struct prefix *p, *src_p;
+
 	srcdest_rnode_prefixes(rn, &p, &src_p);
 	vrf_id_t vrf_id = VRF_UNKNOWN;
 
@@ -1920,7 +1965,8 @@ void rib_queue_add(struct route_node *rn
 	}
 
 	if (zebrad.ribq == NULL) {
-		zlog_err("%s: work_queue does not exist!", __func__);
+		flog_err(ZEBRA_ERR_WQ_NONEXISTENT,
+			  "%s: work_queue does not exist!", __func__);
 		return;
 	}
 
@@ -1949,7 +1995,6 @@ static struct meta_queue *meta_queue_new
 	unsigned i;
 
 	new = XCALLOC(MTYPE_WORK_QUEUE, sizeof(struct meta_queue));
-	assert(new);
 
 	for (i = 0; i < MQ_SIZE; i++) {
 		new->subq[i] = list_new();
@@ -1976,7 +2021,8 @@ static void rib_queue_init(struct zebra_
 
 	if (!(zebra->ribq =
 		      work_queue_new(zebra->master, "route_node processing"))) {
-		zlog_err("%s: could not initialise work queue!", __func__);
+		flog_err(ZEBRA_ERR_WQ_NONEXISTENT,
+			  "%s: could not initialise work queue!", __func__);
 		return;
 	}
 
@@ -1989,7 +2035,8 @@ static void rib_queue_init(struct zebra_
 	zebra->ribq->spec.hold = ZEBRA_RIB_PROCESS_HOLD_TIME;
 
 	if (!(zebra->mq = meta_queue_new())) {
-		zlog_err("%s: could not initialise meta queue!", __func__);
+		flog_err(ZEBRA_ERR_WQ_NONEXISTENT,
+			  "%s: could not initialise meta queue!", __func__);
 		return;
 	}
 	return;
@@ -2070,7 +2117,8 @@ static void rib_link(struct route_node *
 		rib_queue_add(rn);
 }
 
-void rib_addnode(struct route_node *rn, struct route_entry *re, int process)
+static void rib_addnode(struct route_node *rn,
+			struct route_entry *re, int process)
 {
 	/* RE node has been un-removed before route-node is processed.
 	 * route_node must hence already be on the queue for processing..
@@ -2119,10 +2167,6 @@ void rib_unlink(struct route_node *rn, s
 	if (dest->selected_fib == re)
 		dest->selected_fib = NULL;
 
-	/* free RE and nexthops */
-	if (re->type == ZEBRA_ROUTE_STATIC)
-		zebra_deregister_rnh_static_nexthops(re->ng.nexthop->vrf_id,
-						     re->ng.nexthop, rn);
 	nexthops_free(re->ng.nexthop);
 	XFREE(MTYPE_RE, re);
 }
@@ -2219,8 +2263,9 @@ void rib_lookup_and_dump(struct prefix_i
 	/* Lookup table.  */
 	table = zebra_vrf_table(AFI_IP, SAFI_UNICAST, vrf_id);
 	if (!table) {
-		zlog_err("%s:%u zebra_vrf_table() returned NULL",
-			 __func__, vrf_id);
+		flog_err(ZEBRA_ERR_TABLE_LOOKUP_FAILED,
+			  "%s:%u zebra_vrf_table() returned NULL", __func__,
+			  vrf_id);
 		return;
 	}
 
@@ -2266,8 +2311,9 @@ void rib_lookup_and_pushup(struct prefix
 	rib_dest_t *dest;
 
 	if (NULL == (table = zebra_vrf_table(AFI_IP, SAFI_UNICAST, vrf_id))) {
-		zlog_err("%s:%u zebra_vrf_table() returned NULL",
-			 __func__, vrf_id);
+		flog_err(ZEBRA_ERR_TABLE_LOOKUP_FAILED,
+			  "%s:%u zebra_vrf_table() returned NULL", __func__,
+			  vrf_id);
 		return;
 	}
 
@@ -2308,14 +2354,14 @@ int rib_add_multipath(afi_t afi, safi_t
 {
 	struct route_table *table;
 	struct route_node *rn;
-	struct route_entry *same;
+	struct route_entry *same = NULL;
 	struct nexthop *nexthop;
 	int ret = 0;
 
 	if (!re)
 		return 0;
 
-	assert(!src_p || afi == AFI_IP6);
+	assert(!src_p || !src_p->prefixlen || afi == AFI_IP6);
 
 	/* Lookup table.  */
 	table = zebra_vrf_table_with_table_id(afi, safi, re->vrf_id, re->table);
@@ -2342,8 +2388,12 @@ int rib_add_multipath(afi_t afi, safi_t
 	/* Lookup route node.*/
 	rn = srcdest_rnode_get(table, p, src_p);
 
-	/* If same type of route are installed, treat it as a implicit
-	   withdraw. */
+	/*
+	 * If same type of route are installed, treat it as a implicit
+	 * withdraw.
+	 * If the user has specified the No route replace semantics
+	 * for the install don't do a route replace.
+	 */
 	RNODE_FOREACH_RE (rn, same) {
 		if (CHECK_FLAG(same->status, ROUTE_ENTRY_REMOVED))
 			continue;
@@ -2355,9 +2405,15 @@ int rib_add_multipath(afi_t afi, safi_t
 		if (same->type == ZEBRA_ROUTE_KERNEL
 		    && same->metric != re->metric)
 			continue;
+
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_RR_USE_DISTANCE) &&
+		    same->distance != re->distance)
+			continue;
+
 		/*
-		 * We should allow duplicate connected routes because of
-		 * IPv6 link-local routes and unnumbered interfaces on Linux.
+		 * We should allow duplicate connected routes
+		 * because of IPv6 link-local routes and unnumbered
+		 * interfaces on Linux.
 		 */
 		if (same->type != ZEBRA_ROUTE_CONNECT)
 			break;
@@ -2394,8 +2450,8 @@ int rib_add_multipath(afi_t afi, safi_t
 void rib_delete(afi_t afi, safi_t safi, vrf_id_t vrf_id, int type,
 		unsigned short instance, int flags, struct prefix *p,
 		struct prefix_ipv6 *src_p, const struct nexthop *nh,
-		uint32_t table_id, uint32_t metric, bool fromkernel,
-		struct ethaddr *rmac)
+		uint32_t table_id, uint32_t metric, uint8_t distance,
+		bool fromkernel)
 {
 	struct route_table *table;
 	struct route_node *rn;
@@ -2406,7 +2462,7 @@ void rib_delete(afi_t afi, safi_t safi,
 	char buf2[INET6_ADDRSTRLEN];
 	rib_dest_t *dest;
 
-	assert(!src_p || afi == AFI_IP6);
+	assert(!src_p || !src_p->prefixlen || afi == AFI_IP6);
 
 	/* Lookup table.  */
 	table = zebra_vrf_table_with_table_id(afi, safi, vrf_id, table_id);
@@ -2449,6 +2505,10 @@ void rib_delete(afi_t afi, safi_t safi,
 			continue;
 		if (re->instance != instance)
 			continue;
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_RR_USE_DISTANCE) &&
+		    distance != re->distance)
+			continue;
+
 		if (re->type == ZEBRA_ROUTE_KERNEL && re->metric != metric)
 			continue;
 		if (re->type == ZEBRA_ROUTE_CONNECT && (rtnh = re->ng.nexthop)
@@ -2525,12 +2585,10 @@ void rib_delete(afi_t afi, safi_t safi,
 						rn, vrf_id,
 						"via %s ifindex %d type %d "
 						"doesn't exist in rib",
-						inet_ntop(
-							family2afi(afi),
-							&nh->gate, buf2,
-							INET_ADDRSTRLEN), /* FIXME
-									     */
-						nh->ifindex, type);
+						inet_ntop(afi2family(afi),
+							  &nh->gate, buf2,
+							  sizeof(buf2)),
+							  nh->ifindex, type);
 				else
 					rnode_debug(
 						rn, vrf_id,
@@ -2569,7 +2627,7 @@ void rib_delete(afi_t afi, safi_t safi,
 					       &(tmp_nh->gate.ipv6),
 					       sizeof(struct in6_addr));
 				}
-				zebra_vxlan_evpn_vrf_route_del(re->vrf_id, rmac,
+				zebra_vxlan_evpn_vrf_route_del(re->vrf_id,
 							       &vtep_ip, p);
 			}
 		}
@@ -2613,8 +2671,7 @@ int rib_add(afi_t afi, safi_t safi, vrf_
 }
 
 /* Schedule routes of a particular table (address-family) based on event. */
-static void rib_update_table(struct route_table *table,
-			     rib_update_event_t event)
+void rib_update_table(struct route_table *table, rib_update_event_t event)
 {
 	struct route_node *rn;
 	struct route_entry *re, *next;
@@ -2694,12 +2751,18 @@ void rib_update(vrf_id_t vrf_id, rib_upd
 
 	/* Process routes of interested address-families. */
 	table = zebra_vrf_table(AFI_IP, SAFI_UNICAST, vrf_id);
-	if (table)
+	if (table) {
+		if (IS_ZEBRA_DEBUG_EVENT)
+			zlog_debug("%s : AFI_IP event %d", __func__, event);
 		rib_update_table(table, event);
+	}
 
 	table = zebra_vrf_table(AFI_IP6, SAFI_UNICAST, vrf_id);
-	if (table)
+	if (table) {
+		if (IS_ZEBRA_DEBUG_EVENT)
+			zlog_debug("%s : AFI_IP6 event %d", __func__, event);
 		rib_update_table(table, event);
+	}
 }
 
 /* Delete self installed routes after zebra is relaunched.  */
diff -urpN frr-frr-5.0.1/zebra/zebra_rnh.c frr-frr-6.0/zebra/zebra_rnh.c
--- frr-frr-5.0.1/zebra/zebra_rnh.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_rnh.c	2018-10-08 14:32:57.000000000 +0200
@@ -47,6 +47,7 @@
 #include "zebra/zebra_routemap.h"
 #include "zebra/interface.h"
 #include "zebra/zebra_memory.h"
+#include "zebra/zebra_errors.h"
 
 static void free_state(vrf_id_t vrf_id, struct route_entry *re,
 		       struct route_node *rn);
@@ -73,7 +74,7 @@ int zebra_rnh_ipv6_default_route = 0;
 
 void zebra_rnh_init(void)
 {
-	hook_register(zapi_client_close, zebra_client_cleanup_rnh);
+	hook_register(zserv_client_close, zebra_client_cleanup_rnh);
 }
 
 static inline struct route_table *get_rnh_table(vrf_id_t vrfid, int family,
@@ -102,7 +103,8 @@ char *rnh_str(struct rnh *rnh, char *buf
 	return buf;
 }
 
-struct rnh *zebra_add_rnh(struct prefix *p, vrf_id_t vrfid, rnh_type_t type)
+struct rnh *zebra_add_rnh(struct prefix *p, vrf_id_t vrfid, rnh_type_t type,
+			  bool *exists)
 {
 	struct route_table *table;
 	struct route_node *rn;
@@ -118,6 +120,7 @@ struct rnh *zebra_add_rnh(struct prefix
 		prefix2str(p, buf, sizeof(buf));
 		zlog_warn("%u: Add RNH %s type %d - table not found", vrfid,
 			  buf, type);
+		exists = false;
 		return NULL;
 	}
 
@@ -131,12 +134,13 @@ struct rnh *zebra_add_rnh(struct prefix
 		rnh = XCALLOC(MTYPE_RNH, sizeof(struct rnh));
 		rnh->client_list = list_new();
 		rnh->vrf_id = vrfid;
-		rnh->zebra_static_route_list = list_new();
 		rnh->zebra_pseudowire_list = list_new();
 		route_lock_node(rn);
 		rn->info = rnh;
 		rnh->node = rn;
-	}
+		*exists = false;
+	} else
+		*exists = true;
 
 	route_unlock_node(rn);
 	return (rn->info);
@@ -167,7 +171,6 @@ void zebra_free_rnh(struct rnh *rnh)
 {
 	rnh->flags |= ZEBRA_NHT_DELETED;
 	list_delete_and_null(&rnh->client_list);
-	list_delete_and_null(&rnh->zebra_static_route_list);
 	list_delete_and_null(&rnh->zebra_pseudowire_list);
 	free_state(rnh->vrf_id, rnh->state, rnh->node);
 	XFREE(MTYPE_RNH, rnh);
@@ -191,6 +194,14 @@ void zebra_delete_rnh(struct rnh *rnh, r
 	route_unlock_node(rn);
 }
 
+/*
+ * This code will send to the registering client
+ * the looked up rnh.
+ * For a rnh that was created, there is no data
+ * so it will send an empty nexthop group
+ * If rnh exists then we know it has been evaluated
+ * and as such it will have a resolved rnh.
+ */
 void zebra_add_rnh_client(struct rnh *rnh, struct zserv *client,
 			  rnh_type_t type, vrf_id_t vrf_id)
 {
@@ -202,8 +213,7 @@ void zebra_add_rnh_client(struct rnh *rn
 	}
 	if (!listnode_lookup(rnh->client_list, client)) {
 		listnode_add(rnh->client_list, client);
-		send_client(rnh, client, type,
-			    vrf_id); // Pending: check if its needed
+		send_client(rnh, client, type, vrf_id);
 	}
 }
 
@@ -218,82 +228,10 @@ void zebra_remove_rnh_client(struct rnh
 	}
 	listnode_delete(rnh->client_list, client);
 	if (list_isempty(rnh->client_list)
-	    && list_isempty(rnh->zebra_static_route_list)
 	    && list_isempty(rnh->zebra_pseudowire_list))
 		zebra_delete_rnh(rnh, type);
 }
 
-void zebra_register_rnh_static_nh(vrf_id_t vrf_id, struct prefix *nh,
-				  struct route_node *static_rn)
-{
-	struct rnh *rnh;
-
-	rnh = zebra_add_rnh(nh, vrf_id, RNH_NEXTHOP_TYPE);
-	if (rnh && !listnode_lookup(rnh->zebra_static_route_list, static_rn)) {
-		listnode_add(rnh->zebra_static_route_list, static_rn);
-	}
-}
-
-void zebra_deregister_rnh_static_nh(vrf_id_t vrf_id, struct prefix *nh,
-				    struct route_node *static_rn)
-{
-	struct rnh *rnh;
-
-	rnh = zebra_lookup_rnh(nh, vrf_id, RNH_NEXTHOP_TYPE);
-	if (!rnh || (rnh->flags & ZEBRA_NHT_DELETED))
-		return;
-
-	listnode_delete(rnh->zebra_static_route_list, static_rn);
-
-	if (list_isempty(rnh->client_list)
-	    && list_isempty(rnh->zebra_static_route_list)
-	    && list_isempty(rnh->zebra_pseudowire_list))
-		zebra_delete_rnh(rnh, RNH_NEXTHOP_TYPE);
-}
-
-void zebra_deregister_rnh_static_nexthops(vrf_id_t vrf_id,
-					  struct nexthop *nexthop,
-					  struct route_node *rn)
-{
-	struct nexthop *nh;
-	struct prefix nh_p;
-
-	for (nh = nexthop; nh; nh = nh->next) {
-		switch (nh->type) {
-		case NEXTHOP_TYPE_IPV4:
-		case NEXTHOP_TYPE_IPV4_IFINDEX:
-			nh_p.family = AF_INET;
-			nh_p.prefixlen = IPV4_MAX_BITLEN;
-			nh_p.u.prefix4 = nh->gate.ipv4;
-			break;
-		case NEXTHOP_TYPE_IPV6:
-		case NEXTHOP_TYPE_IPV6_IFINDEX:
-			nh_p.family = AF_INET6;
-			nh_p.prefixlen = IPV6_MAX_BITLEN;
-			nh_p.u.prefix6 = nh->gate.ipv6;
-			break;
-		/*
-		 * Not sure what really to do here, we are not
-		 * supposed to have either of these for NHT
-		 * and the code has no way to know what prefix
-		 * to use.  So I'm going to just continue
-		 * for the moment, which is preferable to
-		 * what is currently happening which is a
-		 * CRASH and BURN.
-		 * Some simple testing shows that we
-		 * are not leaving slag around for these
-		 * skipped static routes.  Since
-		 * they don't appear to be installed
-		 */
-		case NEXTHOP_TYPE_IFINDEX:
-		case NEXTHOP_TYPE_BLACKHOLE:
-			continue;
-			break;
-		}
-		zebra_deregister_rnh_static_nh(vrf_id, &nh_p, rn);
-	}
-}
-
 /* XXX move this utility function elsewhere? */
 static void addr2hostprefix(int af, const union g_addr *addr,
 			    struct prefix *prefix)
@@ -320,9 +258,10 @@ void zebra_register_rnh_pseudowire(vrf_i
 {
 	struct prefix nh;
 	struct rnh *rnh;
+	bool exists;
 
 	addr2hostprefix(pw->af, &pw->nexthop, &nh);
-	rnh = zebra_add_rnh(&nh, vrf_id, RNH_NEXTHOP_TYPE);
+	rnh = zebra_add_rnh(&nh, vrf_id, RNH_NEXTHOP_TYPE, &exists);
 	if (rnh && !listnode_lookup(rnh->zebra_pseudowire_list, pw)) {
 		listnode_add(rnh->zebra_pseudowire_list, pw);
 		pw->rnh = rnh;
@@ -342,7 +281,6 @@ void zebra_deregister_rnh_pseudowire(vrf
 	pw->rnh = NULL;
 
 	if (list_isempty(rnh->client_list)
-	    && list_isempty(rnh->zebra_static_route_list)
 	    && list_isempty(rnh->zebra_pseudowire_list))
 		zebra_delete_rnh(rnh, RNH_NEXTHOP_TYPE);
 }
@@ -575,115 +513,6 @@ static void zebra_rnh_process_pbr_tables
 	}
 }
 
-static void zebra_rnh_process_static_routes(vrf_id_t vrfid, int family,
-					    struct route_node *nrn,
-					    struct rnh *rnh,
-					    struct route_node *prn,
-					    struct route_entry *re)
-{
-	struct listnode *node;
-	int num_resolving_nh = 0;
-	struct route_node *static_rn;
-	struct route_entry *sre;
-	struct nexthop *nexthop;
-	char bufn[INET6_ADDRSTRLEN];
-	char bufp[INET6_ADDRSTRLEN];
-	char bufs[INET6_ADDRSTRLEN];
-
-	if (IS_ZEBRA_DEBUG_NHT) {
-		prefix2str(&nrn->p, bufn, INET6_ADDRSTRLEN);
-		if (prn)
-			prefix2str(&prn->p, bufp, INET6_ADDRSTRLEN);
-	}
-
-	if (prn && re) {
-		/* Apply route-map for "static" to route resolving this
-		 * nexthop to see if it is filtered or not.
-		 */
-		num_resolving_nh = zebra_rnh_apply_nht_rmap(family, prn, re,
-							    ZEBRA_ROUTE_STATIC);
-		if (num_resolving_nh)
-			rnh->filtered[ZEBRA_ROUTE_STATIC] = 0;
-		else
-			rnh->filtered[ZEBRA_ROUTE_STATIC] = 1;
-	} else
-		rnh->filtered[ZEBRA_ROUTE_STATIC] = 0;
-
-	/* Evaluate each static route associated with this nexthop. */
-	for (ALL_LIST_ELEMENTS_RO(rnh->zebra_static_route_list, node,
-				  static_rn)) {
-		RNODE_FOREACH_RE (static_rn, sre) {
-			if (sre->type != ZEBRA_ROUTE_STATIC)
-				continue;
-
-			/* Set the filter flag for the correct nexthop - static
-			 * route may
-			 * be having multiple. We care here only about
-			 * registered nexthops.
-			 */
-			for (nexthop = sre->ng.nexthop; nexthop;
-			     nexthop = nexthop->next) {
-				switch (nexthop->type) {
-				case NEXTHOP_TYPE_IPV4:
-				case NEXTHOP_TYPE_IPV4_IFINDEX:
-					if (nexthop->gate.ipv4.s_addr
-					    == nrn->p.u.prefix4.s_addr) {
-						if (num_resolving_nh)
-							UNSET_FLAG(
-								nexthop->flags,
-								NEXTHOP_FLAG_FILTERED);
-						else
-							SET_FLAG(
-								nexthop->flags,
-								NEXTHOP_FLAG_FILTERED);
-					}
-					break;
-				case NEXTHOP_TYPE_IPV6:
-				case NEXTHOP_TYPE_IPV6_IFINDEX:
-
-					if (memcmp(&nexthop->gate.ipv6,
-						   &nrn->p.u.prefix6, 16)
-					    == 0) {
-						if (num_resolving_nh)
-							UNSET_FLAG(
-								nexthop->flags,
-								NEXTHOP_FLAG_FILTERED);
-						else
-							SET_FLAG(
-								nexthop->flags,
-								NEXTHOP_FLAG_FILTERED);
-					}
-					break;
-				default:
-					break;
-				}
-			}
-
-			if (IS_ZEBRA_DEBUG_NHT) {
-				prefix2str(&static_rn->p, bufs,
-					   INET6_ADDRSTRLEN);
-				if (prn && re)
-					zlog_debug(
-						"%u:%s: NH change %s, scheduling static route %s",
-						vrfid, bufn,
-						num_resolving_nh
-							? ""
-							: "(filtered by route-map)",
-						bufs);
-				else
-					zlog_debug(
-						"%u:%s: NH unreachable, scheduling static route %s",
-						vrfid, bufn, bufs);
-			}
-
-			SET_FLAG(sre->status, ROUTE_ENTRY_CHANGED);
-			SET_FLAG(sre->status, ROUTE_ENTRY_NEXTHOPS_CHANGED);
-		}
-
-		rib_queue_add(static_rn);
-	}
-}
-
 /*
  * Determine appropriate route (route entry) resolving a tracked
  * nexthop.
@@ -809,10 +638,6 @@ static void zebra_rnh_eval_nexthop_entry
 		zebra_rnh_notify_protocol_clients(vrfid, family, nrn, rnh, prn,
 						  rnh->state);
 
-		/* Process static routes attached to this nexthop */
-		zebra_rnh_process_static_routes(vrfid, family, nrn, rnh, prn,
-						rnh->state);
-
 		zebra_rnh_process_pbr_tables(family, nrn, rnh, prn,
 					     rnh->state);
 
@@ -962,7 +787,6 @@ static void free_state(vrf_id_t vrf_id,
 		return;
 
 	/* free RE and nexthops */
-	zebra_deregister_rnh_static_nexthops(vrf_id, re->ng.nexthop, rn);
 	nexthops_free(re->ng.nexthop);
 	XFREE(MTYPE_RE, re);
 }
@@ -1046,8 +870,9 @@ static int send_client(struct rnh *rnh,
 		stream_put(s, &rn->p.u.prefix6, IPV6_MAX_BYTELEN);
 		break;
 	default:
-		zlog_err("%s: Unknown family (%d) notification attempted\n",
-			 __FUNCTION__, rn->p.family);
+		flog_err(ZEBRA_ERR_RNH_UNKNOWN_FAMILY,
+			  "%s: Unknown family (%d) notification attempted\n",
+			  __FUNCTION__, rn->p.family);
 		break;
 	}
 	if (re) {
@@ -1106,7 +931,7 @@ static int send_client(struct rnh *rnh,
 
 	client->nh_last_upd_time = monotime(NULL);
 	client->last_write_cmd = cmd;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 static void print_nh(struct nexthop *nexthop, struct vty *vty)
@@ -1173,9 +998,6 @@ static void print_rnh(struct route_node
 		vty_out(vty, " %s(fd %d)%s", zebra_route_string(client->proto),
 			client->sock,
 			rnh->filtered[client->proto] ? "(filtered)" : "");
-	if (!list_isempty(rnh->zebra_static_route_list))
-		vty_out(vty, " zebra%s",
-			rnh->filtered[ZEBRA_ROUTE_STATIC] ? "(filtered)" : "");
 	if (!list_isempty(rnh->zebra_pseudowire_list))
 		vty_out(vty, " zebra[pseudowires]");
 	vty_out(vty, "\n");
diff -urpN frr-frr-5.0.1/zebra/zebra_rnh.h frr-frr-6.0/zebra/zebra_rnh.h
--- frr-frr-5.0.1/zebra/zebra_rnh.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_rnh.h	2018-10-08 14:32:57.000000000 +0200
@@ -39,14 +39,16 @@ struct rnh {
 	struct route_entry *state;
 	struct prefix resolved_route;
 	struct list *client_list;
-	struct list
-		*zebra_static_route_list; /* static routes dependent on this NH
-					     */
-	struct list
-		*zebra_pseudowire_list; /* pseudowires dependent on this NH */
+
+	/* pseudowires dependent on this nh */
+	struct list *zebra_pseudowire_list;
+
 	struct route_node *node;
-	int filtered[ZEBRA_ROUTE_MAX]; /* if this has been filtered for client
-					  */
+
+	/*
+	 * if this has been filtered for the client
+	 */
+	int filtered[ZEBRA_ROUTE_MAX];
 };
 
 typedef enum { RNH_NEXTHOP_TYPE, RNH_IMPORT_CHECK_TYPE } rnh_type_t;
@@ -66,20 +68,13 @@ static inline int rnh_resolve_via_defaul
 }
 
 extern struct rnh *zebra_add_rnh(struct prefix *p, vrf_id_t vrfid,
-				 rnh_type_t type);
+				 rnh_type_t type, bool *exists);
 extern struct rnh *zebra_lookup_rnh(struct prefix *p, vrf_id_t vrfid,
 				    rnh_type_t type);
 extern void zebra_free_rnh(struct rnh *rnh);
 extern void zebra_delete_rnh(struct rnh *rnh, rnh_type_t type);
 extern void zebra_add_rnh_client(struct rnh *rnh, struct zserv *client,
 				 rnh_type_t type, vrf_id_t vrfid);
-extern void zebra_register_rnh_static_nh(vrf_id_t, struct prefix *,
-					 struct route_node *);
-extern void zebra_deregister_rnh_static_nexthops(vrf_id_t,
-						 struct nexthop *nexthop,
-						 struct route_node *rn);
-extern void zebra_deregister_rnh_static_nh(vrf_id_t, struct prefix *,
-					   struct route_node *);
 extern void zebra_register_rnh_pseudowire(vrf_id_t, struct zebra_pw *);
 extern void zebra_deregister_rnh_pseudowire(vrf_id_t, struct zebra_pw *);
 extern void zebra_remove_rnh_client(struct rnh *rnh, struct zserv *client,
diff -urpN frr-frr-5.0.1/zebra/zebra_routemap.c frr-frr-6.0/zebra/zebra_routemap.c
--- frr-frr-5.0.1/zebra/zebra_routemap.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_routemap.c	2018-10-08 14:32:57.000000000 +0200
@@ -31,6 +31,7 @@
 #include "plist.h"
 #include "nexthop.h"
 #include "vrf.h"
+#include "frrstr.h"
 
 #include "zebra/zserv.h"
 #include "zebra/redistribute.h"
@@ -136,7 +137,8 @@ static int zebra_route_match_delete(stru
 /* 'match tag TAG'
  * Match function return 1 if match is success else return 0
  */
-static route_map_result_t route_match_tag(void *rule, struct prefix *prefix,
+static route_map_result_t route_match_tag(void *rule,
+					  const struct prefix *prefix,
 					  route_map_object_t type, void *object)
 {
 	route_tag_t *tag;
@@ -162,7 +164,7 @@ static struct route_map_rule_cmd route_m
 /* `match interface IFNAME' */
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_interface(void *rule,
-						struct prefix *prefix,
+						const struct prefix *prefix,
 						route_map_object_t type,
 						void *object)
 {
@@ -878,7 +880,7 @@ DEFUN (show_ipv6_protocol_nht,
 
 /* Match function return 1 if match is success else return zero. */
 static route_map_result_t route_match_ip_next_hop(void *rule,
-						  struct prefix *prefix,
+						  const struct prefix *prefix,
 						  route_map_object_t type,
 						  void *object)
 {
@@ -936,7 +938,7 @@ static struct route_map_rule_cmd route_m
 /* `match ip next-hop prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_next_hop_prefix_list(void *rule, struct prefix *prefix,
+route_match_ip_next_hop_prefix_list(void *rule, const struct prefix *prefix,
 				    route_map_object_t type, void *object)
 {
 	struct prefix_list *plist;
@@ -992,7 +994,7 @@ static struct route_map_rule_cmd route_m
 /* Match function should return 1 if match is success else return
    zero. */
 static route_map_result_t route_match_ip_address(void *rule,
-						 struct prefix *prefix,
+						 const struct prefix *prefix,
 						 route_map_object_t type,
 						 void *object)
 {
@@ -1031,13 +1033,13 @@ static struct route_map_rule_cmd route_m
 /* `match ip address prefix-list PREFIX_LIST' */
 
 static route_map_result_t
-route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
-				   route_map_object_t type, void *object)
+route_match_address_prefix_list(void *rule, const struct prefix *prefix,
+			route_map_object_t type, void *object, afi_t afi)
 {
 	struct prefix_list *plist;
 
 	if (type == RMAP_ZEBRA) {
-		plist = prefix_list_lookup(AFI_IP, (char *)rule);
+		plist = prefix_list_lookup(afi, (char *)rule);
 		if (plist == NULL)
 			return RMAP_NOMATCH;
 
@@ -1048,26 +1050,46 @@ route_match_ip_address_prefix_list(void
 	return RMAP_NOMATCH;
 }
 
-static void *route_match_ip_address_prefix_list_compile(const char *arg)
+static route_map_result_t
+route_match_ip_address_prefix_list(void *rule, const struct prefix *prefix,
+				   route_map_object_t type, void *object)
+{
+	return (route_match_address_prefix_list(rule, prefix, type, object,
+						AFI_IP));
+}
+
+static void *route_match_address_prefix_list_compile(const char *arg)
 {
 	return XSTRDUP(MTYPE_ROUTE_MAP_COMPILED, arg);
 }
 
-static void route_match_ip_address_prefix_list_free(void *rule)
+static void route_match_address_prefix_list_free(void *rule)
 {
 	XFREE(MTYPE_ROUTE_MAP_COMPILED, rule);
 }
 
 static struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd = {
 	"ip address prefix-list", route_match_ip_address_prefix_list,
-	route_match_ip_address_prefix_list_compile,
-	route_match_ip_address_prefix_list_free};
+	route_match_address_prefix_list_compile,
+	route_match_address_prefix_list_free};
+
+static route_map_result_t
+route_match_ipv6_address_prefix_list(void *rule, const struct prefix *prefix,
+					route_map_object_t type, void *object)
+{
+	return (route_match_address_prefix_list(rule, prefix, type, object,
+						AFI_IP6));
+}
 
+static struct route_map_rule_cmd route_match_ipv6_address_prefix_list_cmd = {
+	"ipv6 address prefix-list", route_match_ipv6_address_prefix_list,
+	route_match_address_prefix_list_compile,
+	route_match_address_prefix_list_free};
 
 /* `match ip address prefix-len PREFIXLEN' */
 
 static route_map_result_t
-route_match_address_prefix_len(void *rule, struct prefix *prefix,
+route_match_address_prefix_len(void *rule, const struct prefix *prefix,
 			       route_map_object_t type, void *object)
 {
 	uint32_t *prefixlen = (uint32_t *)rule;
@@ -1096,9 +1118,6 @@ static void *route_match_address_prefix_
 
 	prefix_len = XMALLOC(MTYPE_ROUTE_MAP_COMPILED, sizeof(uint32_t));
 
-	if (!prefix_len)
-		return prefix_len;
-
 	*prefix_len = tmpval;
 	return prefix_len;
 }
@@ -1121,7 +1140,7 @@ static struct route_map_rule_cmd route_m
 /* `match ip nexthop prefix-len PREFIXLEN' */
 
 static route_map_result_t
-route_match_ip_nexthop_prefix_len(void *rule, struct prefix *prefix,
+route_match_ip_nexthop_prefix_len(void *rule, const struct prefix *prefix,
 				  route_map_object_t type, void *object)
 {
 	uint32_t *prefixlen = (uint32_t *)rule;
@@ -1161,7 +1180,7 @@ static struct route_map_rule_cmd route_m
 /* `match source-protocol PROTOCOL' */
 
 static route_map_result_t route_match_source_protocol(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *p,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -1203,7 +1222,7 @@ static struct route_map_rule_cmd route_m
 
 /* `source-instance` */
 static route_map_result_t route_match_source_instance(void *rule,
-						      struct prefix *prefix,
+						      const struct prefix *p,
 						      route_map_object_t type,
 						      void *object)
 {
@@ -1245,7 +1264,7 @@ static struct route_map_rule_cmd route_m
 /* `set src A.B.C.D' */
 
 /* Set src. */
-static route_map_result_t route_set_src(void *rule, struct prefix *prefix,
+static route_map_result_t route_set_src(void *rule, const struct prefix *prefix,
 					route_map_object_t type, void *object)
 {
 	struct nh_rmap_obj *nh_data;
@@ -1282,6 +1301,103 @@ static struct route_map_rule_cmd route_s
 	"src", route_set_src, route_set_src_compile, route_set_src_free,
 };
 
+/* The function checks if the changed routemap specified by parameter rmap
+ * matches the configured protocol routemaps in proto_rm table. If there is
+ * a match then rib_update_table() to process the routes.
+ */
+static void zebra_rib_table_rm_update(const char *rmap)
+{
+	int i = 0;
+	struct route_table *table;
+	char *rmap_name;
+	char afi_ip = 0;
+	char afi_ipv6 = 0;
+
+	for (i = 0; i <= ZEBRA_ROUTE_MAX; i++) {
+	/* Check for ip routemap table */
+		rmap_name = proto_rm[AFI_IP][i];
+		if (rmap_name && (strcmp(rmap_name, rmap) == 0)) {
+			if (IS_ZEBRA_DEBUG_EVENT)
+				zlog_debug("%s : AFI_IP rmap %s, route type %s",
+				__func__, rmap, zebra_route_string(i));
+			/* There is single rib table for all protocols */
+			if (afi_ip == 0) {
+				table = zebra_vrf_table(AFI_IP, SAFI_UNICAST,
+						VRF_DEFAULT);
+				if (table) {
+					afi_ip = 1;
+					rib_update_table(table,
+						RIB_UPDATE_RMAP_CHANGE);
+				}
+			}
+		}
+
+		/* Check for ipv6 routemap table */
+		rmap_name = proto_rm[AFI_IP6][i];
+		if (rmap_name && (strcmp(rmap_name, rmap) == 0)) {
+			if (IS_ZEBRA_DEBUG_EVENT)
+				zlog_debug("%s : AFI_IP6 rmap %s,route type %s",
+				__func__, rmap, zebra_route_string(i));
+			if (afi_ipv6 == 0) {
+				table = zebra_vrf_table(AFI_IP6, SAFI_UNICAST,
+						VRF_DEFAULT);
+				if (table) {
+					afi_ipv6 = 1;
+					rib_update_table(table,
+						RIB_UPDATE_RMAP_CHANGE);
+				}
+			}
+		}
+	}
+}
+
+/* The function checks if the changed routemap specified by parameter rmap
+ * matches the configured protocol routemaps in nht_rm table. If there is
+ * a match then zebra_evaluate_rnh() to process the nexthops.
+ */
+static void zebra_nht_rm_update(const char *rmap)
+{
+	int i = 0;
+	char *rmap_name;
+	char afi_ip = 0;
+	char afi_ipv6 = 0;
+
+	for (i = 0; i <= ZEBRA_ROUTE_MAX; i++) {
+		rmap_name = nht_rm[AFI_IP][i];
+		if (rmap_name && (strcmp(rmap_name, rmap) == 0)) {
+			if (IS_ZEBRA_DEBUG_EVENT)
+				zlog_debug("%s : AFI_IP rmap %s route type %s",
+					__func__, rmap, zebra_route_string(i));
+			if (afi_ip == 0) {
+				afi_ip = 1;
+				zebra_evaluate_rnh(0, AF_INET, 1,
+					RNH_NEXTHOP_TYPE, NULL);
+			}
+		}
+		rmap_name = nht_rm[AFI_IP6][i];
+		if (rmap_name && (strcmp(rmap_name, rmap) == 0)) {
+			if (IS_ZEBRA_DEBUG_EVENT)
+				zlog_debug("%s : AFI_IP6 rmap %s route type %s",
+					__func__, rmap, zebra_route_string(i));
+			if (afi_ipv6 == 0) {
+				afi_ipv6 = 1;
+				zebra_evaluate_rnh(0, AF_INET6, 1,
+					RNH_NEXTHOP_TYPE, NULL);
+			}
+		}
+	}
+}
+
+static void zebra_route_map_process_update_cb(char *rmap_name)
+{
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("Event handler for route-map: %s",
+			   rmap_name);
+	zebra_import_table_rm_update(rmap_name);
+	zebra_rib_table_rm_update(rmap_name);
+	zebra_nht_rm_update(rmap_name);
+}
+
 static int zebra_route_map_update_timer(struct thread *thread)
 {
 	zebra_t_rmap_update = NULL;
@@ -1294,11 +1410,13 @@ static int zebra_route_map_update_timer(
 			"%u: Routemap update-timer fired, scheduling RIB processing",
 			VRF_DEFAULT);
 
-	zebra_import_table_rm_update();
-	rib_update(VRF_DEFAULT, RIB_UPDATE_RMAP_CHANGE);
-	zebra_evaluate_rnh(0, AF_INET, 1, RNH_NEXTHOP_TYPE, NULL);
-	zebra_evaluate_rnh(0, AF_INET6, 1, RNH_NEXTHOP_TYPE, NULL);
+	route_map_walk_update_list(zebra_route_map_process_update_cb);
 
+	/*
+	 * This code needs to be updated to be:
+	 * 1) VRF Aware <sigh>
+	 * 2) Route-map aware
+	 */
 	return (0);
 }
 
@@ -1322,7 +1440,8 @@ void zebra_route_map_write_delay_timer(s
 }
 
 route_map_result_t zebra_route_map_check(int family, int rib_type,
-					 uint8_t instance, struct prefix *p,
+					 uint8_t instance,
+					 const struct prefix *p,
 					 struct nexthop *nexthop,
 					 vrf_id_t vrf_id, route_tag_t tag)
 {
@@ -1368,7 +1487,8 @@ void zebra_del_import_table_route_map(af
 
 route_map_result_t
 zebra_import_table_route_map_check(int family, int re_type, uint8_t instance,
-				   struct prefix *p, struct nexthop *nexthop,
+				   const struct prefix *p,
+				   struct nexthop *nexthop,
 				   vrf_id_t vrf_id, route_tag_t tag,
 				   const char *rmap_name)
 {
@@ -1393,7 +1513,7 @@ zebra_import_table_route_map_check(int f
 }
 
 route_map_result_t zebra_nht_route_map_check(int family, int client_proto,
-					     struct prefix *p,
+					     const struct prefix *p,
 					     struct route_entry *re,
 					     struct nexthop *nexthop)
 {
@@ -1413,11 +1533,10 @@ route_map_result_t zebra_nht_route_map_c
 	if (!rmap && nht_rm[family][ZEBRA_ROUTE_MAX])
 		rmap = route_map_lookup_by_name(
 			nht_rm[family][ZEBRA_ROUTE_MAX]);
-	if (rmap) {
+	if (rmap)
 		ret = route_map_apply(rmap, p, RMAP_ZEBRA, &nh_obj);
-	}
 
-	return (ret);
+	return ret;
 }
 
 static void zebra_route_map_mark_update(const char *rmap_name)
@@ -1433,20 +1552,26 @@ static void zebra_route_map_mark_update(
 
 static void zebra_route_map_add(const char *rmap_name)
 {
-	zebra_route_map_mark_update(rmap_name);
+	if (route_map_mark_updated(rmap_name) == 0)
+		zebra_route_map_mark_update(rmap_name);
+
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
 }
 
 static void zebra_route_map_delete(const char *rmap_name)
 {
-	zebra_route_map_mark_update(rmap_name);
+	if (route_map_mark_updated(rmap_name) == 0)
+		zebra_route_map_mark_update(rmap_name);
+
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_DELETED);
 }
 
 static void zebra_route_map_event(route_map_event_t event,
 				  const char *rmap_name)
 {
-	zebra_route_map_mark_update(rmap_name);
+	if (route_map_mark_updated(rmap_name) == 0)
+		zebra_route_map_mark_update(rmap_name);
+
 	route_map_notify_dependencies(rmap_name, RMAP_EVENT_MATCH_ADDED);
 }
 
@@ -1535,12 +1660,19 @@ void zebra_route_map_init()
 	route_map_match_tag_hook(generic_match_add);
 	route_map_no_match_tag_hook(generic_match_delete);
 
+	route_map_match_ipv6_address_hook(generic_match_add);
+	route_map_no_match_ipv6_address_hook(generic_match_delete);
+
+	route_map_match_ipv6_address_prefix_list_hook(generic_match_add);
+	route_map_no_match_ipv6_address_prefix_list_hook(generic_match_delete);
+
 	route_map_install_match(&route_match_tag_cmd);
 	route_map_install_match(&route_match_interface_cmd);
 	route_map_install_match(&route_match_ip_next_hop_cmd);
 	route_map_install_match(&route_match_ip_next_hop_prefix_list_cmd);
 	route_map_install_match(&route_match_ip_address_cmd);
 	route_map_install_match(&route_match_ip_address_prefix_list_cmd);
+	route_map_install_match(&route_match_ipv6_address_prefix_list_cmd);
 	route_map_install_match(&route_match_ip_address_prefix_len_cmd);
 	route_map_install_match(&route_match_ipv6_address_prefix_len_cmd);
 	route_map_install_match(&route_match_ip_nexthop_prefix_len_cmd);
diff -urpN frr-frr-5.0.1/zebra/zebra_routemap.h frr-frr-6.0/zebra/zebra_routemap.h
--- frr-frr-5.0.1/zebra/zebra_routemap.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_routemap.h	2018-10-08 14:32:57.000000000 +0200
@@ -35,15 +35,16 @@ extern void zebra_route_map_write_delay_
 
 extern route_map_result_t
 zebra_import_table_route_map_check(int family, int rib_type, uint8_t instance,
-				   struct prefix *p, struct nexthop *nexthop,
+				   const struct prefix *p,
+				   struct nexthop *nexthop,
 				   vrf_id_t vrf_id, route_tag_t tag,
 				   const char *rmap_name);
 extern route_map_result_t
 zebra_route_map_check(int family, int rib_type, uint8_t instance,
-		      struct prefix *p, struct nexthop *nexthop,
+		      const struct prefix *p, struct nexthop *nexthop,
 		      vrf_id_t vrf_id, route_tag_t tag);
 extern route_map_result_t
-zebra_nht_route_map_check(int family, int client_proto, struct prefix *p,
+zebra_nht_route_map_check(int family, int client_proto, const struct prefix *p,
 			  struct route_entry *, struct nexthop *nexthop);
 
 
diff -urpN frr-frr-5.0.1/zebra/zebra_static.c frr-frr-6.0/zebra/zebra_static.c
--- frr-frr-5.0.1/zebra/zebra_static.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_static.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,832 +0,0 @@
-/*
- * Static Routing Information code
- * Copyright (C) 2016 Cumulus Networks
- *               Donald Sharp
- *
- * This file is part of Quagga.
- *
- * Quagga is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * Quagga is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#include <zebra.h>
-
-#include <lib/nexthop.h>
-#include <lib/memory.h>
-#include <lib/srcdest_table.h>
-#include <lib/if.h>
-
-#include "vty.h"
-#include "zebra/debug.h"
-#include "zebra/rib.h"
-#include "zebra/zserv.h"
-#include "zebra/zebra_vrf.h"
-#include "zebra/zebra_static.h"
-#include "zebra/zebra_rnh.h"
-#include "zebra/redistribute.h"
-#include "zebra/zebra_memory.h"
-
-/* Install static route into rib. */
-void static_install_route(afi_t afi, safi_t safi, struct prefix *p,
-			  struct prefix_ipv6 *src_p, struct static_route *si)
-{
-	struct route_entry *re;
-	struct route_node *rn;
-	struct route_table *table;
-	struct prefix nh_p;
-	struct nexthop *nexthop = NULL;
-	enum blackhole_type bh_type = 0;
-	struct vrf *nh_vrf;
-
-	/* Lookup table.  */
-	table = zebra_vrf_table(afi, safi, si->vrf_id);
-	if (!table)
-		return;
-
-	/*
-	 * If a specific vrf is coming up and the nexthop vrf we are
-	 * looking at using hasn't been brought up yet, just don't
-	 * install the static route yet.
-	 * When the nexthop vrf comes up we will get another call
-	 * back to do the right thing.  I'm putting this check
-	 * here because we are calling static_install_route a bunch
-	 * from a bunch of different callpaths.
-	 */
-	nh_vrf = vrf_lookup_by_id(si->nh_vrf_id);
-	if (!nh_vrf)
-		return;
-
-	memset(&nh_p, 0, sizeof(nh_p));
-	if (si->type == STATIC_BLACKHOLE) {
-		switch (si->bh_type) {
-		case STATIC_BLACKHOLE_DROP:
-		case STATIC_BLACKHOLE_NULL:
-			bh_type = BLACKHOLE_NULL;
-			break;
-		case STATIC_BLACKHOLE_REJECT:
-			bh_type = BLACKHOLE_REJECT;
-			break;
-		}
-	}
-
-	/* Lookup existing route */
-	rn = srcdest_rnode_get(table, p, src_p);
-	RNODE_FOREACH_RE (rn, re) {
-		if (CHECK_FLAG(re->status, ROUTE_ENTRY_REMOVED))
-			continue;
-
-		if (re->type == ZEBRA_ROUTE_STATIC
-		    && re->distance == si->distance)
-			break;
-	}
-
-	if (re) {
-		/* if tag value changed , update old value in RIB */
-		if (re->tag != si->tag)
-			re->tag = si->tag;
-
-		/* Same distance static route is there.  Update it with new
-		   nexthop. */
-		route_unlock_node(rn);
-		switch (si->type) {
-		case STATIC_IPV4_GATEWAY:
-			nexthop = route_entry_nexthop_ipv4_add(
-				re, &si->addr.ipv4, NULL, si->nh_vrf_id);
-			nh_p.family = AF_INET;
-			nh_p.prefixlen = IPV4_MAX_BITLEN;
-			nh_p.u.prefix4 = si->addr.ipv4;
-			zebra_register_rnh_static_nh(si->nh_vrf_id, &nh_p, rn);
-			break;
-		case STATIC_IPV4_GATEWAY_IFNAME:
-			nexthop = route_entry_nexthop_ipv4_ifindex_add(
-				re, &si->addr.ipv4, NULL, si->ifindex,
-				si->nh_vrf_id);
-			break;
-		case STATIC_IFNAME:
-			nexthop = route_entry_nexthop_ifindex_add(
-				re, si->ifindex, si->nh_vrf_id);
-			break;
-		case STATIC_BLACKHOLE:
-			nexthop =
-				route_entry_nexthop_blackhole_add(re, bh_type);
-			break;
-		case STATIC_IPV6_GATEWAY:
-			nexthop = route_entry_nexthop_ipv6_add(
-				re, &si->addr.ipv6, si->nh_vrf_id);
-			nh_p.family = AF_INET6;
-			nh_p.prefixlen = IPV6_MAX_BITLEN;
-			nh_p.u.prefix6 = si->addr.ipv6;
-			zebra_register_rnh_static_nh(si->nh_vrf_id, &nh_p, rn);
-			break;
-		case STATIC_IPV6_GATEWAY_IFNAME:
-			nexthop = route_entry_nexthop_ipv6_ifindex_add(
-				re, &si->addr.ipv6, si->ifindex, si->nh_vrf_id);
-			break;
-		}
-		/* Update label(s), if present. */
-		if (si->snh_label.num_labels)
-			nexthop_add_labels(nexthop, ZEBRA_LSP_STATIC,
-					   si->snh_label.num_labels,
-					   &si->snh_label.label[0]);
-
-		if (IS_ZEBRA_DEBUG_RIB) {
-			char buf[INET6_ADDRSTRLEN];
-			if (IS_ZEBRA_DEBUG_RIB) {
-				inet_ntop(p->family, &p->u.prefix, buf,
-					  INET6_ADDRSTRLEN);
-				zlog_debug(
-					"%u:%s/%d: Modifying route rn %p, re %p (type %d)",
-					si->vrf_id, buf, p->prefixlen, rn, re,
-					re->type);
-			}
-		}
-
-		re->uptime = time(NULL);
-		/* Schedule route for processing or invoke NHT, as appropriate.
-		 */
-		if (si->type == STATIC_IPV4_GATEWAY
-		    || si->type == STATIC_IPV6_GATEWAY)
-			zebra_evaluate_rnh(si->nh_vrf_id, nh_p.family, 1,
-					   RNH_NEXTHOP_TYPE, &nh_p);
-		else
-			rib_queue_add(rn);
-	} else {
-		/* This is new static route. */
-		re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
-
-		re->type = ZEBRA_ROUTE_STATIC;
-		re->instance = 0;
-		re->distance = si->distance;
-		re->metric = 0;
-		re->mtu = 0;
-		re->vrf_id = si->vrf_id;
-		re->table =
-			(si->vrf_id != VRF_DEFAULT)
-				? (zebra_vrf_lookup_by_id(si->vrf_id))->table_id
-				: zebrad.rtm_table_default;
-		re->nexthop_num = 0;
-		re->tag = si->tag;
-
-		switch (si->type) {
-		case STATIC_IPV4_GATEWAY:
-			nexthop = route_entry_nexthop_ipv4_add(
-				re, &si->addr.ipv4, NULL, si->nh_vrf_id);
-			nh_p.family = AF_INET;
-			nh_p.prefixlen = IPV4_MAX_BITLEN;
-			nh_p.u.prefix4 = si->addr.ipv4;
-			zebra_register_rnh_static_nh(si->nh_vrf_id, &nh_p, rn);
-			break;
-		case STATIC_IPV4_GATEWAY_IFNAME:
-			nexthop = route_entry_nexthop_ipv4_ifindex_add(
-				re, &si->addr.ipv4, NULL, si->ifindex,
-				si->nh_vrf_id);
-			break;
-		case STATIC_IFNAME:
-			nexthop = route_entry_nexthop_ifindex_add(
-				re, si->ifindex, si->nh_vrf_id);
-			break;
-		case STATIC_BLACKHOLE:
-			nexthop =
-				route_entry_nexthop_blackhole_add(re, bh_type);
-			break;
-		case STATIC_IPV6_GATEWAY:
-			nexthop = route_entry_nexthop_ipv6_add(
-				re, &si->addr.ipv6, si->nh_vrf_id);
-			nh_p.family = AF_INET6;
-			nh_p.prefixlen = IPV6_MAX_BITLEN;
-			nh_p.u.prefix6 = si->addr.ipv6;
-			zebra_register_rnh_static_nh(si->nh_vrf_id, &nh_p, rn);
-			break;
-		case STATIC_IPV6_GATEWAY_IFNAME:
-			nexthop = route_entry_nexthop_ipv6_ifindex_add(
-				re, &si->addr.ipv6, si->ifindex, si->nh_vrf_id);
-			break;
-		}
-		/* Update label(s), if present. */
-		if (si->snh_label.num_labels)
-			nexthop_add_labels(nexthop, ZEBRA_LSP_STATIC,
-					   si->snh_label.num_labels,
-					   &si->snh_label.label[0]);
-
-		if (IS_ZEBRA_DEBUG_RIB) {
-			char buf[INET6_ADDRSTRLEN];
-			if (IS_ZEBRA_DEBUG_RIB) {
-				inet_ntop(p->family, &p->u.prefix, buf,
-					  INET6_ADDRSTRLEN);
-				zlog_debug(
-					"%u:%s/%d: Inserting route rn %p, re %p (type %d)",
-					si->vrf_id, buf, p->prefixlen, rn, re,
-					re->type);
-			}
-		}
-		re->uptime = time(NULL);
-		/* Link this re to the tree. Schedule for processing or invoke
-		 * NHT,
-		 * as appropriate.
-		 */
-		if (si->type == STATIC_IPV4_GATEWAY
-		    || si->type == STATIC_IPV6_GATEWAY) {
-			rib_addnode(rn, re, 0);
-			zebra_evaluate_rnh(si->nh_vrf_id, nh_p.family, 1,
-					   RNH_NEXTHOP_TYPE, &nh_p);
-		} else
-			rib_addnode(rn, re, 1);
-	}
-}
-
-/* this works correctly with IFNAME<>IFINDEX because a static route on a
- * non-active interface will have IFINDEX_INTERNAL and thus compare false
- */
-static int static_nexthop_same(struct nexthop *nexthop, struct static_route *si)
-{
-	if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE
-	    && si->type == STATIC_BLACKHOLE)
-		return 1;
-
-	if (nexthop->type == NEXTHOP_TYPE_IPV4
-	    && si->type == STATIC_IPV4_GATEWAY
-	    && IPV4_ADDR_SAME(&nexthop->gate.ipv4, &si->addr.ipv4))
-		return 1;
-	else if (nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX
-		 && si->type == STATIC_IPV4_GATEWAY_IFNAME
-		 && IPV4_ADDR_SAME(&nexthop->gate.ipv4, &si->addr.ipv4)
-		 && nexthop->ifindex == si->ifindex)
-		return 1;
-	else if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-		 && si->type == STATIC_IFNAME
-		 && nexthop->ifindex == si->ifindex)
-		return 1;
-	else if (nexthop->type == NEXTHOP_TYPE_IPV6
-		 && si->type == STATIC_IPV6_GATEWAY
-		 && IPV6_ADDR_SAME(&nexthop->gate.ipv6, &si->addr.ipv6))
-		return 1;
-	else if (nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-		 && si->type == STATIC_IPV6_GATEWAY_IFNAME
-		 && IPV6_ADDR_SAME(&nexthop->gate.ipv6, &si->addr.ipv6)
-		 && nexthop->ifindex == si->ifindex)
-		return 1;
-
-	return 0;
-}
-
-/* Uninstall static route from RIB. */
-void static_uninstall_route(afi_t afi, safi_t safi, struct prefix *p,
-			    struct prefix_ipv6 *src_p, struct static_route *si)
-{
-	struct route_node *rn;
-	struct route_entry *re;
-	struct nexthop *nexthop;
-	struct route_table *table;
-	struct prefix nh_p;
-
-	/* Lookup table.  */
-	table = zebra_vrf_table(afi, safi, si->vrf_id);
-	if (!table)
-		return;
-
-	/* Lookup existing route with type and distance. */
-	rn = srcdest_rnode_lookup(table, p, src_p);
-	if (!rn)
-		return;
-
-	RNODE_FOREACH_RE (rn, re) {
-		if (CHECK_FLAG(re->status, ROUTE_ENTRY_REMOVED))
-			continue;
-
-		if (re->type == ZEBRA_ROUTE_STATIC
-		    && re->distance == si->distance && re->tag == si->tag)
-			break;
-	}
-
-	if (!re) {
-		route_unlock_node(rn);
-		return;
-	}
-
-	/* Lookup nexthop. */
-	for (nexthop = re->ng.nexthop; nexthop; nexthop = nexthop->next)
-		if (static_nexthop_same(nexthop, si))
-			break;
-
-	/* Can't find nexthop. */
-	if (!nexthop) {
-		route_unlock_node(rn);
-		return;
-	}
-
-	/* Check nexthop. */
-	if (re->nexthop_num == 1)
-		rib_delnode(rn, re);
-	else {
-		/* Mark this nexthop as inactive and reinstall the route. Then,
-		 * delete
-		 * the nexthop. There is no need to re-evaluate the route for
-		 * this
-		 * scenario.
-		 */
-		if (IS_ZEBRA_DEBUG_RIB) {
-			char buf[INET6_ADDRSTRLEN];
-			if (IS_ZEBRA_DEBUG_RIB) {
-				inet_ntop(p->family, &p->u.prefix, buf,
-					  INET6_ADDRSTRLEN);
-				zlog_debug(
-					"%u:%s/%d: Modifying route rn %p, re %p (type %d)",
-					si->vrf_id, buf, p->prefixlen, rn, re,
-					re->type);
-			}
-		}
-		UNSET_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB)) {
-			rib_dest_t *dest = rib_dest_from_rnode(rn);
-
-			/* If there are other active nexthops, do an update. */
-			if (re->nexthop_active_num > 1) {
-				/* Update route in kernel if it's in fib */
-				if (dest->selected_fib)
-					rib_install_kernel(rn, re, re);
-				/* Update redistribution if it's selected */
-				if (CHECK_FLAG(re->flags, ZEBRA_FLAG_SELECTED))
-					redistribute_update(
-						p, (struct prefix *)src_p, re,
-						NULL);
-			} else {
-				/* Remove from redistribute if selected route
-				 * becomes inactive */
-				if (CHECK_FLAG(re->flags, ZEBRA_FLAG_SELECTED))
-					redistribute_delete(
-						p, (struct prefix *)src_p, re);
-				/* Remove from kernel if fib route becomes
-				 * inactive */
-				if (dest->selected_fib)
-					rib_uninstall_kernel(rn, re);
-			}
-		}
-
-		if (afi == AFI_IP) {
-			/* Delete the nexthop and dereg from NHT */
-			nh_p.family = AF_INET;
-			nh_p.prefixlen = IPV4_MAX_BITLEN;
-			nh_p.u.prefix4 = nexthop->gate.ipv4;
-		} else {
-			nh_p.family = AF_INET6;
-			nh_p.prefixlen = IPV6_MAX_BITLEN;
-			nh_p.u.prefix6 = nexthop->gate.ipv6;
-		}
-		route_entry_nexthop_delete(re, nexthop);
-		zebra_deregister_rnh_static_nh(si->nh_vrf_id, &nh_p, rn);
-		nexthop_free(nexthop);
-	}
-	/* Unlock node. */
-	route_unlock_node(rn);
-}
-
-int static_add_route(afi_t afi, safi_t safi, uint8_t type, struct prefix *p,
-		     struct prefix_ipv6 *src_p, union g_addr *gate,
-		     const char *ifname, enum static_blackhole_type bh_type,
-		     route_tag_t tag, uint8_t distance, struct zebra_vrf *zvrf,
-		     struct zebra_vrf *nh_zvrf,
-		     struct static_nh_label *snh_label)
-{
-	struct route_node *rn;
-	struct static_route *si;
-	struct static_route *pp;
-	struct static_route *cp;
-	struct static_route *update = NULL;
-	struct route_table *stable = zvrf->stable[afi][safi];
-
-	if (!stable)
-		return -1;
-
-	if (!gate && (type == STATIC_IPV4_GATEWAY
-		      || type == STATIC_IPV4_GATEWAY_IFNAME
-		      || type == STATIC_IPV6_GATEWAY
-		      || type == STATIC_IPV6_GATEWAY_IFNAME))
-		return -1;
-
-	if (!ifname
-	    && (type == STATIC_IFNAME || type == STATIC_IPV4_GATEWAY_IFNAME
-		|| type == STATIC_IPV6_GATEWAY_IFNAME))
-		return -1;
-
-	/* Lookup static route prefix. */
-	rn = srcdest_rnode_get(stable, p, src_p);
-
-	/* Do nothing if there is a same static route.  */
-	for (si = rn->info; si; si = si->next) {
-		if (type == si->type
-		    && (!gate
-			|| ((afi == AFI_IP
-			     && IPV4_ADDR_SAME(&gate->ipv4, &si->addr.ipv4))
-			    || (afi == AFI_IP6
-				&& IPV6_ADDR_SAME(gate, &si->addr.ipv6))))
-		    && (!strcmp(ifname ? ifname : "", si->ifname))) {
-			if ((distance == si->distance) && (tag == si->tag)
-			    && !memcmp(&si->snh_label, snh_label,
-				       sizeof(struct static_nh_label))
-			    && si->bh_type == bh_type) {
-				route_unlock_node(rn);
-				return 0;
-			} else
-				update = si;
-		}
-	}
-
-	/* Distance or tag or label changed, delete existing first. */
-	if (update)
-		static_delete_route(afi, safi, type, p, src_p, gate, ifname,
-				    update->tag, update->distance, zvrf,
-				    &update->snh_label);
-
-	/* Make new static route structure. */
-	si = XCALLOC(MTYPE_STATIC_ROUTE, sizeof(struct static_route));
-
-	si->type = type;
-	si->distance = distance;
-	si->bh_type = bh_type;
-	si->tag = tag;
-	si->vrf_id = zvrf_id(zvrf);
-	si->nh_vrf_id = zvrf_id(nh_zvrf);
-	strcpy(si->nh_vrfname, nh_zvrf->vrf->name);
-
-	if (ifname)
-		strlcpy(si->ifname, ifname, sizeof(si->ifname));
-	si->ifindex = IFINDEX_INTERNAL;
-
-	switch (type) {
-	case STATIC_IPV4_GATEWAY:
-	case STATIC_IPV4_GATEWAY_IFNAME:
-		si->addr.ipv4 = gate->ipv4;
-		break;
-	case STATIC_IPV6_GATEWAY:
-	case STATIC_IPV6_GATEWAY_IFNAME:
-		si->addr.ipv6 = gate->ipv6;
-		break;
-	case STATIC_IFNAME:
-		break;
-	}
-
-	/* Save labels, if any. */
-	memcpy(&si->snh_label, snh_label, sizeof(struct static_nh_label));
-
-	/* Add new static route information to the tree with sort by
-	   distance value and gateway address. */
-	for (pp = NULL, cp = rn->info; cp; pp = cp, cp = cp->next) {
-		if (si->distance < cp->distance)
-			break;
-		if (si->distance > cp->distance)
-			continue;
-		if (si->type == STATIC_IPV4_GATEWAY
-		    && cp->type == STATIC_IPV4_GATEWAY) {
-			if (ntohl(si->addr.ipv4.s_addr)
-			    < ntohl(cp->addr.ipv4.s_addr))
-				break;
-			if (ntohl(si->addr.ipv4.s_addr)
-			    > ntohl(cp->addr.ipv4.s_addr))
-				continue;
-		}
-	}
-
-	/* Make linked list. */
-	if (pp)
-		pp->next = si;
-	else
-		rn->info = si;
-	if (cp)
-		cp->prev = si;
-	si->prev = pp;
-	si->next = cp;
-
-	/* check whether interface exists in system & install if it does */
-	if (!ifname)
-		static_install_route(afi, safi, p, src_p, si);
-	else {
-		struct interface *ifp;
-
-		ifp = if_lookup_by_name(ifname, zvrf_id(nh_zvrf));
-		if (ifp && ifp->ifindex != IFINDEX_INTERNAL) {
-			si->ifindex = ifp->ifindex;
-			static_install_route(afi, safi, p, src_p, si);
-		} else
-			zlog_warn("Static Route using %s interface not installed because the interface does not exist in specified vrf",
-				  ifname);
-	}
-
-	return 1;
-}
-
-int static_delete_route(afi_t afi, safi_t safi, uint8_t type, struct prefix *p,
-			struct prefix_ipv6 *src_p, union g_addr *gate,
-			const char *ifname, route_tag_t tag, uint8_t distance,
-			struct zebra_vrf *zvrf,
-			struct static_nh_label *snh_label)
-{
-	struct route_node *rn;
-	struct static_route *si;
-	struct route_table *stable;
-
-	/* Lookup table.  */
-	stable = zebra_vrf_static_table(afi, safi, zvrf);
-	if (!stable)
-		return -1;
-
-	/* Lookup static route prefix. */
-	rn = srcdest_rnode_lookup(stable, p, src_p);
-	if (!rn)
-		return 0;
-
-	/* Find same static route is the tree */
-	for (si = rn->info; si; si = si->next)
-		if (type == si->type
-		    && (!gate
-			|| ((afi == AFI_IP
-			     && IPV4_ADDR_SAME(&gate->ipv4, &si->addr.ipv4))
-			    || (afi == AFI_IP6
-				&& IPV6_ADDR_SAME(gate, &si->addr.ipv6))))
-		    && (!strcmp(ifname ? ifname : "", si->ifname))
-		    && (!tag || (tag == si->tag))
-		    && (!snh_label->num_labels
-			|| !memcmp(&si->snh_label, snh_label,
-				   sizeof(struct static_nh_label))))
-			break;
-
-	/* Can't find static route. */
-	if (!si) {
-		route_unlock_node(rn);
-		return 0;
-	}
-
-	/* Uninstall from rib. */
-	if (!si->ifname[0] || si->ifindex != IFINDEX_INTERNAL)
-		static_uninstall_route(afi, safi, p, src_p, si);
-
-	/* Unlink static route from linked list. */
-	if (si->prev)
-		si->prev->next = si->next;
-	else
-		rn->info = si->next;
-	if (si->next)
-		si->next->prev = si->prev;
-	route_unlock_node(rn);
-
-	/* Free static route configuration. */
-	XFREE(MTYPE_STATIC_ROUTE, si);
-
-	route_unlock_node(rn);
-
-	return 1;
-}
-
-static void static_ifindex_update_af(struct interface *ifp, bool up, afi_t afi,
-				     safi_t safi)
-{
-	struct route_table *stable;
-	struct route_node *rn;
-	struct static_route *si;
-	struct prefix *p, *src_pp;
-	struct prefix_ipv6 *src_p;
-	struct vrf *vrf;
-
-	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
-		struct zebra_vrf *zvrf;
-
-		zvrf = vrf->info;
-
-		stable = zebra_vrf_static_table(afi, safi, zvrf);
-		if (!stable)
-			continue;
-
-		for (rn = route_top(stable); rn; rn = srcdest_route_next(rn)) {
-			srcdest_rnode_prefixes(rn, &p, &src_pp);
-			src_p = (struct prefix_ipv6 *)src_pp;
-
-			for (si = rn->info; si; si = si->next) {
-				if (!si->ifname[0])
-					continue;
-				if (up) {
-					if (strcmp(si->ifname, ifp->name))
-						continue;
-					si->ifindex = ifp->ifindex;
-					static_install_route(afi, safi, p, src_p, si);
-				} else {
-					if (si->ifindex != ifp->ifindex)
-						continue;
-					static_uninstall_route(afi, safi, p, src_p, si);
-					si->ifindex = IFINDEX_INTERNAL;
-				}
-			}
-		}
-	}
-}
-
-/*
- * This function looks at a zvrf's stable and notices if any of the
- * nexthops we are using are part of the vrf coming up.
- * If we are using them then cleanup the nexthop vrf id
- * to be the new value and then re-installs them
- *
- *
- * stable -> The table we are looking at.
- * zvrf -> The newly changed vrf.
- * afi -> The afi to look at
- * safi -> the safi to look at
- */
-static void static_fixup_vrf(struct zebra_vrf *zvrf,
-			     struct route_table *stable, afi_t afi, safi_t safi)
-{
-	struct route_node *rn;
-	struct static_route *si;
-	struct interface *ifp;
-
-	for (rn = route_top(stable); rn; rn = route_next(rn)) {
-		for (si = rn->info; si; si = si->next) {
-			if (strcmp(zvrf->vrf->name, si->nh_vrfname) != 0)
-				continue;
-
-			si->nh_vrf_id = zvrf->vrf->vrf_id;
-			if (si->ifindex) {
-				ifp = if_lookup_by_name(si->ifname,
-							si->nh_vrf_id);
-				if (ifp)
-					si->ifindex = ifp->ifindex;
-				else
-					continue;
-			}
-			static_install_route(afi, safi, &rn->p, NULL, si);
-		}
-	}
-}
-
-/*
- * This function enables static routes in a zvrf as it
- * is coming up.  It sets the new vrf_id as appropriate.
- *
- * zvrf -> The zvrf that is being brought up and enabled by the kernel
- * stable -> The stable we are looking at.
- * afi -> the afi in question
- * safi -> the safi in question
- */
-static void static_enable_vrf(struct zebra_vrf *zvrf,
-			      struct route_table *stable,
-			      afi_t afi, safi_t safi)
-{
-	struct route_node *rn;
-	struct static_route *si;
-	struct interface *ifp;
-	struct vrf *vrf = zvrf->vrf;
-
-	for (rn = route_top(stable); rn; rn = route_next(rn)) {
-		for (si = rn->info; si; si = si->next) {
-			si->vrf_id = vrf->vrf_id;
-			if (si->ifindex) {
-				ifp = if_lookup_by_name(si->ifname,
-							si->nh_vrf_id);
-				if (ifp)
-					si->ifindex = ifp->ifindex;
-				else
-					continue;
-			}
-			static_install_route(afi, safi, &rn->p, NULL, si);
-		}
-	}
-}
-
-/*
- * When a vrf is being enabled by the kernel, go through all the
- * static routes in the system that use this vrf (both nexthops vrfs
- * and the routes vrf )
- *
- * enable_zvrf -> the vrf being enabled
- */
-void static_fixup_vrf_ids(struct zebra_vrf *enable_zvrf)
-{
-	struct route_table *stable;
-	struct vrf *vrf;
-	afi_t afi;
-	safi_t safi;
-
-	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
-		struct zebra_vrf *zvrf;
-
-		zvrf = vrf->info;
-		/* Install any static routes configured for this VRF. */
-		for (afi = AFI_IP; afi < AFI_MAX; afi++) {
-			for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
-				stable = zvrf->stable[afi][safi];
-				if (!stable)
-					continue;
-
-				static_fixup_vrf(enable_zvrf, stable,
-						 afi, safi);
-
-				if (enable_zvrf == zvrf)
-					static_enable_vrf(zvrf, stable,
-							  afi, safi);
-			}
-		}
-	}
-}
-
-/*
- * Look at the specified stable and if any of the routes in
- * this table are using the zvrf as the nexthop, uninstall
- * those routes.
- *
- * zvrf -> the vrf being disabled
- * stable -> the table we need to look at.
- * afi -> the afi in question
- * safi -> the safi in question
- */
-static void static_cleanup_vrf(struct zebra_vrf *zvrf,
-			       struct route_table *stable,
-			       afi_t afi, safi_t safi)
-{
-	struct route_node *rn;
-	struct static_route *si;
-
-	for (rn = route_top(stable); rn; rn = route_next(rn)) {
-		for (si = rn->info; si; si = si->next) {
-			if (strcmp(zvrf->vrf->name, si->nh_vrfname) != 0)
-				continue;
-
-			static_uninstall_route(afi, safi, &rn->p, NULL, si);
-		}
-	}
-}
-
-/*
- * Look at all static routes in this table and uninstall
- * them.
- *
- * stable -> The table to uninstall from
- * afi -> The afi in question
- * safi -> the safi in question
- */
-static void static_disable_vrf(struct route_table *stable,
-			       afi_t afi, safi_t safi)
-{
-	struct route_node *rn;
-	struct static_route *si;
-
-	for (rn = route_top(stable); rn; rn = route_next(rn)) {
-		for (si = rn->info; si; si = si->next) {
-			static_uninstall_route(afi, safi, &rn->p, NULL, si);
-		}
-	}
-}
-
-/*
- * When the disable_zvrf is shutdown by the kernel, we call
- * this function and it cleans up all static routes using
- * this vrf as a nexthop as well as all static routes
- * in it's stables.
- *
- * disable_zvrf - The vrf being disabled
- */
-void static_cleanup_vrf_ids(struct zebra_vrf *disable_zvrf)
-{
-	struct vrf *vrf;
-	afi_t afi;
-	safi_t safi;
-
-	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
-		struct zebra_vrf *zvrf;
-
-		zvrf = vrf->info;
-
-		/* Uninstall any static routes configured for this VRF. */
-		for (afi = AFI_IP; afi < AFI_MAX; afi++) {
-			for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
-				struct route_table *stable;
-
-				stable = zvrf->stable[afi][safi];
-				if (!stable)
-					continue;
-
-				static_cleanup_vrf(disable_zvrf, stable,
-						   afi, safi);
-
-				if (disable_zvrf == zvrf)
-					static_disable_vrf(stable, afi, safi);
-			}
-		}
-	}
-}
-
-/* called from if_{add,delete}_update, i.e. when ifindex becomes [in]valid */
-void static_ifindex_update(struct interface *ifp, bool up)
-{
-	static_ifindex_update_af(ifp, up, AFI_IP, SAFI_UNICAST);
-	static_ifindex_update_af(ifp, up, AFI_IP, SAFI_MULTICAST);
-	static_ifindex_update_af(ifp, up, AFI_IP6, SAFI_UNICAST);
-	static_ifindex_update_af(ifp, up, AFI_IP6, SAFI_MULTICAST);
-}
diff -urpN frr-frr-5.0.1/zebra/zebra_static.h frr-frr-6.0/zebra/zebra_static.h
--- frr-frr-5.0.1/zebra/zebra_static.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_static.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-/*
- * Static Routing Information header
- * Copyright (C) 2016 Cumulus Networks
- *               Donald Sharp
- *
- * This file is part of Quagga.
- *
- * Quagga is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * Quagga is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#ifndef __ZEBRA_STATIC_H__
-#define __ZEBRA_STATIC_H__
-
-#include "zebra/zebra_mpls.h"
-
-/* Static route label information */
-struct static_nh_label {
-	uint8_t num_labels;
-	uint8_t reserved[3];
-	mpls_label_t label[MPLS_MAX_LABELS];
-};
-
-enum static_blackhole_type {
-	STATIC_BLACKHOLE_DROP = 0,
-	STATIC_BLACKHOLE_NULL,
-	STATIC_BLACKHOLE_REJECT
-};
-
-typedef enum {
-	STATIC_IFNAME,
-	STATIC_IPV4_GATEWAY,
-	STATIC_IPV4_GATEWAY_IFNAME,
-	STATIC_BLACKHOLE,
-	STATIC_IPV6_GATEWAY,
-	STATIC_IPV6_GATEWAY_IFNAME,
-} zebra_static_types;
-
-/* Static route information. */
-struct static_route {
-	/* For linked list. */
-	struct static_route *prev;
-	struct static_route *next;
-
-	/* VRF identifier. */
-	vrf_id_t vrf_id;
-	vrf_id_t nh_vrf_id;
-	char nh_vrfname[VRF_NAMSIZ + 1];
-
-	/* Administrative distance. */
-	uint8_t distance;
-
-	/* Tag */
-	route_tag_t tag;
-
-	/* Flag for this static route's type. */
-	zebra_static_types type;
-
-	/*
-	 * Nexthop value.
-	 */
-	enum static_blackhole_type bh_type;
-	union g_addr addr;
-	ifindex_t ifindex;
-
-	char ifname[INTERFACE_NAMSIZ + 1];
-
-	/* Label information */
-	struct static_nh_label snh_label;
-};
-
-extern void static_install_route(afi_t afi, safi_t safi, struct prefix *p,
-				 struct prefix_ipv6 *src_p,
-				 struct static_route *si);
-extern void static_uninstall_route(afi_t afi, safi_t safi, struct prefix *p,
-				   struct prefix_ipv6 *src_p,
-				   struct static_route *si);
-
-extern int static_add_route(afi_t, safi_t safi, uint8_t type, struct prefix *p,
-			    struct prefix_ipv6 *src_p, union g_addr *gate,
-			    const char *ifname,
-			    enum static_blackhole_type bh_type, route_tag_t tag,
-			    uint8_t distance, struct zebra_vrf *zvrf,
-			    struct zebra_vrf *nh_zvrf,
-			    struct static_nh_label *snh_label);
-
-extern int static_delete_route(afi_t, safi_t safi, uint8_t type,
-			       struct prefix *p, struct prefix_ipv6 *src_p,
-			       union g_addr *gate, const char *ifname,
-			       route_tag_t tag, uint8_t distance,
-			       struct zebra_vrf *zvrf,
-			       struct static_nh_label *snh_label);
-
-extern void static_ifindex_update(struct interface *ifp, bool up);
-
-extern void static_cleanup_vrf_ids(struct zebra_vrf *zvrf);
-extern void static_fixup_vrf_ids(struct zebra_vrf *zvrf);
-#endif
diff -urpN frr-frr-5.0.1/zebra/zebra_vrf.c frr-frr-6.0/zebra/zebra_vrf.c
--- frr-frr-5.0.1/zebra/zebra_vrf.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vrf.c	2018-10-08 14:32:57.000000000 +0200
@@ -35,7 +35,6 @@
 #include "zebra/zebra_rnh.h"
 #include "zebra/router-id.h"
 #include "zebra/zebra_memory.h"
-#include "zebra/zebra_static.h"
 #include "zebra/interface.h"
 #include "zebra/zebra_mpls.h"
 #include "zebra/zebra_vxlan.h"
@@ -134,14 +133,6 @@ static int zebra_vrf_enable(struct vrf *
 		zvrf->import_check_table[afi] = table;
 	}
 
-	static_fixup_vrf_ids(zvrf);
-
-	/*
-	 * We may have static routes that are now possible to
-	 * insert into the appropriate tables
-	 */
-	static_config_install_delayed_routes(zvrf);
-
 	/* Kick off any VxLAN-EVPN processing. */
 	zebra_vxlan_vrf_enable(zvrf);
 
@@ -163,8 +154,6 @@ static int zebra_vrf_disable(struct vrf
 		zlog_debug("VRF %s id %u is now inactive", zvrf_name(zvrf),
 			   zvrf_id(zvrf));
 
-	static_cleanup_vrf_ids(zvrf);
-
 	/* Stop any VxLAN-EVPN processing. */
 	zebra_vxlan_vrf_disable(zvrf);
 
@@ -276,9 +265,6 @@ static int zebra_vrf_delete(struct vrf *
 				route_table_finish(table);
 				XFREE(MTYPE_RIB_TABLE_INFO, table_info);
 			}
-
-			table = zvrf->stable[afi][safi];
-			route_table_finish(table);
 		}
 
 		route_table_finish(zvrf->rnh_table[afi]);
@@ -302,24 +288,6 @@ static int zebra_vrf_delete(struct vrf *
  */
 int zebra_vrf_has_config(struct zebra_vrf *zvrf)
 {
-	afi_t afi;
-	safi_t safi;
-	struct route_table *stable;
-
-	/* NOTE: This is a don't care for the default VRF, but we go through
-	 * the motions to keep things consistent.
-	 */
-	/* Any static routes? */
-	for (afi = AFI_IP; afi < AFI_MAX; afi++) {
-		for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
-			stable = zvrf->stable[afi][safi];
-			if (!stable)
-				continue;
-			if (route_table_count(stable))
-				return 1;
-		}
-	}
-
 	/* EVPN L3-VNI? */
 	if (zvrf->l3vni)
 		return 1;
@@ -328,7 +296,9 @@ int zebra_vrf_has_config(struct zebra_vr
 }
 
 /* Lookup the routing table in a VRF based on both VRF-Id and table-id.
- * NOTE: Table-id is relevant only in the Default VRF.
+ * NOTE: Table-id is relevant on two modes:
+ * - case VRF backend is default : on default VRF only
+ * - case VRF backend is netns : on all VRFs
  */
 struct route_table *zebra_vrf_table_with_table_id(afi_t afi, safi_t safi,
 						  vrf_id_t vrf_id,
@@ -346,6 +316,13 @@ struct route_table *zebra_vrf_table_with
 		else
 			table = zebra_vrf_other_route_table(afi, table_id,
 							    vrf_id);
+	} else if (vrf_is_backend_netns()) {
+		if (table_id == RT_TABLE_MAIN
+		    || table_id == zebrad.rtm_table_default)
+			table = zebra_vrf_table(afi, safi, vrf_id);
+		else
+			table = zebra_vrf_other_route_table(afi, table_id,
+							    vrf_id);
 	} else
 		table = zebra_vrf_table(afi, safi, vrf_id);
 
@@ -365,18 +342,6 @@ void zebra_rtable_node_cleanup(struct ro
 		XFREE(MTYPE_RIB_DEST, node->info);
 }
 
-static void zebra_stable_node_cleanup(struct route_table *table,
-				      struct route_node *node)
-{
-	struct static_route *si, *next;
-
-	if (node->info)
-		for (si = node->info; si; si = next) {
-			next = si->next;
-			XFREE(MTYPE_STATIC_ROUTE, si);
-		}
-}
-
 static void zebra_rnhtable_node_cleanup(struct route_table *table,
 					struct route_node *node)
 {
@@ -413,28 +378,14 @@ static void zebra_vrf_table_create(struc
 struct zebra_vrf *zebra_vrf_alloc(void)
 {
 	struct zebra_vrf *zvrf;
-	afi_t afi;
-	safi_t safi;
-	struct route_table *table;
 
 	zvrf = XCALLOC(MTYPE_ZEBRA_VRF, sizeof(struct zebra_vrf));
 
-	/* Allocate table for static route configuration. */
-	for (afi = AFI_IP; afi <= AFI_IP6; afi++) {
-		for (safi = SAFI_UNICAST; safi <= SAFI_MULTICAST; safi++) {
-			if (afi == AFI_IP6)
-				table = srcdest_table_init();
-			else
-				table = route_table_init();
-			table->cleanup = zebra_stable_node_cleanup;
-			zvrf->stable[afi][safi] = table;
-		}
-	}
-
 	zebra_vxlan_init_tables(zvrf);
 	zebra_mpls_init_tables(zvrf);
 	zebra_pw_init(zvrf);
-
+	zvrf->table_id = RT_TABLE_MAIN;
+	/* by default table ID is default one */
 	return zvrf;
 }
 
@@ -473,19 +424,6 @@ struct route_table *zebra_vrf_table(afi_
 	return zvrf->table[afi][safi];
 }
 
-/* Lookup the static routing table in a VRF. */
-struct route_table *zebra_vrf_static_table(afi_t afi, safi_t safi,
-					   struct zebra_vrf *zvrf)
-{
-	if (!zvrf)
-		return NULL;
-
-	if (afi >= AFI_MAX || safi >= SAFI_MAX)
-		return NULL;
-
-	return zvrf->stable[afi][safi];
-}
-
 struct route_table *zebra_vrf_other_route_table(afi_t afi, uint32_t table_id,
 						vrf_id_t vrf_id)
 {
@@ -501,9 +439,16 @@ struct route_table *zebra_vrf_other_rout
 	if (afi >= AFI_MAX)
 		return NULL;
 
-	if ((vrf_id == VRF_DEFAULT) && (table_id != RT_TABLE_MAIN)
+	if ((table_id != RT_TABLE_MAIN)
 	    && (table_id != zebrad.rtm_table_default)) {
-		return zebra_ns_get_table(zns, zvrf, table_id, afi);
+		if (zvrf->table_id == RT_TABLE_MAIN ||
+		    zvrf->table_id == zebrad.rtm_table_default) {
+			/* this VRF use default table
+			 * so in all cases, it does not use specific table
+			 * so it is possible to configure tables in this VRF
+			 */
+			return zebra_ns_get_table(zns, zvrf, table_id, afi);
+		}
 	}
 
 	return zvrf->table[afi][SAFI_UNICAST];
@@ -536,10 +481,6 @@ static int vrf_config_write(struct vty *
 
 		}
 
-		static_config(vty, zvrf, AFI_IP, SAFI_UNICAST, "ip route");
-		static_config(vty, zvrf, AFI_IP, SAFI_MULTICAST, "ip mroute");
-		static_config(vty, zvrf, AFI_IP6, SAFI_UNICAST, "ipv6 route");
-
 		if (zvrf_id(zvrf) != VRF_DEFAULT)
 			vty_endframe(vty, " exit-vrf\n!\n");
 	}
diff -urpN frr-frr-5.0.1/zebra/zebra_vrf.h frr-frr-6.0/zebra/zebra_vrf.h
--- frr-frr-5.0.1/zebra/zebra_vrf.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vrf.h	2018-10-08 14:32:57.000000000 +0200
@@ -53,9 +53,6 @@ struct zebra_vrf {
 	/* Routing table.  */
 	struct route_table *table[AFI_MAX][SAFI_MAX];
 
-	/* Static route configuration.  */
-	struct route_table *stable[AFI_MAX][SAFI_MAX];
-
 	/* Recursive Nexthop table */
 	struct route_table *rnh_table[AFI_MAX];
 
@@ -159,8 +156,7 @@ extern struct zebra_vrf *zebra_vrf_looku
 extern struct zebra_vrf *zebra_vrf_lookup_by_name(const char *);
 extern struct zebra_vrf *zebra_vrf_alloc(void);
 extern struct route_table *zebra_vrf_table(afi_t, safi_t, vrf_id_t);
-extern struct route_table *zebra_vrf_static_table(afi_t, safi_t,
-						  struct zebra_vrf *zvrf);
+
 extern struct route_table *
 zebra_vrf_other_route_table(afi_t afi, uint32_t table_id, vrf_id_t vrf_id);
 extern int zebra_vrf_has_config(struct zebra_vrf *zvrf);
diff -urpN frr-frr-5.0.1/zebra/zebra_vty.c frr-frr-6.0/zebra/zebra_vty.c
--- frr-frr-5.0.1/zebra/zebra_vty.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vty.c	2018-10-08 14:32:57.000000000 +0200
@@ -41,7 +41,6 @@
 #include "zebra/zebra_rnh.h"
 #include "zebra/redistribute.h"
 #include "zebra/zebra_routemap.h"
-#include "zebra/zebra_static.h"
 #include "lib/json.h"
 #include "zebra/zebra_vxlan.h"
 #ifndef VTYSH_EXTRACT_PL
@@ -78,537 +77,6 @@ static void vty_show_ip_route_summary_pr
 /* VNI range as per RFC 7432 */
 #define CMD_VNI_RANGE "(1-16777215)"
 
-struct static_hold_route {
-	char *vrf_name;
-	char *nhvrf_name;
-	afi_t afi;
-	safi_t safi;
-	char *dest_str;
-	char *mask_str;
-	char *src_str;
-	char *gate_str;
-	char *ifname;
-	char *flag_str;
-	char *tag_str;
-	char *distance_str;
-	char *label_str;
-
-	/* processed & masked destination, used for config display */
-	struct prefix dest;
-};
-
-static struct list *static_list;
-
-static int static_list_compare_helper(const char *s1, const char *s2)
-{
-	/* Are Both NULL */
-	if (s1 == s2)
-		return 0;
-
-	if (!s1 && s2)
-		return -1;
-
-	if (s1 && !s2)
-		return 1;
-
-	return strcmp(s1, s2);
-}
-
-static void static_list_delete(struct static_hold_route *shr)
-{
-	if (shr->vrf_name)
-		XFREE(MTYPE_STATIC_ROUTE, shr->vrf_name);
-	if (shr->nhvrf_name)
-		XFREE(MTYPE_STATIC_ROUTE, shr->nhvrf_name);
-	if (shr->dest_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->dest_str);
-	if (shr->mask_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->mask_str);
-	if (shr->src_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->src_str);
-	if (shr->gate_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->gate_str);
-	if (shr->ifname)
-		XFREE(MTYPE_STATIC_ROUTE, shr->ifname);
-	if (shr->flag_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->flag_str);
-	if (shr->tag_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->tag_str);
-	if (shr->distance_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->distance_str);
-	if (shr->label_str)
-		XFREE(MTYPE_STATIC_ROUTE, shr->label_str);
-
-	XFREE(MTYPE_STATIC_ROUTE, shr);
-}
-
-static int static_list_compare(void *arg1, void *arg2)
-{
-	struct static_hold_route *shr1 = arg1;
-	struct static_hold_route *shr2 = arg2;
-	int ret;
-
-	ret = strcmp(shr1->vrf_name, shr2->vrf_name);
-	if (ret)
-		return ret;
-
-	ret = strcmp(shr1->nhvrf_name, shr2->nhvrf_name);
-	if (ret)
-		return ret;
-
-	ret = shr1->afi - shr2->afi;
-	if (ret)
-		return ret;
-
-	ret = shr1->safi - shr2->safi;
-	if (ret)
-		return ret;
-
-	ret = prefix_cmp(&shr1->dest, &shr2->dest);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->src_str, shr2->src_str);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->gate_str, shr2->gate_str);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->ifname, shr2->ifname);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->flag_str, shr2->flag_str);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->tag_str, shr2->tag_str);
-	if (ret)
-		return ret;
-
-	ret = static_list_compare_helper(shr1->distance_str,
-					 shr2->distance_str);
-	if (ret)
-		return ret;
-
-	return static_list_compare_helper(shr1->label_str, shr2->label_str);
-}
-
-
-/* General function for static route. */
-static int zebra_static_route_holdem(
-	struct zebra_vrf *zvrf, struct zebra_vrf *nh_zvrf, afi_t afi,
-	safi_t safi, const char *negate, struct prefix *dest,
-	const char *dest_str, const char *mask_str, const char *src_str,
-	const char *gate_str, const char *ifname, const char *flag_str,
-	const char *tag_str, const char *distance_str, const char *label_str)
-{
-	struct static_hold_route *shr, *lookup;
-	struct listnode *node;
-
-	zlog_warn("Static Route to %s not installed currently because dependent config not fully available",
-		  dest_str);
-
-	shr = XCALLOC(MTYPE_STATIC_ROUTE, sizeof(*shr));
-	shr->vrf_name = XSTRDUP(MTYPE_STATIC_ROUTE, zvrf->vrf->name);
-	shr->nhvrf_name = XSTRDUP(MTYPE_STATIC_ROUTE, nh_zvrf->vrf->name);
-	shr->afi = afi;
-	shr->safi = safi;
-	if (dest)
-		prefix_copy(&shr->dest, dest);
-	if (dest_str)
-		shr->dest_str = XSTRDUP(MTYPE_STATIC_ROUTE, dest_str);
-	if (mask_str)
-		shr->mask_str = XSTRDUP(MTYPE_STATIC_ROUTE, mask_str);
-	if (src_str)
-		shr->src_str = XSTRDUP(MTYPE_STATIC_ROUTE, src_str);
-	if (gate_str)
-		shr->gate_str = XSTRDUP(MTYPE_STATIC_ROUTE, gate_str);
-	if (ifname)
-		shr->ifname = XSTRDUP(MTYPE_STATIC_ROUTE, ifname);
-	if (flag_str)
-		shr->flag_str = XSTRDUP(MTYPE_STATIC_ROUTE, flag_str);
-	if (tag_str)
-		shr->tag_str = XSTRDUP(MTYPE_STATIC_ROUTE, tag_str);
-	if (distance_str)
-		shr->distance_str = XSTRDUP(MTYPE_STATIC_ROUTE, distance_str);
-	if (label_str)
-		shr->label_str = XSTRDUP(MTYPE_STATIC_ROUTE, label_str);
-
-	for (ALL_LIST_ELEMENTS_RO(static_list, node, lookup)) {
-		if (static_list_compare(shr, lookup) == 0)
-			break;
-	}
-
-	if (lookup) {
-		if (negate) {
-			listnode_delete(static_list, lookup);
-			static_list_delete(shr);
-			static_list_delete(lookup);
-
-			return CMD_SUCCESS;
-		}
-
-		XFREE(MTYPE_STATIC_ROUTE, shr->nhvrf_name);
-		XFREE(MTYPE_STATIC_ROUTE, shr->vrf_name);
-		XFREE(MTYPE_STATIC_ROUTE, shr);
-		/*
-		 * If a person enters the same line again
-		 * we need to silently accept it
-		 */
-		return CMD_SUCCESS;
-	}
-
-	if (!negate)
-		listnode_add_sort(static_list, shr);
-
-	return CMD_SUCCESS;
-}
-
-static int zebra_static_route_leak(
-	struct vty *vty, struct zebra_vrf *zvrf, struct zebra_vrf *nh_zvrf,
-	afi_t afi, safi_t safi, const char *negate, const char *dest_str,
-	const char *mask_str, const char *src_str, const char *gate_str,
-	const char *ifname, const char *flag_str, const char *tag_str,
-	const char *distance_str, const char *label_str)
-{
-	int ret;
-	uint8_t distance;
-	struct prefix p, src;
-	struct prefix_ipv6 *src_p = NULL;
-	union g_addr gate;
-	union g_addr *gatep = NULL;
-	struct in_addr mask;
-	enum static_blackhole_type bh_type = 0;
-	route_tag_t tag = 0;
-	uint8_t type;
-	struct static_nh_label snh_label;
-
-	ret = str2prefix(dest_str, &p);
-	if (ret <= 0) {
-		if (vty)
-			vty_out(vty, "%% Malformed address\n");
-		else
-			zlog_warn("%s: Malformed address: %s",
-				  __PRETTY_FUNCTION__, dest_str);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	switch (afi) {
-	case AFI_IP:
-		/* Cisco like mask notation. */
-		if (mask_str) {
-			ret = inet_aton(mask_str, &mask);
-			if (ret == 0) {
-				if (vty)
-					vty_out(vty, "%% Malformed address\n");
-				else
-					zlog_warn("%s: Malformed address: %s",
-						  __PRETTY_FUNCTION__,
-						  mask_str);
-				return CMD_WARNING_CONFIG_FAILED;
-			}
-			p.prefixlen = ip_masklen(mask);
-		}
-		break;
-	case AFI_IP6:
-		/* srcdest routing */
-		if (src_str) {
-			ret = str2prefix(src_str, &src);
-			if (ret <= 0 || src.family != AF_INET6) {
-				if (vty)
-					vty_out(vty,
-						"%% Malformed source address\n");
-				else
-					zlog_warn(
-						"%s: Malformed Source address: %s",
-						__PRETTY_FUNCTION__, src_str);
-				return CMD_WARNING_CONFIG_FAILED;
-			}
-			src_p = (struct prefix_ipv6 *)&src;
-		}
-		break;
-	default:
-		break;
-	}
-
-	/* Apply mask for given prefix. */
-	apply_mask(&p);
-
-	if (zvrf->vrf->vrf_id == VRF_UNKNOWN
-	    || nh_zvrf->vrf->vrf_id == VRF_UNKNOWN) {
-		vrf_set_user_cfged(zvrf->vrf);
-		return zebra_static_route_holdem(
-			zvrf, nh_zvrf, afi, safi, negate, &p, dest_str,
-			mask_str, src_str, gate_str, ifname, flag_str, tag_str,
-			distance_str, label_str);
-	}
-
-	/* Administrative distance. */
-	if (distance_str)
-		distance = atoi(distance_str);
-	else
-		distance = ZEBRA_STATIC_DISTANCE_DEFAULT;
-
-	/* tag */
-	if (tag_str)
-		tag = strtoul(tag_str, NULL, 10);
-
-	/* Labels */
-	memset(&snh_label, 0, sizeof(struct static_nh_label));
-	if (label_str) {
-		if (!mpls_enabled) {
-			if (vty)
-				vty_out(vty,
-					"%% MPLS not turned on in kernel, ignoring command\n");
-			else
-				zlog_warn(
-					"%s: MPLS not turned on in kernel ignoring static route to %s",
-					__PRETTY_FUNCTION__, dest_str);
-			return CMD_WARNING_CONFIG_FAILED;
-		}
-		int rc = mpls_str2label(label_str, &snh_label.num_labels,
-					snh_label.label);
-		if (rc < 0) {
-			switch (rc) {
-			case -1:
-				if (vty)
-					vty_out(vty, "%% Malformed label(s)\n");
-				else
-					zlog_warn(
-						"%s: Malformed labels specified for route %s",
-						__PRETTY_FUNCTION__, dest_str);
-				break;
-			case -2:
-				if (vty)
-					vty_out(vty,
-						"%% Cannot use reserved label(s) (%d-%d)\n",
-						MPLS_LABEL_RESERVED_MIN,
-						MPLS_LABEL_RESERVED_MAX);
-				else
-					zlog_warn(
-						"%s: Cannot use reserved labels (%d-%d) for %s",
-						__PRETTY_FUNCTION__,
-						MPLS_LABEL_RESERVED_MIN,
-						MPLS_LABEL_RESERVED_MAX,
-						dest_str);
-				break;
-			case -3:
-				if (vty)
-					vty_out(vty,
-						"%% Too many labels. Enter %d or fewer\n",
-						MPLS_MAX_LABELS);
-				else
-					zlog_warn(
-						"%s: Too many labels, Enter %d or fewer for %s",
-						__PRETTY_FUNCTION__,
-						MPLS_MAX_LABELS, dest_str);
-				break;
-			}
-			return CMD_WARNING_CONFIG_FAILED;
-		}
-	}
-
-	/* Null0 static route.  */
-	if (ifname != NULL) {
-		if (strncasecmp(ifname, "Null0", strlen(ifname)) == 0
-		    || strncasecmp(ifname, "reject", strlen(ifname)) == 0
-		    || strncasecmp(ifname, "blackhole", strlen(ifname)) == 0) {
-			if (vty)
-				vty_out(vty,
-					"%% Nexthop interface cannot be Null0, reject or blackhole\n");
-			else
-				zlog_warn(
-					"%s: Nexthop interface cannot be Null0, reject or blackhole for %s",
-					__PRETTY_FUNCTION__, dest_str);
-			return CMD_WARNING_CONFIG_FAILED;
-		}
-	}
-
-	/* Route flags */
-	if (flag_str) {
-		switch (flag_str[0]) {
-		case 'r':
-			bh_type = STATIC_BLACKHOLE_REJECT;
-			break;
-		case 'b':
-			bh_type = STATIC_BLACKHOLE_DROP;
-			break;
-		case 'N':
-			bh_type = STATIC_BLACKHOLE_NULL;
-			break;
-		default:
-			if (vty)
-				vty_out(vty, "%% Malformed flag %s \n",
-					flag_str);
-			else
-				zlog_warn("%s: Malformed flag %s for %s",
-					  __PRETTY_FUNCTION__, flag_str,
-					  dest_str);
-			return CMD_WARNING_CONFIG_FAILED;
-		}
-	}
-
-	if (gate_str) {
-		if (inet_pton(afi2family(afi), gate_str, &gate) != 1) {
-			if (vty)
-				vty_out(vty,
-					"%% Malformed nexthop address %s\n",
-					gate_str);
-			else
-				zlog_warn(
-					"%s: Malformed nexthop address %s for %s",
-					__PRETTY_FUNCTION__, gate_str,
-					dest_str);
-			return CMD_WARNING_CONFIG_FAILED;
-		}
-		gatep = &gate;
-	}
-
-	if (gate_str == NULL && ifname == NULL)
-		type = STATIC_BLACKHOLE;
-	else if (gate_str && ifname) {
-		if (afi == AFI_IP)
-			type = STATIC_IPV4_GATEWAY_IFNAME;
-		else
-			type = STATIC_IPV6_GATEWAY_IFNAME;
-	} else if (ifname)
-		type = STATIC_IFNAME;
-	else {
-		if (afi == AFI_IP)
-			type = STATIC_IPV4_GATEWAY;
-		else
-			type = STATIC_IPV6_GATEWAY;
-	}
-
-	if (!negate) {
-		static_add_route(afi, safi, type, &p, src_p, gatep, ifname,
-				 bh_type, tag, distance, zvrf, nh_zvrf,
-				 &snh_label);
-		/* Mark as having FRR configuration */
-		vrf_set_user_cfged(zvrf->vrf);
-	} else {
-		static_delete_route(afi, safi, type, &p, src_p, gatep, ifname,
-				    tag, distance, zvrf, &snh_label);
-		/* If no other FRR config for this VRF, mark accordingly. */
-		if (!zebra_vrf_has_config(zvrf))
-			vrf_reset_user_cfged(zvrf->vrf);
-	}
-
-	return CMD_SUCCESS;
-}
-
-static struct zebra_vrf *zebra_vty_get_unknown_vrf(struct vty *vty,
-						   const char *vrf_name)
-{
-	struct zebra_vrf *zvrf;
-	struct vrf *vrf;
-
-	zvrf = zebra_vrf_lookup_by_name(vrf_name);
-
-	if (zvrf)
-		return zvrf;
-
-	vrf = vrf_get(VRF_UNKNOWN, vrf_name);
-	if (!vrf) {
-		vty_out(vty, "%% Could not create vrf %s\n", vrf_name);
-		return NULL;
-	}
-	zvrf = vrf->info;
-	if (!zvrf) {
-		vty_out(vty, "%% Could not create vrf-info %s\n",
-			vrf_name);
-		return NULL;
-	}
-	/* Mark as having FRR configuration */
-	vrf_set_user_cfged(vrf);
-
-	return zvrf;
-}
-
-static int zebra_static_route(struct vty *vty, afi_t afi, safi_t safi,
-			      const char *negate, const char *dest_str,
-			      const char *mask_str, const char *src_str,
-			      const char *gate_str, const char *ifname,
-			      const char *flag_str, const char *tag_str,
-			      const char *distance_str, const char *vrf_name,
-			      const char *label_str)
-{
-	struct zebra_vrf *zvrf;
-
-	/* VRF id */
-	zvrf = zebra_vrf_lookup_by_name(vrf_name);
-
-	/* When trying to delete, the VRF must exist. */
-	if (negate && !zvrf) {
-		vty_out(vty, "%% vrf %s is not defined\n", vrf_name);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	/* When trying to create, create the VRF if it doesn't exist.
-	 * Note: The VRF isn't active until we hear about it from the kernel.
-	 */
-	if (!zvrf) {
-		zvrf = zebra_vty_get_unknown_vrf(vty, vrf_name);
-		if (!zvrf)
-			return CMD_WARNING_CONFIG_FAILED;
-	}
-	return zebra_static_route_leak(
-		vty, zvrf, zvrf, afi, safi, negate, dest_str, mask_str, src_str,
-		gate_str, ifname, flag_str, tag_str, distance_str, label_str);
-}
-
-void static_config_install_delayed_routes(struct zebra_vrf *zvrf)
-{
-	struct listnode *node, *nnode;
-	struct static_hold_route *shr;
-	struct zebra_vrf *ozvrf, *nh_zvrf;
-	int installed;
-
-	for (ALL_LIST_ELEMENTS(static_list, node, nnode, shr)) {
-		ozvrf = zebra_vrf_lookup_by_name(shr->vrf_name);
-		nh_zvrf = zebra_vrf_lookup_by_name(shr->nhvrf_name);
-
-		if (ozvrf != zvrf && nh_zvrf != zvrf)
-			continue;
-
-		if (ozvrf->vrf->vrf_id == VRF_UNKNOWN
-		    || nh_zvrf->vrf->vrf_id == VRF_UNKNOWN)
-			continue;
-
-		installed = zebra_static_route_leak(
-			NULL, ozvrf, nh_zvrf, shr->afi, shr->safi, NULL,
-			shr->dest_str, shr->mask_str, shr->src_str,
-			shr->gate_str, shr->ifname, shr->flag_str, shr->tag_str,
-			shr->distance_str, shr->label_str);
-
-		if (installed != CMD_SUCCESS)
-			zlog_debug(
-				"%s: Attempt to install %s as a route and it was rejected",
-				__PRETTY_FUNCTION__, shr->dest_str);
-		listnode_delete(static_list, shr);
-		static_list_delete(shr);
-	}
-}
-/* Static unicast routes for multicast RPF lookup. */
-DEFPY (ip_mroute_dist,
-       ip_mroute_dist_cmd,
-       "[no] ip mroute A.B.C.D/M$prefix <A.B.C.D$gate|INTERFACE$ifname> [(1-255)$distance]",
-       NO_STR
-       IP_STR
-       "Configure static unicast route into MRIB for multicast RPF lookup\n"
-       "IP destination prefix (e.g. 10.0.0.0/8)\n"
-       "Nexthop address\n"
-       "Nexthop interface name\n"
-       "Distance\n")
-{
-	return zebra_static_route(vty, AFI_IP, SAFI_MULTICAST, no, prefix_str,
-				  NULL, NULL, gate_str, ifname, NULL, NULL,
-				  distance_str, NULL, NULL);
-}
-
 DEFUN (ip_multicast_mode,
        ip_multicast_mode_cmd,
        "ip multicast rpf-lookup-mode <urib-only|mrib-only|mrib-then-urib|lower-distance|longer-prefix>",
@@ -702,287 +170,6 @@ DEFUN (show_ip_rpf_addr,
 	return CMD_SUCCESS;
 }
 
-/* Static route configuration.  */
-DEFPY(ip_route_blackhole,
-      ip_route_blackhole_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask>                        \
-	<reject|blackhole>$flag                                               \
-	[{                                                                    \
-	  tag (1-4294967295)                                                  \
-	  |(1-255)$distance                                                   \
-	  |vrf NAME                                                           \
-	  |label WORD                                                         \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "Emit an ICMP unreachable when matched\n"
-      "Silently discard pkts when matched\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR)
-{
-	return zebra_static_route(vty, AFI_IP, SAFI_UNICAST, no, prefix,
-				  mask_str, NULL, NULL, NULL, flag, tag_str,
-				  distance_str, vrf, label);
-}
-
-DEFPY(ip_route_blackhole_vrf,
-      ip_route_blackhole_vrf_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask>                        \
-	<reject|blackhole>$flag                                               \
-	[{                                                                    \
-	  tag (1-4294967295)                                                  \
-	  |(1-255)$distance                                                   \
-	  |label WORD                                                         \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "Emit an ICMP unreachable when matched\n"
-      "Silently discard pkts when matched\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      MPLS_LABEL_HELPSTR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	struct zebra_vrf *zvrf = vrf->info;
-
-	/*
-	 * Coverity is complaining that prefix could
-	 * be dereferenced, but we know that prefix will
-	 * valid.  Add an assert to make it happy
-	 */
-	assert(prefix);
-	return zebra_static_route_leak(vty, zvrf, zvrf, AFI_IP, SAFI_UNICAST,
-				       no, prefix, mask_str, NULL, NULL, NULL,
-				       flag, tag_str, distance_str, label);
-}
-
-DEFPY(ip_route_address_interface,
-      ip_route_address_interface_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
-	A.B.C.D$gate                                   \
-	INTERFACE$ifname                               \
-	[{                                             \
-	  tag (1-4294967295)                           \
-	  |(1-255)$distance                            \
-	  |vrf NAME                                    \
-	  |label WORD                                  \
-	  |nexthop-vrf NAME                            \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "IP gateway address\n"
-      "IP gateway interface name. Specify 'Null0' (case-insensitive) for a \
-      null route.\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	struct zebra_vrf *zvrf;
-	struct zebra_vrf *nh_zvrf;
-
-	const char *flag = NULL;
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-
-	zvrf = zebra_vty_get_unknown_vrf(vty, vrf);
-	if (!zvrf) {
-		vty_out(vty, "%% vrf %s is not defined\n", vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
-		NULL, gate_str, ifname, flag, tag_str, distance_str, label);
-}
-
-DEFPY(ip_route_address_interface_vrf,
-      ip_route_address_interface_vrf_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
-	A.B.C.D$gate                                   \
-	INTERFACE$ifname                               \
-	[{                                             \
-	  tag (1-4294967295)                           \
-	  |(1-255)$distance                            \
-	  |label WORD                                  \
-	  |nexthop-vrf NAME                            \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "IP gateway address\n"
-      "IP gateway interface name. Specify 'Null0' (case-insensitive) for a \
-      null route.\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	const char *flag = NULL;
-	struct zebra_vrf *zvrf = vrf->info;
-	struct zebra_vrf *nh_zvrf;
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
-		NULL, gate_str, ifname, flag, tag_str, distance_str, label);
-}
-
-DEFPY(ip_route,
-      ip_route_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
-	<A.B.C.D$gate|INTERFACE$ifname>                \
-	[{                                             \
-	  tag (1-4294967295)                           \
-	  |(1-255)$distance                            \
-	  |vrf NAME                                    \
-	  |label WORD                                  \
-	  |nexthop-vrf NAME                            \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "IP gateway address\n"
-      "IP gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	struct zebra_vrf *zvrf;
-	struct zebra_vrf *nh_zvrf;
-	const char *flag = NULL;
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-
-	zvrf = zebra_vty_get_unknown_vrf(vty, vrf);
-	if (!zvrf) {
-		vty_out(vty, "%% vrf %s is not defined\n", vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
-		NULL, gate_str, ifname, flag, tag_str, distance_str, label);
-}
-
-DEFPY(ip_route_vrf,
-      ip_route_vrf_cmd,
-      "[no] ip route\
-	<A.B.C.D/M$prefix|A.B.C.D$prefix A.B.C.D$mask> \
-	<A.B.C.D$gate|INTERFACE$ifname>                \
-	[{                                             \
-	  tag (1-4294967295)                           \
-	  |(1-255)$distance                            \
-	  |label WORD                                  \
-	  |nexthop-vrf NAME                            \
-          }]",
-      NO_STR IP_STR
-      "Establish static routes\n"
-      "IP destination prefix (e.g. 10.0.0.0/8)\n"
-      "IP destination prefix\n"
-      "IP destination prefix mask\n"
-      "IP gateway address\n"
-      "IP gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this route\n"
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	struct zebra_vrf *zvrf = vrf->info;
-	struct zebra_vrf *nh_zvrf;
-
-	const char *flag = NULL;
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP, SAFI_UNICAST, no, prefix, mask_str,
-		NULL, gate_str, ifname, flag, tag_str, distance_str, label);
-}
-
 /* New RIB.  Detailed information for IPv4 route. */
 static void vty_show_ip_route_detail(struct vty *vty, struct route_node *rn,
 				     int mcast)
@@ -1107,7 +294,8 @@ static void vty_show_ip_route_detail(str
 				break;
 			}
 
-			if (re->vrf_id != nexthop->vrf_id) {
+			if ((re->vrf_id != nexthop->vrf_id)
+			     && (nexthop->type != NEXTHOP_TYPE_BLACKHOLE)) {
 				struct vrf *vrf =
 					vrf_lookup_by_id(nexthop->vrf_id);
 
@@ -1216,6 +404,13 @@ static void vty_show_ip_route(struct vty
 			json_object_int_add(json_route, "metric", re->metric);
 		}
 
+		if (re->tag)
+			json_object_int_add(json_route, "tag", re->tag);
+
+		json_object_int_add(json_route, "internalStatus",
+				    re->status);
+		json_object_int_add(json_route, "internalFlags",
+				    re->flags);
 		if (uptime < ONE_DAY_SECOND)
 			sprintf(buf, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min,
 				tm->tm_sec);
@@ -1232,6 +427,9 @@ static void vty_show_ip_route(struct vty
 		for (ALL_NEXTHOPS(re->ng, nexthop)) {
 			json_nexthop = json_object_new_object();
 
+			json_object_int_add(json_nexthop, "flags",
+					    nexthop->flags);
+
 			if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_DUPLICATE))
 				json_object_boolean_true_add(json_nexthop,
 							     "duplicate");
@@ -1317,7 +515,8 @@ static void vty_show_ip_route(struct vty
 				break;
 			}
 
-			if (nexthop->vrf_id != re->vrf_id) {
+			if ((nexthop->vrf_id != re->vrf_id)
+			     && (nexthop->type != NEXTHOP_TYPE_BLACKHOLE)) {
 				struct vrf *vrf =
 					vrf_lookup_by_id(nexthop->vrf_id);
 
@@ -1471,7 +670,8 @@ static void vty_show_ip_route(struct vty
 			break;
 		}
 
-		if (nexthop->vrf_id != re->vrf_id) {
+		if ((nexthop->vrf_id != re->vrf_id)
+		     && (nexthop->type != NEXTHOP_TYPE_BLACKHOLE)) {
 			struct vrf *vrf = vrf_lookup_by_id(nexthop->vrf_id);
 
 			if (vrf)
@@ -1532,6 +732,29 @@ static void vty_show_ip_route(struct vty
 	}
 }
 
+static void vty_show_ip_route_detail_json(struct vty *vty,
+					struct route_node *rn)
+{
+	json_object *json = NULL;
+	json_object *json_prefix = NULL;
+	struct route_entry *re;
+	char buf[BUFSIZ];
+
+	json = json_object_new_object();
+
+	RNODE_FOREACH_RE (rn, re) {
+		json_prefix = json_object_new_array();
+		vty_show_ip_route(vty, rn, re, json_prefix);
+		prefix2str(&rn->p, buf, sizeof buf);
+		json_object_object_add(json, buf, json_prefix);
+		json_prefix = NULL;
+	}
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(
+					     json, JSON_C_TO_STRING_PRETTY));
+	json_object_free(json);
+}
+
 static void do_show_route_helper(struct vty *vty, struct zebra_vrf *zvrf,
 				 struct route_table *table, afi_t afi,
 				 bool use_fib, route_tag_t tag,
@@ -1553,7 +776,7 @@ static void do_show_route_helper(struct
 		json = json_object_new_object();
 
 	/* Show all routes. */
-	for (rn = route_top(table); rn; rn = route_next(rn)) {
+	for (rn = route_top(table); rn; rn = srcdest_route_next(rn)) {
 		dest = rib_dest_from_rnode(rn);
 
 		RNODE_FOREACH_RE (rn, re) {
@@ -1613,15 +836,15 @@ static void do_show_route_helper(struct
 		}
 
 		if (json_prefix) {
-			prefix2str(&rn->p, buf, sizeof buf);
+			prefix2str(&rn->p, buf, sizeof(buf));
 			json_object_object_add(json, buf, json_prefix);
 			json_prefix = NULL;
 		}
 	}
 
 	if (use_json) {
-		vty_out(vty, "%s\n", json_object_to_json_string_ext(
-					     json, JSON_C_TO_STRING_PRETTY));
+		vty_out(vty, "%s\n", json_object_to_json_string_ext(json,
+						JSON_C_TO_STRING_PRETTY));
 		json_object_free(json);
 	}
 }
@@ -1689,6 +912,35 @@ DEFPY (show_route_table,
 	return CMD_SUCCESS;
 }
 
+DEFPY (show_route_table_vrf,
+       show_route_table_vrf_cmd,
+       "show <ip$ipv4|ipv6$ipv6> route table (1-4294967295)$table vrf NAME$vrf_name [json$json]",
+       SHOW_STR
+       IP_STR
+       IP6_STR
+       "IP routing table\n"
+       "Table to display\n"
+       "The table number to display, if available\n"
+       VRF_CMD_HELP_STR
+       JSON_STR)
+{
+	afi_t afi = ipv4 ? AFI_IP : AFI_IP6;
+	struct zebra_vrf *zvrf;
+	struct route_table *t;
+	vrf_id_t vrf_id = VRF_DEFAULT;
+
+	if (vrf_name)
+		VRF_GET_ID(vrf_id, vrf_name, !!json);
+	zvrf = zebra_vrf_lookup_by_id(vrf_id);
+
+	t = zebra_ns_find_table(zvrf->zns, table, afi);
+	if (t)
+		do_show_route_helper(vty, zvrf, t, afi, false, 0, false, false,
+				     0, 0, !!json);
+
+	return CMD_SUCCESS;
+}
+
 DEFUN (show_ip_nht,
        show_ip_nht_cmd,
        "show ip nht [vrf NAME]",
@@ -1701,7 +953,7 @@ DEFUN (show_ip_nht,
 	vrf_id_t vrf_id = VRF_DEFAULT;
 
 	if (argc == 5)
-		VRF_GET_ID(vrf_id, argv[idx_vrf]->arg);
+		VRF_GET_ID(vrf_id, argv[idx_vrf]->arg, false);
 
 	zebra_print_rnh_table(vrf_id, AF_INET, vty, RNH_NEXTHOP_TYPE);
 	return CMD_SUCCESS;
@@ -1741,7 +993,7 @@ DEFUN (show_ipv6_nht,
 	vrf_id_t vrf_id = VRF_DEFAULT;
 
 	if (argc == 5)
-		VRF_GET_ID(vrf_id, argv[idx_vrf]->arg);
+		VRF_GET_ID(vrf_id, argv[idx_vrf]->arg, false);
 
 	zebra_print_rnh_table(vrf_id, AF_INET6, vty, RNH_NEXTHOP_TYPE);
 	return CMD_SUCCESS;
@@ -1907,7 +1159,7 @@ DEFPY (show_route,
 		vrf_id_t vrf_id = VRF_DEFAULT;
 
 		if (vrf_name)
-			VRF_GET_ID(vrf_id, vrf_name);
+			VRF_GET_ID(vrf_id, vrf_name, !!json);
 		vrf = vrf_lookup_by_id(vrf_id);
 		do_show_ip_route(vty, vrf->name, afi, SAFI_UNICAST, !!fib,
 				 !!json, tag, prefix_str ? prefix : NULL,
@@ -1931,7 +1183,8 @@ DEFPY (show_route_detail,
 	   X:X::X:X$address\
 	   |X:X::X:X/M$prefix\
 	  >\
-	 >",
+	 >\
+	 [json$json]",
        SHOW_STR
        IP_STR
        "IP routing table\n"
@@ -1942,7 +1195,8 @@ DEFPY (show_route_detail,
        "IP routing table\n"
        VRF_FULL_CMD_HELP_STR
        "IPv6 Address\n"
-       "IPv6 prefix\n")
+       "IPv6 prefix\n"
+       JSON_STR)
 {
 	afi_t afi = ipv4 ? AFI_IP : AFI_IP6;
 	struct route_table *table;
@@ -1973,7 +1227,10 @@ DEFPY (show_route_detail,
 				continue;
 			}
 
-			vty_show_ip_route_detail(vty, rn, 0);
+			if (json)
+				vty_show_ip_route_detail_json(vty, rn);
+			else
+				vty_show_ip_route_detail(vty, rn, 0);
 
 			route_unlock_node(rn);
 		}
@@ -1981,7 +1238,7 @@ DEFPY (show_route_detail,
 		vrf_id_t vrf_id = VRF_DEFAULT;
 
 		if (vrf_name)
-			VRF_GET_ID(vrf_id, vrf_name);
+			VRF_GET_ID(vrf_id, vrf_name, false);
 
 		table = zebra_vrf_table(afi, SAFI_UNICAST, vrf_id);
 		if (!table)
@@ -1998,7 +1255,10 @@ DEFPY (show_route_detail,
 			return CMD_WARNING;
 		}
 
-		vty_show_ip_route_detail(vty, rn, 0);
+		if (json)
+			vty_show_ip_route_detail_json(vty, rn);
+		else
+			vty_show_ip_route_detail(vty, rn, 0);
 
 		route_unlock_node(rn);
 	}
@@ -2048,7 +1308,7 @@ DEFPY (show_route_summary,
 		vrf_id_t vrf_id = VRF_DEFAULT;
 
 		if (vrf_name)
-			VRF_GET_ID(vrf_id, vrf_name);
+			VRF_GET_ID(vrf_id, vrf_name, false);
 
 		table = zebra_vrf_table(afi, SAFI_UNICAST, vrf_id);
 		if (!table)
@@ -2201,384 +1461,6 @@ static void vty_show_ip_route_summary_pr
 	vty_out(vty, "\n");
 }
 
-/* Write static route configuration. */
-int static_config(struct vty *vty, struct zebra_vrf *zvrf, afi_t afi,
-		  safi_t safi, const char *cmd)
-{
-	struct static_hold_route *shr;
-	struct listnode *node;
-	char spacing[100];
-	struct route_node *rn;
-	struct static_route *si;
-	struct route_table *stable;
-	char buf[SRCDEST2STR_BUFFER];
-	int write = 0;
-
-	if ((stable = zvrf->stable[afi][safi]) == NULL)
-		return write;
-
-	sprintf(spacing, "%s%s", (zvrf->vrf->vrf_id == VRF_DEFAULT) ? "" : " ",
-		cmd);
-
-	/*
-	 * Static routes for vrfs not fully inited
-	 */
-	for (ALL_LIST_ELEMENTS_RO(static_list, node, shr)) {
-		if (shr->afi != afi || shr->safi != safi)
-			continue;
-
-		if (strcmp(zvrf->vrf->name, shr->vrf_name) != 0)
-			continue;
-
-		char dest_str[PREFIX_STRLEN];
-
-		prefix2str(&shr->dest, dest_str, sizeof(dest_str));
-
-		vty_out(vty, "%s ", spacing);
-		if (shr->dest_str)
-			vty_out(vty, "%s ", dest_str);
-		if (shr->src_str)
-			vty_out(vty, "from %s ", shr->src_str);
-		if (shr->gate_str)
-			vty_out(vty, "%s ", shr->gate_str);
-		if (shr->ifname)
-			vty_out(vty, "%s ", shr->ifname);
-		if (shr->flag_str)
-			vty_out(vty, "%s ", shr->flag_str);
-		if (shr->tag_str)
-			vty_out(vty, "tag %s ", shr->tag_str);
-		if (shr->distance_str)
-			vty_out(vty, "%s ", shr->distance_str);
-		if (shr->label_str)
-			vty_out(vty, "label %s ", shr->label_str);
-		if (strcmp(shr->vrf_name, shr->nhvrf_name) != 0)
-			vty_out(vty, "nexthop-vrf %s", shr->nhvrf_name);
-		vty_out(vty, "\n");
-	}
-
-	for (rn = route_top(stable); rn; rn = srcdest_route_next(rn))
-		for (si = rn->info; si; si = si->next) {
-			vty_out(vty, "%s %s", spacing,
-				srcdest_rnode2str(rn, buf, sizeof buf));
-
-			switch (si->type) {
-			case STATIC_IPV4_GATEWAY:
-				vty_out(vty, " %s", inet_ntoa(si->addr.ipv4));
-				break;
-			case STATIC_IPV6_GATEWAY:
-				vty_out(vty, " %s",
-					inet_ntop(AF_INET6, &si->addr.ipv6, buf,
-						  sizeof buf));
-				break;
-			case STATIC_IFNAME:
-				vty_out(vty, " %s", si->ifname);
-				break;
-			case STATIC_BLACKHOLE:
-				switch (si->bh_type) {
-				case STATIC_BLACKHOLE_DROP:
-					vty_out(vty, " blackhole");
-					break;
-				case STATIC_BLACKHOLE_NULL:
-					vty_out(vty, " Null0");
-					break;
-				case STATIC_BLACKHOLE_REJECT:
-					vty_out(vty, " reject");
-					break;
-				}
-				break;
-			case STATIC_IPV4_GATEWAY_IFNAME:
-				vty_out(vty, " %s %s",
-					inet_ntop(AF_INET, &si->addr.ipv4, buf,
-						  sizeof buf),
-					si->ifname);
-				break;
-			case STATIC_IPV6_GATEWAY_IFNAME:
-				vty_out(vty, " %s %s",
-					inet_ntop(AF_INET6, &si->addr.ipv6, buf,
-						  sizeof buf),
-					si->ifname);
-				break;
-			}
-
-			if (si->tag)
-				vty_out(vty, " tag %" ROUTE_TAG_PRI, si->tag);
-
-			if (si->distance != ZEBRA_STATIC_DISTANCE_DEFAULT)
-				vty_out(vty, " %d", si->distance);
-
-			/* Label information */
-			if (si->snh_label.num_labels)
-				vty_out(vty, " label %s",
-					mpls_label2str(si->snh_label.num_labels,
-						       si->snh_label.label, buf,
-						       sizeof buf, 0));
-
-			if (si->nh_vrf_id != si->vrf_id) {
-				vty_out(vty, " nexthop-vrf %s", si->nh_vrfname);
-			}
-
-			vty_out(vty, "\n");
-
-			write = 1;
-		}
-	return write;
-}
-
-DEFPY(ipv6_route_blackhole,
-      ipv6_route_blackhole_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          <Null0|reject|blackhole>$flag                    \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |vrf NAME                                      \
-            |label WORD                                    \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "Null interface\n"
-      "Emit an ICMP unreachable when matched\n"
-      "Silently discard pkts when matched\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR)
-{
-	return zebra_static_route(vty, AFI_IP6, SAFI_UNICAST, no, prefix_str,
-				  NULL, from_str, NULL, NULL, flag, tag_str,
-				  distance_str, vrf, label);
-}
-
-DEFPY(ipv6_route_blackhole_vrf,
-      ipv6_route_blackhole_vrf_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          <Null0|reject|blackhole>$flag                    \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |label WORD                                    \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "Null interface\n"
-      "Emit an ICMP unreachable when matched\n"
-      "Silently discard pkts when matched\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      MPLS_LABEL_HELPSTR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	struct zebra_vrf *zvrf = vrf->info;
-
-	/*
-	 * Coverity is complaining that prefix could
-	 * be dereferenced, but we know that prefix will
-	 * valid.  Add an assert to make it happy
-	 */
-	assert(prefix);
-	return zebra_static_route_leak(
-		vty, zvrf, zvrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
-		from_str, NULL, NULL, flag, tag_str, distance_str, label);
-}
-
-DEFPY(ipv6_route_address_interface,
-      ipv6_route_address_interface_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          X:X::X:X$gate                                    \
-          INTERFACE$ifname                                 \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |vrf NAME                                      \
-            |label WORD                                    \
-            |nexthop-vrf NAME                              \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "IPv6 gateway address\n"
-      "IPv6 gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	struct zebra_vrf *zvrf;
-	struct zebra_vrf *nh_zvrf;
-
-	zvrf = zebra_vty_get_unknown_vrf(vty, vrf);
-	if (!zvrf) {
-		vty_out(vty, "%% vrf %s is not defined\n", vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
-		from_str, gate_str, ifname, NULL, tag_str, distance_str, label);
-}
-
-DEFPY(ipv6_route_address_interface_vrf,
-      ipv6_route_address_interface_vrf_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          X:X::X:X$gate                                    \
-          INTERFACE$ifname                                 \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |label WORD                                    \
-            |nexthop-vrf NAME                              \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "IPv6 gateway address\n"
-      "IPv6 gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	struct zebra_vrf *zvrf = vrf->info;
-	struct zebra_vrf *nh_zvrf;
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
-		from_str, gate_str, ifname, NULL, tag_str, distance_str, label);
-}
-
-DEFPY(ipv6_route,
-      ipv6_route_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          <X:X::X:X$gate|INTERFACE$ifname>                 \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |vrf NAME                                      \
-            |label WORD                                    \
-            |nexthop-vrf NAME                              \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "IPv6 gateway address\n"
-      "IPv6 gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      VRF_CMD_HELP_STR
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	struct zebra_vrf *zvrf;
-	struct zebra_vrf *nh_zvrf;
-
-	zvrf = zebra_vty_get_unknown_vrf(vty, vrf);
-	if (!zvrf) {
-		vty_out(vty, "%% vrf %s is not defined\n", vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
-		from_str, gate_str, ifname, NULL, tag_str, distance_str, label);
-}
-
-DEFPY(ipv6_route_vrf,
-      ipv6_route_vrf_cmd,
-      "[no] ipv6 route X:X::X:X/M$prefix [from X:X::X:X/M] \
-          <X:X::X:X$gate|INTERFACE$ifname>                 \
-          [{                                               \
-            tag (1-4294967295)                             \
-            |(1-255)$distance                              \
-            |label WORD                                    \
-            |nexthop-vrf NAME                              \
-          }]",
-      NO_STR
-      IPV6_STR
-      "Establish static routes\n"
-      "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
-      "IPv6 source-dest route\n"
-      "IPv6 source prefix\n"
-      "IPv6 gateway address\n"
-      "IPv6 gateway interface name\n"
-      "Set tag for this route\n"
-      "Tag value\n"
-      "Distance value for this prefix\n"
-      MPLS_LABEL_HELPSTR
-      VRF_CMD_HELP_STR)
-{
-	VTY_DECLVAR_CONTEXT(vrf, vrf);
-	struct zebra_vrf *zvrf = vrf->info;
-	struct zebra_vrf *nh_zvrf;
-
-	if (nexthop_vrf)
-		nh_zvrf = zebra_vty_get_unknown_vrf(vty, nexthop_vrf);
-	else
-		nh_zvrf = zvrf;
-
-	if (!nh_zvrf) {
-		vty_out(vty, "%% nexthop vrf %s is not defined\n", nexthop_vrf);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	return zebra_static_route_leak(
-		vty, zvrf, nh_zvrf, AFI_IP6, SAFI_UNICAST, no, prefix_str, NULL,
-		from_str, gate_str, ifname, NULL, tag_str, distance_str, label);
-}
-
 /*
  * Show IPv6 mroute command.Used to dump
  * the Multicast routing table.
@@ -2598,7 +1480,7 @@ DEFUN (show_ipv6_mroute,
 	vrf_id_t vrf_id = VRF_DEFAULT;
 
 	if (argc == 5)
-		VRF_GET_ID(vrf_id, argv[4]->arg);
+		VRF_GET_ID(vrf_id, argv[4]->arg, false);
 
 	table = zebra_vrf_table(AFI_IP6, SAFI_MULTICAST, vrf_id);
 	if (!table)
@@ -2680,6 +1562,9 @@ DEFUN (show_vrf,
 	struct vrf *vrf;
 	struct zebra_vrf *zvrf;
 
+	if (vrf_is_backend_netns())
+		vty_out(vty, "netns-based vrfs\n");
+
 	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
 		if (!(zvrf = vrf->info))
 			continue;
@@ -2703,7 +1588,7 @@ DEFUN (show_vrf,
 	return CMD_SUCCESS;
 }
 
-DEFUN (default_vrf_vni_mapping,
+DEFUN_HIDDEN (default_vrf_vni_mapping,
        default_vrf_vni_mapping_cmd,
        "vni " CMD_VNI_RANGE "[prefix-routes-only]",
        "VNI corresponding to the DEFAULT VRF\n"
@@ -2733,7 +1618,7 @@ DEFUN (default_vrf_vni_mapping,
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_default_vrf_vni_mapping,
+DEFUN_HIDDEN (no_default_vrf_vni_mapping,
        no_default_vrf_vni_mapping_cmd,
        "no vni " CMD_VNI_RANGE,
        NO_STR
@@ -2792,12 +1677,14 @@ DEFUN (vrf_vni_mapping,
 
 DEFUN (no_vrf_vni_mapping,
        no_vrf_vni_mapping_cmd,
-       "no vni " CMD_VNI_RANGE,
+       "no vni " CMD_VNI_RANGE "[prefix-routes-only]",
        NO_STR
        "VNI corresponding to tenant VRF\n"
-       "VNI-ID")
+       "VNI-ID\n"
+       "prefix-routes-only\n")
 {
 	int ret = 0;
+	int filter = 0;
 	char err[ERR_STR_SZ];
 	vni_t vni = strtoul(argv[2]->arg, NULL, 10);
 
@@ -2806,7 +1693,11 @@ DEFUN (no_vrf_vni_mapping,
 	assert(vrf);
 	assert(zvrf);
 
-	ret = zebra_vxlan_process_vrf_vni_cmd(zvrf, vni, err, ERR_STR_SZ, 0, 0);
+	if (argc == 4)
+		filter = 1;
+
+	ret = zebra_vxlan_process_vrf_vni_cmd(zvrf, vni, err,
+					      ERR_STR_SZ, filter, 0);
 	if (ret != 0) {
 		vty_out(vty, "%s\n", err);
 		return CMD_WARNING;
@@ -3270,12 +2161,20 @@ DEFUN (show_pbr_ipset,
 /* policy routing contexts */
 DEFUN (show_pbr_iptable,
        show_pbr_iptable_cmd,
-       "show pbr iptable",
+       "show pbr iptable [WORD]",
        SHOW_STR
        "Policy-Based Routing\n"
-       "IPtable Context information\n")
+       "IPtable Context information\n"
+       "IPtable Name information\n")
 {
-	zebra_pbr_show_iptable(vty);
+	int idx = 0;
+	int found = 0;
+
+	found = argv_find(argv, argc, "WORD", &idx);
+	if (!found)
+		zebra_pbr_show_iptable(vty, NULL);
+	else
+		zebra_pbr_show_iptable(vty, argv[idx]->arg);
 	return CMD_SUCCESS;
 }
 
@@ -3347,7 +2246,8 @@ DEFUN_HIDDEN (zebra_packet_process,
 {
 	uint32_t packets = strtoul(argv[2]->arg, NULL, 10);
 
-	zebrad.packets_to_process = packets;
+	atomic_store_explicit(&zebrad.packets_to_process, packets,
+			      memory_order_relaxed);
 
 	return CMD_SUCCESS;
 }
@@ -3360,7 +2260,9 @@ DEFUN_HIDDEN (no_zebra_packet_process,
 	      "Zapi Protocol\n"
 	      "Number of packets to process before relinquishing thread\n")
 {
-	zebrad.packets_to_process = ZEBRA_ZAPI_PACKETS_TO_PROCESS;
+	atomic_store_explicit(&zebrad.packets_to_process,
+			      ZEBRA_ZAPI_PACKETS_TO_PROCESS,
+			      memory_order_relaxed);
 
 	return CMD_SUCCESS;
 }
@@ -3717,15 +2619,10 @@ void zebra_vty_init(void)
 
 	install_element(CONFIG_NODE, &allow_external_route_update_cmd);
 	install_element(CONFIG_NODE, &no_allow_external_route_update_cmd);
-	install_element(CONFIG_NODE, &ip_mroute_dist_cmd);
+
 	install_element(CONFIG_NODE, &ip_multicast_mode_cmd);
 	install_element(CONFIG_NODE, &no_ip_multicast_mode_cmd);
-	install_element(CONFIG_NODE, &ip_route_blackhole_cmd);
-	install_element(VRF_NODE, &ip_route_blackhole_vrf_cmd);
-	install_element(CONFIG_NODE, &ip_route_address_interface_cmd);
-	install_element(VRF_NODE, &ip_route_address_interface_vrf_cmd);
-	install_element(CONFIG_NODE, &ip_route_cmd);
-	install_element(VRF_NODE, &ip_route_vrf_cmd);
+
 	install_element(CONFIG_NODE, &ip_zebra_import_table_distance_cmd);
 	install_element(CONFIG_NODE, &no_ip_zebra_import_table_cmd);
 	install_element(CONFIG_NODE, &zebra_workqueue_timer_cmd);
@@ -3737,6 +2634,8 @@ void zebra_vty_init(void)
 	install_element(VIEW_NODE, &show_vrf_vni_cmd);
 	install_element(VIEW_NODE, &show_route_cmd);
 	install_element(VIEW_NODE, &show_route_table_cmd);
+	if (vrf_is_backend_netns())
+		install_element(VIEW_NODE, &show_route_table_vrf_cmd);
 	install_element(VIEW_NODE, &show_route_detail_cmd);
 	install_element(VIEW_NODE, &show_route_summary_cmd);
 	install_element(VIEW_NODE, &show_ip_nht_cmd);
@@ -3747,12 +2646,6 @@ void zebra_vty_init(void)
 	install_element(VIEW_NODE, &show_ip_rpf_cmd);
 	install_element(VIEW_NODE, &show_ip_rpf_addr_cmd);
 
-	install_element(CONFIG_NODE, &ipv6_route_blackhole_cmd);
-	install_element(VRF_NODE, &ipv6_route_blackhole_vrf_cmd);
-	install_element(CONFIG_NODE, &ipv6_route_address_interface_cmd);
-	install_element(VRF_NODE, &ipv6_route_address_interface_vrf_cmd);
-	install_element(CONFIG_NODE, &ipv6_route_cmd);
-	install_element(VRF_NODE, &ipv6_route_vrf_cmd);
 	install_element(CONFIG_NODE, &ip_nht_default_route_cmd);
 	install_element(CONFIG_NODE, &no_ip_nht_default_route_cmd);
 	install_element(CONFIG_NODE, &ipv6_nht_default_route_cmd);
@@ -3789,7 +2682,5 @@ void zebra_vty_init(void)
 	install_element(VRF_NODE, &vrf_vni_mapping_cmd);
 	install_element(VRF_NODE, &no_vrf_vni_mapping_cmd);
 
-	static_list = list_new();
-	static_list->cmp = (int (*)(void *, void *))static_list_compare;
-	static_list->del = (void (*)(void *))static_list_delete;
+
 }
diff -urpN frr-frr-5.0.1/zebra/zebra_vxlan.c frr-frr-6.0/zebra/zebra_vxlan.c
--- frr-frr-5.0.1/zebra/zebra_vxlan.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vxlan.c	2018-10-08 14:32:57.000000000 +0200
@@ -22,30 +22,34 @@
 
 #include <zebra.h>
 
+#include "hash.h"
 #include "if.h"
-#include "prefix.h"
-#include "table.h"
-#include "memory.h"
-#include "log.h"
+#include "jhash.h"
 #include "linklist.h"
+#include "log.h"
+#include "memory.h"
+#include "prefix.h"
 #include "stream.h"
-#include "hash.h"
-#include "jhash.h"
+#include "table.h"
 #include "vlan.h"
 #include "vxlan.h"
+#ifdef GNU_LINUX
+#include <linux/neighbour.h>
+#endif
 
+#include "zebra/debug.h"
+#include "zebra/interface.h"
 #include "zebra/rib.h"
 #include "zebra/rt.h"
+#include "zebra/rt_netlink.h"
+#include "zebra/zebra_errors.h"
+#include "zebra/zebra_l2.h"
+#include "zebra/zebra_memory.h"
 #include "zebra/zebra_ns.h"
-#include "zebra/zserv.h"
-#include "zebra/debug.h"
-#include "zebra/interface.h"
 #include "zebra/zebra_vrf.h"
-#include "zebra/rt_netlink.h"
-#include "zebra/zebra_vxlan_private.h"
 #include "zebra/zebra_vxlan.h"
-#include "zebra/zebra_memory.h"
-#include "zebra/zebra_l2.h"
+#include "zebra/zebra_vxlan_private.h"
+#include "zebra/zserv.h"
 
 DEFINE_MTYPE_STATIC(ZEBRA, HOST_PREFIX, "host prefix");
 DEFINE_MTYPE_STATIC(ZEBRA, ZVNI, "VNI hash");
@@ -56,7 +60,6 @@ DEFINE_MTYPE_STATIC(ZEBRA, NEIGH, "VNI N
 
 /* definitions */
 
-
 /* static function declarations */
 static int ip_prefix_send_to_client(vrf_id_t vrf_id, struct prefix *p,
 				    uint16_t cmd);
@@ -83,7 +86,6 @@ static void *zvni_neigh_alloc(void *p);
 static zebra_neigh_t *zvni_neigh_add(zebra_vni_t *zvni, struct ipaddr *ip,
 				     struct ethaddr *mac);
 static int zvni_neigh_del(zebra_vni_t *zvni, zebra_neigh_t *n);
-static int zvni_neigh_del_hash_entry(struct hash_backet *backet, void *arg);
 static void zvni_neigh_del_from_vtep(zebra_vni_t *zvni, int uninstall,
 				     struct in_addr *r_vtep_ip);
 static void zvni_neigh_del_all(zebra_vni_t *zvni, int uninstall, int upd_client,
@@ -139,7 +141,6 @@ static int mac_cmp(const void *p1, const
 static void *zvni_mac_alloc(void *p);
 static zebra_mac_t *zvni_mac_add(zebra_vni_t *zvni, struct ethaddr *macaddr);
 static int zvni_mac_del(zebra_vni_t *zvni, zebra_mac_t *mac);
-static int zvni_mac_del_hash_entry(struct hash_backet *backet, void *arg);
 static void zvni_mac_del_from_vtep(zebra_vni_t *zvni, int uninstall,
 				   struct in_addr *r_vtep_ip);
 static void zvni_mac_del_all(zebra_vni_t *zvni, int uninstall, int upd_client,
@@ -183,6 +184,47 @@ static void zvni_deref_ip2mac(zebra_vni_
 			      int uninstall);
 
 /* Private functions */
+static int host_rb_entry_compare(const struct host_rb_entry *hle1,
+				 const struct host_rb_entry *hle2)
+{
+	if (hle1->p.family < hle2->p.family)
+		return -1;
+
+	if (hle1->p.family > hle2->p.family)
+		return 1;
+
+	if (hle1->p.prefixlen < hle2->p.prefixlen)
+		return -1;
+
+	if (hle1->p.prefixlen > hle2->p.prefixlen)
+		return 1;
+
+	if (hle1->p.family == AF_INET) {
+		if (hle1->p.u.prefix4.s_addr < hle2->p.u.prefix4.s_addr)
+			return -1;
+
+		if (hle1->p.u.prefix4.s_addr > hle2->p.u.prefix4.s_addr)
+			return 1;
+
+		return 0;
+	} else {
+		zlog_warn("%s: Unexpected family type: %d", __PRETTY_FUNCTION__,
+			  hle1->p.family);
+		return 0;
+	}
+}
+RB_GENERATE(host_rb_tree_entry, host_rb_entry, hl_entry, host_rb_entry_compare);
+
+static uint32_t rb_host_count(struct host_rb_tree_entry *hrbe)
+{
+	struct host_rb_entry *hle;
+	uint32_t count = 0;
+
+	RB_FOREACH (hle, host_rb_tree_entry, hrbe)
+		count++;
+
+	return count;
+}
 
 /*
  * Return number of valid MACs in a VNI's MAC hash table - all
@@ -203,6 +245,7 @@ static uint32_t num_valid_macs(zebra_vni
 		for (hb = hash->index[i]; hb; hb = hb->next) {
 			mac = (zebra_mac_t *)hb->data;
 			if (CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE)
+			    || CHECK_FLAG(mac->flags, ZEBRA_MAC_LOCAL)
 			    || !CHECK_FLAG(mac->flags, ZEBRA_MAC_AUTO))
 				num_macs++;
 		}
@@ -238,12 +281,11 @@ static void zvni_find_neigh_addr_width(s
 	int width;
 
 	n = (zebra_neigh_t *)backet->data;
-	if (!n)
-		return;
 
 	ipaddr2str(&n->ip, buf, sizeof(buf)), width = strlen(buf);
 	if (width > wctx->addr_width)
 		wctx->addr_width = width;
+
 }
 
 /*
@@ -289,6 +331,10 @@ static void zvni_print_neigh(zebra_neigh
 		else
 			json_object_boolean_true_add(json, "defaultGateway");
 	}
+	if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG)) {
+		if (!json)
+			vty_out(vty, " Router");
+	}
 	if (json == NULL)
 		vty_out(vty, "\n");
 }
@@ -308,8 +354,6 @@ static void zvni_print_neigh_hash(struct
 	vty = wctx->vty;
 	json_vni = wctx->json;
 	n = (zebra_neigh_t *)backet->data;
-	if (!n)
-		return;
 
 	if (json_vni)
 		json_row = json_object_new_object();
@@ -388,17 +432,13 @@ static void zvni_print_neigh_hash_all_vn
 	json = (json_object *)args[1];
 
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni) {
-		if (json)
-			vty_out(vty, "{}\n");
-		return;
-	}
+
 	num_neigh = hashcount(zvni->neigh_table);
-	if (json == NULL)
+	if (json == NULL) {
 		vty_out(vty,
 			"\nVNI %u #ARP (IPv4 and IPv6, local and remote) %u\n\n",
 			zvni->vni, num_neigh);
-	else {
+	} else {
 		json_vni = json_object_new_object();
 		json_object_int_add(json_vni, "numArpNd", num_neigh);
 		snprintf(vni_str, VNI_STR_LEN, "%u", zvni->vni);
@@ -420,9 +460,10 @@ static void zvni_print_neigh_hash_all_vn
 	wctx.json = json_vni;
 	hash_iterate(zvni->neigh_table, zvni_find_neigh_addr_width, &wctx);
 
-	if (json == NULL)
+	if (json == NULL) {
 		vty_out(vty, "%*s %-6s %-17s %-21s\n", -wctx.addr_width, "IP",
 			"Type", "MAC", "Remote VTEP");
+	}
 	hash_iterate(zvni->neigh_table, zvni_print_neigh_hash, &wctx);
 
 	if (json)
@@ -435,20 +476,20 @@ static void zl3vni_print_nh(zebra_neigh_
 {
 	char buf1[ETHER_ADDR_STRLEN];
 	char buf2[INET6_ADDRSTRLEN];
-	struct listnode *node = NULL;
-	struct prefix *p = NULL;
 	json_object *json_hosts = NULL;
+	struct host_rb_entry *hle;
 
 	if (!json) {
 		vty_out(vty, "Ip: %s\n",
 			ipaddr2str(&n->ip, buf2, sizeof(buf2)));
 		vty_out(vty, "  RMAC: %s\n",
 			prefix_mac2str(&n->emac, buf1, sizeof(buf1)));
-		vty_out(vty, "  Refcount: %d\n", listcount(n->host_list));
+		vty_out(vty, "  Refcount: %d\n",
+			rb_host_count(&n->host_rb));
 		vty_out(vty, "  Prefixes:\n");
-		for (ALL_LIST_ELEMENTS_RO(n->host_list, node, p))
+		RB_FOREACH (hle, host_rb_tree_entry, &n->host_rb)
 			vty_out(vty, "    %s\n",
-				prefix2str(p, buf2, sizeof(buf2)));
+				prefix2str(&hle->p, buf2, sizeof(buf2)));
 	} else {
 		json_hosts = json_object_new_array();
 		json_object_string_add(
@@ -456,11 +497,12 @@ static void zl3vni_print_nh(zebra_neigh_
 		json_object_string_add(
 			json, "routerMac",
 			prefix_mac2str(&n->emac, buf2, sizeof(buf2)));
-		json_object_int_add(json, "refCount", listcount(n->host_list));
-		for (ALL_LIST_ELEMENTS_RO(n->host_list, node, p))
+		json_object_int_add(json, "refCount",
+				    rb_host_count(&n->host_rb));
+		RB_FOREACH (hle, host_rb_tree_entry, &n->host_rb)
 			json_object_array_add(json_hosts,
 					      json_object_new_string(prefix2str(
-						      p, buf2, sizeof(buf2))));
+										&hle->p, buf2, sizeof(buf2))));
 		json_object_object_add(json, "prefixList", json_hosts);
 	}
 }
@@ -471,20 +513,19 @@ static void zl3vni_print_rmac(zebra_mac_
 {
 	char buf1[ETHER_ADDR_STRLEN];
 	char buf2[PREFIX_STRLEN];
-	struct listnode *node = NULL;
-	struct prefix *p = NULL;
 	json_object *json_hosts = NULL;
+	struct host_rb_entry *hle;
 
 	if (!json) {
 		vty_out(vty, "MAC: %s\n",
 			prefix_mac2str(&zrmac->macaddr, buf1, sizeof(buf1)));
 		vty_out(vty, " Remote VTEP: %s\n",
 			inet_ntoa(zrmac->fwd_info.r_vtep_ip));
-		vty_out(vty, " Refcount: %d\n", listcount(zrmac->host_list));
+		vty_out(vty, " Refcount: %d\n", rb_host_count(&zrmac->host_rb));
 		vty_out(vty, "  Prefixes:\n");
-		for (ALL_LIST_ELEMENTS_RO(zrmac->host_list, node, p))
+		RB_FOREACH (hle, host_rb_tree_entry, &zrmac->host_rb)
 			vty_out(vty, "    %s\n",
-				prefix2str(p, buf2, sizeof(buf2)));
+				prefix2str(&hle->p, buf2, sizeof(buf2)));
 	} else {
 		json_hosts = json_object_new_array();
 		json_object_string_add(
@@ -493,11 +534,12 @@ static void zl3vni_print_rmac(zebra_mac_
 		json_object_string_add(json, "vtepIp",
 				       inet_ntoa(zrmac->fwd_info.r_vtep_ip));
 		json_object_int_add(json, "refCount",
-				    listcount(zrmac->host_list));
-		for (ALL_LIST_ELEMENTS_RO(zrmac->host_list, node, p))
-			json_object_array_add(json_hosts,
-					      json_object_new_string(prefix2str(
-						      p, buf2, sizeof(buf2))));
+				    rb_host_count(&zrmac->host_rb));
+		RB_FOREACH (hle, host_rb_tree_entry, &zrmac->host_rb)
+			json_object_array_add(
+				json_hosts,
+				json_object_new_string(prefix2str(
+					&hle->p, buf2, sizeof(buf2))));
 		json_object_object_add(json, "prefixList", json_hosts);
 	}
 }
@@ -542,6 +584,9 @@ static void zvni_print_mac(zebra_mac_t *
 	if (CHECK_FLAG(mac->flags, ZEBRA_MAC_DEF_GW))
 		vty_out(vty, " Default-gateway Mac ");
 
+	if (CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE_DEF_GW))
+		vty_out(vty, " Remote-gateway Mac ");
+
 	vty_out(vty, "\n");
 	/* print all the associated neigh */
 	vty_out(vty, " Neighbors:\n");
@@ -576,8 +621,6 @@ static void zvni_print_mac_hash(struct h
 	vty = wctx->vty;
 	json_mac_hdr = wctx->json;
 	mac = (zebra_mac_t *)backet->data;
-	if (!mac)
-		return;
 
 	prefix_mac2str(&mac->macaddr, buf1, sizeof(buf1));
 
@@ -683,11 +726,6 @@ static void zvni_print_mac_hash_all_vni(
 	json = (struct json_object *)wctx->json;
 
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni) {
-		if (json)
-			vty_out(vty, "{}\n");
-		return;
-	}
 	wctx->zvni = zvni;
 
 	/*We are iterating over a new VNI, set the count to 0*/
@@ -742,8 +780,6 @@ static void zl3vni_print_nh_hash(struct
 	if (json_vni)
 		json_nh = json_object_new_object();
 	n = (zebra_neigh_t *)backet->data;
-	if (!n)
-		return;
 
 	if (!json_vni) {
 		vty_out(vty, "%-15s %-17s\n",
@@ -776,11 +812,6 @@ static void zl3vni_print_nh_hash_all_vni
 	json = (struct json_object *)args[1];
 
 	zl3vni = (zebra_l3vni_t *)backet->data;
-	if (!zl3vni) {
-		if (json)
-			vty_out(vty, "{}\n");
-		return;
-	}
 
 	num_nh = hashcount(zl3vni->nh_table);
 	if (!num_nh)
@@ -820,11 +851,6 @@ static void zl3vni_print_rmac_hash_all_v
 	json = (struct json_object *)args[1];
 
 	zl3vni = (zebra_l3vni_t *)backet->data;
-	if (!zl3vni) {
-		if (json)
-			vty_out(vty, "{}\n");
-		return;
-	}
 
 	num_rmacs = hashcount(zl3vni->rmac_table);
 	if (!num_rmacs)
@@ -868,8 +894,6 @@ static void zl3vni_print_rmac_hash(struc
 	if (json)
 		json_rmac = json_object_new_object();
 	zrmac = (zebra_mac_t *)backet->data;
-	if (!zrmac)
-		return;
 
 	if (!json) {
 		vty_out(vty, "%-17s %-21s\n",
@@ -1046,8 +1070,6 @@ static void zl3vni_print_hash(struct has
 	json = (json_object *)ctx[1];
 
 	zl3vni = (zebra_l3vni_t *)backet->data;
-	if (!zl3vni)
-		return;
 
 	if (!json) {
 		vty_out(vty, "%-10u %-4s %-21s %-8lu %-8lu %-15s %-37s\n",
@@ -1095,8 +1117,6 @@ static void zvni_print_hash(struct hash_
 	json = ctxt[1];
 
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni)
-		return;
 
 	zvtep = zvni->vteps;
 	while (zvtep) {
@@ -1154,7 +1174,7 @@ static int zvni_macip_send_msg_to_client
 	struct zserv *client = NULL;
 	struct stream *s = NULL;
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -1196,7 +1216,7 @@ static int zvni_macip_send_msg_to_client
 	else
 		client->macipdel_cnt++;
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -1294,7 +1314,7 @@ static int zvni_neigh_del(zebra_vni_t *z
 /*
  * Free neighbor hash entry (callback)
  */
-static int zvni_neigh_del_hash_entry(struct hash_backet *backet, void *arg)
+static void zvni_neigh_del_hash_entry(struct hash_backet *backet, void *arg)
 {
 	struct neigh_walk_ctx *wctx = arg;
 	zebra_neigh_t *n = backet->data;
@@ -1312,10 +1332,10 @@ static int zvni_neigh_del_hash_entry(str
 		if (wctx->uninstall)
 			zvni_neigh_uninstall(wctx->zvni, n);
 
-		return zvni_neigh_del(wctx->zvni, n);
+		zvni_neigh_del(wctx->zvni, n);
 	}
 
-	return 0;
+	return;
 }
 
 /*
@@ -1335,10 +1355,7 @@ static void zvni_neigh_del_from_vtep(zeb
 	wctx.flags = DEL_REMOTE_NEIGH_FROM_VTEP;
 	wctx.r_vtep_ip = *r_vtep_ip;
 
-	hash_iterate(zvni->neigh_table,
-		     (void (*)(struct hash_backet *,
-			       void *))zvni_neigh_del_hash_entry,
-		     &wctx);
+	hash_iterate(zvni->neigh_table, zvni_neigh_del_hash_entry, &wctx);
 }
 
 /*
@@ -1358,10 +1375,7 @@ static void zvni_neigh_del_all(zebra_vni
 	wctx.upd_client = upd_client;
 	wctx.flags = flags;
 
-	hash_iterate(zvni->neigh_table,
-		     (void (*)(struct hash_backet *,
-			       void *))zvni_neigh_del_hash_entry,
-		     &wctx);
+	hash_iterate(zvni->neigh_table, zvni_neigh_del_hash_entry, &wctx);
 }
 
 /*
@@ -1446,14 +1460,13 @@ static void zvni_process_neigh_on_local_
 				zvni_neigh_send_del_to_client(zvni->vni, &n->ip,
 							      &n->emac, 0);
 			}
-		} else if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_REMOTE)) {
-			if (IS_ZEBRA_DEBUG_VXLAN)
-				zlog_err(
-					"local MAC %s getting deleted on VNI %u has remote neigh %s",
-					prefix_mac2str(&n->emac, buf,
-						       sizeof(buf)),
-					zvni->vni,
-					ipaddr2str(&n->ip, buf2, sizeof(buf2)));
+		} else if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_REMOTE)
+			   && IS_ZEBRA_DEBUG_VXLAN) {
+			zlog_debug(
+				"local MAC %s getting deleted on VNI %u has remote neigh %s",
+				prefix_mac2str(&n->emac, buf, sizeof(buf)),
+				zvni->vni,
+				ipaddr2str(&n->ip, buf2, sizeof(buf2)));
 		}
 	}
 }
@@ -1497,14 +1510,13 @@ static void zvni_process_neigh_on_remote
 	char buf2[INET6_ADDRSTRLEN];
 
 	for (ALL_LIST_ELEMENTS_RO(zmac->neigh_list, node, n)) {
-		if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_LOCAL)) {
-			if (IS_ZEBRA_DEBUG_VXLAN)
-				zlog_err(
-					"remote  MAC %s getting deleted on VNI %u has local neigh %s",
-					prefix_mac2str(&n->emac, buf,
-						       sizeof(buf)),
-					zvni->vni,
-					ipaddr2str(&n->ip, buf2, sizeof(buf2)));
+		if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_LOCAL)
+		    && IS_ZEBRA_DEBUG_VXLAN) {
+			zlog_debug(
+				"remote MAC %s getting deleted on VNI %u has local neigh %s",
+				prefix_mac2str(&n->emac, buf, sizeof(buf)),
+				zvni->vni,
+				ipaddr2str(&n->ip, buf2, sizeof(buf2)));
 		}
 	}
 }
@@ -1520,6 +1532,9 @@ static int zvni_neigh_send_add_to_client
 
 	if (CHECK_FLAG(neigh_flags, ZEBRA_NEIGH_DEF_GW))
 		SET_FLAG(flags, ZEBRA_MACIP_TYPE_GW);
+	/* Set router flag (R-bit) based on local neigh entry add */
+	if (CHECK_FLAG(neigh_flags, ZEBRA_NEIGH_ROUTER_FLAG))
+		SET_FLAG(flags, ZEBRA_MACIP_TYPE_ROUTER_FLAG);
 
 	return zvni_macip_send_msg_to_client(vni, macaddr, ip, flags,
 					     ZEBRA_MACIP_ADD);
@@ -1543,6 +1558,10 @@ static int zvni_neigh_install(zebra_vni_
 	struct zebra_if *zif;
 	struct zebra_l2info_vxlan *vxl;
 	struct interface *vlan_if;
+#ifdef GNU_LINUX
+	uint8_t flags;
+#endif
+	int ret = 0;
 
 	if (!(n->flags & ZEBRA_NEIGH_REMOTE))
 		return 0;
@@ -1555,8 +1574,13 @@ static int zvni_neigh_install(zebra_vni_
 	vlan_if = zvni_map_to_svi(vxl->access_vlan, zif->brslave_info.br_if);
 	if (!vlan_if)
 		return -1;
-
-	return kernel_add_neigh(vlan_if, &n->ip, &n->emac);
+#ifdef GNU_LINUX
+	flags = NTF_EXT_LEARNED;
+	if (n->flags & ZEBRA_NEIGH_ROUTER_FLAG)
+		flags |= NTF_ROUTER;
+	ret = kernel_add_neigh(vlan_if, &n->ip, &n->emac, flags);
+#endif
+	return ret;
 }
 
 /*
@@ -1572,8 +1596,8 @@ static int zvni_neigh_uninstall(zebra_vn
 		return 0;
 
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p couldn't be uninstalled - no intf",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p couldn't be uninstalled - no intf",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -1597,8 +1621,6 @@ static void zvni_install_neigh_hash(stru
 	struct neigh_walk_ctx *wctx = ctxt;
 
 	n = (zebra_neigh_t *)backet->data;
-	if (!n)
-		return;
 
 	if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_REMOTE))
 		zvni_neigh_install(wctx->zvni, n);
@@ -1747,9 +1769,10 @@ static int zvni_gw_macip_add(struct inte
 	if (!mac) {
 		mac = zvni_mac_add(zvni, macaddr);
 		if (!mac) {
-			zlog_err("Failed to add MAC %s intf %s(%u) VID %u",
-				 prefix_mac2str(macaddr, buf, sizeof(buf)),
-				 ifp->name, ifp->ifindex, vxl->access_vlan);
+			flog_err(ZEBRA_ERR_MAC_ADD_FAILED,
+				  "Failed to add MAC %s intf %s(%u) VID %u",
+				  prefix_mac2str(macaddr, buf, sizeof(buf)),
+				  ifp->name, ifp->ifindex, vxl->access_vlan);
 			return -1;
 		}
 	}
@@ -1766,7 +1789,8 @@ static int zvni_gw_macip_add(struct inte
 	if (!n) {
 		n = zvni_neigh_add(zvni, ip, macaddr);
 		if (!n) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_MAC_ADD_FAILED,
 				"Failed to add neighbor %s MAC %s intf %s(%u) -> VNI %u",
 				ipaddr2str(ip, buf2, sizeof(buf2)),
 				prefix_mac2str(macaddr, buf, sizeof(buf)),
@@ -1778,6 +1802,9 @@ static int zvni_gw_macip_add(struct inte
 	/* Set "local" forwarding info. */
 	SET_FLAG(n->flags, ZEBRA_NEIGH_LOCAL);
 	SET_FLAG(n->flags, ZEBRA_NEIGH_DEF_GW);
+	/* Set Router flag (R-bit) */
+	if (ip->ipa_type == IPADDR_V6)
+		SET_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG);
 	memcpy(&n->emac, macaddr, ETH_ALEN);
 	n->ifindex = ifp->ifindex;
 
@@ -1787,10 +1814,10 @@ static int zvni_gw_macip_add(struct inte
 
 	if (IS_ZEBRA_DEBUG_VXLAN)
 		zlog_debug(
-			"SVI %s(%u) L2-VNI %u, sending GW MAC %s IP %s add to BGP",
+			"SVI %s(%u) L2-VNI %u, sending GW MAC %s IP %s add to BGP with flags 0x%x",
 			ifp->name, ifp->ifindex, zvni->vni,
 			prefix_mac2str(macaddr, buf, sizeof(buf)),
-			ipaddr2str(ip, buf2, sizeof(buf2)));
+			ipaddr2str(ip, buf2, sizeof(buf2)), n->flags);
 
 	zvni_neigh_send_add_to_client(zvni->vni, ip, macaddr, n->flags);
 
@@ -1816,9 +1843,9 @@ static int zvni_gw_macip_del(struct inte
 	/* mac entry should be present */
 	mac = zvni_mac_lookup(zvni, &n->emac);
 	if (!mac) {
-		zlog_err("MAC %s doesnt exists for neigh %s on VNI %u",
-			 prefix_mac2str(&n->emac, buf1, sizeof(buf1)),
-			 ipaddr2str(ip, buf2, sizeof(buf2)), zvni->vni);
+		zlog_warn("MAC %s doesnt exists for neigh %s on VNI %u",
+			  prefix_mac2str(&n->emac, buf1, sizeof(buf1)),
+			  ipaddr2str(ip, buf2, sizeof(buf2)), zvni->vni);
 		return -1;
 	}
 
@@ -1831,7 +1858,7 @@ static int zvni_gw_macip_del(struct inte
 		zlog_debug(
 			"%u:SVI %s(%u) VNI %u, sending GW MAC %s IP %s del to BGP",
 			ifp->vrf_id, ifp->name, ifp->ifindex, zvni->vni,
-			prefix_mac2str(&(n->emac), NULL, ETHER_ADDR_STRLEN),
+			prefix_mac2str(&(n->emac), buf1, sizeof(buf1)),
 			ipaddr2str(ip, buf2, sizeof(buf2)));
 
 	/* Remove neighbor from BGP. */
@@ -1860,8 +1887,6 @@ static void zvni_gw_macip_del_for_vni_ha
 
 	/* Add primary SVI MAC*/
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni)
-		return;
 
 	ifp = zvni->vxlan_if;
 	if (!ifp)
@@ -1901,8 +1926,6 @@ static void zvni_gw_macip_add_for_vni_ha
 	struct interface *ifp = NULL;
 
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni)
-		return;
 
 	ifp = zvni->vxlan_if;
 	if (!ifp)
@@ -1933,12 +1956,14 @@ static void zvni_gw_macip_add_for_vni_ha
 static int zvni_local_neigh_update(zebra_vni_t *zvni,
 				   struct interface *ifp,
 				   struct ipaddr *ip,
-				   struct ethaddr *macaddr)
+				   struct ethaddr *macaddr,
+				   uint8_t router_flag)
 {
 	char buf[ETHER_ADDR_STRLEN];
 	char buf2[INET6_ADDRSTRLEN];
 	zebra_neigh_t *n = NULL;
 	zebra_mac_t *zmac = NULL, *old_zmac = NULL;
+	bool check_rbit = false;
 
 	/* create a dummy MAC if the MAC is not already present */
 	zmac = zvni_mac_lookup(zvni, macaddr);
@@ -1968,34 +1993,40 @@ static int zvni_local_neigh_update(zebra
 	n = zvni_neigh_lookup(zvni, ip);
 	if (n) {
 		if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_LOCAL)) {
+
+			if (router_flag !=
+			    (CHECK_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG)
+					? 1 : 0))
+				check_rbit = true;
+
 			if (memcmp(n->emac.octet, macaddr->octet,
 				   ETH_ALEN) == 0) {
 				/* Update any params and return - client doesn't
 				 * care about a purely local change.
 				 */
 				n->ifindex = ifp->ifindex;
-				return 0;
-			}
+			} else {
 
-			/* If the MAC has changed,
-			 * need to issue a delete first
-			 * as this means a different MACIP route.
-			 * Also, need to do some unlinking/relinking.
-			 */
-			zvni_neigh_send_del_to_client(zvni->vni, &n->ip,
+				/* If the MAC has changed,
+				 * need to issue a delete first
+				 * as this means a different MACIP route.
+				 * Also, need to do some unlinking/relinking.
+				 */
+				zvni_neigh_send_del_to_client(zvni->vni, &n->ip,
 						      &n->emac, 0);
-			old_zmac = zvni_mac_lookup(zvni, &n->emac);
-			if (old_zmac) {
-				listnode_delete(old_zmac->neigh_list, n);
-				zvni_deref_ip2mac(zvni, old_zmac, 0);
-			}
+				old_zmac = zvni_mac_lookup(zvni, &n->emac);
+				if (old_zmac) {
+					listnode_delete(old_zmac->neigh_list, n);
+					zvni_deref_ip2mac(zvni, old_zmac, 0);
+				}
 
-			/* Update the forwarding info. */
-			n->ifindex = ifp->ifindex;
-			memcpy(&n->emac, macaddr, ETH_ALEN);
+				/* Update the forwarding info. */
+				n->ifindex = ifp->ifindex;
+				memcpy(&n->emac, macaddr, ETH_ALEN);
 
-			/* Link to new MAC */
-			listnode_add_sort(zmac->neigh_list, n);
+				/* Link to new MAC */
+				listnode_add_sort(zmac->neigh_list, n);
+			}
 
 		} else
 		/* Neighbor has moved from remote to local. */
@@ -2020,12 +2051,14 @@ static int zvni_local_neigh_update(zebra
 			n->r_vtep_ip.s_addr = 0;
 			SET_FLAG(n->flags, ZEBRA_NEIGH_LOCAL);
 			n->ifindex = ifp->ifindex;
+			check_rbit = true;
 		}
 	} else {
 		/* New neighbor - create */
 		n = zvni_neigh_add(zvni, ip, macaddr);
 		if (!n) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_MAC_ADD_FAILED,
 				"Failed to add neighbor %s MAC %s intf %s(%u) -> VNI %u",
 				ipaddr2str(ip, buf2, sizeof(buf2)),
 				prefix_mac2str(macaddr, buf, sizeof(buf)),
@@ -2035,31 +2068,48 @@ static int zvni_local_neigh_update(zebra
 		/* Set "local" forwarding info. */
 		SET_FLAG(n->flags, ZEBRA_NEIGH_LOCAL);
 		n->ifindex = ifp->ifindex;
+		check_rbit = true;
 	}
 
+	/*Mark Router flag (R-bit) */
+	if (router_flag)
+		SET_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG);
+	else
+		UNSET_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG);
+
 	/* Before we program this in BGP, we need to check if MAC is locally
 	 * learnt as well
 	 */
 	if (!CHECK_FLAG(zmac->flags, ZEBRA_MAC_LOCAL)) {
 		if (IS_ZEBRA_DEBUG_VXLAN)
 			zlog_debug(
-				"Skipping neigh %s add to client as MAC %s is not local on VNI %u",
+				"Skipping neigh %s add to client as MAC %s is not local on VNI %u with flags 0x%x",
 				ipaddr2str(ip, buf2, sizeof(buf2)),
 				prefix_mac2str(macaddr, buf, sizeof(buf)),
-				zvni->vni);
+				zvni->vni, n->flags);
+
+		return 0;
+	}
 
+	if (!check_rbit) {
+		if (IS_ZEBRA_DEBUG_VXLAN)
+			zlog_debug(
+				"Skipping neigh %s with MAC %s on VNI %u add to client as router flag is not set.",
+				ipaddr2str(ip, buf2, sizeof(buf2)),
+				prefix_mac2str(macaddr, buf, sizeof(buf)),
+				zvni->vni);
 		return 0;
 	}
 
 	/* Inform BGP. */
 	if (IS_ZEBRA_DEBUG_VXLAN)
-		zlog_debug("Neigh %s (MAC %s) is now ACTIVE on L2-VNI %u",
+		zlog_debug("Neigh %s (MAC %s) is now ACTIVE on L2-VNI %u with flags 0x%x",
 			   ipaddr2str(ip, buf2, sizeof(buf2)),
 			   prefix_mac2str(macaddr, buf, sizeof(buf)),
-			   zvni->vni);
+			   zvni->vni, n->flags);
 	ZEBRA_NEIGH_SET_ACTIVE(n);
 
-	return zvni_neigh_send_add_to_client(zvni->vni, ip, macaddr, 0);
+	return zvni_neigh_send_add_to_client(zvni->vni, ip, macaddr, n->flags);
 }
 
 static int zvni_remote_neigh_update(zebra_vni_t *zvni,
@@ -2092,10 +2142,11 @@ static int zvni_remote_neigh_update(zebr
 		 */
 		zmac = zvni_mac_lookup(zvni, macaddr);
 		if (!zmac || !CHECK_FLAG(zmac->flags, ZEBRA_MAC_REMOTE)) {
-			zlog_err("Ignore remote neigh %s (MAC %s) on L2-VNI %u - MAC unknown or local",
-				 ipaddr2str(&n->ip, buf2, sizeof(buf2)),
-				 prefix_mac2str(macaddr, buf, sizeof(buf)),
-				 zvni->vni);
+			zlog_warn(
+				"Ignore remote neigh %s (MAC %s) on L2-VNI %u - MAC unknown or local",
+				ipaddr2str(&n->ip, buf2, sizeof(buf2)),
+				prefix_mac2str(macaddr, buf, sizeof(buf)),
+				zvni->vni);
 			return -1;
 		}
 
@@ -2189,7 +2240,7 @@ static int zvni_mac_del(zebra_vni_t *zvn
 /*
  * Free MAC hash entry (callback)
  */
-static int zvni_mac_del_hash_entry(struct hash_backet *backet, void *arg)
+static void zvni_mac_del_hash_entry(struct hash_backet *backet, void *arg)
 {
 	struct mac_walk_ctx *wctx = arg;
 	zebra_mac_t *mac = backet->data;
@@ -2209,10 +2260,10 @@ static int zvni_mac_del_hash_entry(struc
 		if (wctx->uninstall)
 			zvni_mac_uninstall(wctx->zvni, mac, 0);
 
-		return zvni_mac_del(wctx->zvni, mac);
+		zvni_mac_del(wctx->zvni, mac);
 	}
 
-	return 0;
+	return;
 }
 
 /*
@@ -2232,9 +2283,7 @@ static void zvni_mac_del_from_vtep(zebra
 	wctx.flags = DEL_REMOTE_MAC_FROM_VTEP;
 	wctx.r_vtep_ip = *r_vtep_ip;
 
-	hash_iterate(zvni->mac_table, (void (*)(struct hash_backet *,
-						void *))zvni_mac_del_hash_entry,
-		     &wctx);
+	hash_iterate(zvni->mac_table, zvni_mac_del_hash_entry, &wctx);
 }
 
 /*
@@ -2254,9 +2303,7 @@ static void zvni_mac_del_all(zebra_vni_t
 	wctx.upd_client = upd_client;
 	wctx.flags = flags;
 
-	hash_iterate(zvni->mac_table, (void (*)(struct hash_backet *,
-						void *))zvni_mac_del_hash_entry,
-		     &wctx);
+	hash_iterate(zvni->mac_table, zvni_mac_del_hash_entry, &wctx);
 }
 
 /*
@@ -2505,7 +2552,8 @@ static int zvni_mac_install(zebra_vni_t
 		return -1;
 	vxl = &zif->l2info.vxl;
 
-	sticky = CHECK_FLAG(mac->flags, ZEBRA_MAC_STICKY) ? 1 : 0;
+	sticky = CHECK_FLAG(mac->flags,
+			 (ZEBRA_MAC_STICKY | ZEBRA_MAC_REMOTE_DEF_GW)) ? 1 : 0;
 
 	return kernel_add_mac(zvni->vxlan_if, vxl->access_vlan, &mac->macaddr,
 			      mac->fwd_info.r_vtep_ip, sticky);
@@ -2527,8 +2575,8 @@ static int zvni_mac_uninstall(zebra_vni_
 		return 0;
 
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p couldn't be uninstalled - no intf",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p couldn't be uninstalled - no intf",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -2561,8 +2609,6 @@ static void zvni_install_mac_hash(struct
 	struct mac_walk_ctx *wctx = ctxt;
 
 	mac = (zebra_mac_t *)backet->data;
-	if (!mac)
-		return;
 
 	if (CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE))
 		zvni_mac_install(wctx->zvni, mac);
@@ -2738,7 +2784,7 @@ static int zvni_send_add_to_client(zebra
 	struct zserv *client;
 	struct stream *s;
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -2760,7 +2806,7 @@ static int zvni_send_add_to_client(zebra
 			   zebra_route_string(client->proto));
 
 	client->vniadd_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -2771,7 +2817,7 @@ static int zvni_send_del_to_client(vni_t
 	struct zserv *client;
 	struct stream *s;
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -2790,7 +2836,7 @@ static int zvni_send_del_to_client(vni_t
 			   zebra_route_string(client->proto));
 
 	client->vnidel_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -2857,7 +2903,7 @@ static void zvni_build_hash_table()
 			/* VNI hash entry is not expected to exist. */
 			zvni = zvni_lookup(vni);
 			if (zvni) {
-				zlog_err(
+				zlog_warn(
 					"VNI hash already present for IF %s(%u) L2-VNI %u",
 					ifp->name, ifp->ifindex, vni);
 				continue;
@@ -2865,7 +2911,7 @@ static void zvni_build_hash_table()
 
 			zvni = zvni_add(vni);
 			if (!zvni) {
-				zlog_err(
+				zlog_warn(
 					"Failed to add VNI hash, IF %s(%u) L2-VNI %u",
 					ifp->name, ifp->ifindex, vni);
 				return;
@@ -2924,10 +2970,6 @@ static zebra_vtep_t *zvni_vtep_add(zebra
 	zebra_vtep_t *zvtep;
 
 	zvtep = XCALLOC(MTYPE_ZVNI_VTEP, sizeof(zebra_vtep_t));
-	if (!zvtep) {
-		zlog_err("Failed to alloc VTEP entry, VNI %u", zvni->vni);
-		return NULL;
-	}
 
 	zvtep->vtep_ip = *vtep_ip;
 
@@ -2992,8 +3034,8 @@ static int zvni_vtep_install(zebra_vni_t
 static int zvni_vtep_uninstall(zebra_vni_t *zvni, struct in_addr *vtep_ip)
 {
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p couldn't be uninstalled - no intf",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p couldn't be uninstalled - no intf",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -3010,8 +3052,6 @@ static void zvni_cleanup_all(struct hash
 	struct zebra_vrf *zvrf = (struct zebra_vrf *)arg;
 
 	zvni = (zebra_vni_t *)backet->data;
-	if (!zvni)
-		return;
 
 	/* remove from l3-vni list */
 	if (zvrf->l3vni)
@@ -3036,48 +3076,44 @@ static void zl3vni_cleanup_all(struct ha
 	zebra_l3vni_t *zl3vni = NULL;
 
 	zl3vni = (zebra_l3vni_t *)backet->data;
-	if (!zl3vni)
-		return;
 
 	zebra_vxlan_process_l3vni_oper_down(zl3vni);
 }
 
-static int is_host_present_in_host_list(struct list *list, struct prefix *host)
+static void rb_find_or_add_host(struct host_rb_tree_entry *hrbe,
+				struct prefix *host)
 {
-	struct listnode *node = NULL;
-	struct prefix *p = NULL;
+	struct host_rb_entry lookup;
+	struct host_rb_entry *hle;
 
-	for (ALL_LIST_ELEMENTS_RO(list, node, p)) {
-		if (prefix_same(p, host))
-			return 1;
-	}
-	return 0;
-}
+	memset(&lookup, 0, sizeof(lookup));
+	memcpy(&lookup.p, host, sizeof(*host));
 
-static void host_list_add_host(struct list *list, struct prefix *host)
-{
-	struct prefix *p = NULL;
+	hle = RB_FIND(host_rb_tree_entry, hrbe, &lookup);
+	if (hle)
+		return;
 
-	p = XCALLOC(MTYPE_HOST_PREFIX, sizeof(struct prefix));
-	memcpy(p, host, sizeof(struct prefix));
+	hle = XCALLOC(MTYPE_HOST_PREFIX, sizeof(struct host_rb_entry));
+	memcpy(hle, &lookup, sizeof(lookup));
 
-	listnode_add_sort(list, p);
+	RB_INSERT(host_rb_tree_entry, hrbe, hle);
 }
 
-static void host_list_delete_host(struct list *list, struct prefix *host)
+static void rb_delete_host(struct host_rb_tree_entry *hrbe, struct prefix *host)
 {
-	struct listnode *node = NULL, *nnode = NULL, *node_to_del = NULL;
-	struct prefix *p = NULL;
+	struct host_rb_entry lookup;
+	struct host_rb_entry *hle;
 
-	for (ALL_LIST_ELEMENTS(list, node, nnode, p)) {
-		if (prefix_same(p, host)) {
-			XFREE(MTYPE_HOST_PREFIX, p);
-			node_to_del = node;
-		}
+	memset(&lookup, 0, sizeof(lookup));
+	memcpy(&lookup.p, host, sizeof(*host));
+
+	hle = RB_FIND(host_rb_tree_entry, hrbe, &lookup);
+	if (hle) {
+		RB_REMOVE(host_rb_tree_entry, hrbe, hle);
+		XFREE(MTYPE_HOST_PREFIX, hle);
 	}
 
-	if (node_to_del)
-		list_delete_node(list, node_to_del);
+	return;
 }
 
 /*
@@ -3123,8 +3159,7 @@ static zebra_mac_t *zl3vni_rmac_add(zebr
 	zrmac = hash_get(zl3vni->rmac_table, &tmp_rmac, zl3vni_rmac_alloc);
 	assert(zrmac);
 
-	zrmac->host_list = list_new();
-	zrmac->host_list->cmp = (int (*)(void *, void *))prefix_cmp;
+	RB_INIT(host_rb_tree_entry, &zrmac->host_rb);
 
 	SET_FLAG(zrmac->flags, ZEBRA_MAC_REMOTE);
 	SET_FLAG(zrmac->flags, ZEBRA_MAC_REMOTE_RMAC);
@@ -3138,10 +3173,14 @@ static zebra_mac_t *zl3vni_rmac_add(zebr
 static int zl3vni_rmac_del(zebra_l3vni_t *zl3vni, zebra_mac_t *zrmac)
 {
 	zebra_mac_t *tmp_rmac;
+	struct host_rb_entry *hle;
 
-	if (zrmac->host_list)
-		list_delete_and_null(&zrmac->host_list);
-	zrmac->host_list = NULL;
+	while (!RB_EMPTY(host_rb_tree_entry, &zrmac->host_rb)) {
+		hle = RB_ROOT(host_rb_tree_entry, &zrmac->host_rb);
+
+		RB_REMOVE(host_rb_tree_entry, &zrmac->host_rb, hle);
+		XFREE(MTYPE_HOST_PREFIX, hle);
+	}
 
 	tmp_rmac = hash_release(zl3vni->rmac_table, zrmac);
 	if (tmp_rmac)
@@ -3186,7 +3225,7 @@ static int zl3vni_rmac_uninstall(zebra_l
 		return 0;
 
 	if (!zl3vni->vxlan_if) {
-		zlog_err(
+		zlog_warn(
 			"RMAC %s on L3-VNI %u hash %p couldn't be uninstalled - no vxlan_if",
 			prefix_mac2str(&zrmac->macaddr, buf, sizeof(buf)),
 			zl3vni->vni, zl3vni);
@@ -3231,32 +3270,25 @@ static int zl3vni_remote_rmac_add(zebra_
 		zl3vni_rmac_install(zl3vni, zrmac);
 	}
 
-	if (!is_host_present_in_host_list(zrmac->host_list, host_prefix))
-		host_list_add_host(zrmac->host_list, host_prefix);
+	rb_find_or_add_host(&zrmac->host_rb, host_prefix);
+
 	return 0;
 }
 
 
 /* handle rmac delete */
-static int zl3vni_remote_rmac_del(zebra_l3vni_t *zl3vni, struct ethaddr *rmac,
+static void zl3vni_remote_rmac_del(zebra_l3vni_t *zl3vni, zebra_mac_t *zrmac,
 				  struct prefix *host_prefix)
 {
-	zebra_mac_t *zrmac = NULL;
-
-	zrmac = zl3vni_rmac_lookup(zl3vni, rmac);
-	if (!zrmac)
-		return -1;
-
-	host_list_delete_host(zrmac->host_list, host_prefix);
-	if (list_isempty(zrmac->host_list)) {
+	rb_delete_host(&zrmac->host_rb, host_prefix);
 
+	if (RB_EMPTY(host_rb_tree_entry, &zrmac->host_rb)) {
 		/* uninstall from kernel */
 		zl3vni_rmac_uninstall(zl3vni, zrmac);
 
 		/* del the rmac entry */
 		zl3vni_rmac_del(zl3vni, zrmac);
 	}
-	return 0;
 }
 
 /*
@@ -3303,8 +3335,7 @@ static zebra_neigh_t *zl3vni_nh_add(zebr
 	n = hash_get(zl3vni->nh_table, &tmp_n, zl3vni_nh_alloc);
 	assert(n);
 
-	n->host_list = list_new();
-	n->host_list->cmp = (int (*)(void *, void *))prefix_cmp;
+	RB_INIT(host_rb_tree_entry, &n->host_rb);
 
 	memcpy(&n->emac, mac, ETH_ALEN);
 	SET_FLAG(n->flags, ZEBRA_NEIGH_REMOTE);
@@ -3319,10 +3350,14 @@ static zebra_neigh_t *zl3vni_nh_add(zebr
 static int zl3vni_nh_del(zebra_l3vni_t *zl3vni, zebra_neigh_t *n)
 {
 	zebra_neigh_t *tmp_n;
+	struct host_rb_entry *hle;
+
+	while (!RB_EMPTY(host_rb_tree_entry, &n->host_rb)) {
+		hle = RB_ROOT(host_rb_tree_entry, &n->host_rb);
 
-	if (n->host_list)
-		list_delete_and_null(&n->host_list);
-	n->host_list = NULL;
+		RB_REMOVE(host_rb_tree_entry, &n->host_rb, hle);
+		XFREE(MTYPE_HOST_PREFIX, hle);
+	}
 
 	tmp_n = hash_release(zl3vni->nh_table, n);
 	if (tmp_n)
@@ -3336,14 +3371,24 @@ static int zl3vni_nh_del(zebra_l3vni_t *
  */
 static int zl3vni_nh_install(zebra_l3vni_t *zl3vni, zebra_neigh_t *n)
 {
+#ifdef GNU_LINUX
+	uint8_t flags;
+#endif
+	int ret = 0;
+
 	if (!is_l3vni_oper_up(zl3vni))
 		return -1;
 
 	if (!(n->flags & ZEBRA_NEIGH_REMOTE)
 	    || !(n->flags & ZEBRA_NEIGH_REMOTE_NH))
 		return 0;
-
-	return kernel_add_neigh(zl3vni->svi_if, &n->ip, &n->emac);
+#ifdef GNU_LINUX
+	flags = NTF_EXT_LEARNED;
+	if (n->flags & ZEBRA_NEIGH_ROUTER_FLAG)
+		flags |= NTF_ROUTER;
+	ret = kernel_add_neigh(zl3vni->svi_if, &n->ip, &n->emac, flags);
+#endif
+	return ret;
 }
 
 /*
@@ -3387,33 +3432,24 @@ static int zl3vni_remote_nh_add(zebra_l3
 		zl3vni_nh_install(zl3vni, nh);
 	}
 
-	if (!is_host_present_in_host_list(nh->host_list, host_prefix))
-		host_list_add_host(nh->host_list, host_prefix);
+	rb_find_or_add_host(&nh->host_rb, host_prefix);
 
 	return 0;
 }
 
 /* handle nh neigh delete */
-static int zl3vni_remote_nh_del(zebra_l3vni_t *zl3vni, struct ipaddr *vtep_ip,
-				struct prefix *host_prefix)
+static void zl3vni_remote_nh_del(zebra_l3vni_t *zl3vni, zebra_neigh_t *nh,
+				 struct prefix *host_prefix)
 {
-	zebra_neigh_t *nh = NULL;
-
-	nh = zl3vni_nh_lookup(zl3vni, vtep_ip);
-	if (!nh)
-		return -1;
-
-	host_list_delete_host(nh->host_list, host_prefix);
-	if (list_isempty(nh->host_list)) {
+	rb_delete_host(&nh->host_rb, host_prefix);
 
+	if (RB_EMPTY(host_rb_tree_entry, &nh->host_rb)) {
 		/* uninstall from kernel */
 		zl3vni_nh_uninstall(zl3vni, nh);
 
 		/* delete the nh entry */
 		zl3vni_nh_del(zl3vni, nh);
 	}
-
-	return 0;
 }
 
 /* handle neigh update from kernel - the only thing of interest is to
@@ -3718,7 +3754,7 @@ static int zl3vni_send_add_to_client(zeb
 	struct ethaddr rmac;
 	char buf[ETHER_ADDR_STRLEN];
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -3750,7 +3786,7 @@ static int zl3vni_send_add_to_client(zeb
 			zebra_route_string(client->proto));
 
 	client->l3vniadd_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /*
@@ -3761,7 +3797,7 @@ static int zl3vni_send_del_to_client(zeb
 	struct stream *s = NULL;
 	struct zserv *client = NULL;
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -3780,7 +3816,7 @@ static int zl3vni_send_del_to_client(zeb
 			   zebra_route_string(client->proto));
 
 	client->l3vnidel_cnt++;
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 static void zebra_vxlan_process_l3vni_oper_up(zebra_l3vni_t *zl3vni)
@@ -3847,8 +3883,9 @@ static int zebra_vxlan_handle_vni_transi
 
 		/* Delete the hash entry. */
 		if (zvni_del(zvni)) {
-			zlog_err("Failed to del VNI hash %p, VNI %u", zvni,
-				 zvni->vni);
+			flog_err(ZEBRA_ERR_VNI_DEL_FAILED,
+				  "Failed to del VNI hash %p, VNI %u", zvni,
+				  zvni->vni);
 			return -1;
 		}
 	} else {
@@ -3893,7 +3930,7 @@ static int ip_prefix_send_to_client(vrf_
 	struct stream *s = NULL;
 	char buf[PREFIX_STRLEN];
 
-	client = zebra_find_client(ZEBRA_ROUTE_BGP, 0);
+	client = zserv_find_client(ZEBRA_ROUTE_BGP, 0);
 	/* BGP may not be running. */
 	if (!client)
 		return 0;
@@ -3917,7 +3954,7 @@ static int ip_prefix_send_to_client(vrf_
 	else
 		client->prefixdel_cnt++;
 
-	return zebra_server_send_message(client, s);
+	return zserv_send_message(client, s);
 }
 
 /* re-add remote rmac if needed */
@@ -3958,34 +3995,65 @@ void zebra_vxlan_evpn_vrf_route_add(vrf_
 				    struct prefix *host_prefix)
 {
 	zebra_l3vni_t *zl3vni = NULL;
+	struct ipaddr ipv4_vtep;
 
 	zl3vni = zl3vni_from_vrf(vrf_id);
 	if (!zl3vni || !is_l3vni_oper_up(zl3vni))
 		return;
 
-	/* add the next hop neighbor */
+	/*
+	 * add the next hop neighbor -
+	 * neigh to be installed is the ipv6 nexthop neigh
+	 */
 	zl3vni_remote_nh_add(zl3vni, vtep_ip, rmac, host_prefix);
 
-	/* add the rmac */
-	zl3vni_remote_rmac_add(zl3vni, rmac, vtep_ip, host_prefix);
+	/*
+	 * if the remote vtep is a ipv4 mapped ipv6 address convert it to ipv4
+	 * address. Rmac is programmed against the ipv4 vtep because we only
+	 * support ipv4 tunnels in the h/w right now
+	 */
+	memset(&ipv4_vtep, 0, sizeof(struct ipaddr));
+	ipv4_vtep.ipa_type = IPADDR_V4;
+	if (vtep_ip->ipa_type == IPADDR_V6)
+		ipv4_mapped_ipv6_to_ipv4(&vtep_ip->ipaddr_v6,
+					 &(ipv4_vtep.ipaddr_v4));
+	else
+		memcpy(&(ipv4_vtep.ipaddr_v4), &vtep_ip->ipaddr_v4,
+		       sizeof(struct in_addr));
+
+	/*
+	 * add the rmac - remote rmac to be installed is against the ipv4
+	 * nexthop address
+	 */
+	zl3vni_remote_rmac_add(zl3vni, rmac, &ipv4_vtep, host_prefix);
 }
 
 /* handle evpn vrf route delete */
-void zebra_vxlan_evpn_vrf_route_del(vrf_id_t vrf_id, struct ethaddr *rmac,
+void zebra_vxlan_evpn_vrf_route_del(vrf_id_t vrf_id,
 				    struct ipaddr *vtep_ip,
 				    struct prefix *host_prefix)
 {
 	zebra_l3vni_t *zl3vni = NULL;
+	zebra_neigh_t *nh = NULL;
+	zebra_mac_t *zrmac = NULL;
 
 	zl3vni = zl3vni_from_vrf(vrf_id);
 	if (!zl3vni)
 		return;
 
+	/* find the next hop entry and rmac entry */
+	nh = zl3vni_nh_lookup(zl3vni, vtep_ip);
+	if (!nh)
+		return;
+	zrmac = zl3vni_rmac_lookup(zl3vni, &nh->emac);
+
 	/* delete the next hop entry */
-	zl3vni_remote_nh_del(zl3vni, vtep_ip, host_prefix);
+	zl3vni_remote_nh_del(zl3vni, nh, host_prefix);
 
 	/* delete the rmac entry */
-	zl3vni_remote_rmac_del(zl3vni, rmac, host_prefix);
+	if (zrmac)
+		zl3vni_remote_rmac_del(zl3vni, zrmac, host_prefix);
+
 }
 
 void zebra_vxlan_print_specific_rmac_l3vni(struct vty *vty, vni_t l3vni,
@@ -4465,9 +4533,11 @@ void zebra_vxlan_print_neigh_vni_vtep(st
 	memset(&wctx, 0, sizeof(struct neigh_walk_ctx));
 	wctx.zvni = zvni;
 	wctx.vty = vty;
+	wctx.addr_width = 15;
 	wctx.flags = SHOW_REMOTE_NEIGH_FROM_VTEP;
 	wctx.r_vtep_ip = vtep_ip;
 	wctx.json = json;
+	hash_iterate(zvni->neigh_table, zvni_find_neigh_addr_width, &wctx);
 	hash_iterate(zvni->neigh_table, zvni_print_neigh_hash, &wctx);
 
 	if (use_json) {
@@ -4834,7 +4904,7 @@ int zebra_vxlan_handle_kernel_neigh_del(
 		return 0;
 
 	if (!zvni->vxlan_if) {
-		zlog_err(
+		zlog_warn(
 			"VNI %u hash %p doesn't have intf upon local neighbor DEL",
 			zvni->vni, zvni);
 		return -1;
@@ -4853,7 +4923,7 @@ int zebra_vxlan_handle_kernel_neigh_del(
 	zmac = zvni_mac_lookup(zvni, &n->emac);
 	if (!zmac) {
 		if (IS_ZEBRA_DEBUG_VXLAN)
-			zlog_err(
+			zlog_warn(
 				"Trying to del a neigh %s without a mac %s on VNI %u",
 				ipaddr2str(ip, buf, sizeof(buf)),
 				prefix_mac2str(&n->emac, buf2, sizeof(buf2)),
@@ -4896,7 +4966,8 @@ int zebra_vxlan_handle_kernel_neigh_upda
 					   struct ipaddr *ip,
 					   struct ethaddr *macaddr,
 					   uint16_t state,
-					   uint8_t ext_learned)
+					   uint8_t ext_learned,
+					   uint8_t router_flag)
 {
 	char buf[ETHER_ADDR_STRLEN];
 	char buf2[INET6_ADDRSTRLEN];
@@ -4919,15 +4990,17 @@ int zebra_vxlan_handle_kernel_neigh_upda
 
 	if (IS_ZEBRA_DEBUG_VXLAN)
 		zlog_debug(
-			"Add/Update neighbor %s MAC %s intf %s(%u) state 0x%x %s-> L2-VNI %u",
+			"Add/Update neighbor %s MAC %s intf %s(%u) state 0x%x %s %s-> L2-VNI %u",
 			ipaddr2str(ip, buf2, sizeof(buf2)),
 			prefix_mac2str(macaddr, buf, sizeof(buf)), ifp->name,
 			ifp->ifindex, state, ext_learned ? "ext-learned " : "",
+			router_flag ? "router " : "",
 			zvni->vni);
 
 	/* Is this about a local neighbor or a remote one? */
 	if (!ext_learned)
-		return zvni_local_neigh_update(zvni, ifp, ip, macaddr);
+		return zvni_local_neigh_update(zvni, ifp, ip, macaddr,
+					       router_flag);
 
 	return zvni_remote_neigh_update(zvni, ifp, ip, macaddr, state);
 }
@@ -4998,7 +5071,7 @@ void zebra_vxlan_remote_macip_del(ZAPI_H
 		}
 		ifp = zvni->vxlan_if;
 		if (!ifp) {
-			zlog_err(
+			zlog_warn(
 				"VNI %u hash %p doesn't have intf upon remote MACIP DEL",
 				vni, zvni);
 			continue;
@@ -5025,9 +5098,9 @@ void zebra_vxlan_remote_macip_del(ZAPI_H
 			n = zvni_neigh_lookup(zvni, &ip);
 
 		if (n && !mac) {
-			zlog_err("Failed to locate MAC %s for neigh %s VNI %u",
-				 prefix_mac2str(&macaddr, buf, sizeof(buf)),
-				 ipaddr2str(&ip, buf1, sizeof(buf1)), vni);
+			zlog_warn("Failed to locate MAC %s for neigh %s VNI %u",
+				  prefix_mac2str(&macaddr, buf, sizeof(buf)),
+				  ipaddr2str(&ip, buf1, sizeof(buf1)), vni);
 			continue;
 		}
 
@@ -5041,7 +5114,7 @@ void zebra_vxlan_remote_macip_del(ZAPI_H
 		/* Ignore the delete if this mac is a gateway mac-ip */
 		if (mac && CHECK_FLAG(mac->flags, ZEBRA_MAC_LOCAL)
 		    && CHECK_FLAG(mac->flags, ZEBRA_MAC_DEF_GW)) {
-			zlog_err(
+			zlog_warn(
 				"%u: Ignore Del for  MAC %s neigh %s on VNI %u as it is configured as a default gateway",
 				zvrf_id(zvrf),
 				prefix_mac2str(&macaddr, buf, sizeof(buf)),
@@ -5104,6 +5177,8 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 	char buf[ETHER_ADDR_STRLEN];
 	char buf1[INET6_ADDRSTRLEN];
 	uint8_t sticky = 0;
+	uint8_t remote_gw = 0;
+	uint8_t router_flag = 0;
 	uint8_t flags = 0;
 	struct interface *ifp = NULL;
 	struct zebra_if *zif = NULL;
@@ -5143,8 +5218,10 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 		l += IPV4_MAX_BYTELEN;
 
 		/* Get flags - sticky mac and/or gateway mac */
-		flags = stream_getc(s);
+		STREAM_GETC(s, flags);
 		sticky = CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY);
+		remote_gw = CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_GW);
+		router_flag = CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_ROUTER_FLAG);
 		l++;
 
 		if (IS_ZEBRA_DEBUG_VXLAN)
@@ -5158,14 +5235,14 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 		/* Locate VNI hash entry - expected to exist. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			zlog_warn(
 				"Failed to locate VNI hash upon remote MACIP ADD, VNI %u",
 				vni);
 			continue;
 		}
 		ifp = zvni->vxlan_if;
 		if (!ifp) {
-			zlog_err(
+			zlog_warn(
 				"VNI %u hash %p doesn't have intf upon remote MACIP add",
 				vni, zvni);
 			continue;
@@ -5185,7 +5262,8 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 		zvtep = zvni_vtep_find(zvni, &vtep_ip);
 		if (!zvtep) {
 			if (zvni_vtep_add(zvni, &vtep_ip) == NULL) {
-				zlog_err(
+				flog_err(
+					ZEBRA_ERR_VTEP_ADD_FAILED,
 					"Failed to add remote VTEP, VNI %u zvni %p",
 					vni, zvni);
 				continue;
@@ -5218,6 +5296,8 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 		if (!mac || !CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE)
 		    || (CHECK_FLAG(mac->flags, ZEBRA_MAC_STICKY) ? 1 : 0)
 			       != sticky
+		    || (CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE_DEF_GW) ? 1 : 0)
+			       != remote_gw
 		    || !IPV4_ADDR_SAME(&mac->fwd_info.r_vtep_ip, &vtep_ip))
 			update_mac = 1;
 
@@ -5249,6 +5329,11 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 			else
 				UNSET_FLAG(mac->flags, ZEBRA_MAC_STICKY);
 
+			if (remote_gw)
+				SET_FLAG(mac->flags, ZEBRA_MAC_REMOTE_DEF_GW);
+			else
+				UNSET_FLAG(mac->flags, ZEBRA_MAC_REMOTE_DEF_GW);
+
 			zvni_process_neigh_on_remote_mac_add(zvni, mac);
 
 			/* Install the entry. */
@@ -5268,6 +5353,8 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 		 */
 		n = zvni_neigh_lookup(zvni, &ip);
 		if (!n || !CHECK_FLAG(n->flags, ZEBRA_NEIGH_REMOTE)
+		    || ((CHECK_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG) ? 1 : 0)
+			!= router_flag)
 		    || (memcmp(&n->emac, &macaddr, sizeof(macaddr)) != 0)
 		    || !IPV4_ADDR_SAME(&n->r_vtep_ip, &vtep_ip))
 			update_neigh = 1;
@@ -5305,6 +5392,12 @@ void zebra_vxlan_remote_macip_add(ZAPI_H
 			n->r_vtep_ip = vtep_ip;
 			SET_FLAG(n->flags, ZEBRA_NEIGH_REMOTE);
 
+			/* Set router flag (R-bit) to this Neighbor entry */
+			if (CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_ROUTER_FLAG))
+				SET_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG);
+			else
+				UNSET_FLAG(n->flags, ZEBRA_NEIGH_ROUTER_FLAG);
+
 			/* Install the entry. */
 			zvni_neigh_install(zvni, n);
 		}
@@ -5447,8 +5540,8 @@ int zebra_vxlan_local_mac_del(struct int
 	if (!zvni)
 		return 0;
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p doesn't have intf upon local MAC DEL",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p doesn't have intf upon local MAC DEL",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -5515,8 +5608,8 @@ int zebra_vxlan_local_mac_add_update(str
 	}
 
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p doesn't have intf upon local MAC ADD",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p doesn't have intf upon local MAC ADD",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -5581,9 +5674,10 @@ int zebra_vxlan_local_mac_add_update(str
 	if (!mac) {
 		mac = zvni_mac_add(zvni, macaddr);
 		if (!mac) {
-			zlog_err("Failed to add MAC %s intf %s(%u) VID %u",
-				 prefix_mac2str(macaddr, buf, sizeof(buf)),
-				 ifp->name, ifp->ifindex, vid);
+			flog_err(ZEBRA_ERR_MAC_ADD_FAILED,
+				  "Failed to add MAC %s intf %s(%u) VID %u",
+				  prefix_mac2str(macaddr, buf, sizeof(buf)),
+				  ifp->name, ifp->ifindex, vid);
 			return -1;
 		}
 	}
@@ -5633,8 +5727,8 @@ void zebra_vxlan_remote_vtep_del(ZAPI_HA
 	}
 
 	if (zvrf_id(zvrf) != VRF_DEFAULT) {
-		zlog_err("Recv MACIP DEL for non-default VRF %u",
-			 zvrf_id(zvrf));
+		zlog_warn("Recv MACIP DEL for non-default VRF %u",
+			  zvrf_id(zvrf));
 		return;
 	}
 
@@ -5665,7 +5759,7 @@ void zebra_vxlan_remote_vtep_del(ZAPI_HA
 
 		ifp = zvni->vxlan_if;
 		if (!ifp) {
-			zlog_err(
+			zlog_warn(
 				"VNI %u hash %p doesn't have intf upon remote VTEP DEL",
 				zvni->vni, zvni);
 			continue;
@@ -5717,8 +5811,8 @@ void zebra_vxlan_remote_vtep_add(ZAPI_HA
 	}
 
 	if (zvrf_id(zvrf) != VRF_DEFAULT) {
-		zlog_err("Recv MACIP ADD for non-default VRF %u",
-			 zvrf_id(zvrf));
+		zlog_warn("Recv MACIP ADD for non-default VRF %u",
+			  zvrf_id(zvrf));
 		return;
 	}
 
@@ -5739,7 +5833,8 @@ void zebra_vxlan_remote_vtep_add(ZAPI_HA
 		/* Locate VNI hash entry - expected to exist. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_VTEP_ADD_FAILED,
 				"Failed to locate VNI hash upon remote VTEP ADD, VNI %u",
 				vni);
 			continue;
@@ -5747,7 +5842,8 @@ void zebra_vxlan_remote_vtep_add(ZAPI_HA
 
 		ifp = zvni->vxlan_if;
 		if (!ifp) {
-			zlog_err(
+			flog_err(
+				ZEBRA_ERR_VTEP_ADD_FAILED,
 				"VNI %u hash %p doesn't have intf upon remote VTEP ADD",
 				zvni->vni, zvni);
 			continue;
@@ -5765,8 +5861,9 @@ void zebra_vxlan_remote_vtep_add(ZAPI_HA
 			continue;
 
 		if (zvni_vtep_add(zvni, &vtep_ip) == NULL) {
-			zlog_err("Failed to add remote VTEP, VNI %u zvni %p",
-				 vni, zvni);
+			flog_err(ZEBRA_ERR_VTEP_ADD_FAILED,
+				  "Failed to add remote VTEP, VNI %u zvni %p",
+				  vni, zvni);
 			continue;
 		}
 
@@ -5817,8 +5914,8 @@ int zebra_vxlan_add_del_gw_macip(struct
 		svi_if = if_lookup_by_index_per_ns(zebra_ns_lookup(NS_DEFAULT),
 						   ifp_zif->link_ifindex);
 		if (!svi_if) {
-			zlog_err("MACVLAN %s(%u) without link information",
-				 ifp->name, ifp->ifindex);
+			zlog_warn("MACVLAN %s(%u) without link information",
+				  ifp->name, ifp->ifindex);
 			return -1;
 		}
 
@@ -5865,8 +5962,8 @@ int zebra_vxlan_add_del_gw_macip(struct
 		return 0;
 
 	if (!zvni->vxlan_if) {
-		zlog_err("VNI %u hash %p doesn't have intf upon MACVLAN up",
-			 zvni->vni, zvni);
+		zlog_warn("VNI %u hash %p doesn't have intf upon MACVLAN up",
+			  zvni->vni, zvni);
 		return -1;
 	}
 
@@ -5962,8 +6059,9 @@ int zebra_vxlan_svi_up(struct interface
 			return 0;
 
 		if (!zvni->vxlan_if) {
-			zlog_err("VNI %u hash %p doesn't have intf upon SVI up",
-				 zvni->vni, zvni);
+			zlog_warn(
+				"VNI %u hash %p doesn't have intf upon SVI up",
+				zvni->vni, zvni);
 			return -1;
 		}
 
@@ -6024,7 +6122,7 @@ int zebra_vxlan_if_down(struct interface
 		/* Locate hash entry; it is expected to exist. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			zlog_warn(
 				"Failed to locate VNI hash at DOWN, IF %s(%u) VNI %u",
 				ifp->name, ifp->ifindex, vni);
 			return -1;
@@ -6090,7 +6188,7 @@ int zebra_vxlan_if_up(struct interface *
 		/* Locate hash entry; it is expected to exist. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			zlog_warn(
 				"Failed to locate VNI hash at UP, IF %s(%u) VNI %u",
 				ifp->name, ifp->ifindex, vni);
 			return -1;
@@ -6161,7 +6259,7 @@ int zebra_vxlan_if_del(struct interface
 		/* Locate hash entry; it is expected to exist. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			zlog_warn(
 				"Failed to locate VNI hash at del, IF %s(%u) VNI %u",
 				ifp->name, ifp->ifindex, vni);
 			return 0;
@@ -6184,8 +6282,9 @@ int zebra_vxlan_if_del(struct interface
 
 		/* Delete the hash entry. */
 		if (zvni_del(zvni)) {
-			zlog_err("Failed to del VNI hash %p, IF %s(%u) VNI %u",
-				 zvni, ifp->name, ifp->ifindex, zvni->vni);
+			flog_err(ZEBRA_ERR_VNI_DEL_FAILED,
+				  "Failed to del VNI hash %p, IF %s(%u) VNI %u",
+				  zvni, ifp->name, ifp->ifindex, zvni->vni);
 			return -1;
 		}
 	}
@@ -6271,7 +6370,7 @@ int zebra_vxlan_if_update(struct interfa
 		/* Update VNI hash. */
 		zvni = zvni_lookup(vni);
 		if (!zvni) {
-			zlog_err(
+			zlog_warn(
 				"Failed to find L2-VNI hash on update, IF %s(%u) VNI %u",
 				ifp->name, ifp->ifindex, vni);
 			return -1;
@@ -6399,7 +6498,8 @@ int zebra_vxlan_if_add(struct interface
 		if (!zvni) {
 			zvni = zvni_add(vni);
 			if (!zvni) {
-				zlog_err(
+				flog_err(
+					ZEBRA_ERR_VNI_ADD_FAILED,
 					"Failed to add VNI hash, IF %s(%u) VNI %u",
 					ifp->name, ifp->ifindex, vni);
 				return -1;
@@ -6516,6 +6616,12 @@ int zebra_vxlan_process_vrf_vni_cmd(stru
 			return -1;
 		}
 
+		if (filter && !CHECK_FLAG(zl3vni->filter, PREFIX_ROUTES_ONLY)) {
+			snprintf(err, ERR_STR_SZ,
+				 "prefix-routes-only is not set for the vni");
+			return -1;
+		}
+
 		zebra_vxlan_process_l3vni_oper_down(zl3vni);
 
 		/* delete and uninstall all rmacs */
@@ -6596,13 +6702,13 @@ void zebra_vxlan_advertise_subnet(ZAPI_H
 	struct interface *vlan_if = NULL;
 
 	if (zvrf_id(zvrf) != VRF_DEFAULT) {
-		zlog_err("EVPN GW-MACIP Adv for non-default VRF %u",
-			 zvrf_id(zvrf));
+		zlog_warn("EVPN GW-MACIP Adv for non-default VRF %u",
+			  zvrf_id(zvrf));
 		return;
 	}
 
 	s = msg;
-	advertise = stream_getc(s);
+	STREAM_GETC(s, advertise);
 	vni = stream_get3(s);
 
 	zvni = zvni_lookup(vni);
@@ -6641,6 +6747,9 @@ void zebra_vxlan_advertise_subnet(ZAPI_H
 		zvni_advertise_subnet(zvni, vlan_if, 1);
 	else
 		zvni_advertise_subnet(zvni, vlan_if, 0);
+
+stream_failure:
+	return;
 }
 
 /*
@@ -6656,14 +6765,14 @@ void zebra_vxlan_advertise_gw_macip(ZAPI
 	struct interface *ifp = NULL;
 
 	if (zvrf_id(zvrf) != VRF_DEFAULT) {
-		zlog_err("EVPN GW-MACIP Adv for non-default VRF %u",
-			 zvrf_id(zvrf));
+		zlog_warn("EVPN GW-MACIP Adv for non-default VRF %u",
+			  zvrf_id(zvrf));
 		return;
 	}
 
 	s = msg;
 	STREAM_GETC(s, advertise);
-	STREAM_GET(&vni, s, 3);
+	STREAM_GETL(s, vni);
 
 	if (!vni) {
 		if (IS_ZEBRA_DEBUG_VXLAN)
@@ -6761,7 +6870,7 @@ void zebra_vxlan_advertise_all_vni(ZAPI_
 	struct zebra_ns *zns = NULL;
 
 	if (zvrf_id(zvrf) != VRF_DEFAULT) {
-		zlog_err("EVPN VNI Adv for non-default VRF %u", zvrf_id(zvrf));
+		zlog_warn("EVPN VNI Adv for non-default VRF %u", zvrf_id(zvrf));
 		return;
 	}
 
diff -urpN frr-frr-5.0.1/zebra/zebra_vxlan.h frr-frr-6.0/zebra/zebra_vxlan.h
--- frr-frr-5.0.1/zebra/zebra_vxlan.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vxlan.h	2018-10-08 14:32:57.000000000 +0200
@@ -124,7 +124,8 @@ extern int zebra_vxlan_svi_down(struct i
 				struct interface *link_if);
 extern int zebra_vxlan_handle_kernel_neigh_update(
 	struct interface *ifp, struct interface *link_if, struct ipaddr *ip,
-	struct ethaddr *macaddr, uint16_t state, uint8_t ext_learned);
+	struct ethaddr *macaddr, uint16_t state, uint8_t ext_learned,
+	uint8_t router_flag);
 extern int zebra_vxlan_handle_kernel_neigh_del(struct interface *ifp,
 				       struct interface *link_if,
 				       struct ipaddr *ip);
@@ -160,7 +161,6 @@ extern void zebra_vxlan_evpn_vrf_route_a
 					   struct ipaddr *ip,
 					   struct prefix *host_prefix);
 extern void zebra_vxlan_evpn_vrf_route_del(vrf_id_t vrf_id,
-					   struct ethaddr *rmac,
 					   struct ipaddr *vtep_ip,
 					   struct prefix *host_prefix);
 
diff -urpN frr-frr-5.0.1/zebra/zebra_vxlan_private.h frr-frr-6.0/zebra/zebra_vxlan_private.h
--- frr-frr-5.0.1/zebra/zebra_vxlan_private.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zebra_vxlan_private.h	2018-10-08 14:32:57.000000000 +0200
@@ -215,6 +215,15 @@ static inline void zl3vni_get_rmac(zebra
 		memcpy(rmac->octet, zl3vni->svi_if->hw_addr, ETH_ALEN);
 }
 
+struct host_rb_entry {
+	RB_ENTRY(host_rb_entry) hl_entry;
+
+	struct prefix p;
+};
+
+RB_HEAD(host_rb_tree_entry, host_rb_entry);
+RB_PROTOTYPE(host_rb_tree_entry, host_rb_entry, hl_entry,
+	     host_rb_entry_compare);
 /*
  * MAC hash table.
  *
@@ -238,6 +247,8 @@ struct zebra_mac_t_ {
 #define ZEBRA_MAC_STICKY  0x08  /* Static MAC */
 #define ZEBRA_MAC_REMOTE_RMAC  0x10  /* remote router mac */
 #define ZEBRA_MAC_DEF_GW  0x20
+/* remote VTEP advertised MAC as default GW */
+#define ZEBRA_MAC_REMOTE_DEF_GW	0x40
 
 	/* Local or remote info. */
 	union {
@@ -253,7 +264,7 @@ struct zebra_mac_t_ {
 	struct list *neigh_list;
 
 	/* list of hosts pointing to this remote RMAC */
-	struct list *host_list;
+	struct host_rb_tree_entry host_rb;
 };
 
 /*
@@ -320,6 +331,7 @@ struct zebra_neigh_t_ {
 #define ZEBRA_NEIGH_REMOTE    0x02
 #define ZEBRA_NEIGH_REMOTE_NH    0x04 /* neigh entry for remote vtep */
 #define ZEBRA_NEIGH_DEF_GW    0x08
+#define ZEBRA_NEIGH_ROUTER_FLAG 0x10
 
 	enum zebra_neigh_state state;
 
@@ -327,7 +339,7 @@ struct zebra_neigh_t_ {
 	struct in_addr r_vtep_ip;
 
 	/* list of hosts pointing to this remote NH entry */
-	struct list *host_list;
+	struct host_rb_tree_entry host_rb;
 };
 
 /*
diff -urpN frr-frr-5.0.1/zebra/zserv.c frr-frr-6.0/zebra/zserv.c
--- frr-frr-5.0.1/zebra/zserv.c	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zserv.c	2018-10-08 14:32:57.000000000 +0200
@@ -52,6 +52,9 @@
 #include "lib/vty.h"              /* for vty_out, vty (ptr only) */
 #include "lib/zassert.h"          /* for assert */
 #include "lib/zclient.h"          /* for zmsghdr, ZEBRA_HEADER_SIZE, ZEBRA... */
+#include "lib/frr_pthread.h"      /* for frr_pthread_new, frr_pthread_stop... */
+#include "lib/frratomic.h"        /* for atomic_load_explicit, atomic_stor... */
+#include "lib/lib_errors.h"       /* for generic ferr ids */
 
 #include "zebra/debug.h"          /* for various debugging macros */
 #include "zebra/rib.h"            /* for rib_score_proto */
@@ -60,139 +63,74 @@
 #include "zebra/zserv.h"          /* for zserv */
 /* clang-format on */
 
-/* Event list of zebra. */
-enum event { ZEBRA_READ, ZEBRA_WRITE };
 /* privileges */
 extern struct zebra_privs_t zserv_privs;
-/* post event into client */
-static void zebra_event(struct zserv *client, enum event event);
-
-
-/* Public interface --------------------------------------------------------- */
-
-int zebra_server_send_message(struct zserv *client, struct stream *msg)
-{
-	stream_fifo_push(client->obuf_fifo, msg);
-	zebra_event(client, ZEBRA_WRITE);
-	return 0;
-}
-
-/* Lifecycle ---------------------------------------------------------------- */
-
-/* Hooks for client connect / disconnect */
-DEFINE_HOOK(zapi_client_connect, (struct zserv *client), (client));
-DEFINE_KOOH(zapi_client_close, (struct zserv *client), (client));
-
-/* free zebra client information. */
-static void zebra_client_free(struct zserv *client)
-{
-	hook_call(zapi_client_close, client);
-
-	/* Close file descriptor. */
-	if (client->sock) {
-		unsigned long nroutes;
-
-		close(client->sock);
-		nroutes = rib_score_proto(client->proto, client->instance);
-		zlog_notice(
-			"client %d disconnected. %lu %s routes removed from the rib",
-			client->sock, nroutes,
-			zebra_route_string(client->proto));
-		client->sock = -1;
-	}
-
-	/* Free stream buffers. */
-	if (client->ibuf_work)
-		stream_free(client->ibuf_work);
-	if (client->obuf_work)
-		stream_free(client->obuf_work);
-	if (client->ibuf_fifo)
-		stream_fifo_free(client->ibuf_fifo);
-	if (client->obuf_fifo)
-		stream_fifo_free(client->obuf_fifo);
-	if (client->wb)
-		buffer_free(client->wb);
-
-	/* Release threads. */
-	if (client->t_read)
-		thread_cancel(client->t_read);
-	if (client->t_write)
-		thread_cancel(client->t_write);
-	if (client->t_suicide)
-		thread_cancel(client->t_suicide);
-
-	/* Free bitmaps. */
-	for (afi_t afi = AFI_IP; afi < AFI_MAX; afi++)
-		for (int i = 0; i < ZEBRA_ROUTE_MAX; i++)
-			vrf_bitmap_free(client->redist[afi][i]);
-
-	vrf_bitmap_free(client->redist_default);
-	vrf_bitmap_free(client->ifinfo);
-	vrf_bitmap_free(client->ridinfo);
-
-	XFREE(MTYPE_TMP, client);
-}
 
 /*
- * Called from client thread to terminate itself.
+ * Client thread events.
+ *
+ * These are used almost exclusively by client threads to drive their own event
+ * loops. The only exception is in zserv_client_create(), which pushes an
+ * initial ZSERV_CLIENT_READ event to start the API handler loop.
  */
-static void zebra_client_close(struct zserv *client)
-{
-	listnode_delete(zebrad.client_list, client);
-	zebra_client_free(client);
-}
-
-/* Make new client. */
-static void zebra_client_create(int sock)
-{
-	struct zserv *client;
-	int i;
-	afi_t afi;
-
-	client = XCALLOC(MTYPE_TMP, sizeof(struct zserv));
-
-	/* Make client input/output buffer. */
-	client->sock = sock;
-	client->ibuf_fifo = stream_fifo_new();
-	client->obuf_fifo = stream_fifo_new();
-	client->ibuf_work = stream_new(ZEBRA_MAX_PACKET_SIZ);
-	client->obuf_work = stream_new(ZEBRA_MAX_PACKET_SIZ);
-	client->wb = buffer_new(0);
-
-	/* Set table number. */
-	client->rtm_table = zebrad.rtm_table_default;
-
-	client->connect_time = monotime(NULL);
-	/* Initialize flags */
-	for (afi = AFI_IP; afi < AFI_MAX; afi++)
-		for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
-			client->redist[afi][i] = vrf_bitmap_init();
-	client->redist_default = vrf_bitmap_init();
-	client->ifinfo = vrf_bitmap_init();
-	client->ridinfo = vrf_bitmap_init();
+enum zserv_client_event {
+	/* Schedule a socket read */
+	ZSERV_CLIENT_READ,
+	/* Schedule a buffer write */
+	ZSERV_CLIENT_WRITE,
+};
 
-	/* by default, it's not a synchronous client */
-	client->is_synchronous = 0;
-
-	/* Add this client to linked list. */
-	listnode_add(zebrad.client_list, client);
-
-	zebra_vrf_update_all(client);
+/*
+ * Main thread events.
+ *
+ * These are used by client threads to notify the main thread about various
+ * events and to make processing requests.
+ */
+enum zserv_event {
+	/* Schedule listen job on Zebra API socket */
+	ZSERV_ACCEPT,
+	/* The calling client has packets on its input buffer */
+	ZSERV_PROCESS_MESSAGES,
+	/* The calling client wishes to be killed */
+	ZSERV_HANDLE_CLIENT_FAIL,
+};
 
-	hook_call(zapi_client_connect, client);
+/*
+ * Zebra server event driver for all client threads.
+ *
+ * This is essentially a wrapper around thread_add_event() that centralizes
+ * those scheduling calls into one place.
+ *
+ * All calls to this function schedule an event on the pthread running the
+ * provided client.
+ *
+ * client
+ *    the client in question, and thread target
+ *
+ * event
+ *    the event to notify them about
+ */
+static void zserv_client_event(struct zserv *client,
+			       enum zserv_client_event event);
 
-	/* start read loop */
-	zebra_event(client, ZEBRA_READ);
-}
+/*
+ * Zebra server event driver for the main thread.
+ *
+ * This is essentially a wrapper around thread_add_event() that centralizes
+ * those scheduling calls into one place.
+ *
+ * All calls to this function schedule an event on Zebra's main pthread.
+ *
+ * client
+ *    the client in question
+ *
+ * event
+ *    the event to notify the main thread about
+ */
+static void zserv_event(struct zserv *client, enum zserv_event event);
 
-static int zserv_delayed_close(struct thread *thread)
-{
-	struct zserv *client = THREAD_ARG(thread);
 
-	client->t_suicide = NULL;
-	zebra_client_close(client);
-	return 0;
-}
+/* Client thread lifecycle -------------------------------------------------- */
 
 /*
  * Log zapi message to zlog.
@@ -220,185 +158,164 @@ static void zserv_log_message(const char
 	zlog_hexdump(msg->data, STREAM_READABLE(msg));
 }
 
-static int zserv_flush_data(struct thread *thread)
+/*
+ * Gracefully shut down a client connection.
+ *
+ * Cancel any pending tasks for the client's thread. Then schedule a task on
+ * the main thread to shut down the calling thread.
+ *
+ * It is not safe to close the client socket in this function. The socket is
+ * owned by the main thread.
+ *
+ * Must be called from the client pthread, never the main thread.
+ */
+static void zserv_client_fail(struct zserv *client)
 {
-	struct zserv *client = THREAD_ARG(thread);
+	zlog_warn("Client '%s' encountered an error and is shutting down.",
+		  zebra_route_string(client->proto));
 
-	client->t_write = NULL;
-	if (client->t_suicide) {
-		zebra_client_close(client);
-		return -1;
-	}
-	switch (buffer_flush_available(client->wb, client->sock)) {
-	case BUFFER_ERROR:
-		zlog_warn(
-			"%s: buffer_flush_available failed on zserv client fd %d, closing",
-			__func__, client->sock);
-		zebra_client_close(client);
-		client = NULL;
-		break;
-	case BUFFER_PENDING:
-		client->t_write = NULL;
-		thread_add_write(zebrad.master, zserv_flush_data, client,
-				 client->sock, &client->t_write);
-		break;
-	case BUFFER_EMPTY:
-		break;
-	}
+	atomic_store_explicit(&client->pthread->running, false,
+			      memory_order_relaxed);
 
-	if (client)
-		client->last_write_time = monotime(NULL);
-	return 0;
+	THREAD_OFF(client->t_read);
+	THREAD_OFF(client->t_write);
+	zserv_event(client, ZSERV_HANDLE_CLIENT_FAIL);
 }
 
 /*
- * Write a single packet.
+ * Write all pending messages to client socket.
+ *
+ * This function first attempts to flush any buffered data. If unsuccessful,
+ * the function reschedules itself and returns. If successful, it pops all
+ * available messages from the output queue and continues to write data
+ * directly to the socket until the socket would block. If the socket never
+ * blocks and all data is written, the function returns without rescheduling
+ * itself. If the socket ends up throwing EWOULDBLOCK, the remaining data is
+ * buffered and the function reschedules itself.
+ *
+ * The utility of the buffer is that it allows us to vastly reduce lock
+ * contention by allowing us to pop *all* messages off the output queue at once
+ * instead of locking and unlocking each time we want to pop a single message
+ * off the queue. The same thing could arguably be accomplished faster by
+ * allowing the main thread to write directly into the buffer instead of
+ * enqueuing packets onto an intermediary queue, but the intermediary queue
+ * allows us to expose information about input and output queues to the user in
+ * terms of number of packets rather than size of data.
  */
 static int zserv_write(struct thread *thread)
 {
 	struct zserv *client = THREAD_ARG(thread);
-	bool pending = false;
 	struct stream *msg;
-	int writerv;
+	uint32_t wcmd = 0;
+	struct stream_fifo *cache;
 
-	if (client->t_suicide)
-		return -1;
-
-	if (client->is_synchronous)
+	/* If we have any data pending, try to flush it first */
+	switch (buffer_flush_all(client->wb, client->sock)) {
+	case BUFFER_ERROR:
+		goto zwrite_fail;
+	case BUFFER_PENDING:
+		atomic_store_explicit(&client->last_write_time,
+				      (uint32_t)monotime(NULL),
+				      memory_order_relaxed);
+		zserv_client_event(client, ZSERV_CLIENT_WRITE);
 		return 0;
-
-	msg = stream_fifo_pop(client->obuf_fifo);
-	while (msg) {
-		stream_set_getp(msg, 0);
-		client->last_write_cmd = stream_getw_from(msg, 6);
-
-		writerv = buffer_write(client->wb, client->sock,
-				       STREAM_DATA(msg), stream_get_endp(msg));
-
-		stream_free(msg);
-		msg = NULL;
-		switch (writerv) {
-		case BUFFER_ERROR:
-			zlog_warn(
-				"%s: buffer_write failed to zserv client fd %d, closing",
-				__func__, client->sock);
-			/*
-			 * Schedule a delayed close since many of the
-			 * functions that call this one do not check the
-			 * return code. They do not allow for the possibility
-			 * that an I/O error may have caused the client to
-			 * be deleted.
-			 */
-			client->t_suicide = NULL;
-			thread_add_event(zebrad.master, zserv_delayed_close,
-					 client, 0, &client->t_suicide);
-			return -1;
-		case BUFFER_PENDING:
-			pending = true;
-			/* Intentional Fall-Through */
-		case BUFFER_EMPTY:
-			msg = stream_fifo_pop(client->obuf_fifo);
-			break;
-			break;
-		}
+	case BUFFER_EMPTY:
+		break;
 	}
 
-	if (pending)
-		thread_add_write(zebrad.master, zserv_flush_data, client,
-				 client->sock, &client->t_write);
-
-
-	if (client->obuf_fifo->count)
-		zebra_event(client, ZEBRA_WRITE);
+	cache = stream_fifo_new();
 
-	client->last_write_time = monotime(NULL);
-	return 0;
-}
+	pthread_mutex_lock(&client->obuf_mtx);
+	{
+		while (stream_fifo_head(client->obuf_fifo))
+			stream_fifo_push(cache,
+					 stream_fifo_pop(client->obuf_fifo));
+	}
+	pthread_mutex_unlock(&client->obuf_mtx);
 
-#if defined(HANDLE_ZAPI_FUZZING)
-static void zserv_write_incoming(struct stream *orig, uint16_t command)
-{
-	char fname[MAXPATHLEN];
-	struct stream *copy;
-	int fd = -1;
-
-	copy = stream_dup(orig);
-	stream_set_getp(copy, 0);
-
-	zserv_privs.change(ZPRIVS_RAISE);
-	snprintf(fname, MAXPATHLEN, "%s/%u", DAEMON_VTY_DIR, command);
-	fd = open(fname, O_CREAT | O_WRONLY | O_EXCL, 0644);
-	stream_flush(copy, fd);
-	close(fd);
-	zserv_privs.change(ZPRIVS_LOWER);
-	stream_free(copy);
-}
-#endif
+	if (cache->tail) {
+		msg = cache->tail;
+		stream_set_getp(msg, 0);
+		wcmd = stream_getw_from(msg, 6);
+	}
 
-static int zserv_process_messages(struct thread *thread)
-{
-	struct zserv *client = THREAD_ARG(thread);
-	struct zebra_vrf *zvrf;
-	struct zmsghdr hdr;
-	struct stream *msg;
-	bool hdrvalid;
+	while (stream_fifo_head(cache)) {
+		msg = stream_fifo_pop(cache);
+		buffer_put(client->wb, STREAM_DATA(msg), stream_get_endp(msg));
+		stream_free(msg);
+	}
 
-	do {
-		msg = stream_fifo_pop(client->ibuf_fifo);
+	stream_fifo_free(cache);
 
-		/* break if out of messages */
-		if (!msg)
-			continue;
-
-		/* read & check header */
-		hdrvalid = zapi_parse_header(msg, &hdr);
-		if (!hdrvalid && IS_ZEBRA_DEBUG_PACKET && IS_ZEBRA_DEBUG_RECV) {
-			const char *emsg = "Message has corrupt header";
-			zserv_log_message(emsg, msg, NULL);
-		}
-		if (!hdrvalid)
-			continue;
+	/* If we have any data pending, try to flush it first */
+	switch (buffer_flush_all(client->wb, client->sock)) {
+	case BUFFER_ERROR:
+		goto zwrite_fail;
+	case BUFFER_PENDING:
+		atomic_store_explicit(&client->last_write_time,
+				      (uint32_t)monotime(NULL),
+				      memory_order_relaxed);
+		zserv_client_event(client, ZSERV_CLIENT_WRITE);
+		return 0;
+	case BUFFER_EMPTY:
+		break;
+	}
 
-		hdr.length -= ZEBRA_HEADER_SIZE;
-		/* lookup vrf */
-		zvrf = zebra_vrf_lookup_by_id(hdr.vrf_id);
-		if (!zvrf && IS_ZEBRA_DEBUG_PACKET && IS_ZEBRA_DEBUG_RECV) {
-			const char *emsg = "Message specifies unknown VRF";
-			zserv_log_message(emsg, msg, &hdr);
-		}
-		if (!zvrf)
-			continue;
+	atomic_store_explicit(&client->last_write_cmd, wcmd,
+			      memory_order_relaxed);
 
-		/* process commands */
-		zserv_handle_commands(client, &hdr, msg, zvrf);
+	atomic_store_explicit(&client->last_write_time,
+			      (uint32_t)monotime(NULL), memory_order_relaxed);
 
-	} while (msg);
+	return 0;
 
+zwrite_fail:
+	zlog_warn("%s: could not write to %s [fd = %d], closing.", __func__,
+		  zebra_route_string(client->proto), client->sock);
+	zserv_client_fail(client);
 	return 0;
 }
 
-/* Handler of zebra service request. */
+/*
+ * Read and process data from a client socket.
+ *
+ * The responsibilities here are to read raw data from the client socket,
+ * validate the header, encapsulate it into a single stream object, push it
+ * onto the input queue and then notify the main thread that there is new data
+ * available.
+ *
+ * This function first looks for any data in the client structure's working
+ * input buffer. If data is present, it is assumed that reading stopped in a
+ * previous invocation of this task and needs to be resumed to finish a message.
+ * Otherwise, the socket data stream is assumed to be at the beginning of a new
+ * ZAPI message (specifically at the header). The header is read and validated.
+ * If the header passed validation then the length field found in the header is
+ * used to compute the total length of the message. That much data is read (but
+ * not inspected), appended to the header, placed into a stream and pushed onto
+ * the client's input queue. A task is then scheduled on the main thread to
+ * process the client's input queue. Finally, if all of this was successful,
+ * this task reschedules itself.
+ *
+ * Any failure in any of these actions is handled by terminating the client.
+ */
 static int zserv_read(struct thread *thread)
 {
+	struct zserv *client = THREAD_ARG(thread);
 	int sock;
-	struct zserv *client;
 	size_t already;
-#if defined(HANDLE_ZAPI_FUZZING)
-	int packets = 1;
-#else
-	int packets = zebrad.packets_to_process;
-#endif
-	/* Get thread data.  Reset reading thread because I'm running. */
-	sock = THREAD_FD(thread);
-	client = THREAD_ARG(thread);
+	struct stream_fifo *cache;
+	uint32_t p2p_orig;
 
-	if (client->t_suicide) {
-		zebra_client_close(client);
-		return -1;
-	}
+	uint32_t p2p;
+	struct zmsghdr hdr;
+
+	p2p_orig = atomic_load_explicit(&zebrad.packets_to_process,
+					memory_order_relaxed);
+	cache = stream_fifo_new();
+	p2p = p2p_orig;
+	sock = THREAD_FD(thread);
 
-	while (packets) {
-		struct zmsghdr hdr;
+	while (p2p) {
 		ssize_t nb;
 		bool hdrvalid;
 		char errmsg[256];
@@ -409,11 +326,12 @@ static int zserv_read(struct thread *thr
 		if (already < ZEBRA_HEADER_SIZE) {
 			nb = stream_read_try(client->ibuf_work, sock,
 					     ZEBRA_HEADER_SIZE - already);
-			if ((nb == 0 || nb == -1) && IS_ZEBRA_DEBUG_EVENT)
-				zlog_debug("connection closed socket [%d]",
-					   sock);
-			if ((nb == 0 || nb == -1))
+			if ((nb == 0 || nb == -1)) {
+				if (IS_ZEBRA_DEBUG_EVENT)
+					zlog_debug("connection closed socket [%d]",
+						   sock);
 				goto zread_fail;
+			}
 			if (nb != (ssize_t)(ZEBRA_HEADER_SIZE - already)) {
 				/* Try again later. */
 				break;
@@ -458,6 +376,7 @@ static int zserv_read(struct thread *thr
 				"Message has corrupt header\n%s: socket %d message length %u exceeds buffer size %lu",
 				__func__, sock, hdr.length,
 				(unsigned long)STREAM_SIZE(client->ibuf_work));
+			zserv_log_message(errmsg, client->ibuf_work, &hdr);
 			goto zread_fail;
 		}
 
@@ -465,22 +384,19 @@ static int zserv_read(struct thread *thr
 		if (already < hdr.length) {
 			nb = stream_read_try(client->ibuf_work, sock,
 					     hdr.length - already);
-			if ((nb == 0 || nb == -1) && IS_ZEBRA_DEBUG_EVENT)
-				zlog_debug(
-					"connection closed [%d] when reading zebra data",
-					sock);
-			if ((nb == 0 || nb == -1))
+			if ((nb == 0 || nb == -1)) {
+				if (IS_ZEBRA_DEBUG_EVENT)
+					zlog_debug(
+						   "connection closed [%d] when reading zebra data",
+						   sock);
 				goto zread_fail;
+			}
 			if (nb != (ssize_t)(hdr.length - already)) {
 				/* Try again later. */
 				break;
 			}
 		}
 
-#if defined(HANDLE_ZAPI_FUZZING)
-		zserv_write_incoming(client->ibuf_work, command);
-#endif
-
 		/* Debug packet information. */
 		if (IS_ZEBRA_DEBUG_EVENT)
 			zlog_debug("zebra message comes from socket [%d]",
@@ -489,55 +405,326 @@ static int zserv_read(struct thread *thr
 		if (IS_ZEBRA_DEBUG_PACKET && IS_ZEBRA_DEBUG_RECV)
 			zserv_log_message(NULL, client->ibuf_work, &hdr);
 
-		client->last_read_time = monotime(NULL);
-		client->last_read_cmd = hdr.command;
-
 		stream_set_getp(client->ibuf_work, 0);
 		struct stream *msg = stream_dup(client->ibuf_work);
 
-		stream_fifo_push(client->ibuf_fifo, msg);
+		stream_fifo_push(cache, msg);
+		stream_reset(client->ibuf_work);
+		p2p--;
+	}
 
-		if (client->t_suicide)
-			goto zread_fail;
+	if (p2p < p2p_orig) {
+		/* update session statistics */
+		atomic_store_explicit(&client->last_read_time, monotime(NULL),
+				      memory_order_relaxed);
+		atomic_store_explicit(&client->last_read_cmd, hdr.command,
+				      memory_order_relaxed);
+
+		/* publish read packets on client's input queue */
+		pthread_mutex_lock(&client->ibuf_mtx);
+		{
+			while (cache->head)
+				stream_fifo_push(client->ibuf_fifo,
+						 stream_fifo_pop(cache));
+		}
+		pthread_mutex_unlock(&client->ibuf_mtx);
+
+		/* Schedule job to process those packets */
+		zserv_event(client, ZSERV_PROCESS_MESSAGES);
 
-		--packets;
-		stream_reset(client->ibuf_work);
 	}
 
 	if (IS_ZEBRA_DEBUG_PACKET)
-		zlog_debug("Read %d packets",
-			   zebrad.packets_to_process - packets);
-
-	/* Schedule job to process those packets */
-	thread_add_event(zebrad.master, &zserv_process_messages, client, 0,
-			 NULL);
+		zlog_debug("Read %d packets", p2p_orig - p2p);
 
 	/* Reschedule ourselves */
-	zebra_event(client, ZEBRA_READ);
+	zserv_client_event(client, ZSERV_CLIENT_READ);
+
+	stream_fifo_free(cache);
 
 	return 0;
 
 zread_fail:
-	zebra_client_close(client);
+	stream_fifo_free(cache);
+	zserv_client_fail(client);
 	return -1;
 }
 
-static void zebra_event(struct zserv *client, enum event event)
+static void zserv_client_event(struct zserv *client,
+			       enum zserv_client_event event)
 {
 	switch (event) {
-	case ZEBRA_READ:
-		thread_add_read(zebrad.master, zserv_read, client, client->sock,
-				&client->t_read);
+	case ZSERV_CLIENT_READ:
+		thread_add_read(client->pthread->master, zserv_read, client,
+				client->sock, &client->t_read);
 		break;
-	case ZEBRA_WRITE:
-		thread_add_write(zebrad.master, zserv_write, client,
+	case ZSERV_CLIENT_WRITE:
+		thread_add_write(client->pthread->master, zserv_write, client,
 				 client->sock, &client->t_write);
 		break;
 	}
 }
 
-/* Accept code of zebra server socket. */
-static int zebra_accept(struct thread *thread)
+/* Main thread lifecycle ---------------------------------------------------- */
+
+/*
+ * Read and process messages from a client.
+ *
+ * This task runs on the main pthread. It is scheduled by client pthreads when
+ * they have new messages available on their input queues. The client is passed
+ * as the task argument.
+ *
+ * Each message is popped off the client's input queue and the action associated
+ * with the message is executed. This proceeds until there are no more messages,
+ * an error occurs, or the processing limit is reached.
+ *
+ * The client's I/O thread can push at most zebrad.packets_to_process messages
+ * onto the input buffer before notifying us there are packets to read. As long
+ * as we always process zebrad.packets_to_process messages here, then we can
+ * rely on the read thread to handle queuing this task enough times to process
+ * everything on the input queue.
+ */
+static int zserv_process_messages(struct thread *thread)
+{
+	struct zserv *client = THREAD_ARG(thread);
+	struct stream *msg;
+	struct stream_fifo *cache = stream_fifo_new();
+
+	uint32_t p2p = zebrad.packets_to_process;
+
+	pthread_mutex_lock(&client->ibuf_mtx);
+	{
+		uint32_t i;
+		for (i = 0; i < p2p && stream_fifo_head(client->ibuf_fifo);
+		     ++i) {
+			msg = stream_fifo_pop(client->ibuf_fifo);
+			stream_fifo_push(cache, msg);
+		}
+
+		msg = NULL;
+	}
+	pthread_mutex_unlock(&client->ibuf_mtx);
+
+	while (stream_fifo_head(cache)) {
+		msg = stream_fifo_pop(cache);
+		zserv_handle_commands(client, msg);
+		stream_free(msg);
+	}
+
+	stream_fifo_free(cache);
+
+	return 0;
+}
+
+int zserv_send_message(struct zserv *client, struct stream *msg)
+{
+	/*
+	 * This is a somewhat poorly named variable added with Zebra's portion
+	 * of the label manager. That component does not use the regular
+	 * zserv/zapi_msg interface for handling its messages, as the client
+	 * itself runs in-process. Instead it uses synchronous writes on the
+	 * zserv client's socket directly in the zread* handlers for its
+	 * message types. Furthermore, it cannot handle the usual messages
+	 * Zebra sends (such as those for interface changes) and so has added
+	 * this flag and check here as a hack to suppress all messages that it
+	 * does not explicitly know about.
+	 *
+	 * In any case this needs to be cleaned up at some point.
+	 *
+	 * See also:
+	 *    zread_label_manager_request
+	 *    zsend_label_manager_connect_response
+	 *    zsend_assign_label_chunk_response
+	 *    ...
+	 */
+	if (client->is_synchronous)
+		return 0;
+
+	pthread_mutex_lock(&client->obuf_mtx);
+	{
+		stream_fifo_push(client->obuf_fifo, msg);
+	}
+	pthread_mutex_unlock(&client->obuf_mtx);
+
+	zserv_client_event(client, ZSERV_CLIENT_WRITE);
+
+	return 0;
+}
+
+
+/* Hooks for client connect / disconnect */
+DEFINE_HOOK(zserv_client_connect, (struct zserv *client), (client));
+DEFINE_KOOH(zserv_client_close, (struct zserv *client), (client));
+
+/*
+ * Deinitialize zebra client.
+ *
+ * - Deregister and deinitialize related internal resources
+ * - Gracefully close socket
+ * - Free associated resources
+ * - Free client structure
+ *
+ * This does *not* take any action on the struct thread * fields. These are
+ * managed by the owning pthread and any tasks associated with them must have
+ * been stopped prior to invoking this function.
+ */
+static void zserv_client_free(struct zserv *client)
+{
+	hook_call(zserv_client_close, client);
+
+	/* Close file descriptor. */
+	if (client->sock) {
+		unsigned long nroutes;
+
+		close(client->sock);
+
+		nroutes = rib_score_proto(client->proto, client->instance);
+		zlog_notice(
+			"client %d disconnected. %lu %s routes removed from the rib",
+			client->sock, nroutes,
+			zebra_route_string(client->proto));
+		client->sock = -1;
+	}
+
+	/* Free stream buffers. */
+	if (client->ibuf_work)
+		stream_free(client->ibuf_work);
+	if (client->obuf_work)
+		stream_free(client->obuf_work);
+	if (client->ibuf_fifo)
+		stream_fifo_free(client->ibuf_fifo);
+	if (client->obuf_fifo)
+		stream_fifo_free(client->obuf_fifo);
+	if (client->wb)
+		buffer_free(client->wb);
+
+	/* Free buffer mutexes */
+	pthread_mutex_destroy(&client->obuf_mtx);
+	pthread_mutex_destroy(&client->ibuf_mtx);
+
+	/* Free bitmaps. */
+	for (afi_t afi = AFI_IP; afi < AFI_MAX; afi++)
+		for (int i = 0; i < ZEBRA_ROUTE_MAX; i++)
+			vrf_bitmap_free(client->redist[afi][i]);
+
+	vrf_bitmap_free(client->redist_default);
+	vrf_bitmap_free(client->ifinfo);
+	vrf_bitmap_free(client->ridinfo);
+
+	XFREE(MTYPE_TMP, client);
+}
+
+void zserv_close_client(struct zserv *client)
+{
+	/* synchronously stop and join pthread */
+	frr_pthread_stop(client->pthread, NULL);
+
+	if (IS_ZEBRA_DEBUG_EVENT)
+		zlog_debug("Closing client '%s'",
+			   zebra_route_string(client->proto));
+
+	thread_cancel_event(zebrad.master, client);
+	THREAD_OFF(client->t_cleanup);
+
+	/* destroy pthread */
+	frr_pthread_destroy(client->pthread);
+	client->pthread = NULL;
+
+	/* remove from client list */
+	listnode_delete(zebrad.client_list, client);
+
+	/* delete client */
+	zserv_client_free(client);
+}
+
+/*
+ * This task is scheduled by a ZAPI client pthread on the main pthread when it
+ * wants to stop itself. When this executes, the client connection should
+ * already have been closed and the thread will most likely have died, but its
+ * resources still need to be cleaned up.
+ */
+static int zserv_handle_client_fail(struct thread *thread)
+{
+	struct zserv *client = THREAD_ARG(thread);
+
+	zserv_close_client(client);
+	return 0;
+}
+
+/*
+ * Create a new client.
+ *
+ * This is called when a new connection is accept()'d on the ZAPI socket. It
+ * initializes new client structure, notifies any subscribers of the connection
+ * event and spawns the client's thread.
+ *
+ * sock
+ *    client's socket file descriptor
+ */
+static struct zserv *zserv_client_create(int sock)
+{
+	struct zserv *client;
+	int i;
+	afi_t afi;
+
+	client = XCALLOC(MTYPE_TMP, sizeof(struct zserv));
+
+	/* Make client input/output buffer. */
+	client->sock = sock;
+	client->ibuf_fifo = stream_fifo_new();
+	client->obuf_fifo = stream_fifo_new();
+	client->ibuf_work = stream_new(ZEBRA_MAX_PACKET_SIZ);
+	client->obuf_work = stream_new(ZEBRA_MAX_PACKET_SIZ);
+	pthread_mutex_init(&client->ibuf_mtx, NULL);
+	pthread_mutex_init(&client->obuf_mtx, NULL);
+	client->wb = buffer_new(0);
+
+	/* Set table number. */
+	client->rtm_table = zebrad.rtm_table_default;
+
+	atomic_store_explicit(&client->connect_time, (uint32_t) monotime(NULL),
+			      memory_order_relaxed);
+
+	/* Initialize flags */
+	for (afi = AFI_IP; afi < AFI_MAX; afi++)
+		for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
+			client->redist[afi][i] = vrf_bitmap_init();
+	client->redist_default = vrf_bitmap_init();
+	client->ifinfo = vrf_bitmap_init();
+	client->ridinfo = vrf_bitmap_init();
+
+	/* by default, it's not a synchronous client */
+	client->is_synchronous = 0;
+
+	/* Add this client to linked list. */
+	listnode_add(zebrad.client_list, client);
+
+	struct frr_pthread_attr zclient_pthr_attrs = {
+		.id = frr_pthread_get_id(),
+		.start = frr_pthread_attr_default.start,
+		.stop = frr_pthread_attr_default.stop
+	};
+	client->pthread =
+		frr_pthread_new(&zclient_pthr_attrs, "Zebra API client thread");
+
+	zebra_vrf_update_all(client);
+
+	/* start read loop */
+	zserv_client_event(client, ZSERV_CLIENT_READ);
+
+	/* call callbacks */
+	hook_call(zserv_client_connect, client);
+
+	/* start pthread */
+	frr_pthread_run(client->pthread, NULL);
+
+	return client;
+}
+
+/*
+ * Accept socket connection.
+ */
+static int zserv_accept(struct thread *thread)
 {
 	int accept_sock;
 	int client_sock;
@@ -547,7 +734,7 @@ static int zebra_accept(struct thread *t
 	accept_sock = THREAD_FD(thread);
 
 	/* Reregister myself. */
-	thread_add_read(zebrad.master, zebra_accept, NULL, accept_sock, NULL);
+	zserv_event(NULL, ZSERV_ACCEPT);
 
 	len = sizeof(struct sockaddr_in);
 	client_sock = accept(accept_sock, (struct sockaddr *)&client, &len);
@@ -562,16 +749,14 @@ static int zebra_accept(struct thread *t
 	set_nonblocking(client_sock);
 
 	/* Create new zebra client. */
-	zebra_client_create(client_sock);
+	zserv_client_create(client_sock);
 
 	return 0;
 }
 
-/* Make zebra server socket, wiping any existing one (see bug #403). */
-void zebra_zserv_socket_init(char *path)
+void zserv_start(char *path)
 {
 	int ret;
-	int sock;
 	mode_t old_mask;
 	struct sockaddr_storage sa;
 	socklen_t sa_len;
@@ -584,8 +769,8 @@ void zebra_zserv_socket_init(char *path)
 	old_mask = umask(0077);
 
 	/* Make UNIX domain socket. */
-	sock = socket(sa.ss_family, SOCK_STREAM, 0);
-	if (sock < 0) {
+	zebrad.sock = socket(sa.ss_family, SOCK_STREAM, 0);
+	if (zebrad.sock < 0) {
 		zlog_warn("Can't create zserv socket: %s",
 			  safe_strerror(errno));
 		zlog_warn(
@@ -594,49 +779,68 @@ void zebra_zserv_socket_init(char *path)
 	}
 
 	if (sa.ss_family != AF_UNIX) {
-		sockopt_reuseaddr(sock);
-		sockopt_reuseport(sock);
+		sockopt_reuseaddr(zebrad.sock);
+		sockopt_reuseport(zebrad.sock);
 	} else {
 		struct sockaddr_un *suna = (struct sockaddr_un *)&sa;
 		if (suna->sun_path[0])
 			unlink(suna->sun_path);
 	}
 
-	zserv_privs.change(ZPRIVS_RAISE);
-	setsockopt_so_recvbuf(sock, 1048576);
-	setsockopt_so_sendbuf(sock, 1048576);
-	zserv_privs.change(ZPRIVS_LOWER);
-
-	if (sa.ss_family != AF_UNIX && zserv_privs.change(ZPRIVS_RAISE))
-		zlog_err("Can't raise privileges");
+	frr_elevate_privs(&zserv_privs) {
+		setsockopt_so_recvbuf(zebrad.sock, 1048576);
+		setsockopt_so_sendbuf(zebrad.sock, 1048576);
+	}
 
-	ret = bind(sock, (struct sockaddr *)&sa, sa_len);
+	frr_elevate_privs((sa.ss_family != AF_UNIX) ? &zserv_privs : NULL) {
+		ret = bind(zebrad.sock, (struct sockaddr *)&sa, sa_len);
+	}
 	if (ret < 0) {
 		zlog_warn("Can't bind zserv socket on %s: %s", path,
 			  safe_strerror(errno));
 		zlog_warn(
 			"zebra can't provide full functionality due to above error");
-		close(sock);
+		close(zebrad.sock);
+		zebrad.sock = -1;
 		return;
 	}
-	if (sa.ss_family != AF_UNIX && zserv_privs.change(ZPRIVS_LOWER))
-		zlog_err("Can't lower privileges");
 
-	ret = listen(sock, 5);
+	ret = listen(zebrad.sock, 5);
 	if (ret < 0) {
 		zlog_warn("Can't listen to zserv socket %s: %s", path,
 			  safe_strerror(errno));
 		zlog_warn(
 			"zebra can't provide full functionality due to above error");
-		close(sock);
+		close(zebrad.sock);
+		zebrad.sock = -1;
 		return;
 	}
 
 	umask(old_mask);
 
-	thread_add_read(zebrad.master, zebra_accept, NULL, sock, NULL);
+	zserv_event(NULL, ZSERV_ACCEPT);
+}
+
+void zserv_event(struct zserv *client, enum zserv_event event)
+{
+	switch (event) {
+	case ZSERV_ACCEPT:
+		thread_add_read(zebrad.master, zserv_accept, NULL, zebrad.sock,
+				NULL);
+		break;
+	case ZSERV_PROCESS_MESSAGES:
+		thread_add_event(zebrad.master, zserv_process_messages, client,
+				 0, NULL);
+		break;
+	case ZSERV_HANDLE_CLIENT_FAIL:
+		thread_add_event(zebrad.master, zserv_handle_client_fail,
+				 client, 0, &client->t_cleanup);
+	}
 }
 
+
+/* General purpose ---------------------------------------------------------- */
+
 #define ZEBRA_TIME_BUF 32
 static char *zserv_time_buf(time_t *time1, char *buf, int buflen)
 {
@@ -672,6 +876,8 @@ static void zebra_show_client_detail(str
 {
 	char cbuf[ZEBRA_TIME_BUF], rbuf[ZEBRA_TIME_BUF];
 	char wbuf[ZEBRA_TIME_BUF], nhbuf[ZEBRA_TIME_BUF], mbuf[ZEBRA_TIME_BUF];
+	time_t connect_time, last_read_time, last_write_time;
+	uint16_t last_read_cmd, last_write_cmd;
 
 	vty_out(vty, "Client: %s", zebra_route_string(client->proto));
 	if (client->instance)
@@ -682,8 +888,11 @@ static void zebra_show_client_detail(str
 	vty_out(vty, "FD: %d \n", client->sock);
 	vty_out(vty, "Route Table ID: %d \n", client->rtm_table);
 
+	connect_time = (time_t) atomic_load_explicit(&client->connect_time,
+						     memory_order_relaxed);
+
 	vty_out(vty, "Connect Time: %s \n",
-		zserv_time_buf(&client->connect_time, cbuf, ZEBRA_TIME_BUF));
+		zserv_time_buf(&connect_time, cbuf, ZEBRA_TIME_BUF));
 	if (client->nh_reg_time) {
 		vty_out(vty, "Nexthop Registry Time: %s \n",
 			zserv_time_buf(&client->nh_reg_time, nhbuf,
@@ -697,16 +906,26 @@ static void zebra_show_client_detail(str
 	} else
 		vty_out(vty, "Not registered for Nexthop Updates\n");
 
+	last_read_time = (time_t)atomic_load_explicit(&client->last_read_time,
+						      memory_order_relaxed);
+	last_write_time = (time_t)atomic_load_explicit(&client->last_write_time,
+						       memory_order_relaxed);
+
+	last_read_cmd = atomic_load_explicit(&client->last_read_cmd,
+					     memory_order_relaxed);
+	last_write_cmd = atomic_load_explicit(&client->last_write_cmd,
+					      memory_order_relaxed);
+
 	vty_out(vty, "Last Msg Rx Time: %s \n",
-		zserv_time_buf(&client->last_read_time, rbuf, ZEBRA_TIME_BUF));
+		zserv_time_buf(&last_read_time, rbuf, ZEBRA_TIME_BUF));
 	vty_out(vty, "Last Msg Tx Time: %s \n",
-		zserv_time_buf(&client->last_write_time, wbuf, ZEBRA_TIME_BUF));
-	if (client->last_read_time)
+		zserv_time_buf(&last_write_time, wbuf, ZEBRA_TIME_BUF));
+	if (last_read_cmd)
 		vty_out(vty, "Last Rcvd Cmd: %s \n",
-			zserv_command_string(client->last_read_cmd));
-	if (client->last_write_time)
+			zserv_command_string(last_read_cmd));
+	if (last_write_cmd)
 		vty_out(vty, "Last Sent Cmd: %s \n",
-			zserv_command_string(client->last_write_cmd));
+			zserv_command_string(last_write_cmd));
 	vty_out(vty, "\n");
 
 	vty_out(vty, "Type        Add        Update     Del \n");
@@ -732,6 +951,11 @@ static void zebra_show_client_detail(str
 	vty_out(vty, "MAC-IP add notifications: %d\n", client->macipadd_cnt);
 	vty_out(vty, "MAC-IP delete notifications: %d\n", client->macipdel_cnt);
 
+#if defined DEV_BUILD
+	vty_out(vty, "Input Fifo: %zu:%zu Output Fifo: %zu:%zu\n",
+		client->ibuf_fifo->count, client->ibuf_fifo->max_count,
+		client->obuf_fifo->count, client->obuf_fifo->max_count);
+#endif
 	vty_out(vty, "\n");
 	return;
 }
@@ -740,19 +964,27 @@ static void zebra_show_client_brief(stru
 {
 	char cbuf[ZEBRA_TIME_BUF], rbuf[ZEBRA_TIME_BUF];
 	char wbuf[ZEBRA_TIME_BUF];
+	time_t connect_time, last_read_time, last_write_time;
+
+	connect_time = (time_t)atomic_load_explicit(&client->connect_time,
+						    memory_order_relaxed);
+	last_read_time = (time_t)atomic_load_explicit(&client->last_read_time,
+						      memory_order_relaxed);
+	last_write_time = (time_t)atomic_load_explicit(&client->last_write_time,
+						       memory_order_relaxed);
 
 	vty_out(vty, "%-8s%12s %12s%12s%8d/%-8d%8d/%-8d\n",
 		zebra_route_string(client->proto),
-		zserv_time_buf(&client->connect_time, cbuf, ZEBRA_TIME_BUF),
-		zserv_time_buf(&client->last_read_time, rbuf, ZEBRA_TIME_BUF),
-		zserv_time_buf(&client->last_write_time, wbuf, ZEBRA_TIME_BUF),
+		zserv_time_buf(&connect_time, cbuf, ZEBRA_TIME_BUF),
+		zserv_time_buf(&last_read_time, rbuf, ZEBRA_TIME_BUF),
+		zserv_time_buf(&last_write_time, wbuf, ZEBRA_TIME_BUF),
 		client->v4_route_add_cnt + client->v4_route_upd8_cnt,
 		client->v4_route_del_cnt,
 		client->v6_route_add_cnt + client->v6_route_upd8_cnt,
 		client->v6_route_del_cnt);
 }
 
-struct zserv *zebra_find_client(uint8_t proto, unsigned short instance)
+struct zserv *zserv_find_client(uint8_t proto, unsigned short instance)
 {
 	struct listnode *node, *nnode;
 	struct zserv *client;
@@ -810,19 +1042,12 @@ DEFUN (show_zebra_client_summary,
 void zserv_read_file(char *input)
 {
 	int fd;
-	struct zserv *client = NULL;
 	struct thread t;
 
-	zebra_client_create(-1);
-	client = zebrad.client_list->head->data;
-	t.arg = client;
-
 	fd = open(input, O_RDONLY | O_NONBLOCK);
 	t.u.fd = fd;
 
-	zebra_client_read(&t);
-
-	close(fd);
+	zserv_client_create(fd);
 }
 #endif
 
@@ -830,7 +1055,9 @@ void zserv_init(void)
 {
 	/* Client list init. */
 	zebrad.client_list = list_new();
-	zebrad.client_list->del = (void (*)(void *))zebra_client_free;
+
+	/* Misc init. */
+	zebrad.sock = -1;
 
 	install_element(ENABLE_NODE, &show_zebra_client_cmd);
 	install_element(ENABLE_NODE, &show_zebra_client_summary_cmd);
diff -urpN frr-frr-5.0.1/zebra/zserv.h frr-frr-6.0/zebra/zserv.h
--- frr-frr-5.0.1/zebra/zserv.h	2018-07-05 09:40:17.000000000 +0200
+++ frr-frr-6.0/zebra/zserv.h	2018-10-08 14:32:57.000000000 +0200
@@ -50,11 +50,16 @@
 
 /* Client structure. */
 struct zserv {
+	/* Client pthread */
+	struct frr_pthread *pthread;
+
 	/* Client file descriptor. */
 	int sock;
 
 	/* Input/output buffer to the client. */
+	pthread_mutex_t ibuf_mtx;
 	struct stream_fifo *ibuf_fifo;
+	pthread_mutex_t obuf_mtx;
 	struct stream_fifo *obuf_fifo;
 
 	/* Private I/O buffers */
@@ -68,8 +73,8 @@ struct zserv {
 	struct thread *t_read;
 	struct thread *t_write;
 
-	/* Thread for delayed close. */
-	struct thread *t_suicide;
+	/* Threads for the main pthread */
+	struct thread *t_cleanup;
 
 	/* default routing table this client munges */
 	int rtm_table;
@@ -129,15 +134,28 @@ struct zserv {
 	uint32_t prefixadd_cnt;
 	uint32_t prefixdel_cnt;
 
-	time_t connect_time;
-	time_t last_read_time;
-	time_t last_write_time;
 	time_t nh_reg_time;
 	time_t nh_dereg_time;
 	time_t nh_last_upd_time;
 
-	int last_read_cmd;
-	int last_write_cmd;
+	/*
+	 * Session information.
+	 *
+	 * These are not synchronous with respect to each other. For instance,
+	 * last_read_cmd may contain a value that has been read in the future
+	 * relative to last_read_time.
+	 */
+
+	/* monotime of client creation */
+	_Atomic uint32_t connect_time;
+	/* monotime of last message received */
+	_Atomic uint32_t last_read_time;
+	/* monotime of last message sent */
+	_Atomic uint32_t last_write_time;
+	/* command code of last message read */
+	_Atomic uint16_t last_read_cmd;
+	/* command code of last message written */
+	_Atomic uint16_t last_write_cmd;
 };
 
 #define ZAPI_HANDLER_ARGS                                                      \
@@ -145,8 +163,8 @@ struct zserv {
 		struct zebra_vrf *zvrf
 
 /* Hooks for client connect / disconnect */
-DECLARE_HOOK(zapi_client_connect, (struct zserv *client), (client));
-DECLARE_KOOH(zapi_client_close, (struct zserv *client), (client));
+DECLARE_HOOK(zserv_client_connect, (struct zserv *client), (client));
+DECLARE_KOOH(zserv_client_close, (struct zserv *client), (client));
 
 /* Zebra instance */
 struct zebra_t {
@@ -154,6 +172,9 @@ struct zebra_t {
 	struct thread_master *master;
 	struct list *client_list;
 
+	/* Socket */
+	int sock;
+
 	/* default table */
 	uint32_t rtm_table_default;
 
@@ -165,18 +186,66 @@ struct zebra_t {
 	/* LSP work queue */
 	struct work_queue *lsp_process_q;
 
-#define ZEBRA_ZAPI_PACKETS_TO_PROCESS 10
-	uint32_t packets_to_process;
+#define ZEBRA_ZAPI_PACKETS_TO_PROCESS 1000
+	_Atomic uint32_t packets_to_process;
 };
 extern struct zebra_t zebrad;
 extern unsigned int multipath_num;
 
-/* Prototypes. */
+/*
+ * Initialize Zebra API server.
+ *
+ * Installs CLI commands and creates the client list.
+ */
 extern void zserv_init(void);
-extern void zebra_zserv_socket_init(char *path);
-extern int zebra_server_send_message(struct zserv *client, struct stream *msg);
 
-extern struct zserv *zebra_find_client(uint8_t proto, unsigned short instance);
+/*
+ * Start Zebra API server.
+ *
+ * Allocates resources, creates the server socket and begins listening on the
+ * socket.
+ *
+ * path
+ *    where to place the Unix domain socket
+ */
+extern void zserv_start(char *path);
+
+/*
+ * Send a message to a connected Zebra API client.
+ *
+ * client
+ *    the client to send to
+ *
+ * msg
+ *    the message to send
+ */
+extern int zserv_send_message(struct zserv *client, struct stream *msg);
+
+/*
+ * Retrieve a client by its protocol and instance number.
+ *
+ * proto
+ *    protocol number
+ *
+ * instance
+ *    instance number
+ *
+ * Returns:
+ *    The Zebra API client.
+ */
+extern struct zserv *zserv_find_client(uint8_t proto, unsigned short instance);
+
+
+/*
+ * Close a client.
+ *
+ * Kills a client's thread, removes the client from the client list and cleans
+ * up its resources.
+ *
+ * client
+ *    the client to close
+ */
+extern void zserv_close_client(struct zserv *client);
 
 #if defined(HANDLE_ZAPI_FUZZING)
 extern void zserv_read_file(char *input);

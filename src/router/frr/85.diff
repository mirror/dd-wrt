diff -urpN frr-frr-8.4.2/.github/commitlint.config.js frr-frr-8.5/.github/commitlint.config.js
--- frr-frr-8.4.2/.github/commitlint.config.js	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/commitlint.config.js	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,44 @@
+module.exports = {
+	rules: {
+		'header-max-length': [2, 'always', 72],
+		'type-case': [2, 'always', 'lower-case'],
+		'type-empty': [2, 'never'],
+		'type-enum': [
+			2,
+			'always',
+			[
+				'babeld',
+				'bfdd',
+				'bgpd',
+				'doc',
+				'docker',
+				'eigrpd',
+				'fpm',
+				'isisd',
+				'ldpd',
+				'lib',
+				'multi',
+				'nhrpd',
+				'ospf6d',
+				'ospfd',
+				'pbrd',
+				'pimd',
+				'pim6d',
+				'ripd',
+				'ripngd',
+				'sharpd',
+				'staticd',
+				'tests',
+				'tools',
+				'vtysh',
+				'vrrpd',
+				'yang',
+				'zebra',
+				'all',
+			],
+		],
+		'subject-empty': [2, 'never'],
+		'subject-full-stop': [2, 'never', '.'],
+		'subject-case': [2, 'always', 'sentence-case'],
+	},
+};
diff -urpN frr-frr-8.4.2/.github/workflows/base-branch-label.yml frr-frr-8.5/.github/workflows/base-branch-label.yml
--- frr-frr-8.4.2/.github/workflows/base-branch-label.yml	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/.github/workflows/base-branch-label.yml	2023-03-13 20:01:47.000000000 +0600
@@ -8,6 +8,7 @@ on:
 
 jobs:
   label:
+    if: github.repository == 'frrouting/frr'
     runs-on: ubuntu-latest
     permissions:
       contents: read
diff -urpN frr-frr-8.4.2/.github/workflows/commitlint.yml frr-frr-8.5/.github/workflows/commitlint.yml
--- frr-frr-8.4.2/.github/workflows/commitlint.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/commitlint.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,19 @@
+name: commitlint
+
+on:
+  pull_request_target:
+    types:
+      - opened
+      - reopened
+
+jobs:
+  lint:
+    if: github.repository == 'frrouting/frr'
+    permissions:
+      contents: read
+    runs-on: ubuntu-latest
+    steps:
+      - name: Check Commit
+        uses: wagoid/commitlint-github-action@v5
+        with:
+          configFile: .github/commitlint.config.js
diff -urpN frr-frr-8.4.2/.github/workflows/conflicts.yml frr-frr-8.5/.github/workflows/conflicts.yml
--- frr-frr-8.4.2/.github/workflows/conflicts.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/conflicts.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+name: Add a conflict label is PR needs to rebase
+
+on:
+  push:
+  pull_request_target:
+    types: [synchronize]
+
+jobs:
+  conflicts:
+    if: github.repository == 'frrouting/frr'
+    runs-on: ubuntu-latest
+    permissions:
+      contents: read
+      pull-requests: write
+    steps:
+      - name: Check if PRs need a rebase (have some conflicts)
+        uses: eps1lon/actions-label-merge-conflict@releases/2.x
+        with:
+          dirtyLabel: "conflicts"
+          removeOnDirtyLabel: "no_conflicts"
+          repoToken: "${{ secrets.GITHUB_TOKEN }}"
+          commentOnDirty: "This pull request has conflicts, please resolve those before we can evaluate the pull request."
diff -urpN frr-frr-8.4.2/.github/workflows/docker-daily-master.yml frr-frr-8.5/.github/workflows/docker-daily-master.yml
--- frr-frr-8.4.2/.github/workflows/docker-daily-master.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/docker-daily-master.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,53 @@
+name: Build daily 'master' images for Docker
+
+on:
+  schedule:
+    - cron: '59 23 * * *'
+
+concurrency:
+  group: ${{ github.ref }}
+  cancel-in-progress: true
+
+jobs:
+  docker_daily_master:
+    if: github.repository == 'frrouting/frr'
+    runs-on: ubuntu-latest
+    permissions:
+      contents: read
+    steps:
+      - name: Custom variables
+        id: vars
+        run: |
+          # To package a specific git commit, the date of the commit gets
+          # appended to the latest release, e.g. 1.0.0_git20180204.
+          # This is the requirement by APKBUILD (abuild).
+          # More details: https://wiki.alpinelinux.org/wiki/APKBUILD_Reference.
+          echo ::set-output name=date::$(date +'%Y%m%d')
+
+      - name: Checkout
+        uses: actions/checkout@v3
+        with:
+          ref: master
+
+      - name: Set up QEMU
+        uses: docker/setup-qemu-action@v2
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v2
+
+      - name: Login to Docker Hub
+        uses: docker/login-action@v2
+        with:
+          registry: quay.io
+          username: ${{ secrets.QUAY_USERNAME }}
+          password: ${{ secrets.QUAY_ROBOT_TOKEN }}
+
+      - name: Build and push
+        uses: docker/build-push-action@v3
+        with:
+          context: .
+          file: ./docker/alpine/Dockerfile
+          push: true
+          tags: quay.io/frrouting/frr:master
+          build-args: PKGVER=${{ steps.vars.outputs.date }}
+          platforms: linux/amd64,linux/arm64,linux/arm/v7
diff -urpN frr-frr-8.4.2/.github/workflows/freeze.yml frr-frr-8.5/.github/workflows/freeze.yml
--- frr-frr-8.4.2/.github/workflows/freeze.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/freeze.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,17 @@
+name: Warn before merging if a "freeze" label exists
+
+on:
+  pull_request_target:
+    types: [synchronize, opened, reopened, labeled, unlabeled]
+
+jobs:
+  freeze_warning:
+    if: ${{ contains(github.event.*.labels.*.name, 'freeze') }}
+    name: Warn before merging if a "freeze" label exists
+    runs-on: ubuntu-latest
+    steps:
+      - name: Check for "freeze" label
+        run: |
+          echo "Pull request is labeled as 'freeze'"
+          echo "This workflow fails so that the pull request cannot be merged."
+          exit 1
diff -urpN frr-frr-8.4.2/.github/workflows/mergifyio_backport.yml frr-frr-8.5/.github/workflows/mergifyio_backport.yml
--- frr-frr-8.4.2/.github/workflows/mergifyio_backport.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/mergifyio_backport.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+name: Mergifyio backport
+
+on: [issue_comment]
+
+jobs:
+  mergifyio_backport:
+    if: github.repository == 'frrouting/frr'
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+
+      - uses: actions-ecosystem/action-regex-match@v2
+        id: regex-match
+        with:
+          text: ${{ github.event.comment.body }}
+          regex: '[Mm]ergifyio backport '
+
+      - uses: actions-ecosystem/action-add-labels@v1
+        if: ${{ steps.regex-match.outputs.match != '' }}
+        with:
+          github_token: ${{ secrets.GITHUB_TOKEN }}
+          labels: backport
diff -urpN frr-frr-8.4.2/.github/workflows/size-label.yml frr-frr-8.5/.github/workflows/size-label.yml
--- frr-frr-8.4.2/.github/workflows/size-label.yml	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/.github/workflows/size-label.yml	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,26 @@
+name: Add PRs size label
+
+on: pull_request_target
+
+jobs:
+  size-label:
+    if: github.repository == 'frrouting/frr'
+    runs-on: ubuntu-latest
+    permissions:
+      contents: read
+      pull-requests: write
+    steps:
+      - name: size-label
+        uses: "pascalgn/size-label-action@v0.4.2"
+        env:
+          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
+        with:
+          sizes: >
+            {
+              "0": "XS",
+              "20": "S",
+              "50": "M",
+              "200": "L",
+              "800": "XL",
+              "2000": "XXL"
+            }
diff -urpN frr-frr-8.4.2/.github/workflows/stale.yml frr-frr-8.5/.github/workflows/stale.yml
--- frr-frr-8.4.2/.github/workflows/stale.yml	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/.github/workflows/stale.yml	2023-03-13 20:01:47.000000000 +0600
@@ -10,6 +10,7 @@ permissions:
 
 jobs:
   stale:
+    if: github.repository == 'frrouting/frr'
     permissions:
       issues: write
       pull-requests: write
diff -urpN frr-frr-8.4.2/Makefile.am frr-frr-8.5/Makefile.am
--- frr-frr-8.4.2/Makefile.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/Makefile.am	2023-03-13 20:01:47.000000000 +0600
@@ -144,7 +144,6 @@ pkginclude_HEADERS =
 nodist_pkginclude_HEADERS =
 dist_yangmodels_DATA =
 man_MANS =
-vtysh_scan =
 vtysh_daemons =
 clippy_scan =
 
@@ -226,12 +225,13 @@ EXTRA_DIST += \
 	python/makefile.py \
 	python/tiabwarfo.py \
 	python/xrelfo.py \
+	python/xref2vtysh.py \
 	python/test_xrelfo.py \
 	python/runtests.py \
 	\
 	python/xrefstructs.json \
 	\
-	redhat/frr.logrotate \
+	tools/etc/logrotate.d/frr \
 	redhat/frr.pam \
 	redhat/frr.spec \
 	\
diff -urpN frr-frr-8.4.2/alpine/APKBUILD.in frr-frr-8.5/alpine/APKBUILD.in
--- frr-frr-8.4.2/alpine/APKBUILD.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/alpine/APKBUILD.in	2023-03-13 20:01:47.000000000 +0600
@@ -10,13 +10,13 @@ depends="json-c c-ares iproute2 python3
 makedepends="ncurses-dev net-snmp-dev gawk texinfo perl
     acct autoconf automake bash binutils bison bsd-compat-headers build-base
     c-ares c-ares-dev ca-certificates cryptsetup-libs curl device-mapper-libs
-    expat fakeroot flex fortify-headers gdbm git gmp isl json-c-dev kmod
+    expat fakeroot flex fortify-headers gdbm git gmp json-c-dev kmod
     lddtree libacl libatomic libattr libblkid libburn libbz2 libc-dev
     libcap-dev libcurl libedit libffi libgcc libgomp libisoburn libisofs
     libltdl libressl libssh2 libstdc++ libtool libuuid
     linux-headers lzip lzo m4 make mkinitfs mpc1 mpfr4 mtools musl-dev
-    ncurses-libs ncurses-terminfo ncurses-terminfo-base patch pax-utils pcre
-    perl pkgconf python3 python3-dev readline readline-dev sqlite-libs
+    ncurses-libs ncurses-terminfo ncurses-terminfo-base patch pax-utils pcre2
+    perl pkgconf python3 python3-dev readline readline-dev sqlite-libs pcre2-dev
     squashfs-tools sudo tar texinfo xorriso xz-libs py-pip rtrlib rtrlib-dev
     py3-sphinx elfutils elfutils-dev libyang-dev"
 checkdepends="pytest py-setuptools"
@@ -46,8 +46,9 @@ build() {
 		--enable-multipath=64 \
 		--enable-vty-group=frrvty \
 		--enable-user=$_user \
-		--enable-group=$_user
-	make
+		--enable-group=$_user \
+		--enable-pcre2posix
+	make -j $(nproc)
 }
 
 check() {
diff -urpN frr-frr-8.4.2/babeld/.gitignore frr-frr-8.5/babeld/.gitignore
--- frr-frr-8.4.2/babeld/.gitignore	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/.gitignore	2023-03-13 20:01:47.000000000 +0600
@@ -5,3 +5,4 @@
 !Makefile
 !subdir.am
 !.gitignore
+*_clippy.c
diff -urpN frr-frr-8.4.2/babeld/babel_filter.c frr-frr-8.5/babeld/babel_filter.c
--- frr-frr-8.4.2/babeld/babel_filter.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/babel_filter.c	2023-03-13 20:01:47.000000000 +0600
@@ -44,15 +44,18 @@ babel_filter(int output, const unsigned
     struct prefix_list *plist;
     int distribute;
     struct babel *babel;
+    afi_t family;
 
     p.family = v4mapped(prefix) ? AF_INET : AF_INET6;
     p.prefixlen = v4mapped(prefix) ? plen - 96 : plen;
     if (p.family == AF_INET) {
         uchar_to_inaddr(&p.u.prefix4, prefix);
         distribute = output ? DISTRIBUTE_V4_OUT : DISTRIBUTE_V4_IN;
+        family = AFI_IP;
     } else {
         uchar_to_in6addr(&p.u.prefix6, prefix);
         distribute = output ? DISTRIBUTE_V6_OUT : DISTRIBUTE_V6_IN;
+        family = AFI_IP6;
     }
 
     if (babel_ifp != NULL && babel_ifp->list[distribute]) {
@@ -79,7 +82,7 @@ babel_filter(int output, const unsigned
         dist = distribute_lookup (babel->distribute_ctx, NULL);
     if (dist) {
         if (dist->list[distribute]) {
-            alist = access_list_lookup (p.family, dist->list[distribute]);
+            alist = access_list_lookup (family, dist->list[distribute]);
 
             if (alist) {
                 if (access_list_apply (alist, &p) == FILTER_DENY) {
@@ -90,7 +93,7 @@ babel_filter(int output, const unsigned
 	    }
 	}
         if (dist->prefix[distribute]) {
-            plist = prefix_list_lookup (p.family, dist->prefix[distribute]);
+            plist = prefix_list_lookup (family, dist->prefix[distribute]);
             if (plist) {
                 if (prefix_list_apply (plist, &p) == PREFIX_DENY) {
                     debugf(BABEL_DEBUG_FILTER,"%pFX filtered by distribute %s",
diff -urpN frr-frr-8.4.2/babeld/babel_interface.c frr-frr-8.5/babeld/babel_interface.c
--- frr-frr-8.4.2/babeld/babel_interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/babel_interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -42,6 +42,10 @@ THE SOFTWARE.
 #include "xroute.h"
 #include "babel_errors.h"
 
+#ifndef VTYSH_EXTRACT_PL
+#include "babeld/babel_interface_clippy.c"
+#endif
+
 DEFINE_MTYPE_STATIC(BABELD, BABEL_IF, "Babel Interface");
 
 #define IS_ENABLE(ifp) (babel_enable_if_lookup(ifp->name) >= 0)
@@ -307,9 +311,10 @@ babel_set_wired_internal(babel_interface
 }
 
 /* [Interface Command] Tell the interface is wire. */
-DEFUN (babel_set_wired,
+DEFPY (babel_set_wired,
        babel_set_wired_cmd,
-       "babel wired",
+       "[no] babel wired",
+       NO_STR
        "Babel interface commands\n"
        "Enable wired optimizations\n")
 {
@@ -319,14 +324,15 @@ DEFUN (babel_set_wired,
     babel_ifp = babel_get_if_nfo(ifp);
 
     assert (babel_ifp != NULL);
-    babel_set_wired_internal(babel_ifp, 1);
+    babel_set_wired_internal(babel_ifp, no ? 0 : 1);
     return CMD_SUCCESS;
 }
 
 /* [Interface Command] Tell the interface is wireless (default). */
-DEFUN (babel_set_wireless,
+DEFPY (babel_set_wireless,
        babel_set_wireless_cmd,
-       "babel wireless",
+       "[no] babel wireless",
+       NO_STR
        "Babel interface commands\n"
        "Disable wired optimizations (assume wireless)\n")
 {
@@ -336,34 +342,17 @@ DEFUN (babel_set_wireless,
     babel_ifp = babel_get_if_nfo(ifp);
 
     assert (babel_ifp != NULL);
-    babel_set_wired_internal(babel_ifp, 0);
+    babel_set_wired_internal(babel_ifp, no ? 1 : 0);
     return CMD_SUCCESS;
 }
 
 /* [Interface Command] Enable split horizon. */
-DEFUN (babel_split_horizon,
+DEFPY (babel_split_horizon,
        babel_split_horizon_cmd,
-       "babel split-horizon",
-       "Babel interface commands\n"
-       "Enable split horizon processing\n")
-{
-    VTY_DECLVAR_CONTEXT(interface, ifp);
-    babel_interface_nfo *babel_ifp;
-
-    babel_ifp = babel_get_if_nfo(ifp);
-
-    assert (babel_ifp != NULL);
-    babel_ifp->flags |= BABEL_IF_SPLIT_HORIZON;
-    return CMD_SUCCESS;
-}
-
-/* [Interface Command] Disable split horizon (default). */
-DEFUN (no_babel_split_horizon,
-       no_babel_split_horizon_cmd,
-       "no babel split-horizon",
+       "[no] babel split-horizon",
        NO_STR
        "Babel interface commands\n"
-       "Disable split horizon processing\n")
+       "Enable split horizon processing\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
@@ -371,213 +360,180 @@ DEFUN (no_babel_split_horizon,
     babel_ifp = babel_get_if_nfo(ifp);
 
     assert (babel_ifp != NULL);
-    babel_ifp->flags &= ~BABEL_IF_SPLIT_HORIZON;
+    if (!no)
+        SET_FLAG(babel_ifp->flags, BABEL_IF_SPLIT_HORIZON);
+    else
+        UNSET_FLAG(babel_ifp->flags, BABEL_IF_SPLIT_HORIZON);
     return CMD_SUCCESS;
 }
 
 /* [Interface Command]. */
-DEFUN (babel_set_hello_interval,
+DEFPY (babel_set_hello_interval,
        babel_set_hello_interval_cmd,
-       "babel hello-interval (20-655340)",
+       "[no] babel hello-interval (20-655340)",
+       NO_STR
        "Babel interface commands\n"
        "Time between scheduled hellos\n"
        "Milliseconds\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int interval;
-
-    interval = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
-    babel_ifp->hello_interval = interval;
+    babel_ifp->hello_interval = no ?
+        BABEL_DEFAULT_HELLO_INTERVAL : hello_interval;
     return CMD_SUCCESS;
 }
 
 /* [Interface Command]. */
-DEFUN (babel_set_update_interval,
+DEFPY (babel_set_update_interval,
        babel_set_update_interval_cmd,
-       "babel update-interval (20-655340)",
+       "[no] babel update-interval (20-655340)",
+       NO_STR
        "Babel interface commands\n"
        "Time between scheduled updates\n"
        "Milliseconds\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int interval;
-
-    interval = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
-    babel_ifp->update_interval = interval;
+    babel_ifp->update_interval = no ?
+        BABEL_DEFAULT_UPDATE_INTERVAL : update_interval;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_rxcost,
+DEFPY (babel_set_rxcost,
        babel_set_rxcost_cmd,
-       "babel rxcost (1-65534)",
+       "[no] babel rxcost (1-65534)",
+       NO_STR
        "Babel interface commands\n"
        "Rxcost multiplier\n"
        "Units\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int rxcost;
-
-    rxcost = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
+    if (no)
+        rxcost = CHECK_FLAG(babel_ifp->flags, BABEL_IF_WIRED) ?
+            BABEL_DEFAULT_RXCOST_WIRED : BABEL_DEFAULT_RXCOST_WIRELESS;
+
     babel_ifp->cost = rxcost;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_rtt_decay,
+DEFPY (babel_set_rtt_decay,
        babel_set_rtt_decay_cmd,
-       "babel rtt-decay (1-256)",
+       "[no] babel rtt-decay (1-256)",
+       NO_STR
        "Babel interface commands\n"
        "Decay factor for exponential moving average of RTT samples\n"
        "Units of 1/256\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int decay;
-
-    decay = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
-    babel_ifp->rtt_decay = decay;
+    babel_ifp->rtt_decay = no ? BABEL_DEFAULT_RTT_DECAY : rtt_decay;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_rtt_min,
+DEFPY (babel_set_rtt_min,
        babel_set_rtt_min_cmd,
-       "babel rtt-min (1-65535)",
+       "[no] babel rtt-min (1-65535)",
+       NO_STR
        "Babel interface commands\n"
        "Minimum RTT starting for increasing cost\n"
        "Milliseconds\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int rtt;
-
-    rtt = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
     /* The value is entered in milliseconds but stored as microseconds. */
-    babel_ifp->rtt_min = rtt * 1000;
+    babel_ifp->rtt_min = no ? BABEL_DEFAULT_RTT_MIN : rtt_min * 1000;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_rtt_max,
+DEFPY (babel_set_rtt_max,
        babel_set_rtt_max_cmd,
-       "babel rtt-max (1-65535)",
+       "[no] babel rtt-max (1-65535)",
+       NO_STR
        "Babel interface commands\n"
        "Maximum RTT\n"
        "Milliseconds\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int rtt;
-
-    rtt = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
     /* The value is entered in milliseconds but stored as microseconds. */
-    babel_ifp->rtt_max = rtt * 1000;
+    babel_ifp->rtt_max = no ? BABEL_DEFAULT_RTT_MAX : rtt_max * 1000;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_max_rtt_penalty,
+DEFPY (babel_set_max_rtt_penalty,
        babel_set_max_rtt_penalty_cmd,
-       "babel max-rtt-penalty (0-65535)",
+       "[no] babel max-rtt-penalty (0-65535)",
+       NO_STR
        "Babel interface commands\n"
        "Maximum additional cost due to RTT\n"
        "Milliseconds\n")
 {
   VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
-    int penalty;
-
-    penalty = strtoul(argv[2]->arg, NULL, 10);
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
-    babel_ifp->max_rtt_penalty = penalty;
+    babel_ifp->max_rtt_penalty = no ?
+        BABEL_DEFAULT_MAX_RTT_PENALTY : max_rtt_penalty;
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_enable_timestamps,
+DEFPY (babel_set_enable_timestamps,
        babel_set_enable_timestamps_cmd,
-       "babel enable-timestamps",
-       "Babel interface commands\n"
-       "Enable timestamps\n")
-{
-    VTY_DECLVAR_CONTEXT(interface, ifp);
-    babel_interface_nfo *babel_ifp;
-
-    babel_ifp = babel_get_if_nfo(ifp);
-    assert (babel_ifp != NULL);
-
-    babel_ifp->flags |= BABEL_IF_TIMESTAMPS;
-    return CMD_SUCCESS;
-}
-
-DEFUN (no_babel_set_enable_timestamps,
-       no_babel_set_enable_timestamps_cmd,
-       "no babel enable-timestamps",
+       "[no] babel enable-timestamps",
        NO_STR
        "Babel interface commands\n"
-       "Disable timestamps\n")
+       "Enable timestamps\n")
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
 
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
-
-    babel_ifp->flags &= ~BABEL_IF_TIMESTAMPS;
+    if (!no)
+        SET_FLAG(babel_ifp->flags, BABEL_IF_TIMESTAMPS);
+    else
+        UNSET_FLAG(babel_ifp->flags, BABEL_IF_TIMESTAMPS);
     return CMD_SUCCESS;
 }
 
-DEFUN (babel_set_channel,
+DEFPY (babel_set_channel,
        babel_set_channel_cmd,
-       "babel channel (1-254)",
-       "Babel interface commands\n"
-       "Channel number for diversity routing\n"
-       "Number\n")
-{
-    VTY_DECLVAR_CONTEXT(interface, ifp);
-    babel_interface_nfo *babel_ifp;
-    int channel;
-
-    channel = strtoul(argv[2]->arg, NULL, 10);
-
-    babel_ifp = babel_get_if_nfo(ifp);
-    assert (babel_ifp != NULL);
-
-    babel_ifp->channel = channel;
-    return CMD_SUCCESS;
-}
-
-DEFUN (babel_set_channel_interfering,
-       babel_set_channel_interfering_cmd,
-       "babel channel interfering",
+       "[no] babel channel <(1-254)$ch|interfering$interfering|"
+       "noninterfering$noninterfering>",
+       NO_STR
        "Babel interface commands\n"
        "Channel number for diversity routing\n"
-       "Mark channel as interfering\n")
+       "Number\n"
+       "Mark channel as interfering\n"
+       "Mark channel as noninterfering\n"
+       )
 {
     VTY_DECLVAR_CONTEXT(interface, ifp);
     babel_interface_nfo *babel_ifp;
@@ -585,24 +541,15 @@ DEFUN (babel_set_channel_interfering,
     babel_ifp = babel_get_if_nfo(ifp);
     assert (babel_ifp != NULL);
 
-    babel_ifp->channel = BABEL_IF_CHANNEL_INTERFERING;
-    return CMD_SUCCESS;
-}
-
-DEFUN (babel_set_channel_noninterfering,
-       babel_set_channel_noninterfering_cmd,
-       "babel channel noninterfering",
-       "Babel interface commands\n"
-       "Channel number for diversity routing\n"
-       "Mark channel as noninterfering\n")
-{
-    VTY_DECLVAR_CONTEXT(interface, ifp);
-    babel_interface_nfo *babel_ifp;
-
-    babel_ifp = babel_get_if_nfo(ifp);
-    assert (babel_ifp != NULL);
+    if (no)
+        ch = CHECK_FLAG(babel_ifp->flags, BABEL_IF_WIRED) ?
+            BABEL_IF_CHANNEL_NONINTERFERING : BABEL_IF_CHANNEL_INTERFERING;
+    else if (interfering)
+        ch = BABEL_IF_CHANNEL_INTERFERING;
+    else if (noninterfering)
+        ch = BABEL_IF_CHANNEL_NONINTERFERING;
 
-    babel_ifp->channel = BABEL_IF_CHANNEL_NONINTERFERING;
+    babel_ifp->channel = ch;
     return CMD_SUCCESS;
 }
 
@@ -685,15 +632,15 @@ interface_recalculate(struct interface *
 
     rc = setsockopt(protocol_socket, IPPROTO_IPV6, IPV6_JOIN_GROUP,
                     (char*)&mreq, sizeof(mreq));
-    if(rc < 0) {
-        flog_err_sys(EC_LIB_SOCKET,
-		  "setsockopt(IPV6_JOIN_GROUP) on interface '%s': %s",
-                  ifp->name, safe_strerror(errno));
-        /* This is probably due to a missing link-local address,
-         so down this interface, and wait until the main loop
-         tries to up it again. */
-        interface_reset(ifp);
-        return -1;
+    if (rc < 0 && errno != EADDRINUSE) {
+	    flog_err_sys(EC_LIB_SOCKET,
+			 "setsockopt(IPV6_JOIN_GROUP) on interface '%s': %s",
+			 ifp->name, safe_strerror(errno));
+	    /* This is probably due to a missing link-local address,
+	     so down this interface, and wait until the main loop
+	     tries to up it again. */
+	    interface_reset(ifp);
+	    return -1;
     }
 
     set_timeout(&babel_ifp->hello_timeout, babel_ifp->hello_interval);
@@ -1239,7 +1186,6 @@ babel_if_init(void)
     install_element(BABEL_NODE, &babel_network_cmd);
     install_element(BABEL_NODE, &no_babel_network_cmd);
     install_element(INTERFACE_NODE, &babel_split_horizon_cmd);
-    install_element(INTERFACE_NODE, &no_babel_split_horizon_cmd);
     install_element(INTERFACE_NODE, &babel_set_wired_cmd);
     install_element(INTERFACE_NODE, &babel_set_wireless_cmd);
     install_element(INTERFACE_NODE, &babel_set_hello_interval_cmd);
@@ -1251,9 +1197,6 @@ babel_if_init(void)
     install_element(INTERFACE_NODE, &babel_set_rtt_max_cmd);
     install_element(INTERFACE_NODE, &babel_set_max_rtt_penalty_cmd);
     install_element(INTERFACE_NODE, &babel_set_enable_timestamps_cmd);
-    install_element(INTERFACE_NODE, &no_babel_set_enable_timestamps_cmd);
-    install_element(INTERFACE_NODE, &babel_set_channel_interfering_cmd);
-    install_element(INTERFACE_NODE, &babel_set_channel_noninterfering_cmd);
 
     /* "show babel ..." commands */
     install_element(VIEW_NODE, &show_babel_interface_cmd);
diff -urpN frr-frr-8.4.2/babeld/babel_main.c frr-frr-8.5/babeld/babel_main.c
--- frr-frr-8.4.2/babeld/babel_main.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/babel_main.c	2023-03-13 20:01:47.000000000 +0600
@@ -50,7 +50,6 @@ THE SOFTWARE.
 
 static void babel_fail(void);
 static void babel_init_random(void);
-static void babel_replace_by_null(int fd);
 static void babel_exit_properly(void);
 static void babel_save_state_file(void);
 
@@ -199,8 +198,6 @@ main(int argc, char **argv)
     resend_delay = BABEL_DEFAULT_RESEND_DELAY;
     change_smoothing_half_life(BABEL_DEFAULT_SMOOTHING_HALF_LIFE);
 
-    babel_replace_by_null(STDIN_FILENO);
-
     /* init some quagga's dependencies, and babeld's commands */
     if_zapi_callbacks(babel_ifp_create, babel_ifp_up,
 		      babel_ifp_down, babel_ifp_destroy);
@@ -248,32 +245,6 @@ babel_init_random(void)
 }
 
 /*
- close fd, and replace it by "/dev/null"
- exit if error
- */
-static void
-babel_replace_by_null(int fd)
-{
-    int fd_null;
-    int rc;
-
-    fd_null = open("/dev/null", O_RDONLY);
-    if(fd_null < 0) {
-        flog_err_sys(EC_LIB_SYSTEM_CALL, "open(null): %s", safe_strerror(errno));
-        exit(1);
-    }
-
-    rc = dup2(fd_null, fd);
-    if(rc < 0) {
-        flog_err_sys(EC_LIB_SYSTEM_CALL, "dup2(null, 0): %s",
-		  safe_strerror(errno));
-        exit(1);
-    }
-
-    close(fd_null);
-}
-
-/*
  Load the state file: check last babeld's running state, usefull in case of
  "/etc/init.d/babeld restart"
  */
diff -urpN frr-frr-8.4.2/babeld/babel_zebra.c frr-frr-8.5/babeld/babel_zebra.c
--- frr-frr-8.4.2/babeld/babel_zebra.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/babel_zebra.c	2023-03-13 20:01:47.000000000 +0600
@@ -225,6 +225,8 @@ DEFUN_NOSH (show_debugging_babel,
 
 	debug_babel_config_write(vty);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/babeld/babeld.c frr-frr-8.5/babeld/babeld.c
--- frr-frr-8.4.2/babeld/babeld.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/babeld.c	2023-03-13 20:01:47.000000000 +0600
@@ -47,6 +47,10 @@ THE SOFTWARE.
 #include "babel_zebra.h"
 #include "babel_errors.h"
 
+#ifndef VTYSH_EXTRACT_PL
+#include "babeld/babeld_clippy.c"
+#endif
+
 DEFINE_MGROUP(BABELD, "babeld");
 DEFINE_MTYPE_STATIC(BABELD, BABEL, "Babel Structure");
 
@@ -161,7 +165,7 @@ babel_create_routing_process (void)
     }
 
     /* Threads. */
-    thread_add_read(master, &babel_read_protocol, NULL, protocol_socket, &babel_routing_process->t_read);
+    thread_add_read(master, babel_read_protocol, NULL, protocol_socket, &babel_routing_process->t_read);
     /* wait a little: zebra will announce interfaces, addresses, routes... */
     thread_add_timer_msec(master, babel_init_routing_process, NULL, 200L, &babel_routing_process->t_update);
 
@@ -662,50 +666,42 @@ DEFUN (no_babel_diversity,
 }
 
 /* [Babel Command] */
-DEFUN (babel_diversity_factor,
+DEFPY (babel_diversity_factor,
        babel_diversity_factor_cmd,
-       "babel diversity-factor (1-256)",
+       "[no] babel diversity-factor (1-256)$factor",
+       NO_STR
        "Babel commands\n"
        "Set the diversity factor.\n"
        "Factor in units of 1/256.\n")
 {
-    int factor;
-
-    factor = strtoul(argv[2]->arg, NULL, 10);
-
-    diversity_factor = factor;
+    diversity_factor = no ? BABEL_DEFAULT_DIVERSITY_FACTOR : factor;
     return CMD_SUCCESS;
 }
 
 /* [Babel Command] */
-DEFUN (babel_set_resend_delay,
+DEFPY (babel_set_resend_delay,
        babel_set_resend_delay_cmd,
-       "babel resend-delay (20-655340)",
+       "[no] babel resend-delay (20-655340)$delay",
+       NO_STR
        "Babel commands\n"
        "Time before resending a message\n"
        "Milliseconds\n")
 {
-    int interval;
-
-    interval = strtoul(argv[2]->arg, NULL, 10);
-
-    resend_delay = interval;
+    resend_delay = no ? BABEL_DEFAULT_RESEND_DELAY : delay;
     return CMD_SUCCESS;
 }
 
 /* [Babel Command] */
-DEFUN (babel_set_smoothing_half_life,
+DEFPY (babel_set_smoothing_half_life,
        babel_set_smoothing_half_life_cmd,
-       "babel smoothing-half-life (0-65534)",
+       "[no] babel smoothing-half-life (0-65534)$seconds",
+       NO_STR
        "Babel commands\n"
        "Smoothing half-life\n"
        "Seconds (0 to disable)\n")
 {
-    int seconds;
-
-    seconds = strtoul(argv[2]->arg, NULL, 10);
-
-    change_smoothing_half_life(seconds);
+    change_smoothing_half_life(no ? BABEL_DEFAULT_SMOOTHING_HALF_LIFE
+        : seconds);
     return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/babeld/message.c frr-frr-8.5/babeld/message.c
--- frr-frr-8.4.2/babeld/message.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/message.c	2023-03-13 20:01:47.000000000 +0600
@@ -439,7 +439,7 @@ parse_packet(const unsigned char *from,
 			debugf(BABEL_DEBUG_COMMON,
 			       "Received Hello from %s on %s that does not have all 0's in the unused section of flags, ignoring",
 			       format_address(from), ifp->name);
-			continue;
+			goto done;
 		}
 
 		/*
@@ -451,7 +451,7 @@ parse_packet(const unsigned char *from,
 			debugf(BABEL_DEBUG_COMMON,
 			       "Received Unicast Hello from %s on %s that FRR is not prepared to understand yet",
 			       format_address(from), ifp->name);
-			continue;
+			goto done;
 		}
 
 		DO_NTOHS(seqno, message + 4);
@@ -469,7 +469,7 @@ parse_packet(const unsigned char *from,
 			debugf(BABEL_DEBUG_COMMON,
 			       "Received hello from %s on %s should be ignored as that this version of FRR does not know how to properly handle interval == 0",
 			       format_address(from), ifp->name);
-			continue;
+			goto done;
 		}
 
 		changed = update_neighbour(neigh, seqno, interval);
diff -urpN frr-frr-8.4.2/babeld/subdir.am frr-frr-8.5/babeld/subdir.am
--- frr-frr-8.4.2/babeld/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/babeld/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,11 +4,6 @@
 
 if BABELD
 sbin_PROGRAMS += babeld/babeld
-vtysh_scan += \
-	babeld/babel_interface.c \
-	babeld/babel_zebra.c \
-	babeld/babeld.c \
-	# end
 vtysh_daemons += babeld
 endif
 
@@ -48,4 +43,8 @@ noinst_HEADERS += \
 	babeld/xroute.h \
 	# end
 
+clippy_scan += \
+	babeld/babel_interface.c \
+	babeld/babeld.c
+
 babeld_babeld_LDADD = lib/libfrr.la $(LIBCAP)
diff -urpN frr-frr-8.4.2/bfdd/bfd_packet.c frr-frr-8.5/bfdd/bfd_packet.c
--- frr-frr-8.4.2/bfdd/bfd_packet.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/bfd_packet.c	2023-03-13 20:01:47.000000000 +0600
@@ -746,6 +746,7 @@ static void bfd_sd_reschedule(struct bfd
 	}
 }
 
+PRINTFRR(6, 7)
 static void cp_debug(bool mhop, struct sockaddr_any *peer,
 		     struct sockaddr_any *local, ifindex_t ifindex,
 		     vrf_id_t vrfid, const char *fmt, ...)
@@ -844,7 +845,7 @@ void bfd_recv_cb(struct thread *t)
 	/* Implement RFC 5880 6.8.6 */
 	if (mlen < BFD_PKT_LEN) {
 		cp_debug(is_mhop, &peer, &local, ifindex, vrfid,
-			 "too small (%ld bytes)", mlen);
+			 "too small (%zd bytes)", mlen);
 		return;
 	}
 
diff -urpN frr-frr-8.4.2/bfdd/bfdd_cli.c frr-frr-8.5/bfdd/bfdd_cli.c
--- frr-frr-8.4.2/bfdd/bfdd_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/bfdd_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -26,9 +26,7 @@
 #include "lib/log.h"
 #include "lib/northbound_cli.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bfdd/bfdd_cli_clippy.c"
-#endif /* VTYSH_EXTRACT_PL */
 
 #include "bfd.h"
 #include "bfdd_nb.h"
diff -urpN frr-frr-8.4.2/bfdd/bfdd_vty.c frr-frr-8.5/bfdd/bfdd_vty.c
--- frr-frr-8.4.2/bfdd/bfdd_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/bfdd_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -28,9 +28,7 @@
 
 #include "bfd.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bfdd/bfdd_vty_clippy.c"
-#endif
 
 /*
  * Commands help string definitions.
@@ -973,6 +971,8 @@ DEFUN_NOSH(show_debugging_bfd,
 	if (bglobal.debug_network)
 		vty_out(vty, "  Network layer debugging is on.\n");
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/bfdd/control.c frr-frr-8.5/bfdd/control.c
--- frr-frr-8.4.2/bfdd/control.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/control.c	2023-03-13 20:01:47.000000000 +0600
@@ -435,6 +435,15 @@ static void control_read(struct thread *
 		return;
 	}
 
+#define FRR_BFD_MAXLEN 10 * 1024
+
+	if (plen > FRR_BFD_MAXLEN) {
+		zlog_debug("%s: client closed, invalid message length: %d",
+			   __func__, bcm.bcm_length);
+		control_free(bcs);
+		return;
+	}
+
 	if (bcm.bcm_ver != BMV_VERSION_1) {
 		zlog_debug("%s: client closed due bad version: %d", __func__,
 			   bcm.bcm_ver);
diff -urpN frr-frr-8.4.2/bfdd/ptm_adapter.c frr-frr-8.5/bfdd/ptm_adapter.c
--- frr-frr-8.4.2/bfdd/ptm_adapter.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/ptm_adapter.c	2023-03-13 20:01:47.000000000 +0600
@@ -81,6 +81,7 @@ static void bfdd_client_deregister(struc
 /*
  * Functions
  */
+PRINTFRR(2, 3)
 static void debug_printbpc(const struct bfd_peer_cfg *bpc, const char *fmt, ...)
 {
 	char timers[3][128] = {};
diff -urpN frr-frr-8.4.2/bfdd/subdir.am frr-frr-8.5/bfdd/subdir.am
--- frr-frr-8.4.2/bfdd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bfdd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,8 +5,6 @@
 if BFDD
 noinst_LIBRARIES += bfdd/libbfd.a
 sbin_PROGRAMS += bfdd/bfdd
-vtysh_scan += bfdd/bfdd_vty.c
-vtysh_scan += bfdd/bfdd_cli.c
 vtysh_daemons += bfdd
 man8 += $(MANBUILD)/frr-bfdd.8
 endif
diff -urpN frr-frr-8.4.2/bgpd/bgp_addpath.c frr-frr-8.5/bgpd/bgp_addpath.c
--- frr-frr-8.4.2/bgpd/bgp_addpath.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_addpath.c	2023-03-13 20:01:47.000000000 +0600
@@ -111,6 +111,9 @@ void bgp_addpath_free_info_data(struct b
 uint32_t bgp_addpath_id_for_peer(struct peer *peer, afi_t afi, safi_t safi,
 				struct bgp_addpath_info_data *d)
 {
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
 	if (peer->addpath_type[afi][safi] < BGP_ADDPATH_MAX)
 		return d->addpath_tx_id[peer->addpath_type[afi][safi]];
 	else
@@ -182,6 +185,9 @@ static void bgp_addpath_flush_type_rn(st
 {
 	struct bgp_path_info *pi;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
 	idalloc_drain_pool(
 		bgp->tx_addpath.id_allocators[afi][safi][addpath_type],
 		&(dest->tx_addpath.free_ids[addpath_type]));
@@ -210,6 +216,9 @@ static void bgp_addpath_flush_type(struc
 {
 	struct bgp_dest *dest, *ndest;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
 	for (dest = bgp_table_top(bgp->rib[afi][safi]); dest;
 	     dest = bgp_route_next(dest)) {
 		if (safi == SAFI_MPLS_VPN) {
@@ -251,6 +260,7 @@ static void bgp_addpath_populate_path(st
  * and afi/safi combination. Since we won't waste the time computing addpath IDs
  * for unused strategies, the first time a peer is configured to use a strategy,
  * we have to backfill the data.
+ * In labeled-unicast, addpath allocations SHOULD be done in unicast SAFI.
  */
 static void bgp_addpath_populate_type(struct bgp *bgp, afi_t afi, safi_t safi,
 				    enum bgp_addpath_strat addpath_type)
@@ -259,6 +269,9 @@ static void bgp_addpath_populate_type(st
 	char buf[200];
 	struct id_alloc *allocator;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
 	snprintf(buf, sizeof(buf), "Addpath ID Allocator %s:%d/%d",
 		 bgp_addpath_names(addpath_type)->config_name, (int)afi,
 		 (int)safi);
@@ -357,11 +370,15 @@ void bgp_addpath_set_peer_type(struct pe
 			      enum bgp_addpath_strat addpath_type)
 {
 	struct bgp *bgp = peer->bgp;
-	enum bgp_addpath_strat old_type = peer->addpath_type[afi][safi];
+	enum bgp_addpath_strat old_type;
 	struct listnode *node, *nnode;
 	struct peer *tmp_peer;
 	struct peer_group *group;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
+	old_type = peer->addpath_type[afi][safi];
 	if (addpath_type == old_type)
 		return;
 
@@ -389,9 +406,9 @@ void bgp_addpath_set_peer_type(struct pe
 		}
 	}
 
-	zlog_info("Resetting peer %s%s due to change in addpath config",
+	zlog_info("Resetting peer %s%pBP due to change in addpath config",
 		  CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP) ? "group " : "",
-		  peer->host);
+		  peer);
 
 	if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
 		group = peer->group;
@@ -431,6 +448,9 @@ void bgp_addpath_update_ids(struct bgp *
 	struct bgp_path_info *pi;
 	struct id_alloc_pool **pool_ptr;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi = SAFI_UNICAST;
+
 	for (i = 0; i < BGP_ADDPATH_MAX; i++) {
 		struct id_alloc *alloc =
 			bgp->tx_addpath.id_allocators[afi][safi][i];
diff -urpN frr-frr-8.4.2/bgpd/bgp_aspath.c frr-frr-8.5/bgpd/bgp_aspath.c
--- frr-frr-8.4.2/bgpd/bgp_aspath.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_aspath.c	2023-03-13 20:01:47.000000000 +0600
@@ -1187,6 +1187,33 @@ int aspath_loop_check(struct aspath *asp
 	return count;
 }
 
+/* AS path loop check.  If aspath contains asno
+ * that is a confed id then return >= 1.
+ */
+int aspath_loop_check_confed(struct aspath *aspath, as_t asno)
+{
+	struct assegment *seg;
+	int count = 0;
+
+	if (aspath == NULL || aspath->segments == NULL)
+		return 0;
+
+	seg = aspath->segments;
+
+	while (seg) {
+		unsigned int i;
+
+		for (i = 0; i < seg->length; i++)
+			if (seg->type != AS_CONFED_SEQUENCE &&
+			    seg->type != AS_CONFED_SET && seg->as[i] == asno)
+				count++;
+
+		seg = seg->next;
+	}
+	return count;
+}
+
+
 /* When all of AS path is private AS return 1.  */
 bool aspath_private_as_check(struct aspath *aspath)
 {
@@ -2095,16 +2122,12 @@ const char *aspath_print(struct aspath *
 }
 
 /* Printing functions */
-/* Feed the AS_PATH to the vty; the suffix string follows it only in case
+/* Feed the AS_PATH to the vty; the space suffix follows it only in case
  * AS_PATH wasn't empty.
  */
-void aspath_print_vty(struct vty *vty, const char *format, struct aspath *as,
-		      const char *suffix)
+void aspath_print_vty(struct vty *vty, struct aspath *as)
 {
-	assert(format);
-	vty_out(vty, format, as->str);
-	if (as->str_len && strlen(suffix))
-		vty_out(vty, "%s", suffix);
+	vty_out(vty, "%s%s", as->str, as->str_len ? " " : "");
 }
 
 static void aspath_show_all_iterator(struct hash_bucket *bucket,
diff -urpN frr-frr-8.4.2/bgpd/bgp_aspath.h frr-frr-8.5/bgpd/bgp_aspath.h
--- frr-frr-8.4.2/bgpd/bgp_aspath.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_aspath.h	2023-03-13 20:01:47.000000000 +0600
@@ -104,13 +104,13 @@ extern void aspath_free(struct aspath *a
 extern struct aspath *aspath_intern(struct aspath *aspath);
 extern void aspath_unintern(struct aspath **aspath);
 extern const char *aspath_print(struct aspath *aspath);
-extern void aspath_print_vty(struct vty *vty, const char *format,
-			     struct aspath *aspath, const char *suffix);
+extern void aspath_print_vty(struct vty *vty, struct aspath *aspath);
 extern void aspath_print_all_vty(struct vty *vty);
 extern unsigned int aspath_key_make(const void *p);
 extern unsigned int aspath_get_first_as(struct aspath *aspath);
 extern unsigned int aspath_get_last_as(struct aspath *aspath);
 extern int aspath_loop_check(struct aspath *aspath, as_t asno);
+extern int aspath_loop_check_confed(struct aspath *aspath, as_t asno);
 extern bool aspath_private_as_check(struct aspath *aspath);
 extern struct aspath *aspath_replace_specific_asn(struct aspath *aspath,
 						  as_t target_asn,
diff -urpN frr-frr-8.4.2/bgpd/bgp_attr.c frr-frr-8.5/bgpd/bgp_attr.c
--- frr-frr-8.4.2/bgpd/bgp_attr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_attr.c	2023-03-13 20:01:47.000000000 +0600
@@ -33,6 +33,7 @@
 #include "filter.h"
 #include "command.h"
 #include "srv6.h"
+#include "frrstr.h"
 
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_attr.h"
@@ -73,7 +74,6 @@ static const struct message attr_str[] =
 	{BGP_ATTR_EXT_COMMUNITIES, "EXT_COMMUNITIES"},
 	{BGP_ATTR_AS4_PATH, "AS4_PATH"},
 	{BGP_ATTR_AS4_AGGREGATOR, "AS4_AGGREGATOR"},
-	{BGP_ATTR_AS_PATHLIMIT, "AS_PATHLIMIT"},
 	{BGP_ATTR_PMSI_TUNNEL, "PMSI_TUNNEL_ATTRIBUTE"},
 	{BGP_ATTR_ENCAP, "ENCAP"},
 	{BGP_ATTR_OTC, "OTC"},
@@ -83,6 +83,7 @@ static const struct message attr_str[] =
 	{BGP_ATTR_LARGE_COMMUNITIES, "LARGE_COMMUNITY"},
 	{BGP_ATTR_PREFIX_SID, "PREFIX_SID"},
 	{BGP_ATTR_IPV6_EXT_COMMUNITIES, "IPV6_EXT_COMMUNITIES"},
+	{BGP_ATTR_AIGP, "AIGP"},
 	{0}};
 
 static const struct message attr_flag_str[] = {
@@ -448,6 +449,110 @@ static void transit_unintern(struct tran
 	}
 }
 
+static bool bgp_attr_aigp_get_tlv_metric(uint8_t *pnt, int length,
+					 uint64_t *aigp)
+{
+	uint8_t *data = pnt;
+	uint8_t tlv_type;
+	uint16_t tlv_length;
+
+	while (length) {
+		tlv_type = *data;
+		ptr_get_be16(data + 1, &tlv_length);
+		(void)data;
+
+		/* The value field of the AIGP TLV is always 8 octets
+		 * long and its value is interpreted as an unsigned 64-bit
+		 * integer.
+		 */
+		if (tlv_type == BGP_AIGP_TLV_METRIC) {
+			(void)ptr_get_be64(data + 3, aigp);
+
+			/* If an AIGP attribute is received and its first AIGP
+			 * TLV contains the maximum value 0xffffffffffffffff,
+			 * the attribute SHOULD be considered to be malformed
+			 * and SHOULD be discarded as specified in this section.
+			 */
+			if (*aigp == BGP_AIGP_TLV_METRIC_MAX) {
+				zlog_err("Bad AIGP TLV (%s) length: %llu",
+					 BGP_AIGP_TLV_METRIC_DESC,
+					 BGP_AIGP_TLV_METRIC_MAX);
+				return false;
+			}
+
+			return true;
+		}
+
+		data += tlv_length;
+		length -= tlv_length;
+	}
+
+	return false;
+}
+
+static uint64_t bgp_aigp_metric_total(struct bgp_path_info *bpi)
+{
+	uint64_t aigp = bgp_attr_get_aigp_metric(bpi->attr);
+
+	if (bpi->nexthop)
+		return aigp + bpi->nexthop->metric;
+	else
+		return aigp;
+}
+
+static void stream_put_bgp_aigp_tlv_metric(struct stream *s,
+					   struct bgp_path_info *bpi)
+{
+	stream_putc(s, BGP_AIGP_TLV_METRIC);
+	stream_putw(s, BGP_AIGP_TLV_METRIC_LEN);
+	stream_putq(s, bgp_aigp_metric_total(bpi));
+}
+
+static bool bgp_attr_aigp_valid(uint8_t *pnt, int length)
+{
+	uint8_t *data = pnt;
+	uint8_t tlv_type;
+	uint16_t tlv_length;
+
+	if (length < 3) {
+		zlog_err("Bad AIGP attribute length (MUST be minimum 3): %u",
+			 length);
+		return false;
+	}
+
+	while (length) {
+		tlv_type = *data;
+		ptr_get_be16(data + 1, &tlv_length);
+		(void)data;
+
+		if (length < tlv_length) {
+			zlog_err(
+				"Bad AIGP attribute length: %u, but TLV length: %u",
+				length, tlv_length);
+			return false;
+		}
+
+		if (tlv_length < 3) {
+			zlog_err("Bad AIGP TLV length (MUST be minimum 3): %u",
+				 tlv_length);
+			return false;
+		}
+
+		/* AIGP TLV, Length: 11 */
+		if (tlv_type == BGP_AIGP_TLV_METRIC &&
+		    tlv_length != BGP_AIGP_TLV_METRIC_LEN) {
+			zlog_err("Bad AIGP TLV (%s) length: %u",
+				 BGP_AIGP_TLV_METRIC_DESC, tlv_length);
+			return false;
+		}
+
+		data += tlv_length;
+		length -= tlv_length;
+	}
+
+	return true;
+}
+
 static void *srv6_l3vpn_hash_alloc(void *p)
 {
 	return p;
@@ -702,6 +807,7 @@ unsigned int attrhash_key_make(const voi
 	MIX(attr->nh_type);
 	MIX(attr->bh_type);
 	MIX(attr->otc);
+	MIX(bgp_attr_get_aigp_metric(attr));
 
 	return key;
 }
@@ -736,6 +842,8 @@ bool attrhash_cmp(const void *p1, const
 			       == bgp_attr_get_cluster(attr2)
 		    && bgp_attr_get_transit(attr1)
 			       == bgp_attr_get_transit(attr2)
+		    && bgp_attr_get_aigp_metric(attr1)
+			       == bgp_attr_get_aigp_metric(attr2)
 		    && attr1->rmap_table_id == attr2->rmap_table_id
 		    && (attr1->encap_tunneltype == attr2->encap_tunneltype)
 		    && encap_same(attr1->encap_subtlvs, attr2->encap_subtlvs)
@@ -796,20 +904,20 @@ static void attrhash_finish(void)
 static void attr_show_all_iterator(struct hash_bucket *bucket, struct vty *vty)
 {
 	struct attr *attr = bucket->data;
-	char sid_str[BUFSIZ];
-
-	vty_out(vty, "attr[%ld] nexthop %pI4\n", attr->refcnt, &attr->nexthop);
+	struct in6_addr *sid = NULL;
 
-	sid_str[0] = '\0';
 	if (attr->srv6_l3vpn)
-		inet_ntop(AF_INET6, &attr->srv6_l3vpn->sid, sid_str, BUFSIZ);
+		sid = &attr->srv6_l3vpn->sid;
 	else if (attr->srv6_vpn)
-		inet_ntop(AF_INET6, &attr->srv6_vpn->sid, sid_str, BUFSIZ);
+		sid = &attr->srv6_vpn->sid;
+
+	vty_out(vty, "attr[%ld] nexthop %pI4\n", attr->refcnt, &attr->nexthop);
 
 	vty_out(vty,
-		"\tflags: %" PRIu64" distance: %u med: %u local_pref: %u origin: %u weight: %u label: %u sid: %s\n",
+		"\tflags: %" PRIu64
+		" distance: %u med: %u local_pref: %u origin: %u weight: %u label: %u sid: %pI6\n",
 		attr->flag, attr->distance, attr->med, attr->local_pref,
-		attr->origin, attr->weight, attr->label, sid_str);
+		attr->origin, attr->weight, attr->label, sid);
 }
 
 void attr_show_all(struct vty *vty)
@@ -1387,6 +1495,7 @@ const uint8_t attr_flags_values[] = {
 	[BGP_ATTR_PREFIX_SID] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,
 	[BGP_ATTR_IPV6_EXT_COMMUNITIES] =
 		BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,
+	[BGP_ATTR_AIGP] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,
 };
 static const size_t attr_flags_values_max = array_size(attr_flags_values) - 1;
 
@@ -1546,6 +1655,14 @@ static enum bgp_attr_parse_ret bgp_attr_
 	 */
 	struct aspath *aspath;
 
+	/* Refresh peer's type. If we set e.g.: AS_EXTERNAL/AS_INTERNAL,
+	 * then peer->sort remains BGP_PEER_EBGP/IBGP, hence we need to
+	 * have an actual type before checking.
+	 * This is especially a case for BGP confederation peers, to avoid
+	 * receiving and treating AS_PATH as malformed.
+	 */
+	(void)peer_sort(peer);
+
 	/* Confederation sanity check. */
 	if ((peer->sort == BGP_PEER_CONFED
 	     && !aspath_left_confed_check(attr->aspath))
@@ -1637,12 +1754,9 @@ enum bgp_attr_parse_ret bgp_attr_nexthop
 
 	if (ipv4_martian(&attr->nexthop) && !bgp->allow_martian) {
 		uint8_t data[7]; /* type(2) + length(1) + nhop(4) */
-		char buf[INET_ADDRSTRLEN];
 
-		inet_ntop(AF_INET, &attr->nexthop.s_addr, buf,
-			  INET_ADDRSTRLEN);
-		flog_err(EC_BGP_ATTR_MARTIAN_NH, "Martian nexthop %s",
-			 buf);
+		flog_err(EC_BGP_ATTR_MARTIAN_NH, "Martian nexthop %pI4",
+			 &attr->nexthop);
 		data[0] = BGP_ATTR_FLAG_TRANS;
 		data[1] = BGP_ATTR_NEXT_HOP;
 		data[2] = BGP_ATTR_NHLEN_IPV4;
@@ -1745,6 +1859,7 @@ stream_failure:
 /* Atomic aggregate. */
 static int bgp_attr_atomic(struct bgp_attr_parser_args *args)
 {
+	struct peer *const peer = args->peer;
 	struct attr *const attr = args->attr;
 	const bgp_size_t length = args->length;
 
@@ -1757,10 +1872,22 @@ static int bgp_attr_atomic(struct bgp_at
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto atomic_ignore;
+
 	/* Set atomic aggregate flag. */
 	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+atomic_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Aggregator attribute */
@@ -1786,6 +1913,9 @@ static int bgp_attr_aggregator(struct bg
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto aggregator_ignore;
+
 	if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))
 		aggregator_as = stream_getl(peer->curr);
 	else
@@ -1812,6 +1942,15 @@ static int bgp_attr_aggregator(struct bg
 	}
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+aggregator_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* New Aggregator attribute */
@@ -1832,6 +1971,9 @@ bgp_attr_as4_aggregator(struct bgp_attr_
 					  0);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto as4_aggregator_ignore;
+
 	aggregator_as = stream_getl(peer->curr);
 
 	*as4_aggregator_as = aggregator_as;
@@ -1855,6 +1997,15 @@ bgp_attr_as4_aggregator(struct bgp_attr_
 	}
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+as4_aggregator_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Munge Aggregator and New-Aggregator, AS_PATH and NEW_AS_PATH.
@@ -1974,6 +2125,9 @@ bgp_attr_community(struct bgp_attr_parse
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto community_ignore;
+
 	bgp_attr_set_community(
 		attr,
 		community_parse((uint32_t *)stream_pnt(peer->curr), length));
@@ -1989,6 +2143,15 @@ bgp_attr_community(struct bgp_attr_parse
 					  args->total);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+community_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Originator ID attribute. */
@@ -2012,11 +2175,23 @@ bgp_attr_originator_id(struct bgp_attr_p
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto originator_id_ignore;
+
 	attr->originator_id.s_addr = stream_get_ipv4(peer->curr);
 
 	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+originator_id_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Cluster list attribute. */
@@ -2039,6 +2214,9 @@ bgp_attr_cluster_list(struct bgp_attr_pa
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto cluster_list_ignore;
+
 	bgp_attr_set_cluster(
 		attr, cluster_parse((struct in_addr *)stream_pnt(peer->curr),
 				    length));
@@ -2049,6 +2227,15 @@ bgp_attr_cluster_list(struct bgp_attr_pa
 	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+cluster_list_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Multiprotocol reachability information parse. */
@@ -2308,6 +2495,9 @@ bgp_attr_large_community(struct bgp_attr
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto large_community_ignore;
+
 	bgp_attr_set_lcommunity(
 		attr, lcommunity_parse(stream_pnt(peer->curr), length));
 	/* XXX: fix ecommunity_parse to use stream API */
@@ -2318,6 +2508,15 @@ bgp_attr_large_community(struct bgp_attr
 					  args->total);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+large_community_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Extended Community attribute. */
@@ -2409,6 +2608,9 @@ bgp_attr_ipv6_ext_communities(struct bgp
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto ipv6_ext_community_ignore;
+
 	ipv6_ecomm = ecommunity_parse_ipv6(
 		stream_pnt(peer->curr), length,
 		CHECK_FLAG(peer->flags,
@@ -2423,6 +2625,15 @@ bgp_attr_ipv6_ext_communities(struct bgp
 					  args->total);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+ipv6_ext_community_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* Parse Tunnel Encap attribute in an UPDATE */
@@ -2600,6 +2811,18 @@ bgp_attr_srv6_service_data(struct bgp_at
 	}
 
 	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE) {
+		if (STREAM_READABLE(peer->curr) <
+		    BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH) {
+			flog_err(
+				EC_BGP_ATTR_LEN,
+				"Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficient data (need %u, have %zu remaining in UPDATE)",
+				BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH,
+				STREAM_READABLE(peer->curr));
+			return bgp_attr_malformed(
+				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
+				args->total);
+		}
+
 		loc_block_len = stream_getc(peer->curr);
 		loc_node_len = stream_getc(peer->curr);
 		func_len = stream_getc(peer->curr);
@@ -2649,7 +2872,6 @@ bgp_attr_srv6_service(struct bgp_attr_pa
 	uint16_t length, endpoint_behavior;
 	size_t headersz = sizeof(type) + sizeof(length);
 	enum bgp_attr_parse_ret err;
-	char buf[BUFSIZ];
 
 	if (STREAM_READABLE(peer->curr) < headersz) {
 		flog_err(
@@ -2673,6 +2895,17 @@ bgp_attr_srv6_service(struct bgp_attr_pa
 	}
 
 	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO) {
+		if (STREAM_READABLE(peer->curr) <
+		    BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH) {
+			flog_err(
+				EC_BGP_ATTR_LEN,
+				"Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %d for attribute data, have %zu remaining in UPDATE)",
+				BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH,
+				STREAM_READABLE(peer->curr));
+			return bgp_attr_malformed(
+				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
+				args->total);
+		}
 		stream_getc(peer->curr);
 		stream_get(&ipv6_sid, peer->curr, sizeof(ipv6_sid));
 		sid_flags = stream_getc(peer->curr);
@@ -2680,12 +2913,11 @@ bgp_attr_srv6_service(struct bgp_attr_pa
 		stream_getc(peer->curr);
 
 		/* Log SRv6 Service Sub-TLV */
-		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL)) {
-			inet_ntop(AF_INET6, &ipv6_sid, buf, sizeof(buf));
+		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL))
 			zlog_debug(
-				"%s: srv6-l3-srv sid %s, sid-flags 0x%02x, end-behaviour 0x%04x",
-				__func__, buf, sid_flags, endpoint_behavior);
-		}
+				"%s: srv6-l3-srv sid %pI6, sid-flags 0x%02x, end-behaviour 0x%04x",
+				__func__, &ipv6_sid, sid_flags,
+				endpoint_behavior);
 
 		/* Configure from Info */
 		if (attr->srv6_l3vpn) {
@@ -2746,7 +2978,6 @@ bgp_attr_psid_sub(uint8_t type, uint16_t
 	uint32_t srgb_range;
 	int srgb_count;
 	uint8_t sid_type, sid_flags;
-	char buf[BUFSIZ];
 
 	if (type == BGP_PREFIX_SID_LABEL_INDEX) {
 		if (STREAM_READABLE(peer->curr) < length
@@ -2877,12 +3108,10 @@ bgp_attr_psid_sub(uint8_t type, uint16_t
 			   sizeof(ipv6_sid)); /* sid_value */
 
 		/* Log VPN-SID Sub-TLV */
-		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL)) {
-			inet_ntop(AF_INET6, &ipv6_sid, buf, sizeof(buf));
+		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL))
 			zlog_debug(
-				"%s: vpn-sid: sid %s, sid-type 0x%02x sid-flags 0x%02x",
-				__func__, buf, sid_type, sid_flags);
-		}
+				"%s: vpn-sid: sid %pI6, sid-type 0x%02x sid-flags 0x%02x",
+				__func__, &ipv6_sid, sid_type, sid_flags);
 
 		/* Configure from Info */
 		if (attr->srv6_vpn) {
@@ -3053,6 +3282,52 @@ bgp_attr_pmsi_tunnel(struct bgp_attr_par
 	return BGP_ATTR_PARSE_PROCEED;
 }
 
+/* AIGP attribute (rfc7311) */
+static enum bgp_attr_parse_ret bgp_attr_aigp(struct bgp_attr_parser_args *args)
+{
+	struct peer *const peer = args->peer;
+	struct attr *const attr = args->attr;
+	const bgp_size_t length = args->length;
+	uint8_t *s = stream_pnt(peer->curr);
+	uint64_t aigp = 0;
+
+	/* If an AIGP attribute is received on a BGP session for which
+	 * AIGP_SESSION is disabled, the attribute MUST be treated exactly
+	 * as if it were an unrecognized non-transitive attribute.
+	 * That is, it "MUST be quietly ignored and not passed along to
+	 * other BGP peers".
+	 * For Internal BGP (IBGP) sessions, and for External BGP (EBGP)
+	 * sessions between members of the same BGP Confederation,
+	 * the default value of AIGP_SESSION SHOULD be "enabled".
+	 */
+	if (peer->sort == BGP_PEER_EBGP &&
+	    !CHECK_FLAG(peer->flags, PEER_FLAG_AIGP)) {
+		zlog_warn(
+			"%pBP received AIGP attribute, but eBGP peer do not support it",
+			peer);
+		goto aigp_ignore;
+	}
+
+	if (peer->discard_attrs[args->type])
+		goto aigp_ignore;
+
+	if (!bgp_attr_aigp_valid(s, length))
+		goto aigp_ignore;
+
+	/* Extract AIGP Metric TLV */
+	if (bgp_attr_aigp_get_tlv_metric(s, length, &aigp))
+		bgp_attr_set_aigp_metric(attr, aigp);
+
+aigp_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
+}
+
 /* OTC attribute. */
 static enum bgp_attr_parse_ret bgp_attr_otc(struct bgp_attr_parser_args *args)
 {
@@ -3068,6 +3343,9 @@ static enum bgp_attr_parse_ret bgp_attr_
 					  args->total);
 	}
 
+	if (peer->discard_attrs[args->type])
+		goto otc_ignore;
+
 	attr->otc = stream_getl(peer->curr);
 	if (!attr->otc) {
 		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "OTC attribute value is 0");
@@ -3078,6 +3356,15 @@ static enum bgp_attr_parse_ret bgp_attr_
 	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_OTC);
 
 	return BGP_ATTR_PARSE_PROCEED;
+
+otc_ignore:
+	stream_forward_getp(peer->curr, length);
+
+	if (bgp_debug_update(peer, NULL, NULL, 1))
+		zlog_debug("%pBP: Ignoring attribute %s", peer,
+			   lookup_msg(attr_str, args->type, NULL));
+
+	return BGP_ATTR_PARSE_PROCEED;
 }
 
 /* BGP unknown attribute treatment. */
@@ -3101,6 +3388,14 @@ bgp_attr_unknown(struct bgp_attr_parser_
 	/* Forward read pointer of input stream. */
 	stream_forward_getp(peer->curr, length);
 
+	if (peer->discard_attrs[type]) {
+		if (bgp_debug_update(peer, NULL, NULL, 1))
+			zlog_debug("%pBP: Ignoring attribute %s", peer,
+				   lookup_msg(attr_str, args->type, NULL));
+
+		return BGP_ATTR_PARSE_PROCEED;
+	}
+
 	/* If any of the mandatory well-known attributes are not recognized,
 	   then the Error Subcode is set to Unrecognized Well-known
 	   Attribute.  The Data field contains the unrecognized attribute
@@ -3431,6 +3726,9 @@ enum bgp_attr_parse_ret bgp_attr_parse(s
 		case BGP_ATTR_OTC:
 			ret = bgp_attr_otc(&attr_args);
 			break;
+		case BGP_ATTR_AIGP:
+			ret = bgp_attr_aigp(&attr_args);
+			break;
 		default:
 			ret = bgp_attr_unknown(&attr_args);
 			break;
@@ -3710,7 +4008,10 @@ size_t bgp_packet_mpattr_start(struct st
 				stream_putc(s, attr->mp_nexthop_len);
 				stream_put_ipv4(s, attr->nexthop.s_addr);
 			}
-		default:
+			break;
+		case SAFI_UNSPEC:
+		case SAFI_MAX:
+			assert(!"SAFI's UNSPEC or MAX being specified are a DEV ESCAPE");
 			break;
 		}
 		break;
@@ -3735,23 +4036,21 @@ size_t bgp_packet_mpattr_start(struct st
 			}
 		} break;
 		case SAFI_MPLS_VPN: {
-			if (attr->mp_nexthop_len
-				   == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {
-				stream_putc(s, 48);
-				stream_putl(s, 0); /* RD = 0, per RFC */
-				stream_putl(s, 0);
-				stream_put(s, &attr->mp_nexthop_global,
-					   IPV6_MAX_BYTELEN);
+			if (attr->mp_nexthop_len ==
+			    BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL)
+				stream_putc(s, attr->mp_nexthop_len);
+			else
+				stream_putc(s, BGP_ATTR_NHLEN_VPNV6_GLOBAL);
+			stream_putl(s, 0); /* RD = 0, per RFC */
+			stream_putl(s, 0);
+			stream_put(s, &attr->mp_nexthop_global,
+				   IPV6_MAX_BYTELEN);
+			if (attr->mp_nexthop_len ==
+			    BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {
 				stream_putl(s, 0); /* RD = 0, per RFC */
 				stream_putl(s, 0);
 				stream_put(s, &attr->mp_nexthop_local,
 					   IPV6_MAX_BYTELEN);
-			} else {
-				stream_putc(s, 24);
-				stream_putl(s, 0); /* RD = 0, per RFC */
-				stream_putl(s, 0);
-				stream_put(s, &attr->mp_nexthop_global,
-					   IPV6_MAX_BYTELEN);
 			}
 		} break;
 		case SAFI_ENCAP:
@@ -3761,17 +4060,24 @@ size_t bgp_packet_mpattr_start(struct st
 			break;
 		case SAFI_FLOWSPEC:
 			stream_putc(s, 0); /* no nexthop for flowspec */
-		default:
+			break;
+		case SAFI_UNSPEC:
+		case SAFI_MAX:
+			assert(!"SAFI's UNSPEC or MAX being specified are a DEV ESCAPE");
 			break;
 		}
 		break;
-	default:
+	case AFI_L2VPN:
 		if (safi != SAFI_FLOWSPEC)
 			flog_err(
 				EC_BGP_ATTR_NH_SEND_LEN,
 				"Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d",
 				peer->host, afi, safi, attr->mp_nexthop_len);
 		break;
+	case AFI_UNSPEC:
+	case AFI_MAX:
+		assert(!"DEV ESCAPE: AFI_UNSPEC or AFI_MAX should not be used here");
+		break;
 	}
 
 	/* SNPA */
@@ -3785,7 +4091,12 @@ void bgp_packet_mpattr_prefix(struct str
 			      uint32_t num_labels, bool addpath_capable,
 			      uint32_t addpath_tx_id, struct attr *attr)
 {
-	if (safi == SAFI_MPLS_VPN) {
+	switch (safi) {
+	case SAFI_UNSPEC:
+	case SAFI_MAX:
+		assert(!"Dev escape usage of SAFI_UNSPEC or MAX");
+		break;
+	case SAFI_MPLS_VPN:
 		if (addpath_capable)
 			stream_putl(s, addpath_tx_id);
 		/* Label, RD, Prefix write. */
@@ -3793,33 +4104,74 @@ void bgp_packet_mpattr_prefix(struct str
 		stream_put(s, label, BGP_LABEL_BYTES);
 		stream_put(s, prd->val, 8);
 		stream_put(s, &p->u.prefix, PSIZE(p->prefixlen));
-	} else if (afi == AFI_L2VPN && safi == SAFI_EVPN) {
-		/* EVPN prefix - contents depend on type */
-		bgp_evpn_encode_prefix(s, p, prd, label, num_labels, attr,
-				       addpath_capable, addpath_tx_id);
-	} else if (safi == SAFI_LABELED_UNICAST) {
+		break;
+	case SAFI_EVPN:
+		if (afi == AFI_L2VPN)
+			/* EVPN prefix - contents depend on type */
+			bgp_evpn_encode_prefix(s, p, prd, label, num_labels,
+					       attr, addpath_capable,
+					       addpath_tx_id);
+		else
+			assert(!"Add encoding bits here for other AFI's");
+		break;
+	case SAFI_LABELED_UNICAST:
 		/* Prefix write with label. */
 		stream_put_labeled_prefix(s, p, label, addpath_capable,
 					  addpath_tx_id);
-	} else if (safi == SAFI_FLOWSPEC) {
+		break;
+	case SAFI_FLOWSPEC:
 		stream_putc(s, p->u.prefix_flowspec.prefixlen);
 		stream_put(s, (const void *)p->u.prefix_flowspec.ptr,
 			   p->u.prefix_flowspec.prefixlen);
-	} else
+		break;
+
+	case SAFI_UNICAST:
+	case SAFI_MULTICAST:
 		stream_put_prefix_addpath(s, p, addpath_capable, addpath_tx_id);
+		break;
+	case SAFI_ENCAP:
+		assert(!"Please add proper encoding of SAFI_ENCAP");
+		break;
+	}
 }
 
 size_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi,
 				     const struct prefix *p)
 {
 	int size = PSIZE(p->prefixlen);
-	if (safi == SAFI_MPLS_VPN)
+
+	switch (safi) {
+	case SAFI_UNSPEC:
+	case SAFI_MAX:
+		assert(!"Attempting to figure size for a SAFI_UNSPEC/SAFI_MAX this is a DEV ESCAPE");
+		break;
+	case SAFI_UNICAST:
+	case SAFI_MULTICAST:
+		break;
+	case SAFI_MPLS_VPN:
 		size += 88;
-	else if (safi == SAFI_LABELED_UNICAST)
+		break;
+	case SAFI_ENCAP:
+		/* This has to be wrong, but I don't know what to put here */
+		assert(!"Do we try to use this?");
+		break;
+	case SAFI_LABELED_UNICAST:
 		size += BGP_LABEL_BYTES;
-	else if (afi == AFI_L2VPN && safi == SAFI_EVPN)
-		size += 232; // TODO: Maximum possible for type-2, type-3 and
-			     // type-5
+		break;
+	case SAFI_EVPN:
+		/*
+		 * TODO: Maximum possible for type-2, type-3 and type-5
+		 */
+		if (afi == AFI_L2VPN)
+			size += 232;
+		else
+			assert(!"Attempting to figure size for SAFI_EVPN and !AFI_L2VPN and FRR will not have the proper values");
+		break;
+	case SAFI_FLOWSPEC:
+		size = ((struct prefix_fs *)p)->prefix.prefixlen;
+		break;
+	}
+
 	return size;
 }
 
@@ -3950,7 +4302,8 @@ bgp_size_t bgp_packet_attribute(struct b
 				struct prefix *p, afi_t afi, safi_t safi,
 				struct peer *from, struct prefix_rd *prd,
 				mpls_label_t *label, uint32_t num_labels,
-				bool addpath_capable, uint32_t addpath_tx_id)
+				bool addpath_capable, uint32_t addpath_tx_id,
+				struct bgp_path_info *bpi)
 {
 	size_t cp;
 	size_t aspath_sizep;
@@ -4002,8 +4355,21 @@ bgp_size_t bgp_packet_attribute(struct b
 		aspath = aspath_delete_confed_seq(aspath);
 
 		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {
-			/* Stuff our path CONFED_ID on the front */
-			aspath = aspath_add_seq(aspath, bgp->confed_id);
+			/* A confed member, so we need to do the
+			 * AS_CONFED_SEQUENCE thing if it's outside a common
+			 * administration.
+			 * Configured confederation peers MUST be validated
+			 * under BGP_PEER_CONFED, but if we have configured
+			 * remote-as as AS_EXTERNAL, we need to check again
+			 * if the peer belongs to us.
+			 */
+			if (bgp_confederation_peers_check(bgp, peer->as)) {
+				aspath = aspath_add_confed_seq(aspath,
+							       peer->local_as);
+			} else {
+				/* Stuff our path CONFED_ID on the front */
+				aspath = aspath_add_seq(aspath, bgp->confed_id);
+			}
 		} else {
 			if (peer->change_local_as) {
 				/* If replace-as is specified, we only use the
@@ -4354,7 +4720,9 @@ bgp_size_t bgp_packet_attribute(struct b
 			stream_put(s, &attr->srv6_l3vpn->sid,
 				   sizeof(attr->srv6_l3vpn->sid)); /* sid */
 			stream_putc(s, 0);      /* sid_flags */
-			stream_putw(s, 0xffff); /* endpoint */
+			stream_putw(s,
+				    attr->srv6_l3vpn
+					    ->endpoint_behavior); /* endpoint */
 			stream_putc(s, 0);      /* reserved */
 			stream_putc(
 				s,
@@ -4456,6 +4824,22 @@ bgp_size_t bgp_packet_attribute(struct b
 		stream_putl(s, attr->otc);
 	}
 
+	/* AIGP */
+	if (bpi && attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AIGP) &&
+	    (CHECK_FLAG(peer->flags, PEER_FLAG_AIGP) ||
+	     peer->sort != BGP_PEER_EBGP)) {
+		/* At the moment only AIGP Metric TLV exists for AIGP
+		 * attribute. If more comes in, do not forget to update
+		 * attr_len variable to include new ones.
+		 */
+		uint8_t attr_len = BGP_AIGP_TLV_METRIC_LEN;
+
+		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
+		stream_putc(s, BGP_ATTR_AIGP);
+		stream_putc(s, attr_len);
+		stream_put_bgp_aigp_tlv_metric(s, bpi);
+	}
+
 	/* Unknown transit attribute. */
 	struct transit *transit = bgp_attr_get_transit(attr);
 
@@ -4539,7 +4923,7 @@ void bgp_attr_finish(void)
 }
 
 /* Make attribute packet. */
-void bgp_dump_routes_attr(struct stream *s, struct attr *attr,
+void bgp_dump_routes_attr(struct stream *s, struct bgp_path_info *bpi,
 			  const struct prefix *prefix)
 {
 	unsigned long cp;
@@ -4548,6 +4932,7 @@ void bgp_dump_routes_attr(struct stream
 	struct aspath *aspath;
 	bool addpath_capable = false;
 	uint32_t addpath_tx_id = 0;
+	struct attr *attr = bpi->attr;
 
 	/* Remember current pointer. */
 	cp = stream_get_endp(s);
@@ -4711,7 +5096,91 @@ void bgp_dump_routes_attr(struct stream
 		stream_putl(s, attr->otc);
 	}
 
+	/* AIGP */
+	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AIGP)) {
+		/* At the moment only AIGP Metric TLV exists for AIGP
+		 * attribute. If more comes in, do not forget to update
+		 * attr_len variable to include new ones.
+		 */
+		uint8_t attr_len = BGP_AIGP_TLV_METRIC_LEN;
+
+		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
+		stream_putc(s, BGP_ATTR_AIGP);
+		stream_putc(s, attr_len);
+		stream_put_bgp_aigp_tlv_metric(s, bpi);
+	}
+
 	/* Return total size of attribute. */
 	len = stream_get_endp(s) - cp - 2;
 	stream_putw_at(s, cp, len);
 }
+
+void bgp_path_attribute_discard_vty(struct vty *vty, struct peer *peer,
+				    const char *discard_attrs, bool set)
+{
+	int i, num_attributes;
+	char **attributes;
+	afi_t afi;
+	safi_t safi;
+
+
+	/* If `no` command specified without arbitrary attributes,
+	 * then flush all.
+	 */
+	if (!discard_attrs) {
+		for (i = 0; i < BGP_ATTR_MAX; i++)
+			peer->discard_attrs[i] = false;
+		goto discard_soft_clear;
+	}
+
+	if (discard_attrs) {
+		frrstr_split(discard_attrs, " ", &attributes, &num_attributes);
+
+		if (set)
+			for (i = 0; i < BGP_ATTR_MAX; i++)
+				peer->discard_attrs[i] = false;
+
+		for (i = 0; i < num_attributes; i++) {
+			uint8_t attr_num = strtoul(attributes[i], NULL, 10);
+
+			XFREE(MTYPE_TMP, attributes[i]);
+
+			/* Some of the attributes, just can't be ignored. */
+			if (attr_num == BGP_ATTR_ORIGIN ||
+			    attr_num == BGP_ATTR_AS_PATH ||
+			    attr_num == BGP_ATTR_NEXT_HOP ||
+			    attr_num == BGP_ATTR_MULTI_EXIT_DISC ||
+			    attr_num == BGP_ATTR_MP_REACH_NLRI ||
+			    attr_num == BGP_ATTR_MP_UNREACH_NLRI ||
+			    attr_num == BGP_ATTR_EXT_COMMUNITIES) {
+				vty_out(vty,
+					"%% Can't discard path-attribute %s, ignoring.\n",
+					lookup_msg(attr_str, attr_num, NULL));
+				continue;
+			}
+
+			/* Ignore local-pref, originator-id, cluster-list only
+			 * for eBGP.
+			 */
+			if (peer->sort != BGP_PEER_EBGP &&
+			    (attr_num == BGP_ATTR_LOCAL_PREF ||
+			     attr_num == BGP_ATTR_ORIGINATOR_ID ||
+			     attr_num == BGP_ATTR_CLUSTER_LIST)) {
+				vty_out(vty,
+					"%% Can discard path-attribute %s only for eBGP, ignoring.\n",
+					lookup_msg(attr_str, attr_num, NULL));
+				continue;
+			}
+
+			peer->discard_attrs[attr_num] = set;
+		}
+		XFREE(MTYPE_TMP, attributes);
+	discard_soft_clear:
+		/* Configuring path attributes to be discarded will trigger
+		 * an inbound Route Refresh to ensure that the routing table
+		 * is up to date.
+		 */
+		FOREACH_AFI_SAFI (afi, safi)
+			peer_clear_soft(peer, afi, safi, BGP_CLEAR_SOFT_IN);
+	}
+}
diff -urpN frr-frr-8.4.2/bgpd/bgp_attr.h frr-frr-8.5/bgpd/bgp_attr.h
--- frr-frr-8.4.2/bgpd/bgp_attr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_attr.h	2023-03-13 20:01:47.000000000 +0600
@@ -80,14 +80,6 @@
 #define BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE 1
 #define BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH 6
 
-/* SRv6 SID Structure default values */
-#define BGP_PREFIX_SID_SRV6_LOCATOR_BLOCK_LENGTH 40
-#define BGP_PREFIX_SID_SRV6_LOCATOR_NODE_LENGTH 24
-#define BGP_PREFIX_SID_SRV6_FUNCTION_LENGTH 16
-#define BGP_PREFIX_SID_SRV6_ARGUMENT_LENGTH 0
-#define BGP_PREFIX_SID_SRV6_TRANSPOSITION_LENGTH 16
-#define BGP_PREFIX_SID_SRV6_TRANSPOSITION_OFFSET 64
-
 #define BGP_ATTR_NH_AFI(afi, attr) \
 	((afi != AFI_L2VPN) ? afi : \
 	((attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV4) ? AFI_IP : AFI_IP6))
@@ -337,6 +329,9 @@ struct attr {
 
 	/* OTC value if set */
 	uint32_t otc;
+
+	/* AIGP Metric */
+	uint64_t aigp_metric;
 };
 
 /* rmap_change_flags definition */
@@ -349,6 +344,8 @@ struct attr {
 #define BATTR_RMAP_IPV6_PREFER_GLOBAL_CHANGED (1 << 6)
 #define BATTR_RMAP_LINK_BW_SET (1 << 7)
 #define BATTR_RMAP_L3VPN_ACCEPT_GRE (1 << 8)
+#define BATTR_RMAP_VPNV4_NHOP_CHANGED (1 << 9)
+#define BATTR_RMAP_VPNV6_GLOBAL_NHOP_CHANGED (1 << 10)
 
 /* Router Reflector related structure. */
 struct cluster_list {
@@ -404,21 +401,21 @@ extern struct attr *bgp_attr_aggregate_i
 	struct community *community, struct ecommunity *ecommunity,
 	struct lcommunity *lcommunity, struct bgp_aggregate *aggregate,
 	uint8_t atomic_aggregate, const struct prefix *p);
-extern bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,
-				       struct stream *s, struct attr *attr,
-				       struct bpacket_attr_vec_arr *vecarr,
-				       struct prefix *p, afi_t afi, safi_t safi,
-				       struct peer *from, struct prefix_rd *prd,
-				       mpls_label_t *label, uint32_t num_labels,
-				       bool addpath_capable,
-				       uint32_t addpath_tx_id);
-extern void bgp_dump_routes_attr(struct stream *s, struct attr *attr,
+extern bgp_size_t bgp_packet_attribute(
+	struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr,
+	struct bpacket_attr_vec_arr *vecarr, struct prefix *p, afi_t afi,
+	safi_t safi, struct peer *from, struct prefix_rd *prd,
+	mpls_label_t *label, uint32_t num_labels, bool addpath_capable,
+	uint32_t addpath_tx_id, struct bgp_path_info *bpi);
+extern void bgp_dump_routes_attr(struct stream *s, struct bgp_path_info *bpi,
 				 const struct prefix *p);
 extern bool attrhash_cmp(const void *arg1, const void *arg2);
 extern unsigned int attrhash_key_make(const void *p);
 extern void attr_show_all(struct vty *vty);
 extern unsigned long int attr_count(void);
 extern unsigned long int attr_unknown_count(void);
+extern void bgp_path_attribute_discard_vty(struct vty *vty, struct peer *peer,
+					   const char *discard_attrs, bool set);
 
 /* Cluster list prototypes. */
 extern bool cluster_loop_check(struct cluster_list *cluster,
@@ -480,20 +477,23 @@ extern void bgp_packet_mpunreach_end(str
 extern enum bgp_attr_parse_ret bgp_attr_nexthop_valid(struct peer *peer,
 						      struct attr *attr);
 
-static inline int bgp_rmap_nhop_changed(uint32_t out_rmap_flags,
-					uint32_t in_rmap_flags)
+static inline bool bgp_rmap_nhop_changed(uint32_t out_rmap_flags,
+					 uint32_t in_rmap_flags)
 {
-	return ((CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_PEER_ADDRESS)
-		 || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED)
-		 || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV4_NHOP_CHANGED)
-		 || CHECK_FLAG(out_rmap_flags,
-			       BATTR_RMAP_IPV6_GLOBAL_NHOP_CHANGED)
-		 || CHECK_FLAG(out_rmap_flags,
-			       BATTR_RMAP_IPV6_PREFER_GLOBAL_CHANGED)
-		 || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV6_LL_NHOP_CHANGED)
-		 || CHECK_FLAG(in_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED))
-			? 1
-			: 0);
+	return ((CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_PEER_ADDRESS) ||
+		 CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED) ||
+		 CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV4_NHOP_CHANGED) ||
+		 CHECK_FLAG(out_rmap_flags, BATTR_RMAP_VPNV4_NHOP_CHANGED) ||
+		 CHECK_FLAG(out_rmap_flags,
+			    BATTR_RMAP_VPNV6_GLOBAL_NHOP_CHANGED) ||
+		 CHECK_FLAG(out_rmap_flags,
+			    BATTR_RMAP_IPV6_GLOBAL_NHOP_CHANGED) ||
+		 CHECK_FLAG(out_rmap_flags,
+			    BATTR_RMAP_IPV6_PREFER_GLOBAL_CHANGED) ||
+		 CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV6_LL_NHOP_CHANGED) ||
+		 CHECK_FLAG(in_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED))
+			? true
+			: false);
 }
 
 static inline uint32_t mac_mobility_seqnum(struct attr *attr)
@@ -593,6 +593,19 @@ static inline void bgp_attr_set_transit(
 	attr->transit = transit;
 }
 
+static inline uint64_t bgp_attr_get_aigp_metric(const struct attr *attr)
+{
+	return attr->aigp_metric;
+}
+
+static inline void bgp_attr_set_aigp_metric(struct attr *attr, uint64_t aigp)
+{
+	attr->aigp_metric = aigp;
+
+	if (aigp)
+		attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AIGP);
+}
+
 static inline struct cluster_list *bgp_attr_get_cluster(const struct attr *attr)
 {
 	return attr->cluster1;
diff -urpN frr-frr-8.4.2/bgpd/bgp_bfd.c frr-frr-8.5/bgpd/bgp_bfd.c
--- frr-frr-8.4.2/bgpd/bgp_bfd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_bfd.c	2023-03-13 20:01:47.000000000 +0600
@@ -521,10 +521,8 @@ DEFUN (neighbor_bfd_check_controlplane_f
 	else
 		idx_peer = 1;
 	peer = peer_and_group_lookup_vty(vty, argv[idx_peer]->arg);
-	if (!peer) {
-		vty_out(vty, "%% Specify remote-as or peer-group commands first\n");
+	if (!peer)
 		return CMD_WARNING_CONFIG_FAILED;
-	}
 
 	if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))
 		bgp_group_configure_bfd(peer);
diff -urpN frr-frr-8.4.2/bgpd/bgp_bmp.c frr-frr-8.5/bgpd/bgp_bmp.c
--- frr-frr-8.4.2/bgpd/bgp_bmp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_bmp.c	2023-03-13 20:01:47.000000000 +0600
@@ -853,8 +853,9 @@ static struct stream *bmp_update(const s
 	stream_putw(s, 0);
 
 	/* 5: Encode all the attributes, except MP_REACH_NLRI attr. */
-	total_attr_len = bgp_packet_attribute(NULL, peer, s, attr,
-			&vecarr, NULL, afi, safi, peer, NULL, NULL, 0, 0, 0);
+	total_attr_len =
+		bgp_packet_attribute(NULL, peer, s, attr, &vecarr, NULL, afi,
+				     safi, peer, NULL, NULL, 0, 0, 0, NULL);
 
 	/* space check? */
 
@@ -2033,9 +2034,7 @@ static const struct cmd_variable_handler
 
 #define BMP_STR "BGP Monitoring Protocol\n"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_bmp_clippy.c"
-#endif
 
 DEFPY_NOSH(bmp_targets_main,
       bmp_targets_cmd,
@@ -2512,14 +2511,13 @@ static int bmp_config_write(struct bgp *
 			vty_out(vty, "  bmp mirror\n");
 
 		FOREACH_AFI_SAFI (afi, safi) {
-			const char *afi_str = (afi == AFI_IP) ? "ipv4" : "ipv6";
-
 			if (bt->afimon[afi][safi] & BMP_MON_PREPOLICY)
 				vty_out(vty, "  bmp monitor %s %s pre-policy\n",
-					afi_str, safi2str(safi));
+					afi2str_lower(afi), safi2str(safi));
 			if (bt->afimon[afi][safi] & BMP_MON_POSTPOLICY)
-				vty_out(vty, "  bmp monitor %s %s post-policy\n",
-					afi_str, safi2str(safi));
+				vty_out(vty,
+					"  bmp monitor %s %s post-policy\n",
+					afi2str_lower(afi), safi2str(safi));
 		}
 		frr_each (bmp_listeners, &bt->listeners, bl)
 			vty_out(vty, " \n  bmp listener %pSU port %d\n",
diff -urpN frr-frr-8.4.2/bgpd/bgp_community.h frr-frr-8.5/bgpd/bgp_community.h
--- frr-frr-8.4.2/bgpd/bgp_community.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_community.h	2023-03-13 20:01:47.000000000 +0600
@@ -23,6 +23,7 @@
 
 #include "lib/json.h"
 #include "bgpd/bgp_route.h"
+#include "bgpd/bgp_attr.h"
 
 /* Communities attribute.  */
 struct community {
@@ -109,4 +110,30 @@ extern void bgp_remove_comm_from_aggrega
 						struct community *community);
 extern void bgp_aggr_community_remove(void *arg);
 
+/* This implies that when propagating routes into a VRF, the ACCEPT_OWN
+ * community SHOULD NOT be propagated.
+ */
+static inline void community_strip_accept_own(struct attr *attr)
+{
+	struct community *old_com = bgp_attr_get_community(attr);
+	struct community *new_com = NULL;
+	uint32_t val = COMMUNITY_ACCEPT_OWN;
+
+	if (old_com && community_include(old_com, val)) {
+		new_com = community_dup(old_com);
+		val = htonl(val);
+		community_del_val(new_com, &val);
+
+		if (!old_com->refcnt)
+			community_free(&old_com);
+
+		if (!new_com->size) {
+			community_free(&new_com);
+			bgp_attr_set_community(attr, NULL);
+		} else {
+			bgp_attr_set_community(attr, new_com);
+		}
+	}
+}
+
 #endif /* _QUAGGA_BGP_COMMUNITY_H */
diff -urpN frr-frr-8.4.2/bgpd/bgp_conditional_adv.c frr-frr-8.5/bgpd/bgp_conditional_adv.c
--- frr-frr-8.4.2/bgpd/bgp_conditional_adv.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_conditional_adv.c	2023-03-13 20:01:47.000000000 +0600
@@ -53,18 +53,16 @@ bgp_check_rmap_prefixes_in_bgp_table(str
 
 			if (ret == RMAP_PERMITMATCH) {
 				bgp_dest_unlock_node(dest);
-				if (BGP_DEBUG(update, UPDATE_OUT))
-					zlog_debug(
-						"%s: Condition map routes present in BGP table",
-						__func__);
+				bgp_cond_adv_debug(
+					"%s: Condition map routes present in BGP table",
+					__func__);
 
 				return ret;
 			}
 		}
 	}
 
-	if (BGP_DEBUG(update, UPDATE_OUT))
-		zlog_debug("%s: Condition map routes not present in BGP table",
+	bgp_cond_adv_debug("%s: Condition map routes not present in BGP table",
 			   __func__);
 
 	return ret;
@@ -98,8 +96,7 @@ static void bgp_conditional_adv_routes(s
 	subgrp->pscount = 0;
 	SET_FLAG(subgrp->sflags, SUBGRP_STATUS_TABLE_REPARSING);
 
-	if (BGP_DEBUG(update, UPDATE_OUT))
-		zlog_debug("%s: %s routes to/from %s for %s", __func__,
+	bgp_cond_adv_debug("%s: %s routes to/from %s for %s", __func__,
 			   update_type == UPDATE_TYPE_ADVERTISE ? "Advertise"
 								: "Withdraw",
 			   peer->host, get_afi_safi_str(afi, safi, false));
@@ -239,7 +236,7 @@ static void bgp_conditional_adv_timer(st
 			    !advmap_table_changed)
 				continue;
 
-			if (BGP_DEBUG(update, UPDATE_OUT)) {
+			if (BGP_DEBUG(cond_adv, COND_ADV)) {
 				if (peer->advmap_table_change)
 					zlog_debug(
 						"%s: %s - routes changed in BGP table.",
@@ -284,10 +281,9 @@ static void bgp_conditional_adv_timer(st
 					    .advmap.update_type !=
 				    filter->advmap.update_type)) {
 				/* Handle change to peer advmap */
-				if (BGP_DEBUG(update, UPDATE_OUT))
-					zlog_debug(
-						"%s: advmap.update_type changed for peer %s, adjusting update_group.",
-						__func__, peer->host);
+				bgp_cond_adv_debug(
+					"%s: advmap.update_type changed for peer %s, adjusting update_group.",
+					__func__, peer->host);
 
 				update_group_adjust_peer(paf);
 			}
@@ -298,12 +294,10 @@ static void bgp_conditional_adv_timer(st
 			 */
 			if (peer->advmap_config_change[afi][safi]) {
 
-				if (BGP_DEBUG(update, UPDATE_OUT))
-					zlog_debug(
-						"%s: Configuration is changed on peer %s for %s, send the normal update first.",
-						__func__, peer->host,
-						get_afi_safi_str(afi, safi,
-								 false));
+				bgp_cond_adv_debug(
+					"%s: Configuration is changed on peer %s for %s, send the normal update first.",
+					__func__, peer->host,
+					get_afi_safi_str(afi, safi, false));
 				if (paf) {
 					update_subgroup_split_peer(paf, NULL);
 					subgrp = paf->subgroup;
@@ -340,8 +334,7 @@ void bgp_conditional_adv_enable(struct p
 	 * neighbors (AFI/SAFI). So just increment the counter.
 	 */
 	if (++bgp->condition_filter_count > 1) {
-		if (BGP_DEBUG(update, UPDATE_OUT))
-			zlog_debug("%s: condition_filter_count %d", __func__,
+		bgp_cond_adv_debug("%s: condition_filter_count %d", __func__,
 				   bgp->condition_filter_count);
 
 		return;
@@ -364,8 +357,7 @@ void bgp_conditional_adv_disable(struct
 	 * So there's nothing to do except decrementing the counter.
 	 */
 	if (--bgp->condition_filter_count != 0) {
-		if (BGP_DEBUG(update, UPDATE_OUT))
-			zlog_debug("%s: condition_filter_count %d", __func__,
+		bgp_cond_adv_debug("%s: condition_filter_count %d", __func__,
 				   bgp->condition_filter_count);
 
 		return;
@@ -374,3 +366,164 @@ void bgp_conditional_adv_disable(struct
 	/* Last filter removed. So cancel conditional routes polling thread. */
 	THREAD_OFF(bgp->t_condition_check);
 }
+
+static void peer_advertise_map_filter_update(struct peer *peer, afi_t afi,
+					     safi_t safi, const char *amap_name,
+					     struct route_map *amap,
+					     const char *cmap_name,
+					     struct route_map *cmap,
+					     bool condition, bool set)
+{
+	struct bgp_filter *filter;
+	bool filter_exists = false;
+
+	filter = &peer->filter[afi][safi];
+
+	/* advertise-map is already configured. */
+	if (filter->advmap.aname) {
+		filter_exists = true;
+		XFREE(MTYPE_BGP_FILTER_NAME, filter->advmap.aname);
+		XFREE(MTYPE_BGP_FILTER_NAME, filter->advmap.cname);
+	}
+
+	route_map_counter_decrement(filter->advmap.amap);
+
+	/* Removed advertise-map configuration */
+	if (!set) {
+		memset(&filter->advmap, 0, sizeof(filter->advmap));
+
+		/* decrement condition_filter_count delete timer if
+		 * this is the last advertise-map to be removed.
+		 */
+		if (filter_exists)
+			bgp_conditional_adv_disable(peer, afi, safi);
+
+		/* Process peer route updates. */
+		peer_on_policy_change(peer, afi, safi, 1);
+
+		return;
+	}
+
+	/* Update filter data with newly configured values. */
+	filter->advmap.aname = XSTRDUP(MTYPE_BGP_FILTER_NAME, amap_name);
+	filter->advmap.cname = XSTRDUP(MTYPE_BGP_FILTER_NAME, cmap_name);
+	filter->advmap.amap = amap;
+	filter->advmap.cmap = cmap;
+	filter->advmap.condition = condition;
+	route_map_counter_increment(filter->advmap.amap);
+	peer->advmap_config_change[afi][safi] = true;
+
+	/* Increment condition_filter_count and/or create timer. */
+	if (!filter_exists) {
+		filter->advmap.update_type = UPDATE_TYPE_ADVERTISE;
+		bgp_conditional_adv_enable(peer, afi, safi);
+	}
+
+	/* Process peer route updates. */
+	peer_on_policy_change(peer, afi, safi, 1);
+}
+
+/* Set advertise-map to the peer. */
+int peer_advertise_map_set(struct peer *peer, afi_t afi, safi_t safi,
+			   const char *advertise_name,
+			   struct route_map *advertise_map,
+			   const char *condition_name,
+			   struct route_map *condition_map, bool condition)
+{
+	struct peer *member;
+	struct listnode *node, *nnode;
+
+	/* Set configuration on peer. */
+	peer_advertise_map_filter_update(peer, afi, safi, advertise_name,
+					 advertise_map, condition_name,
+					 condition_map, condition, true);
+
+	/* Check if handling a regular peer & Skip peer-group mechanics. */
+	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
+		/* Set override-flag and process peer route updates. */
+		SET_FLAG(peer->filter_override[afi][safi][RMAP_OUT],
+			 PEER_FT_ADVERTISE_MAP);
+		return 0;
+	}
+
+	/*
+	 * Set configuration on all peer-group members, unless they are
+	 * explicitly overriding peer-group configuration.
+	 */
+	for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
+		/* Skip peers with overridden configuration. */
+		if (CHECK_FLAG(member->filter_override[afi][safi][RMAP_OUT],
+			       PEER_FT_ADVERTISE_MAP))
+			continue;
+
+		/* Set configuration on peer-group member. */
+		peer_advertise_map_filter_update(
+			member, afi, safi, advertise_name, advertise_map,
+			condition_name, condition_map, condition, true);
+	}
+
+	return 0;
+}
+
+/* Unset advertise-map from the peer. */
+int peer_advertise_map_unset(struct peer *peer, afi_t afi, safi_t safi,
+			     const char *advertise_name,
+			     struct route_map *advertise_map,
+			     const char *condition_name,
+			     struct route_map *condition_map, bool condition)
+{
+	struct peer *member;
+	struct listnode *node, *nnode;
+
+	/* advertise-map is not configured */
+	if (!peer->filter[afi][safi].advmap.aname)
+		return 0;
+
+	/* Unset override-flag unconditionally. */
+	UNSET_FLAG(peer->filter_override[afi][safi][RMAP_OUT],
+		   PEER_FT_ADVERTISE_MAP);
+
+	/* Inherit configuration from peer-group if peer is member. */
+	if (peer_group_active(peer)) {
+		PEER_STR_ATTR_INHERIT(peer, peer->group,
+				      filter[afi][safi].advmap.aname,
+				      MTYPE_BGP_FILTER_NAME);
+		PEER_ATTR_INHERIT(peer, peer->group,
+				  filter[afi][safi].advmap.amap);
+	} else
+		peer_advertise_map_filter_update(
+			peer, afi, safi, advertise_name, advertise_map,
+			condition_name, condition_map, condition, false);
+
+	/* Check if handling a regular peer and skip peer-group mechanics. */
+	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
+		/* Process peer route updates. */
+		bgp_cond_adv_debug("%s: Send normal update to %s for %s",
+				   __func__, peer->host,
+				   get_afi_safi_str(afi, safi, false));
+
+		return 0;
+	}
+
+	/*
+	 * Remove configuration on all peer-group members, unless they are
+	 * explicitly overriding peer-group configuration.
+	 */
+	for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
+		/* Skip peers with overridden configuration. */
+		if (CHECK_FLAG(member->filter_override[afi][safi][RMAP_OUT],
+			       PEER_FT_ADVERTISE_MAP))
+			continue;
+		/* Remove configuration on peer-group member. */
+		peer_advertise_map_filter_update(
+			member, afi, safi, advertise_name, advertise_map,
+			condition_name, condition_map, condition, false);
+
+		/* Process peer route updates. */
+		bgp_cond_adv_debug("%s: Send normal update to %s for %s ",
+				   __func__, member->host,
+				   get_afi_safi_str(afi, safi, false));
+	}
+
+	return 0;
+}
diff -urpN frr-frr-8.4.2/bgpd/bgp_conditional_adv.h frr-frr-8.5/bgpd/bgp_conditional_adv.h
--- frr-frr-8.4.2/bgpd/bgp_conditional_adv.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_conditional_adv.h	2023-03-13 20:01:47.000000000 +0600
@@ -33,6 +33,13 @@
 extern "C" {
 #endif
 
+/* Macro to log debug message */
+#define bgp_cond_adv_debug(...)                                                \
+	do {                                                                   \
+		if (BGP_DEBUG(cond_adv, COND_ADV))                             \
+			zlog_debug("" __VA_ARGS__);                            \
+	} while (0)
+
 /* Polling time for monitoring condition-map routes in route table */
 #define DEFAULT_CONDITIONAL_ROUTES_POLL_TIME 60
 
@@ -40,6 +47,18 @@ extern void bgp_conditional_adv_enable(s
 				       safi_t safi);
 extern void bgp_conditional_adv_disable(struct peer *peer, afi_t afi,
 					safi_t safi);
+extern int peer_advertise_map_set(struct peer *peer, afi_t afi, safi_t safi,
+				  const char *advertise_name,
+				  struct route_map *advertise_map,
+				  const char *condition_name,
+				  struct route_map *condition_map,
+				  bool condition);
+extern int peer_advertise_map_unset(struct peer *peer, afi_t afi, safi_t safi,
+				    const char *advertise_name,
+				    struct route_map *advertise_map,
+				    const char *condition_name,
+				    struct route_map *condition_map,
+				    bool condition);
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/bgpd/bgp_damp.c frr-frr-8.5/bgpd/bgp_damp.c
--- frr-frr-8.4.2/bgpd/bgp_damp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_damp.c	2023-03-13 20:01:47.000000000 +0600
@@ -327,7 +327,8 @@ void bgp_damp_info_free(struct bgp_damp_
 	XFREE(MTYPE_BGP_DAMP_INFO, bdi);
 }
 
-static void bgp_damp_parameter_set(int hlife, int reuse, int sup, int maxsup,
+static void bgp_damp_parameter_set(time_t hlife, unsigned int reuse,
+				   unsigned int sup, time_t maxsup,
 				   struct bgp_damp_config *bdc)
 {
 	double reuse_max_ratio;
diff -urpN frr-frr-8.4.2/bgpd/bgp_debug.c frr-frr-8.5/bgpd/bgp_debug.c
--- frr-frr-8.4.2/bgpd/bgp_debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -51,6 +51,8 @@
 #include "bgpd/bgp_flowspec.h"
 #include "bgpd/bgp_packet.h"
 
+#include "bgpd/bgp_debug_clippy.c"
+
 unsigned long conf_bgp_debug_as4;
 unsigned long conf_bgp_debug_neighbor_events;
 unsigned long conf_bgp_debug_events;
@@ -70,6 +72,7 @@ unsigned long conf_bgp_debug_pbr;
 unsigned long conf_bgp_debug_graceful_restart;
 unsigned long conf_bgp_debug_evpn_mh;
 unsigned long conf_bgp_debug_bfd;
+unsigned long conf_bgp_debug_cond_adv;
 
 unsigned long term_bgp_debug_as4;
 unsigned long term_bgp_debug_neighbor_events;
@@ -90,6 +93,7 @@ unsigned long term_bgp_debug_pbr;
 unsigned long term_bgp_debug_graceful_restart;
 unsigned long term_bgp_debug_evpn_mh;
 unsigned long term_bgp_debug_bfd;
+unsigned long term_bgp_debug_cond_adv;
 
 struct list *bgp_debug_neighbor_events_peers = NULL;
 struct list *bgp_debug_keepalive_peers = NULL;
@@ -138,7 +142,6 @@ static const struct message bgp_notify_o
 	{BGP_NOTIFY_OPEN_BAD_PEER_AS, "/Bad Peer AS"},
 	{BGP_NOTIFY_OPEN_BAD_BGP_IDENT, "/Bad BGP Identifier"},
 	{BGP_NOTIFY_OPEN_UNSUP_PARAM, "/Unsupported Optional Parameter"},
-	{BGP_NOTIFY_OPEN_AUTH_FAILURE, "/Authentication Failure"},
 	{BGP_NOTIFY_OPEN_UNACEP_HOLDTIME, "/Unacceptable Hold Time"},
 	{BGP_NOTIFY_OPEN_UNSUP_CAPBL, "/Unsupported Capability"},
 	{BGP_NOTIFY_OPEN_ROLE_MISMATCH, "/Role Mismatch"},
@@ -152,7 +155,6 @@ static const struct message bgp_notify_u
 	{BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR, "/Attribute Flags Error"},
 	{BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, "/Attribute Length Error"},
 	{BGP_NOTIFY_UPDATE_INVAL_ORIGIN, "/Invalid ORIGIN Attribute"},
-	{BGP_NOTIFY_UPDATE_AS_ROUTE_LOOP, "/AS Routing Loop"},
 	{BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, "/Invalid NEXT_HOP Attribute"},
 	{BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, "/Optional Attribute Error"},
 	{BGP_NOTIFY_UPDATE_INVAL_NETWORK, "/Invalid Network Field"},
@@ -320,7 +322,7 @@ static void bgp_debug_list_add_entry(str
 }
 
 static bool bgp_debug_list_remove_entry(struct list *list, const char *host,
-					struct prefix *p)
+					const struct prefix *p)
 {
 	struct bgp_debug_filter *filter;
 	struct listnode *node, *nnode;
@@ -374,8 +376,6 @@ bool bgp_debug_peer_updout_enabled(char
 /* Dump attribute. */
 bool bgp_dump_attr(struct attr *attr, char *buf, size_t size)
 {
-	char addrbuf[BUFSIZ];
-
 	if (!attr)
 		return false;
 
@@ -391,15 +391,12 @@ bool bgp_dump_attr(struct attr *attr, ch
 	/* Add MP case. */
 	if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL
 	    || attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)
-		snprintf(buf + strlen(buf), size - strlen(buf),
-			 ", mp_nexthop %s",
-			 inet_ntop(AF_INET6, &attr->mp_nexthop_global, addrbuf,
-				   BUFSIZ));
+		snprintfrr(buf + strlen(buf), size - strlen(buf),
+			   ", mp_nexthop %pI6", &attr->mp_nexthop_global);
 
 	if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)
-		snprintf(buf + strlen(buf), size - strlen(buf), "(%s)",
-			 inet_ntop(AF_INET6, &attr->mp_nexthop_local, addrbuf,
-				   BUFSIZ));
+		snprintfrr(buf + strlen(buf), size - strlen(buf), "(%pI6)",
+			   &attr->mp_nexthop_local);
 
 	if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV4)
 		snprintfrr(buf, size, "nexthop %pI4", &attr->nexthop);
@@ -408,6 +405,11 @@ bool bgp_dump_attr(struct attr *attr, ch
 		snprintf(buf + strlen(buf), size - strlen(buf),
 			 ", localpref %u", attr->local_pref);
 
+	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AIGP)))
+		snprintf(buf + strlen(buf), size - strlen(buf),
+			 ", aigp-metric %" PRIu64,
+			 (unsigned long long)bgp_attr_get_aigp_metric(attr));
+
 	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)))
 		snprintf(buf + strlen(buf), size - strlen(buf), ", metric %u",
 			 attr->med);
@@ -626,17 +628,14 @@ static void bgp_debug_print_evpn_prefix(
 }
 
 static int bgp_debug_parse_evpn_prefix(struct vty *vty, struct cmd_token **argv,
-				       int argc, struct prefix **argv_pp)
+				       int argc, struct prefix *argv_p)
 {
-	struct prefix *argv_p;
 	struct ethaddr mac = {};
 	struct ipaddr ip = {};
 	int evpn_type = 0;
 	int mac_idx = 0;
 	int ip_idx = 0;
 
-	argv_p = *argv_pp;
-
 	if (bgp_evpn_cli_parse_type(&evpn_type, argv, argc) < 0)
 		return CMD_WARNING;
 
@@ -1019,49 +1018,42 @@ DEFUN (no_debug_bgp_keepalive_peer,
 }
 
 /* debug bgp bestpath */
-DEFUN (debug_bgp_bestpath_prefix,
+DEFPY (debug_bgp_bestpath_prefix,
        debug_bgp_bestpath_prefix_cmd,
-       "debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>",
+       "debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>$prefix",
        DEBUG_STR
        BGP_STR
        "BGP bestpath\n"
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	struct prefix *argv_p;
-	int idx_ipv4_ipv6_prefixlen = 3;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
-
 	if (!bgp_debug_bestpath_prefixes)
 		bgp_debug_bestpath_prefixes = list_new();
 
 	if (bgp_debug_list_has_entry(bgp_debug_bestpath_prefixes, NULL,
-				     argv_p)) {
+				     prefix)) {
 		vty_out(vty,
 			"BGP bestpath debugging is already enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 		return CMD_SUCCESS;
 	}
 
-	bgp_debug_list_add_entry(bgp_debug_bestpath_prefixes, NULL, argv_p);
+	bgp_debug_list_add_entry(bgp_debug_bestpath_prefixes, NULL, prefix);
 
 	if (vty->node == CONFIG_NODE) {
 		DEBUG_ON(bestpath, BESTPATH);
 	} else {
 		TERM_DEBUG_ON(bestpath, BESTPATH);
 		vty_out(vty, "BGP bestpath debugging is on for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 	}
 
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_debug_bgp_bestpath_prefix,
+DEFPY (no_debug_bgp_bestpath_prefix,
        no_debug_bgp_bestpath_prefix_cmd,
-       "no debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>",
+       "no debug bgp bestpath <A.B.C.D/M|X:X::X:X/M>$prefix",
        NO_STR
        DEBUG_STR
        BGP_STR
@@ -1069,18 +1061,12 @@ DEFUN (no_debug_bgp_bestpath_prefix,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	int idx_ipv4_ipv6_prefixlen = 4;
-	struct prefix *argv_p;
-	int found_prefix = 0;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
+	bool found_prefix = false;
 
 	if (bgp_debug_bestpath_prefixes
 	    && !list_isempty(bgp_debug_bestpath_prefixes)) {
 		found_prefix = bgp_debug_list_remove_entry(
-			bgp_debug_bestpath_prefixes, NULL, argv_p);
+			bgp_debug_bestpath_prefixes, NULL, prefix);
 
 		if (list_isempty(bgp_debug_bestpath_prefixes)) {
 			if (vty->node == CONFIG_NODE) {
@@ -1095,10 +1081,10 @@ DEFUN (no_debug_bgp_bestpath_prefix,
 
 	if (found_prefix)
 		vty_out(vty, "BGP bestpath debugging is off for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 	else
 		vty_out(vty, "BGP bestpath debugging was not enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 
 	return CMD_SUCCESS;
 }
@@ -1406,10 +1392,6 @@ DEFUN (no_debug_bgp_update_direct_peer,
 	return CMD_SUCCESS;
 }
 
-#ifndef VTYSH_EXTRACT_PL
-#include "bgpd/bgp_debug_clippy.c"
-#endif
-
 DEFPY (debug_bgp_update_prefix_afi_safi,
        debug_bgp_update_prefix_afi_safi_cmd,
        "debug bgp updates prefix l2vpn$afi evpn$safi type <<macip|2> mac <X:X:X:X:X:X|X:X:X:X:X:X/M> [ip <A.B.C.D|X:X::X:X>]|<multicast|3> ip <A.B.C.D|X:X::X:X>|<prefix|5> ip <A.B.C.D/M|X:X::X:X/M>>",
@@ -1437,39 +1419,33 @@ DEFPY (debug_bgp_update_prefix_afi_safi,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	struct prefix *argv_p;
+	struct prefix argv_p;
 	int ret = CMD_SUCCESS;
 
-	argv_p = prefix_new();
-
 	ret = bgp_debug_parse_evpn_prefix(vty, argv, argc, &argv_p);
-	if (ret != CMD_SUCCESS) {
-		prefix_free(&argv_p);
+	if (ret != CMD_SUCCESS)
 		return ret;
-	}
 
 	if (!bgp_debug_update_prefixes)
 		bgp_debug_update_prefixes = list_new();
 
-	if (bgp_debug_list_has_entry(bgp_debug_update_prefixes, NULL, argv_p)) {
+	if (bgp_debug_list_has_entry(bgp_debug_update_prefixes, NULL,
+				     &argv_p)) {
 		vty_out(vty,
 			"BGP updates debugging is already enabled for %pFX\n",
-			argv_p);
-		prefix_free(&argv_p);
+			&argv_p);
 		return CMD_SUCCESS;
 	}
 
-	bgp_debug_list_add_entry(bgp_debug_update_prefixes, NULL, argv_p);
+	bgp_debug_list_add_entry(bgp_debug_update_prefixes, NULL, &argv_p);
 
 	if (vty->node == CONFIG_NODE) {
 		DEBUG_ON(update, UPDATE_PREFIX);
 	} else {
 		TERM_DEBUG_ON(update, UPDATE_PREFIX);
-		vty_out(vty, "BGP updates debugging is on for %pFX\n", argv_p);
+		vty_out(vty, "BGP updates debugging is on for %pFX\n", &argv_p);
 	}
 
-	prefix_free(&argv_p);
-
 	return CMD_SUCCESS;
 }
 
@@ -1501,22 +1477,18 @@ DEFPY (no_debug_bgp_update_prefix_afi_sa
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	struct prefix *argv_p;
+	struct prefix argv_p;
 	bool found_prefix = false;
 	int ret = CMD_SUCCESS;
 
-	argv_p = prefix_new();
-
 	ret = bgp_debug_parse_evpn_prefix(vty, argv, argc, &argv_p);
-	if (ret != CMD_SUCCESS) {
-		prefix_free(&argv_p);
+	if (ret != CMD_SUCCESS)
 		return ret;
-	}
 
 	if (bgp_debug_update_prefixes
 	    && !list_isempty(bgp_debug_update_prefixes)) {
 		found_prefix = bgp_debug_list_remove_entry(
-			bgp_debug_update_prefixes, NULL, argv_p);
+			bgp_debug_update_prefixes, NULL, &argv_p);
 
 		if (list_isempty(bgp_debug_update_prefixes)) {
 			if (vty->node == CONFIG_NODE) {
@@ -1530,20 +1502,19 @@ DEFPY (no_debug_bgp_update_prefix_afi_sa
 	}
 
 	if (found_prefix)
-		vty_out(vty, "BGP updates debugging is off for %pFX\n", argv_p);
+		vty_out(vty, "BGP updates debugging is off for %pFX\n",
+			&argv_p);
 	else
 		vty_out(vty, "BGP updates debugging was not enabled for %pFX\n",
-			argv_p);
-
-	prefix_free(&argv_p);
+			&argv_p);
 
 	return ret;
 }
 
 
-DEFUN (debug_bgp_update_prefix,
+DEFPY (debug_bgp_update_prefix,
        debug_bgp_update_prefix_cmd,
-       "debug bgp updates prefix <A.B.C.D/M|X:X::X:X/M>",
+       "debug bgp updates prefix <A.B.C.D/M|X:X::X:X/M>$prefix",
        DEBUG_STR
        BGP_STR
        "BGP updates\n"
@@ -1551,39 +1522,32 @@ DEFUN (debug_bgp_update_prefix,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	int idx_ipv4_ipv6_prefixlen = 4;
-	struct prefix *argv_p;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
-
 	if (!bgp_debug_update_prefixes)
 		bgp_debug_update_prefixes = list_new();
 
-	if (bgp_debug_list_has_entry(bgp_debug_update_prefixes, NULL, argv_p)) {
+	if (bgp_debug_list_has_entry(bgp_debug_update_prefixes, NULL, prefix)) {
 		vty_out(vty,
 			"BGP updates debugging is already enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 		return CMD_SUCCESS;
 	}
 
-	bgp_debug_list_add_entry(bgp_debug_update_prefixes, NULL, argv_p);
+	bgp_debug_list_add_entry(bgp_debug_update_prefixes, NULL, prefix);
 
 	if (vty->node == CONFIG_NODE) {
 		DEBUG_ON(update, UPDATE_PREFIX);
 	} else {
 		TERM_DEBUG_ON(update, UPDATE_PREFIX);
 		vty_out(vty, "BGP updates debugging is on for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 	}
 
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_debug_bgp_update_prefix,
+DEFPY (no_debug_bgp_update_prefix,
        no_debug_bgp_update_prefix_cmd,
-       "no debug bgp updates prefix <A.B.C.D/M|X:X::X:X/M>",
+       "no debug bgp updates prefix <A.B.C.D/M|X:X::X:X/M>$prefix",
        NO_STR
        DEBUG_STR
        BGP_STR
@@ -1592,18 +1556,12 @@ DEFUN (no_debug_bgp_update_prefix,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	int idx_ipv4_ipv6_prefixlen = 5;
-	struct prefix *argv_p;
-	int found_prefix = 0;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
+	bool found_prefix = false;
 
 	if (bgp_debug_update_prefixes
 	    && !list_isempty(bgp_debug_update_prefixes)) {
 		found_prefix = bgp_debug_list_remove_entry(
-			bgp_debug_update_prefixes, NULL, argv_p);
+			bgp_debug_update_prefixes, NULL, prefix);
 
 		if (list_isempty(bgp_debug_update_prefixes)) {
 			if (vty->node == CONFIG_NODE) {
@@ -1618,10 +1576,10 @@ DEFUN (no_debug_bgp_update_prefix,
 
 	if (found_prefix)
 		vty_out(vty, "BGP updates debugging is off for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 	else
 		vty_out(vty, "BGP updates debugging was not enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 
 	return CMD_SUCCESS;
 }
@@ -1691,9 +1649,9 @@ DEFUN (debug_bgp_graceful_restart,
 }
 
 
-DEFUN (debug_bgp_zebra_prefix,
+DEFPY (debug_bgp_zebra_prefix,
        debug_bgp_zebra_prefix_cmd,
-       "debug bgp zebra prefix <A.B.C.D/M|X:X::X:X/M>",
+       "debug bgp zebra prefix <A.B.C.D/M|X:X::X:X/M>$prefix",
        DEBUG_STR
        BGP_STR
        "BGP Zebra messages\n"
@@ -1701,30 +1659,22 @@ DEFUN (debug_bgp_zebra_prefix,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	int idx_ipv4_ipv6_prefixlen = 4;
-	struct prefix *argv_p;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
-
 	if (!bgp_debug_zebra_prefixes)
 		bgp_debug_zebra_prefixes = list_new();
 
-	if (bgp_debug_list_has_entry(bgp_debug_zebra_prefixes, NULL, argv_p)) {
+	if (bgp_debug_list_has_entry(bgp_debug_zebra_prefixes, NULL, prefix)) {
 		vty_out(vty, "BGP zebra debugging is already enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 		return CMD_SUCCESS;
 	}
 
-	bgp_debug_list_add_entry(bgp_debug_zebra_prefixes, NULL, argv_p);
+	bgp_debug_list_add_entry(bgp_debug_zebra_prefixes, NULL, prefix);
 
 	if (vty->node == CONFIG_NODE)
 		DEBUG_ON(zebra, ZEBRA);
 	else {
 		TERM_DEBUG_ON(zebra, ZEBRA);
-		vty_out(vty, "BGP zebra debugging is on for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+		vty_out(vty, "BGP zebra debugging is on for %s\n", prefix_str);
 	}
 
 	return CMD_SUCCESS;
@@ -1766,9 +1716,9 @@ DEFUN (no_debug_bgp_graceful_restart,
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_debug_bgp_zebra_prefix,
+DEFPY (no_debug_bgp_zebra_prefix,
        no_debug_bgp_zebra_prefix_cmd,
-       "no debug bgp zebra prefix <A.B.C.D/M|X:X::X:X/M>",
+       "no debug bgp zebra prefix <A.B.C.D/M|X:X::X:X/M>$prefix",
        NO_STR
        DEBUG_STR
        BGP_STR
@@ -1777,18 +1727,12 @@ DEFUN (no_debug_bgp_zebra_prefix,
        "IPv4 prefix\n"
        "IPv6 prefix\n")
 {
-	int idx_ipv4_ipv6_prefixlen = 5;
-	struct prefix *argv_p;
-	int found_prefix = 0;
-
-	argv_p = prefix_new();
-	(void)str2prefix(argv[idx_ipv4_ipv6_prefixlen]->arg, argv_p);
-	apply_mask(argv_p);
+	bool found_prefix = false;
 
 	if (bgp_debug_zebra_prefixes
 	    && !list_isempty(bgp_debug_zebra_prefixes)) {
 		found_prefix = bgp_debug_list_remove_entry(
-			bgp_debug_zebra_prefixes, NULL, argv_p);
+			bgp_debug_zebra_prefixes, NULL, prefix);
 
 		if (list_isempty(bgp_debug_zebra_prefixes)) {
 			if (vty->node == CONFIG_NODE)
@@ -1801,11 +1745,10 @@ DEFUN (no_debug_bgp_zebra_prefix,
 	}
 
 	if (found_prefix)
-		vty_out(vty, "BGP zebra debugging is off for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+		vty_out(vty, "BGP zebra debugging is off for %s\n", prefix_str);
 	else
 		vty_out(vty, "BGP zebra debugging was not enabled for %s\n",
-			argv[idx_ipv4_ipv6_prefixlen]->arg);
+			prefix_str);
 
 	return CMD_SUCCESS;
 }
@@ -2108,6 +2051,33 @@ DEFPY(debug_bgp_bfd, debug_bgp_bfd_cmd,
 	return CMD_SUCCESS;
 }
 
+DEFPY (debug_bgp_cond_adv,
+       debug_bgp_cond_adv_cmd,
+       "[no$no] debug bgp conditional-advertisement",
+       NO_STR
+       DEBUG_STR
+       BGP_STR
+       "BGP conditional advertisement\n")
+{
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(cond_adv, COND_ADV);
+		else
+			DEBUG_ON(cond_adv, COND_ADV);
+	} else {
+		if (no) {
+			TERM_DEBUG_OFF(cond_adv, COND_ADV);
+			vty_out(vty,
+				"BGP conditional advertisement debugging is off\n");
+		} else {
+			TERM_DEBUG_ON(cond_adv, COND_ADV);
+			vty_out(vty,
+				"BGP conditional advertisement debugging is on\n");
+		}
+	}
+	return CMD_SUCCESS;
+}
+
 DEFUN (no_debug_bgp,
        no_debug_bgp_cmd,
        "no debug bgp",
@@ -2152,6 +2122,7 @@ DEFUN (no_debug_bgp,
 	TERM_DEBUG_OFF(evpn_mh, EVPN_MH_ES);
 	TERM_DEBUG_OFF(evpn_mh, EVPN_MH_RT);
 	TERM_DEBUG_OFF(bfd, BFD_LIB);
+	TERM_DEBUG_OFF(cond_adv, COND_ADV);
 
 	vty_out(vty, "All possible debugging has been turned off\n");
 
@@ -2244,6 +2215,12 @@ DEFUN_NOSH (show_debugging_bgp,
 	if (BGP_DEBUG(bfd, BFD_LIB))
 		vty_out(vty, "  BGP BFD library debugging is on\n");
 
+	if (BGP_DEBUG(cond_adv, COND_ADV))
+		vty_out(vty,
+			"  BGP conditional advertisement debugging is on\n");
+
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -2373,6 +2350,11 @@ static int bgp_config_write_debug(struct
 		write++;
 	}
 
+	if (CONF_BGP_DEBUG(cond_adv, COND_ADV)) {
+		vty_out(vty, "debug bgp conditional-advertisement\n");
+		write++;
+	}
+
 	return write;
 }
 
@@ -2501,6 +2483,10 @@ void bgp_debug_init(void)
 	/* debug bgp bfd */
 	install_element(ENABLE_NODE, &debug_bgp_bfd_cmd);
 	install_element(CONFIG_NODE, &debug_bgp_bfd_cmd);
+
+	/* debug bgp conditional advertisement */
+	install_element(ENABLE_NODE, &debug_bgp_cond_adv_cmd);
+	install_element(CONFIG_NODE, &debug_bgp_cond_adv_cmd);
 }
 
 /* Return true if this prefix is on the per_prefix_list of prefixes to debug
diff -urpN frr-frr-8.4.2/bgpd/bgp_debug.h frr-frr-8.5/bgpd/bgp_debug.h
--- frr-frr-8.4.2/bgpd/bgp_debug.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_debug.h	2023-03-13 20:01:47.000000000 +0600
@@ -80,6 +80,7 @@ extern unsigned long conf_bgp_debug_pbr;
 extern unsigned long conf_bgp_debug_graceful_restart;
 extern unsigned long conf_bgp_debug_evpn_mh;
 extern unsigned long conf_bgp_debug_bfd;
+extern unsigned long conf_bgp_debug_cond_adv;
 
 extern unsigned long term_bgp_debug_as4;
 extern unsigned long term_bgp_debug_neighbor_events;
@@ -98,6 +99,7 @@ extern unsigned long term_bgp_debug_pbr;
 extern unsigned long term_bgp_debug_graceful_restart;
 extern unsigned long term_bgp_debug_evpn_mh;
 extern unsigned long term_bgp_debug_bfd;
+extern unsigned long term_bgp_debug_cond_adv;
 
 extern struct list *bgp_debug_neighbor_events_peers;
 extern struct list *bgp_debug_keepalive_peers;
@@ -143,6 +145,7 @@ struct bgp_debug_filter {
 #define BGP_DEBUG_GRACEFUL_RESTART     0x01
 
 #define BGP_DEBUG_BFD_LIB             0x01
+#define BGP_DEBUG_COND_ADV 0x01
 
 #define CONF_DEBUG_ON(a, b)	(conf_bgp_debug_ ## a |= (BGP_DEBUG_ ## b))
 #define CONF_DEBUG_OFF(a, b)	(conf_bgp_debug_ ## a &= ~(BGP_DEBUG_ ## b))
diff -urpN frr-frr-8.4.2/bgpd/bgp_dump.c frr-frr-8.5/bgpd/bgp_dump.c
--- frr-frr-8.4.2/bgpd/bgp_dump.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_dump.c	2023-03-13 20:01:47.000000000 +0600
@@ -117,9 +117,13 @@ static FILE *bgp_dump_open_file(struct b
 	if (bgp_dump->filename[0] != DIRECTORY_SEP) {
 		snprintf(fullpath, sizeof(fullpath), "%s/%s", vty_get_cwd(),
 			 bgp_dump->filename);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+		/* user supplied date/time format string */
 		ret = strftime(realpath, MAXPATHLEN, fullpath, &tm);
 	} else
 		ret = strftime(realpath, MAXPATHLEN, bgp_dump->filename, &tm);
+#pragma GCC diagnostic pop
 
 	if (ret == 0) {
 		flog_warn(EC_BGP_DUMP, "%s: strftime error", __func__);
@@ -376,7 +380,7 @@ bgp_dump_route_node_record(int afi, stru
 
 		/* Dump attribute. */
 		/* Skip prefix & AFI/SAFI for MP_NLRI */
-		bgp_dump_routes_attr(obuf, path->attr, p);
+		bgp_dump_routes_attr(obuf, path, p);
 
 		cur_endp = stream_get_endp(obuf);
 		if (cur_endp > BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE
diff -urpN frr-frr-8.4.2/bgpd/bgp_ecommunity.c frr-frr-8.5/bgpd/bgp_ecommunity.c
--- frr-frr-8.4.2/bgpd/bgp_ecommunity.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_ecommunity.c	2023-03-13 20:01:47.000000000 +0600
@@ -699,6 +699,7 @@ static struct ecommunity *ecommunity_str
 	while ((str = ecommunity_gettoken(str, (void *)&eval, &token))) {
 		switch (token) {
 		case ecommunity_token_rt:
+		case ecommunity_token_rt6:
 		case ecommunity_token_soo:
 			if (!keyword_included || keyword) {
 				if (ecom)
@@ -746,7 +747,6 @@ static struct ecommunity *ecommunity_str
 						    ecom->unit_size);
 			break;
 		case ecommunity_token_unknown:
-		default:
 			if (ecom)
 				ecommunity_free(&ecom);
 			return NULL;
@@ -988,13 +988,8 @@ char *ecommunity_ecom2str(struct ecommun
 				    type == ECOMMUNITY_ENCODE_IP) {
 					struct in_addr *ipv4 =
 						(struct in_addr *)pnt;
-					char ipv4str[INET_ADDRSTRLEN];
-
-					inet_ntop(AF_INET, ipv4,
-						  ipv4str,
-						  INET_ADDRSTRLEN);
-					snprintf(encbuf, sizeof(encbuf),
-						 "NH:%s:%d", ipv4str, pnt[5]);
+					snprintfrr(encbuf, sizeof(encbuf),
+						   "NH:%pI4:%d", ipv4, pnt[5]);
 				} else if (sub_type ==
 					   ECOMMUNITY_LINK_BANDWIDTH &&
 					   type == ECOMMUNITY_ENCODE_AS) {
diff -urpN frr-frr-8.4.2/bgpd/bgp_errors.c frr-frr-8.5/bgpd/bgp_errors.c
--- frr-frr-8.4.2/bgpd/bgp_errors.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_errors.c	2023-03-13 20:01:47.000000000 +0600
@@ -236,6 +236,12 @@ static struct log_ref ferr_bgp_err[] = {
 		.suggestion = "Determine the source of the update and determine why the PMSI tunnel attribute length has been set incorrectly"
 	},
 	{
+		.code = EC_BGP_ATTR_AIGP,
+		.title = "BGP AIGP attribute is incorrect",
+		.description = "BGP AIGP attribute is incorrect",
+		.suggestion = "Determine the source of the attribute and determine why the AIGP attribute has been set incorrectly"
+	},
+	{
 		.code = EC_BGP_PEER_GROUP,
 		.title = "BGP peergroup operated on in error",
 		.description = "BGP operating on peer-group instead of peers included",
diff -urpN frr-frr-8.4.2/bgpd/bgp_errors.h frr-frr-8.5/bgpd/bgp_errors.h
--- frr-frr-8.4.2/bgpd/bgp_errors.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_errors.h	2023-03-13 20:01:47.000000000 +0600
@@ -34,6 +34,7 @@ enum bgp_log_refs {
 	EC_BGP_ATTR_PMSI_TYPE,
 	EC_BGP_ATTR_PMSI_LEN,
 	EC_BGP_ATTR_NH_SEND_LEN,
+	EC_BGP_ATTR_AIGP,
 	EC_BGP_PEER_GROUP,
 	EC_BGP_PEER_DELETE,
 	EC_BGP_TABLE_CHUNK,
diff -urpN frr-frr-8.4.2/bgpd/bgp_evpn.c frr-frr-8.5/bgpd/bgp_evpn.c
--- frr-frr-8.4.2/bgpd/bgp_evpn.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_evpn.c	2023-03-13 20:01:47.000000000 +0600
@@ -62,11 +62,11 @@
 DEFINE_QOBJ_TYPE(bgpevpn);
 DEFINE_QOBJ_TYPE(bgp_evpn_es);
 
+DEFINE_MTYPE_STATIC(BGPD, VRF_ROUTE_TARGET, "L3 Route Target");
 
 /*
  * Static function declarations
  */
-static int delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn);
 static void bgp_evpn_remote_ip_hash_init(struct bgpevpn *evpn);
 static void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *evpn);
 static void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
@@ -350,6 +350,15 @@ int bgp_evpn_route_target_cmp(struct eco
 	return strcmp(ecom1->str, ecom2->str);
 }
 
+/*
+ * Compare L3 Route Targets.
+ */
+static int evpn_vrf_route_target_cmp(struct vrf_route_target *rt1,
+				     struct vrf_route_target *rt2)
+{
+	return bgp_evpn_route_target_cmp(rt1->ecom, rt2->ecom);
+}
+
 void bgp_evpn_xxport_delete_ecomm(void *val)
 {
 	struct ecommunity *ecomm = val;
@@ -357,11 +366,37 @@ void bgp_evpn_xxport_delete_ecomm(void *
 }
 
 /*
+ * Delete l3 Route Target.
+ */
+static void evpn_vrf_rt_del(void *val)
+{
+	struct vrf_route_target *l3rt = val;
+
+	ecommunity_free(&l3rt->ecom);
+
+	XFREE(MTYPE_VRF_ROUTE_TARGET, l3rt);
+}
+
+/*
+ * Allocate a new l3 Route Target.
+ */
+static struct vrf_route_target *evpn_vrf_rt_new(struct ecommunity *ecom)
+{
+	struct vrf_route_target *l3rt;
+
+	l3rt = XCALLOC(MTYPE_VRF_ROUTE_TARGET, sizeof(struct vrf_route_target));
+
+	l3rt->ecom = ecom;
+
+	return l3rt;
+}
+
+/*
  * Mask off global-admin field of specified extended community (RT),
  * just retain the local-admin field.
  */
 static inline void mask_ecom_global_admin(struct ecommunity_val *dst,
-					  struct ecommunity_val *src)
+					  const struct ecommunity_val *src)
 {
 	uint8_t type;
 
@@ -377,33 +412,55 @@ static inline void mask_ecom_global_admi
 }
 
 /*
- * Map one RT to specified VRF.
- * bgp_vrf = BGP vrf instance
+ * Converts the RT to Ecommunity Value and adjusts masking based
+ * on flags set for RT.
  */
-static void map_vrf_to_rt(struct bgp *bgp_vrf, struct ecommunity_val *eval)
+static void vrf_rt2ecom_val(struct ecommunity_val *to_eval,
+			    const struct vrf_route_target *l3rt, int iter)
 {
-	struct vrf_irt_node *irt = NULL;
-	struct ecommunity_val eval_tmp;
+	const struct ecommunity_val *eval;
 
-	/* If using "automatic" RT,
+	eval = (const struct ecommunity_val *)(l3rt->ecom->val +
+					       (iter * ECOMMUNITY_SIZE));
+	/* If using "automatic" or "wildcard *" RT,
 	 * we only care about the local-admin sub-field.
 	 * This is to facilitate using L3VNI(VRF-VNI)
-	 * as the RT for EBGP peering too.
+	 * as the RT for EBGP peering too and simplify
+	 * configurations by allowing any ASN via '*'.
 	 */
-	memcpy(&eval_tmp, eval, ECOMMUNITY_SIZE);
-	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD))
-		mask_ecom_global_admin(&eval_tmp, eval);
+	memcpy(to_eval, eval, ECOMMUNITY_SIZE);
 
-	irt = lookup_vrf_import_rt(&eval_tmp);
-	if (irt && is_vrf_present_in_irt_vrfs(irt->vrfs, bgp_vrf))
-		/* Already mapped. */
-		return;
+	if (CHECK_FLAG(l3rt->flags, BGP_VRF_RT_AUTO) ||
+	    CHECK_FLAG(l3rt->flags, BGP_VRF_RT_WILD))
+		mask_ecom_global_admin(to_eval, eval);
+}
 
-	if (!irt)
-		irt = vrf_import_rt_new(&eval_tmp);
+/*
+ * Map one RT to specified VRF.
+ * bgp_vrf = BGP vrf instance
+ */
+static void map_vrf_to_rt(struct bgp *bgp_vrf, struct vrf_route_target *l3rt)
+{
+	uint32_t i = 0;
 
-	/* Add VRF to the list for this RT. */
-	listnode_add(irt->vrfs, bgp_vrf);
+	for (i = 0; i < l3rt->ecom->size; i++) {
+		struct vrf_irt_node *irt = NULL;
+		struct ecommunity_val eval_tmp;
+
+		/* Adjust masking for value */
+		vrf_rt2ecom_val(&eval_tmp, l3rt, i);
+
+		irt = lookup_vrf_import_rt(&eval_tmp);
+
+		if (irt && is_vrf_present_in_irt_vrfs(irt->vrfs, bgp_vrf))
+			return; /* Already mapped. */
+
+		if (!irt)
+			irt = vrf_import_rt_new(&eval_tmp);
+
+		/* Add VRF to the list for this RT. */
+		listnode_add(irt->vrfs, bgp_vrf);
+	}
 }
 
 /*
@@ -411,12 +468,28 @@ static void map_vrf_to_rt(struct bgp *bg
  * VRFs for this RT, then the RT hash is deleted.
  * bgp_vrf: BGP VRF specific instance
  */
-static void unmap_vrf_from_rt(struct bgp *bgp_vrf, struct vrf_irt_node *irt)
+static void unmap_vrf_from_rt(struct bgp *bgp_vrf,
+			      struct vrf_route_target *l3rt)
 {
-	/* Delete VRF from list for this RT. */
-	listnode_delete(irt->vrfs, bgp_vrf);
-	if (!listnode_head(irt->vrfs)) {
-		vrf_import_rt_free(irt);
+	uint32_t i;
+
+	for (i = 0; i < l3rt->ecom->size; i++) {
+		struct vrf_irt_node *irt;
+		struct ecommunity_val eval_tmp;
+
+		/* Adjust masking for value */
+		vrf_rt2ecom_val(&eval_tmp, l3rt, i);
+
+		irt = lookup_vrf_import_rt(&eval_tmp);
+
+		if (!irt)
+			return; /* Not mapped */
+
+		/* Delete VRF from list for this RT. */
+		listnode_delete(irt->vrfs, bgp_vrf);
+
+		if (!listnode_head(irt->vrfs))
+			vrf_import_rt_free(irt);
 	}
 }
 
@@ -505,10 +578,14 @@ static void bgp_evpn_get_rmac_nexthop(st
  * VNIs but the same across routers (in the same AS) for a particular
  * VNI.
  */
-static void form_auto_rt(struct bgp *bgp, vni_t vni, struct list *rtl)
+static void form_auto_rt(struct bgp *bgp, vni_t vni, struct list *rtl,
+			 bool is_l3)
 {
 	struct ecommunity_val eval;
-	struct ecommunity *ecomadd, *ecom;
+	struct ecommunity *ecomadd;
+	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
+	struct vrf_route_target *newrt;
 	bool ecom_found = false;
 	struct listnode *node;
 
@@ -518,15 +595,30 @@ static void form_auto_rt(struct bgp *bgp
 
 	ecomadd = ecommunity_new();
 	ecommunity_add_val(ecomadd, &eval, false, false);
-	for (ALL_LIST_ELEMENTS_RO(rtl, node, ecom))
-		if (ecommunity_cmp(ecomadd, ecom)) {
-			ecom_found = true;
-			break;
-		}
 
-	if (!ecom_found)
-		listnode_add_sort(rtl, ecomadd);
-	else
+	if (is_l3) {
+		for (ALL_LIST_ELEMENTS_RO(rtl, node, l3rt))
+			if (ecommunity_cmp(ecomadd, l3rt->ecom)) {
+				ecom_found = true;
+				break;
+			}
+	} else {
+		for (ALL_LIST_ELEMENTS_RO(rtl, node, ecom))
+			if (ecommunity_cmp(ecomadd, ecom)) {
+				ecom_found = true;
+				break;
+			}
+	}
+
+	if (!ecom_found) {
+		if (is_l3) {
+			newrt = evpn_vrf_rt_new(ecomadd);
+			/* Label it as autoderived */
+			SET_FLAG(newrt->flags, BGP_VRF_RT_AUTO);
+			listnode_add_sort(rtl, newrt);
+		} else
+			listnode_add_sort(rtl, ecomadd);
+	} else
 		ecommunity_free(&ecomadd);
 }
 
@@ -552,10 +644,14 @@ static void evpn_convert_nexthop_to_ipv6
 	attr->mp_nexthop_len = IPV6_MAX_BYTELEN;
 }
 
-struct bgp_dest *bgp_global_evpn_node_get(struct bgp_table *table, afi_t afi,
+/*
+ * Wrapper for node get in global table.
+ */
+struct bgp_dest *bgp_evpn_global_node_get(struct bgp_table *table, afi_t afi,
 					  safi_t safi,
 					  const struct prefix_evpn *evp,
-					  struct prefix_rd *prd)
+					  struct prefix_rd *prd,
+					  const struct bgp_path_info *local_pi)
 {
 	struct prefix_evpn global_p;
 
@@ -565,14 +661,38 @@ struct bgp_dest *bgp_global_evpn_node_ge
 		 */
 		evpn_type1_prefix_global_copy(&global_p, evp);
 		evp = &global_p;
+	} else if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE &&
+		   local_pi) {
+		/*
+		 * prefix in the global table needs MAC/IP, ensure they are
+		 * present, using one's from local table's path_info.
+		 */
+		if (is_evpn_prefix_ipaddr_none(evp)) {
+			/* VNI MAC -> Global */
+			evpn_type2_prefix_global_copy(
+				&global_p, evp, NULL /* mac */,
+				evpn_type2_path_info_get_ip(local_pi));
+		} else {
+			/* VNI IP -> Global */
+			evpn_type2_prefix_global_copy(
+				&global_p, evp,
+				evpn_type2_path_info_get_mac(local_pi),
+				NULL /* ip */);
+		}
+
+		evp = &global_p;
 	}
 	return bgp_afi_node_get(table, afi, safi, (struct prefix *)evp, prd);
 }
 
-struct bgp_dest *bgp_global_evpn_node_lookup(struct bgp_table *table, afi_t afi,
-					     safi_t safi,
-					     const struct prefix_evpn *evp,
-					     struct prefix_rd *prd)
+/*
+ * Wrapper for node lookup in global table.
+ */
+struct bgp_dest *
+bgp_evpn_global_node_lookup(struct bgp_table *table, afi_t afi, safi_t safi,
+			    const struct prefix_evpn *evp,
+			    struct prefix_rd *prd,
+			    const struct bgp_path_info *local_pi)
 {
 	struct prefix_evpn global_p;
 
@@ -582,21 +702,177 @@ struct bgp_dest *bgp_global_evpn_node_lo
 		 */
 		evpn_type1_prefix_global_copy(&global_p, evp);
 		evp = &global_p;
+	} else if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE &&
+		   local_pi) {
+		/*
+		 * prefix in the global table needs MAC/IP, ensure they are
+		 * present, using one's from local table's path_info.
+		 */
+		if (is_evpn_prefix_ipaddr_none(evp)) {
+			/* VNI MAC -> Global */
+			evpn_type2_prefix_global_copy(
+				&global_p, evp, NULL /* mac */,
+				evpn_type2_path_info_get_ip(local_pi));
+		} else {
+			/* VNI IP -> Global */
+			evpn_type2_prefix_global_copy(
+				&global_p, evp,
+				evpn_type2_path_info_get_mac(local_pi),
+				NULL /* ip */);
+		}
+
+		evp = &global_p;
 	}
 	return bgp_afi_node_lookup(table, afi, safi, (struct prefix *)evp, prd);
 }
 
 /*
+ * Wrapper for node get in VNI IP table.
+ */
+struct bgp_dest *bgp_evpn_vni_ip_node_get(struct bgp_table *const table,
+					  const struct prefix_evpn *evp,
+					  const struct bgp_path_info *parent_pi)
+{
+	struct prefix_evpn vni_p;
+
+	if (evp->prefix.route_type == BGP_EVPN_AD_ROUTE && parent_pi) {
+		/* prefix in the global table doesn't include the VTEP-IP so
+		 * we need to create a different copy for the VNI
+		 */
+		evpn_type1_prefix_vni_ip_copy(&vni_p, evp,
+					      parent_pi->attr->nexthop);
+		evp = &vni_p;
+	} else if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+		/* Only MAC-IP should go into this table, not mac-only */
+		assert(is_evpn_prefix_ipaddr_none(evp) == false);
+
+		/*
+		 * prefix in the vni IP table doesn't include MAC so
+		 * we need to create a different copy of the prefix.
+		 */
+		evpn_type2_prefix_vni_ip_copy(&vni_p, evp);
+		evp = &vni_p;
+	}
+	return bgp_node_get(table, (struct prefix *)evp);
+}
+
+/*
+ * Wrapper for node lookup in VNI IP table.
+ */
+struct bgp_dest *
+bgp_evpn_vni_ip_node_lookup(const struct bgp_table *const table,
+			    const struct prefix_evpn *evp,
+			    const struct bgp_path_info *parent_pi)
+{
+	struct prefix_evpn vni_p;
+
+	if (evp->prefix.route_type == BGP_EVPN_AD_ROUTE && parent_pi) {
+		/* prefix in the global table doesn't include the VTEP-IP so
+		 * we need to create a different copy for the VNI
+		 */
+		evpn_type1_prefix_vni_ip_copy(&vni_p, evp,
+					      parent_pi->attr->nexthop);
+		evp = &vni_p;
+	} else if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+		/* Only MAC-IP should go into this table, not mac-only */
+		assert(is_evpn_prefix_ipaddr_none(evp) == false);
+
+		/*
+		 * prefix in the vni IP table doesn't include MAC so
+		 * we need to create a different copy of the prefix.
+		 */
+		evpn_type2_prefix_vni_ip_copy(&vni_p, evp);
+		evp = &vni_p;
+	}
+	return bgp_node_lookup(table, (struct prefix *)evp);
+}
+
+/*
+ * Wrapper for node get in VNI MAC table.
+ */
+struct bgp_dest *
+bgp_evpn_vni_mac_node_get(struct bgp_table *const table,
+			  const struct prefix_evpn *evp,
+			  const struct bgp_path_info *parent_pi)
+{
+	struct prefix_evpn vni_p;
+
+	/* Only type-2 should ever go into this table */
+	assert(evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE);
+
+	/*
+	 * prefix in the vni MAC table doesn't include IP so
+	 * we need to create a different copy of the prefix.
+	 */
+	evpn_type2_prefix_vni_mac_copy(&vni_p, evp);
+	evp = &vni_p;
+	return bgp_node_get(table, (struct prefix *)evp);
+}
+
+/*
+ * Wrapper for node lookup in VNI MAC table.
+ */
+struct bgp_dest *
+bgp_evpn_vni_mac_node_lookup(const struct bgp_table *const table,
+			     const struct prefix_evpn *evp,
+			     const struct bgp_path_info *parent_pi)
+{
+	struct prefix_evpn vni_p;
+
+	/* Only type-2 should ever go into this table */
+	assert(evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE);
+
+	/*
+	 * prefix in the vni MAC table doesn't include IP so
+	 * we need to create a different copy of the prefix.
+	 */
+	evpn_type2_prefix_vni_mac_copy(&vni_p, evp);
+	evp = &vni_p;
+	return bgp_node_lookup(table, (struct prefix *)evp);
+}
+
+/*
+ * Wrapper for node get in both VNI tables.
+ */
+struct bgp_dest *bgp_evpn_vni_node_get(struct bgpevpn *vpn,
+				       const struct prefix_evpn *p,
+				       const struct bgp_path_info *parent_pi)
+{
+	if ((p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) &&
+	    (is_evpn_prefix_ipaddr_none(p) == true))
+		return bgp_evpn_vni_mac_node_get(vpn->mac_table, p, parent_pi);
+
+	return bgp_evpn_vni_ip_node_get(vpn->ip_table, p, parent_pi);
+}
+
+/*
+ * Wrapper for node lookup in both VNI tables.
+ */
+struct bgp_dest *bgp_evpn_vni_node_lookup(const struct bgpevpn *vpn,
+					  const struct prefix_evpn *p,
+					  const struct bgp_path_info *parent_pi)
+{
+	if ((p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) &&
+	    (is_evpn_prefix_ipaddr_none(p) == true))
+		return bgp_evpn_vni_mac_node_lookup(vpn->mac_table, p,
+						    parent_pi);
+
+	return bgp_evpn_vni_ip_node_lookup(vpn->ip_table, p, parent_pi);
+}
+
+/*
  * Add (update) or delete MACIP from zebra.
  */
 static int bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
 				       const struct prefix_evpn *p,
+				       const struct ethaddr *mac,
 				       struct in_addr remote_vtep_ip, int add,
 				       uint8_t flags, uint32_t seq, esi_t *esi)
 {
 	struct stream *s;
 	uint16_t ipa_len;
 	static struct in_addr zero_remote_vtep_ip;
+	bool esi_valid;
 
 	/* Check socket. */
 	if (!zclient || zclient->sock < 0)
@@ -620,7 +896,12 @@ static int bgp_zebra_send_remote_macip(s
 		s, add ? ZEBRA_REMOTE_MACIP_ADD : ZEBRA_REMOTE_MACIP_DEL,
 		bgp->vrf_id);
 	stream_putl(s, vpn->vni);
-	stream_put(s, &p->prefix.macip_addr.mac.octet, ETH_ALEN); /* Mac Addr */
+
+	if (mac) /* Mac Addr */
+		stream_put(s, &mac->octet, ETH_ALEN);
+	else
+		stream_put(s, &p->prefix.macip_addr.mac.octet, ETH_ALEN);
+
 	/* IP address length and IP address, if any. */
 	if (is_evpn_prefix_ipaddr_none(p))
 		stream_putw(s, 0);
@@ -633,10 +914,13 @@ static int bgp_zebra_send_remote_macip(s
 	/* If the ESI is valid that becomes the nexthop; tape out the
 	 * VTEP-IP for that case
 	 */
-	if (bgp_evpn_is_esi_valid(esi))
+	if (bgp_evpn_is_esi_valid(esi)) {
+		esi_valid = true;
 		stream_put_in_addr(s, &zero_remote_vtep_ip);
-	else
+	} else {
+		esi_valid = false;
 		stream_put_in_addr(s, &remote_vtep_ip);
+	}
 
 	/* TX flags - MAC sticky status and/or gateway mac */
 	/* Also TX the sequence number of the best route. */
@@ -648,12 +932,20 @@ static int bgp_zebra_send_remote_macip(s
 
 	stream_putw_at(s, 0, stream_get_endp(s));
 
-	if (bgp_debug_zebra(NULL))
+	if (bgp_debug_zebra(NULL)) {
+		char esi_buf[ESI_STR_LEN];
+
+		if (esi_valid)
+			esi_to_str(esi, esi_buf, sizeof(esi_buf));
+		else
+			snprintf(esi_buf, sizeof(esi_buf), "-");
 		zlog_debug(
-			"Tx %s MACIP, VNI %u MAC %pEA IP %pIA flags 0x%x seq %u remote VTEP %pI4",
+			"Tx %s MACIP, VNI %u MAC %pEA IP %pIA flags 0x%x seq %u remote VTEP %pI4 esi %s",
 			add ? "ADD" : "DEL", vpn->vni,
-			&p->prefix.macip_addr.mac, &p->prefix.macip_addr.ip,
-			flags, seq, &remote_vtep_ip);
+			(mac ? mac : &p->prefix.macip_addr.mac),
+			&p->prefix.macip_addr.ip, flags, seq, &remote_vtep_ip,
+			esi_buf);
+	}
 
 	frrtrace(5, frr_bgp, evpn_mac_ip_zsend, add, vpn, p, remote_vtep_ip,
 		 esi);
@@ -724,8 +1016,9 @@ static void build_evpn_type5_route_extco
 	struct ecommunity_val eval_rmac;
 	bgp_encap_types tnl_type;
 	struct listnode *node, *nnode;
-	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
 	struct ecommunity *old_ecom;
+	struct ecommunity *ecom;
 	struct list *vrf_export_rtl = NULL;
 
 	/* Encap */
@@ -749,10 +1042,10 @@ static void build_evpn_type5_route_extco
 
 	/* Add the export RTs for L3VNI/VRF */
 	vrf_export_rtl = bgp_vrf->vrf_export_rtl;
-	for (ALL_LIST_ELEMENTS(vrf_export_rtl, node, nnode, ecom))
+	for (ALL_LIST_ELEMENTS(vrf_export_rtl, node, nnode, l3rt))
 		bgp_attr_set_ecommunity(
-			attr,
-			ecommunity_merge(bgp_attr_get_ecommunity(attr), ecom));
+			attr, ecommunity_merge(bgp_attr_get_ecommunity(attr),
+					       l3rt->ecom));
 
 	/* add the router mac extended community */
 	if (!is_zero_mac(&attr->rmac)) {
@@ -789,6 +1082,7 @@ static void build_evpn_route_extcomm(str
 	bgp_encap_types tnl_type;
 	struct listnode *node, *nnode;
 	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
 	uint32_t seqnum;
 	struct list *vrf_export_rtl = NULL;
 
@@ -817,12 +1111,12 @@ static void build_evpn_route_extcomm(str
 		vrf_export_rtl = bgpevpn_get_vrf_export_rtl(vpn);
 		if (vrf_export_rtl && !list_isempty(vrf_export_rtl)) {
 			for (ALL_LIST_ELEMENTS(vrf_export_rtl, node, nnode,
-					       ecom))
+					       l3rt))
 				bgp_attr_set_ecommunity(
 					attr,
 					ecommunity_merge(
 						bgp_attr_get_ecommunity(attr),
-						ecom));
+						l3rt->ecom));
 		}
 	}
 
@@ -985,8 +1279,13 @@ static int evpn_zebra_install(struct bgp
 		}
 
 		ret = bgp_zebra_send_remote_macip(
-				bgp, vpn, p, pi->attr->nexthop, 1, flags,
-				seq, bgp_evpn_attr_get_esi(pi->attr));
+			bgp, vpn, p,
+			(is_evpn_prefix_ipaddr_none(p)
+				 ? NULL /* MAC update */
+				 : evpn_type2_path_info_get_mac(
+					   pi) /* MAC-IP update */),
+			pi->attr->nexthop, 1, flags, seq,
+			bgp_evpn_attr_get_esi(pi->attr));
 	} else if (p->prefix.route_type == BGP_EVPN_AD_ROUTE) {
 		ret = bgp_evpn_remote_es_evi_add(bgp, vpn, p);
 	} else {
@@ -1012,13 +1311,19 @@ static int evpn_zebra_install(struct bgp
 /* Uninstall EVPN route from zebra. */
 static int evpn_zebra_uninstall(struct bgp *bgp, struct bgpevpn *vpn,
 				const struct prefix_evpn *p,
-				struct in_addr remote_vtep_ip)
+				struct bgp_path_info *pi, bool is_sync)
 {
 	int ret;
 
 	if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
-		ret = bgp_zebra_send_remote_macip(bgp, vpn, p, remote_vtep_ip,
-						0, 0, 0, NULL);
+		ret = bgp_zebra_send_remote_macip(
+			bgp, vpn, p,
+			(is_evpn_prefix_ipaddr_none(p)
+				 ? NULL /* MAC update */
+				 : evpn_type2_path_info_get_mac(
+					   pi) /* MAC-IP update */),
+			(is_sync ? zero_vtep_ip : pi->attr->nexthop), 0, 0, 0,
+			NULL);
 	else if (p->prefix.route_type == BGP_EVPN_AD_ROUTE)
 		ret = bgp_evpn_remote_es_evi_del(bgp, vpn, p);
 	else
@@ -1061,9 +1366,10 @@ static void evpn_delete_old_local_route(
 	 * this table is a 2-level tree (RD-level + Prefix-level) similar to
 	 * L3VPN routes.
 	 */
-	global_dest = bgp_global_evpn_node_lookup(bgp->rib[afi][safi], afi, safi,
-			(const struct prefix_evpn *)bgp_dest_get_prefix(dest),
-			&vpn->prd);
+	global_dest = bgp_evpn_global_node_lookup(
+		bgp->rib[afi][safi], afi, safi,
+		(const struct prefix_evpn *)bgp_dest_get_prefix(dest),
+		&vpn->prd, old_local);
 	if (global_dest) {
 		/* Delete route entry in the global EVPN table. */
 		delete_evpn_route_entry(bgp, afi, safi, global_dest, &pi);
@@ -1176,7 +1482,7 @@ int evpn_route_select_install(struct bgp
 				bgp, vpn,
 				(const struct prefix_evpn *)bgp_dest_get_prefix(
 					dest),
-				old_select->attr->nexthop);
+				old_select, false);
 	}
 
 	/* Clear any route change flags. */
@@ -1362,9 +1668,8 @@ static int update_evpn_type5_route(struc
 	build_evpn_type5_route_extcomm(bgp_vrf, &attr);
 
 	/* get the route node in global table */
-	dest = bgp_global_evpn_node_get(bgp_evpn->rib[afi][safi], afi, safi,
-			(const struct prefix_evpn *)evp,
-			&bgp_vrf->vrf_prd);
+	dest = bgp_evpn_global_node_get(bgp_evpn->rib[afi][safi], afi, safi,
+					evp, &bgp_vrf->vrf_prd, NULL);
 	assert(dest);
 
 	/* create or update the route entry within the route node */
@@ -1386,13 +1691,22 @@ static int update_evpn_type5_route(struc
 static void bgp_evpn_get_sync_info(struct bgp *bgp, esi_t *esi,
 				   struct bgp_dest *dest, uint32_t loc_seq,
 				   uint32_t *max_sync_seq, bool *active_on_peer,
-				   bool *peer_router, bool *proxy_from_peer)
+				   bool *peer_router, bool *proxy_from_peer,
+				   const struct ethaddr *mac)
 {
 	struct bgp_path_info *tmp_pi;
 	struct bgp_path_info *second_best_path = NULL;
 	uint32_t tmp_mm_seq = 0;
 	esi_t *tmp_esi;
 	int paths_eq;
+	struct ethaddr *tmp_mac;
+	bool mac_cmp = false;
+	struct prefix_evpn *evp = (struct prefix_evpn *)&dest->p;
+
+
+	/* mac comparison is not needed for MAC-only routes */
+	if (mac && !is_evpn_prefix_ipaddr_none(evp))
+		mac_cmp = true;
 
 	/* find the best non-local path. a local path can only be present
 	 * as best path
@@ -1403,6 +1717,13 @@ static void bgp_evpn_get_sync_info(struc
 			!CHECK_FLAG(tmp_pi->flags, BGP_PATH_VALID))
 			continue;
 
+		/* ignore paths that have a different mac */
+		if (mac_cmp) {
+			tmp_mac = evpn_type2_path_info_get_mac(tmp_pi);
+			if (memcmp(mac, tmp_mac, sizeof(*mac)))
+				continue;
+		}
+
 		if (bgp_evpn_path_info_cmp(bgp, tmp_pi,
 				second_best_path, &paths_eq))
 			second_best_path = tmp_pi;
@@ -1447,7 +1768,8 @@ static void bgp_evpn_get_sync_info(struc
 static void update_evpn_route_entry_sync_info(struct bgp *bgp,
 					      struct bgp_dest *dest,
 					      struct attr *attr,
-					      uint32_t loc_seq, bool setup_sync)
+					      uint32_t loc_seq, bool setup_sync,
+					      const struct ethaddr *mac)
 {
 	esi_t *esi;
 	struct prefix_evpn *evp =
@@ -1466,7 +1788,8 @@ static void update_evpn_route_entry_sync
 
 			bgp_evpn_get_sync_info(bgp, esi, dest, loc_seq,
 					       &max_sync_seq, &active_on_peer,
-					       &peer_router, &proxy_from_peer);
+					       &peer_router, &proxy_from_peer,
+					       mac);
 			attr->mm_sync_seqnum = max_sync_seq;
 			if (active_on_peer)
 				attr->es_flags |= ATTR_ES_PEER_ACTIVE;
@@ -1509,15 +1832,16 @@ static void update_evpn_route_entry_sync
 }
 
 /*
- * Create or update EVPN route entry. This could be in the VNI route table
+ * Create or update EVPN route entry. This could be in the VNI route tables
  * or the global route table.
  */
 static int update_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 				   afi_t afi, safi_t safi,
 				   struct bgp_dest *dest, struct attr *attr,
-				   int add, struct bgp_path_info **pi,
-				   uint8_t flags, uint32_t seq, bool vpn_rt,
-				   bool *old_is_sync)
+				   const struct ethaddr *mac,
+				   const struct ipaddr *ip, int add,
+				   struct bgp_path_info **pi, uint8_t flags,
+				   uint32_t seq, bool vpn_rt, bool *old_is_sync)
 {
 	struct bgp_path_info *tmp_pi;
 	struct bgp_path_info *local_pi;
@@ -1548,7 +1872,7 @@ static int update_evpn_route_entry(struc
 	/* if a local path is being added with a non-zero esi look
 	 * for SYNC paths from ES peers and bubble up the sync-info
 	 */
-	update_evpn_route_entry_sync_info(bgp, dest, attr, seq, vpn_rt);
+	update_evpn_route_entry_sync_info(bgp, dest, attr, seq, vpn_rt, mac);
 
 	/* For non-GW MACs, update MAC mobility seq number, if needed. */
 	if (seq && !CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_GW))
@@ -1589,6 +1913,14 @@ static int update_evpn_route_entry(struc
 
 		memcpy(&tmp_pi->extra->label, label, sizeof(label));
 		tmp_pi->extra->num_labels = num_labels;
+
+		if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+			if (mac)
+				evpn_type2_path_info_set_mac(tmp_pi, *mac);
+			else if (ip)
+				evpn_type2_path_info_set_ip(tmp_pi, *ip);
+		}
+
 		/* Mark route as self type-2 route */
 		if (flags && CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_SVI_IP))
 			tmp_pi->extra->af_flags = BGP_EVPN_MACIP_TYPE_SVI_IP;
@@ -1618,6 +1950,15 @@ static int update_evpn_route_entry(struc
 			memcpy(&tmp_pi->extra->label, label, sizeof(label));
 			tmp_pi->extra->num_labels = num_labels;
 
+			if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+				if (mac)
+					evpn_type2_path_info_set_mac(tmp_pi,
+								     *mac);
+				else if (ip)
+					evpn_type2_path_info_set_ip(tmp_pi,
+								    *ip);
+			}
+
 			/* The attribute has changed. */
 			/* Add (or update) attribute to hash. */
 			attr_new = bgp_attr_intern(attr);
@@ -1737,6 +2078,7 @@ static int update_evpn_route(struct bgp
 	safi_t safi = SAFI_EVPN;
 	int route_change;
 	bool old_is_sync = false;
+	bool mac_only = false;
 
 	memset(&attr, 0, sizeof(attr));
 
@@ -1777,10 +2119,11 @@ static int update_evpn_route(struct bgp
 		char buf3[ESI_STR_LEN];
 
 		zlog_debug(
-			"VRF %s vni %u type-2 route evp %pFX RMAC %pEA nexthop %pI4 esi %s",
+			"VRF %s vni %u type-%u route evp %pFX RMAC %pEA nexthop %pI4 esi %s",
 			vpn->bgp_vrf ? vrf_id_to_name(vpn->bgp_vrf->vrf_id)
-				     : " ",
-			vpn->vni, p, &attr.rmac, &attr.mp_nexthop_global_in,
+				     : "None",
+			vpn->vni, p->prefix.route_type, p, &attr.rmac,
+			&attr.mp_nexthop_global_in,
 			esi_to_str(esi, buf3, sizeof(buf3)));
 	}
 
@@ -1796,14 +2139,20 @@ static int update_evpn_route(struct bgp
 	/* Set up extended community. */
 	build_evpn_route_extcomm(vpn, &attr, add_l3_ecomm);
 
-	/* First, create (or fetch) route node within the VNI. */
-	/* NOTE: There is no RD here. */
-	dest = bgp_node_get(vpn->route_table, (struct prefix *)p);
+	/* First, create (or fetch) route node within the VNI.
+	 * NOTE: There is no RD here.
+	 */
+	dest = bgp_evpn_vni_node_get(vpn, p, NULL);
+
+	if ((p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) &&
+	    (is_evpn_prefix_ipaddr_none(p) == true))
+		mac_only = true;
 
 	/* Create or update route entry. */
-	route_change = update_evpn_route_entry(bgp, vpn, afi, safi, dest, &attr,
-			1, &pi, flags, seq,
-			true /* setup_sync */, &old_is_sync);
+	route_change = update_evpn_route_entry(
+		bgp, vpn, afi, safi, dest, &attr,
+		(mac_only ? NULL : &p->prefix.macip_addr.mac), NULL /* ip */, 1,
+		&pi, flags, seq, true /* setup_sync */, &old_is_sync);
 	assert(pi);
 	attr_new = pi->attr;
 
@@ -1841,7 +2190,7 @@ static int update_evpn_route(struct bgp
 			 */
 			new_is_sync = bgp_evpn_attr_is_sync(pi->attr);
 			if (!new_is_sync && old_is_sync)
-				evpn_zebra_uninstall(bgp, vpn, p, zero_vtep_ip);
+				evpn_zebra_uninstall(bgp, vpn, p, pi, true);
 		}
 	}
 	bgp_path_info_unlock(pi);
@@ -1856,12 +2205,12 @@ static int update_evpn_route(struct bgp
 	if (route_change) {
 		struct bgp_path_info *global_pi;
 
-		dest = bgp_global_evpn_node_get(bgp->rib[afi][safi], afi, safi,
-				(const struct prefix_evpn *)p,
-				&vpn->prd);
-		update_evpn_route_entry(bgp, vpn, afi, safi, dest, attr_new, 1,
-				&global_pi, flags, seq,
-				false /* setup_sync */, NULL /* old_is_sync */);
+		dest = bgp_evpn_global_node_get(bgp->rib[afi][safi], afi, safi,
+						p, &vpn->prd, NULL);
+		update_evpn_route_entry(
+			bgp, vpn, afi, safi, dest, attr_new, NULL /* mac */,
+			NULL /* ip */, 1, &global_pi, flags, seq,
+			false /* setup_sync */, NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
 		bgp_process(bgp, dest, afi, safi);
@@ -1915,8 +2264,8 @@ static int delete_evpn_type5_route(struc
 		return 0;
 
 	/* locate the global route entry for this type-5 prefix */
-	dest = bgp_global_evpn_node_lookup(bgp_evpn->rib[afi][safi], afi, safi,
-			(const struct prefix_evpn *)evp, &bgp_vrf->vrf_prd);
+	dest = bgp_evpn_global_node_lookup(bgp_evpn->rib[afi][safi], afi, safi,
+					   evp, &bgp_vrf->vrf_prd, NULL);
 	if (!dest)
 		return 0;
 
@@ -1942,9 +2291,9 @@ static int delete_evpn_route(struct bgp
 	/* First, locate the route node within the VNI. If it doesn't exist,
 	 * there
 	 * is nothing further to do.
+	 * NOTE: There is no RD here.
 	 */
-	/* NOTE: There is no RD here. */
-	dest = bgp_node_lookup(vpn->route_table, (struct prefix *)p);
+	dest = bgp_evpn_vni_node_lookup(vpn, p, NULL);
 	if (!dest)
 		return 0;
 
@@ -1952,8 +2301,8 @@ static int delete_evpn_route(struct bgp
 	 * this table is a 2-level tree (RD-level + Prefix-level) similar to
 	 * L3VPN routes.
 	 */
-	global_dest = bgp_global_evpn_node_lookup(bgp->rib[afi][safi], afi, safi,
-			(const struct prefix_evpn *)p, &vpn->prd);
+	global_dest = bgp_evpn_global_node_lookup(bgp->rib[afi][safi], afi,
+						  safi, p, &vpn->prd, NULL);
 	if (global_dest) {
 		/* Delete route entry in the global EVPN table. */
 		delete_evpn_route_entry(bgp, afi, safi, global_dest, &pi);
@@ -1992,8 +2341,7 @@ void bgp_evpn_update_type2_route_entry(s
 	int add_l3_ecomm = 0;
 	struct bgp_dest *global_dest;
 	struct bgp_path_info *global_pi;
-	struct prefix_evpn *evp =
-		(struct prefix_evpn *)bgp_dest_get_prefix(dest);
+	struct prefix_evpn evp;
 	int route_change;
 	bool old_is_sync = false;
 
@@ -2001,6 +2349,22 @@ void bgp_evpn_update_type2_route_entry(s
 		return;
 
 	/*
+	 * VNI table MAC-IP prefixes don't have MAC so make sure it's set from
+	 * path info here.
+	 */
+	if (is_evpn_prefix_ipaddr_none((struct prefix_evpn *)&dest->p)) {
+		/* VNI MAC -> Global */
+		evpn_type2_prefix_global_copy(
+			&evp, (struct prefix_evpn *)&dest->p, NULL /* mac */,
+			evpn_type2_path_info_get_ip(local_pi));
+	} else {
+		/* VNI IP -> Global */
+		evpn_type2_prefix_global_copy(
+			&evp, (struct prefix_evpn *)&dest->p,
+			evpn_type2_path_info_get_mac(local_pi), NULL /* ip */);
+	}
+
+	/*
 	 * Build attribute per local route as the MAC mobility and
 	 * some other values could differ for different routes. The
 	 * attributes will be shared in the hash table.
@@ -2014,18 +2378,17 @@ void bgp_evpn_update_type2_route_entry(s
 	attr.es_flags = local_pi->attr->es_flags;
 	if (local_pi->attr->default_gw) {
 		attr.default_gw = 1;
-		if (is_evpn_prefix_ipaddr_v6(evp))
+		if (is_evpn_prefix_ipaddr_v6(&evp))
 			attr.router_flag = 1;
 	}
 	memcpy(&attr.esi, &local_pi->attr->esi, sizeof(esi_t));
-	bgp_evpn_get_rmac_nexthop(vpn, evp, &attr,
-			local_pi->extra->af_flags);
+	bgp_evpn_get_rmac_nexthop(vpn, &evp, &attr, local_pi->extra->af_flags);
 	vni2label(vpn->vni, &(attr.label));
 	/* Add L3 VNI RTs and RMAC for non IPv6 link-local if
 	 * using L3 VNI for type-2 routes also.
 	 */
 	add_l3_ecomm = bgp_evpn_route_add_l3_ecomm_ok(
-		vpn, evp,
+		vpn, &evp,
 		(attr.es_flags & ATTR_ES_IS_LOCAL) ? &attr.esi : NULL);
 
 	/* Set up extended community. */
@@ -2039,15 +2402,15 @@ void bgp_evpn_update_type2_route_entry(s
 			"VRF %s vni %u evp %pFX RMAC %pEA nexthop %pI4 esi %s esf 0x%x from %s",
 			vpn->bgp_vrf ? vrf_id_to_name(vpn->bgp_vrf->vrf_id)
 				     : " ",
-			vpn->vni, evp, &attr.rmac, &attr.mp_nexthop_global_in,
+			vpn->vni, &evp, &attr.rmac, &attr.mp_nexthop_global_in,
 			esi_to_str(&attr.esi, buf3, sizeof(buf3)),
 			attr.es_flags, caller);
 	}
 
 	/* Update the route entry. */
 	route_change = update_evpn_route_entry(
-		bgp, vpn, afi, safi, dest, &attr, 0, &pi, 0, seq,
-		true /* setup_sync */, &old_is_sync);
+		bgp, vpn, afi, safi, dest, &attr, NULL /* mac */, NULL /* ip */,
+		0, &pi, 0, seq, true /* setup_sync */, &old_is_sync);
 
 	assert(pi);
 	attr_new = pi->attr;
@@ -2082,8 +2445,7 @@ void bgp_evpn_update_type2_route_entry(s
 			 */
 			new_is_sync = bgp_evpn_attr_is_sync(pi->attr);
 			if (!new_is_sync && old_is_sync)
-				evpn_zebra_uninstall(bgp, vpn,
-						evp, zero_vtep_ip);
+				evpn_zebra_uninstall(bgp, vpn, &evp, pi, true);
 		}
 	}
 
@@ -2093,13 +2455,14 @@ void bgp_evpn_update_type2_route_entry(s
 
 	if (route_change) {
 		/* Update route in global routing table. */
-		global_dest = bgp_global_evpn_node_get(bgp->rib[afi][safi], afi,
-						       safi, evp, &vpn->prd);
+		global_dest = bgp_evpn_global_node_get(
+			bgp->rib[afi][safi], afi, safi, &evp, &vpn->prd, NULL);
 		assert(global_dest);
 		update_evpn_route_entry(
-			bgp, vpn, afi, safi, global_dest, attr_new, 0,
-			&global_pi, 0, mac_mobility_seqnum(attr_new),
-			false /* setup_sync */, NULL /* old_is_sync */);
+			bgp, vpn, afi, safi, global_dest, attr_new,
+			NULL /* mac */, NULL /* ip */, 0, &global_pi, 0,
+			mac_mobility_seqnum(attr_new), false /* setup_sync */,
+			NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
 		bgp_process(bgp, global_dest, afi, safi);
@@ -2110,43 +2473,51 @@ void bgp_evpn_update_type2_route_entry(s
 	aspath_unintern(&attr.aspath);
 }
 
+static void update_type2_route(struct bgp *bgp, struct bgpevpn *vpn,
+			       struct bgp_dest *dest)
+{
+	struct bgp_path_info *tmp_pi;
+
+	const struct prefix_evpn *evp =
+		(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
+
+	if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
+		return;
+
+	/* Identify local route. */
+	for (tmp_pi = bgp_dest_get_bgp_path_info(dest); tmp_pi;
+	     tmp_pi = tmp_pi->next) {
+		if (tmp_pi->peer == bgp->peer_self &&
+		    tmp_pi->type == ZEBRA_ROUTE_BGP &&
+		    tmp_pi->sub_type == BGP_ROUTE_STATIC)
+			break;
+	}
+
+	if (!tmp_pi)
+		return;
+
+	bgp_evpn_update_type2_route_entry(bgp, vpn, dest, tmp_pi, __func__);
+}
+
 /*
  * Update all type-2 (MACIP) local routes for this VNI - these should also
  * be scheduled for advertise to peers.
  */
-static int update_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+static void update_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct bgp_dest *dest;
-	struct bgp_path_info *tmp_pi;
 
-	/* Walk this VNI's route table and update local type-2 routes. For any
-	 * routes updated, update corresponding entry in the global table too.
+	/* Walk this VNI's route MAC & IP table and update local type-2
+	 * routes. For any routes updated, update corresponding entry in the
+	 * global table too.
 	 */
-	for (dest = bgp_table_top(vpn->route_table); dest;
-			dest = bgp_route_next(dest)) {
-		const struct prefix_evpn *evp =
-			(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
-
-		if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
-			continue;
-
-		/* Identify local route. */
-		for (tmp_pi = bgp_dest_get_bgp_path_info(dest); tmp_pi;
-				tmp_pi = tmp_pi->next) {
-			if (tmp_pi->peer == bgp->peer_self
-					&& tmp_pi->type == ZEBRA_ROUTE_BGP
-					&& tmp_pi->sub_type == BGP_ROUTE_STATIC)
-				break;
-		}
-
-		if (!tmp_pi)
-			continue;
-
-		bgp_evpn_update_type2_route_entry(bgp, vpn, dest, tmp_pi,
-				__func__);
-	}
+	for (dest = bgp_table_top(vpn->mac_table); dest;
+	     dest = bgp_route_next(dest))
+		update_type2_route(bgp, vpn, dest);
 
-	return 0;
+	for (dest = bgp_table_top(vpn->ip_table); dest;
+	     dest = bgp_route_next(dest))
+		update_type2_route(bgp, vpn, dest);
 }
 
 /*
@@ -2187,55 +2558,65 @@ static void delete_global_type2_routes(s
 	}
 }
 
+static void delete_vni_type2_route(struct bgp *bgp, struct bgp_dest *dest)
+{
+	struct bgp_path_info *pi;
+	afi_t afi = AFI_L2VPN;
+	safi_t safi = SAFI_EVPN;
+
+	const struct prefix_evpn *evp =
+		(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
+
+	if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
+		return;
+
+	delete_evpn_route_entry(bgp, afi, safi, dest, &pi);
+
+	/* Route entry in local table gets deleted immediately. */
+	if (pi)
+		bgp_path_info_reap(dest, pi);
+}
+
+static void delete_vni_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+{
+	struct bgp_dest *dest;
+
+	/* Next, walk this VNI's MAC & IP route table and delete local type-2
+	 * routes.
+	 */
+	for (dest = bgp_table_top(vpn->mac_table); dest;
+	     dest = bgp_route_next(dest))
+		delete_vni_type2_route(bgp, dest);
+
+	for (dest = bgp_table_top(vpn->ip_table); dest;
+	     dest = bgp_route_next(dest))
+		delete_vni_type2_route(bgp, dest);
+}
+
 /*
  * Delete all type-2 (MACIP) local routes for this VNI - from the global
  * table as well as the per-VNI route table.
  */
-static int delete_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+static void delete_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
-	afi_t afi;
-	safi_t safi;
-	struct bgp_dest *dest;
-	struct bgp_path_info *pi;
-
-	afi = AFI_L2VPN;
-	safi = SAFI_EVPN;
-
 	/* First, walk the global route table for this VNI's type-2 local
 	 * routes.
 	 * EVPN routes are a 2-level table, first get the RD table.
 	 */
 	delete_global_type2_routes(bgp, vpn);
-
-	/* Next, walk this VNI's route table and delete local type-2 routes. */
-	for (dest = bgp_table_top(vpn->route_table); dest;
-	     dest = bgp_route_next(dest)) {
-		const struct prefix_evpn *evp =
-			(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
-
-		if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
-			continue;
-
-		delete_evpn_route_entry(bgp, afi, safi, dest, &pi);
-
-		/* Route entry in local table gets deleted immediately. */
-		if (pi)
-			bgp_path_info_reap(dest, pi);
-	}
-
-	return 0;
+	delete_vni_type2_routes(bgp, vpn);
 }
 
 /*
  * Delete all routes in the per-VNI route table.
  */
-static int delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
+static void delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct bgp_dest *dest;
 	struct bgp_path_info *pi, *nextpi;
 
-	/* Walk this VNI's route table and delete all routes. */
-	for (dest = bgp_table_top(vpn->route_table); dest;
+	/* Walk this VNI's MAC & IP route table and delete all routes. */
+	for (dest = bgp_table_top(vpn->mac_table); dest;
 	     dest = bgp_route_next(dest)) {
 		for (pi = bgp_dest_get_bgp_path_info(dest);
 		     (pi != NULL) && (nextpi = pi->next, 1); pi = nextpi) {
@@ -2245,7 +2626,14 @@ static int delete_all_vni_routes(struct
 		}
 	}
 
-	return 0;
+	for (dest = bgp_table_top(vpn->ip_table); dest;
+	     dest = bgp_route_next(dest)) {
+		for (pi = bgp_dest_get_bgp_path_info(dest);
+		     (pi != NULL) && (nextpi = pi->next, 1); pi = nextpi) {
+			bgp_path_info_delete(dest, pi);
+			bgp_path_info_reap(dest, pi);
+		}
+	}
 }
 
 /* BUM traffic flood mode per-l2-vni */
@@ -2292,7 +2680,8 @@ int update_routes_for_vni(struct bgp *bg
 			return ret;
 	}
 
-	return update_all_type2_routes(bgp, vpn);
+	update_all_type2_routes(bgp, vpn);
+	return 0;
 }
 
 /*
@@ -2309,9 +2698,7 @@ static int delete_routes_for_vni(struct
 	/* Delete and withdraw locally learnt type-2 routes (MACIP)
 	 * followed by type-3 routes (only one) - for this VNI.
 	 */
-	ret = delete_all_type2_routes(bgp, vpn);
-	if (ret)
-		return ret;
+	delete_all_type2_routes(bgp, vpn);
 
 	build_evpn_type3_prefix(&p, vpn->originator_ip);
 	ret = delete_evpn_route(bgp, vpn, &p);
@@ -2319,7 +2706,8 @@ static int delete_routes_for_vni(struct
 		return ret;
 
 	/* Delete all routes from the per-VNI table. */
-	return delete_all_vni_routes(bgp, vpn);
+	delete_all_vni_routes(bgp, vpn);
+	return 0;
 }
 
 /*
@@ -2348,23 +2736,29 @@ static int bgp_evpn_mcast_grp_change(str
  * Note: Route re-advertisement happens elsewhere after other processing
  * other changes.
  */
-static int handle_tunnel_ip_change(struct bgp *bgp, struct bgpevpn *vpn,
-				   struct in_addr originator_ip)
+static void handle_tunnel_ip_change(struct bgp *bgp, struct bgpevpn *vpn,
+				    struct in_addr originator_ip)
 {
 	struct prefix_evpn p;
 
+	if (IPV4_ADDR_SAME(&vpn->originator_ip, &originator_ip))
+		return;
+
 	/* If VNI is not live, we only need to update the originator ip */
 	if (!is_vni_live(vpn)) {
 		vpn->originator_ip = originator_ip;
-		return 0;
+		return;
 	}
 
 	/* Update the tunnel-ip hash */
 	bgp_tip_del(bgp, &vpn->originator_ip);
-	bgp_tip_add(bgp, &originator_ip);
-
-	/* filter routes as martian nexthop db has changed */
-	bgp_filter_evpn_routes_upon_martian_nh_change(bgp);
+	if (bgp_tip_add(bgp, &originator_ip))
+		/* The originator_ip was not already present in the
+		 * bgp martian next-hop table as a tunnel-ip, so we
+		 * need to go back and filter routes matching the new
+		 * martian next-hop.
+		 */
+		bgp_filter_evpn_routes_upon_martian_nh_change(bgp);
 
 	/* Need to withdraw type-3 route as the originator IP is part
 	 * of the key.
@@ -2374,7 +2768,7 @@ static int handle_tunnel_ip_change(struc
 
 	/* Update the tunnel IP and re-advertise all routes for this VNI. */
 	vpn->originator_ip = originator_ip;
-	return 0;
+	return;
 }
 
 static struct bgp_path_info *
@@ -2400,6 +2794,7 @@ bgp_create_evpn_bgp_path_info(struct bgp
 		pi->extra->num_labels = parent_pi->extra->num_labels;
 		pi->extra->igpmetric = parent_pi->extra->igpmetric;
 	}
+
 	bgp_path_info_add(dest, pi);
 
 	return pi;
@@ -2578,32 +2973,19 @@ static int install_evpn_route_entry_in_v
 }
 
 /*
- * Install route entry into the VNI routing table and invoke route selection.
+ * Common handling for vni route tables install/selection.
  */
-static int install_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
-				    const struct prefix_evpn *p,
-				    struct bgp_path_info *parent_pi)
+static int install_evpn_route_entry_in_vni_common(
+	struct bgp *bgp, struct bgpevpn *vpn, const struct prefix_evpn *p,
+	struct bgp_dest *dest, struct bgp_path_info *parent_pi)
 {
-	struct bgp_dest *dest;
 	struct bgp_path_info *pi;
 	struct bgp_path_info *local_pi;
 	struct attr *attr_new;
 	int ret;
-	struct prefix_evpn ad_evp;
 	bool old_local_es = false;
 	bool new_local_es;
 
-	/* EAD prefix in the global table doesn't include the VTEP-IP so
-	 * we need to create a different copy for the VNI
-	 */
-	if (p->prefix.route_type == BGP_EVPN_AD_ROUTE)
-		p = evpn_type1_prefix_vni_copy(&ad_evp, p,
-				parent_pi->attr->nexthop);
-
-	/* Create (or fetch) route within the VNI. */
-	/* NOTE: There is no RD here. */
-	dest = bgp_node_get(vpn->route_table, (struct prefix *)p);
-
 	/* Check if route entry is already present. */
 	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
 		if (pi->extra
@@ -2614,13 +2996,27 @@ static int install_evpn_route_entry(stru
 		/* Create an info */
 		pi = bgp_create_evpn_bgp_path_info(parent_pi, dest,
 						    parent_pi->attr);
+
+		if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+			if (is_evpn_type2_dest_ipaddr_none(dest))
+				evpn_type2_path_info_set_ip(
+					pi, p->prefix.macip_addr.ip);
+			else
+				evpn_type2_path_info_set_mac(
+					pi, p->prefix.macip_addr.mac);
+		}
+
 		new_local_es = bgp_evpn_attr_is_local_es(pi->attr);
 	} else {
-		if (attrhash_cmp(pi->attr, parent_pi->attr)
-		    && !CHECK_FLAG(pi->flags, BGP_PATH_REMOVED)) {
-			bgp_dest_unlock_node(dest);
+		/* Return early if attributes haven't changed
+		 * and dest isn't flagged for removal.
+		 * dest will be unlocked by either
+		 * install_evpn_route_entry_in_vni_mac() or
+		 * install_evpn_route_entry_in_vni_ip()
+		 */
+		if (attrhash_cmp(pi->attr, parent_pi->attr) &&
+		    !CHECK_FLAG(pi->flags, BGP_PATH_REMOVED))
 			return 0;
-		}
 		/* The attribute has changed. */
 		/* Add (or update) attribute to hash. */
 		attr_new = bgp_attr_intern(parent_pi->attr);
@@ -2671,12 +3067,160 @@ static int install_evpn_route_entry(stru
 	if (local_pi && (old_local_es || new_local_es))
 		bgp_evpn_update_type2_route_entry(bgp, vpn, dest, local_pi,
 						  __func__);
+
+	return ret;
+}
+
+/*
+ * Common handling for vni route tables uninstall/selection.
+ */
+static int uninstall_evpn_route_entry_in_vni_common(
+	struct bgp *bgp, struct bgpevpn *vpn, const struct prefix_evpn *p,
+	struct bgp_dest *dest, struct bgp_path_info *parent_pi)
+{
+	struct bgp_path_info *pi;
+	struct bgp_path_info *local_pi;
+	int ret;
+
+	/* Find matching route entry. */
+	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
+		if (pi->extra &&
+		    (struct bgp_path_info *)pi->extra->parent == parent_pi)
+			break;
+
+	if (!pi)
+		return 0;
+
+	bgp_evpn_remote_ip_hash_del(vpn, pi);
+
+	/* Mark entry for deletion */
+	bgp_path_info_delete(dest, pi);
+
+	/* Perform route selection and update zebra, if required. */
+	ret = evpn_route_select_install(bgp, vpn, dest);
+
+	/* if the best path is a local path with a non-zero ES
+	 * sync info against the local path may need to be updated
+	 * when a remote path is deleted
+	 */
+	local_pi = bgp_evpn_route_get_local_path(bgp, dest);
+	if (local_pi && bgp_evpn_attr_is_local_es(local_pi->attr))
+		bgp_evpn_update_type2_route_entry(bgp, vpn, dest, local_pi,
+						  __func__);
+
+	return ret;
+}
+
+/*
+ * Install route entry into VNI IP table and invoke route selection.
+ */
+static int install_evpn_route_entry_in_vni_ip(struct bgp *bgp,
+					      struct bgpevpn *vpn,
+					      const struct prefix_evpn *p,
+					      struct bgp_path_info *parent_pi)
+{
+	int ret;
+	struct bgp_dest *dest;
+
+	/* Ignore MAC Only Type-2 */
+	if ((p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) &&
+	    (is_evpn_prefix_ipaddr_none(p) == true))
+		return 0;
+
+	/* Create (or fetch) route within the VNI IP table. */
+	dest = bgp_evpn_vni_ip_node_get(vpn->ip_table, p, parent_pi);
+
+	ret = install_evpn_route_entry_in_vni_common(bgp, vpn, p, dest,
+						     parent_pi);
+
+	bgp_dest_unlock_node(dest);
+
+	return ret;
+}
+
+/*
+ * Install route entry into VNI MAC table and invoke route selection.
+ */
+static int install_evpn_route_entry_in_vni_mac(struct bgp *bgp,
+					       struct bgpevpn *vpn,
+					       const struct prefix_evpn *p,
+					       struct bgp_path_info *parent_pi)
+{
+	int ret;
+	struct bgp_dest *dest;
+
+	/* Only type-2 routes go into this table */
+	if (p->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
+		return 0;
+
+	/* Create (or fetch) route within the VNI MAC table. */
+	dest = bgp_evpn_vni_mac_node_get(vpn->mac_table, p, parent_pi);
+
+	ret = install_evpn_route_entry_in_vni_common(bgp, vpn, p, dest,
+						     parent_pi);
+
+	bgp_dest_unlock_node(dest);
+
+	return ret;
+}
+
+/*
+ * Uninstall route entry from VNI IP table and invoke route selection.
+ */
+static int uninstall_evpn_route_entry_in_vni_ip(struct bgp *bgp,
+						struct bgpevpn *vpn,
+						const struct prefix_evpn *p,
+						struct bgp_path_info *parent_pi)
+{
+	int ret;
+	struct bgp_dest *dest;
+
+	/* Ignore MAC Only Type-2 */
+	if ((p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) &&
+	    (is_evpn_prefix_ipaddr_none(p) == true))
+		return 0;
+
+	/* Locate route within the VNI IP table. */
+	dest = bgp_evpn_vni_ip_node_lookup(vpn->ip_table, p, parent_pi);
+	if (!dest)
+		return 0;
+
+	ret = uninstall_evpn_route_entry_in_vni_common(bgp, vpn, p, dest,
+						       parent_pi);
+
 	bgp_dest_unlock_node(dest);
 
 	return ret;
 }
 
 /*
+ * Uninstall route entry from VNI IP table and invoke route selection.
+ */
+static int
+uninstall_evpn_route_entry_in_vni_mac(struct bgp *bgp, struct bgpevpn *vpn,
+				      const struct prefix_evpn *p,
+				      struct bgp_path_info *parent_pi)
+{
+	int ret;
+	struct bgp_dest *dest;
+
+	/* Only type-2 routes go into this table */
+	if (p->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE)
+		return 0;
+
+	/* Locate route within the VNI MAC table. */
+	dest = bgp_evpn_vni_mac_node_lookup(vpn->mac_table, p, parent_pi);
+	if (!dest)
+		return 0;
+
+	ret = uninstall_evpn_route_entry_in_vni_common(bgp, vpn, p, dest,
+						       parent_pi);
+
+	bgp_dest_unlock_node(dest);
+
+	return ret;
+}
+/*
  * Uninstall route entry from the VRF routing table and send message
  * to zebra, if appropriate.
  */
@@ -2754,62 +3298,79 @@ static int uninstall_evpn_route_entry_in
 }
 
 /*
- * Uninstall route entry from the VNI routing table and send message
- * to zebra, if appropriate.
+ * Install route entry into the VNI routing tables.
+ */
+static int install_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
+				    const struct prefix_evpn *p,
+				    struct bgp_path_info *parent_pi)
+{
+	int ret = 0;
+
+	if (bgp_debug_update(parent_pi->peer, NULL, NULL, 1))
+		zlog_debug(
+			"%s (%u): Installing EVPN %pFX route in VNI %u IP/MAC table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
+
+	ret = install_evpn_route_entry_in_vni_mac(bgp, vpn, p, parent_pi);
+
+	if (ret) {
+		flog_err(
+			EC_BGP_EVPN_FAIL,
+			"%s (%u): Failed to install EVPN %pFX route in VNI %u MAC table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
+
+		return ret;
+	}
+
+	ret = install_evpn_route_entry_in_vni_ip(bgp, vpn, p, parent_pi);
+
+	if (ret) {
+		flog_err(
+			EC_BGP_EVPN_FAIL,
+			"%s (%u): Failed to install EVPN %pFX route in VNI %u IP table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
+
+		return ret;
+	}
+
+	return ret;
+}
+
+/*
+ * Uninstall route entry from the VNI routing tables.
  */
 static int uninstall_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 				      const struct prefix_evpn *p,
 				      struct bgp_path_info *parent_pi)
 {
-	struct bgp_dest *dest;
-	struct bgp_path_info *pi;
-	struct bgp_path_info *local_pi;
-	int ret;
-	struct prefix_evpn ad_evp;
+	int ret = 0;
 
-	/* EAD prefix in the global table doesn't include the VTEP-IP so
-	 * we need to create a different copy for the VNI
-	 */
-	if (p->prefix.route_type == BGP_EVPN_AD_ROUTE)
-		p = evpn_type1_prefix_vni_copy(&ad_evp, p,
-				parent_pi->attr->nexthop);
+	if (bgp_debug_update(parent_pi->peer, NULL, NULL, 1))
+		zlog_debug(
+			"%s (%u): Uninstalling EVPN %pFX route from VNI %u IP/MAC table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
 
-	/* Locate route within the VNI. */
-	/* NOTE: There is no RD here. */
-	dest = bgp_node_lookup(vpn->route_table, (struct prefix *)p);
-	if (!dest)
-		return 0;
+	ret = uninstall_evpn_route_entry_in_vni_ip(bgp, vpn, p, parent_pi);
 
-	/* Find matching route entry. */
-	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
-		if (pi->extra
-		    && (struct bgp_path_info *)pi->extra->parent == parent_pi)
-			break;
+	if (ret) {
+		flog_err(
+			EC_BGP_EVPN_FAIL,
+			"%s (%u): Failed to uninstall EVPN %pFX route from VNI %u IP table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
 
-	if (!pi) {
-		bgp_dest_unlock_node(dest);
-		return 0;
+		return ret;
 	}
 
-	bgp_evpn_remote_ip_hash_del(vpn, pi);
-
-	/* Mark entry for deletion */
-	bgp_path_info_delete(dest, pi);
+	ret = uninstall_evpn_route_entry_in_vni_mac(bgp, vpn, p, parent_pi);
 
-	/* Perform route selection and update zebra, if required. */
-	ret = evpn_route_select_install(bgp, vpn, dest);
-
-	/* if the best path is a local path with a non-zero ES
-	 * sync info against the local path may need to be updated
-	 * when a remote path is deleted
-	 */
-	local_pi = bgp_evpn_route_get_local_path(bgp, dest);
-	if (local_pi && bgp_evpn_attr_is_local_es(local_pi->attr))
-		bgp_evpn_update_type2_route_entry(bgp, vpn, dest, local_pi,
-			__func__);
+	if (ret) {
+		flog_err(
+			EC_BGP_EVPN_FAIL,
+			"%s (%u): Failed to uninstall EVPN %pFX route from VNI %u MAC table",
+			vrf_id_to_name(bgp->vrf_id), bgp->vrf_id, p, vpn->vni);
 
-	/* Unlock route node. */
-	bgp_dest_unlock_node(dest);
+		return ret;
+	}
 
 	return ret;
 }
@@ -3385,7 +3946,8 @@ static int bgp_evpn_install_uninstall_ta
 	 * we need to create a different copy for the VNI
 	 */
 	if (evp->prefix.route_type == BGP_EVPN_AD_ROUTE)
-		evp = evpn_type1_prefix_vni_copy(&ad_evp, evp, attr->nexthop);
+		evp = evpn_type1_prefix_vni_ip_copy(&ad_evp, evp,
+						    attr->nexthop);
 
 	ecom = bgp_attr_get_ecommunity(attr);
 	if (!ecom || !ecom->size)
@@ -3600,16 +4162,94 @@ static void withdraw_router_id_vrf(struc
 	delete_withdraw_vrf_routes(bgp_vrf);
 }
 
+static void update_advertise_vni_route(struct bgp *bgp, struct bgpevpn *vpn,
+				       struct bgp_dest *dest)
+{
+	struct bgp_dest *global_dest;
+	struct bgp_path_info *pi, *global_pi;
+	struct attr *attr;
+	afi_t afi = AFI_L2VPN;
+	safi_t safi = SAFI_EVPN;
+
+	struct prefix_evpn tmp_evp;
+	const struct prefix_evpn *evp =
+		(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
+
+	/*
+	 * We have already processed type-3 routes.
+	 * Process only type-1 and type-2 routes here.
+	 */
+	if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE &&
+	    evp->prefix.route_type != BGP_EVPN_AD_ROUTE)
+		return;
+
+	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
+		if (pi->peer == bgp->peer_self && pi->type == ZEBRA_ROUTE_BGP &&
+		    pi->sub_type == BGP_ROUTE_STATIC)
+			break;
+	if (!pi)
+		return;
+
+	/*
+	 * VNI table MAC-IP prefixes don't have MAC so make sure it's
+	 * set from path info here.
+	 */
+	if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+		if (is_evpn_prefix_ipaddr_none(evp)) {
+			/* VNI MAC -> Global */
+			evpn_type2_prefix_global_copy(
+				&tmp_evp, evp, NULL /* mac */,
+				evpn_type2_path_info_get_ip(pi));
+		} else {
+			/* VNI IP -> Global */
+			evpn_type2_prefix_global_copy(
+				&tmp_evp, evp, evpn_type2_path_info_get_mac(pi),
+				NULL /* ip */);
+		}
+	} else {
+		memcpy(&tmp_evp, evp, sizeof(tmp_evp));
+	}
+
+	/* Create route in global routing table using this route entry's
+	 * attribute.
+	 */
+	attr = pi->attr;
+	global_dest = bgp_evpn_global_node_get(bgp->rib[afi][safi], afi, safi,
+					       &tmp_evp, &vpn->prd, NULL);
+	assert(global_dest);
+
+	if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+		/* Type-2 route */
+		update_evpn_route_entry(
+			bgp, vpn, afi, safi, global_dest, attr, NULL /* mac */,
+			NULL /* ip */, 1, &global_pi, 0,
+			mac_mobility_seqnum(attr), false /* setup_sync */,
+			NULL /* old_is_sync */);
+	} else {
+		/* Type-1 route */
+		struct bgp_evpn_es *es;
+		int route_changed = 0;
+
+		es = bgp_evpn_es_find(&evp->prefix.ead_addr.esi);
+		bgp_evpn_mh_route_update(bgp, es, vpn, afi, safi, global_dest,
+					 attr, &global_pi, &route_changed);
+	}
+
+	/* Schedule for processing and unlock node. */
+	bgp_process(bgp, global_dest, afi, safi);
+	bgp_dest_unlock_node(global_dest);
+}
+
 /*
  * Update and advertise local routes for a VNI. Invoked upon router-id
  * change. Note that the processing is done only on the global route table
  * using routes that already exist in the per-VNI table.
  */
-static int update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
+static void update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct prefix_evpn p;
 	struct bgp_dest *dest, *global_dest;
-	struct bgp_path_info *pi, *global_pi;
+	struct bgp_path_info *pi;
 	struct attr *attr;
 	afi_t afi = AFI_L2VPN;
 	safi_t safi = SAFI_EVPN;
@@ -3623,9 +4263,9 @@ static int update_advertise_vni_routes(s
 	if (bgp_evpn_vni_flood_mode_get(bgp, vpn)
 				== VXLAN_FLOOD_HEAD_END_REPL) {
 		build_evpn_type3_prefix(&p, vpn->originator_ip);
-		dest = bgp_node_lookup(vpn->route_table, (struct prefix *)&p);
+		dest = bgp_evpn_vni_node_lookup(vpn, &p, NULL);
 		if (!dest) /* unexpected */
-			return 0;
+			return;
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
 			if (pi->peer == bgp->peer_self &&
 			    pi->type == ZEBRA_ROUTE_BGP
@@ -3633,76 +4273,33 @@ static int update_advertise_vni_routes(s
 				break;
 		if (!pi) {
 			bgp_dest_unlock_node(dest);
-			return 0;
+			return;
 		}
+
 		attr = pi->attr;
 
-		global_dest = bgp_global_evpn_node_get(bgp->rib[afi][safi],
-				afi, safi, &p, &vpn->prd);
-		update_evpn_route_entry(bgp, vpn, afi, safi, global_dest, attr,
-				1, &pi, 0, mac_mobility_seqnum(attr),
-				false /* setup_sync */, NULL /* old_is_sync */);
+		global_dest = bgp_evpn_global_node_get(
+			bgp->rib[afi][safi], afi, safi, &p, &vpn->prd, NULL);
+		update_evpn_route_entry(
+			bgp, vpn, afi, safi, global_dest, attr, NULL /* mac */,
+			NULL /* ip */, 1, &pi, 0, mac_mobility_seqnum(attr),
+			false /* setup_sync */, NULL /* old_is_sync */);
 
 		/* Schedule for processing and unlock node. */
 		bgp_process(bgp, global_dest, afi, safi);
 		bgp_dest_unlock_node(global_dest);
 	}
 
-	/* Now, walk this VNI's route table and use the route and its attribute
-	 * to create and schedule route in global table.
+	/* Now, walk this VNI's MAC & IP route table and use the route and its
+	 * attribute to create and schedule route in global table.
 	 */
-	for (dest = bgp_table_top(vpn->route_table); dest;
-	     dest = bgp_route_next(dest)) {
-		const struct prefix_evpn *evp =
-			(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
-
-		/*
-		 * We have already processed type-3 routes.
-		 * Process only type-1 and type-2 routes here.
-		 */
-		if (evp->prefix.route_type != BGP_EVPN_MAC_IP_ROUTE
-		    && evp->prefix.route_type != BGP_EVPN_AD_ROUTE)
-			continue;
-
-		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
-			if (pi->peer == bgp->peer_self
-			    && pi->type == ZEBRA_ROUTE_BGP
-			    && pi->sub_type == BGP_ROUTE_STATIC)
-				break;
-		if (!pi)
-			continue;
-
-		/* Create route in global routing table using this route entry's
-		 * attribute.
-		 */
-		attr = pi->attr;
-		global_dest = bgp_global_evpn_node_get(bgp->rib[afi][safi], afi, safi,
-					     evp, &vpn->prd);
-		assert(global_dest);
-
-		if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
-			/* Type-2 route */
-			update_evpn_route_entry(
-				bgp, vpn, afi, safi, global_dest, attr, 1,
-				&global_pi, 0, mac_mobility_seqnum(attr),
-				false /* setup_sync */, NULL /* old_is_sync */);
-		} else {
-			/* Type-1 route */
-			struct bgp_evpn_es *es;
-			int route_changed = 0;
-
-			es = bgp_evpn_es_find(&evp->prefix.ead_addr.esi);
-			bgp_evpn_mh_route_update(bgp, es, vpn, afi, safi,
-						 global_dest, attr, &global_pi,
-						 &route_changed);
-		}
-
-		/* Schedule for processing and unlock node. */
-		bgp_process(bgp, global_dest, afi, safi);
-		bgp_dest_unlock_node(global_dest);
-	}
+	for (dest = bgp_table_top(vpn->mac_table); dest;
+	     dest = bgp_route_next(dest))
+		update_advertise_vni_route(bgp, vpn, dest);
 
-	return 0;
+	for (dest = bgp_table_top(vpn->ip_table); dest;
+	     dest = bgp_route_next(dest))
+		update_advertise_vni_route(bgp, vpn, dest);
 }
 
 /*
@@ -3724,8 +4321,8 @@ static int delete_withdraw_vni_routes(st
 
 	/* Remove type-3 route for this VNI from global table. */
 	build_evpn_type3_prefix(&p, vpn->originator_ip);
-	global_dest = bgp_global_evpn_node_lookup(bgp->rib[afi][safi], afi, safi,
-			(const struct prefix_evpn *)&p, &vpn->prd);
+	global_dest = bgp_evpn_global_node_lookup(bgp->rib[afi][safi], afi,
+						  safi, &p, &vpn->prd, NULL);
 	if (global_dest) {
 		/* Delete route entry in the global EVPN table. */
 		delete_evpn_route_entry(bgp, afi, safi, global_dest, &pi);
@@ -3832,7 +4429,7 @@ static int process_type2_route(struct pe
 	mpls_label_t label[BGP_MAX_LABELS] = {};
 	uint32_t num_labels = 0;
 	uint32_t eth_tag;
-	int ret;
+	int ret = 0;
 
 	/* Type-2 route should be either 33, 37 or 49 bytes or an
 	 * additional 3 bytes if there is a second label (VNI):
@@ -3925,13 +4522,13 @@ static int process_type2_route(struct pe
 
 	/* Process the route. */
 	if (attr)
-		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
-				 afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				 &prd, &label[0], num_labels, 0, &evpn);
+		bgp_update(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			   &label[0], num_labels, 0, &evpn);
 	else
-		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
-				   afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				   &prd, &label[0], num_labels, &evpn);
+		bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			     safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			     &label[0], num_labels, &evpn);
 	goto done;
 
 fail:
@@ -3956,7 +4553,6 @@ static int process_type3_route(struct pe
 	struct prefix_evpn p;
 	uint8_t ipaddr_len;
 	uint32_t eth_tag;
-	int ret;
 
 	/* Type-3 route should be either 17 or 29 bytes: RD (8), Eth Tag (4),
 	 * IP len (1) and IP (4 or 16).
@@ -4017,14 +4613,14 @@ static int process_type3_route(struct pe
 
 	/* Process the route. */
 	if (attr)
-		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
-				 afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				 &prd, NULL, 0, 0, NULL);
+		bgp_update(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, NULL,
+			   0, 0, NULL);
 	else
-		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
-				   afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				   &prd, NULL, 0, NULL);
-	return ret;
+		bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			     safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			     NULL, 0, NULL);
+	return 0;
 }
 
 /*
@@ -4040,7 +4636,6 @@ static int process_type5_route(struct pe
 	uint8_t ippfx_len;
 	uint32_t eth_tag;
 	mpls_label_t label; /* holds the VNI as in the packet */
-	int ret;
 	bool is_valid_update = true;
 
 	/* Type-5 route should be 34 or 58 bytes:
@@ -4152,9 +4747,9 @@ static int process_type5_route(struct pe
 
 	/* Process the route. */
 	if (attr && is_valid_update)
-		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
-				 afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				 &prd, &label, 1, 0, &evpn);
+		bgp_update(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			   &label, 1, 0, &evpn);
 	else {
 		if (!is_valid_update) {
 			char attr_str[BUFSIZ] = {0};
@@ -4165,12 +4760,12 @@ static int process_type5_route(struct pe
 				peer->hostname, peer->bgp->vrf_id, &p,
 				attr_str);
 		}
-		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
-				   afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				   &prd, &label, 1, &evpn);
+		bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			     safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			     &label, 1, &evpn);
 	}
 
-	return ret;
+	return 0;
 }
 
 static void evpn_mpattr_encode_type5(struct stream *s, const struct prefix *p,
@@ -4263,13 +4858,14 @@ static void evpn_auto_rt_import_add_for_
 {
 	struct bgp *bgp_evpn = NULL;
 
-	form_auto_rt(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_import_rtl);
-	UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD);
+	form_auto_rt(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_import_rtl, true);
 
 	/* Map RT to VRF */
 	bgp_evpn = bgp_get_evpn();
+
 	if (!bgp_evpn)
 		return;
+
 	bgp_evpn_map_vrf_to_its_rts(bgp_vrf);
 }
 
@@ -4278,7 +4874,8 @@ static void evpn_auto_rt_import_add_for_
  */
 static void evpn_auto_rt_import_delete_for_vrf(struct bgp *bgp_vrf)
 {
-	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_import_rtl);
+	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_import_rtl,
+			    true);
 }
 
 /*
@@ -4286,8 +4883,7 @@ static void evpn_auto_rt_import_delete_f
  */
 static void evpn_auto_rt_export_add_for_vrf(struct bgp *bgp_vrf)
 {
-	UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD);
-	form_auto_rt(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl);
+	form_auto_rt(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl, true);
 }
 
 /*
@@ -4295,7 +4891,8 @@ static void evpn_auto_rt_export_add_for_
  */
 static void evpn_auto_rt_export_delete_for_vrf(struct bgp *bgp_vrf)
 {
-	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl);
+	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl,
+			    true);
 }
 
 static void bgp_evpn_handle_export_rt_change_for_vrf(struct bgp *bgp_vrf)
@@ -4538,36 +5135,65 @@ void bgp_evpn_advertise_type5_routes(str
 	}
 }
 
-void evpn_rt_delete_auto(struct bgp *bgp, vni_t vni, struct list *rtl)
+static void rt_list_remove_node(struct list *rt_list,
+				struct ecommunity *ecomdel, bool is_l3)
 {
-	struct listnode *node, *nnode, *node_to_del;
-	struct ecommunity *ecom, *ecom_auto;
+	struct listnode *node = NULL, *nnode = NULL, *node_to_del = NULL;
+	struct vrf_route_target *l3rt = NULL;
+	struct ecommunity *ecom = NULL;
+
+	if (is_l3) {
+		for (ALL_LIST_ELEMENTS(rt_list, node, nnode, l3rt)) {
+			if (ecommunity_match(l3rt->ecom, ecomdel)) {
+				evpn_vrf_rt_del(l3rt);
+				node_to_del = node;
+				break;
+			}
+		}
+	} else {
+		for (ALL_LIST_ELEMENTS(rt_list, node, nnode, ecom)) {
+			if (ecommunity_match(ecom, ecomdel)) {
+				ecommunity_free(&ecom);
+				node_to_del = node;
+				break;
+			}
+		}
+	}
+
+
+	if (node_to_del)
+		list_delete_node(rt_list, node_to_del);
+}
+
+void evpn_rt_delete_auto(struct bgp *bgp, vni_t vni, struct list *rtl,
+			 bool is_l3)
+{
+	struct ecommunity *ecom_auto;
 	struct ecommunity_val eval;
 
 	if (bgp->advertise_autort_rfc8365)
 		vni |= EVPN_AUTORT_VXLAN;
+
 	encode_route_target_as((bgp->as & 0xFFFF), vni, &eval);
 
 	ecom_auto = ecommunity_new();
 	ecommunity_add_val(ecom_auto, &eval, false, false);
-	node_to_del = NULL;
 
-	for (ALL_LIST_ELEMENTS(rtl, node, nnode, ecom)) {
-		if (ecommunity_match(ecom, ecom_auto)) {
-			ecommunity_free(&ecom);
-			node_to_del = node;
-			break;
-		}
-	}
-
-	if (node_to_del)
-		list_delete_node(rtl, node_to_del);
+	rt_list_remove_node(rtl, ecom_auto, is_l3);
 
 	ecommunity_free(&ecom_auto);
 }
 
-void bgp_evpn_configure_import_rt_for_vrf(struct bgp *bgp_vrf,
-					  struct ecommunity *ecomadd)
+static void evpn_vrf_rt_routes_map(struct bgp *bgp_vrf)
+{
+	/* map VRFs to its RTs and install routes matching this new RT */
+	if (is_l3vni_live(bgp_vrf)) {
+		bgp_evpn_map_vrf_to_its_rts(bgp_vrf);
+		install_routes_for_vrf(bgp_vrf);
+	}
+}
+
+static void evpn_vrf_rt_routes_unmap(struct bgp *bgp_vrf)
 {
 	/* uninstall routes from vrf */
 	if (is_l3vni_live(bgp_vrf))
@@ -4575,112 +5201,189 @@ void bgp_evpn_configure_import_rt_for_vr
 
 	/* Cleanup the RT to VRF mapping */
 	bgp_evpn_unmap_vrf_from_its_rts(bgp_vrf);
+}
 
-	/* Remove auto generated RT */
-	evpn_auto_rt_import_delete_for_vrf(bgp_vrf);
+static bool rt_list_has_cfgd_rt(struct list *rt_list)
+{
+	struct listnode *node = NULL, *nnode = NULL;
+	struct vrf_route_target *l3rt = NULL;
+
+	for (ALL_LIST_ELEMENTS(rt_list, node, nnode, l3rt)) {
+		if (!CHECK_FLAG(l3rt->flags, BGP_VRF_RT_AUTO))
+			return true;
+	}
+
+	return false;
+}
+
+static void unconfigure_import_rt_for_vrf_fini(struct bgp *bgp_vrf)
+{
+	if (!bgp_vrf->vrf_import_rtl)
+		return; /* this should never fail */
+
+	if (!is_l3vni_live(bgp_vrf))
+		return; /* Nothing to do if no vni */
+
+	/* fall back to auto-generated RT if this was the last RT */
+	if (list_isempty(bgp_vrf->vrf_import_rtl))
+		evpn_auto_rt_import_add_for_vrf(bgp_vrf);
+}
+
+static void unconfigure_export_rt_for_vrf_fini(struct bgp *bgp_vrf)
+{
+
+	if (!bgp_vrf->vrf_export_rtl)
+		return; /* this should never fail */
+
+	if (!is_l3vni_live(bgp_vrf))
+		return; /* Nothing to do if no vni */
+
+	/* fall back to auto-generated RT if this was the last RT */
+	if (list_isempty(bgp_vrf->vrf_export_rtl))
+		evpn_auto_rt_export_add_for_vrf(bgp_vrf);
+
+	bgp_evpn_handle_export_rt_change_for_vrf(bgp_vrf);
+}
+
+void bgp_evpn_configure_import_rt_for_vrf(struct bgp *bgp_vrf,
+					  struct ecommunity *ecomadd,
+					  bool is_wildcard)
+{
+	struct vrf_route_target *newrt;
+
+	newrt = evpn_vrf_rt_new(ecomadd);
+
+	if (is_wildcard)
+		SET_FLAG(newrt->flags, BGP_VRF_RT_WILD);
+
+	evpn_vrf_rt_routes_unmap(bgp_vrf);
+
+	/* Remove auto generated RT if not configured */
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD))
+		evpn_auto_rt_import_delete_for_vrf(bgp_vrf);
 
 	/* Add the newly configured RT to RT list */
-	listnode_add_sort(bgp_vrf->vrf_import_rtl, ecomadd);
+	listnode_add_sort(bgp_vrf->vrf_import_rtl, newrt);
+
 	SET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD);
 
-	/* map VRF to its RTs and install routes matching the new RTs */
-	if (is_l3vni_live(bgp_vrf)) {
-		bgp_evpn_map_vrf_to_its_rts(bgp_vrf);
-		install_routes_for_vrf(bgp_vrf);
-	}
+	evpn_vrf_rt_routes_map(bgp_vrf);
+}
+
+void bgp_evpn_configure_import_auto_rt_for_vrf(struct bgp *bgp_vrf)
+{
+	if (CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD))
+		return; /* Already configured */
+
+	SET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD);
+
+	if (!is_l3vni_live(bgp_vrf))
+		return; /* Wait for VNI before adding rts */
+
+	evpn_vrf_rt_routes_unmap(bgp_vrf);
+
+	evpn_auto_rt_import_add_for_vrf(bgp_vrf);
+
+	evpn_vrf_rt_routes_map(bgp_vrf);
 }
 
 void bgp_evpn_unconfigure_import_rt_for_vrf(struct bgp *bgp_vrf,
 					    struct ecommunity *ecomdel)
 {
-	struct listnode *node = NULL, *nnode = NULL, *node_to_del = NULL;
-	struct ecommunity *ecom = NULL;
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD))
+		return; /* Already un-configured */
 
-	/* uninstall routes from vrf */
-	if (is_l3vni_live(bgp_vrf))
-		uninstall_routes_for_vrf(bgp_vrf);
+	evpn_vrf_rt_routes_unmap(bgp_vrf);
 
-	/* Cleanup the RT to VRF mapping */
-	bgp_evpn_unmap_vrf_from_its_rts(bgp_vrf);
+	/* Remove rt */
+	rt_list_remove_node(bgp_vrf->vrf_import_rtl, ecomdel, true);
 
-	/* remove the RT from the RT list */
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, ecom)) {
-		if (ecommunity_match(ecom, ecomdel)) {
-			ecommunity_free(&ecom);
-			node_to_del = node;
-			break;
-		}
-	}
+	if (!rt_list_has_cfgd_rt(bgp_vrf->vrf_import_rtl))
+		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD);
 
-	if (node_to_del)
-		list_delete_node(bgp_vrf->vrf_import_rtl, node_to_del);
+	unconfigure_import_rt_for_vrf_fini(bgp_vrf);
 
-	assert(bgp_vrf->vrf_import_rtl);
-	/* fallback to auto import rt, if this was the last RT */
-	if (bgp_vrf->vrf_import_rtl && list_isempty(bgp_vrf->vrf_import_rtl)) {
-		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD);
-		if (is_l3vni_live(bgp_vrf))
-			evpn_auto_rt_import_add_for_vrf(bgp_vrf);
-	}
+	evpn_vrf_rt_routes_map(bgp_vrf);
+}
 
-	/* map VRFs to its RTs and install routes matching this new RT */
-	if (is_l3vni_live(bgp_vrf)) {
-		bgp_evpn_map_vrf_to_its_rts(bgp_vrf);
-		install_routes_for_vrf(bgp_vrf);
-	}
+void bgp_evpn_unconfigure_import_auto_rt_for_vrf(struct bgp *bgp_vrf)
+{
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD))
+		return; /* Already un-configured */
+
+	evpn_vrf_rt_routes_unmap(bgp_vrf);
+
+	/* remove auto-generated RT */
+	evpn_auto_rt_import_delete_for_vrf(bgp_vrf);
+
+	UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD);
+
+	unconfigure_import_rt_for_vrf_fini(bgp_vrf);
+
+	evpn_vrf_rt_routes_map(bgp_vrf);
 }
 
 void bgp_evpn_configure_export_rt_for_vrf(struct bgp *bgp_vrf,
 					  struct ecommunity *ecomadd)
 {
-	/* remove auto-generated RT */
-	evpn_auto_rt_export_delete_for_vrf(bgp_vrf);
+	struct vrf_route_target *newrt;
+
+	newrt = evpn_vrf_rt_new(ecomadd);
+
+	/* Remove auto generated RT if not configured */
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD))
+		evpn_auto_rt_export_delete_for_vrf(bgp_vrf);
 
 	/* Add the new RT to the RT list */
-	listnode_add_sort(bgp_vrf->vrf_export_rtl, ecomadd);
+	listnode_add_sort(bgp_vrf->vrf_export_rtl, newrt);
+
 	SET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD);
 
 	if (is_l3vni_live(bgp_vrf))
 		bgp_evpn_handle_export_rt_change_for_vrf(bgp_vrf);
 }
 
+void bgp_evpn_configure_export_auto_rt_for_vrf(struct bgp *bgp_vrf)
+{
+	if (CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD))
+		return; /* Already configured */
+
+	SET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD);
+
+	if (!is_l3vni_live(bgp_vrf))
+		return; /* Wait for VNI before adding rts */
+
+	evpn_auto_rt_export_add_for_vrf(bgp_vrf);
+
+	bgp_evpn_handle_export_rt_change_for_vrf(bgp_vrf);
+}
+
 void bgp_evpn_unconfigure_export_rt_for_vrf(struct bgp *bgp_vrf,
 					    struct ecommunity *ecomdel)
 {
-	struct listnode *node = NULL, *nnode = NULL, *node_to_del = NULL;
-	struct ecommunity *ecom = NULL;
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD))
+		return; /* Already un-configured */
 
-	/* Remove the RT from the RT list */
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_export_rtl, node, nnode, ecom)) {
-		if (ecommunity_match(ecom, ecomdel)) {
-			ecommunity_free(&ecom);
-			node_to_del = node;
-			break;
-		}
-	}
+	/* Remove rt */
+	rt_list_remove_node(bgp_vrf->vrf_export_rtl, ecomdel, true);
 
-	if (node_to_del)
-		list_delete_node(bgp_vrf->vrf_export_rtl, node_to_del);
+	if (!rt_list_has_cfgd_rt(bgp_vrf->vrf_export_rtl))
+		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD);
 
-	/*
-	 * Temporary assert to make SA happy.
-	 * The ALL_LIST_ELEMENTS macro above has a NULL check
-	 * which means that SA is going to complain about
-	 * the list_isempty call, which doesn't NULL check.
-	 * So until we get this situation cleaned up, here
-	 * we are.
-	 */
-	assert(bgp_vrf->vrf_export_rtl);
+	unconfigure_export_rt_for_vrf_fini(bgp_vrf);
+}
 
-	/* fall back to auto-generated RT if this was the last RT */
-	if (list_isempty(bgp_vrf->vrf_export_rtl)) {
-		UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD);
-		if (is_l3vni_live(bgp_vrf))
-			evpn_auto_rt_export_add_for_vrf(bgp_vrf);
-	}
+void bgp_evpn_unconfigure_export_auto_rt_for_vrf(struct bgp *bgp_vrf)
+{
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD))
+		return; /* Already un-configured */
 
-	if (is_l3vni_live(bgp_vrf))
-		bgp_evpn_handle_export_rt_change_for_vrf(bgp_vrf);
+	/* remove auto-generated RT */
+	evpn_auto_rt_export_delete_for_vrf(bgp_vrf);
+
+	UNSET_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD);
+
+	unconfigure_export_rt_for_vrf_fini(bgp_vrf);
 }
 
 /*
@@ -5109,19 +5812,11 @@ int bgp_nlri_parse_evpn(struct peer *pee
  */
 void bgp_evpn_map_vrf_to_its_rts(struct bgp *bgp_vrf)
 {
-	uint32_t i = 0;
-	struct ecommunity_val *eval = NULL;
-	struct listnode *node = NULL, *nnode = NULL;
-	struct ecommunity *ecom = NULL;
+	struct listnode *node, *nnode;
+	struct vrf_route_target *l3rt;
 
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, ecom)) {
-		for (i = 0; i < ecom->size; i++) {
-			eval = (struct ecommunity_val *)(ecom->val
-							 + (i
-							    * ECOMMUNITY_SIZE));
-			map_vrf_to_rt(bgp_vrf, eval);
-		}
-	}
+	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, l3rt))
+		map_vrf_to_rt(bgp_vrf, l3rt);
 }
 
 /*
@@ -5129,37 +5824,13 @@ void bgp_evpn_map_vrf_to_its_rts(struct
  */
 void bgp_evpn_unmap_vrf_from_its_rts(struct bgp *bgp_vrf)
 {
-	uint32_t i;
-	struct ecommunity_val *eval;
 	struct listnode *node, *nnode;
-	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
 
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, ecom)) {
-		for (i = 0; i < ecom->size; i++) {
-			struct vrf_irt_node *irt;
-			struct ecommunity_val eval_tmp;
-
-			eval = (struct ecommunity_val *)(ecom->val
-							 + (i
-							    * ECOMMUNITY_SIZE));
-			/* If using "automatic" RT, we only care about the
-			 * local-admin sub-field.
-			 * This is to facilitate using VNI as the RT for EBGP
-			 * peering too.
-			 */
-			memcpy(&eval_tmp, eval, ECOMMUNITY_SIZE);
-			if (!CHECK_FLAG(bgp_vrf->vrf_flags,
-					BGP_VRF_IMPORT_RT_CFGD))
-				mask_ecom_global_admin(&eval_tmp, eval);
-
-			irt = lookup_vrf_import_rt(&eval_tmp);
-			if (irt)
-				unmap_vrf_from_rt(bgp_vrf, irt);
-		}
-	}
+	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, l3rt))
+		unmap_vrf_from_rt(bgp_vrf, l3rt);
 }
 
-
 /*
  * Map the RTs (configured or automatically derived) of a VNI to the VNI.
  * The mapping will be used during route processing.
@@ -5221,7 +5892,7 @@ void bgp_evpn_unmap_vni_from_its_rts(str
  */
 void bgp_evpn_derive_auto_rt_import(struct bgp *bgp, struct bgpevpn *vpn)
 {
-	form_auto_rt(bgp, vpn->vni, vpn->import_rtl);
+	form_auto_rt(bgp, vpn->vni, vpn->import_rtl, false);
 	UNSET_FLAG(vpn->flags, VNI_FLAG_IMPRT_CFGD);
 
 	/* Map RT to VNI */
@@ -5233,7 +5904,7 @@ void bgp_evpn_derive_auto_rt_import(stru
  */
 void bgp_evpn_derive_auto_rt_export(struct bgp *bgp, struct bgpevpn *vpn)
 {
-	form_auto_rt(bgp, vpn->vni, vpn->export_rtl);
+	form_auto_rt(bgp, vpn->vni, vpn->export_rtl, false);
 	UNSET_FLAG(vpn->flags, VNI_FLAG_EXPRT_CFGD);
 }
 
@@ -5327,8 +5998,9 @@ struct bgpevpn *bgp_evpn_new(struct bgp
 	bf_assign_index(bm->rd_idspace, vpn->rd_id);
 	derive_rd_rt_for_vni(bgp, vpn);
 
-	/* Initialize EVPN route table. */
-	vpn->route_table = bgp_table_init(bgp, AFI_L2VPN, SAFI_EVPN);
+	/* Initialize EVPN route tables. */
+	vpn->ip_table = bgp_table_init(bgp, AFI_L2VPN, SAFI_EVPN);
+	vpn->mac_table = bgp_table_init(bgp, AFI_L2VPN, SAFI_EVPN);
 
 	/* Add to hash */
 	(void)hash_get(bgp->vnihash, vpn, hash_alloc_intern);
@@ -5356,7 +6028,8 @@ void bgp_evpn_free(struct bgp *bgp, stru
 	bgp_evpn_remote_ip_hash_destroy(vpn);
 	bgp_evpn_vni_es_cleanup(vpn);
 	bgpevpn_unlink_from_l3vni(vpn);
-	bgp_table_unlock(vpn->route_table);
+	bgp_table_unlock(vpn->ip_table);
+	bgp_table_unlock(vpn->mac_table);
 	bgp_evpn_unmap_vni_from_its_rts(bgp, vpn);
 	list_delete(&vpn->import_rtl);
 	list_delete(&vpn->export_rtl);
@@ -5482,7 +6155,7 @@ int bgp_evpn_local_macip_del(struct bgp
 		delete_evpn_route(bgp, vpn, &p);
 	} else {
 		/* Re-instate the current remote best path if any */
-		dest = bgp_node_lookup(vpn->route_table, (struct prefix *)&p);
+		dest = bgp_evpn_vni_node_lookup(vpn, &p, NULL);
 		if (dest) {
 			evpn_zebra_reinstall_best_route(bgp, vpn, dest);
 			bgp_dest_unlock_node(dest);
@@ -5643,12 +6316,14 @@ int bgp_evpn_local_l3vni_add(vni_t l3vni
 	}
 
 	/* Map auto derive or configured RTs */
-	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD))
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_RT_CFGD) ||
+	    CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD))
 		evpn_auto_rt_import_add_for_vrf(bgp_vrf);
 	else
 		bgp_evpn_map_vrf_to_its_rts(bgp_vrf);
 
-	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD))
+	if (!CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_RT_CFGD) ||
+	    CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD))
 		evpn_auto_rt_export_add_for_vrf(bgp_vrf);
 
 	/* auto derive RD */
@@ -5766,14 +6441,8 @@ int bgp_evpn_local_vni_del(struct bgp *b
 
 	/* Locate VNI hash */
 	vpn = bgp_evpn_lookup_vni(bgp, vni);
-	if (!vpn) {
-		if (bgp_debug_zebra(NULL))
-			flog_warn(
-				EC_BGP_EVPN_VPN_VNI,
-				"%u: VNI hash entry for VNI %u not found at DEL",
-				bgp->vrf_id, vni);
+	if (!vpn)
 		return 0;
-	}
 
 	/* Remove all local EVPN routes and schedule for processing (to
 	 * withdraw from peers).
@@ -5880,8 +6549,7 @@ int bgp_evpn_local_vni_add(struct bgp *b
 		/* If tunnel endpoint IP has changed, update (and delete prior
 		 * type-3 route, if needed.)
 		 */
-		if (!IPV4_ADDR_SAME(&vpn->originator_ip, &originator_ip))
-			handle_tunnel_ip_change(bgp, vpn, originator_ip);
+		handle_tunnel_ip_change(bgp, vpn, originator_ip);
 
 		/* Update all routes with new endpoint IP and/or export RT
 		 * for VRFs
@@ -5902,10 +6570,13 @@ int bgp_evpn_local_vni_add(struct bgp *b
 	SET_FLAG(vpn->flags, VNI_FLAG_LIVE);
 
 	/* tunnel is now active, add tunnel-ip to db */
-	bgp_tip_add(bgp, &originator_ip);
-
-	/* filter routes as nexthop database has changed */
-	bgp_filter_evpn_routes_upon_martian_nh_change(bgp);
+	if (bgp_tip_add(bgp, &originator_ip))
+		/* The originator_ip was not already present in the
+		 * bgp martian next-hop table as a tunnel-ip, so we
+		 * need to go back and filter routes matching the new
+		 * martian next-hop.
+		 */
+		bgp_filter_evpn_routes_upon_martian_nh_change(bgp);
 
 	/*
 	 * Create EVPN type-3 route and schedule for processing.
@@ -6021,12 +6692,12 @@ void bgp_evpn_init(struct bgp *bgp)
 			    "BGP VRF Import RT Hash");
 	bgp->vrf_import_rtl = list_new();
 	bgp->vrf_import_rtl->cmp =
-		(int (*)(void *, void *))bgp_evpn_route_target_cmp;
-	bgp->vrf_import_rtl->del = bgp_evpn_xxport_delete_ecomm;
+		(int (*)(void *, void *))evpn_vrf_route_target_cmp;
+	bgp->vrf_import_rtl->del = evpn_vrf_rt_del;
 	bgp->vrf_export_rtl = list_new();
 	bgp->vrf_export_rtl->cmp =
-		(int (*)(void *, void *))bgp_evpn_route_target_cmp;
-	bgp->vrf_export_rtl->del = bgp_evpn_xxport_delete_ecomm;
+		(int (*)(void *, void *))evpn_vrf_route_target_cmp;
+	bgp->vrf_export_rtl->del = evpn_vrf_rt_del;
 	bgp->l2vnis = list_new();
 	bgp->l2vnis->cmp = vni_list_cmp;
 	/* By default Duplicate Address Dection is enabled.
@@ -6242,6 +6913,7 @@ static void bgp_evpn_remote_ip_hash_del(
 	if (ip->macip_path_list->count == 0) {
 		bgp_evpn_remote_ip_process_nexthops(vpn, &ip->addr, false);
 		hash_release(vpn->remote_ip_hash, ip);
+		list_delete(&ip->macip_path_list);
 		XFREE(MTYPE_EVPN_REMOTE_IP, ip);
 	}
 }
@@ -6488,7 +7160,7 @@ void bgp_evpn_handle_resolve_overlay_ind
 
 	bgp_evpn_remote_ip_hash_init(vpn);
 
-	for (dest = bgp_table_top(vpn->route_table); dest;
+	for (dest = bgp_table_top(vpn->ip_table); dest;
 	     dest = bgp_route_next(dest))
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
 			bgp_evpn_remote_ip_hash_add(vpn, pi);
diff -urpN frr-frr-8.4.2/bgpd/bgp_evpn_mh.c frr-frr-8.5/bgpd/bgp_evpn_mh.c
--- frr-frr-8.4.2/bgpd/bgp_evpn_mh.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_evpn_mh.c	2023-03-13 20:01:47.000000000 +0600
@@ -471,7 +471,7 @@ static int bgp_evpn_mh_route_delete(stru
 	struct prefix_rd *prd;
 
 	if (vpn) {
-		rt_table = vpn->route_table;
+		rt_table = vpn->ip_table;
 		prd = &vpn->prd;
 	} else {
 		rt_table = es->route_table;
@@ -498,9 +498,8 @@ static int bgp_evpn_mh_route_delete(stru
 	/* Next, locate route node in the global EVPN routing table.
 	 * Note that this table is a 2-level tree (RD-level + Prefix-level)
 	 */
-	global_dest =
-		bgp_global_evpn_node_lookup(bgp->rib[afi][safi], afi, safi,
-					    (const struct prefix_evpn *)p, prd);
+	global_dest = bgp_evpn_global_node_lookup(bgp->rib[afi][safi], afi,
+						  safi, p, prd, NULL);
 	if (global_dest) {
 
 		/* Delete route entry in the global EVPN table. */
@@ -675,8 +674,9 @@ static int bgp_evpn_type4_route_update(s
 	if (route_changed) {
 		struct bgp_path_info *global_pi;
 
-		dest = bgp_global_evpn_node_get(bgp->rib[afi][safi], afi, safi,
-						p, &es->es_base_frag->prd);
+		dest = bgp_evpn_global_node_get(bgp->rib[afi][safi], afi, safi,
+						p, &es->es_base_frag->prd,
+						NULL);
 		bgp_evpn_mh_route_update(bgp, es, NULL, afi, safi, dest,
 					 attr_new, &global_pi, &route_changed);
 
@@ -706,7 +706,6 @@ int bgp_evpn_type4_route_process(struct
 		struct attr *attr, uint8_t *pfx, int psize,
 		uint32_t addpath_id)
 {
-	int ret;
 	esi_t esi;
 	uint8_t ipaddr_len;
 	struct in_addr vtep_ip;
@@ -750,15 +749,15 @@ int bgp_evpn_type4_route_process(struct
 	build_evpn_type4_prefix(&p, &esi, vtep_ip);
 	/* Process the route. */
 	if (attr) {
-		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
-				afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				&prd, NULL, 0, 0, NULL);
+		bgp_update(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, NULL,
+			   0, 0, NULL);
 	} else {
-		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
-				afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				&prd, NULL, 0, NULL);
+		bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			     safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			     NULL, 0, NULL);
 	}
-	return ret;
+	return 0;
 }
 
 /* Check if a prefix belongs to the local ES */
@@ -960,7 +959,7 @@ static int bgp_evpn_type1_route_update(s
 		bgp_evpn_type1_evi_route_extcomm_build(es, vpn, &attr);
 
 		/* First, create (or fetch) route node within the VNI. */
-		dest = bgp_node_get(vpn->route_table, (struct prefix *)p);
+		dest = bgp_node_get(vpn->ip_table, (struct prefix *)p);
 
 		/* Create or update route entry. */
 		ret = bgp_evpn_mh_route_update(bgp, es, vpn, afi, safi, dest,
@@ -1015,8 +1014,8 @@ static int bgp_evpn_type1_route_update(s
 	if (route_changed) {
 		struct bgp_path_info *global_pi;
 
-		dest = bgp_global_evpn_node_get(bgp->rib[afi][safi], afi, safi,
-						p, global_rd);
+		dest = bgp_evpn_global_node_get(bgp->rib[afi][safi], afi, safi,
+						p, global_rd, NULL);
 		bgp_evpn_mh_route_update(bgp, es, vpn, afi, safi, dest,
 					 attr_new, &global_pi, &route_changed);
 
@@ -1180,7 +1179,6 @@ int bgp_evpn_type1_route_process(struct
 		struct attr *attr, uint8_t *pfx, int psize,
 		uint32_t addpath_id)
 {
-	int ret;
 	struct prefix_rd prd;
 	esi_t esi;
 	uint32_t eth_tag;
@@ -1219,15 +1217,15 @@ int bgp_evpn_type1_route_process(struct
 	build_evpn_type1_prefix(&p, eth_tag, &esi, vtep_ip);
 	/* Process the route. */
 	if (attr) {
-		ret = bgp_update(peer, (struct prefix *)&p, addpath_id, attr,
-				afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				&prd, NULL, 0, 0, NULL);
+		bgp_update(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, NULL,
+			   0, 0, NULL);
 	} else {
-		ret = bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr,
-				afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-				&prd, NULL, 0, NULL);
+		bgp_withdraw(peer, (struct prefix *)&p, addpath_id, attr, afi,
+			     safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd,
+			     NULL, 0, NULL);
 	}
-	return ret;
+	return 0;
 }
 
 void bgp_evpn_mh_config_ead_export_rt(struct bgp *bgp,
@@ -1692,7 +1690,7 @@ bgp_evpn_es_path_update_on_es_vrf_chg(st
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_RT))
 		zlog_debug("update paths linked to es %s on es-vrf %s %s",
-			   es->esi_str, es_vrf->bgp_vrf->name, reason);
+			   es->esi_str, es_vrf->bgp_vrf->name_pretty, reason);
 
 	for (ALL_LIST_ELEMENTS_RO(es->macip_global_path_list, node, es_info)) {
 		pi = es_info->pi;
@@ -2435,7 +2433,7 @@ static char *bgp_evpn_es_vteps_str(char
 	struct listnode *node;
 	struct bgp_evpn_es_vtep *es_vtep;
 	bool first = true;
-	char ip_buf[INET6_ADDRSTRLEN];
+	char ip_buf[INET_ADDRSTRLEN];
 
 	vtep_str[0] = '\0';
 	for (ALL_LIST_ELEMENTS_RO(es->es_vtep_list, node, es_vtep)) {
@@ -3230,7 +3228,7 @@ static void bgp_evpn_es_vrf_show_entry(s
 		json_object *json_types;
 
 		json_object_string_add(json, "esi", es->esi_str);
-		json_object_string_add(json, "vrf", bgp_vrf->name);
+		json_object_string_add(json, "vrf", bgp_vrf->name_pretty);
 
 		if (es_vrf->flags & (BGP_EVPNES_VRF_NHG_ACTIVE)) {
 			json_types = json_object_new_array();
@@ -3250,7 +3248,7 @@ static void bgp_evpn_es_vrf_show_entry(s
 			strlcat(flags_str, "A", sizeof(flags_str));
 
 		vty_out(vty, "%-30s %-15s %-5s %-8u %-8u %u\n", es->esi_str,
-			bgp_vrf->name, flags_str, es_vrf->nhg_id,
+			bgp_vrf->name_pretty, flags_str, es_vrf->nhg_id,
 			es_vrf->v6_nhg_id, es_vrf->ref_cnt);
 	}
 }
@@ -3903,7 +3901,7 @@ static char *bgp_evpn_es_evi_vteps_str(c
 	struct listnode *node;
 	struct bgp_evpn_es_evi_vtep *evi_vtep;
 	bool first = true;
-	char ip_buf[INET6_ADDRSTRLEN];
+	char ip_buf[INET_ADDRSTRLEN];
 
 	vtep_str[0] = '\0';
 	for (ALL_LIST_ELEMENTS_RO(es_evi->es_evi_vtep_list, node, evi_vtep)) {
@@ -4425,10 +4423,11 @@ static void bgp_evpn_nh_zebra_update_sen
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES)) {
 		if (add)
 			zlog_debug("evpn vrf %s nh %s rmac %pEA add to zebra",
-				   nh->bgp_vrf->name, nh->nh_str, &nh->rmac);
+				   nh->bgp_vrf->name_pretty, nh->nh_str,
+				   &nh->rmac);
 		else if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 			zlog_debug("evpn vrf %s nh %s del to zebra",
-				   nh->bgp_vrf->name, nh->nh_str);
+				   nh->bgp_vrf->name_pretty, nh->nh_str);
 	}
 
 	frrtrace(2, frr_bgp, evpn_mh_nh_rmac_zsend, add, nh);
@@ -4497,8 +4496,8 @@ static struct bgp_evpn_nh *bgp_evpn_nh_a
 	}
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh %s rmac %pEA add", n->bgp_vrf->name,
-			   n->nh_str, &n->rmac);
+		zlog_debug("evpn vrf %s nh %s rmac %pEA add",
+			   n->bgp_vrf->name_pretty, n->nh_str, &n->rmac);
 	bgp_evpn_nh_zebra_update(n, true);
 	return n;
 }
@@ -4513,8 +4512,8 @@ static void bgp_evpn_nh_del(struct bgp_e
 		return;
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh %s del to zebra", bgp_vrf->name,
-			   n->nh_str);
+		zlog_debug("evpn vrf %s nh %s del to zebra",
+			   bgp_vrf->name_pretty, n->nh_str);
 
 	bgp_evpn_nh_zebra_update(n, false);
 	list_delete(&n->pi_list);
@@ -4556,7 +4555,7 @@ static bool bgp_evpn_nh_cmp(const void *
 void bgp_evpn_nh_init(struct bgp *bgp_vrf)
 {
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh init", bgp_vrf->name);
+		zlog_debug("evpn vrf %s nh init", bgp_vrf->name_pretty);
 	bgp_vrf->evpn_nh_table = hash_create(
 		bgp_evpn_nh_hash_keymake, bgp_evpn_nh_cmp, "BGP EVPN NH table");
 }
@@ -4568,7 +4567,7 @@ static void bgp_evpn_nh_flush_entry(stru
 	struct bgp_path_evpn_nh_info *nh_info;
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh %s flush", nh->bgp_vrf->name,
+		zlog_debug("evpn vrf %s nh %s flush", nh->bgp_vrf->name_pretty,
 			   nh->nh_str);
 
 	/* force flush paths */
@@ -4586,7 +4585,7 @@ static void bgp_evpn_nh_flush_cb(struct
 void bgp_evpn_nh_finish(struct bgp *bgp_vrf)
 {
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh finish", bgp_vrf->name);
+		zlog_debug("evpn vrf %s nh finish", bgp_vrf->name_pretty);
 	hash_iterate(
 		bgp_vrf->evpn_nh_table,
 		(void (*)(struct hash_bucket *, void *))bgp_evpn_nh_flush_cb,
@@ -4612,7 +4611,7 @@ static void bgp_evpn_nh_update_ref_pi(st
 
 		if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 			zlog_debug("evpn vrf %s nh %s ref_pi update",
-				   nh->bgp_vrf->name, nh->nh_str);
+				   nh->bgp_vrf->name_pretty, nh->nh_str);
 		nh->ref_pi = pi;
 		/* If we have a new pi copy rmac from it and update
 		 * zebra if the new rmac is different
@@ -4632,8 +4631,8 @@ static void bgp_evpn_nh_clear_ref_pi(str
 		return;
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
-		zlog_debug("evpn vrf %s nh %s ref_pi clear", nh->bgp_vrf->name,
-			   nh->nh_str);
+		zlog_debug("evpn vrf %s nh %s ref_pi clear",
+			   nh->bgp_vrf->name_pretty, nh->nh_str);
 	nh->ref_pi = NULL;
 	/* try to find another ref_pi */
 	bgp_evpn_nh_update_ref_pi(nh);
@@ -4692,7 +4691,7 @@ static void bgp_evpn_path_nh_unlink(stru
 			   pi->net ? prefix2str(&pi->net->p, prefix_buf,
 						sizeof(prefix_buf))
 				   : "",
-			   nh->bgp_vrf->name, nh->nh_str);
+			   nh->bgp_vrf->name_pretty, nh->nh_str);
 
 	list_delete_node(nh->pi_list, &nh_info->nh_listnode);
 
@@ -4724,7 +4723,7 @@ static void bgp_evpn_path_nh_link(struct
 	if (!bgp_vrf->evpn_nh_table) {
 		if (BGP_DEBUG(evpn_mh, EVPN_MH_RT))
 			zlog_debug("path %pFX linked to vrf %s failed",
-				   &pi->net->p, bgp_vrf->name);
+				   &pi->net->p, bgp_vrf->name_pretty);
 		return;
 	}
 
@@ -4772,7 +4771,7 @@ static void bgp_evpn_path_nh_link(struct
 
 	if (BGP_DEBUG(evpn_mh, EVPN_MH_RT))
 		zlog_debug("path %pFX linked to nh %s %s", &pi->net->p,
-			   nh->bgp_vrf->name, nh->nh_str);
+			   nh->bgp_vrf->name_pretty, nh->nh_str);
 
 	/* link mac-ip path to the new nh */
 	nh_info->nh = nh;
@@ -4786,7 +4785,8 @@ static void bgp_evpn_path_nh_link(struct
 		if (!nh->ref_pi)
 			zlog_debug(
 				"path %pFX linked to nh %s %s with no valid pi",
-				&pi->net->p, nh->bgp_vrf->name, nh->nh_str);
+				&pi->net->p, nh->bgp_vrf->name_pretty,
+				nh->nh_str);
 	}
 }
 
@@ -4826,15 +4826,15 @@ static void bgp_evpn_nh_show_entry(struc
 	else
 		prefix_buf[0] = '\0';
 	if (json) {
-		json_object_string_add(json, "vrf", nh->bgp_vrf->name);
+		json_object_string_add(json, "vrf", nh->bgp_vrf->name_pretty);
 		json_object_string_add(json, "ip", nh->nh_str);
 		json_object_string_add(json, "rmac", mac_buf);
 		json_object_string_add(json, "basePath", prefix_buf);
 		json_object_int_add(json, "pathCount", listcount(nh->pi_list));
 	} else {
-		vty_out(vty, "%-15s %-15s %-17s %-10d %s\n", nh->bgp_vrf->name,
-			nh->nh_str, mac_buf, listcount(nh->pi_list),
-			prefix_buf);
+		vty_out(vty, "%-15s %-15s %-17s %-10d %s\n",
+			nh->bgp_vrf->name_pretty, nh->nh_str, mac_buf,
+			listcount(nh->pi_list), prefix_buf);
 	}
 
 	/* add ES to the json array */
diff -urpN frr-frr-8.4.2/bgpd/bgp_evpn_private.h frr-frr-8.5/bgpd/bgp_evpn_private.h
--- frr-frr-8.4.2/bgpd/bgp_evpn_private.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_evpn_private.h	2023-03-13 20:01:47.000000000 +0600
@@ -112,9 +112,10 @@ struct bgpevpn {
 	 */
 	struct hash *remote_ip_hash;
 
-	/* Route table for EVPN routes for
+	/* Route tables for EVPN routes for
 	 * this VNI. */
-	struct bgp_table *route_table;
+	struct bgp_table *ip_table;
+	struct bgp_table *mac_table;
 
 	/* RB tree of ES-EVIs */
 	struct bgp_es_evi_rb_head es_evi_rb_tree;
@@ -194,6 +195,18 @@ struct evpn_remote_ip {
 	struct list *macip_path_list;
 };
 
+/*
+ * Wrapper struct for l3 RT's
+ */
+struct vrf_route_target {
+	/* flags based on config to determine how RTs are handled */
+	uint8_t flags;
+#define BGP_VRF_RT_AUTO (1 << 0)
+#define BGP_VRF_RT_WILD (1 << 1)
+
+	struct ecommunity *ecom;
+};
+
 static inline int is_vrf_rd_configured(struct bgp *bgp_vrf)
 {
 	return (CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_RD_CFGD));
@@ -531,10 +544,10 @@ static inline void evpn_type1_prefix_glo
 /* EAD prefix in the global table doesn't include the VTEP-IP so
  * we need to create a different copy for the VNI
  */
-static inline struct prefix_evpn *evpn_type1_prefix_vni_copy(
-		struct prefix_evpn *vni_p,
-		const struct prefix_evpn *global_p,
-		struct in_addr originator_ip)
+static inline struct prefix_evpn *
+evpn_type1_prefix_vni_ip_copy(struct prefix_evpn *vni_p,
+			      const struct prefix_evpn *global_p,
+			      struct in_addr originator_ip)
 {
 	memcpy(vni_p, global_p, sizeof(*vni_p));
 	vni_p->prefix.ead_addr.ip.ipa_type = IPADDR_V4;
@@ -543,6 +556,77 @@ static inline struct prefix_evpn *evpn_t
 	return vni_p;
 }
 
+static inline void evpn_type2_prefix_global_copy(
+	struct prefix_evpn *global_p, const struct prefix_evpn *vni_p,
+	const struct ethaddr *mac, const struct ipaddr *ip)
+{
+	memcpy(global_p, vni_p, sizeof(*global_p));
+
+	if (mac)
+		global_p->prefix.macip_addr.mac = *mac;
+
+	if (ip)
+		global_p->prefix.macip_addr.ip = *ip;
+}
+
+static inline void
+evpn_type2_prefix_vni_ip_copy(struct prefix_evpn *vni_p,
+			      const struct prefix_evpn *global_p)
+{
+	memcpy(vni_p, global_p, sizeof(*vni_p));
+	memset(&vni_p->prefix.macip_addr.mac, 0, sizeof(struct ethaddr));
+}
+
+static inline void
+evpn_type2_prefix_vni_mac_copy(struct prefix_evpn *vni_p,
+			       const struct prefix_evpn *global_p)
+{
+	memcpy(vni_p, global_p, sizeof(*vni_p));
+	memset(&vni_p->prefix.macip_addr.ip, 0, sizeof(struct ipaddr));
+}
+
+/* Get MAC of path_info prefix */
+static inline struct ethaddr *
+evpn_type2_path_info_get_mac(const struct bgp_path_info *local_pi)
+{
+	assert(local_pi->extra);
+	return &local_pi->extra->vni_info.mac;
+}
+
+/* Get IP of path_info prefix */
+static inline struct ipaddr *
+evpn_type2_path_info_get_ip(const struct bgp_path_info *local_pi)
+{
+	assert(local_pi->extra);
+	return &local_pi->extra->vni_info.ip;
+}
+
+/* Set MAC of path_info prefix */
+static inline void evpn_type2_path_info_set_mac(struct bgp_path_info *local_pi,
+						const struct ethaddr mac)
+{
+	assert(local_pi->extra);
+	local_pi->extra->vni_info.mac = mac;
+}
+
+/* Set IP of path_info prefix */
+static inline void evpn_type2_path_info_set_ip(struct bgp_path_info *local_pi,
+					       const struct ipaddr ip)
+{
+	assert(local_pi->extra);
+	local_pi->extra->vni_info.ip = ip;
+}
+
+/* Is the IP empty for the RT's dest? */
+static inline bool is_evpn_type2_dest_ipaddr_none(const struct bgp_dest *dest)
+{
+	const struct prefix_evpn *evp =
+		(const struct prefix_evpn *)bgp_dest_get_prefix(dest);
+
+	assert(evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE);
+	return is_evpn_prefix_ipaddr_none(evp);
+}
+
 static inline int evpn_default_originate_set(struct bgp *bgp, afi_t afi,
 					     safi_t safi)
 {
@@ -590,15 +674,21 @@ extern struct zclient *zclient;
 extern void bgp_evpn_install_uninstall_default_route(struct bgp *bgp_vrf,
 						     afi_t afi, safi_t safi,
 						     bool add);
-extern void evpn_rt_delete_auto(struct bgp *, vni_t, struct list *);
+extern void evpn_rt_delete_auto(struct bgp *bgp, vni_t vni, struct list *rtl,
+				bool is_l3);
 extern void bgp_evpn_configure_export_rt_for_vrf(struct bgp *bgp_vrf,
 						 struct ecommunity *ecomadd);
+extern void bgp_evpn_configure_export_auto_rt_for_vrf(struct bgp *bgp_vrf);
 extern void bgp_evpn_unconfigure_export_rt_for_vrf(struct bgp *bgp_vrf,
 						   struct ecommunity *ecomdel);
+extern void bgp_evpn_unconfigure_export_auto_rt_for_vrf(struct bgp *bgp_vrf);
 extern void bgp_evpn_configure_import_rt_for_vrf(struct bgp *bgp_vrf,
-						 struct ecommunity *ecomadd);
+						 struct ecommunity *ecomadd,
+						 bool is_wildcard);
+extern void bgp_evpn_configure_import_auto_rt_for_vrf(struct bgp *bgp_vrf);
 extern void bgp_evpn_unconfigure_import_rt_for_vrf(struct bgp *bgp_vrf,
 						   struct ecommunity *ecomdel);
+extern void bgp_evpn_unconfigure_import_auto_rt_for_vrf(struct bgp *bgp_vrf);
 extern int bgp_evpn_handle_export_rt_change(struct bgp *bgp,
 					    struct bgpevpn *vpn);
 extern void bgp_evpn_handle_autort_change(struct bgp *bgp);
@@ -633,14 +723,39 @@ extern void delete_evpn_route_entry(stru
 int vni_list_cmp(void *p1, void *p2);
 extern int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
 				     struct bgp_dest *dest);
-extern struct bgp_dest *bgp_global_evpn_node_get(struct bgp_table *table,
-						 afi_t afi, safi_t safi,
-						 const struct prefix_evpn *evp,
-						 struct prefix_rd *prd);
 extern struct bgp_dest *
-bgp_global_evpn_node_lookup(struct bgp_table *table, afi_t afi, safi_t safi,
+bgp_evpn_global_node_get(struct bgp_table *table, afi_t afi, safi_t safi,
+			 const struct prefix_evpn *evp, struct prefix_rd *prd,
+			 const struct bgp_path_info *local_pi);
+extern struct bgp_dest *
+bgp_evpn_global_node_lookup(struct bgp_table *table, afi_t afi, safi_t safi,
+			    const struct prefix_evpn *evp,
+			    struct prefix_rd *prd,
+			    const struct bgp_path_info *local_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_ip_node_get(struct bgp_table *const table,
+			 const struct prefix_evpn *evp,
+			 const struct bgp_path_info *parent_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_ip_node_lookup(const struct bgp_table *const table,
 			    const struct prefix_evpn *evp,
-			    struct prefix_rd *prd);
+			    const struct bgp_path_info *parent_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_mac_node_get(struct bgp_table *const table,
+			  const struct prefix_evpn *evp,
+			  const struct bgp_path_info *parent_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_mac_node_lookup(const struct bgp_table *const table,
+			     const struct prefix_evpn *evp,
+			     const struct bgp_path_info *parent_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_node_get(struct bgpevpn *vpn, const struct prefix_evpn *p,
+		      const struct bgp_path_info *parent_pi);
+extern struct bgp_dest *
+bgp_evpn_vni_node_lookup(const struct bgpevpn *vpn, const struct prefix_evpn *p,
+			 const struct bgp_path_info *parent_pi);
+
+extern void bgp_evpn_import_route_in_vrfs(struct bgp_path_info *pi, int import);
 extern void bgp_evpn_update_type2_route_entry(struct bgp *bgp,
 					      struct bgpevpn *vpn,
 					      struct bgp_node *rn,
diff -urpN frr-frr-8.4.2/bgpd/bgp_evpn_vty.c frr-frr-8.5/bgpd/bgp_evpn_vty.c
--- frr-frr-8.4.2/bgpd/bgp_evpn_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_evpn_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -57,6 +57,8 @@ struct vni_walk_ctx {
 	struct in_addr vtep_ip;
 	json_object *json;
 	int detail;
+	int type;
+	bool mac_table;
 };
 
 int argv_find_and_parse_oly_idx(struct cmd_token **argv, int argc, int *oly_idx,
@@ -370,10 +372,9 @@ static void bgp_evpn_show_route_header(s
 static void display_l3vni(struct vty *vty, struct bgp *bgp_vrf,
 			  json_object *json)
 {
-	char buf1[INET6_ADDRSTRLEN];
 	char *ecom_str;
 	struct listnode *node, *nnode;
-	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
 	json_object *json_import_rtl = NULL;
 	json_object *json_export_rtl = NULL;
 	char buf2[ETHER_ADDR_STRLEN];
@@ -417,9 +418,8 @@ static void display_l3vni(struct vty *vt
 		vty_out(vty, "  Advertise-svi-macip : %s\n", "n/a");
 		vty_out(vty, "  Advertise-pip: %s\n",
 			bgp_vrf->evpn_info->advertise_pip ? "Yes" : "No");
-		vty_out(vty, "  System-IP: %s\n",
-			inet_ntop(AF_INET, &bgp_vrf->evpn_info->pip_ip,
-				  buf1, INET_ADDRSTRLEN));
+		vty_out(vty, "  System-IP: %pI4\n",
+			&bgp_vrf->evpn_info->pip_ip);
 		vty_out(vty, "  System-MAC: %s\n",
 				prefix_mac2str(&bgp_vrf->evpn_info->pip_rmac,
 					       buf2, sizeof(buf2)));
@@ -431,8 +431,8 @@ static void display_l3vni(struct vty *vt
 	if (!json)
 		vty_out(vty, "  Import Route Target:\n");
 
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, ecom)) {
-		ecom_str = ecommunity_ecom2str(ecom,
+	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_import_rtl, node, nnode, l3rt)) {
+		ecom_str = ecommunity_ecom2str(l3rt->ecom,
 					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
 
 		if (json)
@@ -449,8 +449,8 @@ static void display_l3vni(struct vty *vt
 	else
 		vty_out(vty, "  Export Route Target:\n");
 
-	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_export_rtl, node, nnode, ecom)) {
-		ecom_str = ecommunity_ecom2str(ecom,
+	for (ALL_LIST_ELEMENTS(bgp_vrf->vrf_export_rtl, node, nnode, l3rt)) {
+		ecom_str = ecommunity_ecom2str(l3rt->ecom,
 					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
 
 		if (json)
@@ -517,7 +517,7 @@ static void display_vni(struct vty *vty,
 			json, "sviInterface",
 			ifindex2ifname(vpn->svi_ifindex, vpn->tenant_vrf_id));
 	} else {
-		vty_out(vty, "VNI: %d", vpn->vni);
+		vty_out(vty, "VNI: %u", vpn->vni);
 		if (is_vni_live(vpn))
 			vty_out(vty, " (known to the kernel)");
 		vty_out(vty, "\n");
@@ -735,7 +735,8 @@ static void bgp_evpn_show_routes_mac_ip_
 
 			if (detail)
 				route_vty_out_detail(
-					vty, bgp, rn, pi, AFI_L2VPN, SAFI_EVPN,
+					vty, bgp, rn, bgp_dest_get_prefix(rn),
+					pi, AFI_L2VPN, SAFI_EVPN,
 					RPKI_NOT_BEING_USED, json_path);
 			else
 				route_vty_out(vty, &rn->p, pi, 0, SAFI_EVPN,
@@ -770,9 +771,10 @@ static void bgp_evpn_show_routes_mac_ip_
 	bgp_evpn_show_routes_mac_ip_es(vty, esi, json, detail, true);
 }
 
-static void show_vni_routes(struct bgp *bgp, struct bgpevpn *vpn, int type,
-			    struct vty *vty, struct in_addr vtep_ip,
-			    json_object *json, int detail)
+static void show_vni_routes(struct bgp *bgp, struct bgpevpn *vpn,
+			    struct vty *vty, int type, bool mac_table,
+			    struct in_addr vtep_ip, json_object *json,
+			    int detail)
 {
 	struct bgp_dest *dest;
 	struct bgp_path_info *pi;
@@ -783,7 +785,11 @@ static void show_vni_routes(struct bgp *
 
 	prefix_cnt = path_cnt = 0;
 
-	table = vpn->route_table;
+	if (mac_table)
+		table = vpn->mac_table;
+	else
+		table = vpn->ip_table;
+
 	tbl_ver = table->version;
 	for (dest = bgp_table_top(table); dest; dest = bgp_route_next(dest)) {
 		const struct prefix_evpn *evp =
@@ -818,6 +824,7 @@ static void show_vni_routes(struct bgp *
 		 * with code that already exists).
 		 */
 		for (; pi; pi = pi->next) {
+			struct prefix tmp_p;
 			json_object *json_path = NULL;
 
 			if (vtep_ip.s_addr != INADDR_ANY
@@ -825,16 +832,43 @@ static void show_vni_routes(struct bgp *
 					       &(pi->attr->nexthop)))
 				continue;
 
+			if (evp->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
+				/*
+				 * VNI IP/MAC table prefixes don't have MAC/IP
+				 * respectively so make sure it's set from path
+				 * info here.
+				 */
+				if (is_evpn_prefix_ipaddr_none(evp)) {
+					/* VNI MAC -> Global */
+					evpn_type2_prefix_global_copy(
+						(struct prefix_evpn *)&tmp_p,
+						evp, NULL /* mac */,
+						evpn_type2_path_info_get_ip(
+							pi));
+				} else {
+					/* VNI IP -> Global */
+					evpn_type2_prefix_global_copy(
+						(struct prefix_evpn *)&tmp_p,
+						evp,
+						evpn_type2_path_info_get_mac(
+							pi),
+						NULL /* ip */);
+				}
+			} else
+				memcpy(&tmp_p, p, sizeof(tmp_p));
+
+
 			if (json)
 				json_path = json_object_new_array();
 
 			if (detail)
-				route_vty_out_detail(vty, bgp, dest, pi,
+				route_vty_out_detail(vty, bgp, dest, &tmp_p, pi,
 						     AFI_L2VPN, SAFI_EVPN,
 						     RPKI_NOT_BEING_USED,
 						     json_path);
+
 			else
-				route_vty_out(vty, p, pi, 0, SAFI_EVPN,
+				route_vty_out(vty, &tmp_p, pi, 0, SAFI_EVPN,
 					      json_path, false);
 
 			if (json)
@@ -887,21 +921,57 @@ static void show_vni_routes_hash(struct
 	json_object *json_vni = NULL;
 	char vni_str[VNI_STR_LEN];
 
-	snprintf(vni_str, sizeof(vni_str), "%d", vpn->vni);
+	snprintf(vni_str, sizeof(vni_str), "%u", vpn->vni);
 	if (json) {
 		json_vni = json_object_new_object();
 		json_object_int_add(json_vni, "vni", vpn->vni);
 	} else {
-		vty_out(vty, "\nVNI: %d\n\n", vpn->vni);
+		vty_out(vty, "\nVNI: %u\n\n", vpn->vni);
 	}
 
-	show_vni_routes(wctx->bgp, vpn, 0, wctx->vty, wctx->vtep_ip, json_vni,
-			wctx->detail);
+	show_vni_routes(wctx->bgp, vpn, wctx->vty, wctx->type, wctx->mac_table,
+			wctx->vtep_ip, json_vni, wctx->detail);
 
 	if (json)
 		json_object_object_add(json, vni_str, json_vni);
 }
 
+static void show_vni_routes_all_hash(struct hash_bucket *bucket, void *arg)
+{
+	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;
+	struct vni_walk_ctx *wctx = arg;
+	struct vty *vty = wctx->vty;
+	json_object *json = wctx->json;
+	json_object *json_vni = NULL;
+	json_object *json_vni_mac = NULL;
+	char vni_str[VNI_STR_LEN];
+
+	snprintf(vni_str, sizeof(vni_str), "%u", vpn->vni);
+	if (json) {
+		json_vni = json_object_new_object();
+		json_object_int_add(json_vni, "vni", vpn->vni);
+	} else {
+		vty_out(vty, "\nVNI: %u\n\n", vpn->vni);
+	}
+
+	show_vni_routes(wctx->bgp, vpn, wctx->vty, 0, false, wctx->vtep_ip,
+			json_vni, wctx->detail);
+
+	if (json)
+		json_object_object_add(json, vni_str, json_vni);
+
+	if (json)
+		json_vni_mac = json_object_new_object();
+	else
+		vty_out(vty, "\nVNI: %u MAC Table\n\n", vpn->vni);
+
+	show_vni_routes(wctx->bgp, vpn, wctx->vty, 0, true, wctx->vtep_ip,
+			json_vni_mac, wctx->detail);
+
+	if (json)
+		json_object_object_add(json_vni, "macTable", json_vni_mac);
+}
+
 static void show_l3vni_entry(struct vty *vty, struct bgp *bgp,
 			     json_object *json)
 {
@@ -913,7 +983,7 @@ static void show_l3vni_entry(struct vty
 	char rt_buf[25];
 	char *ecom_str;
 	struct listnode *node, *nnode;
-	struct ecommunity *ecom;
+	struct vrf_route_target *l3rt;
 
 	if (!bgp->l3vni)
 		return;
@@ -954,8 +1024,8 @@ static void show_l3vni_entry(struct vty
 			&bgp->vrf_prd);
 	}
 
-	for (ALL_LIST_ELEMENTS(bgp->vrf_import_rtl, node, nnode, ecom)) {
-		ecom_str = ecommunity_ecom2str(ecom,
+	for (ALL_LIST_ELEMENTS(bgp->vrf_import_rtl, node, nnode, l3rt)) {
+		ecom_str = ecommunity_ecom2str(l3rt->ecom,
 					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
 
 		if (json) {
@@ -982,8 +1052,8 @@ static void show_l3vni_entry(struct vty
 	if (json)
 		json_object_object_add(json_vni, "importRTs", json_import_rtl);
 
-	for (ALL_LIST_ELEMENTS(bgp->vrf_export_rtl, node, nnode, ecom)) {
-		ecom_str = ecommunity_ecom2str(ecom,
+	for (ALL_LIST_ELEMENTS(bgp->vrf_export_rtl, node, nnode, l3rt)) {
+		ecom_str = ecommunity_ecom2str(l3rt->ecom,
 					       ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
 
 		if (json) {
@@ -1984,12 +2054,12 @@ DEFUN(no_evpnrt5_network,
 
 static void evpn_import_rt_delete_auto(struct bgp *bgp, struct bgpevpn *vpn)
 {
-	evpn_rt_delete_auto(bgp, vpn->vni, vpn->import_rtl);
+	evpn_rt_delete_auto(bgp, vpn->vni, vpn->import_rtl, false);
 }
 
 static void evpn_export_rt_delete_auto(struct bgp *bgp, struct bgpevpn *vpn)
 {
-	evpn_rt_delete_auto(bgp, vpn->vni, vpn->export_rtl);
+	evpn_rt_delete_auto(bgp, vpn->vni, vpn->export_rtl, false);
 }
 
 /*
@@ -2322,9 +2392,9 @@ static void evpn_show_import_rts(struct
 /*
  * Display EVPN routes for all VNIs - vty handler.
  */
-static void evpn_show_routes_vni_all(struct vty *vty, struct bgp *bgp,
-				     struct in_addr vtep_ip, json_object *json,
-				     int detail)
+static void evpn_show_routes_vni_all(struct vty *vty, struct bgp *bgp, int type,
+				     bool mac_table, struct in_addr vtep_ip,
+				     json_object *json, int detail)
 {
 	uint32_t num_vnis;
 	struct vni_walk_ctx wctx;
@@ -2335,6 +2405,8 @@ static void evpn_show_routes_vni_all(str
 	memset(&wctx, 0, sizeof(wctx));
 	wctx.bgp = bgp;
 	wctx.vty = vty;
+	wctx.type = type;
+	wctx.mac_table = mac_table;
 	wctx.vtep_ip = vtep_ip;
 	wctx.json = json;
 	wctx.detail = detail;
@@ -2344,6 +2416,32 @@ static void evpn_show_routes_vni_all(str
 }
 
 /*
+ * Display EVPN routes for all VNIs & all types - vty handler.
+ */
+static void evpn_show_routes_vni_all_type_all(struct vty *vty, struct bgp *bgp,
+					      struct in_addr vtep_ip,
+					      json_object *json, int detail)
+{
+	uint32_t num_vnis;
+	struct vni_walk_ctx wctx;
+
+	num_vnis = hashcount(bgp->vnihash);
+	if (!num_vnis)
+		return;
+
+	memset(&wctx, 0, sizeof(struct vni_walk_ctx));
+	wctx.bgp = bgp;
+	wctx.vty = vty;
+	wctx.vtep_ip = vtep_ip;
+	wctx.json = json;
+	wctx.detail = detail;
+	hash_iterate(bgp->vnihash,
+		     (void (*)(struct hash_bucket *,
+			       void *))show_vni_routes_all_hash,
+		     &wctx);
+}
+
+/*
  * Display EVPN routes for a VNI -- for specific type-3 route (vty handler).
  */
 static void evpn_show_route_vni_multicast(struct vty *vty, struct bgp *bgp,
@@ -2371,7 +2469,7 @@ static void evpn_show_route_vni_multicas
 
 	/* See if route exists. */
 	build_evpn_type3_prefix(&p, orig_ip);
-	dest = bgp_node_lookup(vpn->route_table, (struct prefix *)&p);
+	dest = bgp_evpn_vni_node_lookup(vpn, &p, NULL);
 	if (!dest || !bgp_dest_has_bgp_path_info_data(dest)) {
 		if (!json)
 			vty_out(vty, "%% Network not in table\n");
@@ -2386,7 +2484,8 @@ static void evpn_show_route_vni_multicas
 		json_paths = json_object_new_array();
 
 	/* Prefix and num paths displayed once per prefix. */
-	route_vty_out_detail_header(vty, bgp, dest, NULL, afi, safi, json);
+	route_vty_out_detail_header(vty, bgp, dest, bgp_dest_get_prefix(dest),
+				    NULL, afi, safi, json);
 
 	/* Display each path for this prefix. */
 	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
@@ -2395,8 +2494,9 @@ static void evpn_show_route_vni_multicas
 		if (json)
 			json_path = json_object_new_array();
 
-		route_vty_out_detail(vty, bgp, dest, pi, afi, safi,
-				     RPKI_NOT_BEING_USED, json_path);
+		route_vty_out_detail(vty, bgp, dest, bgp_dest_get_prefix(dest),
+				     pi, afi, safi, RPKI_NOT_BEING_USED,
+				     json_path);
 
 		if (json)
 			json_object_array_add(json_paths, json_path);
@@ -2427,12 +2527,16 @@ static void evpn_show_route_vni_macip(st
 {
 	struct bgpevpn *vpn;
 	struct prefix_evpn p;
+	struct prefix_evpn tmp_p;
 	struct bgp_dest *dest;
 	struct bgp_path_info *pi;
 	uint32_t path_cnt = 0;
 	afi_t afi;
 	safi_t safi;
 	json_object *json_paths = NULL;
+	struct ethaddr empty_mac = {};
+	struct ipaddr empty_ip = {};
+	const struct prefix_evpn *evp;
 
 	afi = AFI_L2VPN;
 	safi = SAFI_EVPN;
@@ -2445,9 +2549,11 @@ static void evpn_show_route_vni_macip(st
 		return;
 	}
 
+	build_evpn_type2_prefix(&p, mac ? mac : &empty_mac,
+				ip ? ip : &empty_ip);
+
 	/* See if route exists. Look for both non-sticky and sticky. */
-	build_evpn_type2_prefix(&p, mac, ip);
-	dest = bgp_node_lookup(vpn->route_table, (struct prefix *)&p);
+	dest = bgp_evpn_vni_node_lookup(vpn, &p, NULL);
 	if (!dest || !bgp_dest_has_bgp_path_info_data(dest)) {
 		if (!json)
 			vty_out(vty, "%% Network not in table\n");
@@ -2458,21 +2564,68 @@ static void evpn_show_route_vni_macip(st
 		return;
 	}
 
+	/*
+	 * MAC is per-path, we have to walk the path_info's and look for it
+	 * first here.
+	 */
+	if (ip && mac) {
+		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
+			if (memcmp(mac, evpn_type2_path_info_get_mac(pi),
+				   sizeof(*mac)) == 0)
+				break;
+		}
+
+		if (!pi) {
+			if (!json)
+				vty_out(vty, "%% Network not in table\n");
+			return;
+		}
+	}
+
 	if (json)
 		json_paths = json_object_new_array();
 
 	/* Prefix and num paths displayed once per prefix. */
-	route_vty_out_detail_header(vty, bgp, dest, NULL, afi, safi, json);
+	route_vty_out_detail_header(vty, bgp, dest, (struct prefix *)&p, NULL,
+				    afi, safi, json);
+
+	evp = (const struct prefix_evpn *)bgp_dest_get_prefix(dest);
 
 	/* Display each path for this prefix. */
 	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 		json_object *json_path = NULL;
 
+		/* skip non-matching MACs */
+		if (ip && mac &&
+		    memcmp(mac, evpn_type2_path_info_get_mac(pi),
+			   sizeof(*mac)) != 0)
+			continue;
+
 		if (json)
 			json_path = json_object_new_array();
 
-		route_vty_out_detail(vty, bgp, dest, pi, afi, safi,
-				     RPKI_NOT_BEING_USED, json_path);
+		/*
+		 * VNI table MAC-IP prefixes don't have MAC so
+		 * make sure it's set from path info
+		 * here.
+		 */
+		if (is_evpn_prefix_ipaddr_none(evp)) {
+			/* VNI MAC -> Global */
+			evpn_type2_prefix_global_copy(
+				(struct prefix_evpn *)&tmp_p, evp,
+				NULL /* mac */,
+				evpn_type2_path_info_get_ip(pi));
+		} else {
+			/* VNI IP -> Global */
+			evpn_type2_prefix_global_copy(
+				(struct prefix_evpn *)&tmp_p, evp,
+				evpn_type2_path_info_get_mac(pi),
+				NULL /* ip */);
+		}
+
+		route_vty_out_detail(vty, bgp, dest, (struct prefix *)&tmp_p,
+				     pi, afi, safi, RPKI_NOT_BEING_USED,
+				     json_path);
 
 		if (json)
 			json_object_array_add(json_paths, json_path);
@@ -2516,8 +2669,8 @@ static void evpn_show_routes_esi(struct
  * If the vtep_ip is non zero, only routes behind that vtep are shown
  */
 static void evpn_show_routes_vni(struct vty *vty, struct bgp *bgp, vni_t vni,
-				 int type, struct in_addr vtep_ip,
-				 json_object *json)
+				 int type, bool mac_table,
+				 struct in_addr vtep_ip, json_object *json)
 {
 	struct bgpevpn *vpn;
 
@@ -2530,7 +2683,7 @@ static void evpn_show_routes_vni(struct
 	}
 
 	/* Walk this VNI's route table and display appropriate routes. */
-	show_vni_routes(bgp, vpn, type, vty, vtep_ip, json, 0);
+	show_vni_routes(bgp, vpn, vty, type, mac_table, vtep_ip, json, 0);
 }
 
 /*
@@ -2568,7 +2721,8 @@ static void evpn_show_route_rd_macip(str
 	}
 
 	/* Prefix and num paths displayed once per prefix. */
-	route_vty_out_detail_header(vty, bgp, dest, prd, afi, safi, json);
+	route_vty_out_detail_header(vty, bgp, dest, bgp_dest_get_prefix(dest),
+				    prd, afi, safi, json);
 
 	if (json)
 		json_paths = json_object_new_array();
@@ -2580,8 +2734,9 @@ static void evpn_show_route_rd_macip(str
 		if (json)
 			json_path = json_object_new_array();
 
-		route_vty_out_detail(vty, bgp, dest, pi, afi, safi,
-				     RPKI_NOT_BEING_USED, json_path);
+		route_vty_out_detail(vty, bgp, dest, bgp_dest_get_prefix(dest),
+				     pi, afi, safi, RPKI_NOT_BEING_USED,
+				     json_path);
 
 		if (json)
 			json_object_array_add(json_paths, json_path);
@@ -2673,8 +2828,9 @@ static void evpn_show_route_rd(struct vt
 			}
 
 			/* Prefix and num paths displayed once per prefix. */
-			route_vty_out_detail_header(vty, bgp, dest, prd, afi,
-						    safi, json_prefix);
+			route_vty_out_detail_header(
+				vty, bgp, dest, bgp_dest_get_prefix(dest), prd,
+				afi, safi, json_prefix);
 
 			prefix_cnt++;
 		}
@@ -2689,8 +2845,9 @@ static void evpn_show_route_rd(struct vt
 			if (json)
 				json_path = json_object_new_array();
 
-			route_vty_out_detail(vty, bgp, dest, pi, afi, safi,
-					     RPKI_NOT_BEING_USED, json_path);
+			route_vty_out_detail(
+				vty, bgp, dest, bgp_dest_get_prefix(dest), pi,
+				afi, safi, RPKI_NOT_BEING_USED, json_path);
 
 			if (json)
 				json_object_array_add(json_paths, json_path);
@@ -2807,7 +2964,7 @@ static void evpn_show_route_rd_all_macip
 		} else
 			/* Prefix and num paths displayed once per prefix. */
 			route_vty_out_detail_header(
-				vty, bgp, dest, (struct prefix_rd *)rd_destp,
+				vty, bgp, dest, p, (struct prefix_rd *)rd_destp,
 				AFI_L2VPN, SAFI_EVPN, json_prefix);
 
 		/* For EVPN, the prefix is displayed for each path (to
@@ -2822,7 +2979,7 @@ static void evpn_show_route_rd_all_macip
 			if (json)
 				json_path = json_object_new_array();
 
-			route_vty_out_detail(vty, bgp, dest, pi, AFI_L2VPN,
+			route_vty_out_detail(vty, bgp, dest, p, pi, AFI_L2VPN,
 					     SAFI_EVPN, RPKI_NOT_BEING_USED,
 					     json_path);
 
@@ -2960,6 +3117,7 @@ static void evpn_show_all_routes(struct
 			if (detail)
 				route_vty_out_detail_header(
 					vty, bgp, dest,
+					bgp_dest_get_prefix(dest),
 					(struct prefix_rd *)rd_destp, AFI_L2VPN,
 					SAFI_EVPN, json_prefix);
 
@@ -2979,9 +3137,10 @@ static void evpn_show_all_routes(struct
 
 				if (detail) {
 					route_vty_out_detail(
-						vty, bgp, dest, pi, AFI_L2VPN,
-						SAFI_EVPN, RPKI_NOT_BEING_USED,
-						json_path);
+						vty, bgp, dest,
+						bgp_dest_get_prefix(dest), pi,
+						AFI_L2VPN, SAFI_EVPN,
+						RPKI_NOT_BEING_USED, json_path);
 				} else
 					route_vty_out(vty, p, pi, 0, SAFI_EVPN,
 						      json_path, false);
@@ -3033,6 +3192,21 @@ static void evpn_show_all_routes(struct
 	}
 }
 
+int bgp_evpn_show_all_routes(struct vty *vty, struct bgp *bgp, int type,
+			     bool use_json, int detail)
+{
+	json_object *json = NULL;
+
+	if (use_json)
+		json = json_object_new_object();
+
+	evpn_show_all_routes(vty, bgp, type, json, detail);
+
+	if (use_json)
+		vty_json(vty, json);
+	return CMD_SUCCESS;
+}
+
 /*
  * Display specified VNI (vty handler)
  */
@@ -3297,7 +3471,7 @@ static void write_vni_config(struct vty
 	struct ecommunity *ecom;
 
 	if (is_vni_configured(vpn)) {
-		vty_out(vty, "  vni %d\n", vpn->vni);
+		vty_out(vty, "  vni %u\n", vpn->vni);
 		if (is_rd_configured(vpn))
 			vty_out(vty, "   rd %pRD\n", &vpn->prd);
 
@@ -3336,9 +3510,7 @@ static void write_vni_config(struct vty
 	}
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_evpn_vty_clippy.c"
-#endif
 
 DEFPY(bgp_evpn_flood_control,
       bgp_evpn_flood_control_cmd,
@@ -3980,11 +4152,13 @@ DEFUN (bgp_evpn_advertise_type5,
 
 DEFUN (no_bgp_evpn_advertise_type5,
        no_bgp_evpn_advertise_type5_cmd,
-       "no advertise " BGP_AFI_CMD_STR "" BGP_SAFI_CMD_STR,
+       "no advertise " BGP_AFI_CMD_STR "" BGP_SAFI_CMD_STR " [route-map WORD]",
        NO_STR
        "Advertise prefix routes\n"
        BGP_AFI_HELP_STR
-       BGP_SAFI_HELP_STR)
+       BGP_SAFI_HELP_STR
+       "route-map for filtering specific routes\n"
+       "Name of the route map\n")
 {
 	struct bgp *bgp_vrf = VTY_GET_CONTEXT(bgp); /* bgp vrf instance */
 	int idx_afi = 0;
@@ -4562,28 +4736,32 @@ DEFUN(show_bgp_l2vpn_evpn_summary, show_
 				    as_type, as, show_flags);
 }
 
+static int bgp_evpn_cli_parse_type_cmp(int *type, const char *type_str)
+{
+	if ((strncmp(type_str, "ma", 2) == 0) || (strmatch(type_str, "2")))
+		*type = BGP_EVPN_MAC_IP_ROUTE;
+	else if ((strncmp(type_str, "mu", 2) == 0) || (strmatch(type_str, "3")))
+		*type = BGP_EVPN_IMET_ROUTE;
+	else if ((strncmp(type_str, "es", 2) == 0) || (strmatch(type_str, "4")))
+		*type = BGP_EVPN_ES_ROUTE;
+	else if ((strncmp(type_str, "ea", 2) == 0) || (strmatch(type_str, "1")))
+		*type = BGP_EVPN_AD_ROUTE;
+	else if ((strncmp(type_str, "p", 1) == 0) || (strmatch(type_str, "5")))
+		*type = BGP_EVPN_IP_PREFIX_ROUTE;
+	else
+		return -1;
+
+	return 0;
+}
+
 int bgp_evpn_cli_parse_type(int *type, struct cmd_token **argv, int argc)
 {
 	int type_idx = 0;
 
 	if (argv_find(argv, argc, "type", &type_idx)) {
 		/* Specific type is requested */
-		if ((strncmp(argv[type_idx + 1]->arg, "ma", 2) == 0)
-		    || (strmatch(argv[type_idx + 1]->arg, "2")))
-			*type = BGP_EVPN_MAC_IP_ROUTE;
-		else if ((strncmp(argv[type_idx + 1]->arg, "mu", 2) == 0)
-			 || (strmatch(argv[type_idx + 1]->arg, "3")))
-			*type = BGP_EVPN_IMET_ROUTE;
-		else if ((strncmp(argv[type_idx + 1]->arg, "es", 2) == 0)
-			 || (strmatch(argv[type_idx + 1]->arg, "4")))
-			*type = BGP_EVPN_ES_ROUTE;
-		else if ((strncmp(argv[type_idx + 1]->arg, "ea", 2) == 0)
-			 || (strmatch(argv[type_idx + 1]->arg, "1")))
-			*type = BGP_EVPN_AD_ROUTE;
-		else if ((strncmp(argv[type_idx + 1]->arg, "p", 1) == 0)
-			 || (strmatch(argv[type_idx + 1]->arg, "5")))
-			*type = BGP_EVPN_IP_PREFIX_ROUTE;
-		else
+		if (bgp_evpn_cli_parse_type_cmp(type,
+						argv[type_idx + 1]->arg) != 0)
 			return -1;
 	}
 
@@ -4629,8 +4807,14 @@ DEFUN(show_bgp_l2vpn_evpn_route,
 
 	evpn_show_all_routes(vty, bgp, type, json, detail);
 
+	/*
+	 * This is an extremely expensive operation at scale
+	 * and as such we need to save as much time as is
+	 * possible.
+	 */
 	if (uj)
-		vty_json(vty, json);
+		vty_json_no_pretty(vty, json);
+
 	return CMD_SUCCESS;
 }
 
@@ -4881,7 +5065,7 @@ DEFUN(show_bgp_l2vpn_evpn_route_vni, sho
 		}
 	}
 
-	evpn_show_routes_vni(vty, bgp, vni, type, vtep_ip, json);
+	evpn_show_routes_vni(vty, bgp, vni, type, false, vtep_ip, json);
 
 	if (uj)
 		vty_json(vty, json);
@@ -5063,7 +5247,464 @@ DEFUN(show_bgp_l2vpn_evpn_route_vni_all,
 		}
 	}
 
-	evpn_show_routes_vni_all(vty, bgp, vtep_ip, json, da);
+	evpn_show_routes_vni_all(vty, bgp, 0, false, vtep_ip, json, da);
+
+	if (uj) {
+		vty_json(vty, json);
+		json_object_free(json);
+	}
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN ALL routing tables - for all VNIs.
+ */
+DEFPY(show_bgp_vni_all,
+      show_bgp_vni_all_cmd,
+      "show bgp vni all [vtep A.B.C.D$addr] [detail$detail] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_ALL_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      DETAIL_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni_all_type_all(vty, bgp, addr, json, !!detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN EAD routing table - for all VNIs.
+ */
+DEFPY(show_bgp_vni_all_ead,
+      show_bgp_vni_all_ead_cmd,
+      "show bgp vni all type <1|ead> [vtep A.B.C.D$addr] [<detail$detail|json$uj>]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_ALL_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_1_HELP_STR
+      EVPN_TYPE_1_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      DETAIL_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni_all(vty, bgp, BGP_EVPN_AD_ROUTE, false, addr, json,
+				 !!detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN MAC routing table - for all VNIs.
+ */
+DEFPY(show_bgp_vni_all_macip_mac,
+      show_bgp_vni_all_macip_mac_cmd,
+      "show bgp vni all type <2|macip> mac [vtep A.B.C.D$addr] [<detail$detail|json$uj>]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_ALL_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      "MAC Table\n"
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      DETAIL_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni_all(vty, bgp, BGP_EVPN_MAC_IP_ROUTE, true, addr,
+				 json, !!detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN IP routing table - for all VNIs.
+ */
+DEFPY(show_bgp_vni_all_macip_ip,
+      show_bgp_vni_all_macip_ip_cmd,
+      "show bgp vni all type <2|macip> ip [vtep A.B.C.D$addr] [<detail$detail|json$uj>]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_ALL_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      "IP Table\n"
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      DETAIL_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni_all(vty, bgp, BGP_EVPN_MAC_IP_ROUTE, false, addr,
+				 json, !!detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN Multicast routing table - for all VNIs.
+ */
+DEFPY(show_bgp_vni_all_imet,
+      show_bgp_vni_all_imet_cmd,
+      "show bgp vni all type <3|multicast> [vtep A.B.C.D$addr] [<detail$detail|json$uj>]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_ALL_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_3_HELP_STR
+      EVPN_TYPE_3_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      DETAIL_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni_all(vty, bgp, BGP_EVPN_IMET_ROUTE, false, addr,
+				 json, !!detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN ALL routing tables - for select VNI
+ */
+DEFPY(show_bgp_vni,
+      show_bgp_vni_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni [vtep A.B.C.D$addr] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+	json_object *json_mac = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj) {
+		json = json_object_new_object();
+		json_mac = json_object_new_object();
+	}
+
+	evpn_show_routes_vni(vty, bgp, vni, 0, false, addr, json);
+
+	if (!uj)
+		vty_out(vty, "\n\nMAC Table:\n\n");
+
+	evpn_show_routes_vni(vty, bgp, vni, 0, true, addr, json_mac);
+
+	if (uj) {
+		json_object_object_add(json, "macTable", json_mac);
+		vty_json(vty, json);
+	}
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN EAD routing table - for select VNI
+ */
+DEFPY(show_bgp_vni_ead,
+      show_bgp_vni_ead_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni type <1|ead> [vtep A.B.C.D$addr] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_1_HELP_STR
+      EVPN_TYPE_1_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni(vty, bgp, vni, BGP_EVPN_AD_ROUTE, false, addr,
+			     json);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN MAC-IP MAC routing table - for select VNI
+ */
+DEFPY(show_bgp_vni_macip_mac,
+      show_bgp_vni_macip_mac_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni type <2|macip> mac [vtep A.B.C.D$addr] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      "MAC Table\n"
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni(vty, bgp, vni, BGP_EVPN_MAC_IP_ROUTE, true, addr,
+			     json);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN MAC-IP IP routing table - for select VNI
+ */
+DEFPY(show_bgp_vni_macip_ip,
+      show_bgp_vni_macip_ip_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni type <2|macip> ip [vtep A.B.C.D$addr] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      "IP Table\n"
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni(vty, bgp, vni, BGP_EVPN_MAC_IP_ROUTE, false, addr,
+			     json);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN Multicast routing table - for select VNI
+ */
+DEFPY(show_bgp_vni_imet,
+      show_bgp_vni_imet_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni type <3|multicast> [vtep A.B.C.D$addr] [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_3_HELP_STR
+      EVPN_TYPE_3_HELP_STR
+      VTEP_HELP_STR
+      VTEP_IP_HELP_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_routes_vni(vty, bgp, vni, BGP_EVPN_IMET_ROUTE, false, addr,
+			     json);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN MACIP MAC routing table - for select VNI & MAC
+ */
+DEFPY(show_bgp_vni_macip_mac_addr,
+      show_bgp_vni_macip_mac_addr_cmd,
+      "show bgp vni "CMD_VNI_RANGE"$vni type <2|macip> mac X:X:X:X:X:X [json$uj]",
+      SHOW_STR
+      BGP_STR
+      VNI_HELP_STR
+      VNI_NUM_HELP_STR
+      EVPN_TYPE_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      EVPN_TYPE_2_HELP_STR
+      "MAC Table\n"
+      MAC_STR
+      JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	evpn_show_route_vni_macip(vty, bgp, vni, &mac->eth_addr, NULL, json);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return CMD_SUCCESS;
+}
+
+/*
+ * Display per-VNI EVPN MACIP IP routing table - for select VNI & IP
+ */
+DEFPY(show_bgp_vni_macip_ip_addr, show_bgp_vni_macip_ip_addr_cmd,
+      "show bgp vni " CMD_VNI_RANGE
+      "$vni type <2|macip> ip <A.B.C.D|X:X::X:X> [json$uj]",
+      SHOW_STR BGP_STR VNI_HELP_STR VNI_NUM_HELP_STR EVPN_TYPE_HELP_STR
+	      EVPN_TYPE_2_HELP_STR EVPN_TYPE_2_HELP_STR
+      "IP Table\n" IP_ADDR_STR IP6_ADDR_STR JSON_STR)
+{
+	struct bgp *bgp;
+	json_object *json = NULL;
+	struct ipaddr ip_addr = {.ipa_type = IPADDR_NONE};
+
+	bgp = bgp_get_evpn();
+	if (!bgp)
+		return CMD_WARNING;
+
+	/* check if we need json output */
+	if (uj)
+		json = json_object_new_object();
+
+	if (sockunion_family(ip) == AF_INET) {
+		ip_addr.ipa_type = IPADDR_V4;
+		ip_addr.ipaddr_v4.s_addr = sockunion2ip(ip);
+	} else {
+		ip_addr.ipa_type = IPADDR_V6;
+		memcpy(&ip_addr.ipaddr_v6, &ip->sin6.sin6_addr,
+		       sizeof(struct in6_addr));
+	}
+	evpn_show_route_vni_macip(vty, bgp, vni, NULL, &ip_addr, json);
 
 	if (uj)
 		vty_json(vty, json);
@@ -5654,18 +6295,35 @@ DEFUN (no_bgp_evpn_vni_rd_without_val,
  * Loop over all extended-communities in the route-target list rtl and
  * return 1 if we find ecomtarget
  */
-static int bgp_evpn_rt_matches_existing(struct list *rtl,
-					struct ecommunity *ecomtarget)
+static bool bgp_evpn_rt_matches_existing(struct list *rtl,
+					 struct ecommunity *ecomtarget)
 {
-	struct listnode *node, *nnode;
+	struct listnode *node;
 	struct ecommunity *ecom;
 
-	for (ALL_LIST_ELEMENTS(rtl, node, nnode, ecom)) {
+	for (ALL_LIST_ELEMENTS_RO(rtl, node, ecom)) {
 		if (ecommunity_match(ecom, ecomtarget))
-			return 1;
+			return true;
 	}
 
-	return 0;
+	return false;
+}
+
+/*
+ * L3 RT version of above.
+ */
+static bool bgp_evpn_vrf_rt_matches_existing(struct list *rtl,
+					     struct ecommunity *ecomtarget)
+{
+	struct listnode *node;
+	struct vrf_route_target *l3rt;
+
+	for (ALL_LIST_ELEMENTS_RO(rtl, node, l3rt)) {
+		if (ecommunity_match(l3rt->ecom, ecomtarget))
+			return true;
+	}
+
+	return false;
 }
 
 /* display L3VNI related info for a VRF instance */
@@ -5685,7 +6343,7 @@ DEFUN (show_bgp_vrf_l3vni_info,
 	struct bgp *bgp = NULL;
 	struct listnode *node = NULL;
 	struct bgpevpn *vpn = NULL;
-	struct ecommunity *ecom = NULL;
+	struct vrf_route_target *l3rt;
 	json_object *json = NULL;
 	json_object *json_vnis = NULL;
 	json_object *json_export_rts = NULL;
@@ -5735,13 +6393,13 @@ DEFUN (show_bgp_vrf_l3vni_info,
 		vty_out(vty, "\n");
 		vty_out(vty, "  Export-RTs:\n");
 		vty_out(vty, "    ");
-		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_export_rtl, node, ecom))
-			vty_out(vty, "%s  ", ecommunity_str(ecom));
+		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_export_rtl, node, l3rt))
+			vty_out(vty, "%s  ", ecommunity_str(l3rt->ecom));
 		vty_out(vty, "\n");
 		vty_out(vty, "  Import-RTs:\n");
 		vty_out(vty, "    ");
-		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_import_rtl, node, ecom))
-			vty_out(vty, "%s  ", ecommunity_str(ecom));
+		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_import_rtl, node, l3rt))
+			vty_out(vty, "%s  ", ecommunity_str(l3rt->ecom));
 		vty_out(vty, "\n");
 		vty_out(vty, "  RD: %pRD\n", &bgp->vrf_prd);
 	} else {
@@ -5765,17 +6423,19 @@ DEFUN (show_bgp_vrf_l3vni_info,
 		json_object_object_add(json, "l2vnis", json_vnis);
 
 		/* export rts */
-		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_export_rtl, node, ecom))
+		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_export_rtl, node, l3rt))
 			json_object_array_add(
 				json_export_rts,
-				json_object_new_string(ecommunity_str(ecom)));
+				json_object_new_string(
+					ecommunity_str(l3rt->ecom)));
 		json_object_object_add(json, "export-rts", json_export_rts);
 
 		/* import rts */
-		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_import_rtl, node, ecom))
+		for (ALL_LIST_ELEMENTS_RO(bgp->vrf_import_rtl, node, l3rt))
 			json_object_array_add(
 				json_import_rts,
-				json_object_new_string(ecommunity_str(ecom)));
+				json_object_new_string(
+					ecommunity_str(l3rt->ecom)));
 		json_object_object_add(json, "import-rts", json_import_rts);
 		json_object_string_addf(json, "rd", "%pRD", &bgp->vrf_prd);
 	}
@@ -5785,22 +6445,126 @@ DEFUN (show_bgp_vrf_l3vni_info,
 	return CMD_SUCCESS;
 }
 
+static int add_rt(struct bgp *bgp, struct ecommunity *ecom, bool is_import,
+		  bool is_wildcard)
+{
+	/* Do nothing if we already have this route-target */
+	if (is_import) {
+		if (!bgp_evpn_vrf_rt_matches_existing(bgp->vrf_import_rtl,
+						      ecom))
+			bgp_evpn_configure_import_rt_for_vrf(bgp, ecom,
+							     is_wildcard);
+		else
+			return -1;
+	} else {
+		if (!bgp_evpn_vrf_rt_matches_existing(bgp->vrf_export_rtl,
+						      ecom))
+			bgp_evpn_configure_export_rt_for_vrf(bgp, ecom);
+		else
+			return -1;
+	}
+
+	return 0;
+}
+
+static int del_rt(struct bgp *bgp, struct ecommunity *ecom, bool is_import)
+{
+	/* Verify we already have this route-target */
+	if (is_import) {
+		if (!bgp_evpn_vrf_rt_matches_existing(bgp->vrf_import_rtl,
+						      ecom))
+			return -1;
+
+		bgp_evpn_unconfigure_import_rt_for_vrf(bgp, ecom);
+	} else {
+		if (!bgp_evpn_vrf_rt_matches_existing(bgp->vrf_export_rtl,
+						      ecom))
+			return -1;
+
+		bgp_evpn_unconfigure_export_rt_for_vrf(bgp, ecom);
+	}
+
+	return 0;
+}
+
+static int parse_rtlist(struct bgp *bgp, struct vty *vty, int argc,
+			struct cmd_token **argv, int rt_idx, bool is_add,
+			bool is_import)
+{
+	int ret = CMD_SUCCESS;
+	bool is_wildcard = false;
+	struct ecommunity *ecom = NULL;
+
+	for (int i = rt_idx; i < argc; i++) {
+		is_wildcard = false;
+
+		/*
+		 * Special handling for wildcard '*' here.
+		 *
+		 * Let's just convert it to 0 here so we dont have to modify
+		 * the ecommunity parser.
+		 */
+		if ((argv[i]->arg)[0] == '*') {
+			(argv[i]->arg)[0] = '0';
+			is_wildcard = true;
+		}
+
+		ecom = ecommunity_str2com(argv[i]->arg, ECOMMUNITY_ROUTE_TARGET,
+					  0);
+
+		/* Put it back as was */
+		if (is_wildcard)
+			(argv[i]->arg)[0] = '*';
+
+		if (!ecom) {
+			vty_out(vty, "%% Malformed Route Target list\n");
+			ret = CMD_WARNING;
+			continue;
+		}
+
+		ecommunity_str(ecom);
+
+		if (is_add) {
+			if (add_rt(bgp, ecom, is_import, is_wildcard) != 0) {
+				vty_out(vty,
+					"%% RT specified already configured for this VRF: %s\n",
+					argv[i]->arg);
+				ecommunity_free(&ecom);
+				ret = CMD_WARNING;
+			}
+
+		} else {
+			if (del_rt(bgp, ecom, is_import) != 0) {
+				vty_out(vty,
+					"%% RT specified does not match configuration for this VRF: %s\n",
+					argv[i]->arg);
+				ret = CMD_WARNING;
+			}
+
+			ecommunity_free(&ecom);
+		}
+	}
+
+	return ret;
+}
+
 /* import/export rt for l3vni-vrf */
 DEFUN (bgp_evpn_vrf_rt,
        bgp_evpn_vrf_rt_cmd,
-       "route-target <both|import|export> RT",
+       "route-target <both|import|export> RTLIST...",
        "Route Target\n"
        "import and export\n"
        "import\n"
        "export\n"
-       "Route target (A.B.C.D:MN|EF:OPQR|GHJK:MN)\n")
+       "Space separated route target list (A.B.C.D:MN|EF:OPQR|GHJK:MN|*:OPQR|*:MN)\n")
 {
+	int ret = CMD_SUCCESS;
+	int tmp_ret = CMD_SUCCESS;
 	int rt_type;
 	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
-	struct ecommunity *ecomadd = NULL;
 
 	if (!bgp)
-		return CMD_WARNING;
+		return CMD_WARNING_CONFIG_FAILED;
 
 	if (!strcmp(argv[1]->arg, "import"))
 		rt_type = RT_TYPE_IMPORT;
@@ -5810,49 +6574,92 @@ DEFUN (bgp_evpn_vrf_rt,
 		rt_type = RT_TYPE_BOTH;
 	else {
 		vty_out(vty, "%% Invalid Route Target type\n");
-		return CMD_WARNING;
+		return CMD_WARNING_CONFIG_FAILED;
 	}
 
-	ecomadd = ecommunity_str2com(argv[2]->arg, ECOMMUNITY_ROUTE_TARGET, 0);
-	if (!ecomadd) {
-		vty_out(vty, "%% Malformed Route Target list\n");
-		return CMD_WARNING;
+	if (strmatch(argv[2]->arg, "auto")) {
+		vty_out(vty, "%% `auto` cannot be configured via list\n");
+		return CMD_WARNING_CONFIG_FAILED;
 	}
-	ecommunity_str(ecomadd);
 
-	/* Add/update the import route-target */
-	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT) {
-		/* Do nothing if we already have this import route-target */
-		if (!bgp_evpn_rt_matches_existing(bgp->vrf_import_rtl, ecomadd))
-			bgp_evpn_configure_import_rt_for_vrf(bgp, ecomadd);
+	if (rt_type != RT_TYPE_IMPORT) {
+		for (int i = 2; i < argc; i++) {
+			if ((argv[i]->arg)[0] == '*') {
+				vty_out(vty,
+					"%% Wildcard '*' only applicable for import\n");
+				return CMD_WARNING_CONFIG_FAILED;
+			}
+		}
 	}
 
-	/* Add/update the export route-target */
-	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT) {
-		/* Do nothing if we already have this export route-target */
-		if (!bgp_evpn_rt_matches_existing(bgp->vrf_export_rtl, ecomadd))
-			bgp_evpn_configure_export_rt_for_vrf(bgp, ecomadd);
+	/* Add/update the import route-target */
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT)
+		tmp_ret = parse_rtlist(bgp, vty, argc, argv, 2, true, true);
+
+	if (ret == CMD_SUCCESS && tmp_ret != CMD_SUCCESS)
+		ret = tmp_ret;
+
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT)
+		tmp_ret = parse_rtlist(bgp, vty, argc, argv, 2, true, false);
+
+	if (ret == CMD_SUCCESS && tmp_ret != CMD_SUCCESS)
+		ret = tmp_ret;
+
+	return ret;
+}
+
+DEFPY (bgp_evpn_vrf_rt_auto,
+       bgp_evpn_vrf_rt_auto_cmd,
+       "route-target <both|import|export>$type auto",
+       "Route Target\n"
+       "import and export\n"
+       "import\n"
+       "export\n"
+       "Automatically derive route target\n")
+{
+	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
+	int rt_type;
+
+	if (!bgp)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (strmatch(type, "import"))
+		rt_type = RT_TYPE_IMPORT;
+	else if (strmatch(type, "export"))
+		rt_type = RT_TYPE_EXPORT;
+	else if (strmatch(type, "both"))
+		rt_type = RT_TYPE_BOTH;
+	else {
+		vty_out(vty, "%% Invalid Route Target type\n");
+		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT)
+		bgp_evpn_configure_import_auto_rt_for_vrf(bgp);
+
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT)
+		bgp_evpn_configure_export_auto_rt_for_vrf(bgp);
+
 	return CMD_SUCCESS;
 }
 
 DEFUN (no_bgp_evpn_vrf_rt,
        no_bgp_evpn_vrf_rt_cmd,
-       "no route-target <both|import|export> RT",
+       "no route-target <both|import|export> RTLIST...",
        NO_STR
        "Route Target\n"
        "import and export\n"
        "import\n"
        "export\n"
-       EVPN_ASN_IP_HELP_STR)
+       "Space separated route target list (A.B.C.D:MN|EF:OPQR|GHJK:MN)\n")
 {
 	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
-	int rt_type, found_ecomdel;
-	struct ecommunity *ecomdel = NULL;
+	int ret = CMD_SUCCESS;
+	int tmp_ret = CMD_SUCCESS;
+	int rt_type;
 
 	if (!bgp)
-		return CMD_WARNING;
+		return CMD_WARNING_CONFIG_FAILED;
 
 	if (!strcmp(argv[2]->arg, "import"))
 		rt_type = RT_TYPE_IMPORT;
@@ -5862,79 +6669,114 @@ DEFUN (no_bgp_evpn_vrf_rt,
 		rt_type = RT_TYPE_BOTH;
 	else {
 		vty_out(vty, "%% Invalid Route Target type\n");
-		return CMD_WARNING;
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (!strcmp(argv[3]->arg, "auto")) {
+		vty_out(vty, "%% `auto` cannot be unconfigured via list\n");
+		return CMD_WARNING_CONFIG_FAILED;
 	}
 
 	if (rt_type == RT_TYPE_IMPORT) {
 		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_RT_CFGD)) {
 			vty_out(vty,
 				"%% Import RT is not configured for this VRF\n");
-			return CMD_WARNING;
+			return CMD_WARNING_CONFIG_FAILED;
 		}
 	} else if (rt_type == RT_TYPE_EXPORT) {
 		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_RT_CFGD)) {
 			vty_out(vty,
 				"%% Export RT is not configured for this VRF\n");
-			return CMD_WARNING;
+			return CMD_WARNING_CONFIG_FAILED;
 		}
 	} else if (rt_type == RT_TYPE_BOTH) {
 		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_RT_CFGD)
 		    && !CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_RT_CFGD)) {
 			vty_out(vty,
 				"%% Import/Export RT is not configured for this VRF\n");
-			return CMD_WARNING;
+			return CMD_WARNING_CONFIG_FAILED;
 		}
 	}
 
-	ecomdel = ecommunity_str2com(argv[3]->arg, ECOMMUNITY_ROUTE_TARGET, 0);
-	if (!ecomdel) {
-		vty_out(vty, "%% Malformed Route Target list\n");
-		return CMD_WARNING;
+	if (rt_type != RT_TYPE_IMPORT) {
+		for (int i = 3; i < argc; i++) {
+			if ((argv[i]->arg)[0] == '*') {
+				vty_out(vty,
+					"%% Wildcard '*' only applicable for import\n");
+				return CMD_WARNING_CONFIG_FAILED;
+			}
+		}
+	}
+
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT)
+		tmp_ret = parse_rtlist(bgp, vty, argc, argv, 3, false, true);
+
+	if (ret == CMD_SUCCESS && tmp_ret != CMD_SUCCESS)
+		ret = tmp_ret;
+
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT)
+		tmp_ret = parse_rtlist(bgp, vty, argc, argv, 3, false, false);
+
+	if (ret == CMD_SUCCESS && tmp_ret != CMD_SUCCESS)
+		ret = tmp_ret;
+
+	return ret;
+}
+
+DEFPY (no_bgp_evpn_vrf_rt_auto,
+       no_bgp_evpn_vrf_rt_auto_cmd,
+       "no route-target <both|import|export>$type auto",
+       NO_STR
+       "Route Target\n"
+       "import and export\n"
+       "import\n"
+       "export\n"
+       "Automatically derive route target\n")
+{
+	struct bgp *bgp = VTY_GET_CONTEXT(bgp);
+	int rt_type;
+
+	if (!bgp)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (strmatch(type, "import"))
+		rt_type = RT_TYPE_IMPORT;
+	else if (strmatch(type, "export"))
+		rt_type = RT_TYPE_EXPORT;
+	else if (strmatch(type, "both"))
+		rt_type = RT_TYPE_BOTH;
+	else {
+		vty_out(vty, "%% Invalid Route Target type\n");
+		return CMD_WARNING_CONFIG_FAILED;
 	}
-	ecommunity_str(ecomdel);
 
 	if (rt_type == RT_TYPE_IMPORT) {
-		if (!bgp_evpn_rt_matches_existing(bgp->vrf_import_rtl,
-						  ecomdel)) {
-			ecommunity_free(&ecomdel);
+		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD)) {
 			vty_out(vty,
-				"%% RT specified does not match configuration for this VRF\n");
-			return CMD_WARNING;
+				"%% Import AUTO RT is not configured for this VRF\n");
+			return CMD_WARNING_CONFIG_FAILED;
 		}
-		bgp_evpn_unconfigure_import_rt_for_vrf(bgp, ecomdel);
 	} else if (rt_type == RT_TYPE_EXPORT) {
-		if (!bgp_evpn_rt_matches_existing(bgp->vrf_export_rtl,
-						  ecomdel)) {
-			ecommunity_free(&ecomdel);
+		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD)) {
 			vty_out(vty,
-				"%% RT specified does not match configuration for this VRF\n");
-			return CMD_WARNING;
+				"%% Export AUTO RT is not configured for this VRF\n");
+			return CMD_WARNING_CONFIG_FAILED;
 		}
-		bgp_evpn_unconfigure_export_rt_for_vrf(bgp, ecomdel);
 	} else if (rt_type == RT_TYPE_BOTH) {
-		found_ecomdel = 0;
-
-		if (bgp_evpn_rt_matches_existing(bgp->vrf_import_rtl,
-						 ecomdel)) {
-			bgp_evpn_unconfigure_import_rt_for_vrf(bgp, ecomdel);
-			found_ecomdel = 1;
-		}
-
-		if (bgp_evpn_rt_matches_existing(bgp->vrf_export_rtl,
-						 ecomdel)) {
-			bgp_evpn_unconfigure_export_rt_for_vrf(bgp, ecomdel);
-			found_ecomdel = 1;
-		}
-
-		if (!found_ecomdel) {
-			ecommunity_free(&ecomdel);
+		if (!CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD) &&
+		    !CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD)) {
 			vty_out(vty,
-				"%% RT specified does not match configuration for this VRF\n");
-			return CMD_WARNING;
+				"%% Import/Export AUTO RT is not configured for this VRF\n");
+			return CMD_WARNING_CONFIG_FAILED;
 		}
 	}
 
-	ecommunity_free(&ecomdel);
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT)
+		bgp_evpn_unconfigure_import_auto_rt_for_vrf(bgp);
+
+	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT)
+		bgp_evpn_unconfigure_export_auto_rt_for_vrf(bgp);
+
 	return CMD_SUCCESS;
 }
 
@@ -6054,15 +6896,17 @@ DEFUN (bgp_evpn_vni_rt,
 		return CMD_WARNING;
 	}
 
-	ecomadd = ecommunity_str2com(argv[2]->arg, ECOMMUNITY_ROUTE_TARGET, 0);
-	if (!ecomadd) {
-		vty_out(vty, "%% Malformed Route Target list\n");
-		return CMD_WARNING;
-	}
-	ecommunity_str(ecomadd);
-
 	/* Add/update the import route-target */
 	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_IMPORT) {
+		/* Note that first of the two RTs is created for "both" type */
+		ecomadd = ecommunity_str2com(argv[2]->arg,
+					     ECOMMUNITY_ROUTE_TARGET, 0);
+		if (!ecomadd) {
+			vty_out(vty, "%% Malformed Route Target list\n");
+			return CMD_WARNING;
+		}
+		ecommunity_str(ecomadd);
+
 		/* Do nothing if we already have this import route-target */
 		if (!bgp_evpn_rt_matches_existing(vpn->import_rtl, ecomadd))
 			evpn_configure_import_rt(bgp, vpn, ecomadd);
@@ -6070,6 +6914,15 @@ DEFUN (bgp_evpn_vni_rt,
 
 	/* Add/update the export route-target */
 	if (rt_type == RT_TYPE_BOTH || rt_type == RT_TYPE_EXPORT) {
+		/* Note that second of the two RTs is created for "both" type */
+		ecomadd = ecommunity_str2com(argv[2]->arg,
+					     ECOMMUNITY_ROUTE_TARGET, 0);
+		if (!ecomadd) {
+			vty_out(vty, "%% Malformed Route Target list\n");
+			return CMD_WARNING;
+		}
+		ecommunity_str(ecomadd);
+
 		/* Do nothing if we already have this export route-target */
 		if (!bgp_evpn_rt_matches_existing(vpn->export_rtl, ecomadd))
 			evpn_configure_export_rt(bgp, vpn, ecomadd);
@@ -6250,8 +7103,6 @@ static int vni_cmp(const void **a, const
 void bgp_config_write_evpn_info(struct vty *vty, struct bgp *bgp, afi_t afi,
 				safi_t safi)
 {
-	char buf2[INET6_ADDRSTRLEN];
-
 	if (bgp->advertise_all_vni)
 		vty_out(vty, "  advertise-all-vni\n");
 
@@ -6396,10 +7247,8 @@ void bgp_config_write_evpn_info(struct v
 		if (bgp->evpn_info->advertise_pip) {
 			if (bgp->evpn_info->pip_ip_static.s_addr
 			    != INADDR_ANY) {
-				vty_out(vty, "  advertise-pip ip %s",
-					inet_ntop(AF_INET,
-					&bgp->evpn_info->pip_ip_static,
-					buf2, INET_ADDRSTRLEN));
+				vty_out(vty, "  advertise-pip ip %pI4",
+					&bgp->evpn_info->pip_ip_static);
 				if (!is_zero_mac(&(
 					    bgp->evpn_info->pip_rmac_static))) {
 					char buf[ETHER_ADDR_STRLEN];
@@ -6421,31 +7270,66 @@ void bgp_config_write_evpn_info(struct v
 	if (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_RT_CFGD)) {
 		char *ecom_str;
 		struct listnode *node, *nnode;
-		struct ecommunity *ecom;
+		struct vrf_route_target *l3rt;
 
 		for (ALL_LIST_ELEMENTS(bgp->vrf_import_rtl, node, nnode,
-				       ecom)) {
+				       l3rt)) {
+
+			if (CHECK_FLAG(l3rt->flags, BGP_VRF_RT_AUTO))
+				continue;
+
 			ecom_str = ecommunity_ecom2str(
-				ecom, ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
-			vty_out(vty, "  route-target import %s\n", ecom_str);
+				l3rt->ecom, ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+
+			if (CHECK_FLAG(l3rt->flags, BGP_VRF_RT_WILD)) {
+				char *vni_str = NULL;
+
+				vni_str = strchr(ecom_str, ':');
+				if (!vni_str) {
+					XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
+					continue;
+				}
+
+				/* Move pointer to vni */
+				vni_str += 1;
+
+				vty_out(vty, "  route-target import *:%s\n",
+					vni_str);
+
+			} else
+				vty_out(vty, "  route-target import %s\n",
+					ecom_str);
+
 			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
 		}
 	}
 
+	/* import route-target auto */
+	if (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_AUTO_RT_CFGD))
+		vty_out(vty, "  route-target import auto\n");
+
 	/* export route-target */
 	if (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_RT_CFGD)) {
 		char *ecom_str;
 		struct listnode *node, *nnode;
-		struct ecommunity *ecom;
+		struct vrf_route_target *l3rt;
 
 		for (ALL_LIST_ELEMENTS(bgp->vrf_export_rtl, node, nnode,
-				       ecom)) {
+				       l3rt)) {
+
+			if (CHECK_FLAG(l3rt->flags, BGP_VRF_RT_AUTO))
+				continue;
+
 			ecom_str = ecommunity_ecom2str(
-				ecom, ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
+				l3rt->ecom, ECOMMUNITY_FORMAT_ROUTE_MAP, 0);
 			vty_out(vty, "  route-target export %s\n", ecom_str);
 			XFREE(MTYPE_ECOMMUNITY_STR, ecom_str);
 		}
 	}
+
+	/* export route-target auto */
+	if (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_AUTO_RT_CFGD))
+		vty_out(vty, "  route-target export auto\n");
 }
 
 void bgp_ethernetvpn_init(void)
@@ -6519,6 +7403,20 @@ void bgp_ethernetvpn_init(void)
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_import_rt_cmd);
 	install_element(VIEW_NODE, &show_bgp_l2vpn_evpn_vrf_import_rt_cmd);
 
+	/* "show bgp vni" commands. */
+	install_element(VIEW_NODE, &show_bgp_vni_all_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_all_ead_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_all_macip_mac_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_all_macip_ip_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_all_imet_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_ead_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_macip_mac_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_macip_ip_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_imet_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_macip_mac_addr_cmd);
+	install_element(VIEW_NODE, &show_bgp_vni_macip_ip_addr_cmd);
+
 	/* "show bgp evpn" commands. */
 	install_element(VIEW_NODE, &show_bgp_evpn_vni_cmd);
 	install_element(VIEW_NODE, &show_bgp_evpn_summary_cmd);
@@ -6547,6 +7445,8 @@ void bgp_ethernetvpn_init(void)
 	install_element(BGP_NODE, &no_bgp_evpn_vrf_rd_without_val_cmd);
 	install_element(BGP_EVPN_NODE, &bgp_evpn_vrf_rt_cmd);
 	install_element(BGP_EVPN_NODE, &no_bgp_evpn_vrf_rt_cmd);
+	install_element(BGP_EVPN_NODE, &bgp_evpn_vrf_rt_auto_cmd);
+	install_element(BGP_EVPN_NODE, &no_bgp_evpn_vrf_rt_auto_cmd);
 	install_element(BGP_EVPN_NODE, &bgp_evpn_ead_es_rt_cmd);
 	install_element(BGP_EVPN_NODE, &no_bgp_evpn_ead_es_rt_cmd);
 	install_element(BGP_EVPN_NODE, &bgp_evpn_ead_es_frag_evi_limit_cmd);
diff -urpN frr-frr-8.4.2/bgpd/bgp_evpn_vty.h frr-frr-8.5/bgpd/bgp_evpn_vty.h
--- frr-frr-8.4.2/bgpd/bgp_evpn_vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_evpn_vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -27,6 +27,12 @@ extern void bgp_ethernetvpn_init(void);
 
 #define L2VPN_HELP_STR        "Layer 2 Virtual Private Network\n"
 #define EVPN_HELP_STR        "Ethernet Virtual Private Network\n"
+#define VNI_HELP_STR "VXLAN Network Identifier\n"
+#define VNI_NUM_HELP_STR "VNI number\n"
+#define VNI_ALL_HELP_STR "All VNIs\n"
+#define DETAIL_HELP_STR "Print Detailed Output\n"
+#define VTEP_HELP_STR "Remote VTEP\n"
+#define VTEP_IP_HELP_STR "Remote VTEP IP address\n"
 
 extern int argv_find_and_parse_oly_idx(struct cmd_token **argv, int argc,
 				       int *oly_idx,
@@ -36,4 +42,7 @@ extern int argv_find_and_parse_oly_idx(s
 extern int bgp_evpn_cli_parse_type(int *type, struct cmd_token **argv,
 				   int argc);
 
+extern int bgp_evpn_show_all_routes(struct vty *vty, struct bgp *bgp, int type,
+				    bool use_json, int detail);
+
 #endif /* _QUAGGA_BGP_EVPN_VTY_H */
diff -urpN frr-frr-8.4.2/bgpd/bgp_flowspec.c frr-frr-8.5/bgpd/bgp_flowspec.c
--- frr-frr-8.4.2/bgpd/bgp_flowspec.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_flowspec.c	2023-03-13 20:01:47.000000000 +0600
@@ -103,7 +103,6 @@ int bgp_nlri_parse_flowspec(struct peer
 	safi_t safi;
 	int psize = 0;
 	struct prefix p;
-	int ret;
 	void *temp;
 
 	/* Start processing the NLRI - there may be multiple in the MP_REACH */
@@ -141,6 +140,13 @@ int bgp_nlri_parse_flowspec(struct peer
 				psize);
 			return BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;
 		}
+
+		if (psize == 0) {
+			flog_err(EC_BGP_FLOWSPEC_PACKET,
+				 "Flowspec NLRI length 0 which makes no sense");
+			return BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;
+		}
+
 		if (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {
 			flog_err(
 				EC_BGP_FLOWSPEC_PACKET,
@@ -190,21 +196,13 @@ int bgp_nlri_parse_flowspec(struct peer
 		}
 		/* Process the route. */
 		if (!withdraw)
-			ret = bgp_update(peer, &p, 0, attr,
-					 afi, safi,
-					 ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-					 NULL, NULL, 0, 0, NULL);
+			bgp_update(peer, &p, 0, attr, afi, safi,
+				   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,
+				   NULL, 0, 0, NULL);
 		else
-			ret = bgp_withdraw(peer, &p, 0, attr,
-					   afi, safi,
-					   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-					   NULL, NULL, 0, NULL);
-		if (ret) {
-			flog_err(EC_BGP_FLOWSPEC_INSTALLATION,
-				 "Flowspec NLRI failed to be %s.",
-				 attr ? "added" : "withdrawn");
-			return BGP_NLRI_PARSE_ERROR;
-		}
+			bgp_withdraw(peer, &p, 0, attr, afi, safi,
+				     ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,
+				     NULL, 0, NULL);
 	}
 	return BGP_NLRI_PARSE_OK;
 }
diff -urpN frr-frr-8.4.2/bgpd/bgp_flowspec_vty.c frr-frr-8.5/bgpd/bgp_flowspec_vty.c
--- frr-frr-8.4.2/bgpd/bgp_flowspec_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_flowspec_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -338,18 +338,14 @@ void route_vty_out_flowspec(struct vty *
 			local_buff[0] = '\0';
 			if (p->u.prefix_flowspec.family == AF_INET
 			    && attr->nexthop.s_addr != INADDR_ANY)
-				inet_ntop(AF_INET,
-					  &attr->nexthop.s_addr,
-					  local_buff,
-					  INET6_ADDRSTRLEN);
+				inet_ntop(AF_INET, &attr->nexthop.s_addr,
+					  local_buff, sizeof(local_buff));
 			else if (p->u.prefix_flowspec.family == AF_INET6 &&
 				 attr->mp_nexthop_len != 0 &&
 				 attr->mp_nexthop_len != BGP_ATTR_NHLEN_IPV4 &&
 				 attr->mp_nexthop_len != BGP_ATTR_NHLEN_VPNV4)
-				inet_ntop(AF_INET6,
-					  &attr->mp_nexthop_global,
-					  local_buff,
-					  INET6_ADDRSTRLEN);
+				inet_ntop(AF_INET6, &attr->mp_nexthop_global,
+					  local_buff, sizeof(local_buff));
 			if (local_buff[0] != '\0')
 				vty_out(vty, "\tNLRI NH %s\n",
 					local_buff);
diff -urpN frr-frr-8.4.2/bgpd/bgp_fsm.c frr-frr-8.5/bgpd/bgp_fsm.c
--- frr-frr-8.4.2/bgpd/bgp_fsm.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_fsm.c	2023-03-13 20:01:47.000000000 +0600
@@ -61,6 +61,13 @@
 DEFINE_HOOK(peer_backward_transition, (struct peer * peer), (peer));
 DEFINE_HOOK(peer_status_changed, (struct peer * peer), (peer));
 
+enum bgp_fsm_state_progress {
+	BGP_FSM_FAILURE_AND_DELETE = -2,
+	BGP_FSM_FAILURE = -1,
+	BGP_FSM_SUCCESS = 0,
+	BGP_FSM_SUCCESS_STATE_TRANSFER = 1,
+};
+
 /* Definition of display strings corresponding to FSM events. This should be
  * kept consistent with the events defined in bgpd.h
  */
@@ -99,7 +106,7 @@ static void bgp_holdtime_timer(struct th
 static void bgp_delayopen_timer(struct thread *);
 
 /* BGP FSM functions. */
-static int bgp_start(struct peer *);
+static enum bgp_fsm_state_progress bgp_start(struct peer *);
 
 /* Register peer with NHT */
 int bgp_peer_reg_with_nht(struct peer *peer)
@@ -272,22 +279,20 @@ static struct peer *peer_xfer_conn(struc
 		}
 	}
 
+	if (peer->hostname) {
+		XFREE(MTYPE_BGP_PEER_HOST, peer->hostname);
+		peer->hostname = NULL;
+	}
 	if (from_peer->hostname != NULL) {
-		if (peer->hostname) {
-			XFREE(MTYPE_BGP_PEER_HOST, peer->hostname);
-			peer->hostname = NULL;
-		}
-
 		peer->hostname = from_peer->hostname;
 		from_peer->hostname = NULL;
 	}
 
+	if (peer->domainname) {
+		XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);
+		peer->domainname = NULL;
+	}
 	if (from_peer->domainname != NULL) {
-		if (peer->domainname) {
-			XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);
-			peer->domainname = NULL;
-		}
-
 		peer->domainname = from_peer->domainname;
 		from_peer->domainname = NULL;
 	}
@@ -601,40 +606,41 @@ void bgp_delayopen_timer(struct thread *
 
 /* BGP Peer Down Cause */
 const char *const peer_down_str[] = {"",
-			       "Router ID changed",
-			       "Remote AS changed",
-			       "Local AS change",
-			       "Cluster ID changed",
-			       "Confederation identifier changed",
-			       "Confederation peer changed",
-			       "RR client config change",
-			       "RS client config change",
-			       "Update source change",
-			       "Address family activated",
-			       "Admin. shutdown",
-			       "User reset",
-			       "BGP Notification received",
-			       "BGP Notification send",
-			       "Peer closed the session",
-			       "Neighbor deleted",
-			       "Peer-group add member",
-			       "Peer-group delete member",
-			       "Capability changed",
-			       "Passive config change",
-			       "Multihop config change",
-			       "NSF peer closed the session",
-			       "Intf peering v6only config change",
-			       "BFD down received",
-			       "Interface down",
-			       "Neighbor address lost",
-			       "Waiting for NHT",
-			       "Waiting for Peer IPv6 LLA",
-			       "Waiting for VRF to be initialized",
-			       "No AFI/SAFI activated for peer",
-			       "AS Set config change",
-			       "Waiting for peer OPEN",
-			       "Reached received prefix count",
-			       "Socket Error"};
+				     "Router ID changed",
+				     "Remote AS changed",
+				     "Local AS change",
+				     "Cluster ID changed",
+				     "Confederation identifier changed",
+				     "Confederation peer changed",
+				     "RR client config change",
+				     "RS client config change",
+				     "Update source change",
+				     "Address family activated",
+				     "Admin. shutdown",
+				     "User reset",
+				     "BGP Notification received",
+				     "BGP Notification send",
+				     "Peer closed the session",
+				     "Neighbor deleted",
+				     "Peer-group add member",
+				     "Peer-group delete member",
+				     "Capability changed",
+				     "Passive config change",
+				     "Multihop config change",
+				     "NSF peer closed the session",
+				     "Intf peering v6only config change",
+				     "BFD down received",
+				     "Interface down",
+				     "Neighbor address lost",
+				     "No path to specified Neighbor",
+				     "Waiting for Peer IPv6 LLA",
+				     "Waiting for VRF to be initialized",
+				     "No AFI/SAFI activated for peer",
+				     "AS Set config change",
+				     "Waiting for peer OPEN",
+				     "Reached received prefix count",
+				     "Socket Error",
+				     "Admin. shutdown (RTT)"};
 
 static void bgp_graceful_restart_timer_off(struct peer *peer)
 {
@@ -1237,7 +1243,7 @@ static void bgp_update_delay_process_sta
 
 /* Called after event occurred, this function change status and reset
    read/write and timer thread. */
-void bgp_fsm_change_status(struct peer *peer, int status)
+void bgp_fsm_change_status(struct peer *peer, enum bgp_fsm_status status)
 {
 	struct bgp *bgp;
 	uint32_t peer_count;
@@ -1292,7 +1298,8 @@ void bgp_fsm_change_status(struct peer *
 		 * Clearing
 		 * (or Deleted).
 		 */
-		if (!work_queue_is_scheduled(peer->clear_node_queue))
+		if (!work_queue_is_scheduled(peer->clear_node_queue) &&
+		    status != Deleted)
 			BGP_EVENT_ADD(peer, Clearing_Completed);
 	}
 
@@ -1304,7 +1311,7 @@ void bgp_fsm_change_status(struct peer *
 	peer->rtt_keepalive_rcv = 0;
 
 	/* Fire backward transition hook if that's the case */
-	if (peer->ostatus > peer->status)
+	if (peer->ostatus == Established && peer->status != Established)
 		hook_call(peer_backward_transition, peer);
 
 	/* Save event that caused status change. */
@@ -1331,17 +1338,17 @@ void bgp_fsm_change_status(struct peer *
 		bgp_update_delay_process_status_change(peer);
 
 	if (bgp_debug_neighbor_events(peer))
-		zlog_debug("%s went from %s to %s", peer->host,
+		zlog_debug("%s fd %d went from %s to %s", peer->host, peer->fd,
 			   lookup_msg(bgp_status_msg, peer->ostatus, NULL),
 			   lookup_msg(bgp_status_msg, peer->status, NULL));
 }
 
 /* Flush the event queue and ensure the peer is shut down */
-static int bgp_clearing_completed(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_clearing_completed(struct peer *peer)
 {
-	int rc = bgp_stop(peer);
+	enum bgp_fsm_state_progress rc = bgp_stop(peer);
 
-	if (rc >= 0)
+	if (rc >= BGP_FSM_SUCCESS)
 		BGP_EVENT_FLUSH(peer);
 
 	return rc;
@@ -1349,12 +1356,12 @@ static int bgp_clearing_completed(struct
 
 /* Administrative BGP peer stop event. */
 /* May be called multiple times for the same peer */
-int bgp_stop(struct peer *peer)
+enum bgp_fsm_state_progress bgp_stop(struct peer *peer)
 {
 	afi_t afi;
 	safi_t safi;
 	char orf_name[BUFSIZ];
-	int ret = 0;
+	enum bgp_fsm_state_progress ret = BGP_FSM_SUCCESS;
 	struct bgp *bgp = peer->bgp;
 	struct graceful_restart_info *gr_info = NULL;
 
@@ -1371,7 +1378,7 @@ int bgp_stop(struct peer *peer)
 			zlog_debug("%s (dynamic neighbor) deleted (%s)",
 				   peer->host, __func__);
 		peer_delete(peer);
-		return -1;
+		return BGP_FSM_FAILURE_AND_DELETE;
 	}
 
 	/* Can't do this in Clearing; events are used for state transitions */
@@ -1580,7 +1587,7 @@ int bgp_stop(struct peer *peer)
 	if (!CHECK_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE)
 	    && !(CHECK_FLAG(peer->flags, PEER_FLAG_DELETE))) {
 		peer_delete(peer);
-		ret = -1;
+		ret = BGP_FSM_FAILURE_AND_DELETE;
 	} else {
 		bgp_peer_conf_if_to_su_update(peer);
 	}
@@ -1588,7 +1595,7 @@ int bgp_stop(struct peer *peer)
 }
 
 /* BGP peer is stoped by the error. */
-static int bgp_stop_with_error(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_stop_with_error(struct peer *peer)
 {
 	/* Double start timer. */
 	peer->v_start *= 2;
@@ -1602,16 +1609,16 @@ static int bgp_stop_with_error(struct pe
 			zlog_debug("%s (dynamic neighbor) deleted (%s)",
 				   peer->host, __func__);
 		peer_delete(peer);
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
-	return (bgp_stop(peer));
+	return bgp_stop(peer);
 }
 
 
 /* something went wrong, send notify and tear down */
-static int bgp_stop_with_notify(struct peer *peer, uint8_t code,
-				uint8_t sub_code)
+static enum bgp_fsm_state_progress
+bgp_stop_with_notify(struct peer *peer, uint8_t code, uint8_t sub_code)
 {
 	/* Send notify to remote peer */
 	bgp_notify_send(peer, code, sub_code);
@@ -1621,13 +1628,13 @@ static int bgp_stop_with_notify(struct p
 			zlog_debug("%s (dynamic neighbor) deleted (%s)",
 				   peer->host, __func__);
 		peer_delete(peer);
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	/* Clear start timer value to default. */
 	peer->v_start = BGP_INIT_START_TIMER;
 
-	return (bgp_stop(peer));
+	return bgp_stop(peer);
 }
 
 /**
@@ -1692,13 +1699,12 @@ static void bgp_connect_check(struct thr
 
 /* TCP connection open.  Next we send open message to remote peer. And
    add read thread for reading open message. */
-static int bgp_connect_success(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_connect_success(struct peer *peer)
 {
 	if (peer->fd < 0) {
 		flog_err(EC_BGP_CONNECT, "%s peer's fd is negative value %d",
 			 __func__, peer->fd);
-		bgp_stop(peer);
-		return -1;
+		return bgp_stop(peer);
 	}
 
 	if (bgp_getsockname(peer) < 0) {
@@ -1708,7 +1714,7 @@ static int bgp_connect_success(struct pe
 		bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,
 				bgp_fsm_error_subcode(peer->status));
 		bgp_writes_on(peer);
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	/*
@@ -1730,19 +1736,19 @@ static int bgp_connect_success(struct pe
 	/* Send an open message */
 	bgp_open_send(peer);
 
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* TCP connection open with RFC 4271 optional session attribute DelayOpen flag
  * set.
  */
-static int bgp_connect_success_w_delayopen(struct peer *peer)
+static enum bgp_fsm_state_progress
+bgp_connect_success_w_delayopen(struct peer *peer)
 {
 	if (peer->fd < 0) {
 		flog_err(EC_BGP_CONNECT, "%s: peer's fd is negative value %d",
 			 __func__, peer->fd);
-		bgp_stop(peer);
-		return -1;
+		return bgp_stop(peer);
 	}
 
 	if (bgp_getsockname(peer) < 0) {
@@ -1752,7 +1758,7 @@ static int bgp_connect_success_w_delayop
 		bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,
 				bgp_fsm_error_subcode(peer->status));
 		bgp_writes_on(peer);
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	/*
@@ -1783,18 +1789,18 @@ static int bgp_connect_success_w_delayop
 		zlog_debug("%s [FSM] BGP OPEN message delayed for %d seconds",
 			   peer->host, peer->delayopen);
 
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* TCP connect fail */
-static int bgp_connect_fail(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_connect_fail(struct peer *peer)
 {
 	if (peer_dynamic_neighbor_no_nsf(peer)) {
 		if (bgp_debug_neighbor_events(peer))
 			zlog_debug("%s (dynamic neighbor) deleted (%s)",
 				   peer->host, __func__);
 		peer_delete(peer);
-		return -1;
+		return BGP_FSM_FAILURE_AND_DELETE;
 	}
 
 	/*
@@ -1803,13 +1809,13 @@ static int bgp_connect_fail(struct peer
 	 */
 	bgp_nht_interface_events(peer);
 
-	return (bgp_stop(peer));
+	return bgp_stop(peer);
 }
 
 /* This function is the first starting point of all BGP connection. It
  * try to connect to remote peer with non-blocking IO.
  */
-int bgp_start(struct peer *peer)
+enum bgp_fsm_state_progress bgp_start(struct peer *peer)
 {
 	int status;
 
@@ -1821,7 +1827,7 @@ int bgp_start(struct peer *peer)
 				"%s [FSM] Unable to get neighbor's IP address, waiting...",
 				peer->host);
 		peer->last_reset = PEER_DOWN_NBR_ADDR;
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	if (BGP_PEER_START_SUPPRESSED(peer)) {
@@ -1829,13 +1835,15 @@ int bgp_start(struct peer *peer)
 			flog_err(EC_BGP_FSM,
 				 "%s [FSM] Trying to start suppressed peer - this is never supposed to happen!",
 				 peer->host);
-		if (CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN))
+		if (CHECK_FLAG(peer->sflags, PEER_STATUS_RTT_SHUTDOWN))
+			peer->last_reset = PEER_DOWN_RTT_SHUTDOWN;
+		else if (CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN))
 			peer->last_reset = PEER_DOWN_USER_SHUTDOWN;
 		else if (CHECK_FLAG(peer->bgp->flags, BGP_FLAG_SHUTDOWN))
 			peer->last_reset = PEER_DOWN_USER_SHUTDOWN;
 		else if (CHECK_FLAG(peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))
 			peer->last_reset = PEER_DOWN_PFX_COUNT;
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	/* Scrub some information that might be left over from a previous,
@@ -1861,7 +1869,7 @@ int bgp_start(struct peer *peer)
 	/* If the peer is passive mode, force to move to Active mode. */
 	if (CHECK_FLAG(peer->flags, PEER_FLAG_PASSIVE)) {
 		BGP_EVENT_ADD(peer, TCP_connection_open_failed);
-		return 0;
+		return BGP_FSM_SUCCESS;
 	}
 
 	if (peer->bgp->vrf_id == VRF_UNKNOWN) {
@@ -1871,7 +1879,7 @@ int bgp_start(struct peer *peer)
 				"%s [FSM] In a VRF that is not initialised yet",
 				peer->host);
 		peer->last_reset = PEER_DOWN_VRF_UNINIT;
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	/* Register peer for NHT. If next hop is already resolved, proceed
@@ -1880,11 +1888,12 @@ int bgp_start(struct peer *peer)
 	if (!bgp_peer_reg_with_nht(peer)) {
 		if (bgp_zebra_num_connects()) {
 			if (bgp_debug_neighbor_events(peer))
-				zlog_debug("%s [FSM] Waiting for NHT",
-					   peer->host);
+				zlog_debug(
+					"%s [FSM] Waiting for NHT, no path to neighbor present",
+					peer->host);
 			peer->last_reset = PEER_DOWN_WAITING_NHT;
 			BGP_EVENT_ADD(peer, TCP_connection_open_failed);
-			return 0;
+			return BGP_FSM_SUCCESS;
 		}
 	}
 
@@ -1919,7 +1928,7 @@ int bgp_start(struct peer *peer)
 			flog_err(EC_BGP_FSM,
 				 "%s peer's fd is negative value %d", __func__,
 				 peer->fd);
-			return -1;
+			return BGP_FSM_FAILURE;
 		}
 		/*
 		 * - when the socket becomes ready, poll() will signify POLLOUT
@@ -1936,24 +1945,26 @@ int bgp_start(struct peer *peer)
 				 &peer->t_connect_check_w);
 		break;
 	}
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* Connect retry timer is expired when the peer status is Connect. */
-static int bgp_reconnect(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_reconnect(struct peer *peer)
 {
-	if (bgp_stop(peer) < 0)
-		return -1;
+	enum bgp_fsm_state_progress ret;
+
+	ret = bgp_stop(peer);
+	if (ret < BGP_FSM_SUCCESS)
+		return ret;
 
 	/* Send graceful restart capabilty */
 	BGP_GR_ROUTER_DETECT_AND_SEND_CAPABILITY_TO_ZEBRA(peer->bgp,
 							  peer->bgp->peer);
 
-	bgp_start(peer);
-	return 0;
+	return bgp_start(peer);
 }
 
-static int bgp_fsm_open(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_open(struct peer *peer)
 {
 	/* If DelayOpen is active, we may still need to send an open message */
 	if ((peer->status == Connect) || (peer->status == Active))
@@ -1962,12 +1973,12 @@ static int bgp_fsm_open(struct peer *pee
 	/* Send keepalive and make keepalive timer */
 	bgp_keepalive_send(peer);
 
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* FSM error, unexpected event.  This is error of BGP connection. So cut the
    peer and change to Idle status. */
-static int bgp_fsm_event_error(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_event_error(struct peer *peer)
 {
 	flog_err(EC_BGP_FSM, "%s [FSM] unexpected packet received in state %s",
 		 peer->host, lookup_msg(bgp_status_msg, peer->status, NULL));
@@ -1978,7 +1989,7 @@ static int bgp_fsm_event_error(struct pe
 
 /* Hold timer expire.  This is error of BGP connection. So cut the
    peer and change to Idle status. */
-static int bgp_fsm_holdtime_expire(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_holdtime_expire(struct peer *peer)
 {
 	if (bgp_debug_neighbor_events(peer))
 		zlog_debug("%s [FSM] Hold timer expire", peer->host);
@@ -1996,7 +2007,8 @@ static int bgp_fsm_holdtime_expire(struc
 }
 
 /* RFC 4271 DelayOpenTimer_Expires event */
-static int bgp_fsm_delayopen_timer_expire(struct peer *peer)
+static enum bgp_fsm_state_progress
+bgp_fsm_delayopen_timer_expire(struct peer *peer)
 {
 	/* Stop the DelayOpenTimer */
 	THREAD_OFF(peer->t_delayopen);
@@ -2007,7 +2019,7 @@ static int bgp_fsm_delayopen_timer_expir
 	/* Set the HoldTimer to a large value (4 minutes) */
 	peer->v_holdtime = 245;
 
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* Start the selection deferral timer thread for the specified AFI, SAFI */
@@ -2088,25 +2100,28 @@ static int bgp_update_gr_info(struct pee
  * Convert peer from stub to full fledged peer, set some timers, and generate
  * initial updates.
  */
-static int bgp_establish(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_establish(struct peer *peer)
 {
 	afi_t afi;
 	safi_t safi;
 	int nsf_af_count = 0;
-	int ret = 0;
+	enum bgp_fsm_state_progress ret = BGP_FSM_SUCCESS;
 	struct peer *other;
 	int status;
 
 	other = peer->doppelganger;
+	hash_release(peer->bgp->peerhash, peer);
+	if (other)
+		hash_release(peer->bgp->peerhash, other);
+
 	peer = peer_xfer_conn(peer);
 	if (!peer) {
 		flog_err(EC_BGP_CONNECT, "%%Neighbor failed in xfer_conn");
-		return -1;
+		return BGP_FSM_FAILURE;
 	}
 
 	if (other == peer)
-		ret = 1; /* bgp_establish specific code when xfer_conn
-			    happens. */
+		ret = BGP_FSM_SUCCESS_STATE_TRANSFER;
 
 	/* Reset capability open status flag. */
 	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_CAPABILITY_OPEN))
@@ -2302,7 +2317,6 @@ static int bgp_establish(struct peer *pe
 	 * the doppelgangers su and this peer's su are the same
 	 * so the hash_release is the same for either.
 	 */
-	hash_release(peer->bgp->peerhash, peer);
 	(void)hash_get(peer->bgp->peerhash, peer, hash_alloc_intern);
 
 	/* Start BFD peer if not already running. */
@@ -2313,21 +2327,21 @@ static int bgp_establish(struct peer *pe
 }
 
 /* Keepalive packet is received. */
-static int bgp_fsm_keepalive(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_keepalive(struct peer *peer)
 {
 	THREAD_OFF(peer->t_holdtime);
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* Update packet is received. */
-static int bgp_fsm_update(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_update(struct peer *peer)
 {
 	THREAD_OFF(peer->t_holdtime);
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* This is empty event. */
-static int bgp_ignore(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_ignore(struct peer *peer)
 {
 	flog_err(
 		EC_BGP_FSM,
@@ -2336,11 +2350,11 @@ static int bgp_ignore(struct peer *peer)
 		lookup_msg(bgp_status_msg, peer->status, NULL),
 		bgp_event_str[peer->last_event],
 		bgp_event_str[peer->last_major_event], peer->fd);
-	return 0;
+	return BGP_FSM_SUCCESS;
 }
 
 /* This is to handle unexpected events.. */
-static int bgp_fsm_exeption(struct peer *peer)
+static enum bgp_fsm_state_progress bgp_fsm_exception(struct peer *peer)
 {
 	flog_err(
 		EC_BGP_FSM,
@@ -2349,7 +2363,7 @@ static int bgp_fsm_exeption(struct peer
 		lookup_msg(bgp_status_msg, peer->status, NULL),
 		bgp_event_str[peer->last_event],
 		bgp_event_str[peer->last_major_event], peer->fd);
-	return (bgp_stop(peer));
+	return bgp_stop(peer);
 }
 
 void bgp_fsm_nht_update(struct peer *peer, bool has_valid_nexthops)
@@ -2390,7 +2404,7 @@ void bgp_fsm_nht_update(struct peer *pee
 
 /* Finite State Machine structure */
 static const struct {
-	int (*func)(struct peer *);
+	enum bgp_fsm_state_progress (*func)(struct peer *);
 	enum bgp_fsm_status next_state;
 } FSM[BGP_STATUS_MAX - 1][BGP_EVENTS_MAX - 1] = {
 	{
@@ -2421,19 +2435,19 @@ static const struct {
 		{bgp_connect_success, OpenSent}, /* TCP_connection_open */
 		{bgp_connect_success_w_delayopen,
 		 Connect},		    /* TCP_connection_open_w_delay */
-		{bgp_stop, Idle},	   /* TCP_connection_closed        */
+		{bgp_stop, Idle},	    /* TCP_connection_closed        */
 		{bgp_connect_fail, Active}, /* TCP_connection_open_failed   */
 		{bgp_connect_fail, Idle},   /* TCP_fatal_error              */
 		{bgp_reconnect, Connect},   /* ConnectRetry_timer_expired   */
-		{bgp_fsm_exeption, Idle},   /* Hold_Timer_expired           */
-		{bgp_fsm_exeption, Idle},   /* KeepAlive_timer_expired      */
+		{bgp_fsm_exception, Idle},  /* Hold_Timer_expired           */
+		{bgp_fsm_exception, Idle},  /* KeepAlive_timer_expired      */
 		{bgp_fsm_delayopen_timer_expire,
 		 OpenSent},		     /* DelayOpen_timer_expired */
 		{bgp_fsm_open, OpenConfirm}, /* Receive_OPEN_message         */
-		{bgp_fsm_exeption, Idle},    /* Receive_KEEPALIVE_message    */
-		{bgp_fsm_exeption, Idle},    /* Receive_UPDATE_message       */
-		{bgp_stop, Idle},	    /* Receive_NOTIFICATION_message */
-		{bgp_fsm_exeption, Idle},    /* Clearing_Completed           */
+		{bgp_fsm_exception, Idle},   /* Receive_KEEPALIVE_message    */
+		{bgp_fsm_exception, Idle},   /* Receive_UPDATE_message       */
+		{bgp_stop, Idle},	     /* Receive_NOTIFICATION_message */
+		{bgp_fsm_exception, Idle},   /* Clearing_Completed           */
 	},
 	{
 		/* Active, */
@@ -2441,97 +2455,97 @@ static const struct {
 		{bgp_stop, Idle},     /* BGP_Stop                     */
 		{bgp_connect_success, OpenSent}, /* TCP_connection_open */
 		{bgp_connect_success_w_delayopen,
-		 Active},		  /* TCP_connection_open_w_delay */
-		{bgp_stop, Idle},	 /* TCP_connection_closed        */
-		{bgp_ignore, Active},     /* TCP_connection_open_failed   */
-		{bgp_fsm_exeption, Idle}, /* TCP_fatal_error              */
-		{bgp_start, Connect},     /* ConnectRetry_timer_expired   */
-		{bgp_fsm_exeption, Idle}, /* Hold_Timer_expired           */
-		{bgp_fsm_exeption, Idle}, /* KeepAlive_timer_expired      */
+		 Active},		   /* TCP_connection_open_w_delay */
+		{bgp_stop, Idle},	   /* TCP_connection_closed        */
+		{bgp_ignore, Active},	   /* TCP_connection_open_failed   */
+		{bgp_fsm_exception, Idle}, /* TCP_fatal_error              */
+		{bgp_start, Connect},	   /* ConnectRetry_timer_expired   */
+		{bgp_fsm_exception, Idle}, /* Hold_Timer_expired           */
+		{bgp_fsm_exception, Idle}, /* KeepAlive_timer_expired      */
 		{bgp_fsm_delayopen_timer_expire,
 		 OpenSent},		     /* DelayOpen_timer_expired */
 		{bgp_fsm_open, OpenConfirm}, /* Receive_OPEN_message         */
-		{bgp_fsm_exeption, Idle},    /* Receive_KEEPALIVE_message    */
-		{bgp_fsm_exeption, Idle},    /* Receive_UPDATE_message       */
-		{bgp_fsm_exeption, Idle},    /* Receive_NOTIFICATION_message */
-		{bgp_fsm_exeption, Idle},    /* Clearing_Completed           */
+		{bgp_fsm_exception, Idle},   /* Receive_KEEPALIVE_message    */
+		{bgp_fsm_exception, Idle},   /* Receive_UPDATE_message       */
+		{bgp_fsm_exception, Idle},   /* Receive_NOTIFICATION_message */
+		{bgp_fsm_exception, Idle},   /* Clearing_Completed           */
 	},
 	{
 		/* OpenSent, */
-		{bgp_ignore, OpenSent},   /* BGP_Start                    */
-		{bgp_stop, Idle},	 /* BGP_Stop                     */
-		{bgp_stop, Active},       /* TCP_connection_open          */
-		{bgp_fsm_exeption, Idle}, /* TCP_connection_open_w_delay */
-		{bgp_stop, Active},       /* TCP_connection_closed        */
-		{bgp_stop, Active},       /* TCP_connection_open_failed   */
-		{bgp_stop, Active},       /* TCP_fatal_error              */
-		{bgp_fsm_exeption, Idle}, /* ConnectRetry_timer_expired   */
+		{bgp_ignore, OpenSent},	   /* BGP_Start                    */
+		{bgp_stop, Idle},	   /* BGP_Stop                     */
+		{bgp_stop, Active},	   /* TCP_connection_open          */
+		{bgp_fsm_exception, Idle}, /* TCP_connection_open_w_delay */
+		{bgp_stop, Active},	   /* TCP_connection_closed        */
+		{bgp_stop, Active},	   /* TCP_connection_open_failed   */
+		{bgp_stop, Active},	   /* TCP_fatal_error              */
+		{bgp_fsm_exception, Idle}, /* ConnectRetry_timer_expired   */
 		{bgp_fsm_holdtime_expire, Idle}, /* Hold_Timer_expired */
-		{bgp_fsm_exeption, Idle},    /* KeepAlive_timer_expired      */
-		{bgp_fsm_exeption, Idle},    /* DelayOpen_timer_expired */
+		{bgp_fsm_exception, Idle},   /* KeepAlive_timer_expired      */
+		{bgp_fsm_exception, Idle},   /* DelayOpen_timer_expired */
 		{bgp_fsm_open, OpenConfirm}, /* Receive_OPEN_message         */
 		{bgp_fsm_event_error, Idle}, /* Receive_KEEPALIVE_message    */
 		{bgp_fsm_event_error, Idle}, /* Receive_UPDATE_message       */
 		{bgp_fsm_event_error, Idle}, /* Receive_NOTIFICATION_message */
-		{bgp_fsm_exeption, Idle},    /* Clearing_Completed           */
+		{bgp_fsm_exception, Idle},   /* Clearing_Completed           */
 	},
 	{
 		/* OpenConfirm, */
 		{bgp_ignore, OpenConfirm}, /* BGP_Start                    */
-		{bgp_stop, Idle},	  /* BGP_Stop                     */
-		{bgp_stop, Idle},	  /* TCP_connection_open          */
-		{bgp_fsm_exeption, Idle},  /* TCP_connection_open_w_delay */
-		{bgp_stop, Idle},	  /* TCP_connection_closed        */
-		{bgp_stop, Idle},	  /* TCP_connection_open_failed   */
-		{bgp_stop, Idle},	  /* TCP_fatal_error              */
-		{bgp_fsm_exeption, Idle},  /* ConnectRetry_timer_expired   */
+		{bgp_stop, Idle},	   /* BGP_Stop                     */
+		{bgp_stop, Idle},	   /* TCP_connection_open          */
+		{bgp_fsm_exception, Idle}, /* TCP_connection_open_w_delay */
+		{bgp_stop, Idle},	   /* TCP_connection_closed        */
+		{bgp_stop, Idle},	   /* TCP_connection_open_failed   */
+		{bgp_stop, Idle},	   /* TCP_fatal_error              */
+		{bgp_fsm_exception, Idle}, /* ConnectRetry_timer_expired   */
 		{bgp_fsm_holdtime_expire, Idle}, /* Hold_Timer_expired */
 		{bgp_ignore, OpenConfirm},    /* KeepAlive_timer_expired      */
-		{bgp_fsm_exeption, Idle},     /* DelayOpen_timer_expired */
-		{bgp_fsm_exeption, Idle},     /* Receive_OPEN_message         */
+		{bgp_fsm_exception, Idle},    /* DelayOpen_timer_expired */
+		{bgp_fsm_exception, Idle},    /* Receive_OPEN_message         */
 		{bgp_establish, Established}, /* Receive_KEEPALIVE_message    */
-		{bgp_fsm_exeption, Idle},     /* Receive_UPDATE_message       */
+		{bgp_fsm_exception, Idle},    /* Receive_UPDATE_message       */
 		{bgp_stop_with_error, Idle},  /* Receive_NOTIFICATION_message */
-		{bgp_fsm_exeption, Idle},     /* Clearing_Completed           */
+		{bgp_fsm_exception, Idle},    /* Clearing_Completed           */
 	},
 	{
 		/* Established, */
 		{bgp_ignore, Established}, /* BGP_Start                    */
-		{bgp_stop, Clearing},      /* BGP_Stop                     */
-		{bgp_stop, Clearing},      /* TCP_connection_open          */
-		{bgp_fsm_exeption, Idle},  /* TCP_connection_open_w_delay */
-		{bgp_stop, Clearing},      /* TCP_connection_closed        */
-		{bgp_stop, Clearing},      /* TCP_connection_open_failed   */
-		{bgp_stop, Clearing},      /* TCP_fatal_error              */
-		{bgp_stop, Clearing},      /* ConnectRetry_timer_expired   */
+		{bgp_stop, Clearing},	   /* BGP_Stop                     */
+		{bgp_stop, Clearing},	   /* TCP_connection_open          */
+		{bgp_fsm_exception, Idle}, /* TCP_connection_open_w_delay */
+		{bgp_stop, Clearing},	   /* TCP_connection_closed        */
+		{bgp_stop, Clearing},	   /* TCP_connection_open_failed   */
+		{bgp_stop, Clearing},	   /* TCP_fatal_error              */
+		{bgp_stop, Clearing},	   /* ConnectRetry_timer_expired   */
 		{bgp_fsm_holdtime_expire, Clearing}, /* Hold_Timer_expired */
 		{bgp_ignore, Established}, /* KeepAlive_timer_expired      */
-		{bgp_fsm_exeption, Idle},  /* DelayOpen_timer_expired */
-		{bgp_stop, Clearing},      /* Receive_OPEN_message         */
+		{bgp_fsm_exception, Idle}, /* DelayOpen_timer_expired */
+		{bgp_stop, Clearing},	   /* Receive_OPEN_message         */
 		{bgp_fsm_keepalive,
 		 Established}, /* Receive_KEEPALIVE_message    */
 		{bgp_fsm_update, Established}, /* Receive_UPDATE_message */
 		{bgp_stop_with_error,
-		 Clearing},		  /* Receive_NOTIFICATION_message */
-		{bgp_fsm_exeption, Idle}, /* Clearing_Completed           */
+		 Clearing},		   /* Receive_NOTIFICATION_message */
+		{bgp_fsm_exception, Idle}, /* Clearing_Completed           */
 	},
 	{
 		/* Clearing, */
 		{bgp_ignore, Clearing}, /* BGP_Start                    */
-		{bgp_stop, Clearing},   /* BGP_Stop                     */
-		{bgp_stop, Clearing},   /* TCP_connection_open          */
-		{bgp_stop, Clearing},   /* TCP_connection_open_w_delay */
-		{bgp_stop, Clearing},   /* TCP_connection_closed        */
-		{bgp_stop, Clearing},   /* TCP_connection_open_failed   */
-		{bgp_stop, Clearing},   /* TCP_fatal_error              */
-		{bgp_stop, Clearing},   /* ConnectRetry_timer_expired   */
-		{bgp_stop, Clearing},   /* Hold_Timer_expired           */
-		{bgp_stop, Clearing},   /* KeepAlive_timer_expired      */
-		{bgp_stop, Clearing},   /* DelayOpen_timer_expired */
-		{bgp_stop, Clearing},   /* Receive_OPEN_message         */
-		{bgp_stop, Clearing},   /* Receive_KEEPALIVE_message    */
-		{bgp_stop, Clearing},   /* Receive_UPDATE_message       */
-		{bgp_stop, Clearing},   /* Receive_NOTIFICATION_message */
+		{bgp_stop, Clearing},	/* BGP_Stop                     */
+		{bgp_stop, Clearing},	/* TCP_connection_open          */
+		{bgp_stop, Clearing},	/* TCP_connection_open_w_delay */
+		{bgp_stop, Clearing},	/* TCP_connection_closed        */
+		{bgp_stop, Clearing},	/* TCP_connection_open_failed   */
+		{bgp_stop, Clearing},	/* TCP_fatal_error              */
+		{bgp_stop, Clearing},	/* ConnectRetry_timer_expired   */
+		{bgp_stop, Clearing},	/* Hold_Timer_expired           */
+		{bgp_stop, Clearing},	/* KeepAlive_timer_expired      */
+		{bgp_stop, Clearing},	/* DelayOpen_timer_expired */
+		{bgp_stop, Clearing},	/* Receive_OPEN_message         */
+		{bgp_stop, Clearing},	/* Receive_KEEPALIVE_message    */
+		{bgp_stop, Clearing},	/* Receive_UPDATE_message       */
+		{bgp_stop, Clearing},	/* Receive_NOTIFICATION_message */
 		{bgp_clearing_completed, Idle}, /* Clearing_Completed */
 	},
 	{
@@ -2564,13 +2578,15 @@ void bgp_event(struct thread *thread)
 	peer = THREAD_ARG(thread);
 	event = THREAD_VAL(thread);
 
+	peer_lock(peer);
 	bgp_event_update(peer, event);
+	peer_unlock(peer);
 }
 
 int bgp_event_update(struct peer *peer, enum bgp_fsm_events event)
 {
 	enum bgp_fsm_status next;
-	int ret = 0;
+	enum bgp_fsm_state_progress ret = 0;
 	struct peer *other;
 	int passive_conn = 0;
 	int dyn_nbr;
@@ -2599,8 +2615,9 @@ int bgp_event_update(struct peer *peer,
 	if (FSM[peer->status - 1][event - 1].func)
 		ret = (*(FSM[peer->status - 1][event - 1].func))(peer);
 
-	if (ret >= 0) {
-		if (ret == 1 && next == Established) {
+	if (ret >= BGP_FSM_SUCCESS) {
+		if (ret == BGP_FSM_SUCCESS_STATE_TRANSFER &&
+		    next == Established) {
 			/* The case when doppelganger swap accurred in
 			   bgp_establish.
 			   Update the peer pointer accordingly */
@@ -2634,7 +2651,8 @@ int bgp_event_update(struct peer *peer,
 		 * we need to indicate that the peer was stopped in the return
 		 * code.
 		 */
-		if (!dyn_nbr && !passive_conn && peer->bgp) {
+		if (!dyn_nbr && !passive_conn && peer->bgp &&
+		    ret != BGP_FSM_FAILURE_AND_DELETE) {
 			flog_err(
 				EC_BGP_FSM,
 				"%s [FSM] Failure handling event %s in state %s, prior events %s, %s, fd %d",
diff -urpN frr-frr-8.4.2/bgpd/bgp_fsm.h frr-frr-8.5/bgpd/bgp_fsm.h
--- frr-frr-8.4.2/bgpd/bgp_fsm.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_fsm.h	2023-03-13 20:01:47.000000000 +0600
@@ -125,7 +125,8 @@ extern int bgp_event_update(struct peer
 extern int bgp_stop(struct peer *peer);
 extern void bgp_timer_set(struct peer *);
 extern void bgp_routeadv_timer(struct thread *);
-extern void bgp_fsm_change_status(struct peer *peer, int status);
+extern void bgp_fsm_change_status(struct peer *peer,
+				  enum bgp_fsm_status status);
 extern const char *const peer_down_str[];
 extern void bgp_update_delay_end(struct bgp *);
 extern void bgp_maxmed_update(struct bgp *);
diff -urpN frr-frr-8.4.2/bgpd/bgp_io.c frr-frr-8.5/bgpd/bgp_io.c
--- frr-frr-8.4.2/bgpd/bgp_io.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_io.c	2023-03-13 20:01:47.000000000 +0600
@@ -50,8 +50,9 @@ static void bgp_process_reads(struct thr
 static bool validate_header(struct peer *);
 
 /* generic i/o status codes */
-#define BGP_IO_TRANS_ERR (1 << 0) // EAGAIN or similar occurred
-#define BGP_IO_FATAL_ERR (1 << 1) // some kind of fatal TCP error
+#define BGP_IO_TRANS_ERR (1 << 0) /* EAGAIN or similar occurred */
+#define BGP_IO_FATAL_ERR (1 << 1) /* some kind of fatal TCP error */
+#define BGP_IO_WORK_FULL_ERR (1 << 2) /* No room in work buffer */
 
 /* Thread external API ----------------------------------------------------- */
 
@@ -163,6 +164,59 @@ static void bgp_process_writes(struct th
 	}
 }
 
+static int read_ibuf_work(struct peer *peer)
+{
+	/* static buffer for transferring packets */
+	/* shorter alias to peer's input buffer */
+	struct ringbuf *ibw = peer->ibuf_work;
+	/* packet size as given by header */
+	uint16_t pktsize = 0;
+	struct stream *pkt;
+
+	/* ============================================== */
+	frr_with_mutex (&peer->io_mtx) {
+		if (peer->ibuf->count >= bm->inq_limit)
+			return -ENOMEM;
+	}
+
+	/* check that we have enough data for a header */
+	if (ringbuf_remain(ibw) < BGP_HEADER_SIZE)
+		return 0;
+
+	/* check that header is valid */
+	if (!validate_header(peer))
+		return -EBADMSG;
+
+	/* header is valid; retrieve packet size */
+	ringbuf_peek(ibw, BGP_MARKER_SIZE, &pktsize, sizeof(pktsize));
+
+	pktsize = ntohs(pktsize);
+
+	/* if this fails we are seriously screwed */
+	assert(pktsize <= peer->max_packet_size);
+
+	/*
+	 * If we have that much data, chuck it into its own
+	 * stream and append to input queue for processing.
+	 *
+	 * Otherwise, come back later.
+	 */
+	if (ringbuf_remain(ibw) < pktsize)
+		return 0;
+
+	pkt = stream_new(pktsize);
+	assert(STREAM_WRITEABLE(pkt) == pktsize);
+	assert(ringbuf_get(ibw, pkt->data, pktsize) == pktsize);
+	stream_set_endp(pkt, pktsize);
+
+	frrtrace(2, frr_bgp, packet_read, peer, pkt);
+	frr_with_mutex (&peer->io_mtx) {
+		stream_fifo_push(peer->ibuf, pkt);
+	}
+
+	return pktsize;
+}
+
 /*
  * Called from I/O pthread when a file descriptor has become ready for reading,
  * or has hung up.
@@ -173,12 +227,14 @@ static void bgp_process_writes(struct th
 static void bgp_process_reads(struct thread *thread)
 {
 	/* clang-format off */
-	static struct peer *peer;	// peer to read from
-	uint16_t status;		// bgp_read status code
-	bool more = true;		// whether we got more data
-	bool fatal = false;		// whether fatal error occurred
-	bool added_pkt = false;		// whether we pushed onto ->ibuf
-	int code = 0;			// FSM code if error occurred
+	static struct peer *peer;       /* peer to read from */
+	uint16_t status;                /* bgp_read status code */
+	bool fatal = false;             /* whether fatal error occurred */
+	bool added_pkt = false;         /* whether we pushed onto ->ibuf */
+	int code = 0;                   /* FSM code if error occurred */
+	bool ibuf_full = false;         /* Is peer fifo IN Buffer full */
+	static bool ibuf_full_logged;   /* Have we logged full already */
+	int ret = 1;
 	/* clang-format on */
 
 	peer = THREAD_ARG(thread);
@@ -195,12 +251,11 @@ static void bgp_process_reads(struct thr
 	/* error checking phase */
 	if (CHECK_FLAG(status, BGP_IO_TRANS_ERR)) {
 		/* no problem; just don't process packets */
-		more = false;
+		goto done;
 	}
 
 	if (CHECK_FLAG(status, BGP_IO_FATAL_ERR)) {
 		/* problem; tear down session */
-		more = false;
 		fatal = true;
 
 		/* Handle the error in the main pthread, include the
@@ -208,67 +263,54 @@ static void bgp_process_reads(struct thr
 		 */
 		thread_add_event(bm->master, bgp_packet_process_error,
 				 peer, code, &peer->t_process_packet_error);
+		goto done;
 	}
 
-	while (more) {
-		/* static buffer for transferring packets */
-		/* shorter alias to peer's input buffer */
-		struct ringbuf *ibw = peer->ibuf_work;
-		/* packet size as given by header */
-		uint16_t pktsize = 0;
-
-		/* check that we have enough data for a header */
-		if (ringbuf_remain(ibw) < BGP_HEADER_SIZE)
+	while (true) {
+		ret = read_ibuf_work(peer);
+		if (ret <= 0)
 			break;
 
-		/* check that header is valid */
-		if (!validate_header(peer)) {
-			fatal = true;
-			break;
-		}
-
-		/* header is valid; retrieve packet size */
-		ringbuf_peek(ibw, BGP_MARKER_SIZE, &pktsize, sizeof(pktsize));
-
-		pktsize = ntohs(pktsize);
-
-		/* if this fails we are seriously screwed */
-		assert(pktsize <= peer->max_packet_size);
-
-		/*
-		 * If we have that much data, chuck it into its own
-		 * stream and append to input queue for processing.
-		 */
-		if (ringbuf_remain(ibw) >= pktsize) {
-			struct stream *pkt = stream_new(pktsize);
+		added_pkt = true;
+	}
 
-			assert(STREAM_WRITEABLE(pkt) == pktsize);
-			assert(ringbuf_get(ibw, pkt->data, pktsize) == pktsize);
-			stream_set_endp(pkt, pktsize);
-
-			frrtrace(2, frr_bgp, packet_read, peer, pkt);
-			frr_with_mutex (&peer->io_mtx) {
-				stream_fifo_push(peer->ibuf, pkt);
-			}
+	switch (ret) {
+	case -EBADMSG:
+		fatal = true;
+		break;
+	case -ENOMEM:
+		ibuf_full = true;
+		if (!ibuf_full_logged) {
+			if (bgp_debug_neighbor_events(peer))
+				zlog_debug(
+					"%s [Event] Peer Input-Queue is full: limit (%u)",
+					peer->host, bm->inq_limit);
 
-			added_pkt = true;
-		} else
-			break;
+			ibuf_full_logged = true;
+		}
+		break;
+	default:
+		ibuf_full_logged = false;
+		break;
 	}
 
+done:
 	/* handle invalid header */
 	if (fatal) {
 		/* wipe buffer just in case someone screwed up */
 		ringbuf_wipe(peer->ibuf_work);
-	} else {
+		return;
+	}
+
+	/* ringbuf should be fully drained unless ibuf is full */
+	if (!ibuf_full)
 		assert(ringbuf_space(peer->ibuf_work) >= peer->max_packet_size);
 
-		thread_add_read(fpt->master, bgp_process_reads, peer, peer->fd,
-				&peer->t_read);
-		if (added_pkt)
-			thread_add_event(bm->master, bgp_process_packet,
-					 peer, 0, &peer->t_process_packet);
-	}
+	thread_add_read(fpt->master, bgp_process_reads, peer, peer->fd,
+			&peer->t_read);
+	if (added_pkt)
+		thread_add_event(bm->master, bgp_process_packet, peer, 0,
+				 &peer->t_process_packet);
 }
 
 /*
@@ -462,12 +504,20 @@ done : {
  */
 static uint16_t bgp_read(struct peer *peer, int *code_p)
 {
-	size_t readsize; // how many bytes we want to read
-	ssize_t nbytes;  // how many bytes we actually read
+	size_t readsize; /* how many bytes we want to read */
+	ssize_t nbytes;  /* how many bytes we actually read */
+	size_t ibuf_work_space; /* space we can read into the work buf */
 	uint16_t status = 0;
 
-	readsize =
-		MIN(ringbuf_space(peer->ibuf_work), sizeof(peer->ibuf_scratch));
+	ibuf_work_space = ringbuf_space(peer->ibuf_work);
+
+	if (ibuf_work_space == 0) {
+		SET_FLAG(status, BGP_IO_WORK_FULL_ERR);
+		return status;
+	}
+
+	readsize = MIN(ibuf_work_space, sizeof(peer->ibuf_scratch));
+
 	nbytes = read(peer->fd, peer->ibuf_scratch, readsize);
 
 	/* EAGAIN or EWOULDBLOCK; come back later */
diff -urpN frr-frr-8.4.2/bgpd/bgp_keepalives.c frr-frr-8.5/bgpd/bgp_keepalives.c
--- frr-frr-8.4.2/bgpd/bgp_keepalives.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_keepalives.c	2023-03-13 20:01:47.000000000 +0600
@@ -36,6 +36,10 @@
 #include "bgpd/bgp_keepalives.h"
 /* clang-format on */
 
+DEFINE_MTYPE_STATIC(BGPD, BGP_PKAT, "Peer KeepAlive Timer");
+DEFINE_MTYPE_STATIC(BGPD, BGP_COND, "BGP Peer pthread Conditional");
+DEFINE_MTYPE_STATIC(BGPD, BGP_MUTEX, "BGP Peer pthread Mutex");
+
 /*
  * Peer KeepAlive Timer.
  * Associates a peer with the time of its last keepalive.
@@ -54,7 +58,7 @@ static struct hash *peerhash;
 
 static struct pkat *pkat_new(struct peer *peer)
 {
-	struct pkat *pkat = XMALLOC(MTYPE_TMP, sizeof(struct pkat));
+	struct pkat *pkat = XMALLOC(MTYPE_BGP_PKAT, sizeof(struct pkat));
 	pkat->peer = peer;
 	monotime(&pkat->last);
 	return pkat;
@@ -62,7 +66,7 @@ static struct pkat *pkat_new(struct peer
 
 static void pkat_del(void *pkat)
 {
-	XFREE(MTYPE_TMP, pkat);
+	XFREE(MTYPE_BGP_PKAT, pkat);
 }
 
 
@@ -115,7 +119,7 @@ static void peer_process(struct hash_buc
 		elapsed.tv_sec >= ka.tv_sec || timercmp(&diff, &tolerance, <);
 
 	if (send_keepalive) {
-		if (bgp_debug_neighbor_events(pkat->peer))
+		if (bgp_debug_keepalive(pkat->peer))
 			zlog_debug("%s [FSM] Timer (keepalive timer expire)",
 				   pkat->peer->host);
 
@@ -158,8 +162,8 @@ static void bgp_keepalives_finish(void *
 	pthread_mutex_destroy(peerhash_mtx);
 	pthread_cond_destroy(peerhash_cond);
 
-	XFREE(MTYPE_TMP, peerhash_mtx);
-	XFREE(MTYPE_TMP, peerhash_cond);
+	XFREE(MTYPE_BGP_MUTEX, peerhash_mtx);
+	XFREE(MTYPE_BGP_COND, peerhash_cond);
 }
 
 /*
@@ -184,8 +188,8 @@ void *bgp_keepalives_start(void *arg)
 	 */
 	rcu_read_unlock();
 
-	peerhash_mtx = XCALLOC(MTYPE_TMP, sizeof(pthread_mutex_t));
-	peerhash_cond = XCALLOC(MTYPE_TMP, sizeof(pthread_cond_t));
+	peerhash_mtx = XCALLOC(MTYPE_BGP_MUTEX, sizeof(pthread_mutex_t));
+	peerhash_cond = XCALLOC(MTYPE_BGP_COND, sizeof(pthread_cond_t));
 
 	/* initialize mutex */
 	pthread_mutex_init(peerhash_mtx, NULL);
@@ -269,8 +273,9 @@ void bgp_keepalives_on(struct peer *peer
 			peer_lock(peer);
 		}
 		SET_FLAG(peer->thread_flags, PEER_THREAD_KEEPALIVES_ON);
+		/* Force the keepalive thread to wake up */
+		pthread_cond_signal(peerhash_cond);
 	}
-	bgp_keepalives_wake();
 }
 
 void bgp_keepalives_off(struct peer *peer)
@@ -300,19 +305,15 @@ void bgp_keepalives_off(struct peer *pee
 	}
 }
 
-void bgp_keepalives_wake(void)
-{
-	frr_with_mutex (peerhash_mtx) {
-		pthread_cond_signal(peerhash_cond);
-	}
-}
-
 int bgp_keepalives_stop(struct frr_pthread *fpt, void **result)
 {
 	assert(fpt->running);
 
-	atomic_store_explicit(&fpt->running, false, memory_order_relaxed);
-	bgp_keepalives_wake();
+	frr_with_mutex (peerhash_mtx) {
+		atomic_store_explicit(&fpt->running, false,
+				      memory_order_relaxed);
+		pthread_cond_signal(peerhash_cond);
+	}
 
 	pthread_join(fpt->thread, result);
 	return 0;
diff -urpN frr-frr-8.4.2/bgpd/bgp_keepalives.h frr-frr-8.5/bgpd/bgp_keepalives.h
--- frr-frr-8.4.2/bgpd/bgp_keepalives.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_keepalives.h	2023-03-13 20:01:47.000000000 +0600
@@ -74,18 +74,6 @@ extern void bgp_keepalives_init(void);
 extern void *bgp_keepalives_start(void *arg);
 
 /**
- * Poking function for keepalives pthread.
- *
- * Under normal circumstances the pthread will automatically wake itself
- * whenever it is necessary to do work. This function may be used to force the
- * thread to wake up and see if there is any work to do, or if it is time to
- * die.
- *
- * It is not necessary to call this after bgp_keepalives_on().
- */
-extern void bgp_keepalives_wake(void);
-
-/**
  * Stops the thread and blocks until it terminates.
  */
 int bgp_keepalives_stop(struct frr_pthread *fpt, void **result);
diff -urpN frr-frr-8.4.2/bgpd/bgp_label.c frr-frr-8.5/bgpd/bgp_label.c
--- frr-frr-8.4.2/bgpd/bgp_label.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_label.c	2023-03-13 20:01:47.000000000 +0600
@@ -312,6 +312,9 @@ static int bgp_nlri_get_labels(struct pe
 	uint8_t llen = 0;
 	uint8_t label_depth = 0;
 
+	if (plen < BGP_LABEL_BYTES)
+		return 0;
+
 	for (; data < lim; data += BGP_LABEL_BYTES) {
 		memcpy(label, data, BGP_LABEL_BYTES);
 		llen += BGP_LABEL_BYTES;
@@ -374,6 +377,9 @@ int bgp_nlri_parse_label(struct peer *pe
 			memcpy(&addpath_id, pnt, BGP_ADDPATH_ID_LEN);
 			addpath_id = ntohl(addpath_id);
 			pnt += BGP_ADDPATH_ID_LEN;
+
+			if (pnt >= lim)
+				return BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;
 		}
 
 		/* Fetch prefix length. */
@@ -392,6 +398,15 @@ int bgp_nlri_parse_label(struct peer *pe
 
 		/* Fill in the labels */
 		llen = bgp_nlri_get_labels(peer, pnt, psize, &label);
+		if (llen == 0) {
+			flog_err(
+				EC_BGP_UPDATE_RCV,
+				"%s [Error] Update packet error (wrong label length 0)",
+				peer->host);
+			bgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,
+					BGP_NOTIFY_UPDATE_INVAL_NETWORK);
+			return BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;
+		}
 		p.prefixlen = prefixlen - BSIZE(llen);
 
 		/* There needs to be at least one label */
diff -urpN frr-frr-8.4.2/bgpd/bgp_labelpool.c frr-frr-8.5/bgpd/bgp_labelpool.c
--- frr-frr-8.4.2/bgpd/bgp_labelpool.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_labelpool.c	2023-03-13 20:01:47.000000000 +0600
@@ -39,9 +39,7 @@
 
 #define BGP_LABELPOOL_ENABLE_TESTS 0
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_labelpool_clippy.c"
-#endif
 
 
 /*
@@ -745,22 +743,12 @@ DEFUN(show_bgp_labelpool_summary, show_b
 
 	if (uj) {
 		json = json_object_new_object();
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
-		json_object_int_add(json, "Ledger", skiplist_count(lp->ledger));
 		json_object_int_add(json, "ledger", skiplist_count(lp->ledger));
-		json_object_int_add(json, "InUse", skiplist_count(lp->inuse));
 		json_object_int_add(json, "inUse", skiplist_count(lp->inuse));
-		json_object_int_add(json, "Requests",
-				    lp_fifo_count(&lp->requests));
 		json_object_int_add(json, "requests",
 				    lp_fifo_count(&lp->requests));
-		json_object_int_add(json, "LabelChunks", listcount(lp->chunks));
 		json_object_int_add(json, "labelChunks", listcount(lp->chunks));
-		json_object_int_add(json, "Pending", lp->pending_count);
 		json_object_int_add(json, "pending", lp->pending_count);
-		json_object_int_add(json, "Reconnects", lp->reconnect_count);
 		json_object_int_add(json, "reconnects", lp->reconnect_count);
 		vty_json(vty, json);
 	} else {
diff -urpN frr-frr-8.4.2/bgpd/bgp_mac.c frr-frr-8.5/bgpd/bgp_mac.c
--- frr-frr-8.4.2/bgpd/bgp_mac.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_mac.c	2023-03-13 20:01:47.000000000 +0600
@@ -211,16 +211,10 @@ static void bgp_process_mac_rescan_table
 
 			memcpy(&evpn, bgp_attr_get_evpn_overlay(pi->attr),
 			       sizeof(evpn));
-			int32_t ret = bgp_update(peer, p,
-						 pi->addpath_rx_id,
-						 pi->attr, AFI_L2VPN, SAFI_EVPN,
-						 ZEBRA_ROUTE_BGP,
-						 BGP_ROUTE_NORMAL, &prd,
-						 label_pnt, num_labels,
-						 1, evpn);
-
-			if (ret < 0)
-				bgp_dest_unlock_node(dest);
+			bgp_update(peer, p, pi->addpath_rx_id, pi->attr,
+				   AFI_L2VPN, SAFI_EVPN, ZEBRA_ROUTE_BGP,
+				   BGP_ROUTE_NORMAL, &prd, label_pnt,
+				   num_labels, 1, evpn);
 		}
 	}
 }
@@ -242,19 +236,18 @@ static void bgp_mac_rescan_evpn_table(st
 		if (!peer_established(peer))
 			continue;
 
-		if (CHECK_FLAG(peer->af_flags[afi][safi],
-			       PEER_FLAG_SOFT_RECONFIG)) {
-			if (bgp_debug_update(peer, NULL, NULL, 1))
-				zlog_debug("Processing EVPN MAC interface change on peer %s (inbound, soft-reconfig)",
-					   peer->host);
+		if (bgp_debug_update(peer, NULL, NULL, 1))
+			zlog_debug(
+				"Processing EVPN MAC interface change on peer %s %s",
+				peer->host,
+				CHECK_FLAG(peer->af_flags[afi][safi],
+					   PEER_FLAG_SOFT_RECONFIG)
+					? "(inbound, soft-reconfig)"
+					: "");
 
-			bgp_soft_reconfig_in(peer, afi, safi);
-		} else {
+		if (!bgp_soft_reconfig_in(peer, afi, safi)) {
 			struct bgp_table *table = bgp->rib[afi][safi];
 
-			if (bgp_debug_update(peer, NULL, NULL, 1))
-				zlog_debug("Processing EVPN MAC interface change on peer %s",
-					   peer->host);
 			bgp_process_mac_rescan_table(bgp, peer, table, macaddr);
 		}
 	}
diff -urpN frr-frr-8.4.2/bgpd/bgp_mpath.c frr-frr-8.5/bgpd/bgp_mpath.c
--- frr-frr-8.4.2/bgpd/bgp_mpath.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_mpath.c	2023-03-13 20:01:47.000000000 +0600
@@ -278,8 +278,10 @@ void bgp_mp_list_add(struct list *mp_lis
 static struct bgp_path_info_mpath *bgp_path_info_mpath_new(void)
 {
 	struct bgp_path_info_mpath *new_mpath;
+
 	new_mpath = XCALLOC(MTYPE_BGP_MPATH_INFO,
 			    sizeof(struct bgp_path_info_mpath));
+
 	return new_mpath;
 }
 
@@ -313,8 +315,6 @@ bgp_path_info_mpath_get(struct bgp_path_
 
 	if (!path->mpath) {
 		mpath = bgp_path_info_mpath_new();
-		if (!mpath)
-			return NULL;
 		path->mpath = mpath;
 		mpath->mp_info = path;
 	}
@@ -567,7 +567,7 @@ void bgp_path_info_mpath_update(struct b
 
 	if (debug)
 		zlog_debug(
-			"%pRN(%s): starting mpath update, newbest %s num candidates %d old-mpath-count %d old-cum-bw u%" PRIu64,
+			"%pRN(%s): starting mpath update, newbest %s num candidates %d old-mpath-count %d old-cum-bw %" PRIu64,
 			bgp_dest_to_rnode(dest), bgp->name_pretty,
 			new_best ? new_best->peer->host : "NONE",
 			mp_list ? listcount(mp_list) : 0, old_mpath_count,
@@ -750,7 +750,7 @@ void bgp_path_info_mpath_update(struct b
 
 		if (debug)
 			zlog_debug(
-				"%pRN(%s): New mpath count (incl newbest) %d mpath-change %s all_paths_lb %d cum_bw u%" PRIu64,
+				"%pRN(%s): New mpath count (incl newbest) %d mpath-change %s all_paths_lb %d cum_bw %" PRIu64,
 				bgp_dest_to_rnode(dest), bgp->name_pretty,
 				mpath_count, mpath_changed ? "YES" : "NO",
 				all_paths_lb, cum_bw);
diff -urpN frr-frr-8.4.2/bgpd/bgp_mplsvpn.c frr-frr-8.5/bgpd/bgp_mplsvpn.c
--- frr-frr-8.4.2/bgpd/bgp_mplsvpn.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_mplsvpn.c	2023-03-13 20:01:47.000000000 +0600
@@ -42,6 +42,7 @@
 #include "bgpd/bgp_packet.h"
 #include "bgpd/bgp_vty.h"
 #include "bgpd/bgp_vpn.h"
+#include "bgpd/bgp_community.h"
 #include "bgpd/bgp_ecommunity.h"
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_nexthop.h"
@@ -359,7 +360,7 @@ void vpn_leak_zebra_vrf_label_withdraw(s
  * leaked to VPN. Zebra should install this srv6-function in the kernel with
  * an action of "End.DT4/6's IP FIB to route the PDU."
  */
-void vpn_leak_zebra_vrf_sid_update(struct bgp *bgp, afi_t afi)
+void vpn_leak_zebra_vrf_sid_update_per_af(struct bgp *bgp, afi_t afi)
 {
 	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
 	enum seg6local_action_t act;
@@ -367,7 +368,6 @@ void vpn_leak_zebra_vrf_sid_update(struc
 	struct in6_addr *tovpn_sid = NULL;
 	struct in6_addr *tovpn_sid_ls = NULL;
 	struct vrf *vrf;
-	char buf[256] = {0};
 
 	if (bgp->vrf_id == VRF_UNKNOWN) {
 		if (debug)
@@ -384,12 +384,10 @@ void vpn_leak_zebra_vrf_sid_update(struc
 		return;
 	}
 
-	if (debug) {
-		inet_ntop(AF_INET6, tovpn_sid, buf, sizeof(buf));
-		zlog_debug("%s: vrf %s: afi %s: setting sid %s for vrf id %d",
-			   __func__, bgp->name_pretty, afi2str(afi), buf,
+	if (debug)
+		zlog_debug("%s: vrf %s: afi %s: setting sid %pI6 for vrf id %d",
+			   __func__, bgp->name_pretty, afi2str(afi), tovpn_sid,
 			   bgp->vrf_id);
-	}
 
 	vrf = vrf_lookup_by_id(bgp->vrf_id);
 	if (!vrf)
@@ -406,10 +404,77 @@ void vpn_leak_zebra_vrf_sid_update(struc
 }
 
 /*
+ * This function informs zebra of the srv6-function this vrf sets on routes
+ * leaked to VPN. Zebra should install this srv6-function in the kernel with
+ * an action of "End.DT46's IP FIB to route the PDU."
+ */
+void vpn_leak_zebra_vrf_sid_update_per_vrf(struct bgp *bgp)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
+	enum seg6local_action_t act;
+	struct seg6local_context ctx = {};
+	struct in6_addr *tovpn_sid = NULL;
+	struct in6_addr *tovpn_sid_ls = NULL;
+	struct vrf *vrf;
+
+	if (bgp->vrf_id == VRF_UNKNOWN) {
+		if (debug)
+			zlog_debug(
+				"%s: vrf %s: vrf_id not set, can't set zebra vrf label",
+				__func__, bgp->name_pretty);
+		return;
+	}
+
+	tovpn_sid = bgp->tovpn_sid;
+	if (!tovpn_sid) {
+		if (debug)
+			zlog_debug("%s: vrf %s: sid not set", __func__,
+				   bgp->name_pretty);
+		return;
+	}
+
+	if (debug)
+		zlog_debug("%s: vrf %s: setting sid %pI6 for vrf id %d",
+			   __func__, bgp->name_pretty, tovpn_sid, bgp->vrf_id);
+
+	vrf = vrf_lookup_by_id(bgp->vrf_id);
+	if (!vrf)
+		return;
+
+	ctx.table = vrf->data.l.table_id;
+	act = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+	zclient_send_localsid(zclient, tovpn_sid, bgp->vrf_id, act, &ctx);
+
+	tovpn_sid_ls = XCALLOC(MTYPE_BGP_SRV6_SID, sizeof(struct in6_addr));
+	*tovpn_sid_ls = *tovpn_sid;
+	bgp->tovpn_zebra_vrf_sid_last_sent = tovpn_sid_ls;
+}
+
+/*
+ * This function informs zebra of the srv6-function this vrf sets on routes
+ * leaked to VPN. Zebra should install this srv6-function in the kernel with
+ * an action of "End.DT4/6/46's IP FIB to route the PDU."
+ */
+void vpn_leak_zebra_vrf_sid_update(struct bgp *bgp, afi_t afi)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
+
+	if (bgp->vpn_policy[afi].tovpn_sid)
+		return vpn_leak_zebra_vrf_sid_update_per_af(bgp, afi);
+
+	if (bgp->tovpn_sid)
+		return vpn_leak_zebra_vrf_sid_update_per_vrf(bgp);
+
+	if (debug)
+		zlog_debug("%s: vrf %s: afi %s: sid not set", __func__,
+			   bgp->name_pretty, afi2str(afi));
+}
+
+/*
  * If zebra tells us vrf has become unconfigured, tell zebra not to
  * use this srv6-function to forward to the vrf anymore
  */
-void vpn_leak_zebra_vrf_sid_withdraw(struct bgp *bgp, afi_t afi)
+void vpn_leak_zebra_vrf_sid_withdraw_per_af(struct bgp *bgp, afi_t afi)
 {
 	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
 
@@ -431,6 +496,45 @@ void vpn_leak_zebra_vrf_sid_withdraw(str
 	      bgp->vpn_policy[afi].tovpn_zebra_vrf_sid_last_sent);
 }
 
+/*
+ * If zebra tells us vrf has become unconfigured, tell zebra not to
+ * use this srv6-function to forward to the vrf anymore
+ */
+void vpn_leak_zebra_vrf_sid_withdraw_per_vrf(struct bgp *bgp)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
+
+	if (bgp->vrf_id == VRF_UNKNOWN) {
+		if (debug)
+			zlog_debug(
+				"%s: vrf %s: vrf_id not set, can't set zebra vrf label",
+				__func__, bgp->name_pretty);
+		return;
+	}
+
+	if (debug)
+		zlog_debug("%s: deleting sid for vrf %s (id=%d)", __func__,
+			   bgp->name_pretty, bgp->vrf_id);
+
+	zclient_send_localsid(zclient, bgp->tovpn_zebra_vrf_sid_last_sent,
+			      bgp->vrf_id, ZEBRA_SEG6_LOCAL_ACTION_UNSPEC,
+			      NULL);
+	XFREE(MTYPE_BGP_SRV6_SID, bgp->tovpn_zebra_vrf_sid_last_sent);
+}
+
+/*
+ * If zebra tells us vrf has become unconfigured, tell zebra not to
+ * use this srv6-function to forward to the vrf anymore
+ */
+void vpn_leak_zebra_vrf_sid_withdraw(struct bgp *bgp, afi_t afi)
+{
+	if (bgp->vpn_policy[afi].tovpn_zebra_vrf_sid_last_sent)
+		vpn_leak_zebra_vrf_sid_withdraw_per_af(bgp, afi);
+
+	if (bgp->tovpn_zebra_vrf_sid_last_sent)
+		vpn_leak_zebra_vrf_sid_withdraw_per_vrf(bgp);
+}
+
 int vpn_leak_label_callback(
 	mpls_label_t label,
 	void *labelid,
@@ -504,6 +608,18 @@ static void sid_register(struct bgp *bgp
 	listnode_add(bgp->srv6_functions, func);
 }
 
+static void sid_unregister(struct bgp *bgp, const struct in6_addr *sid)
+{
+	struct listnode *node, *nnode;
+	struct bgp_srv6_function *func;
+
+	for (ALL_LIST_ELEMENTS(bgp->srv6_functions, node, nnode, func))
+		if (sid_same(&func->sid, sid)) {
+			listnode_delete(bgp->srv6_functions, func);
+			XFREE(MTYPE_BGP_SRV6_FUNCTION, func);
+		}
+}
+
 static bool sid_exist(struct bgp *bgp, const struct in6_addr *sid)
 {
 	struct listnode *node;
@@ -524,37 +640,77 @@ static bool sid_exist(struct bgp *bgp, c
  * else: try to allocate as auto-mode
  */
 static uint32_t alloc_new_sid(struct bgp *bgp, uint32_t index,
-			      struct in6_addr *sid_locator,
+			      struct srv6_locator_chunk *sid_locator_chunk,
 			      struct in6_addr *sid)
 {
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_LABEL);
 	struct listnode *node;
 	struct srv6_locator_chunk *chunk;
 	bool alloced = false;
 	int label = 0;
 	uint8_t offset = 0;
-	uint8_t len = 0;
+	uint8_t func_len = 0, shift_len = 0;
+	uint32_t index_max = 0;
 
-	if (!bgp || !sid_locator || !sid)
+	if (!bgp || !sid_locator_chunk || !sid)
 		return false;
 
 	for (ALL_LIST_ELEMENTS_RO(bgp->srv6_locator_chunks, node, chunk)) {
-		*sid_locator = chunk->prefix.prefix;
+		if (chunk->function_bits_length >
+		    BGP_PREFIX_SID_SRV6_MAX_FUNCTION_LENGTH) {
+			if (debug)
+				zlog_debug(
+					"%s: invalid SRv6 Locator chunk (%pFX): Function Length must be less or equal to %d",
+					__func__, &chunk->prefix,
+					BGP_PREFIX_SID_SRV6_MAX_FUNCTION_LENGTH);
+			continue;
+		}
+
+		index_max = (1 << chunk->function_bits_length) - 1;
+
+		if (index > index_max) {
+			if (debug)
+				zlog_debug(
+					"%s: skipped SRv6 Locator chunk (%pFX): Function Length is too short to support specified index (%u)",
+					__func__, &chunk->prefix, index);
+			continue;
+		}
+
 		*sid = chunk->prefix.prefix;
+		*sid_locator_chunk = *chunk;
 		offset = chunk->block_bits_length + chunk->node_bits_length;
-		len = chunk->function_bits_length ?: 16;
+		func_len = chunk->function_bits_length;
+		shift_len = BGP_PREFIX_SID_SRV6_MAX_FUNCTION_LENGTH - func_len;
 
 		if (index != 0) {
-			label = index << 12;
-			transpose_sid(sid, label, offset, len);
+			label = index << shift_len;
+			if (label < MPLS_LABEL_UNRESERVED_MIN) {
+				if (debug)
+					zlog_debug(
+						"%s: skipped to allocate SRv6 SID (%pFX): Label (%u) is too small to use",
+						__func__, &chunk->prefix,
+						label);
+				continue;
+			}
+
+			transpose_sid(sid, label, offset, func_len);
 			if (sid_exist(bgp, sid))
-				return false;
+				continue;
 			alloced = true;
 			break;
 		}
 
-		for (size_t i = 1; i < 255; i++) {
-			label = i << 12;
-			transpose_sid(sid, label, offset, len);
+		for (uint32_t i = 1; i < index_max; i++) {
+			label = i << shift_len;
+			if (label < MPLS_LABEL_UNRESERVED_MIN) {
+				if (debug)
+					zlog_debug(
+						"%s: skipped to allocate SRv6 SID (%pFX): Label (%u) is too small to use",
+						__func__, &chunk->prefix,
+						label);
+				continue;
+			}
+			transpose_sid(sid, label, offset, func_len);
 			if (sid_exist(bgp, sid))
 				continue;
 			alloced = true;
@@ -569,11 +725,12 @@ static uint32_t alloc_new_sid(struct bgp
 	return label;
 }
 
-void ensure_vrf_tovpn_sid(struct bgp *bgp_vpn, struct bgp *bgp_vrf, afi_t afi)
+void ensure_vrf_tovpn_sid_per_af(struct bgp *bgp_vpn, struct bgp *bgp_vrf,
+				 afi_t afi)
 {
 	int debug = BGP_DEBUG(vpn, VPN_LEAK_FROM_VRF);
-	char buf[256];
-	struct in6_addr *tovpn_sid, *tovpn_sid_locator;
+	struct srv6_locator_chunk *tovpn_sid_locator;
+	struct in6_addr *tovpn_sid;
 	uint32_t tovpn_sid_index = 0, tovpn_sid_transpose_label;
 	bool tovpn_sid_auto = false;
 
@@ -607,27 +764,26 @@ void ensure_vrf_tovpn_sid(struct bgp *bg
 		return;
 	}
 
-	tovpn_sid_locator =
-		XCALLOC(MTYPE_BGP_SRV6_SID, sizeof(struct in6_addr));
+	tovpn_sid_locator = srv6_locator_chunk_alloc();
 	tovpn_sid = XCALLOC(MTYPE_BGP_SRV6_SID, sizeof(struct in6_addr));
 
 	tovpn_sid_transpose_label = alloc_new_sid(bgp_vpn, tovpn_sid_index,
 						  tovpn_sid_locator, tovpn_sid);
 
 	if (tovpn_sid_transpose_label == 0) {
-		zlog_debug("%s: not allocated new sid for vrf %s: afi %s",
-			   __func__, bgp_vrf->name_pretty, afi2str(afi));
-		XFREE(MTYPE_BGP_SRV6_SID, tovpn_sid_locator);
+		if (debug)
+			zlog_debug(
+				"%s: not allocated new sid for vrf %s: afi %s",
+				__func__, bgp_vrf->name_pretty, afi2str(afi));
+		srv6_locator_chunk_free(&tovpn_sid_locator);
 		XFREE(MTYPE_BGP_SRV6_SID, tovpn_sid);
 		return;
 	}
 
-	if (debug) {
-		inet_ntop(AF_INET6, tovpn_sid, buf, sizeof(buf));
-		zlog_debug("%s: new sid %s allocated for vrf %s: afi %s",
-			   __func__, buf, bgp_vrf->name_pretty,
+	if (debug)
+		zlog_debug("%s: new sid %pI6 allocated for vrf %s: afi %s",
+			   __func__, tovpn_sid, bgp_vrf->name_pretty,
 			   afi2str(afi));
-	}
 
 	bgp_vrf->vpn_policy[afi].tovpn_sid = tovpn_sid;
 	bgp_vrf->vpn_policy[afi].tovpn_sid_locator = tovpn_sid_locator;
@@ -635,21 +791,167 @@ void ensure_vrf_tovpn_sid(struct bgp *bg
 		tovpn_sid_transpose_label;
 }
 
+void ensure_vrf_tovpn_sid_per_vrf(struct bgp *bgp_vpn, struct bgp *bgp_vrf)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_FROM_VRF);
+	struct srv6_locator_chunk *tovpn_sid_locator;
+	struct in6_addr *tovpn_sid;
+	uint32_t tovpn_sid_index = 0, tovpn_sid_transpose_label;
+	bool tovpn_sid_auto = false;
+
+	if (debug)
+		zlog_debug("%s: try to allocate new SID for vrf %s", __func__,
+			   bgp_vrf->name_pretty);
+
+	/* skip when tovpn sid is already allocated on vrf instance */
+	if (bgp_vrf->tovpn_sid)
+		return;
+
+	/*
+	 * skip when bgp vpn instance ins't allocated
+	 * or srv6 locator chunk isn't allocated
+	 */
+	if (!bgp_vpn || !bgp_vpn->srv6_locator_chunks)
+		return;
+
+	tovpn_sid_index = bgp_vrf->tovpn_sid_index;
+	tovpn_sid_auto = CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_TOVPN_SID_AUTO);
+
+	/* skip when VPN isn't configured on vrf-instance */
+	if (tovpn_sid_index == 0 && !tovpn_sid_auto)
+		return;
+
+	/* check invalid case both configured index and auto */
+	if (tovpn_sid_index != 0 && tovpn_sid_auto) {
+		zlog_err("%s: index-mode and auto-mode both selected. ignored.",
+			 __func__);
+		return;
+	}
+
+	tovpn_sid_locator = srv6_locator_chunk_alloc();
+	tovpn_sid = XCALLOC(MTYPE_BGP_SRV6_SID, sizeof(struct in6_addr));
+
+	tovpn_sid_transpose_label = alloc_new_sid(bgp_vpn, tovpn_sid_index,
+						  tovpn_sid_locator, tovpn_sid);
+
+	if (tovpn_sid_transpose_label == 0) {
+		if (debug)
+			zlog_debug("%s: not allocated new sid for vrf %s",
+				   __func__, bgp_vrf->name_pretty);
+		srv6_locator_chunk_free(&tovpn_sid_locator);
+		XFREE(MTYPE_BGP_SRV6_SID, tovpn_sid);
+		return;
+	}
+
+	if (debug)
+		zlog_debug("%s: new sid %pI6 allocated for vrf %s", __func__,
+			   tovpn_sid, bgp_vrf->name_pretty);
+
+	bgp_vrf->tovpn_sid = tovpn_sid;
+	bgp_vrf->tovpn_sid_locator = tovpn_sid_locator;
+	bgp_vrf->tovpn_sid_transpose_label = tovpn_sid_transpose_label;
+}
+
+void ensure_vrf_tovpn_sid(struct bgp *bgp_vpn, struct bgp *bgp_vrf, afi_t afi)
+{
+	/* per-af sid */
+	if (bgp_vrf->vpn_policy[afi].tovpn_sid_index != 0 ||
+	    CHECK_FLAG(bgp_vrf->vpn_policy[afi].flags,
+		       BGP_VPN_POLICY_TOVPN_SID_AUTO))
+		return ensure_vrf_tovpn_sid_per_af(bgp_vpn, bgp_vrf, afi);
+
+	/* per-vrf sid */
+	if (bgp_vrf->tovpn_sid_index != 0 ||
+	    CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_TOVPN_SID_AUTO))
+		return ensure_vrf_tovpn_sid_per_vrf(bgp_vpn, bgp_vrf);
+}
+
+void delete_vrf_tovpn_sid_per_af(struct bgp *bgp_vpn, struct bgp *bgp_vrf,
+				 afi_t afi)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_FROM_VRF);
+	uint32_t tovpn_sid_index = 0;
+	bool tovpn_sid_auto = false;
+
+	if (debug)
+		zlog_debug("%s: try to remove SID for vrf %s: afi %s", __func__,
+			   bgp_vrf->name_pretty, afi2str(afi));
+
+	tovpn_sid_index = bgp_vrf->vpn_policy[afi].tovpn_sid_index;
+	tovpn_sid_auto = CHECK_FLAG(bgp_vrf->vpn_policy[afi].flags,
+				    BGP_VPN_POLICY_TOVPN_SID_AUTO);
+
+	/* skip when VPN is configured on vrf-instance */
+	if (tovpn_sid_index != 0 || tovpn_sid_auto)
+		return;
+
+	srv6_locator_chunk_free(&bgp_vrf->vpn_policy[afi].tovpn_sid_locator);
+
+	if (bgp_vrf->vpn_policy[afi].tovpn_sid) {
+		sid_unregister(bgp_vpn, bgp_vrf->vpn_policy[afi].tovpn_sid);
+		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->vpn_policy[afi].tovpn_sid);
+	}
+	bgp_vrf->vpn_policy[afi].tovpn_sid_transpose_label = 0;
+}
+
+void delete_vrf_tovpn_sid_per_vrf(struct bgp *bgp_vpn, struct bgp *bgp_vrf)
+{
+	int debug = BGP_DEBUG(vpn, VPN_LEAK_FROM_VRF);
+	uint32_t tovpn_sid_index = 0;
+	bool tovpn_sid_auto = false;
+
+	if (debug)
+		zlog_debug("%s: try to remove SID for vrf %s", __func__,
+			   bgp_vrf->name_pretty);
+
+	tovpn_sid_index = bgp_vrf->tovpn_sid_index;
+	tovpn_sid_auto =
+		CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VPN_POLICY_TOVPN_SID_AUTO);
+
+	/* skip when VPN is configured on vrf-instance */
+	if (tovpn_sid_index != 0 || tovpn_sid_auto)
+		return;
+
+	srv6_locator_chunk_free(&bgp_vrf->tovpn_sid_locator);
+
+	if (bgp_vrf->tovpn_sid) {
+		sid_unregister(bgp_vpn, bgp_vrf->tovpn_sid);
+		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->tovpn_sid);
+	}
+	bgp_vrf->tovpn_sid_transpose_label = 0;
+}
+
+void delete_vrf_tovpn_sid(struct bgp *bgp_vpn, struct bgp *bgp_vrf, afi_t afi)
+{
+	delete_vrf_tovpn_sid_per_af(bgp_vpn, bgp_vrf, afi);
+	delete_vrf_tovpn_sid_per_vrf(bgp_vpn, bgp_vrf);
+}
+
 /*
- * This function shifts "label" 4 bits to the right and
- * embeds it by length "len", starting at offset "offset"
- * as seen from the MSB (Most Significant Bit) of "sid".
+ * This function embeds upper `len` bits of `label` in `sid`,
+ * starting at offset `offset` as seen from the MSB of `sid`.
  *
- * e.g. if "label" is 0x1000 and "len" is 16, "label" is
- * embedded in "sid" as follows:
+ * e.g. Given that `label` is 0x12345 and `len` is 16,
+ * then `label` will be embedded in `sid` as follows:
  *
  *                 <----   len  ----->
- *         label:  0000 0001 0000 0000 0000
- *         sid:    .... 0000 0001 0000 0000
+ *         label:  0001 0002 0003 0004 0005
+ *         sid:    .... 0001 0002 0003 0004
  *                      <----   len  ----->
  *                    ^
  *                    |
  *                 offset from MSB
+ *
+ * e.g. Given that `label` is 0x12345 and `len` is 8,
+ * `label` will be embedded in `sid` as follows:
+ *
+ *                 <- len ->
+ *         label:  0001 0002 0003 0004 0005
+ *         sid:    .... 0001 0002 0000 0000
+ *                      <- len ->
+ *                    ^
+ *                    |
+ *                 offset from MSB
  */
 void transpose_sid(struct in6_addr *sid, uint32_t label, uint8_t offset,
 		   uint8_t len)
@@ -657,7 +959,7 @@ void transpose_sid(struct in6_addr *sid,
 	for (uint8_t idx = 0; idx < len; idx++) {
 		uint8_t tidx = offset + idx;
 		sid->s6_addr[tidx / 8] &= ~(0x1 << (7 - tidx % 8));
-		if (label >> (len + 3 - idx) & 0x1)
+		if (label >> (19 - idx) & 0x1)
 			sid->s6_addr[tidx / 8] |= 0x1 << (7 - tidx % 8);
 	}
 }
@@ -768,12 +1070,14 @@ static bool leak_update_nexthop_valid(st
 		bgp_nexthop = bgp_orig;
 
 	/*
-	 * No nexthop tracking for redistributed routes or for
-	 * EVPN-imported routes that get leaked.
+	 * No nexthop tracking for redistributed routes, for
+	 * EVPN-imported routes that get leaked, or for routes
+	 * leaked between VRFs with accept-own community.
 	 */
 	if (bpi_ultimate->sub_type == BGP_ROUTE_REDISTRIBUTE ||
-	    is_pi_family_evpn(bpi_ultimate))
-		nh_valid = 1;
+	    is_pi_family_evpn(bpi_ultimate) ||
+	    CHECK_FLAG(bpi_ultimate->flags, BGP_PATH_ACCEPT_OWN))
+		nh_valid = true;
 	else
 		/*
 		 * TBD do we need to do anything about the
@@ -793,9 +1097,8 @@ static bool leak_update_nexthop_valid(st
 	}
 
 	if (debug)
-		zlog_debug("%s: %pFX nexthop is %svalid (in vrf %s)", __func__,
-			   p, (nh_valid ? "" : "not "),
-			   bgp_nexthop->name_pretty);
+		zlog_debug("%s: %pFX nexthop is %svalid (in %s)", __func__, p,
+			   (nh_valid ? "" : "not "), bgp_nexthop->name_pretty);
 
 	return nh_valid;
 }
@@ -889,7 +1192,7 @@ leak_update(struct bgp *to_bgp, struct b
 			if (!ecommunity_cmp(
 				    bgp_attr_get_ecommunity(bpi->attr),
 				    bgp_attr_get_ecommunity(new_attr))) {
-				vpn_leak_to_vrf_withdraw(to_bgp, bpi);
+				vpn_leak_to_vrf_withdraw(bpi);
 				bgp_aggregate_decrement(to_bgp, p, bpi, afi,
 							safi);
 				bgp_path_info_delete(bn, bpi);
@@ -946,6 +1249,9 @@ leak_update(struct bgp *to_bgp, struct b
 		if (nexthop_self_flag)
 			bgp_path_info_set_flag(bn, bpi, BGP_PATH_ANNC_NH_SELF);
 
+		if (CHECK_FLAG(source_bpi->flags, BGP_PATH_ACCEPT_OWN))
+			bgp_path_info_set_flag(bn, bpi, BGP_PATH_ACCEPT_OWN);
+
 		if (leak_update_nexthop_valid(to_bgp, bn, new_attr, afi, safi,
 					      source_bpi, bpi, bgp_orig, p,
 					      debug))
@@ -986,6 +1292,9 @@ leak_update(struct bgp *to_bgp, struct b
 	if (nexthop_self_flag)
 		bgp_path_info_set_flag(bn, new, BGP_PATH_ANNC_NH_SELF);
 
+	if (CHECK_FLAG(source_bpi->flags, BGP_PATH_ACCEPT_OWN))
+		bgp_path_info_set_flag(bn, new, BGP_PATH_ACCEPT_OWN);
+
 	bgp_path_info_extra_get(new);
 
 	/*
@@ -1167,6 +1476,8 @@ void vpn_leak_from_vrf_update(struct bgp
 		XFREE(MTYPE_ECOMMUNITY_STR, s);
 	}
 
+	community_strip_accept_own(&static_attr);
+
 	/* Nexthop */
 	/* if policy nexthop not set, use 0 */
 	if (CHECK_FLAG(from_bgp->vpn_policy[afi].flags,
@@ -1245,27 +1556,74 @@ void vpn_leak_from_vrf_update(struct bgp
 
 	/* Set SID for SRv6 VPN */
 	if (from_bgp->vpn_policy[afi].tovpn_sid_locator) {
+		struct srv6_locator_chunk *locator =
+			from_bgp->vpn_policy[afi].tovpn_sid_locator;
 		encode_label(
 			from_bgp->vpn_policy[afi].tovpn_sid_transpose_label,
 			&label);
 		static_attr.srv6_l3vpn = XCALLOC(MTYPE_BGP_SRV6_L3VPN,
 				sizeof(struct bgp_attr_srv6_l3vpn));
 		static_attr.srv6_l3vpn->sid_flags = 0x00;
-		static_attr.srv6_l3vpn->endpoint_behavior = 0xffff;
+		static_attr.srv6_l3vpn->endpoint_behavior =
+			afi == AFI_IP
+				? (CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID)
+					   ? SRV6_ENDPOINT_BEHAVIOR_END_DT4_USID
+					   : SRV6_ENDPOINT_BEHAVIOR_END_DT4)
+				: (CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID)
+					   ? SRV6_ENDPOINT_BEHAVIOR_END_DT6_USID
+					   : SRV6_ENDPOINT_BEHAVIOR_END_DT6);
+		static_attr.srv6_l3vpn->loc_block_len =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->block_bits_length;
+		static_attr.srv6_l3vpn->loc_node_len =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->node_bits_length;
+		static_attr.srv6_l3vpn->func_len =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->function_bits_length;
+		static_attr.srv6_l3vpn->arg_len =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->argument_bits_length;
+		static_attr.srv6_l3vpn->transposition_len =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->function_bits_length;
+		static_attr.srv6_l3vpn->transposition_offset =
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->block_bits_length +
+			from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->node_bits_length;
+		;
+		memcpy(&static_attr.srv6_l3vpn->sid,
+		       &from_bgp->vpn_policy[afi]
+				.tovpn_sid_locator->prefix.prefix,
+		       sizeof(struct in6_addr));
+	} else if (from_bgp->tovpn_sid_locator) {
+		struct srv6_locator_chunk *locator =
+			from_bgp->tovpn_sid_locator;
+		encode_label(from_bgp->tovpn_sid_transpose_label, &label);
+		static_attr.srv6_l3vpn =
+			XCALLOC(MTYPE_BGP_SRV6_L3VPN,
+				sizeof(struct bgp_attr_srv6_l3vpn));
+		static_attr.srv6_l3vpn->sid_flags = 0x00;
+		static_attr.srv6_l3vpn->endpoint_behavior =
+			CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID)
+				? SRV6_ENDPOINT_BEHAVIOR_END_DT46_USID
+				: SRV6_ENDPOINT_BEHAVIOR_END_DT46;
 		static_attr.srv6_l3vpn->loc_block_len =
-			BGP_PREFIX_SID_SRV6_LOCATOR_BLOCK_LENGTH;
+			from_bgp->tovpn_sid_locator->block_bits_length;
 		static_attr.srv6_l3vpn->loc_node_len =
-			BGP_PREFIX_SID_SRV6_LOCATOR_NODE_LENGTH;
+			from_bgp->tovpn_sid_locator->node_bits_length;
 		static_attr.srv6_l3vpn->func_len =
-			BGP_PREFIX_SID_SRV6_FUNCTION_LENGTH;
+			from_bgp->tovpn_sid_locator->function_bits_length;
 		static_attr.srv6_l3vpn->arg_len =
-			BGP_PREFIX_SID_SRV6_ARGUMENT_LENGTH;
+			from_bgp->tovpn_sid_locator->argument_bits_length;
 		static_attr.srv6_l3vpn->transposition_len =
-			BGP_PREFIX_SID_SRV6_TRANSPOSITION_LENGTH;
+			from_bgp->tovpn_sid_locator->function_bits_length;
 		static_attr.srv6_l3vpn->transposition_offset =
-			BGP_PREFIX_SID_SRV6_TRANSPOSITION_OFFSET;
+			from_bgp->tovpn_sid_locator->block_bits_length +
+			from_bgp->tovpn_sid_locator->node_bits_length;
 		memcpy(&static_attr.srv6_l3vpn->sid,
-		       from_bgp->vpn_policy[afi].tovpn_sid_locator,
+		       &from_bgp->tovpn_sid_locator->prefix.prefix,
 		       sizeof(struct in6_addr));
 	}
 
@@ -1303,7 +1661,7 @@ void vpn_leak_from_vrf_update(struct bgp
 	 * because of loop checking.
 	 */
 	if (new_info)
-		vpn_leak_to_vrf_update(from_bgp, new_info);
+		vpn_leak_to_vrf_update(from_bgp, new_info, NULL);
 }
 
 void vpn_leak_from_vrf_withdraw(struct bgp *to_bgp,		/* to */
@@ -1364,7 +1722,7 @@ void vpn_leak_from_vrf_withdraw(struct b
 
 	if (bpi) {
 		/* withdraw from looped vrfs as well */
-		vpn_leak_to_vrf_withdraw(to_bgp, bpi);
+		vpn_leak_to_vrf_withdraw(bpi);
 
 		bgp_aggregate_decrement(to_bgp, p, bpi, afi, safi);
 		bgp_path_info_delete(bn, bpi);
@@ -1419,7 +1777,7 @@ void vpn_leak_from_vrf_withdraw_all(stru
 						zlog_debug("%s: deleting it",
 							   __func__);
 					/* withdraw from leak-to vrfs as well */
-					vpn_leak_to_vrf_withdraw(to_bgp, bpi);
+					vpn_leak_to_vrf_withdraw(bpi);
 					bgp_aggregate_decrement(
 						to_bgp, bgp_dest_get_prefix(bn),
 						bpi, afi, safi);
@@ -1459,10 +1817,40 @@ void vpn_leak_from_vrf_update_all(struct
 	}
 }
 
-static bool
-vpn_leak_to_vrf_update_onevrf(struct bgp *to_bgp,	     /* to */
-			      struct bgp *from_bgp,	   /* from */
-			      struct bgp_path_info *path_vpn) /* route */
+static struct bgp *bgp_lookup_by_rd(struct bgp_path_info *bpi,
+				    struct prefix_rd *rd, afi_t afi)
+{
+	struct listnode *node, *nnode;
+	struct bgp *bgp;
+
+	if (!rd)
+		return NULL;
+
+	/* If ACCEPT_OWN is not enabled for this path - return. */
+	if (!CHECK_FLAG(bpi->flags, BGP_PATH_ACCEPT_OWN))
+		return NULL;
+
+	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
+		if (bgp->inst_type != BGP_INSTANCE_TYPE_VRF)
+			continue;
+
+		if (!CHECK_FLAG(bgp->vpn_policy[afi].flags,
+				BGP_VPN_POLICY_TOVPN_RD_SET))
+			continue;
+
+		/* Check if we have source VRF by RD value */
+		if (memcmp(&bgp->vpn_policy[afi].tovpn_rd.val, rd->val,
+			   ECOMMUNITY_SIZE) == 0)
+			return bgp;
+	}
+
+	return NULL;
+}
+
+static bool vpn_leak_to_vrf_update_onevrf(struct bgp *to_bgp,   /* to */
+					  struct bgp *from_bgp, /* from */
+					  struct bgp_path_info *path_vpn,
+					  struct prefix_rd *prd)
 {
 	const struct prefix *p = bgp_dest_get_prefix(path_vpn->net);
 	afi_t afi = family2afi(p->family);
@@ -1479,15 +1867,35 @@ vpn_leak_to_vrf_update_onevrf(struct bgp
 	struct bgp_path_info *bpi_ultimate = NULL;
 	int origin_local = 0;
 	struct bgp *src_vrf;
+	struct interface *ifp;
 
 	int debug = BGP_DEBUG(vpn, VPN_LEAK_TO_VRF);
 
 	if (!vpn_leak_from_vpn_active(to_bgp, afi, &debugmsg)) {
 		if (debug)
-			zlog_debug("%s: skipping: %s", __func__, debugmsg);
+			zlog_debug(
+				"%s: from vpn (%s) to vrf (%s), skipping: %s",
+				__func__, from_bgp->name_pretty,
+				to_bgp->name_pretty, debugmsg);
 		return false;
 	}
 
+	/*
+	 * For VRF-2-VRF route-leaking,
+	 * the source will be the originating VRF.
+	 *
+	 * If ACCEPT_OWN mechanism is enabled, then we SHOULD(?)
+	 * get the source VRF (BGP) by looking at the RD.
+	 */
+	struct bgp *src_bgp = bgp_lookup_by_rd(path_vpn, prd, afi);
+
+	if (path_vpn->extra && path_vpn->extra->bgp_orig)
+		src_vrf = path_vpn->extra->bgp_orig;
+	else if (src_bgp)
+		src_vrf = src_bgp;
+	else
+		src_vrf = from_bgp;
+
 	/* Check for intersection of route targets */
 	if (!ecommunity_include(
 		    to_bgp->vpn_policy[afi].rtlist[BGP_VPN_POLICY_DIR_FROMVPN],
@@ -1499,8 +1907,22 @@ vpn_leak_to_vrf_update_onevrf(struct bgp
 		return false;
 	}
 
+	/* A route MUST NOT ever be accepted back into its source VRF, even if
+	 * it carries one or more RTs that match that VRF.
+	 */
+	if (CHECK_FLAG(path_vpn->flags, BGP_PATH_ACCEPT_OWN) && prd &&
+	    memcmp(&prd->val, &to_bgp->vpn_policy[afi].tovpn_rd.val,
+		   ECOMMUNITY_SIZE) == 0) {
+		if (debug)
+			zlog_debug(
+				"%s: skipping import, match RD (%pRD) of src VRF (%s) and the prefix (%pFX)",
+				__func__, prd, to_bgp->name_pretty, p);
+
+		return false;
+	}
+
 	if (debug)
-		zlog_debug("%s: updating %pFX to vrf %s", __func__, p,
+		zlog_debug("%s: updating RD %pRD, %pFX to %s", __func__, prd, p,
 			   to_bgp->name_pretty);
 
 	/* shallow copy */
@@ -1526,6 +1948,8 @@ vpn_leak_to_vrf_update_onevrf(struct bgp
 			ecommunity_free(&old_ecom);
 	}
 
+	community_strip_accept_own(&static_attr);
+
 	/*
 	 * Nexthop: stash and clear
 	 *
@@ -1538,6 +1962,20 @@ vpn_leak_to_vrf_update_onevrf(struct bgp
 	memset(&nexthop_orig, 0, sizeof(nexthop_orig));
 	nexthop_orig.family = nhfamily;
 
+	/* If the path has accept-own community and the source VRF
+	 * is valid, reset next-hop to self, to allow importing own
+	 * routes between different VRFs on the same node.
+	 * Set the nh ifindex to VRF's interface, not the real interface.
+	 * Let the kernel to decide with double lookup the real next-hop
+	 * interface when installing the route.
+	 */
+	if (src_bgp) {
+		subgroup_announce_reset_nhop(nhfamily, &static_attr);
+		ifp = if_get_vrf_loopback(src_vrf->vrf_id);
+		if (ifp)
+			static_attr.nh_ifindex = ifp->ifindex;
+	}
+
 	switch (nhfamily) {
 	case AF_INET:
 		/* save */
@@ -1649,23 +2087,15 @@ vpn_leak_to_vrf_update_onevrf(struct bgp
 		zlog_debug("%s: pfx %pBD: num_labels %d", __func__,
 			   path_vpn->net, num_labels);
 
-	/*
-	 * For VRF-2-VRF route-leaking,
-	 * the source will be the originating VRF.
-	 */
-	if (path_vpn->extra && path_vpn->extra->bgp_orig)
-		src_vrf = path_vpn->extra->bgp_orig;
-	else
-		src_vrf = from_bgp;
-
 	leak_update(to_bgp, bn, new_attr, afi, safi, path_vpn, pLabels,
 		    num_labels, src_vrf, &nexthop_orig, nexthop_self_flag,
 		    debug);
 	return true;
 }
 
-bool vpn_leak_to_vrf_update(struct bgp *from_bgp,	   /* from */
-			    struct bgp_path_info *path_vpn) /* route */
+bool vpn_leak_to_vrf_update(struct bgp *from_bgp,
+			    struct bgp_path_info *path_vpn,
+			    struct prefix_rd *prd)
 {
 	struct listnode *mnode, *mnnode;
 	struct bgp *bgp;
@@ -1682,14 +2112,13 @@ bool vpn_leak_to_vrf_update(struct bgp *
 		if (!path_vpn->extra
 		    || path_vpn->extra->bgp_orig != bgp) { /* no loop */
 			leak_success |= vpn_leak_to_vrf_update_onevrf(
-				bgp, from_bgp, path_vpn);
+				bgp, from_bgp, path_vpn, prd);
 		}
 	}
 	return leak_success;
 }
 
-void vpn_leak_to_vrf_withdraw(struct bgp *from_bgp,	   /* from */
-			      struct bgp_path_info *path_vpn) /* route */
+void vpn_leak_to_vrf_withdraw(struct bgp_path_info *path_vpn)
 {
 	const struct prefix *p;
 	afi_t afi;
@@ -1732,7 +2161,8 @@ void vpn_leak_to_vrf_withdraw(struct bgp
 	for (ALL_LIST_ELEMENTS(bm->bgp, mnode, mnnode, bgp)) {
 		if (!vpn_leak_from_vpn_active(bgp, afi, &debugmsg)) {
 			if (debug)
-				zlog_debug("%s: skipping: %s", __func__,
+				zlog_debug("%s: from %s, skipping: %s",
+					   __func__, bgp->name_pretty,
 					   debugmsg);
 			continue;
 		}
@@ -1838,7 +2268,7 @@ void vpn_leak_to_vrf_update_all(struct b
 					continue;
 
 				vpn_leak_to_vrf_update_onevrf(to_bgp, vpn_from,
-							      bpi);
+							      bpi, NULL);
 			}
 		}
 	}
@@ -2411,6 +2841,10 @@ int bgp_show_mpls_vpn(struct vty *vty, a
 {
 	struct bgp *bgp;
 	struct bgp_table *table;
+	uint16_t show_flags = 0;
+
+	if (use_json)
+		SET_FLAG(show_flags, BGP_SHOW_OPT_JSON);
 
 	bgp = bgp_get_default();
 	if (bgp == NULL) {
@@ -2422,7 +2856,7 @@ int bgp_show_mpls_vpn(struct vty *vty, a
 	}
 	table = bgp->rib[afi][SAFI_MPLS_VPN];
 	return bgp_show_table_rd(vty, bgp, SAFI_MPLS_VPN, table, prd, type,
-				 output_arg, use_json);
+				 output_arg, show_flags);
 }
 
 DEFUN (show_bgp_ip_vpn_all_rd,
diff -urpN frr-frr-8.4.2/bgpd/bgp_mplsvpn.h frr-frr-8.5/bgpd/bgp_mplsvpn.h
--- frr-frr-8.4.2/bgpd/bgp_mplsvpn.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_mplsvpn.h	2023-03-13 20:01:47.000000000 +0600
@@ -41,6 +41,8 @@
 #define V4_HEADER_OVERLAY                                                      \
 	"   Network          Next Hop      EthTag    Overlay Index   RouterMac\n"
 
+#define BGP_PREFIX_SID_SRV6_MAX_FUNCTION_LENGTH 20
+
 extern void bgp_mplsvpn_init(void);
 extern int bgp_nlri_parse_vpn(struct peer *, struct attr *, struct bgp_nlri *);
 extern uint32_t decode_label(mpls_label_t *);
@@ -70,17 +72,28 @@ extern void vpn_leak_to_vrf_update_all(s
 				       afi_t afi);
 
 extern bool vpn_leak_to_vrf_update(struct bgp *from_bgp,
-				   struct bgp_path_info *path_vpn);
+				   struct bgp_path_info *path_vpn,
+				   struct prefix_rd *prd);
 
-extern void vpn_leak_to_vrf_withdraw(struct bgp *from_bgp,
-				     struct bgp_path_info *path_vpn);
+extern void vpn_leak_to_vrf_withdraw(struct bgp_path_info *path_vpn);
 
 extern void vpn_leak_zebra_vrf_label_update(struct bgp *bgp, afi_t afi);
 extern void vpn_leak_zebra_vrf_label_withdraw(struct bgp *bgp, afi_t afi);
 extern void vpn_leak_zebra_vrf_sid_update(struct bgp *bgp, afi_t afi);
+extern void vpn_leak_zebra_vrf_sid_update_per_af(struct bgp *bgp, afi_t afi);
+extern void vpn_leak_zebra_vrf_sid_update_per_vrf(struct bgp *bgp);
 extern void vpn_leak_zebra_vrf_sid_withdraw(struct bgp *bgp, afi_t afi);
+extern void vpn_leak_zebra_vrf_sid_withdraw_per_af(struct bgp *bgp, afi_t afi);
+extern void vpn_leak_zebra_vrf_sid_withdraw_per_vrf(struct bgp *bgp);
 extern int vpn_leak_label_callback(mpls_label_t label, void *lblid, bool alloc);
 extern void ensure_vrf_tovpn_sid(struct bgp *vpn, struct bgp *vrf, afi_t afi);
+extern void delete_vrf_tovpn_sid(struct bgp *vpn, struct bgp *vrf, afi_t afi);
+extern void delete_vrf_tovpn_sid_per_af(struct bgp *vpn, struct bgp *vrf,
+					afi_t afi);
+extern void delete_vrf_tovpn_sid_per_vrf(struct bgp *vpn, struct bgp *vrf);
+extern void ensure_vrf_tovpn_sid_per_af(struct bgp *vpn, struct bgp *vrf,
+					afi_t afi);
+extern void ensure_vrf_tovpn_sid_per_vrf(struct bgp *vpn, struct bgp *vrf);
 extern void transpose_sid(struct in6_addr *sid, uint32_t label, uint8_t offset,
 			  uint8_t size);
 extern void vrf_import_from_vrf(struct bgp *to_bgp, struct bgp *from_bgp,
@@ -248,17 +261,33 @@ static inline void vpn_leak_postchange(e
 			vpn_leak_zebra_vrf_label_update(bgp_vrf, afi);
 		}
 
-		if (!bgp_vrf->vpn_policy[afi].tovpn_sid)
+		if (bgp_vrf->vpn_policy[afi].tovpn_sid_index == 0 &&
+		    !CHECK_FLAG(bgp_vrf->vpn_policy[afi].flags,
+				BGP_VPN_POLICY_TOVPN_SID_AUTO) &&
+		    bgp_vrf->tovpn_sid_index == 0 &&
+		    !CHECK_FLAG(bgp_vrf->vrf_flags, BGP_VRF_TOVPN_SID_AUTO))
+			delete_vrf_tovpn_sid(bgp_vpn, bgp_vrf, afi);
+
+		if (!bgp_vrf->vpn_policy[afi].tovpn_sid && !bgp_vrf->tovpn_sid)
 			ensure_vrf_tovpn_sid(bgp_vpn, bgp_vrf, afi);
 
-		if (!bgp_vrf->vpn_policy[afi].tovpn_sid
-		    && bgp_vrf->vpn_policy[afi].tovpn_zebra_vrf_sid_last_sent)
+		if ((!bgp_vrf->vpn_policy[afi].tovpn_sid &&
+		     bgp_vrf->vpn_policy[afi].tovpn_zebra_vrf_sid_last_sent) ||
+		    (!bgp_vrf->tovpn_sid &&
+		     bgp_vrf->tovpn_zebra_vrf_sid_last_sent))
 			vpn_leak_zebra_vrf_sid_withdraw(bgp_vrf, afi);
 
-		if (sid_diff(bgp_vrf->vpn_policy[afi].tovpn_sid,
-			     bgp_vrf->vpn_policy[afi]
-				     .tovpn_zebra_vrf_sid_last_sent)) {
-			vpn_leak_zebra_vrf_sid_update(bgp_vrf, afi);
+		if (bgp_vrf->vpn_policy[afi].tovpn_sid) {
+			if (sid_diff(bgp_vrf->vpn_policy[afi].tovpn_sid,
+				     bgp_vrf->vpn_policy[afi]
+					     .tovpn_zebra_vrf_sid_last_sent)) {
+				vpn_leak_zebra_vrf_sid_update(bgp_vrf, afi);
+			}
+		} else if (bgp_vrf->tovpn_sid) {
+			if (sid_diff(bgp_vrf->tovpn_sid,
+				     bgp_vrf->tovpn_zebra_vrf_sid_last_sent)) {
+				vpn_leak_zebra_vrf_sid_update(bgp_vrf, afi);
+			}
 		}
 
 		vpn_leak_from_vrf_update_all(bgp_vpn, bgp_vrf, afi);
diff -urpN frr-frr-8.4.2/bgpd/bgp_mplsvpn_snmp.c frr-frr-8.5/bgpd/bgp_mplsvpn_snmp.c
--- frr-frr-8.4.2/bgpd/bgp_mplsvpn_snmp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_mplsvpn_snmp.c	2023-03-13 20:01:47.000000000 +0600
@@ -1529,7 +1529,7 @@ static uint8_t *mplsL3vpnRteTable(struct
 	char vrf_name[VRF_NAMSIZ];
 	struct bgp *l3vpn_bgp;
 	struct bgp_dest *dest;
-	struct bgp_path_info *pi;
+	struct bgp_path_info *pi, *bpi_ultimate;
 	const struct prefix *p;
 	uint16_t policy = 0;
 
@@ -1545,6 +1545,8 @@ static uint8_t *mplsL3vpnRteTable(struct
 	if (!pi)
 		return NULL;
 
+	bpi_ultimate = bgp_get_imported_bpi_ultimate(pi);
+
 	p = bgp_dest_get_prefix(dest);
 
 	if (!p)
@@ -1661,8 +1663,8 @@ static uint8_t *mplsL3vpnRteTable(struct
 	case MPLSL3VPNVRFRTEINETCIDRNEXTHOPAS:
 		return SNMP_INTEGER(pi->peer ? pi->peer->as : 0);
 	case MPLSL3VPNVRFRTEINETCIDRMETRIC1:
-		if (pi->extra)
-			return SNMP_INTEGER(pi->extra->igpmetric);
+		if (bpi_ultimate->extra)
+			return SNMP_INTEGER(bpi_ultimate->extra->igpmetric);
 		else
 			return SNMP_INTEGER(0);
 	case MPLSL3VPNVRFRTEINETCIDRMETRIC2:
diff -urpN frr-frr-8.4.2/bgpd/bgp_network.c frr-frr-8.5/bgpd/bgp_network.c
--- frr-frr-8.4.2/bgpd/bgp_network.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_network.c	2023-03-13 20:01:47.000000000 +0600
@@ -207,6 +207,25 @@ int bgp_md5_set(struct peer *peer)
 	return bgp_md5_set_password(peer, peer->password);
 }
 
+static void bgp_update_setsockopt_tcp_keepalive(struct bgp *bgp, int fd)
+{
+	if (!bgp)
+		return;
+	if (bgp->tcp_keepalive_idle != 0) {
+		int ret;
+
+		ret = setsockopt_tcp_keepalive(fd, bgp->tcp_keepalive_idle,
+					       bgp->tcp_keepalive_intvl,
+					       bgp->tcp_keepalive_probes);
+		if (ret < 0)
+			zlog_err(
+				"Can't set TCP keepalive on socket %d, idle %u intvl %u probes %u",
+				fd, bgp->tcp_keepalive_idle,
+				bgp->tcp_keepalive_intvl,
+				bgp->tcp_keepalive_probes);
+	}
+}
+
 int bgp_md5_unset(struct peer *peer)
 {
 	/* Unset the password from listen socket. */
@@ -415,6 +434,9 @@ static void bgp_accept(struct thread *th
 
 	bgp_socket_set_buffer_size(bgp_sock);
 
+	/* Set TCP keepalive when TCP keepalive is enabled */
+	bgp_update_setsockopt_tcp_keepalive(bgp, bgp_sock);
+
 	/* Check remote IP address */
 	peer1 = peer_lookup(bgp, &su);
 
@@ -499,17 +521,25 @@ static void bgp_accept(struct thread *th
 	 * is shutdown.
 	 */
 	if (BGP_PEER_START_SUPPRESSED(peer1)) {
-		if (bgp_debug_neighbor_events(peer1))
-			zlog_debug(
-				"[Event] Incoming BGP connection rejected from %s due to maximum-prefix or shutdown",
-				peer1->host);
+		if (bgp_debug_neighbor_events(peer1)) {
+			if (peer1->shut_during_cfg)
+				zlog_debug(
+					"[Event] Incoming BGP connection rejected from %s due to configuration being currently read in",
+					peer1->host);
+			else
+				zlog_debug(
+					"[Event] Incoming BGP connection rejected from %s due to maximum-prefix or shutdown",
+					peer1->host);
+		}
 		close(bgp_sock);
 		return;
 	}
 
 	if (bgp_debug_neighbor_events(peer1))
-		zlog_debug("[Event] BGP connection from host %s fd %d",
-			   inet_sutop(&su, buf), bgp_sock);
+		zlog_debug(
+			"[Event] connection from %s fd %d, active peer status %d fd %d",
+			inet_sutop(&su, buf), bgp_sock, peer1->status,
+			peer1->fd);
 
 	if (peer1->doppelganger) {
 		/* We have an existing connection. Kill the existing one and run
@@ -529,9 +559,7 @@ static void bgp_accept(struct thread *th
 				peer1->host);
 
 	peer = peer_create(&su, peer1->conf_if, peer1->bgp, peer1->local_as,
-			   peer1->as, peer1->as_type, NULL);
-	hash_release(peer->bgp->peerhash, peer);
-	(void)hash_get(peer->bgp->peerhash, peer, hash_alloc_intern);
+			   peer1->as, peer1->as_type, NULL, false);
 
 	peer_xfer_config(peer, peer1);
 	bgp_peer_gr_flags_update(peer);
@@ -548,8 +576,6 @@ static void bgp_accept(struct thread *th
 		}
 	}
 
-	UNSET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
-
 	peer->doppelganger = peer1;
 	peer1->doppelganger = peer;
 	peer->fd = bgp_sock;
@@ -718,12 +744,16 @@ int bgp_connect(struct peer *peer)
 
 	bgp_socket_set_buffer_size(peer->fd);
 
+	/* Set TCP keepalive when TCP keepalive is enabled */
+	bgp_update_setsockopt_tcp_keepalive(peer->bgp, peer->fd);
+
 	if (bgp_set_socket_ttl(peer, peer->fd) < 0) {
 		peer->last_reset = PEER_DOWN_SOCKET_ERROR;
 		if (bgp_debug_neighbor_events(peer))
 			zlog_debug("%s: Failure to set socket ttl for connection to %s, error received: %s(%d)",
 				   __func__, peer->host, safe_strerror(errno),
 				   errno);
+
 		return -1;
 	}
 
diff -urpN frr-frr-8.4.2/bgpd/bgp_nexthop.c frr-frr-8.5/bgpd/bgp_nexthop.c
--- frr-frr-8.4.2/bgpd/bgp_nexthop.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_nexthop.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,6 +23,7 @@
 #include "command.h"
 #include "thread.h"
 #include "prefix.h"
+#include "lib/json.h"
 #include "zclient.h"
 #include "stream.h"
 #include "network.h"
@@ -187,15 +188,30 @@ void bgp_tip_hash_destroy(struct bgp *bg
 	bgp->tip_hash = NULL;
 }
 
-void bgp_tip_add(struct bgp *bgp, struct in_addr *tip)
+/* Add/Update Tunnel-IP entry of bgp martian next-hop table.
+ *
+ * Returns true only if we add a _new_ TIP so the caller knows that an
+ * actionable change has occurred. If we find an existing TIP then we
+ * only need to update the refcnt, since the collection of known TIPs
+ * has not changed.
+ */
+bool bgp_tip_add(struct bgp *bgp, struct in_addr *tip)
 {
 	struct tip_addr tmp;
 	struct tip_addr *addr;
+	bool tip_added = false;
 
 	tmp.addr = *tip;
 
-	addr = hash_get(bgp->tip_hash, &tmp, bgp_tip_hash_alloc);
+	addr = hash_lookup(bgp->tip_hash, &tmp);
+	if (!addr) {
+		addr = hash_get(bgp->tip_hash, &tmp, bgp_tip_hash_alloc);
+		tip_added = true;
+	}
+
 	addr->refcnt++;
+
+	return tip_added;
 }
 
 void bgp_tip_del(struct bgp *bgp, struct in_addr *tip)
@@ -731,17 +747,68 @@ bool bgp_subgrp_multiaccess_check_v4(str
 	return false;
 }
 
+static void bgp_show_bgp_path_info_flags(uint32_t flags, json_object *json)
+{
+	json_object *json_flags = NULL;
+
+	if (!json)
+		return;
+
+	json_flags = json_object_new_object();
+	json_object_boolean_add(json_flags, "igpChanged",
+				CHECK_FLAG(flags, BGP_PATH_IGP_CHANGED));
+	json_object_boolean_add(json_flags, "damped",
+				CHECK_FLAG(flags, BGP_PATH_DAMPED));
+	json_object_boolean_add(json_flags, "history",
+				CHECK_FLAG(flags, BGP_PATH_HISTORY));
+	json_object_boolean_add(json_flags, "bestpath",
+				CHECK_FLAG(flags, BGP_PATH_SELECTED));
+	json_object_boolean_add(json_flags, "valid",
+				CHECK_FLAG(flags, BGP_PATH_VALID));
+	json_object_boolean_add(json_flags, "attrChanged",
+				CHECK_FLAG(flags, BGP_PATH_ATTR_CHANGED));
+	json_object_boolean_add(json_flags, "deterministicMedCheck",
+				CHECK_FLAG(flags, BGP_PATH_DMED_CHECK));
+	json_object_boolean_add(json_flags, "deterministicMedSelected",
+				CHECK_FLAG(flags, BGP_PATH_DMED_SELECTED));
+	json_object_boolean_add(json_flags, "stale",
+				CHECK_FLAG(flags, BGP_PATH_STALE));
+	json_object_boolean_add(json_flags, "removed",
+				CHECK_FLAG(flags, BGP_PATH_REMOVED));
+	json_object_boolean_add(json_flags, "counted",
+				CHECK_FLAG(flags, BGP_PATH_COUNTED));
+	json_object_boolean_add(json_flags, "multipath",
+				CHECK_FLAG(flags, BGP_PATH_MULTIPATH));
+	json_object_boolean_add(json_flags, "multipathChanged",
+				CHECK_FLAG(flags, BGP_PATH_MULTIPATH_CHG));
+	json_object_boolean_add(json_flags, "ribAttributeChanged",
+				CHECK_FLAG(flags, BGP_PATH_RIB_ATTR_CHG));
+	json_object_boolean_add(json_flags, "nexthopSelf",
+				CHECK_FLAG(flags, BGP_PATH_ANNC_NH_SELF));
+	json_object_boolean_add(json_flags, "linkBandwidthChanged",
+				CHECK_FLAG(flags, BGP_PATH_LINK_BW_CHG));
+	json_object_boolean_add(json_flags, "acceptOwn",
+				CHECK_FLAG(flags, BGP_PATH_ACCEPT_OWN));
+	json_object_object_add(json, "flags", json_flags);
+}
+
 static void bgp_show_nexthop_paths(struct vty *vty, struct bgp *bgp,
-				   struct bgp_nexthop_cache *bnc)
+				   struct bgp_nexthop_cache *bnc,
+				   json_object *json)
 {
 	struct bgp_dest *dest;
 	struct bgp_path_info *path;
-	int afi;
+	afi_t afi;
 	safi_t safi;
 	struct bgp_table *table;
 	struct bgp *bgp_path;
+	json_object *paths = NULL;
+	json_object *json_path = NULL;
 
-	vty_out(vty, "  Paths:\n");
+	if (json)
+		paths = json_object_new_array();
+	else
+		vty_out(vty, "  Paths:\n");
 	LIST_FOREACH (path, &(bnc->paths), nh_thread) {
 		dest = path->net;
 		assert(dest && bgp_dest_table(dest));
@@ -750,6 +817,25 @@ static void bgp_show_nexthop_paths(struc
 		safi = table->safi;
 		bgp_path = table->bgp;
 
+		if (json) {
+			json_path = json_object_new_object();
+			json_object_string_add(json_path, "afi", afi2str(afi));
+			json_object_string_add(json_path, "safi",
+					       safi2str(safi));
+			json_object_string_addf(json_path, "prefix", "%pBD",
+						dest);
+			if (dest->pdest)
+				json_object_string_addf(
+					json_path, "rd", "%pRD",
+					(struct prefix_rd *)bgp_dest_get_prefix(
+						dest->pdest));
+			json_object_string_add(
+				json_path, "vrf",
+				vrf_id_to_name(bgp_path->vrf_id));
+			bgp_show_bgp_path_info_flags(path->flags, json_path);
+			json_object_array_add(paths, json_path);
+			continue;
+		}
 		if (dest->pdest)
 			vty_out(vty, "    %d/%d %pBD RD %pRD %s flags 0x%x\n",
 				afi, safi, dest,
@@ -760,33 +846,99 @@ static void bgp_show_nexthop_paths(struc
 			vty_out(vty, "    %d/%d %pBD %s flags 0x%x\n",
 				afi, safi, dest, bgp_path->name_pretty, path->flags);
 	}
+	if (json)
+		json_object_object_add(json, "paths", paths);
 }
 
 static void bgp_show_nexthops_detail(struct vty *vty, struct bgp *bgp,
-				     struct bgp_nexthop_cache *bnc)
+				     struct bgp_nexthop_cache *bnc,
+				     json_object *json)
 {
-	char buf[PREFIX2STR_BUFFER];
 	struct nexthop *nexthop;
+	json_object *json_gates = NULL;
+	json_object *json_gate = NULL;
 
+	if (json)
+		json_gates = json_object_new_array();
 	for (nexthop = bnc->nexthop; nexthop; nexthop = nexthop->next) {
+		if (json) {
+			json_gate = json_object_new_object();
+			switch (nexthop->type) {
+			case NEXTHOP_TYPE_IPV6:
+				json_object_string_addf(json_gate, "ip", "%pI6",
+							&nexthop->gate.ipv6);
+				break;
+			case NEXTHOP_TYPE_IPV6_IFINDEX:
+				json_object_string_addf(json_gate, "ip", "%pI6",
+							&nexthop->gate.ipv6);
+				json_object_string_add(
+					json_gate, "interfaceName",
+					ifindex2ifname(
+						bnc->ifindex ? bnc->ifindex
+							     : nexthop->ifindex,
+						bgp->vrf_id));
+				break;
+			case NEXTHOP_TYPE_IPV4:
+				json_object_string_addf(json_gate, "ip", "%pI4",
+							&nexthop->gate.ipv4);
+				break;
+			case NEXTHOP_TYPE_IFINDEX:
+				json_object_string_add(
+					json_gate, "interfaceName",
+					ifindex2ifname(
+						bnc->ifindex ? bnc->ifindex
+							     : nexthop->ifindex,
+						bgp->vrf_id));
+				break;
+			case NEXTHOP_TYPE_IPV4_IFINDEX:
+				json_object_string_addf(json_gate, "ip", "%pI4",
+							&nexthop->gate.ipv4);
+				json_object_string_add(
+					json_gate, "interfaceName",
+					ifindex2ifname(
+						bnc->ifindex ? bnc->ifindex
+							     : nexthop->ifindex,
+						bgp->vrf_id));
+				break;
+			case NEXTHOP_TYPE_BLACKHOLE:
+				json_object_boolean_true_add(json_gate,
+							     "unreachable");
+				switch (nexthop->bh_type) {
+				case BLACKHOLE_REJECT:
+					json_object_boolean_true_add(json_gate,
+								     "reject");
+					break;
+				case BLACKHOLE_ADMINPROHIB:
+					json_object_boolean_true_add(
+						json_gate, "adminProhibited");
+					break;
+				case BLACKHOLE_NULL:
+					json_object_boolean_true_add(
+						json_gate, "blackhole");
+					break;
+				case BLACKHOLE_UNSPEC:
+					break;
+				}
+				break;
+			default:
+				break;
+			}
+			json_object_array_add(json_gates, json_gate);
+			continue;
+		}
 		switch (nexthop->type) {
 		case NEXTHOP_TYPE_IPV6:
-			vty_out(vty, "  gate %s\n",
-				inet_ntop(AF_INET6, &nexthop->gate.ipv6, buf,
-					  sizeof(buf)));
+			vty_out(vty, "  gate %pI6\n", &nexthop->gate.ipv6);
 			break;
 		case NEXTHOP_TYPE_IPV6_IFINDEX:
-			vty_out(vty, "  gate %s, if %s\n",
-				inet_ntop(AF_INET6, &nexthop->gate.ipv6, buf,
-					  sizeof(buf)),
+			vty_out(vty, "  gate %pI6, if %s\n",
+				&nexthop->gate.ipv6,
 				ifindex2ifname(bnc->ifindex ? bnc->ifindex
 							    : nexthop->ifindex,
 					       bgp->vrf_id));
 			break;
 		case NEXTHOP_TYPE_IPV4:
-			vty_out(vty, "  gate %s\n",
-				inet_ntop(AF_INET, &nexthop->gate.ipv4, buf,
-					  sizeof(buf)));
+			vty_out(vty, "  gate %pI4\n", &nexthop->gate.ipv4);
 			break;
 		case NEXTHOP_TYPE_IFINDEX:
 			vty_out(vty, "  if %s\n",
@@ -795,9 +947,8 @@ static void bgp_show_nexthops_detail(str
 					       bgp->vrf_id));
 			break;
 		case NEXTHOP_TYPE_IPV4_IFINDEX:
-			vty_out(vty, "  gate %s, if %s\n",
-				inet_ntop(AF_INET, &nexthop->gate.ipv4, buf,
-					  sizeof(buf)),
+			vty_out(vty, "  gate %pI4, if %s\n",
+				&nexthop->gate.ipv4,
 				ifindex2ifname(bnc->ifindex ? bnc->ifindex
 							    : nexthop->ifindex,
 					       bgp->vrf_id));
@@ -810,98 +961,190 @@ static void bgp_show_nexthops_detail(str
 				nexthop->type);
 		}
 	}
+	if (json)
+		json_object_object_add(json, "nexthops", json_gates);
 }
 
 static void bgp_show_nexthop(struct vty *vty, struct bgp *bgp,
-			     struct bgp_nexthop_cache *bnc,
-			     bool specific)
+			     struct bgp_nexthop_cache *bnc, bool specific,
+			     json_object *json)
 {
 	char buf[PREFIX2STR_BUFFER];
 	time_t tbuf;
 	struct peer *peer;
+	json_object *json_last_update = NULL;
+	json_object *json_nexthop = NULL;
 
 	peer = (struct peer *)bnc->nht_info;
 
-	if (bnc->srte_color)
-		vty_out(vty, " SR-TE color %u -", bnc->srte_color);
+	if (json)
+		json_nexthop = json_object_new_object();
+	if (bnc->srte_color) {
+		if (json)
+			json_object_int_add(json_nexthop, "srteColor",
+					    bnc->srte_color);
+		else
+			vty_out(vty, " SR-TE color %u -", bnc->srte_color);
+	}
+	inet_ntop(bnc->prefix.family, &bnc->prefix.u.prefix, buf, sizeof(buf));
 	if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_VALID)) {
-		vty_out(vty, " %s valid [IGP metric %d], #paths %d",
-			inet_ntop(bnc->prefix.family, &bnc->prefix.u.prefix,
-				  buf, sizeof(buf)),
-			bnc->metric, bnc->path_count);
-		if (peer)
-			vty_out(vty, ", peer %s", peer->host);
-		if (bnc->is_evpn_gwip_nexthop)
-			vty_out(vty, " EVPN Gateway IP");
-		vty_out(vty, "\n");
-		bgp_show_nexthops_detail(vty, bgp, bnc);
+		if (json) {
+			json_object_boolean_true_add(json_nexthop, "valid");
+			json_object_boolean_true_add(json_nexthop, "complete");
+			json_object_int_add(json_nexthop, "igpMetric",
+					    bnc->metric);
+			json_object_int_add(json_nexthop, "pathCount",
+					    bnc->path_count);
+			if (peer)
+				json_object_string_add(json_nexthop, "peer",
+						       peer->host);
+			if (bnc->is_evpn_gwip_nexthop)
+				json_object_boolean_true_add(json_nexthop,
+							     "isEvpnGatewayIp");
+		} else {
+			vty_out(vty, " %s valid [IGP metric %d], #paths %d",
+				buf, bnc->metric, bnc->path_count);
+			if (peer)
+				vty_out(vty, ", peer %s", peer->host);
+			if (bnc->is_evpn_gwip_nexthop)
+				vty_out(vty, " EVPN Gateway IP");
+			vty_out(vty, "\n");
+		}
+		bgp_show_nexthops_detail(vty, bgp, bnc, json_nexthop);
 	} else if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_EVPN_INCOMPLETE)) {
-		vty_out(vty,
-			" %s overlay index unresolved [IGP metric %d], #paths %d",
-			inet_ntop(bnc->prefix.family, &bnc->prefix.u.prefix,
-				  buf, sizeof(buf)),
-			bnc->metric, bnc->path_count);
-		if (bnc->is_evpn_gwip_nexthop)
-			vty_out(vty, " EVPN Gateway IP");
-		vty_out(vty, "\n");
-		bgp_show_nexthops_detail(vty, bgp, bnc);
+		if (json) {
+			json_object_boolean_true_add(json_nexthop, "valid");
+			json_object_boolean_false_add(json_nexthop, "complete");
+			json_object_int_add(json_nexthop, "igpMetric",
+					    bnc->metric);
+			json_object_int_add(json_nexthop, "pathCount",
+					    bnc->path_count);
+			if (bnc->is_evpn_gwip_nexthop)
+				json_object_boolean_true_add(json_nexthop,
+							     "isEvpnGatewayIp");
+		} else {
+			vty_out(vty,
+				" %s overlay index unresolved [IGP metric %d], #paths %d",
+				buf, bnc->metric, bnc->path_count);
+			if (bnc->is_evpn_gwip_nexthop)
+				vty_out(vty, " EVPN Gateway IP");
+			vty_out(vty, "\n");
+		}
+		bgp_show_nexthops_detail(vty, bgp, bnc, json_nexthop);
 	} else {
-		vty_out(vty, " %s invalid, #paths %d",
-			inet_ntop(bnc->prefix.family, &bnc->prefix.u.prefix,
-				  buf, sizeof(buf)),
-			bnc->path_count);
-		if (peer)
-			vty_out(vty, ", peer %s", peer->host);
-		if (bnc->is_evpn_gwip_nexthop)
-			vty_out(vty, " EVPN Gateway IP");
-		vty_out(vty, "\n");
-		if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_CONNECTED))
-			vty_out(vty, "  Must be Connected\n");
-		if (!CHECK_FLAG(bnc->flags, BGP_NEXTHOP_REGISTERED))
-			vty_out(vty, "  Is not Registered\n");
+		if (json) {
+			json_object_boolean_false_add(json_nexthop, "valid");
+			json_object_boolean_false_add(json_nexthop, "complete");
+			json_object_int_add(json_nexthop, "pathCount",
+					    bnc->path_count);
+			if (peer)
+				json_object_string_add(json_nexthop, "peer",
+						       peer->host);
+			if (bnc->is_evpn_gwip_nexthop)
+				json_object_boolean_true_add(json_nexthop,
+							     "isEvpnGatewayIp");
+			if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_CONNECTED))
+				json_object_boolean_false_add(json_nexthop,
+							      "isConnected");
+			if (!CHECK_FLAG(bnc->flags, BGP_NEXTHOP_REGISTERED))
+				json_object_boolean_false_add(json_nexthop,
+							      "isRegistered");
+		} else {
+			vty_out(vty, " %s invalid, #paths %d", buf,
+				bnc->path_count);
+			if (peer)
+				vty_out(vty, ", peer %s", peer->host);
+			if (bnc->is_evpn_gwip_nexthop)
+				vty_out(vty, " EVPN Gateway IP");
+			vty_out(vty, "\n");
+			if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_CONNECTED))
+				vty_out(vty, "  Must be Connected\n");
+			if (!CHECK_FLAG(bnc->flags, BGP_NEXTHOP_REGISTERED))
+				vty_out(vty, "  Is not Registered\n");
+		}
 	}
 	tbuf = time(NULL) - (monotime(NULL) - bnc->last_update);
-	vty_out(vty, "  Last update: %s", ctime(&tbuf));
-	vty_out(vty, "\n");
+	if (json) {
+		if (!specific) {
+			json_last_update = json_object_new_object();
+			json_object_int_add(json_last_update, "epoch", tbuf);
+			json_object_string_add(json_last_update, "string",
+					       ctime(&tbuf));
+			json_object_object_add(json_nexthop, "lastUpdate",
+					       json_last_update);
+		} else {
+			json_object_int_add(json_nexthop, "lastUpdate", tbuf);
+		}
+	} else {
+		vty_out(vty, "  Last update: %s", ctime(&tbuf));
+	}
 
 	/* show paths dependent on nexthop, if needed. */
 	if (specific)
-		bgp_show_nexthop_paths(vty, bgp, bnc);
+		bgp_show_nexthop_paths(vty, bgp, bnc, json_nexthop);
+	if (json)
+		json_object_object_add(json, buf, json_nexthop);
 }
 
 static void bgp_show_nexthops(struct vty *vty, struct bgp *bgp,
-			      bool import_table)
+			      bool import_table, json_object *json, afi_t afi,
+			      bool detail)
 {
 	struct bgp_nexthop_cache *bnc;
-	afi_t afi;
 	struct bgp_nexthop_cache_head(*tree)[AFI_MAX];
+	json_object *json_afi = NULL;
+	bool found = false;
 
-	if (import_table)
-		vty_out(vty, "Current BGP import check cache:\n");
-	else
-		vty_out(vty, "Current BGP nexthop cache:\n");
+	if (!json) {
+		if (import_table)
+			vty_out(vty, "Current BGP import check cache:\n");
+		else
+			vty_out(vty, "Current BGP nexthop cache:\n");
+	}
 	if (import_table)
 		tree = &bgp->import_check_table;
 	else
 		tree = &bgp->nexthop_cache_table;
+
+	if (afi == AFI_IP || afi == AFI_IP6) {
+		if (json)
+			json_afi = json_object_new_object();
+		frr_each (bgp_nexthop_cache, &(*tree)[afi], bnc) {
+			bgp_show_nexthop(vty, bgp, bnc, detail, json_afi);
+			found = true;
+		}
+		if (found && json)
+			json_object_object_add(
+				json, (afi == AFI_IP) ? "ipv4" : "ipv6",
+				json_afi);
+		return;
+	}
+
 	for (afi = AFI_IP; afi < AFI_MAX; afi++) {
+		if (json && (afi == AFI_IP || afi == AFI_IP6))
+			json_afi = json_object_new_object();
 		frr_each (bgp_nexthop_cache, &(*tree)[afi], bnc)
-			bgp_show_nexthop(vty, bgp, bnc, false);
+			bgp_show_nexthop(vty, bgp, bnc, detail, json_afi);
+		if (json && (afi == AFI_IP || afi == AFI_IP6))
+			json_object_object_add(
+				json, (afi == AFI_IP) ? "ipv4" : "ipv6",
+				json_afi);
 	}
 }
 
 static int show_ip_bgp_nexthop_table(struct vty *vty, const char *name,
-				     const char *nhopip_str,
-				     bool import_table)
+				     const char *nhopip_str, bool import_table,
+				     json_object *json, afi_t afi, bool detail)
 {
 	struct bgp *bgp;
 
-	if (name)
+	if (name && !strmatch(name, VRF_DEFAULT_NAME))
 		bgp = bgp_lookup_by_name(name);
 	else
 		bgp = bgp_get_default();
 	if (!bgp) {
-		vty_out(vty, "%% No such BGP instance exist\n");
+		if (!json)
+			vty_out(vty, "%% No such BGP instance exist\n");
 		return CMD_WARNING;
 	}
 
@@ -909,42 +1152,70 @@ static int show_ip_bgp_nexthop_table(str
 		struct prefix nhop;
 		struct bgp_nexthop_cache_head (*tree)[AFI_MAX];
 		struct bgp_nexthop_cache *bnc;
+		bool found = false;
+		json_object *json_afi = NULL;
 
 		if (!str2prefix(nhopip_str, &nhop)) {
-			vty_out(vty, "nexthop address is malformed\n");
+			if (!json)
+				vty_out(vty, "nexthop address is malformed\n");
 			return CMD_WARNING;
 		}
 		tree = import_table ? &bgp->import_check_table
 				    : &bgp->nexthop_cache_table;
-		bnc = bnc_find(&(*tree)[family2afi(nhop.family)], &nhop, 0, 0);
-		if (!bnc) {
-			vty_out(vty, "specified nexthop does not have entry\n");
-			return CMD_SUCCESS;
+		if (json)
+			json_afi = json_object_new_object();
+		frr_each (bgp_nexthop_cache, &(*tree)[family2afi(nhop.family)],
+			  bnc) {
+			if (prefix_cmp(&bnc->prefix, &nhop))
+				continue;
+			bgp_show_nexthop(vty, bgp, bnc, true, json_afi);
+			found = true;
 		}
-		bgp_show_nexthop(vty, bgp, bnc, true);
+		if (json)
+			json_object_object_add(
+				json,
+				(family2afi(nhop.family) == AFI_IP) ? "ipv4"
+								    : "ipv6",
+				json_afi);
+		if (!found && !json)
+			vty_out(vty, "nexthop %s does not have entry\n",
+				nhopip_str);
 	} else
-		bgp_show_nexthops(vty, bgp, import_table);
+		bgp_show_nexthops(vty, bgp, import_table, json, afi, detail);
 
 	return CMD_SUCCESS;
 }
 
-static void bgp_show_all_instances_nexthops_vty(struct vty *vty)
+static void bgp_show_all_instances_nexthops_vty(struct vty *vty,
+						json_object *json, afi_t afi,
+						bool detail)
 {
 	struct listnode *node, *nnode;
 	struct bgp *bgp;
+	const char *inst_name;
+	json_object *json_instance = NULL;
 
 	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
-		vty_out(vty, "\nInstance %s:\n",
-			(bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
-				? VRF_DEFAULT_NAME
-				: bgp->name);
-		bgp_show_nexthops(vty, bgp, false);
+		inst_name = (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
+				    ? VRF_DEFAULT_NAME
+				    : bgp->name;
+		if (json)
+			json_instance = json_object_new_object();
+		else
+			vty_out(vty, "\nInstance %s:\n", inst_name);
+
+		bgp_show_nexthops(vty, bgp, false, json_instance, afi, detail);
+
+		if (json)
+			json_object_object_add(json, inst_name, json_instance);
 	}
 }
 
-DEFUN (show_ip_bgp_nexthop,
+#include "bgpd/bgp_nexthop_clippy.c"
+
+DEFPY (show_ip_bgp_nexthop,
        show_ip_bgp_nexthop_cmd,
-       "show [ip] bgp [<view|vrf> VIEWVRFNAME] nexthop [<A.B.C.D|X:X::X:X>] [detail]",
+       "show [ip] bgp [<view|vrf> VIEWVRFNAME$vrf] nexthop [<A.B.C.D|X:X::X:X>$nhop] [<ipv4$afi [A.B.C.D$nhop]|ipv6$afi [X:X::X:X$nhop]>] [detail$detail] [json$uj]",
        SHOW_STR
        IP_STR
        BGP_STR
@@ -952,54 +1223,85 @@ DEFUN (show_ip_bgp_nexthop,
        "BGP nexthop table\n"
        "IPv4 nexthop address\n"
        "IPv6 nexthop address\n"
-       "Show detailed information\n")
+       "BGP nexthop IPv4 table\n"
+       "IPv4 nexthop address\n"
+       "BGP nexthop IPv6 table\n"
+       "IPv6 nexthop address\n"
+       "Show detailed information\n"
+       JSON_STR)
 {
-	int idx = 0;
-	int nh_idx = 0;
-	char *vrf = NULL;
-	char *nhop_ip = NULL;
+	int rc = 0;
+	json_object *json = NULL;
+	afi_t afiz = AFI_UNSPEC;
 
-	if (argv_find(argv, argc, "view", &idx)
-	    || argv_find(argv, argc, "vrf", &idx))
-		vrf = argv[++idx]->arg;
+	if (uj)
+		json = json_object_new_object();
 
-	if (argv_find(argv, argc, "A.B.C.D", &nh_idx)
-	    || argv_find(argv, argc, "X:X::X:X", &nh_idx))
-		nhop_ip = argv[nh_idx]->arg;
+	if (afi)
+		afiz = bgp_vty_afi_from_str(afi);
 
-	return show_ip_bgp_nexthop_table(vty, vrf, nhop_ip, false);
+	rc = show_ip_bgp_nexthop_table(vty, vrf, nhop_str, false, json, afiz,
+				       detail);
+
+	if (uj)
+		vty_json(vty, json);
+
+	return rc;
 }
 
-DEFUN (show_ip_bgp_import_check,
+DEFPY (show_ip_bgp_import_check,
        show_ip_bgp_import_check_cmd,
-       "show [ip] bgp [<view|vrf> VIEWVRFNAME] import-check-table [detail]",
+       "show [ip] bgp [<view|vrf> VIEWVRFNAME$vrf] import-check-table [detail$detail] [json$uj]",
        SHOW_STR
        IP_STR
        BGP_STR
        BGP_INSTANCE_HELP_STR
        "BGP import check table\n"
-       "Show detailed information\n")
+       "Show detailed information\n"
+       JSON_STR)
 {
-	int idx = 0;
-	char *vrf = NULL;
+	int rc = 0;
+	json_object *json = NULL;
+
+	if (uj)
+		json = json_object_new_object();
 
-	if (argv_find(argv, argc, "view", &idx)
-	    || argv_find(argv, argc, "vrf", &idx))
-		vrf = argv[++idx]->arg;
+	rc = show_ip_bgp_nexthop_table(vty, vrf, NULL, true, json, AFI_UNSPEC,
+				       detail);
 
-	return show_ip_bgp_nexthop_table(vty, vrf, NULL, true);
+	if (uj)
+		vty_json(vty, json);
+
+	return rc;
 }
 
-DEFUN (show_ip_bgp_instance_all_nexthop,
+DEFPY (show_ip_bgp_instance_all_nexthop,
        show_ip_bgp_instance_all_nexthop_cmd,
-       "show [ip] bgp <view|vrf> all nexthop",
+       "show [ip] bgp <view|vrf> all nexthop [<ipv4|ipv6>$afi] [detail$detail] [json$uj]",
        SHOW_STR
        IP_STR
        BGP_STR
        BGP_INSTANCE_ALL_HELP_STR
-       "BGP nexthop table\n")
+       "BGP nexthop table\n"
+       "BGP IPv4 nexthop table\n"
+       "BGP IPv6 nexthop table\n"
+       "Show detailed information\n"
+       JSON_STR)
 {
-	bgp_show_all_instances_nexthops_vty(vty);
+	json_object *json = NULL;
+	afi_t afiz = AFI_UNSPEC;
+
+	if (uj)
+		json = json_object_new_object();
+
+	if (afi)
+		afiz = bgp_vty_afi_from_str(afi);
+
+	bgp_show_all_instances_nexthops_vty(vty, json, afiz, detail);
+
+	if (uj)
+		vty_json(vty, json);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/bgpd/bgp_nexthop.h frr-frr-8.5/bgpd/bgp_nexthop.h
--- frr-frr-8.4.2/bgpd/bgp_nexthop.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_nexthop.h	2023-03-13 20:01:47.000000000 +0600
@@ -166,7 +166,7 @@ extern void bgp_scan_finish(struct bgp *
 extern void bgp_scan_vty_init(void);
 extern void bgp_address_init(struct bgp *bgp);
 extern void bgp_address_destroy(struct bgp *bgp);
-extern void bgp_tip_add(struct bgp *bgp, struct in_addr *tip);
+extern bool bgp_tip_add(struct bgp *bgp, struct in_addr *tip);
 extern void bgp_tip_del(struct bgp *bgp, struct in_addr *tip);
 extern void bgp_tip_hash_init(struct bgp *bgp);
 extern void bgp_tip_hash_destroy(struct bgp *bgp);
diff -urpN frr-frr-8.4.2/bgpd/bgp_nht.c frr-frr-8.5/bgpd/bgp_nht.c
--- frr-frr-8.4.2/bgpd/bgp_nht.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_nht.c	2023-03-13 20:01:47.000000000 +0600
@@ -139,7 +139,8 @@ static int bgp_isvalid_nexthop_for_mpls(
 	 */
 	return (bgp_zebra_num_connects() == 0 ||
 		(bnc && (bnc->nexthop_num > 0 &&
-			 (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_LABELED_VALID) ||
+			 (CHECK_FLAG(path->flags, BGP_PATH_ACCEPT_OWN) ||
+			  CHECK_FLAG(bnc->flags, BGP_NEXTHOP_LABELED_VALID) ||
 			  bnc->bgp->srv6_enabled ||
 			  bgp_isvalid_nexthop_for_ebgp(bnc, path) ||
 			  bgp_isvalid_nexthop_for_mplsovergre(bnc, path)))));
@@ -211,6 +212,37 @@ void bgp_replace_nexthop_by_peer(struct
 		bnct->nht_info = to;
 }
 
+/*
+ * Returns the bnc whose bnc->nht_info matches the LL peer by
+ * looping through the IPv6 nexthop table
+ */
+static struct bgp_nexthop_cache *
+bgp_find_ipv6_nexthop_matching_peer(struct peer *peer)
+{
+	struct bgp_nexthop_cache *bnc;
+
+	frr_each (bgp_nexthop_cache, &peer->bgp->nexthop_cache_table[AFI_IP6],
+		  bnc) {
+		if (bnc->nht_info == peer) {
+			if (BGP_DEBUG(nht, NHT)) {
+				zlog_debug(
+					"Found bnc: %pFX(%u)(%u)(%p) for peer: %s(%s) %p",
+					&bnc->prefix, bnc->ifindex,
+					bnc->srte_color, bnc, peer->host,
+					peer->bgp->name_pretty, peer);
+			}
+			return bnc;
+		}
+	}
+
+	if (BGP_DEBUG(nht, NHT))
+		zlog_debug(
+			"Could not find bnc for peer %s(%s) %p in v6 nexthop table",
+			peer->host, peer->bgp->name_pretty, peer);
+
+	return NULL;
+}
+
 void bgp_unlink_nexthop_by_peer(struct peer *peer)
 {
 	struct prefix p;
@@ -218,15 +250,30 @@ void bgp_unlink_nexthop_by_peer(struct p
 	afi_t afi = family2afi(peer->su.sa.sa_family);
 	ifindex_t ifindex = 0;
 
-	if (!sockunion2hostprefix(&peer->su, &p))
-		return;
-	/*
-	 * Gather the ifindex for if up/down events to be
-	 * tagged into this fun
-	 */
-	if (afi == AFI_IP6 && IN6_IS_ADDR_LINKLOCAL(&peer->su.sin6.sin6_addr))
-		ifindex = peer->su.sin6.sin6_scope_id;
-	bnc = bnc_find(&peer->bgp->nexthop_cache_table[afi], &p, 0, ifindex);
+	if (!sockunion2hostprefix(&peer->su, &p)) {
+		/*
+		 * In scenarios where unnumbered BGP session is brought
+		 * down by shutting down the interface before unconfiguring
+		 * the BGP neighbor, neighbor information in peer->su.sa
+		 * will be cleared when the interface is shutdown. So
+		 * during the deletion of unnumbered bgp peer, above check
+		 * will return true. Therefore, in this case,BGP needs to
+		 * find the bnc whose bnc->nht_info matches the
+		 * peer being deleted and free it.
+		 */
+		bnc = bgp_find_ipv6_nexthop_matching_peer(peer);
+	} else {
+		/*
+		 * Gather the ifindex for if up/down events to be
+		 * tagged into this fun
+		 */
+		if (afi == AFI_IP6 &&
+		    IN6_IS_ADDR_LINKLOCAL(&peer->su.sin6.sin6_addr))
+			ifindex = peer->su.sin6.sin6_scope_id;
+		bnc = bnc_find(&peer->bgp->nexthop_cache_table[afi], &p, 0,
+			       ifindex);
+	}
+
 	if (!bnc)
 		return;
 
@@ -247,6 +294,7 @@ int bgp_find_or_add_nexthop(struct bgp *
 {
 	struct bgp_nexthop_cache_head *tree = NULL;
 	struct bgp_nexthop_cache *bnc;
+	struct bgp_path_info *bpi_ultimate;
 	struct prefix p;
 	uint32_t srte_color = 0;
 	int is_bgp_static_route = 0;
@@ -291,7 +339,7 @@ int bgp_find_or_add_nexthop(struct bgp *
 		 * Gather the ifindex for if up/down events to be
 		 * tagged into this fun
 		 */
-		if (afi == AFI_IP6 &&
+		if (afi == AFI_IP6 && peer->conf_if &&
 		    IN6_IS_ADDR_LINKLOCAL(&peer->su.sin6.sin6_addr)) {
 			ifindex = peer->su.sin6.sin6_scope_id;
 			if (ifindex == 0) {
@@ -403,10 +451,12 @@ int bgp_find_or_add_nexthop(struct bgp *
 		/* updates NHT pi list reference */
 		path_nh_map(pi, bnc, true);
 
+		bpi_ultimate = bgp_get_imported_bpi_ultimate(pi);
 		if (CHECK_FLAG(bnc->flags, BGP_NEXTHOP_VALID) && bnc->metric)
-			(bgp_path_info_extra_get(pi))->igpmetric = bnc->metric;
-		else if (pi->extra)
-			pi->extra->igpmetric = 0;
+			(bgp_path_info_extra_get(bpi_ultimate))->igpmetric =
+				bnc->metric;
+		else if (bpi_ultimate->extra)
+			bpi_ultimate->extra->igpmetric = 0;
 	} else if (peer) {
 		/*
 		 * Let's not accidentally save the peer data for a peer
@@ -442,6 +492,15 @@ void bgp_delete_connected_nexthop(afi_t
 	if (!peer)
 		return;
 
+	/*
+	 * In case the below check evaluates true and if
+	 * the bnc has not been freed at this point, then
+	 * we might have to do something similar to what's
+	 * done in bgp_unlink_nexthop_by_peer(). Since
+	 * bgp_unlink_nexthop_by_peer() loops through the
+	 * nodes of V6 nexthop cache to find the bnc, it is
+	 * currently not being called here.
+	 */
 	if (!sockunion2hostprefix(&peer->su, &p))
 		return;
 	/*
@@ -1067,6 +1126,7 @@ void evaluate_paths(struct bgp_nexthop_c
 {
 	struct bgp_dest *dest;
 	struct bgp_path_info *path;
+	struct bgp_path_info *bpi_ultimate;
 	int afi;
 	struct peer *peer = (struct peer *)bnc->nht_info;
 	struct bgp_table *table;
@@ -1166,11 +1226,12 @@ void evaluate_paths(struct bgp_nexthop_c
 
 		/* Copy the metric to the path. Will be used for bestpath
 		 * computation */
+		bpi_ultimate = bgp_get_imported_bpi_ultimate(path);
 		if (bgp_isvalid_nexthop(bnc) && bnc->metric)
-			(bgp_path_info_extra_get(path))->igpmetric =
+			(bgp_path_info_extra_get(bpi_ultimate))->igpmetric =
 				bnc->metric;
-		else if (path->extra)
-			path->extra->igpmetric = 0;
+		else if (bpi_ultimate->extra)
+			bpi_ultimate->extra->igpmetric = 0;
 
 		if (CHECK_FLAG(bnc->change_flags, BGP_NEXTHOP_METRIC_CHANGED)
 		    || CHECK_FLAG(bnc->change_flags, BGP_NEXTHOP_CHANGED)
@@ -1389,14 +1450,21 @@ static uint32_t bgp_l3nhg_start;
 static void bgp_l3nhg_add_cb(const char *name)
 {
 }
+
+static void bgp_l3nhg_modify_cb(const struct nexthop_group_cmd *nhgc)
+{
+}
+
 static void bgp_l3nhg_add_nexthop_cb(const struct nexthop_group_cmd *nhgc,
 				     const struct nexthop *nhop)
 {
 }
+
 static void bgp_l3nhg_del_nexthop_cb(const struct nexthop_group_cmd *nhgc,
 				     const struct nexthop *nhop)
 {
 }
+
 static void bgp_l3nhg_del_cb(const char *name)
 {
 }
@@ -1409,8 +1477,9 @@ static void bgp_l3nhg_zebra_init(void)
 
 	bgp_l3nhg_zebra_inited = true;
 	bgp_l3nhg_start = zclient_get_nhg_start(ZEBRA_ROUTE_BGP);
-	nexthop_group_init(bgp_l3nhg_add_cb, bgp_l3nhg_add_nexthop_cb,
-			   bgp_l3nhg_del_nexthop_cb, bgp_l3nhg_del_cb);
+	nexthop_group_init(bgp_l3nhg_add_cb, bgp_l3nhg_modify_cb,
+			   bgp_l3nhg_add_nexthop_cb, bgp_l3nhg_del_nexthop_cb,
+			   bgp_l3nhg_del_cb);
 }
 
 
diff -urpN frr-frr-8.4.2/bgpd/bgp_open.c frr-frr-8.5/bgpd/bgp_open.c
--- frr-frr-8.4.2/bgpd/bgp_open.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_open.c	2023-03-13 20:01:47.000000000 +0600
@@ -357,6 +357,7 @@ static void bgp_capability_orf_not_suppo
 }
 
 static const struct message orf_type_str[] = {
+	{ORF_TYPE_RESERVED, "Reserved"},
 	{ORF_TYPE_PREFIX, "Prefixlist"},
 	{ORF_TYPE_PREFIX_OLD, "Prefixlist (old)"},
 	{0}};
@@ -433,6 +434,12 @@ static int bgp_capability_orf_entry(stru
 		switch (hdr->code) {
 		case CAPABILITY_CODE_ORF:
 			switch (type) {
+			case ORF_TYPE_RESERVED:
+				if (bgp_debug_neighbor_events(peer))
+					zlog_debug(
+						"%s Addr-family %d/%d has reserved ORF type, ignoring",
+						peer->host, afi, safi);
+				break;
 			case ORF_TYPE_PREFIX:
 				break;
 			default:
@@ -443,6 +450,12 @@ static int bgp_capability_orf_entry(stru
 			break;
 		case CAPABILITY_CODE_ORF_OLD:
 			switch (type) {
+			case ORF_TYPE_RESERVED:
+				if (bgp_debug_neighbor_events(peer))
+					zlog_debug(
+						"%s Addr-family %d/%d has reserved ORF type, ignoring",
+						peer->host, afi, safi);
+				break;
 			case ORF_TYPE_PREFIX_OLD:
 				break;
 			default:
@@ -1116,13 +1129,6 @@ static int bgp_capability_parse(struct p
 	return 0;
 }
 
-static int bgp_auth_parse(struct peer *peer, size_t length)
-{
-	bgp_notify_send(peer, BGP_NOTIFY_OPEN_ERR,
-			BGP_NOTIFY_OPEN_AUTH_FAILURE);
-	return -1;
-}
-
 static bool strict_capability_same(struct peer *peer)
 {
 	int i, j;
@@ -1326,17 +1332,11 @@ int bgp_open_option_parse(struct peer *p
 			zlog_debug(
 				"%s rcvd OPEN w/ optional parameter type %u (%s) len %u",
 				peer->host, opt_type,
-				opt_type == BGP_OPEN_OPT_AUTH
-					? "Authentication"
-					: opt_type == BGP_OPEN_OPT_CAP
-						  ? "Capability"
-						  : "Unknown",
+				opt_type == BGP_OPEN_OPT_CAP ? "Capability"
+							     : "Unknown",
 				opt_length);
 
 		switch (opt_type) {
-		case BGP_OPEN_OPT_AUTH:
-			ret = bgp_auth_parse(peer, opt_length);
-			break;
 		case BGP_OPEN_OPT_CAP:
 			ret = bgp_capability_parse(peer, opt_length,
 						   mp_capability, &error);
@@ -1645,7 +1645,7 @@ uint16_t bgp_open_capability(struct stre
 	iana_safi_t pkt_safi = IANA_SAFI_UNICAST;
 	as_t local_as;
 	uint8_t afi_safi_count = 0;
-	int adv_addpath_tx = 0;
+	bool adv_addpath_tx = false;
 
 	/* Non-Ext OP Len. */
 	cp = stream_get_endp(s);
@@ -1784,7 +1784,17 @@ uint16_t bgp_open_capability(struct stre
 			 * will use it is
 			 * configured */
 			if (peer->addpath_type[afi][safi] != BGP_ADDPATH_NONE)
-				adv_addpath_tx = 1;
+				adv_addpath_tx = true;
+
+			/* If we have enabled labeled unicast, we MUST check
+			 * against unicast SAFI because addpath IDs are
+			 * allocated under unicast SAFI, the same as the RIB
+			 * is managed in unicast SAFI.
+			 */
+			if (safi == SAFI_LABELED_UNICAST)
+				if (peer->addpath_type[afi][SAFI_UNICAST] !=
+				    BGP_ADDPATH_NONE)
+					adv_addpath_tx = true;
 		}
 	}
 
@@ -1825,6 +1835,10 @@ uint16_t bgp_open_capability(struct stre
 				SET_FLAG(flags, BGP_ADDPATH_TX);
 				SET_FLAG(peer->af_cap[afi][safi],
 					 PEER_CAP_ADDPATH_AF_TX_ADV);
+				if (safi == SAFI_LABELED_UNICAST)
+					SET_FLAG(
+						peer->af_cap[afi][SAFI_UNICAST],
+						PEER_CAP_ADDPATH_AF_TX_ADV);
 			} else {
 				UNSET_FLAG(peer->af_cap[afi][safi],
 					   PEER_CAP_ADDPATH_AF_TX_ADV);
diff -urpN frr-frr-8.4.2/bgpd/bgp_open.h frr-frr-8.5/bgpd/bgp_open.h
--- frr-frr-8.4.2/bgpd/bgp_open.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_open.h	2023-03-13 20:01:47.000000000 +0600
@@ -76,6 +76,7 @@ struct graceful_restart_af {
 /* Cooperative Route Filtering Capability.  */
 
 /* ORF Type */
+#define ORF_TYPE_RESERVED               0
 #define ORF_TYPE_PREFIX                64
 #define ORF_TYPE_PREFIX_OLD           128
 
diff -urpN frr-frr-8.4.2/bgpd/bgp_packet.c frr-frr-8.5/bgpd/bgp_packet.c
--- frr-frr-8.4.2/bgpd/bgp_packet.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_packet.c	2023-03-13 20:01:47.000000000 +0600
@@ -487,6 +487,16 @@ void bgp_generate_updgrp_packets(struct
 	if (peer->t_routeadv)
 		return;
 
+	/*
+	 * Since the following is a do while loop
+	 * let's stop adding to the outq if we are
+	 * already at the limit.
+	 */
+	if (peer->obuf->count >= bm->outq_limit) {
+		bgp_write_proceed_actions(peer);
+		return;
+	}
+
 	do {
 		enum bgp_af_index index;
 
@@ -609,7 +619,8 @@ void bgp_generate_updgrp_packets(struct
 			bgp_packet_add(peer, s);
 			bpacket_queue_advance_peer(paf);
 		}
-	} while (s && (++generated < wpq));
+	} while (s && (++generated < wpq) &&
+		 (peer->obuf->count <= bm->outq_limit));
 
 	if (generated)
 		bgp_writes_on(peer);
@@ -979,10 +990,11 @@ static void bgp_notify_send_internal(str
 
 		peer->notify.code = bgp_notify.code;
 		peer->notify.subcode = bgp_notify.subcode;
+		peer->notify.length = bgp_notify.length;
 
 		if (bgp_notify.length && data) {
-			bgp_notify.data =
-				XMALLOC(MTYPE_TMP, bgp_notify.length * 3);
+			bgp_notify.data = XMALLOC(MTYPE_BGP_NOTIFICATION,
+						  bgp_notify.length * 3);
 			for (i = 0; i < bgp_notify.length; i++)
 				if (first) {
 					snprintf(c, sizeof(c), " %02x",
@@ -1002,7 +1014,15 @@ static void bgp_notify_send_internal(str
 		bgp_notify_print(peer, &bgp_notify, "sending", hard_reset);
 
 		if (bgp_notify.data) {
-			XFREE(MTYPE_TMP, bgp_notify.data);
+			if (data) {
+				XFREE(MTYPE_BGP_NOTIFICATION,
+				      peer->notify.data);
+				peer->notify.data = XCALLOC(
+					MTYPE_BGP_NOTIFICATION, datalen);
+				memcpy(peer->notify.data, data, datalen);
+			}
+
+			XFREE(MTYPE_BGP_NOTIFICATION, bgp_notify.data);
 			bgp_notify.length = 0;
 		}
 	}
@@ -1011,9 +1031,12 @@ static void bgp_notify_send_internal(str
 	if (code == BGP_NOTIFY_CEASE) {
 		if (sub_code == BGP_NOTIFY_CEASE_ADMIN_RESET)
 			peer->last_reset = PEER_DOWN_USER_RESET;
-		else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN)
-			peer->last_reset = PEER_DOWN_USER_SHUTDOWN;
-		else
+		else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN) {
+			if (CHECK_FLAG(peer->sflags, PEER_STATUS_RTT_SHUTDOWN))
+				peer->last_reset = PEER_DOWN_RTT_SHUTDOWN;
+			else
+				peer->last_reset = PEER_DOWN_USER_SHUTDOWN;
+		} else
 			peer->last_reset = PEER_DOWN_NOTIFY_SEND;
 	} else
 		peer->last_reset = PEER_DOWN_NOTIFY_SEND;
@@ -1749,15 +1772,24 @@ static int bgp_keepalive_receive(struct
 	/* If the peer's RTT is higher than expected, shutdown
 	 * the peer automatically.
 	 */
-	if (CHECK_FLAG(peer->flags, PEER_FLAG_RTT_SHUTDOWN)
-	    && peer->rtt > peer->rtt_expected) {
+	if (!CHECK_FLAG(peer->flags, PEER_FLAG_RTT_SHUTDOWN))
+		return Receive_KEEPALIVE_message;
 
+	if (peer->rtt > peer->rtt_expected) {
 		peer->rtt_keepalive_rcv++;
 
 		if (peer->rtt_keepalive_rcv > peer->rtt_keepalive_conf) {
-			zlog_warn(
-				"%s shutdown due to high round-trip-time (%dms > %dms)",
-				peer->host, peer->rtt, peer->rtt_expected);
+			char rtt_shutdown_reason[BUFSIZ] = {};
+
+			snprintfrr(
+				rtt_shutdown_reason,
+				sizeof(rtt_shutdown_reason),
+				"shutdown due to high round-trip-time (%dms > %dms, hit %u times)",
+				peer->rtt, peer->rtt_expected,
+				peer->rtt_keepalive_rcv);
+			zlog_warn("%s %s", peer->host, rtt_shutdown_reason);
+			SET_FLAG(peer->sflags, PEER_STATUS_RTT_SHUTDOWN);
+			peer_tx_shutdown_message_set(peer, rtt_shutdown_reason);
 			peer_flag_set(peer, PEER_FLAG_SHUTDOWN);
 		}
 	} else {
@@ -2001,7 +2033,8 @@ static int bgp_update_receive(struct pee
 			break;
 		case NLRI_WITHDRAW:
 		case NLRI_MP_WITHDRAW:
-			nlri_ret = bgp_nlri_parse(peer, &attr, &nlris[i], 1);
+			nlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,
+						  &nlris[i], 1);
 			break;
 		default:
 			nlri_ret = BGP_NLRI_PARSE_ERROR;
diff -urpN frr-frr-8.4.2/bgpd/bgp_pbr.c frr-frr-8.5/bgpd/bgp_pbr.c
--- frr-frr-8.4.2/bgpd/bgp_pbr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_pbr.c	2023-03-13 20:01:47.000000000 +0600
@@ -1636,9 +1636,8 @@ void bgp_pbr_print_policy_route(struct b
 				ptr_ip = &api->actions[i].u.zr.redirect_ip_v4;
 			else
 				ptr_ip = &api->actions[i].u.zr.redirect_ip_v6;
-			if (inet_ntop(afi2family(api->afi),
-				      ptr_ip, local_buff,
-				      INET6_ADDRSTRLEN) != NULL) {
+			if (inet_ntop(afi2family(api->afi), ptr_ip, local_buff,
+				      sizeof(local_buff)) != NULL) {
 				delta = snprintf(ptr, len,
 					  "@redirect ip nh %s", local_buff);
 				len -= delta;
diff -urpN frr-frr-8.4.2/bgpd/bgp_regex.h frr-frr-8.5/bgpd/bgp_regex.h
--- frr-frr-8.4.2/bgpd/bgp_regex.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_regex.h	2023-03-13 20:01:47.000000000 +0600
@@ -18,19 +18,24 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef _QUAGGA_BGP_REGEX_H
-#define _QUAGGA_BGP_REGEX_H
+#ifndef _FRR_BGP_REGEX_H
+#define _FRR_BGP_REGEX_H
 
 #include <zebra.h>
 
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 
 extern void bgp_regex_free(regex_t *regex);
 extern regex_t *bgp_regcomp(const char *str);
 extern int bgp_regexec(regex_t *regex, struct aspath *aspath);
 
-#endif /* _QUAGGA_BGP_REGEX_H */
+#endif /* _FRR_BGP_REGEX_H */
diff -urpN frr-frr-8.4.2/bgpd/bgp_route.c frr-frr-8.5/bgpd/bgp_route.c
--- frr-frr-8.4.2/bgpd/bgp_route.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_route.c	2023-03-13 20:01:47.000000000 +0600
@@ -89,9 +89,7 @@
 #include "bgpd/bgp_flowspec_util.h"
 #include "bgpd/bgp_pbr.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_route_clippy.c"
-#endif
 
 DEFINE_HOOK(bgp_snmp_update_stats,
 	    (struct bgp_node *rn, struct bgp_path_info *pi, bool added),
@@ -102,10 +100,6 @@ DEFINE_HOOK(bgp_rpki_prefix_status,
 	     const struct prefix *prefix),
 	    (peer, attr, prefix));
 
-/* Render dest to prefix_rd based on safi */
-static const struct prefix_rd *bgp_rd_from_dest(const struct bgp_dest *dest,
-						safi_t safi);
-
 /* Extern from bgp_dump.c */
 extern const char *bgp_origin_str[];
 extern const char *bgp_origin_long_str[];
@@ -282,8 +276,10 @@ struct bgp_path_info_extra *bgp_path_inf
 }
 
 /* Free bgp route information. */
-static void bgp_path_info_free(struct bgp_path_info *path)
+void bgp_path_info_free_with_caller(const char *name,
+				    struct bgp_path_info *path)
 {
+	frrtrace(2, frr_bgp, bgp_path_info_free, path, name);
 	bgp_attr_unintern(&path->attr);
 
 	bgp_unlink_nexthop(path);
@@ -394,8 +390,10 @@ static int bgp_dest_set_defer_flag(struc
 	return -1;
 }
 
-void bgp_path_info_add(struct bgp_dest *dest, struct bgp_path_info *pi)
+void bgp_path_info_add_with_caller(const char *name, struct bgp_dest *dest,
+				   struct bgp_path_info *pi)
 {
+	frrtrace(3, frr_bgp, bgp_path_info_add, dest, pi, name);
 	struct bgp_path_info *top;
 
 	top = bgp_dest_get_bgp_path_info(dest);
@@ -874,6 +872,79 @@ static int bgp_path_info_cmp(struct bgp
 		return 0;
 	}
 
+	/* If a BGP speaker supports ACCEPT_OWN and is configured for the
+	 * extensions defined in this document, the following step is inserted
+	 * after the LOCAL_PREF comparison step in the BGP decision process:
+	 *	When comparing a pair of routes for a BGP destination, the
+	 *	route with the ACCEPT_OWN community attached is preferred over
+	 *	the route that does not have the community.
+	 * This extra step MUST only be invoked during the best path selection
+	 * process of VPN-IP routes.
+	 */
+	if (safi == SAFI_MPLS_VPN &&
+	    (CHECK_FLAG(new->peer->af_flags[afi][safi], PEER_FLAG_ACCEPT_OWN) ||
+	     CHECK_FLAG(exist->peer->af_flags[afi][safi],
+			PEER_FLAG_ACCEPT_OWN))) {
+		bool new_accept_own = false;
+		bool exist_accept_own = false;
+		uint32_t accept_own = COMMUNITY_ACCEPT_OWN;
+
+		if (newattr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))
+			new_accept_own = community_include(
+				bgp_attr_get_community(newattr), accept_own);
+		if (existattr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))
+			exist_accept_own = community_include(
+				bgp_attr_get_community(existattr), accept_own);
+
+		if (new_accept_own && !exist_accept_own) {
+			*reason = bgp_path_selection_accept_own;
+			if (debug)
+				zlog_debug(
+					"%s: %s wins over %s due to accept-own",
+					pfx_buf, new_buf, exist_buf);
+			return 1;
+		}
+
+		if (!new_accept_own && exist_accept_own) {
+			*reason = bgp_path_selection_accept_own;
+			if (debug)
+				zlog_debug(
+					"%s: %s loses to %s due to accept-own",
+					pfx_buf, new_buf, exist_buf);
+			return 0;
+		}
+	}
+
+	/* Tie-breaker - AIGP (Metric TLV) attribute */
+	if (CHECK_FLAG(newattr->flag, ATTR_FLAG_BIT(BGP_ATTR_AIGP)) &&
+	    CHECK_FLAG(existattr->flag, ATTR_FLAG_BIT(BGP_ATTR_AIGP)) &&
+	    CHECK_FLAG(bgp->flags, BGP_FLAG_COMPARE_AIGP)) {
+		uint64_t new_aigp = bgp_attr_get_aigp_metric(newattr);
+		uint64_t exist_aigp = bgp_attr_get_aigp_metric(existattr);
+
+		if (new_aigp < exist_aigp) {
+			*reason = bgp_path_selection_aigp;
+			if (debug)
+				zlog_debug(
+					"%s: %s wins over %s due to AIGP %" PRIu64
+					" < %" PRIu64,
+					pfx_buf, new_buf, exist_buf, new_aigp,
+					exist_aigp);
+			return 1;
+		}
+
+		if (new_aigp > exist_aigp) {
+			*reason = bgp_path_selection_aigp;
+			if (debug)
+				zlog_debug(
+					"%s: %s loses to %s due to AIGP %" PRIu64
+					" > %" PRIu64,
+					pfx_buf, new_buf, exist_buf, new_aigp,
+					exist_aigp);
+			return 0;
+		}
+	}
+
 	/* 3. Local route check. We prefer:
 	 *  - BGP_ROUTE_STATIC
 	 *  - BGP_ROUTE_AGGREGATE
@@ -1142,9 +1213,18 @@ static int bgp_path_info_cmp(struct bgp
 		/* If one path has a label but the other does not, do not treat
 		 * them as equals for multipath
 		 */
-		if ((new->extra &&bgp_is_valid_label(&new->extra->label[0]))
-		    != (exist->extra
-			&& bgp_is_valid_label(&exist->extra->label[0]))) {
+		int newl, existl;
+
+		newl = existl = 0;
+
+		if (new->extra)
+			newl = new->extra->num_labels;
+		if (exist->extra)
+			existl = exist->extra->num_labels;
+		if (((new->extra &&bgp_is_valid_label(&new->extra->label[0])) !=
+		     (exist->extra &&
+		      bgp_is_valid_label(&exist->extra->label[0]))) ||
+		    (newl != existl)) {
 			if (debug)
 				zlog_debug(
 					"%s: %s and %s cannot be multipath, one has a label while the other does not",
@@ -1969,11 +2049,9 @@ bool subgroup_announce_check(struct bgp_
 	/* If this is not the bestpath then check to see if there is an enabled
 	 * addpath
 	 * feature that requires us to advertise it */
-	if (!CHECK_FLAG(pi->flags, BGP_PATH_SELECTED)) {
-		if (!bgp_addpath_tx_path(peer->addpath_type[afi][safi], pi)) {
+	if (!CHECK_FLAG(pi->flags, BGP_PATH_SELECTED))
+		if (!bgp_addpath_capable(pi, peer, afi, safi))
 			return false;
-		}
-	}
 
 	/* Aggregate-address suppress check. */
 	if (bgp_path_suppressed(pi) && !UNSUPPRESS_MAP_NAME(filter))
@@ -2069,18 +2147,18 @@ bool subgroup_announce_check(struct bgp_
 	}
 
 	/* AS path loop check. */
-	if (onlypeer && onlypeer->as_path_loop_detection
-	    && aspath_loop_check(piattr->aspath, onlypeer->as)) {
+	if (peer->as_path_loop_detection &&
+	    aspath_loop_check(piattr->aspath, peer->as)) {
 		if (bgp_debug_update(NULL, p, subgrp->update_group, 0))
 			zlog_debug(
 				"%pBP [Update:SEND] suppress announcement to peer AS %u that is part of AS path.",
-				onlypeer, onlypeer->as);
+				peer, peer->as);
 		return false;
 	}
 
 	/* If we're a CONFED we need to loop check the CONFED ID too */
 	if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {
-		if (aspath_loop_check(piattr->aspath, bgp->confed_id)) {
+		if (aspath_loop_check_confed(piattr->aspath, bgp->confed_id)) {
 			if (bgp_debug_update(NULL, p, subgrp->update_group, 0))
 				zlog_debug(
 					"%pBP [Update:SEND] suppress announcement to peer AS %u is AS path.",
@@ -2204,8 +2282,12 @@ bool subgroup_announce_check(struct bgp_
 			&& peer->shared_network
 			&& (from == bgp->peer_self
 			    || peer->sort == BGP_PEER_EBGP))) {
-			attr->mp_nexthop_len =
-				BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL;
+			if (safi == SAFI_MPLS_VPN)
+				attr->mp_nexthop_len =
+					BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL;
+			else
+				attr->mp_nexthop_len =
+					BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL;
 		}
 
 		/* Clear off link-local nexthop in source, whenever it is not
@@ -2466,8 +2548,8 @@ bool subgroup_announce_check(struct bgp_
 
 			if (bgp_debug_update(NULL, p, subgrp->update_group, 0))
 				zlog_debug(
-					"%s: BGP_PATH_ANNC_NH_SELF, family=%s",
-					__func__, family2str(family));
+					"%s: %pFX BGP_PATH_ANNC_NH_SELF, family=%s",
+					__func__, p, family2str(family));
 			subgroup_announce_reset_nhop(family, attr);
 			nh_reset = true;
 		}
@@ -2536,12 +2618,7 @@ static void bgp_route_select_timer_expir
 	safi = info->safi;
 	bgp = info->bgp;
 
-	if (BGP_DEBUG(update, UPDATE_OUT))
-		zlog_debug("afi %d, safi %d : route select timer expired", afi,
-			   safi);
-
 	bgp->gr_info[afi][safi].t_route_select = NULL;
-
 	XFREE(MTYPE_TMP, info);
 
 	/* Best path selection */
@@ -2590,9 +2667,12 @@ void bgp_best_selection(struct bgp *bgp,
 				continue;
 			if (BGP_PATH_HOLDDOWN(pi1))
 				continue;
-			if (pi1->peer != bgp->peer_self)
+			if (pi1->peer != bgp->peer_self &&
+			    !CHECK_FLAG(pi1->peer->sflags,
+					PEER_STATUS_NSF_WAIT)) {
 				if (!peer_established(pi1->peer))
 					continue;
+			}
 
 			new_select = pi1;
 			if (pi1->next) {
@@ -3835,11 +3915,65 @@ static void bgp_attr_add_no_export_commu
 	bgp_attr_set_community(attr, new);
 }
 
-int bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
-	       struct attr *attr, afi_t afi, safi_t safi, int type,
-	       int sub_type, struct prefix_rd *prd, mpls_label_t *label,
-	       uint32_t num_labels, int soft_reconfig,
-	       struct bgp_route_evpn *evpn)
+static bool bgp_accept_own(struct peer *peer, afi_t afi, safi_t safi,
+			   struct attr *attr, const struct prefix *prefix,
+			   int *sub_type)
+{
+	struct listnode *node, *nnode;
+	struct bgp *bgp;
+	bool accept_own_found = false;
+
+	if (safi != SAFI_MPLS_VPN)
+		return false;
+
+	/* Processing of the ACCEPT_OWN community is enabled by configuration */
+	if (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_ACCEPT_OWN))
+		return false;
+
+	/* The route in question carries the ACCEPT_OWN community */
+	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES)) {
+		struct community *comm = bgp_attr_get_community(attr);
+
+		if (community_include(comm, COMMUNITY_ACCEPT_OWN))
+			accept_own_found = true;
+	}
+
+	/* The route in question is targeted to one or more destination VRFs
+	 * on the router (as determined by inspecting the Route Target(s)).
+	 */
+	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
+		if (bgp->inst_type != BGP_INSTANCE_TYPE_VRF)
+			continue;
+
+		if (accept_own_found &&
+		    ecommunity_include(
+			    bgp->vpn_policy[afi]
+				    .rtlist[BGP_VPN_POLICY_DIR_TOVPN],
+			    bgp_attr_get_ecommunity(attr))) {
+			if (bgp_debug_update(peer, prefix, NULL, 1))
+				zlog_debug(
+					"%pBP prefix %pFX has ORIGINATOR_ID, but it's accepted due to ACCEPT_OWN",
+					peer, prefix);
+
+			/* Treat this route as imported, because it's leaked
+			 * already from another VRF, and we got an updated
+			 * version from route-reflector with ACCEPT_OWN
+			 * community.
+			 */
+			*sub_type = BGP_ROUTE_IMPORTED;
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
+		struct attr *attr, afi_t afi, safi_t safi, int type,
+		int sub_type, struct prefix_rd *prd, mpls_label_t *label,
+		uint32_t num_labels, int soft_reconfig,
+		struct bgp_route_evpn *evpn)
 {
 	int ret;
 	int aspath_loop_count = 0;
@@ -3848,7 +3982,7 @@ int bgp_update(struct peer *peer, const
 	struct attr new_attr;
 	struct attr *attr_new;
 	struct bgp_path_info *pi;
-	struct bgp_path_info *new;
+	struct bgp_path_info *new = NULL;
 	struct bgp_path_info_extra *extra;
 	const char *reason;
 	char pfx_buf[BGP_PRD_PATH_STRLEN];
@@ -3856,11 +3990,10 @@ int bgp_update(struct peer *peer, const
 	int do_loop_check = 1;
 	int has_valid_label = 0;
 	afi_t nh_afi;
-	uint8_t pi_type = 0;
-	uint8_t pi_sub_type = 0;
 	bool force_evpn_import = false;
 	safi_t orig_safi = safi;
 	bool leak_success = true;
+	int allowas_in = 0;
 
 	if (frrtrace_enabled(frr_bgp, process_update)) {
 		char pfxprint[PREFIX2STR_BUFFER];
@@ -3907,6 +4040,10 @@ int bgp_update(struct peer *peer, const
 	    && peer != bgp->peer_self)
 		bgp_adj_in_set(dest, peer, attr, addpath_id);
 
+	/* Update permitted loop count */
+	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN))
+		allowas_in = peer->allowas_in[afi][safi];
+
 	/* Check previously received route. */
 	for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
 		if (pi->peer == peer && pi->type == type
@@ -3916,8 +4053,8 @@ int bgp_update(struct peer *peer, const
 
 	/* AS path local-as loop check. */
 	if (peer->change_local_as) {
-		if (peer->allowas_in[afi][safi])
-			aspath_loop_count = peer->allowas_in[afi][safi];
+		if (allowas_in)
+			aspath_loop_count = allowas_in;
 		else if (!CHECK_FLAG(peer->flags,
 				     PEER_FLAG_LOCAL_AS_NO_PREPEND))
 			aspath_loop_count = 1;
@@ -3945,23 +4082,37 @@ int bgp_update(struct peer *peer, const
 
 	/* AS path loop check. */
 	if (do_loop_check) {
-		if (aspath_loop_check(attr->aspath, bgp->as)
-			    > peer->allowas_in[afi][safi]
-		    || (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
-			&& aspath_loop_check(attr->aspath, bgp->confed_id)
-				   > peer->allowas_in[afi][safi])) {
+		if (aspath_loop_check(attr->aspath, bgp->as) >
+		    peer->allowas_in[afi][safi]) {
 			peer->stat_pfx_aspath_loop++;
 			reason = "as-path contains our own AS;";
 			goto filtered;
 		}
 	}
 
-	/* Route reflector originator ID check.  */
+	/* If we're a CONFED we need to loop check the CONFED ID too */
+	if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION) && do_loop_check)
+		if (aspath_loop_check_confed(attr->aspath, bgp->confed_id) >
+		    peer->allowas_in[afi][safi]) {
+			peer->stat_pfx_aspath_loop++;
+			reason = "as-path contains our own confed AS;";
+			goto filtered;
+		}
+
+	/* Route reflector originator ID check. If ACCEPT_OWN mechanism is
+	 * enabled, then take care of that too.
+	 */
+	bool accept_own = false;
+
 	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID)
 	    && IPV4_ADDR_SAME(&bgp->router_id, &attr->originator_id)) {
-		peer->stat_pfx_originator_loop++;
-		reason = "originator is us;";
-		goto filtered;
+		accept_own =
+			bgp_accept_own(peer, afi, safi, attr, p, &sub_type);
+		if (!accept_own) {
+			peer->stat_pfx_originator_loop++;
+			reason = "originator is us;";
+			goto filtered;
+		}
 	}
 
 	/* Route reflector cluster ID check.  */
@@ -4061,21 +4212,18 @@ int bgp_update(struct peer *peer, const
 			new_attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
 			new_attr.local_pref = BGP_GSHUT_LOCAL_PREF;
 
-			/* If graceful-shutdown is configured then add the GSHUT
-			 * community to all paths received from eBGP peers */
-		} else if (bgp_in_graceful_shutdown(peer->bgp))
+			/* If graceful-shutdown is configured globally or
+			 * per neighbor, then add the GSHUT community to
+			 * all paths received from eBGP peers. */
+		} else if (bgp_in_graceful_shutdown(peer->bgp) ||
+			   CHECK_FLAG(peer->flags, PEER_FLAG_GRACEFUL_SHUTDOWN))
 			bgp_attr_add_gshut_community(&new_attr);
 	}
 
-	if (pi) {
-		pi_type = pi->type;
-		pi_sub_type = pi->sub_type;
-	}
-
 	/* next hop check.  */
-	if (!CHECK_FLAG(peer->flags, PEER_FLAG_IS_RFAPI_HD)
-	    && bgp_update_martian_nexthop(bgp, afi, safi, pi_type, pi_sub_type,
-					  &new_attr, dest)) {
+	if (!CHECK_FLAG(peer->flags, PEER_FLAG_IS_RFAPI_HD) &&
+	    bgp_update_martian_nexthop(bgp, afi, safi, type, sub_type,
+				       &new_attr, dest)) {
 		peer->stat_pfx_nh_invalid++;
 		reason = "martian or self next-hop;";
 		bgp_attr_flush(&new_attr);
@@ -4108,14 +4256,6 @@ int bgp_update(struct peer *peer, const
 	    && (!CHECK_FLAG(dest->flags, BGP_NODE_FIB_INSTALLED)))
 		SET_FLAG(dest->flags, BGP_NODE_FIB_INSTALL_PENDING);
 
-	/* If maximum prefix count is configured and current prefix
-	 * count exeed it.
-	 */
-	if (bgp_maximum_prefix_overflow(peer, afi, safi, 0)) {
-		bgp_attr_flush(&new_attr);
-		return -1;
-	}
-
 	/* If neighbor soo is configured, tag all incoming routes with
 	 * this SoO tag and then filter out advertisements in
 	 * subgroup_announce_check() if it matches the configured SoO
@@ -4209,7 +4349,7 @@ int bgp_update(struct peer *peer, const
 			bgp_dest_unlock_node(dest);
 			bgp_attr_unintern(&attr_new);
 
-			return 0;
+			return;
 		}
 
 		/* Withdraw/Announce before we fully processed the withdraw */
@@ -4328,8 +4468,7 @@ int bgp_update(struct peer *peer, const
 						bgp_evpn_unimport_route(
 							bgp, afi, safi, p, pi);
 					else /* SAFI_MPLS_VPN */
-						vpn_leak_to_vrf_withdraw(bgp,
-									 pi);
+						vpn_leak_to_vrf_withdraw(pi);
 				}
 			}
 		}
@@ -4423,7 +4562,7 @@ int bgp_update(struct peer *peer, const
 			ret = bgp_damp_update(pi, dest, afi, safi);
 			if (ret == BGP_DAMP_SUPPRESSED) {
 				bgp_dest_unlock_node(dest);
-				return 0;
+				return;
 			}
 		}
 
@@ -4465,8 +4604,13 @@ int bgp_update(struct peer *peer, const
 				bgp_path_info_unset_flag(dest, pi,
 							 BGP_PATH_VALID);
 			}
-		} else
+		} else {
+			if (accept_own)
+				bgp_path_info_set_flag(dest, pi,
+						       BGP_PATH_ACCEPT_OWN);
+
 			bgp_path_info_set_flag(dest, pi, BGP_PATH_VALID);
+		}
 
 #ifdef ENABLE_BGP_VNC
 		if (safi == SAFI_MPLS_VPN) {
@@ -4516,8 +4660,7 @@ int bgp_update(struct peer *peer, const
 		}
 		if ((SAFI_MPLS_VPN == safi)
 		    && (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)) {
-
-			leak_success = vpn_leak_to_vrf_update(bgp, pi);
+			leak_success = vpn_leak_to_vrf_update(bgp, pi, prd);
 		}
 
 #ifdef ENABLE_BGP_VNC
@@ -4539,7 +4682,7 @@ int bgp_update(struct peer *peer, const
 			bgp_unlink_nexthop(pi);
 			bgp_path_info_delete(dest, pi);
 		}
-		return 0;
+		return;
 	} // End of implicit withdraw
 
 	/* Received Logging. */
@@ -4615,18 +4758,26 @@ int bgp_update(struct peer *peer, const
 		    CHECK_FLAG(peer->flags, PEER_FLAG_IS_RFAPI_HD))
 			bgp_path_info_set_flag(dest, new, BGP_PATH_VALID);
 		else {
-			if (BGP_DEBUG(nht, NHT)) {
-				char buf1[INET6_ADDRSTRLEN];
-				inet_ntop(AF_INET,
-					  (const void *)&attr_new->nexthop,
-					  buf1, INET6_ADDRSTRLEN);
-				zlog_debug("%s(%s): NH unresolved", __func__,
-					   buf1);
-			}
+			if (BGP_DEBUG(nht, NHT))
+				zlog_debug("%s(%pI4): NH unresolved", __func__,
+					   &attr_new->nexthop);
 			bgp_path_info_unset_flag(dest, new, BGP_PATH_VALID);
 		}
-	} else
+	} else {
+		if (accept_own)
+			bgp_path_info_set_flag(dest, new, BGP_PATH_ACCEPT_OWN);
+
 		bgp_path_info_set_flag(dest, new, BGP_PATH_VALID);
+	}
+
+	/* If maximum prefix count is configured and current prefix
+	 * count exeed it.
+	 */
+	if (bgp_maximum_prefix_overflow(peer, afi, safi, 0)) {
+		reason = "maximum-prefix overflow";
+		bgp_attr_flush(&new_attr);
+		goto filtered;
+	}
 
 	/* Addpath ID */
 	new->addpath_rx_id = addpath_id;
@@ -4672,7 +4823,7 @@ int bgp_update(struct peer *peer, const
 	}
 	if ((SAFI_MPLS_VPN == safi)
 	    && (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)) {
-		leak_success = vpn_leak_to_vrf_update(bgp, new);
+		leak_success = vpn_leak_to_vrf_update(bgp, new, prd);
 	}
 #ifdef ENABLE_BGP_VNC
 	if (SAFI_MPLS_VPN == safi) {
@@ -4694,11 +4845,18 @@ int bgp_update(struct peer *peer, const
 		bgp_path_info_delete(dest, new);
 	}
 
-	return 0;
+	return;
 
 /* This BGP update is filtered.  Log the reason then update BGP
    entry.  */
 filtered:
+	if (new) {
+		bgp_unlink_nexthop(new);
+		bgp_path_info_delete(dest, new);
+		bgp_path_info_extra_free(&new->extra);
+		XFREE(MTYPE_BGP_ROUTE, new);
+	}
+
 	hook_call(bgp_process, bgp, afi, safi, dest, peer, true);
 
 	if (bgp_debug_update(peer, p, NULL, 1)) {
@@ -4730,7 +4888,7 @@ filtered:
 		if ((SAFI_MPLS_VPN == safi)
 		    && (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)) {
 
-			vpn_leak_to_vrf_withdraw(bgp, pi);
+			vpn_leak_to_vrf_withdraw(pi);
 		}
 
 		bgp_rib_remove(dest, pi, peer, afi, safi);
@@ -4750,13 +4908,14 @@ filtered:
 	}
 #endif
 
-	return 0;
+	return;
 }
 
-int bgp_withdraw(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
-		 struct attr *attr, afi_t afi, safi_t safi, int type,
-		 int sub_type, struct prefix_rd *prd, mpls_label_t *label,
-		 uint32_t num_labels, struct bgp_route_evpn *evpn)
+void bgp_withdraw(struct peer *peer, const struct prefix *p,
+		  uint32_t addpath_id, struct attr *attr, afi_t afi,
+		  safi_t safi, int type, int sub_type, struct prefix_rd *prd,
+		  mpls_label_t *label, uint32_t num_labels,
+		  struct bgp_route_evpn *evpn)
 {
 	struct bgp *bgp;
 	char pfx_buf[BGP_PRD_PATH_STRLEN];
@@ -4801,7 +4960,7 @@ int bgp_withdraw(struct peer *peer, cons
 					peer->host, pfx_buf);
 			}
 			bgp_dest_unlock_node(dest);
-			return 0;
+			return;
 		}
 
 	/* Lookup withdrawn route. */
@@ -4831,7 +4990,7 @@ int bgp_withdraw(struct peer *peer, cons
 		if ((SAFI_MPLS_VPN == safi)
 		    && (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)) {
 
-			vpn_leak_to_vrf_withdraw(bgp, pi);
+			vpn_leak_to_vrf_withdraw(pi);
 		}
 	} else if (bgp_debug_update(peer, p, NULL, 1)) {
 		bgp_debug_rdpfxpath2str(afi, safi, prd, p, label, num_labels,
@@ -4843,7 +5002,7 @@ int bgp_withdraw(struct peer *peer, cons
 	/* Unlock bgp_node_get() lock. */
 	bgp_dest_unlock_node(dest);
 
-	return 0;
+	return;
 }
 
 void bgp_default_originate(struct peer *peer, afi_t afi, safi_t safi,
@@ -4975,10 +5134,10 @@ static void bgp_soft_reconfig_table_flag
 	}
 }
 
-static int bgp_soft_reconfig_table_update(struct peer *peer,
-					  struct bgp_dest *dest,
-					  struct bgp_adj_in *ain, afi_t afi,
-					  safi_t safi, struct prefix_rd *prd)
+static void bgp_soft_reconfig_table_update(struct peer *peer,
+					   struct bgp_dest *dest,
+					   struct bgp_adj_in *ain, afi_t afi,
+					   safi_t safi, struct prefix_rd *prd)
 {
 	struct bgp_path_info *pi;
 	uint32_t num_labels = 0;
@@ -4999,17 +5158,15 @@ static int bgp_soft_reconfig_table_updat
 	else
 		memset(&evpn, 0, sizeof(evpn));
 
-	return bgp_update(peer, bgp_dest_get_prefix(dest), ain->addpath_rx_id,
-			  ain->attr, afi, safi, ZEBRA_ROUTE_BGP,
-			  BGP_ROUTE_NORMAL, prd, label_pnt, num_labels, 1,
-			  &evpn);
+	bgp_update(peer, bgp_dest_get_prefix(dest), ain->addpath_rx_id,
+		   ain->attr, afi, safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, prd,
+		   label_pnt, num_labels, 1, &evpn);
 }
 
 static void bgp_soft_reconfig_table(struct peer *peer, afi_t afi, safi_t safi,
 				    struct bgp_table *table,
 				    struct prefix_rd *prd)
 {
-	int ret;
 	struct bgp_dest *dest;
 	struct bgp_adj_in *ain;
 
@@ -5021,13 +5178,8 @@ static void bgp_soft_reconfig_table(stru
 			if (ain->peer != peer)
 				continue;
 
-			ret = bgp_soft_reconfig_table_update(peer, dest, ain,
-							     afi, safi, prd);
-
-			if (ret < 0) {
-				bgp_dest_unlock_node(dest);
-				return;
-			}
+			bgp_soft_reconfig_table_update(peer, dest, ain, afi,
+						       safi, prd);
 		}
 }
 
@@ -5042,7 +5194,6 @@ static void bgp_soft_reconfig_table(stru
 static void bgp_soft_reconfig_table_task(struct thread *thread)
 {
 	uint32_t iter, max_iter;
-	int ret;
 	struct bgp_dest *dest;
 	struct bgp_adj_in *ain;
 	struct peer *peer;
@@ -5075,27 +5226,10 @@ static void bgp_soft_reconfig_table_task
 				if (ain->peer != peer)
 					continue;
 
-				ret = bgp_soft_reconfig_table_update(
+				bgp_soft_reconfig_table_update(
 					peer, dest, ain, table->afi,
 					table->safi, prd);
 				iter++;
-
-				if (ret < 0) {
-					bgp_dest_unlock_node(dest);
-					listnode_delete(
-						table->soft_reconfig_peers,
-						peer);
-					bgp_announce_route(peer, table->afi,
-							   table->safi, false);
-					if (list_isempty(
-						    table->soft_reconfig_peers)) {
-						list_delete(
-							&table->soft_reconfig_peers);
-						bgp_soft_reconfig_table_flag(
-							table, false);
-						return;
-					}
-				}
 			}
 		}
 	}
@@ -5165,7 +5299,10 @@ void bgp_soft_reconfig_table_task_cancel
 	}
 }
 
-void bgp_soft_reconfig_in(struct peer *peer, afi_t afi, safi_t safi)
+/*
+ * Returns false if the peer is not configured for soft reconfig in
+ */
+bool bgp_soft_reconfig_in(struct peer *peer, afi_t afi, safi_t safi)
 {
 	struct bgp_dest *dest;
 	struct bgp_table *table;
@@ -5173,14 +5310,14 @@ void bgp_soft_reconfig_in(struct peer *p
 	struct peer *npeer;
 	struct peer_af *paf;
 
-	if (!peer_established(peer))
-		return;
+	if (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
+		return false;
 
 	if ((safi != SAFI_MPLS_VPN) && (safi != SAFI_ENCAP)
 	    && (safi != SAFI_EVPN)) {
 		table = peer->bgp->rib[afi][safi];
 		if (!table)
-			return;
+			return true;
 
 		table->soft_reconfig_init = true;
 
@@ -5240,6 +5377,8 @@ void bgp_soft_reconfig_in(struct peer *p
 
 			bgp_soft_reconfig_table(peer, afi, safi, table, &prd);
 		}
+
+	return true;
 }
 
 
@@ -5291,7 +5430,7 @@ static wq_item_status bgp_clear_route_no
 			}
 			if (SAFI_MPLS_VPN == safi &&
 			    bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
-				vpn_leak_to_vrf_withdraw(bgp, pi);
+				vpn_leak_to_vrf_withdraw(pi);
 			}
 
 			bgp_rib_remove(dest, pi, peer, afi, safi);
@@ -5560,8 +5699,7 @@ void bgp_clear_stale_route(struct peer *
 						    BGP_ROUTE_IMPORTED &&
 					    peer->bgp->inst_type ==
 						    BGP_INSTANCE_TYPE_DEFAULT)
-						vpn_leak_to_vrf_withdraw(
-							peer->bgp, pi);
+						vpn_leak_to_vrf_withdraw(pi);
 
 					bgp_rib_remove(rm, pi, peer, afi, safi);
 					break;
@@ -5807,7 +5945,6 @@ int bgp_nlri_parse_ip(struct peer *peer,
 	uint8_t *lim;
 	struct prefix p;
 	int psize;
-	int ret;
 	afi_t afi;
 	safi_t safi;
 	bool addpath_capable;
@@ -5920,23 +6057,18 @@ int bgp_nlri_parse_ip(struct peer *peer,
 
 		/* Normal process. */
 		if (attr)
-			ret = bgp_update(peer, &p, addpath_id, attr, afi, safi,
-					 ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
-					 NULL, NULL, 0, 0, NULL);
-		else
-			ret = bgp_withdraw(peer, &p, addpath_id, attr, afi,
-					   safi, ZEBRA_ROUTE_BGP,
-					   BGP_ROUTE_NORMAL, NULL, NULL, 0,
-					   NULL);
+			bgp_update(peer, &p, addpath_id, attr, afi, safi,
+				   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,
+				   NULL, 0, 0, NULL);
+		else
+			bgp_withdraw(peer, &p, addpath_id, attr, afi, safi,
+				     ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,
+				     NULL, 0, NULL);
 
 		/* Do not send BGP notification twice when maximum-prefix count
 		 * overflow. */
 		if (CHECK_FLAG(peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))
 			return BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW;
-
-		/* Address family configuration mismatch. */
-		if (ret < 0)
-			return BGP_NLRI_PARSE_ERROR_ADDRESS_FAMILY;
 	}
 
 	/* Packet length consistency check. */
@@ -5992,6 +6124,9 @@ void bgp_static_update(struct bgp *bgp,
 	if (afi == AFI_IP)
 		attr.mp_nexthop_len = BGP_ATTR_NHLEN_IPV4;
 
+	if (bgp_static->igpmetric)
+		bgp_attr_set_aigp_metric(&attr, bgp_static->igpmetric);
+
 	if (bgp_static->atomic)
 		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);
 
@@ -6110,7 +6245,7 @@ void bgp_static_update(struct bgp *bgp,
 						char buf1[INET6_ADDRSTRLEN];
 						inet_ntop(p->family,
 							  &p->u.prefix, buf1,
-							  INET6_ADDRSTRLEN);
+							  sizeof(buf1));
 						zlog_debug(
 							"%s(%s): Route not in table, not advertising",
 							__func__, buf1);
@@ -6160,8 +6295,9 @@ void bgp_static_update(struct bgp *bgp,
 		else {
 			if (BGP_DEBUG(nht, NHT)) {
 				char buf1[INET6_ADDRSTRLEN];
+
 				inet_ntop(p->family, &p->u.prefix, buf1,
-					  INET6_ADDRSTRLEN);
+					  sizeof(buf1));
 				zlog_debug(
 					"%s(%s): Route not in table, not advertising",
 					__func__, buf1);
@@ -6258,7 +6394,7 @@ static void bgp_static_withdraw_safi(str
 #endif
 		if (SAFI_MPLS_VPN == safi
 		    && bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
-			vpn_leak_to_vrf_withdraw(bgp, pi);
+			vpn_leak_to_vrf_withdraw(pi);
 		}
 		bgp_aggregate_decrement(bgp, p, pi, afi, safi);
 		bgp_path_info_delete(dest, pi);
@@ -6393,7 +6529,8 @@ static void bgp_static_update_safi(struc
 
 			if (SAFI_MPLS_VPN == safi
 			    && bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
-				vpn_leak_to_vrf_update(bgp, pi);
+				vpn_leak_to_vrf_update(bgp, pi,
+						       &bgp_static->prd);
 			}
 #ifdef ENABLE_BGP_VNC
 			rfapiProcessUpdate(pi->peer, NULL, p, &bgp_static->prd,
@@ -6433,7 +6570,7 @@ static void bgp_static_update_safi(struc
 
 	if (SAFI_MPLS_VPN == safi
 	    && bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
-		vpn_leak_to_vrf_update(bgp, new);
+		vpn_leak_to_vrf_update(bgp, new, &bgp_static->prd);
 	}
 #ifdef ENABLE_BGP_VNC
 	rfapiProcessUpdate(new->peer, NULL, p, &bgp_static->prd, new->attr, afi,
@@ -8536,6 +8673,9 @@ void bgp_redistribute_add(struct bgp *bg
 	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);
 	attr.tag = tag;
 
+	if (metric)
+		bgp_attr_set_aigp_metric(&attr, metric);
+
 	afi = family2afi(p->family);
 
 	red = bgp_redist_lookup(bgp, afi, type, instance);
@@ -8545,8 +8685,10 @@ void bgp_redistribute_add(struct bgp *bg
 		/* Copy attribute for modification. */
 		attr_new = attr;
 
-		if (red->redist_metric_flag)
+		if (red->redist_metric_flag) {
 			attr_new.med = red->redist_metric;
+			bgp_attr_set_aigp_metric(&attr_new, red->redist_metric);
+		}
 
 		/* Apply route-map. */
 		if (red->rmap.name) {
@@ -8722,7 +8864,7 @@ static void route_vty_out_route(struct b
 				struct vty *vty, json_object *json, bool wide)
 {
 	int len = 0;
-	char buf[BUFSIZ];
+	char buf[INET6_ADDRSTRLEN];
 
 	if (p->family == AF_INET) {
 		if (!json) {
@@ -8731,7 +8873,7 @@ static void route_vty_out_route(struct b
 			json_object_string_add(json, "prefix",
 					       inet_ntop(p->family,
 							 &p->u.prefix, buf,
-							 BUFSIZ));
+							 sizeof(buf)));
 			json_object_int_add(json, "prefixLen", p->prefixlen);
 			json_object_string_addf(json, "network", "%pFX", p);
 			json_object_int_add(json, "version", dest->version);
@@ -8753,9 +8895,9 @@ static void route_vty_out_route(struct b
 			len = vty_out(vty, "%pFX", p);
 		else {
 			json_object_string_add(json, "prefix",
-						inet_ntop(p->family,
-							&p->u.prefix, buf,
-							BUFSIZ));
+					       inet_ntop(p->family,
+							 &p->u.prefix, buf,
+							 sizeof(buf)));
 			json_object_int_add(json, "prefixLen", p->prefixlen);
 			json_object_string_addf(json, "network", "%pFX", p);
 			json_object_int_add(json, "version", dest->version);
@@ -8796,8 +8938,12 @@ const char *bgp_path_selection_reason2st
 		return "Weight";
 	case bgp_path_selection_local_pref:
 		return "Local Pref";
+	case bgp_path_selection_accept_own:
+		return "Accept Own";
 	case bgp_path_selection_local_route:
 		return "Local Route";
+	case bgp_path_selection_aigp:
+		return "AIGP";
 	case bgp_path_selection_confed_as_path:
 		return "Confederation based AS Path";
 	case bgp_path_selection_as_path:
@@ -8893,6 +9039,8 @@ static void route_vty_short_status_out(s
 		vty_out(vty, "I");
 	else if (rpki_state == RPKI_NOTFOUND)
 		vty_out(vty, "N");
+	else
+		vty_out(vty, " ");
 
 	/* Route status display. */
 	if (CHECK_FLAG(path->flags, BGP_PATH_REMOVED))
@@ -9018,20 +9166,17 @@ void route_vty_out(struct vty *vty, cons
 	 * attr->mp_nexthop_global_in
 	 */
 	if ((safi == SAFI_ENCAP) || (safi == SAFI_MPLS_VPN)) {
-		char buf[BUFSIZ];
 		char nexthop[128];
 		int af = NEXTHOP_FAMILY(attr->mp_nexthop_len);
 
 		switch (af) {
 		case AF_INET:
-			snprintf(nexthop, sizeof(nexthop), "%s",
-				 inet_ntop(af, &attr->mp_nexthop_global_in, buf,
-					   BUFSIZ));
+			snprintfrr(nexthop, sizeof(nexthop), "%pI4",
+				   &attr->mp_nexthop_global_in);
 			break;
 		case AF_INET6:
-			snprintf(nexthop, sizeof(nexthop), "%s",
-				 inet_ntop(af, &attr->mp_nexthop_global, buf,
-					   BUFSIZ));
+			snprintfrr(nexthop, sizeof(nexthop), "%pI6",
+				   &attr->mp_nexthop_global);
 			break;
 		default:
 			snprintf(nexthop, sizeof(nexthop), "?");
@@ -9318,7 +9463,7 @@ void route_vty_out(struct vty *vty, cons
 			json_object_string_add(json_path, "path",
 					       attr->aspath->str);
 		else
-			aspath_print_vty(vty, "%s", attr->aspath, " ");
+			aspath_print_vty(vty, attr->aspath);
 	}
 
 	/* Print origin */
@@ -9421,7 +9566,7 @@ void route_vty_out_tmp(struct vty *vty,
 		json_status = json_object_new_object();
 		json_net = json_object_new_object();
 	} else {
-		vty_out(vty, "*");
+		vty_out(vty, " *");
 		vty_out(vty, ">");
 		vty_out(vty, " ");
 	}
@@ -9485,8 +9630,14 @@ void route_vty_out_tmp(struct vty *vty,
 						       attr->aspath->str);
 
 			/* Print origin */
+#if CONFDATE > 20231208
+CPP_NOTICE("Drop `bgpOriginCodes` from JSON outputs")
+#endif
 			json_object_string_add(json_net, "bgpOriginCode",
 					       bgp_origin_str[attr->origin]);
+			json_object_string_add(
+				json_net, "origin",
+				bgp_origin_long_str[attr->origin]);
 		} else {
 			if (p->family == AF_INET &&
 			    (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP ||
@@ -9502,13 +9653,8 @@ void route_vty_out_tmp(struct vty *vty,
 					vty_out(vty, "%-16pI4", &attr->nexthop);
 			} else if (p->family == AF_INET6 ||
 				   BGP_ATTR_MP_NEXTHOP_LEN_IP6(attr)) {
-				char buf[BUFSIZ];
-
-				len = vty_out(
-					vty, "%s",
-					inet_ntop(AF_INET6,
-						  &attr->mp_nexthop_global, buf,
-						  BUFSIZ));
+				len = vty_out(vty, "%pI6",
+					      &attr->mp_nexthop_global);
 				len = wide ? (41 - len) : (16 - len);
 				if (len < 1)
 					vty_out(vty, "\n%*s", 36, " ");
@@ -9535,15 +9681,27 @@ void route_vty_out_tmp(struct vty *vty,
 
 			/* Print aspath */
 			if (attr->aspath)
-				aspath_print_vty(vty, "%s", attr->aspath, " ");
+				aspath_print_vty(vty, attr->aspath);
 
 			/* Print origin */
 			vty_out(vty, "%s", bgp_origin_str[attr->origin]);
 		}
 	}
 	if (use_json) {
+		struct bgp_path_info *bpi = bgp_dest_get_bgp_path_info(dest);
+
+#if CONFDATE > 20231208
+CPP_NOTICE("Drop `bgpStatusCodes` from JSON outputs")
+#endif
 		json_object_boolean_true_add(json_status, "*");
 		json_object_boolean_true_add(json_status, ">");
+		json_object_boolean_true_add(json_net, "valid");
+		json_object_boolean_true_add(json_net, "best");
+
+		if (bpi && CHECK_FLAG(bpi->flags, BGP_PATH_MULTIPATH)) {
+			json_object_boolean_true_add(json_status, "=");
+			json_object_boolean_true_add(json_net, "multipath");
+		}
 		json_object_object_add(json_net, "appliedStatusSymbols",
 				       json_status);
 		json_object_object_addf(json_ar, json_net, "%pFX", p);
@@ -9710,8 +9868,6 @@ void route_vty_out_overlay(struct vty *v
 		if (!json_path) {
 			vty_out(vty, "?");
 		} else {
-			json_object_string_add(json_nexthop, "Error",
-					       "Unsupported address-family");
 			json_object_string_add(json_nexthop, "error",
 					       "Unsupported address-family");
 		}
@@ -9790,7 +9946,7 @@ static void damp_route_vty_out(struct vt
 						use_json, NULL));
 
 		if (attr->aspath)
-			aspath_print_vty(vty, "%s", attr->aspath, " ");
+			aspath_print_vty(vty, attr->aspath);
 
 		vty_out(vty, "%s", bgp_origin_str[attr->origin]);
 
@@ -9867,7 +10023,7 @@ static void flap_route_vty_out(struct vt
 			vty_out(vty, "%*s ", 8, " ");
 
 		if (attr->aspath)
-			aspath_print_vty(vty, "%s", attr->aspath, " ");
+			aspath_print_vty(vty, attr->aspath);
 
 		vty_out(vty, "%s", bgp_origin_str[attr->origin]);
 
@@ -10016,12 +10172,13 @@ static void route_vty_out_detail_es_info
 }
 
 void route_vty_out_detail(struct vty *vty, struct bgp *bgp, struct bgp_dest *bn,
-			  struct bgp_path_info *path, afi_t afi, safi_t safi,
+			  const struct prefix *p, struct bgp_path_info *path,
+			  afi_t afi, safi_t safi,
 			  enum rpki_states rpki_curr_state,
 			  json_object *json_paths)
 {
 	char buf[INET6_ADDRSTRLEN];
-	char buf1[BUFSIZ];
+	char tag_buf[30];
 	struct attr *attr = path->attr;
 	time_t tbuf;
 	json_object *json_bestpath = NULL;
@@ -10052,6 +10209,9 @@ void route_vty_out_detail(struct vty *vt
 	uint32_t bos = 0;
 	uint32_t exp = 0;
 	mpls_label_t label = MPLS_INVALID_LABEL;
+	tag_buf[0] = '\0';
+	struct bgp_path_info *bpi_ultimate =
+		bgp_get_imported_bpi_ultimate(path);
 
 	if (json_paths) {
 		json_path = json_object_new_object();
@@ -10061,13 +10221,10 @@ void route_vty_out_detail(struct vty *vt
 
 	if (safi == SAFI_EVPN) {
 		if (!json_paths)
-			vty_out(vty, "  Route %pRN", bn);
+			vty_out(vty, "  Route %pFX", p);
 	}
 
 	if (path->extra) {
-		char tag_buf[30];
-
-		tag_buf[0] = '\0';
 		if (path->extra && path->extra->num_labels) {
 			bgp_evpn_label2str(path->extra->label,
 					   path->extra->num_labels, tag_buf,
@@ -10078,50 +10235,9 @@ void route_vty_out_detail(struct vty *vt
 				if (tag_buf[0] != '\0')
 					vty_out(vty, " VNI %s", tag_buf);
 			} else {
-				if (tag_buf[0]) {
-					json_object_string_add(json_path, "VNI",
-							       tag_buf);
+				if (tag_buf[0])
 					json_object_string_add(json_path, "vni",
 							       tag_buf);
-				}
-			}
-		}
-
-		if (path->extra && path->extra->parent && !json_paths) {
-			struct bgp_path_info *parent_ri;
-			struct bgp_dest *dest, *pdest;
-
-			parent_ri = (struct bgp_path_info *)path->extra->parent;
-			dest = parent_ri->net;
-			if (dest && dest->pdest) {
-				pdest = dest->pdest;
-				if (is_pi_family_evpn(parent_ri)) {
-					vty_out(vty,
-						"  Imported from %pRD:%pFX, VNI %s",
-						(struct prefix_rd *)
-							bgp_dest_get_prefix(
-								pdest),
-						(struct prefix_evpn *)
-							bgp_dest_get_prefix(
-								dest),
-						tag_buf);
-					if (attr->es_flags & ATTR_ES_L3_NHG)
-						vty_out(vty, ", L3NHG %s",
-							(attr->es_flags
-							 & ATTR_ES_L3_NHG_ACTIVE)
-								? "active"
-								: "inactive");
-					vty_out(vty, "\n");
-
-				} else
-					vty_out(vty,
-						"  Imported from %pRD:%pFX\n",
-						(struct prefix_rd *)
-							bgp_dest_get_prefix(
-								pdest),
-						(struct prefix_evpn *)
-							bgp_dest_get_prefix(
-								dest));
 			}
 		}
 	}
@@ -10143,6 +10259,41 @@ void route_vty_out_detail(struct vty *vt
 	if (safi == SAFI_EVPN && !json_path)
 		vty_out(vty, "\n");
 
+
+	if (path->extra && path->extra->parent && !json_paths) {
+		struct bgp_path_info *parent_ri;
+		struct bgp_dest *dest, *pdest;
+
+		parent_ri = (struct bgp_path_info *)path->extra->parent;
+		dest = parent_ri->net;
+		if (dest && dest->pdest) {
+			pdest = dest->pdest;
+			if (is_pi_family_evpn(parent_ri)) {
+				vty_out(vty,
+					"  Imported from %pRD:%pFX, VNI %s",
+					(struct prefix_rd *)bgp_dest_get_prefix(
+						pdest),
+					(struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					tag_buf);
+				if (CHECK_FLAG(attr->es_flags, ATTR_ES_L3_NHG))
+					vty_out(vty, ", L3NHG %s",
+						CHECK_FLAG(
+							attr->es_flags,
+							ATTR_ES_L3_NHG_ACTIVE)
+							? "active"
+							: "inactive");
+				vty_out(vty, "\n");
+
+			} else
+				vty_out(vty, "  Imported from %pRD:%pFX\n",
+					(struct prefix_rd *)bgp_dest_get_prefix(
+						pdest),
+					(struct prefix_evpn *)
+						bgp_dest_get_prefix(dest));
+		}
+	}
+
 	/* Line1 display AS-path, Aggregator */
 	if (attr->aspath) {
 		if (json_paths) {
@@ -10153,7 +10304,7 @@ void route_vty_out_detail(struct vty *vt
 					       attr->aspath->json);
 		} else {
 			if (attr->aspath->segments)
-				aspath_print_vty(vty, "  %s", attr->aspath, "");
+				vty_out(vty, "  %s", attr->aspath->str);
 			else
 				vty_out(vty, "  Local");
 		}
@@ -10222,10 +10373,9 @@ void route_vty_out_detail(struct vty *vt
 
 	/* Line2 display Next-hop, Neighbor, Router-id */
 	/* Display the nexthop */
-	const struct prefix *bn_p = bgp_dest_get_prefix(bn);
 
-	if ((bn_p->family == AF_INET || bn_p->family == AF_ETHERNET ||
-	     bn_p->family == AF_EVPN) &&
+	if ((p->family == AF_INET || p->family == AF_ETHERNET ||
+	     p->family == AF_EVPN) &&
 	    (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP || safi == SAFI_EVPN ||
 	     !BGP_ATTR_MP_NEXTHOP_LEN_IP6(attr))) {
 		if (safi == SAFI_MPLS_VPN || safi == SAFI_ENCAP
@@ -10299,21 +10449,27 @@ void route_vty_out_detail(struct vty *vt
 	}
 
 	/* Display the IGP cost or 'inaccessible' */
-	if (!CHECK_FLAG(path->flags, BGP_PATH_VALID)) {
-		if (json_paths)
+	if (!CHECK_FLAG(bpi_ultimate->flags, BGP_PATH_VALID)) {
+		bool import = CHECK_FLAG(bgp->flags, BGP_FLAG_IMPORT_CHECK);
+
+		if (json_paths) {
 			json_object_boolean_false_add(json_nexthop_global,
 						      "accessible");
-		else
-			vty_out(vty, " (inaccessible)");
+			json_object_boolean_add(json_nexthop_global,
+						"importCheckEnabled", import);
+		} else {
+			vty_out(vty, " (inaccessible%s)",
+				import ? ", import-check enabled" : "");
+		}
 	} else {
-		if (path->extra && path->extra->igpmetric) {
+		if (bpi_ultimate->extra && bpi_ultimate->extra->igpmetric) {
 			if (json_paths)
-				json_object_int_add(json_nexthop_global,
-						    "metric",
-						    path->extra->igpmetric);
+				json_object_int_add(
+					json_nexthop_global, "metric",
+					bpi_ultimate->extra->igpmetric);
 			else
 				vty_out(vty, " (metric %u)",
-					path->extra->igpmetric);
+					bpi_ultimate->extra->igpmetric);
 		}
 
 		/* IGP cost is 0, display this only for json */
@@ -10332,7 +10488,7 @@ void route_vty_out_detail(struct vty *vt
 	/* This path was originated locally */
 	if (path->peer == bgp->peer_self) {
 
-		if (safi == SAFI_EVPN || (bn_p->family == AF_INET &&
+		if (safi == SAFI_EVPN || (p->family == AF_INET &&
 					  !BGP_ATTR_MP_NEXTHOP_LEN_IP6(attr))) {
 			if (json_paths)
 				json_object_string_add(json_peer, "peerId",
@@ -10400,10 +10556,7 @@ void route_vty_out_detail(struct vty *vt
 			if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
 				vty_out(vty, " (%pI4)", &attr->originator_id);
 			else
-				vty_out(vty, " (%s)",
-					inet_ntop(AF_INET,
-						  &path->peer->remote_id, buf1,
-						  sizeof(buf1)));
+				vty_out(vty, " (%pI4)", &path->peer->remote_id);
 		}
 	}
 
@@ -10526,6 +10679,15 @@ void route_vty_out_detail(struct vty *vt
 			vty_out(vty, ", localpref %u", attr->local_pref);
 	}
 
+	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AIGP)) {
+		if (json_paths)
+			json_object_int_add(json_path, "aigpMetric",
+					    bgp_attr_get_aigp_metric(attr));
+		else
+			vty_out(vty, ", aigp-metric %" PRIu64,
+				bgp_attr_get_aigp_metric(attr));
+	}
+
 	if (attr->weight != 0) {
 		if (json_paths)
 			json_object_int_add(json_path, "weight", attr->weight);
@@ -10807,11 +10969,12 @@ void route_vty_out_detail(struct vty *vt
 
 	/* Remote SID */
 	if (path->extra && path->extra->num_sids > 0 && safi != SAFI_EVPN) {
-		inet_ntop(AF_INET6, &path->extra->sid[0].sid, buf, sizeof(buf));
 		if (json_paths)
-			json_object_string_add(json_path, "remoteSid", buf);
+			json_object_string_addf(json_path, "remoteSid", "%pI6",
+						&path->extra->sid[0].sid);
 		else
-			vty_out(vty, "      Remote SID: %s\n", buf);
+			vty_out(vty, "      Remote SID: %pI6\n",
+				&path->extra->sid[0].sid);
 	}
 
 	/* Label Index */
@@ -11023,6 +11186,8 @@ static int bgp_show_table(struct vty *vt
 	bool use_json = CHECK_FLAG(show_flags, BGP_SHOW_OPT_JSON);
 	bool wide = CHECK_FLAG(show_flags, BGP_SHOW_OPT_WIDE);
 	bool all = CHECK_FLAG(show_flags, BGP_SHOW_OPT_AFI_ALL);
+	bool detail_json = CHECK_FLAG(show_flags, BGP_SHOW_OPT_JSON_DETAIL);
+	bool detail_routes = CHECK_FLAG(show_flags, BGP_SHOW_OPT_ROUTES_DETAIL);
 
 	if (output_cum && *output_cum != 0)
 		header = false;
@@ -11056,8 +11221,7 @@ static int bgp_show_table(struct vty *vt
 	}
 
 	/* Check for 'json detail', where we need header output once per dest */
-	if (use_json && CHECK_FLAG(show_flags, BGP_SHOW_OPT_DETAIL) &&
-	    type != bgp_show_type_dampend_paths &&
+	if (use_json && detail_json && type != bgp_show_type_dampend_paths &&
 	    type != bgp_show_type_damp_neighbor &&
 	    type != bgp_show_type_flap_statistics &&
 	    type != bgp_show_type_flap_neighbor)
@@ -11320,17 +11484,19 @@ static int bgp_show_table(struct vty *vt
 				vty_out(vty, "Default local pref %u, ",
 					bgp->default_local_pref);
 				vty_out(vty, "local AS %u\n", bgp->as);
-				vty_out(vty, BGP_SHOW_SCODE_HEADER);
-				vty_out(vty, BGP_SHOW_NCODE_HEADER);
-				vty_out(vty, BGP_SHOW_OCODE_HEADER);
-				vty_out(vty, BGP_SHOW_RPKI_HEADER);
+				if (!detail_routes) {
+					vty_out(vty, BGP_SHOW_SCODE_HEADER);
+					vty_out(vty, BGP_SHOW_NCODE_HEADER);
+					vty_out(vty, BGP_SHOW_OCODE_HEADER);
+					vty_out(vty, BGP_SHOW_RPKI_HEADER);
+				}
 				if (type == bgp_show_type_dampend_paths
 				    || type == bgp_show_type_damp_neighbor)
 					vty_out(vty, BGP_SHOW_DAMP_HEADER);
 				else if (type == bgp_show_type_flap_statistics
 					 || type == bgp_show_type_flap_neighbor)
 					vty_out(vty, BGP_SHOW_FLAP_HEADER);
-				else
+				else if (!detail_routes)
 					vty_out(vty, (wide ? BGP_SHOW_HEADER_WIDE
 							   : BGP_SHOW_HEADER));
 				header = false;
@@ -11347,8 +11513,9 @@ static int bgp_show_table(struct vty *vt
 				prd = bgp_rd_from_dest(dest, safi);
 
 				route_vty_out_detail_header(
-					vty, bgp, dest, prd, table->afi,
-					safi, jtemp);
+					vty, bgp, dest,
+					bgp_dest_get_prefix(dest), prd,
+					table->afi, safi, jtemp);
 
 				json_object_array_add(json_paths, jtemp);
 
@@ -11372,15 +11539,30 @@ static int bgp_show_table(struct vty *vt
 						   AFI_IP, safi, use_json,
 						   json_paths);
 			else {
-				if (CHECK_FLAG(show_flags, BGP_SHOW_OPT_DETAIL))
+				if (detail_routes || detail_json) {
+					const struct prefix_rd *prd = NULL;
+
+					if (dest->pdest)
+						prd = bgp_rd_from_dest(
+							dest->pdest, safi);
+
+					if (!use_json)
+						route_vty_out_detail_header(
+							vty, bgp, dest,
+							bgp_dest_get_prefix(
+								dest),
+							prd, table->afi, safi,
+							NULL);
+
 					route_vty_out_detail(
-						vty, bgp, dest, pi,
+						vty, bgp, dest, dest_p, pi,
 						family2afi(dest_p->family),
 						safi, RPKI_NOT_BEING_USED,
 						json_paths);
-				else
+				} else {
 					route_vty_out(vty, dest_p, pi, display,
 						      safi, json_paths, wide);
+				}
 			}
 			display++;
 		}
@@ -11416,7 +11598,16 @@ static int bgp_show_table(struct vty *vt
 				else
 					vty_out(vty, ",\"%pFX\": ", dest_p);
 			}
-			vty_json(vty, json_paths);
+			/*
+			 * We are using no_pretty here because under
+			 * extremely high settings( say lots and lots of
+			 * routes with lots and lots of ways to reach
+			 * that route via different paths ) this can
+			 * save several minutes of output when FRR
+			 * is run on older cpu's or more underperforming
+			 * routers out there
+			 */
+			vty_json_no_pretty(vty, json_paths);
 			json_paths = NULL;
 			first = 0;
 		} else
@@ -11462,7 +11653,8 @@ static int bgp_show_table(struct vty *vt
 
 int bgp_show_table_rd(struct vty *vty, struct bgp *bgp, safi_t safi,
 		      struct bgp_table *table, struct prefix_rd *prd_match,
-		      enum bgp_show_type type, void *output_arg, bool use_json)
+		      enum bgp_show_type type, void *output_arg,
+		      uint16_t show_flags)
 {
 	struct bgp_dest *dest, *next;
 	unsigned long output_cum = 0;
@@ -11470,13 +11662,10 @@ int bgp_show_table_rd(struct vty *vty, s
 	unsigned long json_header_depth = 0;
 	struct bgp_table *itable;
 	bool show_msg;
-	uint16_t show_flags = 0;
+	bool use_json = !!CHECK_FLAG(show_flags, BGP_SHOW_OPT_JSON);
 
 	show_msg = (!use_json && type == bgp_show_type_normal);
 
-	if (use_json)
-		SET_FLAG(show_flags, BGP_SHOW_OPT_JSON);
-
 	for (dest = bgp_table_top(table); dest; dest = next) {
 		const struct prefix *dest_p = bgp_dest_get_prefix(dest);
 
@@ -11507,6 +11696,9 @@ int bgp_show_table_rd(struct vty *vty, s
 			vty_out(vty,
 				"\nDisplayed  %ld routes and %ld total paths\n",
 				output_cum, total_cum);
+	} else {
+		if (use_json && output_cum == 0)
+			vty_out(vty, "{}\n");
 	}
 	return CMD_SUCCESS;
 }
@@ -11539,7 +11731,7 @@ static int bgp_show(struct vty *vty, str
 	/* use MPLS and ENCAP specific shows until they are merged */
 	if (safi == SAFI_MPLS_VPN) {
 		return bgp_show_table_rd(vty, bgp, safi, table, NULL, type,
-					 output_arg, use_json);
+					 output_arg, show_flags);
 	}
 
 	if (safi == SAFI_FLOWSPEC && type == bgp_show_type_detail) {
@@ -11548,6 +11740,9 @@ static int bgp_show(struct vty *vty, str
 					       1, NULL, NULL);
 	}
 
+	if (safi == SAFI_EVPN)
+		return bgp_evpn_show_all_routes(vty, bgp, type, use_json, 0);
+
 	return bgp_show_table(vty, bgp, safi, table, type, output_arg, NULL, 1,
 			      NULL, NULL, &json_header_depth, show_flags,
 			      rpki_target_state);
@@ -11595,12 +11790,11 @@ static void bgp_show_all_instances_route
 
 /* Header of detailed BGP route information */
 void route_vty_out_detail_header(struct vty *vty, struct bgp *bgp,
-				 struct bgp_dest *dest,
-				 const struct prefix_rd *prd,
-				 afi_t afi, safi_t safi, json_object *json)
+				 struct bgp_dest *dest, const struct prefix *p,
+				 const struct prefix_rd *prd, afi_t afi,
+				 safi_t safi, json_object *json)
 {
 	struct bgp_path_info *pi;
-	const struct prefix *p;
 	struct peer *peer;
 	struct listnode *node, *nnode;
 	char buf1[RD_ADDRSTRLEN];
@@ -11630,7 +11824,6 @@ void route_vty_out_detail_header(struct
 
 	mpls_lse_decode(dest->local_label, &label, &ttl, &exp, &bos);
 
-	p = bgp_dest_get_prefix(dest);
 	has_valid_label = bgp_is_valid_label(&label);
 
 	if (safi == SAFI_EVPN) {
@@ -11838,8 +12031,9 @@ static void bgp_show_path_info(const str
 
 		if (header) {
 			route_vty_out_detail_header(
-				vty, bgp, bgp_node, pfx_rd,
-				AFI_IP, safi, json_header);
+				vty, bgp, bgp_node,
+				bgp_dest_get_prefix(bgp_node), pfx_rd, AFI_IP,
+				safi, json_header);
 			header = 0;
 		}
 		(*display)++;
@@ -11850,8 +12044,10 @@ static void bgp_show_path_info(const str
 		    || (pathtype == BGP_PATH_SHOW_MULTIPATH
 			&& (CHECK_FLAG(pi->flags, BGP_PATH_MULTIPATH)
 			    || CHECK_FLAG(pi->flags, BGP_PATH_SELECTED))))
-			route_vty_out_detail(vty, bgp, bgp_node, pi, AFI_IP,
-					     safi, rpki_curr_state, json_paths);
+			route_vty_out_detail(vty, bgp, bgp_node,
+					     bgp_dest_get_prefix(bgp_node), pi,
+					     AFI_IP, safi, rpki_curr_state,
+					     json_paths);
 	}
 
 	if (json && json_paths) {
@@ -11866,8 +12062,8 @@ static void bgp_show_path_info(const str
 /*
  * Return rd based on safi
  */
-static const struct prefix_rd *bgp_rd_from_dest(const struct bgp_dest *dest,
-						safi_t safi)
+const struct prefix_rd *bgp_rd_from_dest(const struct bgp_dest *dest,
+					 safi_t safi)
 {
 	switch (safi) {
 	case SAFI_MPLS_VPN:
@@ -11876,7 +12072,6 @@ static const struct prefix_rd *bgp_rd_fr
 		return (struct prefix_rd *)(bgp_dest_get_prefix(dest));
 	default:
 		return NULL;
-
 	}
 }
 
@@ -12420,7 +12615,8 @@ DEFPY(show_ip_bgp, show_ip_bgp_cmd,
           |alias ALIAS_NAME\
           |A.B.C.D/M longer-prefixes\
           |X:X::X:X/M longer-prefixes\
-          ] [json$uj [detail$detail] | wide$wide]",
+          |detail-routes$detail_routes\
+          ] [json$uj [detail$detail_json] | wide$wide]",
       SHOW_STR IP_STR BGP_STR BGP_INSTANCE_HELP_STR BGP_AFI_HELP_STR
 	      BGP_SAFI_WITH_LABEL_HELP_STR
       "Display the entries for all address families\n"
@@ -12468,6 +12664,7 @@ DEFPY(show_ip_bgp, show_ip_bgp_cmd,
       "Display route and more specific routes\n"
       "IPv6 prefix\n"
       "Display route and more specific routes\n"
+      "Display detailed version of all routes\n"
       JSON_STR
       "Display detailed version of JSON output\n"
       "Increase table width for longer prefixes\n")
@@ -12490,8 +12687,11 @@ DEFPY(show_ip_bgp, show_ip_bgp_cmd,
 		SET_FLAG(show_flags, BGP_SHOW_OPT_JSON);
 	}
 
-	if (detail)
-		SET_FLAG(show_flags, BGP_SHOW_OPT_DETAIL);
+	if (detail_json)
+		SET_FLAG(show_flags, BGP_SHOW_OPT_JSON_DETAIL);
+
+	if (detail_routes)
+		SET_FLAG(show_flags, BGP_SHOW_OPT_ROUTES_DETAIL);
 
 	/* [<ipv4|ipv6> [all]] */
 	if (all) {
@@ -13721,7 +13921,8 @@ static void show_adj_route_header(struct
 				  struct bgp_table *table, int *header1,
 				  int *header2, json_object *json,
 				  json_object *json_scode,
-				  json_object *json_ocode, bool wide)
+				  json_object *json_ocode, bool wide,
+				  bool detail)
 {
 	uint64_t version = table ? table->version : 0;
 
@@ -13755,15 +13956,17 @@ static void show_adj_route_header(struct
 			vty_out(vty, "local AS %u\n",
 				peer->change_local_as ? peer->change_local_as
 						      : peer->local_as);
-			vty_out(vty, BGP_SHOW_SCODE_HEADER);
-			vty_out(vty, BGP_SHOW_NCODE_HEADER);
-			vty_out(vty, BGP_SHOW_OCODE_HEADER);
-			vty_out(vty, BGP_SHOW_RPKI_HEADER);
+			if (!detail) {
+				vty_out(vty, BGP_SHOW_SCODE_HEADER);
+				vty_out(vty, BGP_SHOW_NCODE_HEADER);
+				vty_out(vty, BGP_SHOW_OCODE_HEADER);
+				vty_out(vty, BGP_SHOW_RPKI_HEADER);
+			}
 		}
 		*header1 = 0;
 	}
 	if (*header2) {
-		if (!json)
+		if (!json && !detail)
 			vty_out(vty, (wide ? BGP_SHOW_HEADER_WIDE
 					   : BGP_SHOW_HEADER));
 		*header2 = 0;
@@ -13787,12 +13990,15 @@ show_adj_route(struct vty *vty, struct p
 	struct update_subgroup *subgrp;
 	struct peer_af *paf;
 	bool route_filtered;
+	bool detail = CHECK_FLAG(show_flags, BGP_SHOW_OPT_ROUTES_DETAIL);
 	bool use_json = CHECK_FLAG(show_flags, BGP_SHOW_OPT_JSON);
 	bool wide = CHECK_FLAG(show_flags, BGP_SHOW_OPT_WIDE);
 	bool show_rd = ((safi == SAFI_MPLS_VPN) || (safi == SAFI_ENCAP)
 			|| (safi == SAFI_EVPN))
 			       ? true
 			       : false;
+	int display = 0;
+	json_object *json_net = NULL;
 
 	bgp = peer->bgp;
 
@@ -13833,14 +14039,17 @@ show_adj_route(struct vty *vty, struct p
 			vty_out(vty, "local AS %u\n",
 				peer->change_local_as ? peer->change_local_as
 						      : peer->local_as);
-			vty_out(vty, BGP_SHOW_SCODE_HEADER);
-			vty_out(vty, BGP_SHOW_NCODE_HEADER);
-			vty_out(vty, BGP_SHOW_OCODE_HEADER);
-			vty_out(vty, BGP_SHOW_RPKI_HEADER);
+			if (!detail) {
+				vty_out(vty, BGP_SHOW_SCODE_HEADER);
+				vty_out(vty, BGP_SHOW_NCODE_HEADER);
+				vty_out(vty, BGP_SHOW_OCODE_HEADER);
+				vty_out(vty, BGP_SHOW_RPKI_HEADER);
+			}
 
 			vty_out(vty, "Originating default network %s\n\n",
 				(afi == AFI_IP) ? "0.0.0.0/0" : "::/0");
 		}
+		(*output_count)++;
 		*header1 = 0;
 	}
 
@@ -13853,7 +14062,7 @@ show_adj_route(struct vty *vty, struct p
 
 				show_adj_route_header(vty, peer, table, header1,
 						      header2, json, json_scode,
-						      json_ocode, wide);
+						      json_ocode, wide, detail);
 
 				if ((safi == SAFI_MPLS_VPN)
 				    || (safi == SAFI_ENCAP)
@@ -13897,8 +14106,23 @@ show_adj_route(struct vty *vty, struct p
 				    && (route_filtered || ret == RMAP_DENY))
 					(*filtered_count)++;
 
-				route_vty_out_tmp(vty, dest, rn_p, &attr, safi,
-						  use_json, json_ar, wide);
+				if (detail) {
+					if (use_json)
+						json_net =
+							json_object_new_object();
+					bgp_show_path_info(
+						NULL /* prefix_rd */, dest, vty,
+						bgp, afi, safi, json_net,
+						BGP_PATH_SHOW_ALL, &display,
+						RPKI_NOT_BEING_USED);
+					if (use_json)
+						json_object_object_addf(
+							json_ar, json_net,
+							"%pFX", rn_p);
+				} else
+					route_vty_out_tmp(vty, dest, rn_p,
+							  &attr, safi, use_json,
+							  json_ar, wide);
 				bgp_attr_flush(&attr);
 				(*output_count)++;
 			}
@@ -13908,10 +14132,10 @@ show_adj_route(struct vty *vty, struct p
 					if (paf->peer != peer || !adj->attr)
 						continue;
 
-					show_adj_route_header(vty, peer, table,
-							      header1, header2,
-							      json, json_scode,
-							      json_ocode, wide);
+					show_adj_route_header(
+						vty, peer, table, header1,
+						header2, json, json_scode,
+						json_ocode, wide, detail);
 
 					const struct prefix *rn_p =
 						bgp_dest_get_prefix(dest);
@@ -13938,10 +14162,32 @@ show_adj_route(struct vty *vty, struct p
 								show_rd = false;
 							}
 						}
-						route_vty_out_tmp(
-							vty, dest, rn_p, &attr,
-							safi, use_json, json_ar,
-							wide);
+						if (detail) {
+							if (use_json)
+								json_net =
+									json_object_new_object();
+							bgp_show_path_info(
+								NULL /* prefix_rd
+								      */
+								,
+								dest, vty, bgp,
+								afi, safi,
+								json_net,
+								BGP_PATH_SHOW_ALL,
+								&display,
+								RPKI_NOT_BEING_USED);
+							if (use_json)
+								json_object_object_addf(
+									json_ar,
+									json_net,
+									"%pFX",
+									rn_p);
+						} else
+							route_vty_out_tmp(
+								vty, dest, rn_p,
+								&attr, safi,
+								use_json,
+								json_ar, wide);
 						(*output_count)++;
 					} else {
 						(*filtered_count)++;
@@ -13954,7 +14200,7 @@ show_adj_route(struct vty *vty, struct p
 
 			show_adj_route_header(vty, peer, table, header1,
 					      header2, json, json_scode,
-					      json_ocode, wide);
+					      json_ocode, wide, detail);
 
 			for (pi = bgp_dest_get_bgp_path_info(dest); pi;
 			     pi = pi->next) {
@@ -14013,7 +14259,9 @@ static int peer_adj_routes(struct vty *v
 		json_ar = json_object_new_object();
 		json_scode = json_object_new_object();
 		json_ocode = json_object_new_object();
-
+#if CONFDATE > 20231208
+CPP_NOTICE("Drop `bgpStatusCodes` from JSON outputs")
+#endif
 		json_object_string_add(json_scode, "suppressed", "s");
 		json_object_string_add(json_scode, "damped", "d");
 		json_object_string_add(json_scode, "history", "h");
@@ -14025,6 +14273,9 @@ static int peer_adj_routes(struct vty *v
 		json_object_string_add(json_scode, "stale", "S");
 		json_object_string_add(json_scode, "removed", "R");
 
+#if CONFDATE > 20231208
+CPP_NOTICE("Drop `bgpOriginCodes` from JSON outputs")
+#endif
 		json_object_string_add(json_ocode, "igp", "i");
 		json_object_string_add(json_ocode, "egp", "e");
 		json_object_string_add(json_ocode, "incomplete", "?");
@@ -14201,27 +14452,28 @@ DEFPY (show_ip_bgp_instance_neighbor_bes
 			       show_flags);
 }
 
-DEFPY (show_ip_bgp_instance_neighbor_advertised_route,
-       show_ip_bgp_instance_neighbor_advertised_route_cmd,
-       "show [ip] bgp [<view|vrf> VIEWVRFNAME] ["BGP_AFI_CMD_STR" ["BGP_SAFI_WITH_LABEL_CMD_STR"]] [all$all] neighbors <A.B.C.D|X:X::X:X|WORD> <advertised-routes|received-routes|filtered-routes> [route-map RMAP_NAME$route_map] [json$uj | wide$wide]",
-       SHOW_STR
-       IP_STR
-       BGP_STR
-       BGP_INSTANCE_HELP_STR
-       BGP_AFI_HELP_STR
-       BGP_SAFI_WITH_LABEL_HELP_STR
-       "Display the entries for all address families\n"
-       "Detailed information on TCP and BGP neighbor connections\n"
-       "Neighbor to display information about\n"
-       "Neighbor to display information about\n"
-       "Neighbor on BGP configured interface\n"
-       "Display the routes advertised to a BGP neighbor\n"
-       "Display the received routes from neighbor\n"
-       "Display the filtered routes received from neighbor\n"
-       "Route-map to modify the attributes\n"
-       "Name of the route map\n"
-       JSON_STR
-       "Increase table width for longer prefixes\n")
+DEFPY(show_ip_bgp_instance_neighbor_advertised_route,
+      show_ip_bgp_instance_neighbor_advertised_route_cmd,
+      "show [ip] bgp [<view|vrf> VIEWVRFNAME] [" BGP_AFI_CMD_STR " [" BGP_SAFI_WITH_LABEL_CMD_STR "]] [all$all] neighbors <A.B.C.D|X:X::X:X|WORD> <advertised-routes|received-routes|filtered-routes> [route-map RMAP_NAME$route_map] [detail$detail] [json$uj | wide$wide]",
+      SHOW_STR
+      IP_STR
+      BGP_STR
+      BGP_INSTANCE_HELP_STR
+      BGP_AFI_HELP_STR
+      BGP_SAFI_WITH_LABEL_HELP_STR
+      "Display the entries for all address families\n"
+      "Detailed information on TCP and BGP neighbor connections\n"
+      "Neighbor to display information about\n"
+      "Neighbor to display information about\n"
+      "Neighbor on BGP configured interface\n"
+      "Display the routes advertised to a BGP neighbor\n"
+      "Display the received routes from neighbor\n"
+      "Display the filtered routes received from neighbor\n"
+      "Route-map to modify the attributes\n"
+      "Name of the route map\n"
+      "Display detailed version of routes\n"
+      JSON_STR
+      "Increase table width for longer prefixes\n")
 {
 	afi_t afi = AFI_IP6;
 	safi_t safi = SAFI_UNICAST;
@@ -14235,6 +14487,9 @@ DEFPY (show_ip_bgp_instance_neighbor_adv
 	struct listnode *node;
 	struct bgp *abgp;
 
+	if (detail)
+		SET_FLAG(show_flags, BGP_SHOW_OPT_ROUTES_DETAIL);
+
 	if (uj) {
 		argc--;
 		SET_FLAG(show_flags, BGP_SHOW_OPT_JSON);
@@ -14446,7 +14701,7 @@ DEFUN (show_ip_bgp_flowspec_routes_detai
 	struct bgp *bgp = NULL;
 	int idx = 0;
 	bool uj = use_json(argc, argv);
-	uint16_t show_flags = BGP_SHOW_OPT_DETAIL;
+	uint16_t show_flags = BGP_SHOW_OPT_ROUTES_DETAIL;
 
 	if (uj) {
 		argc--;
@@ -14675,6 +14930,7 @@ uint8_t bgp_distance_apply(const struct
 	struct bgp_distance *bdistance;
 	struct access_list *alist;
 	struct bgp_static *bgp_static;
+	struct bgp_path_info *bpi_ultimate;
 
 	if (!bgp)
 		return 0;
@@ -14684,6 +14940,12 @@ uint8_t bgp_distance_apply(const struct
 	if (pinfo->attr->distance)
 		return pinfo->attr->distance;
 
+	/* get peer origin to calculate appropriate distance */
+	if (pinfo->sub_type == BGP_ROUTE_IMPORTED) {
+		bpi_ultimate = bgp_get_imported_bpi_ultimate(pinfo);
+		peer = bpi_ultimate->peer;
+	}
+
 	/* Check source address.
 	 * Note: for aggregate route, peer can have unspec af type.
 	 */
@@ -15287,13 +15549,15 @@ static void bgp_config_write_network_evp
 			/* "network" configuration display.  */
 			if (p->u.prefix_evpn.route_type == 5) {
 				char local_buf[PREFIX_STRLEN];
+
 				uint8_t family = is_evpn_prefix_ipaddr_v4((
 							 struct prefix_evpn *)p)
 							 ? AF_INET
 							 : AF_INET6;
 				inet_ntop(family,
-					  &p->u.prefix_evpn.prefix_addr.ip.ip.addr,
-					  local_buf, PREFIX_STRLEN);
+					  &p->u.prefix_evpn.prefix_addr.ip.ip
+						   .addr,
+					  local_buf, sizeof(local_buf));
 				snprintf(buf, sizeof(buf), "%s/%u", local_buf,
 					 p->u.prefix_evpn.prefix_addr
 						 .ip_prefix_length);
diff -urpN frr-frr-8.4.2/bgpd/bgp_route.h frr-frr-8.5/bgpd/bgp_route.h
--- frr-frr-8.4.2/bgpd/bgp_route.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_route.h	2023-03-13 20:01:47.000000000 +0600
@@ -80,8 +80,8 @@ enum bgp_show_adj_route_type {
 #define BGP_SHOW_NCODE_HEADER "Nexthop codes: @NNN nexthop's vrf id, < announce-nh-self\n"
 #define BGP_SHOW_RPKI_HEADER                                                   \
 	"RPKI validation codes: V valid, I invalid, N Not found\n\n"
-#define BGP_SHOW_HEADER "   Network          Next Hop            Metric LocPrf Weight Path\n"
-#define BGP_SHOW_HEADER_WIDE "   Network                                      Next Hop                                  Metric LocPrf Weight Path\n"
+#define BGP_SHOW_HEADER "    Network          Next Hop            Metric LocPrf Weight Path\n"
+#define BGP_SHOW_HEADER_WIDE "    Network                                      Next Hop                                  Metric LocPrf Weight Path\n"
 
 /* Maximum number of labels we can process or send with a prefix. We
  * really do only 1 for MPLS (BGP-LU) but we can do 2 for EVPN-VxLAN.
@@ -214,9 +214,14 @@ struct bgp_path_info_extra {
 	} vnc;
 #endif
 
-	/* For imported routes into a VNI (or VRF), this points to the parent.
+	/*
+	 * For imported routes into a VNI (or VRF)
 	 */
-	void *parent;
+	void *parent;	    /* parent from global table */
+	union {
+		struct ethaddr mac; /* MAC set here for VNI IP table */
+		struct ipaddr ip;   /* IP set here for VNI MAC table */
+	} vni_info;
 
 	/*
 	 * Some tunnelish parameters follow. Maybe consolidate into an
@@ -289,7 +294,7 @@ struct bgp_path_info {
 	int lock;
 
 	/* BGP information status.  */
-	uint16_t flags;
+	uint32_t flags;
 #define BGP_PATH_IGP_CHANGED (1 << 0)
 #define BGP_PATH_DAMPED (1 << 1)
 #define BGP_PATH_HISTORY (1 << 2)
@@ -306,6 +311,7 @@ struct bgp_path_info {
 #define BGP_PATH_RIB_ATTR_CHG (1 << 13)
 #define BGP_PATH_ANNC_NH_SELF (1 << 14)
 #define BGP_PATH_LINK_BW_CHG (1 << 15)
+#define BGP_PATH_ACCEPT_OWN (1 << 16)
 
 	/* BGP route type.  This can be static, RIP, OSPF, BGP etc.  */
 	uint8_t type;
@@ -657,8 +663,9 @@ DECLARE_HOOK(bgp_process,
 #define BGP_SHOW_OPT_AFI_IP6 (1 << 4)
 #define BGP_SHOW_OPT_ESTABLISHED (1 << 5)
 #define BGP_SHOW_OPT_FAILED (1 << 6)
-#define BGP_SHOW_OPT_DETAIL (1 << 7)
+#define BGP_SHOW_OPT_JSON_DETAIL (1 << 7)
 #define BGP_SHOW_OPT_TERSE (1 << 8)
+#define BGP_SHOW_OPT_ROUTES_DETAIL (1 << 9)
 
 /* Prototypes. */
 extern void bgp_rib_remove(struct bgp_dest *dest, struct bgp_path_info *pi,
@@ -675,7 +682,12 @@ extern void bgp_default_originate(struct
 extern void bgp_soft_reconfig_table_task_cancel(const struct bgp *bgp,
 						const struct bgp_table *table,
 						const struct peer *peer);
-extern void bgp_soft_reconfig_in(struct peer *, afi_t, safi_t);
+
+/*
+ * If this peer is configured for soft reconfig in then do the work
+ * and return true.  If it is not return false; and do nothing
+ */
+extern bool bgp_soft_reconfig_in(struct peer *peer, afi_t afi, safi_t safi);
 extern void bgp_clear_route(struct peer *, afi_t, safi_t);
 extern void bgp_clear_route_all(struct peer *);
 extern void bgp_clear_adj_in(struct peer *, afi_t, safi_t);
@@ -738,17 +750,17 @@ extern int bgp_static_unset_safi(afi_t a
 				 const char *, const char *, const char *);
 
 /* this is primarily for MPLS-VPN */
-extern int bgp_update(struct peer *peer, const struct prefix *p,
-		      uint32_t addpath_id, struct attr *attr,
-		      afi_t afi, safi_t safi, int type, int sub_type,
-		      struct prefix_rd *prd, mpls_label_t *label,
-		      uint32_t num_labels, int soft_reconfig,
-		      struct bgp_route_evpn *evpn);
-extern int bgp_withdraw(struct peer *peer, const struct prefix *p,
-			uint32_t addpath_id, struct attr *attr, afi_t afi,
-			safi_t safi, int type, int sub_type,
-			struct prefix_rd *prd, mpls_label_t *label,
-			uint32_t num_labels, struct bgp_route_evpn *evpn);
+extern void bgp_update(struct peer *peer, const struct prefix *p,
+		       uint32_t addpath_id, struct attr *attr, afi_t afi,
+		       safi_t safi, int type, int sub_type,
+		       struct prefix_rd *prd, mpls_label_t *label,
+		       uint32_t num_labels, int soft_reconfig,
+		       struct bgp_route_evpn *evpn);
+extern void bgp_withdraw(struct peer *peer, const struct prefix *p,
+			 uint32_t addpath_id, struct attr *attr, afi_t afi,
+			 safi_t safi, int type, int sub_type,
+			 struct prefix_rd *prd, mpls_label_t *label,
+			 uint32_t num_labels, struct bgp_route_evpn *evpn);
 
 /* for bgp_nexthop and bgp_damp */
 extern void bgp_process(struct bgp *, struct bgp_dest *, afi_t, safi_t);
@@ -843,17 +855,18 @@ extern bool bgp_zebra_has_route_changed(
 
 extern void route_vty_out_detail_header(struct vty *vty, struct bgp *bgp,
 					struct bgp_dest *dest,
+					const struct prefix *p,
 					const struct prefix_rd *prd, afi_t afi,
 					safi_t safi, json_object *json);
 extern void route_vty_out_detail(struct vty *vty, struct bgp *bgp,
-				 struct bgp_dest *bn,
+				 struct bgp_dest *bn, const struct prefix *p,
 				 struct bgp_path_info *path, afi_t afi,
 				 safi_t safi, enum rpki_states,
 				 json_object *json_paths);
 extern int bgp_show_table_rd(struct vty *vty, struct bgp *bgp, safi_t safi,
 			     struct bgp_table *table, struct prefix_rd *prd,
 			     enum bgp_show_type type, void *output_arg,
-			     bool use_json);
+			     uint16_t show_flags);
 extern void bgp_best_path_select_defer(struct bgp *bgp, afi_t afi, safi_t safi);
 extern bool bgp_update_martian_nexthop(struct bgp *bgp, afi_t afi, safi_t safi,
 				       uint8_t type, uint8_t stype,
@@ -868,4 +881,14 @@ extern void subgroup_announce_reset_nhop
 const char *
 bgp_path_selection_reason2str(enum bgp_path_selection_reason reason);
 extern bool bgp_addpath_encode_rx(struct peer *peer, afi_t afi, safi_t safi);
+extern const struct prefix_rd *bgp_rd_from_dest(const struct bgp_dest *dest,
+						safi_t safi);
+extern void bgp_path_info_free_with_caller(const char *caller,
+					   struct bgp_path_info *path);
+extern void bgp_path_info_add_with_caller(const char *caller,
+					  struct bgp_dest *dest,
+					  struct bgp_path_info *pi);
+#define bgp_path_info_add(A, B)                                                \
+	bgp_path_info_add_with_caller(__func__, (A), (B))
+#define bgp_path_info_free(B) bgp_path_info_free_with_caller(__func__, (B))
 #endif /* _QUAGGA_BGP_ROUTE_H */
diff -urpN frr-frr-8.4.2/bgpd/bgp_routemap.c frr-frr-8.5/bgpd/bgp_routemap.c
--- frr-frr-8.4.2/bgpd/bgp_routemap.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_routemap.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,11 +30,16 @@
 #include "log.h"
 #include "frrlua.h"
 #include "frrscript.h"
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 #include "buffer.h"
 #include "sockunion.h"
 #include "hash.h"
@@ -74,9 +79,7 @@
 #include "bgpd/rfapi/bgp_rfapi_cfg.h"
 #endif
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_routemap_clippy.c"
-#endif
 
 /* Memo of route-map commands.
 
@@ -643,6 +646,20 @@ route_match_prefix_list_flowspec(afi_t a
 }
 
 static enum route_map_cmd_result_t
+route_match_prefix_list_evpn(afi_t afi, struct prefix_list *plist,
+			     const struct prefix *p)
+{
+	/* Convert to match a general plist */
+	struct prefix new;
+
+	if (evpn_prefix2prefix(p, &new))
+		return RMAP_NOMATCH;
+
+	return (prefix_list_apply(plist, &new) == PREFIX_DENY ? RMAP_NOMATCH
+							      : RMAP_MATCH);
+}
+
+static enum route_map_cmd_result_t
 route_match_address_prefix_list(void *rule, afi_t afi,
 				const struct prefix *prefix, void *object)
 {
@@ -655,6 +672,10 @@ route_match_address_prefix_list(void *ru
 	if (prefix->family == AF_FLOWSPEC)
 		return route_match_prefix_list_flowspec(afi, plist,
 							prefix);
+
+	else if (prefix->family == AF_EVPN)
+		return route_match_prefix_list_evpn(afi, plist, prefix);
+
 	return (prefix_list_apply(plist, prefix) == PREFIX_DENY ? RMAP_NOMATCH
 								: RMAP_MATCH);
 }
@@ -3025,6 +3046,46 @@ static const struct route_map_rule_cmd r
 	route_set_atomic_aggregate_free,
 };
 
+/* AIGP TLV Metric */
+static enum route_map_cmd_result_t
+route_set_aigp_metric(void *rule, const struct prefix *pfx, void *object)
+{
+	const char *aigp_metric = rule;
+	struct bgp_path_info *path = object;
+	uint32_t aigp = 0;
+
+	if (strmatch(aigp_metric, "igp-metric")) {
+		if (!path->nexthop)
+			return RMAP_NOMATCH;
+
+		bgp_attr_set_aigp_metric(path->attr, path->nexthop->metric);
+	} else {
+		aigp = atoi(aigp_metric);
+		bgp_attr_set_aigp_metric(path->attr, aigp);
+	}
+
+	path->attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AIGP);
+
+	return RMAP_OKAY;
+}
+
+static void *route_set_aigp_metric_compile(const char *arg)
+{
+	return XSTRDUP(MTYPE_ROUTE_MAP_COMPILED, arg);
+}
+
+static void route_set_aigp_metric_free(void *rule)
+{
+	XFREE(MTYPE_ROUTE_MAP_COMPILED, rule);
+}
+
+static const struct route_map_rule_cmd route_set_aigp_metric_cmd = {
+	"aigp-metric",
+	route_set_aigp_metric,
+	route_set_aigp_metric_compile,
+	route_set_aigp_metric_free,
+};
+
 /* `set aggregator as AS A.B.C.D' */
 struct aggregator {
 	as_t as;
@@ -3515,16 +3576,29 @@ route_set_ipv6_nexthop_local(void *rule,
 {
 	struct in6_addr *address;
 	struct bgp_path_info *path;
+	struct bgp_dest *dest;
+	struct bgp_table *table = NULL;
 
 	/* Fetch routemap's rule information. */
 	address = rule;
 	path = object;
+	dest = path->net;
+
+	if (!dest)
+		return RMAP_OKAY;
+
+	table = bgp_dest_table(dest);
+	if (!table)
+		return RMAP_OKAY;
 
 	/* Set next hop value. */
 	path->attr->mp_nexthop_local = *address;
 
 	/* Set nexthop length. */
-	if (path->attr->mp_nexthop_len != BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)
+	if (table->safi == SAFI_MPLS_VPN || table->safi == SAFI_ENCAP ||
+	    table->safi == SAFI_EVPN)
+		path->attr->mp_nexthop_len = BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL;
+	else
 		path->attr->mp_nexthop_len = BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL;
 
 	SET_FLAG(path->attr->rmap_change_flags,
@@ -3664,6 +3738,8 @@ route_set_vpnv4_nexthop(void *rule, cons
 	path->attr->mp_nexthop_global_in = *address;
 	path->attr->mp_nexthop_len = BGP_ATTR_NHLEN_IPV4;
 
+	SET_FLAG(path->attr->rmap_change_flags, BATTR_RMAP_VPNV4_NHOP_CHANGED);
+
 	return RMAP_OKAY;
 }
 
@@ -3701,6 +3777,9 @@ route_set_vpnv6_nexthop(void *rule, cons
 	       sizeof(struct in6_addr));
 	path->attr->mp_nexthop_len = BGP_ATTR_NHLEN_VPNV6_GLOBAL;
 
+	SET_FLAG(path->attr->rmap_change_flags,
+		 BATTR_RMAP_VPNV6_GLOBAL_NHOP_CHANGED);
+
 	return RMAP_OKAY;
 }
 
@@ -4079,7 +4158,7 @@ static void bgp_route_map_process_update
 						safi2str(safi),
 						inet_ntop(bn_p->family,
 							  &bn_p->u.prefix, buf,
-							  INET6_ADDRSTRLEN));
+							  sizeof(buf)));
 				bgp_static_update(bgp, bn_p, bgp_static, afi,
 						  safi);
 			}
@@ -4131,7 +4210,7 @@ static void bgp_route_map_process_update
 						safi2str(safi),
 						inet_ntop(bn_p->family,
 							  &bn_p->u.prefix, buf,
-							  INET6_ADDRSTRLEN));
+							  sizeof(buf)));
 				bgp_aggregate_route(bgp, bn_p, afi, safi,
 						    aggregate);
 			}
@@ -6336,6 +6415,42 @@ DEFUN_YANG (no_set_atomic_aggregate,
 	return nb_cli_apply_changes(vty, NULL);
 }
 
+DEFPY_YANG (set_aigp_metric,
+	    set_aigp_metric_cmd,
+	    "set aigp-metric <igp-metric|(1-4294967295)>$aigp_metric",
+	    SET_STR
+	    "BGP AIGP attribute (AIGP Metric TLV)\n"
+	    "AIGP Metric value from IGP protocol\n"
+	    "Manual AIGP Metric value\n")
+{
+	const char *xpath =
+		"./set-action[action='frr-bgp-route-map:aigp-metric']";
+	char xpath_value[XPATH_MAXLEN];
+
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
+	snprintf(xpath_value, sizeof(xpath_value),
+		 "%s/rmap-set-action/frr-bgp-route-map:aigp-metric", xpath);
+	nb_cli_enqueue_change(vty, xpath_value, NB_OP_MODIFY, aigp_metric);
+
+	return nb_cli_apply_changes(vty, NULL);
+}
+
+DEFPY_YANG (no_set_aigp_metric,
+	    no_set_aigp_metric_cmd,
+	    "no set aigp-metric [<igp-metric|(1-4294967295)>]",
+	    NO_STR
+	    SET_STR
+	    "BGP AIGP attribute (AIGP Metric TLV)\n"
+	    "AIGP Metric value from IGP protocol\n"
+	    "Manual AIGP Metric value\n")
+{
+	const char *xpath =
+		"./set-action[action='frr-bgp-route-map:aigp-metric']";
+
+	nb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);
+	return nb_cli_apply_changes(vty, NULL);
+}
+
 DEFUN_YANG (set_aggregator_as,
 	    set_aggregator_as_cmd,
 	    "set aggregator as (1-4294967295) A.B.C.D",
@@ -7005,6 +7120,7 @@ void bgp_route_map_init(void)
 	route_map_install_set(&route_set_aspath_replace_cmd);
 	route_map_install_set(&route_set_origin_cmd);
 	route_map_install_set(&route_set_atomic_aggregate_cmd);
+	route_map_install_set(&route_set_aigp_metric_cmd);
 	route_map_install_set(&route_set_aggregator_as_cmd);
 	route_map_install_set(&route_set_community_cmd);
 	route_map_install_set(&route_set_community_delete_cmd);
@@ -7087,6 +7203,8 @@ void bgp_route_map_init(void)
 	install_element(RMAP_NODE, &no_set_origin_cmd);
 	install_element(RMAP_NODE, &set_atomic_aggregate_cmd);
 	install_element(RMAP_NODE, &no_set_atomic_aggregate_cmd);
+	install_element(RMAP_NODE, &set_aigp_metric_cmd);
+	install_element(RMAP_NODE, &no_set_aigp_metric_cmd);
 	install_element(RMAP_NODE, &set_aggregator_as_cmd);
 	install_element(RMAP_NODE, &no_set_aggregator_as_cmd);
 	install_element(RMAP_NODE, &set_community_cmd);
diff -urpN frr-frr-8.4.2/bgpd/bgp_routemap_nb.c frr-frr-8.5/bgpd/bgp_routemap_nb.c
--- frr-frr-8.4.2/bgpd/bgp_routemap_nb.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_routemap_nb.c	2023-03-13 20:01:47.000000000 +0600
@@ -283,6 +283,13 @@ const struct frr_yang_module_info frr_bg
 			}
 		},
 		{
+			.xpath = "/frr-route-map:lib/route-map/entry/set-action/rmap-set-action/frr-bgp-route-map:aigp-metric",
+			.cbs = {
+				.modify = lib_route_map_entry_set_action_rmap_set_action_aigp_metric_modify,
+				.destroy = lib_route_map_entry_set_action_rmap_set_action_aigp_metric_destroy,
+			}
+		},
+		{
 			.xpath = "/frr-route-map:lib/route-map/entry/set-action/rmap-set-action/frr-bgp-route-map:prepend-as-path",
 			.cbs = {
 				.modify = lib_route_map_entry_set_action_rmap_set_action_prepend_as_path_modify,
diff -urpN frr-frr-8.4.2/bgpd/bgp_routemap_nb.h frr-frr-8.5/bgpd/bgp_routemap_nb.h
--- frr-frr-8.4.2/bgpd/bgp_routemap_nb.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_routemap_nb.h	2023-03-13 20:01:47.000000000 +0600
@@ -106,6 +106,10 @@ int lib_route_map_entry_set_action_rmap_
 int lib_route_map_entry_set_action_rmap_set_action_table_destroy(struct nb_cb_destroy_args *args);
 int lib_route_map_entry_set_action_rmap_set_action_atomic_aggregate_create(struct nb_cb_create_args *args);
 int lib_route_map_entry_set_action_rmap_set_action_atomic_aggregate_destroy(struct nb_cb_destroy_args *args);
+int lib_route_map_entry_set_action_rmap_set_action_aigp_metric_modify(
+	struct nb_cb_modify_args *args);
+int lib_route_map_entry_set_action_rmap_set_action_aigp_metric_destroy(
+	struct nb_cb_destroy_args *args);
 int lib_route_map_entry_set_action_rmap_set_action_prepend_as_path_modify(struct nb_cb_modify_args *args);
 int lib_route_map_entry_set_action_rmap_set_action_prepend_as_path_destroy(struct nb_cb_destroy_args *args);
 int lib_route_map_entry_set_action_rmap_set_action_last_as_modify(struct nb_cb_modify_args *args);
diff -urpN frr-frr-8.4.2/bgpd/bgp_routemap_nb_config.c frr-frr-8.5/bgpd/bgp_routemap_nb_config.c
--- frr-frr-8.4.2/bgpd/bgp_routemap_nb_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_routemap_nb_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -2090,6 +2090,58 @@ lib_route_map_entry_set_action_rmap_set_
 
 /*
  * XPath:
+ * /frr-route-map:lib/route-map/entry/set-action/rmap-set-action/frr-bgp-route-map:aigp-metric
+ */
+int lib_route_map_entry_set_action_rmap_set_action_aigp_metric_modify(
+	struct nb_cb_modify_args *args)
+{
+	struct routemap_hook_context *rhc;
+	const char *aigp;
+	int rv;
+
+	switch (args->event) {
+	case NB_EV_VALIDATE:
+	case NB_EV_PREPARE:
+	case NB_EV_ABORT:
+		break;
+	case NB_EV_APPLY:
+		/* Add configuration. */
+		rhc = nb_running_get_entry(args->dnode, NULL, true);
+		aigp = yang_dnode_get_string(args->dnode, NULL);
+
+		/* Set destroy information. */
+		rhc->rhc_shook = generic_set_delete;
+		rhc->rhc_rule = "aigp-metric";
+		rhc->rhc_event = RMAP_EVENT_SET_DELETED;
+
+		rv = generic_set_add(rhc->rhc_rmi, rhc->rhc_rule, aigp,
+				     args->errmsg, args->errmsg_len);
+		if (rv != CMD_SUCCESS) {
+			rhc->rhc_shook = NULL;
+			return NB_ERR_INCONSISTENCY;
+		}
+	}
+
+	return NB_OK;
+}
+
+int lib_route_map_entry_set_action_rmap_set_action_aigp_metric_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	switch (args->event) {
+	case NB_EV_VALIDATE:
+	case NB_EV_PREPARE:
+	case NB_EV_ABORT:
+		break;
+	case NB_EV_APPLY:
+		return lib_route_map_entry_set_destroy(args);
+	}
+
+	return NB_OK;
+}
+
+/*
+ * XPath:
  * /frr-route-map:lib/route-map/entry/set-action/rmap-set-action/frr-bgp-route-map:prepend-as-path
  */
 int
diff -urpN frr-frr-8.4.2/bgpd/bgp_rpki.c frr-frr-8.5/bgpd/bgp_rpki.c
--- frr-frr-8.4.2/bgpd/bgp_rpki.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_rpki.c	2023-03-13 20:01:47.000000000 +0600
@@ -52,20 +52,17 @@
 
 #include "lib/network.h"
 #include "lib/thread.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "rtrlib/rtrlib.h"
-#endif
 #include "hook.h"
 #include "libfrr.h"
 #include "lib/version.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "bgpd/bgp_rpki_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(BGPD, BGP_RPKI_CACHE, "BGP RPKI Cache server");
 DEFINE_MTYPE_STATIC(BGPD, BGP_RPKI_CACHE_GROUP, "BGP RPKI Cache server group");
 DEFINE_MTYPE_STATIC(BGPD, BGP_RPKI_RTRLIB, "BGP RPKI RTRLib");
+DEFINE_MTYPE_STATIC(BGPD, BGP_RPKI_REVALIDATE, "BGP RPKI Revalidation");
 
 #define POLLING_PERIOD_DEFAULT 3600
 #define EXPIRE_INTERVAL_DEFAULT 7200
@@ -375,10 +372,9 @@ inline bool is_stopping(void)
 	return rtr_is_stopping;
 }
 
-static struct prefix *pfx_record_to_prefix(struct pfx_record *record)
+static void pfx_record_to_prefix(struct pfx_record *record,
+				 struct prefix *prefix)
 {
-	struct prefix *prefix = prefix_new();
-
 	prefix->prefixlen = record->min_len;
 
 	if (record->prefix.ver == LRTR_IPV4) {
@@ -389,15 +385,41 @@ static struct prefix *pfx_record_to_pref
 		ipv6_addr_to_network_byte_order(record->prefix.u.addr6.addr,
 						prefix->u.prefix6.s6_addr32);
 	}
+}
+
+struct rpki_revalidate_prefix {
+	struct bgp *bgp;
+	struct prefix prefix;
+	afi_t afi;
+	safi_t safi;
+};
+
+static void rpki_revalidate_prefix(struct thread *thread)
+{
+	struct rpki_revalidate_prefix *rrp = THREAD_ARG(thread);
+	struct bgp_dest *match, *node;
+
+	match = bgp_table_subtree_lookup(rrp->bgp->rib[rrp->afi][rrp->safi],
+					 &rrp->prefix);
+
+	node = match;
+
+	while (node) {
+		if (bgp_dest_has_bgp_path_info_data(node)) {
+			revalidate_bgp_node(node, rrp->afi, rrp->safi);
+		}
+
+		node = bgp_route_next_until(node, match);
+	}
 
-	return prefix;
+	XFREE(MTYPE_BGP_RPKI_REVALIDATE, rrp);
 }
 
 static void bgpd_sync_callback(struct thread *thread)
 {
 	struct bgp *bgp;
 	struct listnode *node;
-	struct prefix *prefix;
+	struct prefix prefix;
 	struct pfx_record rec;
 
 	thread_add_read(bm->master, bgpd_sync_callback, NULL,
@@ -420,7 +442,7 @@ static void bgpd_sync_callback(struct th
 		RPKI_DEBUG("Could not read from rpki_sync_socket_bgpd");
 		return;
 	}
-	prefix = pfx_record_to_prefix(&rec);
+	pfx_record_to_prefix(&rec, &prefix);
 
 	afi_t afi = (rec.prefix.ver == LRTR_IPV4) ? AFI_IP : AFI_IP6;
 
@@ -429,27 +451,20 @@ static void bgpd_sync_callback(struct th
 
 		for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++) {
 			struct bgp_table *table = bgp->rib[afi][safi];
+			struct rpki_revalidate_prefix *rrp;
 
 			if (!table)
 				continue;
 
-			struct bgp_dest *match;
-			struct bgp_dest *node;
-
-			match = bgp_table_subtree_lookup(table, prefix);
-			node = match;
-
-			while (node) {
-				if (bgp_dest_has_bgp_path_info_data(node)) {
-					revalidate_bgp_node(node, afi, safi);
-				}
-
-				node = bgp_route_next_until(node, match);
-			}
+			rrp = XCALLOC(MTYPE_BGP_RPKI_REVALIDATE, sizeof(*rrp));
+			rrp->bgp = bgp;
+			rrp->prefix = prefix;
+			rrp->afi = afi;
+			rrp->safi = safi;
+			thread_add_event(bm->master, rpki_revalidate_prefix,
+					 rrp, 0, &bgp->t_revalidate[afi][safi]);
 		}
 	}
-
-	prefix_free(&prefix);
 }
 
 static void revalidate_bgp_node(struct bgp_dest *bgp_dest, afi_t afi,
@@ -474,6 +489,31 @@ static void revalidate_bgp_node(struct b
 	}
 }
 
+/*
+ * The act of a soft reconfig in revalidation is really expensive
+ * coupled with the fact that the download of a full rpki state
+ * from a rpki server can be expensive, let's break up the revalidation
+ * to a point in time in the future to allow other bgp events
+ * to take place too.
+ */
+struct rpki_revalidate_peer {
+	afi_t afi;
+	safi_t safi;
+	struct peer *peer;
+};
+
+static void bgp_rpki_revalidate_peer(struct thread *thread)
+{
+	struct rpki_revalidate_peer *rvp = THREAD_ARG(thread);
+
+	/*
+	 * Here's the expensive bit of gnomish deviousness
+	 */
+	bgp_soft_reconfig_in(rvp->peer, rvp->afi, rvp->safi);
+
+	XFREE(MTYPE_BGP_RPKI_REVALIDATE, rvp);
+}
+
 static void revalidate_all_routes(void)
 {
 	struct bgp *bgp;
@@ -484,18 +524,28 @@ static void revalidate_all_routes(void)
 		struct listnode *peer_listnode;
 
 		for (ALL_LIST_ELEMENTS_RO(bgp->peer, peer_listnode, peer)) {
+			afi_t afi;
+			safi_t safi;
+
+			FOREACH_AFI_SAFI (afi, safi) {
+				struct rpki_revalidate_peer *rvp;
 
-			for (size_t i = 0; i < 2; i++) {
-				safi_t safi;
-				afi_t afi = (i == 0) ? AFI_IP : AFI_IP6;
-
-				for (safi = SAFI_UNICAST; safi < SAFI_MAX;
-				     safi++) {
-					if (!peer->bgp->rib[afi][safi])
-						continue;
+				if (!bgp->rib[afi][safi])
+					continue;
 
-					bgp_soft_reconfig_in(peer, afi, safi);
-				}
+				if (!peer_established(peer))
+					continue;
+
+				rvp = XCALLOC(MTYPE_BGP_RPKI_REVALIDATE,
+					      sizeof(*rvp));
+				rvp->peer = peer;
+				rvp->afi = afi;
+				rvp->safi = safi;
+
+				thread_add_event(
+					bm->master, bgp_rpki_revalidate_peer,
+					rvp, 0,
+					&peer->t_revalidate_all[afi][safi]);
 			}
 		}
 	}
@@ -589,7 +639,7 @@ static int bgp_rpki_module_init(void)
 
 	hook_register(bgp_rpki_prefix_status, rpki_validate_prefix);
 	hook_register(frr_late_init, bgp_rpki_init);
-	hook_register(frr_early_fini, &bgp_rpki_fini);
+	hook_register(frr_early_fini, bgp_rpki_fini);
 
 	return 0;
 }
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp.c frr-frr-8.5/bgpd/bgp_snmp.c
--- frr-frr-8.4.2/bgpd/bgp_snmp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp.c	2023-03-13 20:01:47.000000000 +0600
@@ -40,864 +40,16 @@
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_fsm.h"
+#include "bgpd/bgp_snmp.h"
+#include "bgpd/bgp_snmp_bgp4.h"
+#include "bgpd/bgp_snmp_bgp4v2.h"
 #include "bgpd/bgp_mplsvpn_snmp.h"
 
-/* BGP4-MIB described in RFC1657. */
-#define BGP4MIB 1,3,6,1,2,1,15
-
-/* BGP TRAP. */
-#define BGPESTABLISHED			1
-#define BGPBACKWARDTRANSITION		2
-
-/* BGP MIB bgpVersion. */
-#define BGPVERSION			      0
-
-/* BGP MIB bgpLocalAs. */
-#define BGPLOCALAS			      0
-
-/* BGP MIB bgpPeerTable. */
-#define BGPPEERIDENTIFIER                     1
-#define BGPPEERSTATE                          2
-#define BGPPEERADMINSTATUS                    3
-#define BGPPEERNEGOTIATEDVERSION              4
-#define BGPPEERLOCALADDR                      5
-#define BGPPEERLOCALPORT                      6
-#define BGPPEERREMOTEADDR                     7
-#define BGPPEERREMOTEPORT                     8
-#define BGPPEERREMOTEAS                       9
-#define BGPPEERINUPDATES                     10
-#define BGPPEEROUTUPDATES                    11
-#define BGPPEERINTOTALMESSAGES               12
-#define BGPPEEROUTTOTALMESSAGES              13
-#define BGPPEERLASTERROR                     14
-#define BGPPEERFSMESTABLISHEDTRANSITIONS     15
-#define BGPPEERFSMESTABLISHEDTIME            16
-#define BGPPEERCONNECTRETRYINTERVAL          17
-#define BGPPEERHOLDTIME                      18
-#define BGPPEERKEEPALIVE                     19
-#define BGPPEERHOLDTIMECONFIGURED            20
-#define BGPPEERKEEPALIVECONFIGURED           21
-#define BGPPEERMINROUTEADVERTISEMENTINTERVAL 22
-#define BGPPEERINUPDATEELAPSEDTIME           23
-
-/* BGP MIB bgpIdentifier. */
-#define BGPIDENTIFIER                         0
-
-/* BGP MIB bgpRcvdPathAttrTable */
-#define BGPPATHATTRPEER                       1
-#define BGPPATHATTRDESTNETWORK                2
-#define BGPPATHATTRORIGIN                     3
-#define BGPPATHATTRASPATH                     4
-#define BGPPATHATTRNEXTHOP                    5
-#define BGPPATHATTRINTERASMETRIC              6
-
-/* BGP MIB bgp4PathAttrTable. */
-#define BGP4PATHATTRPEER                      1
-#define BGP4PATHATTRIPADDRPREFIXLEN           2
-#define BGP4PATHATTRIPADDRPREFIX              3
-#define BGP4PATHATTRORIGIN                    4
-#define BGP4PATHATTRASPATHSEGMENT             5
-#define BGP4PATHATTRNEXTHOP                   6
-#define BGP4PATHATTRMULTIEXITDISC             7
-#define BGP4PATHATTRLOCALPREF                 8
-#define BGP4PATHATTRATOMICAGGREGATE           9
-#define BGP4PATHATTRAGGREGATORAS             10
-#define BGP4PATHATTRAGGREGATORADDR           11
-#define BGP4PATHATTRCALCLOCALPREF            12
-#define BGP4PATHATTRBEST                     13
-#define BGP4PATHATTRUNKNOWN                  14
-
-/* SNMP value hack. */
-#define INTEGER ASN_INTEGER
-#define INTEGER32 ASN_INTEGER
-#define COUNTER32 ASN_COUNTER
-#define OCTET_STRING ASN_OCTET_STR
-#define IPADDRESS ASN_IPADDRESS
-#define GAUGE32 ASN_UNSIGNED
-
-/* Declare static local variables for convenience. */
-SNMP_LOCAL_VARIABLES
-
-/* BGP-MIB instances. */
-static oid bgp_oid[] = {BGP4MIB};
-static oid bgp_trap_oid[] = {BGP4MIB, 0};
-
-/* IP address 0.0.0.0. */
-static struct in_addr bgp_empty_addr = {.s_addr = 0};
-
-/* Hook functions. */
-static uint8_t *bgpVersion(struct variable *, oid[], size_t *, int, size_t *,
-			   WriteMethod **);
-static uint8_t *bgpLocalAs(struct variable *, oid[], size_t *, int, size_t *,
-			   WriteMethod **);
-static uint8_t *bgpPeerTable(struct variable *, oid[], size_t *, int, size_t *,
-			     WriteMethod **);
-static uint8_t *bgpRcvdPathAttrTable(struct variable *, oid[], size_t *, int,
-				     size_t *, WriteMethod **);
-static uint8_t *bgpIdentifier(struct variable *, oid[], size_t *, int, size_t *,
-			      WriteMethod **);
-static uint8_t *bgp4PathAttrTable(struct variable *, oid[], size_t *, int,
-				  size_t *, WriteMethod **);
-/* static uint8_t *bgpTraps (); */
-
-static struct variable bgp_variables[] = {
-	/* BGP version. */
-	{BGPVERSION, OCTET_STRING, RONLY, bgpVersion, 1, {1}},
-	/* BGP local AS. */
-	{BGPLOCALAS, INTEGER, RONLY, bgpLocalAs, 1, {2}},
-	/* BGP peer table. */
-	{BGPPEERIDENTIFIER, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 1}},
-	{BGPPEERSTATE, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 2}},
-	{BGPPEERADMINSTATUS, INTEGER, RWRITE, bgpPeerTable, 3, {3, 1, 3}},
-	{BGPPEERNEGOTIATEDVERSION,
-	 INTEGER32,
-	 RONLY,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 4}},
-	{BGPPEERLOCALADDR, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 5}},
-	{BGPPEERLOCALPORT, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 6}},
-	{BGPPEERREMOTEADDR, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 7}},
-	{BGPPEERREMOTEPORT, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 8}},
-	{BGPPEERREMOTEAS, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 9}},
-	{BGPPEERINUPDATES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 10}},
-	{BGPPEEROUTUPDATES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 11}},
-	{BGPPEERINTOTALMESSAGES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 12}},
-	{BGPPEEROUTTOTALMESSAGES,
-	 COUNTER32,
-	 RONLY,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 13}},
-	{BGPPEERLASTERROR, OCTET_STRING, RONLY, bgpPeerTable, 3, {3, 1, 14}},
-	{BGPPEERFSMESTABLISHEDTRANSITIONS,
-	 COUNTER32,
-	 RONLY,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 15}},
-	{BGPPEERFSMESTABLISHEDTIME,
-	 GAUGE32,
-	 RONLY,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 16}},
-	{BGPPEERCONNECTRETRYINTERVAL,
-	 INTEGER,
-	 RWRITE,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 17}},
-	{BGPPEERHOLDTIME, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 18}},
-	{BGPPEERKEEPALIVE, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 19}},
-	{BGPPEERHOLDTIMECONFIGURED,
-	 INTEGER,
-	 RWRITE,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 20}},
-	{BGPPEERKEEPALIVECONFIGURED,
-	 INTEGER,
-	 RWRITE,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 21}},
-	{BGPPEERMINROUTEADVERTISEMENTINTERVAL,
-	 INTEGER,
-	 RWRITE,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 23}},
-	{BGPPEERINUPDATEELAPSEDTIME,
-	 GAUGE32,
-	 RONLY,
-	 bgpPeerTable,
-	 3,
-	 {3, 1, 24}},
-	/* BGP identifier. */
-	{BGPIDENTIFIER, IPADDRESS, RONLY, bgpIdentifier, 1, {4}},
-	/* BGP received path attribute table. */
-	{BGPPATHATTRPEER, IPADDRESS, RONLY, bgpRcvdPathAttrTable, 3, {5, 1, 1}},
-	{BGPPATHATTRDESTNETWORK,
-	 IPADDRESS,
-	 RONLY,
-	 bgpRcvdPathAttrTable,
-	 3,
-	 {5, 1, 2}},
-	{BGPPATHATTRORIGIN, INTEGER, RONLY, bgpRcvdPathAttrTable, 3, {5, 1, 3}},
-	{BGPPATHATTRASPATH,
-	 OCTET_STRING,
-	 RONLY,
-	 bgpRcvdPathAttrTable,
-	 3,
-	 {5, 1, 4}},
-	{BGPPATHATTRNEXTHOP,
-	 IPADDRESS,
-	 RONLY,
-	 bgpRcvdPathAttrTable,
-	 3,
-	 {5, 1, 5}},
-	{BGPPATHATTRINTERASMETRIC,
-	 INTEGER32,
-	 RONLY,
-	 bgpRcvdPathAttrTable,
-	 3,
-	 {5, 1, 6}},
-	/* BGP-4 received path attribute table. */
-	{BGP4PATHATTRPEER, IPADDRESS, RONLY, bgp4PathAttrTable, 3, {6, 1, 1}},
-	{BGP4PATHATTRIPADDRPREFIXLEN,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 2}},
-	{BGP4PATHATTRIPADDRPREFIX,
-	 IPADDRESS,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 3}},
-	{BGP4PATHATTRORIGIN, INTEGER, RONLY, bgp4PathAttrTable, 3, {6, 1, 4}},
-	{BGP4PATHATTRASPATHSEGMENT,
-	 OCTET_STRING,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 5}},
-	{BGP4PATHATTRNEXTHOP,
-	 IPADDRESS,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 6}},
-	{BGP4PATHATTRMULTIEXITDISC,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 7}},
-	{BGP4PATHATTRLOCALPREF,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 8}},
-	{BGP4PATHATTRATOMICAGGREGATE,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 9}},
-	{BGP4PATHATTRAGGREGATORAS,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 10}},
-	{BGP4PATHATTRAGGREGATORADDR,
-	 IPADDRESS,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 11}},
-	{BGP4PATHATTRCALCLOCALPREF,
-	 INTEGER,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 12}},
-	{BGP4PATHATTRBEST, INTEGER, RONLY, bgp4PathAttrTable, 3, {6, 1, 13}},
-	{BGP4PATHATTRUNKNOWN,
-	 OCTET_STRING,
-	 RONLY,
-	 bgp4PathAttrTable,
-	 3,
-	 {6, 1, 14}},
-};
-
-
-static uint8_t *bgpVersion(struct variable *v, oid name[], size_t *length,
-			   int exact, size_t *var_len,
-			   WriteMethod **write_method)
-{
-	static uint8_t version;
-
-	if (smux_header_generic(v, name, length, exact, var_len, write_method)
-	    == MATCH_FAILED)
-		return NULL;
-
-	/* Return BGP version.  Zebra bgpd only support version 4. */
-	version = (0x80 >> (BGP_VERSION_4 - 1));
-
-	/* Return octet string length 1. */
-	*var_len = 1;
-	return &version;
-}
-
-static uint8_t *bgpLocalAs(struct variable *v, oid name[], size_t *length,
-			   int exact, size_t *var_len,
-			   WriteMethod **write_method)
-{
-	struct bgp *bgp;
-
-	if (smux_header_generic(v, name, length, exact, var_len, write_method)
-	    == MATCH_FAILED)
-		return NULL;
-
-	/* Get BGP structure. */
-	bgp = bgp_get_default();
-	if (!bgp)
-		return NULL;
-
-	return SNMP_INTEGER(bgp->as);
-}
-
-static struct peer *peer_lookup_addr_ipv4(struct in_addr *src)
-{
-	struct bgp *bgp;
-	struct peer *peer;
-	struct listnode *node;
-	struct listnode *bgpnode;
-
-	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
-		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
-			if (sockunion_family(&peer->su) != AF_INET)
-				continue;
-
-			if (sockunion2ip(&peer->su) == src->s_addr)
-				return peer;
-		}
-	}
-
-	return NULL;
-}
-
-static struct peer *bgp_peer_lookup_next(struct in_addr *src)
-{
-	struct bgp *bgp;
-	struct peer *peer;
-	struct peer *next_peer = NULL;
-	struct listnode *node;
-	struct listnode *bgpnode;
-
-	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
-		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
-			if (sockunion_family(&peer->su) != AF_INET)
-				continue;
-			if (ntohl(sockunion2ip(&peer->su)) <= ntohl(src->s_addr))
-				continue;
-
-			if (!next_peer
-			    || ntohl(sockunion2ip(&next_peer->su))
-				       > ntohl(sockunion2ip(&peer->su))) {
-				next_peer = peer;
-			}
-		}
-	}
-
-	if (next_peer) {
-		src->s_addr = sockunion2ip(&next_peer->su);
-		return next_peer;
-	}
-
-	return NULL;
-}
-
-/* 1.3.6.1.2.1.15.3.1.x  = 10 */
-#define PEERTAB_NAMELEN 10
-
-static struct peer *bgpPeerTable_lookup(struct variable *v, oid name[],
-					size_t *length, struct in_addr *addr,
-					int exact)
-{
-	struct peer *peer = NULL;
-	size_t namelen = v ? v->namelen : PEERTAB_NAMELEN;
-	int len;
-
-	if (exact) {
-		/* Check the length. */
-		if (*length - namelen != sizeof(struct in_addr))
-			return NULL;
-
-		oid2in_addr(name + namelen, IN_ADDR_SIZE, addr);
-
-		peer = peer_lookup_addr_ipv4(addr);
-		return peer;
-	} else {
-		len = *length - namelen;
-		if (len > 4)
-			len = 4;
-
-		oid2in_addr(name + namelen, len, addr);
-
-		peer = bgp_peer_lookup_next(addr);
-
-		if (peer == NULL)
-			return NULL;
-
-		oid_copy_in_addr(name + namelen, addr);
-		*length = sizeof(struct in_addr) + namelen;
-
-		return peer;
-	}
-	return NULL;
-}
-
-/* BGP write methods. */
-static int write_bgpPeerTable(int action, uint8_t *var_val,
-			      uint8_t var_val_type, size_t var_val_len,
-			      uint8_t *statP, oid *name, size_t length)
-{
-	struct in_addr addr;
-	struct peer *peer;
-	long intval;
-
-	if (var_val_type != ASN_INTEGER) {
-		return SNMP_ERR_WRONGTYPE;
-	}
-	if (var_val_len != sizeof(long)) {
-		return SNMP_ERR_WRONGLENGTH;
-	}
-
-	intval = *(long *)var_val;
-
-	memset(&addr, 0, sizeof(addr));
-
-	peer = bgpPeerTable_lookup(NULL, name, &length, &addr, 1);
-	if (!peer)
-		return SNMP_ERR_NOSUCHNAME;
-
-	if (action != SNMP_MSG_INTERNAL_SET_COMMIT)
-		return SNMP_ERR_NOERROR;
-
-	zlog_info("%s: SNMP write .%ld = %ld", peer->host,
-		  (long)name[PEERTAB_NAMELEN - 1], intval);
-
-	switch (name[PEERTAB_NAMELEN - 1]) {
-	case BGPPEERADMINSTATUS:
-#define BGP_PeerAdmin_stop  1
-#define BGP_PeerAdmin_start 2
-		/* When the peer is established,   */
-		if (intval == BGP_PeerAdmin_stop)
-			BGP_EVENT_ADD(peer, BGP_Stop);
-		else if (intval == BGP_PeerAdmin_start)
-			; /* Do nothing. */
-		else
-			return SNMP_ERR_NOSUCHNAME;
-		break;
-	case BGPPEERCONNECTRETRYINTERVAL:
-		peer_flag_set(peer, PEER_FLAG_TIMER_CONNECT);
-		peer->connect = intval;
-		peer->v_connect = intval;
-		break;
-	case BGPPEERHOLDTIMECONFIGURED:
-		peer_flag_set(peer, PEER_FLAG_TIMER);
-		peer->holdtime = intval;
-		peer->v_holdtime = intval;
-		break;
-	case BGPPEERKEEPALIVECONFIGURED:
-		peer_flag_set(peer, PEER_FLAG_TIMER);
-		peer->keepalive = intval;
-		peer->v_keepalive = intval;
-		break;
-	case BGPPEERMINROUTEADVERTISEMENTINTERVAL:
-		peer->v_routeadv = intval;
-		break;
-	}
-	return SNMP_ERR_NOERROR;
-}
-
-static uint8_t *bgpPeerTable(struct variable *v, oid name[], size_t *length,
-			     int exact, size_t *var_len,
-			     WriteMethod **write_method)
-{
-	static struct in_addr addr;
-	struct peer *peer;
-	uint32_t ui, uo;
-
-	if (smux_header_table(v, name, length, exact, var_len, write_method)
-	    == MATCH_FAILED)
-		return NULL;
-	memset(&addr, 0, sizeof(addr));
-
-	peer = bgpPeerTable_lookup(v, name, length, &addr, exact);
-	if (!peer)
-		return NULL;
-
-	switch (v->magic) {
-	case BGPPEERIDENTIFIER:
-		return SNMP_IPADDRESS(peer->remote_id);
-	case BGPPEERSTATE:
-		return SNMP_INTEGER(peer->status);
-	case BGPPEERADMINSTATUS:
-		*write_method = write_bgpPeerTable;
-#define BGP_PeerAdmin_stop  1
-#define BGP_PeerAdmin_start 2
-		if (CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN))
-			return SNMP_INTEGER(BGP_PeerAdmin_stop);
-		else
-			return SNMP_INTEGER(BGP_PeerAdmin_start);
-	case BGPPEERNEGOTIATEDVERSION:
-		return SNMP_INTEGER(BGP_VERSION_4);
-	case BGPPEERLOCALADDR:
-		if (peer->su_local)
-			return SNMP_IPADDRESS(peer->su_local->sin.sin_addr);
-		else
-			return SNMP_IPADDRESS(bgp_empty_addr);
-	case BGPPEERLOCALPORT:
-		if (peer->su_local)
-			return SNMP_INTEGER(
-				ntohs(peer->su_local->sin.sin_port));
-		else
-			return SNMP_INTEGER(0);
-	case BGPPEERREMOTEADDR:
-		if (peer->su_remote)
-			return SNMP_IPADDRESS(peer->su_remote->sin.sin_addr);
-		else
-			return SNMP_IPADDRESS(bgp_empty_addr);
-	case BGPPEERREMOTEPORT:
-		if (peer->su_remote)
-			return SNMP_INTEGER(
-				ntohs(peer->su_remote->sin.sin_port));
-		else
-			return SNMP_INTEGER(0);
-	case BGPPEERREMOTEAS:
-		return SNMP_INTEGER(peer->as);
-	case BGPPEERINUPDATES:
-		ui = atomic_load_explicit(&peer->update_in,
-					  memory_order_relaxed);
-		return SNMP_INTEGER(ui);
-	case BGPPEEROUTUPDATES:
-		uo = atomic_load_explicit(&peer->update_out,
-					  memory_order_relaxed);
-		return SNMP_INTEGER(uo);
-	case BGPPEERINTOTALMESSAGES:
-		return SNMP_INTEGER(PEER_TOTAL_RX(peer));
-	case BGPPEEROUTTOTALMESSAGES:
-		return SNMP_INTEGER(PEER_TOTAL_TX(peer));
-	case BGPPEERLASTERROR: {
-		static uint8_t lasterror[2];
-		lasterror[0] = peer->notify.code;
-		lasterror[1] = peer->notify.subcode;
-		*var_len = 2;
-		return (uint8_t *)&lasterror;
-	}
-	case BGPPEERFSMESTABLISHEDTRANSITIONS:
-		return SNMP_INTEGER(peer->established);
-	case BGPPEERFSMESTABLISHEDTIME:
-		if (peer->uptime == 0)
-			return SNMP_INTEGER(0);
-		else
-			return SNMP_INTEGER(monotime(NULL) - peer->uptime);
-	case BGPPEERCONNECTRETRYINTERVAL:
-		*write_method = write_bgpPeerTable;
-		return SNMP_INTEGER(peer->v_connect);
-	case BGPPEERHOLDTIME:
-		return SNMP_INTEGER(peer->v_holdtime);
-	case BGPPEERKEEPALIVE:
-		return SNMP_INTEGER(peer->v_keepalive);
-	case BGPPEERHOLDTIMECONFIGURED:
-		*write_method = write_bgpPeerTable;
-		if (CHECK_FLAG(peer->flags, PEER_FLAG_TIMER))
-			return SNMP_INTEGER(peer->holdtime);
-		else
-			return SNMP_INTEGER(peer->v_holdtime);
-	case BGPPEERKEEPALIVECONFIGURED:
-		*write_method = write_bgpPeerTable;
-		if (CHECK_FLAG(peer->flags, PEER_FLAG_TIMER))
-			return SNMP_INTEGER(peer->keepalive);
-		else
-			return SNMP_INTEGER(peer->v_keepalive);
-	case BGPPEERMINROUTEADVERTISEMENTINTERVAL:
-		*write_method = write_bgpPeerTable;
-		return SNMP_INTEGER(peer->v_routeadv);
-	case BGPPEERINUPDATEELAPSEDTIME:
-		if (peer->update_time == 0)
-			return SNMP_INTEGER(0);
-		else
-			return SNMP_INTEGER(monotime(NULL) - peer->update_time);
-	default:
-		return NULL;
-	}
-	return NULL;
-}
-
-static uint8_t *bgpIdentifier(struct variable *v, oid name[], size_t *length,
-			      int exact, size_t *var_len,
-			      WriteMethod **write_method)
-{
-	struct bgp *bgp;
-
-	if (smux_header_generic(v, name, length, exact, var_len, write_method)
-	    == MATCH_FAILED)
-		return NULL;
-
-	bgp = bgp_get_default();
-	if (!bgp)
-		return NULL;
-
-	return SNMP_IPADDRESS(bgp->router_id);
-}
-
-static uint8_t *bgpRcvdPathAttrTable(struct variable *v, oid name[],
-				     size_t *length, int exact, size_t *var_len,
-				     WriteMethod **write_method)
-{
-	/* Received Path Attribute Table.  This table contains, one entry
-	   per path to a network, path attributes received from all peers
-	   running BGP version 3 or less.  This table is obsolete, having
-	   been replaced in functionality with the bgp4PathAttrTable.  */
-	return NULL;
-}
-
-static struct bgp_path_info *bgp4PathAttrLookup(struct variable *v, oid name[],
-						size_t *length, struct bgp *bgp,
-						struct prefix_ipv4 *addr,
-						int exact)
-{
-	oid *offset;
-	int offsetlen;
-	struct bgp_path_info *path;
-	struct bgp_path_info *min;
-	struct bgp_dest *dest;
-	union sockunion su;
-	unsigned int len;
-	struct in_addr paddr;
-
-	sockunion_init(&su);
-
-#define BGP_PATHATTR_ENTRY_OFFSET (IN_ADDR_SIZE + 1 + IN_ADDR_SIZE)
-
-	if (exact) {
-		if (*length - v->namelen != BGP_PATHATTR_ENTRY_OFFSET)
-			return NULL;
-
-		/* Set OID offset for prefix. */
-		offset = name + v->namelen;
-		oid2in_addr(offset, IN_ADDR_SIZE, &addr->prefix);
-		offset += IN_ADDR_SIZE;
-
-		/* Prefix length. */
-		addr->prefixlen = *offset;
-		offset++;
-
-		/* Peer address. */
-		su.sin.sin_family = AF_INET;
-		oid2in_addr(offset, IN_ADDR_SIZE, &su.sin.sin_addr);
-
-		/* Lookup node. */
-		dest = bgp_node_lookup(bgp->rib[AFI_IP][SAFI_UNICAST],
-				       (struct prefix *)addr);
-		if (dest) {
-			for (path = bgp_dest_get_bgp_path_info(dest); path;
-			     path = path->next)
-				if (sockunion_same(&path->peer->su, &su))
-					return path;
-
-			bgp_dest_unlock_node(dest);
-		}
-	} else {
-		offset = name + v->namelen;
-		offsetlen = *length - v->namelen;
-		len = offsetlen;
-
-		if (offsetlen == 0)
-			dest = bgp_table_top(bgp->rib[AFI_IP][SAFI_UNICAST]);
-		else {
-			if (len > IN_ADDR_SIZE)
-				len = IN_ADDR_SIZE;
-
-			oid2in_addr(offset, len, &addr->prefix);
-
-			offset += IN_ADDR_SIZE;
-			offsetlen -= IN_ADDR_SIZE;
-
-			if (offsetlen > 0)
-				addr->prefixlen = *offset;
-			else
-				addr->prefixlen = len * 8;
-
-			dest = bgp_node_get(bgp->rib[AFI_IP][SAFI_UNICAST],
-					    (struct prefix *)addr);
-
-			offset++;
-			offsetlen--;
-		}
-
-		if (offsetlen > 0) {
-			len = offsetlen;
-			if (len > IN_ADDR_SIZE)
-				len = IN_ADDR_SIZE;
-
-			oid2in_addr(offset, len, &paddr);
-		} else
-			paddr.s_addr = INADDR_ANY;
-
-		if (!dest)
-			return NULL;
-
-		do {
-			min = NULL;
-
-			for (path = bgp_dest_get_bgp_path_info(dest); path;
-			     path = path->next) {
-				if (path->peer->su.sin.sin_family == AF_INET
-				    && ntohl(paddr.s_addr)
-					       < ntohl(path->peer->su.sin
-							       .sin_addr
-							       .s_addr)) {
-					if (min) {
-						if (ntohl(path->peer->su.sin
-								  .sin_addr
-								  .s_addr)
-						    < ntohl(min->peer->su.sin
-								    .sin_addr
-								    .s_addr))
-							min = path;
-					} else
-						min = path;
-				}
-			}
-
-			if (min) {
-				const struct prefix *rn_p =
-					bgp_dest_get_prefix(dest);
-
-				*length =
-					v->namelen + BGP_PATHATTR_ENTRY_OFFSET;
-
-				offset = name + v->namelen;
-				oid_copy_in_addr(offset, &rn_p->u.prefix4);
-				offset += IN_ADDR_SIZE;
-				*offset = rn_p->prefixlen;
-				offset++;
-				oid_copy_in_addr(offset,
-						 &min->peer->su.sin.sin_addr);
-				addr->prefix = rn_p->u.prefix4;
-				addr->prefixlen = rn_p->prefixlen;
-
-				bgp_dest_unlock_node(dest);
-
-				return min;
-			}
-
-			paddr.s_addr = INADDR_ANY;
-		} while ((dest = bgp_route_next(dest)) != NULL);
-	}
-	return NULL;
-}
-
-static uint8_t *bgp4PathAttrTable(struct variable *v, oid name[],
-				  size_t *length, int exact, size_t *var_len,
-				  WriteMethod **write_method)
-{
-	struct bgp *bgp;
-	struct bgp_path_info *path;
-	struct prefix_ipv4 addr;
-
-	bgp = bgp_get_default();
-	if (!bgp)
-		return NULL;
-
-	if (smux_header_table(v, name, length, exact, var_len, write_method)
-	    == MATCH_FAILED)
-		return NULL;
-	memset(&addr, 0, sizeof(addr));
-
-	path = bgp4PathAttrLookup(v, name, length, bgp, &addr, exact);
-	if (!path)
-		return NULL;
-
-	switch (v->magic) {
-	case BGP4PATHATTRPEER: /* 1 */
-		return SNMP_IPADDRESS(path->peer->su.sin.sin_addr);
-	case BGP4PATHATTRIPADDRPREFIXLEN: /* 2 */
-		return SNMP_INTEGER(addr.prefixlen);
-	case BGP4PATHATTRIPADDRPREFIX: /* 3 */
-		return SNMP_IPADDRESS(addr.prefix);
-	case BGP4PATHATTRORIGIN: /* 4 */
-		return SNMP_INTEGER(path->attr->origin);
-	case BGP4PATHATTRASPATHSEGMENT: /* 5 */
-		return aspath_snmp_pathseg(path->attr->aspath, var_len);
-	case BGP4PATHATTRNEXTHOP: /* 6 */
-		return SNMP_IPADDRESS(path->attr->nexthop);
-	case BGP4PATHATTRMULTIEXITDISC: /* 7 */
-		return SNMP_INTEGER(path->attr->med);
-	case BGP4PATHATTRLOCALPREF: /* 8 */
-		return SNMP_INTEGER(path->attr->local_pref);
-	case BGP4PATHATTRATOMICAGGREGATE: /* 9 */
-		return SNMP_INTEGER(1);
-	case BGP4PATHATTRAGGREGATORAS: /* 10 */
-		return SNMP_INTEGER(path->attr->aggregator_as);
-	case BGP4PATHATTRAGGREGATORADDR: /* 11 */
-		return SNMP_IPADDRESS(path->attr->aggregator_addr);
-	case BGP4PATHATTRCALCLOCALPREF: /* 12 */
-		return SNMP_INTEGER(-1);
-	case BGP4PATHATTRBEST: /* 13 */
-#define BGP4_PathAttrBest_false 1
-#define BGP4_PathAttrBest_true  2
-		if (CHECK_FLAG(path->flags, BGP_PATH_SELECTED))
-			return SNMP_INTEGER(BGP4_PathAttrBest_true);
-		else
-			return SNMP_INTEGER(BGP4_PathAttrBest_false);
-	case BGP4PATHATTRUNKNOWN: /* 14 */
-		*var_len = 0;
-		return NULL;
-	}
-	return NULL;
-}
-
-/* BGP Traps. */
-static struct trap_object bgpTrapList[] = {{3, {3, 1, BGPPEERREMOTEADDR} },
-					   {3, {3, 1, BGPPEERLASTERROR} },
-					   {3, {3, 1, BGPPEERSTATE} } };
-
-static int bgpTrapEstablished(struct peer *peer)
-{
-	int ret;
-	struct in_addr addr;
-	oid index[sizeof(oid) * IN_ADDR_SIZE];
-
-	/* Check if this peer just went to Established */
-	if ((peer->ostatus != OpenConfirm) || !(peer_established(peer)))
-		return 0;
-
-	ret = inet_aton(peer->host, &addr);
-	if (ret == 0)
-		return 0;
-
-	oid_copy_in_addr(index, &addr);
-
-	smux_trap(bgp_variables, array_size(bgp_variables), bgp_trap_oid,
-		  array_size(bgp_trap_oid), bgp_oid,
-		  sizeof(bgp_oid) / sizeof(oid), index, IN_ADDR_SIZE,
-		  bgpTrapList, array_size(bgpTrapList), BGPESTABLISHED);
-	return 0;
-}
-
-static int bgpTrapBackwardTransition(struct peer *peer)
-{
-	int ret;
-	struct in_addr addr;
-	oid index[sizeof(oid) * IN_ADDR_SIZE];
-
-	ret = inet_aton(peer->host, &addr);
-	if (ret == 0)
-		return 0;
-
-	oid_copy_in_addr(index, &addr);
-
-	smux_trap(bgp_variables, array_size(bgp_variables), bgp_trap_oid,
-		  array_size(bgp_trap_oid), bgp_oid,
-		  sizeof(bgp_oid) / sizeof(oid), index, IN_ADDR_SIZE,
-		  bgpTrapList, array_size(bgpTrapList), BGPBACKWARDTRANSITION);
-	return 0;
-}
-
 static int bgp_snmp_init(struct thread_master *tm)
 {
 	smux_init(tm);
-	REGISTER_MIB("mibII/bgp", bgp_variables, variable, bgp_oid);
+	bgp_snmp_bgp4_init(tm);
+	bgp_snmp_bgp4v2_init(tm);
 	bgp_mpls_l3vpn_module_init();
 	return 0;
 }
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp.h frr-frr-8.5/bgpd/bgp_snmp.h
--- frr-frr-8.4.2/bgpd/bgp_snmp.h	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp.h	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,32 @@
+/* Common header file for BGP SNMP implementation.
+ *
+ * Copyright (C) 2022 Donatas Abraitis <donatas@opensourcerouting.org>
+ *
+ * This file is part of FRRouting (FRR).
+ *
+ * FRR is free software; you can redistribute it and/or modify it under the
+ * terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _FRR_BGP_SNMP_H_
+#define _FRR_BGP_SNMP_H_
+
+/* SNMP value hack. */
+#define INTEGER ASN_INTEGER
+#define INTEGER32 ASN_INTEGER
+#define COUNTER32 ASN_COUNTER
+#define OCTET_STRING ASN_OCTET_STR
+#define IPADDRESS ASN_IPADDRESS
+#define GAUGE32 ASN_UNSIGNED
+
+#endif /* _FRR_BGP_SNMP_H_ */
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp_bgp4.c frr-frr-8.5/bgpd/bgp_snmp_bgp4.c
--- frr-frr-8.4.2/bgpd/bgp_snmp_bgp4.c	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp_bgp4.c	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,814 @@
+/* BGP4 SNMP support
+ * Copyright (C) 1999, 2000 Kunihiro Ishiguro
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+
+#include "if.h"
+#include "log.h"
+#include "prefix.h"
+#include "command.h"
+#include "thread.h"
+#include "smux.h"
+#include "filter.h"
+#include "hook.h"
+#include "libfrr.h"
+#include "lib/version.h"
+
+#include "bgpd/bgpd.h"
+#include "bgpd/bgp_table.h"
+#include "bgpd/bgp_aspath.h"
+#include "bgpd/bgp_attr.h"
+#include "bgpd/bgp_route.h"
+#include "bgpd/bgp_fsm.h"
+#include "bgpd/bgp_snmp.h"
+#include "bgpd/bgp_snmp_bgp4.h"
+#include "bgpd/bgp_mplsvpn_snmp.h"
+
+/* Declare static local variables for convenience. */
+SNMP_LOCAL_VARIABLES
+
+/* BGP-MIB instances. */
+static oid bgp_oid[] = {BGP4MIB};
+static oid bgp_trap_oid[] = {BGP4MIB, 0};
+
+/* IP address 0.0.0.0. */
+static struct in_addr bgp_empty_addr = {.s_addr = 0};
+
+static uint8_t *bgpVersion(struct variable *v, oid name[], size_t *length,
+			   int exact, size_t *var_len,
+			   WriteMethod **write_method)
+{
+	static uint8_t version;
+
+	if (smux_header_generic(v, name, length, exact, var_len,
+				write_method) == MATCH_FAILED)
+		return NULL;
+
+	/* Return BGP version.  Zebra bgpd only support version 4. */
+	version = (0x80 >> (BGP_VERSION_4 - 1));
+
+	/* Return octet string length 1. */
+	*var_len = 1;
+	return &version;
+}
+
+static uint8_t *bgpLocalAs(struct variable *v, oid name[], size_t *length,
+			   int exact, size_t *var_len,
+			   WriteMethod **write_method)
+{
+	struct bgp *bgp;
+
+	if (smux_header_generic(v, name, length, exact, var_len,
+				write_method) == MATCH_FAILED)
+		return NULL;
+
+	/* Get BGP structure. */
+	bgp = bgp_get_default();
+	if (!bgp)
+		return NULL;
+
+	return SNMP_INTEGER(bgp->as);
+}
+
+static struct peer *peer_lookup_addr_ipv4(struct in_addr *src)
+{
+	struct bgp *bgp;
+	struct peer *peer;
+	struct listnode *node;
+	struct listnode *bgpnode;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
+			if (sockunion_family(&peer->su) != AF_INET)
+				continue;
+
+			if (sockunion2ip(&peer->su) == src->s_addr)
+				return peer;
+		}
+	}
+
+	return NULL;
+}
+
+static struct peer *bgp_peer_lookup_next(struct in_addr *src)
+{
+	struct bgp *bgp;
+	struct peer *peer;
+	struct peer *next_peer = NULL;
+	struct listnode *node;
+	struct listnode *bgpnode;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
+			if (sockunion_family(&peer->su) != AF_INET)
+				continue;
+			if (ntohl(sockunion2ip(&peer->su)) <=
+			    ntohl(src->s_addr))
+				continue;
+
+			if (!next_peer ||
+			    ntohl(sockunion2ip(&next_peer->su)) >
+				    ntohl(sockunion2ip(&peer->su))) {
+				next_peer = peer;
+			}
+		}
+	}
+
+	if (next_peer) {
+		src->s_addr = sockunion2ip(&next_peer->su);
+		return next_peer;
+	}
+
+	return NULL;
+}
+
+/* 1.3.6.1.2.1.15.3.1.x  = 10 */
+#define PEERTAB_NAMELEN 10
+
+static struct peer *bgpPeerTable_lookup(struct variable *v, oid name[],
+					size_t *length, struct in_addr *addr,
+					int exact)
+{
+	struct peer *peer = NULL;
+	size_t namelen = v ? v->namelen : PEERTAB_NAMELEN;
+	int len;
+
+	if (exact) {
+		/* Check the length. */
+		if (*length - namelen != sizeof(struct in_addr))
+			return NULL;
+
+		oid2in_addr(name + namelen, IN_ADDR_SIZE, addr);
+
+		peer = peer_lookup_addr_ipv4(addr);
+		return peer;
+	} else {
+		len = *length - namelen;
+		if (len > 4)
+			len = 4;
+
+		oid2in_addr(name + namelen, len, addr);
+
+		peer = bgp_peer_lookup_next(addr);
+
+		if (peer == NULL)
+			return NULL;
+
+		oid_copy_in_addr(name + namelen, addr);
+		*length = sizeof(struct in_addr) + namelen;
+
+		return peer;
+	}
+	return NULL;
+}
+
+/* BGP write methods. */
+static int write_bgpPeerTable(int action, uint8_t *var_val,
+			      uint8_t var_val_type, size_t var_val_len,
+			      uint8_t *statP, oid *name, size_t length)
+{
+	struct in_addr addr;
+	struct peer *peer;
+	long intval;
+
+	if (var_val_type != ASN_INTEGER) {
+		return SNMP_ERR_WRONGTYPE;
+	}
+	if (var_val_len != sizeof(long)) {
+		return SNMP_ERR_WRONGLENGTH;
+	}
+
+	intval = *(long *)var_val;
+
+	memset(&addr, 0, sizeof(addr));
+
+	peer = bgpPeerTable_lookup(NULL, name, &length, &addr, 1);
+	if (!peer)
+		return SNMP_ERR_NOSUCHNAME;
+
+	if (action != SNMP_MSG_INTERNAL_SET_COMMIT)
+		return SNMP_ERR_NOERROR;
+
+	zlog_info("%s: SNMP write .%ld = %ld", peer->host,
+		  (long)name[PEERTAB_NAMELEN - 1], intval);
+
+	switch (name[PEERTAB_NAMELEN - 1]) {
+	case BGPPEERADMINSTATUS:
+#define BGP_PeerAdmin_stop 1
+#define BGP_PeerAdmin_start 2
+		/* When the peer is established,   */
+		if (intval == BGP_PeerAdmin_stop)
+			BGP_EVENT_ADD(peer, BGP_Stop);
+		else if (intval == BGP_PeerAdmin_start)
+			; /* Do nothing. */
+		else
+			return SNMP_ERR_NOSUCHNAME;
+		break;
+	case BGPPEERCONNECTRETRYINTERVAL:
+		peer_flag_set(peer, PEER_FLAG_TIMER_CONNECT);
+		peer->connect = intval;
+		peer->v_connect = intval;
+		break;
+	case BGPPEERHOLDTIMECONFIGURED:
+		peer_flag_set(peer, PEER_FLAG_TIMER);
+		peer->holdtime = intval;
+		peer->v_holdtime = intval;
+		break;
+	case BGPPEERKEEPALIVECONFIGURED:
+		peer_flag_set(peer, PEER_FLAG_TIMER);
+		peer->keepalive = intval;
+		peer->v_keepalive = intval;
+		break;
+	case BGPPEERMINROUTEADVERTISEMENTINTERVAL:
+		peer->v_routeadv = intval;
+		break;
+	}
+	return SNMP_ERR_NOERROR;
+}
+
+static uint8_t *bgpPeerTable(struct variable *v, oid name[], size_t *length,
+			     int exact, size_t *var_len,
+			     WriteMethod **write_method)
+{
+	static struct in_addr addr;
+	struct peer *peer;
+	uint32_t ui, uo;
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+	memset(&addr, 0, sizeof(addr));
+
+	peer = bgpPeerTable_lookup(v, name, length, &addr, exact);
+	if (!peer)
+		return NULL;
+
+	switch (v->magic) {
+	case BGPPEERIDENTIFIER:
+		return SNMP_IPADDRESS(peer->remote_id);
+	case BGPPEERSTATE:
+		return SNMP_INTEGER(peer->status);
+	case BGPPEERADMINSTATUS:
+		*write_method = write_bgpPeerTable;
+#define BGP_PeerAdmin_stop 1
+#define BGP_PeerAdmin_start 2
+		if (CHECK_FLAG(peer->flags, PEER_FLAG_SHUTDOWN))
+			return SNMP_INTEGER(BGP_PeerAdmin_stop);
+		else
+			return SNMP_INTEGER(BGP_PeerAdmin_start);
+	case BGPPEERNEGOTIATEDVERSION:
+		return SNMP_INTEGER(BGP_VERSION_4);
+	case BGPPEERLOCALADDR:
+		if (peer->su_local)
+			return SNMP_IPADDRESS(peer->su_local->sin.sin_addr);
+		else
+			return SNMP_IPADDRESS(bgp_empty_addr);
+	case BGPPEERLOCALPORT:
+		if (peer->su_local)
+			return SNMP_INTEGER(
+				ntohs(peer->su_local->sin.sin_port));
+		else
+			return SNMP_INTEGER(0);
+	case BGPPEERREMOTEADDR:
+		if (peer->su_remote)
+			return SNMP_IPADDRESS(peer->su_remote->sin.sin_addr);
+		else
+			return SNMP_IPADDRESS(bgp_empty_addr);
+	case BGPPEERREMOTEPORT:
+		if (peer->su_remote)
+			return SNMP_INTEGER(
+				ntohs(peer->su_remote->sin.sin_port));
+		else
+			return SNMP_INTEGER(0);
+	case BGPPEERREMOTEAS:
+		return SNMP_INTEGER(peer->as);
+	case BGPPEERINUPDATES:
+		ui = atomic_load_explicit(&peer->update_in,
+					  memory_order_relaxed);
+		return SNMP_INTEGER(ui);
+	case BGPPEEROUTUPDATES:
+		uo = atomic_load_explicit(&peer->update_out,
+					  memory_order_relaxed);
+		return SNMP_INTEGER(uo);
+	case BGPPEERINTOTALMESSAGES:
+		return SNMP_INTEGER(PEER_TOTAL_RX(peer));
+	case BGPPEEROUTTOTALMESSAGES:
+		return SNMP_INTEGER(PEER_TOTAL_TX(peer));
+	case BGPPEERLASTERROR: {
+		static uint8_t lasterror[2];
+		lasterror[0] = peer->notify.code;
+		lasterror[1] = peer->notify.subcode;
+		*var_len = 2;
+		return (uint8_t *)&lasterror;
+	}
+	case BGPPEERFSMESTABLISHEDTRANSITIONS:
+		return SNMP_INTEGER(peer->established);
+	case BGPPEERFSMESTABLISHEDTIME:
+		if (peer->uptime == 0)
+			return SNMP_INTEGER(0);
+		else
+			return SNMP_INTEGER(monotime(NULL) - peer->uptime);
+	case BGPPEERCONNECTRETRYINTERVAL:
+		*write_method = write_bgpPeerTable;
+		return SNMP_INTEGER(peer->v_connect);
+	case BGPPEERHOLDTIME:
+		return SNMP_INTEGER(peer->v_holdtime);
+	case BGPPEERKEEPALIVE:
+		return SNMP_INTEGER(peer->v_keepalive);
+	case BGPPEERHOLDTIMECONFIGURED:
+		*write_method = write_bgpPeerTable;
+		if (CHECK_FLAG(peer->flags, PEER_FLAG_TIMER))
+			return SNMP_INTEGER(peer->holdtime);
+		else
+			return SNMP_INTEGER(peer->v_holdtime);
+	case BGPPEERKEEPALIVECONFIGURED:
+		*write_method = write_bgpPeerTable;
+		if (CHECK_FLAG(peer->flags, PEER_FLAG_TIMER))
+			return SNMP_INTEGER(peer->keepalive);
+		else
+			return SNMP_INTEGER(peer->v_keepalive);
+	case BGPPEERMINROUTEADVERTISEMENTINTERVAL:
+		*write_method = write_bgpPeerTable;
+		return SNMP_INTEGER(peer->v_routeadv);
+	case BGPPEERINUPDATEELAPSEDTIME:
+		if (peer->update_time == 0)
+			return SNMP_INTEGER(0);
+		else
+			return SNMP_INTEGER(monotime(NULL) - peer->update_time);
+	default:
+		return NULL;
+	}
+	return NULL;
+}
+
+static uint8_t *bgpIdentifier(struct variable *v, oid name[], size_t *length,
+			      int exact, size_t *var_len,
+			      WriteMethod **write_method)
+{
+	struct bgp *bgp;
+
+	if (smux_header_generic(v, name, length, exact, var_len,
+				write_method) == MATCH_FAILED)
+		return NULL;
+
+	bgp = bgp_get_default();
+	if (!bgp)
+		return NULL;
+
+	return SNMP_IPADDRESS(bgp->router_id);
+}
+
+static uint8_t *bgpRcvdPathAttrTable(struct variable *v, oid name[],
+				     size_t *length, int exact, size_t *var_len,
+				     WriteMethod **write_method)
+{
+	/* Received Path Attribute Table.  This table contains, one entry
+	   per path to a network, path attributes received from all peers
+	   running BGP version 3 or less.  This table is obsolete, having
+	   been replaced in functionality with the bgp4PathAttrTable.  */
+	return NULL;
+}
+
+static struct bgp_path_info *bgp4PathAttrLookup(struct variable *v, oid name[],
+						size_t *length, struct bgp *bgp,
+						struct prefix_ipv4 *addr,
+						int exact)
+{
+	oid *offset;
+	int offsetlen;
+	struct bgp_path_info *path;
+	struct bgp_path_info *min;
+	struct bgp_dest *dest;
+	union sockunion su;
+	unsigned int len;
+	struct in_addr paddr;
+
+	sockunion_init(&su);
+
+#define BGP_PATHATTR_ENTRY_OFFSET (IN_ADDR_SIZE + 1 + IN_ADDR_SIZE)
+
+	if (exact) {
+		if (*length - v->namelen != BGP_PATHATTR_ENTRY_OFFSET)
+			return NULL;
+
+		/* Set OID offset for prefix. */
+		offset = name + v->namelen;
+		oid2in_addr(offset, IN_ADDR_SIZE, &addr->prefix);
+		offset += IN_ADDR_SIZE;
+
+		/* Prefix length. */
+		addr->prefixlen = *offset;
+		offset++;
+
+		/* Peer address. */
+		su.sin.sin_family = AF_INET;
+		oid2in_addr(offset, IN_ADDR_SIZE, &su.sin.sin_addr);
+
+		/* Lookup node. */
+		dest = bgp_node_lookup(bgp->rib[AFI_IP][SAFI_UNICAST],
+				       (struct prefix *)addr);
+		if (dest) {
+			for (path = bgp_dest_get_bgp_path_info(dest); path;
+			     path = path->next)
+				if (sockunion_same(&path->peer->su, &su))
+					return path;
+
+			bgp_dest_unlock_node(dest);
+		}
+	} else {
+		offset = name + v->namelen;
+		offsetlen = *length - v->namelen;
+		len = offsetlen;
+
+		if (offsetlen == 0)
+			dest = bgp_table_top(bgp->rib[AFI_IP][SAFI_UNICAST]);
+		else {
+			if (len > IN_ADDR_SIZE)
+				len = IN_ADDR_SIZE;
+
+			oid2in_addr(offset, len, &addr->prefix);
+
+			offset += IN_ADDR_SIZE;
+			offsetlen -= IN_ADDR_SIZE;
+
+			if (offsetlen > 0)
+				addr->prefixlen = *offset;
+			else
+				addr->prefixlen = len * 8;
+
+			dest = bgp_node_get(bgp->rib[AFI_IP][SAFI_UNICAST],
+					    (struct prefix *)addr);
+
+			offset++;
+			offsetlen--;
+		}
+
+		if (offsetlen > 0) {
+			len = offsetlen;
+			if (len > IN_ADDR_SIZE)
+				len = IN_ADDR_SIZE;
+
+			oid2in_addr(offset, len, &paddr);
+		} else
+			paddr.s_addr = INADDR_ANY;
+
+		if (!dest)
+			return NULL;
+
+		do {
+			min = NULL;
+
+			for (path = bgp_dest_get_bgp_path_info(dest); path;
+			     path = path->next) {
+				if (path->peer->su.sin.sin_family == AF_INET &&
+				    ntohl(paddr.s_addr) <
+					    ntohl(path->peer->su.sin.sin_addr
+							  .s_addr)) {
+					if (min) {
+						if (ntohl(path->peer->su.sin
+								  .sin_addr
+								  .s_addr) <
+						    ntohl(min->peer->su.sin
+								  .sin_addr
+								  .s_addr))
+							min = path;
+					} else
+						min = path;
+				}
+			}
+
+			if (min) {
+				const struct prefix *rn_p =
+					bgp_dest_get_prefix(dest);
+
+				*length =
+					v->namelen + BGP_PATHATTR_ENTRY_OFFSET;
+
+				offset = name + v->namelen;
+				oid_copy_in_addr(offset, &rn_p->u.prefix4);
+				offset += IN_ADDR_SIZE;
+				*offset = rn_p->prefixlen;
+				offset++;
+				oid_copy_in_addr(offset,
+						 &min->peer->su.sin.sin_addr);
+				addr->prefix = rn_p->u.prefix4;
+				addr->prefixlen = rn_p->prefixlen;
+
+				bgp_dest_unlock_node(dest);
+
+				return min;
+			}
+
+			paddr.s_addr = INADDR_ANY;
+		} while ((dest = bgp_route_next(dest)) != NULL);
+	}
+	return NULL;
+}
+
+static uint8_t *bgp4PathAttrTable(struct variable *v, oid name[],
+				  size_t *length, int exact, size_t *var_len,
+				  WriteMethod **write_method)
+{
+	struct bgp *bgp;
+	struct bgp_path_info *path;
+	struct prefix_ipv4 addr;
+
+	bgp = bgp_get_default();
+	if (!bgp)
+		return NULL;
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+	memset(&addr, 0, sizeof(addr));
+
+	path = bgp4PathAttrLookup(v, name, length, bgp, &addr, exact);
+	if (!path)
+		return NULL;
+
+	switch (v->magic) {
+	case BGP4PATHATTRPEER: /* 1 */
+		return SNMP_IPADDRESS(path->peer->su.sin.sin_addr);
+	case BGP4PATHATTRIPADDRPREFIXLEN: /* 2 */
+		return SNMP_INTEGER(addr.prefixlen);
+	case BGP4PATHATTRIPADDRPREFIX: /* 3 */
+		return SNMP_IPADDRESS(addr.prefix);
+	case BGP4PATHATTRORIGIN: /* 4 */
+		return SNMP_INTEGER(path->attr->origin);
+	case BGP4PATHATTRASPATHSEGMENT: /* 5 */
+		return aspath_snmp_pathseg(path->attr->aspath, var_len);
+	case BGP4PATHATTRNEXTHOP: /* 6 */
+		return SNMP_IPADDRESS(path->attr->nexthop);
+	case BGP4PATHATTRMULTIEXITDISC: /* 7 */
+		return SNMP_INTEGER(path->attr->med);
+	case BGP4PATHATTRLOCALPREF: /* 8 */
+		return SNMP_INTEGER(path->attr->local_pref);
+	case BGP4PATHATTRATOMICAGGREGATE: /* 9 */
+		return SNMP_INTEGER(1);
+	case BGP4PATHATTRAGGREGATORAS: /* 10 */
+		return SNMP_INTEGER(path->attr->aggregator_as);
+	case BGP4PATHATTRAGGREGATORADDR: /* 11 */
+		return SNMP_IPADDRESS(path->attr->aggregator_addr);
+	case BGP4PATHATTRCALCLOCALPREF: /* 12 */
+		return SNMP_INTEGER(-1);
+	case BGP4PATHATTRBEST: /* 13 */
+#define BGP4_PathAttrBest_false 1
+#define BGP4_PathAttrBest_true 2
+		if (CHECK_FLAG(path->flags, BGP_PATH_SELECTED))
+			return SNMP_INTEGER(BGP4_PathAttrBest_true);
+		else
+			return SNMP_INTEGER(BGP4_PathAttrBest_false);
+	case BGP4PATHATTRUNKNOWN: /* 14 */
+		*var_len = 0;
+		return NULL;
+	}
+	return NULL;
+}
+
+/* BGP Traps. */
+static struct trap_object bgpTrapList[] = {{3, {3, 1, BGPPEERREMOTEADDR}},
+					   {3, {3, 1, BGPPEERLASTERROR}},
+					   {3, {3, 1, BGPPEERSTATE}}};
+
+static struct variable bgp_variables[] = {
+	/* BGP version. */
+	{BGPVERSION, OCTET_STRING, RONLY, bgpVersion, 1, {1}},
+	/* BGP local AS. */
+	{BGPLOCALAS, INTEGER, RONLY, bgpLocalAs, 1, {2}},
+	/* BGP peer table. */
+	{BGPPEERIDENTIFIER, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 1}},
+	{BGPPEERSTATE, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 2}},
+	{BGPPEERADMINSTATUS, INTEGER, RWRITE, bgpPeerTable, 3, {3, 1, 3}},
+	{BGPPEERNEGOTIATEDVERSION,
+	 INTEGER32,
+	 RONLY,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 4}},
+	{BGPPEERLOCALADDR, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 5}},
+	{BGPPEERLOCALPORT, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 6}},
+	{BGPPEERREMOTEADDR, IPADDRESS, RONLY, bgpPeerTable, 3, {3, 1, 7}},
+	{BGPPEERREMOTEPORT, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 8}},
+	{BGPPEERREMOTEAS, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 9}},
+	{BGPPEERINUPDATES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 10}},
+	{BGPPEEROUTUPDATES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 11}},
+	{BGPPEERINTOTALMESSAGES, COUNTER32, RONLY, bgpPeerTable, 3, {3, 1, 12}},
+	{BGPPEEROUTTOTALMESSAGES,
+	 COUNTER32,
+	 RONLY,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 13}},
+	{BGPPEERLASTERROR, OCTET_STRING, RONLY, bgpPeerTable, 3, {3, 1, 14}},
+	{BGPPEERFSMESTABLISHEDTRANSITIONS,
+	 COUNTER32,
+	 RONLY,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 15}},
+	{BGPPEERFSMESTABLISHEDTIME,
+	 GAUGE32,
+	 RONLY,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 16}},
+	{BGPPEERCONNECTRETRYINTERVAL,
+	 INTEGER,
+	 RWRITE,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 17}},
+	{BGPPEERHOLDTIME, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 18}},
+	{BGPPEERKEEPALIVE, INTEGER, RONLY, bgpPeerTable, 3, {3, 1, 19}},
+	{BGPPEERHOLDTIMECONFIGURED,
+	 INTEGER,
+	 RWRITE,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 20}},
+	{BGPPEERKEEPALIVECONFIGURED,
+	 INTEGER,
+	 RWRITE,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 21}},
+	{BGPPEERMINROUTEADVERTISEMENTINTERVAL,
+	 INTEGER,
+	 RWRITE,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 23}},
+	{BGPPEERINUPDATEELAPSEDTIME,
+	 GAUGE32,
+	 RONLY,
+	 bgpPeerTable,
+	 3,
+	 {3, 1, 24}},
+	/* BGP identifier. */
+	{BGPIDENTIFIER, IPADDRESS, RONLY, bgpIdentifier, 1, {4}},
+	/* BGP received path attribute table. */
+	{BGPPATHATTRPEER, IPADDRESS, RONLY, bgpRcvdPathAttrTable, 3, {5, 1, 1}},
+	{BGPPATHATTRDESTNETWORK,
+	 IPADDRESS,
+	 RONLY,
+	 bgpRcvdPathAttrTable,
+	 3,
+	 {5, 1, 2}},
+	{BGPPATHATTRORIGIN, INTEGER, RONLY, bgpRcvdPathAttrTable, 3, {5, 1, 3}},
+	{BGPPATHATTRASPATH,
+	 OCTET_STRING,
+	 RONLY,
+	 bgpRcvdPathAttrTable,
+	 3,
+	 {5, 1, 4}},
+	{BGPPATHATTRNEXTHOP,
+	 IPADDRESS,
+	 RONLY,
+	 bgpRcvdPathAttrTable,
+	 3,
+	 {5, 1, 5}},
+	{BGPPATHATTRINTERASMETRIC,
+	 INTEGER32,
+	 RONLY,
+	 bgpRcvdPathAttrTable,
+	 3,
+	 {5, 1, 6}},
+	/* BGP-4 received path attribute table. */
+	{BGP4PATHATTRPEER, IPADDRESS, RONLY, bgp4PathAttrTable, 3, {6, 1, 1}},
+	{BGP4PATHATTRIPADDRPREFIXLEN,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 2}},
+	{BGP4PATHATTRIPADDRPREFIX,
+	 IPADDRESS,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 3}},
+	{BGP4PATHATTRORIGIN, INTEGER, RONLY, bgp4PathAttrTable, 3, {6, 1, 4}},
+	{BGP4PATHATTRASPATHSEGMENT,
+	 OCTET_STRING,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 5}},
+	{BGP4PATHATTRNEXTHOP,
+	 IPADDRESS,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 6}},
+	{BGP4PATHATTRMULTIEXITDISC,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 7}},
+	{BGP4PATHATTRLOCALPREF,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 8}},
+	{BGP4PATHATTRATOMICAGGREGATE,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 9}},
+	{BGP4PATHATTRAGGREGATORAS,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 10}},
+	{BGP4PATHATTRAGGREGATORADDR,
+	 IPADDRESS,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 11}},
+	{BGP4PATHATTRCALCLOCALPREF,
+	 INTEGER,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 12}},
+	{BGP4PATHATTRBEST, INTEGER, RONLY, bgp4PathAttrTable, 3, {6, 1, 13}},
+	{BGP4PATHATTRUNKNOWN,
+	 OCTET_STRING,
+	 RONLY,
+	 bgp4PathAttrTable,
+	 3,
+	 {6, 1, 14}},
+};
+
+int bgpTrapEstablished(struct peer *peer)
+{
+	int ret;
+	struct in_addr addr;
+	oid index[sizeof(oid) * IN_ADDR_SIZE];
+
+	/* Check if this peer just went to Established */
+	if ((peer->ostatus != OpenConfirm) || !(peer_established(peer)))
+		return 0;
+
+	ret = inet_aton(peer->host, &addr);
+	if (ret == 0)
+		return 0;
+
+	oid_copy_in_addr(index, &addr);
+
+	smux_trap(bgp_variables, array_size(bgp_variables), bgp_trap_oid,
+		  array_size(bgp_trap_oid), bgp_oid,
+		  sizeof(bgp_oid) / sizeof(oid), index, IN_ADDR_SIZE,
+		  bgpTrapList, array_size(bgpTrapList), BGPESTABLISHED);
+	return 0;
+}
+
+int bgpTrapBackwardTransition(struct peer *peer)
+{
+	int ret;
+	struct in_addr addr;
+	oid index[sizeof(oid) * IN_ADDR_SIZE];
+
+	ret = inet_aton(peer->host, &addr);
+	if (ret == 0)
+		return 0;
+
+	oid_copy_in_addr(index, &addr);
+
+	smux_trap(bgp_variables, array_size(bgp_variables), bgp_trap_oid,
+		  array_size(bgp_trap_oid), bgp_oid,
+		  sizeof(bgp_oid) / sizeof(oid), index, IN_ADDR_SIZE,
+		  bgpTrapList, array_size(bgpTrapList), BGPBACKWARDTRANSITION);
+	return 0;
+}
+
+int bgp_snmp_bgp4_init(struct thread_master *tm)
+{
+	REGISTER_MIB("mibII/bgp", bgp_variables, variable, bgp_oid);
+	return 0;
+}
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp_bgp4.h frr-frr-8.5/bgpd/bgp_snmp_bgp4.h
--- frr-frr-8.4.2/bgpd/bgp_snmp_bgp4.h	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp_bgp4.h	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,90 @@
+/* BGP4-MIB SNMP support
+ *
+ * Using: http://www.circitor.fr/Mibs/Html/B/BGP4-MIB.php
+ *
+ * Copyright (C) 2022 Donatas Abraitis <donatas@opensourcerouting.org>
+ *
+ * This file is part of FRRouting (FRR).
+ *
+ * FRR is free software; you can redistribute it and/or modify it under the
+ * terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _FRR_BGP_SNMP_BGP4_H_
+#define _FRR_BGP_SNMP_BGP4_H_
+
+#define BGPVERSION 0
+#define BGPLOCALAS 0
+#define BGPIDENTIFIER 0
+
+/* bgp */
+#define BGP4MIB 1, 3, 6, 1, 2, 1, 15
+
+/* bgpTraps */
+#define BGPESTABLISHED 1
+#define BGPBACKWARDTRANSITION 2
+
+/* bgpPeerTable */
+#define BGPPEERIDENTIFIER 1
+#define BGPPEERSTATE 2
+#define BGPPEERADMINSTATUS 3
+#define BGPPEERNEGOTIATEDVERSION 4
+#define BGPPEERLOCALADDR 5
+#define BGPPEERLOCALPORT 6
+#define BGPPEERREMOTEADDR 7
+#define BGPPEERREMOTEPORT 8
+#define BGPPEERREMOTEAS 9
+#define BGPPEERINUPDATES 10
+#define BGPPEEROUTUPDATES 11
+#define BGPPEERINTOTALMESSAGES 12
+#define BGPPEEROUTTOTALMESSAGES 13
+#define BGPPEERLASTERROR 14
+#define BGPPEERFSMESTABLISHEDTRANSITIONS 15
+#define BGPPEERFSMESTABLISHEDTIME 16
+#define BGPPEERCONNECTRETRYINTERVAL 17
+#define BGPPEERHOLDTIME 18
+#define BGPPEERKEEPALIVE 19
+#define BGPPEERHOLDTIMECONFIGURED 20
+#define BGPPEERKEEPALIVECONFIGURED 21
+#define BGPPEERMINROUTEADVERTISEMENTINTERVAL 22
+#define BGPPEERINUPDATEELAPSEDTIME 23
+
+/* bgpPathAttrEntry */
+#define BGPPATHATTRPEER 1
+#define BGPPATHATTRDESTNETWORK 2
+#define BGPPATHATTRORIGIN 3
+#define BGPPATHATTRASPATH 4
+#define BGPPATHATTRNEXTHOP 5
+#define BGPPATHATTRINTERASMETRIC 6
+
+/* bgp4PathAttrEntry */
+#define BGP4PATHATTRPEER 1
+#define BGP4PATHATTRIPADDRPREFIXLEN 2
+#define BGP4PATHATTRIPADDRPREFIX 3
+#define BGP4PATHATTRORIGIN 4
+#define BGP4PATHATTRASPATHSEGMENT 5
+#define BGP4PATHATTRNEXTHOP 6
+#define BGP4PATHATTRMULTIEXITDISC 7
+#define BGP4PATHATTRLOCALPREF 8
+#define BGP4PATHATTRATOMICAGGREGATE 9
+#define BGP4PATHATTRAGGREGATORAS 10
+#define BGP4PATHATTRAGGREGATORADDR 11
+#define BGP4PATHATTRCALCLOCALPREF 12
+#define BGP4PATHATTRBEST 13
+#define BGP4PATHATTRUNKNOWN 14
+
+extern int bgpTrapEstablished(struct peer *peer);
+extern int bgpTrapBackwardTransition(struct peer *peer);
+extern int bgp_snmp_bgp4_init(struct thread_master *tm);
+
+#endif /* _FRR_BGP_SNMP_BGP4_H_ */
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp_bgp4v2.c frr-frr-8.5/bgpd/bgp_snmp_bgp4v2.c
--- frr-frr-8.4.2/bgpd/bgp_snmp_bgp4v2.c	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp_bgp4v2.c	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,1417 @@
+/* BGP4V2-MIB SNMP support
+ *
+ * Copyright (C) 2022 Donatas Abraitis <donatas@opensourcerouting.org>
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+
+#include "if.h"
+#include "log.h"
+#include "prefix.h"
+#include "command.h"
+#include "thread.h"
+#include "smux.h"
+#include "filter.h"
+#include "hook.h"
+#include "libfrr.h"
+#include "lib/version.h"
+
+#include "bgpd/bgpd.h"
+#include "bgpd/bgp_table.h"
+#include "bgpd/bgp_aspath.h"
+#include "bgpd/bgp_attr.h"
+#include "bgpd/bgp_debug.h"
+#include "bgpd/bgp_route.h"
+#include "bgpd/bgp_fsm.h"
+#include "bgpd/bgp_snmp.h"
+#include "bgpd/bgp_snmp_bgp4v2.h"
+
+SNMP_LOCAL_VARIABLES
+
+static oid bgpv2_oid[] = {BGP4V2MIB};
+static struct in_addr bgp_empty_addr = {};
+
+static struct peer *peer_lookup_all_vrf(struct ipaddr *addr)
+{
+	struct bgp *bgp;
+	struct peer *peer;
+	struct listnode *node;
+	struct listnode *bgpnode;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
+			switch (sockunion_family(&peer->su)) {
+			case AF_INET:
+				if (IPV4_ADDR_SAME(&peer->su.sin.sin_addr,
+						   &addr->ip._v4_addr))
+					return peer;
+				break;
+			case AF_INET6:
+				if (IPV6_ADDR_SAME(&peer->su.sin6.sin6_addr,
+						   &addr->ip._v6_addr))
+					return peer;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static struct peer *peer_lookup_all_vrf_next(struct ipaddr *addr, oid *offset,
+					     sa_family_t family)
+{
+	struct bgp *bgp;
+	struct peer *peer;
+	struct peer *next_peer = NULL;
+	struct listnode *node;
+	struct listnode *bgpnode;
+
+	for (ALL_LIST_ELEMENTS_RO(bm->bgp, bgpnode, bgp)) {
+		for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
+			sa_family_t peer_family = sockunion_family(&peer->su);
+
+			if (peer_family != family)
+				continue;
+
+			switch (sockunion_family(&peer->su)) {
+			case AF_INET:
+				oid2in_addr(offset, IN_ADDR_SIZE,
+					    &addr->ip._v4_addr);
+				if (IPV4_ADDR_CMP(&peer->su.sin.sin_addr,
+						  &addr->ip._v4_addr) < 0 ||
+				    IPV4_ADDR_SAME(&peer->su.sin.sin_addr,
+						   &addr->ip._v4_addr))
+					continue;
+
+				if (!next_peer ||
+				    IPV4_ADDR_CMP(&next_peer->su.sin.sin_addr,
+						  &peer->su.sin.sin_addr) > 0)
+					next_peer = peer;
+
+				break;
+			case AF_INET6:
+				oid2in6_addr(offset, &addr->ip._v6_addr);
+				if (IPV6_ADDR_CMP(&peer->su.sin6.sin6_addr,
+						  &addr->ip._v6_addr) < 0 ||
+				    IPV6_ADDR_SAME(&peer->su.sin6.sin6_addr,
+						   &addr->ip._v6_addr))
+					continue;
+
+				if (!next_peer ||
+				    IPV6_ADDR_CMP(&next_peer->su.sin6.sin6_addr,
+						  &peer->su.sin6.sin6_addr) > 0)
+					next_peer = peer;
+
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	if (next_peer)
+		return next_peer;
+
+	return NULL;
+}
+
+static struct peer *bgpv2PeerTable_lookup(struct variable *v, oid name[],
+					  size_t *length, int exact,
+					  struct ipaddr *addr)
+{
+	struct peer *peer = NULL;
+	size_t namelen = v ? v->namelen : BGP4V2_PEER_ENTRY_OFFSET;
+	oid *offset = name + namelen;
+	sa_family_t family = name[namelen - 1] == 4 ? AF_INET : AF_INET6;
+	int afi_len = IN_ADDR_SIZE;
+	size_t offsetlen = *length - namelen;
+
+	if (family == AF_INET6)
+		afi_len = IN6_ADDR_SIZE;
+
+	/* Somehow with net-snmp 5.7.3, every OID item in an array
+	 * is uninitialized and has a max random value, let's zero it.
+	 * With 5.8, 5.9, it works fine even without this hack.
+	 */
+	if (!offsetlen) {
+		for (int i = 0; i < afi_len; i++)
+			*(offset + i) = 0;
+	}
+
+	if (exact) {
+		if (family == AF_INET) {
+			oid2in_addr(offset, afi_len, &addr->ip._v4_addr);
+			peer = peer_lookup_all_vrf(addr);
+			return peer;
+		} else if (family == AF_INET6) {
+			oid2in6_addr(offset, &addr->ip._v6_addr);
+			return peer_lookup_all_vrf(addr);
+		}
+	} else {
+		peer = peer_lookup_all_vrf_next(addr, offset, family);
+		if (peer == NULL)
+			return NULL;
+
+		switch (sockunion_family(&peer->su)) {
+		case AF_INET:
+			oid_copy_in_addr(offset, &peer->su.sin.sin_addr);
+			*length = afi_len + namelen;
+			return peer;
+		case AF_INET6:
+			oid_copy_in6_addr(offset, &peer->su.sin6.sin6_addr);
+			*length = afi_len + namelen;
+			return peer;
+		default:
+			break;
+		}
+	}
+
+	return NULL;
+}
+
+static uint8_t *bgpv2PeerTable(struct variable *v, oid name[], size_t *length,
+			       int exact, size_t *var_len,
+			       WriteMethod **write_method)
+{
+	struct peer *peer;
+	struct ipaddr addr = {};
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+
+	peer = bgpv2PeerTable_lookup(v, name, length, exact, &addr);
+	if (!peer)
+		return NULL;
+
+	switch (v->magic) {
+	case BGP4V2_PEER_INSTANCE:
+		return SNMP_INTEGER(peer->bgp->vrf_id);
+	case BGP4V2_PEER_LOCAL_ADDR_TYPE:
+		if (peer->su_local)
+			return SNMP_INTEGER(peer->su_local->sa.sa_family ==
+							    AF_INET
+						    ? AFI_IP
+						    : AFI_IP6);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LOCAL_ADDR:
+		if (peer->su_local)
+			if (peer->su_local->sa.sa_family == AF_INET)
+				return SNMP_IPADDRESS(
+					peer->su_local->sin.sin_addr);
+			else
+				return SNMP_IP6ADDRESS(
+					peer->su_local->sin6.sin6_addr);
+		else
+			return SNMP_IPADDRESS(bgp_empty_addr);
+	case BGP4V2_PEER_REMOTE_ADDR_TYPE:
+		if (peer->su_remote)
+			return SNMP_INTEGER(peer->su_remote->sa.sa_family ==
+							    AF_INET
+						    ? AFI_IP
+						    : AFI_IP6);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_REMOTE_ADDR:
+		if (peer->su_remote)
+			if (peer->su_remote->sa.sa_family == AF_INET)
+				return SNMP_IPADDRESS(
+					peer->su_remote->sin.sin_addr);
+			else
+				return SNMP_IP6ADDRESS(
+					peer->su_remote->sin6.sin6_addr);
+		else
+			return SNMP_IPADDRESS(bgp_empty_addr);
+	case BGP4V2_PEER_LOCAL_PORT:
+		if (peer->su_local)
+			if (peer->su_local->sa.sa_family == AF_INET)
+				return SNMP_INTEGER(
+					ntohs(peer->su_local->sin.sin_port));
+			else
+				return SNMP_INTEGER(
+					ntohs(peer->su_local->sin6.sin6_port));
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LOCAL_AS:
+		return SNMP_INTEGER(peer->local_as);
+	case BGP4V2_PEER_LOCAL_IDENTIFIER:
+		return SNMP_IPADDRESS(peer->local_id);
+	case BGP4V2_PEER_REMOTE_PORT:
+		if (peer->su_remote)
+			if (peer->su_remote->sa.sa_family == AF_INET)
+				return SNMP_INTEGER(
+					ntohs(peer->su_remote->sin.sin_port));
+			else
+				return SNMP_INTEGER(
+					ntohs(peer->su_remote->sin6.sin6_port));
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_REMOTE_AS:
+		return SNMP_INTEGER(peer->as);
+	case BGP4V2_PEER_REMOTE_IDENTIFIER:
+		return SNMP_IPADDRESS(peer->remote_id);
+	case BGP4V2_PEER_ADMIN_STATUS:
+#define BGP_PEER_ADMIN_STATUS_HALTED 1
+#define BGP_PEER_ADMIN_STATUS_RUNNING 2
+		if (BGP_PEER_START_SUPPRESSED(peer))
+			return SNMP_INTEGER(BGP_PEER_ADMIN_STATUS_HALTED);
+		else
+			return SNMP_INTEGER(BGP_PEER_ADMIN_STATUS_RUNNING);
+	case BGP4V2_PEER_STATE:
+		return SNMP_INTEGER(peer->status);
+	case BGP4V2_PEER_DESCRIPTION:
+		if (peer->desc)
+			return SNMP_STRING(peer->desc);
+		break;
+	default:
+		break;
+	}
+
+	return NULL;
+}
+
+static uint8_t *bgpv2PeerErrorsTable(struct variable *v, oid name[],
+				     size_t *length, int exact, size_t *var_len,
+				     WriteMethod **write_method)
+{
+	struct peer *peer;
+	struct ipaddr addr = {};
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+
+	peer = bgpv2PeerTable_lookup(v, name, length, exact, &addr);
+	if (!peer)
+		return NULL;
+
+	switch (v->magic) {
+	case BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->notify.code);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->notify.subcode);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->resettime);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_RECEIVED) {
+			struct bgp_notify notify = peer->notify;
+			char msg_buf[255];
+			const char *msg_str = NULL;
+
+			if (notify.code == BGP_NOTIFY_CEASE &&
+			    (notify.subcode ==
+				     BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN ||
+			     notify.subcode == BGP_NOTIFY_CEASE_ADMIN_RESET)) {
+				msg_str = bgp_notify_admin_message(
+					msg_buf, sizeof(msg_buf),
+					(uint8_t *)notify.data, notify.length);
+				return SNMP_STRING(msg_str);
+			}
+		}
+		return SNMP_STRING("");
+	case BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_STRING(peer->notify.data);
+		else
+			return SNMP_STRING("");
+	case BGP4V2_PEER_LAST_ERROR_CODE_SENT:
+		if (peer->last_reset != PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->notify.code);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT:
+		if (peer->last_reset != PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->notify.subcode);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_SENT_TIME:
+		if (peer->last_reset != PEER_DOWN_NOTIFY_RECEIVED)
+			return SNMP_INTEGER(peer->resettime);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_PEER_LAST_ERROR_SENT_TEXT:
+		if (peer->last_reset == PEER_DOWN_NOTIFY_SEND ||
+		    peer->last_reset == PEER_DOWN_RTT_SHUTDOWN ||
+		    peer->last_reset == PEER_DOWN_USER_SHUTDOWN) {
+			struct bgp_notify notify = peer->notify;
+			char msg_buf[255];
+			const char *msg_str = NULL;
+
+			if (notify.code == BGP_NOTIFY_CEASE &&
+			    (notify.subcode ==
+				     BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN ||
+			     notify.subcode == BGP_NOTIFY_CEASE_ADMIN_RESET)) {
+				msg_str = bgp_notify_admin_message(
+					msg_buf, sizeof(msg_buf),
+					(uint8_t *)notify.data, notify.length);
+				return SNMP_STRING(msg_str);
+			}
+		}
+		return SNMP_STRING("");
+	case BGP4V2_PEER_LAST_ERROR_SENT_DATA:
+		if ((peer->last_reset == PEER_DOWN_NOTIFY_SEND ||
+		     peer->last_reset == PEER_DOWN_RTT_SHUTDOWN ||
+		     peer->last_reset == PEER_DOWN_USER_SHUTDOWN) &&
+		    peer->notify.data)
+			return SNMP_STRING(peer->notify.data);
+		else
+			return SNMP_STRING("");
+	default:
+		break;
+	}
+
+	return NULL;
+}
+
+static uint8_t *bgpv2PeerEventTimesTable(struct variable *v, oid name[],
+					 size_t *length, int exact,
+					 size_t *var_len,
+					 WriteMethod **write_method)
+{
+	struct peer *peer;
+	struct ipaddr addr = {};
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+
+	peer = bgpv2PeerTable_lookup(v, name, length, exact, &addr);
+	if (!peer)
+		return NULL;
+
+	switch (v->magic) {
+	case BGP4V2_PEER_FSM_ESTABLISHED_TIME:
+		if (!peer->uptime)
+			return SNMP_INTEGER(0);
+		else
+			return SNMP_INTEGER(monotime(NULL) - peer->uptime);
+	case BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME:
+		if (!peer->update_time)
+			return SNMP_INTEGER(0);
+		else
+			return SNMP_INTEGER(monotime(NULL) - peer->update_time);
+	default:
+		break;
+	}
+
+	return NULL;
+}
+
+static struct bgp_path_info *
+bgp4v2PathAttrLookup(struct variable *v, oid name[], size_t *length,
+		     struct bgp *bgp, struct prefix *addr, int exact)
+{
+	oid *offset;
+	int offsetlen;
+	struct bgp_path_info *path, *min;
+	struct bgp_dest *dest;
+	union sockunion su;
+	unsigned int len;
+	struct ipaddr paddr = {};
+	size_t namelen = v ? v->namelen : BGP4V2_NLRI_ENTRY_OFFSET;
+	sa_family_t family = name[namelen - 1] == 4 ? AF_INET : AF_INET6;
+	afi_t afi = AFI_IP;
+	size_t afi_len = IN_ADDR_SIZE;
+
+	if (family == AF_INET6) {
+		afi = AFI_IP6;
+		afi_len = IN6_ADDR_SIZE;
+	}
+
+#define BGP_NLRI_ENTRY_OFFSET (afi_len + 1 + afi_len)
+
+	sockunion_init(&su);
+
+	if (exact) {
+		if (*length - namelen != BGP_NLRI_ENTRY_OFFSET)
+			return NULL;
+
+		/* Set OID offset for prefix */
+		offset = name + namelen;
+		if (family == AF_INET)
+			oid2in_addr(offset, afi_len, &addr->u.prefix4);
+		else
+			oid2in6_addr(offset, &addr->u.prefix6);
+		offset += afi_len;
+
+		/* Prefix length */
+		addr->prefixlen = *offset;
+		addr->family = family;
+		offset++;
+
+		/* Peer address */
+		su.sin.sin_family = family;
+		if (family == AF_INET)
+			oid2in_addr(offset, afi_len, &su.sin.sin_addr);
+		else
+			oid2in6_addr(offset, &su.sin6.sin6_addr);
+
+		/* Lookup node */
+		dest = bgp_node_lookup(bgp->rib[afi][SAFI_UNICAST], addr);
+		if (dest) {
+			for (path = bgp_dest_get_bgp_path_info(dest); path;
+			     path = path->next)
+				if (sockunion_same(&path->peer->su, &su))
+					return path;
+
+			bgp_dest_unlock_node(dest);
+		}
+
+		return NULL;
+	}
+
+	offset = name + namelen;
+	offsetlen = *length - namelen;
+	len = offsetlen;
+
+	if (offsetlen == 0) {
+		dest = bgp_table_top(bgp->rib[afi][SAFI_UNICAST]);
+	} else {
+		if (len > afi_len)
+			len = afi_len;
+
+		if (family == AF_INET)
+			oid2in_addr(offset, len, &addr->u.prefix4);
+		else
+			oid2in6_addr(offset, &addr->u.prefix6);
+
+		offset += afi_len;
+		offsetlen -= afi_len;
+
+		if (offsetlen > 0)
+			addr->prefixlen = *offset;
+		else
+			addr->prefixlen = len * 8;
+
+		addr->family = family;
+
+		dest = bgp_node_get(bgp->rib[afi][SAFI_UNICAST], addr);
+
+		offset++;
+		offsetlen--;
+	}
+
+	if (offsetlen > 0) {
+		len = offsetlen;
+		if (len > afi_len)
+			len = afi_len;
+
+		if (family == AF_INET)
+			oid2in_addr(offset, len, &paddr.ip._v4_addr);
+		else
+			oid2in6_addr(offset, &paddr.ip._v6_addr);
+	} else {
+		if (family == AF_INET)
+			memset(&paddr.ip._v4_addr, 0, afi_len);
+		else
+			memset(&paddr.ip._v6_addr, 0, afi_len);
+	}
+
+	if (!dest)
+		return NULL;
+
+	do {
+		min = NULL;
+
+		for (path = bgp_dest_get_bgp_path_info(dest); path;
+		     path = path->next) {
+			sa_family_t path_family =
+				sockunion_family(&path->peer->su);
+
+			if (path_family == AF_INET &&
+			    IPV4_ADDR_CMP(&paddr.ip._v4_addr,
+					  &path->peer->su.sin.sin_addr) < 0) {
+				if (!min ||
+				    (min &&
+				     IPV4_ADDR_CMP(
+					     &path->peer->su.sin.sin_addr,
+					     &min->peer->su.sin.sin_addr) < 0))
+					min = path;
+			} else if (path_family == AF_INET6 &&
+				   IPV6_ADDR_CMP(
+					   &paddr.ip._v6_addr,
+					   &path->peer->su.sin6.sin6_addr) <
+					   0) {
+				if (!min ||
+				    (min &&
+				     IPV6_ADDR_CMP(
+					     &path->peer->su.sin6.sin6_addr,
+					     &min->peer->su.sin6.sin6_addr) <
+					     0))
+					min = path;
+			}
+		}
+
+		if (min) {
+			const struct prefix *rn_p = bgp_dest_get_prefix(dest);
+
+			*length = namelen + BGP_NLRI_ENTRY_OFFSET;
+
+			offset = name + namelen;
+
+			/* Encode prefix into OID */
+			if (family == AF_INET)
+				oid_copy_in_addr(offset, &rn_p->u.prefix4);
+			else
+				oid_copy_in6_addr(offset, &rn_p->u.prefix6);
+
+			offset += afi_len;
+			*offset = rn_p->prefixlen;
+			offset++;
+
+			/* Encode peer's IP into OID */
+			if (family == AF_INET) {
+				oid_copy_in_addr(offset,
+						 &min->peer->su.sin.sin_addr);
+				addr->u.prefix4 = rn_p->u.prefix4;
+			} else {
+				oid_copy_in6_addr(
+					offset, &min->peer->su.sin6.sin6_addr);
+				addr->u.prefix6 = rn_p->u.prefix6;
+			}
+
+			addr->prefixlen = rn_p->prefixlen;
+			addr->family = rn_p->family;
+
+			bgp_dest_unlock_node(dest);
+
+			return min;
+		}
+
+		if (family == AF_INET)
+			memset(&paddr.ip._v4_addr, 0, afi_len);
+		else
+			memset(&paddr.ip._v6_addr, 0, afi_len);
+	} while ((dest = bgp_route_next(dest)));
+
+	return NULL;
+}
+
+static uint8_t *bgp4v2PathAttrTable(struct variable *v, oid name[],
+				    size_t *length, int exact, size_t *var_len,
+				    WriteMethod **write_method)
+{
+	struct bgp *bgp;
+	struct bgp_path_info *path;
+	struct peer_af *paf = NULL;
+	struct prefix addr = {};
+	const struct prefix *prefix = NULL;
+	enum bgp_af_index index;
+
+	bgp = bgp_get_default();
+	if (!bgp)
+		return NULL;
+
+	if (smux_header_table(v, name, length, exact, var_len, write_method) ==
+	    MATCH_FAILED)
+		return NULL;
+
+	path = bgp4v2PathAttrLookup(v, name, length, bgp, &addr, exact);
+	if (!path)
+		return NULL;
+
+	prefix = bgp_dest_get_prefix(path->net);
+
+	AF_FOREACH (index) {
+		paf = path->peer->peer_af_array[index];
+		if (paf)
+			break;
+	}
+
+	switch (v->magic) {
+	case BGP4V2_NLRI_INDEX:
+		return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_AFI:
+		if (paf)
+			return SNMP_INTEGER(paf->afi);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_SAFI:
+		if (paf)
+			return SNMP_INTEGER(paf->safi);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_PREFIX_TYPE:
+		if (paf)
+			return SNMP_INTEGER(paf->afi);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_PREFIX:
+		if (prefix->family == AF_INET6)
+			return SNMP_IP6ADDRESS(prefix->u.prefix6);
+		else
+			return SNMP_IPADDRESS(prefix->u.prefix4);
+	case BGP4V2_NLRI_PREFIX_LEN:
+		return SNMP_INTEGER(prefix->prefixlen);
+	case BGP4V2_NLRI_BEST:
+		if (CHECK_FLAG(path->flags, BGP_PATH_SELECTED))
+			return SNMP_INTEGER(1);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_CALC_LOCAL_PREF:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
+			return SNMP_INTEGER(path->attr->local_pref);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_ORIGIN:
+		switch (path->attr->origin) {
+		case BGP_ORIGIN_IGP:
+			return SNMP_INTEGER(1);
+		case BGP_ORIGIN_EGP:
+			return SNMP_INTEGER(2);
+		case BGP_ORIGIN_INCOMPLETE:
+			return SNMP_INTEGER(3);
+		default:
+			return SNMP_INTEGER(0);
+		}
+	case BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE:
+		switch (path->attr->mp_nexthop_len) {
+		case BGP_ATTR_NHLEN_IPV4:
+			return SNMP_INTEGER(1);
+		case BGP_ATTR_NHLEN_IPV6_GLOBAL:
+			return SNMP_INTEGER(2);
+		case BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL:
+			if (path->attr->mp_nexthop_prefer_global)
+				return SNMP_INTEGER(2);
+			else
+				return SNMP_INTEGER(4);
+		default:
+			return SNMP_INTEGER(1);
+		}
+	case BGP4V2_NLRI_NEXT_HOP_ADDR:
+		switch (path->attr->mp_nexthop_len) {
+		case BGP_ATTR_NHLEN_IPV4:
+			return SNMP_IPADDRESS(path->attr->mp_nexthop_global_in);
+		case BGP_ATTR_NHLEN_IPV6_GLOBAL:
+			return SNMP_IP6ADDRESS(path->attr->mp_nexthop_global);
+		case BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL:
+			if (path->attr->mp_nexthop_prefer_global)
+				return SNMP_IP6ADDRESS(
+					path->attr->mp_nexthop_global);
+			else
+				return SNMP_IP6ADDRESS(
+					path->attr->mp_nexthop_local);
+		default:
+			return SNMP_IPADDRESS(path->attr->nexthop);
+		}
+		break;
+	case BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE:
+	case BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR:
+		/* Not properly defined in specification what should be here. */
+		break;
+	case BGP4V2_NLRI_LOCAL_PREF_PRESENT:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
+			return SNMP_INTEGER(1);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_LOCAL_PREF:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
+			return SNMP_INTEGER(path->attr->local_pref);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_MED_PRESENT:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)))
+			return SNMP_INTEGER(1);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_MED:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)))
+			return SNMP_INTEGER(path->attr->med);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_ATOMIC_AGGREGATE:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)))
+			return SNMP_INTEGER(1);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_AGGREGATOR_PRESENT:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)))
+			return SNMP_INTEGER(1);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_AGGREGATOR_AS:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)))
+			return SNMP_INTEGER(path->attr->aggregator_as);
+		else
+			return SNMP_INTEGER(0);
+	case BGP4V2_NLRI_AGGREGATOR_ADDR:
+		if (CHECK_FLAG(path->attr->flag,
+			       ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)))
+			return SNMP_IPADDRESS(path->attr->aggregator_addr);
+		else
+			return SNMP_IPADDRESS(bgp_empty_addr);
+	case BGP4V2_NLRI_AS_PATH_CALC_LENGTH:
+		return SNMP_INTEGER(path->attr->aspath->segments->length);
+	case BGP4V2_NLRI_AS_PATH:
+		return aspath_snmp_pathseg(path->attr->aspath, var_len);
+	case BGP4V2_NLRI_PATH_ATTR_UNKNOWN:
+		*var_len = 0;
+		return NULL;
+	}
+	return NULL;
+}
+
+static struct variable bgpv2_variables[] = {
+	/* bgp4V2PeerEntry */
+	{BGP4V2_PEER_INSTANCE,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_INSTANCE, 1, 4}},
+	{BGP4V2_PEER_INSTANCE,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_INSTANCE, 2, 16}},
+	{BGP4V2_PEER_LOCAL_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_ADDR_TYPE, 1, 4}},
+	{BGP4V2_PEER_LOCAL_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_ADDR_TYPE, 2, 16}},
+	{BGP4V2_PEER_LOCAL_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_ADDR, 1, 4}},
+	{BGP4V2_PEER_LOCAL_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_ADDR, 2, 16}},
+	{BGP4V2_PEER_REMOTE_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_ADDR_TYPE, 1, 4}},
+	{BGP4V2_PEER_REMOTE_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_ADDR_TYPE, 2, 16}},
+	{BGP4V2_PEER_REMOTE_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_ADDR, 1, 4}},
+	{BGP4V2_PEER_REMOTE_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_ADDR, 2, 16}},
+	{BGP4V2_PEER_LOCAL_PORT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_PORT, 1, 4}},
+	{BGP4V2_PEER_LOCAL_PORT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_PORT, 2, 16}},
+	{BGP4V2_PEER_LOCAL_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_AS, 1, 4}},
+	{BGP4V2_PEER_LOCAL_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_AS, 2, 16}},
+	{BGP4V2_PEER_LOCAL_IDENTIFIER,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_IDENTIFIER, 1, 4}},
+	{BGP4V2_PEER_LOCAL_IDENTIFIER,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_LOCAL_IDENTIFIER, 2, 16}},
+	{BGP4V2_PEER_REMOTE_PORT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_PORT, 1, 4}},
+	{BGP4V2_PEER_REMOTE_PORT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_PORT, 2, 16}},
+	{BGP4V2_PEER_REMOTE_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_AS, 1, 4}},
+	{BGP4V2_PEER_REMOTE_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_AS, 2, 16}},
+	{BGP4V2_PEER_REMOTE_IDENTIFIER,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_IDENTIFIER, 1, 4}},
+	{BGP4V2_PEER_REMOTE_IDENTIFIER,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_REMOTE_IDENTIFIER, 2, 16}},
+	{BGP4V2_PEER_ADMIN_STATUS,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_ADMIN_STATUS, 1, 4}},
+	{BGP4V2_PEER_ADMIN_STATUS,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_ADMIN_STATUS, 2, 16}},
+	{BGP4V2_PEER_STATE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_STATE, 1, 4}},
+	{BGP4V2_PEER_STATE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_STATE, 2, 16}},
+	{BGP4V2_PEER_DESCRIPTION,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_DESCRIPTION, 1, 4}},
+	{BGP4V2_PEER_DESCRIPTION,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerTable,
+	 6,
+	 {1, 2, 1, BGP4V2_PEER_DESCRIPTION, 2, 16}},
+	/* bgp4V2PeerErrorsEntry */
+	{BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_CODE_SENT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_CODE_SENT, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_CODE_SENT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_CODE_SENT, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_TIME, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_TIME, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_TEXT,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_TEXT, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_TEXT,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_TEXT, 2, 16}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_DATA,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_DATA, 1, 4}},
+	{BGP4V2_PEER_LAST_ERROR_SENT_DATA,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgpv2PeerErrorsTable,
+	 6,
+	 {1, 3, 1, BGP4V2_PEER_LAST_ERROR_SENT_DATA, 2, 16}},
+	/* bgp4V2PeerEventTimesEntry */
+	{BGP4V2_PEER_FSM_ESTABLISHED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerEventTimesTable,
+	 6,
+	 {1, 4, 1, BGP4V2_PEER_FSM_ESTABLISHED_TIME, 1, 4}},
+	{BGP4V2_PEER_FSM_ESTABLISHED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerEventTimesTable,
+	 6,
+	 {1, 4, 1, BGP4V2_PEER_FSM_ESTABLISHED_TIME, 2, 16}},
+	{BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerEventTimesTable,
+	 6,
+	 {1, 4, 1, BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME, 1, 4}},
+	{BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgpv2PeerEventTimesTable,
+	 6,
+	 {1, 4, 1, BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME, 2, 16}},
+	/* bgp4V2NlriTable */
+	{BGP4V2_NLRI_INDEX,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_INDEX, 1, 4}},
+	{BGP4V2_NLRI_INDEX,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_INDEX, 2, 16}},
+	{BGP4V2_NLRI_AFI,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AFI, 1, 4}},
+	{BGP4V2_NLRI_AFI,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AFI, 2, 16}},
+	{BGP4V2_NLRI_SAFI,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_SAFI, 1, 4}},
+	{BGP4V2_NLRI_SAFI,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_SAFI, 2, 16}},
+	{BGP4V2_NLRI_PREFIX_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX_TYPE, 1, 4}},
+	{BGP4V2_NLRI_PREFIX_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX_TYPE, 2, 16}},
+	{BGP4V2_NLRI_PREFIX,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX, 1, 4}},
+	{BGP4V2_NLRI_PREFIX,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX, 2, 16}},
+	{BGP4V2_NLRI_PREFIX_LEN,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX_LEN, 1, 4}},
+	{BGP4V2_NLRI_PREFIX_LEN,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PREFIX_LEN, 2, 16}},
+	{BGP4V2_NLRI_BEST,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_BEST, 1, 4}},
+	{BGP4V2_NLRI_BEST,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_BEST, 2, 16}},
+	{BGP4V2_NLRI_CALC_LOCAL_PREF,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_CALC_LOCAL_PREF, 1, 4}},
+	{BGP4V2_NLRI_CALC_LOCAL_PREF,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_CALC_LOCAL_PREF, 2, 16}},
+	{BGP4V2_NLRI_ORIGIN,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_ORIGIN, 1, 4}},
+	{BGP4V2_NLRI_ORIGIN,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_ORIGIN, 2, 16}},
+	{BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE, 1, 4}},
+	{BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE, 2, 16}},
+	{BGP4V2_NLRI_NEXT_HOP_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_NEXT_HOP_ADDR, 1, 4}},
+	{BGP4V2_NLRI_NEXT_HOP_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_NEXT_HOP_ADDR, 2, 16}},
+	{BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE, 1, 4}},
+	{BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE, 2, 16}},
+	{BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR, 1, 4}},
+	{BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR, 2, 16}},
+	{BGP4V2_NLRI_LOCAL_PREF_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LOCAL_PREF_PRESENT, 1, 4}},
+	{BGP4V2_NLRI_LOCAL_PREF_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LOCAL_PREF_PRESENT, 2, 16}},
+	{BGP4V2_NLRI_LOCAL_PREF,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LOCAL_PREF, 1, 4}},
+	{BGP4V2_NLRI_LOCAL_PREF,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_LOCAL_PREF, 2, 16}},
+	{BGP4V2_NLRI_MED_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_MED_PRESENT, 1, 4}},
+	{BGP4V2_NLRI_MED_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_MED_PRESENT, 2, 16}},
+	{BGP4V2_NLRI_MED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_MED, 1, 4}},
+	{BGP4V2_NLRI_MED,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_MED, 2, 16}},
+	{BGP4V2_NLRI_ATOMIC_AGGREGATE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_ATOMIC_AGGREGATE, 1, 4}},
+	{BGP4V2_NLRI_ATOMIC_AGGREGATE,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_ATOMIC_AGGREGATE, 2, 16}},
+	{BGP4V2_NLRI_AGGREGATOR_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_PRESENT, 1, 4}},
+	{BGP4V2_NLRI_AGGREGATOR_PRESENT,
+	 ASN_INTEGER,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_PRESENT, 2, 16}},
+	{BGP4V2_NLRI_AGGREGATOR_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_AS, 1, 4}},
+	{BGP4V2_NLRI_AGGREGATOR_AS,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_AS, 2, 16}},
+	{BGP4V2_NLRI_AGGREGATOR_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_ADDR, 1, 4}},
+	{BGP4V2_NLRI_AGGREGATOR_ADDR,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AGGREGATOR_ADDR, 2, 16}},
+	{BGP4V2_NLRI_AS_PATH_CALC_LENGTH,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH_CALC_LENGTH, 1, 4}},
+	{BGP4V2_NLRI_AS_PATH_CALC_LENGTH,
+	 ASN_UNSIGNED,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH_CALC_LENGTH, 2, 16}},
+	{BGP4V2_NLRI_AS_PATH_STRING,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH_STRING, 1, 4}},
+	{BGP4V2_NLRI_AS_PATH_STRING,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH_STRING, 2, 16}},
+	{BGP4V2_NLRI_AS_PATH,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH, 1, 4}},
+	{BGP4V2_NLRI_AS_PATH,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_AS_PATH, 2, 16}},
+	{BGP4V2_NLRI_PATH_ATTR_UNKNOWN,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PATH_ATTR_UNKNOWN, 1, 4}},
+	{BGP4V2_NLRI_PATH_ATTR_UNKNOWN,
+	 ASN_OCTET_STR,
+	 RONLY,
+	 bgp4v2PathAttrTable,
+	 6,
+	 {1, 9, 1, BGP4V2_NLRI_PATH_ATTR_UNKNOWN, 2, 16}},
+};
+
+int bgp_snmp_bgp4v2_init(struct thread_master *tm)
+{
+	REGISTER_MIB("mibII/bgpv2", bgpv2_variables, variable, bgpv2_oid);
+	return 0;
+}
diff -urpN frr-frr-8.4.2/bgpd/bgp_snmp_bgp4v2.h frr-frr-8.5/bgpd/bgp_snmp_bgp4v2.h
--- frr-frr-8.4.2/bgpd/bgp_snmp_bgp4v2.h	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_snmp_bgp4v2.h	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,100 @@
+/* BGP4V2-MIB SNMP support
+ *
+ * Using: http://www.circitor.fr/Mibs/Html/B/BGP4V2-MIB.php
+ *
+ * Copyright (C) 2022 Donatas Abraitis <donatas@opensourcerouting.org>
+ *
+ * This file is part of FRRouting (FRR).
+ *
+ * FRR is free software; you can redistribute it and/or modify it under the
+ * terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * FRR is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _FRR_BGP_SNMP_BGP4V2_H_
+#define _FRR_BGP_SNMP_BGP4V2_H_
+
+/* bgp4V2 */
+#define BGP4V2MIB 1, 3, 6, 1, 3, 5, 1
+
+/* bgp4V2PeerEntry:
+ * offset 1.3.6.1.3.5.1.1.2.1.x.(1|2).(4|16) = 13
+ */
+#define BGP4V2_PEER_ENTRY_OFFSET 13
+#define BGP4V2_PEER_INSTANCE 1
+#define BGP4V2_PEER_LOCAL_ADDR_TYPE 2
+#define BGP4V2_PEER_LOCAL_ADDR 3
+#define BGP4V2_PEER_REMOTE_ADDR_TYPE 4
+#define BGP4V2_PEER_REMOTE_ADDR 5
+#define BGP4V2_PEER_LOCAL_PORT 6
+#define BGP4V2_PEER_LOCAL_AS 7
+#define BGP4V2_PEER_LOCAL_IDENTIFIER 8
+#define BGP4V2_PEER_REMOTE_PORT 9
+#define BGP4V2_PEER_REMOTE_AS 10
+#define BGP4V2_PEER_REMOTE_IDENTIFIER 11
+#define BGP4V2_PEER_ADMIN_STATUS 12
+#define BGP4V2_PEER_STATE 13
+#define BGP4V2_PEER_DESCRIPTION 14
+
+/* bgp4V2PeerErrorsEntry */
+#define BGP4V2_PEER_LAST_ERROR_CODE_RECEIVED 1
+#define BGP4V2_PEER_LAST_ERROR_SUBCODE_RECEIVED 2
+#define BGP4V2_PEER_LAST_ERROR_RECEIVED_TIME 3
+#define BGP4V2_PEER_LAST_ERROR_RECEIVED_TEXT 4
+#define BGP4V2_PEER_LAST_ERROR_RECEIVED_DATA 5
+#define BGP4V2_PEER_LAST_ERROR_CODE_SENT 6
+#define BGP4V2_PEER_LAST_ERROR_SUBCODE_SENT 7
+#define BGP4V2_PEER_LAST_ERROR_SENT_TIME 8
+#define BGP4V2_PEER_LAST_ERROR_SENT_TEXT 9
+#define BGP4V2_PEER_LAST_ERROR_SENT_DATA 10
+
+/* bgp4V2PeerEventTimesEntry */
+#define BGP4V2_PEER_FSM_ESTABLISHED_TIME 1
+#define BGP4V2_PEER_PEER_IN_UPDATES_ELAPSED_TIME 2
+
+/* bgp4V2NlriEntry
+ * offset 1.3.6.1.3.5.1.1.9.1.x.(1|2).(4|16) = 13
+ */
+#define BGP4V2_NLRI_ENTRY_OFFSET 13
+#define BGP4V2_NLRI_INDEX 1
+#define BGP4V2_NLRI_AFI 2
+#define BGP4V2_NLRI_SAFI 3
+#define BGP4V2_NLRI_PREFIX_TYPE 4
+#define BGP4V2_NLRI_PREFIX 5
+#define BGP4V2_NLRI_PREFIX_LEN 6
+#define BGP4V2_NLRI_BEST 7
+#define BGP4V2_NLRI_CALC_LOCAL_PREF 8
+#define BGP4V2_NLRI_ORIGIN 9
+#define BGP4V2_NLRI_NEXT_HOP_ADDR_TYPE 10
+#define BGP4V2_NLRI_NEXT_HOP_ADDR 11
+#define BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR_TYPE 12
+#define BGP4V2_NLRI_LINK_LOCAL_NEXT_HOP_ADDR 13
+#define BGP4V2_NLRI_LOCAL_PREF_PRESENT 14
+#define BGP4V2_NLRI_LOCAL_PREF 15
+#define BGP4V2_NLRI_MED_PRESENT 16
+#define BGP4V2_NLRI_MED 17
+#define BGP4V2_NLRI_ATOMIC_AGGREGATE 18
+#define BGP4V2_NLRI_AGGREGATOR_PRESENT 19
+#define BGP4V2_NLRI_AGGREGATOR_AS 20
+#define BGP4V2_NLRI_AGGREGATOR_ADDR 21
+#define BGP4V2_NLRI_AS_PATH_CALC_LENGTH 22
+#define BGP4V2_NLRI_AS_PATH_STRING 23
+#define BGP4V2_NLRI_AS_PATH 24
+#define BGP4V2_NLRI_PATH_ATTR_UNKNOWN 25
+
+/* bgp4V2Notifications */
+#define BGP4V2_ESTABLISHED_NOTIFICATION 1
+#define BGP4V2_BACKWARD_TRANSITION_NOTIFICATION 2
+
+extern int bgp_snmp_bgp4v2_init(struct thread_master *tm);
+
+#endif /* _FRR_BGP_SNMP_BGP4V2_H_ */
diff -urpN frr-frr-8.4.2/bgpd/bgp_table.h frr-frr-8.5/bgpd/bgp_table.h
--- frr-frr-8.4.2/bgpd/bgp_table.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_table.h	2023-03-13 20:01:47.000000000 +0600
@@ -63,7 +63,9 @@ enum bgp_path_selection_reason {
 	bgp_path_selection_evpn_lower_ip,
 	bgp_path_selection_weight,
 	bgp_path_selection_local_pref,
+	bgp_path_selection_accept_own,
 	bgp_path_selection_local_route,
+	bgp_path_selection_aigp,
 	bgp_path_selection_confed_as_path,
 	bgp_path_selection_as_path,
 	bgp_path_selection_origin,
diff -urpN frr-frr-8.4.2/bgpd/bgp_trace.h frr-frr-8.5/bgpd/bgp_trace.h
--- frr-frr-8.4.2/bgpd/bgp_trace.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_trace.h	2023-03-13 20:01:47.000000000 +0600
@@ -247,6 +247,71 @@ TRACEPOINT_EVENT(
 )
 TRACEPOINT_LOGLEVEL(frr_bgp, bgp_dest_unlock, TRACE_INFO)
 
+/*
+ * peer_lock/peer_unlock
+ */
+TRACEPOINT_EVENT(
+	frr_bgp,
+	bgp_peer_lock,
+	TP_ARGS(struct peer *, peer,
+		const char *, name),
+	TP_FIELDS(
+		ctf_string(caller, name)
+		ctf_string(peer, PEER_HOSTNAME(peer))
+		ctf_integer(unsigned int, count, peer->lock)
+	)
+)
+TRACEPOINT_LOGLEVEL(frr_bgp, bgp_peer_lock, TRACE_INFO)
+
+TRACEPOINT_EVENT(
+	frr_bgp,
+	bgp_peer_unlock,
+	TP_ARGS(struct peer *, peer,
+		const char *, name),
+	TP_FIELDS(
+		ctf_string(caller, name)
+		ctf_string(peer, PEER_HOSTNAME(peer))
+		ctf_integer(unsigned int, count, peer->lock)
+	)
+)
+TRACEPOINT_LOGLEVEL(frr_bgp, bgp_peer_unlock, TRACE_INFO)
+
+/*
+ * bgp_path_info_add/bgp_path_info_free
+ */
+TRACEPOINT_EVENT(
+	frr_bgp,
+	bgp_path_info_add,
+	TP_ARGS(struct bgp_dest *, dest,
+		struct bgp_path_info *, bpi,
+		const char *, name),
+	TP_FIELDS(
+		ctf_string(caller, name)
+		ctf_string(prefix, bgp_dest_get_prefix_str(dest))
+		ctf_string(peer, PEER_HOSTNAME(bpi->peer))
+		ctf_integer(unsigned int, dest_lock,
+			    bgp_dest_get_lock_count(dest))
+		ctf_integer(unsigned int, peer_lock, bpi->peer->lock)
+	)
+)
+TRACEPOINT_LOGLEVEL(frr_bgp, bgp_path_info_add, TRACE_INFO)
+
+TRACEPOINT_EVENT(
+	frr_bgp,
+	bgp_path_info_free,
+	TP_ARGS(struct bgp_path_info *, bpi,
+		const char *, name),
+	TP_FIELDS(
+		ctf_string(caller, name)
+		ctf_string(prefix, bgp_dest_get_prefix_str(bpi->net))
+		ctf_string(peer, PEER_HOSTNAME(bpi->peer))
+		ctf_integer(unsigned int, dest_lock,
+			    bgp_dest_get_lock_count(bpi->net))
+		ctf_integer(unsigned int, peer_lock, bpi->peer->lock)
+	)
+)
+TRACEPOINT_LOGLEVEL(frr_bgp, bgp_path_info_free, TRACE_INFO)
+
 TRACEPOINT_EVENT(
 	frr_bgp,
 	evpn_mac_ip_zsend,
diff -urpN frr-frr-8.4.2/bgpd/bgp_updgrp.c frr-frr-8.5/bgpd/bgp_updgrp.c
--- frr-frr-8.4.2/bgpd/bgp_updgrp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_updgrp.c	2023-03-13 20:01:47.000000000 +0600
@@ -164,6 +164,7 @@ static void conf_copy(struct peer *dst,
 	dst->change_local_as = src->change_local_as;
 	dst->shared_network = src->shared_network;
 	dst->local_role = src->local_role;
+	dst->as_path_loop_detection = src->as_path_loop_detection;
 
 	if (src->soo[afi][safi]) {
 		ecommunity_free(&dst->soo[afi][safi]);
@@ -331,7 +332,7 @@ static unsigned int updgrp_hash_key_make
 	const struct update_group *updgrp;
 	const struct peer *peer;
 	const struct bgp_filter *filter;
-	uint32_t flags;
+	uint64_t flags;
 	uint32_t key;
 	afi_t afi;
 	safi_t safi;
@@ -360,6 +361,9 @@ static unsigned int updgrp_hash_key_make
 	key = jhash_1word(peer->max_packet_size, key);
 	key = jhash_1word(peer->pmax_out[afi][safi], key);
 
+	if (peer->as_path_loop_detection)
+		key = jhash_2words(peer->as, peer->as_path_loop_detection, key);
+
 	if (peer->group)
 		key = jhash_1word(jhash(peer->group->name,
 					strlen(peer->group->name), SEED1),
@@ -436,6 +440,11 @@ static unsigned int updgrp_hash_key_make
 	 */
 	key = jhash_1word(peer->local_role, key);
 
+	/* Neighbors configured with the AIGP attribute are put in a separate
+	 * update group from other neighbors.
+	 */
+	key = jhash_1word((peer->flags & PEER_FLAG_AIGP), key);
+
 	if (peer->soo[afi][safi]) {
 		char *soo_str = ecommunity_str(peer->soo[afi][safi]);
 
@@ -449,12 +458,13 @@ static unsigned int updgrp_hash_key_make
 			(intmax_t)CHECK_FLAG(peer->flags, PEER_UPDGRP_FLAGS),
 			(intmax_t)CHECK_FLAG(flags, PEER_UPDGRP_AF_FLAGS));
 		zlog_debug(
-			"%pBP Update Group Hash: addpath: %u UpdGrpCapFlag: %u UpdGrpCapAFFlag: %u route_adv: %u change local as: %u",
+			"%pBP Update Group Hash: addpath: %u UpdGrpCapFlag: %u UpdGrpCapAFFlag: %u route_adv: %u change local as: %u, as_path_loop_detection: %d",
 			peer, (uint32_t)peer->addpath_type[afi][safi],
 			CHECK_FLAG(peer->cap, PEER_UPDGRP_CAP_FLAGS),
 			CHECK_FLAG(peer->af_cap[afi][safi],
 				   PEER_UPDGRP_AF_CAP_FLAGS),
-			peer->v_routeadv, peer->change_local_as);
+			peer->v_routeadv, peer->change_local_as,
+			peer->as_path_loop_detection);
 		zlog_debug(
 			"%pBP Update Group Hash: max packet size: %u pmax_out: %u Peer Group: %s rmap out: %s",
 			peer, peer->max_packet_size, peer->pmax_out[afi][safi],
@@ -506,8 +516,8 @@ static bool updgrp_hash_cmp(const void *
 	const struct update_group *grp2;
 	const struct peer *pe1;
 	const struct peer *pe2;
-	uint32_t flags1;
-	uint32_t flags2;
+	uint64_t flags1;
+	uint64_t flags2;
 	const struct bgp_filter *fl1;
 	const struct bgp_filter *fl2;
 	afi_t afi;
@@ -672,6 +682,15 @@ static int update_group_show_walkcb(stru
 	struct bgp_filter *filter;
 	struct peer *peer = UPDGRP_PEER(updgrp);
 	int match = 0;
+	json_object *json_updgrp = NULL;
+	json_object *json_subgrps = NULL;
+	json_object *json_subgrp = NULL;
+	json_object *json_time = NULL;
+	json_object *json_subgrp_time = NULL;
+	json_object *json_subgrp_event = NULL;
+	json_object *json_peers = NULL;
+	json_object *json_pkt_info = NULL;
+	time_t epoch_tbuf, tbuf;
 
 	if (!ctx)
 		return CMD_SUCCESS;
@@ -698,79 +717,233 @@ static int update_group_show_walkcb(stru
 
 	vty = ctx->vty;
 
-	vty_out(vty, "Update-group %" PRIu64 ":\n", updgrp->id);
-	vty_out(vty, "  Created: %s", timestamp_string(updgrp->uptime));
+	if (ctx->uj) {
+		json_updgrp = json_object_new_object();
+		/* Display json o/p */
+		tbuf = monotime(NULL);
+		tbuf -= updgrp->uptime;
+		epoch_tbuf = time(NULL) - tbuf;
+		json_time = json_object_new_object();
+		json_object_int_add(json_time, "epoch", epoch_tbuf);
+		json_object_string_add(json_time, "epochString",
+				       ctime(&epoch_tbuf));
+		json_object_object_add(json_updgrp, "groupCreateTime",
+				       json_time);
+		json_object_string_add(json_updgrp, "afi",
+				       afi2str(updgrp->afi));
+		json_object_string_add(json_updgrp, "safi",
+				       safi2str(updgrp->safi));
+	} else {
+		vty_out(vty, "Update-group %" PRIu64 ":\n", updgrp->id);
+		vty_out(vty, "  Created: %s", timestamp_string(updgrp->uptime));
+	}
+
 	filter = &updgrp->conf->filter[updgrp->afi][updgrp->safi];
-	if (filter->map[RMAP_OUT].name)
-		vty_out(vty, "  Outgoing route map: %s\n",
-			filter->map[RMAP_OUT].name);
-	vty_out(vty, "  MRAI value (seconds): %d\n", updgrp->conf->v_routeadv);
-	if (updgrp->conf->change_local_as)
-		vty_out(vty, "  Local AS %u%s%s\n",
-			updgrp->conf->change_local_as,
-			CHECK_FLAG(updgrp->conf->flags,
-				   PEER_FLAG_LOCAL_AS_NO_PREPEND)
-				? " no-prepend"
-				: "",
-			CHECK_FLAG(updgrp->conf->flags,
-				   PEER_FLAG_LOCAL_AS_REPLACE_AS)
-				? " replace-as"
-				: "");
+	if (filter->map[RMAP_OUT].name) {
+		if (ctx->uj)
+			json_object_string_add(json_updgrp, "outRouteMap",
+					       filter->map[RMAP_OUT].name);
+		else
+			vty_out(vty, "  Outgoing route map: %s\n",
+				filter->map[RMAP_OUT].name);
+	}
 
+	if (ctx->uj)
+		json_object_int_add(json_updgrp, "minRouteAdvInt",
+				    updgrp->conf->v_routeadv);
+	else
+		vty_out(vty, "  MRAI value (seconds): %d\n",
+			updgrp->conf->v_routeadv);
+
+	if (updgrp->conf->change_local_as) {
+		if (ctx->uj) {
+			json_object_int_add(json_updgrp, "localAs",
+					    updgrp->conf->change_local_as);
+			json_object_boolean_add(
+				json_updgrp, "noPrepend",
+				CHECK_FLAG(updgrp->conf->flags,
+					   PEER_FLAG_LOCAL_AS_NO_PREPEND));
+			json_object_boolean_add(
+				json_updgrp, "replaceLocalAs",
+				CHECK_FLAG(updgrp->conf->flags,
+					   PEER_FLAG_LOCAL_AS_REPLACE_AS));
+		} else {
+			vty_out(vty, "  Local AS %u%s%s\n",
+				updgrp->conf->change_local_as,
+				CHECK_FLAG(updgrp->conf->flags,
+					   PEER_FLAG_LOCAL_AS_NO_PREPEND)
+					? " no-prepend"
+					: "",
+				CHECK_FLAG(updgrp->conf->flags,
+					   PEER_FLAG_LOCAL_AS_REPLACE_AS)
+					? " replace-as"
+					: "");
+		}
+	}
+	if (ctx->uj)
+		json_subgrps = json_object_new_array();
 	UPDGRP_FOREACH_SUBGRP (updgrp, subgrp) {
 		if (ctx->subgrp_id && (ctx->subgrp_id != subgrp->id))
 			continue;
-		vty_out(vty, "\n");
-		vty_out(vty, "  Update-subgroup %" PRIu64 ":\n", subgrp->id);
-		vty_out(vty, "    Created: %s",
-			timestamp_string(subgrp->uptime));
+		if (ctx->uj) {
+			json_subgrp = json_object_new_object();
+			json_object_int_add(json_subgrp, "subGroupId",
+					    subgrp->id);
+			tbuf = monotime(NULL);
+			tbuf -= subgrp->uptime;
+			epoch_tbuf = time(NULL) - tbuf;
+			json_subgrp_time = json_object_new_object();
+			json_object_int_add(json_subgrp_time, "epoch",
+					    epoch_tbuf);
+			json_object_string_add(json_subgrp_time, "epochString",
+					       ctime(&epoch_tbuf));
+			json_object_object_add(json_subgrp, "groupCreateTime",
+					       json_subgrp_time);
+		} else {
+			vty_out(vty, "\n");
+			vty_out(vty, "  Update-subgroup %" PRIu64 ":\n",
+				subgrp->id);
+			vty_out(vty, "    Created: %s",
+				timestamp_string(subgrp->uptime));
+		}
 
 		if (subgrp->split_from.update_group_id
 		    || subgrp->split_from.subgroup_id) {
-			vty_out(vty, "    Split from group id: %" PRIu64 "\n",
-				subgrp->split_from.update_group_id);
-			vty_out(vty,
-				"    Split from subgroup id: %" PRIu64 "\n",
-				subgrp->split_from.subgroup_id);
+			if (ctx->uj) {
+				json_object_int_add(
+					json_subgrp, "splitGroupId",
+					subgrp->split_from.update_group_id);
+				json_object_int_add(
+					json_subgrp, "splitSubGroupId",
+					subgrp->split_from.subgroup_id);
+			} else {
+				vty_out(vty,
+					"    Split from group id: %" PRIu64
+					"\n",
+					subgrp->split_from.update_group_id);
+				vty_out(vty,
+					"    Split from subgroup id: %" PRIu64
+					"\n",
+					subgrp->split_from.subgroup_id);
+			}
 		}
 
-		vty_out(vty, "    Join events: %u\n", subgrp->join_events);
-		vty_out(vty, "    Prune events: %u\n", subgrp->prune_events);
-		vty_out(vty, "    Merge events: %u\n", subgrp->merge_events);
-		vty_out(vty, "    Split events: %u\n", subgrp->split_events);
-		vty_out(vty, "    Update group switch events: %u\n",
-			subgrp->updgrp_switch_events);
-		vty_out(vty, "    Peer refreshes combined: %u\n",
-			subgrp->peer_refreshes_combined);
-		vty_out(vty, "    Merge checks triggered: %u\n",
-			subgrp->merge_checks_triggered);
-		vty_out(vty, "    Coalesce Time: %u%s\n",
-			(UPDGRP_INST(subgrp->update_group))->coalesce_time,
-			subgrp->t_coalesce ? "(Running)" : "");
-		vty_out(vty, "    Version: %" PRIu64 "\n", subgrp->version);
-		vty_out(vty, "    Packet queue length: %d\n",
-			bpacket_queue_length(SUBGRP_PKTQ(subgrp)));
-		vty_out(vty, "    Total packets enqueued: %u\n",
-			subgroup_total_packets_enqueued(subgrp));
-		vty_out(vty, "    Packet queue high watermark: %d\n",
-			bpacket_queue_hwm_length(SUBGRP_PKTQ(subgrp)));
-		vty_out(vty, "    Adj-out list count: %u\n", subgrp->adj_count);
-		vty_out(vty, "    Advertise list: %s\n",
-			advertise_list_is_empty(subgrp) ? "empty"
-							: "not empty");
-		vty_out(vty, "    Flags: %s\n",
-			CHECK_FLAG(subgrp->flags, SUBGRP_FLAG_NEEDS_REFRESH)
-				? "R"
-				: "");
-		if (peer)
-			vty_out(vty, "    Max packet size: %d\n",
-				peer->max_packet_size);
+		if (ctx->uj) {
+			json_subgrp_event = json_object_new_object();
+			json_object_int_add(json_subgrp_event, "joinEvents",
+					    subgrp->join_events);
+			json_object_int_add(json_subgrp_event, "pruneEvents",
+					    subgrp->prune_events);
+			json_object_int_add(json_subgrp_event, "mergeEvents",
+					    subgrp->merge_events);
+			json_object_int_add(json_subgrp_event, "splitEvents",
+					    subgrp->split_events);
+			json_object_int_add(json_subgrp_event, "switchEvents",
+					    subgrp->updgrp_switch_events);
+			json_object_int_add(json_subgrp_event,
+					    "peerRefreshEvents",
+					    subgrp->peer_refreshes_combined);
+			json_object_int_add(json_subgrp_event,
+					    "mergeCheckEvents",
+					    subgrp->merge_checks_triggered);
+			json_object_object_add(json_subgrp, "statistics",
+					       json_subgrp_event);
+			json_object_int_add(json_subgrp, "coalesceTime",
+					    (UPDGRP_INST(subgrp->update_group))
+						    ->coalesce_time);
+			json_object_int_add(json_subgrp, "version",
+					    subgrp->version);
+			json_pkt_info = json_object_new_object();
+			json_object_int_add(
+				json_pkt_info, "qeueueLen",
+				bpacket_queue_length(SUBGRP_PKTQ(subgrp)));
+			json_object_int_add(
+				json_pkt_info, "queuedTotal",
+				subgroup_total_packets_enqueued(subgrp));
+			json_object_int_add(
+				json_pkt_info, "queueHwmLen",
+				bpacket_queue_hwm_length(SUBGRP_PKTQ(subgrp)));
+			json_object_int_add(
+				json_pkt_info, "totalEnqueued",
+				subgroup_total_packets_enqueued(subgrp));
+			json_object_object_add(json_subgrp, "packetQueueInfo",
+					       json_pkt_info);
+			json_object_int_add(json_subgrp, "adjListCount",
+					    subgrp->adj_count);
+			json_object_boolean_add(
+				json_subgrp, "needsRefresh",
+				CHECK_FLAG(subgrp->flags,
+					   SUBGRP_FLAG_NEEDS_REFRESH));
+		} else {
+			vty_out(vty, "    Join events: %u\n",
+				subgrp->join_events);
+			vty_out(vty, "    Prune events: %u\n",
+				subgrp->prune_events);
+			vty_out(vty, "    Merge events: %u\n",
+				subgrp->merge_events);
+			vty_out(vty, "    Split events: %u\n",
+				subgrp->split_events);
+			vty_out(vty, "    Update group switch events: %u\n",
+				subgrp->updgrp_switch_events);
+			vty_out(vty, "    Peer refreshes combined: %u\n",
+				subgrp->peer_refreshes_combined);
+			vty_out(vty, "    Merge checks triggered: %u\n",
+				subgrp->merge_checks_triggered);
+			vty_out(vty, "    Coalesce Time: %u%s\n",
+				(UPDGRP_INST(subgrp->update_group))
+					->coalesce_time,
+				subgrp->t_coalesce ? "(Running)" : "");
+			vty_out(vty, "    Version: %" PRIu64 "\n",
+				subgrp->version);
+			vty_out(vty, "    Packet queue length: %d\n",
+				bpacket_queue_length(SUBGRP_PKTQ(subgrp)));
+			vty_out(vty, "    Total packets enqueued: %u\n",
+				subgroup_total_packets_enqueued(subgrp));
+			vty_out(vty, "    Packet queue high watermark: %d\n",
+				bpacket_queue_hwm_length(SUBGRP_PKTQ(subgrp)));
+			vty_out(vty, "    Adj-out list count: %u\n",
+				subgrp->adj_count);
+			vty_out(vty, "    Advertise list: %s\n",
+				advertise_list_is_empty(subgrp) ? "empty"
+								: "not empty");
+			vty_out(vty, "    Flags: %s\n",
+				CHECK_FLAG(subgrp->flags,
+					   SUBGRP_FLAG_NEEDS_REFRESH)
+					? "R"
+					: "");
+			if (peer)
+				vty_out(vty, "    Max packet size: %d\n",
+					peer->max_packet_size);
+		}
 		if (subgrp->peer_count > 0) {
-			vty_out(vty, "    Peers:\n");
-			SUBGRP_FOREACH_PEER (subgrp, paf)
-				vty_out(vty, "      - %s\n", paf->peer->host);
+			if (ctx->uj) {
+				json_peers = json_object_new_array();
+				SUBGRP_FOREACH_PEER (subgrp, paf) {
+					json_object *peer =
+						json_object_new_string(
+							paf->peer->host);
+					json_object_array_add(json_peers, peer);
+				}
+				json_object_object_add(json_subgrp, "peers",
+						       json_peers);
+			} else {
+				vty_out(vty, "    Peers:\n");
+				SUBGRP_FOREACH_PEER (subgrp, paf)
+					vty_out(vty, "      - %s\n",
+						paf->peer->host);
+			}
 		}
+
+		if (ctx->uj)
+			json_object_array_add(json_subgrps, json_subgrp);
+	}
+
+	if (ctx->uj) {
+		json_object_object_add(json_updgrp, "subGroup", json_subgrps);
+		json_object_object_addf(ctx->json_updategrps, json_updgrp,
+					"%" PRIu64, updgrp->id);
 	}
+
 	return UPDWALK_CONTINUE;
 }
 
@@ -1703,14 +1876,34 @@ void update_bgp_group_free(struct bgp *b
 }
 
 void update_group_show(struct bgp *bgp, afi_t afi, safi_t safi, struct vty *vty,
-		       uint64_t subgrp_id)
+		       uint64_t subgrp_id, bool uj)
 {
 	struct updwalk_context ctx;
+	json_object *json_vrf_obj = NULL;
+
 	memset(&ctx, 0, sizeof(ctx));
 	ctx.vty = vty;
 	ctx.subgrp_id = subgrp_id;
+	ctx.uj = uj;
+
+	if (uj) {
+		ctx.json_updategrps = json_object_new_object();
+		json_vrf_obj = json_object_new_object();
+	}
 
 	update_group_af_walk(bgp, afi, safi, update_group_show_walkcb, &ctx);
+
+	if (uj) {
+		const char *vname;
+
+		if (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
+			vname = VRF_DEFAULT_NAME;
+		else
+			vname = bgp->name;
+		json_object_object_add(json_vrf_obj, vname,
+				       ctx.json_updategrps);
+		vty_json(vty, json_vrf_obj);
+	}
 }
 
 /*
@@ -2043,10 +2236,18 @@ bool bgp_addpath_encode_tx(struct peer *
 			      PEER_CAP_ADDPATH_AF_RX_RCV));
 }
 
+bool bgp_addpath_capable(struct bgp_path_info *bpi, struct peer *peer,
+			 afi_t afi, safi_t safi)
+{
+	return (bgp_addpath_tx_path(peer->addpath_type[afi][safi], bpi) ||
+		(safi == SAFI_LABELED_UNICAST &&
+		 bgp_addpath_tx_path(peer->addpath_type[afi][SAFI_UNICAST],
+				     bpi)));
+}
+
 bool bgp_check_selected(struct bgp_path_info *bpi, struct peer *peer,
 			bool addpath_capable, afi_t afi, safi_t safi)
 {
 	return (CHECK_FLAG(bpi->flags, BGP_PATH_SELECTED) ||
-		(addpath_capable &&
-		 bgp_addpath_tx_path(peer->addpath_type[afi][safi], bpi)));
+		(addpath_capable && bgp_addpath_capable(bpi, peer, afi, safi)));
 }
diff -urpN frr-frr-8.4.2/bgpd/bgp_updgrp.h frr-frr-8.5/bgpd/bgp_updgrp.h
--- frr-frr-8.4.2/bgpd/bgp_updgrp.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_updgrp.h	2023-03-13 20:01:47.000000000 +0600
@@ -88,6 +88,8 @@ typedef struct {
 #define BPKT_ATTRVEC_FLAGS_RMAP_IPV4_NH_CHANGED   (1 << 4)
 #define BPKT_ATTRVEC_FLAGS_RMAP_IPV6_GNH_CHANGED  (1 << 5)
 #define BPKT_ATTRVEC_FLAGS_RMAP_IPV6_LNH_CHANGED  (1 << 6)
+#define BPKT_ATTRVEC_FLAGS_RMAP_VPNV4_NH_CHANGED  (1 << 7)
+#define BPKT_ATTRVEC_FLAGS_RMAP_VPNV6_GNH_CHANGED (1 << 8)
 
 typedef struct bpacket_attr_vec_arr {
 	bpacket_attr_vec entries[BGP_ATTR_VEC_MAX];
@@ -302,6 +304,8 @@ struct updwalk_context {
 	updgrp_walkcb cb;
 	void *context;
 	uint8_t flags;
+	bool uj;
+	json_object *json_updategrps;
 
 #define UPDWALK_FLAGS_ADVQUEUE   (1 << 0)
 #define UPDWALK_FLAGS_ADVERTISED (1 << 1)
@@ -363,7 +367,7 @@ extern void update_bgp_group_init(struct
 extern void udpate_bgp_group_free(struct bgp *);
 
 extern void update_group_show(struct bgp *bgp, afi_t afi, safi_t safi,
-			      struct vty *vty, uint64_t subgrp_id);
+			      struct vty *vty, uint64_t subgrp_id, bool uj);
 extern void update_group_show_stats(struct bgp *bgp, struct vty *vty);
 extern void update_group_adjust_peer(struct peer_af *paf);
 extern int update_group_adjust_soloness(struct peer *peer, int set);
@@ -472,6 +476,8 @@ extern void update_bgp_group_free(struct
 extern bool bgp_addpath_encode_tx(struct peer *peer, afi_t afi, safi_t safi);
 extern bool bgp_check_selected(struct bgp_path_info *bpi, struct peer *peer,
 			       bool addpath_capable, afi_t afi, safi_t safi);
+extern bool bgp_addpath_capable(struct bgp_path_info *bpi, struct peer *peer,
+				afi_t afi, safi_t safi);
 
 /*
  * Inline functions
diff -urpN frr-frr-8.4.2/bgpd/bgp_updgrp_adv.c frr-frr-8.5/bgpd/bgp_updgrp_adv.c
--- frr-frr-8.4.2/bgpd/bgp_updgrp_adv.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_updgrp_adv.c	2023-03-13 20:01:47.000000000 +0600
@@ -355,6 +355,11 @@ static int update_group_announce_walkcb(
 	struct update_subgroup *subgrp;
 
 	UPDGRP_FOREACH_SUBGRP (updgrp, subgrp) {
+		/* Avoid supressing duplicate routes later
+		 * when processing in subgroup_announce_table().
+		 */
+		SET_FLAG(subgrp->sflags, SUBGRP_STATUS_FORCE_UPDATES);
+
 		subgroup_announce_all(subgrp);
 	}
 
@@ -507,6 +512,23 @@ void bgp_adj_out_set_subgroup(struct bgp
 			zlog_debug("%s suppress UPDATE w/ attr: %s", peer->host,
 				   attr_str);
 		}
+
+		/*
+		 * If BGP is skipping sending this value to it's peers
+		 * the version number should be updated just like it
+		 * would if it sent the data.  Why?  Because update
+		 * groups will not be coalesced until such time that
+		 * the version numbers are the same.
+		 *
+		 * Imagine a scenario with say 2 peers and they come
+		 * up and are placed in the same update group.  Then
+		 * a new peer comes up a bit later.  Then a prefix is
+		 * flapped that we decide for the first 2 peers are
+		 * mapped to and we decide not to send the data to
+		 * it.  Then unless more network changes happen we
+		 * will never be able to coalesce the 3rd peer down
+		 */
+		subgrp->version = MAX(subgrp->version, dest->version);
 		return;
 	}
 
@@ -650,6 +672,7 @@ void subgroup_announce_table(struct upda
 	struct peer *peer;
 	afi_t afi;
 	safi_t safi;
+	safi_t safi_rib;
 	bool addpath_capable;
 	struct bgp *bgp;
 	bool advertise;
@@ -661,10 +684,12 @@ void subgroup_announce_table(struct upda
 	addpath_capable = bgp_addpath_encode_tx(peer, afi, safi);
 
 	if (safi == SAFI_LABELED_UNICAST)
-		safi = SAFI_UNICAST;
+		safi_rib = SAFI_UNICAST;
+	else
+		safi_rib = safi;
 
 	if (!table)
-		table = peer->bgp->rib[afi][safi];
+		table = peer->bgp->rib[afi][safi_rib];
 
 	if (safi != SAFI_MPLS_VPN && safi != SAFI_ENCAP && safi != SAFI_EVPN
 	    && CHECK_FLAG(peer->af_flags[afi][safi],
@@ -683,7 +708,7 @@ void subgroup_announce_table(struct upda
 		for (ri = bgp_dest_get_bgp_path_info(dest); ri; ri = ri->next) {
 
 			if (!bgp_check_selected(ri, peer, addpath_capable, afi,
-						safi))
+						safi_rib))
 				continue;
 
 			if (subgroup_announce_check(dest, ri, subgrp, dest_p,
@@ -698,7 +723,8 @@ void subgroup_announce_table(struct upda
 						bgp_adj_out_unset_subgroup(
 							dest, subgrp, 1,
 							bgp_addpath_id_for_peer(
-								peer, afi, safi,
+								peer, afi,
+								safi_rib,
 								&ri->tx_addpath));
 				}
 			} else {
@@ -717,7 +743,7 @@ void subgroup_announce_table(struct upda
 				bgp_adj_out_unset_subgroup(
 					dest, subgrp, 1,
 					bgp_addpath_id_for_peer(
-						peer, afi, safi,
+						peer, afi, safi_rib,
 						&ri->tx_addpath));
 			}
 		}
@@ -794,6 +820,7 @@ void subgroup_default_originate(struct u
 	route_map_result_t new_ret = RMAP_DENYMATCH;
 	afi_t afi;
 	safi_t safi;
+	safi_t safi_rib;
 	int pref = 65536;
 	int new_pref = 0;
 
@@ -807,6 +834,11 @@ void subgroup_default_originate(struct u
 	if (!(afi == AFI_IP || afi == AFI_IP6))
 		return;
 
+	if (safi == SAFI_LABELED_UNICAST)
+		safi_rib = SAFI_UNICAST;
+	else
+		safi_rib = safi;
+
 	bgp = peer->bgp;
 	from = bgp->peer_self;
 
@@ -840,7 +872,7 @@ void subgroup_default_originate(struct u
 		 * the default route. We announce the default
 		 * route only if route-map has a match.
 		 */
-		for (dest = bgp_table_top(bgp->rib[afi][safi]); dest;
+		for (dest = bgp_table_top(bgp->rib[afi][safi_rib]); dest;
 		     dest = bgp_route_next(dest)) {
 			if (!bgp_dest_has_bgp_path_info_data(dest))
 				continue;
@@ -898,7 +930,8 @@ void subgroup_default_originate(struct u
 	memset(&p, 0, sizeof(p));
 	p.family = afi2family(afi);
 	p.prefixlen = 0;
-	dest = bgp_afi_node_lookup(bgp->rib[afi][safi], afi, safi, &p, NULL);
+	dest = bgp_afi_node_lookup(bgp->rib[afi][safi_rib], afi, safi_rib, &p,
+				   NULL);
 
 	if (withdraw) {
 		/* Withdraw the default route advertised using default
@@ -918,10 +951,14 @@ void subgroup_default_originate(struct u
 					if (subgroup_announce_check(
 						    dest, pi, subgrp,
 						    bgp_dest_get_prefix(dest),
-						    &attr, NULL))
+						    &attr, NULL)) {
+						struct attr *default_attr =
+							bgp_attr_intern(&attr);
+
 						bgp_adj_out_set_subgroup(
-							dest, subgrp, &attr,
-							pi);
+							dest, subgrp,
+							default_attr, pi);
+					}
 			}
 			bgp_dest_unlock_node(dest);
 		}
diff -urpN frr-frr-8.4.2/bgpd/bgp_updgrp_packet.c frr-frr-8.5/bgpd/bgp_updgrp_packet.c
--- frr-frr-8.4.2/bgpd/bgp_updgrp_packet.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_updgrp_packet.c	2023-03-13 20:01:47.000000000 +0600
@@ -379,10 +379,11 @@ struct stream *bpacket_reformat_for_peer
 
 		route_map_sets_nh =
 			(CHECK_FLAG(vec->flags,
-				    BPKT_ATTRVEC_FLAGS_RMAP_IPV4_NH_CHANGED)
-			 || CHECK_FLAG(
-				 vec->flags,
-				 BPKT_ATTRVEC_FLAGS_RMAP_NH_PEER_ADDRESS));
+				    BPKT_ATTRVEC_FLAGS_RMAP_IPV4_NH_CHANGED) ||
+			 CHECK_FLAG(vec->flags,
+				    BPKT_ATTRVEC_FLAGS_RMAP_VPNV4_NH_CHANGED) ||
+			 CHECK_FLAG(vec->flags,
+				    BPKT_ATTRVEC_FLAGS_RMAP_NH_PEER_ADDRESS));
 
 		switch (nhlen) {
 		case BGP_ATTR_NHLEN_IPV4:
@@ -468,10 +469,12 @@ struct stream *bpacket_reformat_for_peer
 
 		route_map_sets_nh =
 			(CHECK_FLAG(vec->flags,
-				    BPKT_ATTRVEC_FLAGS_RMAP_IPV6_GNH_CHANGED)
-			 || CHECK_FLAG(
+				    BPKT_ATTRVEC_FLAGS_RMAP_IPV6_GNH_CHANGED) ||
+			 CHECK_FLAG(
 				 vec->flags,
-				 BPKT_ATTRVEC_FLAGS_RMAP_NH_PEER_ADDRESS));
+				 BPKT_ATTRVEC_FLAGS_RMAP_VPNV6_GNH_CHANGED) ||
+			 CHECK_FLAG(vec->flags,
+				    BPKT_ATTRVEC_FLAGS_RMAP_NH_PEER_ADDRESS));
 
 		/*
 		 * The logic here is rather similar to that for IPv4, the
@@ -752,7 +755,7 @@ struct bpacket *subgroup_update_packet(s
 			 * attr. */
 			total_attr_len = bgp_packet_attribute(
 				NULL, peer, s, adv->baa->attr, &vecarr, NULL,
-				afi, safi, from, NULL, NULL, 0, 0, 0);
+				afi, safi, from, NULL, NULL, 0, 0, 0, path);
 
 			space_remaining =
 				STREAM_CONCAT_REMAIN(s, snlri, STREAM_SIZE(s))
@@ -1069,6 +1072,9 @@ void subgroup_default_update_packet(stru
 	safi_t safi;
 	struct bpacket_attr_vec_arr vecarr;
 	bool addpath_capable = false;
+	uint8_t default_originate_label[4] = {0x80, 0x00, 0x00};
+	mpls_label_t *label = NULL;
+	uint32_t num_labels = 0;
 
 	if (DISABLE_BGP_ANNOUNCE)
 		return;
@@ -1082,6 +1088,11 @@ void subgroup_default_update_packet(stru
 	bpacket_attr_vec_arr_reset(&vecarr);
 	addpath_capable = bgp_addpath_encode_tx(peer, afi, safi);
 
+	if (safi == SAFI_LABELED_UNICAST) {
+		label = (mpls_label_t *)default_originate_label;
+		num_labels = 1;
+	}
+
 	memset(&p, 0, sizeof(p));
 	p.family = afi2family(afi);
 	p.prefixlen = 0;
@@ -1124,8 +1135,9 @@ void subgroup_default_update_packet(stru
 	pos = stream_get_endp(s);
 	stream_putw(s, 0);
 	total_attr_len = bgp_packet_attribute(
-		NULL, peer, s, attr, &vecarr, &p, afi, safi, from, NULL, NULL,
-		0, addpath_capable, BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE);
+		NULL, peer, s, attr, &vecarr, &p, afi, safi, from, NULL, label,
+		num_labels, addpath_capable,
+		BGP_ADDPATH_TX_ID_FOR_DEFAULT_ORIGINATE, NULL);
 
 	/* Set Total Path Attribute Length. */
 	stream_putw_at(s, pos, total_attr_len);
@@ -1275,6 +1287,15 @@ bpacket_vec_arr_inherit_attr_flags(struc
 		SET_FLAG(vecarr->entries[BGP_ATTR_VEC_NH].flags,
 			 BPKT_ATTRVEC_FLAGS_RMAP_IPV6_GNH_CHANGED);
 
+	if (CHECK_FLAG(attr->rmap_change_flags, BATTR_RMAP_VPNV4_NHOP_CHANGED))
+		SET_FLAG(vecarr->entries[BGP_ATTR_VEC_NH].flags,
+			 BPKT_ATTRVEC_FLAGS_RMAP_VPNV4_NH_CHANGED);
+
+	if (CHECK_FLAG(attr->rmap_change_flags,
+		       BATTR_RMAP_VPNV6_GLOBAL_NHOP_CHANGED))
+		SET_FLAG(vecarr->entries[BGP_ATTR_VEC_NH].flags,
+			 BPKT_ATTRVEC_FLAGS_RMAP_VPNV6_GNH_CHANGED);
+
 	if (CHECK_FLAG(attr->rmap_change_flags,
 		       BATTR_RMAP_IPV6_LL_NHOP_CHANGED))
 		SET_FLAG(vecarr->entries[BGP_ATTR_VEC_NH].flags,
diff -urpN frr-frr-8.4.2/bgpd/bgp_vty.c frr-frr-8.5/bgpd/bgp_vty.c
--- frr-frr-8.4.2/bgpd/bgp_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -156,9 +156,7 @@ static struct peer_group *listen_range_e
 					      struct prefix *range, int exact);
 
 static void bgp_show_global_graceful_restart_mode_vty(struct vty *vty,
-						      struct bgp *bgp,
-						      bool use_json,
-						      json_object *json);
+						      struct bgp *bgp);
 
 static int bgp_show_neighbor_graceful_restart_afi_all(struct vty *vty,
 						      enum show_type type,
@@ -298,7 +296,6 @@ static int bgp_srv6_locator_unset(struct
 	struct srv6_locator_chunk *chunk;
 	struct bgp_srv6_function *func;
 	struct bgp *bgp_vrf;
-	struct in6_addr *tovpn_sid;
 
 	/* release chunk notification via ZAPI */
 	ret = bgp_zebra_srv6_manager_release_locator_chunk(
@@ -309,7 +306,7 @@ static int bgp_srv6_locator_unset(struct
 	/* refresh chunks */
 	for (ALL_LIST_ELEMENTS(bgp->srv6_locator_chunks, node, nnode, chunk)) {
 		listnode_delete(bgp->srv6_locator_chunks, chunk);
-		srv6_locator_chunk_free(chunk);
+		srv6_locator_chunk_free(&chunk);
 	}
 
 	/* refresh functions */
@@ -324,16 +321,15 @@ static int bgp_srv6_locator_unset(struct
 			continue;
 
 		/* refresh vpnv4 tovpn_sid */
-		tovpn_sid = bgp_vrf->vpn_policy[AFI_IP].tovpn_sid;
-		if (tovpn_sid)
-			XFREE(MTYPE_BGP_SRV6_SID,
-			      bgp_vrf->vpn_policy[AFI_IP].tovpn_sid);
+		XFREE(MTYPE_BGP_SRV6_SID,
+		      bgp_vrf->vpn_policy[AFI_IP].tovpn_sid);
 
 		/* refresh vpnv6 tovpn_sid */
-		tovpn_sid = bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid;
-		if (tovpn_sid)
-			XFREE(MTYPE_BGP_SRV6_SID,
-			      bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid);
+		XFREE(MTYPE_BGP_SRV6_SID,
+		      bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid);
+
+		/* refresh per-vrf tovpn_sid */
+		XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->tovpn_sid);
 	}
 
 	/* update vpn bgp processes */
@@ -345,12 +341,15 @@ static int bgp_srv6_locator_unset(struct
 			continue;
 
 		/* refresh vpnv4 tovpn_sid_locator */
-		XFREE(MTYPE_BGP_SRV6_SID,
-		      bgp_vrf->vpn_policy[AFI_IP].tovpn_sid_locator);
+		srv6_locator_chunk_free(
+			&bgp_vrf->vpn_policy[AFI_IP].tovpn_sid_locator);
 
 		/* refresh vpnv6 tovpn_sid_locator */
-		XFREE(MTYPE_BGP_SRV6_SID,
-		      bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid_locator);
+		srv6_locator_chunk_free(
+			&bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid_locator);
+
+		/* refresh per-vrf tovpn_sid_locator */
+		srv6_locator_chunk_free(&bgp_vrf->tovpn_sid_locator);
 	}
 
 	/* clear locator name */
@@ -818,6 +817,9 @@ struct peer *peer_and_group_lookup_vty(s
 
 	if (peer) {
 		if (peer_dynamic_neighbor(peer)) {
+			zlog_warn(
+				"%pBP: Operation not allowed on a dynamic neighbor",
+				peer);
 			vty_out(vty,
 				"%% Operation not allowed on a dynamic neighbor\n");
 			return NULL;
@@ -829,6 +831,8 @@ struct peer *peer_and_group_lookup_vty(s
 	if (group)
 		return group->conf;
 
+	zlog_warn("Specify remote-as or peer-group commands first before: %s",
+		  vty->buf);
 	vty_out(vty, "%% Specify remote-as or peer-group commands first\n");
 
 	return NULL;
@@ -873,9 +877,6 @@ int bgp_vty_return(struct vty *vty, enum
 	case BGP_ERR_REMOVE_PRIVATE_AS:
 		str = "remove-private-AS cannot be configured for IBGP peers";
 		break;
-	case BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP:
-		str = "Local-AS allowed only for EBGP peers";
-		break;
 	case BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS:
 		str = "Cannot have local-as same as BGP AS number";
 		break;
@@ -936,9 +937,6 @@ int bgp_vty_return(struct vty *vty, enum
 	case BGP_ERR_AF_UNCONFIGURED:
 		str = "AFI/SAFI specified is not currently configured.";
 		break;
-	case BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS:
-		str = "AS specified for local as is the same as the remote as and this is not allowed.";
-		break;
 	case BGP_ERR_INVALID_AS:
 		str = "Confederation AS specified is the same AS as our AS.";
 		break;
@@ -1308,9 +1306,50 @@ void bgp_clear_soft_in(struct bgp *bgp,
 	bgp_clear(NULL, bgp, afi, safi, clear_all, BGP_CLEAR_SOFT_IN, NULL);
 }
 
-#ifndef VTYSH_EXTRACT_PL
+static int peer_flag_modify_vty(struct vty *vty, const char *ip_str,
+				uint64_t flag, int set)
+{
+	int ret;
+	struct peer *peer;
+
+	peer = peer_and_group_lookup_vty(vty, ip_str);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	/*
+	 * If 'neighbor <interface>', then this is for directly connected peers,
+	 * we should not accept disable-connected-check.
+	 */
+	if (peer->conf_if && (flag == PEER_FLAG_DISABLE_CONNECTED_CHECK)) {
+		vty_out(vty,
+			"%s is directly connected peer, cannot accept disable-connected-check\n",
+			ip_str);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (!set && flag == PEER_FLAG_SHUTDOWN)
+		peer_tx_shutdown_message_unset(peer);
+
+	if (set)
+		ret = peer_flag_set(peer, flag);
+	else
+		ret = peer_flag_unset(peer, flag);
+
+	return bgp_vty_return(vty, ret);
+}
+
+static int peer_flag_set_vty(struct vty *vty, const char *ip_str, uint64_t flag)
+{
+	return peer_flag_modify_vty(vty, ip_str, flag, 1);
+}
+
+static int peer_flag_unset_vty(struct vty *vty, const char *ip_str,
+			       uint64_t flag)
+{
+	return peer_flag_modify_vty(vty, ip_str, flag, 0);
+}
+
 #include "bgpd/bgp_vty_clippy.c"
-#endif
 
 DEFUN_HIDDEN (bgp_local_mac,
               bgp_local_mac_cmd,
@@ -1919,13 +1958,6 @@ DEFUN (bgp_confederation_peers,
 
 	for (i = idx_asn; i < argc; i++) {
 		as = strtoul(argv[i]->arg, NULL, 10);
-
-		if (bgp->as == as) {
-			vty_out(vty,
-				"%% Local member-AS not allowed in confed peer list\n");
-			continue;
-		}
-
 		bgp_confederation_peers_add(bgp, as);
 	}
 	return CMD_SUCCESS;
@@ -2354,6 +2386,15 @@ void bgp_config_write_coalesce_time(stru
 		vty_out(vty, " coalesce-time %u\n", bgp->coalesce_time);
 }
 
+/* BGP TCP keepalive */
+static void bgp_config_tcp_keepalive(struct vty *vty, struct bgp *bgp)
+{
+	if (bgp->tcp_keepalive_idle) {
+		vty_out(vty, " bgp tcp-keepalive %u %u %u\n",
+			bgp->tcp_keepalive_idle, bgp->tcp_keepalive_intvl,
+			bgp->tcp_keepalive_probes);
+	}
+}
 
 DEFUN (bgp_coalesce_time,
        bgp_coalesce_time_cmd,
@@ -2577,6 +2618,38 @@ DEFUN(no_bgp_minimum_holdtime, no_bgp_mi
 	return CMD_SUCCESS;
 }
 
+DEFPY(bgp_tcp_keepalive, bgp_tcp_keepalive_cmd,
+      "bgp tcp-keepalive (1-65535)$idle (1-65535)$intvl (1-30)$probes",
+      BGP_STR
+      "TCP keepalive parameters\n"
+      "TCP keepalive idle time (seconds)\n"
+      "TCP keepalive interval (seconds)\n"
+      "TCP keepalive maximum probes\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+
+	bgp_tcp_keepalive_set(bgp, (uint16_t)idle, (uint16_t)intvl,
+			      (uint16_t)probes);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(no_bgp_tcp_keepalive, no_bgp_tcp_keepalive_cmd,
+      "no bgp tcp-keepalive [(1-65535) (1-65535) (1-30)]",
+      NO_STR
+      BGP_STR
+      "TCP keepalive parameters\n"
+      "TCP keepalive idle time (seconds)\n"
+      "TCP keepalive interval (seconds)\n"
+      "TCP keepalive maximum probes\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+
+	bgp_tcp_keepalive_unset(bgp);
+
+	return CMD_SUCCESS;
+}
+
 DEFUN (bgp_client_to_client_reflection,
        bgp_client_to_client_reflection_cmd,
        "bgp client-to-client reflection",
@@ -3287,6 +3360,42 @@ DEFUN (no_bgp_neighbor_graceful_restart_
 	return bgp_vty_return(vty, ret);
 }
 
+DEFPY (neighbor_graceful_shutdown,
+       neighbor_graceful_shutdown_cmd,
+       "[no$no] neighbor <A.B.C.D|X:X::X:X|WORD>$neighbor graceful-shutdown",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Graceful shutdown\n")
+{
+	afi_t afi;
+	safi_t safi;
+	struct peer *peer;
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+	int ret;
+
+	peer = peer_and_group_lookup_vty(vty, neighbor);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (no)
+		ret = peer_flag_unset_vty(vty, neighbor,
+					  PEER_FLAG_GRACEFUL_SHUTDOWN);
+	else
+		ret = peer_flag_set_vty(vty, neighbor,
+					PEER_FLAG_GRACEFUL_SHUTDOWN);
+
+	FOREACH_AFI_SAFI (afi, safi) {
+		if (!peer->afc[afi][safi])
+			continue;
+
+		bgp_clear(vty, bgp, afi, safi, clear_peer, BGP_CLEAR_SOFT_IN,
+			  neighbor);
+	}
+
+	return ret;
+}
+
 DEFUN_HIDDEN (bgp_graceful_restart_disable_eor,
               bgp_graceful_restart_disable_eor_cmd,
               "bgp graceful-restart disable-eor",
@@ -3355,7 +3464,7 @@ DEFUN (no_bgp_graceful_restart_rib_stale
 }
 
 DEFUN(bgp_llgr_stalepath_time, bgp_llgr_stalepath_time_cmd,
-      "bgp long-lived-graceful-restart stale-time (1-4294967295)",
+      "bgp long-lived-graceful-restart stale-time (1-16777215)",
       BGP_STR
       "Enable Long-lived Graceful Restart\n"
       "Specifies maximum time to wait before purging long-lived stale routes\n"
@@ -3372,7 +3481,7 @@ DEFUN(bgp_llgr_stalepath_time, bgp_llgr_
 }
 
 DEFUN(no_bgp_llgr_stalepath_time, no_bgp_llgr_stalepath_time_cmd,
-      "no bgp long-lived-graceful-restart stale-time [(1-4294967295)]",
+      "no bgp long-lived-graceful-restart stale-time [(1-16777215)]",
       NO_STR BGP_STR
       "Enable Long-lived Graceful Restart\n"
       "Specifies maximum time to wait before purging long-lived stale routes\n"
@@ -3526,6 +3635,26 @@ DEFUN (no_bgp_fast_external_failover,
 	return CMD_SUCCESS;
 }
 
+DEFPY (bgp_bestpath_aigp,
+       bgp_bestpath_aigp_cmd,
+       "[no$no] bgp bestpath aigp",
+       NO_STR
+       BGP_STR
+       "Change the default bestpath selection\n"
+       "Evaluate the AIGP attribute during the best path selection process\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+
+	if (no)
+		UNSET_FLAG(bgp->flags, BGP_FLAG_COMPARE_AIGP);
+	else
+		SET_FLAG(bgp->flags, BGP_FLAG_COMPARE_AIGP);
+
+	bgp_recalculate_all_bestpaths(bgp);
+
+	return CMD_SUCCESS;
+}
+
 /* "bgp bestpath compare-routerid" configuration.  */
 DEFUN (bgp_bestpath_compare_router_id,
        bgp_bestpath_compare_router_id_cmd,
@@ -4547,7 +4676,7 @@ static int peer_conf_interface_get(struc
 			ret = peer_remote_as(bgp, NULL, conf_if, &as, as_type);
 	} else {
 		peer = peer_create(NULL, conf_if, bgp, bgp->as, as, as_type,
-				   NULL);
+				   NULL, true);
 
 		if (!peer) {
 			vty_out(vty, "%% BGP failed to create peer\n");
@@ -5192,49 +5321,6 @@ ALIAS_HIDDEN(no_neighbor_set_peer_group,
 	     "Member of the peer-group\n"
 	     "Peer-group name\n")
 
-static int peer_flag_modify_vty(struct vty *vty, const char *ip_str,
-				uint64_t flag, int set)
-{
-	int ret;
-	struct peer *peer;
-
-	peer = peer_and_group_lookup_vty(vty, ip_str);
-	if (!peer)
-		return CMD_WARNING_CONFIG_FAILED;
-
-	/*
-	 * If 'neighbor <interface>', then this is for directly connected peers,
-	 * we should not accept disable-connected-check.
-	 */
-	if (peer->conf_if && (flag == PEER_FLAG_DISABLE_CONNECTED_CHECK)) {
-		vty_out(vty,
-			"%s is directly connected peer, cannot accept disable-connected-check\n",
-			ip_str);
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-
-	if (!set && flag == PEER_FLAG_SHUTDOWN)
-		peer_tx_shutdown_message_unset(peer);
-
-	if (set)
-		ret = peer_flag_set(peer, flag);
-	else
-		ret = peer_flag_unset(peer, flag);
-
-	return bgp_vty_return(vty, ret);
-}
-
-static int peer_flag_set_vty(struct vty *vty, const char *ip_str, uint64_t flag)
-{
-	return peer_flag_modify_vty(vty, ip_str, flag, 1);
-}
-
-static int peer_flag_unset_vty(struct vty *vty, const char *ip_str,
-			       uint64_t flag)
-{
-	return peer_flag_modify_vty(vty, ip_str, flag, 0);
-}
-
 /* neighbor passive. */
 DEFUN (neighbor_passive,
        neighbor_passive_cmd,
@@ -5469,7 +5555,7 @@ DEFUN (no_neighbor_capability_enhe,
 }
 
 static int peer_af_flag_modify_vty(struct vty *vty, const char *peer_str,
-				   afi_t afi, safi_t safi, uint32_t flag,
+				   afi_t afi, safi_t safi, uint64_t flag,
 				   int set)
 {
 	int ret;
@@ -5488,13 +5574,13 @@ static int peer_af_flag_modify_vty(struc
 }
 
 static int peer_af_flag_set_vty(struct vty *vty, const char *peer_str,
-				afi_t afi, safi_t safi, uint32_t flag)
+				afi_t afi, safi_t safi, uint64_t flag)
 {
 	return peer_af_flag_modify_vty(vty, peer_str, afi, safi, flag, 1);
 }
 
 static int peer_af_flag_unset_vty(struct vty *vty, const char *peer_str,
-				  afi_t afi, safi_t safi, uint32_t flag)
+				  afi_t afi, safi_t safi, uint64_t flag)
 {
 	return peer_af_flag_modify_vty(vty, peer_str, afi, safi, flag, 0);
 }
@@ -5773,7 +5859,7 @@ ALIAS_HIDDEN(neighbor_remove_private_as_
 	     "neighbor <A.B.C.D|X:X::X:X|WORD> remove-private-AS all",
 	     NEIGHBOR_STR NEIGHBOR_ADDR_STR2
 	     "Remove private ASNs in outbound updates\n"
-	     "Apply to all AS numbers")
+	     "Apply to all AS numbers\n")
 
 DEFUN (neighbor_remove_private_as_replace_as,
        neighbor_remove_private_as_replace_as_cmd,
@@ -6469,6 +6555,26 @@ DEFUN (no_neighbor_ebgp_multihop,
 	return peer_ebgp_multihop_unset_vty(vty, argv[idx_peer]->arg);
 }
 
+DEFPY (neighbor_aigp,
+       neighbor_aigp_cmd,
+       "[no$no] neighbor <A.B.C.D|X:X::X:X|WORD>$neighbor aigp",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Enable send and receive of the AIGP attribute per neighbor\n")
+{
+	struct peer *peer;
+
+	peer = peer_and_group_lookup_vty(vty, neighbor);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (no)
+		return peer_flag_unset_vty(vty, neighbor, PEER_FLAG_AIGP);
+	else
+		return peer_flag_set_vty(vty, neighbor, PEER_FLAG_AIGP);
+}
+
 static uint8_t get_role_by_name(const char *role_str)
 {
 	if (strncmp(role_str, "peer", 2) == 0)
@@ -8247,6 +8353,32 @@ ALIAS_HIDDEN(
 	"Only give warning message when limit is exceeded\n"
 	"Force checking all received routes not only accepted\n")
 
+/* "neighbor accept-own" */
+DEFPY (neighbor_accept_own,
+       neighbor_accept_own_cmd,
+       "[no$no] neighbor <A.B.C.D|X:X::X:X|WORD>$neighbor accept-own",
+       NO_STR
+       NEIGHBOR_STR
+       NEIGHBOR_ADDR_STR2
+       "Enable handling of self-originated VPN routes containing ACCEPT_OWN community\n")
+{
+	struct peer *peer;
+	afi_t afi = bgp_node_afi(vty);
+	safi_t safi = bgp_node_safi(vty);
+	int ret;
+
+	peer = peer_and_group_lookup_vty(vty, neighbor);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	if (no)
+		ret = peer_af_flag_unset(peer, afi, safi, PEER_FLAG_ACCEPT_OWN);
+	else
+		ret = peer_af_flag_set(peer, afi, safi, PEER_FLAG_ACCEPT_OWN);
+
+	return bgp_vty_return(vty, ret);
+}
+
 /* "neighbor soo" */
 DEFPY (neighbor_soo,
        neighbor_soo_cmd,
@@ -8634,6 +8766,59 @@ DEFPY(
 	return CMD_SUCCESS;
 }
 
+DEFPY(neighbor_path_attribute_discard,
+      neighbor_path_attribute_discard_cmd,
+      "neighbor <A.B.C.D|X:X::X:X|WORD>$neighbor path-attribute discard (1-255)...",
+      NEIGHBOR_STR
+      NEIGHBOR_ADDR_STR2
+      "Manipulate path attributes from incoming UPDATE messages\n"
+      "Drop specified attributes from incoming UPDATE messages\n"
+      "Attribute number\n")
+{
+	struct peer *peer;
+	int idx = 0;
+	const char *discard_attrs = NULL;
+
+	peer = peer_and_group_lookup_vty(vty, neighbor);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	argv_find(argv, argc, "(1-255)", &idx);
+	if (idx)
+		discard_attrs = argv_concat(argv, argc, idx);
+
+	bgp_path_attribute_discard_vty(vty, peer, discard_attrs, true);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(no_neighbor_path_attribute_discard,
+      no_neighbor_path_attribute_discard_cmd,
+      "no neighbor <A.B.C.D|X:X::X:X|WORD>$neighbor path-attribute discard [(1-255)]",
+      NO_STR
+      NEIGHBOR_STR
+      NEIGHBOR_ADDR_STR2
+      "Manipulate path attributes from incoming UPDATE messages\n"
+      "Drop specified attributes from incoming UPDATE messages\n"
+      "Attribute number\n")
+{
+	struct peer *peer;
+	int idx = 0;
+	const char *discard_attrs = NULL;
+
+	peer = peer_and_group_lookup_vty(vty, neighbor);
+	if (!peer)
+		return CMD_WARNING_CONFIG_FAILED;
+
+	argv_find(argv, argc, "(1-255)", &idx);
+	if (idx)
+		discard_attrs = argv[idx]->arg;
+
+	bgp_path_attribute_discard_vty(vty, peer, discard_attrs, false);
+
+	return CMD_SUCCESS;
+}
+
 static int set_ecom_list(struct vty *vty, int argc, struct cmd_token **argv,
 			 struct ecommunity **list, bool is_rt6)
 {
@@ -8860,7 +9045,7 @@ DEFPY (af_label_vpn_export,
 
 DEFPY (af_sid_vpn_export,
        af_sid_vpn_export_cmd,
-       "[no] sid vpn export <(1-255)$sid_idx|auto$sid_auto>",
+       "[no] sid vpn export <(1-1048575)$sid_idx|auto$sid_auto>",
        NO_STR
        "sid value for VRF\n"
        "Between current address-family and vpn\n"
@@ -8889,6 +9074,14 @@ DEFPY (af_sid_vpn_export,
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (bgp->tovpn_sid_index != 0 ||
+	    CHECK_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO)) {
+		vty_out(vty,
+			"per-vrf sid and per-af sid are mutually exclusive\n"
+			"Failed: per-vrf sid is configured. Remove per-vrf sid before configuring per-af sid\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
 	/* skip when it's already configured */
 	if ((sid_idx != 0 && bgp->vpn_policy[afi].tovpn_sid_index != 0)
 	    || (sid_auto && CHECK_FLAG(bgp->vpn_policy[afi].flags,
@@ -8930,6 +9123,92 @@ DEFPY (af_sid_vpn_export,
 	return CMD_SUCCESS;
 }
 
+DEFPY (bgp_sid_vpn_export,
+       bgp_sid_vpn_export_cmd,
+       "[no] sid vpn per-vrf export <(1-1048575)$sid_idx|auto$sid_auto>",
+       NO_STR
+       "sid value for VRF\n"
+       "Between current vrf and vpn\n"
+       "sid per-VRF (both IPv4 and IPv6 address families)\n"
+       "For routes leaked from current vrf to vpn\n"
+       "Sid allocation index\n"
+       "Automatically assign a label\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+	int debug;
+
+	debug = (BGP_DEBUG(vpn, VPN_LEAK_TO_VRF) |
+		 BGP_DEBUG(vpn, VPN_LEAK_FROM_VRF));
+
+	if (no) {
+		/* when per-VRF SID is not set, do nothing */
+		if (bgp->tovpn_sid_index == 0 &&
+		    !CHECK_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO))
+			return CMD_SUCCESS;
+
+		sid_idx = 0;
+		sid_auto = false;
+		bgp->tovpn_sid_index = 0;
+		UNSET_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO);
+	}
+
+	if (bgp->vpn_policy[AFI_IP].tovpn_sid_index != 0 ||
+	    CHECK_FLAG(bgp->vpn_policy[AFI_IP].flags,
+		       BGP_VPN_POLICY_TOVPN_SID_AUTO) ||
+	    bgp->vpn_policy[AFI_IP6].tovpn_sid_index != 0 ||
+	    CHECK_FLAG(bgp->vpn_policy[AFI_IP6].flags,
+		       BGP_VPN_POLICY_TOVPN_SID_AUTO)) {
+		vty_out(vty,
+			"per-vrf sid and per-af sid are mutually exclusive\n"
+			"Failed: per-af sid is configured. Remove per-af sid before configuring per-vrf sid\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	/* skip when it's already configured */
+	if ((sid_idx != 0 && bgp->tovpn_sid_index != 0) ||
+	    (sid_auto && CHECK_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO)))
+		return CMD_SUCCESS;
+
+	/*
+	 * mode change between sid_idx and sid_auto isn't supported.
+	 * user must negate sid vpn export when they want to change the mode
+	 */
+	if ((sid_auto && bgp->tovpn_sid_index != 0) ||
+	    (sid_idx != 0 &&
+	     CHECK_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO))) {
+		vty_out(vty, "it's already configured as %s.\n",
+			sid_auto ? "auto-mode" : "idx-mode");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	/* pre-change */
+	vpn_leak_prechange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP, bgp_get_default(),
+			   bgp);
+	vpn_leak_prechange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP6, bgp_get_default(),
+			   bgp);
+
+	if (sid_auto) {
+		/* SID allocation auto-mode */
+		if (debug)
+			zlog_debug("%s: auto per-vrf sid alloc.", __func__);
+		SET_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO);
+	} else if (sid_idx != 0) {
+		/* SID allocation index-mode */
+		if (debug)
+			zlog_debug("%s: idx %ld per-vrf sid alloc.", __func__,
+				   sid_idx);
+		bgp->tovpn_sid_index = sid_idx;
+	}
+
+	/* post-change */
+	vpn_leak_postchange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP, bgp_get_default(),
+			    bgp);
+	vpn_leak_postchange(BGP_VPN_POLICY_DIR_TOVPN, AFI_IP6,
+			    bgp_get_default(), bgp);
+
+	return CMD_SUCCESS;
+}
+
 ALIAS (af_label_vpn_export,
        af_no_label_vpn_export_cmd,
        "no label vpn export",
@@ -8938,6 +9217,15 @@ ALIAS (af_label_vpn_export,
        "Between current address-family and vpn\n"
        "For routes leaked from current address-family to vpn\n")
 
+ALIAS (bgp_sid_vpn_export,
+       no_bgp_sid_vpn_export_cmd,
+       "no$no sid vpn per-vrf export",
+       NO_STR
+       "sid value for VRF\n"
+       "Between current vrf and vpn\n"
+       "sid per-VRF (both IPv4 and IPv6 address families)\n"
+       "For routes leaked from current vrf to vpn\n")
+
 DEFPY (af_nexthop_vpn_export,
        af_nexthop_vpn_export_cmd,
        "[no] nexthop vpn export [<A.B.C.D|X:X::X:X>$nexthop_su]",
@@ -9637,11 +9925,6 @@ DEFPY (show_bgp_srv6,
 	struct listnode *node;
 	struct srv6_locator_chunk *chunk;
 	struct bgp_srv6_function *func;
-	struct in6_addr *tovpn4_sid;
-	struct in6_addr *tovpn6_sid;
-	char buf[256];
-	char buf_tovpn4_sid[256];
-	char buf_tovpn6_sid[256];
 
 	bgp = bgp_get_default();
 	if (!bgp)
@@ -9649,13 +9932,18 @@ DEFPY (show_bgp_srv6,
 
 	vty_out(vty, "locator_name: %s\n", bgp->srv6_locator_name);
 	vty_out(vty, "locator_chunks:\n");
-	for (ALL_LIST_ELEMENTS_RO(bgp->srv6_locator_chunks, node, chunk))
+	for (ALL_LIST_ELEMENTS_RO(bgp->srv6_locator_chunks, node, chunk)) {
 		vty_out(vty, "- %pFX\n", &chunk->prefix);
+		vty_out(vty, "  block-length: %d\n", chunk->block_bits_length);
+		vty_out(vty, "  node-length: %d\n", chunk->node_bits_length);
+		vty_out(vty, "  func-length: %d\n",
+			chunk->function_bits_length);
+		vty_out(vty, "  arg-length: %d\n", chunk->argument_bits_length);
+	}
 
 	vty_out(vty, "functions:\n");
 	for (ALL_LIST_ELEMENTS_RO(bgp->srv6_functions, node, func)) {
-		inet_ntop(AF_INET6, &func->sid, buf, sizeof(buf));
-		vty_out(vty, "- sid: %s\n", buf);
+		vty_out(vty, "- sid: %pI6\n", &func->sid);
 		vty_out(vty, "  locator: %s\n", func->locator_name);
 	}
 
@@ -9664,19 +9952,11 @@ DEFPY (show_bgp_srv6,
 		vty_out(vty, "- name: %s\n",
 			bgp->name ? bgp->name : "default");
 
-		tovpn4_sid = bgp->vpn_policy[AFI_IP].tovpn_sid;
-		tovpn6_sid = bgp->vpn_policy[AFI_IP6].tovpn_sid;
-		if (tovpn4_sid)
-			inet_ntop(AF_INET6, tovpn4_sid, buf_tovpn4_sid,
-				  sizeof(buf_tovpn4_sid));
-		if (tovpn6_sid)
-			inet_ntop(AF_INET6, tovpn6_sid, buf_tovpn6_sid,
-				  sizeof(buf_tovpn6_sid));
-
-		vty_out(vty, "  vpn_policy[AFI_IP].tovpn_sid: %s\n",
-			tovpn4_sid ? buf_tovpn4_sid : "none");
-		vty_out(vty, "  vpn_policy[AFI_IP6].tovpn_sid: %s\n",
-			tovpn6_sid ? buf_tovpn6_sid : "none");
+		vty_out(vty, "  vpn_policy[AFI_IP].tovpn_sid: %pI6\n",
+			bgp->vpn_policy[AFI_IP].tovpn_sid);
+		vty_out(vty, "  vpn_policy[AFI_IP6].tovpn_sid: %pI6\n",
+			bgp->vpn_policy[AFI_IP6].tovpn_sid);
+		vty_out(vty, "  per-vrf tovpn_sid: %pI6\n", bgp->tovpn_sid);
 	}
 
 	return CMD_SUCCESS;
@@ -9999,35 +10279,158 @@ DEFUN (show_bgp_views,
 	return CMD_SUCCESS;
 }
 
-DEFUN (show_bgp_vrfs,
+static inline void calc_peers_cfgd_estbd(struct bgp *bgp, int *peers_cfgd,
+					 int *peers_estbd)
+{
+	struct peer *peer;
+	struct listnode *node;
+
+	*peers_cfgd = *peers_estbd = 0;
+	for (ALL_LIST_ELEMENTS_RO(bgp->peer, node, peer)) {
+		if (!CHECK_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE))
+			continue;
+		(*peers_cfgd)++;
+		if (peer_established(peer))
+			(*peers_estbd)++;
+	}
+}
+
+static void print_bgp_vrfs(struct bgp *bgp, struct vty *vty, json_object *json,
+			   const char *type)
+{
+	int peers_cfg, peers_estb;
+
+	calc_peers_cfgd_estbd(bgp, &peers_cfg, &peers_estb);
+
+	if (json) {
+		int64_t vrf_id_ui = (bgp->vrf_id == VRF_UNKNOWN)
+					    ? -1
+					    : (int64_t)bgp->vrf_id;
+		json_object_string_add(json, "type", type);
+		json_object_int_add(json, "vrfId", vrf_id_ui);
+		json_object_string_addf(json, "routerId", "%pI4",
+					&bgp->router_id);
+		json_object_int_add(json, "numConfiguredPeers", peers_cfg);
+		json_object_int_add(json, "numEstablishedPeers", peers_estb);
+		json_object_int_add(json, "l3vni", bgp->l3vni);
+		json_object_string_addf(json, "rmac", "%pEA", &bgp->rmac);
+		json_object_string_add(
+			json, "interface",
+			ifindex2ifname(bgp->l3vni_svi_ifindex, bgp->vrf_id));
+	}
+}
+
+static int show_bgp_vrfs_detail_common(struct vty *vty, struct bgp *bgp,
+				       json_object *json, const char *name,
+				       const char *type, bool use_vrf)
+{
+	int peers_cfg, peers_estb;
+
+	calc_peers_cfgd_estbd(bgp, &peers_cfg, &peers_estb);
+
+	if (use_vrf) {
+		if (json) {
+			print_bgp_vrfs(bgp, vty, json, type);
+		} else {
+			vty_out(vty, "BGP instance %s VRF id %d\n",
+				bgp->name_pretty,
+				bgp->vrf_id == VRF_UNKNOWN ? -1
+							   : (int)bgp->vrf_id);
+			vty_out(vty, "Router Id %pI4\n", &bgp->router_id);
+			vty_out(vty,
+				"Num Configured Peers %d, Established %d\n",
+				peers_cfg, peers_estb);
+			if (bgp->l3vni) {
+				vty_out(vty,
+					"L3VNI %u, L3VNI-SVI %s, Router MAC %pEA\n",
+					bgp->l3vni,
+					ifindex2ifname(bgp->l3vni_svi_ifindex,
+						       bgp->vrf_id),
+					&bgp->rmac);
+			}
+		}
+	} else {
+		if (json) {
+			print_bgp_vrfs(bgp, vty, json, type);
+		} else {
+			vty_out(vty, "%4s  %-5d  %-16pI4  %-9u  %-10u  %-37s\n",
+				type,
+				bgp->vrf_id == VRF_UNKNOWN ? -1
+							   : (int)bgp->vrf_id,
+				&bgp->router_id, peers_cfg, peers_estb, name);
+			vty_out(vty, "%11s  %-16u  %-21pEA  %-20s\n", " ",
+				bgp->l3vni, &bgp->rmac,
+				ifindex2ifname(bgp->l3vni_svi_ifindex,
+					       bgp->vrf_id));
+		}
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (show_bgp_vrfs,
        show_bgp_vrfs_cmd,
-       "show [ip] bgp vrfs [json]",
+       "show [ip] bgp vrfs [<VRFNAME$vrf_name>] [json]",
        SHOW_STR
        IP_STR
        BGP_STR
        "Show BGP VRFs\n"
+       "Specific VRF name\n"
        JSON_STR)
 {
-	char buf[ETHER_ADDR_STRLEN];
 	struct list *inst = bm->bgp;
 	struct listnode *node;
 	struct bgp *bgp;
 	bool uj = use_json(argc, argv);
 	json_object *json = NULL;
 	json_object *json_vrfs = NULL;
+	json_object *json_vrf = NULL;
 	int count = 0;
+	const char *name = vrf_name;
+	const char *type;
 
-	if (uj) {
+	if (uj)
 		json = json_object_new_object();
-		json_vrfs = json_object_new_object();
+
+	if (name) {
+		if (strmatch(name, VRF_DEFAULT_NAME)) {
+			bgp = bgp_get_default();
+			type = "DFLT";
+		} else {
+			bgp = bgp_lookup_by_name(name);
+			type = "VRF";
+		}
+		if (!bgp) {
+			if (uj)
+				vty_json(vty, json);
+			else
+				vty_out(vty,
+					"%% Specified BGP instance not found\n");
+
+			return CMD_WARNING;
+		}
 	}
 
+	if (vrf_name) {
+		if (uj)
+			json_vrf = json_object_new_object();
+
+		show_bgp_vrfs_detail_common(vty, bgp, json_vrf, name, type,
+					    true);
+
+		if (uj) {
+			json_object_object_add(json, name, json_vrf);
+			vty_json(vty, json);
+		}
+
+		return CMD_SUCCESS;
+	}
+
+	if (uj)
+		json_vrfs = json_object_new_object();
+
 	for (ALL_LIST_ELEMENTS_RO(inst, node, bgp)) {
-		const char *name, *type;
-		struct peer *peer;
-		struct listnode *node2, *nnode2;
-		int peers_cfg, peers_estb;
-		json_object *json_vrf = NULL;
+		const char *name;
 
 		/* Skip Views. */
 		if (bgp->inst_type == BGP_INSTANCE_TYPE_VIEW)
@@ -10042,20 +10445,9 @@ DEFUN (show_bgp_vrfs,
 			vty_out(vty, "%11s  %-16s  %-21s  %-6s\n", " ",
 				"L3-VNI", "RouterMAC", "Interface");
 		}
-
-		peers_cfg = peers_estb = 0;
 		if (uj)
 			json_vrf = json_object_new_object();
 
-
-		for (ALL_LIST_ELEMENTS(bgp->peer, node2, nnode2, peer)) {
-			if (!CHECK_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE))
-				continue;
-			peers_cfg++;
-			if (peer_established(peer))
-				peers_estb++;
-		}
-
 		if (bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT) {
 			name = VRF_DEFAULT_NAME;
 			type = "DFLT";
@@ -10064,49 +10456,16 @@ DEFUN (show_bgp_vrfs,
 			type = "VRF";
 		}
 
+		show_bgp_vrfs_detail_common(vty, bgp, json_vrf, name, type,
+					    false);
 
-		if (uj) {
-			int64_t vrf_id_ui = (bgp->vrf_id == VRF_UNKNOWN)
-						    ? -1
-						    : (int64_t)bgp->vrf_id;
-			char buf[BUFSIZ] = {0};
-
-			json_object_string_add(json_vrf, "type", type);
-			json_object_int_add(json_vrf, "vrfId", vrf_id_ui);
-			json_object_string_addf(json_vrf, "routerId", "%pI4",
-						&bgp->router_id);
-			json_object_int_add(json_vrf, "numConfiguredPeers",
-					    peers_cfg);
-			json_object_int_add(json_vrf, "numEstablishedPeers",
-					    peers_estb);
-
-			json_object_int_add(json_vrf, "l3vni", bgp->l3vni);
-			json_object_string_add(
-				json_vrf, "rmac",
-				prefix_mac2str(&bgp->rmac, buf, sizeof(buf)));
-			json_object_string_add(json_vrf, "interface",
-				ifindex2ifname(bgp->l3vni_svi_ifindex,
-					       bgp->vrf_id));
+		if (uj)
 			json_object_object_add(json_vrfs, name, json_vrf);
-		} else {
-			vty_out(vty, "%4s  %-5d  %-16pI4  %-9u  %-10u  %-37s\n",
-				type,
-				bgp->vrf_id == VRF_UNKNOWN ? -1
-							   : (int)bgp->vrf_id,
-				&bgp->router_id, peers_cfg, peers_estb, name);
-			vty_out(vty,"%11s  %-16u  %-21s  %-20s\n", " ",
-				bgp->l3vni,
-				prefix_mac2str(&bgp->rmac, buf, sizeof(buf)),
-				ifindex2ifname(bgp->l3vni_svi_ifindex,
-					       bgp->vrf_id));
-		}
 	}
 
 	if (uj) {
 		json_object_object_add(json, "vrfs", json_vrfs);
-
 		json_object_int_add(json, "totalVrfs", count);
-
 		vty_json(vty, json);
 	} else {
 		if (count)
@@ -11590,7 +11949,6 @@ static void bgp_show_peer_afi_orf_cap(st
 
 static void bgp_show_neighnor_graceful_restart_flags(struct vty *vty,
 						     struct peer *p,
-						     bool use_json,
 						     json_object *json)
 {
 	bool rbit = false;
@@ -11603,7 +11961,7 @@ static void bgp_show_neighnor_graceful_r
 		nbit = CHECK_FLAG(p->cap, PEER_CAP_GRACEFUL_RESTART_N_BIT_RCV);
 	}
 
-	if (use_json) {
+	if (json) {
 		json_object_boolean_add(json, "rBit", rbit);
 		json_object_boolean_add(json, "nBit", nbit);
 	} else {
@@ -11614,12 +11972,11 @@ static void bgp_show_neighnor_graceful_r
 
 static void bgp_show_neighbor_graceful_restart_remote_mode(struct vty *vty,
 							   struct peer *peer,
-							   bool use_json,
 							   json_object *json)
 {
 	const char *mode = "NotApplicable";
 
-	if (!use_json)
+	if (!json)
 		vty_out(vty, "\n    Remote GR Mode: ");
 
 	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_ADV)
@@ -11642,20 +11999,19 @@ static void bgp_show_neighbor_graceful_r
 		}
 	}
 
-	if (use_json) {
+	if (json)
 		json_object_string_add(json, "remoteGrMode", mode);
-	} else
-		vty_out(vty, mode, "\n");
+	else
+		vty_out(vty, "%s\n", mode);
 }
 
 static void bgp_show_neighbor_graceful_restart_local_mode(struct vty *vty,
 							  struct peer *p,
-							  bool use_json,
 							  json_object *json)
 {
 	const char *mode = "Invalid";
 
-	if (!use_json)
+	if (!json)
 		vty_out(vty, "    Local GR Mode: ");
 
 	if (bgp_peer_gr_mode_get(p) == PEER_HELPER)
@@ -11675,15 +12031,14 @@ static void bgp_show_neighbor_graceful_r
 			mode = "Invalid*";
 	}
 
-	if (use_json) {
+	if (json)
 		json_object_string_add(json, "localGrMode", mode);
-	} else {
-		vty_out(vty, mode, "\n");
-	}
+	else
+		vty_out(vty, "%s\n", mode);
 }
 
 static void bgp_show_neighbor_graceful_restart_capability_per_afi_safi(
-	struct vty *vty, struct peer *peer, bool use_json, json_object *json)
+	struct vty *vty, struct peer *peer, json_object *json)
 {
 	afi_t afi;
 	safi_t safi;
@@ -11700,7 +12055,7 @@ static void bgp_show_neighbor_graceful_r
 		    !CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV))
 			continue;
 
-		if (use_json) {
+		if (json) {
 			json_afi_safi = json_object_new_object();
 			json_endofrib_status = json_object_new_object();
 			json_timer = json_object_new_object();
@@ -11711,7 +12066,7 @@ static void bgp_show_neighbor_graceful_r
 		else
 			eor_flag = false;
 
-		if (!use_json) {
+		if (!json) {
 			vty_out(vty, "    %s:\n",
 				get_afi_safi_str(afi, safi, false));
 
@@ -11722,25 +12077,25 @@ static void bgp_show_neighbor_graceful_r
 		    CHECK_FLAG(peer->af_cap[afi][safi],
 			       PEER_CAP_RESTART_AF_PRESERVE_RCV)) {
 
-			if (use_json) {
+			if (json) {
 				json_object_boolean_true_add(json_afi_safi,
 							     "fBit");
 			} else
 				vty_out(vty, "True\n");
 		} else {
-			if (use_json)
+			if (json)
 				json_object_boolean_false_add(json_afi_safi,
 							      "fBit");
 			else
 				vty_out(vty, "False\n");
 		}
 
-		if (!use_json)
+		if (!json)
 			vty_out(vty, "      End-of-RIB sent: ");
 
 		if (CHECK_FLAG(peer->af_sflags[afi][safi],
 			       PEER_STATUS_EOR_SEND)) {
-			if (use_json) {
+			if (json) {
 				json_object_boolean_true_add(
 					json_endofrib_status, "endOfRibSend");
 
@@ -11753,7 +12108,7 @@ static void bgp_show_neighbor_graceful_r
 				PRINT_EOR(eor_flag);
 			}
 		} else {
-			if (use_json) {
+			if (json) {
 				json_object_boolean_false_add(
 					json_endofrib_status, "endOfRibSend");
 				json_object_boolean_false_add(
@@ -11767,25 +12122,25 @@ static void bgp_show_neighbor_graceful_r
 			}
 		}
 
-		if (!use_json)
+		if (!json)
 			vty_out(vty, "      End-of-RIB received: ");
 
 		if (CHECK_FLAG(peer->af_sflags[afi][safi],
 			       PEER_STATUS_EOR_RECEIVED)) {
-			if (use_json)
+			if (json)
 				json_object_boolean_true_add(
 					json_endofrib_status, "endOfRibRecv");
 			else
 				vty_out(vty, "Yes\n");
 		} else {
-			if (use_json)
+			if (json)
 				json_object_boolean_false_add(
 					json_endofrib_status, "endOfRibRecv");
 			else
 				vty_out(vty, "No\n");
 		}
 
-		if (use_json) {
+		if (json) {
 			json_object_int_add(json_timer, "stalePathTimer",
 					    peer->bgp->stalepath_time);
 
@@ -11845,7 +12200,7 @@ static void bgp_show_neighbor_graceful_r
 						peer->bgp->gr_info[afi][safi]
 							.t_select_deferral));
 		}
-		if (use_json) {
+		if (json) {
 			json_object_object_add(json_afi_safi, "endOfRibStatus",
 					       json_endofrib_status);
 			json_object_object_add(json_afi_safi, "timers",
@@ -11859,10 +12214,9 @@ static void bgp_show_neighbor_graceful_r
 
 static void bgp_show_neighbor_graceful_restart_time(struct vty *vty,
 						    struct peer *p,
-						    bool use_json,
 						    json_object *json)
 {
-	if (use_json) {
+	if (json) {
 		json_object *json_timer = NULL;
 
 		json_timer = json_object_new_object();
@@ -11898,7 +12252,7 @@ static void bgp_show_neighbor_graceful_r
 }
 
 static void bgp_show_peer_gr_status(struct vty *vty, struct peer *p,
-				    bool use_json, json_object *json)
+				    json_object *json)
 {
 	char dn_flag[2] = {0};
 	/* '*' + v6 address of neighbor */
@@ -11908,7 +12262,7 @@ static void bgp_show_peer_gr_status(stru
 		dn_flag[0] = '*';
 
 	if (p->conf_if) {
-		if (use_json)
+		if (json)
 			json_object_string_addf(json, "neighborAddr", "%pSU",
 						&p->su);
 		else
@@ -11918,7 +12272,7 @@ static void bgp_show_peer_gr_status(stru
 		snprintf(neighborAddr, sizeof(neighborAddr), "%s%s", dn_flag,
 			 p->host);
 
-		if (use_json)
+		if (json)
 			json_object_string_add(json, "neighborAddr",
 					       neighborAddr);
 		else
@@ -11926,7 +12280,7 @@ static void bgp_show_peer_gr_status(stru
 	}
 
 	/* more gr info in new format */
-	BGP_SHOW_PEER_GR_CAPABILITY(vty, p, use_json, json);
+	BGP_SHOW_PEER_GR_CAPABILITY(vty, p, json);
 }
 
 static void bgp_show_peer_afi(struct vty *vty, struct peer *p, afi_t afi,
@@ -12073,6 +12427,16 @@ static void bgp_show_peer_afi(struct vty
 				json_addr,
 				"privateAsNumsRemovedInUpdatesToNbr");
 
+		if (CHECK_FLAG(p->af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN)) {
+			if (CHECK_FLAG(p->af_flags[afi][safi],
+				       PEER_FLAG_ALLOWAS_IN_ORIGIN))
+				json_object_boolean_true_add(json_addr,
+							     "allowAsInOrigin");
+			else
+				json_object_int_add(json_addr, "allowAsInCount",
+						    p->allowas_in[afi][safi]);
+		}
+
 		if (p->addpath_type[afi][safi] != BGP_ADDPATH_NONE)
 			json_object_boolean_true_add(
 				json_addr,
@@ -12384,6 +12748,17 @@ static void bgp_show_peer_afi(struct vty
 			vty_out(vty,
 				"  Private AS numbers removed in updates to this neighbor\n");
 
+		if (CHECK_FLAG(p->af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN)) {
+			if (CHECK_FLAG(p->af_flags[afi][safi],
+				       PEER_FLAG_ALLOWAS_IN_ORIGIN))
+				vty_out(vty,
+					"  Local AS allowed as path origin\n");
+			else
+				vty_out(vty,
+					"  Local AS allowed in path, %d occurrences\n",
+					p->allowas_in[afi][safi]);
+		}
+
 		if (p->addpath_type[afi][safi] != BGP_ADDPATH_NONE)
 			vty_out(vty, "  %s\n",
 				bgp_addpath_names(p->addpath_type[afi][safi])
@@ -12583,7 +12958,6 @@ static void bgp_show_peer(struct vty *vt
 			  json_object *json)
 {
 	struct bgp *bgp;
-	char buf1[PREFIX2STR_BUFFER];
 	char timebuf[BGP_UPTIME_LEN];
 	char dn_flag[2];
 	afi_t afi;
@@ -12712,9 +13086,8 @@ static void bgp_show_peer(struct vty *vt
 
 	if (p->hostname) {
 		if (use_json) {
-			if (p->hostname)
-				json_object_string_add(json_neigh, "hostname",
-						       p->hostname);
+			json_object_string_add(json_neigh, "hostname",
+					       p->hostname);
 
 			if (p->domainname)
 				json_object_string_add(json_neigh, "domainname",
@@ -12726,6 +13099,10 @@ static void bgp_show_peer(struct vty *vt
 			else
 				vty_out(vty, "Hostname: %s\n", p->hostname);
 		}
+	} else {
+		if (use_json)
+			json_object_string_add(json_neigh, "hostname",
+					       "Unknown");
 	}
 
 	/* Peer-group */
@@ -12907,11 +13284,8 @@ static void bgp_show_peer(struct vty *vt
 
 		/* BGP Version. */
 		vty_out(vty, "  BGP version 4");
-		vty_out(vty, ", remote router ID %s",
-			inet_ntop(AF_INET, &p->remote_id, buf1, sizeof(buf1)));
-		vty_out(vty, ", local router ID %s\n",
-			inet_ntop(AF_INET, &bgp->router_id, buf1,
-					sizeof(buf1)));
+		vty_out(vty, ", remote router ID %pI4", &p->remote_id);
+		vty_out(vty, ", local router ID %pI4\n", &bgp->router_id);
 
 		/* Confederation */
 		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
@@ -13886,7 +14260,7 @@ static void bgp_show_peer(struct vty *vt
 				thread_timer_remain_second(p->t_gr_stale) *
 					1000);
 		/* more gr info in new format */
-		BGP_SHOW_PEER_GR_CAPABILITY(vty, p, use_json, json_grace);
+		BGP_SHOW_PEER_GR_CAPABILITY(vty, p, json_grace);
 		json_object_object_add(json_neigh, "gracefulRestartInfo",
 				       json_grace);
 	} else {
@@ -13932,7 +14306,7 @@ static void bgp_show_peer(struct vty *vt
 				thread_timer_remain_second(p->t_gr_stale));
 
 		/* more gr info in new format */
-		BGP_SHOW_PEER_GR_CAPABILITY(vty, p, use_json, NULL);
+		BGP_SHOW_PEER_GR_CAPABILITY(vty, p, NULL);
 	}
 
 	if (use_json) {
@@ -14281,28 +14655,44 @@ static void bgp_show_peer(struct vty *vt
 						       "bgpConnection",
 						       "nonSharedNetwork");
 		} else {
-			vty_out(vty, "Nexthop: %s\n",
-				inet_ntop(AF_INET, &p->nexthop.v4, buf1,
-					  sizeof(buf1)));
-			vty_out(vty, "Nexthop global: %s\n",
-				inet_ntop(AF_INET6, &p->nexthop.v6_global, buf1,
-					  sizeof(buf1)));
-			vty_out(vty, "Nexthop local: %s\n",
-				inet_ntop(AF_INET6, &p->nexthop.v6_local, buf1,
-					  sizeof(buf1)));
+			vty_out(vty, "Nexthop: %pI4\n", &p->nexthop.v4);
+			vty_out(vty, "Nexthop global: %pI6\n",
+				&p->nexthop.v6_global);
+			vty_out(vty, "Nexthop local: %pI6\n",
+				&p->nexthop.v6_local);
 			vty_out(vty, "BGP connection: %s\n",
 				p->shared_network ? "shared network"
 						  : "non shared network");
 		}
+	} else {
+		if (use_json) {
+			json_object_string_add(json_neigh, "nexthop",
+					       "Unknown");
+			json_object_string_add(json_neigh, "nexthopGlobal",
+					       "Unknown");
+			json_object_string_add(json_neigh, "nexthopLocal",
+					       "Unknown");
+			json_object_string_add(json_neigh, "bgpConnection",
+					       "Unknown");
+		}
 	}
 
 	/* Timer information. */
 	if (use_json) {
 		json_object_int_add(json_neigh, "connectRetryTimer",
 				    p->v_connect);
-		if (peer_established(p) && p->rtt)
+		if (peer_established(p)) {
 			json_object_int_add(json_neigh, "estimatedRttInMsecs",
 					    p->rtt);
+			if (CHECK_FLAG(p->flags, PEER_FLAG_RTT_SHUTDOWN)) {
+				json_object_int_add(json_neigh,
+						    "shutdownRttInMsecs",
+						    p->rtt_expected);
+				json_object_int_add(json_neigh,
+						    "shutdownRttAfterCount",
+						    p->rtt_keepalive_rcv);
+			}
+		}
 		if (p->t_start)
 			json_object_int_add(
 				json_neigh, "nextStartTimerDueInMsecs",
@@ -14337,9 +14727,14 @@ static void bgp_show_peer(struct vty *vt
 	} else {
 		vty_out(vty, "BGP Connect Retry Timer in Seconds: %d\n",
 			p->v_connect);
-		if (peer_established(p) && p->rtt)
+		if (peer_established(p)) {
 			vty_out(vty, "Estimated round trip time: %d ms\n",
 				p->rtt);
+			if (CHECK_FLAG(p->flags, PEER_FLAG_RTT_SHUTDOWN))
+				vty_out(vty,
+					"Shutdown when RTT > %dms, count > %u\n",
+					p->rtt_expected, p->rtt_keepalive_rcv);
+		}
 		if (p->t_start)
 			vty_out(vty, "Next start timer due in %ld seconds\n",
 				thread_timer_remain_second(p->t_start));
@@ -14384,20 +14779,14 @@ static int bgp_show_neighbor_graceful_re
 					      enum show_type type,
 					      union sockunion *su,
 					      const char *conf_if, afi_t afi,
-					      bool use_json)
+					      json_object *json)
 {
 	struct listnode *node, *nnode;
 	struct peer *peer;
-	int find = 0;
+	bool found = false;
 	safi_t safi = SAFI_UNICAST;
-	json_object *json = NULL;
 	json_object *json_neighbor = NULL;
 
-	if (use_json) {
-		json = json_object_new_object();
-		json_neighbor = json_object_new_object();
-	}
-
 	for (ALL_LIST_ELEMENTS(bgp->peer, node, nnode, peer)) {
 
 		if (!CHECK_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE))
@@ -14406,15 +14795,15 @@ static int bgp_show_neighbor_graceful_re
 		if ((peer->afc[afi][safi]) == 0)
 			continue;
 
+		if (json)
+			json_neighbor = json_object_new_object();
+
 		if (type == show_all) {
-			bgp_show_peer_gr_status(vty, peer, use_json,
-						json_neighbor);
+			bgp_show_peer_gr_status(vty, peer, json_neighbor);
 
-			if (use_json) {
+			if (json)
 				json_object_object_add(json, peer->host,
 						       json_neighbor);
-				json_neighbor = NULL;
-			}
 
 		} else if (type == show_peer) {
 			if (conf_if) {
@@ -14422,43 +14811,39 @@ static int bgp_show_neighbor_graceful_re
 				     && !strcmp(peer->conf_if, conf_if))
 				    || (peer->hostname
 					&& !strcmp(peer->hostname, conf_if))) {
-					find = 1;
+					found = true;
 					bgp_show_peer_gr_status(vty, peer,
-								use_json,
 								json_neighbor);
 				}
 			} else {
 				if (sockunion_same(&peer->su, su)) {
-					find = 1;
+					found = true;
 					bgp_show_peer_gr_status(vty, peer,
-								use_json,
 								json_neighbor);
 				}
 			}
-			if (use_json && find)
-				json_object_object_add(json, peer->host,
-						       json_neighbor);
+			if (json) {
+				if (found)
+					json_object_object_add(json, peer->host,
+							       json_neighbor);
+				else
+					json_object_free(json_neighbor);
+			}
 		}
 
-		if (find) {
-			json_neighbor = NULL;
+		if (found)
 			break;
-		}
 	}
 
-	if (type == show_peer && !find) {
-		if (use_json)
+	if (type == show_peer && !found) {
+		if (json)
 			json_object_boolean_true_add(json, "bgpNoSuchNeighbor");
 		else
 			vty_out(vty, "%% No such neighbor\n");
 	}
-	if (use_json) {
-		if (json_neighbor)
-			json_object_free(json_neighbor);
-		vty_json(vty, json);
-	} else {
+
+	if (!json)
 		vty_out(vty, "\n");
-	}
 
 	return CMD_SUCCESS;
 }
@@ -14571,7 +14956,7 @@ static int bgp_show_neighbor(struct vty
 static void bgp_show_neighbor_graceful_restart_vty(struct vty *vty,
 						   enum show_type type,
 						   const char *ip_str,
-						   afi_t afi, bool use_json)
+						   afi_t afi, json_object *json)
 {
 
 	int ret;
@@ -14583,21 +14968,20 @@ static void bgp_show_neighbor_graceful_r
 	if (!bgp)
 		return;
 
-	if (!use_json)
-		bgp_show_global_graceful_restart_mode_vty(vty, bgp, use_json,
-							  NULL);
+	if (!json)
+		bgp_show_global_graceful_restart_mode_vty(vty, bgp);
 
 	if (ip_str) {
 		ret = str2sockunion(ip_str, &su);
 		if (ret < 0)
-			bgp_show_neighbor_graceful_restart(
-				vty, bgp, type, NULL, ip_str, afi, use_json);
+			bgp_show_neighbor_graceful_restart(vty, bgp, type, NULL,
+							   ip_str, afi, json);
 		else
 			bgp_show_neighbor_graceful_restart(vty, bgp, type, &su,
-							   NULL, afi, use_json);
+							   NULL, afi, json);
 	} else
 		bgp_show_neighbor_graceful_restart(vty, bgp, type, NULL, NULL,
-						   afi, use_json);
+						   afi, json);
 }
 
 static void bgp_show_all_instances_neighbors_vty(struct vty *vty,
@@ -14917,9 +15301,7 @@ DEFUN (show_ip_bgp_lcommunity_info,
 /* Graceful Restart */
 
 static void bgp_show_global_graceful_restart_mode_vty(struct vty *vty,
-						      struct bgp *bgp,
-						      bool use_json,
-						      json_object *json)
+						      struct bgp *bgp)
 {
 
 
@@ -14954,22 +15336,32 @@ static int bgp_show_neighbor_graceful_re
 						      const char *ip_str,
 						      afi_t afi, bool use_json)
 {
+	json_object *json = NULL;
+
+	if (use_json)
+		json = json_object_new_object();
+
 	if ((afi == AFI_MAX) && (ip_str == NULL)) {
 		afi = AFI_IP;
 
 		while ((afi != AFI_L2VPN) && (afi < AFI_MAX)) {
 
 			bgp_show_neighbor_graceful_restart_vty(
-				vty, type, ip_str, afi, use_json);
+				vty, type, ip_str, afi, json);
 			afi++;
 		}
 	} else if (afi != AFI_MAX) {
 		bgp_show_neighbor_graceful_restart_vty(vty, type, ip_str, afi,
-						       use_json);
+						       json);
 	} else {
+		if (json)
+			json_object_free(json);
 		return CMD_ERR_INCOMPLETE;
 	}
 
+	if (json)
+		vty_json(vty, json);
+
 	return CMD_SUCCESS;
 }
 /* Graceful Restart */
@@ -15250,28 +15642,30 @@ DEFUN (show_ip_bgp_route_leak,
 }
 
 static void bgp_show_all_instances_updgrps_vty(struct vty *vty, afi_t afi,
-					       safi_t safi)
+					       safi_t safi, bool uj)
 {
 	struct listnode *node, *nnode;
 	struct bgp *bgp;
 
 	for (ALL_LIST_ELEMENTS(bm->bgp, node, nnode, bgp)) {
-		vty_out(vty, "\nInstance %s:\n",
-			(bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
-				? VRF_DEFAULT_NAME
-				: bgp->name);
-		update_group_show(bgp, afi, safi, vty, 0);
+		if (!uj)
+			vty_out(vty, "\nInstance %s:\n",
+				(bgp->inst_type == BGP_INSTANCE_TYPE_DEFAULT)
+					? VRF_DEFAULT_NAME
+					: bgp->name);
+
+		update_group_show(bgp, afi, safi, vty, 0, uj);
 	}
 }
 
 static int bgp_show_update_groups(struct vty *vty, const char *name, int afi,
-				  int safi, uint64_t subgrp_id)
+				  int safi, uint64_t subgrp_id, bool uj)
 {
 	struct bgp *bgp;
 
 	if (name) {
 		if (strmatch(name, "all")) {
-			bgp_show_all_instances_updgrps_vty(vty, afi, safi);
+			bgp_show_all_instances_updgrps_vty(vty, afi, safi, uj);
 			return CMD_SUCCESS;
 		} else {
 			bgp = bgp_lookup_by_name(name);
@@ -15281,13 +15675,13 @@ static int bgp_show_update_groups(struct
 	}
 
 	if (bgp)
-		update_group_show(bgp, afi, safi, vty, subgrp_id);
+		update_group_show(bgp, afi, safi, vty, subgrp_id, uj);
 	return CMD_SUCCESS;
 }
 
 DEFUN (show_ip_bgp_updgrps,
        show_ip_bgp_updgrps_cmd,
-       "show [ip] bgp [<view|vrf> VIEWVRFNAME] ["BGP_AFI_CMD_STR" ["BGP_SAFI_WITH_LABEL_CMD_STR"]] update-groups [SUBGROUP-ID]",
+       "show [ip] bgp [<view|vrf> VIEWVRFNAME] ["BGP_AFI_CMD_STR" ["BGP_SAFI_WITH_LABEL_CMD_STR"]] update-groups [SUBGROUP-ID] [json]",
        SHOW_STR
        IP_STR
        BGP_STR
@@ -15295,7 +15689,8 @@ DEFUN (show_ip_bgp_updgrps,
        BGP_AFI_HELP_STR
        BGP_SAFI_WITH_LABEL_HELP_STR
        "Detailed info about dynamic update groups\n"
-       "Specific subgroup to display detailed info for\n")
+       "Specific subgroup to display detailed info for\n"
+       JSON_STR)
 {
 	char *vrf = NULL;
 	afi_t afi = AFI_IP6;
@@ -15304,6 +15699,8 @@ DEFUN (show_ip_bgp_updgrps,
 
 	int idx = 0;
 
+	bool uj = use_json(argc, argv);
+
 	/* show [ip] bgp */
 	if (argv_find(argv, argc, "ip", &idx))
 		afi = AFI_IP;
@@ -15325,19 +15722,22 @@ DEFUN (show_ip_bgp_updgrps,
 	if (argv[idx]->type == VARIABLE_TKN)
 		subgrp_id = strtoull(argv[idx]->arg, NULL, 10);
 
-	return (bgp_show_update_groups(vty, vrf, afi, safi, subgrp_id));
+	return (bgp_show_update_groups(vty, vrf, afi, safi, subgrp_id, uj));
 }
 
 DEFUN (show_bgp_instance_all_ipv6_updgrps,
        show_bgp_instance_all_ipv6_updgrps_cmd,
-       "show [ip] bgp <view|vrf> all update-groups",
+       "show [ip] bgp <view|vrf> all update-groups [json]",
        SHOW_STR
        IP_STR
        BGP_STR
        BGP_INSTANCE_ALL_HELP_STR
-       "Detailed info about dynamic update groups\n")
+       "Detailed info about dynamic update groups\n"
+       JSON_STR)
 {
-	bgp_show_all_instances_updgrps_vty(vty, AFI_IP6, SAFI_UNICAST);
+	bool uj = use_json(argc, argv);
+
+	bgp_show_all_instances_updgrps_vty(vty, AFI_IP6, SAFI_UNICAST, uj);
 	return CMD_SUCCESS;
 }
 
@@ -15354,7 +15754,7 @@ DEFUN (show_bgp_l2vpn_evpn_updgrps,
 	char *vrf = NULL;
 	uint64_t subgrp_id = 0;
 
-	bgp_show_update_groups(vty, vrf, AFI_L2VPN, SAFI_EVPN, subgrp_id);
+	bgp_show_update_groups(vty, vrf, AFI_L2VPN, SAFI_EVPN, subgrp_id, 0);
 	return CMD_SUCCESS;
 }
 
@@ -16512,7 +16912,7 @@ static bool peergroup_af_flag_check(stru
 		if (CHECK_FLAG(peer->af_flags_invert[afi][safi], flag))
 			return !peer_af_flag_check(peer, afi, safi, flag);
 		else
-			return !!peer_af_flag_check(peer, afi, safi, flag);
+			return peer_af_flag_check(peer, afi, safi, flag);
 	}
 
 	return !!CHECK_FLAG(peer->af_flags_override[afi][safi], flag);
@@ -16927,6 +17327,14 @@ static void bgp_config_write_peer_global
 		}
 	}
 
+	/* aigp */
+	if (peergroup_flag_check(peer, PEER_FLAG_AIGP))
+		vty_out(vty, " neighbor %s aigp\n", addr);
+
+	/* graceful-shutdown */
+	if (peergroup_flag_check(peer, PEER_FLAG_GRACEFUL_SHUTDOWN))
+		vty_out(vty, " neighbor %s graceful-shutdown\n", addr);
+
 	/* role */
 	if (peergroup_flag_check(peer, PEER_FLAG_ROLE) &&
 	    peer->local_role != ROLE_UNDEFINED)
@@ -17042,6 +17450,15 @@ static void bgp_config_write_peer_global
 		vty_out(vty, " neighbor %s sender-as-path-loop-detection\n",
 			addr);
 
+	/* path-attribute discard */
+	char discard_attrs_str[BUFSIZ] = {0};
+	bool discard_attrs = bgp_path_attribute_discard(
+		peer, discard_attrs_str, sizeof(discard_attrs_str));
+
+	if (discard_attrs)
+		vty_out(vty, " neighbor %s path-attribute discard %s\n", addr,
+			discard_attrs_str);
+
 	if (!CHECK_FLAG(peer->peer_gr_new_status_flag,
 			PEER_GRACEFUL_RESTART_NEW_STATE_INHERIT)) {
 
@@ -17290,6 +17707,10 @@ static void bgp_config_write_peer_af(str
 		}
 	}
 
+	/* accept-own */
+	if (peergroup_af_flag_check(peer, afi, safi, PEER_FLAG_ACCEPT_OWN))
+		vty_out(vty, "  neighbor %s accept-own\n", addr);
+
 	/* soo */
 	if (peergroup_af_flag_check(peer, afi, safi, PEER_FLAG_SOO)) {
 		char *soo_str = ecommunity_ecom2str(
@@ -17457,6 +17878,7 @@ int bgp_config_write(struct vty *vty)
 	struct listnode *mnode, *mnnode;
 	afi_t afi;
 	safi_t safi;
+	uint32_t tovpn_sid_index = 0;
 
 	if (bm->rmap_update_timer != RMAP_DEFAULT_UPDATE_TIMER)
 		vty_out(vty, "bgp route-map delay-timer %u\n",
@@ -17486,6 +17908,13 @@ int bgp_config_write(struct vty *vty)
 	if (bm->tcp_dscp != IPTOS_PREC_INTERNETCONTROL)
 		vty_out(vty, "bgp session-dscp %u\n", bm->tcp_dscp >> 2);
 
+	/* BGP InQ limit */
+	if (bm->inq_limit != BM_DEFAULT_Q_LIMIT)
+		vty_out(vty, "bgp input-queue-limit %u\n", bm->inq_limit);
+
+	if (bm->outq_limit != BM_DEFAULT_Q_LIMIT)
+		vty_out(vty, "bgp output-queue-limit %u\n", bm->outq_limit);
+
 	/* BGP configuration. */
 	for (ALL_LIST_ELEMENTS(bm->bgp, mnode, mnnode, bgp)) {
 
@@ -17717,6 +18146,9 @@ int bgp_config_write(struct vty *vty)
 			vty_out(vty,
 				" bgp graceful-restart preserve-fw-state\n");
 
+		/* BGP TCP keepalive */
+		bgp_config_tcp_keepalive(vty, bgp);
+
 		/* Stale timer for RIB */
 		if (bgp->rib_stale_time != BGP_DEFAULT_RIB_STALE_TIME)
 			vty_out(vty,
@@ -17746,6 +18178,8 @@ int bgp_config_write(struct vty *vty)
 		}
 		if (CHECK_FLAG(bgp->flags, BGP_FLAG_COMPARE_ROUTER_ID))
 			vty_out(vty, " bgp bestpath compare-routerid\n");
+		if (CHECK_FLAG(bgp->flags, BGP_FLAG_COMPARE_AIGP))
+			vty_out(vty, " bgp bestpath aigp\n");
 		if (CHECK_FLAG(bgp->flags, BGP_FLAG_MED_CONFED)
 		    || CHECK_FLAG(bgp->flags, BGP_FLAG_MED_MISSING_AS_WORST)) {
 			vty_out(vty, " bgp bestpath med");
@@ -17838,6 +18272,13 @@ int bgp_config_write(struct vty *vty)
 			vty_endframe(vty, " exit\n");
 		}
 
+		tovpn_sid_index = bgp->tovpn_sid_index;
+		if (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_TOVPN_SID_AUTO)) {
+			vty_out(vty, " sid vpn per-vrf export auto\n");
+		} else if (tovpn_sid_index != 0) {
+			vty_out(vty, " sid vpn per-vrf export %d\n",
+				tovpn_sid_index);
+		}
 
 		/* IPv4 unicast configuration.  */
 		bgp_config_write_family(vty, bgp, AFI_IP, SAFI_UNICAST);
@@ -18188,6 +18629,57 @@ DEFPY(mpls_bgp_forwarding, mpls_bgp_forw
 	return CMD_SUCCESS;
 }
 
+DEFPY (bgp_inq_limit,
+       bgp_inq_limit_cmd,
+       "bgp input-queue-limit (1-4294967295)$limit",
+       BGP_STR
+       "Set the BGP Input Queue limit for all peers when message parsing\n"
+       "Input-Queue limit\n")
+{
+	bm->inq_limit = limit;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (no_bgp_inq_limit,
+       no_bgp_inq_limit_cmd,
+       "no bgp input-queue-limit [(1-4294967295)$limit]",
+       NO_STR
+       BGP_STR
+       "Set the BGP Input Queue limit for all peers when message parsing\n"
+       "Input-Queue limit\n")
+{
+	bm->inq_limit = BM_DEFAULT_Q_LIMIT;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (bgp_outq_limit,
+       bgp_outq_limit_cmd,
+       "bgp output-queue-limit (1-4294967295)$limit",
+       BGP_STR
+       "Set the BGP Output Queue limit for all peers when message parsing\n"
+       "Output-Queue limit\n")
+{
+	bm->outq_limit = limit;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (no_bgp_outq_limit,
+       no_bgp_outq_limit_cmd,
+       "no bgp output-queue-limit [(1-4294967295)$limit]",
+       NO_STR
+       BGP_STR
+       "Set the BGP Output Queue limit for all peers when message parsing\n"
+       "Output-Queue limit\n")
+{
+	bm->outq_limit = BM_DEFAULT_Q_LIMIT;
+
+	return CMD_SUCCESS;
+}
+
+
 /* Initialization of BGP interface. */
 static void bgp_vty_if_init(void)
 {
@@ -18237,6 +18729,12 @@ void bgp_vty_init(void)
 	install_default(BGP_EVPN_VNI_NODE);
 	install_default(BGP_SRV6_NODE);
 
+	/* "global bgp inq-limit command */
+	install_element(CONFIG_NODE, &bgp_inq_limit_cmd);
+	install_element(CONFIG_NODE, &no_bgp_inq_limit_cmd);
+	install_element(CONFIG_NODE, &bgp_outq_limit_cmd);
+	install_element(CONFIG_NODE, &no_bgp_outq_limit_cmd);
+
 	/* "bgp local-mac" hidden commands. */
 	install_element(CONFIG_NODE, &bgp_local_mac_cmd);
 	install_element(CONFIG_NODE, &no_bgp_local_mac_cmd);
@@ -18313,6 +18811,12 @@ void bgp_vty_init(void)
 	install_element(BGP_NODE, &neighbor_role_strict_cmd);
 	install_element(BGP_NODE, &no_neighbor_role_cmd);
 
+	/* "neighbor aigp" commands. */
+	install_element(BGP_NODE, &neighbor_aigp_cmd);
+
+	/* "neighbor graceful-shutdown" command */
+	install_element(BGP_NODE, &neighbor_graceful_shutdown_cmd);
+
 	/* bgp disable-ebgp-connected-nh-check */
 	install_element(BGP_NODE, &bgp_disable_connected_route_check_cmd);
 	install_element(BGP_NODE, &no_bgp_disable_connected_route_check_cmd);
@@ -18447,6 +18951,9 @@ void bgp_vty_init(void)
 	install_element(BGP_NODE, &bgp_fast_external_failover_cmd);
 	install_element(BGP_NODE, &no_bgp_fast_external_failover_cmd);
 
+	/* "bgp bestpath aigp" commands */
+	install_element(BGP_NODE, &bgp_bestpath_aigp_cmd);
+
 	/* "bgp bestpath compare-routerid" commands */
 	install_element(BGP_NODE, &bgp_bestpath_compare_router_id_cmd);
 	install_element(BGP_NODE, &no_bgp_bestpath_compare_router_id_cmd);
@@ -19059,6 +19566,10 @@ void bgp_vty_init(void)
 	install_element(BGP_NODE, &neighbor_aspath_loop_detection_cmd);
 	install_element(BGP_NODE, &no_neighbor_aspath_loop_detection_cmd);
 
+	/* "neighbor path-attribute discard" commands. */
+	install_element(BGP_NODE, &neighbor_path_attribute_discard_cmd);
+	install_element(BGP_NODE, &no_neighbor_path_attribute_discard_cmd);
+
 	/* "neighbor passive" commands. */
 	install_element(BGP_NODE, &neighbor_passive_cmd);
 	install_element(BGP_NODE, &no_neighbor_passive_cmd);
@@ -19461,6 +19972,10 @@ void bgp_vty_init(void)
 	install_element(BGP_EVPN_NODE, &neighbor_allowas_in_cmd);
 	install_element(BGP_EVPN_NODE, &no_neighbor_allowas_in_cmd);
 
+	/* neighbor accept-own */
+	install_element(BGP_VPNV4_NODE, &neighbor_accept_own_cmd);
+	install_element(BGP_VPNV6_NODE, &neighbor_accept_own_cmd);
+
 	/* "neighbor soo" */
 	install_element(BGP_IPV4_NODE, &neighbor_soo_cmd);
 	install_element(BGP_IPV4_NODE, &no_neighbor_soo_cmd);
@@ -19596,6 +20111,10 @@ void bgp_vty_init(void)
 	install_element(BGP_NODE, &neighbor_ttl_security_cmd);
 	install_element(BGP_NODE, &no_neighbor_ttl_security_cmd);
 
+	/* "bgp tcp-keepalive" commands */
+	install_element(BGP_NODE, &bgp_tcp_keepalive_cmd);
+	install_element(BGP_NODE, &no_bgp_tcp_keepalive_cmd);
+
 	/* "show [ip] bgp memory" commands. */
 	install_element(VIEW_NODE, &show_bgp_memory_cmd);
 
@@ -19655,6 +20174,8 @@ void bgp_vty_init(void)
 	install_element(BGP_SRV6_NODE, &no_bgp_srv6_locator_cmd);
 	install_element(BGP_IPV4_NODE, &af_sid_vpn_export_cmd);
 	install_element(BGP_IPV6_NODE, &af_sid_vpn_export_cmd);
+	install_element(BGP_NODE, &bgp_sid_vpn_export_cmd);
+	install_element(BGP_NODE, &no_bgp_sid_vpn_export_cmd);
 
 	bgp_vty_if_init();
 }
diff -urpN frr-frr-8.4.2/bgpd/bgp_vty.h frr-frr-8.5/bgpd/bgp_vty.h
--- frr-frr-8.4.2/bgpd/bgp_vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -56,18 +56,14 @@ struct bgp;
 	"V         AS    LocalAS   MsgRcvd   MsgSent   TblVer  InQ OutQ  Up/Down State/PfxRcd   PfxSnt Desc\n"
 #define BGP_SHOW_SUMMARY_HEADER_FAILED "EstdCnt DropCnt ResetTime Reason\n"
 
-#define BGP_SHOW_PEER_GR_CAPABILITY(vty, p, use_json, json)                    \
+#define BGP_SHOW_PEER_GR_CAPABILITY(vty, p, json)                              \
 	do {                                                                   \
-		bgp_show_neighbor_graceful_restart_local_mode(vty, p,          \
-							      use_json, json); \
-		bgp_show_neighbor_graceful_restart_remote_mode(                \
-			vty, p, use_json, json);                               \
-		bgp_show_neighnor_graceful_restart_flags(vty, p, use_json,     \
-							 json);                \
-		bgp_show_neighbor_graceful_restart_time(vty, p, use_json,      \
-							json);                 \
+		bgp_show_neighbor_graceful_restart_local_mode(vty, p, json);   \
+		bgp_show_neighbor_graceful_restart_remote_mode(vty, p, json);  \
+		bgp_show_neighnor_graceful_restart_flags(vty, p, json);        \
+		bgp_show_neighbor_graceful_restart_time(vty, p, json);         \
 		bgp_show_neighbor_graceful_restart_capability_per_afi_safi(    \
-			vty, p, use_json, json);                               \
+			vty, p, json);                                         \
 	} while (0)
 
 #define VTY_BGP_GR_DEFINE_LOOP_VARIABLE                                        \
diff -urpN frr-frr-8.4.2/bgpd/bgp_zebra.c frr-frr-8.5/bgpd/bgp_zebra.c
--- frr-frr-8.4.2/bgpd/bgp_zebra.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgp_zebra.c	2023-03-13 20:01:47.000000000 +0600
@@ -918,7 +918,7 @@ bool bgp_zebra_nexthop_set(union sockuni
 			memcpy(&nexthop->v6_global, &local->sin6.sin6_addr,
 			       IPV6_MAX_BYTELEN);
 
-			/* If directory connected set link-local address. */
+			/* If directly connected set link-local address. */
 			direct = if_lookup_by_ipv6(&remote->sin6.sin6_addr,
 						   remote->sin6.sin6_scope_id,
 						   peer->bgp->vrf_id);
@@ -931,7 +931,7 @@ bool bgp_zebra_nexthop_set(union sockuni
 			 */
 			if (!v6_ll_avail && if_is_loopback(ifp))
 				v6_ll_avail = true;
-			else {
+			else if (!v6_ll_avail) {
 				flog_warn(
 					EC_BGP_NO_LL_ADDRESS_AVAILABLE,
 					"Interface: %s does not have a v6 LL address associated with it, waiting until one is created for it",
@@ -1529,7 +1529,9 @@ void bgp_zebra_announce(struct bgp_dest
 
 		api_nh->weight = nh_weight;
 
-		if (mpinfo->extra && !sid_zero(&mpinfo->extra->sid[0].sid) &&
+		if (mpinfo->extra &&
+		    bgp_is_valid_label(&mpinfo->extra->label[0]) &&
+		    !sid_zero(&mpinfo->extra->sid[0].sid) &&
 		    !CHECK_FLAG(api_nh->flags, ZAPI_NEXTHOP_FLAG_EVPN)) {
 			sid_info = &mpinfo->extra->sid[0];
 
@@ -1537,12 +1539,16 @@ void bgp_zebra_announce(struct bgp_dest
 			       sizeof(api_nh->seg6_segs));
 
 			if (sid_info->transposition_len != 0) {
-				if (!bgp_is_valid_label(
-					    &mpinfo->extra->label[0]))
-					continue;
-
 				mpls_lse_decode(mpinfo->extra->label[0], &label,
 						&ttl, &exp, &bos);
+
+				if (label < MPLS_LABEL_UNRESERVED_MIN) {
+					if (bgp_debug_zebra(&api.prefix))
+						zlog_debug(
+							"skip invalid SRv6 routes: transposition scheme is used, but label is too small");
+					continue;
+				}
+
 				transpose_sid(&api_nh->seg6_segs, label,
 					      sid_info->transposition_offset,
 					      sid_info->transposition_len);
@@ -1623,9 +1629,8 @@ void bgp_zebra_announce(struct bgp_dest
 		zlog_debug(
 			"Tx route %s VRF %u %pFX metric %u tag %" ROUTE_TAG_PRI
 			" count %d nhg %d",
-			valid_nh_count ? "add" : "delete", bgp->vrf_id,
-			&api.prefix, api.metric, api.tag, api.nexthop_num,
-			nhg_id);
+			is_add ? "add" : "delete", bgp->vrf_id, &api.prefix,
+			api.metric, api.tag, api.nexthop_num, nhg_id);
 		for (i = 0; i < api.nexthop_num; i++) {
 			api_nh = &api.nexthops[i];
 
@@ -3216,13 +3221,13 @@ static int bgp_zebra_process_srv6_locato
 	if (strcmp(bgp->srv6_locator_name, chunk->locator_name) != 0) {
 		zlog_err("%s: Locator name unmatch %s:%s", __func__,
 			 bgp->srv6_locator_name, chunk->locator_name);
-		srv6_locator_chunk_free(chunk);
+		srv6_locator_chunk_free(&chunk);
 		return 0;
 	}
 
 	for (ALL_LIST_ELEMENTS_RO(bgp->srv6_locator_chunks, node, c)) {
 		if (!prefix_cmp(&c->prefix, &chunk->prefix)) {
-			srv6_locator_chunk_free(chunk);
+			srv6_locator_chunk_free(&chunk);
 			return 0;
 		}
 	}
@@ -3255,10 +3260,10 @@ static int bgp_zebra_process_srv6_locato
 	struct srv6_locator loc = {};
 	struct bgp *bgp = bgp_get_default();
 	struct listnode *node, *nnode;
-	struct srv6_locator_chunk *chunk;
+	struct srv6_locator_chunk *chunk, *tovpn_sid_locator;
 	struct bgp_srv6_function *func;
 	struct bgp *bgp_vrf;
-	struct in6_addr *tovpn_sid, *tovpn_sid_locator;
+	struct in6_addr *tovpn_sid;
 	struct prefix_ipv6 tmp_prefi;
 
 	if (zapi_srv6_locator_decode(zclient->ibuf, &loc) < 0)
@@ -3269,7 +3274,7 @@ static int bgp_zebra_process_srv6_locato
 		if (prefix_match((struct prefix *)&loc.prefix,
 				 (struct prefix *)&chunk->prefix)) {
 			listnode_delete(bgp->srv6_locator_chunks, chunk);
-			srv6_locator_chunk_free(chunk);
+			srv6_locator_chunk_free(&chunk);
 		}
 
 	// refresh functions
@@ -3312,6 +3317,17 @@ static int bgp_zebra_process_srv6_locato
 				XFREE(MTYPE_BGP_SRV6_SID,
 				      bgp_vrf->vpn_policy[AFI_IP6].tovpn_sid);
 		}
+
+		/* refresh per-vrf tovpn_sid */
+		tovpn_sid = bgp_vrf->tovpn_sid;
+		if (tovpn_sid) {
+			tmp_prefi.family = AF_INET6;
+			tmp_prefi.prefixlen = IPV6_MAX_BITLEN;
+			tmp_prefi.prefix = *tovpn_sid;
+			if (prefix_match((struct prefix *)&loc.prefix,
+					 (struct prefix *)&tmp_prefi))
+				XFREE(MTYPE_BGP_SRV6_SID, bgp_vrf->tovpn_sid);
+		}
 	}
 
 	vpn_leak_postchange_all();
@@ -3327,10 +3343,12 @@ static int bgp_zebra_process_srv6_locato
 		if (tovpn_sid_locator) {
 			tmp_prefi.family = AF_INET6;
 			tmp_prefi.prefixlen = IPV6_MAX_BITLEN;
-			tmp_prefi.prefix = *tovpn_sid_locator;
+			tmp_prefi.prefix = tovpn_sid_locator->prefix.prefix;
 			if (prefix_match((struct prefix *)&loc.prefix,
 					 (struct prefix *)&tmp_prefi))
-				XFREE(MTYPE_BGP_SRV6_SID, tovpn_sid_locator);
+				srv6_locator_chunk_free(
+					&bgp_vrf->vpn_policy[AFI_IP]
+						 .tovpn_sid_locator);
 		}
 
 		/* refresh vpnv6 tovpn_sid_locator */
@@ -3339,10 +3357,24 @@ static int bgp_zebra_process_srv6_locato
 		if (tovpn_sid_locator) {
 			tmp_prefi.family = AF_INET6;
 			tmp_prefi.prefixlen = IPV6_MAX_BITLEN;
-			tmp_prefi.prefix = *tovpn_sid_locator;
+			tmp_prefi.prefix = tovpn_sid_locator->prefix.prefix;
+			if (prefix_match((struct prefix *)&loc.prefix,
+					 (struct prefix *)&tmp_prefi))
+				srv6_locator_chunk_free(
+					&bgp_vrf->vpn_policy[AFI_IP6]
+						 .tovpn_sid_locator);
+		}
+
+		/* refresh per-vrf tovpn_sid_locator */
+		tovpn_sid_locator = bgp_vrf->tovpn_sid_locator;
+		if (tovpn_sid_locator) {
+			tmp_prefi.family = AF_INET6;
+			tmp_prefi.prefixlen = IPV6_MAX_BITLEN;
+			tmp_prefi.prefix = tovpn_sid_locator->prefix.prefix;
 			if (prefix_match((struct prefix *)&loc.prefix,
 					 (struct prefix *)&tmp_prefi))
-				XFREE(MTYPE_BGP_SRV6_SID, tovpn_sid_locator);
+				srv6_locator_chunk_free(
+					&bgp_vrf->tovpn_sid_locator);
 		}
 	}
 
@@ -3651,35 +3683,33 @@ void bgp_zebra_announce_default(struct b
 
 	/* redirect IP */
 	if (afi == AFI_IP && nh->gate.ipv4.s_addr != INADDR_ANY) {
-		char buff[PREFIX_STRLEN];
-
 		api_nh->vrf_id = nh->vrf_id;
 		api_nh->gate.ipv4 = nh->gate.ipv4;
 		api_nh->type = NEXTHOP_TYPE_IPV4;
 
-		inet_ntop(AF_INET, &(nh->gate.ipv4), buff, INET_ADDRSTRLEN);
 		if (BGP_DEBUG(zebra, ZEBRA))
-			zlog_debug("BGP: %s default route to %s table %d (redirect IP)",
-				  announce ? "adding" : "withdrawing",
-				  buff, table_id);
+			zlog_debug(
+				"BGP: %s default route to %pI4 table %d (redirect IP)",
+				announce ? "adding" : "withdrawing",
+				&nh->gate.ipv4, table_id);
+
 		zclient_route_send(announce ? ZEBRA_ROUTE_ADD
 				   : ZEBRA_ROUTE_DELETE,
 				   zclient, &api);
 	} else if (afi == AFI_IP6 &&
 		   memcmp(&nh->gate.ipv6,
 			  &in6addr_any, sizeof(struct in6_addr))) {
-		char buff[PREFIX_STRLEN];
-
 		api_nh->vrf_id = nh->vrf_id;
 		memcpy(&api_nh->gate.ipv6, &nh->gate.ipv6,
 		       sizeof(struct in6_addr));
 		api_nh->type = NEXTHOP_TYPE_IPV6;
 
-		inet_ntop(AF_INET6, &(nh->gate.ipv6), buff, INET_ADDRSTRLEN);
 		if (BGP_DEBUG(zebra, ZEBRA))
-			zlog_debug("BGP: %s default route to %s table %d (redirect IP)",
-				  announce ? "adding" : "withdrawing",
-				  buff, table_id);
+			zlog_debug(
+				"BGP: %s default route to %pI6 table %d (redirect IP)",
+				announce ? "adding" : "withdrawing",
+				&nh->gate.ipv6, table_id);
+
 		zclient_route_send(announce ? ZEBRA_ROUTE_ADD
 				   : ZEBRA_ROUTE_DELETE,
 				   zclient, &api);
diff -urpN frr-frr-8.4.2/bgpd/bgpd.c frr-frr-8.5/bgpd/bgpd.c
--- frr-frr-8.4.2/bgpd/bgpd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgpd.c	2023-03-13 20:01:47.000000000 +0600
@@ -92,6 +92,7 @@
 #include "bgpd/bgp_evpn_private.h"
 #include "bgpd/bgp_evpn_mh.h"
 #include "bgpd/bgp_mac.h"
+#include "bgp_trace.h"
 
 DEFINE_MTYPE_STATIC(BGPD, PEER_TX_SHUTDOWN_MSG, "Peer shutdown message (TX)");
 DEFINE_MTYPE_STATIC(BGPD, BGP_EVPN_INFO, "BGP EVPN instance information");
@@ -551,6 +552,21 @@ void bgp_timers_unset(struct bgp *bgp)
 	bgp->default_delayopen = BGP_DEFAULT_DELAYOPEN;
 }
 
+void bgp_tcp_keepalive_set(struct bgp *bgp, uint16_t keepalive_idle,
+			   uint16_t keepalive_intvl, uint16_t keepalive_probes)
+{
+	bgp->tcp_keepalive_idle = keepalive_idle;
+	bgp->tcp_keepalive_intvl = keepalive_intvl;
+	bgp->tcp_keepalive_probes = keepalive_probes;
+}
+
+void bgp_tcp_keepalive_unset(struct bgp *bgp)
+{
+	bgp->tcp_keepalive_idle = 0;
+	bgp->tcp_keepalive_intvl = 0;
+	bgp->tcp_keepalive_probes = 0;
+}
+
 /* BGP confederation configuration.  */
 void bgp_confederation_id_set(struct bgp *bgp, as_t as)
 {
@@ -655,7 +671,7 @@ void bgp_confederation_peers_add(struct
 	struct peer *peer;
 	struct listnode *node, *nnode;
 
-	if (bgp->as == as)
+	if (!bgp)
 		return;
 
 	if (bgp_confederation_peers_check(bgp, as))
@@ -671,8 +687,8 @@ void bgp_confederation_peers_add(struct
 	if (bgp_config_check(bgp, BGP_CONFIG_CONFEDERATION)) {
 		for (ALL_LIST_ELEMENTS(bgp->peer, node, nnode, peer)) {
 			if (peer->as == as) {
-				(void)peer_sort(peer);
 				peer->local_as = bgp->as;
+				(void)peer_sort(peer);
 				if (BGP_IS_VALID_STATE_FOR_NOTIF(
 					    peer->status)) {
 					peer->last_reset =
@@ -722,8 +738,8 @@ void bgp_confederation_peers_remove(stru
 	if (bgp_config_check(bgp, BGP_CONFIG_CONFEDERATION)) {
 		for (ALL_LIST_ELEMENTS(bgp->peer, node, nnode, peer)) {
 			if (peer->as == as) {
-				(void)peer_sort(peer);
 				peer->local_as = bgp->confed_id;
+				(void)peer_sort(peer);
 				if (BGP_IS_VALID_STATE_FOR_NOTIF(
 					    peer->status)) {
 					peer->last_reset =
@@ -934,6 +950,7 @@ static bool peer_hash_same(const void *p
 {
 	const struct peer *peer1 = p1;
 	const struct peer *peer2 = p2;
+
 	return (sockunion_same(&peer1->su, &peer2->su)
 		&& CHECK_FLAG(peer1->flags, PEER_FLAG_CONFIG_NODE)
 			   == CHECK_FLAG(peer2->flags, PEER_FLAG_CONFIG_NODE));
@@ -963,9 +980,10 @@ void peer_flag_inherit(struct peer *peer
 		COND_FLAG(peer->flags, flag, group_val);
 }
 
-int peer_af_flag_check(struct peer *peer, afi_t afi, safi_t safi, uint32_t flag)
+bool peer_af_flag_check(struct peer *peer, afi_t afi, safi_t safi,
+			uint64_t flag)
 {
-	return CHECK_FLAG(peer->af_flags[afi][safi], flag);
+	return !!CHECK_FLAG(peer->af_flags[afi][safi], flag);
 }
 
 void peer_af_flag_inherit(struct peer *peer, afi_t afi, safi_t safi,
@@ -997,9 +1015,15 @@ void peer_af_flag_inherit(struct peer *p
 static inline enum bgp_peer_sort peer_calc_sort(struct peer *peer)
 {
 	struct bgp *bgp;
+	as_t local_as;
 
 	bgp = peer->bgp;
 
+	if (peer->change_local_as)
+		local_as = peer->change_local_as;
+	else
+		local_as = peer->local_as;
+
 	/* Peer-group */
 	if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
 		if (peer->as_type == AS_INTERNAL)
@@ -1010,8 +1034,8 @@ static inline enum bgp_peer_sort peer_ca
 
 		else if (peer->as_type == AS_SPECIFIED && peer->as) {
 			assert(bgp);
-			return (bgp->as == peer->as ? BGP_PEER_IBGP
-						    : BGP_PEER_EBGP);
+			return (local_as == peer->as ? BGP_PEER_IBGP
+						     : BGP_PEER_EBGP);
 		}
 
 		else {
@@ -1028,17 +1052,17 @@ static inline enum bgp_peer_sort peer_ca
 
 	/* Normal peer */
 	if (bgp && CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {
-		if (peer->local_as == 0)
+		if (local_as == 0)
 			return BGP_PEER_INTERNAL;
 
-		if (peer->local_as == peer->as) {
+		if (local_as == peer->as) {
 			if (bgp->as == bgp->confed_id) {
-				if (peer->local_as == bgp->as)
+				if (local_as == bgp->as)
 					return BGP_PEER_IBGP;
 				else
 					return BGP_PEER_EBGP;
 			} else {
-				if (peer->local_as == bgp->confed_id)
+				if (local_as == bgp->confed_id)
 					return BGP_PEER_EBGP;
 				else
 					return BGP_PEER_IBGP;
@@ -1056,8 +1080,7 @@ static inline enum bgp_peer_sort peer_ca
 			    && (peer->group->conf->as_type != AS_UNSPECIFIED)) {
 				if (peer->group->conf->as_type
 				    == AS_SPECIFIED) {
-					if (peer->local_as
-					    == peer->group->conf->as)
+					if (local_as == peer->group->conf->as)
 						return BGP_PEER_IBGP;
 					else
 						return BGP_PEER_EBGP;
@@ -1073,9 +1096,8 @@ static inline enum bgp_peer_sort peer_ca
 			return (peer->as_type == AS_INTERNAL ? BGP_PEER_IBGP
 							     : BGP_PEER_EBGP);
 
-		return (peer->local_as == 0
-				? BGP_PEER_INTERNAL
-				: peer->local_as == peer->as ? BGP_PEER_IBGP
+		return (local_as == 0 ? BGP_PEER_INTERNAL
+				      : local_as == peer->as ? BGP_PEER_IBGP
 							     : BGP_PEER_EBGP);
 	}
 }
@@ -1107,6 +1129,9 @@ static void peer_free(struct peer *peer)
 	bgp_timer_set(peer);
 	bgp_reads_off(peer);
 	bgp_writes_off(peer);
+	thread_cancel_event_ready(bm->master, peer);
+	FOREACH_AFI_SAFI (afi, safi)
+		THREAD_OFF(peer->t_revalidate_all[afi][safi]);
 	assert(!peer->t_write);
 	assert(!peer->t_read);
 	BGP_EVENT_FLUSH(peer);
@@ -1132,6 +1157,7 @@ static void peer_free(struct peer *peer)
 
 	XFREE(MTYPE_PEER_DESC, peer->desc);
 	XFREE(MTYPE_BGP_PEER_HOST, peer->host);
+	XFREE(MTYPE_BGP_PEER_HOST, peer->hostname);
 	XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);
 	XFREE(MTYPE_BGP_PEER_IFNAME, peer->ifname);
 
@@ -1170,6 +1196,7 @@ static void peer_free(struct peer *peer)
 /* increase reference count on a struct peer */
 struct peer *peer_lock_with_caller(const char *name, struct peer *peer)
 {
+	frrtrace(2, frr_bgp, bgp_peer_lock, peer, name);
 	assert(peer && (peer->lock >= 0));
 
 	peer->lock++;
@@ -1182,6 +1209,7 @@ struct peer *peer_lock_with_caller(const
  */
 struct peer *peer_unlock_with_caller(const char *name, struct peer *peer)
 {
+	frrtrace(2, frr_bgp, bgp_peer_unlock, peer, name);
 	assert(peer && (peer->lock > 0));
 
 	peer->lock--;
@@ -1435,7 +1463,10 @@ void peer_xfer_config(struct peer *peer_
 
 	/* peer flags apply */
 	peer_dst->flags = peer_src->flags;
-
+	/*
+	 * The doppelganger *must* not have a config node stored
+	 */
+	UNSET_FLAG(peer_dst->flags, PEER_FLAG_CONFIG_NODE);
 	peer_dst->peer_gr_present_state = peer_src->peer_gr_present_state;
 	peer_dst->peer_gr_new_status_flag = peer_src->peer_gr_new_status_flag;
 
@@ -1591,15 +1622,18 @@ void bgp_peer_conf_if_to_su_update(struc
 	struct interface *ifp;
 	int prev_family;
 	int peer_addr_updated = 0;
+	struct listnode *node;
+	union sockunion old_su;
 
+	/*
+	 * This function is only ever needed when FRR an interface
+	 * based peering, so this simple test will tell us if
+	 * we are in an interface based configuration or not
+	 */
 	if (!peer->conf_if)
 		return;
 
-	/*
-	 * Our peer structure is stored in the bgp->peerhash
-	 * release it before we modify anything.
-	 */
-	hash_release(peer->bgp->peerhash, peer);
+	old_su = peer->su;
 
 	prev_family = peer->su.sa.sa_family;
 	if ((ifp = if_lookup_by_name(peer->conf_if, peer->bgp->vrf_id))) {
@@ -1642,9 +1676,48 @@ void bgp_peer_conf_if_to_su_update(struc
 	}
 
 	/*
-	 * Since our su changed we need to del/add peer to the peerhash
+	 * If they are the same, nothing to do here, move along
 	 */
-	(void)hash_get(peer->bgp->peerhash, peer, hash_alloc_intern);
+	if (!sockunion_same(&old_su, &peer->su)) {
+		union sockunion new_su = peer->su;
+		struct bgp *bgp = peer->bgp;
+
+		/*
+		 * Our peer structure is stored in the bgp->peerhash
+		 * release it before we modify anything in both the
+		 * hash and the list.  But *only* if the peer
+		 * is in the bgp->peerhash as that on deletion
+		 * we call bgp_stop which calls this function :(
+		 * so on deletion let's remove from the list first
+		 * and then do the deletion preventing this from
+		 * being added back on the list below when we
+		 * fail to remove it up here.
+		 */
+
+		/*
+		 * listnode_lookup just scans the list
+		 * for the peer structure so it's safe
+		 * to use without modifying the su
+		 */
+		node = listnode_lookup(bgp->peer, peer);
+		if (node) {
+			/*
+			 * Let's reset the peer->su release and
+			 * reset it and put it back.  We have to
+			 * do this because hash_release will
+			 * scan through looking for a matching
+			 * su if needed.
+			 */
+			peer->su = old_su;
+			hash_release(peer->bgp->peerhash, peer);
+			listnode_delete(peer->bgp->peer, peer);
+
+			peer->su = new_su;
+			(void)hash_get(peer->bgp->peerhash, peer,
+				       hash_alloc_intern);
+			listnode_add_sort(peer->bgp->peer, peer);
+		}
+	}
 }
 
 void bgp_recalculate_afi_safi_bestpaths(struct bgp *bgp, afi_t afi, safi_t safi)
@@ -1693,7 +1766,8 @@ void bgp_recalculate_all_bestpaths(struc
  */
 struct peer *peer_create(union sockunion *su, const char *conf_if,
 			 struct bgp *bgp, as_t local_as, as_t remote_as,
-			 int as_type, struct peer_group *group)
+			 int as_type, struct peer_group *group,
+			 bool config_node)
 {
 	int active;
 	struct peer *peer;
@@ -1731,6 +1805,10 @@ struct peer *peer_create(union sockunion
 	peer = peer_lock(peer); /* bgp peer list reference */
 	peer->group = group;
 	listnode_add_sort(bgp->peer, peer);
+
+	if (config_node)
+		SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
+
 	(void)hash_get(bgp->peerhash, peer, hash_alloc_intern);
 
 	/* Adjust update-group coalesce timer heuristics for # peers. */
@@ -1758,8 +1836,6 @@ struct peer *peer_create(union sockunion
 	/* Default configured keepalives count for shutdown rtt command */
 	peer->rtt_keepalive_conf = 1;
 
-	SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
-
 	/* If 'bgp default <afi>-<safi>' is configured, then activate the
 	 * neighbor for the corresponding address family. IPv4 Unicast is
 	 * the only address family enabled by default without expliict
@@ -1794,6 +1870,7 @@ struct peer *peer_create_accept(struct b
 
 	peer = peer_lock(peer); /* bgp peer list reference */
 	listnode_add_sort(bgp->peer, peer);
+	(void)hash_get(bgp->peerhash, peer, hash_alloc_intern);
 
 	return peer;
 }
@@ -1885,14 +1962,6 @@ void peer_as_change(struct peer *peer, a
 		UNSET_FLAG(peer->af_flags[AFI_L2VPN][SAFI_EVPN],
 			   PEER_FLAG_REFLECTOR_CLIENT);
 	}
-
-	/* local-as reset */
-	if (newtype != BGP_PEER_EBGP) {
-		peer->change_local_as = 0;
-		peer_flag_unset(peer, PEER_FLAG_LOCAL_AS);
-		peer_flag_unset(peer, PEER_FLAG_LOCAL_AS_NO_PREPEND);
-		peer_flag_unset(peer, PEER_FLAG_LOCAL_AS_REPLACE_AS);
-	}
 }
 
 /* If peer does not exist, create new one.  If peer already exists,
@@ -1959,14 +2028,15 @@ int peer_remote_as(struct bgp *bgp, unio
 
 		/* If the peer is not part of our confederation, and its not an
 		   iBGP peer then spoof the source AS */
-		if (bgp_config_check(bgp, BGP_CONFIG_CONFEDERATION)
-		    && !bgp_confederation_peers_check(bgp, *as)
-		    && bgp->as != *as)
+		if (bgp_config_check(bgp, BGP_CONFIG_CONFEDERATION) &&
+		    !bgp_confederation_peers_check(bgp, *as) && *as &&
+		    bgp->as != *as)
 			local_as = bgp->confed_id;
 		else
 			local_as = bgp->as;
 
-		peer_create(su, conf_if, bgp, local_as, *as, as_type, NULL);
+		peer_create(su, conf_if, bgp, local_as, *as, as_type, NULL,
+			    true);
 	}
 
 	return 0;
@@ -2425,6 +2495,9 @@ int peer_delete(struct peer *peer)
 	bgp_keepalives_off(peer);
 	bgp_reads_off(peer);
 	bgp_writes_off(peer);
+	thread_cancel_event_ready(bm->master, peer);
+	FOREACH_AFI_SAFI (afi, safi)
+		THREAD_OFF(peer->t_revalidate_all[afi][safi]);
 	assert(!CHECK_FLAG(peer->thread_flags, PEER_THREAD_WRITES_ON));
 	assert(!CHECK_FLAG(peer->thread_flags, PEER_THREAD_READS_ON));
 	assert(!CHECK_FLAG(peer->thread_flags, PEER_THREAD_KEEPALIVES_ON));
@@ -2486,9 +2559,16 @@ int peer_delete(struct peer *peer)
 	/* Delete from all peer list. */
 	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)
 	    && (pn = listnode_lookup(bgp->peer, peer))) {
-		peer_unlock(peer); /* bgp peer list reference */
+		/*
+		 * Removing from the list node first because
+		 * peer_unlock *can* call peer_delete( I know,
+		 * I know ).  So let's remove it and in
+		 * the su recalculate function we'll ensure
+		 * it's in there or not.
+		 */
 		list_delete_node(bgp->peer, pn);
 		hash_release(bgp->peerhash, peer);
+		peer_unlock(peer); /* bgp peer list reference */
 	}
 
 	/* Buffers.  */
@@ -2624,8 +2704,9 @@ struct peer_group *peer_group_get(struct
 static void peer_group2peer_config_copy(struct peer_group *group,
 					struct peer *peer)
 {
-	uint32_t flags_tmp;
+	uint64_t flags_tmp;
 	struct peer *conf;
+	bool config_node = !!CHECK_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
 
 	conf = group->conf;
 
@@ -2653,6 +2734,9 @@ static void peer_group2peer_config_copy(
 	SET_FLAG(peer->flags, flags_tmp);
 	SET_FLAG(peer->flags_invert, conf->flags_invert);
 
+	if (config_node)
+		SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
+
 	/* peer timers apply */
 	if (!CHECK_FLAG(peer->flags_override, PEER_FLAG_TIMER)) {
 		PEER_ATTR_INHERIT(peer, group, holdtime);
@@ -3033,17 +3117,6 @@ int peer_group_bind(struct bgp *bgp, uni
 			/* ebgp-multihop reset */
 			if (gtype == BGP_PEER_IBGP)
 				group->conf->ttl = MAXTTL;
-
-			/* local-as reset */
-			if (gtype != BGP_PEER_EBGP) {
-				group->conf->change_local_as = 0;
-				peer_flag_unset(group->conf,
-						PEER_FLAG_LOCAL_AS);
-				peer_flag_unset(group->conf,
-						PEER_FLAG_LOCAL_AS_NO_PREPEND);
-				peer_flag_unset(group->conf,
-						PEER_FLAG_LOCAL_AS_REPLACE_AS);
-			}
 		}
 
 		SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
@@ -3065,7 +3138,7 @@ int peer_group_bind(struct bgp *bgp, uni
 		}
 
 		peer = peer_create(su, NULL, bgp, bgp->as, group->conf->as,
-				   group->conf->as_type, group);
+				   group->conf->as_type, group, true);
 
 		peer = peer_lock(peer); /* group->peer list reference */
 		listnode_add(group->peer, peer);
@@ -3087,8 +3160,6 @@ int peer_group_bind(struct bgp *bgp, uni
 				peer_deactivate(peer, afi, safi);
 		}
 
-		SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
-
 		/* Set up peer's events and timers. */
 		if (peer_active(peer))
 			bgp_timer_set(peer);
@@ -3197,6 +3268,7 @@ static struct bgp *bgp_create(as_t *as,
 	bgp->default_local_pref = BGP_DEFAULT_LOCAL_PREF;
 	bgp->default_subgroup_pkt_queue_max =
 		BGP_DEFAULT_SUBGROUP_PKT_QUEUE_MAX;
+	bgp_tcp_keepalive_unset(bgp);
 	bgp_timers_unset(bgp);
 	bgp->default_min_holdtime = 0;
 	bgp->restart_time = BGP_DEFAULT_RESTART_TIME;
@@ -3498,7 +3570,7 @@ int bgp_get(struct bgp **bgp_val, as_t *
 	if (IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)) {
 		if (BGP_DEBUG(zebra, ZEBRA))
 			zlog_debug("%s: Registering BGP instance %s to zebra",
-				   __func__, name);
+				   __func__, bgp->name_pretty);
 		bgp_zebra_instance_register(bgp);
 	}
 
@@ -3632,6 +3704,9 @@ int bgp_delete(struct bgp *bgp)
 
 	hook_call(bgp_inst_delete, bgp);
 
+	FOREACH_AFI_SAFI (afi, safi)
+		THREAD_OFF(bgp->t_revalidate[afi][safi]);
+
 	THREAD_OFF(bgp->t_condition_check);
 	THREAD_OFF(bgp->t_startup);
 	THREAD_OFF(bgp->t_maxmed_onstartup);
@@ -3707,8 +3782,10 @@ int bgp_delete(struct bgp *bgp)
 	for (ALL_LIST_ELEMENTS(bgp->group, node, next, group))
 		peer_group_delete(group);
 
-	for (ALL_LIST_ELEMENTS(bgp->peer, node, next, peer))
+	while (listcount(bgp->peer)) {
+		peer = listnode_head(bgp->peer);
 		peer_delete(peer);
+	}
 
 	if (bgp->peer_self) {
 		peer_delete(bgp->peer_self);
@@ -3953,7 +4030,7 @@ struct peer *peer_create_bind_dynamic_ne
 
 	/* Create peer first; we've already checked group config is valid. */
 	peer = peer_create(su, NULL, bgp, bgp->as, group->conf->as,
-			   group->conf->as_type, group);
+			   group->conf->as_type, group, true);
 	if (!peer)
 		return NULL;
 
@@ -3982,7 +4059,6 @@ struct peer *peer_create_bind_dynamic_ne
 	/* Mark as dynamic, but also as a "config node" for other things to
 	 * work. */
 	SET_FLAG(peer->flags, PEER_FLAG_DYNAMIC_NEIGHBOR);
-	SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);
 
 	return peer;
 }
@@ -4119,6 +4195,25 @@ static void peer_drop_dynamic_neighbor(s
 			   peer->group->name, dncount);
 }
 
+bool bgp_path_attribute_discard(struct peer *peer, char *buf, size_t size)
+{
+	if (!buf)
+		return false;
+
+	buf[0] = '\0';
+
+	for (unsigned int i = 0; i < BGP_ATTR_MAX; i++) {
+		if (peer->discard_attrs[i])
+			snprintf(buf + strlen(buf), size - strlen(buf), "%s%d",
+				 (strlen(buf) > 0) ? " " : "", i);
+	}
+
+	if (strlen(buf) > 0)
+		return true;
+
+	return false;
+}
+
 /* If peer is configured at least one address family return 1. */
 bool peer_active(struct peer *peer)
 {
@@ -4261,15 +4356,17 @@ static const struct peer_flag_action pee
 	{PEER_FLAG_TIMER_CONNECT, 0, peer_change_none},
 	{PEER_FLAG_TIMER_DELAYOPEN, 0, peer_change_none},
 	{PEER_FLAG_PASSWORD, 0, peer_change_none},
-	{PEER_FLAG_LOCAL_AS, 0, peer_change_none},
-	{PEER_FLAG_LOCAL_AS_NO_PREPEND, 0, peer_change_none},
-	{PEER_FLAG_LOCAL_AS_REPLACE_AS, 0, peer_change_none},
+	{PEER_FLAG_LOCAL_AS, 0, peer_change_reset},
+	{PEER_FLAG_LOCAL_AS_NO_PREPEND, 0, peer_change_reset},
+	{PEER_FLAG_LOCAL_AS_REPLACE_AS, 0, peer_change_reset},
 	{PEER_FLAG_UPDATE_SOURCE, 0, peer_change_none},
 	{PEER_FLAG_DISABLE_LINK_BW_ENCODING_IEEE, 0, peer_change_none},
 	{PEER_FLAG_EXTENDED_OPT_PARAMS, 0, peer_change_reset},
 	{PEER_FLAG_ROLE_STRICT_MODE, 0, peer_change_reset},
 	{PEER_FLAG_ROLE, 0, peer_change_reset},
 	{PEER_FLAG_PORT, 0, peer_change_reset},
+	{PEER_FLAG_AIGP, 0, peer_change_none},
+	{PEER_FLAG_GRACEFUL_SHUTDOWN, 0, peer_change_none},
 	{0, 0, 0}};
 
 static const struct peer_flag_action peer_af_flag_action_list[] = {
@@ -4302,6 +4399,7 @@ static const struct peer_flag_action pee
 	{PEER_FLAG_WEIGHT, 0, peer_change_reset_in},
 	{PEER_FLAG_DISABLE_ADDPATH_RX, 0, peer_change_reset},
 	{PEER_FLAG_SOO, 0, peer_change_reset},
+	{PEER_FLAG_ACCEPT_OWN, 0, peer_change_reset},
 	{0, 0, 0}};
 
 /* Proper action set. */
@@ -4351,7 +4449,7 @@ static int peer_flag_action_set(const st
 	return found;
 }
 
-static void peer_flag_modify_action(struct peer *peer, uint32_t flag)
+static void peer_flag_modify_action(struct peer *peer, uint64_t flag)
 {
 	if (flag == PEER_FLAG_SHUTDOWN) {
 		if (CHECK_FLAG(peer->flags, flag)) {
@@ -5488,8 +5586,8 @@ void peer_tcp_mss_unset(struct peer *pee
  * being used by a peer has changed (AF specific). Automatically
  * initiates inbound or outbound processing as needed.
  */
-static void peer_on_policy_change(struct peer *peer, afi_t afi, safi_t safi,
-				  int outbound)
+void peer_on_policy_change(struct peer *peer, afi_t afi, safi_t safi,
+			   int outbound)
 {
 	if (outbound) {
 		update_group_adjust_peer(peer_af_find(peer, afi, safi));
@@ -5499,11 +5597,11 @@ static void peer_on_policy_change(struct
 		if (!peer_established(peer))
 			return;
 
-		if (CHECK_FLAG(peer->af_flags[afi][safi],
-			       PEER_FLAG_SOFT_RECONFIG)) {
-			bgp_soft_reconfig_in(peer, afi, safi);
-		} else if (CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_OLD_RCV) ||
-			   CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_NEW_RCV)) {
+		if (bgp_soft_reconfig_in(peer, afi, safi))
+			return;
+
+		if (CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_OLD_RCV) ||
+		    CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_NEW_RCV)) {
 			if (CHECK_FLAG(peer->af_cap[afi][safi],
 				       PEER_CAP_ORF_PREFIX_SM_ADV) &&
 			    (CHECK_FLAG(peer->af_cap[afi][safi],
@@ -6121,17 +6219,10 @@ int peer_local_as_set(struct peer *peer,
 	struct bgp *bgp = peer->bgp;
 	struct peer *member;
 	struct listnode *node, *nnode;
-	enum bgp_peer_sort ptype = peer_sort(peer);
-
-	if (ptype != BGP_PEER_EBGP && ptype != BGP_PEER_INTERNAL)
-		return BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP;
 
 	if (bgp->as == as)
 		return BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS;
 
-	if (peer->as == as)
-		return BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS;
-
 	/* Save previous flag states. */
 	old_no_prepend =
 		!!CHECK_FLAG(peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);
@@ -6147,20 +6238,11 @@ int peer_local_as_set(struct peer *peer,
 	    && old_replace_as == replace_as)
 		return 0;
 	peer->change_local_as = as;
+	(void)peer_sort(peer);
 
 	/* Check if handling a regular peer. */
-	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
-		/* Send notification or reset peer depending on state. */
-		if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
-			peer->last_reset = PEER_DOWN_LOCAL_AS_CHANGE;
-			bgp_notify_send(peer, BGP_NOTIFY_CEASE,
-					BGP_NOTIFY_CEASE_CONFIG_CHANGE);
-		} else
-			bgp_session_reset(peer);
-
-		/* Skip peer-group mechanics for regular peers. */
+	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))
 		return 0;
-	}
 
 	/*
 	 * Set flag and configuration on all peer-group members, unless they are
@@ -6189,14 +6271,6 @@ int peer_local_as_set(struct peer *peer,
 		COND_FLAG(member->flags, PEER_FLAG_LOCAL_AS_REPLACE_AS,
 			  replace_as);
 		member->change_local_as = as;
-
-		/* Send notification or stop peer depending on state. */
-		if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status)) {
-			member->last_reset = PEER_DOWN_LOCAL_AS_CHANGE;
-			bgp_notify_send(member, BGP_NOTIFY_CEASE,
-					BGP_NOTIFY_CEASE_CONFIG_CHANGE);
-		} else
-			BGP_EVENT_ADD(member, BGP_Stop);
 	}
 
 	return 0;
@@ -7231,169 +7305,6 @@ int peer_unsuppress_map_unset(struct pee
 	return 0;
 }
 
-static void peer_advertise_map_filter_update(struct peer *peer, afi_t afi,
-					     safi_t safi, const char *amap_name,
-					     struct route_map *amap,
-					     const char *cmap_name,
-					     struct route_map *cmap,
-					     bool condition, bool set)
-{
-	struct bgp_filter *filter;
-	bool filter_exists = false;
-
-	filter = &peer->filter[afi][safi];
-
-	/* advertise-map is already configured. */
-	if (filter->advmap.aname) {
-		filter_exists = true;
-		XFREE(MTYPE_BGP_FILTER_NAME, filter->advmap.aname);
-		XFREE(MTYPE_BGP_FILTER_NAME, filter->advmap.cname);
-	}
-
-	route_map_counter_decrement(filter->advmap.amap);
-
-	/* Removed advertise-map configuration */
-	if (!set) {
-		memset(&filter->advmap, 0, sizeof(filter->advmap));
-
-		/* decrement condition_filter_count delete timer if
-		 * this is the last advertise-map to be removed.
-		 */
-		if (filter_exists)
-			bgp_conditional_adv_disable(peer, afi, safi);
-
-		/* Process peer route updates. */
-		peer_on_policy_change(peer, afi, safi, 1);
-
-		return;
-	}
-
-	/* Update filter data with newly configured values. */
-	filter->advmap.aname = XSTRDUP(MTYPE_BGP_FILTER_NAME, amap_name);
-	filter->advmap.cname = XSTRDUP(MTYPE_BGP_FILTER_NAME, cmap_name);
-	filter->advmap.amap = amap;
-	filter->advmap.cmap = cmap;
-	filter->advmap.condition = condition;
-	route_map_counter_increment(filter->advmap.amap);
-	peer->advmap_config_change[afi][safi] = true;
-
-	/* Increment condition_filter_count and/or create timer. */
-	if (!filter_exists) {
-		filter->advmap.update_type = UPDATE_TYPE_ADVERTISE;
-		bgp_conditional_adv_enable(peer, afi, safi);
-	}
-
-	/* Process peer route updates. */
-	peer_on_policy_change(peer, afi, safi, 1);
-}
-
-/* Set advertise-map to the peer. */
-int peer_advertise_map_set(struct peer *peer, afi_t afi, safi_t safi,
-			   const char *advertise_name,
-			   struct route_map *advertise_map,
-			   const char *condition_name,
-			   struct route_map *condition_map, bool condition)
-{
-	struct peer *member;
-	struct listnode *node, *nnode;
-
-	/* Set configuration on peer. */
-	peer_advertise_map_filter_update(peer, afi, safi, advertise_name,
-					 advertise_map, condition_name,
-					 condition_map, condition, true);
-
-	/* Check if handling a regular peer & Skip peer-group mechanics. */
-	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
-		/* Set override-flag and process peer route updates. */
-		SET_FLAG(peer->filter_override[afi][safi][RMAP_OUT],
-			 PEER_FT_ADVERTISE_MAP);
-		return 0;
-	}
-
-	/*
-	 * Set configuration on all peer-group members, unless they are
-	 * explicitly overriding peer-group configuration.
-	 */
-	for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
-		/* Skip peers with overridden configuration. */
-		if (CHECK_FLAG(member->filter_override[afi][safi][RMAP_OUT],
-			       PEER_FT_ADVERTISE_MAP))
-			continue;
-
-		/* Set configuration on peer-group member. */
-		peer_advertise_map_filter_update(
-			member, afi, safi, advertise_name, advertise_map,
-			condition_name, condition_map, condition, true);
-	}
-
-	return 0;
-}
-
-/* Unset advertise-map from the peer. */
-int peer_advertise_map_unset(struct peer *peer, afi_t afi, safi_t safi,
-			     const char *advertise_name,
-			     struct route_map *advertise_map,
-			     const char *condition_name,
-			     struct route_map *condition_map, bool condition)
-{
-	struct peer *member;
-	struct listnode *node, *nnode;
-
-	/* advertise-map is not configured */
-	if (!peer->filter[afi][safi].advmap.aname)
-		return 0;
-
-	/* Unset override-flag unconditionally. */
-	UNSET_FLAG(peer->filter_override[afi][safi][RMAP_OUT],
-		   PEER_FT_ADVERTISE_MAP);
-
-	/* Inherit configuration from peer-group if peer is member. */
-	if (peer_group_active(peer)) {
-		PEER_STR_ATTR_INHERIT(peer, peer->group,
-				      filter[afi][safi].advmap.aname,
-				      MTYPE_BGP_FILTER_NAME);
-		PEER_ATTR_INHERIT(peer, peer->group,
-				  filter[afi][safi].advmap.amap);
-	} else
-		peer_advertise_map_filter_update(
-			peer, afi, safi, advertise_name, advertise_map,
-			condition_name, condition_map, condition, false);
-
-	/* Check if handling a regular peer and skip peer-group mechanics. */
-	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
-		/* Process peer route updates. */
-		if (BGP_DEBUG(update, UPDATE_OUT))
-			zlog_debug("%s: Send normal update to %s for %s",
-				   __func__, peer->host,
-				   get_afi_safi_str(afi, safi, false));
-
-		return 0;
-	}
-
-	/*
-	 * Remove configuration on all peer-group members, unless they are
-	 * explicitly overriding peer-group configuration.
-	 */
-	for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
-		/* Skip peers with overridden configuration. */
-		if (CHECK_FLAG(member->filter_override[afi][safi][RMAP_OUT],
-			       PEER_FT_ADVERTISE_MAP))
-			continue;
-		/* Remove configuration on peer-group member. */
-		peer_advertise_map_filter_update(
-			member, afi, safi, advertise_name, advertise_map,
-			condition_name, condition_map, condition, false);
-
-		/* Process peer route updates. */
-		if (BGP_DEBUG(update, UPDATE_OUT))
-			zlog_debug("%s: Send normal update to %s for %s ",
-				   __func__, member->host,
-				   get_afi_safi_str(afi, safi, false));
-	}
-
-	return 0;
-}
-
 static bool peer_maximum_prefix_clear_overflow(struct peer *peer)
 {
 	if (!CHECK_FLAG(peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))
@@ -7946,10 +7857,7 @@ int peer_clear_soft(struct peer *peer, a
 	    || stype == BGP_CLEAR_SOFT_IN_ORF_PREFIX) {
 		/* If neighbor has soft reconfiguration inbound flag.
 		   Use Adj-RIB-In database. */
-		if (CHECK_FLAG(peer->af_flags[afi][safi],
-			       PEER_FLAG_SOFT_RECONFIG))
-			bgp_soft_reconfig_in(peer, afi, safi);
-		else {
+		if (!bgp_soft_reconfig_in(peer, afi, safi)) {
 			/* If neighbor has route refresh capability, send route
 			   refresh
 			   message to the peer. */
@@ -8038,6 +7946,8 @@ void bgp_master_init(struct thread_maste
 	bm->socket_buffer = buffer_size;
 	bm->wait_for_fib = false;
 	bm->tcp_dscp = IPTOS_PREC_INTERNETCONTROL;
+	bm->inq_limit = BM_DEFAULT_Q_LIMIT;
+	bm->outq_limit = BM_DEFAULT_Q_LIMIT;
 
 	bgp_mac_init();
 	/* init the rd id space.
diff -urpN frr-frr-8.4.2/bgpd/bgpd.h frr-frr-8.5/bgpd/bgpd.h
--- frr-frr-8.4.2/bgpd/bgpd.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/bgpd.h	2023-03-13 20:01:47.000000000 +0600
@@ -132,6 +132,7 @@ struct bgp_master {
 
 	/* Various BGP global configuration.  */
 	uint8_t options;
+
 #define BGP_OPT_NO_FIB                   (1 << 0)
 #define BGP_OPT_NO_LISTEN                (1 << 1)
 #define BGP_OPT_NO_ZEBRA                 (1 << 2)
@@ -175,6 +176,10 @@ struct bgp_master {
 	/* DSCP value for TCP sessions */
 	uint8_t tcp_dscp;
 
+#define BM_DEFAULT_Q_LIMIT 10000
+	uint32_t inq_limit;
+	uint32_t outq_limit;
+
 	QOBJ_FIELDS;
 };
 DECLARE_QOBJ_TYPE(bgp_master);
@@ -238,7 +243,7 @@ struct vpn_policy {
 	 */
 	uint32_t tovpn_sid_index; /* unset => set to 0 */
 	struct in6_addr *tovpn_sid;
-	struct in6_addr *tovpn_sid_locator;
+	struct srv6_locator_chunk *tovpn_sid_locator;
 	uint32_t tovpn_sid_transpose_label;
 	struct in6_addr *tovpn_zebra_vrf_sid_last_sent;
 };
@@ -431,6 +436,8 @@ struct bgp {
 	/* BGP update delay on startup */
 	struct thread *t_update_delay;
 	struct thread *t_establish_wait;
+	struct thread *t_revalidate[AFI_MAX][SAFI_MAX];
+
 	uint8_t update_delay_over;
 	uint8_t main_zebra_update_hold;
 	uint8_t main_peers_update_hold;
@@ -458,44 +465,46 @@ struct bgp {
 
 	/* BGP flags. */
 	uint64_t flags;
-#define BGP_FLAG_ALWAYS_COMPARE_MED       (1 << 0)
-#define BGP_FLAG_DETERMINISTIC_MED        (1 << 1)
-#define BGP_FLAG_MED_MISSING_AS_WORST     (1 << 2)
-#define BGP_FLAG_MED_CONFED               (1 << 3)
-#define BGP_FLAG_NO_CLIENT_TO_CLIENT (1 << 4)
-#define BGP_FLAG_COMPARE_ROUTER_ID (1 << 5)
-#define BGP_FLAG_ASPATH_IGNORE (1 << 6)
-#define BGP_FLAG_IMPORT_CHECK (1 << 7)
-#define BGP_FLAG_NO_FAST_EXT_FAILOVER (1 << 8)
-#define BGP_FLAG_LOG_NEIGHBOR_CHANGES (1 << 9)
+#define BGP_FLAG_ALWAYS_COMPARE_MED (1ULL << 0)
+#define BGP_FLAG_DETERMINISTIC_MED (1ULL << 1)
+#define BGP_FLAG_MED_MISSING_AS_WORST (1ULL << 2)
+#define BGP_FLAG_MED_CONFED (1ULL << 3)
+#define BGP_FLAG_NO_CLIENT_TO_CLIENT (1ULL << 4)
+#define BGP_FLAG_COMPARE_ROUTER_ID (1ULL << 5)
+#define BGP_FLAG_ASPATH_IGNORE (1ULL << 6)
+#define BGP_FLAG_IMPORT_CHECK (1ULL << 7)
+#define BGP_FLAG_NO_FAST_EXT_FAILOVER (1ULL << 8)
+#define BGP_FLAG_LOG_NEIGHBOR_CHANGES (1ULL << 9)
 
 /* This flag is set when we have full BGP Graceful-Restart mode enable */
-#define BGP_FLAG_GRACEFUL_RESTART (1 << 10)
+#define BGP_FLAG_GRACEFUL_RESTART (1ULL << 10)
 
-#define BGP_FLAG_ASPATH_CONFED (1 << 11)
-#define BGP_FLAG_ASPATH_MULTIPATH_RELAX (1 << 12)
-#define BGP_FLAG_RR_ALLOW_OUTBOUND_POLICY (1 << 13)
-#define BGP_FLAG_DISABLE_NH_CONNECTED_CHK (1 << 14)
-#define BGP_FLAG_MULTIPATH_RELAX_AS_SET (1 << 15)
-#define BGP_FLAG_FORCE_STATIC_PROCESS (1 << 16)
-#define BGP_FLAG_SHOW_HOSTNAME (1 << 17)
-#define BGP_FLAG_GR_PRESERVE_FWD (1 << 18)
-#define BGP_FLAG_GRACEFUL_SHUTDOWN (1 << 19)
-#define BGP_FLAG_DELETE_IN_PROGRESS (1 << 20)
-#define BGP_FLAG_SELECT_DEFER_DISABLE (1 << 21)
-#define BGP_FLAG_GR_DISABLE_EOR (1 << 22)
-#define BGP_FLAG_EBGP_REQUIRES_POLICY (1 << 23)
-#define BGP_FLAG_SHOW_NEXTHOP_HOSTNAME (1 << 24)
+#define BGP_FLAG_ASPATH_CONFED (1ULL << 11)
+#define BGP_FLAG_ASPATH_MULTIPATH_RELAX (1ULL << 12)
+#define BGP_FLAG_RR_ALLOW_OUTBOUND_POLICY (1ULL << 13)
+#define BGP_FLAG_DISABLE_NH_CONNECTED_CHK (1ULL << 14)
+#define BGP_FLAG_MULTIPATH_RELAX_AS_SET (1ULL << 15)
+#define BGP_FLAG_FORCE_STATIC_PROCESS (1ULL << 16)
+#define BGP_FLAG_SHOW_HOSTNAME (1ULL << 17)
+#define BGP_FLAG_GR_PRESERVE_FWD (1ULL << 18)
+#define BGP_FLAG_GRACEFUL_SHUTDOWN (1ULL << 19)
+#define BGP_FLAG_DELETE_IN_PROGRESS (1ULL << 20)
+#define BGP_FLAG_SELECT_DEFER_DISABLE (1ULL << 21)
+#define BGP_FLAG_GR_DISABLE_EOR (1ULL << 22)
+#define BGP_FLAG_EBGP_REQUIRES_POLICY (1ULL << 23)
+#define BGP_FLAG_SHOW_NEXTHOP_HOSTNAME (1ULL << 24)
 
 /* This flag is set if the instance is in administrative shutdown */
-#define BGP_FLAG_SHUTDOWN (1 << 25)
-#define BGP_FLAG_SUPPRESS_FIB_PENDING (1 << 26)
-#define BGP_FLAG_SUPPRESS_DUPLICATES (1 << 27)
-#define BGP_FLAG_PEERTYPE_MULTIPATH_RELAX (1 << 29)
+#define BGP_FLAG_SHUTDOWN (1ULL << 25)
+#define BGP_FLAG_SUPPRESS_FIB_PENDING (1ULL << 26)
+#define BGP_FLAG_SUPPRESS_DUPLICATES (1ULL << 27)
+#define BGP_FLAG_PEERTYPE_MULTIPATH_RELAX (1ULL << 29)
 /* Indicate Graceful Restart support for BGP NOTIFICATION messages */
-#define BGP_FLAG_GRACEFUL_NOTIFICATION (1 << 30)
+#define BGP_FLAG_GRACEFUL_NOTIFICATION (1ULL << 30)
 /* Send Hard Reset CEASE Notification for 'Administrative Reset' */
-#define BGP_FLAG_HARD_ADMIN_RESET (1 << 31)
+#define BGP_FLAG_HARD_ADMIN_RESET (1ULL << 31)
+/* Evaluate the AIGP attribute during the best path selection process */
+#define BGP_FLAG_COMPARE_AIGP (1ULL << 32)
 
 	/* BGP default address-families.
 	 * New peers inherit enabled afi/safis from bgp instance.
@@ -719,8 +728,12 @@ struct bgp {
 #define BGP_VRF_AUTO                        (1 << 0)
 #define BGP_VRF_IMPORT_RT_CFGD              (1 << 1)
 #define BGP_VRF_EXPORT_RT_CFGD              (1 << 2)
-#define BGP_VRF_RD_CFGD                     (1 << 3)
-#define BGP_VRF_L3VNI_PREFIX_ROUTES_ONLY    (1 << 4)
+#define BGP_VRF_IMPORT_AUTO_RT_CFGD         (1 << 3) /* retain auto when cfgd */
+#define BGP_VRF_EXPORT_AUTO_RT_CFGD         (1 << 4) /* retain auto when cfgd */
+#define BGP_VRF_RD_CFGD                     (1 << 5)
+#define BGP_VRF_L3VNI_PREFIX_ROUTES_ONLY    (1 << 6)
+/* per-VRF toVPN SID */
+#define BGP_VRF_TOVPN_SID_AUTO              (1 << 7)
 
 	/* unique ID for auto derivation of RD for this vrf */
 	uint16_t vrf_rd_id;
@@ -768,6 +781,16 @@ struct bgp {
 	char srv6_locator_name[SRV6_LOCNAME_SIZE];
 	struct list *srv6_locator_chunks;
 	struct list *srv6_functions;
+	uint32_t tovpn_sid_index; /* unset => set to 0 */
+	struct in6_addr *tovpn_sid;
+	struct srv6_locator_chunk *tovpn_sid_locator;
+	uint32_t tovpn_sid_transpose_label;
+	struct in6_addr *tovpn_zebra_vrf_sid_last_sent;
+
+	/* TCP keepalive parameters for BGP connection */
+	uint16_t tcp_keepalive_idle;
+	uint16_t tcp_keepalive_intvl;
+	uint16_t tcp_keepalive_probes;
 
 	struct timeval ebgprequirespolicywarning;
 #define FIFTEENMINUTE2USEC (int64_t)15 * 60 * 1000000
@@ -1351,6 +1374,8 @@ struct peer {
 	/* `local-role` configured */
 #define PEER_FLAG_ROLE (1ULL << 32)
 #define PEER_FLAG_PORT (1ULL << 33)
+#define PEER_FLAG_AIGP (1ULL << 34)
+#define PEER_FLAG_GRACEFUL_SHUTDOWN (1ULL << 35)
 
 	/*
 	 *GR-Disabled mode means unset PEER_FLAG_GRACEFUL_RESTART
@@ -1410,13 +1435,14 @@ struct peer {
 #define PEER_FLAG_REMOVE_PRIVATE_AS_REPLACE (1ULL << 19)
 #define PEER_FLAG_AS_OVERRIDE (1ULL << 20)
 #define PEER_FLAG_REMOVE_PRIVATE_AS_ALL_REPLACE (1ULL << 21)
-#define PEER_FLAG_WEIGHT (1ULL << 24)
-#define PEER_FLAG_ALLOWAS_IN_ORIGIN (1ULL << 25)
-#define PEER_FLAG_SEND_LARGE_COMMUNITY (1ULL << 26)
-#define PEER_FLAG_MAX_PREFIX_OUT (1ULL << 27)
-#define PEER_FLAG_MAX_PREFIX_FORCE (1ULL << 28)
-#define PEER_FLAG_DISABLE_ADDPATH_RX (1ULL << 29)
-#define PEER_FLAG_SOO (1ULL << 30)
+#define PEER_FLAG_WEIGHT (1ULL << 22)
+#define PEER_FLAG_ALLOWAS_IN_ORIGIN (1ULL << 23)
+#define PEER_FLAG_SEND_LARGE_COMMUNITY (1ULL << 24)
+#define PEER_FLAG_MAX_PREFIX_OUT (1ULL << 25)
+#define PEER_FLAG_MAX_PREFIX_FORCE (1ULL << 26)
+#define PEER_FLAG_DISABLE_ADDPATH_RX (1ULL << 27)
+#define PEER_FLAG_SOO (1ULL << 28)
+#define PEER_FLAG_ACCEPT_OWN (1ULL << 63)
 
 	enum bgp_addpath_strat addpath_type[AFI_MAX][SAFI_MAX];
 
@@ -1457,6 +1483,7 @@ struct peer {
 /* LLGR aware peer */
 #define PEER_STATUS_LLGR_WAIT (1U << 11)
 #define PEER_STATUS_REFRESH_PENDING (1U << 12) /* refresh request from peer */
+#define PEER_STATUS_RTT_SHUTDOWN (1U << 13) /* In shutdown state due to RTT */
 
 	/* Configured timer values. */
 	_Atomic uint32_t holdtime;
@@ -1489,6 +1516,7 @@ struct peer {
 	struct thread *t_gr_restart;
 	struct thread *t_gr_stale;
 	struct thread *t_llgr_stale[AFI_MAX][SAFI_MAX];
+	struct thread *t_revalidate_all[AFI_MAX][SAFI_MAX];
 	struct thread *t_generate_updgrp_packets;
 	struct thread *t_process_packet;
 	struct thread *t_process_packet_error;
@@ -1669,6 +1697,7 @@ struct peer {
 #define PEER_DOWN_WAITING_OPEN          32U /* Waiting for open to succeed */
 #define PEER_DOWN_PFX_COUNT             33U /* Reached received prefix count */
 #define PEER_DOWN_SOCKET_ERROR          34U /* Some socket error happened */
+#define PEER_DOWN_RTT_SHUTDOWN          35U /* Automatically shutdown due to RTT */
 	/*
 	 * Remember to update peer_down_str in bgp_fsm.c when you add
 	 * a new value to the last_reset reason
@@ -1735,6 +1764,10 @@ struct peer {
 
 	bool shut_during_cfg;
 
+#define BGP_ATTR_MAX 255
+	/* Path attributes discard */
+	bool discard_attrs[BGP_ATTR_MAX];
+
 	QOBJ_FIELDS;
 };
 DECLARE_QOBJ_TYPE(peer);
@@ -1816,7 +1849,6 @@ struct bgp_nlri {
 #define BGP_MSG_ROUTE_REFRESH_OLD              128
 
 /* BGP open optional parameter.  */
-#define BGP_OPEN_OPT_AUTH                        1
 #define BGP_OPEN_OPT_CAP                         2
 
 /* BGP4 attribute type codes.  */
@@ -1835,10 +1867,10 @@ struct bgp_nlri {
 #define BGP_ATTR_EXT_COMMUNITIES                16
 #define BGP_ATTR_AS4_PATH                       17
 #define BGP_ATTR_AS4_AGGREGATOR                 18
-#define BGP_ATTR_AS_PATHLIMIT                   21
 #define BGP_ATTR_PMSI_TUNNEL                    22
 #define BGP_ATTR_ENCAP                          23
 #define BGP_ATTR_IPV6_EXT_COMMUNITIES           25
+#define BGP_ATTR_AIGP                           26
 #define BGP_ATTR_LARGE_COMMUNITIES              32
 #define BGP_ATTR_OTC                            35
 #define BGP_ATTR_PREFIX_SID                     40
@@ -1881,7 +1913,6 @@ struct bgp_nlri {
 #define BGP_NOTIFY_OPEN_BAD_PEER_AS              2
 #define BGP_NOTIFY_OPEN_BAD_BGP_IDENT            3
 #define BGP_NOTIFY_OPEN_UNSUP_PARAM              4
-#define BGP_NOTIFY_OPEN_AUTH_FAILURE             5
 #define BGP_NOTIFY_OPEN_UNACEP_HOLDTIME          6
 #define BGP_NOTIFY_OPEN_UNSUP_CAPBL              7
 #define BGP_NOTIFY_OPEN_ROLE_MISMATCH           11
@@ -1893,7 +1924,6 @@ struct bgp_nlri {
 #define BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR          4
 #define BGP_NOTIFY_UPDATE_ATTR_LENG_ERR          5
 #define BGP_NOTIFY_UPDATE_INVAL_ORIGIN           6
-#define BGP_NOTIFY_UPDATE_AS_ROUTE_LOOP          7
 #define BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP         8
 #define BGP_NOTIFY_UPDATE_OPT_ATTR_ERR           9
 #define BGP_NOTIFY_UPDATE_INVAL_NETWORK         10
@@ -1967,6 +1997,13 @@ struct bgp_nlri {
 #define BGP_DYNAMIC_NEIGHBORS_LIMIT_MIN          1
 #define BGP_DYNAMIC_NEIGHBORS_LIMIT_MAX      65535
 
+/* BGP AIGP */
+#define BGP_AIGP_TLV_RESERVED 0 /* AIGP Reserved */
+#define BGP_AIGP_TLV_METRIC 1   /* AIGP Metric */
+#define BGP_AIGP_TLV_METRIC_LEN 11
+#define BGP_AIGP_TLV_METRIC_MAX 0xffffffffffffffffULL
+#define BGP_AIGP_TLV_METRIC_DESC "Accumulated IGP Metric"
+
 /* Flag for peer_clear_soft().  */
 enum bgp_clear_type {
 	BGP_CLEAR_SOFT_NONE,
@@ -2004,13 +2041,11 @@ enum bgp_create_error_code {
 	BGP_ERR_AF_UNCONFIGURED = -15,
 	BGP_ERR_SOFT_RECONFIG_UNCONFIGURED = -16,
 	BGP_ERR_INSTANCE_MISMATCH = -17,
-	BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP = -18,
 	BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS = -19,
 	BGP_ERR_TCPSIG_FAILED = -20,
 	BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK = -21,
 	BGP_ERR_NO_IBGP_WITH_TTLHACK = -22,
 	BGP_ERR_NO_INTERFACE_CONFIG = -23,
-	BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS = -24,
 	BGP_ERR_AS_OVERRIDE = -25,
 	BGP_ERR_INVALID_DYNAMIC_NEIGHBORS_LIMIT = -26,
 	BGP_ERR_DYNAMIC_NEIGHBORS_RANGE_EXISTS = -27,
@@ -2096,8 +2131,10 @@ extern bool peer_active_nego(struct peer
 extern bool peer_afc_received(struct peer *peer);
 extern bool peer_afc_advertised(struct peer *peer);
 extern void bgp_recalculate_all_bestpaths(struct bgp *bgp);
-extern struct peer *peer_create(union sockunion *, const char *, struct bgp *,
-				as_t, as_t, int, struct peer_group *);
+extern struct peer *peer_create(union sockunion *su, const char *conf_if,
+				struct bgp *bgp, as_t local_as, as_t remote_as,
+				int as_type, struct peer_group *group,
+				bool config_node);
 extern struct peer *peer_create_accept(struct bgp *);
 extern void peer_xfer_config(struct peer *dst, struct peer *src);
 extern char *peer_uptime(time_t uptime2, char *buf, size_t len, bool use_json,
@@ -2190,7 +2227,8 @@ extern int peer_af_flag_set(struct peer
 			    uint64_t flag);
 extern int peer_af_flag_unset(struct peer *peer, afi_t afi, safi_t safi,
 			      uint64_t flag);
-extern int peer_af_flag_check(struct peer *, afi_t, safi_t, uint32_t);
+extern bool peer_af_flag_check(struct peer *peer, afi_t afi, safi_t safi,
+			       uint64_t flag);
 extern void peer_af_flag_inherit(struct peer *peer, afi_t afi, safi_t safi,
 				 uint64_t flag);
 extern void peer_change_action(struct peer *peer, afi_t afi, safi_t safi,
@@ -2215,6 +2253,9 @@ extern int peer_default_originate_set(st
 				      const char *rmap,
 				      struct route_map *route_map);
 extern int peer_default_originate_unset(struct peer *, afi_t, safi_t);
+extern void bgp_tcp_keepalive_set(struct bgp *bgp, uint16_t idle,
+				  uint16_t interval, uint16_t probes);
+extern void bgp_tcp_keepalive_unset(struct bgp *bgp);
 
 extern void peer_port_set(struct peer *, uint16_t);
 extern void peer_port_unset(struct peer *);
@@ -2576,7 +2617,10 @@ void peer_tcp_mss_unset(struct peer *pee
 
 extern void bgp_recalculate_afi_safi_bestpaths(struct bgp *bgp, afi_t afi,
 					       safi_t safi);
-
+extern void peer_on_policy_change(struct peer *peer, afi_t afi, safi_t safi,
+				  int outbound);
+extern bool bgp_path_attribute_discard(struct peer *peer, char *buf,
+				       size_t size);
 #ifdef _FRR_ATTRIBUTE_PRINTFRR
 /* clang-format off */
 #pragma FRR printfrr_ext "%pBP" (struct peer *)
diff -urpN frr-frr-8.4.2/bgpd/rfapi/rfapi.c frr-frr-8.5/bgpd/rfapi/rfapi.c
--- frr-frr-8.4.2/bgpd/rfapi/rfapi.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/rfapi/rfapi.c	2023-03-13 20:01:47.000000000 +0600
@@ -1273,13 +1273,15 @@ static int rfapi_open_inner(struct rfapi
 	}
 
 	{ /* base code assumes have valid host pointer */
-		char buf[BUFSIZ];
+		char buf[INET6_ADDRSTRLEN];
 		buf[0] = 0;
 
 		if (rfd->vn_addr.addr_family == AF_INET) {
-			inet_ntop(AF_INET, &rfd->vn_addr.addr.v4, buf, BUFSIZ);
+			inet_ntop(AF_INET, &rfd->vn_addr.addr.v4, buf,
+				  sizeof(buf));
 		} else if (rfd->vn_addr.addr_family == AF_INET6) {
-			inet_ntop(AF_INET6, &rfd->vn_addr.addr.v6, buf, BUFSIZ);
+			inet_ntop(AF_INET6, &rfd->vn_addr.addr.v6, buf,
+				  sizeof(buf));
 		}
 		rfd->peer->host = XSTRDUP(MTYPE_BGP_PEER_HOST, buf);
 	}
@@ -3174,13 +3176,17 @@ DEFUN (debug_rfapi_unregister_vn_un,
        "debug rfapi-dev unregister vn <A.B.C.D|X:X::X:X> un <A.B.C.D|X:X::X:X> prefix <A.B.C.D/M|X:X::X:X/M> [kill]",
        DEBUG_STR
        DEBUG_RFAPI_STR
-       "rfapi_register\n"
+       "rfapi_unregister\n"
        "indicate vn addr follows\n"
        "virtual network interface address\n"
+       "virtual network interface address\n"
        "indicate xt addr follows\n"
        "underlay network interface address\n"
+       "underlay network interface address\n"
        "prefix to remove\n"
-       "Remove without holddown")
+       "prefix to remove\n"
+       "prefix to remove\n"
+       "Remove without holddown\n")
 {
 	struct rfapi_ip_addr vn;
 	struct rfapi_ip_addr un;
@@ -3195,7 +3201,6 @@ DEFUN (debug_rfapi_unregister_vn_un,
 	if ((rc = rfapiCliGetRfapiIpAddr(vty, argv[4]->arg, &vn)))
 		return rc;
 
-
 	/*
 	 * Get UN addr
 	 */
diff -urpN frr-frr-8.4.2/bgpd/rfapi/rfapi_import.c frr-frr-8.5/bgpd/rfapi/rfapi_import.c
--- frr-frr-8.4.2/bgpd/rfapi/rfapi_import.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/rfapi/rfapi_import.c	2023-03-13 20:01:47.000000000 +0600
@@ -2344,8 +2344,7 @@ static void rfapiMonitorEncapDelete(stru
 }
 
 /*
- * quagga lib/thread.h says this must return int even though
- * it doesn't do anything with the return value
+ * Timer callback for withdraw
  */
 static void rfapiWithdrawTimerVPN(struct thread *t)
 {
@@ -2355,19 +2354,27 @@ static void rfapiWithdrawTimerVPN(struct
 	const struct prefix *p;
 	struct rfapi_monitor_vpn *moved;
 	afi_t afi;
+	bool early_exit = false;
 
 	if (bgp == NULL) {
 		vnc_zlog_debug_verbose(
                    "%s: NULL BGP pointer, assume shutdown race condition!!!",
                    __func__);
-		return;
+		early_exit = true;
 	}
-	if (CHECK_FLAG(bgp->flags, BGP_FLAG_DELETE_IN_PROGRESS)) {
+	if (bgp && CHECK_FLAG(bgp->flags, BGP_FLAG_DELETE_IN_PROGRESS)) {
 		vnc_zlog_debug_verbose(
 			"%s: BGP delete in progress, assume shutdown race condition!!!",
 			__func__);
+		early_exit = true;
+	}
+
+	/* This callback is responsible for the withdraw object's memory */
+	if (early_exit) {
+		XFREE(MTYPE_RFAPI_WITHDRAW, wcb);
 		return;
 	}
+
 	assert(wcb->node);
 	assert(bpi);
 	assert(wcb->import_table);
@@ -2908,7 +2915,8 @@ static void rfapiBgpInfoFilteredImportEn
 
 	vnc_zlog_debug_verbose(
 		"%s: entry: %s: prefix %s/%d", __func__, action_str,
-		inet_ntop(p->family, &p->u.prefix, buf, BUFSIZ), p->prefixlen);
+		inet_ntop(p->family, &p->u.prefix, buf, sizeof(buf)),
+		p->prefixlen);
 
 	memset(&p_firstbpi_old, 0, sizeof(p_firstbpi_old));
 	memset(&p_firstbpi_new, 0, sizeof(p_firstbpi_new));
diff -urpN frr-frr-8.4.2/bgpd/rfapi/rfapi_vty.c frr-frr-8.5/bgpd/rfapi/rfapi_vty.c
--- frr-frr-8.4.2/bgpd/rfapi/rfapi_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/rfapi/rfapi_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -322,6 +322,7 @@ int rfapiDebugPrintf(void *dummy, const
 	return 0;
 }
 
+PRINTFRR(2, 3)
 static int rfapiStdioPrintf(void *stream, const char *format, ...)
 {
 	FILE *file = NULL;
@@ -411,9 +412,10 @@ void rfapi_vty_out_vncinfo(struct vty *v
 
 		if (!rfapiGetVncTunnelUnAddr(bpi->attr, &pfx_un)) {
 			char buf[BUFSIZ];
+
 			vty_out(vty, "UN=%s",
 				inet_ntop(pfx_un.family, pfx_un.u.val, buf,
-					  BUFSIZ));
+					  sizeof(buf)));
 		}
 	}
 
@@ -432,11 +434,7 @@ void rfapi_vty_out_vncinfo(struct vty *v
 				decode_label(&bpi->extra->label[0]));
 
 		if (bpi->extra->num_sids) {
-			char buf[BUFSIZ];
-
-			vty_out(vty, " sid=%s",
-				inet_ntop(AF_INET6, &bpi->extra->sid[0].sid,
-					  buf, sizeof(buf)));
+			vty_out(vty, " sid=%pI6", &bpi->extra->sid[0].sid);
 
 			if (bpi->extra->sid[0].loc_block_len != 0) {
 				vty_out(vty, " sid_structure=[%d,%d,%d,%d]",
@@ -466,7 +464,6 @@ void rfapiPrintAttrPtrs(void *stream, st
 	const char *vty_newline;
 	struct transit *transit;
 	struct cluster_list *cluster;
-	char buf[BUFSIZ];
 	struct ecommunity *ecomm;
 	struct community *comm;
 
@@ -478,8 +475,7 @@ void rfapiPrintAttrPtrs(void *stream, st
 		return;
 
 	/* IPv4 Nexthop */
-	inet_ntop(AF_INET, &attr->nexthop, buf, BUFSIZ);
-	fp(out, "  nexthop=%s%s", buf, HVTYNL);
+	fp(out, "  nexthop=%pI4%s", &attr->nexthop, HVTYNL);
 
 	fp(out, "  aspath=%p, refcnt=%d%s", attr->aspath,
 	   (attr->aspath ? attr->aspath->refcnt : 0), HVTYNL);
@@ -571,15 +567,12 @@ void rfapiPrintBi(void *stream, struct b
 
 	/* Nexthop */
 	if (af == AF_INET) {
-		r = snprintf(p, REMAIN, "%s",
-			     inet_ntop(AF_INET,
-				       &bpi->attr->mp_nexthop_global_in, buf,
-				       BUFSIZ));
+		r = snprintfrr(p, REMAIN, "%pI4",
+			       &bpi->attr->mp_nexthop_global_in);
 		INCP;
 	} else if (af == AF_INET6) {
-		r = snprintf(p, REMAIN, "%s",
-			     inet_ntop(AF_INET6, &bpi->attr->mp_nexthop_global,
-				       buf, BUFSIZ));
+		r = snprintfrr(p, REMAIN, "%pI6",
+			       &bpi->attr->mp_nexthop_global);
 		INCP;
 	} else {
 		r = snprintf(p, REMAIN, "?");
@@ -590,9 +583,9 @@ void rfapiPrintBi(void *stream, struct b
 	 * VNC tunnel subtlv, if present, contains UN address
 	 */
 	if (!rfapiGetVncTunnelUnAddr(bpi->attr, &pfx_un)) {
-		r = snprintf(
-			p, REMAIN, " un=%s",
-			inet_ntop(pfx_un.family, pfx_un.u.val, buf, BUFSIZ));
+		r = snprintf(p, REMAIN, " un=%s",
+			     inet_ntop(pfx_un.family, pfx_un.u.val, buf,
+				       sizeof(buf)));
 		INCP;
 	}
 
@@ -719,7 +712,8 @@ char *rfapiMonitorVpn2Str(struct rfapi_m
 	rc = snprintf(buf, size,
 		      "m=%p, next=%p, rfd=%p(vn=%s un=%s), p=%s/%d, node=%p", m,
 		      m->next, m->rfd, buf_vn, buf_un,
-		      inet_ntop(m->p.family, &m->p.u.prefix, buf_pfx, BUFSIZ),
+		      inet_ntop(m->p.family, &m->p.u.prefix, buf_pfx,
+				sizeof(buf_pfx)),
 		      m->p.prefixlen, m->node);
 	buf[size - 1] = 0;
 	if (rc >= size)
@@ -800,9 +794,9 @@ void rfapiShowImportTable(void *stream,
 		const struct prefix *p = agg_node_get_prefix(rn);
 
 		if (p->family == AF_ETHERNET) {
-			rfapiEthAddr2Str(&p->u.prefix_eth, buf, BUFSIZ);
+			rfapiEthAddr2Str(&p->u.prefix_eth, buf, sizeof(buf));
 		} else {
-			inet_ntop(p->family, &p->u.prefix, buf, BUFSIZ);
+			inet_ntop(p->family, &p->u.prefix, buf, sizeof(buf));
 		}
 
 		fp(out, "%s/%d @%p #%d%s", buf, p->prefixlen, rn,
@@ -933,7 +927,7 @@ int rfapiShowVncQueries(void *stream, st
 					buf_remain, BUFSIZ);
 				fp(out, " %-15s %-10s\n",
 				   inet_ntop(m->p.family, &m->p.u.prefix,
-					     buf_pfx, BUFSIZ),
+					     buf_pfx, sizeof(buf_pfx)),
 				   buf_remain);
 			}
 		}
@@ -1052,9 +1046,10 @@ static int rfapiPrintRemoteRegBi(struct
 	 * Prefix
 	 */
 	buf_pfx[0] = 0;
-	snprintf(buf_pfx, sizeof(buf_pfx), "%s/%d",
-		 rfapi_ntop(p->family, &p->u.prefix, buf_ntop, BUFSIZ),
-		 p->prefixlen);
+	snprintf(
+		buf_pfx, sizeof(buf_pfx), "%s/%d",
+		rfapi_ntop(p->family, &p->u.prefix, buf_ntop, sizeof(buf_ntop)),
+		p->prefixlen);
 	buf_pfx[BUFSIZ - 1] = 0;
 	nlines++;
 
@@ -1065,7 +1060,7 @@ static int rfapiPrintRemoteRegBi(struct
 	if (!rfapiGetUnAddrOfVpnBi(bpi, &pfx_un)) {
 		snprintf(buf_un, sizeof(buf_un), "%s",
 			 inet_ntop(pfx_un.family, &pfx_un.u.prefix, buf_ntop,
-				   BUFSIZ));
+				   sizeof(buf_ntop)));
 	}
 
 	bgp_attr_extcom_tunnel_type(bpi->attr, &tun_type);
@@ -1079,7 +1074,7 @@ static int rfapiPrintRemoteRegBi(struct
 		 */
 		snprintf(buf_un, sizeof(buf_un), "%s",
 			 inet_ntop(pfx_vn.family, &pfx_vn.u.prefix, buf_ntop,
-				   BUFSIZ));
+				   sizeof(buf_ntop)));
 		if (bpi->extra) {
 			uint32_t l = decode_label(&bpi->extra->label[0]);
 			snprintf(buf_vn, sizeof(buf_vn), "Label: %d", l);
@@ -1090,7 +1085,7 @@ static int rfapiPrintRemoteRegBi(struct
 	} else {
 		snprintf(buf_vn, sizeof(buf_vn), "%s",
 			 inet_ntop(pfx_vn.family, &pfx_vn.u.prefix, buf_ntop,
-				   BUFSIZ));
+				   sizeof(buf_ntop)));
 	}
 	buf_vn[BUFSIZ - 1] = 0;
 	buf_un[BUFSIZ - 1] = 0;
diff -urpN frr-frr-8.4.2/bgpd/rfapi/rfapi_vty.h frr-frr-8.5/bgpd/rfapi/rfapi_vty.h
--- frr-frr-8.4.2/bgpd/rfapi/rfapi_vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/rfapi/rfapi_vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -62,7 +62,8 @@ extern int rfapiStr2EthAddr(const char *
 extern const char *rfapi_ntop(int af, const void *src, char *buf,
 			      socklen_t size);
 
-extern int rfapiDebugPrintf(void *dummy, const char *format, ...);
+extern int rfapiDebugPrintf(void *dummy, const char *format, ...)
+	PRINTFRR(2, 3);
 
 extern int rfapiStream2Vty(void *stream,			  /* input */
 			   int (**fp)(void *, const char *, ...), /* output */
diff -urpN frr-frr-8.4.2/bgpd/subdir.am frr-frr-8.5/bgpd/subdir.am
--- frr-frr-8.4.2/bgpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/bgpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -6,36 +6,9 @@ if BGPD
 noinst_LIBRARIES += bgpd/libbgp.a
 sbin_PROGRAMS += bgpd/bgpd
 noinst_PROGRAMS += bgpd/bgp_btoa
-vtysh_scan += \
-	bgpd/bgp_bfd.c \
-	bgpd/bgp_debug.c \
-	bgpd/bgp_dump.c \
-	bgpd/bgp_evpn_mh.c \
-	bgpd/bgp_evpn_vty.c \
-	bgpd/bgp_filter.c \
-	bgpd/bgp_labelpool.c \
-	bgpd/bgp_mplsvpn.c \
-	bgpd/bgp_nexthop.c \
-	bgpd/bgp_route.c \
-	bgpd/bgp_routemap.c \
-	bgpd/bgp_vty.c \
-	bgpd/bgp_flowspec_vty.c \
-	# end
-
-# can be loaded as DSO - always include for vtysh
-vtysh_scan += bgpd/bgp_rpki.c
-vtysh_scan += bgpd/bgp_bmp.c
 
 vtysh_daemons += bgpd
 
-if ENABLE_BGP_VNC
-vtysh_scan += \
-	bgpd/rfapi/bgp_rfapi_cfg.c \
-	bgpd/rfapi/rfapi.c \
-	bgpd/rfapi/rfapi_vty.c \
-	bgpd/rfapi/vnc_debug.c \
-	# end
-endif
 if SNMP
 module_LTLIBRARIES += bgpd/bgpd_snmp.la
 endif
@@ -177,6 +150,9 @@ noinst_HEADERS += \
 	bgpd/bgp_route.h \
 	bgpd/bgp_routemap_nb.h \
 	bgpd/bgp_script.h \
+	bgpd/bgp_snmp.h \
+	bgpd/bgp_snmp_bgp4.h \
+	bgpd/bgp_snmp_bgp4v2.h \
 	bgpd/bgp_table.h \
 	bgpd/bgp_updgrp.h \
 	bgpd/bgp_vpn.h \
@@ -214,7 +190,7 @@ bgpd_bgp_btoa_SOURCES = bgpd/bgp_btoa.c
 bgpd_bgpd_LDADD = bgpd/libbgp.a $(RFPLDADD) lib/libfrr.la $(LIBYANG_LIBS) $(LIBCAP) $(LIBM) $(UST_LIBS)
 bgpd_bgp_btoa_LDADD = bgpd/libbgp.a $(RFPLDADD) lib/libfrr.la $(LIBYANG_LIBS) $(LIBCAP) $(LIBM) $(UST_LIBS)
 
-bgpd_bgpd_snmp_la_SOURCES = bgpd/bgp_snmp.c  bgpd/bgp_mplsvpn_snmp.c
+bgpd_bgpd_snmp_la_SOURCES = bgpd/bgp_snmp_bgp4.c bgpd/bgp_snmp_bgp4v2.c bgpd/bgp_snmp.c bgpd/bgp_mplsvpn_snmp.c
 bgpd_bgpd_snmp_la_CFLAGS = $(AM_CFLAGS) $(SNMP_CFLAGS) -std=gnu11
 bgpd_bgpd_snmp_la_LDFLAGS = $(MODULE_LDFLAGS)
 bgpd_bgpd_snmp_la_LIBADD = lib/libfrrsnmp.la
@@ -237,6 +213,7 @@ clippy_scan += \
 	bgpd/bgp_routemap.c \
 	bgpd/bgp_rpki.c \
 	bgpd/bgp_vty.c \
+        bgpd/bgp_nexthop.c \
 	# end
 
 nodist_bgpd_bgpd_SOURCES = \
diff -urpN frr-frr-8.4.2/configure.ac frr-frr-8.5/configure.ac
--- frr-frr-8.4.2/configure.ac	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/configure.ac	2023-03-13 20:01:47.000000000 +0600
@@ -7,7 +7,7 @@
 ##
 AC_PREREQ([2.69])
 
-AC_INIT([frr], [8.4.2], [https://github.com/frrouting/frr/issues])
+AC_INIT([frr], [8.5], [https://github.com/frrouting/frr/issues])
 PACKAGE_URL="https://frrouting.org/"
 AC_SUBST([PACKAGE_URL])
 PACKAGE_FULLNAME="FRRouting"
@@ -349,6 +349,8 @@ AC_C_FLAG([-fno-omit-frame-pointer])
 AC_C_FLAG([-funwind-tables])
 AC_C_FLAG([-Wall])
 AC_C_FLAG([-Wextra])
+AC_C_FLAG([-Wformat-nonliteral])
+AC_C_FLAG([-Wformat-security])
 AC_C_FLAG([-Wstrict-prototypes])
 AC_C_FLAG([-Wmissing-prototypes])
 AC_C_FLAG([-Wmissing-declarations])
@@ -712,6 +714,8 @@ AC_ARG_ENABLE([cpu-time],
   AS_HELP_STRING([--disable-cpu-time], [disable cpu usage data gathering]))
 AC_ARG_ENABLE([pcreposix],
   AS_HELP_STRING([--enable-pcreposix], [enable using PCRE Posix libs for regex functions]))
+AC_ARG_ENABLE([pcre2posix],
+  AS_HELP_STRING([--enable-pcre2posix], [enable using PCRE2 Posix libs for regex functions]))
 AC_ARG_ENABLE([fpm],
   AS_HELP_STRING([--enable-fpm], [enable Forwarding Plane Manager support]))
 AC_ARG_ENABLE([werror],
@@ -1659,6 +1663,16 @@ if test "$enable_pcreposix" = "yes"; the
 fi
 AC_SUBST([HAVE_LIBPCREPOSIX])
 
+dnl ---------------------------
+dnl check system has PCRE2 regexp
+dnl ---------------------------
+if test "$enable_pcre2posix" = "yes"; then
+  AC_CHECK_LIB([pcre2-posix], [regexec], [], [
+    AC_MSG_ERROR([--enable-pcre2posix given but unable to find libpcre2-posix])
+  ])
+fi
+AC_SUBST([HAVE_LIBPCRE2_POSIX])
+
 dnl ##########################################################################
 dnl test "$enable_clippy_only" != "yes"
 fi
@@ -2644,6 +2658,7 @@ AC_DEFINE_UNQUOTED([ZEBRA_SERV_PATH], ["
 AC_DEFINE_UNQUOTED([BFDD_CONTROL_SOCKET], ["$frr_statedir%s%s/bfdd.sock"], [bfdd control socket])
 AC_DEFINE_UNQUOTED([OSPFD_GR_STATE], ["$frr_statedir%s/ospfd-gr.json"], [ospfd GR state information])
 AC_DEFINE_UNQUOTED([OSPF6D_GR_STATE], ["$frr_statedir/ospf6d-gr.json"], [ospf6d GR state information])
+AC_DEFINE_UNQUOTED([ISISD_RESTART], ["$frr_statedir%s/isid-restart.json"], [isisd restart information])
 AC_DEFINE_UNQUOTED([OSPF6_AUTH_SEQ_NUM_FILE], ["$frr_statedir/ospf6d-at-seq-no.dat"], [ospf6d AT Sequence number information])
 AC_DEFINE_UNQUOTED([DAEMON_VTY_DIR], ["$frr_statedir%s%s"], [daemon vty directory])
 AC_DEFINE_UNQUOTED([DAEMON_DB_DIR], ["$frr_statedir"], [daemon database directory])
@@ -2759,7 +2774,6 @@ AC_CONFIG_FILES([
 	  pkgsrc/ripd.sh pkgsrc/ripngd.sh pkgsrc/zebra.sh
 	  pkgsrc/eigrpd.sh])
 
-AC_CONFIG_FILES([vtysh/extract.pl], [chmod +x vtysh/extract.pl])
 AC_CONFIG_FILES([tools/frr], [chmod +x tools/frr])
 AC_CONFIG_FILES([tools/watchfrr.sh], [chmod +x tools/watchfrr.sh])
 AC_CONFIG_FILES([tools/frrinit.sh], [chmod +x tools/frrinit.sh])
diff -urpN frr-frr-8.4.2/debian/changelog frr-frr-8.5/debian/changelog
--- frr-frr-8.4.2/debian/changelog	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/changelog	2023-03-13 20:01:47.000000000 +0600
@@ -1,14 +1,44 @@
-frr (8.4.2-0) unstable; urgency=medium
+frr (8.5-0) unstable; urgency=medium
 
-  * New upstream release FRR 8.4.2
+  * New upstream release FRR 8.5
 
- -- Jafar Al-Gharaibeh <jafar@atcorp.com>  Mon, 09 Jan 2023 10:00:00 +0500
+ -- Jafar Al-Gharaibeh <jafar@atcorp.com>  Fri, 10 Mar 2023 02:00:00 -0600
 
-frr (8.4.1-0) unstable; urgency=medium
+frr (8.4.2-1) unstable; urgency=medium
 
-  * New upstream release FRR 8.4.1
+  * new upstream release FRR 8.4.2
+  * drop all patches in debian/patches/, they got merged upstream
 
- -- Jafar Al-Gharaibeh <jafar@atcorp.com>  Thu, 17 Nov 2022 10:00:00 +0500
+ -- David Lamparter <equinox-debian@diac24.net>  Mon, 23 Jan 2023 17:32:02 +0100
+
+frr (8.4.1-2) unstable; urgency=medium
+
+  * commit to git tarball as source instead of dist tarball
+  * ditch unneeded sphinx missing files patch
+  * fix clippy symbol lookup issue (build SEGV on mips64el)
+  * correctly mark :native for libelf-dev & libpython3-dev to fix cross-build
+  * use mutex for zserv stats (atomic uint64_t is too wide for 32-bit archs)
+
+ -- David Lamparter <equinox-debian@diac24.net>  Fri, 06 Jan 2023 14:59:57 +0100
+
+frr (8.4.1-1) unstable; urgency=medium
+
+  * New upstream release FRR 8.4.1 (closes: #1017518)
+  * New frr@ systemd service unit to run inside network namespace
+  * egrep to grep -E
+  * upstream fix ospfd crash (PR 8876) (closes: #981139)
+  * upstream fix isisd parsing issues CVE-2022-26125, CVE-2022-26126 and
+    babeld parsing issues CVE-2022-26127, CVE-2022-26128, CVE-2022-26129
+    (closes: #1008010)
+  * upstream fix bgpd out-of-bounds read CVE-2022-37032 (closes: #1021016)
+  * upstream fix bgpd UAF CVE-2022-37035 (closes: #1016978)
+  * libyang-related pcre3 dep replaced with pcre2 (closes: #1000032)
+  * disable ELF magic on mips64el
+  * fixed texinfo figure installation directory
+  * enable dh_sphinxdoc to get rid of embedded javascript in frr-doc
+  * removed bogus iproute dependency choice
+
+ -- David Lamparter <equinox-debian@diac24.net>  Mon, 02 Jan 2023 14:46:06 +0100
 
 frr (8.4-0) unstable; urgency=medium
 
@@ -28,6 +58,13 @@ frr (8.2-0) unstable; urgency=medium
 
  -- Jafar Al-Gharaibeh <jafar@atcorp.com>  Tue, 01 Mar 2022 10:00:00 +0500
 
+frr (8.1-1) unstable; urgency=medium
+
+  * New upstream release FRR 8.1
+  * Upload to unstable.
+
+ -- Ondej Sur <ondrej@debian.org>  Sat, 13 Nov 2021 13:32:48 +0100
+
 frr (8.1-0) unstable; urgency=medium
 
   * New upstream release FRR 8.1
@@ -1013,7 +1050,7 @@ quagga (0.98.3-6) testing-proposed-updat
 quagga (0.98.3-5) unstable; urgency=high
 
   * The patch which tried to remove the OpenSSL dependency, which is
-    not only unnecessary but also a violation of the licence and thus RC,
+    not only unneccessary but also a violation of the licence and thus RC,
     stopped working a while ago, since autoreconf is no longer run before
     building the binaries. So now ./configure is patched directly (thanks
     to Faidon Liambotis for reporting). Closes: #306840
@@ -1394,7 +1431,7 @@ quagga (0.96.4x-3) unstable; urgency=low
   * Made the directory (but not the config/log files!) world accessible
     again on user request (thanks to Anand Kumria)). Closes: #213129
   * No longer providing sample configuration in /etc/quagga/. They are
-    now only available in /usr/share/doc/quagga/ to avoid accidentally
+    now only available in /usr/share/doc/quagga/ to avoid accidently
     using them without changing the adresses (thanks to Marc Haber).
     Closes: #215918
 
@@ -1454,7 +1491,7 @@ quagga (0.96.3-1) unstable; urgency=medi
 
 quagga (0.96.2-9) unstable; urgency=medium
 
-  * Removed /usr/share/info/dir.* which were accidentally there and prevented
+  * Removed /usr/share/info/dir.* which were accidently there and prevented
     the installation by dpkg (thanks to Simon Raven). Closes: #212614
   * Reworded package description (thanks to Anand Kumria). Closes: #213125
   * Added french debconf translation (thanks to Christian Perrier).
diff -urpN frr-frr-8.4.2/debian/control frr-frr-8.5/debian/control
--- frr-frr-8.4.2/debian/control	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/control	2023-03-13 20:01:47.000000000 +0600
@@ -13,11 +13,11 @@ Build-Depends: bison,
                install-info,
                libc-ares-dev,
                libcap-dev,
-               libelf-dev,
+               libelf-dev:native,
                libjson-c-dev | libjson0-dev,
                libpam0g-dev | libpam-dev,
                libpcre2-dev,
-               libpython3-dev,
+               libpython3-dev:native,
                libreadline-dev,
                librtr-dev (>= 0.8.0~) <!pkg.frr.nortrlib>,
                libsnmp-dev,
@@ -25,10 +25,10 @@ Build-Depends: bison,
                libyang2-dev,
                lsb-base,
                pkg-config,
-               python3,
-               python3-dev,
-               python3-pytest <!nocheck>,
-               python3-sphinx,
+               python3:native,
+               python3-dev:native,
+               python3-pytest:native <!nocheck>,
+               python3-sphinx:native,
                texinfo (>= 4.7),
                lua5.3 <pkg.frr.lua>,
                liblua5.3-dev <pkg.frr.lua>
@@ -39,7 +39,7 @@ Vcs-Git: https://github.com/FRRouting/fr
 
 Package: frr
 Architecture: linux-any
-Depends: iproute2 | iproute,
+Depends: iproute2,
          logrotate (>= 3.2-11),
          lsof,
          ${misc:Depends},
@@ -104,9 +104,8 @@ Package: frr-doc
 Section: doc
 Architecture: all
 Multi-Arch: foreign
-Depends: libjs-jquery,
-         libjs-underscore,
-         ${misc:Depends}
+Depends: ${misc:Depends},
+         ${sphinxdoc:Depends}
 Suggests: frr
 Conflicts: quagga-doc
 Description: FRRouting suite - user manual
diff -urpN frr-frr-8.4.2/debian/frr-doc.doc-base frr-frr-8.5/debian/frr-doc.doc-base
--- frr-frr-8.4.2/debian/frr-doc.doc-base	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr-doc.doc-base	2023-03-13 20:01:47.000000000 +0600
@@ -12,12 +12,12 @@ Format: info
 Index: /usr/share/info/frr.info.gz
 Files:
  /usr/share/info/frr.info.gz
- /usr/share/info/fig-normal-processing.png
- /usr/share/info/fig-rs-processing.png
- /usr/share/info/fig-vnc-commercial-route-reflector.png
- /usr/share/info/fig-vnc-frr-route-reflector.png
- /usr/share/info/fig-vnc-gw.png
- /usr/share/info/fig-vnc-mesh.png
- /usr/share/info/fig-vnc-redundant-route-reflectors.png
- /usr/share/info/fig_topologies_full.png
- /usr/share/info/fig_topologies_rs.png
+ /usr/share/info/frr-figures/fig-normal-processing.png
+ /usr/share/info/frr-figures/fig-rs-processing.png
+ /usr/share/info/frr-figures/fig-vnc-commercial-route-reflector.png
+ /usr/share/info/frr-figures/fig-vnc-frr-route-reflector.png
+ /usr/share/info/frr-figures/fig-vnc-gw.png
+ /usr/share/info/frr-figures/fig-vnc-mesh.png
+ /usr/share/info/frr-figures/fig-vnc-redundant-route-reflectors.png
+ /usr/share/info/frr-figures/fig_topologies_full.png
+ /usr/share/info/frr-figures/fig_topologies_rs.png
diff -urpN frr-frr-8.4.2/debian/frr-doc.info frr-frr-8.5/debian/frr-doc.info
--- frr-frr-8.4.2/debian/frr-doc.info	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr-doc.info	2023-03-13 20:01:47.000000000 +0600
@@ -1 +1 @@
-doc/user/_build/texinfo/frr.info
+build/doc/user/_build/texinfo/frr.info
diff -urpN frr-frr-8.4.2/debian/frr-doc.install frr-frr-8.5/debian/frr-doc.install
--- frr-frr-8.4.2/debian/frr-doc.install	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr-doc.install	2023-03-13 20:01:47.000000000 +0600
@@ -3,14 +3,14 @@
 # other
 README.md         usr/share/doc/frr
 doc/figures/*.png usr/share/doc/frr
-doc/figures/fig-normal-processing.png usr/share/info
-doc/figures/fig-rs-processing.png usr/share/info
-doc/figures/fig-vnc-commercial-route-reflector.png usr/share/info
-doc/figures/fig-vnc-frr-route-reflector.png usr/share/info
-doc/figures/fig-vnc-gw.png usr/share/info
-doc/figures/fig-vnc-mesh.png usr/share/info
-doc/figures/fig-vnc-redundant-route-reflectors.png usr/share/info
-doc/figures/fig_topologies_full.png usr/share/info
-doc/figures/fig_topologies_rs.png usr/share/info
+doc/figures/fig-normal-processing.png              usr/share/info/frr-figures
+doc/figures/fig-rs-processing.png                  usr/share/info/frr-figures
+doc/figures/fig-vnc-commercial-route-reflector.png usr/share/info/frr-figures
+doc/figures/fig-vnc-frr-route-reflector.png        usr/share/info/frr-figures
+doc/figures/fig-vnc-gw.png                         usr/share/info/frr-figures
+doc/figures/fig-vnc-mesh.png                       usr/share/info/frr-figures
+doc/figures/fig-vnc-redundant-route-reflectors.png usr/share/info/frr-figures
+doc/figures/fig_topologies_full.png                usr/share/info/frr-figures
+doc/figures/fig_topologies_rs.png                  usr/share/info/frr-figures
 usr/share/doc/frr/html
 usr/share/info/
diff -urpN frr-frr-8.4.2/debian/frr.install frr-frr-8.5/debian/frr.install
--- frr-frr-8.4.2/debian/frr.install	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr.install	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,7 @@
 debian/frr.conf usr/lib/tmpfiles.d
 etc/
 tools/etc/frr/frr.conf etc/frr/
+tools/etc/logrotate.d/frr etc/logrotate.d/
 tools/frr-reload usr/lib/frr/
 usr/bin/mtracebis
 usr/bin/vtysh
diff -urpN frr-frr-8.4.2/debian/frr.lintian-overrides frr-frr-8.5/debian/frr.lintian-overrides
--- frr-frr-8.4.2/debian/frr.lintian-overrides	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr.lintian-overrides	2023-03-13 20:01:47.000000000 +0600
@@ -1,10 +1,6 @@
 # function names & co.
-frr binary: spelling-error-in-binary usr/lib/*/frr/libfrr.so.0.0.0 writen written
-frr binary: spelling-error-in-binary usr/lib/*/frr/libfrrospfapiclient.so.0.0.0 writen written
-frr binary: spelling-error-in-binary usr/lib/frr/ospfd writen written
-frr binary: spelling-error-in-binary usr/lib/frr/zebra writen written
-frr binary: spelling-error-in-binary usr/lib/frr/pimd writen written
-frr binary: spelling-error-in-binary usr/lib/frr/pimd iif if
+frr binary: spelling-error-in-binary *writen written*
+frr binary: spelling-error-in-binary *iif if*
 
 # prefixed man pages for off-PATH daemons
 manpage-without-executable
diff -urpN frr-frr-8.4.2/debian/frr.logrotate frr-frr-8.5/debian/frr.logrotate
--- frr-frr-8.4.2/debian/frr.logrotate	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr.logrotate	1970-01-01 06:00:00.000000000 +0600
@@ -1,27 +0,0 @@
-/var/log/frr/*.log {
-        size 500k
-        sharedscripts
-        missingok
-        compress
-        rotate 14
-        create 0640 frr frr
-
-        postrotate
-            pid=$(lsof -t -a -c /syslog/ /var/log/frr/* 2>/dev/null)
-            if [ -n "$pid" ]
-            then # using syslog
-                 kill -HUP $pid
-            fi
-            # in case using file logging; if switching back and forth
-            # between file and syslog, rsyslogd might still have file
-            # open, as well as the daemons, so always signal the daemons.
-            # It's safe, a NOP if (only) syslog is being used.
-            for i in babeld bgpd eigrpd isisd ldpd nhrpd ospf6d ospfd sharpd \
-                pimd pim6d ripd ripngd zebra pathd pbrd staticd bfdd fabricd vrrpd; do
-                if [ -e /var/run/frr/$i.pid ] ; then
-                    pids="$pids $(cat /var/run/frr/$i.pid)"
-                fi
-            done
-            [ -n "$pids" ] && kill -USR1 $pids || true
-        endscript
-}
diff -urpN frr-frr-8.4.2/debian/frr.manpages frr-frr-8.5/debian/frr.manpages
--- frr-frr-8.4.2/debian/frr.manpages	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr.manpages	2023-03-13 20:01:47.000000000 +0600
@@ -1,16 +1,16 @@
-doc/manpages/_build/man/frr-bgpd.8
-doc/manpages/_build/man/frr-eigrpd.8
-doc/manpages/_build/man/frr-fabricd.8
-doc/manpages/_build/man/frr-isisd.8
-doc/manpages/_build/man/frr-ldpd.8
-doc/manpages/_build/man/frr-nhrpd.8
-doc/manpages/_build/man/frr-ospf6d.8
-doc/manpages/_build/man/frr-ospfd.8
-doc/manpages/_build/man/frr-pimd.8
-doc/manpages/_build/man/frr-ripd.8
-doc/manpages/_build/man/frr-ripngd.8
-doc/manpages/_build/man/frr-watchfrr.8
-doc/manpages/_build/man/frr-zebra.8
-doc/manpages/_build/man/frr.1
-doc/manpages/_build/man/mtracebis.8
-doc/manpages/_build/man/vtysh.1
+build/doc/manpages/_build/man/frr-bgpd.8
+build/doc/manpages/_build/man/frr-eigrpd.8
+build/doc/manpages/_build/man/frr-fabricd.8
+build/doc/manpages/_build/man/frr-isisd.8
+build/doc/manpages/_build/man/frr-ldpd.8
+build/doc/manpages/_build/man/frr-nhrpd.8
+build/doc/manpages/_build/man/frr-ospf6d.8
+build/doc/manpages/_build/man/frr-ospfd.8
+build/doc/manpages/_build/man/frr-pimd.8
+build/doc/manpages/_build/man/frr-ripd.8
+build/doc/manpages/_build/man/frr-ripngd.8
+build/doc/manpages/_build/man/frr-watchfrr.8
+build/doc/manpages/_build/man/frr-zebra.8
+build/doc/manpages/_build/man/frr.1
+build/doc/manpages/_build/man/mtracebis.8
+build/doc/manpages/_build/man/vtysh.1
diff -urpN frr-frr-8.4.2/debian/frr.pam frr-frr-8.5/debian/frr.pam
--- frr-frr-8.4.2/debian/frr.pam	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/frr.pam	2023-03-13 20:01:47.000000000 +0600
@@ -1,3 +1,4 @@
 # Any user may call vtysh but only those belonging to the group frrvty can
 # actually connect to the socket and use the program.
 auth	sufficient	pam_permit.so
+account	sufficient	pam_rootok.so
diff -urpN frr-frr-8.4.2/debian/rules frr-frr-8.5/debian/rules
--- frr-frr-8.4.2/debian/rules	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/rules	2023-03-13 20:01:47.000000000 +0600
@@ -27,16 +27,16 @@ else
   CONF_LUA=--enable-scripting
 endif
 
-ifeq ($(filter pkg.frr.pim6d,$(DEB_BUILD_PROFILES)),)
-  CONF_PIM6=--disable-pim6d
-else
+ifeq ($(filter pkg.frr.nopim6d,$(DEB_BUILD_PROFILES)),)
   CONF_PIM6=--enable-pim6d
+else
+  CONF_PIM6=--disable-pim6d
 endif
 
 export PYTHON=python3
 
 %:
-	dh $@
+	dh $@ -Bbuild --with=sphinxdoc
 
 override_dh_auto_configure:
 	$(shell dpkg-buildflags --export=sh); \
@@ -76,11 +76,13 @@ override_dh_auto_install:
 
 	sed -e '1c #!/usr/bin/python3' -i debian/tmp/usr/lib/frr/frr-reload.py
 	sed -e '1c #!/usr/bin/python3' -i debian/tmp/usr/lib/frr/generate_support_bundle.py
+	sed -e '1c #!/usr/bin/python3' -i debian/tmp/usr/lib/frr/frr_babeltrace.py
+	sed -e '1c #!/usr/bin/python3' -i debian/tmp/usr/lib/frr/ospfclient.py
 
 # let dh_systemd_* and dh_installinit do their thing automatically
-	cp tools/frr.service debian/frr.service
-	cp tools/frr@.service debian/frr@.service
-	cp tools/frrinit.sh debian/frr.init
+	cp build/tools/frr.service debian/frr.service
+	cp build/tools/frr@.service debian/frr@.service
+	cp build/tools/frrinit.sh debian/frr.init
 	-rm -f debian/tmp/usr/lib/frr/frr
 
 # install config files
@@ -93,12 +95,6 @@ override_dh_auto_install:
 	rm -rf debian/tmp/usr/include
 	-rm debian/tmp/usr/lib/frr/ssd
 
-# use installed js libraries
-	-rm -f debian/tmp/usr/share/doc/frr/html/_static/jquery.js
-	ln -s /usr/share/javascript/jquery/jquery.js debian/tmp/usr/share/doc/frr/html/_static/jquery.js
-	-rm -f debian/tmp/usr/share/doc/frr/html/_static/underscore.js
-	ln -s /usr/share/javascript/underscore/underscore.js debian/tmp/usr/share/doc/frr/html/_static/underscore.js
-
 override_dh_auto_build:
 	dh_auto_build -- $(MAKE_SILENT)
 
@@ -114,6 +110,11 @@ override_dh_makeshlibs:
 override_dh_missing:
 	dh_missing --fail-missing
 
+ifneq ($(filter nocheck,$(DEB_BUILD_PROFILES) $(DEB_BUILD_OPTIONS)),)
+override_dh_auto_test:
+	true
+endif
+
 override_dh_auto_clean:
 # we generally do NOT want a full distclean since that wipes both
 # debian/changelog and config.version
diff -urpN frr-frr-8.4.2/debian/watch frr-frr-8.5/debian/watch
--- frr-frr-8.4.2/debian/watch	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/watch	2023-03-13 20:01:47.000000000 +0600
@@ -1,5 +1,10 @@
 version=4
 
-opts=uversionmangle=s/(\d)[_\.\-\+]?((RC|rc|pre|dev|beta|alpha)\d*)$/$1~$2/ \
+opts="\
+searchmode=plain,\
+uversionmangle=s/(\d)[_\.\-\+]?((RC|rc|pre|dev|beta|alpha)\d*)$/$1~$2/,\
+downloadurlmangle=s&releases/>FRR\s*(\d\S+)\s+Release<&archive/refs/tags/frr-$1.tar.gz&,\
+filenamemangle=s&>FRR\s*(\d\S+)\s+Release<&frr-$1.tar.gz&,\
+" \
 https://github.com/FRRouting/frr/releases/ \
-	.*/frr-(\d\S+)\.(?:zip|tgz|tbz|txz|(?:tar\.(?:gz|bz2|xz)))
+	>FRR\s*(\d\S+)\s+Release<
diff -urpN frr-frr-8.4.2/debian/watchfrr.rc frr-frr-8.5/debian/watchfrr.rc
--- frr-frr-8.4.2/debian/watchfrr.rc	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/debian/watchfrr.rc	1970-01-01 06:00:00.000000000 +0600
@@ -1,4 +0,0 @@
-check process watchfrr with pidfile /var/run/frr/watchfrr.pid
-        start program = "/etc/init.d/frr start watchfrr" with timeout 120 seconds
-        stop program = "/etc/init.d/frr stop watchfrr"
-        if 3 restarts within 10 cycles then timeout
diff -urpN frr-frr-8.4.2/doc/accords/README.md frr-frr-8.5/doc/accords/README.md
--- frr-frr-8.4.2/doc/accords/README.md	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/accords/README.md	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,32 @@
+FRR accords
+===========
+
+
+This directory contains some text documents with "accords" agreed upon by the
+FRR community.  The idea here is that by passing text documents through the
+PR/review process, consensus for work items, design decisions, etc. can be
+established and documented.  They can also be changed later by followup PRs if
+consensus shifts.  This is intended to reduce friction, and provide more
+transparency for newcomers & less frequent contributors.
+
+Examples of things that could go here:
+
+- agreement on how to fix some deeper-seated existing shortcoming in FRR that
+  might take some time to fix, to get consensus before putting time into it.
+
+- larger design (especially system/package integration) decisions that are not
+  immediately tangible to the code.
+
+- scoping decisions, particularly negative (i.e. we decided at some point that
+  FRR is not the right place for something) - these are otherwise lost in some
+  ancient closed PR, and some new contributor might be unaware and waste time.
+
+Files in this directory are not formatted in any specific way and not rendered
+into documentation.  They're intended to be read with your code editor of
+choice.
+
+To avoid misunderstandings, there is one "rule" about wording:  the consensus
+actual is worded with "will", "going to", "is" - this reflects the idea that
+when the PR is merged, it *is* community consensus.  Words like "should",
+"would" or "might" should be limited to context and reference that is provided
+as rationale for the consensus.
diff -urpN frr-frr-8.4.2/doc/accords/cli-colors frr-frr-8.5/doc/accords/cli-colors
--- frr-frr-8.4.2/doc/accords/cli-colors	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/accords/cli-colors	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,44 @@
+Adding colors to FRR CLI output
+===============================
+
+
+There were multiple approaches/attempts to get colored output for the CLI into
+FRR, most recently End of 2022 in PR #12497.  After some discussion, some items
+crystallized out:
+
+First, generally speaking, colors (or other rich output formatting) must be
+used sparingly.  In particular, e.g. "every IP address" is not something to
+color.  The output formatting needs to have an actual purpose to improve UX,
+not turn it into a christmas tree.
+
+In the long run, the CLI will hopefully become a YANG frontend.  In that case,
+the CLI frontend component is a great place to apply all kinds of output/UI/UX
+features.  However, this is a long way off.
+
+That said, an implementation in the current vtysh+daemon ecosystem is not out
+of the question, especially if the use of colors/formatting is limited to
+important places (which is desirable anyway - see general statement above.)
+We don't want to litter formatting all over every single vty_out call.
+
+A color option on a per-command/DEFUN level (i.e. the way `[json]` is done) was
+rejected.  The decision to color output must take information from vtysh's
+environment into account, notably the TERM environment variable, the NO_COLOR
+environment variable, and whether stdout is a terminal or not.  An explicit
+`--color` switch (or `terminal color` vtysh command, or other similar things)
+is needed too.  To be clear, the switch must not be on individual commands, it
+needs to be on the vtysh session level.
+
+Lastly, the output pager needs to work with this.
+
+
+Suggested implementation
+------------------------
+
+(not part of the consensus / accord, only to record discussion)
+
+As far as discussion went, the most promising approach to actually implement
+this is to put some type of unconditional formatting tag into daemon's vty_out
+calls.  This would be some escape-like sequence - an actual ANSI color code
+itself is not particularly readable or pretty, though that would work as well.
+vtysh would then, while passing through the output from the daemons, replace or
+remove these tags according to terminal/user settings.
diff -urpN frr-frr-8.4.2/doc/accords/frr-service-is-watchfrr frr-frr-8.5/doc/accords/frr-service-is-watchfrr
--- frr-frr-8.4.2/doc/accords/frr-service-is-watchfrr	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/accords/frr-service-is-watchfrr	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+The "FRR" service unit is watchfrr
+==================================
+
+
+"FRR" on the distribution/OS level is one service (generally called "frr").
+Exposing individual daemons (zebra, staticd, bgpd, ...) as service units does
+not match FRR's internal expectations.
+
+At some future point, watchfrr will add functionality to receive "router bgp",
+"router ospf" etc. commands (or their YANG variants) and automatically start
+the required daemons.  In particular with multi-instance setups, this will
+simplify config (no more mucking around /etc/frr/daemons - if watchfrr
+understands which daemons are needed by a given config, the daemons file is
+pointless.)
+
+This to some degree assumes an "integrated-config world".
diff -urpN frr-frr-8.4.2/doc/accords/integrated-config-wins frr-frr-8.5/doc/accords/integrated-config-wins
--- frr-frr-8.4.2/doc/accords/integrated-config-wins	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/accords/integrated-config-wins	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+Integrated config wins
+======================
+
+
+The use of split-configuration setups (zebra.conf, staticd.conf, bgpd.conf,
+etc.) in FRR is considered deprecated and will go away at some point.
+
+At this point there is no timeline yet on removing split-config support, and
+this needs to go through an extensive deprecation period with increasingly
+loud user warnings.
diff -urpN frr-frr-8.4.2/doc/developer/cli.rst frr-frr-8.5/doc/developer/cli.rst
--- frr-frr-8.4.2/doc/developer/cli.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/cli.rst	2023-03-13 20:01:47.000000000 +0600
@@ -106,6 +106,11 @@ convention. Please do not scatter indivi
 source files; instead expose the necessary functions in a header and place the
 command definition in a ``*_vty.[ch]`` file.
 
+.. note::
+
+   Please see :ref:`cli-workflow` for requirements when creating CLI commands
+   (e.g., JSON structure and formatting).
+
 Definition Grammar
 ^^^^^^^^^^^^^^^^^^
 FRR uses its own grammar for defining CLI commands. The grammar draws from
@@ -453,9 +458,7 @@ all DEFPY statements**:
    /* GPL header */
    #include ...
    ...
-   #ifndef VTYSH_EXTRACT_PL
    #include "daemon/filename_clippy.c"
-   #endif
 
    DEFPY(...)
    DEFPY(...)
diff -urpN frr-frr-8.4.2/doc/developer/conf.py frr-frr-8.5/doc/developer/conf.py
--- frr-frr-8.4.2/doc/developer/conf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/conf.py	2023-03-13 20:01:47.000000000 +0600
@@ -118,14 +118,6 @@ version = release.split("-")[0]
 for key, value in replace_vars.items():
     rst_prolog += ".. |{0}| replace:: {1}\n".format(key, value)
 
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
 # There are two options for replacing |today|: either, you set today to some
 # non-false value, then it is used:
 # today = ''
diff -urpN frr-frr-8.4.2/doc/developer/fpm.rst frr-frr-8.5/doc/developer/fpm.rst
--- frr-frr-8.4.2/doc/developer/fpm.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/fpm.rst	2023-03-13 20:01:47.000000000 +0600
@@ -101,3 +101,19 @@ Data
 ^^^^
 
 The netlink or protobuf message payload.
+
+
+Route Status Notification from ASIC
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The dplane_fpm_nl has the ability to read route netlink messages
+from the underlying fpm implementation that can tell zebra
+whether or not the route has been Offloaded/Failed or Trapped.
+The end developer must send the data up the same socket that has
+been created to listen for FPM messages from Zebra.  The data sent
+must have a Frame Header with Version set to 1, Message Type set to 1
+and an appropriate message Length.  The message data must contain
+a RTM_NEWROUTE netlink message that sends the prefix and nexthops
+associated with the route.  Finally rtm_flags must contain
+RTM_F_OFFLOAD, RTM_F_TRAP and or RTM_F_OFFLOAD_FAILED to signify
+what has happened to the route in the ASIC.
diff -urpN frr-frr-8.4.2/doc/developer/frr-release-procedure.rst frr-frr-8.5/doc/developer/frr-release-procedure.rst
--- frr-frr-8.4.2/doc/developer/frr-release-procedure.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/frr-release-procedure.rst	2023-03-13 20:01:47.000000000 +0600
@@ -235,6 +235,9 @@ Stage 3 - Publish
 #. Deploy the updated ``frr-www`` on the frrouting.org web server and verify
    that the announcement text is visible.
 
+#. Update readthedocs.org (Default Version) for https://docs.frrouting.org to
+   be the version of this latest release.
+
 #. Send an email to ``announce@lists.frrouting.org``. The text of this email
    should include text as appropriate from the GitHub release and a link to the
    GitHub release, Debian repository, and RPM repository.
diff -urpN frr-frr-8.4.2/doc/developer/packaging-debian.rst frr-frr-8.5/doc/developer/packaging-debian.rst
--- frr-frr-8.4.2/doc/developer/packaging-debian.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/packaging-debian.rst	2023-03-13 20:01:47.000000000 +0600
@@ -66,7 +66,7 @@ buster.)
      +----------------+-------------------+-----------------------------------------+
      | pkg.frr.lua    | pkg.frr.nolua     | builds lua scripting extension          |
      +----------------+-------------------+-----------------------------------------+
-     | pkg.frr.pim6d  | pkg.frr.nopim6d   | builds pim6d (work in progress)         |
+     | pkg.frr.pim6d  | pkg.frr.nopim6d   | builds pim6d (default enabled)          |
      +----------------+-------------------+-----------------------------------------+
 
    * the ``-uc -us`` options to disable signing the packages with your GPG key
diff -urpN frr-frr-8.4.2/doc/developer/packaging-redhat.rst frr-frr-8.5/doc/developer/packaging-redhat.rst
--- frr-frr-8.4.2/doc/developer/packaging-redhat.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/packaging-redhat.rst	2023-03-13 20:01:47.000000000 +0600
@@ -83,6 +83,7 @@ Tested on CentOS 6, CentOS 7, CentOS 8 a
       %{!?with_watchfrr:      %global  with_watchfrr      1 }
       %{!?with_bgp_vnc:       %global  with_bgp_vnc       0 }
       %{!?with_pimd:          %global  with_pimd          1 }
+      %{!?with_pim6d:         %global  with_pim6d         1 }
       %{!?with_rpki:          %global  with_rpki          0 }
 
 8. Build the RPM::
diff -urpN frr-frr-8.4.2/doc/developer/vtysh.rst frr-frr-8.5/doc/developer/vtysh.rst
--- frr-frr-8.4.2/doc/developer/vtysh.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/vtysh.rst	2023-03-13 20:01:47.000000000 +0600
@@ -43,9 +43,14 @@ simplifying the output. This is discusse
 Command Extraction
 ------------------
 
-When VTYSH is built, a Perl script named :file:`extract.pl` searches the FRR
-codebase looking for ``DEFUN``'s. It extracts these ``DEFUN``'s, transforms
-them into ``DEFSH``'s and appends them to ``vtysh_cmd.c``. Each ``DEFSH``
+To build ``vtysh``, the :file:`python/xref2vtysh.py` script scans through the
+:file:`frr.xref` file created earlier in the build process.  This file contains
+a list of all ``DEFUN`` and ``install_element`` sites in the code, generated
+directly from the binaries (and therefore matching exactly what is really
+available.)
+
+This list is collated and transformed into ``DEFSH`` (and ``install_element``)
+statements, output to ``vtysh_cmd.c``. Each ``DEFSH``
 contains the name of the command plus ``_vtysh``, as well as a flag that
 indicates which daemons the command was found in. When the command is executed
 in VTYSH, this flag is inspected to determine which daemons to send the command
@@ -55,6 +60,12 @@ avoiding spurious errors from daemons th
 The extraction script contains lots of hardcoded knowledge about what sources
 to look at and what flags to use for certain commands.
 
+.. note::
+
+   The ``vtysh_scan`` Makefile variable and ``#ifndef VTYSH_EXTRACT_PL``
+   checks in source files are no longer used.  Remove them when rebasing older
+   changes.
+
 .. _vtysh-special-defuns:
 
 Special DEFUNs
@@ -69,7 +80,7 @@ several VTYSH-specific ``DEFUN`` variant
    simply forwarded to the daemons indicated in the daemon flag.
 
 ``DEFUN_NOSH``
-   Used by daemons. Has the same expansion as a ``DEFUN``, but ``extract.pl``
+   Used by daemons. Has the same expansion as a ``DEFUN``, but ``xref2vtysh.py``
    will skip these definitions when extracting commands. This is typically used
    when VTYSH must take some special action upon receiving the command, and the
    programmer therefore needs to write VTYSH's copy of the command manually
diff -urpN frr-frr-8.4.2/doc/developer/workflow.rst frr-frr-8.5/doc/developer/workflow.rst
--- frr-frr-8.4.2/doc/developer/workflow.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/developer/workflow.rst	2023-03-13 20:01:47.000000000 +0600
@@ -139,6 +139,10 @@ March/July/November.  Walking backwards
    version. Once the release is done, whatever updates we make to changelog
    files on the release branch need to be cherry-picked to the master branch.
 
+   Update essential dates in advance for reference table (below) when
+   the next freeze, dev/X.Y, RC, and release phases are scheduled. This should
+   go in the ``master`` branch.
+
  - 2 weeks earlier, a ``frr-X.Y-rc`` release candidate is tagged.
 
      .. code-block:: console
@@ -163,15 +167,29 @@ as early as possible, i.e. the first 2-w
 For reference, the expected release schedule according to the above is:
 
 +---------+------------+------------+------------+------------+------------+
-| Release | 2022-07-05 | 2022-11-01 | 2023-03-07 | 2023-07-04 | 2023-10-31 |
+| Release | 2023-03-07 | 2023-07-04 | 2023-10-31 | 2024-02-27 | 2024-06-25 |
 +---------+------------+------------+------------+------------+------------+
-| RC      | 2022-06-21 | 2022-10-18 | 2023-02-21 | 2023-06-20 | 2023-10-17 |
+| RC      | 2023-02-21 | 2023-06-20 | 2023-10-17 | 2024-02-13 | 2024-06-11 |
 +---------+------------+------------+------------+------------+------------+
-| dev/X.Y | 2022-06-07 | 2022-10-04 | 2023-02-07 | 2023-06-06 | 2023-10-03 |
+| dev/X.Y | 2023-02-07 | 2023-06-06 | 2023-10-03 | 2024-01-30 | 2024-05-28 |
 +---------+------------+------------+------------+------------+------------+
-| freeze  | 2022-05-24 | 2022-09-20 | 2023-01-24 | 2023-05-23 | 2023-09-19 |
+| freeze  | 2023-01-24 | 2023-05-23 | 2023-09-19 | 2024-01-16 | 2024-05-14 |
 +---------+------------+------------+------------+------------+------------+
 
+Here is the hint on how to get the dates easily:
+
+   .. code-block:: console
+
+      ~$ # Last freeze date was 2023-09-19
+      ~$ date +%F --date='2023-09-19 +119 days' # Next freeze date
+      2024-01-16
+      ~$ date +%F --date='2024-01-16 +14 days'  # Next dev/X.Y date
+      2024-01-30
+      ~$ date +%F --date='2024-01-30 +14 days'  # Next RC date
+      2024-02-13
+      ~$ date +%F --date='2024-02-13 +14 days'  # Next Release date
+      2024-02-27
+
 Each release is managed by one or more volunteer release managers from the FRR
 community.  These release managers are expected to handle the branch for a period
 of one year.  To spread and distribute this workload, this should be rotated for
@@ -290,6 +308,21 @@ your changes is usually not required and
 messages by the maintainers. However, you are free to include an update to the
 changelog with some better description.
 
+Accords: non-code community consensus
+=====================================
+
+The FRR repository has a place for "accords" - these are items of
+consideration for FRR that influence how we work as a community, but either
+haven't resulted in code *yet*, or may *never* result in code being written.
+They are placed in the ``doc/accords/`` directory.
+
+The general idea is to simply pass small blurbs of text through our normal PR
+procedures, giving them the same visibility, comment and review mechanisms as
+code PRs - and changing them later is another PR.  Please refer to the README
+file in ``doc/accords/`` for further details.  The file names of items in that
+directory are hopefully helpful in determining whether some of them might be
+relevant to your work.
+
 Submitting Patches and Enhancements
 ===================================
 
@@ -309,6 +342,46 @@ summary of the included patches.  The de
 additional details that will help the reviewer to understand the context
 of the included patches.
 
+Squash commits
+--------------
+
+Before merging make sure a PR has squashed the following kinds of commits:
+
+- Fixes/review feedback
+- Typos
+- Merges and rebases
+- Work in progress
+
+This helps to automatically generate human-readable changelog messages.
+
+Commit Guidelines
+-----------------
+
+There is a built-in commit linter. Basic rules:
+
+- Commit messages must be prefixed with the name of the changed subsystem, followed
+  by a colon and a space and start with an imperative verb.
+
+   `Check <https://github.com/FRRouting/frr/tree/master/.github/commitlint.config.js>`_ all
+   the supported subsystems.
+
+- Commit messages must start with a capital letter
+- Commit messages must not end with a period ``.``
+
+Why was my pull request closed?
+-------------------------------
+
+Pull requests older than 180 days will be closed. Exceptions can be made for
+pull requests that have active review comments, or that are awaiting other
+dependent pull requests. Closed pull requests are easy to recreate, and little
+work is lost by closing a pull request that subsequently needs to be reopened.
+
+We want to limit the total number of pull requests in flight to:
+
+- Maintain a clean project
+- Remove old pull requests that would be difficult to rebase as the underlying code has changed over time
+- Encourage code velocity
+
 .. _license-for-contributions:
 
 License for Contributions
@@ -1275,6 +1348,8 @@ is to correctly set up `LD_LIBRARY_PATH`
 are used.  (On some systems, `libtool` is also available from PATH, but this is
 not always the case.)
 
+.. _cli-workflow:
+
 CLI changes
 -----------
 
@@ -1341,9 +1416,23 @@ the development mailing list / public Sl
 JSON Output
 ^^^^^^^^^^^
 
-* All JSON keys are to be camelCased, with no spaces
+New JSON output in FRR needs to be backed by schema, in particular a YANG model.
+When adding new JSON, first search for an existing YANG model, either in FRR or
+a standard model (e.g., IETF) and use that model as the basis for any JSON
+structure and *especially* for key names and canonical values formats.
+
+If no YANG model exists to support the JSON then an FRR YANG model needs to be
+added to or created to support the JSON format.
+
+* All JSON keys are to be ``camelCased``, with no spaces. YANG modules almost
+  always use ``kebab-case`` (i.e., all lower case with hyphens to separate
+  words), so these identifiers need to be mapped to ``camelCase`` by removing
+  the hyphen (or symbol) and capitalizing the following letter, for
+  example "router-id" becomes "routerId"
 * Commands which output JSON should produce ``{}`` if they have nothing to
   display
+* In general JSON commands include a ``json`` keyword typically at the end of
+  the CLI command (e.g., ``show ip ospf json``)
 
 Use of const
 ^^^^^^^^^^^^
diff -urpN frr-frr-8.4.2/doc/manpages/conf.py frr-frr-8.5/doc/manpages/conf.py
--- frr-frr-8.4.2/doc/manpages/conf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/manpages/conf.py	2023-03-13 20:01:47.000000000 +0600
@@ -114,14 +114,6 @@ version = release.split("-")[0]
 for key, value in replace_vars.items():
     rst_prolog += ".. |{0}| replace:: {1}\n".format(key, value)
 
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
 # There are two options for replacing |today|: either, you set today to some
 # non-false value, then it is used:
 # today = ''
diff -urpN frr-frr-8.4.2/doc/user/basic.rst frr-frr-8.5/doc/user/basic.rst
--- frr-frr-8.4.2/doc/user/basic.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/basic.rst	2023-03-13 20:01:47.000000000 +0600
@@ -617,6 +617,10 @@ Terminal Mode Commands
    usage is printed sequentially. You can specify the daemon's name to print
    only its memory usage.
 
+.. clicmd:: show motd
+
+   Show current motd banner.
+
 .. clicmd:: show history
 
    Dump the vtysh cli history.
diff -urpN frr-frr-8.4.2/doc/user/bfd.rst frr-frr-8.5/doc/user/bfd.rst
--- frr-frr-8.4.2/doc/user/bfd.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/bfd.rst	2023-03-13 20:01:47.000000000 +0600
@@ -353,6 +353,54 @@ The following commands are available ins
    that interface.
 
 
+.. _bfd-static-peer-config:
+
+BFD Static Route Monitoring Configuration
+-----------------------------------------
+
+A monitored static route conditions the installation to the RIB on the
+BFD session running state: when BFD session is up the route is installed
+to RIB, but when the BFD session is down it is removed from the RIB.
+
+The following commands are available inside the configuration node:
+
+.. clicmd:: ip route A.B.C.D/M A.B.C.D bfd [{multi-hop|source A.B.C.D|profile BFDPROF}]
+
+   Configure a static route for ``A.B.C.D/M`` using gateway ``A.B.C.D`` and use
+   the gateway address as BFD peer destination address.
+
+.. clicmd:: ipv6 route X:X::X:X/M [from X:X::X:X/M] X:X::X:X bfd [{multi-hop|source X:X::X:X|profile BFDPROF}]
+
+   Configure a static route for ``X:X::X:X/M`` using gateway
+   ``X:X::X:X`` and use the gateway address as BFD peer destination
+   address.
+
+The static routes when uninstalled will no longer show up in the output of
+the command ``show ip route`` or ``show ipv6 route``, instead we must use the
+BFD static route show command to see these monitored route status.
+
+.. clicmd:: show bfd static route [json]
+
+   Show all monitored static routes and their status.
+
+   Example output:
+
+   ::
+
+      Showing BFD monitored static routes:
+
+        Route groups:
+          rtg1 peer 172.16.0.1 (status: uninstalled):
+              2001:db8::100/128
+
+      Next hops:
+        VRF default IPv4 Unicast:
+            192.168.100.0/24 peer 172.16.0.1 (status: uninstalled)
+
+        VRF default IPv4 Multicast:
+
+        VRF default IPv6 Unicast:
+
 .. _bfd-configuration:
 
 Configuration
diff -urpN frr-frr-8.4.2/doc/user/bgp.rst frr-frr-8.5/doc/user/bgp.rst
--- frr-frr-8.4.2/doc/user/bgp.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/bgp.rst	2023-03-13 20:01:47.000000000 +0600
@@ -148,6 +148,12 @@ bottom until one of the factors can be u
 
    Prefer higher local preference routes to lower.
 
+   If ``bgp bestpath aigp`` is enabled, and both paths that are compared have
+   AIGP attribute, BGP uses AIGP tie-breaking unless both of the paths have the
+   AIGP metric attribute. This means that the AIGP attribute is not evaluated
+   during the best path selection process between two paths when one path does
+   not have the AIGP attribute.
+
 3. **Local route check**
 
    Prefer local routes (statics, aggregates, redistributed) to received routes.
@@ -401,6 +407,17 @@ Route Selection
    paths learned from any of eBGP, iBGP, or confederation neighbors will
    be multipath if they are otherwise considered equal cost.
 
+.. clicmd:: bgp bestpath aigp
+
+   Use the bgp bestpath aigp command to evaluate the AIGP attribute during
+   the best path selection process between two paths that have the AIGP
+   attribute.
+
+   When bgp bestpath aigp is disabled, BGP does not use AIGP tie-breaking
+   rules unless paths have the AIGP attribute.
+
+   Disabled by default.
+
 .. clicmd:: maximum-paths (1-128)
 
    Sets the maximum-paths value used for ecmp calculations for this
@@ -1035,7 +1052,7 @@ Long-lived Graceful Restart
 Currently, only restarter mode is supported. This capability is advertised only
 if graceful restart capability is negotiated.
 
-.. clicmd:: bgp long-lived-graceful-restart stale-time (1-4294967295)
+.. clicmd:: bgp long-lived-graceful-restart stale-time (1-16777215)
 
    Specifies the maximum time to wait before purging long-lived stale routes for
    helper routers.
@@ -1670,6 +1687,35 @@ Configuring Peers
    turning on this command will allow BGP to install v4 routes with
    v6 nexthops if you do not have v4 configured on interfaces.
 
+.. clicmd:: neighbor <A.B.C.D|X:X::X:X|WORD> accept-own
+
+   Enable handling of self-originated VPN routes containing ``accept-own`` community.
+
+   This feature allows you to handle self-originated VPN routes, which a BGP speaker
+   receives from a route-reflector. A 'self-originated' route is one that was
+   originally advertised by the speaker itself. As per :rfc:`4271`, a BGP speaker rejects
+   advertisements that originated the speaker itself. However, the BGP ACCEPT_OWN
+   mechanism enables a router to accept the prefixes it has advertised, when reflected
+   from a route-reflector that modifies certain attributes of the prefix.
+
+   A special community called ``accept-own`` is attached to the prefix by the
+   route-reflector, which is a signal to the receiving router to bypass the ORIGINATOR_ID
+   and NEXTHOP/MP_REACH_NLRI check.
+
+   Default: disabled.
+
+.. clicmd:: neighbor <A.B.C.D|X:X::X:X|WORD> path-attribute discard (1-255)...
+
+   Drops specified path attributes from BGP UPDATE messages from the specified neighbor.
+
+   If you do not want specific attributes, you can drop them using this command, and
+   let the BGP proceed by ignoring those attributes.
+
+.. clicmd:: neighbor <A.B.C.D|X:X::X:X|WORD> graceful-shutdown
+
+   Mark all routes from this neighbor as less preferred by setting ``graceful-shutdown``
+   community, and local-preference to 0.
+
 .. clicmd:: bgp fast-external-failover
 
    This command causes bgp to take down ebgp peers immediately
@@ -1781,6 +1827,13 @@ Configuring Peers
    with lower holdtime less than configured minimum holdtime.
    When this command is not set, minimum holdtime does not work.
 
+.. clicmd:: bgp tcp-keepalive (1-65535) (1-65535) (1-30)
+
+   This command allows user to configure TCP keepalive with new BGP peers.
+   Each parameter respectively stands for TCP keepalive idle timer (seconds),
+   interval (seconds), and maximum probes. By default, TCP keepalive is
+   disabled.
+
 Displaying Information about Peers
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
@@ -2372,9 +2425,9 @@ in AS 7675, the announced routes' local
 
 The following configuration is an example of BGP route filtering using
 communities attribute. This configuration only permit BGP routes which has BGP
-communities value ``0:80`` or ``0:90``. The network operator can set special
-internal communities value at BGP border router, then limit the BGP route
-announcements into the internal network.
+communities value (``0:80`` and ``0:90``) or ``0:100``. The network operator can
+set special internal communities value at BGP border router, then limit the
+BGP route announcements into the internal network.
 
 .. code-block:: frr
 
@@ -2385,6 +2438,7 @@ announcements into the internal network.
     exit-address-family
    !
    bgp community-list 1 permit 0:80 0:90
+   bgp community-list 1 permit 0:100
    !
    route-map RMAP permit in
     match community 1
@@ -2888,6 +2942,23 @@ L3VPN SRv6
    Specify the SRv6 locator to be used for SRv6 L3VPN. The Locator name must
    be set in zebra, but user can set it in any order.
 
+General configuration
+^^^^^^^^^^^^^^^^^^^^^
+
+Configuration of the SRv6 SID used to advertise a L3VPN for both IPv4 and IPv6
+is accomplished via the following command in the context of a VRF:
+
+.. clicmd:: sid vpn per-vrf export (1..1048575)|auto
+
+   Enables a SRv6 SID to be attached to a route exported from the current
+   unicast VRF to VPN. A single SID is used for both IPv4 and IPv6 address
+   families. If you want to set a SID for only IPv4 address family or IPv6
+   address family, you need to use the command ``sid vpn export (1..1048575)|auto``
+   in the context of an address-family. If the value specified is ``auto``,
+   the SID value is automatically assigned from a pool maintained by the Zebra
+   daemon. If Zebra is not running, or if this command is not configured, automatic
+   SID assignment will not complete, which will block corresponding route export.
+
 .. _bgp-evpn:
 
 Ethernet Virtual Network - EVPN
@@ -2911,6 +2982,39 @@ sysctl configurations:
 
 For more information, see ``man 7 arp``.
 
+.. _bgp-enabling-evpn:
+
+Enabling EVPN
+^^^^^^^^^^^^^
+
+EVPN should be enabled on the BGP instance corresponding to the VRF acting as
+the underlay for the VXLAN tunneling. In most circumstances this will be the
+default VRF. The command to enable EVPN for a BGP instance is
+``advertise-all-vni`` which lives under ``address-family l2vpn evpn``:
+
+.. code-block:: frr
+
+   router bgp 65001
+    !
+    address-family l2vpn evpn
+     advertise-all-vni
+
+A more comprehensive configuration example can be found in the :ref:`evpn` page.
+
+.. _bgp-evpn-l3-route-targets:
+
+EVPN L3 Route-Targets
+^^^^^^^^^^^^^^^^^^^^^
+
+.. clicmd:: route-target <import|export|both> <RTLIST|auto>
+
+Modify the route-target set for EVPN advertised type-2/type-5 routes.
+RTLIST is a list of any of matching
+``(A.B.C.D:MN|EF:OPQR|GHJK:MN|*:OPQR|*:MN)`` where ``*`` indicates wildcard
+matching for the AS number. It will be set to match any AS number. This is
+useful in datacenter deployments with Downstream VNI. ``auto`` is used to
+retain the autoconfigure that is default behavior for L3 RTs.
+
 .. _bgp-evpn-advertise-pip:
 
 EVPN advertise-PIP
@@ -3488,6 +3592,10 @@ Debugging
    library messages and BGP BFD integration messages that are mostly state
    transitions and validation problems.
 
+.. clicmd:: debug bgp conditional-advertisement
+
+   Enable or disable debugging of BGP conditional advertisement.
+
 .. clicmd:: debug bgp neighbor-events
 
    Enable or disable debugging for neighbor events. This provides general
@@ -3642,6 +3750,16 @@ The following command is available in ``
    the startup configuration, graceful shutdown will remain in effect
    across restarts of *bgpd* and will need to be explicitly disabled.
 
+.. clicmd:: bgp input-queue-limit (1-4294967295)
+
+   Set the BGP Input Queue limit for all peers when messaging parsing. Increase
+   this only if you have the memory to handle large queues of messages at once.
+
+.. clicmd:: bgp output-queue-limit (1-4294967295)
+
+   Set the BGP Output Queue limit for all peers when messaging parsing. Increase
+   this only if you have the memory to handle large queues of messages at once.
+
 .. _bgp-displaying-bgp-information:
 
 Displaying BGP Information
@@ -3727,6 +3845,28 @@ structure is extended with :clicmd:`show
 
 .. clicmd:: show bgp [afi] [safi] [all] [wide|json]
 
+.. clicmd:: show bgp vrfs [<VRFNAME$vrf_name>] [json]
+
+   The command displays all bgp vrf instances basic info like router-id,
+   configured and established neighbors,
+   evpn related basic info like l3vni, router-mac, vxlan-interface.
+   User can get that information as JSON format when ``json`` keyword
+   at the end of cli is presented.
+
+   .. code-block:: frr
+
+      torc-11# show bgp vrfs
+      Type  Id     routerId          #PeersCfg  #PeersEstb  Name
+                   L3-VNI            RouterMAC              Interface
+      DFLT  0      17.0.0.6          3          3           default
+                   0                 00:00:00:00:00:00      unknown
+       VRF  21     17.0.0.6          0          0           sym_1
+                   8888              34:11:12:22:22:01      vlan4034_l3
+       VRF  32     17.0.0.6          0          0           sym_2
+                   8889              34:11:12:22:22:01      vlan4035_l3
+
+      Total number of VRFs (including default): 3
+
 .. clicmd:: show bgp [<ipv4|ipv6> <unicast|multicast|vpn|labeled-unicast|flowspec> | l2vpn evpn]
 
    These commands display BGP routes for the specific routing table indicated by
@@ -3737,6 +3877,10 @@ structure is extended with :clicmd:`show
 
    EVPN prefixes can also be filtered by EVPN route type.
 
+.. clicmd:: show bgp vni <all|VNI> [vtep VTEP] [type <ead|1|macip|2|multicast|3>] [<detail|json>]
+
+   Display per-VNI EVPN routing table in bgp. Filter route-type, vtep, or VNI.
+
 .. clicmd:: show bgp [afi] [safi] [all] summary [json]
 
    Show a bgp peer summary for the specified address family, and subsequent
@@ -3772,7 +3916,7 @@ structure is extended with :clicmd:`show
    The ``terse`` option can be used in combination with the remote-as, neighbor,
    failed and established filters, and with the ``wide`` option as well.
 
-.. clicmd:: show bgp [afi] [safi] [neighbor [PEER] [routes|advertised-routes|received-routes] [json]
+.. clicmd:: show bgp [afi] [safi] [neighbor [PEER] [routes|advertised-routes|received-routes] [detail] [json]
 
    This command shows information on a specific BGP peer of the relevant
    afi and safi selected.
@@ -3787,6 +3931,13 @@ structure is extended with :clicmd:`show
    The ``received-routes`` keyword displays all routes belonging to this
    address-family (prior to inbound policy) that were received by this peer.
 
+   If ``detail`` option is specified, the detailed version of all routes
+   will be displayed. The same format as ``show [ip] bgp [afi] [safi] PREFIX``
+   will be used, but for the whole table of received, advertised or filtered
+   prefixes.
+
+   If ``json`` option is specified, output is displayed in JSON format.
+
 .. clicmd:: show bgp [<view|vrf> VIEWVRFNAME] [afi] [safi] neighbors PEER received prefix-filter [json]
 
    Display Address Prefix ORFs received from this peer.
@@ -3879,7 +4030,7 @@ structure is extended with :clicmd:`show
 
    If the ``json`` option is specified, output is displayed in JSON format.
 
-.. clicmd:: show [ip] bgp [afi] [safi] [all] neighbors A.B.C.D [advertised-routes|received-routes|filtered-routes] [json|wide]
+.. clicmd:: show [ip] bgp [afi] [safi] [all] neighbors A.B.C.D [advertised-routes|received-routes|filtered-routes] [detail] [json|wide]
 
    Display the routes advertised to a BGP neighbor or received routes
    from neighbor or filtered routes received from neighbor based on the
@@ -3896,8 +4047,24 @@ structure is extended with :clicmd:`show
    if afi is specified, with ``all`` option, routes will be displayed for
    each SAFI in the selcted AFI
 
+   If ``detail`` option is specified, the detailed version of all routes
+   will be displayed. The same format as ``show [ip] bgp [afi] [safi] PREFIX``
+   will be used, but for the whole table of received, advertised or filtered
+   prefixes.
+
    If ``json`` option is specified, output is displayed in JSON format.
 
+.. clicmd:: show [ip] bgp [afi] [safi] [all] detail-routes
+
+   Display the detailed version of all routes. The same format as using
+   ``show [ip] bgp [afi] [safi] PREFIX``, but for the whole BGP table.
+
+   If ``all`` option is specified, ``ip`` keyword is ignored and,
+   routes displayed for all AFIs and SAFIs.
+
+   If ``afi`` is specified, with ``all`` option, routes will be displayed for
+   each SAFI in the selected AFI.
+
 .. _bgp-display-routes-by-community:
 
 Displaying Routes by Community Attribute
@@ -4054,6 +4221,25 @@ Displaying Update Group Information
 
    Display Information about update-group events in FRR.
 
+Displaying Nexthop Information
+------------------------------
+.. clicmd:: show [ip] bgp [<view|vrf> VIEWVRFNAME] nexthop ipv4 [A.B.C.D] [detail] [json]
+
+.. clicmd:: show [ip] bgp [<view|vrf> VIEWVRFNAME] nexthop ipv6 [X:X::X:X] [detail] [json]
+
+.. clicmd:: show [ip] bgp [<view|vrf> VIEWVRFNAME] nexthop [<A.B.C.D|X:X::X:X>] [detail] [json]
+
+.. clicmd:: show [ip] bgp <view|vrf> all nexthop [json]
+
+   Display information about nexthops to bgp neighbors. If a certain nexthop is
+   specified, also provides information about paths associated with the nexthop.
+   With detail option provides information about gates of each nexthop.
+
+.. clicmd:: show [ip] bgp [<view|vrf> VIEWVRFNAME] import-check-table [detail] [json]
+
+   Display information about nexthops from table that is used to check network's
+   existence in the rib for network statements.
+
 Segment-Routing IPv6
 --------------------
 
diff -urpN frr-frr-8.4.2/doc/user/conf.py frr-frr-8.5/doc/user/conf.py
--- frr-frr-8.4.2/doc/user/conf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/conf.py	2023-03-13 20:01:47.000000000 +0600
@@ -117,14 +117,6 @@ version = release.split("-")[0]
 for key, value in replace_vars.items():
     rst_prolog += ".. |{0}| replace:: {1}\n".format(key, value)
 
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
 # There are two options for replacing |today|: either, you set today to some
 # non-false value, then it is used:
 # today = ''
diff -urpN frr-frr-8.4.2/doc/user/evpn.rst frr-frr-8.5/doc/user/evpn.rst
--- frr-frr-8.4.2/doc/user/evpn.rst	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/user/evpn.rst	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,530 @@
+.. _evpn:
+
+****
+EVPN
+****
+
+:abbr:`EVPN` stands for Ethernet Virtual Private Network. This is an extension
+of BGP that enables the signaling of bridged (L2) and routed (L3) VPNs over a
+common network. EVPN is described in :rfc:`7432` and is updated by several
+additional RFCs and IETF drafts including :rfc:`9135` (Integrated Routing
+and Bridging in Ethernet VPN), :rfc:`9136` (IP Prefix Advertisement in Ethernet
+VPN), :rfc:`8584` (Framework for Ethernet VPN Designated Forwarder Election
+Extensibility), and :rfc:`8365` (A Network Virtualization Overlay Solution Using
+Ethernet VPN). FRR supports All-Active Layer-2 Multihoming for devices (MHD) via
+LACP Ethernet Segments as well as both Symmetric and Asymmetric IRB.
+FRR implements MAC-VRFs using a "VLAN-Based Service Interface" (:rfc:`7432`)
+and performs processing of Symmetric IRB routes following the
+"Interface-less IP-VRF-to-IP-VRF Model" (:rfc:`9136`).
+
+.. _evpn-concepts:
+
+EVPN Concepts
+=============
+BGP-EVPN is the control plane for the transport of Ethernet frames, regardless
+of whether those frames are bridged or routed. In the case of a VLAN-Based
+Service Interface with VXLAN encap, a single VNI is used to represent an EVPN
+Instance (EVI) and will have its own Route Distinguisher and set of
+Import/Export Route-Targets.
+
+A VNI is considered to be either Layer-2 (tied to a MAC-VRF) or Layer-3
+(tied to an IP-VRF), which indicates what kind of information is represented by
+the VRF. An IP-VRF represents a routing table (operating in much the same way as
+a VRF traditionally operates in L3VPN), while a MAC-VRF represents a bridging
+table i.e. MAC (fdb) and ARP/NDP entries.
+
+A MAC-VRF can be thought of as a VLAN with or without an SVI associated with it.
+An SVI is a Layer-3 interface bound to a bridging domain. In Linux an SVI can
+either be a traditional bridge or a VLAN subinterface of a VLAN-aware bridge.
+If there is an SVI for the VLAN, ARP/NDP entries can be bound to the MACs within
+the broadcast domain. Without an SVI, the VLAN operates in traditional L2
+fashion and MACs are the only type of host addresses known within the VLAN.
+
+In the same way that there can be a many-to-one relationship of SVIs to a VRF,
+there can also be a many-to-one relationship of MAC-VRFs (L2VNIs) to an IP-VRF
+(L3VNI). In FRR the L3VNI association for an L2VNI is determined by the
+presence of an SVI for the VLAN and the VRF membership of the SVI.
+If an L2VNI does not have an SVI or its SVI is not enslaved to a VRF, the L2VNI
+will be associated with the "default" VRF. If an L2VNI has an SVI whose master
+device is a VRF, then that L2VNI will be associated with its master VRF.
+
+.. _evpn-frr-configuration:
+
+FRR Configuration
+=================
+FRR learns about the system's Linux network interface configuration from the
+kernel via Netlink, however it does not manage network interfaces directly.
+The following sections will include examples of Linux interface configurations
+that are compatible with FRR's EVPN implementation. While there are multiple
+interface managers that can setup a proper kernel config (e.g. ifupdown2),
+these examples will use iproute2 to add/configure the interfaces.
+
+All of the examples will follow the same basic setup but use different, yet
+compatible, interface configurations.
+
+In this example we will setup the following:
+
+* An IP-VRF named vrf1, associated with L3VNI 100
+* An IP-VRF named vrf2, associated with L3VNI 200
+* An IP-VRF named vrf3, with no L3VNI associations
+* A MAC-VRF using VLAN 10, associated with L2VNI 110 and IP-VRF vrf1
+* A MAC-VRF using VLAN 20, associated with L2VNI 220 and IP-VRF vrf2
+* A MAC-VRF using VLAN 30, associated with L2VNI 330 and IP-VRF vrf3
+* A MAC-VRF using VLAN 40, associated with L2VNI 440 and IP-VRF default
+* A MAC-VRF using VLAN 50, associated with L2VNI 550 and operating L2-Only
+
+.. _evpn-sample-configuration:
+
+Sample Configuration
+--------------------
+This is a sample FRR configuration that implements the above EVPN environment.
+The first snippet will be the config in its entiretly, then each config element
+will be explained individually later in the document.
+
+The following snippet will result in a functional EVPN control plane if the
+corresponding Linux interface configuration is correct, compatible, and active:
+
+.. code-block:: frr
+
+   vrf vrf1
+    vni 100
+   exit-vrf
+   !
+   vrf vrf2
+    vni 200
+   exit-vrf
+   !
+   router bgp 4200000000
+    neighbor 192.168.122.12 remote-as internal
+    !
+    address-family ipv4 unicast
+     network 100.64.0.1/32
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     neighbor 192.168.122.12 activate
+     advertise-all-vni
+     advertise-svi-ip
+    exit-address-family
+   exit
+   !
+   router bgp 4200000000 vrf vrf1
+    !
+    address-family ipv4 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family ipv6 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     advertise ipv4 unicast
+     advertise ipv6 unicast
+    exit-address-family
+   exit
+   !
+   router bgp 4200000000 vrf vrf2
+    !
+    address-family ipv4 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family ipv6 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     advertise ipv4 unicast
+     advertise ipv6 unicast
+    exit-address-family
+   exit
+
+A VRF will get its L3VNI association as a result of the ``vni`` command under
+the ``vrf`` stanza. Until this L3VNI association is made, zebra will discover
+the VNI from netlink but will consider it to be an L2VNI. The current L2 vs L3
+context of a VNI can be seen in the output of ``show evpn vni``.
+
+In this configuration we are telling zebra to consider VXLAN-ID 100 to be the
+L3VNI for vrf1 and VXLAN-ID 200 to be the L3VNI for vrf2.
+
+.. code-block:: frr
+
+   vrf vrf1
+    vni 100
+   exit-vrf
+   !
+   vrf vrf2
+    vni 200
+   exit-vrf
+
+The VTEP-IP (100.64.0.1) needs to be reachable by other VTEPs in the EVPN
+environment in order for VXLAN decapsulation to function. In this example we
+will advertise our local VTEP-IP using BGP (via the ``network`` statement), but
+static routes or other routing protocols like IS-IS or OSPF can also be used.
+
+In order to enable EVPN for a BGP instance, we must use the command
+``advertise-all-vni``. In this example we will be using the default VRF to
+carry the l2vpn evpn address-family, so we will enable EVPN for the default VRF.
+
+In this example, we plan to exchange EVPN routes with 192.168.122.12, so we
+will activate the l2vpn evpn address-family for this peer in order to allow
+EVPN NLRI to be advertised and received.
+
+The ``advertise-svi-ip`` command also belongs in the BGP instance where EVPN is
+enabled. This command tells FRR to originate "self" Type-2 routes for all the
+MAC/IP pairs associated with the local SVI interfaces.
+
+.. code-block:: frr
+
+   router bgp 4200000000
+    neighbor 192.168.122.12 remote-as internal
+    !
+    address-family ipv4 unicast
+     network 100.64.0.1/32
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     neighbor 192.168.122.12 activate
+     advertise-all-vni
+     advertise-svi-ip
+    exit-address-family
+   exit
+
+IPv4 and IPv6 BGP Prefixes from an IP-VRF are not exported to EVPN as Type-5
+routes until the respective ``advertise <afi> unicast`` command has been
+configured in the BGP instance of the VRF in question. All routes in the BGP
+RIB (locally originated, learned from a peer, or leaked from another VRF) will
+be eligible to be exported to EVPN so long as they are valid and selected in
+the VRF's unicast table.
+
+In this example, the BGP instances for vrf1 and vrf2 will have their static
+routes redistributed into the BGP loc-rib for the ipv4 unicast and ipv6 unicast
+address-families via the ``redistribute static`` statements. These unicast
+prefixes will then be exported into EVPN as Type-5 routes as a result of the
+``advertise ipv4 unicast`` and ``advertise ipv6 unicast`` commands.
+
+.. code-block:: frr
+
+   router bgp 4200000000 vrf vrf1
+    !
+    address-family ipv4 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family ipv6 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     advertise ipv4 unicast
+     advertise ipv6 unicast
+    exit-address-family
+   exit
+   !
+   router bgp 4200000000 vrf vrf2
+    !
+    address-family ipv4 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family ipv6 unicast
+     redistribute static
+    exit-address-family
+    !
+    address-family l2vpn evpn
+     advertise ipv4 unicast
+     advertise ipv6 unicast
+    exit-address-family
+   exit
+
+.. _evpn-linux-interface-configuration:
+
+Linux Interface Configuration
+=============================
+The Linux kernel offers several options for configuring netdevices for an
+EVPN-VXLAN environment. The following section will include samples of a few
+netdev configurations that are compatible with FRR which implement the
+environment described above.
+
+Some high-level config considerations:
+
+* The local VTEP-IP should always be set to a reachable IP on the lo device.
+* An L3VNI should always have an SVI (aka the L3-SVI).
+* An L3-SVI should not be assigned an IP address, link-local or otherwise.
+
+  * IPv6 address autoconfiguration can be disabled via ``addrgenmode none``.
+
+* An SVI for an L2VNI is only needed for routing (IRB) or ARP/ND suppression.
+
+  * ARP/ND suppression is a kernel function, it is not managed by FRR.
+  * ARP/ND suppression is enabled per bridge_slave via ``neigh_suppress``.
+  * ARP/ND suppression should only be enabled on vxlan interfaces.
+  * IPv4/IPv6 forwarding should be disabled on SVIs not used for routing (IRB).
+
+* Dynamic MAC/VTEP learning should be disabled on VXLAN interfaces used in EVPN.
+
+  * Dynamic MAC learning is a function of the kernel bridge driver, not FRR.
+  * Dynamic MAC learning is toggled per bridge_slave via ``learning {on|off}``.
+  * Dynamic VTEP learning is a function of the kernel vxlan driver, not FRR.
+  * Dynamic VTEP learning is toggled per vxlan interface via ``[no]learning``.
+
+* The VXLAN interfaces should not have a ``remote`` VTEP defined.
+
+  * Remote VTEPs are learned via EVPN, so static VTEPs are unnecessary.
+
+.. _evpn-traditional-bridge-traditional-vxlan-devices:
+
+Traditional Bridges and Traditional VXLAN Devices
+-------------------------------------------------
+In the traditional bridge model, we use a separate ``bridge`` interface per
+MAC-VRF which acts as the SVI for that broadcast domain. A bridge is considered
+"traditional" if ``vlan_filtering`` is set to ``0`` (disabled) which indicates
+the bridge only has one broadcast domain which does not consider VLAN tags.
+Similarly, only one VNI is carried by each "traditional" ``vxlan`` interface.
+So in this deployment model, each VXLAN-enabled broadcast domain will have one
+traditional vxlan interface enslaved to one traditional bridge.
+
+Bridges created for an L3VNI broadcast domain should only have one member: the
+L3VNI vxlan device. Bridges created for an L2VNI broadcast domain generally
+have multiple members: the L2VNI vxlan device, plus any host/network ports
+where the L2 domain will be carried.
+
+To carry the broadcast domains of multiple traditional bridges over the same
+host/network port, a tagged ``vlan`` sub-interface of the port must be created
+per broadcast domain. The vlan sub-interfaces would then be enslaved to the
+traditional bridge, ensuring that only packets tagged with the expected VID are
+associated with the expected broadcast domain.
+
+.. code-block:: shell
+
+   ###################
+   ## vxlan vtep-ip ##
+   ###################
+   ip addr add 100.64.0.1/32 dev lo
+
+   #############################
+   ## ip-vrf vrf1 / l3vni 100 ##
+   #############################
+   ip link add vrf1 type vrf table 1100
+   ip link set vrf1 up
+   ip link add br100 type bridge
+   ip link set br100 master vrf1 addrgenmode none
+   ip link set br100 addr aa:bb:cc:00:00:64
+   ip link add vni100 type vxlan local 100.64.0.1 dstport 4789 id 100 nolearning
+   ip link set vni100 master br100 addrgenmode none
+   ip link set vni100 type bridge_slave neigh_suppress on learning off
+   ip link set vni100 up
+   ip link set br100 up
+
+   #############################
+   ## ip-vrf vrf2 / l3vni 200 ##
+   #############################
+   ip link add vrf2 type vrf table 1200
+   ip link set vrf2 up
+   ip link add br200 type bridge
+   ip link set br200 master vrf2 addrgenmode none
+   ip link set br200 addr aa:bb:cc:00:00:c8
+   ip link add vni200 type vxlan local 100.64.0.1 dstport 4789 id 200 nolearning
+   ip link set vni200 master br200 addrgenmode none
+   ip link set vni200 type bridge_slave neigh_suppress on learning off
+   ip link set vni200 up
+   ip link set br200 up
+
+   #################
+   ## ip-vrf vrf3 ##
+   #################
+   ip link add vrf3 type vrf table 1300
+   ip link set vrf3 up
+
+   ###############
+   ## l2vni 110 ##
+   ###############
+   ip link add br10 type bridge
+   ip link set br10 master vrf1
+   ip link set br10 addr aa:bb:cc:00:00:6e
+   ip addr add 10.0.10.1/24 dev br10
+   ip addr add 2001:db8:0:10::1/64 dev br10
+   ip link add vni110 type vxlan local 100.64.0.1 dstport 4789 id 110 nolearning
+   ip link set vni110 master br10 addrgenmode none
+   ip link set vni110 type bridge_slave neigh_suppress on learning off
+   ip link set vni110 up
+   ip link set br10 up
+
+   ###############
+   ## l2vni 220 ##
+   ###############
+   ip link add br20 type bridge
+   ip link set br20 master vrf2
+   ip link set br20 addr aa:bb:cc:00:00:dc
+   ip addr add 10.0.20.1/24 dev br20
+   ip addr add 2001:db8:0:20::1/64 dev br20
+   ip link add vni220 type vxlan local 100.64.0.1 dstport 4789 id 220 nolearning
+   ip link set vni220 master br20 addrgenmode none
+   ip link set vni220 type bridge_slave neigh_suppress on learning off
+   ip link set vni220 up
+   ip link set br20 up
+
+   ###############
+   ## l2vni 330 ##
+   ###############
+   ip link add br30 type bridge
+   ip link set br30 master vrf3
+   ip link set br30 addr aa:bb:cc:00:01:4a
+   ip addr add 10.0.30.1/24 dev br30
+   ip addr add 2001:db8:0:30::1/64 dev br30
+   ip link add vni330 type vxlan local 100.64.0.1 dstport 4789 id 330 nolearning
+   ip link set vni330 master br30 addrgenmode none
+   ip link set vni330 type bridge_slave neigh_suppress on learning off
+   ip link set vni330 up
+   ip link set br30 up
+
+   ###############
+   ## l2vni 440 ##
+   ###############
+   ip link add br40 type bridge
+   ip link set br40 addr aa:bb:cc:00:01:b8
+   ip addr add 10.0.40.1/24 dev br40
+   ip addr add 2001:db8:0:40::1/64 dev br40
+   ip link add vni440 type vxlan local 100.64.0.1 dstport 4789 id 440 nolearning
+   ip link set vni440 master br40 addrgenmode none
+   ip link set vni440 type bridge_slave neigh_suppress on learning off
+   ip link set vni440 up
+   ip link set br40 up
+
+   ###############
+   ## l2vni 550 ##
+   ###############
+   ip link add br50 type bridge
+   ip link set br50 addrgenmode none
+   ip link set br50 addr aa:bb:cc:00:02:26
+   ip link add vni550 type vxlan local 100.64.0.1 dstport 4789 id 550 nolearning
+   ip link set vni550 master br50 addrgenmode none
+   ip link set vni550 type bridge_slave neigh_suppress on learning off
+   sysctl -w net.ipv4.conf.br50.forwarding=0
+   sysctl -w net.ipv6.conf.br50.forwarding=0
+   ip link set vni550 up
+   ip link set br50 up
+
+   ##################
+   ## create vlan subinterface of eth0 for each l2vni vlan and enslave each
+   ## subinterface to the corresponding bridge
+   ##################
+   ip link set eth0 up
+   for i in 10 20 30 40 50; do
+      ip link add link eth0 name eth0.$i type vlan id $i;
+      ip link set eth0.$i master br$i;
+      ip link set eth0.$i up;
+   done
+
+
+To begin with, it creates a ``vrf`` interface named "vrf1" that is bound to the
+kernel routing table with ID 1100. This will represent the IP-VRF "vrf1" which
+we will later allocate an L3VNI for.
+
+.. code-block:: shell
+
+   ip link add vrf1 type vrf table 1100
+
+This block creates a traditional ``bridge`` interface named "br100", binds it to
+the VRF named "vrf1", disables IPv6 address autoconfiguration, and statically
+defines the MAC address of "br100". This traditional bridge is used for the
+L3VNI broadcast domain mapping to VRF "vrf1", i.e. "br100" is vrf1's L3-SVI.
+
+.. code-block:: shell
+
+   ip link add br100 type bridge
+   ip link set br100 master vrf1 addrgenmode none
+   ip link set br100 addr aa:bb:cc:00:00:64
+
+Here a traditional ``vxlan`` interface is created with the name "vni100" which
+uses a VTEP-IP of 100.64.0.1, carries VNI 100, and has Dynamic VTEP learning
+disabled. IPv6 address autoconfiguration is disabled for "vni100", then the
+interface is enslaved to "br100", ARP/ND suppression is enabled, and Dynamic
+MAC Learning is disabled.
+
+.. code-block:: shell
+
+   ip link add vni100 type vxlan local 100.64.0.1 dstport 4789 id 100 nolearning
+   ip link set vni100 master br100 addrgenmode none
+   ip link set vni100 type bridge_slave neigh_suppress on learning off
+
+This completes the necessary configuration for a VRF and L3VNI.
+
+Here a traditional bridge named "br10" is created. We add "br10" to "vrf1" by
+setting "vrf1" as the ``master`` of "br10". It is not necessary to set the SVI
+MAC statically, but it is done here for consistency's sake. Since "br10" will
+be used for routing, IPv4 and IPv6 addresses are also added to the SVI.
+
+.. code-block:: shell
+
+   ip link add br10 type bridge
+   ip link set br10 master vrf1
+   ip link set br10 addr aa:bb:cc:00:00:6e
+   ip addr add 10.0.10.1/24 dev br10
+   ip addr add 2001:db8:0:10::1/64 dev br10
+
+If the SVI will not be used for routing, IP addresses should not be assigned to
+the SVI interface and IPv4/IPv6 "forwarding" should be disabled for the SVI via
+the appropriate sysctl nodes.
+
+.. code-block:: shell
+
+   sysctl -w net.ipv4.conf.<ifname>.forwarding=0
+   sysctl -w net.ipv6.conf.<ifname>.forwarding=0
+
+The following commands create a ``vxlan`` interface for VNI 100. Other than the
+VNI, The interface settings are the same for an L2VNI as they are for an L3VNI.
+
+.. code-block:: shell
+
+   ip link add vni110 type vxlan local 100.64.0.1 dstport 4789 id 110 nolearning
+   ip link set vni110 master br10 addrgenmode none
+   ip link set vni110 type bridge_slave neigh_suppress on learning off
+
+Finally, to limit a traditional bridge's broadcast domain to traffic matching
+specific VLAN-IDs, ``vlan`` subinterfaces of a host/network port need to be
+setup. This example shows the creation of a VLAN subinterface of "eth0"
+matching VID 10 with the name "eth0.10". By enslaving "eth0.10" to "br10"
+(instead of "eth0") we ensure that only Ethernet frames ingressing "eth0"
+tagged with VID 10 will be associated with the "br10" broadcast domain.
+
+.. code-block:: shell
+
+      ip link add link eth0 name eth0.10 type vlan id 10
+      ip link set eth0.10 master br10
+
+If you do not want to restrict the broadcast domain by VLAN-ID, you can skip
+the creation of the VLAN subinterfaces and directly enslave "eth0" to "br10".
+
+.. code-block:: shell
+
+      ip link set eth0 master br10
+
+This completes the necessary configuration for an L2VNI.
+
+Displaying EVPN information
+---------------------------
+
+.. clicmd:: show evpn mac vni (1-16777215) detail [json]
+
+   Display detailed information about MAC addresses for
+   a specified VNI.
+
+.. clicmd:: show vrf [<NAME$vrf_name|all$vrf_all>] vni [json]
+
+   Displays VRF to L3VNI mapping. It also displays L3VNI associated
+   router-mac, svi interface and vxlan interface.
+   User can get that information as JSON format when ``json`` keyword
+   at the end of cli is presented.
+
+   .. code-block:: frr
+
+      tor2# show vrf vni
+      VRF                                   VNI        VxLAN IF             L3-SVI               State Rmac
+      sym_1                                 9288       vxlan21              vlan210_l3           Up    21:31:36:ff:ff:20
+      sym_2                                 9289       vxlan21              vlan210_l3           Up    21:31:36:ff:ff:20
+      sym_3                                 9290       vxlan21              vlan210_l3           Up    21:31:36:ff:ff:20
+      tor2# show vrf sym_1 vni
+      VRF                                   VNI        VxLAN IF             L3-SVI               State Rmac
+      sym_1                                 9288       vxlan21              vlan210_l3           Up    44:38:36:ff:ff:20
diff -urpN frr-frr-8.4.2/doc/user/index.rst frr-frr-8.5/doc/user/index.rst
--- frr-frr-8.4.2/doc/user/index.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/index.rst	2023-03-13 20:01:47.000000000 +0600
@@ -31,6 +31,7 @@ Basics
    kernel
    snmp
    scripting
+   nexthop_groups
 .. modules
 
 #########
@@ -48,6 +49,7 @@ Protocols
    fabricd
    ldpd
    eigrpd
+   evpn
    isisd
    nhrpd
    ospfd
diff -urpN frr-frr-8.4.2/doc/user/installation.rst frr-frr-8.5/doc/user/installation.rst
--- frr-frr-8.4.2/doc/user/installation.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/installation.rst	2023-03-13 20:01:47.000000000 +0600
@@ -314,7 +314,8 @@ options from the list below.
 
    Turn on the ability of FRR to access some shell options( telnet/ssh/bash/etc. )
    from vtysh itself.  This option is considered extremely unsecure and should only
-   be considered for usage if you really really know what you are doing.
+   be considered for usage if you really really know what you are doing.  This
+   option is deprecated and will be removed on Feb 1, 2024.
 
 .. option:: --enable-gcov
 
@@ -368,6 +369,13 @@ options from the list below.
 
    Turn on the usage of PCRE Posix libs for regex functionality.
 
+.. option:: --enable-pcre2posix
+
+   Turn on the usage of PCRE2 Posix libs for regex functionality.
+
+   PCRE2 versions <= 10.31 work a bit differently. We suggest using at least
+   >= 10.36.
+
 .. option:: --enable-rpath
 
    Set hardcoded rpaths in the executable [default=yes].
diff -urpN frr-frr-8.4.2/doc/user/isisd.rst frr-frr-8.5/doc/user/isisd.rst
--- frr-frr-8.4.2/doc/user/isisd.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/isisd.rst	2023-03-13 20:01:47.000000000 +0600
@@ -83,6 +83,10 @@ writing, *isisd* does not support multip
 
    Set overload bit to avoid any transit traffic.
 
+.. clicmd:: set-overload-bit on-startup (0-86400)
+
+   Set overload bit on startup for the specified duration, in seconds. Reference: :rfc:`3277`
+
 .. clicmd:: purge-originator
 
    Enable or disable :rfc:`6232` purge originator identification.
diff -urpN frr-frr-8.4.2/doc/user/nexthop_groups.rst frr-frr-8.5/doc/user/nexthop_groups.rst
--- frr-frr-8.4.2/doc/user/nexthop_groups.rst	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/doc/user/nexthop_groups.rst	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,29 @@
+.. _nexthop-groups:
+
+Nexthop Groups
+==============
+
+Nexthop groups are a way to encapsulate ECMP information together.  It's a
+listing of ECMP nexthops used to forward packets.
+
+.. clicmd:: nexthop-group NAME
+
+   Create a nexthop-group with an associated NAME.  This will put you into a
+   sub-mode where you can specify individual nexthops.  To exit this mode type
+   exit or end as per normal conventions for leaving a sub-mode.
+
+.. clicmd:: nexthop [A.B.C.D|X:X::X:XX] [interface [onlink]] [nexthop-vrf NAME] [label LABELS]
+
+   Create a v4 or v6 nexthop.  All normal rules for creating nexthops that you
+   are used to are allowed here.  The syntax was intentionally kept the same as
+   creating nexthops as you would for static routes.
+
+.. clicmd:: resilient buckets (1-256) idle-timer (1-4294967295) unbalanced-timer (1-4294967295)
+
+   Create a resilient Nexthop Group with the specified number of buckets, and
+   associated timers.  Instead of using the normal kernel hashing methodology
+   this specifies that X buckets will be created for the nexthop group and
+   when a nexthop is lost the buckets forwarding that particular nexthop
+   will be automatically re-assigned.  This cli command must be the first
+   command entered currently.  Additionally this command only works with linux 5.19
+   kernels or newer.
diff -urpN frr-frr-8.4.2/doc/user/ospfd.rst frr-frr-8.5/doc/user/ospfd.rst
--- frr-frr-8.4.2/doc/user/ospfd.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/ospfd.rst	2023-03-13 20:01:47.000000000 +0600
@@ -195,7 +195,7 @@ To start OSPF process you have to specif
    This command supersedes the *timers spf* command in previous FRR
    releases.
 
-.. clicmd:: max-metric router-lsa [on-startup|on-shutdown] (5-86400)
+.. clicmd:: max-metric router-lsa [on-startup (5-86400)|on-shutdown (5-100)]
 
 .. clicmd:: max-metric router-lsa administrative
 
@@ -782,7 +782,7 @@ Showing Information
 
 .. _show-ip-ospf:
 
-.. clicmd:: show ip ospf [json]
+.. clicmd:: show ip ospf [vrf <NAME|all>] [json]
 
    Show information on a variety of general OSPF and area state and
    configuration information.
@@ -831,6 +831,13 @@ Showing Information
    Show the OSPF routing table, as determined by the most recent SPF
    calculation.
 
+.. clicmd:: show ip ospf [vrf <NAME|all>] border-routers [json]
+
+   Show the list of ABR and ASBR border routers summary learnt via
+   OSPFv2 Type-3 (Summary LSA) and Type-4 (Summary ASBR LSA).
+   User can get that information as JSON format when ``json`` keyword
+   at the end of cli is presented.
+
 .. clicmd:: show ip ospf graceful-restart helper [detail] [json]
 
    Displays the Grcaeful Restart Helper details including helper
@@ -1060,78 +1067,83 @@ TI-LFA requires a proper Segment Routing
 Debugging OSPF
 ==============
 
-.. clicmd:: debug ospf bfd
+.. clicmd:: debug ospf [(1-65535)] bfd
 
    Enable or disable debugging for BFD events. This will show BFD integration
    library messages and OSPF BFD integration messages that are mostly state
    transitions and validation problems.
 
-.. clicmd:: debug ospf client-api
+.. clicmd:: debug ospf [(1-65535)] client-api
 
    Show debug information for the OSPF opaque data client API.
 
-.. clicmd:: debug ospf packet (hello|dd|ls-request|ls-update|ls-ack|all) (send|recv) [detail]
+.. clicmd:: debug ospf [(1-65535)] default-information
 
+   Show debug information of default information
 
-   Dump Packet for debugging
+.. clicmd:: debug ospf [(1-65535)] packet (hello|dd|ls-request|ls-update|ls-ack|all) (send|recv) [detail]
 
-.. clicmd:: debug ospf ism
 
-.. clicmd:: debug ospf ism (status|events|timers)
+   Dump Packet for debugging
 
+.. clicmd:: debug ospf [(1-65535)] ism [status|events|timers]
 
 
-   Show debug information of Interface State Machine
 
-.. clicmd:: debug ospf nsm
+   Show debug information of Interface State Machine
 
-.. clicmd:: debug ospf nsm (status|events|timers)
+.. clicmd:: debug ospf [(1-65535)] nsm [status|events|timers]
 
 
 
    Show debug information of Network State Machine
 
-.. clicmd:: debug ospf event
+.. clicmd:: debug ospf [(1-65535)] event
 
 
    Show debug information of OSPF event
 
-.. clicmd:: debug ospf nssa
+.. clicmd:: debug ospf [(1-65535)] nssa
 
 
    Show debug information about Not So Stub Area
 
-.. clicmd:: debug ospf lsa
+.. clicmd:: debug ospf [(1-65535)] ldp-sync
 
-.. clicmd:: debug ospf lsa (generate|flooding|refresh)
+   Show debug information about LDP-Sync
+
+.. clicmd:: debug ospf [(1-65535)] lsa [aggregate|flooding|generate|install|refresh]
 
 
 
    Show debug detail of Link State messages
 
-.. clicmd:: debug ospf te
+.. clicmd:: debug ospf [(1-65535)] sr
+
+   Show debug information about Segment Routing
+
+.. clicmd:: debug ospf [(1-65535)] te
 
 
    Show debug information about Traffic Engineering LSA
 
-.. clicmd:: debug ospf zebra
+.. clicmd:: debug ospf [(1-65535)] ti-lfa
 
-.. clicmd:: debug ospf zebra (interface|redistribute)
+   Show debug information about SR TI-LFA
+
+.. clicmd:: debug ospf [(1-65535)] zebra [interface|redistribute]
 
 
 
    Show debug information of ZEBRA API
 
-.. clicmd:: debug ospf graceful-restart helper
+.. clicmd:: debug ospf [(1-65535)] graceful-restart
 
 
    Enable/disable debug information for OSPF Graceful Restart Helper
 
 .. clicmd:: show debugging ospf
 
-.. clicmd:: debug ospf lsa aggregate
-
-   Debug commnd to enable/disable external route summarisation specific debugs.
 
 
 Sample Configuration
diff -urpN frr-frr-8.4.2/doc/user/pathd.rst frr-frr-8.5/doc/user/pathd.rst
--- frr-frr-8.4.2/doc/user/pathd.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/pathd.rst	2023-03-13 20:01:47.000000000 +0600
@@ -175,7 +175,7 @@ controller and obtain those by means of
 .. image:: images/pathd_initiated_multi.png
 
 Starting
-=============
+========
 
 Default configuration file for *pathd* is :file:`pathd.conf`.  The typical
 location of :file:`pathd.conf` is |INSTALL_PREFIX_ETC|/pathd.conf.
@@ -480,6 +480,12 @@ Configuration Commands
 
    Specify a peer and its precedence in a PCC definition.
 
+Debugging
+---------
+
+.. clicmd:: debug pathd policy
+
+   Enable or disable Pathd policy information.
 
 Introspection Commands
 ----------------------
diff -urpN frr-frr-8.4.2/doc/user/pbr.rst frr-frr-8.5/doc/user/pbr.rst
--- frr-frr-8.4.2/doc/user/pbr.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/pbr.rst	2023-03-13 20:01:47.000000000 +0600
@@ -32,26 +32,8 @@ Nexthop Groups
 
 Nexthop groups are a way to encapsulate ECMP information together.  It's a
 listing of ECMP nexthops used to forward packets for when a pbr-map is matched.
-
-.. clicmd:: nexthop-group NAME
-
-   Create a nexthop-group with an associated NAME.  This will put you into a
-   sub-mode where you can specify individual nexthops.  To exit this mode type
-   exit or end as per normal conventions for leaving a sub-mode.
-
-.. clicmd:: nexthop [A.B.C.D|X:X::X:XX] [interface [onlink]] [nexthop-vrf NAME] [label LABELS]
-
-   Create a v4 or v6 nexthop.  All normal rules for creating nexthops that you
-   are used to are allowed here.  The syntax was intentionally kept the same as
-   creating nexthops as you would for static routes.
-
-.. clicmd:: pbr table range (10000-4294966272) (10000-4294966272)
-
-   Set or unset the range used to assign numeric table ID's to new
-   nexthop-group tables. Existing tables will not be modified to fit in this
-   range, so it is recommended to configure this before adding nexthop groups.
-
-   .. seealso:: :ref:`pbr-details`
+For detailed instructions on how to specify a nexthop group on the CLI, see
+the nexthop-groups section.
 
 Showing Nexthop Group Information
 ---------------------------------
@@ -301,6 +283,15 @@ causes the policy to be installed into t
    | valid  | Is the map well-formed?    | Boolean |
    +--------+----------------------------+---------+
 
+.. clicmd:: pbr table range (10000-4294966272) (10000-4294966272)
+
+   Set or unset the range used to assign numeric table ID's to new
+   nexthop-group tables. Existing tables will not be modified to fit in this
+   range, so it is recommended to configure this before adding nexthop groups.
+
+   .. seealso:: :ref:`pbr-details`
+
+
 .. _pbr-debugs:
 
 PBR Debugs
@@ -310,10 +301,6 @@ PBR Debugs
 
    Debug pbr in pbrd daemon. You specify what types of debugs to turn on.
 
-.. clicmd:: debug zebra pbr
-
-   Debug pbr in zebra daemon.
-
 .. _pbr-details:
 
 PBR Details
diff -urpN frr-frr-8.4.2/doc/user/pim.rst frr-frr-8.5/doc/user/pim.rst
--- frr-frr-8.4.2/doc/user/pim.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/pim.rst	2023-03-13 20:01:47.000000000 +0600
@@ -578,7 +578,7 @@ cause great confusion.
 
 .. clicmd:: show ip pim bsm-database
 
-   Display all fragments ofstored bootstrap message in user readable format.
+   Display all fragments of stored bootstrap message in user readable format.
 
 .. clicmd:: mtrace A.B.C.D [A.B.C.D]
 
diff -urpN frr-frr-8.4.2/doc/user/pimv6.rst frr-frr-8.5/doc/user/pimv6.rst
--- frr-frr-8.4.2/doc/user/pimv6.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/pimv6.rst	2023-03-13 20:01:47.000000000 +0600
@@ -162,6 +162,18 @@ is in a vrf, enter the interface command
 
    Disable sending and receiving pim control packets on the interface.
 
+.. clicmd:: ipv6 pim bsm
+
+   Tell pim that we would like to use this interface to process bootstrap
+   messages. This is enabled by default. 'no' form of this command is used to
+   restrict bsm messages on this interface.
+
+.. clicmd:: ipv6 pim unicast-bsm
+
+   Tell pim that we would like to allow interface to process unicast bootstrap
+   messages. This is enabled by default. 'no' form of this command is used to
+   restrict processing of unicast bsm messages on this interface.
+
 .. clicmd:: ipv6 mld
 
    Tell pim to receive MLD reports and Query on this interface. The default
@@ -373,6 +385,18 @@ General multicast routing state
    Display total number of S,G mroutes and number of S,G mroutes
    installed into the kernel for all vrfs.
 
+.. clicmd:: show ipv6 pim bsr
+
+   Display current bsr, its uptime and last received bsm age.
+
+.. clicmd:: show ipv6 pim bsrp-info
+
+   Display group-to-rp mappings received from E-BSR.
+
+.. clicmd:: show ipv6 pim bsm-database
+
+   Display all fragments of stored bootstrap message in user readable format.
+
 PIMv6 Clear Commands
 ====================
 
@@ -416,6 +440,10 @@ configure CLI mode. If you specify debug
 mode, the debug commands can be persistent across restarts of the FRR pim6d if
 the config was written out.
 
+.. clicmd:: debug mld
+
+   This turns on debugging for MLD protocol activity.
+
 .. clicmd:: debug pimv6 events
 
    This turns on debugging for PIMv6 system events. Especially timers.
@@ -456,3 +484,19 @@ the config was written out.
 .. clicmd:: debug mroute6 detail
 
    This turns on detailed debugging for PIMv6 interaction with kernel MFC cache.
+
+.. clicmd:: debug mld events
+
+   This turns on debugging for MLD system events.
+
+.. clicmd:: debug mld packets
+
+   This turns on information about MLD protocol packets handling.
+
+.. clicmd:: debug mld trace [detail]
+
+   This traces mld code and how it is running. 
+
+.. clicmd:: debug pimv6 bsm
+
+   This turns on debugging for BSR message processing.
diff -urpN frr-frr-8.4.2/doc/user/routemap.rst frr-frr-8.5/doc/user/routemap.rst
--- frr-frr-8.4.2/doc/user/routemap.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/routemap.rst	2023-03-13 20:01:47.000000000 +0600
@@ -310,6 +310,11 @@ Route Map Set Command
    trip time or `+rtt`/`-rtt` to add/subtract the round trip time to/from the
    MED.
 
+.. clicmd:: set aigp-metric <igp-metric|(1-4294967295)>
+
+   Set the BGP attribute AIGP to a specific value. If ``igp-metric`` is specified,
+   then the value is taken from the IGP protocol, otherwise an arbitrary value.
+
 .. clicmd:: set as-path prepend AS_PATH
 
    Set the BGP AS path to prepend.
diff -urpN frr-frr-8.4.2/doc/user/setup.rst frr-frr-8.5/doc/user/setup.rst
--- frr-frr-8.4.2/doc/user/setup.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/setup.rst	2023-03-13 20:01:47.000000000 +0600
@@ -116,6 +116,16 @@ allow this to happen.
 
 ::
 
+  FRR_NO_ROOT="yes"
+
+This option allows you to run FRR as a non-root user. Use this option
+only when you know what you are doing since most of the daemons
+in FRR will not be able to run under a regular user. This option
+is useful for example when you run FRR in a container with a designated
+user instead of root.
+
+::
+
    zebra_options=" -s 90000000 --daemon -A 127.0.0.1"
    bgpd_options="   --daemon -A 127.0.0.1"
    ...
diff -urpN frr-frr-8.4.2/doc/user/sharp.rst frr-frr-8.5/doc/user/sharp.rst
--- frr-frr-8.4.2/doc/user/sharp.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/sharp.rst	2023-03-13 20:01:47.000000000 +0600
@@ -187,7 +187,7 @@ keyword. At present, no sharp commands w
 
    There are many End Functions defined in SRv6, which have been standardized
    in RFC 8986. The current implementation supports End, End.X, End.T, End.DX4,
-   and End.DT6, which can be configured as follows.
+   End.DT6 and End.DT46, which can be configured as follows.
 
 ::
 
@@ -196,6 +196,7 @@ keyword. At present, no sharp commands w
    router# sharp install seg6local-routes 1::3 nexthop-seg6local dum0 End_T 10 1
    router# sharp install seg6local-routes 1::4 nexthop-seg6local dum0 End_DX4 10.0.0.1 1
    router# sharp install seg6local-routes 1::5 nexthop-seg6local dum0 End_DT6 10 1
+   router# sharp install seg6local-routes 1::6 nexthop-seg6local dum0 End_DT46 10 1
 
    router# show ipv6 route
    D>* 1::1/128 [150/0] is directly connected, dum0, seg6local End USP, weight 1, 00:00:05
@@ -203,6 +204,7 @@ keyword. At present, no sharp commands w
    D>* 1::3/128 [150/0] is directly connected, dum0, seg6local End.T table 10, weight 1, 00:00:05
    D>* 1::4/128 [150/0] is directly connected, dum0, seg6local End.DX4 nh4 10.0.0.1, weight 1, 00:00:05
    D>* 1::5/128 [150/0] is directly connected, dum0, seg6local End.DT6 table 10, weight 1, 00:00:05
+   D>* 1::6/128 [150/0] is directly connected, dum0, seg6local End.DT46 table 10, weight 1, 00:00:05
 
    bash# ip -6 route
    1::1  encap seg6local action End dev dum0 proto 194 metric 20 pref medium
@@ -210,6 +212,7 @@ keyword. At present, no sharp commands w
    1::3  encap seg6local action End.T table 10 dev dum0 proto 194 metric 20 pref medium
    1::4  encap seg6local action End.DX4 nh4 10.0.0.1 dev dum0 proto 194 metric 20 pref medium
    1::5  encap seg6local action End.DT6 table 10 dev dum0 proto 194 metric 20 pref medium
+   1::6  encap seg6local action End.DT46 table 10 dev dum0 proto 194 metric 20 pref medium
 
 .. clicmd:: show sharp segment-routing srv6
 
diff -urpN frr-frr-8.4.2/doc/user/snmp.rst frr-frr-8.5/doc/user/snmp.rst
--- frr-frr-8.4.2/doc/user/snmp.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/snmp.rst	2023-03-13 20:01:47.000000000 +0600
@@ -115,6 +115,65 @@ Then, you can use the following command
    OSPF-MIB::ospfRouterId.0 = IpAddress: 192.168.42.109
    [...]
 
+An example below is how to query SNMP for BGP:
+
+   .. code-block:: shell
+
+      $ # BGP4-MIB (https://www.circitor.fr/Mibs/Mib/B/BGP4-MIB.mib)
+      $ snmpwalk -c public -v2c -On -Ln localhost .1.3.6.1.2.1.15
+
+      $ # BGP4V2-MIB (http://www.circitor.fr/Mibs/Mib/B/BGP4V2-MIB.mib)
+      $ # Information about the peers (bgp4V2PeerTable):
+      $ snmpwalk -c public -v2c -On -Ln localhost .1.3.6.1.3.5.1.1.2
+      ...
+      .1.3.6.1.3.5.1.1.2.1.1.1.4.192.168.10.124 = Gauge32: 0
+      .1.3.6.1.3.5.1.1.2.1.1.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 0
+      .1.3.6.1.3.5.1.1.2.1.2.1.4.192.168.10.124 = INTEGER: 1
+      .1.3.6.1.3.5.1.1.2.1.2.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = INTEGER: 2
+      .1.3.6.1.3.5.1.1.2.1.3.1.4.192.168.10.124 = Hex-STRING: C0 A8 0A 11
+      .1.3.6.1.3.5.1.1.2.1.3.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Hex-STRING: 2A 02 47 80 0A BC 00 00 00 00 00 00 00 00 00 01
+      .1.3.6.1.3.5.1.1.2.1.4.1.4.192.168.10.124 = INTEGER: 1
+      .1.3.6.1.3.5.1.1.2.1.4.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = INTEGER: 2
+      .1.3.6.1.3.5.1.1.2.1.5.1.4.192.168.10.124 = Hex-STRING: C0 A8 0A 7C
+      .1.3.6.1.3.5.1.1.2.1.5.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Hex-STRING: 2A 02 47 80 0A BC 00 00 00 00 00 00 00 00 00 02
+      .1.3.6.1.3.5.1.1.2.1.6.1.4.192.168.10.124 = Gauge32: 179
+      .1.3.6.1.3.5.1.1.2.1.6.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 179
+      .1.3.6.1.3.5.1.1.2.1.7.1.4.192.168.10.124 = Gauge32: 65002
+      .1.3.6.1.3.5.1.1.2.1.7.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 65002
+      .1.3.6.1.3.5.1.1.2.1.8.1.4.192.168.10.124 = Hex-STRING: C0 A8 0A 11
+      .1.3.6.1.3.5.1.1.2.1.8.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Hex-STRING: C0 A8 0A 11
+      .1.3.6.1.3.5.1.1.2.1.9.1.4.192.168.10.124 = Gauge32: 41894
+      .1.3.6.1.3.5.1.1.2.1.9.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 39960
+      .1.3.6.1.3.5.1.1.2.1.10.1.4.192.168.10.124 = Gauge32: 65001
+      .1.3.6.1.3.5.1.1.2.1.10.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 65001
+      .1.3.6.1.3.5.1.1.2.1.11.1.4.192.168.10.124 = Hex-STRING: C8 C8 C8 CA
+      .1.3.6.1.3.5.1.1.2.1.11.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Hex-STRING: C8 C8 C8 CA
+      .1.3.6.1.3.5.1.1.2.1.12.1.4.192.168.10.124 = INTEGER: 2
+      .1.3.6.1.3.5.1.1.2.1.12.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = INTEGER: 2
+      .1.3.6.1.3.5.1.1.2.1.13.1.4.192.168.10.124 = INTEGER: 6
+      .1.3.6.1.3.5.1.1.2.1.13.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = INTEGER: 6
+
+      $ # Information about the BGP table (bgp4V2NlriTable):
+      $ snmpwalk -c public -v2c -On -Ln localhost .1.3.6.1.3.5.1.1.9
+      ...
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.10.0.2.0.24.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.10.10.100.0.24.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.172.16.31.1.32.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.172.16.31.2.32.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.172.16.31.3.32.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.192.168.0.0.24.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.192.168.1.0.24.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.1.4.192.168.10.0.24.192.168.10.124 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.22.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.0.64.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Gauge32: 1
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.10.0.2.0.24.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.10.10.100.0.24.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.172.16.31.1.32.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.172.16.31.2.32.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.172.16.31.3.32.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.192.168.0.0.24.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.192.168.1.0.24.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.1.4.192.168.10.0.24.192.168.10.124 = Hex-STRING: 02 01 FD E9
+      .1.3.6.1.3.5.1.1.9.1.24.2.16.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.0.64.42.2.71.128.10.188.0.0.0.0.0.0.0.0.0.2 = Hex-STRING: 02 01 FD E9
 
 The AgentX protocol can be transported over a Unix socket or using TCP or UDP.
 It usually defaults to a Unix socket and depends on how NetSNMP was built. If
@@ -132,5 +191,7 @@ Here is the syntax for using AgentX:
 
 .. clicmd:: agentx
 
+   Once enabled, it can't be unconfigured. Only removing from the daemons file
+   the keyword ``agentx`` takes an effect.
 
 .. include:: snmptrap.rst
diff -urpN frr-frr-8.4.2/doc/user/subdir.am frr-frr-8.5/doc/user/subdir.am
--- frr-frr-8.4.2/doc/user/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -11,6 +11,7 @@ user_RSTFILES = \
 	doc/user/bugs.rst \
 	doc/user/conf.py \
 	doc/user/eigrpd.rst \
+	doc/user/evpn.rst \
 	doc/user/extlog.rst \
 	doc/user/fabricd.rst \
 	doc/user/filter.rst \
@@ -22,6 +23,7 @@ user_RSTFILES = \
 	doc/user/ipv6.rst \
 	doc/user/isisd.rst \
 	doc/user/kernel.rst \
+	doc/user/nexthop_groups.rst \
 	doc/user/nhrpd.rst \
 	doc/user/ospf6d.rst \
 	doc/user/ospfd.rst \
diff -urpN frr-frr-8.4.2/doc/user/vrrp.rst frr-frr-8.5/doc/user/vrrp.rst
--- frr-frr-8.4.2/doc/user/vrrp.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/vrrp.rst	2023-03-13 20:01:47.000000000 +0600
@@ -393,6 +393,11 @@ All interface configuration commands are
    higher priority to take over Master status from the existing Master. Enabled
    by default.
 
+.. clicmd:: vrrp (1-255) checksum-with-ipv4-pseudoheader
+
+   Specify whether VRRPv3 checksum should involve IPv4 pseudoheader. This
+   command should not affect VRRPv2 and IPv6. Enabled by default.
+
 .. clicmd:: vrrp (1-255) priority (1-254)
 
    Set the router priority. The router with the highest priority is elected as
@@ -448,7 +453,7 @@ Show commands, global defaults and debug
    zebra
       Logs communications with Zebra.
 
-.. clicmd:: vrrp default <advertisement-interval (1-4096)|preempt|priority (1-254)|shutdown>
+.. clicmd:: vrrp default <advertisement-interval (1-4096)|preempt|priority (1-254)|checksum-with-ipv4-pseudoheader|shutdown>
 
    Configure defaults for new VRRP routers. These values will not affect
    already configured VRRP routers, but will be applied to newly configured
@@ -550,3 +555,19 @@ feature instead, explained `here
 <https://www.virtuallyghetto.com/2018/04/native-mac-learning-in-vsphere-6-7-removes-the-need-for-promiscuous-mode-for-nested-esxi.html>`_.
 
 Issue reference: https://github.com/FRRouting/frr/issues/5386
+
+
+My router cannot interoperate with branded routers / L3 switches
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+FRR includes a pseudoheader when calculating VRRPv3 checksums by default,
+regardless of whether it's IPv4 or IPv6.
+
+Some vendors have different interpretations of `VRRPv3 RFC 5798 #5.2.8
+<https://www.rfc-editor.org/rfc/rfc5798.html#section-5.2.8>`_. In such cases,
+their checksums are calculated with a pseudoheader only when it comes to IPv6.
+
+You need to disable ``checksum-with-ipv4-pseudoheader`` so that FRR computes and
+accepts such checksums.
+
+Issue reference: https://github.com/FRRouting/frr/issues/9951
diff -urpN frr-frr-8.4.2/doc/user/zebra.rst frr-frr-8.5/doc/user/zebra.rst
--- frr-frr-8.4.2/doc/user/zebra.rst	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/doc/user/zebra.rst	2023-03-13 20:01:47.000000000 +0600
@@ -68,7 +68,7 @@ Besides the common invocation options (:
    option and we will use Route Replace Semantics instead of delete
    than add.
 
-.. option:: --asic-offload [notify_on_offload|notify_on_ack]
+.. option:: --asic-offload=[notify_on_offload|notify_on_ack]
 
    The linux kernel has the ability to use asic-offload ( see switchdev
    development ).  When the operator knows that FRR will be working in
@@ -76,11 +76,12 @@ Besides the common invocation options (:
    code only supports asynchronous notification of the offload state.
    In other words the initial ACK received for linux kernel installation
    does not give zebra any data about what the state of the offload
-   is.  This option takes the optional paramegers notify_on_offload
+   is.  This option takes the optional parameters notify_on_offload
    or notify_on_ack.  This signals to zebra to notify upper level
    protocols about route installation/update on ack received from
    the linux kernel or from offload notification.
 
+
 .. option:: -s <SIZE>, --nl-bufsize <SIZE>
 
    Allow zebra to modify the default receive buffer size to SIZE
@@ -296,7 +297,7 @@ the default route.
    Allow IPv6 nexthop tracking to resolve via the default route. This parameter
    is configured per-VRF, so the command is also available in the VRF subnode.
 
-.. clicmd:: show ip nht [vrf NAME] [A.B.C.D|X:X::X:X] [mrib]
+.. clicmd:: show ip nht [vrf NAME] [A.B.C.D|X:X::X:X] [mrib] [json]
 
    Show nexthop tracking status for address resolution.  If vrf is not specified
    then display the default vrf.  If ``all`` is specified show all vrf address
@@ -305,6 +306,17 @@ the default route.
    indicates that the operator wants to see the multicast rib address resolution
    table.  An alternative form of the command is ``show ip import-check`` and this
    form of the command is deprecated at this point in time.
+   User can get that information as JSON string when ``json`` key word
+   at the end of cli is presented.
+
+.. clicmd:: show ip nht route-map [vrf <NAME|all>] [json]
+
+   This command displays route-map attach point to nexthop tracking and
+   displays list of protocol with its applied route-map.
+   When zebra considers sending NHT resoultion, the nofification only
+   sent to appropriate client protocol only after applying route-map filter.
+   User can get that information as JSON format when ``json`` keyword
+   at the end of cli is presented.
 
 PBR dataplane programming
 =========================
@@ -745,7 +757,7 @@ and this section also helps that case.
    Create a new locator. If the name of an existing locator is specified,
    move to specified locator's configuration node to change the settings it.
 
-.. clicmd:: prefix X:X::X:X/M [func-bits 32]
+.. clicmd:: prefix X:X::X:X/M [func-bits (0-64)] [block-len 40] [node-len 24]
 
    Set the ipv6 prefix block of the locator. SRv6 locator is defined by
    RFC8986. The actual routing protocol specifies the locator and allocates a
@@ -764,10 +776,33 @@ and this section also helps that case.
    configure the locator's prefix as ``2001:db8:1:1::/64``, then default SID
    will be ``2001:db8:1:1:1::``)
 
+   This command takes three optional parameters: ``func-bits``, ``block-len``
+   and ``node-len``. These parameters allow users to set the format for the SIDs
+   allocated from the SRv6 Locator. SID Format is defined in RFC 8986.
+
+   According to RFC 8986, an SRv6 SID consists of BLOCK:NODE:FUNCTION:ARGUMENT,
+   where BLOCK is the SRv6 SID block (i.e., the IPv6 prefix allocated for SRv6
+   SIDs by the operator), NODE is the identifier of the parent node instantiating
+   the SID, FUNCTION identifies the local behavior associated to the SID and
+   ARGUMENT encodes additional information used to process the behavior.
+   BLOCK and NODE make up the SRv6 Locator.
+
    The function bits range is 16bits by default.  If operator want to change
    function bits range, they can configure with ``func-bits``
    option.
 
+   The ``block-len`` and ``node-len`` parameters allow the user to configure the
+   length of the SRv6 SID block and SRv6 SID node, respectively. Both the lengths
+   are expressed in bits.
+
+   ``block-len``, ``node-len`` and ``func-bits`` may be any value as long as
+   ``block-len+node-len = locator-len`` and ``block-len+node-len+func-bits <= 128``.
+
+   When both ``block-len`` and ``node-len`` are omitted, the following default
+   values are used: ``block-len = 24``, ``node-len = prefix-len-24``.
+
+   If only one parameter is omitted, the other parameter is derived from the first.
+
 ::
 
    router# configure terminal
@@ -787,6 +822,36 @@ and this section also helps that case.
       !
    ...
 
+.. clicmd:: behavior usid
+
+   Specify the SRv6 locator as a Micro-segment (uSID) locator. When a locator is
+   specified as a uSID locator, all the SRv6 SIDs allocated from the locator by the routing
+   protocols are bound to the SRv6 uSID behaviors. For example, if you configure BGP to use
+   a locator specified as a uSID locator, BGP instantiates and advertises SRv6 uSID behaviors
+   (e.g., ``uDT4`` / ``uDT6`` / ``uDT46``) instead of classic SRv6 behaviors
+   (e.g., ``End.DT4`` / ``End.DT6`` / ``End.DT46``).
+
+::
+
+   router# configure terminal
+   router(config)# segment-routinig
+   router(config-sr)# srv6
+   router(config-srv6)# locators
+   router(config-srv6-locators)# locator loc1
+   router(config-srv6-locator)# prefix fc00:0:1::/48 block-len 32 node-len 16 func-bits 16
+   router(config-srv6-locator)# behavior usid
+
+   router(config-srv6-locator)# show run
+   ...
+   segment-routing
+    srv6
+     locators
+      locator loc1
+       prefix fc00:0:1::/48
+       behavior usid
+      !
+   ...
+
 .. _multicast-rib-commands:
 
 Multicast RIB Commands
@@ -1286,7 +1351,7 @@ zebra Terminal Mode Commands
    total number of route nodes in the table.  Which will be higher than
    the actual number of routes that are held.
 
-.. clicmd:: show nexthop-group rib [ID] [vrf NAME] [singleton [ip|ip6]] [type]
+.. clicmd:: show nexthop-group rib [ID] [vrf NAME] [singleton [ip|ip6]] [type] [json]
 
    Display nexthop groups created by zebra.  The [vrf NAME] option
    is only meaningful if you have started zebra with the --vrfwnetns
diff -urpN frr-frr-8.4.2/docker/alpine/Dockerfile frr-frr-8.5/docker/alpine/Dockerfile
--- frr-frr-8.4.2/docker/alpine/Dockerfile	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/docker/alpine/Dockerfile	2023-03-13 20:01:47.000000000 +0600
@@ -1,7 +1,7 @@
 # syntax=docker/dockerfile:1
 
 # Create a basic stage set up to build APKs
-FROM alpine:3.15 as alpine-builder
+FROM alpine:3.17 as alpine-builder
 RUN apk add \
 		--update-cache \
 		abuild \
@@ -13,7 +13,7 @@ RUN apk add \
 RUN adduser -D -G abuild builder && su builder -c 'abuild-keygen -a -n'
 
 # This stage builds a dist tarball from the source
-FROM alpine:3.15 as source-builder
+FROM alpine:3.17 as source-builder
 
 RUN mkdir -p /src/alpine
 COPY alpine/APKBUILD.in /src/alpine
@@ -48,7 +48,7 @@ RUN cd /dist \
 	&& abuild -r -P /pkgs/apk
 
 # This stage installs frr from the apk
-FROM alpine:3.15
+FROM alpine:3.17
 RUN mkdir -p /pkgs/apk
 COPY --from=alpine-apk-builder /pkgs/apk/ /pkgs/apk/
 RUN apk add \
diff -urpN frr-frr-8.4.2/eigrpd/eigrp_cli.c frr-frr-8.5/eigrpd/eigrp_cli.c
--- frr-frr-8.4.2/eigrpd/eigrp_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/eigrpd/eigrp_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -31,9 +31,7 @@
 #include "eigrp_zebra.h"
 #include "eigrp_cli.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "eigrpd/eigrp_cli_clippy.c"
-#endif /* VTYSH_EXTRACT_PL */
 
 /*
  * XPath: /frr-eigrpd:eigrpd/instance
diff -urpN frr-frr-8.4.2/eigrpd/eigrp_dump.c frr-frr-8.5/eigrpd/eigrp_dump.c
--- frr-frr-8.4.2/eigrpd/eigrp_dump.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/eigrpd/eigrp_dump.c	2023-03-13 20:01:47.000000000 +0600
@@ -322,6 +322,7 @@ DEFUN_NOSH (show_debugging_eigrp,
 		}
 	}
 
+	cmd_show_lib_debugs(vty);
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/eigrpd/eigrp_interface.c frr-frr-8.5/eigrpd/eigrp_interface.c
--- frr-frr-8.4.2/eigrpd/eigrp_interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/eigrpd/eigrp_interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@
 #include "if.h"
 #include "table.h"
 #include "memory.h"
+#include "network.h"
 #include "command.h"
 #include "stream.h"
 #include "log.h"
@@ -83,7 +84,7 @@ struct eigrp_interface *eigrp_if_new(str
 	/* Initialize neighbor list. */
 	ei->nbrs = list_new();
 
-	ei->crypt_seqnum = time(NULL);
+	ei->crypt_seqnum = frr_sequence32_next();
 
 	/* Initialize lists */
 	for (i = 0; i < EIGRP_FILTER_MAX; i++) {
diff -urpN frr-frr-8.4.2/eigrpd/eigrp_vty.c frr-frr-8.5/eigrpd/eigrp_vty.c
--- frr-frr-8.4.2/eigrpd/eigrp_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/eigrpd/eigrp_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -55,9 +55,7 @@
 #include "eigrpd/eigrp_dump.h"
 #include "eigrpd/eigrp_const.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "eigrpd/eigrp_vty_clippy.c"
-#endif
 
 static void eigrp_vty_display_prefix_entry(struct vty *vty, struct eigrp *eigrp,
 					   struct eigrp_prefix_descriptor *pe,
diff -urpN frr-frr-8.4.2/eigrpd/subdir.am frr-frr-8.5/eigrpd/subdir.am
--- frr-frr-8.4.2/eigrpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/eigrpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,12 +4,6 @@
 
 if EIGRPD
 sbin_PROGRAMS += eigrpd/eigrpd
-vtysh_scan += \
-	eigrpd/eigrp_cli.c \
-	eigrpd/eigrp_dump.c \
-	eigrpd/eigrp_vty.c \
-	# end
-#	eigrpd/eigrp_routemap.c
 vtysh_daemons += eigrpd
 man8 += $(MANBUILD)/frr-eigrpd.8
 endif
diff -urpN frr-frr-8.4.2/grpc/subdir.am frr-frr-8.5/grpc/subdir.am
--- frr-frr-8.4.2/grpc/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/grpc/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -28,6 +28,13 @@ am__v_PROTOC_1 =
 
 SUFFIXES += .pb.h .pb.cc .grpc.pb.cc
 
+grpc/frr-northbound.grpc.pb.h: grpc/frr-northbound.grpc.pb.cc
+	@test -f $@ || rm -f $< || true
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) $<
+grpc/frr-northbound.pb.h: grpc/frr-northbound.pb.cc
+	@test -f $@ || rm -f $< || true
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) $<
+
 .proto.pb.cc:
 	$(AM_V_PROTOC)$(PROTOC) -I$(top_srcdir) --cpp_out=$(top_builddir) $^
 .proto.grpc.pb.cc:
diff -urpN frr-frr-8.4.2/include/linux/rtnetlink.h frr-frr-8.5/include/linux/rtnetlink.h
--- frr-frr-8.4.2/include/linux/rtnetlink.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/include/linux/rtnetlink.h	2023-03-13 20:01:47.000000000 +0600
@@ -185,9 +185,6 @@ enum {
 	RTM_GETNEXTHOPBUCKET,
 #define RTM_GETNEXTHOPBUCKET	RTM_GETNEXTHOPBUCKET
 
-        RTM_SETHWFLAGS = 119,
-#define RTM_SETHWFLAGS RTM_SETHWFLAGS
-
 	RTM_NEWTUNNEL = 120,
 #define RTM_NEWTUNNEL	RTM_NEWTUNNEL
 	RTM_DELTUNNEL,
diff -urpN frr-frr-8.4.2/include/linux/seg6_local.h frr-frr-8.5/include/linux/seg6_local.h
--- frr-frr-8.4.2/include/linux/seg6_local.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/include/linux/seg6_local.h	2023-03-13 20:01:47.000000000 +0600
@@ -27,6 +27,7 @@ enum {
 	SEG6_LOCAL_OIF,
 	SEG6_LOCAL_BPF,
 	SEG6_LOCAL_VRFTABLE,
+	SEG6_LOCAL_COUNTERS,
 	__SEG6_LOCAL_MAX,
 };
 #define SEG6_LOCAL_MAX (__SEG6_LOCAL_MAX - 1)
@@ -63,6 +64,8 @@ enum {
 	SEG6_LOCAL_ACTION_END_AM	= 14,
 	/* custom BPF action */
 	SEG6_LOCAL_ACTION_END_BPF	= 15,
+	/* decap and lookup of DA in v4 or v6 table */
+	SEG6_LOCAL_ACTION_END_DT46	= 16,
 
 	__SEG6_LOCAL_ACTION_MAX,
 };
@@ -78,4 +81,33 @@ enum {
 
 #define SEG6_LOCAL_BPF_PROG_MAX (__SEG6_LOCAL_BPF_PROG_MAX - 1)
 
+/* SRv6 Behavior counters are encoded as netlink attributes guaranteeing the
+ * correct alignment.
+ * Each counter is identified by a different attribute type (i.e.
+ * SEG6_LOCAL_CNT_PACKETS).
+ *
+ * - SEG6_LOCAL_CNT_PACKETS: identifies a counter that counts the number of
+ *   packets that have been CORRECTLY processed by an SRv6 Behavior instance
+ *   (i.e., packets that generate errors or are dropped are NOT counted).
+ *
+ * - SEG6_LOCAL_CNT_BYTES: identifies a counter that counts the total amount
+ *   of traffic in bytes of all packets that have been CORRECTLY processed by
+ *   an SRv6 Behavior instance (i.e., packets that generate errors or are
+ *   dropped are NOT counted).
+ *
+ * - SEG6_LOCAL_CNT_ERRORS: identifies a counter that counts the number of
+ *   packets that have NOT been properly processed by an SRv6 Behavior instance
+ *   (i.e., packets that generate errors or are dropped).
+ */
+enum {
+	SEG6_LOCAL_CNT_UNSPEC,
+	SEG6_LOCAL_CNT_PAD,		/* pad for 64 bits values */
+	SEG6_LOCAL_CNT_PACKETS,
+	SEG6_LOCAL_CNT_BYTES,
+	SEG6_LOCAL_CNT_ERRORS,
+	__SEG6_LOCAL_CNT_MAX,
+};
+
+#define SEG6_LOCAL_CNT_MAX (__SEG6_LOCAL_CNT_MAX - 1)
+
 #endif
diff -urpN frr-frr-8.4.2/include/subdir.am frr-frr-8.5/include/subdir.am
--- frr-frr-8.4.2/include/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/include/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -19,4 +19,5 @@ noinst_HEADERS += \
 	include/linux/seg6_local.h \
 	include/linux/mroute.h \
 	include/linux/mroute6.h \
+	include/linux/pkt_cls.h \
 	# end
diff -urpN frr-frr-8.4.2/isisd/isis_adjacency.c frr-frr-8.5/isisd/isis_adjacency.c
--- frr-frr-8.4.2/isisd/isis_adjacency.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_adjacency.c	2023-03-13 20:01:47.000000000 +0600
@@ -212,6 +212,36 @@ static const char *adj_level2string(int
 	return NULL; /* not reached */
 }
 
+static void isis_adj_route_switchover(struct isis_adjacency *adj)
+{
+	union g_addr ip = {};
+	ifindex_t ifindex;
+	unsigned int i;
+
+	if (!adj->circuit || !adj->circuit->interface)
+		return;
+
+	ifindex = adj->circuit->interface->ifindex;
+
+	for (i = 0; i < adj->ipv4_address_count; i++) {
+		ip.ipv4 = adj->ipv4_addresses[i];
+		isis_circuit_switchover_routes(adj->circuit, AF_INET, &ip,
+					       ifindex);
+	}
+
+	for (i = 0; i < adj->ll_ipv6_count; i++) {
+		ip.ipv6 = adj->ll_ipv6_addrs[i];
+		isis_circuit_switchover_routes(adj->circuit, AF_INET6, &ip,
+					       ifindex);
+	}
+
+	for (i = 0; i < adj->global_ipv6_count; i++) {
+		ip.ipv6 = adj->global_ipv6_addrs[i];
+		isis_circuit_switchover_routes(adj->circuit, AF_INET6, &ip,
+					       ifindex);
+	}
+}
+
 void isis_adj_process_threeway(struct isis_adjacency *adj,
 			       struct isis_threeway_adj *tw_adj,
 			       enum isis_adj_usage adj_usage)
@@ -298,6 +328,16 @@ void isis_adj_state_change(struct isis_a
 	if (new_state == old_state)
 		return;
 
+	if (old_state == ISIS_ADJ_UP &&
+	    !CHECK_FLAG(adj->circuit->flags, ISIS_CIRCUIT_IF_DOWN_FROM_Z)) {
+		if (IS_DEBUG_EVENTS)
+			zlog_debug(
+				"ISIS-Adj (%s): Starting fast-reroute on state change %d->%d: %s",
+				circuit->area->area_tag, old_state, new_state,
+				reason ? reason : "unspecified");
+		isis_adj_route_switchover(adj);
+	}
+
 	adj->adj_state = new_state;
 	send_hello_sched(circuit, adj->level, TRIGGERED_IIH_DELAY);
 
diff -urpN frr-frr-8.4.2/isisd/isis_adjacency.h frr-frr-8.5/isisd/isis_adjacency.h
--- frr-frr-8.4.2/isisd/isis_adjacency.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_adjacency.h	2023-03-13 20:01:47.000000000 +0600
@@ -151,5 +151,4 @@ void isis_adj_build_up_list(struct list
 int isis_adj_usage2levels(enum isis_adj_usage usage);
 void isis_bfd_startup_timer(struct thread *thread);
 const char *isis_adj_name(const struct isis_adjacency *adj);
-
 #endif /* ISIS_ADJACENCY_H */
diff -urpN frr-frr-8.4.2/isisd/isis_circuit.c frr-frr-8.5/isisd/isis_circuit.c
--- frr-frr-8.4.2/isisd/isis_circuit.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_circuit.c	2023-03-13 20:01:47.000000000 +0600
@@ -598,6 +598,32 @@ size_t isis_circuit_pdu_size(struct isis
 	return ISO_MTU(circuit);
 }
 
+static bool isis_circuit_lfa_enabled(struct isis_circuit *circuit, int level)
+{
+	return (circuit->lfa_protection[level - 1] ||
+		circuit->rlfa_protection[level - 1] ||
+		circuit->tilfa_protection[level - 1]);
+}
+
+void isis_circuit_switchover_routes(struct isis_circuit *circuit, int family,
+				    union g_addr *nexthop_ip, ifindex_t ifindex)
+{
+	char is_type;
+
+	if (!circuit->area)
+		return;
+
+	is_type = circuit->area->is_type;
+	if ((is_type == IS_LEVEL_1 || is_type == IS_LEVEL_1_AND_2) &&
+	    isis_circuit_lfa_enabled(circuit, IS_LEVEL_1))
+		isis_area_switchover_routes(circuit->area, family, nexthop_ip,
+					    ifindex, IS_LEVEL_1);
+	if ((is_type == IS_LEVEL_2 || is_type == IS_LEVEL_1_AND_2) &&
+	    isis_circuit_lfa_enabled(circuit, IS_LEVEL_2))
+		isis_area_switchover_routes(circuit->area, family, nexthop_ip,
+					    ifindex, IS_LEVEL_2);
+}
+
 void isis_circuit_stream(struct isis_circuit *circuit, struct stream **stream)
 {
 	size_t stream_size = isis_circuit_pdu_size(circuit);
@@ -1602,17 +1628,26 @@ static int isis_ifp_up(struct interface
 {
 	struct isis_circuit *circuit = ifp->info;
 
-	if (circuit)
+	if (circuit) {
+		UNSET_FLAG(circuit->flags, ISIS_CIRCUIT_IF_DOWN_FROM_Z);
 		isis_csm_state_change(IF_UP_FROM_Z, circuit, ifp);
+	}
 
 	return 0;
 }
 
 static int isis_ifp_down(struct interface *ifp)
 {
+	afi_t afi;
 	struct isis_circuit *circuit = ifp->info;
 
-	if (circuit) {
+	if (circuit &&
+	    !CHECK_FLAG(circuit->flags, ISIS_CIRCUIT_IF_DOWN_FROM_Z)) {
+		SET_FLAG(circuit->flags, ISIS_CIRCUIT_IF_DOWN_FROM_Z);
+		for (afi = AFI_IP; afi <= AFI_IP6; afi++)
+			isis_circuit_switchover_routes(
+				circuit, afi == AFI_IP ? AF_INET : AF_INET6,
+				NULL, ifp->ifindex);
 		isis_csm_state_change(IF_DOWN_FROM_Z, circuit, ifp);
 
 		SET_FLAG(circuit->flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF);
diff -urpN frr-frr-8.4.2/isisd/isis_circuit.h frr-frr-8.5/isisd/isis_circuit.h
--- frr-frr-8.4.2/isisd/isis_circuit.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_circuit.h	2023-03-13 20:01:47.000000000 +0600
@@ -28,6 +28,7 @@
 #include "qobj.h"
 #include "prefix.h"
 #include "ferr.h"
+#include "nexthop.h"
 
 #include "isis_constants.h"
 #include "isis_common.h"
@@ -141,6 +142,7 @@ struct isis_circuit {
 	struct list *ipv6_non_link; /* our non-link local IPv6 addresses */
 	uint16_t upadjcount[ISIS_LEVELS];
 #define ISIS_CIRCUIT_FLAPPED_AFTER_SPF 0x01
+#define ISIS_CIRCUIT_IF_DOWN_FROM_Z 0x02
 	uint8_t flags;
 	bool disable_threeway_adj;
 	struct {
@@ -209,6 +211,9 @@ void isis_circuit_print_vty(struct isis_
 void isis_circuit_print_json(struct isis_circuit *circuit,
 			     struct json_object *json, char detail);
 size_t isis_circuit_pdu_size(struct isis_circuit *circuit);
+void isis_circuit_switchover_routes(struct isis_circuit *circuit, int family,
+				    union g_addr *nexthop_ip,
+				    ifindex_t ifindex);
 void isis_circuit_stream(struct isis_circuit *circuit, struct stream **stream);
 
 void isis_circuit_af_set(struct isis_circuit *circuit, bool ip_router,
diff -urpN frr-frr-8.4.2/isisd/isis_cli.c frr-frr-8.5/isisd/isis_cli.c
--- frr-frr-8.4.2/isisd/isis_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,9 +37,7 @@
 #include "isisd/isis_circuit.h"
 #include "isisd/isis_csm.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "isisd/isis_cli_clippy.c"
-#endif
 
 #ifndef FABRICD
 
@@ -63,7 +61,7 @@ DEFPY_YANG_NOSH(router_isis, router_isis
 		 vrf_name);
 	nb_cli_enqueue_change(vty, ".", NB_OP_CREATE, NULL);
 
-	ret = nb_cli_apply_changes(vty, base_xpath);
+	ret = nb_cli_apply_changes(vty, "%s", base_xpath);
 	if (ret == CMD_SUCCESS)
 		VTY_PUSH_XPATH(ISIS_NODE, base_xpath);
 
@@ -404,7 +402,7 @@ DEFPY_YANG(set_overload_bit, set_overloa
       "Reset overload bit to accept transit traffic\n"
       "Set overload bit to avoid any transit traffic\n")
 {
-	nb_cli_enqueue_change(vty, "./overload", NB_OP_MODIFY,
+	nb_cli_enqueue_change(vty, "./overload/enabled", NB_OP_MODIFY,
 			      no ? "false" : "true");
 
 	return nb_cli_apply_changes(vty, NULL);
@@ -419,6 +417,42 @@ void cli_show_isis_overload(struct vty *
 }
 
 /*
+ * XPath: /frr-isisd:isis/instance/overload/on-startup
+ */
+DEFPY_YANG(set_overload_bit_on_startup, set_overload_bit_on_startup_cmd,
+	   "set-overload-bit on-startup (0-86400)$val",
+	   "Set overload bit to avoid any transit traffic\n"
+	   "Set overload bit on startup\n"
+	   "Set overload time in seconds\n")
+{
+	nb_cli_enqueue_change(vty, "./overload/on-startup", NB_OP_MODIFY,
+			      val_str);
+
+	return nb_cli_apply_changes(vty, NULL);
+}
+
+DEFPY_YANG(no_set_overload_bit_on_startup, no_set_overload_bit_on_startup_cmd,
+	   "no set-overload-bit on-startup [(0-86400)$val]",
+	   NO_STR
+	   "Reset overload bit to accept transit traffic\n"
+	   "Set overload bit on startup\n"
+	   "Set overload time in seconds\n")
+{
+	nb_cli_enqueue_change(vty, "./overload/on-startup", NB_OP_DESTROY,
+			      NULL);
+
+	return nb_cli_apply_changes(vty, NULL);
+}
+
+void cli_show_isis_overload_on_startup(struct vty *vty,
+				       const struct lyd_node *dnode,
+				       bool show_defaults)
+{
+	vty_out(vty, " set-overload-bit on-startup %s\n",
+		yang_dnode_get_string(dnode, NULL));
+}
+
+/*
  * XPath: /frr-isisd:isis/instance/attach-send
  */
 DEFPY_YANG(attached_bit_send, attached_bit_send_cmd, "[no] attached-bit send",
@@ -1393,7 +1427,7 @@ DEFPY_YANG(
 				      overload ? "true" : "false");
 	}
 
-	return nb_cli_apply_changes(vty, base_xpath);
+	return nb_cli_apply_changes(vty, "%s", base_xpath);
 }
 
 void cli_show_isis_mt_ipv4_multicast(struct vty *vty,
@@ -3107,6 +3141,9 @@ void isis_cli_init(void)
 	install_element(ISIS_NODE, &dynamic_hostname_cmd);
 
 	install_element(ISIS_NODE, &set_overload_bit_cmd);
+	install_element(ISIS_NODE, &set_overload_bit_on_startup_cmd);
+	install_element(ISIS_NODE, &no_set_overload_bit_on_startup_cmd);
+
 	install_element(ISIS_NODE, &attached_bit_send_cmd);
 	install_element(ISIS_NODE, &attached_bit_receive_ignore_cmd);
 
diff -urpN frr-frr-8.4.2/isisd/isis_lfa.c frr-frr-8.5/isisd/isis_lfa.c
--- frr-frr-8.4.2/isisd/isis_lfa.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_lfa.c	2023-03-13 20:01:47.000000000 +0600
@@ -1836,7 +1836,7 @@ static bool clfa_loop_free_check(struct
 				 struct isis_vertex *vertex_S_D,
 				 struct isis_spf_adj *sadj_primary,
 				 struct isis_spf_adj *sadj_N,
-				 uint32_t *lfa_metric)
+				 uint32_t *path_metric)
 {
 	struct isis_spf_node *node_N;
 	uint32_t dist_N_D;
@@ -1882,7 +1882,7 @@ static bool clfa_loop_free_check(struct
 			   dist_N_S, dist_S_D);
 
 	if (dist_N_D < (dist_N_S + dist_S_D)) {
-		*lfa_metric = sadj_N->metric + dist_N_D;
+		*path_metric = sadj_N->metric + dist_N_D;
 		return true;
 	}
 
@@ -2082,7 +2082,7 @@ void isis_lfa_compute(struct isis_area *
 		      struct isis_spftree *spftree,
 		      struct lfa_protected_resource *resource)
 {
-	struct isis_vertex *vertex;
+	struct isis_vertex *vertex, *parent_vertex;
 	struct listnode *vnode, *snode;
 	int level = spftree->level;
 
@@ -2099,7 +2099,7 @@ void isis_lfa_compute(struct isis_area *
 		struct isis_vertex_adj *vadj_primary;
 		struct isis_spf_adj *sadj_primary;
 		bool allow_ecmp;
-		uint32_t best_metric = UINT32_MAX;
+		uint32_t prefix_metric, best_metric = UINT32_MAX;
 		char buf[VID2STR_BUFFER];
 
 		if (!VTYPE_IP(vertex->type))
@@ -2133,6 +2133,9 @@ void isis_lfa_compute(struct isis_area *
 		vadj_primary = listnode_head(vertex->Adj_N);
 		sadj_primary = vadj_primary->sadj;
 
+		parent_vertex = listnode_head(vertex->parents);
+		prefix_metric = vertex->d_N - parent_vertex->d_N;
+
 		/*
 		 * Loop over list of SPF adjacencies and compute a list of
 		 * preliminary LFAs.
@@ -2140,7 +2143,7 @@ void isis_lfa_compute(struct isis_area *
 		lfa_list = list_new();
 		lfa_list->del = isis_vertex_adj_free;
 		for (ALL_LIST_ELEMENTS_RO(spftree->sadj_list, snode, sadj_N)) {
-			uint32_t lfa_metric;
+			uint32_t lfa_metric, path_metric;
 			struct isis_vertex_adj *lfa;
 			struct isis_prefix_sid *psid = NULL;
 			bool last_hop = false;
@@ -2190,7 +2193,7 @@ void isis_lfa_compute(struct isis_area *
 
 			/* Check loop-free criterion. */
 			if (!clfa_loop_free_check(spftree, vertex, sadj_primary,
-						  sadj_N, &lfa_metric)) {
+						  sadj_N, &path_metric)) {
 				if (IS_DEBUG_LFA)
 					zlog_debug(
 						"ISIS-LFA: LFA condition not met for %s",
@@ -2198,6 +2201,7 @@ void isis_lfa_compute(struct isis_area *
 				continue;
 			}
 
+			lfa_metric = path_metric + prefix_metric;
 			if (lfa_metric < best_metric)
 				best_metric = lfa_metric;
 
@@ -2208,7 +2212,7 @@ void isis_lfa_compute(struct isis_area *
 
 			if (vertex->N.ip.sr.present) {
 				psid = &vertex->N.ip.sr.sid;
-				if (lfa_metric == sadj_N->metric)
+				if (path_metric == sadj_N->metric)
 					last_hop = true;
 			}
 			lfa = isis_vertex_adj_add(spftree, vertex, lfa_list,
diff -urpN frr-frr-8.4.2/isisd/isis_lsp.c frr-frr-8.5/isisd/isis_lsp.c
--- frr-frr-8.4.2/isisd/isis_lsp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_lsp.c	2023-03-13 20:01:47.000000000 +0600
@@ -68,6 +68,8 @@ static void lsp_l2_refresh_pseudo(struct
 
 static void lsp_destroy(struct isis_lsp *lsp);
 
+static bool device_startup;
+
 int lsp_id_cmp(uint8_t *id1, uint8_t *id2)
 {
 	return memcmp(id1, id2, ISIS_SYS_ID_LEN + 2);
@@ -437,6 +439,21 @@ bool isis_level2_adj_up(struct isis_area
 	return false;
 }
 
+/*
+ * Unset the overload bit after the timer expires
+ */
+void set_overload_on_start_timer(struct thread *thread)
+{
+	struct isis_area *area = THREAD_ARG(thread);
+	assert(area);
+
+	area->t_overload_on_startup_timer = NULL;
+
+	/* Check if set-overload-bit is not currently configured */
+	if (!area->overload_configured)
+		isis_area_overload_bit_set(area, false);
+}
+
 static void isis_reset_attach_bit(struct isis_adjacency *adj)
 {
 	struct isis_area *area = adj->circuit->area;
@@ -1355,6 +1372,7 @@ int lsp_generate(struct isis_area *area,
 	uint32_t seq_num = 0;
 	uint8_t lspid[ISIS_SYS_ID_LEN + 2];
 	uint16_t rem_lifetime, refresh_time;
+	uint32_t overload_time;
 
 	if ((area == NULL) || (area->is_type & level) != level)
 		return ISIS_ERROR;
@@ -1363,6 +1381,18 @@ int lsp_generate(struct isis_area *area,
 
 	memcpy(&lspid, area->isis->sysid, ISIS_SYS_ID_LEN);
 
+	/* Check if device should be overloaded on startup */
+	if (device_startup) {
+		overload_time = isis_restart_read_overload_time(area);
+		if (overload_time > 0) {
+			isis_area_overload_bit_set(area, true);
+			thread_add_timer(master, set_overload_on_start_timer,
+					 area, overload_time,
+					 &area->t_overload_on_startup_timer);
+		}
+		device_startup = false;
+	}
+
 	/* only builds the lsp if the area shares the level */
 	oldlsp = lsp_search(&area->lspdb[level - 1], lspid);
 	if (oldlsp) {
@@ -2373,6 +2403,7 @@ int isis_lsp_iterate_is_reach(struct isi
 
 void lsp_init(void)
 {
+	device_startup = true;
 	hook_register(isis_adj_state_change_hook,
 		      lsp_handle_adj_state_change);
 }
diff -urpN frr-frr-8.4.2/isisd/isis_lsp.h frr-frr-8.5/isisd/isis_lsp.h
--- frr-frr-8.4.2/isisd/isis_lsp.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_lsp.h	2023-03-13 20:01:47.000000000 +0600
@@ -66,6 +66,7 @@ DECLARE_RBTREE_UNIQ(lspdb, struct isis_l
 void lsp_db_init(struct lspdb_head *head);
 void lsp_db_fini(struct lspdb_head *head);
 void lsp_tick(struct thread *thread);
+void set_overload_on_start_timer(struct thread *thread);
 
 int lsp_generate(struct isis_area *area, int level);
 #define lsp_regenerate_schedule(area, level, all_pseudo) \
diff -urpN frr-frr-8.4.2/isisd/isis_nb.c frr-frr-8.5/isisd/isis_nb.c
--- frr-frr-8.4.2/isisd/isis_nb.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_nb.c	2023-03-13 20:01:47.000000000 +0600
@@ -81,11 +81,18 @@ const struct frr_yang_module_info frr_is
 			},
 		},
 		{
-			.xpath = "/frr-isisd:isis/instance/overload",
+			.xpath = "/frr-isisd:isis/instance/overload/enabled",
 			.cbs = {
 				.cli_show = cli_show_isis_overload,
-				.modify = isis_instance_overload_modify,
-			},
+				.modify = isis_instance_overload_enabled_modify,
+			}
+		},
+		{
+			.xpath = "/frr-isisd:isis/instance/overload/on-startup",
+			.cbs = {
+				.cli_show = cli_show_isis_overload_on_startup,
+				.modify = isis_instance_overload_on_startup_modify,
+			}
 		},
 		{
 			.xpath = "/frr-isisd:isis/instance/metric-style",
@@ -1100,6 +1107,66 @@ const struct frr_yang_module_info frr_is
 			}
 		},
 		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid",
+			.cbs = {
+				.get_next = lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_get_next,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/af",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_af_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/value",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_value_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/weight",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_weight_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/protection-requested",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_protection_requested_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid",
+			.cbs = {
+				.get_next = lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_get_next,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/af",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_af_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/value",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_value_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/weight",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_weight_get_elem,
+			}
+		},
+		{
+			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/protection-requested",
+			.cbs = {
+				.get_elem = lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_protection_requested_get_elem,
+			}
+		},
+		{
 			.xpath = "/frr-interface:lib/interface/state/frr-isisd:isis/event-counters/adjacency-changes",
 			.cbs = {
 				.get_elem = lib_interface_state_isis_event_counters_adjacency_changes_get_elem,
diff -urpN frr-frr-8.4.2/isisd/isis_nb.h frr-frr-8.5/isisd/isis_nb.h
--- frr-frr-8.4.2/isisd/isis_nb.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_nb.h	2023-03-13 20:01:47.000000000 +0600
@@ -37,7 +37,8 @@ int isis_instance_dynamic_hostname_modif
 int isis_instance_attached_send_modify(struct nb_cb_modify_args *args);
 int isis_instance_attached_receive_modify(struct nb_cb_modify_args *args);
 int isis_instance_attached_modify(struct nb_cb_modify_args *args);
-int isis_instance_overload_modify(struct nb_cb_modify_args *args);
+int isis_instance_overload_enabled_modify(struct nb_cb_modify_args *args);
+int isis_instance_overload_on_startup_modify(struct nb_cb_modify_args *args);
 int isis_instance_metric_style_modify(struct nb_cb_modify_args *args);
 int isis_instance_purge_originator_modify(struct nb_cb_modify_args *args);
 int isis_instance_lsp_mtu_modify(struct nb_cb_modify_args *args);
@@ -368,6 +369,36 @@ lib_interface_state_isis_adjacencies_adj
 	struct nb_cb_get_elem_args *args);
 struct yang_data *lib_interface_state_isis_adjacencies_adjacency_state_get_elem(
 	struct nb_cb_get_elem_args *args);
+const void *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_get_next(
+	struct nb_cb_get_next_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_af_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_value_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_weight_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_protection_requested_get_elem(
+	struct nb_cb_get_elem_args *args);
+const void *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_get_next(
+	struct nb_cb_get_next_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_af_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_value_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_weight_get_elem(
+	struct nb_cb_get_elem_args *args);
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_protection_requested_get_elem(
+	struct nb_cb_get_elem_args *args);
 struct yang_data *
 lib_interface_state_isis_event_counters_adjacency_changes_get_elem(
 	struct nb_cb_get_elem_args *args);
@@ -442,6 +473,9 @@ void cli_show_isis_attached_receive(stru
 				    bool show_defaults);
 void cli_show_isis_overload(struct vty *vty, const struct lyd_node *dnode,
 			    bool show_defaults);
+void cli_show_isis_overload_on_startup(struct vty *vty,
+				       const struct lyd_node *dnode,
+				       bool show_defaults);
 void cli_show_isis_metric_style(struct vty *vty, const struct lyd_node *dnode,
 				bool show_defaults);
 void cli_show_isis_area_pwd(struct vty *vty, const struct lyd_node *dnode,
diff -urpN frr-frr-8.4.2/isisd/isis_nb_config.c frr-frr-8.5/isisd/isis_nb_config.c
--- frr-frr-8.4.2/isisd/isis_nb_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_nb_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -336,9 +336,9 @@ int isis_instance_attached_modify(struct
 }
 
 /*
- * XPath: /frr-isisd:isis/instance/overload
+ * XPath: /frr-isisd:isis/instance/overload/enabled
  */
-int isis_instance_overload_modify(struct nb_cb_modify_args *args)
+int isis_instance_overload_enabled_modify(struct nb_cb_modify_args *args)
 {
 	struct isis_area *area;
 	bool overload;
@@ -348,10 +348,30 @@ int isis_instance_overload_modify(struct
 
 	area = nb_running_get_entry(args->dnode, NULL, true);
 	overload = yang_dnode_get_bool(args->dnode, NULL);
+	area->overload_configured = overload;
+
 	isis_area_overload_bit_set(area, overload);
 
 	return NB_OK;
 }
+
+/*
+ * XPath: /frr-isisd:isis/instance/overload/on-startup
+ */
+int isis_instance_overload_on_startup_modify(struct nb_cb_modify_args *args)
+{
+	struct isis_area *area;
+	uint32_t overload_time;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	overload_time = yang_dnode_get_uint32(args->dnode, NULL);
+	area = nb_running_get_entry(args->dnode, NULL, true);
+	isis_area_overload_on_startup_set(area, overload_time);
+
+	return NB_OK;
+}
 
 /*
  * XPath: /frr-isisd:isis/instance/metric-style
diff -urpN frr-frr-8.4.2/isisd/isis_nb_state.c frr-frr-8.5/isisd/isis_nb_state.c
--- frr-frr-8.4.2/isisd/isis_nb_state.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_nb_state.c	2023-03-13 20:01:47.000000000 +0600
@@ -216,6 +216,228 @@ struct yang_data *lib_interface_state_is
 
 /*
  * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid
+ */
+const void *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_get_next(
+	struct nb_cb_get_next_args *args)
+{
+	const struct isis_adjacency *adj = args->parent_list_entry;
+	const struct sr_adjacency *sra = args->list_entry, *sra_next = NULL;
+	struct listnode *node, *node_next;
+
+	if (args->list_entry == NULL)
+		sra_next = listnode_head(adj->adj_sids);
+	else {
+		node = listnode_lookup(adj->adj_sids, sra);
+		node_next = listnextnode(node);
+		if (node_next)
+			sra_next = listgetdata(node_next);
+	}
+
+	return sra_next;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/af
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_af_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		/* Adjacency SID is not published with circuit type Broadcast */
+		return NULL;
+	case CIRCUIT_T_P2P:
+		return yang_data_new_uint8(args->xpath, sra->u.adj_sid->family);
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/value
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_value_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		/* Adjacency SID is not published with circuit type Broadcast */
+		return NULL;
+	case CIRCUIT_T_P2P:
+		return yang_data_new_uint32(args->xpath, sra->u.adj_sid->sid);
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/weight
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_weight_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		/* Adjacency SID is not published with circuit type Broadcast */
+		return NULL;
+	case CIRCUIT_T_P2P:
+		return yang_data_new_uint8(args->xpath, sra->u.adj_sid->weight);
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/adjacency-sids/adjacency-sid/protection-requested
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_adjacency_sids_adjacency_sid_protection_requested_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		/* Adjacency SID is not published with circuit type Broadcast */
+		return NULL;
+	case CIRCUIT_T_P2P:
+		return yang_data_new_bool(args->xpath,
+					  sra->u.adj_sid->flags &
+						  EXT_SUBTLV_LINK_ADJ_SID_BFLG);
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid
+ */
+const void *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_get_next(
+	struct nb_cb_get_next_args *args)
+{
+	const struct isis_adjacency *adj = args->parent_list_entry;
+	const struct sr_adjacency *sra = args->list_entry, *sra_next = NULL;
+	struct listnode *node, *node_next;
+
+	if (args->list_entry == NULL)
+		sra_next = listnode_head(adj->adj_sids);
+	else {
+		node = listnode_lookup(adj->adj_sids, sra);
+		node_next = listnextnode(node);
+		if (node_next)
+			sra_next = listgetdata(node_next);
+	}
+
+	return sra_next;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/af
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_af_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		return yang_data_new_uint8(args->xpath,
+					   sra->u.ladj_sid->family);
+	case CIRCUIT_T_P2P:
+		/* LAN adjacency SID is not published with circuit type P2P */
+		return NULL;
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/value
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_value_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		return yang_data_new_uint32(args->xpath, sra->u.ladj_sid->sid);
+	case CIRCUIT_T_P2P:
+		/* LAN adjacency SID is not published with circuit type P2P */
+		return NULL;
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/weight
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_weight_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		return yang_data_new_uint8(args->xpath,
+					   sra->u.ladj_sid->weight);
+	case CIRCUIT_T_P2P:
+		/* LAN adjacency SID is not published with circuit type P2P */
+		return NULL;
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
+ * /frr-interface:lib/interface/state/frr-isisd:isis/adjacencies/adjacency/lan-adjacency-sids/lan-adjacency-sid/protection-requested
+ */
+struct yang_data *
+lib_interface_state_isis_adjacencies_adjacency_lan_adjacency_sids_lan_adjacency_sid_protection_requested_get_elem(
+	struct nb_cb_get_elem_args *args)
+{
+	const struct sr_adjacency *sra = args->list_entry;
+
+	switch (sra->adj->circuit->circ_type) {
+	case CIRCUIT_T_BROADCAST:
+		return yang_data_new_bool(args->xpath,
+					  sra->u.ladj_sid->flags &
+						  EXT_SUBTLV_LINK_ADJ_SID_BFLG);
+	case CIRCUIT_T_P2P:
+		/* LAN adjacency SID is not published with circuit type P2P */
+		return NULL;
+	}
+
+	return NULL;
+}
+
+/*
+ * XPath:
  * /frr-interface:lib/interface/state/frr-isisd:isis/event-counters/adjacency-changes
  */
 struct yang_data *
diff -urpN frr-frr-8.4.2/isisd/isis_route.c frr-frr-8.5/isisd/isis_route.c
--- frr-frr-8.4.2/isisd/isis_route.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_route.c	2023-03-13 20:01:47.000000000 +0600
@@ -91,11 +91,18 @@ static struct isis_nexthop *nexthoplooku
 	struct isis_nexthop *nh;
 
 	for (ALL_LIST_ELEMENTS_RO(nexthops, node, nh)) {
-		if (nh->family != family)
-			continue;
 		if (nh->ifindex != ifindex)
 			continue;
 
+		/* if the IP is unspecified, return the first nexthop found on
+		 * the interface
+		 */
+		if (!ip)
+			return nh;
+
+		if (nh->family != family)
+			continue;
+
 		switch (family) {
 		case AF_INET:
 			if (IPV4_ADDR_CMP(&nh->ip.ipv4, &ip->ipv4))
@@ -459,6 +466,21 @@ void isis_route_delete(struct isis_area
 	route_unlock_node(rode);
 }
 
+static void isis_route_remove_previous_sid(struct isis_area *area,
+					   struct prefix *prefix,
+					   struct isis_route_info *route_info)
+{
+	/*
+	 * Explicitly uninstall previous Prefix-SID label if it has
+	 * changed or was removed.
+	 */
+	if (route_info->sr_previous.present &&
+	    (!route_info->sr.present ||
+	     route_info->sr_previous.label != route_info->sr.label))
+		isis_zebra_prefix_sid_uninstall(area, prefix, route_info,
+						&route_info->sr_previous);
+}
+
 static void isis_route_update(struct isis_area *area, struct prefix *prefix,
 			      struct prefix_ipv6 *src_p,
 			      struct isis_route_info *route_info)
@@ -470,17 +492,7 @@ static void isis_route_update(struct isi
 		if (CHECK_FLAG(route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))
 			return;
 
-		/*
-		 * Explicitly uninstall previous Prefix-SID label if it has
-		 * changed or was removed.
-		 */
-		if (route_info->sr_previous.present
-		    && (!route_info->sr.present
-			|| route_info->sr_previous.label
-				   != route_info->sr.label))
-			isis_zebra_prefix_sid_uninstall(
-				area, prefix, route_info,
-				&route_info->sr_previous);
+		isis_route_remove_previous_sid(area, prefix, route_info);
 
 		/* Install route. */
 		isis_zebra_route_add_route(area->isis, prefix, src_p,
@@ -727,3 +739,54 @@ void isis_route_invalidate_table(struct
 		UNSET_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ACTIVE);
 	}
 }
+
+void isis_route_switchover_nexthop(struct isis_area *area,
+				   struct route_table *table, int family,
+				   union g_addr *nexthop_addr,
+				   ifindex_t ifindex)
+{
+	const char *ifname = NULL, *vrfname = NULL;
+	struct isis_route_info *rinfo;
+	struct prefix_ipv6 *src_p;
+	struct route_node *rnode;
+	vrf_id_t vrf_id;
+	struct prefix *prefix;
+
+	if (IS_DEBUG_EVENTS) {
+		if (area && area->isis) {
+			vrf_id = area->isis->vrf_id;
+			vrfname = vrf_id_to_name(vrf_id);
+			ifname = ifindex2ifname(ifindex, vrf_id);
+		}
+		zlog_debug("%s: initiating fast-reroute %s on VRF %s iface %s",
+			   __func__, family2str(family), vrfname ? vrfname : "",
+			   ifname ? ifname : "");
+	}
+
+	for (rnode = route_top(table); rnode;
+	     rnode = srcdest_route_next(rnode)) {
+		if (!rnode->info)
+			continue;
+		rinfo = rnode->info;
+
+		if (!rinfo->backup)
+			continue;
+
+		if (!nexthoplookup(rinfo->nexthops, family, nexthop_addr,
+				   ifindex))
+			continue;
+
+		srcdest_rnode_prefixes(rnode, (const struct prefix **)&prefix,
+				       (const struct prefix **)&src_p);
+
+		/* Switchover route. */
+		isis_route_remove_previous_sid(area, prefix, rinfo);
+		UNSET_FLAG(rinfo->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);
+		isis_route_update(area, prefix, src_p, rinfo->backup);
+
+		isis_route_info_delete(rinfo);
+
+		rnode->info = NULL;
+		route_unlock_node(rnode);
+	}
+}
diff -urpN frr-frr-8.4.2/isisd/isis_route.h frr-frr-8.5/isisd/isis_route.h
--- frr-frr-8.4.2/isisd/isis_route.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_route.h	2023-03-13 20:01:47.000000000 +0600
@@ -86,4 +86,9 @@ void isis_route_invalidate_table(struct
 void isis_route_node_cleanup(struct route_table *table,
 			     struct route_node *node);
 
+void isis_route_switchover_nexthop(struct isis_area *area,
+				   struct route_table *table, int family,
+				   union g_addr *nexthop_addr,
+				   ifindex_t ifindex);
+
 #endif /* _ZEBRA_ISIS_ROUTE_H */
diff -urpN frr-frr-8.4.2/isisd/isis_spf.c frr-frr-8.5/isisd/isis_spf.c
--- frr-frr-8.4.2/isisd/isis_spf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_spf.c	2023-03-13 20:01:47.000000000 +0600
@@ -1853,6 +1853,15 @@ void isis_spf_invalidate_routes(struct i
 	tree->route_table_backup->cleanup = isis_route_node_cleanup;
 }
 
+void isis_spf_switchover_routes(struct isis_area *area,
+				struct isis_spftree **trees, int family,
+				union g_addr *nexthop_ip, ifindex_t ifindex,
+				int level)
+{
+	isis_route_switchover_nexthop(area, trees[level - 1]->route_table,
+				      family, nexthop_ip, ifindex);
+}
+
 static void isis_run_spf_cb(struct thread *thread)
 {
 	struct isis_spf_run *run = THREAD_ARG(thread);
@@ -1924,9 +1933,19 @@ void isis_spf_timer_free(void *run)
 int _isis_spf_schedule(struct isis_area *area, int level,
 		       const char *func, const char *file, int line)
 {
-	struct isis_spftree *spftree = area->spftree[SPFTREE_IPV4][level - 1];
-	time_t now = monotime(NULL);
-	int diff = now - spftree->last_run_monotime;
+	struct isis_spftree *spftree;
+	time_t now;
+	long tree_diff, diff;
+	int tree;
+
+	now = monotime(NULL);
+	diff = 0;
+	for (tree = SPFTREE_IPV4; tree < SPFTREE_COUNT; tree++) {
+		spftree = area->spftree[tree][level - 1];
+		tree_diff = difftime(now - spftree->last_run_monotime, 0);
+		if (tree_diff != now && (diff == 0 || tree_diff < diff))
+			diff = tree_diff;
+	}
 
 	if (CHECK_FLAG(im->options, F_ISIS_UNIT_TEST))
 		return 0;
@@ -1936,7 +1955,7 @@ int _isis_spf_schedule(struct isis_area
 
 	if (IS_DEBUG_SPF_EVENTS) {
 		zlog_debug(
-			"ISIS-SPF (%s) L%d SPF schedule called, lastrun %d sec ago Caller: %s %s:%d",
+			"ISIS-SPF (%s) L%d SPF schedule called, lastrun %ld sec ago Caller: %s %s:%d",
 			area->area_tag, level, diff, func, file, line);
 	}
 
@@ -2695,12 +2714,14 @@ void isis_spf_init(void)
 
 void isis_spf_print(struct isis_spftree *spftree, struct vty *vty)
 {
+	uint64_t last_run_duration = spftree->last_run_duration;
+
 	vty_out(vty, "      last run elapsed  : ");
 	vty_out_timestr(vty, spftree->last_run_timestamp);
 	vty_out(vty, "\n");
 
-	vty_out(vty, "      last run duration : %u usec\n",
-		(uint32_t)spftree->last_run_duration);
+	vty_out(vty, "      last run duration : %" PRIu64 " usec\n",
+		last_run_duration);
 
 	vty_out(vty, "      run count         : %u\n", spftree->runcount);
 }
diff -urpN frr-frr-8.4.2/isisd/isis_spf.h frr-frr-8.5/isisd/isis_spf.h
--- frr-frr-8.4.2/isisd/isis_spf.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_spf.h	2023-03-13 20:01:47.000000000 +0600
@@ -60,6 +60,10 @@ struct isis_vertex *isis_spf_prefix_sid_
 void isis_spf_invalidate_routes(struct isis_spftree *tree);
 void isis_spf_verify_routes(struct isis_area *area,
 			    struct isis_spftree **trees);
+void isis_spf_switchover_routes(struct isis_area *area,
+				struct isis_spftree **trees, int family,
+				union g_addr *nexthop_ip, ifindex_t ifindex,
+				int level);
 void isis_spftree_del(struct isis_spftree *spftree);
 void spftree_area_init(struct isis_area *area);
 void spftree_area_del(struct isis_area *area);
diff -urpN frr-frr-8.4.2/isisd/isis_sr.c frr-frr-8.5/isisd/isis_sr.c
--- frr-frr-8.4.2/isisd/isis_sr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_sr.c	2023-03-13 20:01:47.000000000 +0600
@@ -1057,8 +1057,9 @@ static void show_node(struct vty *vty, s
 }
 
 DEFUN(show_sr_node, show_sr_node_cmd,
-      "show isis segment-routing node",
-      SHOW_STR PROTO_HELP
+      "show " PROTO_NAME " segment-routing node",
+      SHOW_STR
+      PROTO_HELP
       "Segment-Routing\n"
       "Segment-Routing node\n")
 {
diff -urpN frr-frr-8.4.2/isisd/isis_te.c frr-frr-8.5/isisd/isis_te.c
--- frr-frr-8.4.2/isisd/isis_te.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isis_te.c	2023-03-13 20:01:47.000000000 +0600
@@ -66,6 +66,8 @@
 
 DEFINE_MTYPE_STATIC(ISISD, ISIS_MPLS_TE,    "ISIS MPLS_TE parameters");
 
+static void isis_mpls_te_circuit_ip_update(struct isis_circuit *circuit);
+
 /*------------------------------------------------------------------------*
  * Following are control functions for MPLS-TE parameters management.
  *------------------------------------------------------------------------*/
@@ -111,9 +113,13 @@ void isis_mpls_te_create(struct isis_are
 	if (area->mta->ted)
 		isis_te_init_ted(area);
 
-	/* Update Extended TLVs according to Interface link parameters */
-	for (ALL_LIST_ELEMENTS_RO(area->circuit_list, node, circuit))
+	/* Update Extended TLVs according to Interface link parameters
+	 * and neighbor IP addresses
+	 */
+	for (ALL_LIST_ELEMENTS_RO(area->circuit_list, node, circuit)) {
 		isis_link_params_update(circuit, circuit->interface);
+		isis_mpls_te_circuit_ip_update(circuit);
+	}
 }
 
 /**
@@ -132,7 +138,7 @@ void isis_mpls_te_disable(struct isis_ar
 	area->mta->status = disable;
 
 	/* Remove Link State Database */
-	ls_ted_del_all(&area->mta->ted);
+	ls_ted_clean(area->mta->ted);
 
 	/* Disable Extended SubTLVs on all circuit */
 	for (ALL_LIST_ELEMENTS_RO(area->circuit_list, node, circuit)) {
@@ -336,16 +342,12 @@ void isis_link_params_update(struct isis
 	return;
 }
 
-static int isis_mpls_te_adj_ip_enabled(struct isis_adjacency *adj, int family,
-				       bool global)
+static int _isis_mpls_te_adj_ip_enabled(struct isis_adjacency *adj, int family,
+					bool global)
 {
 	struct isis_circuit *circuit;
 	struct isis_ext_subtlvs *ext;
 
-	/* Sanity Check */
-	if (!adj || !adj->circuit)
-		return 0;
-
 	circuit = adj->circuit;
 
 	/* Check that MPLS TE is enabled */
@@ -366,6 +368,12 @@ static int isis_mpls_te_adj_ip_enabled(s
 		}
 		break;
 	case AF_INET6:
+		/* Nothing to do for link-local addresses - ie. not global.
+		 * https://datatracker.ietf.org/doc/html/rfc6119#section-3.1.1
+		 * Because the IPv6 traffic engineering TLVs present in LSPs are
+		 * propagated across networks, they MUST NOT use link-local
+		 * addresses.
+		 */
 		if (!global)
 			return 0;
 
@@ -381,22 +389,32 @@ static int isis_mpls_te_adj_ip_enabled(s
 		return 0;
 	}
 
-	/* Update LSP */
-	lsp_regenerate_schedule(circuit->area, circuit->is_type, 0);
-
 	return 0;
 }
 
-static int isis_mpls_te_adj_ip_disabled(struct isis_adjacency *adj, int family,
-					bool global)
+static int isis_mpls_te_adj_ip_enabled(struct isis_adjacency *adj, int family,
+				       bool global)
 {
-	struct isis_circuit *circuit;
-	struct isis_ext_subtlvs *ext;
+	int ret;
 
 	/* Sanity Check */
-	if (!adj || !adj->circuit || !adj->circuit->ext)
+	if (!adj || !adj->circuit)
 		return 0;
 
+	ret = _isis_mpls_te_adj_ip_enabled(adj, family, global);
+
+	/* Update LSP */
+	lsp_regenerate_schedule(adj->circuit->area, adj->circuit->is_type, 0);
+
+	return ret;
+}
+
+static int _isis_mpls_te_adj_ip_disabled(struct isis_adjacency *adj, int family,
+					 bool global)
+{
+	struct isis_circuit *circuit;
+	struct isis_ext_subtlvs *ext;
+
 	circuit = adj->circuit;
 
 	/* Check that MPLS TE is enabled */
@@ -422,12 +440,59 @@ static int isis_mpls_te_adj_ip_disabled(
 		return 0;
 	}
 
+	return 0;
+}
+
+static int isis_mpls_te_adj_ip_disabled(struct isis_adjacency *adj, int family,
+					bool global)
+{
+	int ret;
+
+	/* Sanity Check */
+	if (!adj || !adj->circuit || !adj->circuit->ext)
+		return 0;
+
+	ret = _isis_mpls_te_adj_ip_disabled(adj, family, global);
+
 	/* Update LSP */
-	lsp_regenerate_schedule(circuit->area, circuit->is_type, 0);
+	lsp_regenerate_schedule(adj->circuit->area, adj->circuit->is_type, 0);
 
-	return 0;
+	return ret;
 }
 
+static void isis_mpls_te_circuit_ip_update(struct isis_circuit *circuit)
+{
+	struct isis_adjacency *adj;
+
+	/* https://datatracker.ietf.org/doc/html/rfc6119#section-3.2.3
+	 * This sub-TLV of the Extended IS Reachability TLV is used for point-
+	 * to-point links
+	 */
+	if (circuit->circ_type != CIRCUIT_T_P2P)
+		return;
+
+	adj = circuit->u.p2p.neighbor;
+
+	if (!adj)
+		return;
+
+	/* Nothing to do for link-local addresses.
+	 * https://datatracker.ietf.org/doc/html/rfc6119#section-3.1.1
+	 * Because the IPv6 traffic engineering TLVs present in LSPs are
+	 * propagated across networks, they MUST NOT use link-local addresses.
+	 */
+	if (adj->ipv4_address_count > 0)
+		_isis_mpls_te_adj_ip_enabled(adj, AF_INET, false);
+	else
+		_isis_mpls_te_adj_ip_disabled(adj, AF_INET, false);
+
+	if (adj->global_ipv6_count > 0)
+		_isis_mpls_te_adj_ip_enabled(adj, AF_INET6, true);
+	else
+		_isis_mpls_te_adj_ip_disabled(adj, AF_INET6, true);
+}
+
+
 int isis_mpls_te_update(struct interface *ifp)
 {
 	struct isis_circuit *circuit;
diff -urpN frr-frr-8.4.2/isisd/isisd.c frr-frr-8.5/isisd/isisd.c
--- frr-frr-8.4.2/isisd/isisd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isisd.c	2023-03-13 20:01:47.000000000 +0600
@@ -723,7 +723,7 @@ void isis_vrf_init(void)
 	vrf_cmd_init(NULL);
 }
 
-void isis_terminate()
+void isis_terminate(void)
 {
 	struct isis *isis;
 	struct listnode *node, *nnode;
@@ -1700,6 +1700,8 @@ DEFUN_NOSH (show_debugging,
 	if (IS_DEBUG_LFA)
 		print_debug(vty, DEBUG_LFA, 1);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -2743,7 +2745,6 @@ static void show_isis_database_json(stru
 	struct isis_area *area;
 	int level;
 	struct json_object *tag_area_json,*area_json, *lsp_json, *area_arr_json, *arr_json;
-	uint8_t area_cnt = 0;
 
 	if (isis->area_list->count == 0)
 		return;
@@ -2768,7 +2769,6 @@ static void show_isis_database_json(stru
 			json_object_array_add(arr_json, lsp_json);
 		}
 		json_object_array_add(area_arr_json, area_json);
-		area_cnt++;
 	}
 }
 
@@ -3090,6 +3090,25 @@ void isis_area_verify_routes(struct isis
 		isis_spf_verify_routes(area, area->spftree[tree]);
 }
 
+void isis_area_switchover_routes(struct isis_area *area, int family,
+				 union g_addr *nexthop_ip, ifindex_t ifindex,
+				 int level)
+{
+	int tree;
+
+	/* TODO SPFTREE_DSTSRC */
+	if (family == AF_INET)
+		tree = SPFTREE_IPV4;
+	else if (family == AF_INET6)
+		tree = SPFTREE_IPV6;
+	else
+		return;
+
+	isis_spf_switchover_routes(area, area->spftree[tree], family,
+				   nexthop_ip, ifindex, level);
+}
+
+
 static void area_resign_level(struct isis_area *area, int level)
 {
 	isis_area_invalidate_routes(area, level);
@@ -3196,9 +3215,15 @@ void isis_area_overload_bit_set(struct i
 
 	if (new_overload_bit != area->overload_bit) {
 		area->overload_bit = new_overload_bit;
-
-		if (new_overload_bit)
+		if (new_overload_bit) {
 			area->overload_counter++;
+		} else {
+			/* Cancel overload on startup timer if it's running */
+			if (area->t_overload_on_startup_timer) {
+				THREAD_OFF(area->t_overload_on_startup_timer);
+				area->t_overload_on_startup_timer = NULL;
+			}
+		}
 
 #ifndef FABRICD
 		hook_call(isis_hook_db_overload, area);
@@ -3211,6 +3236,109 @@ void isis_area_overload_bit_set(struct i
 #endif /* ifndef FABRICD */
 }
 
+void isis_area_overload_on_startup_set(struct isis_area *area,
+				       uint32_t startup_time)
+{
+	if (area->overload_on_startup_time != startup_time) {
+		area->overload_on_startup_time = startup_time;
+		isis_restart_write_overload_time(area, startup_time);
+	}
+}
+
+/*
+ * Returns the path of the file (non-volatile memory) that contains restart
+ * information.
+ */
+char *isis_restart_filepath(void)
+{
+	static char filepath[MAXPATHLEN];
+	snprintf(filepath, sizeof(filepath), ISISD_RESTART, "");
+	return filepath;
+}
+
+/*
+ * Record in non-volatile memory the overload on startup time.
+ */
+void isis_restart_write_overload_time(struct isis_area *isis_area,
+				      uint32_t overload_time)
+{
+	char *filepath;
+	const char *area_name;
+	json_object *json;
+	json_object *json_areas;
+	json_object *json_area;
+
+	filepath = isis_restart_filepath();
+	area_name = isis_area->area_tag;
+
+	json = json_object_from_file(filepath);
+	if (json == NULL)
+		json = json_object_new_object();
+
+	json_object_object_get_ex(json, "areas", &json_areas);
+	if (!json_areas) {
+		json_areas = json_object_new_object();
+		json_object_object_add(json, "areas", json_areas);
+	}
+
+	json_object_object_get_ex(json_areas, area_name, &json_area);
+	if (!json_area) {
+		json_area = json_object_new_object();
+		json_object_object_add(json_areas, area_name, json_area);
+	}
+
+	json_object_int_add(json_area, "overload_time",
+			    isis_area->overload_on_startup_time);
+	json_object_to_file_ext(filepath, json, JSON_C_TO_STRING_PRETTY);
+	json_object_free(json);
+}
+
+/*
+ * Fetch from non-volatile memory the overload on startup time.
+ */
+uint32_t isis_restart_read_overload_time(struct isis_area *isis_area)
+{
+	char *filepath;
+	const char *area_name;
+	json_object *json;
+	json_object *json_areas;
+	json_object *json_area;
+	json_object *json_overload_time;
+	uint32_t overload_time = 0;
+
+	filepath = isis_restart_filepath();
+	area_name = isis_area->area_tag;
+
+	json = json_object_from_file(filepath);
+	if (json == NULL)
+		json = json_object_new_object();
+
+	json_object_object_get_ex(json, "areas", &json_areas);
+	if (!json_areas) {
+		json_areas = json_object_new_object();
+		json_object_object_add(json, "areas", json_areas);
+	}
+
+	json_object_object_get_ex(json_areas, area_name, &json_area);
+	if (!json_area) {
+		json_area = json_object_new_object();
+		json_object_object_add(json_areas, area_name, json_area);
+	}
+
+	json_object_object_get_ex(json_area, "overload_time",
+				  &json_overload_time);
+	if (json_overload_time) {
+		overload_time = json_object_get_int(json_overload_time);
+	}
+
+	json_object_object_del(json_areas, area_name);
+
+	json_object_to_file_ext(filepath, json, JSON_C_TO_STRING_PRETTY);
+	json_object_free(json);
+
+	return overload_time;
+}
+
 void isis_area_attached_bit_send_set(struct isis_area *area, bool attached_bit)
 {
 
diff -urpN frr-frr-8.4.2/isisd/isisd.h frr-frr-8.5/isisd/isisd.h
--- frr-frr-8.4.2/isisd/isisd.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/isisd.h	2023-03-13 20:01:47.000000000 +0600
@@ -142,6 +142,7 @@ struct isis_area {
 	struct flags flags;
 	struct thread *t_tick; /* LSP walker */
 	struct thread *t_lsp_refresh[ISIS_LEVELS];
+	struct thread *t_overload_on_startup_timer;
 	struct timeval last_lsp_refresh_event[ISIS_LEVELS];
 	struct thread *t_rlfa_rib_update;
 	/* t_lsp_refresh is used in two ways:
@@ -180,7 +181,9 @@ struct isis_area {
 	char is_type; /* level-1 level-1-2 or level-2-only */
 	/* are we overloaded? */
 	char overload_bit;
+	bool overload_configured;
 	uint32_t overload_counter;
+	uint32_t overload_on_startup_time;
 	/* L1/L2 router identifier for inter-area traffic */
 	char attached_bit_send;
 	char attached_bit_rcv_ignore;
@@ -288,8 +291,13 @@ struct isis_lsp *lsp_for_sysid(struct ls
 
 void isis_area_invalidate_routes(struct isis_area *area, int levels);
 void isis_area_verify_routes(struct isis_area *area);
+void isis_area_switchover_routes(struct isis_area *area, int family,
+				 union g_addr *nexthop_ip, ifindex_t ifindex,
+				 int level);
 
 void isis_area_overload_bit_set(struct isis_area *area, bool overload_bit);
+void isis_area_overload_on_startup_set(struct isis_area *area,
+				       uint32_t startup_time);
 void isis_area_attached_bit_send_set(struct isis_area *area, bool attached_bit);
 void isis_area_attached_bit_receive_set(struct isis_area *area,
 					bool attached_bit);
@@ -315,7 +323,10 @@ void show_isis_database_lspdb_json(struc
 void show_isis_database_lspdb_vty(struct vty *vty, struct isis_area *area,
 				  int level, struct lspdb_head *lspdb,
 				  const char *argv, int ui_level);
-
+char *isis_restart_filepath(void);
+void isis_restart_write_overload_time(struct isis_area *isis_area,
+				      uint32_t overload_time);
+uint32_t isis_restart_read_overload_time(struct isis_area *isis_area);
 /* YANG paths */
 #define ISIS_INSTANCE	"/frr-isisd:isis/instance"
 #define ISIS_SR		"/frr-isisd:isis/instance/segment-routing"
diff -urpN frr-frr-8.4.2/isisd/subdir.am frr-frr-8.5/isisd/subdir.am
--- frr-frr-8.4.2/isisd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/isisd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,16 +5,6 @@
 if ISISD
 noinst_LIBRARIES += isisd/libisis.a
 sbin_PROGRAMS += isisd/isisd
-vtysh_scan += \
-	isisd/isis_cli.c \
-	isisd/isis_ldp_sync.c \
-	isisd/isis_redist.c \
-	isisd/isis_spf.c \
-	isisd/isis_te.c \
-	isisd/isis_sr.c \
-	isisd/isis_vty_fabricd.c \
-	isisd/isisd.c \
-	# end
 vtysh_daemons += isisd
 if SNMP
 module_LTLIBRARIES += isisd/isisd_snmp.la
@@ -25,18 +15,6 @@ endif
 if FABRICD
 noinst_LIBRARIES += isisd/libfabric.a
 sbin_PROGRAMS += isisd/fabricd
-if !ISISD
-vtysh_scan += \
-	isisd/isis_cli.c \
-	isisd/isis_ldp_sync.c \
-	isisd/isis_redist.c \
-	isisd/isis_spf.c \
-	isisd/isis_te.c \
-	isisd/isis_sr.c \
-	isisd/isis_vty_fabricd.c \
-	isisd/isisd.c \
-	# end
-endif
 vtysh_daemons += fabricd
 endif
 
diff -urpN frr-frr-8.4.2/ldpd/ldp_vty_cmds.c frr-frr-8.5/ldpd/ldp_vty_cmds.c
--- frr-frr-8.4.2/ldpd/ldp_vty_cmds.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/ldp_vty_cmds.c	2023-03-13 20:01:47.000000000 +0600
@@ -25,9 +25,7 @@
 
 #include "ldpd/ldpd.h"
 #include "ldpd/ldp_vty.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ldpd/ldp_vty_cmds_clippy.c"
-#endif
 
 DEFPY_NOSH(ldp_mpls_ldp,
 	ldp_mpls_ldp_cmd,
@@ -246,7 +244,7 @@ DEFPY  (ldp_allow_broken_lsps,
 	"[no] install allow-broken-lsps",
 	NO_STR
 	"install lsps\n"
-	"if no remote-label install with imp-null")
+	"if no remote-label install with imp-null\n")
 {
 	return (ldp_vty_allow_broken_lsp(vty, no));
 }
@@ -774,7 +772,11 @@ DEFPY_NOSH (ldp_show_debugging_mpls_ldp,
 	    "MPLS information\n"
 	    "Label Distribution Protocol\n")
 {
-	return (ldp_vty_show_debugging(vty));
+	ldp_vty_show_debugging(vty);
+
+	cmd_show_lib_debugs(vty);
+
+	return CMD_SUCCESS;
 }
 
 static void
diff -urpN frr-frr-8.4.2/ldpd/ldp_vty_exec.c frr-frr-8.5/ldpd/ldp_vty_exec.c
--- frr-frr-8.4.2/ldpd/ldp_vty_exec.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/ldp_vty_exec.c	2023-03-13 20:01:47.000000000 +0600
@@ -1472,10 +1472,6 @@ show_l2vpn_pw_msg_json(struct imsg *imsg
 		json_pw = json_object_new_object();
 		json_object_string_addf(json_pw, "peerId", "%pI4", &pw->lsr_id);
 		json_object_int_add(json_pw, "vcId", pw->pwid);
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
-		json_object_string_add(json_pw, "VpnName", pw->l2vpn_name);
 		json_object_string_add(json_pw, "vpnName", pw->l2vpn_name);
 		if (pw->status == PW_FORWARDING)
 			json_object_string_add(json_pw, "status", "up");
diff -urpN frr-frr-8.4.2/ldpd/ldpe.c frr-frr-8.5/ldpd/ldpe.c
--- frr-frr-8.4.2/ldpd/ldpe.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/ldpe.c	2023-03-13 20:01:47.000000000 +0600
@@ -208,7 +208,6 @@ ldpe_shutdown(void)
 	iev_main_sync->ibuf.fd = -1;
 
 	control_cleanup(ctl_sock_path);
-	config_clear(leconf);
 
 #ifdef __OpenBSD__
 	if (sysdep.no_pfkey == 0) {
@@ -231,6 +230,7 @@ ldpe_shutdown(void)
 		adj_del(adj, S_SHUTDOWN);
 	}
 
+	config_clear(leconf);
 	/* clean up */
 	if (iev_lde)
 		free(iev_lde);
diff -urpN frr-frr-8.4.2/ldpd/log.c frr-frr-8.5/ldpd/log.c
--- frr-frr-8.4.2/ldpd/log.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/log.c	2023-03-13 20:01:47.000000000 +0600
@@ -77,7 +77,11 @@ log_warn(const char *emsg, ...)
 			vlog(LOG_ERR, emsg, ap);
 			logit(LOG_ERR, "%s", strerror(errno));
 		} else {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+			/* format extended above */
 			vlog(LOG_ERR, nfmt, ap);
+#pragma GCC diagnostic pop
 			free(nfmt);
 		}
 		va_end(ap);
diff -urpN frr-frr-8.4.2/ldpd/logmsg.c frr-frr-8.5/ldpd/logmsg.c
--- frr-frr-8.4.2/ldpd/logmsg.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/logmsg.c	2023-03-13 20:01:47.000000000 +0600
@@ -137,7 +137,7 @@ log_time(time_t t)
 	char		*buf;
 	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
 	static int	 idx = 0;
-	unsigned int	 sec, min, hrs, day, week;
+	uint64_t	 sec, min, hrs, day, week;
 
 	buf = tfbuf[idx++];
 	if (idx == TF_BUFS)
@@ -155,11 +155,17 @@ log_time(time_t t)
 	week /= 7;
 
 	if (week > 0)
-		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
+		snprintfrr(buf, TF_LEN,
+			   "%02" PRIu64 "w%01" PRIu64 "d%02" PRIu64 "h", week,
+			   day, hrs);
 	else if (day > 0)
-		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
+		snprintfrr(buf, TF_LEN,
+			   "%01" PRIu64 "d%02" PRIu64 "h%02" PRIu64 "m", day,
+			   hrs, min);
 	else
-		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);
+		snprintfrr(buf, TF_LEN,
+			   "%02" PRIu64 ":%02" PRIu64 ":%02" PRIu64, hrs, min,
+			   sec);
 
 	return (buf);
 }
diff -urpN frr-frr-8.4.2/ldpd/neighbor.c frr-frr-8.5/ldpd/neighbor.c
--- frr-frr-8.4.2/ldpd/neighbor.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/neighbor.c	2023-03-13 20:01:47.000000000 +0600
@@ -359,8 +359,7 @@ nbr_find_ldpid(uint32_t lsr_id)
 	return (RB_FIND(nbr_id_head, &nbrs_by_id, &n));
 }
 
-struct nbr *
-nbr_get_first_ldpid()
+struct nbr *nbr_get_first_ldpid(void)
 {
 	return (RB_MIN(nbr_id_head, &nbrs_by_id));
 }
diff -urpN frr-frr-8.4.2/ldpd/subdir.am frr-frr-8.5/ldpd/subdir.am
--- frr-frr-8.4.2/ldpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ldpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,7 +5,6 @@
 if LDPD
 noinst_LIBRARIES += ldpd/libldp.a
 sbin_PROGRAMS += ldpd/ldpd
-vtysh_scan += ldpd/ldp_vty_cmds.c
 vtysh_daemons += ldpd
 man8 += $(MANBUILD)/frr-ldpd.8
 endif
diff -urpN frr-frr-8.4.2/lib/agentx.c frr-frr-8.5/lib/agentx.c
--- frr-frr-8.4.2/lib/agentx.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/agentx.c	2023-03-13 20:01:47.000000000 +0600
@@ -32,13 +32,15 @@
 #include "linklist.h"
 #include "lib/version.h"
 #include "lib_errors.h"
+#include "hook.h"
+#include "libfrr.h"
 #include "xref.h"
 
 XREF_SETUP();
 
 DEFINE_HOOK(agentx_enabled, (), ());
 
-static int agentx_enabled = 0;
+static bool agentx_enabled = false;
 
 static struct thread_master *agentx_tm;
 static struct thread *timeout_thr = NULL;
@@ -48,8 +50,6 @@ static void agentx_events_update(void);
 
 static void agentx_timeout(struct thread *t)
 {
-	timeout_thr = NULL;
-
 	snmp_timeout();
 	run_alarms();
 	netsnmp_check_outstanding_agent_requests();
@@ -228,7 +228,7 @@ DEFUN (agentx_enable,
 		init_snmp(FRR_SMUX_NAME);
 		events = list_new();
 		agentx_events_update();
-		agentx_enabled = 1;
+		agentx_enabled = true;
 		hook_call(agentx_enabled);
 	}
 
@@ -247,7 +247,14 @@ DEFUN (no_agentx,
 	return CMD_WARNING_CONFIG_FAILED;
 }
 
-int smux_enabled(void)
+static int smux_disable(void)
+{
+	agentx_enabled = false;
+
+	return 0;
+}
+
+bool smux_enabled(void)
 {
 	return agentx_enabled;
 }
@@ -266,6 +273,8 @@ void smux_init(struct thread_master *tm)
 	install_node(&agentx_node);
 	install_element(CONFIG_NODE, &agentx_enable_cmd);
 	install_element(CONFIG_NODE, &no_agentx_cmd);
+
+	hook_register(frr_early_fini, smux_disable);
 }
 
 void smux_agentx_enable(void)
@@ -274,7 +283,7 @@ void smux_agentx_enable(void)
 		init_snmp(FRR_SMUX_NAME);
 		events = list_new();
 		agentx_events_update();
-		agentx_enabled = 1;
+		agentx_enabled = true;
 	}
 }
 
diff -urpN frr-frr-8.4.2/lib/bfd.c frr-frr-8.5/lib/bfd.c
--- frr-frr-8.4.2/lib/bfd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/bfd.c	2023-03-13 20:01:47.000000000 +0600
@@ -29,11 +29,13 @@
 #include "stream.h"
 #include "vrf.h"
 #include "zclient.h"
+#include "libfrr.h"
 #include "table.h"
 #include "vty.h"
 #include "bfd.h"
 
 DEFINE_MTYPE_STATIC(LIB, BFD_INFO, "BFD info");
+DEFINE_MTYPE_STATIC(LIB, BFD_SOURCE, "BFD source cache");
 
 /**
  * BFD protocol integration configuration.
@@ -48,6 +50,29 @@ enum bfd_session_event {
 };
 
 /**
+ * BFD source selection result cache.
+ *
+ * This structure will keep track of the result based on the destination
+ * prefix. When the result changes all related BFD sessions with automatic
+ * source will be updated.
+ */
+struct bfd_source_cache {
+	/** Address VRF belongs. */
+	vrf_id_t vrf_id;
+	/** Destination network address. */
+	struct prefix address;
+	/** Source selected. */
+	struct prefix source;
+	/** Is the source address valid? */
+	bool valid;
+	/** BFD sessions using this. */
+	size_t refcount;
+
+	SLIST_ENTRY(bfd_source_cache) entry;
+};
+SLIST_HEAD(bfd_source_list, bfd_source_cache);
+
+/**
  * Data structure to do the necessary tricks to hide the BFD protocol
  * integration internals.
  */
@@ -82,6 +107,11 @@ struct bfd_session_params {
 	/** BFD session installation state. */
 	bool installed;
 
+	/** Automatic source selection. */
+	bool auto_source;
+	/** Currently selected source. */
+	struct bfd_source_cache *source_cache;
+
 	/** Global BFD paramaters list. */
 	TAILQ_ENTRY(bfd_session_params) entry;
 };
@@ -92,6 +122,8 @@ struct bfd_sessions_global {
 	 * without code duplication among daemons.
 	 */
 	TAILQ_HEAD(bsplist, bfd_session_params) bsplist;
+	/** BFD automatic source selection cache. */
+	struct bfd_source_list source_list;
 
 	/** Pointer to FRR's event manager. */
 	struct thread_master *tm;
@@ -111,6 +143,13 @@ static struct bfd_sessions_global bsglob
 static const struct in6_addr i6a_zero;
 
 /*
+ * Prototypes
+ */
+
+static void bfd_source_cache_get(struct bfd_session_params *session);
+static void bfd_source_cache_put(struct bfd_session_params *session);
+
+/*
  * bfd_get_peer_info - Extract the Peer information for which the BFD session
  *                     went down from the message sent from Zebra to clients.
  */
@@ -531,6 +570,8 @@ void bfd_sess_free(struct bfd_session_pa
 	/* Remove from global list. */
 	TAILQ_REMOVE(&bsglobal.bsplist, (*bsp), entry);
 
+	bfd_source_cache_put(*bsp);
+
 	/* Free the memory and point to NULL. */
 	XFREE(MTYPE_BFD_INFO, (*bsp));
 }
@@ -565,6 +606,8 @@ void bfd_sess_set_ipv4_addrs(struct bfd_
 
 	/* If already installed, remove the old setting. */
 	_bfd_sess_remove(bsp);
+	/* Address changed so we must reapply auto source. */
+	bfd_source_cache_put(bsp);
 
 	bsp->args.family = AF_INET;
 
@@ -578,6 +621,9 @@ void bfd_sess_set_ipv4_addrs(struct bfd_
 
 	assert(dst);
 	memcpy(&bsp->args.dst, dst, sizeof(struct in_addr));
+
+	if (bsp->auto_source)
+		bfd_source_cache_get(bsp);
 }
 
 void bfd_sess_set_ipv6_addrs(struct bfd_session_params *bsp,
@@ -589,6 +635,8 @@ void bfd_sess_set_ipv6_addrs(struct bfd_
 
 	/* If already installed, remove the old setting. */
 	_bfd_sess_remove(bsp);
+	/* Address changed so we must reapply auto source. */
+	bfd_source_cache_put(bsp);
 
 	bsp->args.family = AF_INET6;
 
@@ -600,6 +648,9 @@ void bfd_sess_set_ipv6_addrs(struct bfd_
 
 	assert(dst);
 	bsp->args.dst = *dst;
+
+	if (bsp->auto_source)
+		bfd_source_cache_get(bsp);
 }
 
 void bfd_sess_set_interface(struct bfd_session_params *bsp, const char *ifname)
@@ -646,8 +697,13 @@ void bfd_sess_set_vrf(struct bfd_session
 
 	/* If already installed, remove the old setting. */
 	_bfd_sess_remove(bsp);
+	/* Address changed so we must reapply auto source. */
+	bfd_source_cache_put(bsp);
 
 	bsp->args.vrf_id = vrf_id;
+
+	if (bsp->auto_source)
+		bfd_source_cache_get(bsp);
 }
 
 void bfd_sess_set_hop_count(struct bfd_session_params *bsp, uint8_t hops)
@@ -677,6 +733,18 @@ void bfd_sess_set_timers(struct bfd_sess
 	bsp->args.min_tx = min_tx;
 }
 
+void bfd_sess_set_auto_source(struct bfd_session_params *bsp, bool enable)
+{
+	if (bsp->auto_source == enable)
+		return;
+
+	bsp->auto_source = enable;
+	if (enable)
+		bfd_source_cache_get(bsp);
+	else
+		bfd_source_cache_put(bsp);
+}
+
 void bfd_sess_install(struct bfd_session_params *bsp)
 {
 	bsp->lastev = BSE_INSTALL;
@@ -746,6 +814,11 @@ void bfd_sess_timers(const struct bfd_se
 	*min_tx = bsp->args.min_tx;
 }
 
+bool bfd_sess_auto_source(const struct bfd_session_params *bsp)
+{
+	return bsp->auto_source;
+}
+
 void bfd_sess_show(struct vty *vty, struct json_object *json,
 		   struct bfd_session_params *bsp)
 {
@@ -950,10 +1023,42 @@ int zclient_bfd_session_update(ZAPI_CALL
 	return 0;
 }
 
+/**
+ * Frees all allocated resources and stops any activity.
+ *
+ * Must be called after every BFD session has been successfully
+ * unconfigured otherwise this function will `free()` any available
+ * session causing existing pointers to dangle.
+ *
+ * This is just a comment, in practice it will be called by the FRR
+ * library late finish hook. \see `bfd_protocol_integration_init`.
+ */
+static int bfd_protocol_integration_finish(void)
+{
+	if (bsglobal.zc == NULL)
+		return 0;
+
+	while (!TAILQ_EMPTY(&bsglobal.bsplist)) {
+		struct bfd_session_params *session =
+			TAILQ_FIRST(&bsglobal.bsplist);
+		bfd_sess_free(&session);
+	}
+
+	/*
+	 * BFD source cache is linked to sessions, if all sessions are gone
+	 * then the source cache must be empty.
+	 */
+	if (!SLIST_EMPTY(&bsglobal.source_list))
+		zlog_warn("BFD integration source cache not empty");
+
+	return 0;
+}
+
 void bfd_protocol_integration_init(struct zclient *zc, struct thread_master *tm)
 {
 	/* Initialize data structure. */
 	TAILQ_INIT(&bsglobal.bsplist);
+	SLIST_INIT(&bsglobal.source_list);
 
 	/* Copy pointers. */
 	bsglobal.zc = zc;
@@ -964,6 +1069,8 @@ void bfd_protocol_integration_init(struc
 
 	/* Send the client registration */
 	bfd_client_sendmsg(zc, ZEBRA_BFD_CLIENT_REGISTER, VRF_DEFAULT);
+
+	hook_register(frr_fini, bfd_protocol_integration_finish);
 }
 
 void bfd_protocol_integration_set_debug(bool enable)
@@ -985,3 +1092,262 @@ bool bfd_protocol_integration_shutting_d
 {
 	return bsglobal.shutting_down;
 }
+
+/*
+ * BFD automatic source selection
+ *
+ * This feature will use the next hop tracking (NHT) provided by zebra
+ * to find out the source address by looking at the output interface.
+ *
+ * When the interface address / routing table change we'll be notified
+ * and be able to update the source address accordingly.
+ *
+ *     <daemon>                 zebra
+ *         |
+ * +-----------------+
+ * | BFD session set |
+ * | to auto source  |
+ * +-----------------+
+ *         |
+ *         \                 +-----------------+
+ *          -------------->  | Resolves        |
+ *                           | destination     |
+ *                           | address         |
+ *                           +-----------------+
+ *                                |
+ * +-----------------+            /
+ * | Sets resolved   | <----------
+ * | source address  |
+ * +-----------------+
+ */
+static bool
+bfd_source_cache_session_match(const struct bfd_source_cache *source,
+			       const struct bfd_session_params *session)
+{
+	const struct in_addr *address;
+	const struct in6_addr *address_v6;
+
+	if (session->args.vrf_id != source->vrf_id)
+		return false;
+	if (session->args.family != source->address.family)
+		return false;
+
+	switch (session->args.family) {
+	case AF_INET:
+		address = (const struct in_addr *)&session->args.dst;
+		if (address->s_addr != source->address.u.prefix4.s_addr)
+			return false;
+		break;
+	case AF_INET6:
+		address_v6 = &session->args.dst;
+		if (memcmp(address_v6, &source->address.u.prefix6,
+			   sizeof(struct in6_addr)))
+			return false;
+		break;
+	default:
+		return false;
+	}
+
+	return true;
+}
+
+static struct bfd_source_cache *
+bfd_source_cache_find(vrf_id_t vrf_id, const struct prefix *prefix)
+{
+	struct bfd_source_cache *source;
+
+	SLIST_FOREACH (source, &bsglobal.source_list, entry) {
+		if (source->vrf_id != vrf_id)
+			continue;
+		if (!prefix_same(&source->address, prefix))
+			continue;
+
+		return source;
+	}
+
+	return NULL;
+}
+
+static void bfd_source_cache_get(struct bfd_session_params *session)
+{
+	struct bfd_source_cache *source;
+	struct prefix target = {};
+
+	switch (session->args.family) {
+	case AF_INET:
+		target.family = AF_INET;
+		target.prefixlen = IPV4_MAX_BITLEN;
+		memcpy(&target.u.prefix4, &session->args.dst,
+		       sizeof(struct in_addr));
+		break;
+	case AF_INET6:
+		target.family = AF_INET6;
+		target.prefixlen = IPV6_MAX_BITLEN;
+		memcpy(&target.u.prefix6, &session->args.dst,
+		       sizeof(struct in6_addr));
+		break;
+	default:
+		return;
+	}
+
+	source = bfd_source_cache_find(session->args.vrf_id, &target);
+	if (source) {
+		if (session->source_cache == source)
+			return;
+
+		bfd_source_cache_put(session);
+		session->source_cache = source;
+		source->refcount++;
+		return;
+	}
+
+	source = XCALLOC(MTYPE_BFD_SOURCE, sizeof(*source));
+	prefix_copy(&source->address, &target);
+	source->vrf_id = session->args.vrf_id;
+	SLIST_INSERT_HEAD(&bsglobal.source_list, source, entry);
+
+	bfd_source_cache_put(session);
+	session->source_cache = source;
+	source->refcount = 1;
+
+	return;
+}
+
+static void bfd_source_cache_put(struct bfd_session_params *session)
+{
+	if (session->source_cache == NULL)
+		return;
+
+	session->source_cache->refcount--;
+	if (session->source_cache->refcount > 0) {
+		session->source_cache = NULL;
+		return;
+	}
+
+	SLIST_REMOVE(&bsglobal.source_list, session->source_cache,
+		     bfd_source_cache, entry);
+	XFREE(MTYPE_BFD_SOURCE, session->source_cache);
+}
+
+/** Updates BFD running session if source address has changed. */
+static void
+bfd_source_cache_update_session(const struct bfd_source_cache *source,
+				struct bfd_session_params *session)
+{
+	const struct in_addr *address;
+	const struct in6_addr *address_v6;
+
+	switch (session->args.family) {
+	case AF_INET:
+		address = (const struct in_addr *)&session->args.src;
+		if (memcmp(address, &source->source.u.prefix4,
+			   sizeof(struct in_addr)) == 0)
+			return;
+
+		_bfd_sess_remove(session);
+		memcpy(&session->args.src, &source->source.u.prefix4,
+		       sizeof(struct in_addr));
+		break;
+	case AF_INET6:
+		address_v6 = &session->args.src;
+		if (memcmp(address_v6, &source->source.u.prefix6,
+			   sizeof(struct in6_addr)) == 0)
+			return;
+
+		_bfd_sess_remove(session);
+		memcpy(&session->args.src, &source->source.u.prefix6,
+		       sizeof(struct in6_addr));
+		break;
+	default:
+		return;
+	}
+
+	bfd_sess_install(session);
+}
+
+static void
+bfd_source_cache_update_sessions(const struct bfd_source_cache *source)
+{
+	struct bfd_session_params *session;
+
+	if (!source->valid)
+		return;
+
+	TAILQ_FOREACH (session, &bsglobal.bsplist, entry) {
+		if (!session->auto_source)
+			continue;
+		if (!bfd_source_cache_session_match(source, session))
+			continue;
+
+		bfd_source_cache_update_session(source, session);
+	}
+}
+
+/**
+ * Try to translate next hop information into source address.
+ *
+ * \returns `true` if source changed otherwise `false`.
+ */
+static bool bfd_source_cache_update(struct bfd_source_cache *source,
+				    const struct zapi_route *route)
+{
+	size_t nh_index;
+
+	for (nh_index = 0; nh_index < route->nexthop_num; nh_index++) {
+		const struct zapi_nexthop *nh = &route->nexthops[nh_index];
+		const struct interface *interface;
+		const struct connected *connected;
+		const struct listnode *node;
+
+		interface = if_lookup_by_index(nh->ifindex, nh->vrf_id);
+		if (interface == NULL) {
+			zlog_err("next hop interface not found (index %d)",
+				 nh->ifindex);
+			continue;
+		}
+
+		for (ALL_LIST_ELEMENTS_RO(interface->connected, node,
+					  connected)) {
+			if (source->address.family !=
+			    connected->address->family)
+				continue;
+			if (prefix_same(connected->address, &source->source))
+				return false;
+			/*
+			 * Skip link-local as it is only useful for single hop
+			 * and in that case no source is specified usually.
+			 */
+			if (source->address.family == AF_INET6 &&
+			    IN6_IS_ADDR_LINKLOCAL(
+				    &connected->address->u.prefix6))
+				continue;
+
+			prefix_copy(&source->source, connected->address);
+			source->valid = true;
+			return true;
+		}
+	}
+
+	memset(&source->source, 0, sizeof(source->source));
+	source->valid = false;
+	return false;
+}
+
+int bfd_nht_update(const struct prefix *match, const struct zapi_route *route)
+{
+	struct bfd_source_cache *source;
+
+	if (bsglobal.debugging)
+		zlog_debug("BFD NHT update for %pFX", &route->prefix);
+
+	SLIST_FOREACH (source, &bsglobal.source_list, entry) {
+		if (source->vrf_id != route->vrf_id)
+			continue;
+		if (!prefix_same(match, &source->address))
+			continue;
+		if (bfd_source_cache_update(source, route))
+			bfd_source_cache_update_sessions(source);
+	}
+
+	return 0;
+}
diff -urpN frr-frr-8.4.2/lib/bfd.h frr-frr-8.5/lib/bfd.h
--- frr-frr-8.4.2/lib/bfd.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/bfd.h	2023-03-13 20:01:47.000000000 +0600
@@ -222,6 +222,18 @@ void bfd_sess_set_timers(struct bfd_sess
 			 uint32_t min_tx);
 
 /**
+ * Configures the automatic source selection for the BFD session.
+ *
+ * NOTE:
+ * Setting this configuration will override the IP source value set by
+ * `bfd_sess_set_ipv4_addrs` or `bfd_sess_set_ipv6_addrs`.
+ *
+ * \param bsp BFD session parameters
+ * \param enable BFD automatic source selection state.
+ */
+void bfd_sess_set_auto_source(struct bfd_session_params *bsp, bool enable);
+
+/**
  * Installs or updates the BFD session based on the saved session arguments.
  *
  * NOTE:
@@ -331,6 +343,11 @@ void bfd_sess_timers(const struct bfd_se
 		     uint32_t *min_tx);
 
 /**
+ * Gets the automatic source selection state.
+ */
+bool bfd_sess_auto_source(const struct bfd_session_params *bsp);
+
+/**
  * Show BFD session configuration and status. If `json` is provided (e.g. not
  * `NULL`) then information will be inserted in object, otherwise printed to
  * `vty`.
@@ -456,6 +473,13 @@ extern bool bfd_protocol_integration_deb
  */
 extern bool bfd_protocol_integration_shutting_down(void);
 
+/* Update nexthop-tracking (nht) information for BFD auto source selection.
+ * The function must be called from the daemon callback function
+ * that deals with the ZEBRA_NEXTHOP_UPDATE zclient command
+ */
+extern int bfd_nht_update(const struct prefix *match,
+			  const struct zapi_route *route);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/lib/clippy.c frr-frr-8.5/lib/clippy.c
--- frr-frr-8.4.2/lib/clippy.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/clippy.c	2023-03-13 20:01:47.000000000 +0600
@@ -108,6 +108,7 @@ int main(int argc, char **argv)
 
 #include "log.h"
 
+PRINTFRR(3, 0)
 void vzlogx(const struct xref_logmsg *xref, int prio,
 	    const char *format, va_list args)
 {
diff -urpN frr-frr-8.4.2/lib/command.c frr-frr-8.5/lib/command.c
--- frr-frr-8.4.2/lib/command.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command.c	2023-03-13 20:01:47.000000000 +0600
@@ -48,6 +48,7 @@
 #include "lib_errors.h"
 #include "northbound_cli.h"
 #include "network.h"
+#include "routemap.h"
 
 #include "frrscript.h"
 
@@ -264,8 +265,7 @@ void install_node(struct cmd_node *node)
 	node->cmdgraph = graph_new();
 	node->cmd_vector = vector_init(VECTOR_MIN_SIZE);
 	// add start node
-	struct cmd_token *token =
-		cmd_token_new(START_TKN, CMD_ATTR_NORMAL, NULL, NULL);
+	struct cmd_token *token = cmd_token_new(START_TKN, 0, NULL, NULL);
 	graph_new_node(node->cmdgraph, token,
 		       (void (*)(void *)) & cmd_token_del);
 
@@ -325,7 +325,7 @@ void _install_element(enum node_type nty
 	if (cnode->graph_built || !defer_cli_tree) {
 		struct graph *graph = graph_new();
 		struct cmd_token *token =
-			cmd_token_new(START_TKN, CMD_ATTR_NORMAL, NULL, NULL);
+			cmd_token_new(START_TKN, 0, NULL, NULL);
 		graph_new_node(graph, token,
 			       (void (*)(void *)) & cmd_token_del);
 
@@ -348,8 +348,7 @@ static void cmd_finalize_iter(struct has
 	struct cmd_node *cnode = arg;
 	const struct cmd_element *cmd = hb->data;
 	struct graph *graph = graph_new();
-	struct cmd_token *token =
-		cmd_token_new(START_TKN, CMD_ATTR_NORMAL, NULL, NULL);
+	struct cmd_token *token = cmd_token_new(START_TKN, 0, NULL, NULL);
 
 	graph_new_node(graph, token, (void (*)(void *)) & cmd_token_del);
 
@@ -404,7 +403,7 @@ void uninstall_element(enum node_type nt
 	if (cnode->graph_built) {
 		struct graph *graph = graph_new();
 		struct cmd_token *token =
-			cmd_token_new(START_TKN, CMD_ATTR_NORMAL, NULL, NULL);
+			cmd_token_new(START_TKN, 0, NULL, NULL);
 		graph_new_node(graph, token,
 			       (void (*)(void *)) & cmd_token_del);
 
@@ -503,7 +502,7 @@ static int config_write_host(struct vty
 		else if (cputime_threshold != 5000000)
 #endif
 			vty_out(vty, "service cputime-warning %lu\n",
-				cputime_threshold);
+				cputime_threshold / 1000);
 
 		if (!walltime_threshold)
 			vty_out(vty, "no service walltime-warning\n");
@@ -513,7 +512,7 @@ static int config_write_host(struct vty
 		else if (walltime_threshold != 5000000)
 #endif
 			vty_out(vty, "service walltime-warning %lu\n",
-				walltime_threshold);
+				walltime_threshold / 1000);
 
 		if (host.advanced)
 			vty_out(vty, "service advanced-vty\n");
@@ -990,7 +989,7 @@ static int cmd_execute_command_real(vect
 			 * Perform pending commit (if any) before executing
 			 * non-YANG command.
 			 */
-			if (matched_element->attr != CMD_ATTR_YANG)
+			if (!(matched_element->attr & CMD_ATTR_YANG))
 				(void)nb_cli_pending_commit_check(vty);
 		}
 
@@ -1471,8 +1470,7 @@ static void permute(struct graph_node *s
 	for (unsigned int i = 0; i < vector_active(start->to); i++) {
 		struct graph_node *gn = vector_slot(start->to, i);
 		struct cmd_token *tok = gn->data;
-		if (tok->attr == CMD_ATTR_HIDDEN
-		    || tok->attr == CMD_ATTR_DEPRECATED)
+		if (tok->attr & CMD_ATTR_HIDDEN)
 			continue;
 		else if (tok->type == END_TKN || gn == start) {
 			vty_out(vty, " ");
@@ -1561,9 +1559,8 @@ int cmd_list_cmds(struct vty *vty, int d
 		const struct cmd_element *element = NULL;
 		for (unsigned int i = 0; i < vector_active(node->cmd_vector);
 		     i++)
-			if ((element = vector_slot(node->cmd_vector, i))
-			    && element->attr != CMD_ATTR_DEPRECATED
-			    && element->attr != CMD_ATTR_HIDDEN) {
+			if ((element = vector_slot(node->cmd_vector, i)) &&
+			    !(element->attr & CMD_ATTR_HIDDEN)) {
 				vty_out(vty, "    ");
 				print_cmd(vty, element->string);
 			}
@@ -2446,6 +2443,11 @@ const char *host_config_get(void)
 	return host.config;
 }
 
+void cmd_show_lib_debugs(struct vty *vty)
+{
+	route_map_show_debug(vty);
+}
+
 void install_default(enum node_type node)
 {
 	_install_element(node, &config_exit_cmd);
diff -urpN frr-frr-8.4.2/lib/command.h frr-frr-8.5/lib/command.h
--- frr-frr-8.4.2/lib/command.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command.h	2023-03-13 20:01:47.000000000 +0600
@@ -251,9 +251,6 @@ struct cmd_node {
 /* Argc max counts. */
 #define CMD_ARGC_MAX   256
 
-/* Turn off these macros when using cpp with extract.pl */
-#ifndef VTYSH_EXTRACT_PL
-
 /* helper defines for end-user DEFUN* macros */
 #define DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attrs, dnum)     \
 	static const struct cmd_element cmdname = {                            \
@@ -280,17 +277,18 @@ struct cmd_node {
 			    int argc __attribute__((unused)),                  \
 			    struct cmd_token *argv[] __attribute__((unused)))
 
-#define DEFPY(funcname, cmdname, cmdstr, helpstr)                              \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, 0)            \
-	funcdecl_##funcname
-
-#define DEFPY_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
-	DEFPY(funcname, cmdname, cmdstr, helpstr)
+/* DEFPY variants */
 
 #define DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, attr)                   \
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attr, 0)         \
 	funcdecl_##funcname
 
+#define DEFPY(funcname, cmdname, cmdstr, helpstr)                              \
+	DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, 0)
+
+#define DEFPY_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
+	DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_NOSH)
+
 #define DEFPY_HIDDEN(funcname, cmdname, cmdstr, helpstr)                       \
 	DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN)
 
@@ -298,18 +296,19 @@ struct cmd_node {
 	DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_YANG)
 
 #define DEFPY_YANG_NOSH(funcname, cmdname, cmdstr, helpstr)                    \
-	DEFPY_YANG(funcname, cmdname, cmdstr, helpstr)
+	DEFPY_ATTR(funcname, cmdname, cmdstr, helpstr,                         \
+		   CMD_ATTR_YANG | CMD_ATTR_NOSH)
 
-#define DEFUN(funcname, cmdname, cmdstr, helpstr)                              \
-	DEFUN_CMD_FUNC_DECL(funcname)                                          \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, 0)            \
-	DEFUN_CMD_FUNC_TEXT(funcname)
+/* DEFUN variants */
 
 #define DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, attr)                   \
 	DEFUN_CMD_FUNC_DECL(funcname)                                          \
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attr, 0)         \
 	DEFUN_CMD_FUNC_TEXT(funcname)
 
+#define DEFUN(funcname, cmdname, cmdstr, helpstr)                              \
+	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, 0)
+
 #define DEFUN_HIDDEN(funcname, cmdname, cmdstr, helpstr)                       \
 	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN)
 
@@ -318,75 +317,55 @@ struct cmd_node {
 
 /* DEFUN_NOSH for commands that vtysh should ignore */
 #define DEFUN_NOSH(funcname, cmdname, cmdstr, helpstr)                         \
-	DEFUN(funcname, cmdname, cmdstr, helpstr)
+	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_NOSH)
 
 #define DEFUN_YANG_NOSH(funcname, cmdname, cmdstr, helpstr)                    \
-	DEFUN_YANG(funcname, cmdname, cmdstr, helpstr)
+	DEFUN_ATTR(funcname, cmdname, cmdstr, helpstr,                         \
+		   CMD_ATTR_YANG | CMD_ATTR_NOSH)
 
 /* DEFSH for vtysh. */
+#define DEFSH_ATTR(daemon, cmdname, cmdstr, helpstr, attr)                     \
+	DEFUN_CMD_ELEMENT(NULL, cmdname, cmdstr, helpstr, attr, daemon)
+
 #define DEFSH(daemon, cmdname, cmdstr, helpstr)                                \
-	DEFUN_CMD_ELEMENT(NULL, cmdname, cmdstr, helpstr, 0, daemon)
+	DEFSH_ATTR(daemon, cmdname, cmdstr, helpstr, 0)
 
 #define DEFSH_HIDDEN(daemon, cmdname, cmdstr, helpstr)                         \
-	DEFUN_CMD_ELEMENT(NULL, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN,     \
-			  daemon)
-
-#define DEFSH_YANG(daemon, cmdname, cmdstr, helpstr)                           \
-	DEFUN_CMD_ELEMENT(NULL, cmdname, cmdstr, helpstr, CMD_ATTR_YANG, daemon)
+	DEFSH_ATTR(daemon, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN)
 
 /* DEFUN + DEFSH */
-#define DEFUNSH(daemon, funcname, cmdname, cmdstr, helpstr)                    \
-	DEFUN_CMD_FUNC_DECL(funcname)                                          \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, daemon)       \
-	DEFUN_CMD_FUNC_TEXT(funcname)
-
-/* DEFUN + DEFSH with attributes */
 #define DEFUNSH_ATTR(daemon, funcname, cmdname, cmdstr, helpstr, attr)         \
 	DEFUN_CMD_FUNC_DECL(funcname)                                          \
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attr, daemon)    \
 	DEFUN_CMD_FUNC_TEXT(funcname)
 
+#define DEFUNSH(daemon, funcname, cmdname, cmdstr, helpstr)                    \
+	DEFUNSH_ATTR(daemon, funcname, cmdname, cmdstr, helpstr, 0)
+
 #define DEFUNSH_HIDDEN(daemon, funcname, cmdname, cmdstr, helpstr)             \
 	DEFUNSH_ATTR(daemon, funcname, cmdname, cmdstr, helpstr,               \
 		     CMD_ATTR_HIDDEN)
 
-#define DEFUNSH_DEPRECATED(daemon, funcname, cmdname, cmdstr, helpstr)         \
-	DEFUNSH_ATTR(daemon, funcname, cmdname, cmdstr, helpstr,               \
-		     CMD_ATTR_DEPRECATED)
-
-#define DEFUNSH_YANG(daemon, funcname, cmdname, cmdstr, helpstr)               \
-	DEFUNSH_ATTR(daemon, funcname, cmdname, cmdstr, helpstr, CMD_ATTR_YANG)
-
 /* ALIAS macro which define existing command's alias. */
-#define ALIAS(funcname, cmdname, cmdstr, helpstr)                              \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, 0)
-
 #define ALIAS_ATTR(funcname, cmdname, cmdstr, helpstr, attr)                   \
 	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, attr, 0)
 
+#define ALIAS(funcname, cmdname, cmdstr, helpstr)                              \
+	ALIAS_ATTR(funcname, cmdname, cmdstr, helpstr, 0)
+
 #define ALIAS_HIDDEN(funcname, cmdname, cmdstr, helpstr)                       \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN, \
-			  0)
+	ALIAS_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN)
 
+/* note: DEPRECATED implies HIDDEN, and other than that there is currently no
+ * difference.  It's purely for expressing intent in the source code - a
+ * DEPRECATED command is supposed to go away, a HIDDEN one is likely to stay.
+ */
 #define ALIAS_DEPRECATED(funcname, cmdname, cmdstr, helpstr)                   \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr,                  \
-			  CMD_ATTR_DEPRECATED, 0)
+	ALIAS_ATTR(funcname, cmdname, cmdstr, helpstr,                         \
+		   CMD_ATTR_DEPRECATED | CMD_ATTR_HIDDEN)
 
 #define ALIAS_YANG(funcname, cmdname, cmdstr, helpstr)                         \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_YANG, 0)
-
-#define ALIAS_SH(daemon, funcname, cmdname, cmdstr, helpstr)                   \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, 0, daemon)
-
-#define ALIAS_SH_HIDDEN(daemon, funcname, cmdname, cmdstr, helpstr)            \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_HIDDEN, \
-			  daemon)
-
-#define ALIAS_SH_DEPRECATED(daemon, funcname, cmdname, cmdstr, helpstr)        \
-	DEFUN_CMD_ELEMENT(funcname, cmdname, cmdstr, helpstr,                  \
-			  CMD_ATTR_DEPRECATED, daemon)
-
-#endif /* VTYSH_EXTRACT_PL */
+	ALIAS_ATTR(funcname, cmdname, cmdstr, helpstr, CMD_ATTR_YANG)
 
 /* Some macroes */
 
@@ -404,6 +383,8 @@ struct cmd_node {
 #define SHOW_STR "Show running system information\n"
 #define IP_STR "IP information\n"
 #define IPV6_STR "IPv6 information\n"
+#define IP_ADDR_STR "IPv4 Address\n"
+#define IP6_ADDR_STR "IPv6 Address\n"
 #define SRTE_STR "SR-TE information\n"
 #define SRTE_COLOR_STR "SR-TE Color information\n"
 #define NO_STR "Negate a command or set its defaults\n"
@@ -515,6 +496,13 @@ struct cmd_node {
 #define ROLE_STR                                                               \
 	"Providing transit\nRoute server\nRS client\nUsing transit\nPublic/private peering\n"
 
+/* BFD protocol integration strings. */
+#define BFD_INTEGRATION_STR "BFD monitoring\n"
+#define BFD_INTEGRATION_MULTI_HOP_STR "Use BFD multi hop session\n"
+#define BFD_INTEGRATION_SOURCE_STR "Use source for BFD session\n"
+#define BFD_INTEGRATION_SOURCEV4_STR "Use IPv4 source for BFD session\n"
+#define BFD_INTEGRATION_SOURCEV6_STR "Use IPv4 source for BFD session\n"
+
 /* Prototypes. */
 extern void install_node(struct cmd_node *node);
 extern void install_default(enum node_type);
@@ -526,7 +514,6 @@ struct xref_install_element {
 	enum node_type node_type;
 };
 
-#ifndef VTYSH_EXTRACT_PL
 #define install_element(node_type_, cmd_element_) do {                         \
 		static const struct xref_install_element _xref                 \
 				__attribute__((used)) = {                      \
@@ -538,7 +525,6 @@ struct xref_install_element {
 		XREF_LINK(_xref.xref);                                         \
 		_install_element(node_type_, cmd_element_);                    \
 	} while (0)
-#endif
 
 extern void _install_element(enum node_type, const struct cmd_element *);
 
@@ -633,9 +619,6 @@ extern void print_version(const char *);
 extern int cmd_banner_motd_file(const char *);
 extern void cmd_banner_motd_line(const char *line);
 
-/* struct host global, ick */
-extern struct host host;
-
 struct cmd_variable_handler {
 	const char *tokenname, *varname;
 	void (*completions)(vector out, struct cmd_token *token);
@@ -649,6 +632,12 @@ extern char *cmd_variable_comp2str(vecto
 
 extern void command_setup_early_logging(const char *dest, const char *level);
 
+/*
+ * Allow a mechanism for `debug XXX` commands that live
+ * under the lib directory to output their debug status
+ */
+extern void cmd_show_lib_debugs(struct vty *vty);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/lib/command_graph.c frr-frr-8.5/lib/command_graph.c
--- frr-frr-8.4.2/lib/command_graph.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command_graph.c	2023-03-13 20:01:47.000000000 +0600
@@ -494,9 +494,10 @@ void cmd_graph_node_print_cb(struct grap
 	snprintf(nbuf, sizeof(nbuf), "<b>%s</b>",
 		 lookup_msg(tokennames, tok->type, NULL));
 	buffer_putstr(buf, nbuf);
-	if (tok->attr == CMD_ATTR_DEPRECATED)
+	if (tok->attr & CMD_ATTR_DEPRECATED)
 		buffer_putstr(buf, " (d)");
-	else if (tok->attr == CMD_ATTR_HIDDEN)
+	/* DEPRECATED implies HIDDEN, don't print both */
+	else if (tok->attr & CMD_ATTR_HIDDEN)
 		buffer_putstr(buf, " (h)");
 	if (tok->text) {
 		if (tok->type == WORD_TKN)
diff -urpN frr-frr-8.4.2/lib/command_graph.h frr-frr-8.5/lib/command_graph.h
--- frr-frr-8.4.2/lib/command_graph.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command_graph.h	2023-03-13 20:01:47.000000000 +0600
@@ -73,10 +73,11 @@ enum cmd_token_type {
 #define IS_VARYING_TOKEN(x) ((x) >= VARIABLE_TKN && (x) < FORK_TKN)
 
 /* Command attributes */
-enum { CMD_ATTR_NORMAL,
-       CMD_ATTR_DEPRECATED,
-       CMD_ATTR_HIDDEN,
-       CMD_ATTR_YANG,
+enum {
+	CMD_ATTR_YANG = (1 << 0),
+	CMD_ATTR_HIDDEN = (1 << 1),
+	CMD_ATTR_DEPRECATED = (1 << 2),
+	CMD_ATTR_NOSH = (1 << 3),
 };
 
 enum varname_src {
diff -urpN frr-frr-8.4.2/lib/command_match.c frr-frr-8.5/lib/command_match.c
--- frr-frr-8.4.2/lib/command_match.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command_match.c	2023-03-13 20:01:47.000000000 +0600
@@ -395,8 +395,7 @@ enum matcher_rv command_complete(struct
 		for (ALL_LIST_ELEMENTS_RO(current, node, gstack)) {
 			struct cmd_token *token = gstack[0]->data;
 
-			if (token->attr == CMD_ATTR_HIDDEN
-			    || token->attr == CMD_ATTR_DEPRECATED)
+			if (token->attr & CMD_ATTR_HIDDEN)
 				continue;
 
 			enum match_type minmatch = min_match_level(token->type);
diff -urpN frr-frr-8.4.2/lib/command_py.c frr-frr-8.5/lib/command_py.c
--- frr-frr-8.4.2/lib/command_py.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/command_py.c	2023-03-13 20:01:47.000000000 +0600
@@ -226,8 +226,8 @@ static PyObject *graph_to_pyobj(struct w
 			wrap->type = "???";
 		}
 
-		wrap->deprecated = (tok->attr == CMD_ATTR_DEPRECATED);
-		wrap->hidden = (tok->attr == CMD_ATTR_HIDDEN);
+		wrap->deprecated = !!(tok->attr & CMD_ATTR_DEPRECATED);
+		wrap->hidden = !!(tok->attr & CMD_ATTR_HIDDEN);
 		wrap->text = tok->text;
 		wrap->desc = tok->desc;
 		wrap->varname = tok->varname;
@@ -353,6 +353,12 @@ PyMODINIT_FUNC command_py_init(void)
 	if (!pymod)
 		initret(NULL);
 
+	if (PyModule_AddIntMacro(pymod, CMD_ATTR_YANG)
+	    || PyModule_AddIntMacro(pymod, CMD_ATTR_HIDDEN)
+	    || PyModule_AddIntMacro(pymod, CMD_ATTR_DEPRECATED)
+	    || PyModule_AddIntMacro(pymod, CMD_ATTR_NOSH))
+		initret(NULL);
+
 	Py_INCREF(&typeobj_graph_node);
 	PyModule_AddObject(pymod, "GraphNode", (PyObject *)&typeobj_graph_node);
 	Py_INCREF(&typeobj_graph);
diff -urpN frr-frr-8.4.2/lib/compiler.h frr-frr-8.5/lib/compiler.h
--- frr-frr-8.4.2/lib/compiler.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/compiler.h	2023-03-13 20:01:47.000000000 +0600
@@ -72,6 +72,16 @@ extern "C" {
 #endif
 #endif
 
+#ifdef __INTELLISENSE__
+/*
+ * Fix Visual Studio Code error: attribute "constructor" does not take
+ * arguments.
+ *
+ * Caused by the macro `DEFINE_MTYPE_ATTR` in `lib/memory.h`.
+ */
+#pragma diag_suppress 1094
+#endif /* __INTELISENSE__ */
+
 #if __has_attribute(hot)
 #  define _OPTIMIZE_HOT __attribute__((hot))
 #else
@@ -411,6 +421,35 @@ _Static_assert(sizeof(_uint64_t) == 8 &&
 #endif /* !__cplusplus */
 #endif /* !_FRR_ATTRIBUTE_PRINTFRR */
 
+/* helper to get type safety/avoid casts on calls
+ * (w/o this, functions accepting all prefix types need casts on the caller
+ * side, which strips type safety since the cast will accept any pointer
+ * type.)
+ */
+#ifndef __cplusplus
+#define prefixtype(uname, typename, fieldname) typename *fieldname;
+#define TRANSPARENT_UNION __attribute__((transparent_union))
+#else
+#define prefixtype(uname, typename, fieldname)                                 \
+	typename *fieldname;                                                   \
+	uname(typename *x)                                                     \
+	{                                                                      \
+		this->fieldname = x;                                           \
+	}
+#define TRANSPARENT_UNION
+#endif
+
+#ifdef __INTELLISENSE__
+/*
+ * Fix Visual Studio Code error: argument of type "struct prefix *" is
+ * incompatible with parameter of type "union prefixptr".
+ *
+ * This is caused by all functions having the transparent unions in the
+ * prototype. Example: `prefixptr` and `prefixconstptr` from `lib/prefix.h`.
+ */
+#pragma diag_suppress 167
+#endif /* __INTELISENSE__ */
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/lib/db.h frr-frr-8.5/lib/db.h
--- frr-frr-8.4.2/lib/db.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/db.h	2023-03-13 20:01:47.000000000 +0600
@@ -36,21 +36,24 @@
 #define _FRR_DB_H_
 #ifdef HAVE_SQLITE3
 
+#include "compiler.h"
 #include <sqlite3.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-extern int db_init(const char *path_fmt, ...);
+extern int db_init(const char *path_fmt, ...) PRINTFRR(1, 2);
 extern int db_close(void);
+/* WARNING: sqlite format string! not printf compatible! */
 extern int db_bindf(struct sqlite3_stmt *ss, const char *fmt, ...);
 extern struct sqlite3_stmt *db_prepare_len(const char *stmt, int stmtlen);
 extern struct sqlite3_stmt *db_prepare(const char *stmt);
 extern int db_run(struct sqlite3_stmt *ss);
+/* WARNING: sqlite format string! not scanf compatible! */
 extern int db_loadf(struct sqlite3_stmt *ss, const char *fmt, ...);
 extern void db_finalize(struct sqlite3_stmt **ss);
-extern int db_execute(const char *stmt_fmt, ...);
+extern int db_execute(const char *stmt_fmt, ...) PRINTFRR(1, 2);
 
 #ifdef __cplusplus
 }
diff -urpN frr-frr-8.4.2/lib/ferr.c frr-frr-8.5/lib/ferr.c
--- frr-frr-8.4.2/lib/ferr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/ferr.c	2023-03-13 20:01:47.000000000 +0600
@@ -219,6 +219,7 @@ ferr_r ferr_clear(void)
 	return ferr_ok();
 }
 
+PRINTFRR(7, 0)
 static ferr_r ferr_set_va(const char *file, int line, const char *func,
 			  enum ferr_kind kind, const char *pathname,
 			  int errno_val, const char *text, va_list va)
diff -urpN frr-frr-8.4.2/lib/ferr.h frr-frr-8.5/lib/ferr.h
--- frr-frr-8.4.2/lib/ferr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/ferr.h	2023-03-13 20:01:47.000000000 +0600
@@ -178,10 +178,12 @@ ferr_r ferr_clear(void);
 
 /* do NOT call these functions directly.  only for macro use! */
 ferr_r ferr_set_internal(const char *file, int line, const char *func,
-			 enum ferr_kind kind, const char *text, ...);
+			 enum ferr_kind kind, const char *text, ...)
+	PRINTFRR(5, 6);
 ferr_r ferr_set_internal_ext(const char *file, int line, const char *func,
 			     enum ferr_kind kind, const char *pathname,
-			     int errno_val, const char *text, ...);
+			     int errno_val, const char *text, ...)
+	PRINTFRR(7, 8);
 
 #define ferr_ok() 0
 
@@ -221,7 +223,8 @@ ferr_r ferr_set_internal_ext(const char
 
 #include "vty.h"
 /* print error message to vty;  $ERR is replaced by the error's message */
-void vty_print_error(struct vty *vty, ferr_r err, const char *msg, ...);
+void vty_print_error(struct vty *vty, ferr_r err, const char *msg, ...)
+	PRINTFRR(3, 4);
 
 #define CMD_FERR_DO(func, action, ...)                                         \
 	do {                                                                   \
diff -urpN frr-frr-8.4.2/lib/filter_cli.c frr-frr-8.5/lib/filter_cli.c
--- frr-frr-8.4.2/lib/filter_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/filter_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -31,9 +31,7 @@
 #include "lib/plist_int.h"
 #include "lib/printfrr.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/filter_cli_clippy.c"
-#endif /* VTYSH_EXTRACT_PL */
 
 #define ACCESS_LIST_STR "Access list entry\n"
 #define ACCESS_LIST_ZEBRA_STR "Access list name\n"
@@ -68,16 +66,21 @@ static int acl_get_seq_cb(const struct l
  *
  * \param[in] vty shell context with the candidate configuration.
  * \param[in] xpath the XPath to look for the sequence leaf.
- * \returns next unused sequence number.
+ * \returns next unused sequence number, -1 if out of range when adding.
  */
-static long acl_get_seq(struct vty *vty, const char *xpath)
+static int64_t acl_get_seq(struct vty *vty, const char *xpath, bool is_remove)
 {
 	int64_t seq = 0;
 
 	yang_dnode_iterate(acl_get_seq_cb, &seq, vty->candidate_config->dnode,
 			   "%s/entry", xpath);
 
-	return seq + 5;
+	seq += 5;
+	if (!is_remove && seq > UINT32_MAX) {
+		vty_out(vty, "%% Malformed sequence value\n");
+		return -1;
+	}
+	return seq;
 }
 
 static int acl_remove_if_empty(struct vty *vty, const char *iptype,
@@ -100,7 +103,7 @@ static int acl_remove_if_empty(struct vt
 	 * NOTE: if the list is empty it will return the first sequence
 	 * number: 5.
 	 */
-	if (acl_get_seq(vty, xpath) != 5)
+	if (acl_get_seq(vty, xpath, true) != 5)
 		return CMD_SUCCESS;
 
 	/* Nobody is using this list, lets remove it. */
@@ -176,16 +179,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/access-list[type='ipv4'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -200,7 +206,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./source-any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -323,16 +329,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/access-list[type='ipv4'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -360,7 +369,7 @@ DEFPY_YANG(
 				      NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -485,16 +494,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/access-list[type='ipv4'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -507,7 +519,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -588,7 +600,7 @@ DEFPY_YANG(
 
 	remark = argv_concat(argv, argc, 3);
 	nb_cli_enqueue_change(vty, "./remark", NB_OP_CREATE, remark);
-	rv = nb_cli_apply_changes(vty, xpath);
+	rv = nb_cli_apply_changes(vty, "%s", xpath);
 	XFREE(MTYPE_TMP, remark);
 
 	return rv;
@@ -672,16 +684,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/access-list[type='ipv6'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -694,7 +709,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -778,7 +793,7 @@ DEFPY_YANG(
 
 	remark = argv_concat(argv, argc, 4);
 	nb_cli_enqueue_change(vty, "./remark", NB_OP_CREATE, remark);
-	rv = nb_cli_apply_changes(vty, xpath);
+	rv = nb_cli_apply_changes(vty, "%s", xpath);
 	XFREE(MTYPE_TMP, remark);
 
 	return rv;
@@ -859,16 +874,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/access-list[type='mac'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -878,7 +896,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -957,7 +975,7 @@ DEFPY_YANG(
 
 	remark = argv_concat(argv, argc, 4);
 	nb_cli_enqueue_change(vty, "./remark", NB_OP_CREATE, remark);
-	rv = nb_cli_apply_changes(vty, xpath);
+	rv = nb_cli_apply_changes(vty, "%s", xpath);
 	XFREE(MTYPE_TMP, remark);
 
 	return rv;
@@ -1169,7 +1187,7 @@ static int plist_remove_if_empty(struct
 	 * NOTE: if the list is empty it will return the first sequence
 	 * number: 5.
 	 */
-	if (acl_get_seq(vty, xpath) != 5)
+	if (acl_get_seq(vty, xpath, true) != 5)
 		return CMD_SUCCESS;
 
 	/* Nobody is using this list, lets remove it. */
@@ -1277,16 +1295,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/prefix-list[type='ipv4'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -1323,7 +1344,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -1394,7 +1415,7 @@ DEFPY_YANG(
 
 	remark = argv_concat(argv, argc, 4);
 	nb_cli_enqueue_change(vty, "./remark", NB_OP_CREATE, remark);
-	rv = nb_cli_apply_changes(vty, xpath);
+	rv = nb_cli_apply_changes(vty, "%s", xpath);
 	XFREE(MTYPE_TMP, remark);
 
 	return rv;
@@ -1478,16 +1499,19 @@ DEFPY_YANG(
 	 */
 	snprintf(xpath, sizeof(xpath),
 		 "/frr-filter:lib/prefix-list[type='ipv6'][name='%s']", name);
-	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	if (seq_str == NULL) {
 		/* Use XPath to find the next sequence number. */
-		sseq = acl_get_seq(vty, xpath);
+		sseq = acl_get_seq(vty, xpath, false);
+		if (sseq < 0)
+			return CMD_WARNING_CONFIG_FAILED;
+
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%" PRId64 "']", xpath, sseq);
 	} else
 		snprintfrr(xpath_entry, sizeof(xpath_entry),
 			   "%s/entry[sequence='%s']", xpath, seq_str);
 
+	nb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);
 	nb_cli_enqueue_change(vty, xpath_entry, NB_OP_CREATE, NULL);
 
 	nb_cli_enqueue_change(vty, "./action", NB_OP_MODIFY, action);
@@ -1524,7 +1548,7 @@ DEFPY_YANG(
 		nb_cli_enqueue_change(vty, "./any", NB_OP_CREATE, NULL);
 	}
 
-	return nb_cli_apply_changes(vty, xpath_entry);
+	return nb_cli_apply_changes(vty, "%s", xpath_entry);
 }
 
 DEFPY_YANG(
@@ -1595,7 +1619,7 @@ DEFPY_YANG(
 
 	remark = argv_concat(argv, argc, 4);
 	nb_cli_enqueue_change(vty, "./remark", NB_OP_CREATE, remark);
-	rv = nb_cli_apply_changes(vty, xpath);
+	rv = nb_cli_apply_changes(vty, "%s", xpath);
 	XFREE(MTYPE_TMP, remark);
 
 	return rv;
diff -urpN frr-frr-8.4.2/lib/filter_nb.c frr-frr-8.5/lib/filter_nb.c
--- frr-frr-8.4.2/lib/filter_nb.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/filter_nb.c	2023-03-13 20:01:47.000000000 +0600
@@ -70,7 +70,7 @@ static enum nb_error prefix_list_length_
 	 * prefix length <= le.
 	 */
 	if (yang_dnode_exists(args->dnode, xpath_le)) {
-		le = yang_dnode_get_uint8(args->dnode, xpath_le);
+		le = yang_dnode_get_uint8(args->dnode, "%s", xpath_le);
 		if (p.prefixlen > le)
 			goto log_and_fail;
 	}
@@ -80,7 +80,7 @@ static enum nb_error prefix_list_length_
 	 * prefix length <= ge.
 	 */
 	if (yang_dnode_exists(args->dnode, xpath_ge)) {
-		ge = yang_dnode_get_uint8(args->dnode, xpath_ge);
+		ge = yang_dnode_get_uint8(args->dnode, "%s", xpath_ge);
 		if (p.prefixlen > ge)
 			goto log_and_fail;
 	}
@@ -91,8 +91,8 @@ static enum nb_error prefix_list_length_
 	 */
 	if (yang_dnode_exists(args->dnode, xpath_le)
 	    && yang_dnode_exists(args->dnode, xpath_ge)) {
-		le = yang_dnode_get_uint8(args->dnode, xpath_le);
-		ge = yang_dnode_get_uint8(args->dnode, xpath_ge);
+		le = yang_dnode_get_uint8(args->dnode, "%s", xpath_le);
+		ge = yang_dnode_get_uint8(args->dnode, "%s", xpath_ge);
 		if (ge > le)
 			goto log_and_fail;
 	}
@@ -273,7 +273,8 @@ static int _acl_is_dup(const struct lyd_
 			return YANG_ITER_CONTINUE;
 
 		/* Check if different value. */
-		if (strcmp(yang_dnode_get_string(dnode, ada->ada_xpath[idx]),
+		if (strcmp(yang_dnode_get_string(dnode, "%s",
+						 ada->ada_xpath[idx]),
 			   ada->ada_value[idx]))
 			return YANG_ITER_CONTINUE;
 	}
@@ -328,8 +329,8 @@ static bool acl_cisco_is_dup(const struc
 		}
 
 		ada.ada_xpath[arg_idx] = cisco_entries[idx];
-		ada.ada_value[arg_idx] =
-			yang_dnode_get_string(entry_dnode, cisco_entries[idx]);
+		ada.ada_value[arg_idx] = yang_dnode_get_string(
+			entry_dnode, "%s", cisco_entries[idx]);
 		arg_idx++;
 		idx++;
 	}
@@ -378,8 +379,8 @@ static bool acl_zebra_is_dup(const struc
 		}
 
 		ada.ada_xpath[arg_idx] = zebra_entries[idx];
-		ada.ada_value[arg_idx] =
-			yang_dnode_get_string(entry_dnode, zebra_entries[idx]);
+		ada.ada_value[arg_idx] = yang_dnode_get_string(
+			entry_dnode, "%s", zebra_entries[idx]);
 		arg_idx++;
 		idx++;
 	}
diff -urpN frr-frr-8.4.2/lib/frrscript.h frr-frr-8.5/lib/frrscript.h
--- frr-frr-8.4.2/lib/frrscript.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/frrscript.h	2023-03-13 20:01:47.000000000 +0600
@@ -34,7 +34,7 @@ extern "C" {
 #endif
 
 /* Forward declarations */
-extern struct zebra_dplane_ctx ctx;
+struct zebra_dplane_ctx;
 extern void lua_pushzebra_dplane_ctx(lua_State *L,
 				     const struct zebra_dplane_ctx *ctx);
 extern void lua_decode_zebra_dplane_ctx(lua_State *L, int idx,
diff -urpN frr-frr-8.4.2/lib/frrstr.c frr-frr-8.5/lib/frrstr.c
--- frr-frr-8.4.2/lib/frrstr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/frrstr.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,11 +23,16 @@
 #include <string.h>
 #include <ctype.h>
 #include <sys/types.h>
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 
 #include "frrstr.h"
 #include "memory.h"
diff -urpN frr-frr-8.4.2/lib/frrstr.h frr-frr-8.5/lib/frrstr.h
--- frr-frr-8.4.2/lib/frrstr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/frrstr.h	2023-03-13 20:01:47.000000000 +0600
@@ -23,11 +23,16 @@
 
 #include <sys/types.h>
 #include <sys/types.h>
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 #include <stdbool.h>
 
 #include "vector.h"
diff -urpN frr-frr-8.4.2/lib/grammar_sandbox.c frr-frr-8.5/lib/grammar_sandbox.c
--- frr-frr-8.4.2/lib/grammar_sandbox.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/grammar_sandbox.c	2023-03-13 20:01:47.000000000 +0600
@@ -76,8 +76,7 @@ DEFUN (grammar_test,
 
 	// parse the command and install it into the command graph
 	struct graph *graph = graph_new();
-	struct cmd_token *token =
-		cmd_token_new(START_TKN, CMD_ATTR_NORMAL, NULL, NULL);
+	struct cmd_token *token = cmd_token_new(START_TKN, 0, NULL, NULL);
 	graph_new_node(graph, token, (void (*)(void *)) & cmd_token_del);
 
 	cmd_graph_parse(graph, cmd);
diff -urpN frr-frr-8.4.2/lib/grammar_sandbox_main.c frr-frr-8.5/lib/grammar_sandbox_main.c
--- frr-frr-8.4.2/lib/grammar_sandbox_main.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/grammar_sandbox_main.c	2023-03-13 20:01:47.000000000 +0600
@@ -49,8 +49,8 @@ int main(int argc, char **argv)
 
 	/* Library inits. */
 	cmd_init(1);
-	host.name = strdup("test");
-	host.domainname = strdup("testdomainname");
+	cmd_hostname_set("test");
+	cmd_domainname_set("testdomainname");
 
 	vty_init(master, true);
 	lib_cmd_init();
diff -urpN frr-frr-8.4.2/lib/if.c frr-frr-8.5/lib/if.c
--- frr-frr-8.4.2/lib/if.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/if.c	2023-03-13 20:01:47.000000000 +0600
@@ -35,11 +35,10 @@
 #include "buffer.h"
 #include "log.h"
 #include "northbound_cli.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/if_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(LIB, IF, "Interface");
+DEFINE_MTYPE_STATIC(LIB, IFDESC, "Intf Desc");
 DEFINE_MTYPE_STATIC(LIB, CONNECTED, "Connected");
 DEFINE_MTYPE_STATIC(LIB, NBR_CONNECTED, "Neighbor Connected");
 DEFINE_MTYPE(LIB, CONNECTED_LABEL, "Connected interface label");
@@ -290,7 +289,7 @@ void if_delete(struct interface **ifp)
 
 	if_link_params_free(ptr);
 
-	XFREE(MTYPE_TMP, ptr->desc);
+	XFREE(MTYPE_IFDESC, ptr->desc);
 
 	XFREE(MTYPE_IF, ptr);
 	*ifp = NULL;
@@ -565,6 +564,20 @@ size_t if_lookup_by_hwaddr(const uint8_t
 	return count;
 }
 
+/* Get the VRF loopback interface, i.e. the loopback on the default VRF
+ * or the VRF interface.
+ */
+struct interface *if_get_vrf_loopback(vrf_id_t vrf_id)
+{
+	struct interface *ifp = NULL;
+	struct vrf *vrf = vrf_lookup_by_id(vrf_id);
+
+	FOR_ALL_INTERFACES (vrf, ifp)
+		if (if_is_loopback(ifp))
+			return ifp;
+
+	return NULL;
+}
 
 /* Get interface by name if given name interface doesn't exist create
    one. */
@@ -1095,13 +1108,15 @@ const char *if_link_type_str(enum zebra_
 
 struct if_link_params *if_link_params_get(struct interface *ifp)
 {
-	int i;
+	return ifp->link_params;
+}
 
-	if (ifp->link_params != NULL)
-		return ifp->link_params;
+struct if_link_params *if_link_params_enable(struct interface *ifp)
+{
+	struct if_link_params *iflp;
+	int i;
 
-	struct if_link_params *iflp =
-		XCALLOC(MTYPE_IF_LINK_PARAMS, sizeof(struct if_link_params));
+	iflp = if_link_params_init(ifp);
 
 	/* Compute default bandwidth based on interface */
 	iflp->default_bw =
@@ -1129,6 +1144,20 @@ struct if_link_params *if_link_params_ge
 	return iflp;
 }
 
+struct if_link_params *if_link_params_init(struct interface *ifp)
+{
+	struct if_link_params *iflp = if_link_params_get(ifp);
+
+	if (iflp)
+		return iflp;
+
+	iflp = XCALLOC(MTYPE_IF_LINK_PARAMS, sizeof(struct if_link_params));
+
+	ifp->link_params = iflp;
+
+	return iflp;
+}
+
 void if_link_params_free(struct interface *ifp)
 {
 	XFREE(MTYPE_IF_LINK_PARAMS, ifp->link_params);
@@ -1191,7 +1220,7 @@ DEFPY_YANG_NOSH (interface,
 	}
 
 	nb_cli_enqueue_change(vty, ".", NB_OP_CREATE, NULL);
-	ret = nb_cli_apply_changes_clear_pending(vty, xpath_list);
+	ret = nb_cli_apply_changes_clear_pending(vty, "%s", xpath_list);
 	if (ret == CMD_SUCCESS) {
 		VTY_PUSH_XPATH(INTERFACE_NODE, xpath_list);
 
@@ -1250,7 +1279,7 @@ DEFPY_YANG (no_interface,
 
 	nb_cli_enqueue_change(vty, ".", NB_OP_DESTROY, NULL);
 
-	return nb_cli_apply_changes(vty, xpath_list);
+	return nb_cli_apply_changes(vty, "%s", xpath_list);
 }
 
 static void netns_ifname_split(const char *xpath, char *ifname, char *vrfname)
@@ -1598,9 +1627,9 @@ static int lib_interface_description_mod
 		return NB_OK;
 
 	ifp = nb_running_get_entry(args->dnode, NULL, true);
-	XFREE(MTYPE_TMP, ifp->desc);
+	XFREE(MTYPE_IFDESC, ifp->desc);
 	description = yang_dnode_get_string(args->dnode, NULL);
-	ifp->desc = XSTRDUP(MTYPE_TMP, description);
+	ifp->desc = XSTRDUP(MTYPE_IFDESC, description);
 
 	return NB_OK;
 }
@@ -1613,7 +1642,7 @@ static int lib_interface_description_des
 		return NB_OK;
 
 	ifp = nb_running_get_entry(args->dnode, NULL, true);
-	XFREE(MTYPE_TMP, ifp->desc);
+	XFREE(MTYPE_IFDESC, ifp->desc);
 
 	return NB_OK;
 }
diff -urpN frr-frr-8.4.2/lib/if.h frr-frr-8.5/lib/if.h
--- frr-frr-8.4.2/lib/if.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/if.h	2023-03-13 20:01:47.000000000 +0600
@@ -143,9 +143,13 @@ struct if_stats {
 #define TE_EXT_MASK             0x0FFFFFFF
 #define TE_EXT_ANORMAL          0x80000000
 #define LOSS_PRECISION          0.000003
+/* TE_MEGA_BIT and TE_BYTE are utilized to convert TE bandwidth */
 #define TE_MEGA_BIT             1000000
 #define TE_BYTE                 8
-#define DEFAULT_BANDWIDTH       10000
+/* Default TE bandwidth when no value in config.
+ * The value is in Mbps (will be multiplied by TE_BYTE)
+ */
+#define DEFAULT_BANDWIDTH 10
 #define MAX_CLASS_TYPE          8
 #define MAX_PKT_LOSS            50.331642
 
@@ -528,6 +532,7 @@ static inline bool if_address_is_local(c
 struct vrf;
 extern struct interface *if_lookup_by_name_vrf(const char *name, struct vrf *vrf);
 extern struct interface *if_lookup_by_name(const char *ifname, vrf_id_t vrf_id);
+extern struct interface *if_get_vrf_loopback(vrf_id_t vrf_id);
 extern struct interface *if_get_by_name(const char *ifname, vrf_id_t vrf_id,
 					const char *vrf_name);
 
@@ -588,6 +593,8 @@ struct connected *connected_get_linkloca
 
 /* link parameters */
 struct if_link_params *if_link_params_get(struct interface *);
+struct if_link_params *if_link_params_enable(struct interface *ifp);
+struct if_link_params *if_link_params_init(struct interface *ifp);
 void if_link_params_free(struct interface *);
 
 /* Northbound. */
diff -urpN frr-frr-8.4.2/lib/ipaddr.h frr-frr-8.5/lib/ipaddr.h
--- frr-frr-8.4.2/lib/ipaddr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/ipaddr.h	2023-03-13 20:01:47.000000000 +0600
@@ -61,6 +61,8 @@ struct ipaddr {
 #define IPADDRSZ(p)                                                            \
 	(IS_IPADDR_V4((p)) ? sizeof(struct in_addr) : sizeof(struct in6_addr))
 
+#define IPADDR_STRING_SIZE 46
+
 static inline int ipaddr_family(const struct ipaddr *ip)
 {
 	switch (ip->ipa_type) {
diff -urpN frr-frr-8.4.2/lib/lib_vty.c frr-frr-8.5/lib/lib_vty.c
--- frr-frr-8.4.2/lib/lib_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/lib_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -225,10 +225,8 @@ static struct call_back {
 } callback;
 
 
-DEFUN_HIDDEN (start_config,
-	      start_config_cmd,
-	      "XFRR_start_configuration",
-	      "The Beginning of Configuration\n")
+DEFUN_NOSH(start_config, start_config_cmd, "XFRR_start_configuration",
+	   "The Beginning of Configuration\n")
 {
 	callback.readin_time = monotime(NULL);
 
@@ -240,10 +238,8 @@ DEFUN_HIDDEN (start_config,
 	return CMD_SUCCESS;
 }
 
-DEFUN_HIDDEN (end_config,
-	      end_config_cmd,
-	      "XFRR_end_configuration",
-	      "The End of Configuration\n")
+DEFUN_NOSH(end_config, end_config_cmd, "XFRR_end_configuration",
+	   "The End of Configuration\n")
 {
 	time_t readin_time;
 	char readin_time_str[MONOTIME_STRLEN];
diff -urpN frr-frr-8.4.2/lib/libfrr.c frr-frr-8.5/lib/libfrr.c
--- frr-frr-8.4.2/lib/libfrr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/libfrr.c	2023-03-13 20:01:47.000000000 +0600
@@ -789,7 +789,7 @@ struct thread_master *frr_init(void)
 #ifdef HAVE_SQLITE3
 	if (!di->db_file)
 		di->db_file = dbfile_default;
-	db_init(di->db_file);
+	db_init("%s", di->db_file);
 #endif
 
 	if (di->flags & FRR_LIMITED_CLI)
diff -urpN frr-frr-8.4.2/lib/link_state.c frr-frr-8.5/lib/link_state.c
--- frr-frr-8.4.2/lib/link_state.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/link_state.c	2023-03-13 20:01:47.000000000 +0600
@@ -346,7 +346,7 @@ struct ls_prefix *ls_prefix_new(struct l
 	if (adv.origin == UNKNOWN)
 		return NULL;
 
-	new = XCALLOC(MTYPE_LS_DB, sizeof(struct ls_attributes));
+	new = XCALLOC(MTYPE_LS_DB, sizeof(struct ls_prefix));
 	new->adv = adv;
 	new->pref = p;
 
diff -urpN frr-frr-8.4.2/lib/linklist.c frr-frr-8.5/lib/linklist.c
--- frr-frr-8.4.2/lib/linklist.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/linklist.c	2023-03-13 20:01:47.000000000 +0600
@@ -129,9 +129,10 @@ void listnode_add_head(struct list *list
 
 	node->next = list->head;
 
-	if (list->head == NULL)
+	if (list->head == NULL) {
 		list->head = node;
-	else
+		list->tail = node;
+	} else
 		list->head->prev = node;
 	list->head = node;
 
diff -urpN frr-frr-8.4.2/lib/log.c frr-frr-8.5/lib/log.c
--- frr-frr-8.4.2/lib/log.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/log.c	2023-03-13 20:01:47.000000000 +0600
@@ -337,6 +337,7 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_INTERFACE_UP),
 	DESC_ENTRY(ZEBRA_INTERFACE_DOWN),
 	DESC_ENTRY(ZEBRA_INTERFACE_SET_MASTER),
+	DESC_ENTRY(ZEBRA_INTERFACE_SET_PROTODOWN),
 	DESC_ENTRY(ZEBRA_ROUTE_ADD),
 	DESC_ENTRY(ZEBRA_ROUTE_DELETE),
 	DESC_ENTRY(ZEBRA_ROUTE_NOTIFY_OWNER),
@@ -386,10 +387,10 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_FEC_REGISTER),
 	DESC_ENTRY(ZEBRA_FEC_UNREGISTER),
 	DESC_ENTRY(ZEBRA_FEC_UPDATE),
-	DESC_ENTRY(ZEBRA_ADVERTISE_ALL_VNI),
 	DESC_ENTRY(ZEBRA_ADVERTISE_DEFAULT_GW),
 	DESC_ENTRY(ZEBRA_ADVERTISE_SVI_MACIP),
 	DESC_ENTRY(ZEBRA_ADVERTISE_SUBNET),
+	DESC_ENTRY(ZEBRA_ADVERTISE_ALL_VNI),
 	DESC_ENTRY(ZEBRA_LOCAL_ES_ADD),
 	DESC_ENTRY(ZEBRA_LOCAL_ES_DEL),
 	DESC_ENTRY(ZEBRA_REMOTE_ES_VTEP_ADD),
@@ -438,19 +439,23 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_MLAG_CLIENT_REGISTER),
 	DESC_ENTRY(ZEBRA_MLAG_CLIENT_UNREGISTER),
 	DESC_ENTRY(ZEBRA_MLAG_FORWARD_MSG),
+	DESC_ENTRY(ZEBRA_NHG_ADD),
+	DESC_ENTRY(ZEBRA_NHG_DEL),
+	DESC_ENTRY(ZEBRA_NHG_NOTIFY_OWNER),
+	DESC_ENTRY(ZEBRA_EVPN_REMOTE_NH_ADD),
+	DESC_ENTRY(ZEBRA_EVPN_REMOTE_NH_DEL),
+	DESC_ENTRY(ZEBRA_SRV6_LOCATOR_ADD),
+	DESC_ENTRY(ZEBRA_SRV6_LOCATOR_DELETE),
+	DESC_ENTRY(ZEBRA_SRV6_MANAGER_GET_LOCATOR_CHUNK),
+	DESC_ENTRY(ZEBRA_SRV6_MANAGER_RELEASE_LOCATOR_CHUNK),
 	DESC_ENTRY(ZEBRA_ERROR),
 	DESC_ENTRY(ZEBRA_CLIENT_CAPABILITIES),
 	DESC_ENTRY(ZEBRA_OPAQUE_MESSAGE),
 	DESC_ENTRY(ZEBRA_OPAQUE_REGISTER),
 	DESC_ENTRY(ZEBRA_OPAQUE_UNREGISTER),
 	DESC_ENTRY(ZEBRA_NEIGH_DISCOVER),
-	DESC_ENTRY(ZEBRA_NHG_ADD),
-	DESC_ENTRY(ZEBRA_NHG_DEL),
-	DESC_ENTRY(ZEBRA_NHG_NOTIFY_OWNER),
 	DESC_ENTRY(ZEBRA_ROUTE_NOTIFY_REQUEST),
 	DESC_ENTRY(ZEBRA_CLIENT_CLOSE_NOTIFY),
-	DESC_ENTRY(ZEBRA_EVPN_REMOTE_NH_ADD),
-	DESC_ENTRY(ZEBRA_EVPN_REMOTE_NH_DEL),
 	DESC_ENTRY(ZEBRA_NHRP_NEIGH_ADDED),
 	DESC_ENTRY(ZEBRA_NHRP_NEIGH_REMOVED),
 	DESC_ENTRY(ZEBRA_NHRP_NEIGH_GET),
@@ -461,7 +466,13 @@ static const struct zebra_desc_table com
 	DESC_ENTRY(ZEBRA_CONFIGURE_ARP),
 	DESC_ENTRY(ZEBRA_GRE_GET),
 	DESC_ENTRY(ZEBRA_GRE_UPDATE),
-	DESC_ENTRY(ZEBRA_GRE_SOURCE_SET)};
+	DESC_ENTRY(ZEBRA_GRE_SOURCE_SET),
+	DESC_ENTRY(ZEBRA_TC_QDISC_INSTALL),
+	DESC_ENTRY(ZEBRA_TC_QDISC_UNINSTALL),
+	DESC_ENTRY(ZEBRA_TC_CLASS_ADD),
+	DESC_ENTRY(ZEBRA_TC_CLASS_DELETE),
+	DESC_ENTRY(ZEBRA_TC_FILTER_ADD),
+	DESC_ENTRY(ZEBRA_TC_FILTER_DELETE)};
 #undef DESC_ENTRY
 
 static const struct zebra_desc_table unknown = {0, "unknown", '?'};
diff -urpN frr-frr-8.4.2/lib/log_vty.c frr-frr-8.5/lib/log_vty.c
--- frr-frr-8.4.2/lib/log_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/log_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -29,9 +29,7 @@
 #include "lib/printfrr.h"
 #include "lib/systemd.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/log_vty_clippy.c"
-#endif
 
 #define ZLOG_MAXLVL(a, b) MAX(a, b)
 
@@ -761,8 +759,8 @@ DEFPY (log_immediate_mode,
        log_immediate_mode_cmd,
        "[no] log immediate-mode",
        NO_STR
-       "Logging control"
-       "Output immediately, without buffering")
+       "Logging control\n"
+       "Output immediately, without buffering\n")
 {
 	zlog_set_immediate(!no);
 	return CMD_SUCCESS;
diff -urpN frr-frr-8.4.2/lib/network.c frr-frr-8.5/lib/network.c
--- frr-frr-8.4.2/lib/network.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/network.c	2023-03-13 20:01:47.000000000 +0600
@@ -122,3 +122,24 @@ float ntohf(float net)
 {
 	return htonf(net);
 }
+
+uint64_t frr_sequence_next(void)
+{
+	static uint64_t last_sequence;
+	struct timespec ts;
+
+	(void)clock_gettime(CLOCK_MONOTONIC, &ts);
+	if (last_sequence == (uint64_t)ts.tv_sec) {
+		last_sequence++;
+		return last_sequence;
+	}
+
+	last_sequence = ts.tv_sec;
+	return last_sequence;
+}
+
+uint32_t frr_sequence32_next(void)
+{
+	/* coverity[Y2K38_SAFETY] */
+	return (uint32_t)frr_sequence_next();
+}
diff -urpN frr-frr-8.4.2/lib/network.h frr-frr-8.5/lib/network.h
--- frr-frr-8.4.2/lib/network.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/network.h	2023-03-13 20:01:47.000000000 +0600
@@ -82,6 +82,24 @@ extern float ntohf(float);
 #endif
 
 /**
+ * Generate a sequence number using monotonic clock with a same second call
+ * protection to help guarantee a unique incremental sequence number that never
+ * goes back (except when wrapping/overflow).
+ *
+ * **NOTE** this function is not thread safe since it uses `static` variable.
+ *
+ * This function and `frr_sequence32_next` should be used to initialize
+ * sequence numbers without directly calling other `time_t` returning
+ * functions because of `time_t` truncation warnings.
+ *
+ * \returns `uint64_t` number based on the monotonic clock.
+ */
+extern uint64_t frr_sequence_next(void);
+
+/** Same as `frr_sequence_next` but returns truncated number. */
+extern uint32_t frr_sequence32_next(void);
+
+/**
  * Helper function that returns a random long value. The main purpose of
  * this function is to hide a `random()` call that gets flagged by coverity
  * scan and put it into one place.
diff -urpN frr-frr-8.4.2/lib/nexthop_group.c frr-frr-8.5/lib/nexthop_group.c
--- frr-frr-8.4.2/lib/nexthop_group.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/nexthop_group.c	2023-03-13 20:01:47.000000000 +0600
@@ -28,9 +28,7 @@
 #include <command.h>
 #include <jhash.h>
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/nexthop_group_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(LIB, NEXTHOP_GROUP, "Nexthop Group");
 
@@ -49,6 +47,7 @@ struct nexthop_hold {
 
 struct nexthop_group_hooks {
 	void (*new)(const char *name);
+	void (*modify)(const struct nexthop_group_cmd *nhgc);
 	void (*add_nexthop)(const struct nexthop_group_cmd *nhg,
 			    const struct nexthop *nhop);
 	void (*del_nexthop)(const struct nexthop_group_cmd *nhg,
@@ -274,6 +273,7 @@ struct nexthop_group *nexthop_group_new(
 void nexthop_group_copy(struct nexthop_group *to,
 			const struct nexthop_group *from)
 {
+	to->nhgr = from->nhgr;
 	/* Copy everything, including recursive info */
 	copy_nexthops(&to->nexthop, from->nexthop, NULL);
 }
@@ -675,6 +675,50 @@ DEFPY(no_nexthop_group_backup, no_nextho
 	return CMD_SUCCESS;
 }
 
+DEFPY(nexthop_group_resilience,
+      nexthop_group_resilience_cmd,
+      "resilient buckets (1-256) idle-timer (1-4294967295) unbalanced-timer (1-4294967295)",
+      "A resilient Nexthop Group\n"
+      "Buckets in the Hash for this Group\n"
+      "Number of buckets\n"
+      "The Idle timer for this Resilient Nexthop Group in seconds\n"
+      "Number of seconds of Idle time\n"
+      "The length of time that the Nexthop Group can be unbalanced\n"
+      "Number of seconds of Unbalanced time\n")
+{
+	VTY_DECLVAR_CONTEXT(nexthop_group_cmd, nhgc);
+
+	nhgc->nhg.nhgr.buckets = buckets;
+	nhgc->nhg.nhgr.idle_timer = idle_timer;
+	nhgc->nhg.nhgr.unbalanced_timer = unbalanced_timer;
+
+	if (nhg_hooks.modify)
+		nhg_hooks.modify(nhgc);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY(no_nexthop_group_resilience,
+      no_nexthop_group_resilience_cmd,
+      "no resilient [buckets (1-256) idle-timer (1-4294967295) unbalanced-timer (1-4294967295)]",
+      NO_STR
+      "A resilient Nexthop Group\n"
+      "Buckets in the Hash for this Group\n"
+      "Number of buckets\n"
+      "The Idle timer for this Resilient Nexthop Group in seconds\n"
+      "Number of seconds of Idle time\n"
+      "The length of time that the Nexthop Group can be unbalanced\n"
+      "Number of seconds of Unbalanced time\n")
+{
+	VTY_DECLVAR_CONTEXT(nexthop_group_cmd, nhgc);
+
+	nhgc->nhg.nhgr.buckets = 0;
+	nhgc->nhg.nhgr.idle_timer = 0;
+	nhgc->nhg.nhgr.unbalanced_timer = 0;
+
+	return CMD_SUCCESS;
+}
+
 static void nexthop_group_save_nhop(struct nexthop_group_cmd *nhgc,
 				    const char *nhvrf_name,
 				    const union sockunion *addr,
@@ -1130,6 +1174,13 @@ static int nexthop_group_write(struct vt
 
 		vty_out(vty, "nexthop-group %s\n", nhgc->name);
 
+		if (nhgc->nhg.nhgr.buckets)
+			vty_out(vty,
+				" resilient buckets %u idle-timer %u unbalanced-timer %u\n",
+				nhgc->nhg.nhgr.buckets,
+				nhgc->nhg.nhgr.idle_timer,
+				nhgc->nhg.nhgr.unbalanced_timer);
+
 		if (nhgc->backup_list_name[0])
 			vty_out(vty, " backup-group %s\n",
 				nhgc->backup_list_name);
@@ -1300,6 +1351,7 @@ static const struct cmd_variable_handler
 	{.completions = NULL}};
 
 void nexthop_group_init(void (*new)(const char *name),
+			void (*modify)(const struct nexthop_group_cmd *nhgc),
 			void (*add_nexthop)(const struct nexthop_group_cmd *nhg,
 					    const struct nexthop *nhop),
 			void (*del_nexthop)(const struct nexthop_group_cmd *nhg,
@@ -1319,10 +1371,15 @@ void nexthop_group_init(void (*new)(cons
 	install_element(NH_GROUP_NODE, &no_nexthop_group_backup_cmd);
 	install_element(NH_GROUP_NODE, &ecmp_nexthops_cmd);
 
+	install_element(NH_GROUP_NODE, &nexthop_group_resilience_cmd);
+	install_element(NH_GROUP_NODE, &no_nexthop_group_resilience_cmd);
+
 	memset(&nhg_hooks, 0, sizeof(nhg_hooks));
 
 	if (new)
 		nhg_hooks.new = new;
+	if (modify)
+		nhg_hooks.modify = modify;
 	if (add_nexthop)
 		nhg_hooks.add_nexthop = add_nexthop;
 	if (del_nexthop)
diff -urpN frr-frr-8.4.2/lib/nexthop_group.h frr-frr-8.5/lib/nexthop_group.h
--- frr-frr-8.4.2/lib/nexthop_group.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/nexthop_group.h	2023-03-13 20:01:47.000000000 +0600
@@ -28,6 +28,13 @@
 extern "C" {
 #endif
 
+struct nhg_resilience {
+	uint16_t buckets;
+	uint32_t idle_timer;
+	uint32_t unbalanced_timer;
+	uint64_t unbalanced_time;
+};
+
 /*
  * What is a nexthop group?
  *
@@ -38,6 +45,8 @@ extern "C" {
  */
 struct nexthop_group {
 	struct nexthop *nexthop;
+
+	struct nhg_resilience nhgr;
 };
 
 struct nexthop_group *nexthop_group_new(void);
@@ -109,9 +118,17 @@ DECLARE_QOBJ_TYPE(nexthop_group_cmd);
  * a nexthop_group is added/deleted/modified, then set the
  * appropriate callback functions to handle it in your
  * code
+ *
+ * create - The creation of the nexthop group
+ * modify - Modification of the nexthop group when not changing a nexthop
+ *          ( resilience as an example )
+ * add_nexthop - A nexthop is added to the NHG
+ * del_nexthop - A nexthop is deleted from the NHG
+ * destroy - The NHG is deleted
  */
 void nexthop_group_init(
 	void (*create)(const char *name),
+	void (*modify)(const struct nexthop_group_cmd *nhgc),
 	void (*add_nexthop)(const struct nexthop_group_cmd *nhgc,
 			    const struct nexthop *nhop),
 	void (*del_nexthop)(const struct nexthop_group_cmd *nhgc,
diff -urpN frr-frr-8.4.2/lib/northbound_cli.c frr-frr-8.5/lib/northbound_cli.c
--- frr-frr-8.4.2/lib/northbound_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/northbound_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -32,9 +32,7 @@
 #include "northbound.h"
 #include "northbound_cli.h"
 #include "northbound_db.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/northbound_cli_clippy.c"
-#endif
 
 struct debug nb_dbg_cbs_config = {0, "Northbound callbacks: configuration"};
 struct debug nb_dbg_cbs_state = {0, "Northbound callbacks: state"};
diff -urpN frr-frr-8.4.2/lib/northbound_cli.h frr-frr-8.5/lib/northbound_cli.h
--- frr-frr-8.4.2/lib/northbound_cli.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/northbound_cli.h	2023-03-13 20:01:47.000000000 +0600
@@ -71,7 +71,8 @@ extern void nb_cli_enqueue_change(struct
  *    CMD_SUCCESS on success, CMD_WARNING_CONFIG_FAILED otherwise.
  */
 extern int nb_cli_apply_changes_clear_pending(struct vty *vty,
-					      const char *xpath_base_fmt, ...);
+					      const char *xpath_base_fmt, ...)
+	PRINTFRR(2, 3);
 
 /*
  * Apply enqueued changes to the candidate configuration, this function
@@ -89,7 +90,7 @@ extern int nb_cli_apply_changes_clear_pe
  *    CMD_SUCCESS on success, CMD_WARNING_CONFIG_FAILED otherwise.
  */
 extern int nb_cli_apply_changes(struct vty *vty, const char *xpath_base_fmt,
-				...);
+				...) PRINTFRR(2, 3);
 
 /*
  * Execute a YANG RPC or Action.
diff -urpN frr-frr-8.4.2/lib/plist.c frr-frr-8.5/lib/plist.c
--- frr-frr-8.4.2/lib/plist.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/plist.c	2023-03-13 20:01:47.000000000 +0600
@@ -1193,9 +1193,7 @@ static int vty_clear_prefix_list(struct
 	return CMD_SUCCESS;
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/plist_clippy.c"
-#endif
 
 DEFPY (show_ip_prefix_list,
        show_ip_prefix_list_cmd,
diff -urpN frr-frr-8.4.2/lib/prefix.c frr-frr-8.5/lib/prefix.c
--- frr-frr-8.4.2/lib/prefix.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/prefix.c	2023-03-13 20:01:47.000000000 +0600
@@ -138,6 +138,23 @@ afi_t family2afi(int family)
 	return 0;
 }
 
+const char *afi2str_lower(afi_t afi)
+{
+	switch (afi) {
+	case AFI_IP:
+		return "ipv4";
+	case AFI_IP6:
+		return "ipv6";
+	case AFI_L2VPN:
+		return "l2vpn";
+	case AFI_MAX:
+	case AFI_UNSPEC:
+		return "bad-value";
+	}
+
+	assert(!"Reached end of function we should never reach");
+}
+
 const char *afi2str(afi_t afi)
 {
 	switch (afi) {
@@ -1404,6 +1421,63 @@ bool ipv4_unicast_valid(const struct in_
 	return true;
 }
 
+static int ipaddr2prefix(const struct ipaddr *ip, uint16_t prefixlen,
+			 struct prefix *p)
+{
+	switch (ip->ipa_type) {
+	case (IPADDR_V4):
+		p->family = AF_INET;
+		p->u.prefix4 = ip->ipaddr_v4;
+		p->prefixlen = prefixlen;
+		break;
+	case (IPADDR_V6):
+		p->family = AF_INET6;
+		p->u.prefix6 = ip->ipaddr_v6;
+		p->prefixlen = prefixlen;
+		break;
+	case (IPADDR_NONE):
+		p->family = AF_UNSPEC;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Convert type-2 and type-5 evpn route prefixes into the more
+ * general ipv4/ipv6 prefix types so we can match prefix lists
+ * and such.
+ */
+int evpn_prefix2prefix(const struct prefix *evpn, struct prefix *to)
+{
+	const struct evpn_addr *addr;
+
+	if (evpn->family != AF_EVPN)
+		return -1;
+
+	addr = &evpn->u.prefix_evpn;
+
+	switch (addr->route_type) {
+	case BGP_EVPN_MAC_IP_ROUTE:
+		if (IS_IPADDR_V4(&addr->macip_addr.ip))
+			ipaddr2prefix(&addr->macip_addr.ip, 32, to);
+		else if (IS_IPADDR_V6(&addr->macip_addr.ip))
+			ipaddr2prefix(&addr->macip_addr.ip, 128, to);
+		else
+			return -1; /* mac only? */
+
+		break;
+	case BGP_EVPN_IP_PREFIX_ROUTE:
+		ipaddr2prefix(&addr->prefix_addr.ip,
+			      addr->prefix_addr.ip_prefix_length, to);
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
 printfrr_ext_autoreg_p("EA", printfrr_ea);
 static ssize_t printfrr_ea(struct fbuf *buf, struct printfrr_eargs *ea,
 			   const void *ptr)
@@ -1432,7 +1506,7 @@ static ssize_t printfrr_ia(struct fbuf *
 		ea->fmt++;
 	}
 
-	if (!ipa)
+	if (!ipa || !ipa->ipa_type)
 		return bputs(buf, "(null)");
 
 	if (use_star) {
diff -urpN frr-frr-8.4.2/lib/prefix.h frr-frr-8.5/lib/prefix.h
--- frr-frr-8.4.2/lib/prefix.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/prefix.h	2023-03-13 20:01:47.000000000 +0600
@@ -301,22 +301,6 @@ struct prefix_sg {
 	struct in_addr grp;
 };
 
-/* helper to get type safety/avoid casts on calls
- * (w/o this, functions accepting all prefix types need casts on the caller
- * side, which strips type safety since the cast will accept any pointer
- * type.)
- */
-#ifndef __cplusplus
-#define prefixtype(uname, typename, fieldname) \
-	typename *fieldname;
-#define TRANSPARENT_UNION __attribute__((transparent_union))
-#else
-#define prefixtype(uname, typename, fieldname) \
-	typename *fieldname; \
-	uname(typename *x) { this->fieldname = x; }
-#define TRANSPARENT_UNION
-#endif
-
 union prefixptr {
 	prefixtype(prefixptr, struct prefix,      p)
 	prefixtype(prefixptr, struct prefix_ipv4, p4)
@@ -414,6 +398,7 @@ extern afi_t family2afi(int);
 extern const char *family2str(int family);
 extern const char *safi2str(safi_t safi);
 extern const char *afi2str(afi_t afi);
+extern const char *afi2str_lower(afi_t afi);
 
 static inline afi_t prefix_afi(union prefixconstptr pu)
 {
@@ -510,6 +495,7 @@ extern char *esi_to_str(const esi_t *esi
 extern char *evpn_es_df_alg2str(uint8_t df_alg, char *buf, int buf_len);
 extern void prefix_evpn_hexdump(const struct prefix_evpn *p);
 extern bool ipv4_unicast_valid(const struct in_addr *addr);
+extern int evpn_prefix2prefix(const struct prefix *evpn, struct prefix *to);
 
 static inline int ipv6_martian(const struct in6_addr *addr)
 {
diff -urpN frr-frr-8.4.2/lib/printf/glue.c frr-frr-8.5/lib/printf/glue.c
--- frr-frr-8.4.2/lib/printf/glue.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/printf/glue.c	2023-03-13 20:01:47.000000000 +0600
@@ -293,5 +293,9 @@ static ssize_t printfrr_va(struct fbuf *
 	 * when allocating a larger buffer in asnprintfrr()
 	 */
 	va_copy(ap, *vaf->va);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+	/* can't format check this */
 	return vbprintfrr(buf, vaf->fmt, ap);
+#pragma GCC diagnostic pop
 }
diff -urpN frr-frr-8.4.2/lib/printf/vfprintf.c frr-frr-8.5/lib/printf/vfprintf.c
--- frr-frr-8.4.2/lib/printf/vfprintf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/printf/vfprintf.c	2023-03-13 20:01:47.000000000 +0600
@@ -504,14 +504,20 @@ reswitch:	switch (ch) {
 				fmt[4] = ch;
 				fmt[5] = '\0';
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
 				snprintf(buf, sizeof(buf), fmt, prec, arg);
+#pragma GCC diagnostic pop
 			} else {
 				double arg = GETARG(double);
 				char fmt[5] = "%.*";
 				fmt[3] = ch;
 				fmt[4] = '\0';
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
 				snprintf(buf, sizeof(buf), fmt, prec, arg);
+#pragma GCC diagnostic pop
 			}
 			cp = buf;
 			/* for proper padding */
diff -urpN frr-frr-8.4.2/lib/privs.c frr-frr-8.5/lib/privs.c
--- frr-frr-8.4.2/lib/privs.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/privs.c	2023-03-13 20:01:47.000000000 +0600
@@ -261,8 +261,34 @@ zebra_privs_current_t zprivs_state_caps(
 	return ZPRIVS_LOWERED;
 }
 
+/** Release private cap state if allocated. */
+static void zprivs_state_free_caps(void)
+{
+	if (zprivs_state.syscaps_p) {
+		if (zprivs_state.syscaps_p->num)
+			XFREE(MTYPE_PRIVS, zprivs_state.syscaps_p->caps);
+
+		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_p);
+	}
+
+	if (zprivs_state.syscaps_i) {
+		if (zprivs_state.syscaps_i->num)
+			XFREE(MTYPE_PRIVS, zprivs_state.syscaps_i->caps);
+
+		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_i);
+	}
+
+	if (zprivs_state.caps) {
+		cap_free(zprivs_state.caps);
+		zprivs_state.caps = NULL;
+	}
+}
+
 static void zprivs_caps_init(struct zebra_privs_t *zprivs)
 {
+	/* Release allocated zcaps if this function was called before. */
+	zprivs_state_free_caps();
+
 	zprivs_state.syscaps_p = zcaps2sys(zprivs->caps_p, zprivs->cap_num_p);
 	zprivs_state.syscaps_i = zcaps2sys(zprivs->caps_i, zprivs->cap_num_i);
 
@@ -362,18 +388,7 @@ static void zprivs_caps_terminate(void)
 		exit(1);
 	}
 
-	/* free up private state */
-	if (zprivs_state.syscaps_p && zprivs_state.syscaps_p->num) {
-		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_p->caps);
-		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_p);
-	}
-
-	if (zprivs_state.syscaps_i && zprivs_state.syscaps_i->num) {
-		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_i->caps);
-		XFREE(MTYPE_PRIVS, zprivs_state.syscaps_i);
-	}
-
-	cap_free(zprivs_state.caps);
+	zprivs_state_free_caps();
 }
 #else /* !HAVE_LCAPS */
 #error "no Linux capabilities, dazed and confused..."
diff -urpN frr-frr-8.4.2/lib/routemap.c frr-frr-8.5/lib/routemap.c
--- frr-frr-8.4.2/lib/routemap.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/routemap.c	2023-03-13 20:01:47.000000000 +0600
@@ -1815,7 +1815,24 @@ route_map_get_index(struct route_map *ma
 	struct route_map_index *index = NULL, *best_index = NULL;
 	struct route_map_index *head_index = NULL;
 	struct route_table *table = NULL;
-	unsigned char family = prefix->family;
+	struct prefix conv;
+	unsigned char family;
+
+	/*
+	 * Handling for matching evpn_routes in the prefix table.
+	 *
+	 * We convert type2/5 prefix to ipv4/6 prefix to do longest
+	 * prefix matching on.
+	 */
+	if (prefix->family == AF_EVPN) {
+		if (evpn_prefix2prefix(prefix, &conv) != 0)
+			return NULL;
+
+		prefix = &conv;
+	}
+
+
+	family = prefix->family;
 
 	if (family == AF_INET)
 		table = map->ipv4_prefix_table;
@@ -3169,6 +3186,12 @@ static struct cmd_node rmap_debug_node =
 	.config_write = rmap_config_write_debug,
 };
 
+void route_map_show_debug(struct vty *vty)
+{
+	if (rmap_debug)
+		vty_out(vty, "debug route-map\n");
+}
+
 /* Configuration write function. */
 static int rmap_config_write_debug(struct vty *vty)
 {
diff -urpN frr-frr-8.4.2/lib/routemap.h frr-frr-8.5/lib/routemap.h
--- frr-frr-8.4.2/lib/routemap.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/routemap.h	2023-03-13 20:01:47.000000000 +0600
@@ -348,6 +348,7 @@ DECLARE_QOBJ_TYPE(route_map);
 	(strmatch(A, "frr-bgp-route-map:set-origin"))
 #define IS_SET_ATOMIC_AGGREGATE(A)                                             \
 	(strmatch(A, "frr-bgp-route-map:atomic-aggregate"))
+#define IS_SET_AIGP_METRIC(A) (strmatch(A, "frr-bgp-route-map:aigp-metric"))
 #define IS_SET_ORIGINATOR_ID(A)                                                \
 	(strmatch(A, "frr-bgp-route-map:originator-id"))
 #define IS_SET_COMM_LIST_DEL(A)                                                \
@@ -1015,6 +1016,8 @@ extern void route_map_optimization_disab
 						 bool show_defaults);
 extern void route_map_cli_init(void);
 
+extern void route_map_show_debug(struct vty *vty);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/lib/routemap_cli.c frr-frr-8.5/lib/routemap_cli.c
--- frr-frr-8.4.2/lib/routemap_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/routemap_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -26,9 +26,7 @@
 #include "lib/northbound_cli.h"
 #include "lib/routemap.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/routemap_cli_clippy.c"
-#endif /* VTYSH_EXTRACT_PL */
 
 #define ROUTE_MAP_CMD_STR \
 	"Create route-map or enter route-map command mode\n" \
@@ -1089,6 +1087,11 @@ void route_map_action_show(struct vty *v
 				"./rmap-set-action/frr-bgp-route-map:origin"));
 	} else if (IS_SET_ATOMIC_AGGREGATE(action)) {
 		vty_out(vty, " set atomic-aggregate\n");
+	} else if (IS_SET_AIGP_METRIC(action)) {
+		vty_out(vty, " set aigp-metric %s\n",
+			yang_dnode_get_string(
+				dnode,
+				"./rmap-set-action/frr-bgp-route-map:aigp-metric"));
 	} else if (IS_SET_ORIGINATOR_ID(action)) {
 		vty_out(vty, " set originator-id %s\n",
 			yang_dnode_get_string(
diff -urpN frr-frr-8.4.2/lib/smux.h frr-frr-8.5/lib/smux.h
--- frr-frr-8.4.2/lib/smux.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/smux.h	2023-03-13 20:01:47.000000000 +0600
@@ -44,6 +44,7 @@ extern "C" {
 #define SNMP_INVALID 2
 
 #define IN_ADDR_SIZE sizeof(struct in_addr)
+#define IN6_ADDR_SIZE sizeof(struct in6_addr)
 
 /* IANAipRouteProtocol */
 #define IANAIPROUTEPROTOCOLOTHER 1
@@ -87,8 +88,9 @@ struct index_oid {
 /* Declare SMUX return value. */
 #define SNMP_LOCAL_VARIABLES                                                   \
 	static long snmp_int_val __attribute__((unused));                      \
-	static struct in_addr snmp_in_addr_val __attribute__((unused));
-	static uint8_t snmp_octet_val __attribute__((unused));
+	static struct in_addr snmp_in_addr_val __attribute__((unused));        \
+	static uint8_t snmp_octet_val __attribute__((unused));                 \
+	static char snmp_string_val[255] __attribute__((unused));
 #define SNMP_INTEGER(V)                                                        \
 	(*var_len = sizeof(snmp_int_val), snmp_int_val = V,                    \
 	 (uint8_t *)&snmp_int_val)
@@ -97,13 +99,20 @@ struct index_oid {
 	(*var_len = sizeof(snmp_octet_val), snmp_octet_val = V,                    \
 	 (uint8_t *)&snmp_octet_val)
 
+#define SNMP_STRING(V)                                                         \
+	(*var_len = MIN(sizeof(snmp_string_val), strlen(V) + 1),               \
+	 strlcpy(snmp_string_val, V, *var_len), (uint8_t *)&snmp_string_val)
+
 #define SNMP_IPADDRESS(V)                                                      \
 	(*var_len = sizeof(struct in_addr), snmp_in_addr_val = V,              \
 	 (uint8_t *)&snmp_in_addr_val)
 
 #define SNMP_IP6ADDRESS(V) (*var_len = sizeof(struct in6_addr), (uint8_t *)&V)
 
-extern int smux_enabled(void);
+/*
+ * Check to see if snmp is enabled or not
+ */
+extern bool smux_enabled(void);
 
 extern void smux_init(struct thread_master *tm);
 extern void smux_agentx_enable(void);
diff -urpN frr-frr-8.4.2/lib/sockopt.c frr-frr-8.5/lib/sockopt.c
--- frr-frr-8.4.2/lib/sockopt.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/sockopt.c	2023-03-13 20:01:47.000000000 +0600
@@ -693,3 +693,52 @@ int sockopt_tcp_mss_get(int sock)
 
 	return tcp_maxseg;
 }
+
+int setsockopt_tcp_keepalive(int sock, uint16_t keepalive_idle,
+			     uint16_t keepalive_intvl,
+			     uint16_t keepalive_probes)
+{
+	int val = 1;
+
+	if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) < 0) {
+		flog_err_sys(EC_LIB_SYSTEM_CALL,
+			     "%s failed: setsockopt SO_KEEPALIVE (%d): %s",
+			     __func__, sock, safe_strerror(errno));
+		return -1;
+	}
+
+#if defined __OpenBSD__
+	return 0;
+#else
+	/* Send first probe after keepalive_idle seconds */
+	val = keepalive_idle;
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) <
+	    0) {
+		flog_err_sys(EC_LIB_SYSTEM_CALL,
+			     "%s failed: setsockopt TCP_KEEPIDLE (%d): %s",
+			     __func__, sock, safe_strerror(errno));
+		return -1;
+	}
+
+	/* Set interval between two probes */
+	val = keepalive_intvl;
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) <
+	    0) {
+		flog_err_sys(EC_LIB_SYSTEM_CALL,
+			     "%s failed: setsockopt TCP_KEEPINTVL (%d): %s",
+			     __func__, sock, safe_strerror(errno));
+		return -1;
+	}
+
+	/* Set maximum probes */
+	val = keepalive_probes;
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {
+		flog_err_sys(EC_LIB_SYSTEM_CALL,
+			     "%s failed: setsockopt TCP_KEEPCNT (%d): %s",
+			     __func__, sock, safe_strerror(errno));
+		return -1;
+	}
+
+	return 0;
+#endif
+}
diff -urpN frr-frr-8.4.2/lib/sockopt.h frr-frr-8.5/lib/sockopt.h
--- frr-frr-8.4.2/lib/sockopt.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/sockopt.h	2023-03-13 20:01:47.000000000 +0600
@@ -153,6 +153,28 @@ extern int sockopt_tcp_mss_set(int sock,
  *    Socket to get max segement size.
  */
 extern int sockopt_tcp_mss_get(int sock);
+
+/*
+ * Configure TCP keepalive for a given socket
+ *
+ * sock
+ *   Socket to enable keepalive option on.
+ *
+ * keepalive_idle
+ *   number of seconds a connection needs to be idle
+ *   before sending out keep-alive proves
+ *
+ * keepalive_intvl
+ *   number of seconds between TCP keep-alive probes
+ *
+ * keepalive_probes
+ *   max number of probers to send before giving up
+ *   and killing tcp connection
+ */
+extern int setsockopt_tcp_keepalive(int sock, uint16_t keepalive_idle,
+				    uint16_t keepalive_intvl,
+				    uint16_t keepalive_probes);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/lib/srv6.c frr-frr-8.5/lib/srv6.c
--- frr-frr-8.4.2/lib/srv6.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/srv6.c	2023-03-13 20:01:47.000000000 +0600
@@ -57,6 +57,8 @@ const char *seg6local_action2str(uint32_
 		return "End.AS";
 	case ZEBRA_SEG6_LOCAL_ACTION_END_AM:
 		return "End.AM";
+	case ZEBRA_SEG6_LOCAL_ACTION_END_DT46:
+		return "End.DT46";
 	case ZEBRA_SEG6_LOCAL_ACTION_UNSPEC:
 		return "unspec";
 	default:
@@ -83,8 +85,6 @@ const char *seg6local_context2str(char *
 				  const struct seg6local_context *ctx,
 				  uint32_t action)
 {
-	char b0[128];
-
 	switch (action) {
 
 	case ZEBRA_SEG6_LOCAL_ACTION_END:
@@ -93,18 +93,17 @@ const char *seg6local_context2str(char *
 
 	case ZEBRA_SEG6_LOCAL_ACTION_END_X:
 	case ZEBRA_SEG6_LOCAL_ACTION_END_DX6:
-		inet_ntop(AF_INET6, &ctx->nh6, b0, 128);
-		snprintf(str, size, "nh6 %s", b0);
+		snprintfrr(str, size, "nh6 %pI6", &ctx->nh6);
 		return str;
 
 	case ZEBRA_SEG6_LOCAL_ACTION_END_DX4:
-		inet_ntop(AF_INET, &ctx->nh4, b0, 128);
-		snprintf(str, size, "nh4 %s", b0);
+		snprintfrr(str, size, "nh4 %pI4", &ctx->nh4);
 		return str;
 
 	case ZEBRA_SEG6_LOCAL_ACTION_END_T:
 	case ZEBRA_SEG6_LOCAL_ACTION_END_DT6:
 	case ZEBRA_SEG6_LOCAL_ACTION_END_DT4:
+	case ZEBRA_SEG6_LOCAL_ACTION_END_DT46:
 		snprintf(str, size, "table %u", ctx->table);
 		return str;
 
@@ -122,6 +121,13 @@ const char *seg6local_context2str(char *
 	}
 }
 
+static void srv6_locator_chunk_list_free(void *data)
+{
+	struct srv6_locator_chunk *chunk = data;
+
+	srv6_locator_chunk_free(&chunk);
+}
+
 struct srv6_locator *srv6_locator_alloc(const char *name)
 {
 	struct srv6_locator *locator = NULL;
@@ -129,7 +135,7 @@ struct srv6_locator *srv6_locator_alloc(
 	locator = XCALLOC(MTYPE_SRV6_LOCATOR, sizeof(struct srv6_locator));
 	strlcpy(locator->name, name, sizeof(locator->name));
 	locator->chunks = list_new();
-	locator->chunks->del = (void (*)(void *))srv6_locator_chunk_free;
+	locator->chunks->del = srv6_locator_chunk_list_free;
 
 	QOBJ_REG(locator, srv6_locator);
 	return locator;
@@ -154,9 +160,9 @@ void srv6_locator_free(struct srv6_locat
 	}
 }
 
-void srv6_locator_chunk_free(struct srv6_locator_chunk *chunk)
+void srv6_locator_chunk_free(struct srv6_locator_chunk **chunk)
 {
-	XFREE(MTYPE_SRV6_LOCATOR_CHUNK, chunk);
+	XFREE(MTYPE_SRV6_LOCATOR_CHUNK, *chunk);
 }
 
 json_object *srv6_locator_chunk_json(const struct srv6_locator_chunk *chunk)
@@ -228,10 +234,24 @@ json_object *srv6_locator_json(const str
 	/* set prefix */
 	json_object_string_addf(jo_root, "prefix", "%pFX", &loc->prefix);
 
+	/* set block_bits_length */
+	json_object_int_add(jo_root, "blockBitsLength", loc->block_bits_length);
+
+	/* set node_bits_length */
+	json_object_int_add(jo_root, "nodeBitsLength", loc->node_bits_length);
+
 	/* set function_bits_length */
 	json_object_int_add(jo_root, "functionBitsLength",
 			    loc->function_bits_length);
 
+	/* set argument_bits_length */
+	json_object_int_add(jo_root, "argumentBitsLength",
+			    loc->argument_bits_length);
+
+	/* set true if the locator is a Micro-segment (uSID) locator */
+	if (CHECK_FLAG(loc->flags, SRV6_LOCATOR_USID))
+		json_object_string_add(jo_root, "behavior", "usid");
+
 	/* set status_up */
 	json_object_boolean_add(jo_root, "statusUp",
 				loc->status_up);
@@ -277,6 +297,10 @@ json_object *srv6_locator_detailed_json(
 	json_object_int_add(jo_root, "argumentBitsLength",
 			    loc->argument_bits_length);
 
+	/* set true if the locator is a Micro-segment (uSID) locator */
+	if (CHECK_FLAG(loc->flags, SRV6_LOCATOR_USID))
+		json_object_string_add(jo_root, "behavior", "usid");
+
 	/* set algonum */
 	json_object_int_add(jo_root, "algoNum", loc->algonum);
 
diff -urpN frr-frr-8.4.2/lib/srv6.h frr-frr-8.5/lib/srv6.h
--- frr-frr-8.4.2/lib/srv6.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/srv6.h	2023-03-13 20:01:47.000000000 +0600
@@ -60,6 +60,7 @@ enum seg6local_action_t {
 	ZEBRA_SEG6_LOCAL_ACTION_END_AS       = 13,
 	ZEBRA_SEG6_LOCAL_ACTION_END_AM       = 14,
 	ZEBRA_SEG6_LOCAL_ACTION_END_BPF      = 15,
+	ZEBRA_SEG6_LOCAL_ACTION_END_DT46     = 16,
 };
 
 struct seg6_segs {
@@ -91,6 +92,9 @@ struct srv6_locator {
 	bool status_up;
 	struct list *chunks;
 
+	uint8_t flags;
+#define SRV6_LOCATOR_USID (1 << 0) /* The SRv6 Locator is a uSID Locator */
+
 	QOBJ_FIELDS;
 };
 DECLARE_QOBJ_TYPE(srv6_locator);
@@ -115,6 +119,23 @@ struct srv6_locator_chunk {
 	uint8_t proto;
 	uint16_t instance;
 	uint32_t session_id;
+
+	uint8_t flags;
+};
+
+/*
+ * SRv6 Endpoint Behavior codepoints, as defined by IANA in
+ * https://www.iana.org/assignments/segment-routing/segment-routing.xhtml
+ */
+enum srv6_endpoint_behavior_codepoint {
+	SRV6_ENDPOINT_BEHAVIOR_RESERVED       = 0x0000,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT6        = 0x0012,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT4        = 0x0013,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT46       = 0x0014,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT6_USID   = 0x003E,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT4_USID   = 0x003F,
+	SRV6_ENDPOINT_BEHAVIOR_END_DT46_USID  = 0x0040,
+	SRV6_ENDPOINT_BEHAVIOR_OPAQUE         = 0xFFFF,
 };
 
 struct nexthop_srv6 {
@@ -186,7 +207,7 @@ int snprintf_seg6_segs(char *str,
 extern struct srv6_locator *srv6_locator_alloc(const char *name);
 extern struct srv6_locator_chunk *srv6_locator_chunk_alloc(void);
 extern void srv6_locator_free(struct srv6_locator *locator);
-extern void srv6_locator_chunk_free(struct srv6_locator_chunk *chunk);
+extern void srv6_locator_chunk_free(struct srv6_locator_chunk **chunk);
 json_object *srv6_locator_chunk_json(const struct srv6_locator_chunk *chunk);
 json_object *srv6_locator_json(const struct srv6_locator *loc);
 json_object *srv6_locator_detailed_json(const struct srv6_locator *loc);
diff -urpN frr-frr-8.4.2/lib/stream.h frr-frr-8.5/lib/stream.h
--- frr-frr-8.4.2/lib/stream.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/stream.h	2023-03-13 20:01:47.000000000 +0600
@@ -386,6 +386,18 @@ extern void stream_fifo_free(struct stre
  * bit), for 64-bit values (you need to cast them anyway), and neither for
  * encoding (because it's downcasted.)
  */
+static inline const uint8_t *ptr_get_be64(const uint8_t *ptr, uint64_t *out)
+{
+	uint32_t tmp1, tmp2;
+
+	memcpy(&tmp1, ptr, sizeof(tmp1));
+	memcpy(&tmp2, ptr + sizeof(tmp1), sizeof(tmp1));
+
+	*out = (((uint64_t)ntohl(tmp1)) << 32) | ntohl(tmp2);
+
+	return ptr + 8;
+}
+
 static inline const uint8_t *ptr_get_be32(const uint8_t *ptr, uint32_t *out)
 {
 	uint32_t tmp;
diff -urpN frr-frr-8.4.2/lib/subdir.am frr-frr-8.5/lib/subdir.am
--- frr-frr-8.4.2/lib/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -123,6 +123,7 @@ lib_libfrr_la_SOURCES = \
 	lib/printf/glue.c \
 	lib/routing_nb.c \
 	lib/routing_nb_config.c \
+	lib/tc.c \
 	# end
 
 nodist_lib_libfrr_la_SOURCES = \
@@ -139,27 +140,6 @@ nodist_lib_libfrr_la_SOURCES = \
 	yang/frr-module-translator.yang.c \
 	# end
 
-vtysh_scan += \
-	lib/distribute.c \
-	lib/filter.c \
-	lib/filter_cli.c \
-	lib/if.c \
-	lib/if_rmap.c \
-	lib/keychain.c \
-	lib/lib_vty.c \
-	lib/log_vty.c \
-	lib/nexthop_group.c \
-	lib/plist.c \
-	lib/routemap.c \
-	lib/routemap_cli.c \
-	lib/spf_backoff.c \
-	lib/thread.c \
-	lib/vrf.c \
-	lib/vty.c \
-	# end
-# can be loaded as DSO - always include for vtysh
-vtysh_scan += lib/agentx.c
-
 if SQLITE3
 lib_libfrr_la_LIBADD += $(SQLITE3_LIBS)
 lib_libfrr_la_SOURCES += lib/db.c
@@ -295,6 +275,7 @@ pkginclude_HEADERS += \
 	lib/zlog_live.h \
 	lib/zlog_targets.h \
 	lib/pbr.h \
+	lib/tc.h \
 	lib/routing_nb.h \
 	\
 	lib/assert/assert.h \
@@ -346,7 +327,6 @@ lib_libfrrsnmp_la_SOURCES = \
 if CARES
 lib_LTLIBRARIES += lib/libfrrcares.la
 pkginclude_HEADERS += lib/resolver.h
-vtysh_scan += lib/resolver.c
 endif
 
 lib_libfrrcares_la_CFLAGS = $(AM_CFLAGS) $(CARES_CFLAGS)
@@ -477,13 +457,18 @@ SUFFIXES += .xref
 
 # dependencies added in python/makefile.py
 frr.xref:
-	$(AM_V_XRELFO) $(CLIPPY) $(top_srcdir)/python/xrelfo.py -o $@ $^
+	$(AM_V_XRELFO) $(CLIPPY) $(top_srcdir)/python/xrelfo.py -o $@ -c vtysh/vtysh_cmd.c $^
 all-am: frr.xref
 
 clean-xref:
 	-rm -rf $(xrefs) frr.xref
 clean-local: clean-xref
 
+CLEANFILES += vtysh/vtysh_cmd.c
+vtysh/vtysh_cmd.c: frr.xref
+	@test -f $@ || rm -f frr.xref || true
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) frr.xref
+
 ## automake's "ylwrap" is a great piece of GNU software... not.
 .l.c:
 	$(AM_V_LEX)$(am__skiplex) $(LEXCOMPILE) $<
@@ -582,6 +567,7 @@ rt_enabled += --enabled zebra
 endif
 
 lib/route_types.h: $(top_srcdir)/lib/route_types.txt $(top_srcdir)/lib/route_types.pl
+	@$(MKDIR_P) lib
 	$(PERL) $(top_srcdir)/lib/route_types.pl $(rt_enabled) < $(top_srcdir)/lib/route_types.txt > $@
 DISTCLEANFILES += lib/route_types.h
 
@@ -596,6 +582,7 @@ PHONY_GITVERSION=lib/gitversion.h.tmp
 .SILENT: lib/gitversion.h lib/gitversion.h.tmp
 GITH=lib/gitversion.h
 lib/gitversion.h.tmp: $(top_srcdir)/.git
+	@$(MKDIR_P) lib
 	$(PERL) $(top_srcdir)/lib/gitversion.pl $(top_srcdir) > ${GITH}.tmp
 lib/gitversion.h: lib/gitversion.h.tmp
 	{ test -f ${GITH} && diff -s -q ${GITH}.tmp ${GITH}; } || cp ${GITH}.tmp ${GITH}
diff -urpN frr-frr-8.4.2/lib/tc.c frr-frr-8.5/lib/tc.c
--- frr-frr-8.4.2/lib/tc.c	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/lib/tc.c	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,88 @@
+/*
+ * Traffic Control (TC) main library
+ * Copyright (C) 2022  Shichu Yang
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "tc.h"
+
+int tc_getrate(const char *str, uint64_t *rate)
+{
+	char *endp;
+	uint64_t raw = strtoull(str, &endp, 10);
+
+	if (endp == str)
+		return -1;
+
+	/* if the string only contains a number, it must be valid rate (bps) */
+	bool valid = (*endp == '\0');
+
+	const char *p = endp;
+	bool bytes = false, binary_base = false;
+	int power = 0;
+
+	while (*p) {
+		if (strcmp(p, "Bps") == 0) {
+			bytes = true;
+			valid = true;
+			break;
+		} else if (strcmp(p, "bit") == 0) {
+			valid = true;
+			break;
+		}
+		switch (*p) {
+		case 'k':
+		case 'K':
+			power = 1;
+			break;
+		case 'm':
+		case 'M':
+			power = 2;
+			break;
+		case 'g':
+		case 'G':
+			power = 3;
+			break;
+		case 't':
+		case 'T':
+			power = 4;
+			break;
+		case 'i':
+		case 'I':
+			if (power != 0)
+				binary_base = true;
+			else
+				return -1;
+			break;
+		default:
+			return -1;
+		}
+		p++;
+	}
+
+	if (!valid)
+		return -1;
+
+	for (int i = 0; i < power; i++)
+		raw *= binary_base ? 1024ULL : 1000ULL;
+
+	if (bytes)
+		*rate = raw;
+	else
+		*rate = raw / 8ULL;
+
+	return 0;
+}
diff -urpN frr-frr-8.4.2/lib/tc.h frr-frr-8.5/lib/tc.h
--- frr-frr-8.4.2/lib/tc.h	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/lib/tc.h	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,151 @@
+/*
+ * Traffic Control (TC) main header
+ * Copyright (C) 2022  Shichu Yang
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _TC_H
+#define _TC_H
+
+#include <zebra.h>
+#include "stream.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TC_STR "Traffic Control\n"
+
+/* qdisc definitions */
+
+/* qdisc kind (same as class kinds) */
+enum tc_qdisc_kind {
+	TC_QDISC_UNSPEC,
+	TC_QDISC_HTB,
+	TC_QDISC_NOQUEUE,
+};
+
+struct tc_qdisc_htb {
+	/* currently no members */
+};
+
+struct tc_qdisc {
+	ifindex_t ifindex;
+
+	enum tc_qdisc_kind kind;
+	union {
+		struct tc_qdisc_htb htb;
+	} u;
+};
+
+/* class definitions */
+
+/* since classes share the same kinds of qdisc, duplicates omitted */
+struct tc_class_htb {
+	uint64_t rate;
+	uint64_t ceil;
+};
+
+struct tc_class {
+	ifindex_t ifindex;
+	uint32_t handle;
+
+	enum tc_qdisc_kind kind;
+	union {
+		struct tc_class_htb htb;
+	} u;
+};
+
+/* filter definitions */
+
+/* filter kinds */
+enum tc_filter_kind {
+	TC_FILTER_UNSPEC,
+	TC_FILTER_BPF,
+	TC_FILTER_FLOW,
+	TC_FILTER_FLOWER,
+	TC_FILTER_U32,
+};
+
+struct tc_bpf {
+	/* TODO: fill in */
+};
+
+struct tc_flow {
+	/* TODO: fill in */
+};
+
+struct tc_flower {
+	uint32_t classid;
+
+#define TC_FLOWER_IP_PROTOCOL (1 << 0)
+#define TC_FLOWER_SRC_IP (1 << 1)
+#define TC_FLOWER_DST_IP (1 << 2)
+#define TC_FLOWER_SRC_PORT (1 << 3)
+#define TC_FLOWER_DST_PORT (1 << 4)
+#define TC_FLOWER_DSFIELD (1 << 5)
+
+	uint32_t filter_bm;
+
+	uint8_t ip_proto;
+
+	struct prefix src_ip;
+	struct prefix dst_ip;
+
+	uint16_t src_port_min;
+	uint16_t src_port_max;
+	uint16_t dst_port_min;
+	uint16_t dst_port_max;
+
+	uint8_t dsfield;
+	uint8_t dsfield_mask;
+};
+
+struct tc_u32 {
+	/* TODO: fill in */
+};
+
+struct tc_filter {
+	ifindex_t ifindex;
+	uint32_t handle;
+
+	uint32_t priority;
+	uint16_t protocol;
+
+	enum tc_filter_kind kind;
+
+	union {
+		struct tc_bpf bpf;
+		struct tc_flow flow;
+		struct tc_flower flower;
+		struct tc_u32 u32;
+	} u;
+};
+
+extern int tc_getrate(const char *str, uint64_t *rate);
+
+extern int zapi_tc_qdisc_encode(uint8_t cmd, struct stream *s,
+				struct tc_qdisc *qdisc);
+extern int zapi_tc_class_encode(uint8_t cmd, struct stream *s,
+				struct tc_class *class);
+extern int zapi_tc_filter_encode(uint8_t cmd, struct stream *s,
+				 struct tc_filter *filter);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TC_H */
diff -urpN frr-frr-8.4.2/lib/termtable.c frr-frr-8.5/lib/termtable.c
--- frr-frr-8.4.2/lib/termtable.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/termtable.c	2023-03-13 20:01:47.000000000 +0600
@@ -130,6 +130,7 @@ struct ttable *ttable_new(const struct t
  *
  * @return pointer to the first cell of allocated row
  */
+PRINTFRR(3, 0)
 static struct ttable_cell *ttable_insert_row_va(struct ttable *tt, int i,
 						const char *format, va_list ap)
 {
@@ -435,13 +436,12 @@ char *ttable_dump(struct ttable *tt, con
 				abspad -= row[j].style.border.right_on ? 1 : 0;
 
 			/* print text */
-			const char *fmt;
 			if (row[j].style.align == LEFT)
-				fmt = "%-*s";
+				pos += sprintf(&buf[pos], "%-*s", abspad,
+					       row[j].text);
 			else
-				fmt = "%*s";
-
-			pos += sprintf(&buf[pos], fmt, abspad, row[j].text);
+				pos += sprintf(&buf[pos], "%*s", abspad,
+					       row[j].text);
 
 			/* print right padding */
 			for (int k = 0; k < row[j].style.rpad; k++)
diff -urpN frr-frr-8.4.2/lib/thread.c frr-frr-8.5/lib/thread.c
--- frr-frr-8.4.2/lib/thread.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/thread.c	2023-03-13 20:01:47.000000000 +0600
@@ -102,9 +102,7 @@ unsigned long cputime_threshold = CONSUM
 unsigned long walltime_threshold = CONSUMED_TIME_CHECK;
 
 /* CLI start ---------------------------------------------------------------- */
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/thread_clippy.c"
-#endif
 
 static unsigned int cpu_record_hash_key(const struct cpu_thread_history *a)
 {
diff -urpN frr-frr-8.4.2/lib/typesafe.h frr-frr-8.5/lib/typesafe.h
--- frr-frr-8.4.2/lib/typesafe.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/typesafe.h	2023-03-13 20:01:47.000000000 +0600
@@ -850,9 +850,12 @@ macro_inline type *prefix ## _add(struct
 	struct thash_item **np = &h->hh.entries[hbits];                        \
 	while (*np && (*np)->hashval < hval)                                   \
 		np = &(*np)->next;                                             \
-	if (*np && cmpfn(container_of(*np, type, field.hi), item) == 0) {      \
-		h->hh.count--;                                                 \
-		return container_of(*np, type, field.hi);                      \
+	while (*np && (*np)->hashval == hval) {                                \
+		if (cmpfn(container_of(*np, type, field.hi), item) == 0) {     \
+			h->hh.count--;                                         \
+			return container_of(*np, type, field.hi);              \
+		}                                                              \
+		np = &(*np)->next;                                             \
 	}                                                                      \
 	item->field.hi.next = *np;                                             \
 	*np = &item->field.hi;                                                 \
diff -urpN frr-frr-8.4.2/lib/vrf.c frr-frr-8.5/lib/vrf.c
--- frr-frr-8.4.2/lib/vrf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/vrf.c	2023-03-13 20:01:47.000000000 +0600
@@ -652,7 +652,7 @@ DEFUN_YANG_NOSH (vrf,
 	snprintf(xpath_list, sizeof(xpath_list), FRR_VRF_KEY_XPATH, vrfname);
 
 	nb_cli_enqueue_change(vty, xpath_list, NB_OP_CREATE, NULL);
-	ret = nb_cli_apply_changes_clear_pending(vty, xpath_list);
+	ret = nb_cli_apply_changes_clear_pending(vty, "%s", xpath_list);
 	if (ret == CMD_SUCCESS) {
 		VTY_PUSH_XPATH(VRF_NODE, xpath_list);
 		vrf = vrf_lookup_by_name(vrfname);
@@ -1000,8 +1000,7 @@ lib_vrf_state_active_get_elem(struct nb_
 	struct vrf *vrfp = (struct vrf *)args->list_entry;
 
 	if (vrfp->status == VRF_ACTIVE)
-		return yang_data_new_bool(
-			args->xpath, vrfp->status == VRF_ACTIVE ? true : false);
+		return yang_data_new_bool(args->xpath, true);
 
 	return NULL;
 }
diff -urpN frr-frr-8.4.2/lib/vty.c frr-frr-8.5/lib/vty.c
--- frr-frr-8.4.2/lib/vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -24,11 +24,16 @@
 #include <lib/version.h>
 #include <sys/types.h>
 #include <sys/types.h>
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 #include <stdio.h>
 
 #include "linklist.h"
@@ -53,9 +58,7 @@
 #include <arpa/telnet.h>
 #include <termios.h>
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/vty_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(LIB, VTY, "VTY");
 DEFINE_MTYPE_STATIC(LIB, VTY_SERV, "VTY server");
@@ -281,7 +284,8 @@ done:
 	return len;
 }
 
-int vty_json(struct vty *vty, struct json_object *json)
+static int vty_json_helper(struct vty *vty, struct json_object *json,
+			   uint32_t options)
 {
 	const char *text;
 
@@ -289,13 +293,25 @@ int vty_json(struct vty *vty, struct jso
 		return CMD_SUCCESS;
 
 	text = json_object_to_json_string_ext(
-		json, JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE);
+		json, options);
 	vty_out(vty, "%s\n", text);
 	json_object_free(json);
 
 	return CMD_SUCCESS;
 }
 
+int vty_json(struct vty *vty, struct json_object *json)
+{
+	return vty_json_helper(vty, json,
+			       JSON_C_TO_STRING_PRETTY |
+				       JSON_C_TO_STRING_NOSLASHESCAPE);
+}
+
+int vty_json_no_pretty(struct vty *vty, struct json_object *json)
+{
+	return vty_json_helper(vty, json, JSON_C_TO_STRING_NOSLASHESCAPE);
+}
+
 /* Output current time to the vty. */
 void vty_time_print(struct vty *vty, int cr)
 {
@@ -340,6 +356,15 @@ void vty_hello(struct vty *vty)
 		vty_out(vty, "%s", host.motd);
 }
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+/* prompt formatting has a %s in the cmd_node prompt string.
+ *
+ * Also for some reason GCC emits the warning on the end of the function
+ * (optimization maybe?) rather than on the vty_out line, so this pragma
+ * wraps the entire function rather than just the vty_out line.
+ */
+
 /* Put out prompt and wait input from user. */
 static void vty_prompt(struct vty *vty)
 {
@@ -347,6 +372,7 @@ static void vty_prompt(struct vty *vty)
 		vty_out(vty, cmd_prompt(vty->node), cmd_hostname_get());
 	}
 }
+#pragma GCC diagnostic pop
 
 /* Send WILL TELOPT_ECHO to remote server. */
 static void vty_will_echo(struct vty *vty)
@@ -461,8 +487,12 @@ static int vty_command(struct vty *vty,
 			 vty->address);
 
 		/* format the prompt */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+		/* prompt formatting has a %s in the cmd_node prompt string */
 		snprintf(prompt_str, sizeof(prompt_str), cmd_prompt(vty->node),
 			 vty_str);
+#pragma GCC diagnostic pop
 
 		/* now log the command */
 		zlog_notice("%s%s", prompt_str, buf);
diff -urpN frr-frr-8.4.2/lib/vty.h frr-frr-8.5/lib/vty.h
--- frr-frr-8.4.2/lib/vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -22,11 +22,16 @@
 #define _ZEBRA_VTY_H
 
 #include <sys/types.h>
-#ifdef HAVE_LIBPCREPOSIX
+#ifdef HAVE_LIBPCRE2_POSIX
+#ifndef _FRR_PCRE2_POSIX
+#define _FRR_PCRE2_POSIX
+#include <pcre2posix.h>
+#endif /* _FRR_PCRE2_POSIX */
+#elif defined(HAVE_LIBPCREPOSIX)
 #include <pcreposix.h>
 #else
 #include <regex.h>
-#endif /* HAVE_LIBPCREPOSIX */
+#endif /* HAVE_LIBPCRE2_POSIX */
 
 #include "thread.h"
 #include "log.h"
@@ -348,8 +353,12 @@ extern void vty_endframe(struct vty *, c
 extern bool vty_set_include(struct vty *vty, const char *regexp);
 /* returns CMD_SUCCESS so you can do a one-line "return vty_json(...)"
  * NULL check and json_object_free() is included.
+ *
+ * _no_pretty means do not add a bunch of newlines and dump the output
+ * as densely as possible.
  */
 extern int vty_json(struct vty *vty, struct json_object *json);
+extern int vty_json_no_pretty(struct vty *vty, struct json_object *json);
 
 /* post fd to be passed to the vtysh client
  * fd is owned by the VTY code after this and will be closed when done
diff -urpN frr-frr-8.4.2/lib/wheel.c frr-frr-8.5/lib/wheel.c
--- frr-frr-8.4.2/lib/wheel.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/wheel.c	2023-03-13 20:01:47.000000000 +0600
@@ -118,21 +118,6 @@ void wheel_delete(struct timer_wheel *wh
 	XFREE(MTYPE_TIMER_WHEEL, wheel);
 }
 
-int wheel_stop(struct timer_wheel *wheel)
-{
-	THREAD_OFF(wheel->timer);
-	return 0;
-}
-
-int wheel_start(struct timer_wheel *wheel)
-{
-	if (!wheel->timer)
-		thread_add_timer_msec(wheel->master, wheel_timer_thread, wheel,
-				      wheel->nexttime, &wheel->timer);
-
-	return 0;
-}
-
 int wheel_add_item(struct timer_wheel *wheel, void *item)
 {
 	long long slot;
diff -urpN frr-frr-8.4.2/lib/wheel.h frr-frr-8.5/lib/wheel.h
--- frr-frr-8.4.2/lib/wheel.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/wheel.h	2023-03-13 20:01:47.000000000 +0600
@@ -90,16 +90,6 @@ struct timer_wheel *wheel_init(struct th
 void wheel_delete(struct timer_wheel *);
 
 /*
- * Pause the Wheel from running
- */
-int wheel_stop(struct timer_wheel *wheel);
-
-/*
- * Start the wheel running again
- */
-int wheel_start(struct timer_wheel *wheel);
-
-/*
  * wheel - The Timer wheel being modified
  * item - The generic data structure that will be handed
  *        to the slot_run function.
diff -urpN frr-frr-8.4.2/lib/workqueue.c frr-frr-8.5/lib/workqueue.c
--- frr-frr-8.4.2/lib/workqueue.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/workqueue.c	2023-03-13 20:01:47.000000000 +0600
@@ -272,9 +272,6 @@ void work_queue_run(struct thread *threa
 
 		/* dont run items which are past their allowed retries */
 		if (item->ran > wq->spec.max_retries) {
-			/* run error handler, if any */
-			if (wq->spec.errorfunc)
-				wq->spec.errorfunc(wq, item);
 			work_queue_item_remove(wq, item);
 			continue;
 		}
@@ -317,10 +314,6 @@ void work_queue_run(struct thread *threa
 		case WQ_RETRY_NOW:
 		/* a RETRY_NOW that gets here has exceeded max_tries, same as
 		 * ERROR */
-		case WQ_ERROR: {
-			if (wq->spec.errorfunc)
-				wq->spec.errorfunc(wq, item);
-		}
 		/* fallthru */
 		case WQ_SUCCESS:
 		default: {
diff -urpN frr-frr-8.4.2/lib/workqueue.h frr-frr-8.5/lib/workqueue.h
--- frr-frr-8.4.2/lib/workqueue.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/workqueue.h	2023-03-13 20:01:47.000000000 +0600
@@ -41,7 +41,6 @@ DECLARE_MTYPE(WORK_QUEUE);
 /* action value, for use by item processor and item error handlers */
 typedef enum {
 	WQ_SUCCESS = 0,
-	WQ_ERROR,	 /* Error, run error handler if provided */
 	WQ_RETRY_NOW,     /* retry immediately */
 	WQ_RETRY_LATER,   /* retry later, cease processing work queue */
 	WQ_REQUEUE,       /* requeue item, continue processing work queue */
@@ -80,10 +79,6 @@ struct work_queue {
 		 */
 		wq_item_status (*workfunc)(struct work_queue *, void *);
 
-		/* error handling function, optional */
-		void (*errorfunc)(struct work_queue *,
-				  struct work_queue_item *);
-
 		/* callback to delete user specific item data */
 		void (*del_item_data)(struct work_queue *, void *);
 
diff -urpN frr-frr-8.4.2/lib/yang.h frr-frr-8.5/lib/yang.h
--- frr-frr-8.4.2/lib/yang.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/yang.h	2023-03-13 20:01:47.000000000 +0600
@@ -331,7 +331,8 @@ extern void yang_dnode_get_path(const st
  *    Schema name of the libyang data node.
  */
 extern const char *yang_dnode_get_schema_name(const struct lyd_node *dnode,
-					      const char *xpath_fmt, ...);
+					      const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
 
 /*
  * Find a libyang data node by its YANG data path.
@@ -366,7 +367,8 @@ extern struct lyd_node *yang_dnode_get(c
  *    The libyang data node if found, or NULL if not found.
  */
 extern struct lyd_node *yang_dnode_getf(const struct lyd_node *dnode,
-					const char *path_fmt, ...);
+					const char *path_fmt, ...)
+	PRINTFRR(2, 3);
 
 /*
  * Check if a libyang data node exists.
@@ -400,7 +402,7 @@ extern bool yang_dnode_exists(const stru
  *    true if a libyang data node was found, false otherwise.
  */
 extern bool yang_dnode_existsf(const struct lyd_node *dnode,
-			       const char *xpath_fmt, ...);
+			       const char *xpath_fmt, ...) PRINTFRR(2, 3);
 
 /*
  * Iterate over all libyang data nodes that satisfy an XPath query.
@@ -422,7 +424,7 @@ extern bool yang_dnode_existsf(const str
  */
 void yang_dnode_iterate(yang_dnode_iter_cb cb, void *arg,
 			const struct lyd_node *dnode, const char *xpath_fmt,
-			...);
+			...) PRINTFRR(4, 5);
 
 /*
  * Check if the libyang data node contains a default value. Non-presence
@@ -459,7 +461,7 @@ extern bool yang_dnode_is_default(const
  *    true if the data node contains the default value, false otherwise.
  */
 extern bool yang_dnode_is_defaultf(const struct lyd_node *dnode,
-				   const char *xpath_fmt, ...);
+				   const char *xpath_fmt, ...) PRINTFRR(2, 3);
 
 /*
  * Check if the libyang data node and all of its children contain default
@@ -566,7 +568,8 @@ extern struct list *yang_data_list_new(v
  *    Pointer to yang_data if found, NULL otherwise.
  */
 extern struct yang_data *yang_data_list_find(const struct list *list,
-					     const char *xpath_fmt, ...);
+					     const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
 
 /*
  * Create and set up a libyang context (for use by the translator)
diff -urpN frr-frr-8.4.2/lib/yang_translator.c frr-frr-8.5/lib/yang_translator.c
--- frr-frr-8.4.2/lib/yang_translator.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/yang_translator.c	2023-03-13 20:01:47.000000000 +0600
@@ -127,10 +127,15 @@ static void yang_mapping_add(struct yang
 	}
 }
 
+static void yang_tmodule_delete(struct yang_tmodule *tmodule)
+{
+	XFREE(MTYPE_YANG_TRANSLATOR_MODULE, tmodule);
+}
+
 struct yang_translator *yang_translator_load(const char *path)
 {
 	struct yang_translator *translator;
-	struct yang_tmodule *tmodule;
+	struct yang_tmodule *tmodule = NULL;
 	const char *family;
 	struct lyd_node *dnode;
 	struct ly_set *set;
@@ -160,6 +165,7 @@ struct yang_translator *yang_translator_
 		flog_warn(EC_LIB_YANG_TRANSLATOR_LOAD,
 			  "%s: module translator \"%s\" is loaded already",
 			  __func__, family);
+		yang_dnode_free(dnode);
 		return NULL;
 	}
 
@@ -282,15 +288,11 @@ struct yang_translator *yang_translator_
 error:
 	yang_dnode_free(dnode);
 	yang_translator_unload(translator);
+	yang_tmodule_delete(tmodule);
 
 	return NULL;
 }
 
-static void yang_tmodule_delete(struct yang_tmodule *tmodule)
-{
-	XFREE(MTYPE_YANG_TRANSLATOR_MODULE, tmodule);
-}
-
 void yang_translator_unload(struct yang_translator *translator)
 {
 	for (size_t i = 0; i < YANG_TRANSLATE_MAX; i++)
@@ -339,8 +341,12 @@ yang_translate_xpath(const struct yang_t
 	if (!mapping)
 		return YANG_TRANSLATE_NOTFOUND;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+	/* processing format strings from mapping node... */
 	n = sscanf(xpath, mapping->xpath_from_fmt, keys[0], keys[1], keys[2],
 		   keys[3]);
+#pragma GCC diagnostic pop
 	if (n < 0) {
 		flog_warn(EC_LIB_YANG_TRANSLATION_ERROR,
 			  "%s: sscanf() failed: %s", __func__,
@@ -348,8 +354,12 @@ yang_translate_xpath(const struct yang_t
 		return YANG_TRANSLATE_FAILURE;
 	}
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+	/* processing format strings from mapping node... */
 	snprintf(xpath, xpath_len, mapping->xpath_to_fmt, keys[0], keys[1],
 		 keys[2], keys[3]);
+#pragma GCC diagnostic pop
 
 	return YANG_TRANSLATE_SUCCESS;
 }
diff -urpN frr-frr-8.4.2/lib/yang_wrappers.c frr-frr-8.5/lib/yang_wrappers.c
--- frr-frr-8.4.2/lib/yang_wrappers.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/yang_wrappers.c	2023-03-13 20:01:47.000000000 +0600
@@ -58,6 +58,7 @@
 		}                                                              \
 	} while (0)
 
+PRINTFRR(2, 0)
 static inline const char *
 yang_dnode_xpath_get_canon(const struct lyd_node *dnode, const char *xpath_fmt,
 			   va_list ap)
@@ -75,6 +76,7 @@ yang_dnode_xpath_get_canon(const struct
 	return lyd_get_value(&__dleaf->node);
 }
 
+PRINTFRR(2, 0)
 static inline const struct lyd_value *
 yang_dnode_xpath_get_value(const struct lyd_node *dnode, const char *xpath_fmt,
 			   va_list ap)
diff -urpN frr-frr-8.4.2/lib/yang_wrappers.h frr-frr-8.5/lib/yang_wrappers.h
--- frr-frr-8.4.2/lib/yang_wrappers.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/yang_wrappers.h	2023-03-13 20:01:47.000000000 +0600
@@ -30,105 +30,120 @@ extern "C" {
 extern bool yang_str2bool(const char *value);
 extern struct yang_data *yang_data_new_bool(const char *xpath, bool value);
 extern bool yang_dnode_get_bool(const struct lyd_node *dnode,
-				const char *xpath_fmt, ...);
-extern bool yang_get_default_bool(const char *xpath_fmt, ...);
+				const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern bool yang_get_default_bool(const char *xpath_fmt, ...) PRINTFRR(1, 2);
 
 /* dec64 */
 extern double yang_str2dec64(const char *xpath, const char *value);
 extern struct yang_data *yang_data_new_dec64(const char *xpath, double value);
 extern double yang_dnode_get_dec64(const struct lyd_node *dnode,
-				   const char *xpath_fmt, ...);
-extern double yang_get_default_dec64(const char *xpath_fmt, ...);
+				   const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern double yang_get_default_dec64(const char *xpath_fmt, ...) PRINTFRR(1, 2);
 
 /* enum */
 extern int yang_str2enum(const char *xpath, const char *value);
 extern struct yang_data *yang_data_new_enum(const char *xpath, int value);
 extern int yang_dnode_get_enum(const struct lyd_node *dnode,
-			       const char *xpath_fmt, ...);
-extern int yang_get_default_enum(const char *xpath_fmt, ...);
+			       const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern int yang_get_default_enum(const char *xpath_fmt, ...) PRINTFRR(1, 2);
 
 /* int8 */
 extern int8_t yang_str2int8(const char *value);
 extern struct yang_data *yang_data_new_int8(const char *xpath, int8_t value);
 extern int8_t yang_dnode_get_int8(const struct lyd_node *dnode,
-				  const char *xpath_fmt, ...);
-extern int8_t yang_get_default_int8(const char *xpath_fmt, ...);
+				  const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern int8_t yang_get_default_int8(const char *xpath_fmt, ...) PRINTFRR(1, 2);
 
 /* int16 */
 extern int16_t yang_str2int16(const char *value);
 extern struct yang_data *yang_data_new_int16(const char *xpath, int16_t value);
 extern int16_t yang_dnode_get_int16(const struct lyd_node *dnode,
-				    const char *xpath_fmt, ...);
-extern int16_t yang_get_default_int16(const char *xpath_fmt, ...);
+				    const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern int16_t yang_get_default_int16(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* int32 */
 extern int32_t yang_str2int32(const char *value);
 extern struct yang_data *yang_data_new_int32(const char *xpath, int32_t value);
 extern int32_t yang_dnode_get_int32(const struct lyd_node *dnode,
-				    const char *xpath_fmt, ...);
-extern int32_t yang_get_default_int32(const char *xpath_fmt, ...);
+				    const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern int32_t yang_get_default_int32(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* int64 */
 extern int64_t yang_str2int64(const char *value);
 extern struct yang_data *yang_data_new_int64(const char *xpath, int64_t value);
 extern int64_t yang_dnode_get_int64(const struct lyd_node *dnode,
-				    const char *xpath_fmt, ...);
-extern int64_t yang_get_default_int64(const char *xpath_fmt, ...);
+				    const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern int64_t yang_get_default_int64(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* uint8 */
 extern uint8_t yang_str2uint8(const char *value);
 extern struct yang_data *yang_data_new_uint8(const char *xpath, uint8_t value);
 extern uint8_t yang_dnode_get_uint8(const struct lyd_node *dnode,
-				    const char *xpath_fmt, ...);
-extern uint8_t yang_get_default_uint8(const char *xpath_fmt, ...);
+				    const char *xpath_fmt, ...) PRINTFRR(2, 3);
+extern uint8_t yang_get_default_uint8(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* uint16 */
 extern uint16_t yang_str2uint16(const char *value);
 extern struct yang_data *yang_data_new_uint16(const char *xpath,
 					      uint16_t value);
 extern uint16_t yang_dnode_get_uint16(const struct lyd_node *dnode,
-				      const char *xpath_fmt, ...);
-extern uint16_t yang_get_default_uint16(const char *xpath_fmt, ...);
+				      const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
+extern uint16_t yang_get_default_uint16(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* uint32 */
 extern uint32_t yang_str2uint32(const char *value);
 extern struct yang_data *yang_data_new_uint32(const char *xpath,
 					      uint32_t value);
 extern uint32_t yang_dnode_get_uint32(const struct lyd_node *dnode,
-				      const char *xpath_fmt, ...);
-extern uint32_t yang_get_default_uint32(const char *xpath_fmt, ...);
+				      const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
+extern uint32_t yang_get_default_uint32(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* uint64 */
 extern uint64_t yang_str2uint64(const char *value);
 extern struct yang_data *yang_data_new_uint64(const char *xpath,
 					      uint64_t value);
 extern uint64_t yang_dnode_get_uint64(const struct lyd_node *dnode,
-				      const char *xpath_fmt, ...);
-extern uint64_t yang_get_default_uint64(const char *xpath_fmt, ...);
+				      const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
+extern uint64_t yang_get_default_uint64(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 
 /* string */
 extern struct yang_data *yang_data_new_string(const char *xpath,
 					      const char *value);
 extern const char *yang_dnode_get_string(const struct lyd_node *dnode,
-					 const char *xpath_fmt, ...);
+					 const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
 extern void yang_dnode_get_string_buf(char *buf, size_t size,
 				      const struct lyd_node *dnode,
-				      const char *xpath_fmt, ...);
-extern const char *yang_get_default_string(const char *xpath_fmt, ...);
+				      const char *xpath_fmt, ...)
+	PRINTFRR(4, 5);
+extern const char *yang_get_default_string(const char *xpath_fmt, ...)
+	PRINTFRR(1, 2);
 extern void yang_get_default_string_buf(char *buf, size_t size,
-					const char *xpath_fmt, ...);
+					const char *xpath_fmt, ...)
+	PRINTFRR(3, 4);
 
 /* binary */
 extern struct yang_data *yang_data_new_binary(const char *xpath,
 					      const char *value, size_t len);
 extern size_t yang_dnode_get_binary_buf(char *buf, size_t size,
 					const struct lyd_node *dnode,
-					const char *xpath_fmt, ...);
+					const char *xpath_fmt, ...)
+	PRINTFRR(4, 5);
 
 /* empty */
 extern struct yang_data *yang_data_new_empty(const char *xpath);
 extern bool yang_dnode_get_empty(const struct lyd_node *dnode,
-				 const char *xpath_fmt, ...);
+				 const char *xpath_fmt, ...) PRINTFRR(2, 3);
 
 /* ip prefix */
 extern void yang_str2prefix(const char *value, union prefixptr prefix);
@@ -136,9 +151,9 @@ extern struct yang_data *yang_data_new_p
 					      union prefixconstptr prefix);
 extern void yang_dnode_get_prefix(struct prefix *prefix,
 				  const struct lyd_node *dnode,
-				  const char *xpath_fmt, ...);
+				  const char *xpath_fmt, ...) PRINTFRR(3, 4);
 extern void yang_get_default_prefix(union prefixptr var, const char *xpath_fmt,
-				    ...);
+				    ...) PRINTFRR(2, 3);
 
 /* ipv4 */
 extern void yang_str2ipv4(const char *value, struct in_addr *addr);
@@ -146,9 +161,9 @@ extern struct yang_data *yang_data_new_i
 					    const struct in_addr *addr);
 extern void yang_dnode_get_ipv4(struct in_addr *addr,
 				const struct lyd_node *dnode,
-				const char *xpath_fmt, ...);
+				const char *xpath_fmt, ...) PRINTFRR(3, 4);
 extern void yang_get_default_ipv4(struct in_addr *var, const char *xpath_fmt,
-				  ...);
+				  ...) PRINTFRR(2, 3);
 
 /* ipv4p */
 extern void yang_str2ipv4p(const char *value, union prefixptr prefix);
@@ -156,9 +171,9 @@ extern struct yang_data *yang_data_new_i
 					     union prefixconstptr prefix);
 extern void yang_dnode_get_ipv4p(union prefixptr prefix,
 				 const struct lyd_node *dnode,
-				 const char *xpath_fmt, ...);
+				 const char *xpath_fmt, ...) PRINTFRR(3, 4);
 extern void yang_get_default_ipv4p(union prefixptr var, const char *xpath_fmt,
-				   ...);
+				   ...) PRINTFRR(2, 3);
 
 /* ipv6 */
 extern void yang_str2ipv6(const char *value, struct in6_addr *addr);
@@ -166,9 +181,9 @@ extern struct yang_data *yang_data_new_i
 					    const struct in6_addr *addr);
 extern void yang_dnode_get_ipv6(struct in6_addr *addr,
 				const struct lyd_node *dnode,
-				const char *xpath_fmt, ...);
+				const char *xpath_fmt, ...) PRINTFRR(3, 4);
 extern void yang_get_default_ipv6(struct in6_addr *var, const char *xpath_fmt,
-				  ...);
+				  ...) PRINTFRR(2, 3);
 
 /* ipv6p */
 extern void yang_str2ipv6p(const char *value, union prefixptr prefix);
@@ -176,17 +191,18 @@ extern struct yang_data *yang_data_new_i
 					     union prefixconstptr prefix);
 extern void yang_dnode_get_ipv6p(union prefixptr prefix,
 				 const struct lyd_node *dnode,
-				 const char *xpath_fmt, ...);
+				 const char *xpath_fmt, ...) PRINTFRR(3, 4);
 extern void yang_get_default_ipv6p(union prefixptr var, const char *xpath_fmt,
-				   ...);
+				   ...) PRINTFRR(2, 3);
 
 /* ip */
 extern void yang_str2ip(const char *value, struct ipaddr *addr);
 extern struct yang_data *yang_data_new_ip(const char *xpath,
 					  const struct ipaddr *addr);
 extern void yang_dnode_get_ip(struct ipaddr *addr, const struct lyd_node *dnode,
-			      const char *xpath_fmt, ...);
-extern void yang_get_default_ip(struct ipaddr *var, const char *xpath_fmt, ...);
+			      const char *xpath_fmt, ...) PRINTFRR(3, 4);
+extern void yang_get_default_ip(struct ipaddr *var, const char *xpath_fmt, ...)
+	PRINTFRR(2, 3);
 
 /* mac */
 extern struct yang_data *yang_data_new_mac(const char *xpath,
diff -urpN frr-frr-8.4.2/lib/zclient.c frr-frr-8.5/lib/zclient.c
--- frr-frr-8.4.2/lib/zclient.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zclient.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@
 #include "mpls.h"
 #include "sockopt.h"
 #include "pbr.h"
+#include "tc.h"
 #include "nexthop_group.h"
 #include "lib_errors.h"
 #include "srte.h"
@@ -1088,6 +1089,7 @@ int zapi_srv6_locator_chunk_encode(struc
 	stream_putc(s, c->node_bits_length);
 	stream_putc(s, c->function_bits_length);
 	stream_putc(s, c->argument_bits_length);
+	stream_putc(s, c->flags);
 	return 0;
 }
 
@@ -1109,6 +1111,7 @@ int zapi_srv6_locator_chunk_decode(struc
 	STREAM_GETC(s, c->node_bits_length);
 	STREAM_GETC(s, c->function_bits_length);
 	STREAM_GETC(s, c->argument_bits_length);
+	STREAM_GETC(s, c->flags);
 	return 0;
 
 stream_failure:
@@ -1166,6 +1169,10 @@ static int zapi_nhg_encode(struct stream
 	stream_putw(s, api_nhg->proto);
 	stream_putl(s, api_nhg->id);
 
+	stream_putw(s, api_nhg->resilience.buckets);
+	stream_putl(s, api_nhg->resilience.idle_timer);
+	stream_putl(s, api_nhg->resilience.unbalanced_timer);
+
 	if (cmd == ZEBRA_NHG_ADD) {
 		/* Nexthops */
 		zapi_nexthop_group_sort(api_nhg->nexthops,
@@ -1643,6 +1650,96 @@ int zapi_pbr_rule_encode(uint8_t cmd, st
 	return 0;
 }
 
+int zapi_tc_qdisc_encode(uint8_t cmd, struct stream *s, struct tc_qdisc *qdisc)
+{
+	stream_reset(s);
+	zclient_create_header(s, cmd, VRF_DEFAULT);
+
+
+	stream_putl(s, 1);
+
+	stream_putl(s, qdisc->ifindex);
+	stream_putl(s, qdisc->kind);
+
+	stream_putw_at(s, 0, stream_get_endp(s));
+
+	return 0;
+}
+
+int zapi_tc_class_encode(uint8_t cmd, struct stream *s, struct tc_class *class)
+{
+	stream_reset(s);
+	zclient_create_header(s, cmd, VRF_DEFAULT);
+
+	stream_putl(s, 1);
+
+	stream_putl(s, class->ifindex);
+	stream_putl(s, class->handle);
+	stream_putl(s, class->kind);
+
+	switch (class->kind) {
+	case TC_QDISC_HTB:
+		stream_putq(s, class->u.htb.rate);
+		stream_putq(s, class->u.htb.ceil);
+		break;
+	default:
+		/* not implemented */
+		break;
+	}
+	stream_putw_at(s, 0, stream_get_endp(s));
+
+	return 0;
+}
+
+int zapi_tc_filter_encode(uint8_t cmd, struct stream *s,
+			  struct tc_filter *filter)
+{
+	stream_reset(s);
+	zclient_create_header(s, cmd, VRF_DEFAULT);
+
+	stream_putl(s, 1);
+
+	stream_putl(s, filter->ifindex);
+	stream_putl(s, filter->handle);
+	stream_putl(s, filter->priority);
+	stream_putl(s, filter->protocol);
+	stream_putl(s, filter->kind);
+
+	switch (filter->kind) {
+	case TC_FILTER_FLOWER:
+		stream_putl(s, filter->u.flower.filter_bm);
+		if (filter->u.flower.filter_bm & TC_FLOWER_IP_PROTOCOL)
+			stream_putc(s, filter->u.flower.ip_proto);
+		if (filter->u.flower.filter_bm & TC_FLOWER_SRC_IP)
+			zapi_encode_prefix(s, &filter->u.flower.src_ip,
+					   filter->u.flower.src_ip.family);
+		if (filter->u.flower.filter_bm & TC_FLOWER_SRC_PORT) {
+			stream_putw(s, filter->u.flower.src_port_min);
+			stream_putw(s, filter->u.flower.src_port_max);
+		}
+		if (filter->u.flower.filter_bm & TC_FLOWER_DST_IP)
+			zapi_encode_prefix(s, &filter->u.flower.dst_ip,
+					   filter->u.flower.dst_ip.family);
+		if (filter->u.flower.filter_bm & TC_FLOWER_DST_PORT) {
+			stream_putw(s, filter->u.flower.dst_port_min);
+			stream_putw(s, filter->u.flower.dst_port_max);
+		}
+		if (filter->u.flower.filter_bm & TC_FLOWER_DSFIELD) {
+			stream_putc(s, filter->u.flower.dsfield);
+			stream_putc(s, filter->u.flower.dsfield_mask);
+		}
+		stream_putl(s, filter->u.flower.classid);
+		break;
+	default:
+		/* not implemented */
+		break;
+	}
+
+	stream_putw_at(s, 0, stream_get_endp(s));
+
+	return 0;
+}
+
 bool zapi_nhg_notify_decode(struct stream *s, uint32_t *id,
 			    enum zapi_nhg_notify_owner *note)
 {
@@ -2299,13 +2396,22 @@ static int zclient_handle_error(ZAPI_CAL
 	return 0;
 }
 
-static int link_params_set_value(struct stream *s, struct if_link_params *iflp)
+static int link_params_set_value(struct stream *s, struct interface *ifp)
 {
+	uint8_t link_params_enabled;
+	struct if_link_params *iflp;
+	uint32_t bwclassnum;
+
+	iflp = if_link_params_get(ifp);
 
 	if (iflp == NULL)
-		return -1;
+		iflp = if_link_params_init(ifp);
 
-	uint32_t bwclassnum;
+	STREAM_GETC(s, link_params_enabled);
+	if (!link_params_enabled) {
+		if_link_params_free(ifp);
+		return 0;
+	}
 
 	STREAM_GETL(s, iflp->lp_status);
 	STREAM_GETL(s, iflp->te_metric);
@@ -2346,9 +2452,9 @@ struct interface *zebra_interface_link_p
 						   bool *changed)
 {
 	struct if_link_params *iflp;
-	struct if_link_params iflp_copy;
+	struct if_link_params iflp_prev;
 	ifindex_t ifindex;
-	bool params_changed = false;
+	bool iflp_prev_set;
 
 	STREAM_GETL(s, ifindex);
 
@@ -2361,22 +2467,33 @@ struct interface *zebra_interface_link_p
 		return NULL;
 	}
 
-	if (ifp->link_params == NULL)
-		params_changed = true;
-
-	if ((iflp = if_link_params_get(ifp)) == NULL)
-		return NULL;
-
-	memcpy(&iflp_copy, iflp, sizeof(iflp_copy));
-
-	if (link_params_set_value(s, iflp) != 0)
+	if (if_link_params_get(ifp)) {
+		iflp_prev_set = true;
+		memcpy(&iflp_prev, ifp->link_params, sizeof(iflp_prev));
+	} else
+		iflp_prev_set = false;
+
+	/* read the link_params from stream
+	 * Free ifp->link_params if the stream has no params
+	 * to means that link-params are not enabled on links.
+	 */
+	if (link_params_set_value(s, ifp) != 0)
 		goto stream_failure;
 
-	if (memcmp(&iflp_copy, iflp, sizeof(iflp_copy)))
-		params_changed = true;
+	if (changed == NULL)
+		return ifp;
 
-	if (changed)
-		*changed = params_changed;
+	iflp = if_link_params_get(ifp);
+
+	if (iflp_prev_set && iflp) {
+		if (memcmp(&iflp_prev, iflp, sizeof(iflp_prev)))
+			*changed = true;
+		else
+			*changed = false;
+	} else if (!iflp_prev_set && !iflp)
+		*changed = false;
+	else
+		*changed = true;
 
 	return ifp;
 
@@ -2415,10 +2532,8 @@ static void zebra_interface_if_set_value
 	/* Read Traffic Engineering status */
 	link_params_status = stream_getc(s);
 	/* Then, Traffic Engineering parameters if any */
-	if (link_params_status) {
-		struct if_link_params *iflp = if_link_params_get(ifp);
-		link_params_set_value(s, iflp);
-	}
+	if (link_params_status)
+		link_params_set_value(s, ifp);
 
 	nexthop_group_interface_state_change(ifp, old_ifindex);
 
@@ -2435,12 +2550,20 @@ size_t zebra_interface_link_params_write
 	struct if_link_params *iflp;
 	int i;
 
-	if (s == NULL || ifp == NULL || ifp->link_params == NULL)
+	if (s == NULL || ifp == NULL)
 		return 0;
 
 	iflp = ifp->link_params;
 	w = 0;
 
+	/* encode if link_params is enabled */
+	if (iflp) {
+		w += stream_putc(s, true);
+	} else {
+		w += stream_putc(s, false);
+		return w;
+	}
+
 	w += stream_putl(s, iflp->lp_status);
 
 	w += stream_putl(s, iflp->te_metric);
diff -urpN frr-frr-8.4.2/lib/zclient.h frr-frr-8.5/lib/zclient.h
--- frr-frr-8.4.2/lib/zclient.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zclient.h	2023-03-13 20:01:47.000000000 +0600
@@ -35,6 +35,8 @@ struct zclient;
 
 /* For union g_addr */
 #include "nexthop.h"
+/* For resilience */
+#include "nexthop_group.h"
 
 /* For union pw_protocol_fields */
 #include "pw.h"
@@ -239,6 +241,12 @@ typedef enum {
 	ZEBRA_GRE_GET,
 	ZEBRA_GRE_UPDATE,
 	ZEBRA_GRE_SOURCE_SET,
+	ZEBRA_TC_QDISC_INSTALL,
+	ZEBRA_TC_QDISC_UNINSTALL,
+	ZEBRA_TC_CLASS_ADD,
+	ZEBRA_TC_CLASS_DELETE,
+	ZEBRA_TC_FILTER_ADD,
+	ZEBRA_TC_FILTER_DELETE,
 } zebra_message_types_t;
 
 enum zebra_error_types {
@@ -461,6 +469,8 @@ struct zapi_nhg {
 	uint16_t proto;
 	uint32_t id;
 
+	struct nhg_resilience resilience;
+
 	uint16_t nexthop_num;
 	struct zapi_nexthop nexthops[MULTIPATH_NUM];
 
@@ -538,6 +548,13 @@ struct zapi_route {
  */
 #define ZEBRA_FLAG_OFFLOAD_FAILED     0x200
 
+/*
+ * This flag lets us know that we think the route entry
+ * received has caused us to be out of sync with the
+ * kernel (NLM_F_APPEND at the very least )
+ */
+#define ZEBRA_FLAG_OUTOFSYNC          0x400
+
 	/* The older XXX_MESSAGE flags live here */
 	uint32_t message;
 
diff -urpN frr-frr-8.4.2/lib/zebra.h frr-frr-8.5/lib/zebra.h
--- frr-frr-8.4.2/lib/zebra.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zebra.h	2023-03-13 20:01:47.000000000 +0600
@@ -202,9 +202,9 @@
 #endif /* HAVE_GLIBC_BACKTRACE */
 
 /* Local includes: */
-#if !(defined(__GNUC__) || defined(VTYSH_EXTRACT_PL))
+#if !defined(__GNUC__)
 #define __attribute__(x)
-#endif /* !__GNUC__ || VTYSH_EXTRACT_PL */
+#endif /* !__GNUC__ */
 
 #include <assert.h>
 
diff -urpN frr-frr-8.4.2/lib/zlog.c frr-frr-8.5/lib/zlog.c
--- frr-frr-8.4.2/lib/zlog.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zlog.c	2023-03-13 20:01:47.000000000 +0600
@@ -743,7 +743,11 @@ const char *zlog_msg_text(struct zlog_ms
 		fb.outpos_i = 0;
 
 		va_copy(args, msg->args);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+		/* format-string checking is done further up the chain */
 		need += vbprintfrr(&fb, msg->fmt, args);
+#pragma GCC diagnostic pop
 		va_end(args);
 
 		msg->textlen = need;
@@ -762,7 +766,11 @@ const char *zlog_msg_text(struct zlog_ms
 			fb.outpos_i = 0;
 
 			va_copy(args, msg->args);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+			/* same as above */
 			vbprintfrr(&fb, msg->fmt, args);
+#pragma GCC diagnostic pop
 			va_end(args);
 
 			bputch(&fb, '\n');
diff -urpN frr-frr-8.4.2/lib/zlog.h frr-frr-8.5/lib/zlog.h
--- frr-frr-8.4.2/lib/zlog.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zlog.h	2023-03-13 20:01:47.000000000 +0600
@@ -71,8 +71,8 @@ struct xrefdata_logmsg {
  * determine whether something is a log message or something else.
  */
 
-extern void vzlogx(const struct xref_logmsg *xref, int prio,
-		   const char *fmt, va_list ap);
+extern void vzlogx(const struct xref_logmsg *xref, int prio, const char *fmt,
+		   va_list ap) PRINTFRR(3, 0);
 #define vzlog(prio, ...) vzlogx(NULL, prio, __VA_ARGS__)
 
 PRINTFRR(2, 3)
diff -urpN frr-frr-8.4.2/lib/zlog_5424.c frr-frr-8.5/lib/zlog_5424.c
--- frr-frr-8.4.2/lib/zlog_5424.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zlog_5424.c	2023-03-13 20:01:47.000000000 +0600
@@ -605,12 +605,13 @@ static void gmtime_assafe(time_t ts, str
 	if (ts >= 306) /* Jan 1 of next year */
 		res->tm_year++;
 
-	static unsigned int months[13] = {
+	static time_t months[13] = {
 		0, 31, 61, 92, 122, 153, 184, 214, 245, 275, 306, 337, 365,
 	};
+	const size_t month_max = array_size(months) - 1;
 
-	for (size_t i = 0; i < array_size(months); i++) {
-		if ((unsigned int)ts < months[i + 1]) {
+	for (size_t i = 0; i < month_max; i++) {
+		if (ts < months[i + 1]) {
 			res->tm_mon = ((i + 2) % 12);
 			res->tm_mday = 1 + ts - months[i];
 			break;
diff -urpN frr-frr-8.4.2/lib/zlog_5424_cli.c frr-frr-8.5/lib/zlog_5424_cli.c
--- frr-frr-8.4.2/lib/zlog_5424_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zlog_5424_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -158,9 +158,7 @@ static int reconf_clear_dst(struct zlog_
 	return reconf_dst(cfg, vty);
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "lib/zlog_5424_cli_clippy.c"
-#endif
 
 DEFPY_NOSH(log_5424_target,
 	   log_5424_target_cmd,
diff -urpN frr-frr-8.4.2/lib/zlog_targets.c frr-frr-8.5/lib/zlog_targets.c
--- frr-frr-8.4.2/lib/zlog_targets.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/lib/zlog_targets.c	2023-03-13 20:01:47.000000000 +0600
@@ -257,6 +257,7 @@ bool zlog_file_set_filename(struct zlog_
 		return zlog_file_cycle(zcf);
 	}
 	assert(0);
+	return false;
 }
 
 bool zlog_file_set_fd(struct zlog_cfg_file *zcf, int fd)
@@ -271,6 +272,7 @@ bool zlog_file_set_fd(struct zlog_cfg_fi
 		return zlog_file_cycle(zcf);
 	}
 	assert(0);
+	return false;
 }
 
 struct rcu_close_rotate {
@@ -544,6 +546,7 @@ int zlog_syslog_get_facility(void)
 		return syslog_facility;
 	}
 	assert(0);
+	return 0;
 }
 
 void zlog_syslog_set_prio_min(int prio_min)
@@ -581,4 +584,5 @@ int zlog_syslog_get_prio_min(void)
 		return syslog_prio_min;
 	}
 	assert(0);
+	return 0;
 }
diff -urpN frr-frr-8.4.2/m4/ax_python.m4 frr-frr-8.5/m4/ax_python.m4
--- frr-frr-8.4.2/m4/ax_python.m4	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/m4/ax_python.m4	2023-03-13 20:01:47.000000000 +0600
@@ -206,7 +206,7 @@ AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
     AC_MSG_CHECKING([whether pkg-config python-${tryver} is available])
     unset PYTHON_CFLAGS
     unset PYTHON_LIBS
-    pkg="python-${tryver}"
+    pkg="python-${tryver}-embed"
     pkg="${pkg%-}"
     _PKG_CONFIG([PYTHON_CFLAGS], [cflags], [${pkg}])
     _PKG_CONFIG([PYTHON_LIBS], [libs], [${pkg}])
diff -urpN frr-frr-8.4.2/nhrpd/nhrp_vty.c frr-frr-8.5/nhrpd/nhrp_vty.c
--- frr-frr-8.4.2/nhrpd/nhrp_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/nhrpd/nhrp_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -126,6 +126,8 @@ DEFUN_NOSH(show_debugging_nhrp, show_deb
 			debug_flags_desc[i].str);
 	}
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/nhrpd/subdir.am frr-frr-8.5/nhrpd/subdir.am
--- frr-frr-8.4.2/nhrpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/nhrpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,7 +4,6 @@
 
 if NHRPD
 sbin_PROGRAMS += nhrpd/nhrpd
-vtysh_scan += nhrpd/nhrp_vty.c
 vtysh_daemons += nhrpd
 man8 += $(MANBUILD)/frr-nhrpd.8
 endif
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_abr.c frr-frr-8.5/ospf6d/ospf6_abr.c
--- frr-frr-8.4.2/ospf6d/ospf6_abr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_abr.c	2023-03-13 20:01:47.000000000 +0600
@@ -1322,7 +1322,7 @@ void ospf6_abr_examin_summary(struct osp
 			ospf6_copy_nexthops(tmp_route->nh_list,
 					    o_path->nh_list);
 
-			if (ospf6_route_cmp_nexthops(tmp_route, route) != 0) {
+			if (!ospf6_route_cmp_nexthops(tmp_route, route)) {
 				/* adv. router exists in the list, update nhs */
 				list_delete_all_node(o_path->nh_list);
 				ospf6_copy_nexthops(o_path->nh_list,
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_area.c frr-frr-8.5/ospf6d/ospf6_area.c
--- frr-frr-8.4.2/ospf6d/ospf6_area.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_area.c	2023-03-13 20:01:47.000000000 +0600
@@ -49,9 +49,7 @@
 #include "ospf6d.h"
 #include "lib/json.h"
 #include "ospf6_nssa.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_area_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_AREA,      "OSPF6 area");
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_PLISTNAME, "Prefix list name");
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_asbr.c frr-frr-8.5/ospf6d/ospf6_asbr.c
--- frr-frr-8.4.2/ospf6d/ospf6_asbr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_asbr.c	2023-03-13 20:01:47.000000000 +0600
@@ -65,9 +65,7 @@ static void ospf6_asbr_redistribute_set(
 static void ospf6_asbr_redistribute_unset(struct ospf6 *ospf6,
 					  struct ospf6_redist *red, int type);
 
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_asbr_clippy.c"
-#endif
 
 unsigned char conf_debug_ospf6_asbr = 0;
 
@@ -1587,7 +1585,11 @@ ospf6_asbr_summary_remove_lsa_and_route(
 			zlog_debug(
 				"%s: Remove the blackhole route",
 				__func__);
+
 		ospf6_zebra_route_update_remove(aggr->route, ospf6);
+		if (aggr->route->route_option)
+			XFREE(MTYPE_OSPF6_EXTERNAL_INFO,
+			      aggr->route->route_option);
 		ospf6_route_delete(aggr->route);
 		aggr->route = NULL;
 	}
@@ -2206,10 +2208,10 @@ static const struct route_map_rule_cmd o
 /* add "set metric-type" */
 DEFUN_YANG (ospf6_routemap_set_metric_type, ospf6_routemap_set_metric_type_cmd,
       "set metric-type <type-1|type-2>",
-      "Set value\n"
-      "Type of metric\n"
-      "OSPF6 external type 1 metric\n"
-      "OSPF6 external type 2 metric\n")
+       SET_STR
+       "Type of metric for destination routing protocol\n"
+       "OSPF[6] external type 1 metric\n"
+       "OSPF[6] external type 2 metric\n")
 {
 	char *ext = argv[2]->text;
 
@@ -2228,10 +2230,10 @@ DEFUN_YANG (ospf6_routemap_set_metric_ty
 DEFUN_YANG (ospf6_routemap_no_set_metric_type, ospf6_routemap_no_set_metric_type_cmd,
       "no set metric-type [<type-1|type-2>]",
       NO_STR
-      "Set value\n"
-      "Type of metric\n"
-      "OSPF6 external type 1 metric\n"
-      "OSPF6 external type 2 metric\n")
+      SET_STR
+      "Type of metric for destination routing protocol\n"
+      "OSPF[6] external type 1 metric\n"
+      "OSPF[6] external type 2 metric\n")
 {
 	const char *xpath =
 		"./set-action[action='frr-ospf-route-map:metric-type']";
@@ -2738,8 +2740,13 @@ ospf6_summary_add_aggr_route_and_blackho
 					   struct ospf6_external_aggr_rt *aggr)
 {
 	struct ospf6_route *rt_aggr;
+	struct ospf6_route *old_rt = NULL;
 	struct ospf6_external_info *info;
 
+	/* Check if a route is already present. */
+	if (aggr->route)
+		old_rt = aggr->route;
+
 	/* Create summary route and save it. */
 	rt_aggr = ospf6_route_create(ospf6);
 	rt_aggr->type = OSPF6_DEST_TYPE_NETWORK;
@@ -2758,6 +2765,16 @@ ospf6_summary_add_aggr_route_and_blackho
 	/* Add next-hop to Null interface. */
 	ospf6_add_route_nexthop_blackhole(rt_aggr);
 
+	/* Free the old route, if any. */
+	if (old_rt) {
+		ospf6_zebra_route_update_remove(old_rt, ospf6);
+
+		if (old_rt->route_option)
+			XFREE(MTYPE_OSPF6_EXTERNAL_INFO, old_rt->route_option);
+
+		ospf6_route_delete(old_rt);
+	}
+
 	ospf6_zebra_route_update_add(rt_aggr, ospf6);
 }
 
@@ -3026,8 +3043,8 @@ static void ospf6_aggr_handle_external_i
 	(void)ospf6_originate_type5_type7_lsas(rt, ospf6);
 }
 
-static void
-ospf6_asbr_summary_config_delete(struct ospf6 *ospf6, struct route_node *rn)
+void ospf6_asbr_summary_config_delete(struct ospf6 *ospf6,
+				      struct route_node *rn)
 {
 	struct ospf6_external_aggr_rt *aggr = rn->info;
 
@@ -3169,14 +3186,6 @@ void ospf6_external_aggregator_free(stru
 		hash_clean(aggr->match_extnl_hash,
 			ospf6_aggr_unlink_external_info);
 
-	if (aggr->route) {
-		if (aggr->route->route_option)
-			XFREE(MTYPE_OSPF6_EXTERNAL_INFO,
-			      aggr->route->route_option);
-
-		ospf6_route_delete(aggr->route);
-	}
-
 	if (IS_OSPF6_DEBUG_AGGR)
 		zlog_debug("%s: Release the aggregator Address(%pFX)",
 						__func__,
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_asbr.h frr-frr-8.5/ospf6d/ospf6_asbr.h
--- frr-frr-8.4.2/ospf6d/ospf6_asbr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_asbr.h	2023-03-13 20:01:47.000000000 +0600
@@ -182,4 +182,6 @@ void ospf6_external_aggregator_free(stru
 void ospf6_unset_all_aggr_flag(struct ospf6 *ospf6);
 void ospf6_fill_aggr_route_details(struct ospf6 *ospf6,
 				   struct ospf6_external_aggr_rt *aggr);
+void ospf6_asbr_summary_config_delete(struct ospf6 *ospf6,
+				      struct route_node *rn);
 #endif /* OSPF6_ASBR_H */
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_gr.c frr-frr-8.5/ospf6d/ospf6_gr.c
--- frr-frr-8.4.2/ospf6d/ospf6_gr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_gr.c	2023-03-13 20:01:47.000000000 +0600
@@ -42,9 +42,7 @@
 #include "ospf6d/ospf6_intra.h"
 #include "ospf6d/ospf6_spf.h"
 #include "ospf6d/ospf6_gr.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_gr_clippy.c"
-#endif
 
 static void ospf6_gr_nvm_delete(struct ospf6 *ospf6);
 
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_gr_helper.c frr-frr-8.5/ospf6d/ospf6_gr_helper.c
--- frr-frr-8.4.2/ospf6d/ospf6_gr_helper.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_gr_helper.c	2023-03-13 20:01:47.000000000 +0600
@@ -49,9 +49,7 @@
 #include "ospf6d.h"
 #include "ospf6_gr.h"
 #include "lib/json.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_gr_helper_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_GR_HELPER, "OSPF6 Graceful restart helper");
 
@@ -965,22 +963,18 @@ static void show_ospf6_gr_helper_details
 			json, "supportedGracePeriod",
 			ospf6->ospf6_helper_cfg.supported_grace_time);
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
 		if (ospf6->ospf6_helper_cfg.last_exit_reason !=
-		    OSPF6_GR_HELPER_EXIT_NONE) {
-			json_object_string_add(
-				json, "LastExitReason",
-				ospf6_exit_reason_desc
-					[ospf6->ospf6_helper_cfg
-						 .last_exit_reason]);
+		    OSPF6_GR_HELPER_EXIT_NONE)
 			json_object_string_add(
 				json, "lastExitReason",
 				ospf6_exit_reason_desc
 					[ospf6->ospf6_helper_cfg
 						 .last_exit_reason]);
-		}
+
+		if (ospf6->ospf6_helper_cfg.active_restarter_cnt)
+			json_object_int_add(
+				json, "activeRestarterCnt",
+				ospf6->ospf6_helper_cfg.active_restarter_cnt);
 
 		if (OSPF6_HELPER_ENABLE_RTR_COUNT(ospf6)) {
 			struct json_object *json_rid_array =
@@ -1007,18 +1001,12 @@ CPP_NOTICE("Remove JSON object commands
 
 				if (uj) {
 					json_object_object_get_ex(
-						json, "Neighbors",
-						&json_neighbors);
-					json_object_object_get_ex(
 						json, "neighbors",
 						&json_neighbors);
 					if (!json_neighbors) {
 						json_neighbors =
 						json_object_new_object();
 						json_object_object_add(
-							json, "Neighbors",
-							json_neighbors);
-						json_object_object_add(
 							json, "neighbors",
 							json_neighbors);
 					}
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_interface.c frr-frr-8.5/ospf6d/ospf6_interface.c
--- frr-frr-8.4.2/ospf6d/ospf6_interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@
 #include "ospf6_route.h"
 #include "ospf6_area.h"
 #include "ospf6_abr.h"
+#include "ospf6_nssa.h"
 #include "ospf6_interface.h"
 #include "ospf6_neighbor.h"
 #include "ospf6_intra.h"
@@ -302,6 +303,9 @@ void ospf6_interface_delete(struct ospf6
 	/* disable from area list if possible */
 	ospf6_area_interface_delete(oi);
 
+	if (oi->at_data.auth_key)
+		XFREE(MTYPE_OSPF6_AUTH_MANUAL_KEY, oi->at_data.auth_key);
+
 	/* Free BFD allocated data. */
 	XFREE(MTYPE_TMP, oi->bfd_config.profile);
 
@@ -1116,14 +1120,21 @@ static int ospf6_interface_show(struct v
 				    oi->dead_interval);
 		json_object_int_add(json_obj, "timerIntervalsConfigRetransmit",
 				    oi->rxmt_interval);
+		json_object_boolean_add(
+			json_obj, "timerPassiveIface",
+			!!CHECK_FLAG(oi->flag, OSPF6_INTERFACE_PASSIVE));
 	} else {
 		vty_out(vty, "  State %s, Transmit Delay %d sec, Priority %d\n",
 			ospf6_interface_state_str[oi->state], oi->transdelay,
 			oi->priority);
 		vty_out(vty, "  Timer intervals configured:\n");
-		vty_out(vty, "   Hello %d(%pTHd), Dead %d, Retransmit %d\n",
-			oi->hello_interval, oi->thread_send_hello,
-			oi->dead_interval, oi->rxmt_interval);
+		if (!CHECK_FLAG(oi->flag, OSPF6_INTERFACE_PASSIVE))
+			vty_out(vty,
+				"   Hello %d(%pTHd), Dead %d, Retransmit %d\n",
+				oi->hello_interval, oi->thread_send_hello,
+				oi->dead_interval, oi->rxmt_interval);
+		else
+			vty_out(vty, "   No Hellos (Passive interface)\n");
 	}
 
 	inet_ntop(AF_INET, &oi->drouter, drouter, sizeof(drouter));
@@ -1737,8 +1748,10 @@ void ospf6_interface_start(struct ospf6_
 	ospf6_interface_enable(oi);
 
 	/* If the router is ABR, originate summary routes */
-	if (ospf6_check_and_set_router_abr(ospf6))
+	if (ospf6_check_and_set_router_abr(ospf6)) {
 		ospf6_abr_enable_area(oa);
+		ospf6_schedule_abr_task(ospf6);
+	}
 }
 
 void ospf6_interface_stop(struct ospf6_interface *oi)
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_lsa.c frr-frr-8.5/ospf6d/ospf6_lsa.c
--- frr-frr-8.4.2/ospf6d/ospf6_lsa.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_lsa.c	2023-03-13 20:01:47.000000000 +0600
@@ -46,9 +46,7 @@
 #include "ospf6_flood.h"
 #include "ospf6d.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_lsa_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_LSA,         "OSPF6 LSA");
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_LSA_HEADER,  "OSPF6 LSA header");
@@ -85,11 +83,7 @@ static int ospf6_unknown_lsa_show(struct
 	start = (uint8_t *)lsa->header + sizeof(struct ospf6_lsa_header);
 	end = (uint8_t *)lsa->header + ntohs(lsa->header->length);
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
 	if (use_json) {
-		json_object_string_add(json_obj, "LsaType", "unknown");
 		json_object_string_add(json_obj, "lsaType", "unknown");
 	} else {
 		vty_out(vty, "        Unknown contents:\n");
@@ -575,7 +569,7 @@ void ospf6_lsa_show_dump(struct vty *vty
 		json = json_object_new_object();
 		size_t header_str_sz = (2 * (end - start)) + 1;
 
-		header_str = XMALLOC(MTYPE_TMP, header_str_sz);
+		header_str = XMALLOC(MTYPE_OSPF6_LSA_HEADER, header_str_sz);
 
 		inet_ntop(AF_INET, &lsa->header->id, id, sizeof(id));
 		inet_ntop(AF_INET, &lsa->header->adv_router, adv_router,
@@ -588,7 +582,7 @@ void ospf6_lsa_show_dump(struct vty *vty
 		json_object_string_add(json, "header", header_str);
 		json_object_array_add(json_array, json);
 
-		XFREE(MTYPE_TMP, header_str);
+		XFREE(MTYPE_OSPF6_LSA_HEADER, header_str);
 	} else {
 		vty_out(vty, "\n%s:\n", lsa->name);
 
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_message.c frr-frr-8.5/ospf6d/ospf6_message.c
--- frr-frr-8.4.2/ospf6d/ospf6_message.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_message.c	2023-03-13 20:01:47.000000000 +0600
@@ -28,6 +28,7 @@
 #include "linklist.h"
 #include "lib_errors.h"
 #include "checksum.h"
+#include "network.h"
 
 #include "ospf6_proto.h"
 #include "ospf6_lsa.h"
@@ -2015,6 +2016,9 @@ static void ospf6_auth_trailer_copy_keyc
 			 * these values
 			 */
 			oi->at_data.hash_algo = key->hash_algo;
+			if (oi->at_data.auth_key)
+				XFREE(MTYPE_OSPF6_AUTH_MANUAL_KEY,
+				      oi->at_data.auth_key);
 			oi->at_data.auth_key = XSTRDUP(
 				MTYPE_OSPF6_AUTH_MANUAL_KEY, key->string);
 			oi->at_data.key_id = key->index;
@@ -2297,7 +2301,7 @@ static uint16_t ospf6_make_dbdesc(struct
 	/* if this is initial one, initialize sequence number for DbDesc */
 	if (CHECK_FLAG(on->dbdesc_bits, OSPF6_DBDESC_IBIT)
 	    && (on->dbdesc_seqnum == 0)) {
-		on->dbdesc_seqnum = monotime(NULL);
+		on->dbdesc_seqnum = frr_sequence32_next();
 	}
 
 	/* reserved */
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_neighbor.c frr-frr-8.5/ospf6d/ospf6_neighbor.c
--- frr-frr-8.4.2/ospf6d/ospf6_neighbor.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_neighbor.c	2023-03-13 20:01:47.000000000 +0600
@@ -106,6 +106,23 @@ struct ospf6_neighbor *ospf6_area_neighb
 	return NULL;
 }
 
+static void ospf6_neighbor_clear_ls_lists(struct ospf6_neighbor *on)
+{
+	struct ospf6_lsa *lsa;
+	struct ospf6_lsa *lsanext;
+
+	ospf6_lsdb_remove_all(on->summary_list);
+	if (on->last_ls_req) {
+		ospf6_lsa_unlock(on->last_ls_req);
+		on->last_ls_req = NULL;
+	}
+	ospf6_lsdb_remove_all(on->request_list);
+	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
+		ospf6_decrement_retrans_count(lsa);
+		ospf6_lsdb_remove(lsa, on->retrans_list);
+	}
+}
+
 /* create ospf6_neighbor */
 struct ospf6_neighbor *ospf6_neighbor_create(uint32_t router_id,
 					     struct ospf6_interface *oi)
@@ -147,14 +164,7 @@ struct ospf6_neighbor *ospf6_neighbor_cr
 
 void ospf6_neighbor_delete(struct ospf6_neighbor *on)
 {
-	struct ospf6_lsa *lsa, *lsanext;
-
-	ospf6_lsdb_remove_all(on->summary_list);
-	ospf6_lsdb_remove_all(on->request_list);
-	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-		ospf6_decrement_retrans_count(lsa);
-		ospf6_lsdb_remove(lsa, on->retrans_list);
-	}
+	ospf6_neighbor_clear_ls_lists(on);
 
 	ospf6_lsdb_remove_all(on->dbdesc_list);
 	ospf6_lsdb_remove_all(on->lsupdate_list);
@@ -339,12 +349,7 @@ void negotiation_done(struct thread *thr
 		zlog_debug("Neighbor Event %s: *NegotiationDone*", on->name);
 
 	/* clear ls-list */
-	ospf6_lsdb_remove_all(on->summary_list);
-	ospf6_lsdb_remove_all(on->request_list);
-	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-		ospf6_decrement_retrans_count(lsa);
-		ospf6_lsdb_remove(lsa, on->retrans_list);
-	}
+	ospf6_neighbor_clear_ls_lists(on);
 
 	/* Interface scoped LSAs */
 	for (ALL_LSDB(on->ospf6_if->lsdb, lsa, lsanext)) {
@@ -464,7 +469,6 @@ void loading_done(struct thread *thread)
 void adj_ok(struct thread *thread)
 {
 	struct ospf6_neighbor *on;
-	struct ospf6_lsa *lsa, *lsanext;
 
 	on = (struct ospf6_neighbor *)THREAD_ARG(thread);
 	assert(on);
@@ -486,19 +490,13 @@ void adj_ok(struct thread *thread)
 	} else if (on->state >= OSPF6_NEIGHBOR_EXSTART && !need_adjacency(on)) {
 		ospf6_neighbor_state_change(OSPF6_NEIGHBOR_TWOWAY, on,
 					    OSPF6_NEIGHBOR_EVENT_ADJ_OK);
-		ospf6_lsdb_remove_all(on->summary_list);
-		ospf6_lsdb_remove_all(on->request_list);
-		for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-			ospf6_decrement_retrans_count(lsa);
-			ospf6_lsdb_remove(lsa, on->retrans_list);
-		}
+		ospf6_neighbor_clear_ls_lists(on);
 	}
 }
 
 void seqnumber_mismatch(struct thread *thread)
 {
 	struct ospf6_neighbor *on;
-	struct ospf6_lsa *lsa, *lsanext;
 
 	on = (struct ospf6_neighbor *)THREAD_ARG(thread);
 	assert(on);
@@ -515,12 +513,7 @@ void seqnumber_mismatch(struct thread *t
 	SET_FLAG(on->dbdesc_bits, OSPF6_DBDESC_MBIT);
 	SET_FLAG(on->dbdesc_bits, OSPF6_DBDESC_IBIT);
 
-	ospf6_lsdb_remove_all(on->summary_list);
-	ospf6_lsdb_remove_all(on->request_list);
-	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-		ospf6_decrement_retrans_count(lsa);
-		ospf6_lsdb_remove(lsa, on->retrans_list);
-	}
+	ospf6_neighbor_clear_ls_lists(on);
 
 	THREAD_OFF(on->thread_send_dbdesc);
 	on->dbdesc_seqnum++; /* Incr seqnum as per RFC2328, sec 10.3 */
@@ -532,7 +525,6 @@ void seqnumber_mismatch(struct thread *t
 void bad_lsreq(struct thread *thread)
 {
 	struct ospf6_neighbor *on;
-	struct ospf6_lsa *lsa, *lsanext;
 
 	on = (struct ospf6_neighbor *)THREAD_ARG(thread);
 	assert(on);
@@ -549,12 +541,7 @@ void bad_lsreq(struct thread *thread)
 	SET_FLAG(on->dbdesc_bits, OSPF6_DBDESC_MBIT);
 	SET_FLAG(on->dbdesc_bits, OSPF6_DBDESC_IBIT);
 
-	ospf6_lsdb_remove_all(on->summary_list);
-	ospf6_lsdb_remove_all(on->request_list);
-	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-		ospf6_decrement_retrans_count(lsa);
-		ospf6_lsdb_remove(lsa, on->retrans_list);
-	}
+	ospf6_neighbor_clear_ls_lists(on);
 
 	THREAD_OFF(on->thread_send_dbdesc);
 	on->dbdesc_seqnum++; /* Incr seqnum as per RFC2328, sec 10.3 */
@@ -567,7 +554,6 @@ void bad_lsreq(struct thread *thread)
 void oneway_received(struct thread *thread)
 {
 	struct ospf6_neighbor *on;
-	struct ospf6_lsa *lsa, *lsanext;
 
 	on = (struct ospf6_neighbor *)THREAD_ARG(thread);
 	assert(on);
@@ -582,12 +568,7 @@ void oneway_received(struct thread *thre
 				    OSPF6_NEIGHBOR_EVENT_ONEWAY_RCVD);
 	thread_add_event(master, neighbor_change, on->ospf6_if, 0, NULL);
 
-	ospf6_lsdb_remove_all(on->summary_list);
-	ospf6_lsdb_remove_all(on->request_list);
-	for (ALL_LSDB(on->retrans_list, lsa, lsanext)) {
-		ospf6_decrement_retrans_count(lsa);
-		ospf6_lsdb_remove(lsa, on->retrans_list);
-	}
+	ospf6_neighbor_clear_ls_lists(on);
 
 	THREAD_OFF(on->thread_send_dbdesc);
 	THREAD_OFF(on->thread_send_lsreq);
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_nssa.c frr-frr-8.5/ospf6d/ospf6_nssa.c
--- frr-frr-8.4.2/ospf6d/ospf6_nssa.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_nssa.c	2023-03-13 20:01:47.000000000 +0600
@@ -49,9 +49,7 @@
 #include "ospf6_asbr.h"
 #include "ospf6d.h"
 #include "ospf6_nssa.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_nssa_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_LSA,         "OSPF6 LSA");
 unsigned char config_debug_ospf6_nssa = 0;
@@ -1092,7 +1090,25 @@ static void ospf6_check_and_originate_ty
 			ospf6_nssa_lsa_originate(aggr->route, area, true);
 		}
 	}
+}
+
+static void ospf6_ase_lsa_refresh(struct ospf6 *o)
+{
+	struct ospf6_lsa *old;
 
+	for (struct ospf6_route *route = ospf6_route_head(o->external_table);
+	     route; route = ospf6_route_next(route)) {
+		old = ospf6_lsdb_lookup(htons(OSPF6_LSTYPE_AS_EXTERNAL),
+					route->path.origin.id, o->router_id,
+					o->lsdb);
+		if (old) {
+			THREAD_OFF(old->refresh);
+			thread_add_event(master, ospf6_lsa_refresh, old, 0,
+					 &old->refresh);
+		} else {
+			ospf6_as_external_lsa_originate(route, o);
+		}
+	}
 }
 
 void ospf6_area_nssa_update(struct ospf6_area *area)
@@ -1136,6 +1152,36 @@ void ospf6_area_nssa_update(struct ospf6
 		if (IS_OSPF6_DEBUG_NSSA)
 			zlog_debug("Normal area %s", area->name);
 		ospf6_nssa_flush_area(area);
+
+		/* Check if router is ABR */
+		if (ospf6_check_and_set_router_abr(area->ospf6)) {
+			if (IS_OSPF6_DEBUG_NSSA)
+				zlog_debug("Router is ABR area %s", area->name);
+			ospf6_schedule_abr_task(area->ospf6);
+			ospf6_ase_lsa_refresh(area->ospf6);
+		} else {
+			uint16_t type;
+			struct ospf6_lsa *lsa = NULL;
+
+			/*
+			 * Refresh all type-5 LSAs so they get installed
+			 * in the converted ares
+			 */
+			if (IS_OSPF6_DEBUG_NSSA)
+				zlog_debug("Refresh type-5 LSAs, area %s",
+					   area->name);
+
+			type = htons(OSPF6_LSTYPE_AS_EXTERNAL);
+			for (ALL_LSDB_TYPED_ADVRTR(area->ospf6->lsdb, type,
+						   area->ospf6->router_id,
+						   lsa)) {
+				if (IS_OSPF6_DEBUG_NSSA)
+					ospf6_lsa_header_print(lsa);
+				THREAD_OFF(lsa->refresh);
+				thread_add_event(master, ospf6_lsa_refresh, lsa,
+						 0, &lsa->refresh);
+			}
+		}
 	}
 }
 
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_nssa.h frr-frr-8.5/ospf6d/ospf6_nssa.h
--- frr-frr-8.4.2/ospf6d/ospf6_nssa.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_nssa.h	2023-03-13 20:01:47.000000000 +0600
@@ -45,7 +45,7 @@ extern unsigned char config_debug_ospf6_
 #define OSPF6_LSA_APPROVED      0x08
 #define OSPF6_LSA_LOCAL_XLT     0x40
 
-#define OSPF6_ABR_TASK_DELAY    7
+#define OSPF6_ABR_TASK_DELAY    5
 
 int ospf6_area_nssa_no_summary_set(struct ospf6 *ospf6, struct in_addr area_id);
 int ospf6_area_nssa_unset(struct ospf6 *ospf6, struct ospf6_area *area);
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_route.c frr-frr-8.5/ospf6d/ospf6_route.c
--- frr-frr-8.4.2/ospf6d/ospf6_route.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_route.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,9 +37,7 @@
 #include "ospf6_interface.h"
 #include "ospf6d.h"
 #include "ospf6_zebra.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_route_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_ROUTE,   "OSPF6 route");
 DEFINE_MTYPE_STATIC(OSPF6D, OSPF6_ROUTE_TABLE, "OSPF6 route table");
@@ -248,7 +246,10 @@ void ospf6_merge_nexthops(struct list *d
 	}
 }
 
-int ospf6_route_cmp_nexthops(struct ospf6_route *a, struct ospf6_route *b)
+/*
+ * If the nexthops are the same return true
+ */
+bool ospf6_route_cmp_nexthops(struct ospf6_route *a, struct ospf6_route *b)
 {
 	struct listnode *anode, *bnode;
 	struct ospf6_nexthop *anh, *bnh;
@@ -266,14 +267,14 @@ int ospf6_route_cmp_nexthops(struct ospf
 				/* Currnet List A element not found List B
 				 * Non-Identical lists return */
 				if (identical == false)
-					return 1;
+					return false;
 			}
-			return 0;
+			return true;
 		} else
-			return 1;
+			return false;
 	}
 	/* One of the routes doesn't exist ? */
-	return (1);
+	return false;
 }
 
 int ospf6_num_nexthops(struct list *nh_list)
@@ -579,12 +580,7 @@ ospf6_route_lookup_identical(struct ospf
 
 	for (target = ospf6_route_lookup(&route->prefix, table); target;
 	     target = target->next) {
-		if (target->type == route->type
-		    && prefix_same(&target->prefix, &route->prefix)
-		    && target->path.type == route->path.type
-		    && target->path.cost == route->path.cost
-		    && target->path.u.cost_e2 == route->path.u.cost_e2
-		    && ospf6_route_cmp_nexthops(target, route) == 0)
+		if (ospf6_route_is_identical(target, route))
 			return target;
 	}
 	return NULL;
@@ -1381,7 +1377,7 @@ static void ospf6_route_show_table_summa
 	struct ospf6_route *route, *prev = NULL;
 	int i, pathtype[OSPF6_PATH_TYPE_MAX];
 	unsigned int number = 0;
-	int nh_count = 0, nhinval = 0, ecmp = 0;
+	int nh_count = 0, ecmp = 0;
 	int alternative = 0, destination = 0;
 	char path_str[30];
 
@@ -1395,9 +1391,7 @@ static void ospf6_route_show_table_summa
 		else
 			alternative++;
 		nh_count = ospf6_num_nexthops(route->nh_list);
-		if (!nh_count)
-			nhinval++;
-		else if (nh_count > 1)
+		if (nh_count > 1)
 			ecmp++;
 		pathtype[route->path.type]++;
 		number++;
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_route.h frr-frr-8.5/ospf6d/ospf6_route.h
--- frr-frr-8.4.2/ospf6d/ospf6_route.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_route.h	2023-03-13 20:01:47.000000000 +0600
@@ -304,7 +304,7 @@ extern const char *const ospf6_path_type
 	 (ra)->path.cost == (rb)->path.cost &&                                 \
 	 (ra)->path.u.cost_e2 == (rb)->path.u.cost_e2 &&                       \
 	 listcount(ra->paths) == listcount(rb->paths) &&                       \
-	 ospf6_route_cmp_nexthops(ra, rb) == 0)
+	 ospf6_route_cmp_nexthops(ra, rb))
 
 #define ospf6_route_is_best(r) (CHECK_FLAG ((r)->flag, OSPF6_ROUTE_BEST))
 
@@ -330,8 +330,8 @@ extern void ospf6_add_nexthop(struct lis
 			      struct in6_addr *addr);
 extern void ospf6_add_route_nexthop_blackhole(struct ospf6_route *route);
 extern int ospf6_num_nexthops(struct list *nh_list);
-extern int ospf6_route_cmp_nexthops(struct ospf6_route *a,
-				    struct ospf6_route *b);
+extern bool ospf6_route_cmp_nexthops(struct ospf6_route *a,
+				     struct ospf6_route *b);
 extern void ospf6_route_zebra_copy_nexthops(struct ospf6_route *route,
 					    struct zapi_nexthop nexthops[],
 					    int entries, vrf_id_t vrf_id);
diff -urpN frr-frr-8.4.2/ospf6d/ospf6_top.c frr-frr-8.5/ospf6d/ospf6_top.c
--- frr-frr-8.4.2/ospf6d/ospf6_top.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6_top.c	2023-03-13 20:01:47.000000000 +0600
@@ -65,9 +65,7 @@ FRR_CFG_DEFAULT_BOOL(OSPF6_LOG_ADJACENCY
 	{ .val_bool = false },
 );
 
-#ifndef VTYSH_EXTRACT_PL
 #include "ospf6d/ospf6_top_clippy.c"
-#endif
 
 /* global ospf6d variable */
 static struct ospf6_master ospf6_master;
@@ -500,6 +498,7 @@ void ospf6_delete(struct ospf6 *o)
 	struct route_node *rn = NULL;
 	struct ospf6_area *oa;
 	struct vrf *vrf;
+	struct ospf6_external_aggr_rt *aggr;
 
 	QOBJ_UNREG(o);
 
@@ -538,8 +537,11 @@ void ospf6_delete(struct ospf6 *o)
 	}
 
 	for (rn = route_top(o->rt_aggr_tbl); rn; rn = route_next(rn))
-		if (rn->info)
-			ospf6_external_aggregator_free(rn->info);
+		if (rn->info) {
+			aggr = rn->info;
+			ospf6_asbr_summary_config_delete(o, rn);
+			ospf6_external_aggregator_free(aggr);
+		}
 	route_table_finish(o->rt_aggr_tbl);
 
 	XFREE(MTYPE_OSPF6_TOP, o->name);
@@ -2013,9 +2015,6 @@ ospf6_show_vrf_name(struct vty *vty, str
 	}
 }
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys containing whitespaces")
-#endif
 static int
 ospf6_show_summary_address(struct vty *vty, struct ospf6 *ospf6,
 			json_object *json,
@@ -2035,8 +2034,6 @@ ospf6_show_summary_address(struct vty *v
 
 		ospf6_show_vrf_name(vty, ospf6, json_vrf);
 
-		json_object_int_add(json_vrf, "aggregation delay interval",
-				    ospf6->aggr_delay_interval);
 		json_object_int_add(json_vrf, "aggregationDelayInterval",
 				    ospf6->aggr_delay_interval);
 	}
@@ -2060,18 +2057,10 @@ ospf6_show_summary_address(struct vty *v
 						buf,
 						json_aggr);
 
-			json_object_string_add(json_aggr,
-					"Summary address",
-					buf);
 			json_object_string_add(json_aggr, "summaryAddress",
 					       buf);
 
 			json_object_string_add(
-				json_aggr, "Metric-type",
-				(aggr->mtype == DEFAULT_METRIC_TYPE)
-					? "E2"
-					: "E1");
-			json_object_string_add(
 				json_aggr, "metricType",
 				(aggr->mtype == DEFAULT_METRIC_TYPE) ? "E2"
 								     : "E1");
@@ -2084,9 +2073,6 @@ ospf6_show_summary_address(struct vty *v
 			json_object_int_add(json_aggr, "Tag",
 					    aggr->tag);
 
-			json_object_int_add(json_aggr,
-					"External route count",
-					OSPF6_EXTERNAL_RT_COUNT(aggr));
 			json_object_int_add(json_aggr, "externalRouteCount",
 					    OSPF6_EXTERNAL_RT_COUNT(aggr));
 
diff -urpN frr-frr-8.4.2/ospf6d/ospf6d.c frr-frr-8.5/ospf6d/ospf6d.c
--- frr-frr-8.4.2/ospf6d/ospf6d.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/ospf6d.c	2023-03-13 20:01:47.000000000 +0600
@@ -115,6 +115,8 @@ DEFUN_NOSH (show_debugging_ospf6,
 
 	config_write_ospf6_debug(vty);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/ospf6d/subdir.am frr-frr-8.5/ospf6d/subdir.am
--- frr-frr-8.4.2/ospf6d/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospf6d/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,27 +5,6 @@
 if OSPF6D
 noinst_LIBRARIES += ospf6d/libospf6.a
 sbin_PROGRAMS += ospf6d/ospf6d
-vtysh_scan += \
-	ospf6d/ospf6_nssa.c \
-	ospf6d/ospf6_abr.c \
-	ospf6d/ospf6_asbr.c \
-	ospf6d/ospf6_area.c \
-	ospf6d/ospf6_bfd.c \
-	ospf6d/ospf6_flood.c \
-	ospf6d/ospf6_gr.c \
-	ospf6d/ospf6_gr_helper.c \
-	ospf6d/ospf6_interface.c \
-	ospf6d/ospf6_intra.c \
-	ospf6d/ospf6_lsa.c \
-	ospf6d/ospf6_message.c \
-	ospf6d/ospf6_neighbor.c \
-	ospf6d/ospf6_route.c \
-	ospf6d/ospf6_spf.c \
-	ospf6d/ospf6_top.c \
-	ospf6d/ospf6_zebra.c \
-	ospf6d/ospf6d.c \
-	ospf6d/ospf6_auth_trailer.c \
-	# end
 vtysh_daemons += ospf6d
 if SNMP
 module_LTLIBRARIES += ospf6d/ospf6d_snmp.la
diff -urpN frr-frr-8.4.2/ospfclient/ospf_apiclient.c frr-frr-8.5/ospfclient/ospf_apiclient.c
--- frr-frr-8.4.2/ospfclient/ospf_apiclient.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfclient/ospf_apiclient.c	2023-03-13 20:01:47.000000000 +0600
@@ -54,10 +54,6 @@
 
 #include "ospf_apiclient.h"
 
-/* *sigh* ... can't find a better way to hammer this into automake */
-#include "ospfd/ospf_dump_api.c"
-#include "ospfd/ospf_api.c"
-
 XREF_SETUP();
 
 DEFINE_MGROUP(OSPFCLIENT, "libospfapiclient");
@@ -453,12 +449,6 @@ int ospf_apiclient_lsa_originate(struct
 		return OSPF_API_ILLEGALLSATYPE;
 	}
 
-	if ((size_t)opaquelen > sizeof(buf) - sizeof(struct lsa_header)) {
-		fprintf(stderr, "opaquelen(%d) is larger than buf size %zu\n",
-			opaquelen, sizeof(buf));
-		return OSPF_API_NOMEMORY;
-	}
-
 	/* Make a new LSA from parameters */
 	lsah = (struct lsa_header *)buf;
 	lsah->ls_age = 0;
diff -urpN frr-frr-8.4.2/ospfclient/ospfclient.py frr-frr-8.5/ospfclient/ospfclient.py
--- frr-frr-8.4.2/ospfclient/ospfclient.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfclient/ospfclient.py	2023-03-13 20:01:47.000000000 +0600
@@ -255,6 +255,16 @@ def nsm_name(state):
     return names.get(state, str(state))
 
 
+class WithNothing:
+    "An object that does nothing when used with `with` statement."
+
+    async def __aenter__(self):
+        return
+
+    async def __aexit__(self, *args, **kwargs):
+        return
+
+
 # --------------
 # Client Classes
 # --------------
@@ -560,15 +570,17 @@ class OspfOpaqueClient(OspfApiClient):
 
     Args:
         server: hostname or IP address of server default is "localhost"
+        wait_ready: if True then wait for OSPF to signal ready, in newer versions
+            FRR ospfd is always ready so this overhead can be skipped.
+            default is False.
 
     Raises:
         Will raise exceptions for failures with various `socket` modules
         functions such as `socket.socket`, `socket.setsockopt`, `socket.bind`.
     """
 
-    def __init__(self, server="localhost"):
+    def __init__(self, server="localhost", wait_ready=False):
         handlers = {
-            MSG_READY_NOTIFY: self._ready_msg,
             MSG_LSA_UPDATE_NOTIFY: self._lsa_change_msg,
             MSG_LSA_DELETE_NOTIFY: self._lsa_change_msg,
             MSG_NEW_IF: self._if_msg,
@@ -578,9 +590,13 @@ class OspfOpaqueClient(OspfApiClient):
             MSG_REACHABLE_CHANGE: self._reachable_msg,
             MSG_ROUTER_ID_CHANGE: self._router_id_msg,
         }
+        if wait_ready:
+            handlers[MSG_READY_NOTIFY] = self._ready_msg
+
         super().__init__(server, handlers)
 
-        self.ready_lock = Lock()
+        self.wait_ready = wait_ready
+        self.ready_lock = Lock() if wait_ready else WithNothing()
         self.ready_cond = {
             LSA_TYPE_OPAQUE_LINK: {},
             LSA_TYPE_OPAQUE_AREA: {},
@@ -617,13 +633,9 @@ class OspfOpaqueClient(OspfApiClient):
             mp = struct.pack(msg_fmt[mt], lsa_type, otype)
             await self.msg_send_raises(mt, mp)
 
-    async def _assure_opaque_ready(self, lsa_type, otype):
-        async with self.ready_lock:
-            if self.ready_cond[lsa_type].get(otype) is True:
-                return
-
-        await self._register_opaque_data(lsa_type, otype)
-        await self.wait_opaque_ready(lsa_type, otype)
+            # If we are not waiting, mark ready for register check
+            if not self.wait_ready:
+                self.ready_cond[lsa_type][otype] = True
 
     async def _handle_msg_loop(self):
         try:
@@ -656,6 +668,8 @@ class OspfOpaqueClient(OspfApiClient):
         return lsa
 
     async def _ready_msg(self, mt, msg, extra, lsa_type, otype, addr):
+        assert self.wait_ready
+
         if lsa_type == LSA_TYPE_OPAQUE_LINK:
             e = "ifaddr {}".format(ip(addr))
         elif lsa_type == LSA_TYPE_OPAQUE_AREA:
@@ -825,6 +839,7 @@ class OspfOpaqueClient(OspfApiClient):
         Raises:
             See `msg_send_raises`
         """
+        assert self.ready_cond.get(lsa_type, {}).get(otype) is True, "Not Registered!"
 
         if lsa_type == LSA_TYPE_OPAQUE_LINK:
             ifaddr, aid = int(addr), 0
@@ -842,7 +857,6 @@ class OspfOpaqueClient(OspfApiClient):
             *OspfOpaqueClient._opaque_args(lsa_type, otype, oid, data),
         )
         msg += data
-        await self._assure_opaque_ready(lsa_type, otype)
         await self.msg_send_raises(mt, msg)
 
     async def delete_opaque_data(self, addr, lsa_type, otype, oid, flags=0):
@@ -854,21 +868,31 @@ class OspfOpaqueClient(OspfApiClient):
         Args:
             addr: depends on lsa_type, LINK => ifaddr, AREA => area ID, AS => ignored
             lsa_type: LSA_TYPE_OPAQUE_{LINK,AREA,AS}
-            otype: (octet) opaque type. Note: the type will be registered if the user
-                has not explicity done that yet with `register_opaque_data`.
+            otype: (octet) opaque type.
             oid: (3 octets) ID of this opaque data
             flags: (octet) optional flags (e.g., OSPF_API_DEL_ZERO_LEN_LSA, defaults to no flags)
         Raises:
             See `msg_send_raises`
         """
-        if (lsa_type, otype) in self.opaque_change_cb:
-            del self.opaque_change_cb[(lsa_type, otype)]
+        assert self.ready_cond.get(lsa_type, {}).get(otype) is True, "Not Registered!"
 
         mt = MSG_DELETE_REQUEST
-        await self._assure_opaque_ready(lsa_type, otype)
         mp = struct.pack(msg_fmt[mt], int(addr), lsa_type, otype, flags, oid)
         await self.msg_send_raises(mt, mp)
 
+    async def is_registered(self, lsa_type, otype):
+        """Determine if an (lsa_type, otype) tuple has been registered with FRR
+
+        This determines if the type has been registered, but not necessarily if it is
+        ready, if that is required use the `wait_opaque_ready` metheod.
+
+        Args:
+            lsa_type: LSA_TYPE_OPAQUE_{LINK,AREA,AS}
+            otype: (octet) opaque type.
+        """
+        async with self.ready_lock:
+            return self.ready_cond.get(lsa_type, {}).get(otype) is not None
+
     async def register_opaque_data(self, lsa_type, otype, callback=None):
         """Register intent to advertise opaque data.
 
@@ -878,8 +902,7 @@ class OspfOpaqueClient(OspfApiClient):
 
         Args:
             lsa_type: LSA_TYPE_OPAQUE_{LINK,AREA,AS}
-            otype: (octet) opaque type. Note: the type will be registered if the user
-                has not explicity done that yet with `register_opaque_data`.
+            otype: (octet) opaque type.
             callback: if given, callback will be called when changes are received for
                 LSA of the given (lsa_type, otype). The callbacks signature is:
 
@@ -895,6 +918,10 @@ class OspfOpaqueClient(OspfApiClient):
         Raises:
             See `msg_send_raises`
         """
+        assert not await self.is_registered(
+            lsa_type, otype
+        ), "Registering registered type"
+
         if callback:
             self.opaque_change_cb[(lsa_type, otype)] = callback
         elif (lsa_type, otype) in self.opaque_change_cb:
@@ -913,6 +940,8 @@ class OspfOpaqueClient(OspfApiClient):
             if cond is True:
                 return
 
+            assert self.wait_ready
+
             logging.debug(
                 "waiting for ready %s opaque-type %s", lsa_typename(lsa_type), otype
             )
@@ -933,8 +962,7 @@ class OspfOpaqueClient(OspfApiClient):
 
         Args:
             lsa_type: LSA_TYPE_OPAQUE_{LINK,AREA,AS}
-            otype: (octet) opaque type. Note: the type will be registered if the user
-                has not explicity done that yet with `register_opaque_data`.
+            otype: (octet) opaque type.
             callback: if given, callback will be called when changes are received for
                 LSA of the given (lsa_type, otype). The callbacks signature is:
 
@@ -951,17 +979,8 @@ class OspfOpaqueClient(OspfApiClient):
 
             See `msg_send_raises`
         """
-        if callback:
-            self.opaque_change_cb[(lsa_type, otype)] = callback
-        elif (lsa_type, otype) in self.opaque_change_cb:
-            logging.warning(
-                "OSPFCLIENT: register: removing callback for %s opaque-type %s",
-                lsa_typename(lsa_type),
-                otype,
-            )
-            del self.opaque_change_cb[(lsa_type, otype)]
-
-        return await self._assure_opaque_ready(lsa_type, otype)
+        await self.register_opaque_data(lsa_type, otype, callback)
+        await self.wait_opaque_ready(lsa_type, otype)
 
     async def unregister_opaque_data(self, lsa_type, otype):
         """Unregister intent to advertise opaque data.
@@ -971,11 +990,13 @@ class OspfOpaqueClient(OspfApiClient):
 
         Args:
             lsa_type: LSA_TYPE_OPAQUE_{LINK,AREA,AS}
-            otype: (octet) opaque type. Note: the type will be registered if the user
-                has not explicity done that yet with `register_opaque_data`.
+            otype: (octet) opaque type.
         Raises:
             See `msg_send_raises`
         """
+        assert await self.is_registered(
+            lsa_type, otype
+        ), "Unregistering unregistered type"
 
         if (lsa_type, otype) in self.opaque_change_cb:
             del self.opaque_change_cb[(lsa_type, otype)]
@@ -1081,6 +1102,17 @@ class OspfOpaqueClient(OspfApiClient):
 # ================
 # CLI/Script Usage
 # ================
+def next_action(action_list=None):
+    "Get next action from list or STDIN"
+    if action_list:
+        for action in action_list:
+            yield action
+    else:
+        while True:
+            action = input("")
+            if not action:
+                break
+            yield action.strip()
 
 
 async def async_main(args):
@@ -1099,50 +1131,53 @@ async def async_main(args):
         await c.req_ism_states()
         await c.req_nsm_states()
 
-        if args.actions:
-            for action in args.actions:
-                _s = action.split(",")
-                what = _s.pop(False)
-                if what.casefold() == "wait":
-                    stime = int(_s.pop(False))
-                    logging.info("waiting %s seconds", stime)
-                    await asyncio.sleep(stime)
-                    logging.info("wait complete: %s seconds", stime)
-                    continue
-                ltype = int(_s.pop(False))
-                if ltype == 11:
-                    addr = ip(0)
-                else:
-                    aval = _s.pop(False)
-                    try:
-                        addr = ip(int(aval))
-                    except ValueError:
-                        addr = ip(aval)
-                oargs = [addr, ltype, int(_s.pop(False)), int(_s.pop(False))]
-                if what.casefold() == "add":
+        for action in next_action(args.actions):
+            _s = action.split(",")
+            what = _s.pop(False)
+            if what.casefold() == "wait":
+                stime = int(_s.pop(False))
+                logging.info("waiting %s seconds", stime)
+                await asyncio.sleep(stime)
+                logging.info("wait complete: %s seconds", stime)
+                continue
+            ltype = int(_s.pop(False))
+            if ltype == 11:
+                addr = ip(0)
+            else:
+                aval = _s.pop(False)
+                try:
+                    addr = ip(int(aval))
+                except ValueError:
+                    addr = ip(aval)
+            oargs = [addr, ltype, int(_s.pop(False)), int(_s.pop(False))]
+
+            if not await c.is_registered(oargs[1], oargs[2]):
+                await c.register_opaque_data_wait(oargs[1], oargs[2])
+
+            if what.casefold() == "add":
+                try:
+                    b = bytes.fromhex(_s.pop(False))
+                except IndexError:
+                    b = b""
+                logging.info("opaque data is %s octets", len(b))
+                # Needs to be multiple of 4 in length
+                mod = len(b) % 4
+                if mod:
+                    b += b"\x00" * (4 - mod)
+                    logging.info("opaque padding to %s octets", len(b))
+
+                await c.add_opaque_data(*oargs, b)
+            else:
+                assert what.casefold().startswith("del")
+                f = 0
+                if len(_s) >= 1:
                     try:
-                        b = bytes.fromhex(_s.pop(False))
+                        f = int(_s.pop(False))
                     except IndexError:
-                        b = b""
-                    logging.info("opaque data is %s octets", len(b))
-                    # Needs to be multiple of 4 in length
-                    mod = len(b) % 4
-                    if mod:
-                        b += b"\x00" * (4 - mod)
-                        logging.info("opaque padding to %s octets", len(b))
-
-                    await c.add_opaque_data(*oargs, b)
-                else:
-                    assert what.casefold().startswith("del")
-                    f = 0
-                    if len(_s) >= 1:
-                        try:
-                            f = int(_s.pop(False))
-                        except IndexError:
-                            f = 0
-                    await c.delete_opaque_data(*oargs, f)
-            if args.exit:
-                return 0
+                        f = 0
+                await c.delete_opaque_data(*oargs, f)
+        if not args.actions or args.exit:
+            return 0
     except Exception as error:
         logging.error("async_main: unexpected error: %s", error, exc_info=True)
         return 2
@@ -1158,19 +1193,23 @@ async def async_main(args):
 
 def main(*args):
     ap = argparse.ArgumentParser(args)
+    ap.add_argument("--logtag", default="CLIENT", help="tag to identify log messages")
     ap.add_argument("--exit", action="store_true", help="Exit after commands")
     ap.add_argument("--server", default="localhost", help="OSPF API server")
     ap.add_argument("-v", "--verbose", action="store_true", help="be verbose")
     ap.add_argument(
         "actions",
         nargs="*",
-        help="(ADD|DEL),LSATYPE,[ADDR,],OTYPE,OID,[HEXDATA|DEL_FLAG]",
+        help="WAIT,SEC|(ADD|DEL),LSATYPE,[ADDR,],OTYPE,OID,[HEXDATA|DEL_FLAG]",
     )
     args = ap.parse_args()
 
     level = logging.DEBUG if args.verbose else logging.INFO
     logging.basicConfig(
-        level=level, format="%(asctime)s %(levelname)s: CLIENT: %(name)s %(message)s"
+        level=level,
+        format="%(asctime)s %(levelname)s: {}: %(name)s %(message)s".format(
+            args.logtag
+        ),
     )
 
     logging.info("ospfclient: starting")
diff -urpN frr-frr-8.4.2/ospfclient/subdir.am frr-frr-8.5/ospfclient/subdir.am
--- frr-frr-8.4.2/ospfclient/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfclient/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -27,6 +27,7 @@ endif
 
 ospfclient_ospfclient_LDADD = \
 	ospfclient/libfrrospfapiclient.la \
+	ospfd/libfrrospfclient.a \
 	$(LIBCAP) \
 	# end
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_abr.h frr-frr-8.5/ospfd/ospf_abr.h
--- frr-frr-8.4.2/ospfd/ospf_abr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_abr.h	2023-03-13 20:01:47.000000000 +0600
@@ -22,7 +22,7 @@
 #ifndef _ZEBRA_OSPF_ABR_H
 #define _ZEBRA_OSPF_ABR_H
 
-#define OSPF_ABR_TASK_DELAY 	7
+#define OSPF_ABR_TASK_DELAY 	5
 
 #define OSPF_AREA_RANGE_ADVERTISE	(1 << 0)
 #define OSPF_AREA_RANGE_SUBSTITUTE	(1 << 1)
diff -urpN frr-frr-8.4.2/ospfd/ospf_api.h frr-frr-8.5/ospfd/ospf_api.h
--- frr-frr-8.4.2/ospfd/ospf_api.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_api.h	2023-03-13 20:01:47.000000000 +0600
@@ -298,7 +298,7 @@ struct apimsg {
 	} u;
 };
 
-#define OSPF_API_MAX_MSG_SIZE (sizeof(struct apimsg) + OSPF_MAX_LSA_SIZE)
+#define OSPF_API_MAX_MSG_SIZE (sizeof(struct apimsg) + OSPF_MAX_PACKET_SIZE)
 
 /* -----------------------------------------------------------
  * Prototypes for specific messages
diff -urpN frr-frr-8.4.2/ospfd/ospf_apiserver.c frr-frr-8.5/ospfd/ospf_apiserver.c
--- frr-frr-8.4.2/ospfd/ospf_apiserver.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_apiserver.c	2023-03-13 20:01:47.000000000 +0600
@@ -56,10 +56,14 @@
 #include "ospfd/ospf_ase.h"
 #include "ospfd/ospf_zebra.h"
 #include "ospfd/ospf_errors.h"
+#include "ospfd/ospf_memory.h"
 
 #include "ospfd/ospf_api.h"
 #include "ospfd/ospf_apiserver.h"
 
+DEFINE_MTYPE_STATIC(OSPFD, APISERVER, "API Server");
+DEFINE_MTYPE_STATIC(OSPFD, APISERVER_MSGFILTER, "API Server Message Filter");
+
 /* This is an implementation of an API to the OSPF daemon that allows
  * external applications to access the OSPF daemon through socket
  * connections. The application can use this API to inject its own
@@ -245,9 +249,9 @@ static int ospf_apiserver_del_lsa_hook(s
 struct ospf_apiserver *ospf_apiserver_new(int fd_sync, int fd_async)
 {
 	struct ospf_apiserver *new =
-		XMALLOC(MTYPE_OSPF_APISERVER, sizeof(struct ospf_apiserver));
+		XMALLOC(MTYPE_APISERVER, sizeof(struct ospf_apiserver));
 
-	new->filter = XMALLOC(MTYPE_OSPF_APISERVER_MSGFILTER,
+	new->filter = XMALLOC(MTYPE_APISERVER_MSGFILTER,
 			      sizeof(struct lsa_filter_type));
 
 	new->fd_sync = fd_sync;
@@ -360,7 +364,7 @@ void ospf_apiserver_free(struct ospf_api
 			   (void *)apiserv, apiserver_list->count);
 
 	/* And free instance. */
-	XFREE(MTYPE_OSPF_APISERVER, apiserv);
+	XFREE(MTYPE_APISERVER, apiserv);
 }
 
 void ospf_apiserver_read(struct thread *thread)
@@ -862,8 +866,8 @@ int ospf_apiserver_register_opaque_type(
 	   connection shuts down, we can flush all LSAs of this opaque
 	   type. */
 
-	regtype = XCALLOC(MTYPE_OSPF_APISERVER,
-			  sizeof(struct registered_opaque_type));
+	regtype =
+		XCALLOC(MTYPE_APISERVER, sizeof(struct registered_opaque_type));
 	regtype->lsa_type = lsa_type;
 	regtype->opaque_type = opaque_type;
 
@@ -1155,12 +1159,12 @@ int ospf_apiserver_handle_register_event
 	seqnum = msg_get_seq(msg);
 
 	/* Free existing filter in apiserv. */
-	XFREE(MTYPE_OSPF_APISERVER_MSGFILTER, apiserv->filter);
+	XFREE(MTYPE_APISERVER_MSGFILTER, apiserv->filter);
 	/* Alloc new space for filter. */
 	size = ntohs(msg->hdr.msglen);
 	if (size < OSPF_MAX_LSA_SIZE) {
 
-		apiserv->filter = XMALLOC(MTYPE_OSPF_APISERVER_MSGFILTER, size);
+		apiserv->filter = XMALLOC(MTYPE_APISERVER_MSGFILTER, size);
 
 		/* copy it over. */
 		memcpy(apiserv->filter, &rmsg->filter, size);
@@ -1365,8 +1369,7 @@ int ospf_apiserver_handle_sync_reachable
 		goto out;
 
 	/* send all adds based on current reachable routers */
-	a = abuf = XCALLOC(MTYPE_OSPF_APISERVER,
-			   sizeof(struct in_addr) * rt->count);
+	a = abuf = XCALLOC(MTYPE_APISERVER, sizeof(struct in_addr) * rt->count);
 	for (struct route_node *rn = route_top(rt); rn; rn = route_next(rn))
 		if (listhead((struct list *)rn->info))
 			*a++ = rn->p.u.prefix4;
@@ -1385,7 +1388,7 @@ int ospf_apiserver_handle_sync_reachable
 		rc = ospf_apiserver_send_msg(apiserv, amsg);
 		msg_free(amsg);
 	}
-	XFREE(MTYPE_OSPF_APISERVER, abuf);
+	XFREE(MTYPE_APISERVER, abuf);
 
 out:
 	/* Send a reply back to client with return code */
@@ -2590,9 +2593,12 @@ static inline int cmp_route_nodes(struct
 		return 1;
 	else if (!nrn)
 		return -1;
-	else if (orn->p.u.prefix4.s_addr < nrn->p.u.prefix4.s_addr)
+
+	uint32_t opn = ntohl(orn->p.u.prefix4.s_addr);
+	uint32_t npn = ntohl(nrn->p.u.prefix4.s_addr);
+	if (opn < npn)
 		return -1;
-	else if (orn->p.u.prefix4.s_addr > nrn->p.u.prefix4.s_addr)
+	else if (opn > npn)
 		return 1;
 	else
 		return 0;
@@ -2616,9 +2622,9 @@ void ospf_apiserver_notify_reachable(str
 		return;
 	}
 	if (nrt && nrt->count)
-		a = abuf = XCALLOC(MTYPE_OSPF_APISERVER, insz * nrt->count);
+		a = abuf = XCALLOC(MTYPE_APISERVER, insz * nrt->count);
 	if (ort && ort->count)
-		d = dbuf = XCALLOC(MTYPE_OSPF_APISERVER, insz * ort->count);
+		d = dbuf = XCALLOC(MTYPE_APISERVER, insz * ort->count);
 
 	/* walk both tables */
 	orn = ort ? route_top(ort) : NULL;
@@ -2683,9 +2689,9 @@ void ospf_apiserver_notify_reachable(str
 		msg_free(msg);
 	}
 	if (abuf)
-		XFREE(MTYPE_OSPF_APISERVER, abuf);
+		XFREE(MTYPE_APISERVER, abuf);
 	if (dbuf)
-		XFREE(MTYPE_OSPF_APISERVER, dbuf);
+		XFREE(MTYPE_APISERVER, dbuf);
 }
 
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_apiserver.h frr-frr-8.5/ospfd/ospf_apiserver.h
--- frr-frr-8.4.2/ospfd/ospf_apiserver.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_apiserver.h	2023-03-13 20:01:47.000000000 +0600
@@ -26,10 +26,6 @@
 #include "ospf_api.h"
 #include "ospf_lsdb.h"
 
-/* MTYPE definition is not reflected to "memory.h". */
-#define MTYPE_OSPF_APISERVER MTYPE_TMP
-#define MTYPE_OSPF_APISERVER_MSGFILTER MTYPE_TMP
-
 /* List of opaque types that application registered */
 struct registered_opaque_type {
 	uint8_t lsa_type;
diff -urpN frr-frr-8.4.2/ospfd/ospf_dump.c frr-frr-8.5/ospfd/ospf_dump.c
--- frr-frr-8.4.2/ospfd/ospf_dump.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_dump.c	2023-03-13 20:01:47.000000000 +0600
@@ -42,9 +42,7 @@
 #include "ospfd/ospf_dump.h"
 #include "ospfd/ospf_packet.h"
 #include "ospfd/ospf_network.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospfd/ospf_dump_clippy.c"
-#endif
 
 /* Configuration debug option variables. */
 unsigned long conf_debug_ospf_packet[5] = {0, 0, 0, 0, 0};
@@ -54,13 +52,13 @@ unsigned long conf_debug_ospf_nsm = 0;
 unsigned long conf_debug_ospf_lsa = 0;
 unsigned long conf_debug_ospf_zebra = 0;
 unsigned long conf_debug_ospf_nssa = 0;
-unsigned long conf_debug_ospf_te = 0;
+unsigned long conf_debug_ospf_te;
 unsigned long conf_debug_ospf_ext = 0;
-unsigned long conf_debug_ospf_sr = 0;
-unsigned long conf_debug_ospf_ti_lfa = 0;
-unsigned long conf_debug_ospf_defaultinfo = 0;
-unsigned long conf_debug_ospf_ldp_sync = 0;
-unsigned long conf_debug_ospf_gr = 0;
+unsigned long conf_debug_ospf_sr;
+unsigned long conf_debug_ospf_ti_lfa;
+unsigned long conf_debug_ospf_defaultinfo;
+unsigned long conf_debug_ospf_ldp_sync;
+unsigned long conf_debug_ospf_gr;
 unsigned long conf_debug_ospf_bfd;
 unsigned long conf_debug_ospf_client_api;
 
@@ -72,13 +70,13 @@ unsigned long term_debug_ospf_nsm = 0;
 unsigned long term_debug_ospf_lsa = 0;
 unsigned long term_debug_ospf_zebra = 0;
 unsigned long term_debug_ospf_nssa = 0;
-unsigned long term_debug_ospf_te = 0;
+unsigned long term_debug_ospf_te;
 unsigned long term_debug_ospf_ext = 0;
-unsigned long term_debug_ospf_sr = 0;
-unsigned long term_debug_ospf_ti_lfa = 0;
+unsigned long term_debug_ospf_sr;
+unsigned long term_debug_ospf_ti_lfa;
 unsigned long term_debug_ospf_defaultinfo;
 unsigned long term_debug_ospf_ldp_sync;
-unsigned long term_debug_ospf_gr = 0;
+unsigned long term_debug_ospf_gr;
 unsigned long term_debug_ospf_bfd;
 unsigned long term_debug_ospf_client_api;
 
@@ -628,84 +626,9 @@ void ospf_packet_dump(struct stream *s)
 	stream_set_getp(s, gp);
 }
 
-DEFUN (debug_ospf_packet,
+DEFPY (debug_ospf_packet,
        debug_ospf_packet_cmd,
-       "debug ospf [(1-65535)] packet <hello|dd|ls-request|ls-update|ls-ack|all> [<send [detail]|recv [detail]|detail>]",
-       DEBUG_STR
-       OSPF_STR
-       "Instance ID\n"
-       "OSPF packets\n"
-       "OSPF Hello\n"
-       "OSPF Database Description\n"
-       "OSPF Link State Request\n"
-       "OSPF Link State Update\n"
-       "OSPF Link State Acknowledgment\n"
-       "OSPF all packets\n"
-       "Packet sent\n"
-       "Detail Information\n"
-       "Packet received\n"
-       "Detail Information\n"
-       "Detail Information\n")
-{
-	int inst = (argv[2]->type == RANGE_TKN) ? 1 : 0;
-	int detail = strmatch(argv[argc - 1]->text, "detail");
-	int send = strmatch(argv[argc - (1 + detail)]->text, "send");
-	int recv = strmatch(argv[argc - (1 + detail)]->text, "recv");
-	char *packet = argv[3 + inst]->text;
-
-	if (inst) // user passed instance ID
-	{
-		if (inst != ospf_instance)
-			return CMD_NOT_MY_INSTANCE;
-	}
-
-	int type = 0;
-	int flag = 0;
-	int i;
-
-	/* Check packet type. */
-	if (strmatch(packet, "hello"))
-		type = OSPF_DEBUG_HELLO;
-	else if (strmatch(packet, "dd"))
-		type = OSPF_DEBUG_DB_DESC;
-	else if (strmatch(packet, "ls-request"))
-		type = OSPF_DEBUG_LS_REQ;
-	else if (strmatch(packet, "ls-update"))
-		type = OSPF_DEBUG_LS_UPD;
-	else if (strmatch(packet, "ls-ack"))
-		type = OSPF_DEBUG_LS_ACK;
-	else if (strmatch(packet, "all"))
-		type = OSPF_DEBUG_ALL;
-
-	/* Cases:
-	 * (none)      = send + recv
-	 * detail      = send + recv + detail
-	 * recv        = recv
-	 * send        = send
-	 * recv detail = recv + detail
-	 * send detail = send + detail
-	 */
-	if (!send && !recv)
-		send = recv = 1;
-
-	flag |= (send) ? OSPF_DEBUG_SEND : 0;
-	flag |= (recv) ? OSPF_DEBUG_RECV : 0;
-	flag |= (detail) ? OSPF_DEBUG_DETAIL : 0;
-
-	for (i = 0; i < 5; i++)
-		if (type & (0x01 << i)) {
-			if (vty->node == CONFIG_NODE)
-				DEBUG_PACKET_ON(i, flag);
-			else
-				TERM_DEBUG_PACKET_ON(i, flag);
-		}
-
-	return CMD_SUCCESS;
-}
-
-DEFUN (no_debug_ospf_packet,
-       no_debug_ospf_packet_cmd,
-       "no debug ospf [(1-65535)] packet <hello|dd|ls-request|ls-update|ls-ack|all> [<send [detail]|recv [detail]|detail>]",
+       "[no$no] debug ospf [(1-65535)$inst] packet <hello|dd|ls-request|ls-update|ls-ack|all>$packet [<send$send [detail$detail]|recv$recv [detail$detail]|detail$detail>]",
        NO_STR
        DEBUG_STR
        OSPF_STR
@@ -723,22 +646,13 @@ DEFUN (no_debug_ospf_packet,
        "Detail Information\n"
        "Detail Information\n")
 {
-	int inst = (argv[3]->type == RANGE_TKN) ? 1 : 0;
-	int detail = strmatch(argv[argc - 1]->text, "detail");
-	int send = strmatch(argv[argc - (1 + detail)]->text, "send");
-	int recv = strmatch(argv[argc - (1 + detail)]->text, "recv");
-	char *packet = argv[4 + inst]->text;
-
-	if (inst) // user passed instance ID
-	{
-		if (inst != ospf_instance)
-			return CMD_NOT_MY_INSTANCE;
-	}
-
 	int type = 0;
 	int flag = 0;
 	int i;
 
+	if (inst && inst != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
+
 	/* Check packet type. */
 	if (strmatch(packet, "hello"))
 		type = OSPF_DEBUG_HELLO;
@@ -761,8 +675,10 @@ DEFUN (no_debug_ospf_packet,
 	 * recv detail = recv + detail
 	 * send detail = send + detail
 	 */
-	if (!send && !recv)
-		send = recv = 1;
+	if (!send && !recv) {
+		flag |= OSPF_DEBUG_SEND;
+		flag |= OSPF_DEBUG_RECV;
+	}
 
 	flag |= (send) ? OSPF_DEBUG_SEND : 0;
 	flag |= (recv) ? OSPF_DEBUG_RECV : 0;
@@ -770,10 +686,17 @@ DEFUN (no_debug_ospf_packet,
 
 	for (i = 0; i < 5; i++)
 		if (type & (0x01 << i)) {
-			if (vty->node == CONFIG_NODE)
-				DEBUG_PACKET_OFF(i, flag);
-			else
-				TERM_DEBUG_PACKET_OFF(i, flag);
+			if (vty->node == CONFIG_NODE) {
+				if (no)
+					DEBUG_PACKET_OFF(i, flag);
+				else
+					DEBUG_PACKET_ON(i, flag);
+			} else {
+				if (no)
+					TERM_DEBUG_PACKET_OFF(i, flag);
+				else
+					TERM_DEBUG_PACKET_ON(i, flag);
+			}
 		}
 
 #ifdef DEBUG
@@ -1457,194 +1380,221 @@ DEFUN (no_debug_ospf_instance_nssa,
 	return CMD_SUCCESS;
 }
 
-DEFUN (debug_ospf_te,
+DEFPY (debug_ospf_te,
        debug_ospf_te_cmd,
-       "debug ospf te",
-       DEBUG_STR
-       OSPF_STR
-       "OSPF-TE information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(te, TE);
-	TERM_DEBUG_ON(te, TE);
-	return CMD_SUCCESS;
-}
-
-DEFUN (no_debug_ospf_te,
-       no_debug_ospf_te_cmd,
-       "no debug ospf te",
+       "[no$no] debug ospf [(1-65535)$instance] te",
        NO_STR
        DEBUG_STR
        OSPF_STR
+       "Instance ID\n"
        "OSPF-TE information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(te, TE);
-	TERM_DEBUG_OFF(te, TE);
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
+
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(te, TE);
+		else
+			DEBUG_ON(te, TE);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(te, TE);
+		else
+			TERM_DEBUG_ON(te, TE);
+	}
+
 	return CMD_SUCCESS;
 }
 
-DEFUN (debug_ospf_sr,
+DEFPY (debug_ospf_sr,
        debug_ospf_sr_cmd,
-       "debug ospf sr",
+       "[no$no] debug ospf [(1-65535)$instance] sr",
+       NO_STR
        DEBUG_STR
        OSPF_STR
+       "Instance ID\n"
        "OSPF-SR information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(sr, SR);
-	TERM_DEBUG_ON(sr, SR);
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
+
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(sr, SR);
+		else
+			DEBUG_ON(sr, SR);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(sr, SR);
+		else
+			TERM_DEBUG_ON(sr, SR);
+	}
+
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_debug_ospf_sr,
-       no_debug_ospf_sr_cmd,
-       "no debug ospf sr",
+DEFPY (debug_ospf_ti_lfa,
+       debug_ospf_ti_lfa_cmd,
+       "[no$no] debug ospf [(1-65535)$instance] ti-lfa",
        NO_STR
        DEBUG_STR
        OSPF_STR
-       "OSPF-SR information\n")
+       "Instance ID\n"
+       "OSPF-SR TI-LFA information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(sr, SR);
-	TERM_DEBUG_OFF(sr, SR);
-	return CMD_SUCCESS;
-}
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
 
-DEFUN(debug_ospf_ti_lfa, debug_ospf_ti_lfa_cmd, "debug ospf ti-lfa",
-      DEBUG_STR OSPF_STR "OSPF-SR TI-LFA information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(ti_lfa, TI_LFA);
-	TERM_DEBUG_ON(ti_lfa, TI_LFA);
-	return CMD_SUCCESS;
-}
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(ti_lfa, TI_LFA);
+		else
+			DEBUG_ON(ti_lfa, TI_LFA);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(ti_lfa, TI_LFA);
+		else
+			TERM_DEBUG_ON(ti_lfa, TI_LFA);
+	}
 
-DEFUN(no_debug_ospf_ti_lfa, no_debug_ospf_ti_lfa_cmd, "no debug ospf ti-lfa",
-      NO_STR DEBUG_STR OSPF_STR "OSPF-SR TI-LFA information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(ti_lfa, TI_LFA);
-	TERM_DEBUG_OFF(ti_lfa, TI_LFA);
 	return CMD_SUCCESS;
 }
 
-DEFUN (debug_ospf_default_info,
+DEFPY (debug_ospf_default_info,
        debug_ospf_default_info_cmd,
-       "debug ospf default-information",
+       "[no$no] debug ospf [(1-65535)$instance] default-information",
+       NO_STR
        DEBUG_STR
        OSPF_STR
+       "Instance ID\n"
        "OSPF default information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(defaultinfo, DEFAULTINFO);
-	TERM_DEBUG_ON(defaultinfo, DEFAULTINFO);
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
+
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(defaultinfo, DEFAULTINFO);
+		else
+			DEBUG_ON(defaultinfo, DEFAULTINFO);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(defaultinfo, DEFAULTINFO);
+		else
+			TERM_DEBUG_ON(defaultinfo, DEFAULTINFO);
+	}
+
 	return CMD_SUCCESS;
 }
 
-DEFUN (no_debug_ospf_default_info,
-       no_debug_ospf_default_info_cmd,
-       "no debug ospf default-information",
+DEFPY (debug_ospf_ldp_sync,
+       debug_ospf_ldp_sync_cmd,
+       "[no$no] debug ospf [(1-65535)$instance] ldp-sync",
        NO_STR
        DEBUG_STR
        OSPF_STR
-       "OSPF default information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(defaultinfo, DEFAULTINFO);
-	TERM_DEBUG_OFF(defaultinfo, DEFAULTINFO);
-	return CMD_SUCCESS;
-}
-
-DEFUN(debug_ospf_ldp_sync,
-      debug_ospf_ldp_sync_cmd,
-      "debug ospf ldp-sync",
-      DEBUG_STR OSPF_STR
-      "OSPF LDP-Sync information\n")
+       "Instance ID\n"
+       "OSPF LDP-Sync information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(ldp_sync, LDP_SYNC);
-	TERM_DEBUG_ON(ldp_sync, LDP_SYNC);
-	return CMD_SUCCESS;
-}
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
 
-DEFUN(no_debug_ospf_ldp_sync,
-      no_debug_ospf_ldp_sync_cmd,
-      "no debug ospf ldp-sync",
-      NO_STR
-      DEBUG_STR
-      OSPF_STR
-      "OSPF LDP-Sync information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(ldp_sync, LDP_SYNC);
-	TERM_DEBUG_OFF(ldp_sync, LDP_SYNC);
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(ldp_sync, LDP_SYNC);
+		else
+			DEBUG_ON(ldp_sync, LDP_SYNC);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(ldp_sync, LDP_SYNC);
+		else
+			TERM_DEBUG_ON(ldp_sync, LDP_SYNC);
+	}
 
 	return CMD_SUCCESS;
 }
 
-DEFPY(debug_ospf_gr, debug_ospf_gr_cmd, "[no$no] debug ospf graceful-restart",
-      NO_STR DEBUG_STR OSPF_STR "OSPF Graceful Restart\n")
+DEFPY (debug_ospf_gr,
+       debug_ospf_gr_cmd,
+       "[no$no] debug ospf [(1-65535)$instance] graceful-restart",
+       NO_STR
+       DEBUG_STR
+       OSPF_STR
+       "Instance ID\n"
+       "OSPF Graceful Restart\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(gr, GR);
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
 
-	if (!no)
-		TERM_DEBUG_ON(gr, GR);
-	else
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			CONF_DEBUG_OFF(gr, GR);
+		else
+			CONF_DEBUG_ON(gr, GR);
+	}
+
+	if (no)
 		TERM_DEBUG_OFF(gr, GR);
+	else
+		TERM_DEBUG_ON(gr, GR);
 
 	return CMD_SUCCESS;
 }
 
-DEFPY(debug_ospf_bfd, debug_ospf_bfd_cmd,
-      "[no] debug ospf bfd",
-      NO_STR
-      DEBUG_STR
-      OSPF_STR
-      "Bidirection Forwarding Detection\n")
+DEFPY (debug_ospf_bfd,
+       debug_ospf_bfd_cmd,
+       "[no] debug ospf [(1-65535)$instance] bfd",
+       NO_STR
+       DEBUG_STR
+       OSPF_STR
+       "Instance ID\n"
+       "Bidirection Forwarding Detection\n")
 {
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
+
 	if (vty->node == CONFIG_NODE) {
 		if (no) {
 			bfd_protocol_integration_set_debug(false);
-			CONF_DEBUG_OFF(bfd, BFD_LIB);
+			DEBUG_OFF(bfd, BFD_LIB);
 		} else {
 			bfd_protocol_integration_set_debug(true);
-			CONF_DEBUG_ON(bfd, BFD_LIB);
+			DEBUG_ON(bfd, BFD_LIB);
 		}
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(bfd, BFD_LIB);
+		else
+			TERM_DEBUG_ON(bfd, BFD_LIB);
 	}
 
-	if (no)
-		TERM_DEBUG_OFF(bfd, BFD_LIB);
-	else
-		TERM_DEBUG_ON(bfd, BFD_LIB);
-
 	return CMD_SUCCESS;
 }
 
-DEFUN(debug_ospf_client_api,
-      debug_ospf_client_api_cmd,
-      "debug ospf client-api",
-      DEBUG_STR OSPF_STR
-      "OSPF client API information\n")
+DEFPY (debug_ospf_client_api,
+       debug_ospf_client_api_cmd,
+       "[no$no] debug ospf [(1-65535)$instance] client-api",
+       NO_STR
+       DEBUG_STR
+       OSPF_STR
+       "Instance ID\n"
+       "OSPF client API information\n")
 {
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_ON(client_api, CLIENT_API);
-	TERM_DEBUG_ON(client_api, CLIENT_API);
-	return CMD_SUCCESS;
-}
+	if (instance && instance != ospf_instance)
+		return CMD_NOT_MY_INSTANCE;
 
-DEFUN(no_debug_ospf_client_api,
-      no_debug_ospf_client_api_cmd,
-      "no debug ospf client-api",
-      NO_STR
-      DEBUG_STR
-      OSPF_STR
-      "OSPF client API information\n")
-{
-	if (vty->node == CONFIG_NODE)
-		CONF_DEBUG_OFF(client_api, CLIENT_API);
-	TERM_DEBUG_OFF(client_api, CLIENT_API);
+	if (vty->node == CONFIG_NODE) {
+		if (no)
+			DEBUG_OFF(client_api, CLIENT_API);
+		else
+			DEBUG_ON(client_api, CLIENT_API);
+	} else {
+		if (no)
+			TERM_DEBUG_OFF(client_api, CLIENT_API);
+		else
+			TERM_DEBUG_ON(client_api, CLIENT_API);
+	}
 
 	return CMD_SUCCESS;
 }
@@ -1816,7 +1766,7 @@ static int show_debugging_ospf_common(st
 	}
 
 	if (IS_DEBUG_OSPF(defaultinfo, DEFAULTINFO) == OSPF_DEBUG_DEFAULTINFO)
-		vty_out(vty, "OSPF default information is on\n");
+		vty_out(vty, "  OSPF default information is on\n");
 
 	/* Show debug status for NSSA. */
 	if (IS_DEBUG_OSPF(nssa, NSSA) == OSPF_DEBUG_NSSA)
@@ -1860,7 +1810,11 @@ DEFUN_NOSH (show_debugging_ospf,
 	    DEBUG_STR
 	    OSPF_STR)
 {
-	return show_debugging_ospf_common(vty);
+	show_debugging_ospf_common(vty);
+
+	cmd_show_lib_debugs(vty);
+
+	return CMD_SUCCESS;
 }
 
 DEFUN_NOSH (show_debugging_ospf_instance,
@@ -1878,7 +1832,11 @@ DEFUN_NOSH (show_debugging_ospf_instance
 	if (instance != ospf_instance)
 		return CMD_NOT_MY_INSTANCE;
 
-	return show_debugging_ospf_common(vty);
+	show_debugging_ospf_common(vty);
+
+	cmd_show_lib_debugs(vty);
+
+	return CMD_SUCCESS;
 }
 
 static int config_write_debug(struct vty *vty);
@@ -1978,7 +1936,7 @@ static int config_write_debug(struct vty
 		     & (OSPF_DEBUG_SEND_RECV | OSPF_DEBUG_DETAIL);
 	if (r == (OSPF_DEBUG_SEND_RECV | OSPF_DEBUG_DETAIL)) {
 		vty_out(vty, "debug ospf%s packet all detail\n", str);
-		return 1;
+		write = 1;
 	}
 
 	/* debug ospf packet all. */
@@ -1991,7 +1949,7 @@ static int config_write_debug(struct vty
 			if (conf_debug_ospf_packet[i] & OSPF_DEBUG_DETAIL)
 				vty_out(vty, "debug ospf%s packet %s detail\n",
 					str, type_str[i]);
-		return 1;
+		write = 1;
 	}
 
 	/* debug ospf packet (hello|dd|ls-request|ls-update|ls-ack)
@@ -2047,6 +2005,13 @@ static int config_write_debug(struct vty
 		write = 1;
 	}
 
+	/* debug ospf default-information */
+	if (IS_CONF_DEBUG_OSPF(defaultinfo, DEFAULTINFO) ==
+	    OSPF_DEBUG_DEFAULTINFO) {
+		vty_out(vty, "debug ospf%s default-information\n", str);
+		write = 1;
+	}
+
 	return write;
 }
 
@@ -2074,18 +2039,11 @@ void ospf_debug_init(void)
 	install_element(ENABLE_NODE, &no_debug_ospf_zebra_cmd);
 	install_element(ENABLE_NODE, &no_debug_ospf_event_cmd);
 	install_element(ENABLE_NODE, &no_debug_ospf_nssa_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_te_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_sr_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_ti_lfa_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_default_info_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_ldp_sync_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_client_api_cmd);
 	install_element(ENABLE_NODE, &debug_ospf_gr_cmd);
 	install_element(ENABLE_NODE, &debug_ospf_bfd_cmd);
 
 	install_element(ENABLE_NODE, &show_debugging_ospf_instance_cmd);
 	install_element(ENABLE_NODE, &debug_ospf_packet_cmd);
-	install_element(ENABLE_NODE, &no_debug_ospf_packet_cmd);
 
 	install_element(ENABLE_NODE, &debug_ospf_instance_nsm_cmd);
 	install_element(ENABLE_NODE, &debug_ospf_instance_lsa_cmd);
@@ -2100,7 +2058,6 @@ void ospf_debug_init(void)
 	install_element(ENABLE_NODE, &no_debug_ospf_cmd);
 
 	install_element(CONFIG_NODE, &debug_ospf_packet_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_packet_cmd);
 	install_element(CONFIG_NODE, &debug_ospf_ism_cmd);
 	install_element(CONFIG_NODE, &no_debug_ospf_ism_cmd);
 
@@ -2120,12 +2077,6 @@ void ospf_debug_init(void)
 	install_element(CONFIG_NODE, &no_debug_ospf_zebra_cmd);
 	install_element(CONFIG_NODE, &no_debug_ospf_event_cmd);
 	install_element(CONFIG_NODE, &no_debug_ospf_nssa_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_te_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_sr_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_ti_lfa_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_default_info_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_ldp_sync_cmd);
-	install_element(CONFIG_NODE, &no_debug_ospf_client_api_cmd);
 	install_element(CONFIG_NODE, &debug_ospf_gr_cmd);
 	install_element(CONFIG_NODE, &debug_ospf_bfd_cmd);
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_gr.c frr-frr-8.5/ospfd/ospf_gr.c
--- frr-frr-8.4.2/ospfd/ospf_gr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_gr.c	2023-03-13 20:01:47.000000000 +0600
@@ -44,9 +44,7 @@
 #include "ospfd/ospf_gr.h"
 #include "ospfd/ospf_errors.h"
 #include "ospfd/ospf_dump.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ospfd/ospf_gr_clippy.c"
-#endif
 
 static void ospf_gr_nvm_delete(struct ospf *ospf);
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_interface.c frr-frr-8.5/ospfd/ospf_interface.c
--- frr-frr-8.4.2/ospfd/ospf_interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,6 +30,7 @@
 #include "command.h"
 #include "stream.h"
 #include "log.h"
+#include "network.h"
 #include "zclient.h"
 #include "bfd.h"
 #include "ldp_sync.h"
@@ -274,7 +275,7 @@ struct ospf_interface *ospf_if_new(struc
 	oi->t_ls_upd_event = NULL;
 	oi->t_ls_ack_direct = NULL;
 
-	oi->crypt_seqnum = time(NULL);
+	oi->crypt_seqnum = frr_sequence32_next();
 
 	ospf_opaque_type9_lsa_init(oi);
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_ism.c frr-frr-8.5/ospfd/ospf_ism.c
--- frr-frr-8.4.2/ospfd/ospf_ism.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_ism.c	2023-03-13 20:01:47.000000000 +0600
@@ -223,8 +223,10 @@ int ospf_dr_election(struct ospf_interfa
 
 	new_state = ospf_ism_state(oi);
 
-	zlog_debug("DR-Election[1st]: Backup %pI4", &BDR(oi));
-	zlog_debug("DR-Election[1st]: DR     %pI4", &DR(oi));
+	if (IS_DEBUG_OSPF(ism, ISM_STATUS)) {
+		zlog_debug("DR-Election[1st]: Backup %pI4", &BDR(oi));
+		zlog_debug("DR-Election[1st]: DR     %pI4", &DR(oi));
+	}
 
 	if (new_state != old_state
 	    && !(new_state == ISM_DROther && old_state < ISM_DROther)) {
@@ -233,8 +235,10 @@ int ospf_dr_election(struct ospf_interfa
 
 		new_state = ospf_ism_state(oi);
 
-		zlog_debug("DR-Election[2nd]: Backup %pI4", &BDR(oi));
-		zlog_debug("DR-Election[2nd]: DR     %pI4", &DR(oi));
+		if (IS_DEBUG_OSPF(ism, ISM_STATUS)) {
+			zlog_debug("DR-Election[2nd]: Backup %pI4", &BDR(oi));
+			zlog_debug("DR-Election[2nd]: DR     %pI4", &DR(oi));
+		}
 	}
 
 	list_delete(&el_list);
diff -urpN frr-frr-8.4.2/ospfd/ospf_ldp_sync.c frr-frr-8.5/ospfd/ospf_ldp_sync.c
--- frr-frr-8.4.2/ospfd/ospf_ldp_sync.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_ldp_sync.c	2023-03-13 20:01:47.000000000 +0600
@@ -507,15 +507,8 @@ void ospf_ldp_sync_show_info(struct vty
 
 	if (CHECK_FLAG(ospf->ldp_sync_cmd.flags, LDP_SYNC_FLAG_ENABLE)) {
 		if (use_json) {
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
-			json_object_boolean_true_add(json_vrf,
-						     "MplsLdpIgpSyncEnabled");
 			json_object_boolean_true_add(json_vrf,
 						     "mplsLdpIgpSyncEnabled");
-			json_object_int_add(json_vrf, "MplsLdpIgpSyncHolddown",
-					    ospf->ldp_sync_cmd.holddown);
 			json_object_int_add(json_vrf, "mplsLdpIgpSyncHolddown",
 					    ospf->ldp_sync_cmd.holddown);
 		} else {
@@ -751,9 +744,7 @@ void ospf_ldp_sync_if_write_config(struc
 /*
  * LDP-SYNC commands.
  */
-#ifndef VTYSH_EXTRACT_PL
 #include "ospfd/ospf_ldp_sync_clippy.c"
-#endif
 
 DEFPY (ospf_mpls_ldp_sync,
        ospf_mpls_ldp_sync_cmd,
diff -urpN frr-frr-8.4.2/ospfd/ospf_network.c frr-frr-8.5/ospfd/ospf_network.c
--- frr-frr-8.4.2/ospfd/ospf_network.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_network.c	2023-03-13 20:01:47.000000000 +0600
@@ -104,11 +104,12 @@ int ospf_if_add_alldrouters(struct ospf
 			"can't setsockopt IP_ADD_MEMBERSHIP (fd %d, addr %pI4, ifindex %u, AllDRouters): %s; perhaps a kernel limit on # of multicast group memberships has been exceeded?",
 			top->fd, &p->u.prefix4, ifindex,
 			safe_strerror(errno));
-	else
-		zlog_debug(
-			"interface %pI4 [%u] join AllDRouters Multicast group.",
-			&p->u.prefix4, ifindex);
-
+	else {
+		if (IS_DEBUG_OSPF_EVENT)
+			zlog_debug(
+				"interface %pI4 [%u] join AllDRouters Multicast group.",
+				&p->u.prefix4, ifindex);
+	}
 	return ret;
 }
 
diff -urpN frr-frr-8.4.2/ospfd/ospf_opaque.c frr-frr-8.5/ospfd/ospf_opaque.c
--- frr-frr-8.4.2/ospfd/ospf_opaque.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_opaque.c	2023-03-13 20:01:47.000000000 +0600
@@ -34,6 +34,7 @@
 #include "thread.h"
 #include "hash.h"
 #include "sockunion.h" /* for inet_aton() */
+#include "printfrr.h"
 
 #include "ospfd/ospfd.h"
 #include "ospfd/ospf_interface.h"
@@ -1162,11 +1163,13 @@ void ospf_opaque_config_write_debug(stru
 void show_opaque_info_detail(struct vty *vty, struct ospf_lsa *lsa,
 			     json_object *json)
 {
+	char buf[128], *bp;
 	struct lsa_header *lsah = lsa->data;
 	uint32_t lsid = ntohl(lsah->id.s_addr);
 	uint8_t opaque_type = GET_OPAQUE_TYPE(lsid);
 	uint32_t opaque_id = GET_OPAQUE_ID(lsid);
 	struct ospf_opaque_functab *functab;
+	int len, lenValid;
 
 	/* Switch output functionality by vty address. */
 	if (vty != NULL) {
@@ -1185,11 +1188,19 @@ void show_opaque_info_detail(struct vty
 				json, "opaqueType",
 				ospf_opaque_type_name(opaque_type));
 			json_object_int_add(json, "opaqueId", opaque_id);
-			json_object_int_add(json, "opaqueDataLength",
-					    ntohs(lsah->length)
-						    - OSPF_LSA_HEADER_SIZE);
+			len = ntohs(lsah->length) - OSPF_LSA_HEADER_SIZE;
+			json_object_int_add(json, "opaqueDataLength", len);
+			lenValid = VALID_OPAQUE_INFO_LEN(lsah);
 			json_object_boolean_add(json, "opaqueDataLengthValid",
-						VALID_OPAQUE_INFO_LEN(lsah));
+						lenValid);
+			if (lenValid) {
+				bp = asnprintfrr(MTYPE_TMP, buf, sizeof(buf),
+						 "%*pHXn", (int)len,
+						 (lsah + 1));
+				json_object_string_add(json, "opaqueData", buf);
+				if (bp != buf)
+					XFREE(MTYPE_TMP, bp);
+			}
 		}
 	} else {
 		zlog_debug("    Opaque-Type %u (%s)", opaque_type,
diff -urpN frr-frr-8.4.2/ospfd/ospf_route.c frr-frr-8.5/ospfd/ospf_route.c
--- frr-frr-8.4.2/ospfd/ospf_route.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_route.c	2023-03-13 20:01:47.000000000 +0600
@@ -363,45 +363,50 @@ void ospf_route_install(struct ospf *osp
 
 /* RFC2328 16.1. (4). For "router". */
 void ospf_intra_add_router(struct route_table *rt, struct vertex *v,
-			   struct ospf_area *area, bool add_all)
+			   struct ospf_area *area, bool add_only)
 {
 	struct route_node *rn;
 	struct ospf_route * or ;
 	struct prefix_ipv4 p;
 	struct router_lsa *lsa;
 
-	if (IS_DEBUG_OSPF_EVENT)
-		zlog_debug("%s: Start", __func__);
-
+	if (IS_DEBUG_OSPF_EVENT) {
+		if (!add_only)
+			zlog_debug("%s: Start", __func__);
+		else
+			zlog_debug("%s: REACHRUN: Start", __func__);
+	}
 	lsa = (struct router_lsa *)v->lsa;
 
 	if (IS_DEBUG_OSPF_EVENT)
 		zlog_debug("%s: LS ID: %pI4", __func__, &lsa->header.id);
 
-	if (!OSPF_IS_AREA_BACKBONE(area))
-		ospf_vl_up_check(area, lsa->header.id, v);
-
-	if (!CHECK_FLAG(lsa->flags, ROUTER_LSA_SHORTCUT))
-		area->shortcut_capability = 0;
-
-	/* If the newly added vertex is an area border router or AS boundary
-	   router, a routing table entry is added whose destination type is
-	   "router". */
-	if (!add_all && !IS_ROUTER_LSA_BORDER(lsa) &&
-	    !IS_ROUTER_LSA_EXTERNAL(lsa)) {
-		if (IS_DEBUG_OSPF_EVENT)
-			zlog_debug(
-				"%s: this router is neither ASBR nor ABR, skipping it",
-				__func__);
-		return;
+	if (!add_only) {
+		if (!OSPF_IS_AREA_BACKBONE(area))
+			ospf_vl_up_check(area, lsa->header.id, v);
+
+		if (!CHECK_FLAG(lsa->flags, ROUTER_LSA_SHORTCUT))
+			area->shortcut_capability = 0;
+
+		/* If the newly added vertex is an area border router or AS
+		   boundary router, a routing table entry is added whose
+		   destination type is "router". */
+		if (!IS_ROUTER_LSA_BORDER(lsa) &&
+		    !IS_ROUTER_LSA_EXTERNAL(lsa)) {
+			if (IS_DEBUG_OSPF_EVENT)
+				zlog_debug(
+					"%s: this router is neither ASBR nor ABR, skipping it",
+					__func__);
+			return;
+		}
+
+		/* Update ABR and ASBR count in this area. */
+		if (IS_ROUTER_LSA_BORDER(lsa))
+			area->abr_count++;
+		if (IS_ROUTER_LSA_EXTERNAL(lsa))
+			area->asbr_count++;
 	}
 
-	/* Update ABR and ASBR count in this area. */
-	if (IS_ROUTER_LSA_BORDER(lsa))
-		area->abr_count++;
-	if (IS_ROUTER_LSA_EXTERNAL(lsa))
-		area->asbr_count++;
-
 	/* The Options field found in the associated router-LSA is copied
 	   into the routing table entry's Optional capabilities field. Call
 	   the newly added vertex Router X. */
@@ -448,8 +453,12 @@ void ospf_intra_add_router(struct route_
 
 	listnode_add(rn->info, or);
 
-	if (IS_DEBUG_OSPF_EVENT)
-		zlog_debug("%s: Stop", __func__);
+	if (IS_DEBUG_OSPF_EVENT) {
+		if (!add_only)
+			zlog_debug("%s: Stop", __func__);
+		else
+			zlog_debug("%s: REACHRUN: Stop", __func__);
+	}
 }
 
 /* RFC2328 16.1. (4).  For transit network. */
diff -urpN frr-frr-8.4.2/ospfd/ospf_snmp.c frr-frr-8.5/ospfd/ospf_snmp.c
--- frr-frr-8.4.2/ospfd/ospf_snmp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_snmp.c	2023-03-13 20:01:47.000000000 +0600
@@ -50,6 +50,8 @@
 #include "ospfd/ospf_route.h"
 #include "ospfd/ospf_zebra.h"
 
+DEFINE_MTYPE_STATIC(OSPFD, SNMP, "OSPF SNMP");
+
 /* OSPF2-MIB. */
 #define OSPF2MIB 1,3,6,1,2,1,14
 
@@ -1321,12 +1323,12 @@ struct ospf_snmp_if {
 
 static struct ospf_snmp_if *ospf_snmp_if_new(void)
 {
-	return XCALLOC(MTYPE_TMP, sizeof(struct ospf_snmp_if));
+	return XCALLOC(MTYPE_SNMP, sizeof(struct ospf_snmp_if));
 }
 
 static void ospf_snmp_if_free(struct ospf_snmp_if *osif)
 {
-	XFREE(MTYPE_TMP, osif);
+	XFREE(MTYPE_SNMP, osif);
 }
 
 static int ospf_snmp_if_delete(struct interface *ifp)
diff -urpN frr-frr-8.4.2/ospfd/ospf_spf.c frr-frr-8.5/ospfd/ospf_spf.c
--- frr-frr-8.4.2/ospfd/ospf_spf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_spf.c	2023-03-13 20:01:47.000000000 +0600
@@ -179,8 +179,10 @@ static struct vertex_parent *vertex_pare
 	return new;
 }
 
-static void vertex_parent_free(void *p)
+static void vertex_parent_free(struct vertex_parent *p)
 {
+	vertex_nexthop_free(p->local_nexthop);
+	vertex_nexthop_free(p->nexthop);
 	XFREE(MTYPE_OSPF_VERTEX_PARENT, p);
 }
 
@@ -203,7 +205,7 @@ static struct vertex *ospf_vertex_new(st
 	new->lsa = lsa->data;
 	new->children = list_new();
 	new->parents = list_new();
-	new->parents->del = vertex_parent_free;
+	new->parents->del = (void (*)(void *))vertex_parent_free;
 	new->parents->cmp = vertex_parent_cmp;
 	new->lsa_p = lsa;
 
@@ -346,7 +348,7 @@ static struct vertex *ospf_spf_vertex_co
 
 	memcpy(copy, vertex, sizeof(struct vertex));
 	copy->parents = list_new();
-	copy->parents->del = vertex_parent_free;
+	copy->parents->del = (void (*)(void *))vertex_parent_free;
 	copy->parents->cmp = vertex_parent_cmp;
 	copy->children = list_new();
 
@@ -683,11 +685,15 @@ static void ospf_spf_flush_parents(struc
 /*
  * Consider supplied next-hop for inclusion to the supplied list of
  * equal-cost next-hops, adjust list as necessary.
+ *
+ * Returns vertex parent pointer if created otherwise `NULL` if it already
+ * exists.
  */
-static void ospf_spf_add_parent(struct vertex *v, struct vertex *w,
-				struct vertex_nexthop *newhop,
-				struct vertex_nexthop *newlhop,
-				unsigned int distance)
+static struct vertex_parent *ospf_spf_add_parent(struct vertex *v,
+						 struct vertex *w,
+						 struct vertex_nexthop *newhop,
+						 struct vertex_nexthop *newlhop,
+						 unsigned int distance)
 {
 	struct vertex_parent *vp, *wp;
 	struct listnode *node;
@@ -733,7 +739,8 @@ static void ospf_spf_add_parent(struct v
 				zlog_debug(
 					"%s: ... nexthop already on parent list, skipping add",
 					__func__);
-			return;
+
+			return NULL;
 		}
 	}
 
@@ -741,7 +748,7 @@ static void ospf_spf_add_parent(struct v
 			       newlhop);
 	listnode_add_sort(w->parents, vp);
 
-	return;
+	return vp;
 }
 
 static int match_stub_prefix(struct lsa_header *lsa, struct in_addr v_link_addr,
@@ -979,8 +986,12 @@ static unsigned int ospf_nexthop_calcula
 					memcpy(lnh, nh,
 					       sizeof(struct vertex_nexthop));
 
-					ospf_spf_add_parent(v, w, nh, lnh,
-							    distance);
+					if (ospf_spf_add_parent(v, w, nh, lnh,
+								distance) ==
+					    NULL) {
+						vertex_nexthop_free(nh);
+						vertex_nexthop_free(lnh);
+					}
 					return 1;
 				} else
 					zlog_info(
@@ -1019,8 +1030,13 @@ static unsigned int ospf_nexthop_calcula
 					memcpy(lnh, nh,
 					       sizeof(struct vertex_nexthop));
 
-					ospf_spf_add_parent(v, w, nh, lnh,
-							    distance);
+					if (ospf_spf_add_parent(v, w, nh, lnh,
+								distance) ==
+					    NULL) {
+						vertex_nexthop_free(nh);
+						vertex_nexthop_free(lnh);
+					}
+
 					return 1;
 				} else
 					zlog_info(
@@ -1043,7 +1059,12 @@ static unsigned int ospf_nexthop_calcula
 			lnh = vertex_nexthop_new();
 			memcpy(lnh, nh, sizeof(struct vertex_nexthop));
 
-			ospf_spf_add_parent(v, w, nh, lnh, distance);
+			if (ospf_spf_add_parent(v, w, nh, lnh, distance) ==
+			    NULL) {
+				vertex_nexthop_free(nh);
+				vertex_nexthop_free(lnh);
+			}
+
 			return 1;
 		}
 	} /* end V is the root */
@@ -1086,8 +1107,12 @@ static unsigned int ospf_nexthop_calcula
 					       sizeof(struct vertex_nexthop));
 
 					added = 1;
-					ospf_spf_add_parent(v, w, nh, lnh,
-							    distance);
+					if (ospf_spf_add_parent(v, w, nh, lnh,
+								distance) ==
+					    NULL) {
+						vertex_nexthop_free(nh);
+						vertex_nexthop_free(lnh);
+					}
 				}
 				/*
 				 * Note lack of return is deliberate. See next
@@ -1148,7 +1173,13 @@ static unsigned int ospf_nexthop_calcula
 			lnh = NULL;
 		}
 
-		ospf_spf_add_parent(v, w, vp->nexthop, lnh, distance);
+		nh = vertex_nexthop_new();
+		*nh = *vp->nexthop;
+
+		if (ospf_spf_add_parent(v, w, nh, lnh, distance) == NULL) {
+			vertex_nexthop_free(nh);
+			vertex_nexthop_free(lnh);
+		}
 	}
 
 	return added;
@@ -1891,9 +1922,10 @@ static void ospf_spf_calculate_schedule_
 	rt_time = monotime_since(&start_time, NULL);
 
 	/* Free old all routers routing table */
-	if (ospf->oall_rtrs)
-		/* ospf_route_delete (ospf->old_rtrs); */
+	if (ospf->oall_rtrs) {
 		ospf_rtrs_free(ospf->oall_rtrs);
+		ospf->oall_rtrs = NULL;
+	}
 
 	/* Update all routers routing table */
 	ospf->oall_rtrs = ospf->all_rtrs;
@@ -1903,9 +1935,10 @@ static void ospf_spf_calculate_schedule_
 #endif
 
 	/* Free old ABR/ASBR routing table */
-	if (ospf->old_rtrs)
-		/* ospf_route_delete (ospf->old_rtrs); */
+	if (ospf->old_rtrs) {
 		ospf_rtrs_free(ospf->old_rtrs);
+		ospf->old_rtrs = NULL;
+	}
 
 	/* Update ABR/ASBR routing table */
 	ospf->old_rtrs = ospf->new_rtrs;
diff -urpN frr-frr-8.4.2/ospfd/ospf_vty.c frr-frr-8.5/ospfd/ospf_vty.c
--- frr-frr-8.4.2/ospfd/ospf_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospf_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -184,9 +184,7 @@ static void ospf_show_vrf_name(struct os
 	}
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "ospfd/ospf_vty_clippy.c"
-#endif
 
 DEFUN_NOSH (router_ospf,
        router_ospf_cmd,
@@ -6615,14 +6613,17 @@ static void show_lsa_detail_proc(struct
 		route_lock_node(start);
 		for (rn = start; rn; rn = route_next_until(rn, start))
 			if ((lsa = rn->info)) {
-				if (json) {
-					json_lsa = json_object_new_object();
-					json_object_array_add(json, json_lsa);
-				}
+				if (show_function[lsa->data->type] != NULL) {
+					if (json) {
+						json_lsa =
+							json_object_new_object();
+						json_object_array_add(json,
+								      json_lsa);
+					}
 
-				if (show_function[lsa->data->type] != NULL)
 					show_function[lsa->data->type](
 						vty, lsa, json_lsa);
+				}
 			}
 		route_unlock_node(start);
 	}
@@ -6641,9 +6642,6 @@ static void show_lsa_detail(struct vty *
 	json_object *json_areas = NULL;
 	json_object *json_lsa_array = NULL;
 
-	if (json)
-		json_lsa_type = json_object_new_object();
-
 	switch (type) {
 	case OSPF_AS_EXTERNAL_LSA:
 	case OSPF_OPAQUE_AS_LSA:
@@ -6686,6 +6684,7 @@ static void show_lsa_detail(struct vty *
 		}
 
 		if (json) {
+			json_lsa_type = json_object_new_object();
 			json_object_object_add(json_lsa_type, "areas",
 					       json_areas);
 			json_object_object_add(json,
@@ -7159,6 +7158,9 @@ DEFUN (show_ip_ospf_database_max,
 				vty_out(vty,
 					"%% OSPF is not enabled in vrf %s\n",
 					vrf_name);
+				if (uj)
+					json_object_free(json);
+
 				return CMD_SUCCESS;
 			}
 			ret = (show_ip_ospf_database_common(
@@ -7170,6 +7172,9 @@ DEFUN (show_ip_ospf_database_max,
 		ospf = ospf_lookup_by_vrf_id(VRF_DEFAULT);
 		if (ospf == NULL || !ospf->oi_running) {
 			vty_out(vty, "%% OSPF is not enabled in vrf default\n");
+			if (uj)
+				json_object_free(json);
+
 			return CMD_SUCCESS;
 		}
 
@@ -7177,10 +7182,8 @@ DEFUN (show_ip_ospf_database_max,
 						   use_vrf, json, uj);
 	}
 
-	if (uj) {
-		vty_out(vty, "%s\n", json_object_to_json_string(json));
-		json_object_free(json);
-	}
+	if (uj)
+		vty_json(vty, json);
 
 	return ret;
 }
@@ -7311,16 +7314,26 @@ static int show_ip_ospf_database_type_ad
 		type = OSPF_OPAQUE_AREA_LSA;
 	else if (strncmp(argv[arg_base + idx_type]->text, "opaque-as", 9) == 0)
 		type = OSPF_OPAQUE_AS_LSA;
-	else
+	else {
+		if (uj) {
+			if (use_vrf)
+				json_object_free(json_vrf);
+		}
 		return CMD_WARNING;
+	}
 
 	/* `show ip ospf database LSA adv-router ADV_ROUTER'. */
 	if (strncmp(argv[arg_base + 5]->text, "s", 1) == 0)
 		adv_router = ospf->router_id;
 	else {
 		ret = inet_aton(argv[arg_base + 6]->arg, &adv_router);
-		if (!ret)
+		if (!ret) {
+			if (uj) {
+				if (use_vrf)
+					json_object_free(json_vrf);
+			}
 			return CMD_WARNING;
+		}
 	}
 
 	show_lsa_detail_adv_router(vty, ospf, type, &adv_router, json_vrf);
@@ -7384,9 +7397,12 @@ DEFUN (show_ip_ospf_database_type_adv_ro
 		} else {
 			ospf = ospf_lookup_by_inst_name(inst, vrf_name);
 			if ((ospf == NULL) || !ospf->oi_running) {
-				vty_out(vty,
-					"%% OSPF is not enabled in vrf %s\n",
-					vrf_name);
+				if (uj)
+					vty_json(vty, json);
+				else
+					vty_out(vty,
+						"%% OSPF is not enabled in vrf %s\n",
+						vrf_name);
 				return CMD_SUCCESS;
 			}
 
@@ -7397,7 +7413,11 @@ DEFUN (show_ip_ospf_database_type_adv_ro
 		/* Display default ospf (instance 0) info */
 		ospf = ospf_lookup_by_vrf_id(VRF_DEFAULT);
 		if (ospf == NULL || !ospf->oi_running) {
-			vty_out(vty, "%% OSPF is not enabled on vrf default\n");
+			if (uj)
+				vty_json(vty, json);
+			else
+				vty_out(vty,
+					"%% OSPF is not enabled on vrf default\n");
 			return CMD_SUCCESS;
 		}
 
@@ -10194,17 +10214,10 @@ static int ospf_show_gr_helper_details(s
 		json_object_int_add(json_vrf, "supportedGracePeriod",
 				    ospf->supported_grace_time);
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
-		if (ospf->last_exit_reason != OSPF_GR_HELPER_EXIT_NONE) {
-			json_object_string_add(
-				json_vrf, "LastExitReason",
-				ospf_exit_reason2str(ospf->last_exit_reason));
+		if (ospf->last_exit_reason != OSPF_GR_HELPER_EXIT_NONE)
 			json_object_string_add(
 				json_vrf, "lastExitReason",
 				ospf_exit_reason2str(ospf->last_exit_reason));
-		}
 
 		if (ospf->active_restarter_cnt)
 			json_object_int_add(json_vrf, "activeRestarterCnt",
@@ -10237,17 +10250,12 @@ CPP_NOTICE("Remove JSON object commands
 				continue;
 
 			if (uj) {
-				json_object_object_get_ex(json_vrf, "Neighbors",
-							  &json_neighbors);
 				json_object_object_get_ex(json_vrf, "neighbors",
 							  &json_neighbors);
 				if (!json_neighbors) {
 					json_neighbors =
 						json_object_new_object();
 					json_object_object_add(json_vrf,
-							       "Neighbors",
-							       json_neighbors);
-					json_object_object_add(json_vrf,
 							       "neighbors",
 							       json_neighbors);
 				}
@@ -10531,28 +10539,18 @@ DEFUN (no_ospf_route_aggregation_timer,
 
 static void config_write_stub_router(struct vty *vty, struct ospf *ospf)
 {
-	struct listnode *ln;
-	struct ospf_area *area;
-
 	if (ospf->stub_router_startup_time != OSPF_STUB_ROUTER_UNCONFIGURED)
 		vty_out(vty, " max-metric router-lsa on-startup %u\n",
 			ospf->stub_router_startup_time);
 	if (ospf->stub_router_shutdown_time != OSPF_STUB_ROUTER_UNCONFIGURED)
 		vty_out(vty, " max-metric router-lsa on-shutdown %u\n",
 			ospf->stub_router_shutdown_time);
-	for (ALL_LIST_ELEMENTS_RO(ospf->areas, ln, area)) {
-		if (CHECK_FLAG(area->stub_router_state,
-			       OSPF_AREA_ADMIN_STUB_ROUTED)) {
-			vty_out(vty, " max-metric router-lsa administrative\n");
-			break;
-		}
-	}
+	if (ospf->stub_router_admin_set == OSPF_STUB_ROUTER_ADMINISTRATIVE_SET)
+		vty_out(vty, " max-metric router-lsa administrative\n");
+
 	return;
 }
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys containing whitespaces")
-#endif
 static void show_ip_ospf_route_network(struct vty *vty, struct ospf *ospf,
 				       struct route_table *rt,
 				       json_object *json)
@@ -10656,12 +10654,6 @@ static void show_ip_ospf_route_network(s
 								"ip", " ");
 							json_object_string_add(
 								json_nexthop,
-								"directly attached to",
-								ifindex2ifname(
-									path->ifindex,
-									ospf->vrf_id));
-							json_object_string_add(
-								json_nexthop,
 								"directlyAttachedTo",
 								ifindex2ifname(
 									path->ifindex,
@@ -10805,12 +10797,6 @@ static void show_ip_ospf_route_router(st
 								"ip", " ");
 							json_object_string_add(
 								json_nexthop,
-								"directly attached to",
-								ifindex2ifname(
-									path->ifindex,
-									ospf->vrf_id));
-							json_object_string_add(
-								json_nexthop,
 								"directlyAttachedTo",
 								ifindex2ifname(
 									path->ifindex,
@@ -10937,12 +10923,6 @@ static void show_ip_ospf_route_external(
 							" ");
 						json_object_string_add(
 							json_nexthop,
-							"directly attached to",
-							ifindex2ifname(
-								path->ifindex,
-								ospf->vrf_id));
-						json_object_string_add(
-							json_nexthop,
 							"directlyAttachedTo",
 							ifindex2ifname(
 								path->ifindex,
@@ -11092,15 +11072,38 @@ DEFUN (show_ip_ospf_instance_reachable_r
 
 static int show_ip_ospf_border_routers_common(struct vty *vty,
 					      struct ospf *ospf,
-					      uint8_t use_vrf)
+					      uint8_t use_vrf,
+					      json_object *json)
 {
-	if (ospf->instance)
-		vty_out(vty, "\nOSPF Instance: %d\n\n", ospf->instance);
+	json_object *json_vrf = NULL;
+	json_object *json_router = NULL;
 
-	ospf_show_vrf_name(ospf, vty, NULL, use_vrf);
+	if (json) {
+		if (use_vrf)
+			json_vrf = json_object_new_object();
+		else
+			json_vrf = json;
+		json_router = json_object_new_object();
+	}
+
+	if (ospf->instance) {
+		if (!json)
+			vty_out(vty, "\nOSPF Instance: %d\n\n", ospf->instance);
+		else
+			json_object_int_add(json_vrf, "ospfInstance",
+					    ospf->instance);
+	}
+
+	ospf_show_vrf_name(ospf, vty, json_vrf, use_vrf);
 
 	if (ospf->new_table == NULL) {
-		vty_out(vty, "No OSPF routing information exist\n");
+		if (!json)
+			vty_out(vty, "No OSPF routing information exist\n");
+		else {
+			json_object_free(json_router);
+			if (use_vrf)
+				json_object_free(json_vrf);
+		}
 		return CMD_SUCCESS;
 	}
 
@@ -11108,22 +11111,35 @@ static int show_ip_ospf_border_routers_c
 	show_ip_ospf_route_network (vty, ospf->new_table);   */
 
 	/* Show Router routes. */
-	show_ip_ospf_route_router(vty, ospf, ospf->new_rtrs, NULL);
+	show_ip_ospf_route_router(vty, ospf, ospf->new_rtrs, json_router);
 
-	vty_out(vty, "\n");
+	if (json) {
+		json_object_object_add(json_vrf, "routers", json_router);
+		if (use_vrf) {
+			if (ospf->vrf_id == VRF_DEFAULT)
+				json_object_object_add(json, "default",
+						       json_vrf);
+			else
+				json_object_object_add(json, ospf->name,
+						       json_vrf);
+		}
+	} else {
+		vty_out(vty, "\n");
+	}
 
 	return CMD_SUCCESS;
 }
 
-DEFUN (show_ip_ospf_border_routers,
+DEFPY (show_ip_ospf_border_routers,
        show_ip_ospf_border_routers_cmd,
-       "show ip ospf [vrf <NAME|all>] border-routers",
+       "show ip ospf [vrf <NAME|all>] border-routers [json]",
        SHOW_STR
        IP_STR
        "OSPF information\n"
        VRF_CMD_HELP_STR
        "All VRFs\n"
-       "Show all the ABR's and ASBR's\n")
+       "Show all the ABR's and ASBR's\n"
+       JSON_STR)
 {
 	struct ospf *ospf = NULL;
 	struct listnode *node = NULL;
@@ -11133,6 +11149,11 @@ DEFUN (show_ip_ospf_border_routers,
 	int inst = 0;
 	int idx_vrf = 0;
 	uint8_t use_vrf = 0;
+	bool uj = use_json(argc, argv);
+	json_object *json = NULL;
+
+	if (uj)
+		json = json_object_new_object();
 
 	OSPF_FIND_VRF_ARGS(argv, argc, idx_vrf, vrf_name, all_vrf);
 
@@ -11148,32 +11169,47 @@ DEFUN (show_ip_ospf_border_routers,
 
 				ospf_output = true;
 				ret = show_ip_ospf_border_routers_common(
-					vty, ospf, use_vrf);
+					vty, ospf, use_vrf, json);
 			}
 
-			if (!ospf_output)
+			if (uj)
+				vty_json(vty, json);
+			else if (!ospf_output)
 				vty_out(vty, "%% OSPF is not enabled\n");
+
+			return ret;
 		} else {
 			ospf = ospf_lookup_by_inst_name(inst, vrf_name);
 			if (ospf == NULL || !ospf->oi_running) {
-				vty_out(vty,
-					"%% OSPF is not enabled in vrf %s\n",
-					vrf_name);
+				if (uj)
+					vty_json(vty, json);
+				else
+					vty_out(vty,
+						"%% OSPF is not enabled in vrf %s\n",
+						vrf_name);
+
 				return CMD_SUCCESS;
 			}
-
-			ret = show_ip_ospf_border_routers_common(vty, ospf,
-								 use_vrf);
 		}
 	} else {
 		/* Display default ospf (instance 0) info */
 		ospf = ospf_lookup_by_vrf_id(VRF_DEFAULT);
 		if (ospf == NULL || !ospf->oi_running) {
-			vty_out(vty, "%% OSPF is not enabled in vrf default\n");
+			if (uj)
+				vty_json(vty, json);
+			else
+				vty_out(vty,
+					"%% OSPF is not enabled in vrf default\n");
+
 			return CMD_SUCCESS;
 		}
+	}
 
-		ret = show_ip_ospf_border_routers_common(vty, ospf, use_vrf);
+	if (ospf) {
+		ret = show_ip_ospf_border_routers_common(vty, ospf, use_vrf,
+							 json);
+		if (uj)
+			vty_json(vty, json);
 	}
 
 	return ret;
@@ -11200,7 +11236,7 @@ DEFUN (show_ip_ospf_instance_border_rout
 	if (!ospf || !ospf->oi_running)
 		return CMD_SUCCESS;
 
-	return show_ip_ospf_border_routers_common(vty, ospf, 0);
+	return show_ip_ospf_border_routers_common(vty, ospf, 0, NULL);
 }
 
 static int show_ip_ospf_route_common(struct vty *vty, struct ospf *ospf,
@@ -11222,7 +11258,12 @@ static int show_ip_ospf_route_common(str
 	ospf_show_vrf_name(ospf, vty, json_vrf, use_vrf);
 
 	if (ospf->new_table == NULL) {
-		vty_out(vty, "No OSPF routing information exist\n");
+		if (json) {
+			if (use_vrf)
+				json_object_free(json_vrf);
+		} else {
+			vty_out(vty, "No OSPF routing information exist\n");
+		}
 		return CMD_SUCCESS;
 	}
 
@@ -11590,8 +11631,6 @@ static int ospf_show_summary_address(str
 		vty_out(vty, "aggregation delay interval :%u(in seconds)\n\n",
 			ospf->aggr_delay_interval);
 	} else {
-		json_object_int_add(json_vrf, "aggregation delay interval",
-				    ospf->aggr_delay_interval);
 		json_object_int_add(json_vrf, "aggregationDelayInterval",
 				    ospf->aggr_delay_interval);
 	}
@@ -11610,37 +11649,17 @@ static int ospf_show_summary_address(str
 
 				json_object_object_add(json_vrf, buf,
 						       json_aggr);
-
-				json_object_string_add(json_aggr,
-						       "Summary address", buf);
 				json_object_string_add(json_aggr,
 						       "summaryAddress", buf);
-
-				json_object_string_add(
-					json_aggr, "Metric-type",
-					(mtype == EXTERNAL_METRIC_TYPE_1)
-						? "E1"
-						: "E2");
 				json_object_string_add(
 					json_aggr, "metricType",
 					(mtype == EXTERNAL_METRIC_TYPE_1)
 						? "E1"
 						: "E2");
 
-#if CONFDATE > 20230131
-CPP_NOTICE("Remove JSON object commands with keys starting with capital")
-#endif
-				json_object_int_add(json_aggr, "Metric", mval);
 				json_object_int_add(json_aggr, "metric", mval);
-
-				json_object_int_add(json_aggr, "Tag",
-						    aggr->tag);
 				json_object_int_add(json_aggr, "tag",
 						    aggr->tag);
-
-				json_object_int_add(
-					json_aggr, "External route count",
-					OSPF_EXTERNAL_RT_COUNT(aggr));
 				json_object_int_add(
 					json_aggr, "externalRouteCount",
 					OSPF_EXTERNAL_RT_COUNT(aggr));
diff -urpN frr-frr-8.4.2/ospfd/ospfd.c frr-frr-8.5/ospfd/ospfd.c
--- frr-frr-8.4.2/ospfd/ospfd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/ospfd.c	2023-03-13 20:01:47.000000000 +0600
@@ -851,6 +851,10 @@ static void ospf_finish_final(struct osp
 			ospf_route_delete(ospf, ospf->new_table);
 		ospf_route_table_free(ospf->new_table);
 	}
+	if (ospf->oall_rtrs)
+		ospf_rtrs_free(ospf->oall_rtrs);
+	if (ospf->all_rtrs)
+		ospf_rtrs_free(ospf->all_rtrs);
 	if (ospf->old_rtrs)
 		ospf_rtrs_free(ospf->old_rtrs);
 	if (ospf->new_rtrs)
diff -urpN frr-frr-8.4.2/ospfd/subdir.am frr-frr-8.5/ospfd/subdir.am
--- frr-frr-8.4.2/ospfd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ospfd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,19 +4,8 @@
 
 if OSPFD
 noinst_LIBRARIES += ospfd/libfrrospf.a
+noinst_LIBRARIES += ospfd/libfrrospfclient.a
 sbin_PROGRAMS += ospfd/ospfd
-vtysh_scan += \
-	ospfd/ospf_bfd.c \
-	ospfd/ospf_dump.c \
-	ospfd/ospf_gr.c \
-	ospfd/ospf_ldp_sync.c \
-	ospfd/ospf_opaque.c \
-	ospfd/ospf_ri.c \
-	ospfd/ospf_routemap.c \
-	ospfd/ospf_te.c \
-	ospfd/ospf_sr.c \
-	ospfd/ospf_vty.c \
-	# end
 vtysh_daemons += ospfd
 if SNMP
 module_LTLIBRARIES += ospfd/ospfd_snmp.la
@@ -24,6 +13,11 @@ endif
 man8 += $(MANBUILD)/frr-ospfd.8
 endif
 
+ospfd_libfrrospfclient_a_SOURCES = \
+	ospfd/ospf_api.c \
+	ospfd/ospf_dump_api.c \
+	#end
+
 ospfd_libfrrospf_a_SOURCES = \
 	ospfd/ospf_abr.c \
 	ospfd/ospf_api.c \
@@ -114,7 +108,7 @@ noinst_HEADERS += \
 	ospfd/ospf_zebra.h \
 	# end
 
-ospfd_ospfd_LDADD = ospfd/libfrrospf.a lib/libfrr.la $(LIBCAP) $(LIBM)
+ospfd_ospfd_LDADD = ospfd/libfrrospf.a ospfd/libfrrospfclient.a lib/libfrr.la $(LIBCAP) $(LIBM)
 ospfd_ospfd_SOURCES = ospfd/ospf_main.c
 
 ospfd_ospfd_snmp_la_SOURCES = ospfd/ospf_snmp.c
diff -urpN frr-frr-8.4.2/pathd/path_cli.c frr-frr-8.5/pathd/path_cli.c
--- frr-frr-8.4.2/pathd/path_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -31,9 +31,7 @@
 
 #include "pathd/pathd.h"
 #include "pathd/path_nb.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "pathd/path_cli_clippy.c"
-#endif
 #include "pathd/path_ted.h"
 
 #define XPATH_MAXATTRSIZE 64
@@ -128,7 +126,7 @@ DEFPY(show_srte_policy,
 	ttable_rowseps(tt, 0, BOTTOM, true, '-');
 
 	RB_FOREACH (policy, srte_policy_head, &srte_policies) {
-		char endpoint[46];
+		char endpoint[ENDPOINT_STR_LENGTH];
 		char binding_sid[16] = "-";
 
 		ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
@@ -175,7 +173,7 @@ DEFPY(show_srte_policy_detail,
 	vty_out(vty, "\n");
 	RB_FOREACH (policy, srte_policy_head, &srte_policies) {
 		struct srte_candidate *candidate;
-		char endpoint[46];
+		char endpoint[ENDPOINT_STR_LENGTH];
 		char binding_sid[16] = "-";
 		char *segment_list_info;
 		static char undefined_info[] = "(undefined)";
@@ -1092,7 +1090,26 @@ DEFPY_NOSH(show_debugging_pathd, show_de
 	   "State of each debugging option\n"
 	   "pathd module debugging\n")
 {
+
+	vty_out(vty, "Path debugging status:\n");
+
+	cmd_show_lib_debugs(vty);
 	/* nothing to do here */
+	path_ted_show_debugging(vty);
+	path_policy_show_debugging(vty);
+	return CMD_SUCCESS;
+}
+
+DEFPY(debug_path_policy, debug_path_policy_cmd, "[no] debug pathd policy",
+      NO_STR DEBUG_STR
+      "path debugging\n"
+      "policy debugging\n")
+{
+	uint32_t mode = DEBUG_NODE2MODE(vty->node);
+	bool no_debug = no;
+
+	DEBUG_MODE_SET(&path_policy_debug, mode, !no);
+	DEBUG_FLAGS_SET(&path_policy_debug, PATH_POLICY_DEBUG_BASIC, !no_debug);
 	return CMD_SUCCESS;
 }
 
@@ -1291,8 +1308,34 @@ int config_write_segment_routing(struct
 	return 1;
 }
 
+static int path_policy_cli_debug_config_write(struct vty *vty)
+{
+	if (DEBUG_MODE_CHECK(&path_policy_debug, DEBUG_MODE_CONF)) {
+		if (DEBUG_FLAGS_CHECK(&path_policy_debug,
+				      PATH_POLICY_DEBUG_BASIC))
+			vty_out(vty, "debug pathd policy\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int path_policy_cli_debug_set_all(uint32_t flags, bool set)
+{
+	DEBUG_FLAGS_SET(&path_policy_debug, flags, set);
+
+	/* If all modes have been turned off, don't preserve options. */
+	if (!DEBUG_MODE_CHECK(&path_policy_debug, DEBUG_MODE_ALL))
+		DEBUG_CLEAR(&path_policy_debug);
+
+	return 0;
+}
+
 void path_cli_init(void)
 {
+	hook_register(nb_client_debug_config_write,
+		      path_policy_cli_debug_config_write);
+	hook_register(nb_client_debug_set_all, path_policy_cli_debug_set_all);
+
 	install_node(&segment_routing_node);
 	install_node(&sr_traffic_eng_node);
 	install_node(&srte_segment_list_node);
@@ -1308,6 +1351,9 @@ void path_cli_init(void)
 	install_element(ENABLE_NODE, &show_srte_policy_cmd);
 	install_element(ENABLE_NODE, &show_srte_policy_detail_cmd);
 
+	install_element(ENABLE_NODE, &debug_path_policy_cmd);
+	install_element(CONFIG_NODE, &debug_path_policy_cmd);
+
 	install_element(CONFIG_NODE, &segment_routing_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &sr_traffic_eng_cmd);
 	install_element(SR_TRAFFIC_ENG_NODE, &srte_segment_list_cmd);
diff -urpN frr-frr-8.4.2/pathd/path_nb.c frr-frr-8.5/pathd/path_nb.c
--- frr-frr-8.4.2/pathd/path_nb.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_nb.c	2023-03-13 20:01:47.000000000 +0600
@@ -310,7 +310,7 @@ void iter_objfun_prefs(const struct lyd_
 	struct of_cb_args args = {0};
 	struct of_cb_pref *p;
 
-	yang_dnode_iterate(iter_objfun_cb, &args, dnode, path);
+	yang_dnode_iterate(iter_objfun_cb, &args, dnode, "%s", path);
 	for (p = args.first; p != NULL; p = p->next)
 		fun(p->type, arg);
 }
diff -urpN frr-frr-8.4.2/pathd/path_pcep_cli.c frr-frr-8.5/pathd/path_pcep_cli.c
--- frr-frr-8.4.2/pathd/path_pcep_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_pcep_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -40,9 +40,7 @@
 #include "pathd/path_pcep_lib.h"
 #include "pathd/path_pcep_pcc.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pathd/path_pcep_cli_clippy.c"
-#endif
 
 #define DEFAULT_PCE_PRECEDENCE 255
 #define DEFAULT_PCC_MSD 4
diff -urpN frr-frr-8.4.2/pathd/path_pcep_config.c frr-frr-8.5/pathd/path_pcep_config.c
--- frr-frr-8.4.2/pathd/path_pcep_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_pcep_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -453,8 +453,7 @@ int path_pcep_config_update_path(struct
 	}
 
 	if (number_of_sid_clashed)
-		SET_FLAG(segment->segment_list->flags,
-			 F_SEGMENT_LIST_SID_CONFLICT);
+		SET_FLAG(segment_list->flags, F_SEGMENT_LIST_SID_CONFLICT);
 	else
 		srte_apply_changes();
 
diff -urpN frr-frr-8.4.2/pathd/path_pcep_lib.c frr-frr-8.5/pathd/path_pcep_lib.c
--- frr-frr-8.4.2/pathd/path_pcep_lib.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_pcep_lib.c	2023-03-13 20:01:47.000000000 +0600
@@ -38,7 +38,8 @@ DEFINE_MTYPE_STATIC(PATHD, PCEPLIB_MESSA
 #define MAX_PATH_NAME_SIZE 255
 
 /* pceplib logging callback */
-static int pceplib_logging_cb(int level, const char *fmt, va_list args);
+static int pceplib_logging_cb(int level, const char *fmt, va_list args)
+	PRINTFRR(2, 0);
 
 /* Socket callbacks */
 static int pcep_lib_pceplib_socket_read_cb(void *fpt, void **thread, int fd,
diff -urpN frr-frr-8.4.2/pathd/path_ted.c frr-frr-8.5/pathd/path_ted.c
--- frr-frr-8.4.2/pathd/path_ted.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_ted.c	2023-03-13 20:01:47.000000000 +0600
@@ -29,9 +29,7 @@
 #include "pathd/path_errors.h"
 #include "pathd/path_ted.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pathd/path_ted_clippy.c"
-#endif
 
 static struct ls_ted *path_ted_create_ted(void);
 static void path_ted_register_vty(void);
@@ -162,7 +160,7 @@ bool path_ted_is_initialized(void)
  *
  * @return		Ptr to ted or NULL
  */
-struct ls_ted *path_ted_create_ted()
+struct ls_ted *path_ted_create_ted(void)
 {
 	struct ls_ted *ted = ls_ted_new(TED_KEY, TED_NAME, TED_ASN);
 
@@ -490,6 +488,12 @@ int path_ted_cli_debug_config_write(stru
 	return 0;
 }
 
+void path_ted_show_debugging(struct vty *vty)
+{
+	if (DEBUG_FLAGS_CHECK(&ted_state_g.dbg, PATH_TED_DEBUG_BASIC))
+		vty_out(vty, "  Path TED debugging is on\n");
+}
+
 int path_ted_cli_debug_set_all(uint32_t flags, bool set)
 {
 	DEBUG_FLAGS_SET(&ted_state_g.dbg, flags, set);
diff -urpN frr-frr-8.4.2/pathd/path_ted.h frr-frr-8.5/pathd/path_ted.h
--- frr-frr-8.4.2/pathd/path_ted.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/path_ted.h	2023-03-13 20:01:47.000000000 +0600
@@ -101,6 +101,7 @@ int path_ted_segment_list_refresh(void);
 
 /* TED configuration functions */
 uint32_t path_ted_config_write(struct vty *vty);
+void path_ted_show_debugging(struct vty *vty);
 
 /* TED util functions */
 /* clang-format off */
diff -urpN frr-frr-8.4.2/pathd/pathd.c frr-frr-8.5/pathd/pathd.c
--- frr-frr-8.4.2/pathd/pathd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/pathd.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,6 +23,8 @@
 #include "lib_errors.h"
 #include "network.h"
 #include "libfrr.h"
+#include <debug.h>
+#include <hook.h>
 
 #include "pathd/pathd.h"
 #include "pathd/path_zebra.h"
@@ -44,6 +46,17 @@ DEFINE_HOOK(pathd_candidate_updated, (st
 DEFINE_HOOK(pathd_candidate_removed, (struct srte_candidate * candidate),
 	    (candidate));
 
+struct debug path_policy_debug;
+
+#define PATH_POLICY_DEBUG(fmt, ...)                                            \
+	do {                                                                   \
+		if (DEBUG_FLAGS_CHECK(&path_policy_debug,                      \
+				      PATH_POLICY_DEBUG_BASIC))                \
+			DEBUGD(&path_policy_debug, "policy: " fmt,             \
+			       ##__VA_ARGS__);                                 \
+	} while (0)
+
+
 static void trigger_pathd_candidate_created(struct srte_candidate *candidate);
 static void trigger_pathd_candidate_created_timer(struct thread *thread);
 static void trigger_pathd_candidate_updated(struct srte_candidate *candidate);
@@ -97,6 +110,20 @@ RB_GENERATE(srte_policy_head, srte_polic
 
 struct srte_policy_head srte_policies = RB_INITIALIZER(&srte_policies);
 
+static void srte_policy_status_log(struct srte_policy *policy)
+{
+	char endpoint[ENDPOINT_STR_LENGTH];
+
+	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
+	if (policy->status == SRTE_POLICY_STATUS_DOWN) {
+		PATH_POLICY_DEBUG("SR-TE(%s, %u): policy is DOWN", endpoint,
+				  policy->color);
+	} else if (policy->status == SRTE_POLICY_STATUS_UP) {
+		PATH_POLICY_DEBUG("SR-TE(%s, %u): policy is UP", endpoint,
+				  policy->color);
+	}
+}
+
 /**
  * Adds a segment list to pathd.
  *
@@ -531,6 +558,10 @@ void srte_apply_changes(void)
 
 	RB_FOREACH_SAFE (policy, srte_policy_head, &srte_policies, safe_pol) {
 		if (CHECK_FLAG(policy->flags, F_POLICY_DELETED)) {
+			if (policy->status != SRTE_POLICY_STATUS_DOWN) {
+				policy->status = SRTE_POLICY_STATUS_DOWN;
+				srte_policy_status_log(policy);
+			}
 			srte_policy_del(policy);
 			continue;
 		}
@@ -565,7 +596,7 @@ void srte_policy_apply_changes(struct sr
 	struct srte_candidate *candidate, *safe;
 	struct srte_candidate *old_best_candidate;
 	struct srte_candidate *new_best_candidate;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
 
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
 
@@ -574,8 +605,7 @@ void srte_policy_apply_changes(struct sr
 	new_best_candidate = srte_policy_best_candidate(policy);
 
 	if (new_best_candidate != old_best_candidate) {
-		/* TODO: add debug guard. */
-		zlog_debug(
+		PATH_POLICY_DEBUG(
 			"SR-TE(%s, %u): best candidate changed from %s to %s",
 			endpoint, policy->color,
 			old_best_candidate ? old_best_candidate->name : "none",
@@ -617,10 +647,10 @@ void srte_policy_apply_changes(struct sr
 				   F_SEGMENT_LIST_MODIFIED);
 
 		if (candidate_changed || segment_list_changed) {
-			/* TODO: add debug guard. */
-			zlog_debug("SR-TE(%s, %u): best candidate %s changed",
-				   endpoint, policy->color,
-				   new_best_candidate->name);
+			PATH_POLICY_DEBUG(
+				"SR-TE(%s, %u): best candidate %s changed",
+				endpoint, policy->color,
+				new_best_candidate->name);
 
 			path_zebra_add_sr_policy(
 				policy, new_best_candidate->lsp->segment_list);
@@ -722,10 +752,10 @@ void srte_candidate_set_bandwidth(struct
 				  float bandwidth, bool required)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
 
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug(
+	PATH_POLICY_DEBUG(
 		"SR-TE(%s, %u): candidate %s %sconfig bandwidth set to %f B/s",
 		endpoint, policy->color, candidate->name,
 		required ? "required " : "", bandwidth);
@@ -750,11 +780,13 @@ void srte_lsp_set_bandwidth(struct srte_
 {
 	struct srte_candidate *candidate = lsp->candidate;
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): candidate %s %slsp bandwidth set to %f B/s",
-		   endpoint, policy->color, candidate->name,
-		   required ? "required" : "", bandwidth);
+	PATH_POLICY_DEBUG(
+		"SR-TE(%s, %u): candidate %s %slsp bandwidth set to %f B/s",
+		endpoint, policy->color, candidate->name,
+		required ? "required" : "", bandwidth);
 	SET_FLAG(lsp->flags, F_CANDIDATE_HAS_BANDWIDTH);
 	COND_FLAG(lsp->flags, F_CANDIDATE_REQUIRED_BANDWIDTH, required);
 	lsp->bandwidth = bandwidth;
@@ -770,10 +802,11 @@ void srte_lsp_set_bandwidth(struct srte_
 void srte_candidate_unset_bandwidth(struct srte_candidate *candidate)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): candidate %s config bandwidth unset",
-		   endpoint, policy->color, candidate->name);
+	PATH_POLICY_DEBUG("SR-TE(%s, %u): candidate %s config bandwidth unset",
+			  endpoint, policy->color, candidate->name);
 	UNSET_FLAG(candidate->flags, F_CANDIDATE_HAS_BANDWIDTH);
 	UNSET_FLAG(candidate->flags, F_CANDIDATE_REQUIRED_BANDWIDTH);
 	candidate->bandwidth = 0;
@@ -792,10 +825,11 @@ void srte_lsp_unset_bandwidth(struct srt
 {
 	struct srte_candidate *candidate = lsp->candidate;
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): candidate %s lsp bandwidth unset", endpoint,
-		   policy->color, candidate->name);
+	PATH_POLICY_DEBUG("SR-TE(%s, %u): candidate %s lsp bandwidth unset",
+			  endpoint, policy->color, candidate->name);
 	UNSET_FLAG(lsp->flags, F_CANDIDATE_HAS_BANDWIDTH);
 	UNSET_FLAG(lsp->flags, F_CANDIDATE_REQUIRED_BANDWIDTH);
 	SET_FLAG(candidate->flags, F_CANDIDATE_MODIFIED);
@@ -820,9 +854,10 @@ void srte_candidate_set_metric(struct sr
 			       bool is_computed)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug(
+	PATH_POLICY_DEBUG(
 		"SR-TE(%s, %u): candidate %s %sconfig metric %s (%u) set to %f (is-bound: %s; is_computed: %s)",
 		endpoint, policy->color, candidate->name,
 		required ? "required " : "", srte_candidate_metric_name(type),
@@ -854,9 +889,10 @@ void srte_lsp_set_metric(struct srte_lsp
 {
 	struct srte_candidate *candidate = lsp->candidate;
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug(
+	PATH_POLICY_DEBUG(
 		"SR-TE(%s, %u): candidate %s %slsp metric %s (%u) set to %f (is-bound: %s; is_computed: %s)",
 		endpoint, policy->color, candidate->name,
 		required ? "required " : "", srte_candidate_metric_name(type),
@@ -889,11 +925,13 @@ void srte_candidate_unset_metric(struct
 				 enum srte_candidate_metric_type type)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): candidate %s config metric %s (%u) unset",
-		   endpoint, policy->color, candidate->name,
-		   srte_candidate_metric_name(type), type);
+	PATH_POLICY_DEBUG(
+		"SR-TE(%s, %u): candidate %s config metric %s (%u) unset",
+		endpoint, policy->color, candidate->name,
+		srte_candidate_metric_name(type), type);
 	assert((type > 0) && (type <= MAX_METRIC_TYPE));
 	srte_unset_metric(&candidate->metrics[type - 1]);
 	srte_lsp_unset_metric(candidate->lsp, type);
@@ -913,11 +951,13 @@ void srte_lsp_unset_metric(struct srte_l
 {
 	struct srte_candidate *candidate = lsp->candidate;
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): candidate %s lsp metric %s (%u) unset",
-		   endpoint, policy->color, candidate->name,
-		   srte_candidate_metric_name(type), type);
+	PATH_POLICY_DEBUG(
+		"SR-TE(%s, %u): candidate %s lsp metric %s (%u) unset",
+		endpoint, policy->color, candidate->name,
+		srte_candidate_metric_name(type), type);
 	assert((type > 0) && (type <= MAX_METRIC_TYPE));
 	srte_unset_metric(&lsp->metrics[type - 1]);
 }
@@ -941,16 +981,18 @@ void srte_candidate_set_objfun(struct sr
 			       enum objfun_type type)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
 
 	candidate->objfun = type;
 	SET_FLAG(candidate->flags, F_CANDIDATE_HAS_OBJFUN);
 	COND_FLAG(candidate->flags, F_CANDIDATE_REQUIRED_OBJFUN, required);
 	SET_FLAG(candidate->flags, F_CANDIDATE_MODIFIED);
-	zlog_debug("SR-TE(%s, %u): candidate %s %sobjective function set to %s",
-		   endpoint, policy->color, candidate->name,
-		   required ? "required " : "", objfun_type_name(type));
+	PATH_POLICY_DEBUG(
+		"SR-TE(%s, %u): candidate %s %sobjective function set to %s",
+		endpoint, policy->color, candidate->name,
+		required ? "required " : "", objfun_type_name(type));
 }
 
 /**
@@ -961,14 +1003,15 @@ void srte_candidate_set_objfun(struct sr
 void srte_candidate_unset_objfun(struct srte_candidate *candidate)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
 
 	UNSET_FLAG(candidate->flags, F_CANDIDATE_HAS_OBJFUN);
 	UNSET_FLAG(candidate->flags, F_CANDIDATE_REQUIRED_OBJFUN);
 	SET_FLAG(candidate->flags, F_CANDIDATE_MODIFIED);
 	candidate->objfun = OBJFUN_UNDEFINED;
-	zlog_debug(
+	PATH_POLICY_DEBUG(
 		"SR-TE(%s, %u): candidate %s objective functions preferences unset",
 		endpoint, policy->color, candidate->name);
 }
@@ -1013,7 +1056,8 @@ void srte_candidate_set_affinity_filter(
 					uint32_t filter)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
 
 	assert(type > AFFINITY_FILTER_UNDEFINED);
@@ -1021,7 +1065,7 @@ void srte_candidate_set_affinity_filter(
 	SET_FLAG(candidate->flags, filter_type_to_flag(type));
 	SET_FLAG(candidate->flags, F_CANDIDATE_MODIFIED);
 	candidate->affinity_filters[type - 1] = filter;
-	zlog_debug(
+	PATH_POLICY_DEBUG(
 		"SR-TE(%s, %u): candidate %s affinity filter %s set to 0x%08x",
 		endpoint, policy->color, candidate->name,
 		filter_type_name(type), filter);
@@ -1038,7 +1082,8 @@ void srte_candidate_unset_affinity_filte
 					  enum affinity_filter_type type)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
 
 	assert(type > AFFINITY_FILTER_UNDEFINED);
@@ -1046,9 +1091,10 @@ void srte_candidate_unset_affinity_filte
 	UNSET_FLAG(candidate->flags, filter_type_to_flag(type));
 	SET_FLAG(candidate->flags, F_CANDIDATE_MODIFIED);
 	candidate->affinity_filters[type - 1] = 0;
-	zlog_debug("SR-TE(%s, %u): candidate %s affinity filter %s unset",
-		   endpoint, policy->color, candidate->name,
-		   filter_type_name(type));
+	PATH_POLICY_DEBUG(
+		"SR-TE(%s, %u): candidate %s affinity filter %s unset",
+		endpoint, policy->color, candidate->name,
+		filter_type_name(type));
 }
 
 /**
@@ -1093,10 +1139,11 @@ srte_segment_entry_find(struct srte_segm
 void srte_candidate_status_update(struct srte_candidate *candidate, int status)
 {
 	struct srte_policy *policy = candidate->policy;
-	char endpoint[46];
+	char endpoint[ENDPOINT_STR_LENGTH];
+
 	ipaddr2str(&policy->endpoint, endpoint, sizeof(endpoint));
-	zlog_debug("SR-TE(%s, %u): zebra updated status to %d", endpoint,
-		   policy->color, status);
+	PATH_POLICY_DEBUG("SR-TE(%s, %u): zebra updated status to %d", endpoint,
+			  policy->color, status);
 	switch (status) {
 	case ZEBRA_SR_POLICY_DOWN:
 		switch (policy->status) {
@@ -1109,9 +1156,8 @@ void srte_candidate_status_update(struct
 		case SRTE_POLICY_STATUS_DOWN:
 			return;
 		default:
-			zlog_debug("SR-TE(%s, %u): policy is DOWN", endpoint,
-				   policy->color);
 			policy->status = SRTE_POLICY_STATUS_DOWN;
+			srte_policy_status_log(policy);
 			break;
 		}
 		break;
@@ -1120,9 +1166,8 @@ void srte_candidate_status_update(struct
 		case SRTE_POLICY_STATUS_UP:
 			return;
 		default:
-			zlog_debug("SR-TE(%s, %u): policy is UP", endpoint,
-				   policy->color);
 			policy->status = SRTE_POLICY_STATUS_UP;
+			srte_policy_status_log(policy);
 			break;
 		}
 		break;
@@ -1148,19 +1193,20 @@ void srte_candidate_unset_segment_list(c
 		return;
 	}
 
-	zlog_debug("Unset segment lists for originator %s", originator);
+	PATH_POLICY_DEBUG("Unset segment lists for originator %s", originator);
 
 	/* Iterate the policies, then iterate each policy's candidate path
 	 * to check the candidate path's segment list originator */
 	struct srte_policy *policy;
 	RB_FOREACH (policy, srte_policy_head, &srte_policies) {
-		zlog_debug("Unset segment lists checking policy %s",
-			   policy->name);
+		PATH_POLICY_DEBUG("Unset segment lists checking policy %s",
+				  policy->name);
 		struct srte_candidate *candidate;
 		RB_FOREACH (candidate, srte_candidate_head,
 			    &policy->candidate_paths) {
-			zlog_debug("Unset segment lists checking candidate %s",
-				   candidate->name);
+			PATH_POLICY_DEBUG(
+				"Unset segment lists checking candidate %s",
+				candidate->name);
 			if (candidate->lsp == NULL) {
 				continue;
 			}
@@ -1190,8 +1236,8 @@ void srte_candidate_unset_segment_list(c
 				    sizeof(segment_list->originator))
 				    == 0
 			    || force) {
-				zlog_debug("Unset segment list %s",
-					   segment_list->name);
+				PATH_POLICY_DEBUG("Unset segment list %s",
+						  segment_list->name);
 				SET_FLAG(segment_list->flags,
 					 F_SEGMENT_LIST_DELETED);
 				SET_FLAG(candidate->flags,
@@ -1222,6 +1268,12 @@ const char *srte_origin2str(enum srte_pr
 	}
 }
 
+void path_policy_show_debugging(struct vty *vty)
+{
+	if (DEBUG_FLAGS_CHECK(&path_policy_debug, PATH_POLICY_DEBUG_BASIC))
+		vty_out(vty, "  Path policy debugging is on\n");
+}
+
 void pathd_shutdown(void)
 {
 	path_ted_teardown();
@@ -1347,8 +1399,9 @@ int32_t srte_ted_do_query_type_c(struct
 		zlog_warn(" %s: PATHD-TED: SL: ERROR query C : ted-sid (%d)",
 			  __func__, ted_sid);
 	} else {
-		zlog_debug("%s: PATHD-TED: SL: Success query C : ted-sid (%d)",
-			   __func__, ted_sid);
+		PATH_TED_DEBUG(
+			"%s: PATHD-TED: SL: Success query C : ted-sid (%d)",
+			__func__, ted_sid);
 	}
 	if (CHECK_SID(entry->segment_list->protocol_origin, ted_sid,
 		      entry->sid_value)) {
@@ -1377,8 +1430,9 @@ int32_t srte_ted_do_query_type_e(struct
 		zlog_warn(" %s: PATHD-TED: SL: ERROR query E : ted-sid (%d)",
 			  __func__, ted_sid);
 	} else {
-		zlog_debug("%s: PATHD-TED: SL: Success query E : ted-sid (%d)",
-			   __func__, ted_sid);
+		PATH_TED_DEBUG(
+			"%s: PATHD-TED: SL: Success query E : ted-sid (%d)",
+			__func__, ted_sid);
 	}
 	if (CHECK_SID(entry->segment_list->protocol_origin, ted_sid,
 		      entry->sid_value)) {
@@ -1406,8 +1460,8 @@ int32_t srte_ted_do_query_type_f(struct
 		zlog_warn("%s:SL:  ERROR query F : ted-sid (%d)", __func__,
 			  ted_sid);
 	} else {
-		zlog_debug("%s:SL: Success query F : ted-sid (%d)", __func__,
-			   ted_sid);
+		PATH_TED_DEBUG("%s:SL: Success query F : ted-sid (%d)",
+			       __func__, ted_sid);
 	}
 	if (CHECK_SID(entry->segment_list->protocol_origin, ted_sid,
 		      entry->sid_value)) {
diff -urpN frr-frr-8.4.2/pathd/pathd.h frr-frr-8.5/pathd/pathd.h
--- frr-frr-8.4.2/pathd/pathd.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/pathd.h	2023-03-13 20:01:47.000000000 +0600
@@ -43,6 +43,10 @@ enum srte_protocol_origin {
 	SRTE_ORIGIN_LOCAL = 3,
 };
 
+extern struct debug path_policy_debug;
+
+#define PATH_POLICY_DEBUG_BASIC 0x01
+
 enum srte_policy_status {
 	SRTE_POLICY_STATUS_UNKNOWN = 0,
 	SRTE_POLICY_STATUS_DOWN = 1,
@@ -326,6 +330,8 @@ struct srte_candidate {
 RB_HEAD(srte_candidate_head, srte_candidate);
 RB_PROTOTYPE(srte_candidate_head, srte_candidate, entry, srte_candidate_compare)
 
+#define ENDPOINT_STR_LENGTH IPADDR_STRING_SIZE
+
 struct srte_policy {
 	RB_ENTRY(srte_policy) entry;
 
@@ -444,6 +450,7 @@ void srte_candidate_status_update(struct
 void srte_candidate_unset_segment_list(const char *originator, bool force);
 const char *srte_origin2str(enum srte_protocol_origin origin);
 void pathd_shutdown(void);
+void path_policy_show_debugging(struct vty *vty);
 
 /* path_cli.c */
 void path_cli_init(void);
diff -urpN frr-frr-8.4.2/pathd/subdir.am frr-frr-8.5/pathd/subdir.am
--- frr-frr-8.4.2/pathd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pathd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,16 +5,11 @@
 if PATHD
 noinst_LIBRARIES += pathd/libpath.a
 sbin_PROGRAMS += pathd/pathd
-vtysh_scan += \
-	pathd/path_cli.c \
-	pathd/path_ted.c \
-	#end
 vtysh_daemons += pathd
 # TODO add man page
 #man8 += $(MANBUILD)/pathd.8
 
 if PATHD_PCEP
-vtysh_scan += pathd/path_pcep_cli.c
 module_LTLIBRARIES += pathd/pathd_pcep.la
 endif
 
diff -urpN frr-frr-8.4.2/pbrd/pbr_debug.c frr-frr-8.5/pbrd/pbr_debug.c
--- frr-frr-8.4.2/pbrd/pbr_debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/pbr_debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,9 +23,7 @@
 #include "command.h"
 #include "vector.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pbrd/pbr_debug_clippy.c"
-#endif
 #include "pbrd/pbr_debug.h"
 
 struct debug pbr_dbg_map = {0, "PBR map"};
diff -urpN frr-frr-8.4.2/pbrd/pbr_main.c frr-frr-8.5/pbrd/pbr_main.c
--- frr-frr-8.4.2/pbrd/pbr_main.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/pbr_main.c	2023-03-13 20:01:47.000000000 +0600
@@ -160,10 +160,9 @@ int main(int argc, char **argv, char **e
 
 	pbr_debug_init();
 
-	nexthop_group_init(pbr_nhgroup_add_cb,
+	nexthop_group_init(pbr_nhgroup_add_cb, pbr_nhgroup_modify_cb,
 			   pbr_nhgroup_add_nexthop_cb,
-			   pbr_nhgroup_del_nexthop_cb,
-			   pbr_nhgroup_delete_cb);
+			   pbr_nhgroup_del_nexthop_cb, pbr_nhgroup_delete_cb);
 
 	/*
 	 * So we safely ignore these commands since
diff -urpN frr-frr-8.4.2/pbrd/pbr_nht.c frr-frr-8.5/pbrd/pbr_nht.c
--- frr-frr-8.4.2/pbrd/pbr_nht.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/pbr_nht.c	2023-03-13 20:01:47.000000000 +0600
@@ -229,6 +229,10 @@ void pbr_nhgroup_add_cb(const char *name
 	pbr_map_check_nh_group_change(name);
 }
 
+void pbr_nhgroup_modify_cb(const struct nexthop_group_cmd *nhgc)
+{
+}
+
 void pbr_nhgroup_add_nexthop_cb(const struct nexthop_group_cmd *nhgc,
 				const struct nexthop *nhop)
 {
diff -urpN frr-frr-8.4.2/pbrd/pbr_nht.h frr-frr-8.5/pbrd/pbr_nht.h
--- frr-frr-8.4.2/pbrd/pbr_nht.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/pbr_nht.h	2023-03-13 20:01:47.000000000 +0600
@@ -96,6 +96,7 @@ extern void pbr_nht_set_rule_range(uint3
 extern uint32_t pbr_nht_get_next_rule(uint32_t seqno);
 
 extern void pbr_nhgroup_add_cb(const char *name);
+extern void pbr_nhgroup_modify_cb(const struct nexthop_group_cmd *nhgc);
 extern void pbr_nhgroup_add_nexthop_cb(const struct nexthop_group_cmd *nhg,
 				       const struct nexthop *nhop);
 extern void pbr_nhgroup_del_nexthop_cb(const struct nexthop_group_cmd *nhg,
diff -urpN frr-frr-8.4.2/pbrd/pbr_vty.c frr-frr-8.5/pbrd/pbr_vty.c
--- frr-frr-8.4.2/pbrd/pbr_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/pbr_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -36,9 +36,7 @@
 #include "pbrd/pbr_zebra.h"
 #include "pbrd/pbr_vty.h"
 #include "pbrd/pbr_debug.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "pbrd/pbr_vty_clippy.c"
-#endif
 
 DEFUN_NOSH(pbr_map, pbr_map_cmd, "pbr-map PBRMAP seq (1-700)",
 	   "Create pbr-map or enter pbr-map command mode\n"
@@ -935,12 +933,12 @@ static void vty_show_pbrms(struct vty *v
 
 		if (detail)
 			vty_out(vty,
-				"          Installed: %u(%d) Tableid: %d\n",
+				"          Installed: %u(%d) Tableid: %u\n",
 				pbrms->nhs_installed,
 				pbr_nht_get_installed(pbrms->nhgrp_name),
 				pbr_nht_get_table(pbrms->nhgrp_name));
 		else
-			vty_out(vty, "          Installed: %s Tableid: %d\n",
+			vty_out(vty, "          Installed: %s Tableid: %u\n",
 				pbr_nht_get_installed(pbrms->nhgrp_name) ? "yes"
 									 : "no",
 				pbr_nht_get_table(pbrms->nhgrp_name));
@@ -950,12 +948,12 @@ static void vty_show_pbrms(struct vty *v
 		pbrms_nexthop_group_write_individual_nexthop(vty, pbrms);
 		if (detail)
 			vty_out(vty,
-				"          Installed: %u(%d) Tableid: %d\n",
+				"          Installed: %u(%d) Tableid: %u\n",
 				pbrms->nhs_installed,
 				pbr_nht_get_installed(pbrms->internal_nhg_name),
 				pbr_nht_get_table(pbrms->internal_nhg_name));
 		else
-			vty_out(vty, "          Installed: %s Tableid: %d\n",
+			vty_out(vty, "          Installed: %s Tableid: %u\n",
 				pbr_nht_get_installed(pbrms->internal_nhg_name)
 					? "yes"
 					: "no",
@@ -1243,6 +1241,8 @@ DEFUN_NOSH(show_debugging_pbr,
 
 	pbr_debug_config_write_helper(vty, false);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/pbrd/subdir.am frr-frr-8.5/pbrd/subdir.am
--- frr-frr-8.4.2/pbrd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pbrd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,10 +5,6 @@
 if PBRD
 noinst_LIBRARIES += pbrd/libpbr.a
 sbin_PROGRAMS += pbrd/pbrd
-vtysh_scan += \
-	pbrd/pbr_vty.c \
-	pbrd/pbr_debug.c \
-	# end
 vtysh_daemons += pbrd
 man8 += $(MANBUILD)/frr-pbrd.8
 endif
diff -urpN frr-frr-8.4.2/pceplib/pcep_msg_messages.c frr-frr-8.5/pceplib/pcep_msg_messages.c
--- frr-frr-8.4.2/pceplib/pcep_msg_messages.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_msg_messages.c	2023-03-13 20:01:47.000000000 +0600
@@ -163,7 +163,7 @@ pcep_msg_create_error_with_objects(uint8
 	return message;
 }
 
-struct pcep_message *pcep_msg_create_keepalive()
+struct pcep_message *pcep_msg_create_keepalive(void)
 {
 	return (pcep_msg_create_common(PCEP_TYPE_KEEPALIVE));
 }
diff -urpN frr-frr-8.4.2/pceplib/pcep_msg_messages_encoding.c frr-frr-8.5/pceplib/pcep_msg_messages_encoding.c
--- frr-frr-8.4.2/pceplib/pcep_msg_messages_encoding.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_msg_messages_encoding.c	2023-03-13 20:01:47.000000000 +0600
@@ -348,7 +348,7 @@ struct pcep_message *pcep_decode_message
 	return msg;
 }
 
-struct pcep_versioning *create_default_pcep_versioning()
+struct pcep_versioning *create_default_pcep_versioning(void)
 {
 	struct pcep_versioning *versioning =
 		pceplib_malloc(PCEPLIB_INFRA, sizeof(struct pcep_versioning));
diff -urpN frr-frr-8.4.2/pceplib/pcep_pcc.c frr-frr-8.5/pceplib/pcep_pcc.c
--- frr-frr-8.4.2/pceplib/pcep_pcc.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_pcc.c	2023-03-13 20:01:47.000000000 +0600
@@ -74,7 +74,6 @@ static const short DEFAULT_SRC_TCP_PORT
 // Private fn's
 struct cmd_line_args *get_cmdline_args(int argc, char *argv[]);
 void handle_signal_action(int sig_number);
-int setup_signals(void);
 void send_pce_path_request_message(pcep_session *session);
 void send_pce_report_message(pcep_session *session);
 void print_queue_event(struct pcep_event *event);
@@ -211,8 +210,7 @@ void handle_signal_action(int sig_number
 	}
 }
 
-
-int setup_signals()
+static int setup_signals(void)
 {
 	struct sigaction sa;
 	memset(&sa, 0, sizeof(sa));
diff -urpN frr-frr-8.4.2/pceplib/pcep_pcc_api.c frr-frr-8.5/pceplib/pcep_pcc_api.c
--- frr-frr-8.4.2/pceplib/pcep_pcc_api.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_pcc_api.c	2023-03-13 20:01:47.000000000 +0600
@@ -55,7 +55,7 @@ const char UNKNOWN_EVENT_STR[] = "UNKNOW
 /* Session Logic Handle managed in pcep_session_logic.c */
 extern pcep_event_queue *session_logic_event_queue_;
 
-bool initialize_pcc()
+bool initialize_pcc(void)
 {
 	if (!run_session_logic()) {
 		pcep_log(LOG_ERR, "%s: Error initializing PCC session logic.",
@@ -85,13 +85,13 @@ bool initialize_pcc_infra(struct pceplib
 
 
 /* this function is blocking */
-bool initialize_pcc_wait_for_completion()
+bool initialize_pcc_wait_for_completion(void)
 {
 	return run_session_logic_wait_for_completion();
 }
 
 
-bool destroy_pcc()
+bool destroy_pcc(void)
 {
 	if (!stop_session_logic()) {
 		pcep_log(LOG_WARNING, "%s: Error stopping PCC session logic.",
@@ -103,7 +103,7 @@ bool destroy_pcc()
 }
 
 
-pcep_configuration *create_default_pcep_configuration()
+pcep_configuration *create_default_pcep_configuration(void)
 {
 	pcep_configuration *config =
 		pceplib_malloc(PCEPLIB_INFRA, sizeof(pcep_configuration));
@@ -226,7 +226,7 @@ void send_message(pcep_session *session,
 }
 
 /* Returns true if the queue is empty, false otherwise */
-bool event_queue_is_empty()
+bool event_queue_is_empty(void)
 {
 	if (session_logic_event_queue_ == NULL) {
 		pcep_log(
@@ -246,7 +246,7 @@ bool event_queue_is_empty()
 
 
 /* Return the number of events on the queue, 0 if empty */
-uint32_t event_queue_num_events_available()
+uint32_t event_queue_num_events_available(void)
 {
 	if (session_logic_event_queue_ == NULL) {
 		pcep_log(
@@ -266,7 +266,7 @@ uint32_t event_queue_num_events_availabl
 
 
 /* Return the next event on the queue, NULL if empty */
-struct pcep_event *event_queue_get_event()
+struct pcep_event *event_queue_get_event(void)
 {
 	if (session_logic_event_queue_ == NULL) {
 		pcep_log(
diff -urpN frr-frr-8.4.2/pceplib/pcep_session_logic.c frr-frr-8.5/pceplib/pcep_session_logic.c
--- frr-frr-8.4.2/pceplib/pcep_session_logic.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_session_logic.c	2023-03-13 20:01:47.000000000 +0600
@@ -111,7 +111,7 @@ static bool run_session_logic_common(voi
 }
 
 
-bool run_session_logic()
+bool run_session_logic(void)
 {
 	if (!run_session_logic_common()) {
 		return false;
@@ -234,7 +234,7 @@ bool run_session_logic_with_infra(pcepli
 	return true;
 }
 
-bool run_session_logic_wait_for_completion()
+bool run_session_logic_wait_for_completion(void)
 {
 	if (!run_session_logic()) {
 		return false;
@@ -247,7 +247,7 @@ bool run_session_logic_wait_for_completi
 }
 
 
-bool stop_session_logic()
+bool stop_session_logic(void)
 {
 	if (session_logic_handle_ == NULL) {
 		pcep_log(LOG_WARNING, "%s: Session logic already stopped",
diff -urpN frr-frr-8.4.2/pceplib/pcep_socket_comm.c frr-frr-8.5/pceplib/pcep_socket_comm.c
--- frr-frr-8.4.2/pceplib/pcep_socket_comm.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_socket_comm.c	2023-03-13 20:01:47.000000000 +0600
@@ -62,7 +62,7 @@ int socket_fd_node_compare(void *list_en
 }
 
 
-bool initialize_socket_comm_pre()
+bool initialize_socket_comm_pre(void)
 {
 	socket_comm_handle_ =
 		pceplib_malloc(PCEPLIB_INFRA, sizeof(pcep_socket_comm_handle));
@@ -129,7 +129,7 @@ bool initialize_socket_comm_external_inf
 	return true;
 }
 
-bool initialize_socket_comm_loop()
+bool initialize_socket_comm_loop(void)
 {
 	if (socket_comm_handle_ != NULL) {
 		/* already initialized */
@@ -152,7 +152,7 @@ bool initialize_socket_comm_loop()
 }
 
 
-bool destroy_socket_comm_loop()
+bool destroy_socket_comm_loop(void)
 {
 	socket_comm_handle_->active = false;
 
diff -urpN frr-frr-8.4.2/pceplib/pcep_timers.c frr-frr-8.5/pceplib/pcep_timers.c
--- frr-frr-8.4.2/pceplib/pcep_timers.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_timers.c	2023-03-13 20:01:47.000000000 +0600
@@ -197,7 +197,7 @@ void free_all_timers(pcep_timers_context
 }
 
 
-bool teardown_timers()
+bool teardown_timers(void)
 {
 	if (timers_context_ == NULL) {
 		pcep_log(
@@ -252,7 +252,7 @@ bool teardown_timers()
 }
 
 
-int get_next_timer_id()
+int get_next_timer_id(void)
 {
 	if (timer_id_ == INT_MAX) {
 		timer_id_ = 0;
diff -urpN frr-frr-8.4.2/pceplib/pcep_utils_counters.h frr-frr-8.5/pceplib/pcep_utils_counters.h
--- frr-frr-8.4.2/pceplib/pcep_utils_counters.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_utils_counters.h	2023-03-13 20:01:47.000000000 +0600
@@ -30,6 +30,7 @@
 
 #include <stdbool.h>
 #include <stdint.h>
+#include <time.h>
 
 #ifdef __cplusplus
 extern "C" {
diff -urpN frr-frr-8.4.2/pceplib/pcep_utils_double_linked_list.c frr-frr-8.5/pceplib/pcep_utils_double_linked_list.c
--- frr-frr-8.4.2/pceplib/pcep_utils_double_linked_list.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_utils_double_linked_list.c	2023-03-13 20:01:47.000000000 +0600
@@ -31,7 +31,7 @@
 #include "pcep_utils_logging.h"
 #include "pcep_utils_memory.h"
 
-double_linked_list *dll_initialize()
+double_linked_list *dll_initialize(void)
 {
 	double_linked_list *handle =
 		pceplib_malloc(PCEPLIB_INFRA, sizeof(double_linked_list));
diff -urpN frr-frr-8.4.2/pceplib/pcep_utils_logging.c frr-frr-8.5/pceplib/pcep_utils_logging.c
--- frr-frr-8.4.2/pceplib/pcep_utils_logging.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_utils_logging.c	2023-03-13 20:01:47.000000000 +0600
@@ -27,10 +27,12 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include "compiler.h"
 #include "pcep_utils_logging.h"
 
 /* Forward declaration */
-int pcep_stdout_logger(int priority, const char *format, va_list args);
+int pcep_stdout_logger(int priority, const char *format, va_list args)
+	PRINTFRR(2, 0);
 
 static pcep_logger_func logger_func = pcep_stdout_logger;
 static int logging_level_ = LOG_INFO;
@@ -45,7 +47,7 @@ void set_logging_level(int level)
 	logging_level_ = level;
 }
 
-int get_logging_level()
+int get_logging_level(void)
 {
 	return logging_level_;
 }
diff -urpN frr-frr-8.4.2/pceplib/pcep_utils_memory.c frr-frr-8.5/pceplib/pcep_utils_memory.c
--- frr-frr-8.4.2/pceplib/pcep_utils_memory.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_utils_memory.c	2023-03-13 20:01:47.000000000 +0600
@@ -75,7 +75,7 @@ bool pceplib_memory_initialize(void *pce
 	return true;
 }
 
-void pceplib_memory_reset()
+void pceplib_memory_reset(void)
 {
 	pceplib_infra_mt.total_bytes_allocated = 0;
 	pceplib_infra_mt.num_allocates = 0;
@@ -88,7 +88,7 @@ void pceplib_memory_reset()
 	pceplib_messages_mt.num_frees = 0;
 }
 
-void pceplib_memory_dump()
+void pceplib_memory_dump(void)
 {
 	if (PCEPLIB_INFRA) {
 		pcep_log(
diff -urpN frr-frr-8.4.2/pceplib/pcep_utils_queue.c frr-frr-8.5/pceplib/pcep_utils_queue.c
--- frr-frr-8.4.2/pceplib/pcep_utils_queue.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pceplib/pcep_utils_queue.c	2023-03-13 20:01:47.000000000 +0600
@@ -33,7 +33,7 @@
 #include "pcep_utils_memory.h"
 #include "pcep_utils_queue.h"
 
-queue_handle *queue_initialize()
+queue_handle *queue_initialize(void)
 {
 	/* Set the max_entries to 0 to disable it */
 	return queue_initialize_with_size(0);
diff -urpN frr-frr-8.4.2/pimd/mtracebis_netlink.c frr-frr-8.5/pimd/mtracebis_netlink.c
--- frr-frr-8.4.2/pimd/mtracebis_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/mtracebis_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -92,7 +92,7 @@ int rtnl_open_byproto(struct rtnl_handle
 			rth->local.nl_family);
 		return -1;
 	}
-	rth->seq = (uint32_t)time(NULL);
+	rth->seq = getpid();
 	return 0;
 }
 
diff -urpN frr-frr-8.4.2/pimd/pim6_cmd.c frr-frr-8.5/pimd/pim6_cmd.c
--- frr-frr-8.4.2/pimd/pim6_cmd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim6_cmd.c	2023-03-13 20:01:47.000000000 +0600
@@ -45,9 +45,7 @@
 #include "pim_zebra.h"
 #include "pim_instance.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pimd/pim6_cmd_clippy.c"
-#endif
 
 static struct cmd_node debug_node = {
 	.name = "debug",
@@ -476,6 +474,47 @@ DEFPY (no_ipv6_pim_rp_prefix_list,
 	return pim_process_no_rp_plist_cmd(vty, rp_str, plist);
 }
 
+DEFPY (ipv6_pim_bsm,
+       ipv6_pim_bsm_cmd,
+       "ipv6 pim bsm",
+       IPV6_STR
+       PIM_STR
+       "Enable BSM support on the interface\n")
+{
+	return pim_process_bsm_cmd(vty);
+}
+
+DEFPY (no_ipv6_pim_bsm,
+       no_ipv6_pim_bsm_cmd,
+       "no ipv6 pim bsm",
+       NO_STR
+       IPV6_STR
+       PIM_STR
+       "Enable BSM support on the interface\n")
+{
+	return pim_process_no_bsm_cmd(vty);
+}
+
+DEFPY (ipv6_pim_ucast_bsm,
+       ipv6_pim_ucast_bsm_cmd,
+       "ipv6 pim unicast-bsm",
+       IPV6_STR
+       PIM_STR
+       "Accept/Send unicast BSM on the interface\n")
+{
+	return pim_process_unicast_bsm_cmd(vty);
+}
+
+DEFPY (no_ipv6_pim_ucast_bsm,
+       no_ipv6_pim_ucast_bsm_cmd,
+       "no ipv6 pim unicast-bsm",
+       NO_STR
+       IPV6_STR
+       PIM_STR
+       "Accept/Send unicast BSM on the interface\n")
+{
+	return pim_process_no_unicast_bsm_cmd(vty);
+}
 
 DEFPY (ipv6_ssmpingd,
       ipv6_ssmpingd_cmd,
@@ -1240,6 +1279,44 @@ DEFPY (show_ipv6_pim_interface_traffic,
 	return pim_show_interface_traffic_helper(vrf, if_name, vty, !!json);
 }
 
+DEFPY (show_ipv6_pim_bsr,
+       show_ipv6_pim_bsr_cmd,
+       "show ipv6 pim bsr [vrf NAME] [json$json]",
+       SHOW_STR
+       IPV6_STR
+       PIM_STR
+       "boot-strap router information\n"
+       VRF_CMD_HELP_STR
+       JSON_STR)
+{
+	return pim_show_bsr_helper(vrf, vty, !!json);
+}
+
+DEFPY (show_ipv6_pim_bsm_db,
+       show_ipv6_pim_bsm_db_cmd,
+       "show ipv6 pim bsm-database [vrf NAME] [json$json]",
+       SHOW_STR
+       IPV6_STR
+       PIM_STR
+       "PIM cached bsm packets information\n"
+       VRF_CMD_HELP_STR
+       JSON_STR)
+{
+	return pim_show_bsm_db_helper(vrf, vty, !!json);
+}
+
+DEFPY (show_ipv6_pim_bsrp,
+       show_ipv6_pim_bsrp_cmd,
+       "show ipv6 pim bsrp-info [vrf NAME] [json$json]",
+       SHOW_STR
+       IPV6_STR
+       PIM_STR
+       "PIM cached group-rp mappings information\n"
+       VRF_CMD_HELP_STR
+       JSON_STR)
+{
+	return pim_show_group_rp_mappings_info_helper(vrf, vty, !!json);
+}
 
 DEFPY (clear_ipv6_pim_statistics,
        clear_ipv6_pim_statistics_cmd,
@@ -1558,6 +1635,109 @@ DEFUN_NOSH (show_debugging_pimv6,
 
 	pim_debug_config_write(vty);
 
+	cmd_show_lib_debugs(vty);
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_mld,
+       debug_mld_cmd,
+       "[no] debug mld",
+       NO_STR
+       DEBUG_STR
+       DEBUG_MLD_STR)
+{
+	if (!no) {
+		PIM_DO_DEBUG_GM_EVENTS;
+		PIM_DO_DEBUG_GM_PACKETS;
+		PIM_DO_DEBUG_GM_TRACE;
+	} else {
+		PIM_DONT_DEBUG_GM_EVENTS;
+		PIM_DONT_DEBUG_GM_PACKETS;
+		PIM_DONT_DEBUG_GM_TRACE;
+	}
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_mld_events,
+       debug_mld_events_cmd,
+       "[no] debug mld events",
+       NO_STR
+       DEBUG_STR
+       DEBUG_MLD_STR
+       DEBUG_MLD_EVENTS_STR)
+{
+	if (!no)
+		PIM_DO_DEBUG_GM_EVENTS;
+	else
+		PIM_DONT_DEBUG_GM_EVENTS;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_mld_packets,
+       debug_mld_packets_cmd,
+       "[no] debug mld packets",
+       NO_STR
+       DEBUG_STR
+       DEBUG_MLD_STR
+       DEBUG_MLD_PACKETS_STR)
+{
+	if (!no)
+		PIM_DO_DEBUG_GM_PACKETS;
+	else
+		PIM_DONT_DEBUG_GM_PACKETS;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_mld_trace,
+       debug_mld_trace_cmd,
+       "[no] debug mld trace",
+       NO_STR
+       DEBUG_STR
+       DEBUG_MLD_STR
+       DEBUG_MLD_TRACE_STR)
+{
+	if (!no)
+		PIM_DO_DEBUG_GM_TRACE;
+	else
+		PIM_DONT_DEBUG_GM_TRACE;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_mld_trace_detail,
+       debug_mld_trace_detail_cmd,
+       "[no] debug mld trace detail",
+       NO_STR
+       DEBUG_STR
+       DEBUG_MLD_STR
+       DEBUG_MLD_TRACE_STR
+       "detailed\n")
+{
+	if (!no)
+		PIM_DO_DEBUG_GM_TRACE_DETAIL;
+	else
+		PIM_DONT_DEBUG_GM_TRACE_DETAIL;
+
+	return CMD_SUCCESS;
+}
+
+DEFPY (debug_pimv6_bsm,
+       debug_pimv6_bsm_cmd,
+       "[no] debug pimv6 bsm",
+       NO_STR
+       DEBUG_STR
+       DEBUG_PIMV6_STR
+       DEBUG_PIMV6_BSM_STR)
+{
+	if (!no)
+		PIM_DO_DEBUG_BSM;
+	else
+		PIM_DONT_DEBUG_BSM;
+
 	return CMD_SUCCESS;
 }
 
@@ -1598,6 +1778,11 @@ void pim_cmd_init(void)
 			&interface_no_ipv6_pim_boundary_oil_cmd);
 	install_element(INTERFACE_NODE, &interface_ipv6_mroute_cmd);
 	install_element(INTERFACE_NODE, &interface_no_ipv6_mroute_cmd);
+	/* Install BSM command */
+	install_element(INTERFACE_NODE, &ipv6_pim_bsm_cmd);
+	install_element(INTERFACE_NODE, &no_ipv6_pim_bsm_cmd);
+	install_element(INTERFACE_NODE, &ipv6_pim_ucast_bsm_cmd);
+	install_element(INTERFACE_NODE, &no_ipv6_pim_ucast_bsm_cmd);
 	install_element(CONFIG_NODE, &ipv6_pim_rp_cmd);
 	install_element(VRF_NODE, &ipv6_pim_rp_cmd);
 	install_element(CONFIG_NODE, &no_ipv6_pim_rp_cmd);
@@ -1670,7 +1855,9 @@ void pim_cmd_init(void)
 	install_element(VIEW_NODE, &show_ipv6_mroute_summary_cmd);
 	install_element(VIEW_NODE, &show_ipv6_mroute_summary_vrf_all_cmd);
 	install_element(VIEW_NODE, &show_ipv6_pim_interface_traffic_cmd);
-
+	install_element(VIEW_NODE, &show_ipv6_pim_bsr_cmd);
+	install_element(VIEW_NODE, &show_ipv6_pim_bsm_db_cmd);
+	install_element(VIEW_NODE, &show_ipv6_pim_bsrp_cmd);
 	install_element(ENABLE_NODE, &clear_ipv6_pim_statistics_cmd);
 	install_element(ENABLE_NODE, &clear_ipv6_mroute_cmd);
 	install_element(ENABLE_NODE, &clear_ipv6_pim_oil_cmd);
@@ -1693,6 +1880,12 @@ void pim_cmd_init(void)
 	install_element(ENABLE_NODE, &debug_pimv6_zebra_cmd);
 	install_element(ENABLE_NODE, &debug_mroute6_cmd);
 	install_element(ENABLE_NODE, &debug_mroute6_detail_cmd);
+	install_element(ENABLE_NODE, &debug_mld_cmd);
+	install_element(ENABLE_NODE, &debug_mld_events_cmd);
+	install_element(ENABLE_NODE, &debug_mld_packets_cmd);
+	install_element(ENABLE_NODE, &debug_mld_trace_cmd);
+	install_element(ENABLE_NODE, &debug_mld_trace_detail_cmd);
+	install_element(ENABLE_NODE, &debug_pimv6_bsm_cmd);
 
 	install_element(CONFIG_NODE, &debug_pimv6_cmd);
 	install_element(CONFIG_NODE, &debug_pimv6_nht_cmd);
@@ -1706,4 +1899,10 @@ void pim_cmd_init(void)
 	install_element(CONFIG_NODE, &debug_pimv6_zebra_cmd);
 	install_element(CONFIG_NODE, &debug_mroute6_cmd);
 	install_element(CONFIG_NODE, &debug_mroute6_detail_cmd);
+	install_element(CONFIG_NODE, &debug_mld_cmd);
+	install_element(CONFIG_NODE, &debug_mld_events_cmd);
+	install_element(CONFIG_NODE, &debug_mld_packets_cmd);
+	install_element(CONFIG_NODE, &debug_mld_trace_cmd);
+	install_element(CONFIG_NODE, &debug_mld_trace_detail_cmd);
+	install_element(CONFIG_NODE, &debug_pimv6_bsm_cmd);
 }
diff -urpN frr-frr-8.4.2/pimd/pim6_cmd.h frr-frr-8.5/pimd/pim6_cmd.h
--- frr-frr-8.4.2/pimd/pim6_cmd.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim6_cmd.h	2023-03-13 20:01:47.000000000 +0600
@@ -58,6 +58,7 @@
 #define DEBUG_PIMV6_TRACE_STR "PIMv6 internal daemon activity\n"
 #define DEBUG_PIMV6_ZEBRA_STR "ZEBRA protocol activity\n"
 #define DEBUG_MROUTE6_STR "PIMv6 interaction with kernel MFC cache\n"
+#define DEBUG_PIMV6_BSM_STR "BSR message processing activity\n"
 
 void pim_cmd_init(void);
 
diff -urpN frr-frr-8.4.2/pimd/pim6_mld.c frr-frr-8.5/pimd/pim6_mld.c
--- frr-frr-8.4.2/pimd/pim6_mld.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim6_mld.c	2023-03-13 20:01:47.000000000 +0600
@@ -2319,9 +2319,7 @@ void gm_ifp_update(struct interface *ifp
 
 #include "lib/command.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pimd/pim6_mld_clippy.c"
-#endif
 
 static struct vrf *gm_cmd_vrf_lookup(struct vty *vty, const char *vrf_str,
 				     int *err)
@@ -2395,24 +2393,18 @@ static void gm_show_if_one_detail(struct
 }
 
 static void gm_show_if_one(struct vty *vty, struct interface *ifp,
-			   json_object *js_if)
+			   json_object *js_if, struct ttable *tt)
 {
 	struct pim_interface *pim_ifp = (struct pim_interface *)ifp->info;
 	struct gm_if *gm_ifp = pim_ifp->mld;
 	bool querier;
 
-	if (!gm_ifp) {
-		if (js_if)
-			json_object_string_add(js_if, "state", "down");
-		else
-			vty_out(vty, "%-16s  %5s\n", ifp->name, "down");
-		return;
-	}
-
 	querier = IPV6_ADDR_SAME(&gm_ifp->querier, &pim_ifp->ll_lowest);
 
 	if (js_if) {
 		json_object_string_add(js_if, "name", ifp->name);
+		json_object_string_addf(js_if, "address", "%pPA",
+					&pim_ifp->primary_address);
 		json_object_string_add(js_if, "state", "up");
 		json_object_string_addf(js_if, "version", "%d",
 					gm_ifp->cur_version);
@@ -2439,11 +2431,11 @@ static void gm_show_if_one(struct vty *v
 		json_object_int_add(js_if, "timerLastMemberQueryIntervalMsec",
 				    gm_ifp->cur_query_intv_trig);
 	} else {
-		vty_out(vty, "%-16s  %-5s  %d  %-25pPA  %-5s %11pTH  %pTVMs\n",
-			ifp->name, "up", gm_ifp->cur_version, &gm_ifp->querier,
-			querier ? "query" : "other",
-			querier ? gm_ifp->t_query : gm_ifp->t_other_querier,
-			&gm_ifp->started);
+		ttable_add_row(tt, "%s|%s|%pPAs|%d|%s|%pPAs|%pTH|%pTVMs",
+			       ifp->name, "up", &pim_ifp->primary_address,
+			       gm_ifp->cur_version, querier ? "local" : "other",
+			       &gm_ifp->querier, gm_ifp->t_query,
+			       &gm_ifp->started);
 	}
 }
 
@@ -2451,13 +2443,27 @@ static void gm_show_if_vrf(struct vty *v
 			   bool detail, json_object *js)
 {
 	struct interface *ifp;
-	json_object *js_vrf;
+	json_object *js_vrf = NULL;
+	struct pim_interface *pim_ifp;
+	struct ttable *tt = NULL;
+	char *table = NULL;
 
 	if (js) {
 		js_vrf = json_object_new_object();
 		json_object_object_add(js, vrf->name, js_vrf);
 	}
 
+	if (!js && !detail) {
+		/* Prepare table. */
+		tt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);
+		ttable_add_row(
+			tt,
+			"Interface|State|Address|V|Querier|QuerierIp|Query Timer|Uptime");
+		tt->style.cell.rpad = 2;
+		tt->style.corner = '+';
+		ttable_restyle(tt);
+	}
+
 	FOR_ALL_INTERFACES (vrf, ifp) {
 		json_object *js_if = NULL;
 
@@ -2468,24 +2474,31 @@ static void gm_show_if_vrf(struct vty *v
 			continue;
 		}
 
-		if (!ifp->info)
+		pim_ifp = ifp->info;
+
+		if (!pim_ifp || !pim_ifp->mld)
 			continue;
+
 		if (js) {
 			js_if = json_object_new_object();
 			json_object_object_add(js_vrf, ifp->name, js_if);
 		}
 
-		gm_show_if_one(vty, ifp, js_if);
+		gm_show_if_one(vty, ifp, js_if, tt);
+	}
+
+	/* Dump the generated table. */
+	if (!js && !detail) {
+		table = ttable_dump(tt, "\n");
+		vty_out(vty, "%s\n", table);
+		XFREE(MTYPE_TMP, table);
+		ttable_del(tt);
 	}
 }
 
 static void gm_show_if(struct vty *vty, struct vrf *vrf, const char *ifname,
 		       bool detail, json_object *js)
 {
-	if (!js && !detail)
-		vty_out(vty, "%-16s  %-5s  V  %-25s  %-18s  %s\n", "Interface",
-			"State", "Querier", "Timer", "Uptime");
-
 	if (vrf)
 		gm_show_if_vrf(vty, vrf, ifname, detail, js);
 	else
@@ -2739,7 +2752,7 @@ static void gm_show_joins_one(struct vty
 		}
 
 		js_src = json_object_new_object();
-		json_object_object_addf(js_group, js_src, "%pPA",
+		json_object_object_addf(js_group, js_src, "%pPAs",
 					&sg->sgaddr.src);
 
 		json_object_string_add(js_src, "state", gm_states[sg->state]);
@@ -2802,6 +2815,7 @@ static void gm_show_joins_vrf(struct vty
 
 	if (js) {
 		js_vrf = json_object_new_object();
+		json_object_string_add(js_vrf, "vrf", vrf->name);
 		json_object_object_add(js, vrf->name, js_vrf);
 	}
 
@@ -2997,9 +3011,9 @@ DEFPY(gm_debug_show,
       "debug show mld interface IFNAME",
       DEBUG_STR
       SHOW_STR
-      "MLD"
+      MLD_STR
       INTERFACE_STR
-      "interface name")
+      "interface name\n")
 {
 	struct interface *ifp;
 	struct pim_interface *pim_ifp;
diff -urpN frr-frr-8.4.2/pimd/pim_addr.h frr-frr-8.5/pimd/pim_addr.h
--- frr-frr-8.4.2/pimd/pim_addr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_addr.h	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ typedef struct in_addr pim_addr;
 #define PIM_MAX_BITLEN	IPV4_MAX_BITLEN
 #define PIM_AF_NAME     "ip"
 #define PIM_AF_DBG	"pim"
+#define GM_AF_DBG	"igmp"
 #define PIM_MROUTE_DBG  "mroute"
 #define PIMREG          "pimreg"
 #define GM              "IGMP"
@@ -65,6 +66,7 @@ typedef struct in6_addr pim_addr;
 #define PIM_MAX_BITLEN	IPV6_MAX_BITLEN
 #define PIM_AF_NAME     "ipv6"
 #define PIM_AF_DBG	"pimv6"
+#define GM_AF_DBG	"mld"
 #define PIM_MROUTE_DBG  "mroute6"
 #define PIMREG          "pim6reg"
 #define GM              "MLD"
diff -urpN frr-frr-8.4.2/pimd/pim_br.c frr-frr-8.5/pimd/pim_br.c
--- frr-frr-8.4.2/pimd/pim_br.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_br.c	1970-01-01 06:00:00.000000000 +0600
@@ -1,93 +0,0 @@
-/*
- * PIM for Quagga
- * Copyright (C) 2015 Cumulus Networks, Inc.
- * Donald Sharp
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#include <zebra.h>
-
-#include "memory.h"
-#include "log.h"
-#include "if.h"
-
-#include "pimd.h"
-#include "pim_str.h"
-#include "pim_br.h"
-#include "linklist.h"
-
-struct pim_br {
-	pim_sgaddr sg;
-	pim_addr pmbr;
-};
-
-static struct list *pim_br_list = NULL;
-
-pim_addr pim_br_get_pmbr(pim_sgaddr *sg)
-{
-	struct listnode *node;
-	struct pim_br *pim_br;
-
-	for (ALL_LIST_ELEMENTS_RO(pim_br_list, node, pim_br)) {
-		if (!pim_sgaddr_cmp(*sg, pim_br->sg))
-			return pim_br->pmbr;
-	}
-
-	return PIMADDR_ANY;
-}
-
-void pim_br_set_pmbr(pim_sgaddr *sg, pim_addr br)
-{
-	struct listnode *node, *next;
-	struct pim_br *pim_br;
-
-	for (ALL_LIST_ELEMENTS(pim_br_list, node, next, pim_br)) {
-		if (!pim_sgaddr_cmp(*sg, pim_br->sg))
-			break;
-	}
-
-	if (!pim_br) {
-		pim_br = XCALLOC(MTYPE_PIM_BR, sizeof(*pim_br));
-		pim_br->sg = *sg;
-
-		listnode_add(pim_br_list, pim_br);
-	}
-
-	pim_br->pmbr = br;
-}
-
-/*
- * Remove the (S,G) from the stored values
- */
-void pim_br_clear_pmbr(pim_sgaddr *sg)
-{
-	struct listnode *node, *next;
-	struct pim_br *pim_br;
-
-	for (ALL_LIST_ELEMENTS(pim_br_list, node, next, pim_br)) {
-		if (!pim_sgaddr_cmp(*sg, pim_br->sg))
-			break;
-	}
-
-	if (!pim_br)
-		return;
-
-	listnode_delete(pim_br_list, pim_br);
-}
-
-void pim_br_init(void)
-{
-	pim_br_list = list_new();
-}
diff -urpN frr-frr-8.4.2/pimd/pim_br.h frr-frr-8.5/pimd/pim_br.h
--- frr-frr-8.4.2/pimd/pim_br.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_br.h	1970-01-01 06:00:00.000000000 +0600
@@ -1,30 +0,0 @@
-/*
- * PIM for Quagga
- * Copyright (C) 2015 Cumulus Networks, Inc.
- * Donald Sharp
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; see the file COPYING; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#ifndef PIM_BR_H
-#define PIM_BR_H
-
-pim_addr pim_br_get_pmbr(pim_sgaddr *sg);
-
-void pim_br_set_pmbr(pim_sgaddr *sg, pim_addr value);
-void pim_br_clear_pmbr(pim_sgaddr *sg);
-
-void pim_br_init(void);
-
-#endif
diff -urpN frr-frr-8.4.2/pimd/pim_cmd.c frr-frr-8.5/pimd/pim_cmd.c
--- frr-frr-8.4.2/pimd/pim_cmd.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_cmd.c	2023-03-13 20:01:47.000000000 +0600
@@ -70,9 +70,7 @@
 #include "pim_addr.h"
 #include "pim_cmd_common.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "pimd/pim_cmd_clippy.c"
-#endif
 
 static struct cmd_node debug_node = {
 	.name = "debug",
@@ -837,285 +835,6 @@ static void igmp_show_statistics(struct
 	}
 }
 
-/* Display the bsm database details */
-static void pim_show_bsm_db(struct pim_instance *pim, struct vty *vty, bool uj)
-{
-	int count = 0;
-	int fragment = 1;
-	struct bsm_frag *bsfrag;
-	json_object *json = NULL;
-	json_object *json_group = NULL;
-	json_object *json_row = NULL;
-
-	count = bsm_frags_count(pim->global_scope.bsm_frags);
-
-	if (uj) {
-		json = json_object_new_object();
-		json_object_int_add(json, "Number of the fragments", count);
-	} else {
-		vty_out(vty, "Scope Zone: Global\n");
-		vty_out(vty, "Number of the fragments: %d\n", count);
-		vty_out(vty, "\n");
-	}
-
-	frr_each (bsm_frags, pim->global_scope.bsm_frags, bsfrag) {
-		char grp_str[PREFIX_STRLEN];
-		struct bsmmsg_grpinfo *group;
-		struct bsmmsg_rpinfo *bsm_rpinfo;
-		struct prefix grp;
-		struct bsm_hdr *hdr;
-		pim_addr bsr_addr;
-		uint32_t offset = 0;
-		uint8_t *buf;
-		uint32_t len = 0;
-		uint32_t frag_rp_cnt = 0;
-
-		buf = bsfrag->data;
-		len = bsfrag->size;
-
-		/* skip pim header */
-		buf += PIM_MSG_HEADER_LEN;
-		len -= PIM_MSG_HEADER_LEN;
-
-		hdr = (struct bsm_hdr *)buf;
-		/* NB: bshdr->bsr_addr.addr is packed/unaligned => memcpy */
-		memcpy(&bsr_addr, &hdr->bsr_addr.addr, sizeof(bsr_addr));
-
-		/* BSM starts with bsr header */
-		buf += sizeof(struct bsm_hdr);
-		len -= sizeof(struct bsm_hdr);
-
-		if (uj) {
-			json_object_string_addf(json, "BSR address", "%pPA",
-						&bsr_addr);
-			json_object_int_add(json, "BSR priority",
-					    hdr->bsr_prio);
-			json_object_int_add(json, "Hashmask Length",
-					    hdr->hm_len);
-			json_object_int_add(json, "Fragment Tag",
-					    ntohs(hdr->frag_tag));
-		} else {
-			vty_out(vty, "BSM Fragment : %d\n", fragment);
-			vty_out(vty, "------------------\n");
-			vty_out(vty, "%-15s %-15s %-15s %-15s\n", "BSR-Address",
-				"BSR-Priority", "Hashmask-len", "Fragment-Tag");
-			vty_out(vty, "%-15pPA %-15d %-15d %-15d\n", &bsr_addr,
-				hdr->bsr_prio, hdr->hm_len,
-				ntohs(hdr->frag_tag));
-		}
-
-		vty_out(vty, "\n");
-
-		while (offset < len) {
-			group = (struct bsmmsg_grpinfo *)buf;
-
-			if (group->group.family == PIM_MSG_ADDRESS_FAMILY_IPV4)
-				grp.family = AF_INET;
-			else if (group->group.family ==
-				 PIM_MSG_ADDRESS_FAMILY_IPV6)
-				grp.family = AF_INET6;
-
-			grp.prefixlen = group->group.mask;
-#if PIM_IPV == 4
-			grp.u.prefix4 = group->group.addr;
-#else
-			grp.u.prefix6 = group->group.addr;
-#endif
-
-			prefix2str(&grp, grp_str, sizeof(grp_str));
-
-			buf += sizeof(struct bsmmsg_grpinfo);
-			offset += sizeof(struct bsmmsg_grpinfo);
-
-			if (uj) {
-				json_object_object_get_ex(json, grp_str,
-							  &json_group);
-				if (!json_group) {
-					json_group = json_object_new_object();
-					json_object_int_add(json_group,
-							    "Rp Count",
-							    group->rp_count);
-					json_object_int_add(
-						json_group, "Fragment Rp count",
-						group->frag_rp_count);
-					json_object_object_add(json, grp_str,
-							       json_group);
-				}
-			} else {
-				vty_out(vty, "Group : %s\n", grp_str);
-				vty_out(vty, "-------------------\n");
-				vty_out(vty, "Rp Count:%d\n", group->rp_count);
-				vty_out(vty, "Fragment Rp Count : %d\n",
-					group->frag_rp_count);
-			}
-
-			frag_rp_cnt = group->frag_rp_count;
-
-			if (!frag_rp_cnt)
-				continue;
-
-			if (!uj)
-				vty_out(vty,
-					"RpAddress     HoldTime     Priority\n");
-
-			while (frag_rp_cnt--) {
-				pim_addr rp_addr;
-
-				bsm_rpinfo = (struct bsmmsg_rpinfo *)buf;
-				/* unaligned, again */
-				memcpy(&rp_addr, &bsm_rpinfo->rpaddr,
-				       sizeof(rp_addr));
-
-				buf += sizeof(struct bsmmsg_rpinfo);
-				offset += sizeof(struct bsmmsg_rpinfo);
-
-				if (uj) {
-					json_row = json_object_new_object();
-					json_object_string_addf(
-						json_row, "Rp Address", "%pPA",
-						&rp_addr);
-					json_object_int_add(
-						json_row, "Rp HoldTime",
-						ntohs(bsm_rpinfo->rp_holdtime));
-					json_object_int_add(json_row,
-							    "Rp Priority",
-							    bsm_rpinfo->rp_pri);
-					json_object_object_addf(
-						json_group, json_row, "%pPA",
-						&rp_addr);
-				} else {
-					vty_out(vty, "%-15pPA %-12d %d\n",
-						&rp_addr,
-						ntohs(bsm_rpinfo->rp_holdtime),
-						bsm_rpinfo->rp_pri);
-				}
-			}
-			vty_out(vty, "\n");
-		}
-
-		fragment++;
-	}
-
-	if (uj)
-		vty_json(vty, json);
-}
-
-/*Display the group-rp mappings */
-static void pim_show_group_rp_mappings_info(struct pim_instance *pim,
-					    struct vty *vty, bool uj)
-{
-	struct bsgrp_node *bsgrp;
-	struct bsm_rpinfo *bsm_rp;
-	struct route_node *rn;
-	json_object *json = NULL;
-	json_object *json_group = NULL;
-	json_object *json_row = NULL;
-
-	if (uj) {
-		json = json_object_new_object();
-		json_object_string_addf(json, "BSR Address", "%pPA",
-					&pim->global_scope.current_bsr);
-	} else
-		vty_out(vty, "BSR Address  %pPA\n",
-			&pim->global_scope.current_bsr);
-
-	for (rn = route_top(pim->global_scope.bsrp_table); rn;
-	     rn = route_next(rn)) {
-		bsgrp = (struct bsgrp_node *)rn->info;
-
-		if (!bsgrp)
-			continue;
-
-		char grp_str[PREFIX_STRLEN];
-
-		prefix2str(&bsgrp->group, grp_str, sizeof(grp_str));
-
-		if (uj) {
-			json_object_object_get_ex(json, grp_str, &json_group);
-			if (!json_group) {
-				json_group = json_object_new_object();
-				json_object_object_add(json, grp_str,
-						       json_group);
-			}
-		} else {
-			vty_out(vty, "Group Address %pFX\n", &bsgrp->group);
-			vty_out(vty, "--------------------------\n");
-			vty_out(vty, "%-15s %-15s %-15s %-15s\n", "Rp Address",
-				"priority", "Holdtime", "Hash");
-
-			vty_out(vty, "(ACTIVE)\n");
-		}
-
-		frr_each (bsm_rpinfos, bsgrp->bsrp_list, bsm_rp) {
-			if (uj) {
-				json_row = json_object_new_object();
-				json_object_string_addf(json_row, "Rp Address",
-							"%pPA",
-							&bsm_rp->rp_address);
-				json_object_int_add(json_row, "Rp HoldTime",
-						    bsm_rp->rp_holdtime);
-				json_object_int_add(json_row, "Rp Priority",
-						    bsm_rp->rp_prio);
-				json_object_int_add(json_row, "Hash Val",
-						    bsm_rp->hash);
-				json_object_object_addf(json_group, json_row,
-							"%pPA",
-							&bsm_rp->rp_address);
-
-			} else {
-				vty_out(vty, "%-15pPA %-15u %-15u %-15u\n",
-					&bsm_rp->rp_address, bsm_rp->rp_prio,
-					bsm_rp->rp_holdtime, bsm_rp->hash);
-			}
-		}
-		if (!bsm_rpinfos_count(bsgrp->bsrp_list) && !uj)
-			vty_out(vty, "Active List is empty.\n");
-
-		if (uj) {
-			json_object_int_add(json_group, "Pending RP count",
-					    bsgrp->pend_rp_cnt);
-		} else {
-			vty_out(vty, "(PENDING)\n");
-			vty_out(vty, "Pending RP count :%d\n",
-				bsgrp->pend_rp_cnt);
-			if (bsgrp->pend_rp_cnt)
-				vty_out(vty, "%-15s %-15s %-15s %-15s\n",
-					"Rp Address", "priority", "Holdtime",
-					"Hash");
-		}
-
-		frr_each (bsm_rpinfos, bsgrp->partial_bsrp_list, bsm_rp) {
-			if (uj) {
-				json_row = json_object_new_object();
-				json_object_string_addf(json_row, "Rp Address",
-							"%pPA",
-							&bsm_rp->rp_address);
-				json_object_int_add(json_row, "Rp HoldTime",
-						    bsm_rp->rp_holdtime);
-				json_object_int_add(json_row, "Rp Priority",
-						    bsm_rp->rp_prio);
-				json_object_int_add(json_row, "Hash Val",
-						    bsm_rp->hash);
-				json_object_object_addf(json_group, json_row,
-							"%pPA",
-							&bsm_rp->rp_address);
-			} else {
-				vty_out(vty, "%-15pPA %-15u %-15u %-15u\n",
-					&bsm_rp->rp_address, bsm_rp->rp_prio,
-					bsm_rp->rp_holdtime, bsm_rp->hash);
-			}
-		}
-		if (!bsm_rpinfos_count(bsgrp->partial_bsrp_list) && !uj)
-			vty_out(vty, "Partial List is empty\n");
-
-		if (!uj)
-			vty_out(vty, "\n");
-	}
-
-	if (uj)
-		vty_json(vty, json);
-}
-
 static void igmp_show_groups(struct pim_instance *pim, struct vty *vty, bool uj)
 {
 	struct interface *ifp;
@@ -1439,77 +1158,6 @@ static void igmp_show_source_retransmiss
 	}		  /* scan interfaces */
 }
 
-static void pim_show_bsr(struct pim_instance *pim,
-			 struct vty *vty,
-			 bool uj)
-{
-	char uptime[10];
-	char last_bsm_seen[10];
-	time_t now;
-	char bsr_state[20];
-	json_object *json = NULL;
-
-	if (pim_addr_is_any(pim->global_scope.current_bsr)) {
-		pim_time_uptime(uptime, sizeof(uptime),
-				pim->global_scope.current_bsr_first_ts);
-		pim_time_uptime(last_bsm_seen, sizeof(last_bsm_seen),
-				pim->global_scope.current_bsr_last_ts);
-	}
-
-	else {
-		now = pim_time_monotonic_sec();
-		pim_time_uptime(uptime, sizeof(uptime),
-				(now - pim->global_scope.current_bsr_first_ts));
-		pim_time_uptime(last_bsm_seen, sizeof(last_bsm_seen),
-				now - pim->global_scope.current_bsr_last_ts);
-	}
-
-	switch (pim->global_scope.state) {
-	case NO_INFO:
-		strlcpy(bsr_state, "NO_INFO", sizeof(bsr_state));
-		break;
-	case ACCEPT_ANY:
-		strlcpy(bsr_state, "ACCEPT_ANY", sizeof(bsr_state));
-		break;
-	case ACCEPT_PREFERRED:
-		strlcpy(bsr_state, "ACCEPT_PREFERRED", sizeof(bsr_state));
-		break;
-	default:
-		strlcpy(bsr_state, "", sizeof(bsr_state));
-	}
-
-
-	if (uj) {
-		json = json_object_new_object();
-		json_object_string_addf(json, "bsr", "%pPA",
-					&pim->global_scope.current_bsr);
-		json_object_int_add(json, "priority",
-				    pim->global_scope.current_bsr_prio);
-		json_object_int_add(json, "fragmentTag",
-				    pim->global_scope.bsm_frag_tag);
-		json_object_string_add(json, "state", bsr_state);
-		json_object_string_add(json, "upTime", uptime);
-		json_object_string_add(json, "lastBsmSeen", last_bsm_seen);
-	}
-
-	else {
-		vty_out(vty, "PIMv2 Bootstrap information\n");
-		vty_out(vty, "Current preferred BSR address: %pPA\n",
-			&pim->global_scope.current_bsr);
-		vty_out(vty,
-			"Priority        Fragment-Tag       State           UpTime\n");
-		vty_out(vty, "  %-12d    %-12d    %-13s    %7s\n",
-			pim->global_scope.current_bsr_prio,
-			pim->global_scope.bsm_frag_tag,
-			bsr_state,
-			uptime);
-		vty_out(vty, "Last BSM seen: %s\n", last_bsm_seen);
-	}
-
-	if (uj)
-		vty_json(vty, json);
-}
-
 static void clear_igmp_interfaces(struct pim_instance *pim)
 {
 	struct interface *ifp;
@@ -2772,9 +2420,9 @@ DEFPY (show_ip_pim_interface_traffic,
 	return pim_show_interface_traffic_helper(vrf, if_name, vty, !!json);
 }
 
-DEFUN (show_ip_pim_bsm_db,
+DEFPY (show_ip_pim_bsm_db,
        show_ip_pim_bsm_db_cmd,
-       "show ip pim bsm-database [vrf NAME] [json]",
+       "show ip pim bsm-database [vrf NAME] [json$json]",
        SHOW_STR
        IP_STR
        PIM_STR
@@ -2782,20 +2430,12 @@ DEFUN (show_ip_pim_bsm_db,
        VRF_CMD_HELP_STR
        JSON_STR)
 {
-	int idx = 2;
-	struct vrf *vrf = pim_cmd_lookup_vrf(vty, argv, argc, &idx);
-	bool uj = use_json(argc, argv);
-
-	if (!vrf)
-		return CMD_WARNING;
-
-	pim_show_bsm_db(vrf->info, vty, uj);
-	return CMD_SUCCESS;
+	return pim_show_bsm_db_helper(vrf, vty, !!json);
 }
 
-DEFUN (show_ip_pim_bsrp,
+DEFPY (show_ip_pim_bsrp,
        show_ip_pim_bsrp_cmd,
-       "show ip pim bsrp-info [vrf NAME] [json]",
+       "show ip pim bsrp-info [vrf NAME] [json$json]",
        SHOW_STR
        IP_STR
        PIM_STR
@@ -2803,16 +2443,7 @@ DEFUN (show_ip_pim_bsrp,
        VRF_CMD_HELP_STR
        JSON_STR)
 {
-	int idx = 2;
-	struct vrf *vrf = pim_cmd_lookup_vrf(vty, argv, argc, &idx);
-	bool uj = use_json(argc, argv);
-
-	if (!vrf)
-		return CMD_WARNING;
-
-	pim_show_group_rp_mappings_info(vrf->info, vty, uj);
-
-	return CMD_SUCCESS;
+	return pim_show_group_rp_mappings_info_helper(vrf, vty, !!json);
 }
 
 DEFPY (show_ip_pim_statistics,
@@ -3586,25 +3217,17 @@ DEFUN (show_ip_pim_group_type,
 	return CMD_SUCCESS;
 }
 
-DEFUN (show_ip_pim_bsr,
+DEFPY (show_ip_pim_bsr,
        show_ip_pim_bsr_cmd,
-       "show ip pim bsr [json]",
+       "show ip pim bsr [vrf NAME] [json$json]",
        SHOW_STR
        IP_STR
        PIM_STR
        "boot-strap router information\n"
+       VRF_CMD_HELP_STR
        JSON_STR)
 {
-	int idx = 2;
-	struct vrf *vrf = pim_cmd_lookup_vrf(vty, argv, argc, &idx);
-	bool uj = use_json(argc, argv);
-
-	if (!vrf)
-		return CMD_WARNING;
-
-	pim_show_bsr(vrf->info, vty, uj);
-
-	return CMD_SUCCESS;
+	return pim_show_bsr_helper(vrf, vty, !!json);
 }
 
 DEFUN (ip_ssmpingd,
@@ -4906,6 +4529,7 @@ DEFUN_NOSH (show_debugging_pim,
 
 	pim_debug_config_write(vty);
 
+	cmd_show_lib_debugs(vty);
 	return CMD_SUCCESS;
 }
 
@@ -5009,41 +4633,19 @@ DEFUN (ip_pim_bsm,
        "ip pim bsm",
        IP_STR
        PIM_STR
-       "Enables BSM support on the interface\n")
+       "Enable BSM support on the interface\n")
 {
-	const struct lyd_node *igmp_enable_dnode;
-
-	igmp_enable_dnode =
-		yang_dnode_getf(vty->candidate_config->dnode,
-				FRR_GMP_ENABLE_XPATH, VTY_CURR_XPATH,
-				"frr-routing:ipv4");
-	if (!igmp_enable_dnode)
-		nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
-				      "true");
-	else {
-		if (!yang_dnode_get_bool(igmp_enable_dnode, "."))
-			nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
-					      "true");
-	}
-
-	nb_cli_enqueue_change(vty, "./bsm", NB_OP_MODIFY, "true");
-
-	return nb_cli_apply_changes(vty,
-			FRR_PIM_INTERFACE_XPATH, "frr-routing:ipv4");
+	return pim_process_bsm_cmd(vty);
 }
-
 DEFUN (no_ip_pim_bsm,
        no_ip_pim_bsm_cmd,
        "no ip pim bsm",
        NO_STR
        IP_STR
        PIM_STR
-       "Disables BSM support\n")
+       "Enable BSM support on the interface\n")
 {
-	nb_cli_enqueue_change(vty, "./bsm", NB_OP_MODIFY, "false");
-
-	return nb_cli_apply_changes(vty,
-			FRR_PIM_INTERFACE_XPATH, "frr-routing:ipv4");
+	return pim_process_no_bsm_cmd(vty);
 }
 
 DEFUN (ip_pim_ucast_bsm,
@@ -5053,26 +4655,7 @@ DEFUN (ip_pim_ucast_bsm,
        PIM_STR
        "Accept/Send unicast BSM on the interface\n")
 {
-	const struct lyd_node *igmp_enable_dnode;
-
-	igmp_enable_dnode =
-		yang_dnode_getf(vty->candidate_config->dnode,
-				FRR_GMP_ENABLE_XPATH, VTY_CURR_XPATH,
-				"frr-routing:ipv4");
-	if (!igmp_enable_dnode)
-		nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
-				      "true");
-	else {
-		if (!yang_dnode_get_bool(igmp_enable_dnode, "."))
-			nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
-					      "true");
-	}
-
-	nb_cli_enqueue_change(vty, "./unicast-bsm", NB_OP_MODIFY, "true");
-
-	return nb_cli_apply_changes(vty,
-			FRR_PIM_INTERFACE_XPATH, "frr-routing:ipv4");
-
+	return pim_process_unicast_bsm_cmd(vty);
 }
 
 DEFUN (no_ip_pim_ucast_bsm,
@@ -5081,12 +4664,9 @@ DEFUN (no_ip_pim_ucast_bsm,
        NO_STR
        IP_STR
        PIM_STR
-       "Block send/receive unicast BSM on this interface\n")
+       "Accept/Send unicast BSM on the interface\n")
 {
-	nb_cli_enqueue_change(vty, "./unicast-bsm", NB_OP_MODIFY, "false");
-
-	return nb_cli_apply_changes(vty,
-			FRR_PIM_INTERFACE_XPATH, "frr-routing:ipv4");
+	return pim_process_no_unicast_bsm_cmd(vty);
 }
 
 #if HAVE_BFDD > 0
@@ -5197,14 +4777,11 @@ DEFPY(ip_msdp_timers, ip_msdp_timers_cmd
       "Connection retry period (in seconds)\n")
 {
 	const char *vrfname;
-	char xpath[XPATH_MAXLEN];
 
 	vrfname = pim_cli_get_vrf_name(vty);
 	if (vrfname == NULL)
 		return CMD_WARNING_CONFIG_FAILED;
 
-	snprintf(xpath, sizeof(xpath), FRR_PIM_MSDP_XPATH, "frr-pim:pimd",
-		 "pim", vrfname, "frr-routing:ipv4");
 	nb_cli_enqueue_change(vty, "./hold-time", NB_OP_MODIFY, holdtime_str);
 	nb_cli_enqueue_change(vty, "./keep-alive", NB_OP_MODIFY, keepalive_str);
 	if (connretry_str)
@@ -5214,8 +4791,8 @@ DEFPY(ip_msdp_timers, ip_msdp_timers_cmd
 		nb_cli_enqueue_change(vty, "./connection-retry", NB_OP_DESTROY,
 				      NULL);
 
-	nb_cli_apply_changes(vty, xpath);
-
+	nb_cli_apply_changes(vty, FRR_PIM_MSDP_XPATH, "frr-pim:pimd", "pim",
+			     vrfname, "frr-routing:ipv4");
 	return CMD_SUCCESS;
 }
 
@@ -5230,20 +4807,17 @@ DEFPY(no_ip_msdp_timers, no_ip_msdp_time
       IGNORED_IN_NO_STR)
 {
 	const char *vrfname;
-	char xpath[XPATH_MAXLEN];
 
 	vrfname = pim_cli_get_vrf_name(vty);
 	if (vrfname == NULL)
 		return CMD_WARNING_CONFIG_FAILED;
 
-	snprintf(xpath, sizeof(xpath), FRR_PIM_MSDP_XPATH, "frr-pim:pimd",
-		 "pim", vrfname, "frr-routing:ipv4");
-
 	nb_cli_enqueue_change(vty, "./hold-time", NB_OP_DESTROY, NULL);
 	nb_cli_enqueue_change(vty, "./keep-alive", NB_OP_DESTROY, NULL);
 	nb_cli_enqueue_change(vty, "./connection-retry", NB_OP_DESTROY, NULL);
 
-	nb_cli_apply_changes(vty, xpath);
+	nb_cli_apply_changes(vty, FRR_PIM_MSDP_XPATH, "frr-pim:pimd", "pim",
+			     vrfname, "frr-routing:ipv4");
 
 	return CMD_SUCCESS;
 }
@@ -5437,7 +5011,7 @@ DEFPY(no_ip_msdp_mesh_group,
       IP_STR
       CFG_MSDP_STR
       "Delete MSDP mesh-group\n"
-      "Mesh group name")
+      "Mesh group name\n")
 {
 	const char *vrfname;
 	char xpath_value[XPATH_MAXLEN];
diff -urpN frr-frr-8.4.2/pimd/pim_cmd_common.c frr-frr-8.5/pimd/pim_cmd_common.c
--- frr-frr-8.4.2/pimd/pim_cmd_common.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_cmd_common.c	2023-03-13 20:01:47.000000000 +0600
@@ -299,7 +299,7 @@ int pim_process_no_rp_kat_cmd(struct vty
 		sizeof(rs_timer_xpath));
 
 	/* RFC4601 */
-	v = yang_dnode_get_uint16(vty->candidate_config->dnode,
+	v = yang_dnode_get_uint16(vty->candidate_config->dnode, "%s",
 				  rs_timer_xpath);
 	v = 3 * v + PIM_REGISTER_PROBE_TIME_DEFAULT;
 	if (v > UINT16_MAX)
@@ -688,7 +688,7 @@ int pim_process_no_rp_plist_cmd(struct v
 		return NB_OK;
 	}
 
-	plist = yang_dnode_get_string(plist_dnode, plist_xpath);
+	plist = yang_dnode_get_string(plist_dnode, "%s", plist_xpath);
 	if (strcmp(prefix_list, plist)) {
 		vty_out(vty, "%% Unable to find specified RP\n");
 		return NB_OK;
@@ -1140,42 +1140,24 @@ void pim_show_state(struct pim_instance
 				json_ifp_in = json_object_new_object();
 				json_object_object_add(json_source, in_ifname,
 						       json_ifp_in);
-				json_object_int_add(json_source, "Installed",
-						    c_oil->installed);
 				json_object_int_add(json_source, "installed",
 						    c_oil->installed);
 				json_object_boolean_add(json_source, "isRpt",
 							isRpt);
-				json_object_int_add(json_source, "RefCount",
-						    c_oil->oil_ref_count);
 				json_object_int_add(json_source, "refCount",
 						    c_oil->oil_ref_count);
-				json_object_int_add(json_source, "OilListSize",
-						    c_oil->oil_size);
 				json_object_int_add(json_source, "oilListSize",
 						    c_oil->oil_size);
 				json_object_int_add(
-					json_source, "OilRescan",
-					c_oil->oil_inherited_rescan);
-				json_object_int_add(
 					json_source, "oilRescan",
 					c_oil->oil_inherited_rescan);
-				json_object_int_add(json_source, "LastUsed",
-						    c_oil->cc.lastused);
 				json_object_int_add(json_source, "lastUsed",
 						    c_oil->cc.lastused);
-				json_object_int_add(json_source, "PacketCount",
-						    c_oil->cc.pktcnt);
 				json_object_int_add(json_source, "packetCount",
 						    c_oil->cc.pktcnt);
-				json_object_int_add(json_source, "ByteCount",
-						    c_oil->cc.bytecnt);
 				json_object_int_add(json_source, "byteCount",
 						    c_oil->cc.bytecnt);
 				json_object_int_add(json_source,
-						    "WrongInterface",
-						    c_oil->cc.wrong_if);
-				json_object_int_add(json_source,
 						    "wrongInterface",
 						    c_oil->cc.wrong_if);
 			}
@@ -1416,7 +1398,7 @@ void pim_show_upstream(struct pim_instan
 
 			nbr = pim_neighbor_find(
 				up->rpf.source_nexthop.interface,
-				up->rpf.rpf_addr);
+				up->rpf.rpf_addr, false);
 			if (nbr)
 				pim_time_timer_to_hhmmss(join_timer,
 							 sizeof(join_timer),
@@ -1728,14 +1710,8 @@ static void pim_show_join_helper(struct
 		json_object_string_add(
 			json_row, "channelJoinName",
 			pim_ifchannel_ifjoin_name(ch->ifjoin_state, ch->flags));
-		if (PIM_IF_FLAG_TEST_S_G_RPT(ch->flags)) {
-#if CONFDATE > 20230131
-			CPP_NOTICE(
-				"Remove JSON object commands with keys starting with capital")
-#endif
-			json_object_int_add(json_row, "SGRpt", 1);
+		if (PIM_IF_FLAG_TEST_S_G_RPT(ch->flags))
 			json_object_int_add(json_row, "sgRpt", 1);
-		}
 		if (PIM_IF_FLAG_TEST_PROTO_PIM(ch->flags))
 			json_object_int_add(json_row, "protocolPim", 1);
 		if (PIM_IF_FLAG_TEST_PROTO_IGMP(ch->flags))
@@ -2824,21 +2800,35 @@ static int pim_print_vty_pnc_cache_walkc
 	struct nexthop *nh_node = NULL;
 	ifindex_t first_ifindex;
 	struct interface *ifp = NULL;
+	struct ttable *tt = NULL;
+	char *table = NULL;
+
+	/* Prepare table. */
+	tt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);
+	ttable_add_row(tt, "Address|Interface|Nexthop");
+	tt->style.cell.rpad = 2;
+	tt->style.corner = '+';
+	ttable_restyle(tt);
 
 	for (nh_node = pnc->nexthop; nh_node; nh_node = nh_node->next) {
 		first_ifindex = nh_node->ifindex;
 
 		ifp = if_lookup_by_index(first_ifindex, pim->vrf->vrf_id);
 
-		vty_out(vty, "%-15pPA ", &pnc->rpf.rpf_addr);
-		vty_out(vty, "%-16s ", ifp ? ifp->name : "NULL");
 #if PIM_IPV == 4
-		vty_out(vty, "%pI4 ", &nh_node->gate.ipv4);
+		ttable_add_row(tt, "%pPA|%s|%pI4", &pnc->rpf.rpf_addr,
+			       ifp ? ifp->name : "NULL", &nh_node->gate.ipv4);
 #else
-		vty_out(vty, "%pI6 ", &nh_node->gate.ipv6);
+		ttable_add_row(tt, "%pPA|%s|%pI6", &pnc->rpf.rpf_addr,
+			       ifp ? ifp->name : "NULL", &nh_node->gate.ipv6);
 #endif
-		vty_out(vty, "\n");
 	}
+	/* Dump the generated table. */
+	table = ttable_dump(tt, "\n");
+	vty_out(vty, "%s\n", table);
+	XFREE(MTYPE_TMP, table);
+	ttable_del(tt);
+
 	return CMD_SUCCESS;
 }
 
@@ -2966,8 +2956,6 @@ void pim_show_nexthop(struct pim_instanc
 	} else {
 		vty_out(vty, "Number of registered addresses: %lu\n",
 			pim->rpf_hash->count);
-		vty_out(vty, "Address         Interface        Nexthop\n");
-		vty_out(vty, "---------------------------------------------\n");
 	}
 
 	if (uj) {
@@ -3428,6 +3416,66 @@ int pim_process_ssmpingd_cmd(struct vty
 	return nb_cli_apply_changes(vty, NULL);
 }
 
+int pim_process_bsm_cmd(struct vty *vty)
+{
+	const struct lyd_node *gm_enable_dnode;
+
+	gm_enable_dnode = yang_dnode_getf(vty->candidate_config->dnode,
+					  FRR_GMP_ENABLE_XPATH, VTY_CURR_XPATH,
+					  FRR_PIM_AF_XPATH_VAL);
+	if (!gm_enable_dnode)
+		nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
+				      "true");
+	else {
+		if (!yang_dnode_get_bool(gm_enable_dnode, "."))
+			nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
+					      "true");
+	}
+
+	nb_cli_enqueue_change(vty, "./bsm", NB_OP_MODIFY, "true");
+
+	return nb_cli_apply_changes(vty, FRR_PIM_INTERFACE_XPATH,
+				    FRR_PIM_AF_XPATH_VAL);
+}
+
+int pim_process_no_bsm_cmd(struct vty *vty)
+{
+	nb_cli_enqueue_change(vty, "./bsm", NB_OP_MODIFY, "false");
+
+	return nb_cli_apply_changes(vty, FRR_PIM_INTERFACE_XPATH,
+				    FRR_PIM_AF_XPATH_VAL);
+}
+
+int pim_process_unicast_bsm_cmd(struct vty *vty)
+{
+	const struct lyd_node *gm_enable_dnode;
+
+	gm_enable_dnode = yang_dnode_getf(vty->candidate_config->dnode,
+					  FRR_GMP_ENABLE_XPATH, VTY_CURR_XPATH,
+					  FRR_PIM_AF_XPATH_VAL);
+	if (!gm_enable_dnode)
+		nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
+				      "true");
+	else {
+		if (!yang_dnode_get_bool(gm_enable_dnode, "."))
+			nb_cli_enqueue_change(vty, "./pim-enable", NB_OP_MODIFY,
+					      "true");
+	}
+
+	nb_cli_enqueue_change(vty, "./unicast-bsm", NB_OP_MODIFY, "true");
+
+	return nb_cli_apply_changes(vty, FRR_PIM_INTERFACE_XPATH,
+				    FRR_PIM_AF_XPATH_VAL);
+}
+
+int pim_process_no_unicast_bsm_cmd(struct vty *vty)
+{
+	nb_cli_enqueue_change(vty, "./unicast-bsm", NB_OP_MODIFY, "false");
+
+	return nb_cli_apply_changes(vty, FRR_PIM_INTERFACE_XPATH,
+				    FRR_PIM_AF_XPATH_VAL);
+}
+
 static void show_scan_oil_stats(struct pim_instance *pim, struct vty *vty,
 				time_t now)
 {
@@ -3714,8 +3762,6 @@ void show_mroute(struct pim_instance *pi
 					    c_oil->oil_ref_count);
 			json_object_int_add(json_source, "oilSize",
 					    c_oil->oil_size);
-			json_object_int_add(json_source, "OilInheritedRescan",
-					    c_oil->oil_inherited_rescan);
 			json_object_int_add(json_source, "oilInheritedRescan",
 					    c_oil->oil_inherited_rescan);
 			json_object_string_add(json_source, "iif", in_ifname);
@@ -5195,3 +5241,449 @@ void clear_pim_interfaces(struct pim_ins
 			pim_neighbor_delete_all(ifp, "interface cleared");
 	}
 }
+
+void pim_show_bsr(struct pim_instance *pim, struct vty *vty, bool uj)
+{
+	char uptime[10];
+	char last_bsm_seen[10];
+	time_t now;
+	char bsr_state[20];
+	json_object *json = NULL;
+
+	if (pim_addr_is_any(pim->global_scope.current_bsr)) {
+		pim_time_uptime(uptime, sizeof(uptime),
+				pim->global_scope.current_bsr_first_ts);
+		pim_time_uptime(last_bsm_seen, sizeof(last_bsm_seen),
+				pim->global_scope.current_bsr_last_ts);
+	}
+
+	else {
+		now = pim_time_monotonic_sec();
+		pim_time_uptime(uptime, sizeof(uptime),
+				(now - pim->global_scope.current_bsr_first_ts));
+		pim_time_uptime(last_bsm_seen, sizeof(last_bsm_seen),
+				now - pim->global_scope.current_bsr_last_ts);
+	}
+
+	switch (pim->global_scope.state) {
+	case NO_INFO:
+		strlcpy(bsr_state, "NO_INFO", sizeof(bsr_state));
+		break;
+	case ACCEPT_ANY:
+		strlcpy(bsr_state, "ACCEPT_ANY", sizeof(bsr_state));
+		break;
+	case ACCEPT_PREFERRED:
+		strlcpy(bsr_state, "ACCEPT_PREFERRED", sizeof(bsr_state));
+		break;
+	default:
+		strlcpy(bsr_state, "", sizeof(bsr_state));
+	}
+
+
+	if (uj) {
+		json = json_object_new_object();
+		json_object_string_addf(json, "bsr", "%pPA",
+					&pim->global_scope.current_bsr);
+		json_object_int_add(json, "priority",
+				    pim->global_scope.current_bsr_prio);
+		json_object_int_add(json, "fragmentTag",
+				    pim->global_scope.bsm_frag_tag);
+		json_object_string_add(json, "state", bsr_state);
+		json_object_string_add(json, "upTime", uptime);
+		json_object_string_add(json, "lastBsmSeen", last_bsm_seen);
+	}
+
+	else {
+		vty_out(vty, "PIMv2 Bootstrap information\n");
+		vty_out(vty, "Current preferred BSR address: %pPA\n",
+			&pim->global_scope.current_bsr);
+		vty_out(vty,
+			"Priority        Fragment-Tag       State           UpTime\n");
+		vty_out(vty, "  %-12d    %-12d    %-13s    %7s\n",
+			pim->global_scope.current_bsr_prio,
+			pim->global_scope.bsm_frag_tag, bsr_state, uptime);
+		vty_out(vty, "Last BSM seen: %s\n", last_bsm_seen);
+	}
+
+	if (uj)
+		vty_json(vty, json);
+}
+
+int pim_show_bsr_helper(const char *vrf, struct vty *vty, bool uj)
+{
+	struct pim_instance *pim;
+	struct vrf *v;
+
+	v = vrf_lookup_by_name(vrf ? vrf : VRF_DEFAULT_NAME);
+
+	if (!v)
+		return CMD_WARNING;
+
+	pim = pim_get_pim_instance(v->vrf_id);
+
+	if (!pim) {
+		vty_out(vty, "%% Unable to find pim instance\n");
+		return CMD_WARNING;
+	}
+
+	pim_show_bsr(v->info, vty, uj);
+
+	return CMD_SUCCESS;
+}
+
+/*Display the group-rp mappings */
+static void pim_show_group_rp_mappings_info(struct pim_instance *pim,
+					    struct vty *vty, bool uj)
+{
+	struct bsgrp_node *bsgrp;
+	struct bsm_rpinfo *bsm_rp;
+	struct route_node *rn;
+	json_object *json = NULL;
+	json_object *json_group = NULL;
+	json_object *json_row = NULL;
+	struct ttable *tt = NULL;
+
+	if (uj) {
+		json = json_object_new_object();
+		json_object_string_addf(json, "BSR Address", "%pPA",
+					&pim->global_scope.current_bsr);
+	} else
+		vty_out(vty, "BSR Address  %pPA\n",
+			&pim->global_scope.current_bsr);
+
+	for (rn = route_top(pim->global_scope.bsrp_table); rn;
+	     rn = route_next(rn)) {
+		bsgrp = (struct bsgrp_node *)rn->info;
+
+		if (!bsgrp)
+			continue;
+
+		char grp_str[PREFIX_STRLEN];
+
+		prefix2str(&bsgrp->group, grp_str, sizeof(grp_str));
+
+		if (uj) {
+			json_object_object_get_ex(json, grp_str, &json_group);
+			if (!json_group) {
+				json_group = json_object_new_object();
+				json_object_object_add(json, grp_str,
+						       json_group);
+			}
+		} else {
+			vty_out(vty, "Group Address %pFX\n", &bsgrp->group);
+			vty_out(vty, "--------------------------\n");
+			/* Prepare table. */
+			tt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);
+			ttable_add_row(tt, "Rp Address|priority|Holdtime|Hash");
+			tt->style.cell.rpad = 2;
+			tt->style.corner = '+';
+			ttable_restyle(tt);
+
+			ttable_add_row(tt, "%s|%c|%c|%c", "(ACTIVE)", ' ', ' ',
+				       ' ');
+		}
+
+		frr_each (bsm_rpinfos, bsgrp->bsrp_list, bsm_rp) {
+			if (uj) {
+				json_row = json_object_new_object();
+				json_object_string_addf(json_row, "Rp Address",
+							"%pPA",
+							&bsm_rp->rp_address);
+				json_object_int_add(json_row, "Rp HoldTime",
+						    bsm_rp->rp_holdtime);
+				json_object_int_add(json_row, "Rp Priority",
+						    bsm_rp->rp_prio);
+				json_object_int_add(json_row, "Hash Val",
+						    bsm_rp->hash);
+				json_object_object_addf(json_group, json_row,
+							"%pPA",
+							&bsm_rp->rp_address);
+
+			} else {
+				ttable_add_row(
+					tt, "%pPA|%u|%u|%u",
+					&bsm_rp->rp_address, bsm_rp->rp_prio,
+					bsm_rp->rp_holdtime, bsm_rp->hash);
+			}
+		}
+		/* Dump the generated table. */
+		if (tt) {
+			char *table = NULL;
+
+			table = ttable_dump(tt, "\n");
+			vty_out(vty, "%s\n", table);
+			XFREE(MTYPE_TMP, table);
+			ttable_del(tt);
+			tt = NULL;
+		}
+		if (!bsm_rpinfos_count(bsgrp->bsrp_list) && !uj)
+			vty_out(vty, "Active List is empty.\n");
+
+		if (uj) {
+			json_object_int_add(json_group, "Pending RP count",
+					    bsgrp->pend_rp_cnt);
+		} else {
+			vty_out(vty, "(PENDING)\n");
+			vty_out(vty, "Pending RP count :%d\n",
+				bsgrp->pend_rp_cnt);
+			if (bsgrp->pend_rp_cnt) {
+				/* Prepare table. */
+				tt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);
+				ttable_add_row(
+					tt,
+					"Rp Address|priority|Holdtime|Hash");
+				tt->style.cell.rpad = 2;
+				tt->style.corner = '+';
+				ttable_restyle(tt);
+			}
+		}
+
+		frr_each (bsm_rpinfos, bsgrp->partial_bsrp_list, bsm_rp) {
+			if (uj) {
+				json_row = json_object_new_object();
+				json_object_string_addf(json_row, "Rp Address",
+							"%pPA",
+							&bsm_rp->rp_address);
+				json_object_int_add(json_row, "Rp HoldTime",
+						    bsm_rp->rp_holdtime);
+				json_object_int_add(json_row, "Rp Priority",
+						    bsm_rp->rp_prio);
+				json_object_int_add(json_row, "Hash Val",
+						    bsm_rp->hash);
+				json_object_object_addf(json_group, json_row,
+							"%pPA",
+							&bsm_rp->rp_address);
+			} else {
+				ttable_add_row(
+					tt, "%pPA|%u|%u|%u",
+					&bsm_rp->rp_address, bsm_rp->rp_prio,
+					bsm_rp->rp_holdtime, bsm_rp->hash);
+			}
+		}
+		/* Dump the generated table. */
+		if (tt) {
+			char *table = NULL;
+
+			table = ttable_dump(tt, "\n");
+			vty_out(vty, "%s\n", table);
+			XFREE(MTYPE_TMP, table);
+			ttable_del(tt);
+		}
+		if (!bsm_rpinfos_count(bsgrp->partial_bsrp_list) && !uj)
+			vty_out(vty, "Partial List is empty\n");
+
+		if (!uj)
+			vty_out(vty, "\n");
+	}
+
+	if (uj)
+		vty_json(vty, json);
+}
+
+int pim_show_group_rp_mappings_info_helper(const char *vrf, struct vty *vty,
+					   bool uj)
+{
+	struct pim_instance *pim;
+	struct vrf *v;
+
+	v = vrf_lookup_by_name(vrf ? vrf : VRF_DEFAULT_NAME);
+
+	if (!v)
+		return CMD_WARNING;
+
+	pim = v->info;
+
+	if (!pim) {
+		vty_out(vty, "%% Unable to find pim instance\n");
+		return CMD_WARNING;
+	}
+
+	pim_show_group_rp_mappings_info(v->info, vty, uj);
+
+	return CMD_SUCCESS;
+}
+
+/* Display the bsm database details */
+static void pim_show_bsm_db(struct pim_instance *pim, struct vty *vty, bool uj)
+{
+	int count = 0;
+	int fragment = 1;
+	struct bsm_frag *bsfrag;
+	json_object *json = NULL;
+	json_object *json_group = NULL;
+	json_object *json_row = NULL;
+
+	count = bsm_frags_count(pim->global_scope.bsm_frags);
+
+	if (uj) {
+		json = json_object_new_object();
+		json_object_int_add(json, "Number of the fragments", count);
+	} else {
+		vty_out(vty, "Scope Zone: Global\n");
+		vty_out(vty, "Number of the fragments: %d\n", count);
+		vty_out(vty, "\n");
+	}
+
+	frr_each (bsm_frags, pim->global_scope.bsm_frags, bsfrag) {
+		char grp_str[PREFIX_STRLEN];
+		struct bsmmsg_grpinfo *group;
+		struct bsmmsg_rpinfo *bsm_rpinfo;
+		struct prefix grp;
+		struct bsm_hdr *hdr;
+		pim_addr bsr_addr;
+		uint32_t offset = 0;
+		uint8_t *buf;
+		uint32_t len = 0;
+		uint32_t frag_rp_cnt = 0;
+
+		buf = bsfrag->data;
+		len = bsfrag->size;
+
+		/* skip pim header */
+		buf += PIM_MSG_HEADER_LEN;
+		len -= PIM_MSG_HEADER_LEN;
+
+		hdr = (struct bsm_hdr *)buf;
+		/* NB: bshdr->bsr_addr.addr is packed/unaligned => memcpy */
+		memcpy(&bsr_addr, &hdr->bsr_addr.addr, sizeof(bsr_addr));
+
+		/* BSM starts with bsr header */
+		buf += sizeof(struct bsm_hdr);
+		len -= sizeof(struct bsm_hdr);
+
+		if (uj) {
+			json_object_string_addf(json, "BSR address", "%pPA",
+						&bsr_addr);
+			json_object_int_add(json, "BSR priority",
+					    hdr->bsr_prio);
+			json_object_int_add(json, "Hashmask Length",
+					    hdr->hm_len);
+			json_object_int_add(json, "Fragment Tag",
+					    ntohs(hdr->frag_tag));
+		} else {
+			vty_out(vty, "BSM Fragment : %d\n", fragment);
+			vty_out(vty, "------------------\n");
+			vty_out(vty, "%-15s %-15s %-15s %-15s\n", "BSR-Address",
+				"BSR-Priority", "Hashmask-len", "Fragment-Tag");
+			vty_out(vty, "%-15pPA %-15d %-15d %-15d\n", &bsr_addr,
+				hdr->bsr_prio, hdr->hm_len,
+				ntohs(hdr->frag_tag));
+		}
+
+		vty_out(vty, "\n");
+
+		while (offset < len) {
+			group = (struct bsmmsg_grpinfo *)buf;
+
+			if (group->group.family == PIM_MSG_ADDRESS_FAMILY_IPV4)
+				grp.family = AF_INET;
+			else if (group->group.family ==
+				 PIM_MSG_ADDRESS_FAMILY_IPV6)
+				grp.family = AF_INET6;
+
+			grp.prefixlen = group->group.mask;
+#if PIM_IPV == 4
+			grp.u.prefix4 = group->group.addr;
+#else
+			grp.u.prefix6 = group->group.addr;
+#endif
+
+			prefix2str(&grp, grp_str, sizeof(grp_str));
+
+			buf += sizeof(struct bsmmsg_grpinfo);
+			offset += sizeof(struct bsmmsg_grpinfo);
+
+			if (uj) {
+				json_object_object_get_ex(json, grp_str,
+							  &json_group);
+				if (!json_group) {
+					json_group = json_object_new_object();
+					json_object_int_add(json_group,
+							    "Rp Count",
+							    group->rp_count);
+					json_object_int_add(
+						json_group, "Fragment Rp count",
+						group->frag_rp_count);
+					json_object_object_add(json, grp_str,
+							       json_group);
+				}
+			} else {
+				vty_out(vty, "Group : %s\n", grp_str);
+				vty_out(vty, "-------------------\n");
+				vty_out(vty, "Rp Count:%d\n", group->rp_count);
+				vty_out(vty, "Fragment Rp Count : %d\n",
+					group->frag_rp_count);
+			}
+
+			frag_rp_cnt = group->frag_rp_count;
+
+			if (!frag_rp_cnt)
+				continue;
+
+			if (!uj)
+				vty_out(vty,
+					"RpAddress     HoldTime     Priority\n");
+
+			while (frag_rp_cnt--) {
+				pim_addr rp_addr;
+
+				bsm_rpinfo = (struct bsmmsg_rpinfo *)buf;
+				/* unaligned, again */
+				memcpy(&rp_addr, &bsm_rpinfo->rpaddr.addr,
+				       sizeof(rp_addr));
+
+				buf += sizeof(struct bsmmsg_rpinfo);
+				offset += sizeof(struct bsmmsg_rpinfo);
+
+				if (uj) {
+					json_row = json_object_new_object();
+					json_object_string_addf(
+						json_row, "Rp Address", "%pPA",
+						&rp_addr);
+					json_object_int_add(
+						json_row, "Rp HoldTime",
+						ntohs(bsm_rpinfo->rp_holdtime));
+					json_object_int_add(json_row,
+							    "Rp Priority",
+							    bsm_rpinfo->rp_pri);
+					json_object_object_addf(
+						json_group, json_row, "%pPA",
+						&rp_addr);
+				} else {
+					vty_out(vty, "%-15pPA %-12d %d\n",
+						&rp_addr,
+						ntohs(bsm_rpinfo->rp_holdtime),
+						bsm_rpinfo->rp_pri);
+				}
+			}
+			vty_out(vty, "\n");
+		}
+
+		fragment++;
+	}
+
+	if (uj)
+		vty_json(vty, json);
+}
+
+int pim_show_bsm_db_helper(const char *vrf, struct vty *vty, bool uj)
+{
+	struct pim_instance *pim;
+	struct vrf *v;
+
+	v = vrf_lookup_by_name(vrf ? vrf : VRF_DEFAULT_NAME);
+
+	if (!v)
+		return CMD_WARNING;
+
+	pim = v->info;
+
+	if (!pim) {
+		vty_out(vty, "%% Unable to find pim instance\n");
+		return CMD_WARNING;
+	}
+
+	pim_show_bsm_db(v->info, vty, uj);
+
+	return CMD_SUCCESS;
+}
diff -urpN frr-frr-8.4.2/pimd/pim_cmd_common.h frr-frr-8.5/pimd/pim_cmd_common.h
--- frr-frr-8.4.2/pimd/pim_cmd_common.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_cmd_common.h	2023-03-13 20:01:47.000000000 +0600
@@ -62,6 +62,10 @@ int pim_process_ip_mroute_cmd(struct vty
 			      const char *group_str, const char *source_str);
 int pim_process_no_ip_mroute_cmd(struct vty *vty, const char *interface,
 				 const char *group_str, const char *src_str);
+int pim_process_bsm_cmd(struct vty *vty);
+int pim_process_no_bsm_cmd(struct vty *vty);
+int pim_process_unicast_bsm_cmd(struct vty *vty);
+int pim_process_no_unicast_bsm_cmd(struct vty *vty);
 void json_object_pim_upstream_add(json_object *json, struct pim_upstream *up);
 void pim_show_rpf(struct pim_instance *pim, struct vty *vty, json_object *json);
 void pim_show_neighbors_secondary(struct pim_instance *pim, struct vty *vty);
@@ -114,6 +118,9 @@ void pim_show_neighbors_single(struct pi
 			       const char *neighbor, json_object *json);
 void pim_show_neighbors(struct pim_instance *pim, struct vty *vty,
 			json_object *json);
+int pim_show_group_rp_mappings_info_helper(const char *vrf, struct vty *vty,
+					   bool uj);
+int pim_show_bsm_db_helper(const char *vrf, struct vty *vty, bool uj);
 int gm_process_query_max_response_time_cmd(struct vty *vty,
 					   const char *qmrt_str);
 int gm_process_no_query_max_response_time_cmd(struct vty *vty);
@@ -186,6 +193,8 @@ void pim_show_interface_traffic(struct p
 int pim_show_interface_traffic_helper(const char *vrf, const char *if_name,
 				      struct vty *vty, bool uj);
 void clear_pim_interfaces(struct pim_instance *pim);
+void pim_show_bsr(struct pim_instance *pim, struct vty *vty, bool uj);
+int pim_show_bsr_helper(const char *vrf, struct vty *vty, bool uj);
 /*
  * Special Macro to allow us to get the correct pim_instance;
  */
diff -urpN frr-frr-8.4.2/pimd/pim_hello.c frr-frr-8.5/pimd/pim_hello.c
--- frr-frr-8.4.2/pimd/pim_hello.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_hello.c	2023-03-13 20:01:47.000000000 +0600
@@ -290,7 +290,7 @@ int pim_hello_recv(struct interface *ifp
 	  New neighbor?
 	*/
 
-	neigh = pim_neighbor_find(ifp, src_addr);
+	neigh = pim_neighbor_find(ifp, src_addr, false);
 	if (!neigh) {
 		/* Add as new neighbor */
 
@@ -389,8 +389,10 @@ int pim_hello_build_tlv(struct interface
 	uint8_t *curr = tlv_buf;
 	uint8_t *pastend = tlv_buf + tlv_buf_size;
 	uint8_t *tmp;
+#if PIM_IPV == 4
 	struct pim_interface *pim_ifp = ifp->info;
 	struct pim_instance *pim = pim_ifp->pim;
+#endif
 
 	/*
 	 * Append options
@@ -452,19 +454,20 @@ int pim_hello_build_tlv(struct interface
 
 	/* Secondary Address List */
 	if (ifp->connected->count) {
-		curr = pim_tlv_append_addrlist_ucast(curr, pastend,
-						     ifp->connected, AF_INET);
+		curr = pim_tlv_append_addrlist_ucast(curr, pastend, ifp,
+						     PIM_AF);
 		if (!curr) {
 			if (PIM_DEBUG_PIM_HELLO) {
 				zlog_debug(
-					"%s: could not set PIM hello v4 Secondary Address List option for interface %s",
-					__func__, ifp->name);
+					"%s: could not set PIM hello %s Secondary Address List option for interface %s",
+					__func__, PIM_AF_NAME, ifp->name);
 			}
 			return -4;
 		}
+#if PIM_IPV == 4
 		if (pim->send_v6_secondary) {
-			curr = pim_tlv_append_addrlist_ucast(
-				curr, pastend, ifp->connected, AF_INET6);
+			curr = pim_tlv_append_addrlist_ucast(curr, pastend, ifp,
+							     AF_INET6);
 			if (!curr) {
 				if (PIM_DEBUG_PIM_HELLO) {
 					zlog_debug(
@@ -474,6 +477,7 @@ int pim_hello_build_tlv(struct interface
 				return -4;
 			}
 		}
+#endif
 	}
 
 	return curr - tlv_buf;
diff -urpN frr-frr-8.4.2/pimd/pim_iface.c frr-frr-8.5/pimd/pim_iface.c
--- frr-frr-8.4.2/pimd/pim_iface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_iface.c	2023-03-13 20:01:47.000000000 +0600
@@ -689,7 +689,7 @@ static void pim_if_addr_del_pim(struct c
 {
 	struct pim_interface *pim_ifp = ifc->ifp->info;
 
-	if (ifc->address->family != AF_INET) {
+	if (ifc->address->family != PIM_AF) {
 		/* non-IPv4 address */
 		return;
 	}
@@ -843,7 +843,7 @@ void pim_if_addr_del_all(struct interfac
 	for (ALL_LIST_ELEMENTS(ifp->connected, node, nextnode, ifc)) {
 		struct prefix *p = ifc->address;
 
-		if (p->family != AF_INET)
+		if (p->family != PIM_AF)
 			continue;
 
 		pim_if_addr_del(ifc, 1 /* force_prim_as_any=true */);
@@ -1546,8 +1546,10 @@ void pim_if_create_pimreg(struct pim_ins
 					       pim->vrf->name);
 		pim->regiface->ifindex = PIM_OIF_PIM_REGISTER_VIF;
 
-		pim_if_new(pim->regiface, false, false, true,
-			false /*vxlan_term*/);
+		if (!pim->regiface->info)
+			pim_if_new(pim->regiface, false, false, true,
+				   false /*vxlan_term*/);
+
 		/*
 		 * On vrf moves we delete the interface if there
 		 * is nothing going on with it.  We cannot have
diff -urpN frr-frr-8.4.2/pimd/pim_ifchannel.c frr-frr-8.5/pimd/pim_ifchannel.c
--- frr-frr-8.4.2/pimd/pim_ifchannel.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_ifchannel.c	2023-03-13 20:01:47.000000000 +0600
@@ -711,6 +711,8 @@ static void on_ifjoin_prune_pending_time
 			pim_channel_del_oif(
 				ch->upstream->channel_oil, ifp,
 				PIM_OIF_FLAG_PROTO_STAR, __func__);
+			pim_channel_del_oif(ch->upstream->channel_oil, ifp,
+					    PIM_OIF_FLAG_PROTO_PIM, __func__);
 			if (!ch->upstream->channel_oil->installed)
 				pim_upstream_mroute_add(
 					ch->upstream->channel_oil,
diff -urpN frr-frr-8.4.2/pimd/pim_igmp_mtrace.c frr-frr-8.5/pimd/pim_igmp_mtrace.c
--- frr-frr-8.4.2/pimd/pim_igmp_mtrace.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_igmp_mtrace.c	2023-03-13 20:01:47.000000000 +0600
@@ -365,19 +365,9 @@ static int mtrace_un_forward_packet(stru
 	if (ip_hdr->ip_ttl-- <= 1)
 		return -1;
 
-	ip_hdr->ip_sum = in_cksum(ip_hdr, ip_hdr->ip_hl * 4);
-
-	fd = pim_socket_raw(IPPROTO_RAW);
-
-	if (fd < 0)
-		return -1;
-
-	pim_socket_ip_hdr(fd);
-
 	if (interface == NULL) {
 		memset(&nexthop, 0, sizeof(nexthop));
 		if (!pim_nexthop_lookup(pim, &nexthop, ip_hdr->ip_dst, 0)) {
-			close(fd);
 			if (PIM_DEBUG_MTRACE)
 				zlog_debug(
 					"Dropping mtrace packet, no route to destination");
@@ -389,6 +379,15 @@ static int mtrace_un_forward_packet(stru
 		if_out = interface;
 	}
 
+	ip_hdr->ip_sum = in_cksum(ip_hdr, ip_hdr->ip_hl * 4);
+
+	fd = pim_socket_raw(IPPROTO_RAW);
+
+	if (fd < 0)
+		return -1;
+
+	pim_socket_ip_hdr(fd);
+
 	ret = pim_socket_bind(fd, if_out);
 
 	if (ret < 0) {
@@ -770,7 +769,8 @@ int igmp_mtrace_recv_qry_req(struct gm_s
 	}
 
 	/* 6.2.2 8. If this router is the Rendez-vous Point */
-	if (pim_rp_i_am_rp(pim, mtracep->grp_addr)) {
+	if (mtracep->grp_addr.s_addr != INADDR_ANY &&
+	    pim_rp_i_am_rp(pim, mtracep->grp_addr)) {
 		mtrace_rsp_set_fwd_code(rspp, MTRACE_FWD_CODE_REACHED_RP);
 		/* 7.7.1. PIM-SM ...RP has not performed source-specific join */
 		if (rspp->src_mask == MTRACE_SRC_MASK_GROUP)
diff -urpN frr-frr-8.4.2/pimd/pim_join.c frr-frr-8.5/pimd/pim_join.c
--- frr-frr-8.4.2/pimd/pim_join.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_join.c	2023-03-13 20:01:47.000000000 +0600
@@ -72,8 +72,21 @@ static void recv_join(struct interface *
 	 * If the RPT and WC are set it's a (*,G)
 	 * and the source is the RP
 	 */
-	if ((source_flags & PIM_RPT_BIT_MASK)
-	    && (source_flags & PIM_WILDCARD_BIT_MASK)) {
+	if (CHECK_FLAG(source_flags, PIM_WILDCARD_BIT_MASK)) {
+		/* As per RFC 7761 Section 4.9.1:
+		 * The RPT (or Rendezvous Point Tree) bit is a 1-bit value for
+		 * use with PIM Join/Prune messages (see Section 4.9.5.1). If
+		 * the WC bit is 1, the RPT bit MUST be 1.
+		 */
+		if (!CHECK_FLAG(source_flags, PIM_RPT_BIT_MASK)) {
+			if (PIM_DEBUG_PIM_J_P)
+				zlog_debug(
+					"Discarding (*,G)=%pSG join since WC bit is set but RPT bit is unset",
+					sg);
+
+			return;
+		}
+
 		struct pim_rpf *rp = RP(pim_ifp->pim, sg->grp);
 		pim_addr rpf_addr;
 
@@ -127,8 +140,21 @@ static void recv_prune(struct interface
 
 	++pim_ifp->pim_ifstat_prune_recv;
 
-	if ((source_flags & PIM_RPT_BIT_MASK)
-	    && (source_flags & PIM_WILDCARD_BIT_MASK)) {
+	if (CHECK_FLAG(source_flags, PIM_WILDCARD_BIT_MASK)) {
+		/* As per RFC 7761 Section 4.9.1:
+		 * The RPT (or Rendezvous Point Tree) bit is a 1-bit value for
+		 * use with PIM Join/Prune messages (see Section 4.9.5.1). If
+		 * the WC bit is 1, the RPT bit MUST be 1.
+		 */
+		if (!CHECK_FLAG(source_flags, PIM_RPT_BIT_MASK)) {
+			if (PIM_DEBUG_PIM_J_P)
+				zlog_debug(
+					"Discarding (*,G)=%pSG prune since WC bit is set but RPT bit is unset",
+					sg);
+
+			return;
+		}
+
 		/*
 		 * RFC 4601 Section 4.5.2:
 		 * Received Prune(*,G) messages are processed even if the
diff -urpN frr-frr-8.4.2/pimd/pim_memory.c frr-frr-8.5/pimd/pim_memory.c
--- frr-frr-8.4.2/pimd/pim_memory.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_memory.c	2023-03-13 20:01:47.000000000 +0600
@@ -37,7 +37,6 @@ DEFINE_MTYPE(PIMD, PIM_IFCHANNEL, "PIM i
 DEFINE_MTYPE(PIMD, PIM_UPSTREAM, "PIM upstream (S,G) state");
 DEFINE_MTYPE(PIMD, PIM_SSMPINGD, "PIM sspimgd socket");
 DEFINE_MTYPE(PIMD, PIM_STATIC_ROUTE, "PIM Static Route");
-DEFINE_MTYPE(PIMD, PIM_BR, "PIM Bridge Router info");
 DEFINE_MTYPE(PIMD, PIM_RP, "PIM RP info");
 DEFINE_MTYPE(PIMD, PIM_FILTER_NAME, "PIM RP filter info");
 DEFINE_MTYPE(PIMD, PIM_MSDP_PEER, "PIM MSDP peer");
diff -urpN frr-frr-8.4.2/pimd/pim_memory.h frr-frr-8.5/pimd/pim_memory.h
--- frr-frr-8.4.2/pimd/pim_memory.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_memory.h	2023-03-13 20:01:47.000000000 +0600
@@ -36,7 +36,6 @@ DECLARE_MTYPE(PIM_IFCHANNEL);
 DECLARE_MTYPE(PIM_UPSTREAM);
 DECLARE_MTYPE(PIM_SSMPINGD);
 DECLARE_MTYPE(PIM_STATIC_ROUTE);
-DECLARE_MTYPE(PIM_BR);
 DECLARE_MTYPE(PIM_RP);
 DECLARE_MTYPE(PIM_FILTER_NAME);
 DECLARE_MTYPE(PIM_MSDP_PEER);
diff -urpN frr-frr-8.4.2/pimd/pim_mroute.c frr-frr-8.5/pimd/pim_mroute.c
--- frr-frr-8.4.2/pimd/pim_mroute.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_mroute.c	2023-03-13 20:01:47.000000000 +0600
@@ -47,6 +47,8 @@
 #include "pim_msg.h"
 
 static void mroute_read_on(struct pim_instance *pim);
+static int pim_upstream_mroute_update(struct channel_oil *c_oil,
+				      const char *name);
 
 int pim_mroute_set(struct pim_instance *pim, int enable)
 {
@@ -160,19 +162,36 @@ int pim_mroute_msg_nocache(int fd, struc
 	struct pim_upstream *up;
 	struct pim_rpf *rpg;
 	pim_sgaddr sg;
+	bool desync = false;
 
-	rpg = pim_ifp ? RP(pim_ifp->pim, msg->msg_im_dst) : NULL;
+	memset(&sg, 0, sizeof(sg));
+	sg.src = msg->msg_im_src;
+	sg.grp = msg->msg_im_dst;
+
+	if (!pim_ifp) {
+		if (PIM_DEBUG_MROUTE)
+			zlog_debug(
+				"%s: PIM not enabled on interface, dropping packet to %pSG",
+				ifp->name, &sg);
+		return 0;
+	}
+
+	rpg = RP(pim_ifp->pim, msg->msg_im_dst);
 	/*
 	 * If the incoming interface is unknown OR
 	 * the Interface type is SSM we don't need to
 	 * do anything here
 	 */
-	if (!rpg || pim_rpf_addr_is_inaddr_any(rpg)) {
-		if (PIM_DEBUG_MROUTE_DETAIL)
-			zlog_debug(
-				"%s: Interface is not configured correctly to handle incoming packet: Could be !pim_ifp, !SM, !RP",
-				__func__);
-
+	if (!rpg) {
+		if (PIM_DEBUG_MROUTE)
+			zlog_debug("%s: no RPF for packet to %pSG", ifp->name,
+				   &sg);
+		return 0;
+	}
+	if (pim_rpf_addr_is_inaddr_any(rpg)) {
+		if (PIM_DEBUG_MROUTE)
+			zlog_debug("%s: null RPF for packet to %pSG", ifp->name,
+				   &sg);
 		return 0;
 	}
 
@@ -181,22 +200,21 @@ int pim_mroute_msg_nocache(int fd, struc
 	 * us
 	 */
 	if (!pim_if_connected_to_source(ifp, msg->msg_im_src)) {
-		if (PIM_DEBUG_MROUTE_DETAIL)
+		if (PIM_DEBUG_MROUTE)
 			zlog_debug(
-				"%s: Received incoming packet that doesn't originate on our seg",
-				__func__);
+				"%s: incoming packet to %pSG from non-connected source",
+				ifp->name, &sg);
 		return 0;
 	}
 
-	memset(&sg, 0, sizeof(sg));
-	sg.src = msg->msg_im_src;
-	sg.grp = msg->msg_im_dst;
-
 	if (!(PIM_I_am_DR(pim_ifp))) {
+		/* unlike the other debug messages, this one is further in the
+		 * "normal operation" category and thus under _DETAIL
+		 */
 		if (PIM_DEBUG_MROUTE_DETAIL)
 			zlog_debug(
-				"%s: Interface is not the DR blackholing incoming traffic for %pSG",
-				__func__, &sg);
+				"%s: not DR on interface, not forwarding traffic for %pSG",
+				ifp->name, &sg);
 
 		/*
 		 * We are not the DR, but we are still receiving packets
@@ -217,6 +235,12 @@ int pim_mroute_msg_nocache(int fd, struc
 
 	up = pim_upstream_find_or_add(&sg, ifp, PIM_UPSTREAM_FLAG_MASK_FHR,
 				      __func__);
+	if (up->channel_oil->installed) {
+		zlog_warn(
+			"%s: NOCACHE for %pSG, MFC entry disappeared - reinstalling",
+			ifp->name, &sg);
+		desync = true;
+	}
 
 	/*
 	 * I moved this debug till after the actual add because
@@ -240,6 +264,11 @@ int pim_mroute_msg_nocache(int fd, struc
 	/* if we have receiver, inherit from parent */
 	pim_upstream_inherited_olist_decide(pim_ifp->pim, up);
 
+	/* we just got NOCACHE from the kernel, so...  MFC is not in the
+	 * kernel for some reason or another.  Try installing again.
+	 */
+	if (desync)
+		pim_upstream_mroute_update(up->channel_oil, __func__);
 	return 0;
 }
 
@@ -634,7 +663,7 @@ static int process_igmp_packet(struct pi
 
 	connected_src = pim_if_connected_to_source(ifp, ip_hdr->ip_src);
 
-	if (!connected_src) {
+	if (!connected_src && !pim_addr_is_any(ip_hdr->ip_src)) {
 		if (PIM_DEBUG_GM_PACKETS) {
 			zlog_debug(
 				"Recv IGMP packet on interface: %s from a non-connected source: %pI4",
@@ -644,7 +673,8 @@ static int process_igmp_packet(struct pi
 	}
 
 	pim_ifp = ifp->info;
-	ifaddr = connected_src->u.prefix4;
+	ifaddr = connected_src ? connected_src->u.prefix4
+			       : pim_ifp->primary_address;
 	igmp = pim_igmp_sock_lookup_ifaddr(pim_ifp->gm_socket_list, ifaddr);
 
 	if (PIM_DEBUG_GM_PACKETS) {
@@ -655,11 +685,11 @@ static int process_igmp_packet(struct pi
 	}
 	if (igmp)
 		pim_igmp_packet(igmp, (char *)buf, buf_size);
-	else if (PIM_DEBUG_GM_PACKETS) {
+	else if (PIM_DEBUG_GM_PACKETS)
 		zlog_debug(
-			"No IGMP socket on interface: %s with connected source: %pFX",
-			ifp->name, connected_src);
-	}
+			"No IGMP socket on interface: %s with connected source: %pI4",
+			ifp->name, &ifaddr);
+
 	return 0;
 }
 #endif
diff -urpN frr-frr-8.4.2/pimd/pim_mroute.h frr-frr-8.5/pimd/pim_mroute.h
--- frr-frr-8.4.2/pimd/pim_mroute.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_mroute.h	2023-03-13 20:01:47.000000000 +0600
@@ -39,10 +39,8 @@
 #if defined(HAVE_LINUX_MROUTE_H)
 #include <linux/mroute.h>
 #else
-#ifndef VTYSH_EXTRACT_PL
 #include "linux/mroute.h"
 #endif
-#endif
 
 typedef struct vifctl pim_vifctl;
 typedef struct igmpmsg kernmsg;
@@ -86,10 +84,8 @@ typedef struct sioc_sg_req pim_sioc_sg_r
 #if defined(HAVE_LINUX_MROUTE6_H)
 #include <linux/mroute6.h>
 #else
-#ifndef VTYSH_EXTRACT_PL
 #include "linux/mroute6.h"
 #endif
-#endif
 
 #ifndef MRT_INIT
 #define MRT_BASE MRT6_BASE
diff -urpN frr-frr-8.4.2/pimd/pim_msdp_packet.c frr-frr-8.5/pimd/pim_msdp_packet.c
--- frr-frr-8.4.2/pimd/pim_msdp_packet.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_msdp_packet.c	2023-03-13 20:01:47.000000000 +0600
@@ -83,10 +83,18 @@ static void pim_msdp_pkt_sa_dump_one(str
 
 static void pim_msdp_pkt_sa_dump(struct stream *s)
 {
+	const size_t header_length = PIM_MSDP_SA_X_SIZE - PIM_MSDP_HEADER_SIZE;
+	size_t payload_length;
 	int entry_cnt;
 	int i;
 	struct in_addr rp; /* Last RP address associated with this SA */
 
+	if (header_length > STREAM_READABLE(s)) {
+		zlog_err("BUG MSDP SA bad header (readable %zu expected %zu)",
+			 STREAM_READABLE(s), header_length);
+		return;
+	}
+
 	entry_cnt = stream_getc(s);
 	rp.s_addr = stream_get_ipv4(s);
 
@@ -96,6 +104,13 @@ static void pim_msdp_pkt_sa_dump(struct
 		zlog_debug("  entry_cnt %d rp %s", entry_cnt, rp_str);
 	}
 
+	payload_length = (size_t)entry_cnt * PIM_MSDP_SA_ONE_ENTRY_SIZE;
+	if (payload_length > STREAM_READABLE(s)) {
+		zlog_err("BUG MSDP SA bad length (readable %zu expected %zu)",
+			 STREAM_READABLE(s), payload_length);
+		return;
+	}
+
 	/* dump SAs */
 	for (i = 0; i < entry_cnt; ++i) {
 		pim_msdp_pkt_sa_dump_one(s);
@@ -116,6 +131,11 @@ static void pim_msdp_pkt_dump(struct pim
 		return;
 	}
 
+	if (len < PIM_MSDP_HEADER_SIZE) {
+		zlog_err("invalid MSDP header length");
+		return;
+	}
+
 	switch (type) {
 	case PIM_MSDP_V4_SOURCE_ACTIVE:
 		pim_msdp_pkt_sa_dump(s);
@@ -711,6 +731,30 @@ void pim_msdp_read(struct thread *thread
 			pim_msdp_pkt_rxed_with_fatal_error(mp);
 			return;
 		}
+
+		/*
+		 * Handle messages with longer than expected TLV size: resize
+		 * the stream to handle reading the whole message.
+		 *
+		 * RFC 3618 Section 12. 'Packet Formats':
+		 * > ... If an implementation receives a TLV whose length
+		 * > exceeds the maximum TLV length specified below, the TLV
+		 * > SHOULD be accepted. Any additional data, including possible
+		 * > next TLV's in the same message, SHOULD be ignored, and the
+		 * > MSDP session should not be reset. ...
+		 */
+		if (len > PIM_MSDP_SA_TLV_MAX_SIZE) {
+			/* Check if the current buffer is big enough. */
+			if (mp->ibuf->size < len) {
+				if (PIM_DEBUG_MSDP_PACKETS)
+					zlog_debug(
+						"MSDP peer %s sent TLV with unexpected large length (%d bytes)",
+						mp->key_str, len);
+
+				stream_resize_inplace(&mp->ibuf, len);
+			}
+		}
+
 		/* read complete TLV */
 		mp->packet_size = len;
 	}
diff -urpN frr-frr-8.4.2/pimd/pim_nb_config.c frr-frr-8.5/pimd/pim_nb_config.c
--- frr-frr-8.4.2/pimd/pim_nb_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_nb_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -24,6 +24,7 @@
 #include "lib/northbound_cli.h"
 #include "pim_igmpv3.h"
 #include "pim_neighbor.h"
+#include "pim_nht.h"
 #include "pim_pim.h"
 #include "pim_mlag.h"
 #include "pim_bfd.h"
@@ -146,6 +147,7 @@ static int pim_cmd_interface_add(struct
 		pim_ifp->pim_enable = true;
 
 	pim_if_addr_add_all(ifp);
+	pim_upstream_nh_if_update(pim_ifp->pim, ifp);
 	pim_if_membership_refresh(ifp);
 
 	pim_if_create_pimreg(pim_ifp->pim);
@@ -168,6 +170,7 @@ static int pim_cmd_interface_delete(stru
 	 * pim_ifp->pim_neighbor_list.
 	 */
 	pim_sock_delete(ifp, "pim unconfigured on interface");
+	pim_upstream_nh_if_update(pim_ifp->pim, ifp);
 
 	if (!pim_ifp->gm_enable) {
 		pim_if_addr_del_all(ifp);
diff -urpN frr-frr-8.4.2/pimd/pim_neighbor.c frr-frr-8.5/pimd/pim_neighbor.c
--- frr-frr-8.4.2/pimd/pim_neighbor.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_neighbor.c	2023-03-13 20:01:47.000000000 +0600
@@ -419,7 +419,7 @@ struct pim_neighbor *pim_neighbor_find_b
 }
 
 struct pim_neighbor *pim_neighbor_find(struct interface *ifp,
-				       pim_addr source_addr)
+				       pim_addr source_addr, bool secondary)
 {
 	struct pim_interface *pim_ifp;
 	struct listnode *node;
@@ -438,6 +438,13 @@ struct pim_neighbor *pim_neighbor_find(s
 		}
 	}
 
+	if (secondary) {
+		struct prefix p;
+
+		pim_addr_to_prefix(&p, source_addr);
+		return pim_neighbor_find_by_secondary(ifp, &p);
+	}
+
 	return NULL;
 }
 
diff -urpN frr-frr-8.4.2/pimd/pim_neighbor.h frr-frr-8.5/pimd/pim_neighbor.h
--- frr-frr-8.4.2/pimd/pim_neighbor.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_neighbor.h	2023-03-13 20:01:47.000000000 +0600
@@ -51,7 +51,7 @@ struct pim_neighbor {
 void pim_neighbor_timer_reset(struct pim_neighbor *neigh, uint16_t holdtime);
 void pim_neighbor_free(struct pim_neighbor *neigh);
 struct pim_neighbor *pim_neighbor_find(struct interface *ifp,
-				       pim_addr source_addr);
+				       pim_addr source_addr, bool secondary);
 struct pim_neighbor *pim_neighbor_find_by_secondary(struct interface *ifp,
 						    struct prefix *src);
 struct pim_neighbor *pim_neighbor_find_if(struct interface *ifp);
diff -urpN frr-frr-8.4.2/pimd/pim_nht.c frr-frr-8.5/pimd/pim_nht.c
--- frr-frr-8.4.2/pimd/pim_nht.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_nht.c	2023-03-13 20:01:47.000000000 +0600
@@ -320,12 +320,11 @@ bool pim_nht_bsr_rpf_check(struct pim_in
 			if (if_is_loopback(ifp) && if_is_loopback(src_ifp))
 				return true;
 
-			nbr = pim_neighbor_find(ifp, znh->nexthop_addr);
+			nbr = pim_neighbor_find(ifp, znh->nexthop_addr, true);
 			if (!nbr)
 				continue;
 
-			return znh->ifindex == src_ifp->ifindex &&
-			       (!pim_addr_cmp(znh->nexthop_addr, src_ip));
+			return znh->ifindex == src_ifp->ifindex;
 		}
 		return false;
 	}
@@ -380,12 +379,13 @@ bool pim_nht_bsr_rpf_check(struct pim_in
 			return true;
 
 		/* MRIB (IGP) may be pointing at a router where PIM is down */
-		nbr = pim_neighbor_find(ifp, nhaddr);
+
+		nbr = pim_neighbor_find(ifp, nhaddr, true);
+
 		if (!nbr)
 			continue;
 
-		return nh->ifindex == src_ifp->ifindex &&
-		       (!pim_addr_cmp(nhaddr, src_ip));
+		return nh->ifindex == src_ifp->ifindex;
 	}
 	return false;
 }
@@ -469,6 +469,40 @@ static int pim_update_upstream_nh(struct
 	return 0;
 }
 
+static int pim_upstream_nh_if_update_helper(struct hash_bucket *bucket,
+					    void *arg)
+{
+	struct pim_nexthop_cache *pnc = bucket->data;
+	struct pnc_hash_walk_data *pwd = arg;
+	struct pim_instance *pim = pwd->pim;
+	struct interface *ifp = pwd->ifp;
+	struct nexthop *nh_node = NULL;
+	ifindex_t first_ifindex;
+
+	for (nh_node = pnc->nexthop; nh_node; nh_node = nh_node->next) {
+		first_ifindex = nh_node->ifindex;
+		if (ifp != if_lookup_by_index(first_ifindex, pim->vrf->vrf_id))
+			continue;
+
+		if (pnc->upstream_hash->count) {
+			pim_update_upstream_nh(pim, pnc);
+			break;
+		}
+	}
+
+	return HASHWALK_CONTINUE;
+}
+
+void pim_upstream_nh_if_update(struct pim_instance *pim, struct interface *ifp)
+{
+	struct pnc_hash_walk_data pwd;
+
+	pwd.pim = pim;
+	pwd.ifp = ifp;
+
+	hash_walk(pim->rpf_hash, pim_upstream_nh_if_update_helper, &pwd);
+}
+
 uint32_t pim_compute_ecmp_hash(struct prefix *src, struct prefix *grp)
 {
 	uint32_t hash_val;
@@ -495,6 +529,7 @@ static int pim_ecmp_nexthop_search(struc
 	uint32_t hash_val = 0, mod_val = 0;
 	uint8_t nh_iter = 0, found = 0;
 	uint32_t i, num_nbrs = 0;
+	struct pim_interface *pim_ifp;
 
 	if (!pnc || !pnc->nexthop_num || !nexthop)
 		return 0;
@@ -533,7 +568,7 @@ static int pim_ecmp_nexthop_search(struc
 							src)) {
 				nbr = pim_neighbor_find(
 					nexthop->interface,
-					nexthop->mrib_nexthop_addr);
+					nexthop->mrib_nexthop_addr, true);
 				if (!nbr
 				    && !if_is_loopback(nexthop->interface)) {
 					if (PIM_DEBUG_PIM_NHT)
@@ -575,7 +610,7 @@ static int pim_ecmp_nexthop_search(struc
 #else
 			pim_addr nhaddr = nh_node->gate.ipv6;
 #endif
-			nbrs[i] = pim_neighbor_find(ifps[i], nhaddr);
+			nbrs[i] = pim_neighbor_find(ifps[i], nhaddr, true);
 			if (nbrs[i] || pim_if_connected_to_source(ifps[i], src))
 				num_nbrs++;
 		}
@@ -611,10 +646,13 @@ static int pim_ecmp_nexthop_search(struc
 			nh_iter++;
 			continue;
 		}
-		if (!ifp->info) {
+
+		pim_ifp = ifp->info;
+
+		if (!pim_ifp || !pim_ifp->pim_enable) {
 			if (PIM_DEBUG_PIM_NHT)
 				zlog_debug(
-					"%s: multicast not enabled on input interface %s(%s) (ifindex=%d, RPF for source %pPA)",
+					"%s: pim not enabled on input interface %s(%s) (ifindex=%d, RPF for source %pPA)",
 					__func__, ifp->name, pim->vrf->name,
 					first_ifindex, &src);
 			if (nh_iter == mod_val)
@@ -882,6 +920,7 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 	uint8_t i = 0;
 	uint32_t hash_val = 0, mod_val = 0;
 	uint32_t num_nbrs = 0;
+	struct pim_interface *pim_ifp;
 
 	if (PIM_DEBUG_PIM_NHT_DETAIL)
 		zlog_debug("%s: Looking up: %pPA(%s), last lookup time: %lld",
@@ -922,7 +961,8 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 					     pim->vrf->vrf_id);
 		if (ifps[i]) {
 			nbrs[i] = pim_neighbor_find(
-				ifps[i], nexthop_tab[i].nexthop_addr);
+				ifps[i], nexthop_tab[i].nexthop_addr, true);
+
 			if (nbrs[i] || pim_if_connected_to_source(ifps[i], src))
 				num_nbrs++;
 		}
@@ -964,10 +1004,12 @@ int pim_ecmp_nexthop_lookup(struct pim_i
 			continue;
 		}
 
-		if (!ifp->info) {
+		pim_ifp = ifp->info;
+
+		if (!pim_ifp || !pim_ifp->pim_enable) {
 			if (PIM_DEBUG_PIM_NHT)
 				zlog_debug(
-					"%s: multicast not enabled on input interface %s(%s) (ifindex=%d, RPF for source %pPA)",
+					"%s: pim not enabled on input interface %s(%s) (ifindex=%d, RPF for source %pPA)",
 					__func__, ifp->name, pim->vrf->name,
 					first_ifindex, &src);
 			if (i == mod_val)
diff -urpN frr-frr-8.4.2/pimd/pim_nht.h frr-frr-8.5/pimd/pim_nht.h
--- frr-frr-8.4.2/pimd/pim_nht.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_nht.h	2023-03-13 20:01:47.000000000 +0600
@@ -53,6 +53,11 @@ struct pim_nexthop_cache {
 	uint32_t bsr_count;
 };
 
+struct pnc_hash_walk_data {
+	struct pim_instance *pim;
+	struct interface *ifp;
+};
+
 int pim_parse_nexthop_update(ZAPI_CALLBACK_ARGS);
 int pim_find_or_track_nexthop(struct pim_instance *pim, pim_addr addr,
 			      struct pim_upstream *up, struct rp_info *rp,
@@ -77,5 +82,5 @@ void pim_nht_bsr_del(struct pim_instance
 /* RPF(bsr_addr) == src_ip%src_ifp? */
 bool pim_nht_bsr_rpf_check(struct pim_instance *pim, pim_addr bsr_addr,
 			   struct interface *src_ifp, pim_addr src_ip);
-
+void pim_upstream_nh_if_update(struct pim_instance *pim, struct interface *ifp);
 #endif
diff -urpN frr-frr-8.4.2/pimd/pim_oil.c frr-frr-8.5/pimd/pim_oil.c
--- frr-frr-8.4.2/pimd/pim_oil.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_oil.c	2023-03-13 20:01:47.000000000 +0600
@@ -166,8 +166,8 @@ struct channel_oil *pim_channel_oil_del(
 					const char *name)
 {
 	if (PIM_DEBUG_MROUTE) {
-		pim_sgaddr sg = {.src = *oil_mcastgrp(c_oil),
-				 .grp = *oil_origin(c_oil)};
+		pim_sgaddr sg = {.src = *oil_origin(c_oil),
+				 .grp = *oil_mcastgrp(c_oil)};
 
 		zlog_debug(
 			"%s(%s): Del oil for %pSG, Ref Count: %d (Predecrement)",
diff -urpN frr-frr-8.4.2/pimd/pim_pim.c frr-frr-8.5/pimd/pim_pim.c
--- frr-frr-8.4.2/pimd/pim_pim.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_pim.c	2023-03-13 20:01:47.000000000 +0600
@@ -302,7 +302,7 @@ int pim_pim_packet(struct interface *ifp
 					      pim_msg_len - PIM_MSG_HEADER_LEN);
 		break;
 	case PIM_MSG_TYPE_JOIN_PRUNE:
-		neigh = pim_neighbor_find(ifp, sg.src);
+		neigh = pim_neighbor_find(ifp, sg.src, false);
 		if (!neigh) {
 			if (PIM_DEBUG_PIM_PACKETS)
 				zlog_debug(
@@ -317,7 +317,7 @@ int pim_pim_packet(struct interface *ifp
 					  pim_msg_len - PIM_MSG_HEADER_LEN);
 		break;
 	case PIM_MSG_TYPE_ASSERT:
-		neigh = pim_neighbor_find(ifp, sg.src);
+		neigh = pim_neighbor_find(ifp, sg.src, false);
 		if (!neigh) {
 			if (PIM_DEBUG_PIM_PACKETS)
 				zlog_debug(
diff -urpN frr-frr-8.4.2/pimd/pim_register.c frr-frr-8.5/pimd/pim_register.c
--- frr-frr-8.4.2/pimd/pim_register.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_register.c	2023-03-13 20:01:47.000000000 +0600
@@ -36,7 +36,6 @@
 #include "pim_rp.h"
 #include "pim_register.h"
 #include "pim_upstream.h"
-#include "pim_br.h"
 #include "pim_rpf.h"
 #include "pim_oil.h"
 #include "pim_zebra.h"
@@ -643,24 +642,13 @@ int pim_register_recv(struct interface *
 		}
 
 		if (*bits & PIM_REGISTER_BORDER_BIT) {
-			pim_addr pimbr = pim_br_get_pmbr(&sg);
 			if (PIM_DEBUG_PIM_PACKETS)
 				zlog_debug(
-					"%s: Received Register message with Border bit set",
+					"%s: Received Register message with Border bit set, ignoring",
 					__func__);
 
-			if (pim_addr_is_any(pimbr))
-				pim_br_set_pmbr(&sg, src_addr);
-			else if (pim_addr_cmp(src_addr, pimbr)) {
-				pim_register_stop_send(ifp, &sg, dest_addr,
-						       src_addr);
-				if (PIM_DEBUG_PIM_PACKETS)
-					zlog_debug(
-						"%s: Sending register-Stop to %s and dropping mr. packet",
-						__func__, "Sender");
 				/* Drop Packet Silently */
-				return 0;
-			}
+			return 0;
 		}
 
 		struct pim_upstream *upstream = pim_upstream_find(pim, &sg);
diff -urpN frr-frr-8.4.2/pimd/pim_rp.c frr-frr-8.5/pimd/pim_rp.c
--- frr-frr-8.4.2/pimd/pim_rp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_rp.c	2023-03-13 20:01:47.000000000 +0600
@@ -1079,6 +1079,14 @@ struct pim_rpf *pim_rp_g(struct pim_inst
 	if (rp_info) {
 		pim_addr nht_p;
 
+		if (pim_addr_is_any(rp_info->rp.rpf_addr)) {
+			if (PIM_DEBUG_PIM_NHT_RP)
+				zlog_debug(
+					"%s: Skipping NHT Register since RP is not configured for the group %pPA",
+					__func__, &group);
+			return &rp_info->rp;
+		}
+
 		/* Register addr with Zebra NHT */
 		nht_p = rp_info->rp.rpf_addr;
 		if (PIM_DEBUG_PIM_NHT_RP)
diff -urpN frr-frr-8.4.2/pimd/pim_rpf.c frr-frr-8.5/pimd/pim_rpf.c
--- frr-frr-8.4.2/pimd/pim_rpf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_rpf.c	2023-03-13 20:01:47.000000000 +0600
@@ -61,6 +61,7 @@ bool pim_nexthop_lookup(struct pim_insta
 	ifindex_t first_ifindex = 0;
 	int found = 0;
 	int i = 0;
+	struct pim_interface *pim_ifp;
 
 #if PIM_IPV == 4
 	/*
@@ -118,17 +119,18 @@ bool pim_nexthop_lookup(struct pim_insta
 			continue;
 		}
 
-		if (!ifp->info) {
+		pim_ifp = ifp->info;
+		if (!pim_ifp || !pim_ifp->pim_enable) {
 			if (PIM_DEBUG_ZEBRA)
 				zlog_debug(
-					"%s: multicast not enabled on input interface %s (ifindex=%d, RPF for source %pPAs)",
+					"%s: pim not enabled on input interface %s (ifindex=%d, RPF for source %pPAs)",
 					__func__, ifp->name, first_ifindex,
 					&addr);
 			i++;
-		} else if (neighbor_needed
-			   && !pim_if_connected_to_source(ifp, addr)) {
-			nbr = pim_neighbor_find(ifp,
-						nexthop_tab[i].nexthop_addr);
+		} else if (neighbor_needed &&
+			   !pim_if_connected_to_source(ifp, addr)) {
+			nbr = pim_neighbor_find(
+				ifp, nexthop_tab[i].nexthop_addr, true);
 			if (PIM_DEBUG_PIM_TRACE_DETAIL)
 				zlog_debug("ifp name: %s, pim nbr: %p",
 					   ifp->name, nbr);
diff -urpN frr-frr-8.4.2/pimd/pim_tlv.c frr-frr-8.5/pimd/pim_tlv.c
--- frr-frr-8.4.2/pimd/pim_tlv.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_tlv.c	2023-03-13 20:01:47.000000000 +0600
@@ -29,6 +29,8 @@
 #include "pim_tlv.h"
 #include "pim_str.h"
 #include "pim_msg.h"
+#include "pim_iface.h"
+#include "pim_addr.h"
 
 #if PIM_IPV == 4
 #define PIM_MSG_ADDRESS_FAMILY PIM_MSG_ADDRESS_FAMILY_IPV4
@@ -226,12 +228,15 @@ int pim_encode_addr_group(uint8_t *buf,
 }
 
 uint8_t *pim_tlv_append_addrlist_ucast(uint8_t *buf, const uint8_t *buf_pastend,
-				       struct list *ifconnected, int family)
+				       struct interface *ifp, int family)
 {
 	struct listnode *node;
 	uint16_t option_len = 0;
 	uint8_t *curr;
 	size_t uel;
+	struct list *ifconnected = ifp->connected;
+	struct pim_interface *pim_ifp = ifp->info;
+	pim_addr addr;
 
 	node = listhead(ifconnected);
 
@@ -252,7 +257,10 @@ uint8_t *pim_tlv_append_addrlist_ucast(u
 		struct prefix *p = ifc->address;
 		int l_encode;
 
-		if (!CHECK_FLAG(ifc->flags, ZEBRA_IFA_SECONDARY))
+		addr = pim_addr_from_prefix(p);
+		if (!pim_addr_cmp(pim_ifp->primary_address, addr))
+			/* don't add the primary address
+			 * into the secondary address list */
 			continue;
 
 		if ((curr + uel) > buf_pastend)
diff -urpN frr-frr-8.4.2/pimd/pim_tlv.h frr-frr-8.5/pimd/pim_tlv.h
--- frr-frr-8.4.2/pimd/pim_tlv.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_tlv.h	2023-03-13 20:01:47.000000000 +0600
@@ -82,7 +82,7 @@ uint8_t *pim_tlv_append_2uint16(uint8_t
 uint8_t *pim_tlv_append_uint32(uint8_t *buf, const uint8_t *buf_pastend,
 			       uint16_t option_type, uint32_t option_value);
 uint8_t *pim_tlv_append_addrlist_ucast(uint8_t *buf, const uint8_t *buf_pastend,
-				       struct list *ifconnected, int family);
+				       struct interface *ifp, int family);
 
 int pim_tlv_parse_holdtime(const char *ifname, pim_addr src_addr,
 			   pim_hello_options *hello_options,
diff -urpN frr-frr-8.4.2/pimd/pim_upstream.c frr-frr-8.5/pimd/pim_upstream.c
--- frr-frr-8.4.2/pimd/pim_upstream.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_upstream.c	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,6 @@
 #include "pim_oil.h"
 #include "pim_macro.h"
 #include "pim_rp.h"
-#include "pim_br.h"
 #include "pim_register.h"
 #include "pim_msdp.h"
 #include "pim_jp_agg.h"
@@ -341,7 +340,7 @@ static void join_timer_stop(struct pim_u
 
 	if (up->rpf.source_nexthop.interface)
 		nbr = pim_neighbor_find(up->rpf.source_nexthop.interface,
-					up->rpf.rpf_addr);
+					up->rpf.rpf_addr, true);
 
 	if (nbr)
 		pim_jp_agg_remove_group(nbr->upstream_jp_agg, up, nbr);
@@ -355,7 +354,7 @@ void join_timer_start(struct pim_upstrea
 
 	if (up->rpf.source_nexthop.interface) {
 		nbr = pim_neighbor_find(up->rpf.source_nexthop.interface,
-					up->rpf.rpf_addr);
+					up->rpf.rpf_addr, true);
 
 		if (PIM_DEBUG_PIM_EVENTS) {
 			zlog_debug(
@@ -447,7 +446,8 @@ void pim_upstream_join_suppress(struct p
 	else {
 		/* Remove it from jp agg from the nbr for suppression */
 		nbr = pim_neighbor_find(up->rpf.source_nexthop.interface,
-					up->rpf.rpf_addr);
+					up->rpf.rpf_addr, true);
+
 		if (nbr) {
 			join_timer_remain_msec =
 				pim_time_timer_remain_msec(nbr->jp_timer);
@@ -499,7 +499,8 @@ void pim_upstream_join_timer_decrease_to
 		struct pim_neighbor *nbr;
 
 		nbr = pim_neighbor_find(up->rpf.source_nexthop.interface,
-					up->rpf.rpf_addr);
+					up->rpf.rpf_addr, true);
+
 		if (nbr)
 			join_timer_remain_msec =
 				pim_time_timer_remain_msec(nbr->jp_timer);
@@ -1422,8 +1423,8 @@ struct pim_upstream *pim_upstream_keep_a
 	}
 
 	if (I_am_RP(pim, up->sg.grp)) {
-		pim_br_clear_pmbr(&up->sg);
 		/*
+		 * Handle Border Router
 		 * We need to do more here :)
 		 * But this is the start.
 		 */
diff -urpN frr-frr-8.4.2/pimd/pim_vty.c frr-frr-8.5/pimd/pim_vty.c
--- frr-frr-8.4.2/pimd/pim_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -59,20 +59,20 @@ int pim_debug_config_write(struct vty *v
 		++writes;
 	}
 	if (PIM_DEBUG_GM_EVENTS) {
-		vty_out(vty, "debug igmp events\n");
+		vty_out(vty, "debug " GM_AF_DBG " events\n");
 		++writes;
 	}
 	if (PIM_DEBUG_GM_PACKETS) {
-		vty_out(vty, "debug igmp packets\n");
+		vty_out(vty, "debug " GM_AF_DBG " packets\n");
 		++writes;
 	}
 	/* PIM_DEBUG_GM_TRACE catches _DETAIL too */
 	if (router->debugs & PIM_MASK_GM_TRACE) {
-		vty_out(vty, "debug igmp trace\n");
+		vty_out(vty, "debug " GM_AF_DBG " trace\n");
 		++writes;
 	}
 	if (PIM_DEBUG_GM_TRACE_DETAIL) {
-		vty_out(vty, "debug igmp trace detail\n");
+		vty_out(vty, "debug " GM_AF_DBG " trace detail\n");
 		++writes;
 	}
 
@@ -401,7 +401,7 @@ static int gm_config_write(struct vty *v
 		vty_out(vty, " ipv6 mld last-member-query-interval %d\n",
 			pim_ifp->gm_specific_query_max_response_time_dsec);
 
-	return 0;
+	return writes;
 }
 #endif
 
diff -urpN frr-frr-8.4.2/pimd/pim_zebra.c frr-frr-8.5/pimd/pim_zebra.c
--- frr-frr-8.4.2/pimd/pim_zebra.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/pim_zebra.c	2023-03-13 20:01:47.000000000 +0600
@@ -270,7 +270,8 @@ void pim_zebra_upstream_rpf_changed(stru
 		struct pim_neighbor *nbr;
 
 		nbr = pim_neighbor_find(old->source_nexthop.interface,
-					old->rpf_addr);
+					old->rpf_addr, true);
+
 		if (nbr)
 			pim_jp_agg_remove_group(nbr->upstream_jp_agg, up, nbr);
 
diff -urpN frr-frr-8.4.2/pimd/subdir.am frr-frr-8.5/pimd/subdir.am
--- frr-frr-8.4.2/pimd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/pimd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -6,11 +6,6 @@ if PIMD
 sbin_PROGRAMS += pimd/pimd
 bin_PROGRAMS += pimd/mtracebis
 noinst_PROGRAMS += pimd/test_igmpv3_join
-vtysh_scan += \
-	pimd/pim_cmd.c \
-	pimd/pim6_cmd.c \
-	pimd/pim6_mld.c \
-	#end
 vtysh_daemons += pimd
 vtysh_daemons += pim6d
 man8 += $(MANBUILD)/frr-pimd.8
@@ -21,7 +16,6 @@ pim_common = \
 	pimd/pim_addr.c \
 	pimd/pim_assert.c \
 	pimd/pim_bfd.c \
-	pimd/pim_br.c \
 	pimd/pim_bsm.c \
 	pimd/pim_cmd_common.c \
 	pimd/pim_errors.c \
@@ -103,7 +97,6 @@ noinst_HEADERS += \
 	pimd/pim_addr.h \
 	pimd/pim_assert.h \
 	pimd/pim_bfd.h \
-	pimd/pim_br.h \
 	pimd/pim_bsm.h \
 	pimd/pim_cmd.h \
 	pimd/pim_cmd_common.h \
diff -urpN frr-frr-8.4.2/python/callgraph-dot.py frr-frr-8.5/python/callgraph-dot.py
--- frr-frr-8.4.2/python/callgraph-dot.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/callgraph-dot.py	2023-03-13 20:01:47.000000000 +0600
@@ -321,15 +321,31 @@ extra_info = {
         "lsp_processq_complete",
     ],
     # zebra - main WQ
-    ("mq_add_handler", "work_queue_add"): ["meta_queue_process",],
-    ("meta_queue_process", "work_queue_add"): ["meta_queue_process",],
+    ("mq_add_handler", "work_queue_add"): [
+        "meta_queue_process",
+    ],
+    ("meta_queue_process", "work_queue_add"): [
+        "meta_queue_process",
+    ],
     # bgpd - label pool WQ
-    ("bgp_lp_get", "work_queue_add"): ["lp_cbq_docallback",],
-    ("bgp_lp_event_chunk", "work_queue_add"): ["lp_cbq_docallback",],
-    ("bgp_lp_event_zebra_up", "work_queue_add"): ["lp_cbq_docallback",],
+    ("bgp_lp_get", "work_queue_add"): [
+        "lp_cbq_docallback",
+    ],
+    ("bgp_lp_event_chunk", "work_queue_add"): [
+        "lp_cbq_docallback",
+    ],
+    ("bgp_lp_event_zebra_up", "work_queue_add"): [
+        "lp_cbq_docallback",
+    ],
     # bgpd - main WQ
-    ("bgp_process", "work_queue_add"): ["bgp_process_wq", "bgp_processq_del",],
-    ("bgp_add_eoiu_mark", "work_queue_add"): ["bgp_process_wq", "bgp_processq_del",],
+    ("bgp_process", "work_queue_add"): [
+        "bgp_process_wq",
+        "bgp_processq_del",
+    ],
+    ("bgp_add_eoiu_mark", "work_queue_add"): [
+        "bgp_process_wq",
+        "bgp_processq_del",
+    ],
     # clear node WQ
     ("bgp_clear_route_table", "work_queue_add"): [
         "bgp_clear_route_node",
@@ -337,7 +353,9 @@ extra_info = {
         "bgp_clear_node_complete",
     ],
     # rfapi WQs
-    ("rfapi_close", "work_queue_add"): ["rfapi_deferred_close_workfunc",],
+    ("rfapi_close", "work_queue_add"): [
+        "rfapi_deferred_close_workfunc",
+    ],
     ("rfapiRibUpdatePendingNode", "work_queue_add"): [
         "rfapiRibDoQueuedCallback",
         "rfapiRibQueueItemDelete",
diff -urpN frr-frr-8.4.2/python/clippy/__init__.py frr-frr-8.5/python/clippy/__init__.py
--- frr-frr-8.4.2/python/clippy/__init__.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/clippy/__init__.py	2023-03-13 20:01:47.000000000 +0600
@@ -17,11 +17,29 @@
 # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 
 import os, stat
+
+try:
+    from enum import IntFlag as _IntFlag
+except ImportError:
+    # python <3.6
+    from enum import IntEnum as _IntFlag  # type: ignore
+
 import _clippy
-from _clippy import parse, Graph, GraphNode
+from _clippy import (
+    parse,
+    Graph,
+    GraphNode,
+    CMD_ATTR_YANG,
+    CMD_ATTR_HIDDEN,
+    CMD_ATTR_DEPRECATED,
+    CMD_ATTR_NOSH,
+)
+
 
+frr_top_src = os.path.dirname(
+    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+)
 
-frr_top_src = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 
 def graph_iterate(graph):
     """iterator yielding all nodes of a graph
@@ -78,3 +96,10 @@ def wrdiff(filename, buf, reffiles=[]):
     with open(newname, "w") as out:
         out.write(buf)
     os.rename(newname, filename)
+
+
+class CmdAttr(_IntFlag):
+    YANG = CMD_ATTR_YANG
+    HIDDEN = CMD_ATTR_HIDDEN
+    DEPRECATED = CMD_ATTR_DEPRECATED
+    NOSH = CMD_ATTR_NOSH
diff -urpN frr-frr-8.4.2/python/clippy/elf.py frr-frr-8.5/python/clippy/elf.py
--- frr-frr-8.4.2/python/clippy/elf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/clippy/elf.py	2023-03-13 20:01:47.000000000 +0600
@@ -16,7 +16,7 @@
 # with this program; see the file COPYING; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 
-'''
+"""
 Wrapping layer and additional utility around _clippy.ELFFile.
 
 Essentially, the C bits have the low-level ELF access bits that should be
@@ -28,7 +28,7 @@ across architecture, word size and even
 module (through GElf_*) and this code (cf. struct.unpack format mangling
 in ELFDissectStruct) will take appropriate measures to flip and resize
 fields as needed.
-'''
+"""
 
 import struct
 from collections import OrderedDict
@@ -40,16 +40,18 @@ from _clippy import ELFFile, ELFAccessEr
 # data access
 #
 
+
 class ELFNull(object):
-    '''
+    """
     NULL pointer, returned instead of ELFData
-    '''
+    """
+
     def __init__(self):
         self.symname = None
         self._dstsect = None
 
     def __repr__(self):
-        return '<ptr: NULL>'
+        return "<ptr: NULL>"
 
     def __hash__(self):
         return hash(None)
@@ -57,33 +59,37 @@ class ELFNull(object):
     def get_string(self):
         return None
 
+
 class ELFUnresolved(object):
-    '''
+    """
     Reference to an unresolved external symbol, returned instead of ELFData
 
     :param symname: name of the referenced symbol
     :param addend:  offset added to the symbol, normally zero
-    '''
+    """
+
     def __init__(self, symname, addend):
         self.addend = addend
         self.symname = symname
         self._dstsect = None
 
     def __repr__(self):
-        return '<unresolved: %s+%d>' % (self.symname, self.addend)
+        return "<unresolved: %s+%d>" % (self.symname, self.addend)
 
     def __hash__(self):
         return hash((self.symname, self.addend))
 
+
 class ELFData(object):
-    '''
+    """
     Actual data somewhere in the ELF file.
 
     :type dstsect:  ELFSubset
     :param dstsect: container data area (section or entire file)
     :param dstoffs: byte offset into dstsect
     :param dstlen:  byte size of object, or None if unknown, open-ended or string
-    '''
+    """
+
     def __init__(self, dstsect, dstoffs, dstlen):
         self._dstsect = dstsect
         self._dstoffs = dstoffs
@@ -91,62 +97,78 @@ class ELFData(object):
         self.symname = None
 
     def __repr__(self):
-        return '<ptr: %s+0x%05x/%d>' % (self._dstsect.name, self._dstoffs, self._dstlen or -1)
+        return "<ptr: %s+0x%05x/%d>" % (
+            self._dstsect.name,
+            self._dstoffs,
+            self._dstlen or -1,
+        )
 
     def __hash__(self):
         return hash((self._dstsect, self._dstoffs))
 
     def get_string(self):
-        '''
+        """
         Interpret as C string / null terminated UTF-8 and get the actual text.
-        '''
+        """
         try:
-            return self._dstsect[self._dstoffs:str].decode('UTF-8')
+            return self._dstsect[self._dstoffs : str].decode("UTF-8")
         except:
-            import pdb; pdb.set_trace()
+            import pdb
+
+            pdb.set_trace()
 
     def get_data(self, reflen):
-        '''
+        """
         Interpret as some structure (and check vs. expected length)
 
         :param reflen: expected size of the object, compared against actual
             size (which is only known in rare cases, mostly when directly
             accessing a symbol since symbols have their destination object
             size recorded)
-        '''
+        """
         if self._dstlen is not None and self._dstlen != reflen:
-            raise ValueError('symbol size mismatch (got %d, expected %d)' % (self._dstlen, reflen))
-        return self._dstsect[self._dstoffs:self._dstoffs+reflen]
+            raise ValueError(
+                "symbol size mismatch (got %d, expected %d)" % (self._dstlen, reflen)
+            )
+        return self._dstsect[self._dstoffs : self._dstoffs + reflen]
 
     def offset(self, offs, within_symbol=False):
-        '''
+        """
         Get another ELFData at an offset
 
         :param offs:          byte offset, can be negative (e.g. in container_of)
         :param within_symbol: retain length information
-        '''
+        """
         if self._dstlen is None or not within_symbol:
             return ELFData(self._dstsect, self._dstoffs + offs, None)
         else:
             return ELFData(self._dstsect, self._dstoffs + offs, self._dstlen - offs)
 
+
 #
 # dissection data items
 #
 
+
 class ELFDissectData(object):
-    '''
+    """
     Common bits for ELFDissectStruct and ELFDissectUnion
-    '''
+    """
+
+    def __init__(self):
+        self._data = None
+        self.elfclass = None
 
     def __len__(self):
-        '''
+        """
         Used for boolean evaluation, e.g. "if struct: ..."
-        '''
-        return not (isinstance(self._data, ELFNull) or isinstance(self._data, ELFUnresolved))
+        """
+        return not (
+            isinstance(self._data, ELFNull) or isinstance(self._data, ELFUnresolved)
+        )
 
     def container_of(self, parent, fieldname):
-        '''
+        """
         Assume this struct is embedded in a larger struct and get at the larger
 
         Python ``self.container_of(a, b)`` = C ``container_of(self, a, b)``
@@ -154,25 +176,26 @@ class ELFDissectData(object):
         :param parent:    class (not instance) of the larger struct
         :param fieldname: fieldname that refers back to this
         :returns:         instance of parent, with fieldname set to this object
-        '''
+        """
         offset = 0
-        if not hasattr(parent, '_efields'):
+        if not hasattr(parent, "_efields"):
             parent._setup_efields()
 
         for field in parent._efields[self.elfclass]:
             if field[0] == fieldname:
                 break
             spec = field[1]
-            if spec == 'P':
-                spec = 'I' if self.elfclass == 32 else 'Q'
+            if spec == "P":
+                spec = "I" if self.elfclass == 32 else "Q"
             offset += struct.calcsize(spec)
         else:
-            raise AttributeError('%r not found in %r.fields' % (fieldname, parent))
+            raise AttributeError("%r not found in %r.fields" % (fieldname, parent))
+
+        return parent(self._data.offset(-offset), replace={fieldname: self})
 
-        return parent(self._data.offset(-offset), replace = {fieldname: self})
 
 class ELFDissectStruct(ELFDissectData):
-    '''
+    """
     Decode and provide access to a struct somewhere in the ELF file
 
     Handles pointers and strings somewhat nicely.  Create a subclass for each
@@ -205,30 +228,31 @@ class ELFDissectStruct(ELFDissectData):
     .. attribute:: fieldrename
 
        Dictionary to rename fields, useful if fields comes from tiabwarfo.py.
-    '''
+    """
 
     class Pointer(object):
-        '''
+        """
         Quick wrapper for pointers to further structs
 
         This is just here to avoid going into infinite loops when loading
         structs that have pointers to each other (e.g. struct xref <-->
         struct xrefdata.)  The pointer destination is only instantiated when
         actually accessed.
-        '''
+        """
+
         def __init__(self, cls, ptr):
             self.cls = cls
             self.ptr = ptr
 
         def __repr__(self):
-            return '<Pointer:%s %r>' % (self.cls.__name__, self.ptr)
+            return "<Pointer:%s %r>" % (self.cls.__name__, self.ptr)
 
         def __call__(self):
             if isinstance(self.ptr, ELFNull):
                 return None
             return self.cls(self.ptr)
 
-    def __new__(cls, dataptr, parent = None, replace = None):
+    def __new__(cls, dataptr, parent=None, replace=None):
         if dataptr._dstsect is None:
             return super().__new__(cls)
 
@@ -239,19 +263,19 @@ class ELFDissectStruct(ELFDissectData):
         dataptr._dstsect._pointers[(cls, dataptr)] = obj
         return obj
 
-    replacements = 'lLnN'
+    replacements = "lLnN"
 
     @classmethod
     def _preproc_structspec(cls, elfclass, spec):
         elfbits = elfclass
 
-        if hasattr(spec, 'calcsize'):
-            spec = '%ds' % (spec.calcsize(elfclass),)
+        if hasattr(spec, "calcsize"):
+            spec = "%ds" % (spec.calcsize(elfclass),)
 
         if elfbits == 32:
-            repl = ['i', 'I']
+            repl = ["i", "I"]
         else:
-            repl = ['q', 'Q']
+            repl = ["q", "Q"]
         for c in cls.replacements:
             spec = spec.replace(c, repl[int(c.isupper())])
         return spec
@@ -269,8 +293,8 @@ class ELFDissectStruct(ELFDissectData):
                 size += struct.calcsize(newf[1])
             cls._esize[elfclass] = size
 
-    def __init__(self, dataptr, parent = None, replace = None):
-        if not hasattr(self.__class__, '_efields'):
+    def __init__(self, dataptr, parent=None, replace=None):
+        if not hasattr(self.__class__, "_efields"):
             self._setup_efields()
 
         self._fdata = None
@@ -290,12 +314,12 @@ class ELFDissectStruct(ELFDissectData):
         # need to correlate output from struct.unpack with extra metadata
         # about the particular fields, so note down byte offsets (in locs)
         # and tuple indices of pointers (in ptrs)
-        pspec = ''
+        pspec = ""
         locs = {}
         ptrs = set()
 
         for idx, spec in enumerate(pspecl):
-            if spec == 'P':
+            if spec == "P":
                 ptrs.add(idx)
                 spec = self._elfsect.ptrtype
 
@@ -326,7 +350,9 @@ class ELFDissectStruct(ELFDissectData):
                 self._fdata[name] = replace[name]
                 continue
 
-            if isinstance(self.fields[i][1], type) and issubclass(self.fields[i][1], ELFDissectData):
+            if isinstance(self.fields[i][1], type) and issubclass(
+                self.fields[i][1], ELFDissectData
+            ):
                 dataobj = self.fields[i][1](dataptr.offset(locs[i]), self)
                 self._fdata[name] = dataobj
                 continue
@@ -353,35 +379,41 @@ class ELFDissectStruct(ELFDissectData):
 
     def __repr__(self):
         if not isinstance(self._data, ELFData):
-            return '<%s: %r>' % (self.__class__.__name__, self._data)
-        return '<%s: %s>' % (self.__class__.__name__,
-                ', '.join(['%s=%r' % t for t in self._fdata.items()]))
+            return "<%s: %r>" % (self.__class__.__name__, self._data)
+        return "<%s: %s>" % (
+            self.__class__.__name__,
+            ", ".join(["%s=%r" % t for t in self._fdata.items()]),
+        )
 
     @classmethod
     def calcsize(cls, elfclass):
-        '''
+        """
         Sum up byte size of this struct
 
         Wraps struct.calcsize with some extra features.
-        '''
-        if not hasattr(cls, '_efields'):
+        """
+        if not hasattr(cls, "_efields"):
             cls._setup_efields()
 
-        pspec = ''.join([f[1] for f in cls._efields[elfclass]])
+        pspec = "".join([f[1] for f in cls._efields[elfclass]])
 
-        ptrtype = 'I' if elfclass == 32 else 'Q'
-        pspec = pspec.replace('P', ptrtype)
+        ptrtype = "I" if elfclass == 32 else "Q"
+        pspec = pspec.replace("P", ptrtype)
 
         return struct.calcsize(pspec)
 
+
 class ELFDissectUnion(ELFDissectData):
-    '''
+    """
     Decode multiple structs in the same place.
 
     Not currently used (and hence not tested.)  Worked at some point but not
     needed anymore and may be borked now.  Remove this comment when using.
-    '''
-    def __init__(self, dataptr, parent = None):
+    """
+
+    members = {}
+
+    def __init__(self, dataptr, parent=None):
         self._dataptr = dataptr
         self._parent = parent
         self.members = []
@@ -391,31 +423,44 @@ class ELFDissectUnion(ELFDissectData):
             setattr(self, name, item)
 
     def __repr__(self):
-        return '<%s: %s>' % (self.__class__.__name__, ', '.join([repr(i) for i in self.members]))
+        return "<%s: %s>" % (
+            self.__class__.__name__,
+            ", ".join([repr(i) for i in self.members]),
+        )
 
     @classmethod
     def calcsize(cls, elfclass):
         return max([member.calcsize(elfclass) for name, member in cls.members])
 
+
 #
 # wrappers for spans of ELF data
 #
 
+
 class ELFSubset(object):
-    '''
+    """
     Common abstract base for section-level and file-level access.
-    '''
+    """
 
     def __init__(self):
         super().__init__()
 
+        self.name = None
+        self._obj = None
+        self._elffile = None
+        self.ptrtype = None
+        self.endian = None
         self._pointers = WeakValueDictionary()
 
+    def _wrap_data(self, data, dstsect):
+        raise NotImplementedError()
+
     def __hash__(self):
         return hash(self.name)
 
     def __getitem__(self, k):
-        '''
+        """
         Read data from slice
 
         Subscript **must** be a slice; a simple index will not return a byte
@@ -425,22 +470,22 @@ class ELFSubset(object):
         - `this[123:456]` - extract specific range
         - `this[123:str]` - extract until null byte.  The slice stop value is
             the `str` type (or, technically, `unicode`.)
-        '''
+        """
         return self._obj[k]
 
     def getreloc(self, offset):
-        '''
+        """
         Check for a relocation record at the specified offset.
-        '''
+        """
         return self._obj.getreloc(offset)
 
-    def iter_data(self, scls, slice_ = slice(None)):
-        '''
+    def iter_data(self, scls, slice_=slice(None)):
+        """
         Assume an array of structs present at a particular slice and decode
 
         :param scls:   ELFDissectData subclass for the struct
         :param slice_: optional range specification
-        '''
+        """
         size = scls.calcsize(self._elffile.elfclass)
 
         offset = slice_.start or 0
@@ -453,7 +498,7 @@ class ELFSubset(object):
             offset += size
 
     def pointer(self, offset):
-        '''
+        """
         Try to dereference a pointer value
 
         This checks whether there's a relocation at the given offset and
@@ -463,10 +508,12 @@ class ELFSubset(object):
         :param offset: byte offset from beginning of section,
             or virtual address in file
         :returns:      ELFData wrapping pointed-to object
-        '''
+        """
 
         ptrsize = struct.calcsize(self.ptrtype)
-        data = struct.unpack(self.endian + self.ptrtype, self[offset:offset + ptrsize])[0]
+        data = struct.unpack(
+            self.endian + self.ptrtype, self[offset : offset + ptrsize]
+        )[0]
 
         reloc = self.getreloc(offset)
         dstsect = None
@@ -497,14 +544,15 @@ class ELFSubset(object):
         # wrap_data is different between file & section
         return self._wrap_data(data, dstsect)
 
+
 class ELFDissectSection(ELFSubset):
-    '''
+    """
     Access the contents of an ELF section like ``.text`` or ``.data``
 
     :param elfwrap: ELFDissectFile wrapper for the file
     :param idx:     section index in section header table
     :param section: section object from C module
-    '''
+    """
 
     def __init__(self, elfwrap, idx, section):
         super().__init__()
@@ -524,8 +572,9 @@ class ELFDissectSection(ELFSubset):
         dstsect = self._elfwrap.get_section(dstsect.idx)
         return ELFData(dstsect, offs, None)
 
+
 class ELFDissectFile(ELFSubset):
-    '''
+    """
     Access the contents of an ELF file.
 
     Note that offsets for array subscript and relocation/pointer access are
@@ -537,7 +586,7 @@ class ELFDissectFile(ELFSubset):
     address like 0x400000 on x86.
 
     :param filename: ELF file to open
-    '''
+    """
 
     def __init__(self, filename):
         super().__init__()
@@ -546,8 +595,8 @@ class ELFDissectFile(ELFSubset):
         self._elffile = self._obj = ELFFile(filename)
         self._sections = {}
 
-        self.ptrtype = 'I' if self._elffile.elfclass == 32 else 'Q'
-        self.endian = '>' if self._elffile.bigendian else '<'
+        self.ptrtype = "I" if self._elffile.elfclass == 32 else "Q"
+        self.endian = ">" if self._elffile.bigendian else "<"
 
     @property
     def _elfwrap(self):
@@ -557,9 +606,9 @@ class ELFDissectFile(ELFSubset):
         return ELFData(self, data, None)
 
     def get_section(self, secname):
-        '''
+        """
         Look up section by name or index
-        '''
+        """
         if isinstance(secname, int):
             sh_idx = secname
             section = self._elffile.get_section_idx(secname)
diff -urpN frr-frr-8.4.2/python/clippy/uidhash.py frr-frr-8.5/python/clippy/uidhash.py
--- frr-frr-8.4.2/python/clippy/uidhash.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/clippy/uidhash.py	2023-03-13 20:01:47.000000000 +0600
@@ -19,13 +19,14 @@
 import struct
 from hashlib import sha256
 
-def bititer(data, bits, startbit = True):
-    '''
+
+def bititer(data, bits, startbit=True):
+    """
     just iterate the individual bits out from a bytes object
 
     if startbit is True, an '1' bit is inserted at the very beginning
     goes <bits> at a time, starts at LSB.
-    '''
+    """
     bitavail, v = 0, 0
     if startbit and len(data) > 0:
         v = data.pop(0)
@@ -41,31 +42,33 @@ def bititer(data, bits, startbit = True)
         bitavail -= bits
         v >>= bits
 
+
 def base32c(data):
-    '''
+    """
     Crockford base32 with extra dashes
-    '''
+    """
     chs = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
-    o = ''
+    o = ""
     if type(data) == str:
         data = [ord(v) for v in data]
     else:
         data = list(data)
     for i, bits in enumerate(bititer(data, 5)):
         if i == 5:
-            o = o + '-'
+            o = o + "-"
         elif i == 10:
             break
         o = o + chs[bits]
     return o
 
+
 def uidhash(filename, hashstr, hashu32a, hashu32b):
-    '''
+    """
     xref Unique ID hash used in FRRouting
-    '''
-    filename = '/'.join(filename.rsplit('/')[-2:])
+    """
+    filename = "/".join(filename.rsplit("/")[-2:])
 
-    hdata = filename.encode('UTF-8') + hashstr.encode('UTF-8')
-    hdata += struct.pack('>II', hashu32a, hashu32b)
+    hdata = filename.encode("UTF-8") + hashstr.encode("UTF-8")
+    hdata += struct.pack(">II", hashu32a, hashu32b)
     i = sha256(hdata).digest()
     return base32c(i)
diff -urpN frr-frr-8.4.2/python/makefile.py frr-frr-8.5/python/makefile.py
--- frr-frr-8.4.2/python/makefile.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/makefile.py	2023-03-13 20:01:47.000000000 +0600
@@ -160,6 +160,17 @@ for clippy_file in clippy_scan:
 
 # combine daemon .xref files into frr.xref
 out_lines.append("")
+xref_targets = [
+    target
+    for target in xref_targets
+    if target
+    not in [
+        "bgpd/rfp-example/rfptest/rfptest",
+        "pimd/mtracebis",
+        "tools/ssd",
+        "vtysh/vtysh",
+    ]
+]
 out_lines.append(
     "xrefs = %s" % (" ".join(["%s.xref" % target for target in xref_targets]))
 )
diff -urpN frr-frr-8.4.2/python/runtests.py frr-frr-8.5/python/runtests.py
--- frr-frr-8.4.2/python/runtests.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/runtests.py	2023-03-13 20:01:47.000000000 +0600
@@ -5,9 +5,11 @@ import os
 try:
     import _clippy
 except ImportError:
-    sys.stderr.write('''these tests need to be run with the _clippy C extension
+    sys.stderr.write(
+        """these tests need to be run with the _clippy C extension
 module available.  Try running "clippy runtests.py ...".
-''')
+"""
+    )
     sys.exit(1)
 
 os.chdir(os.path.dirname(os.path.abspath(__file__)))
diff -urpN frr-frr-8.4.2/python/test_xrelfo.py frr-frr-8.5/python/test_xrelfo.py
--- frr-frr-8.4.2/python/test_xrelfo.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/test_xrelfo.py	2023-03-13 20:01:47.000000000 +0600
@@ -22,20 +22,21 @@ import pytest
 from pprint import pprint
 
 root = os.path.dirname(os.path.dirname(__file__))
-sys.path.append(os.path.join(root, 'python'))
+sys.path.append(os.path.join(root, "python"))
 
 import xrelfo
 from clippy import elf, uidhash
 
+
 def test_uidhash():
-    assert uidhash.uidhash("lib/test_xref.c", "logging call", 3, 0) \
-            == 'H7KJB-67TBH'
+    assert uidhash.uidhash("lib/test_xref.c", "logging call", 3, 0) == "H7KJB-67TBH"
+
 
 def test_xrelfo_other():
     for data in [
-            elf.ELFNull(),
-            elf.ELFUnresolved('somesym', 0),
-        ]:
+        elf.ELFNull(),
+        elf.ELFUnresolved("somesym", 0),
+    ]:
 
         dissect = xrelfo.XrefPtr(data)
         print(repr(dissect))
@@ -43,9 +44,10 @@ def test_xrelfo_other():
         with pytest.raises(AttributeError):
             dissect.xref
 
+
 def test_xrelfo_obj():
     xrelfo_ = xrelfo.Xrelfo()
-    edf = xrelfo_.load_elf(os.path.join(root, 'lib/.libs/zclient.o'), 'zclient.lo')
+    edf = xrelfo_.load_elf(os.path.join(root, "lib/.libs/zclient.o"), "zclient.lo")
     xrefs = xrelfo_._xrefs
 
     with pytest.raises(elf.ELFAccessError):
@@ -54,12 +56,13 @@ def test_xrelfo_obj():
     pprint(xrefs[0])
     pprint(xrefs[0]._data)
 
+
 def test_xrelfo_bin():
     xrelfo_ = xrelfo.Xrelfo()
-    edf = xrelfo_.load_elf(os.path.join(root, 'lib/.libs/libfrr.so'), 'libfrr.la')
+    edf = xrelfo_.load_elf(os.path.join(root, "lib/.libs/libfrr.so"), "libfrr.la")
     xrefs = xrelfo_._xrefs
 
-    assert edf[0:4] == b'\x7fELF'
+    assert edf[0:4] == b"\x7fELF"
 
     pprint(xrefs[0])
     pprint(xrefs[0]._data)
diff -urpN frr-frr-8.4.2/python/tiabwarfo.py frr-frr-8.5/python/tiabwarfo.py
--- frr-frr-8.4.2/python/tiabwarfo.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/tiabwarfo.py	2023-03-13 20:01:47.000000000 +0600
@@ -23,10 +23,19 @@ import re
 import argparse
 import json
 
-structs = ['xref', 'xref_logmsg', 'xref_threadsched', 'xref_install_element', 'xrefdata', 'xrefdata_logmsg', 'cmd_element']
+structs = [
+    "xref",
+    "xref_logmsg",
+    "xref_threadsched",
+    "xref_install_element",
+    "xrefdata",
+    "xrefdata_logmsg",
+    "cmd_element",
+]
 
-def extract(filename='lib/.libs/libfrr.so'):
-    '''
+
+def extract(filename="lib/.libs/libfrr.so"):
+    """
     Convert output from "pahole" to JSON.
 
     Example pahole output:
@@ -41,26 +50,30 @@ def extract(filename='lib/.libs/libfrr.s
         /* size: 32, cachelines: 1, members: 5 */
         /* last cacheline: 32 bytes */
     };
-    '''
-    pahole = subprocess.check_output(['pahole', '-C', ','.join(structs), filename]).decode('UTF-8')
-
-    struct_re = re.compile(r'^struct ([^ ]+) \{([^\}]+)};', flags=re.M | re.S)
-    field_re = re.compile(r'^\s*(?P<type>[^;\(]+)\s+(?P<name>[^;\[\]]+)(?:\[(?P<array>\d+)\])?;\s*\/\*(?P<comment>.*)\*\/\s*$')
-    comment_re = re.compile(r'^\s*\/\*.*\*\/\s*$')
+    """
+    pahole = subprocess.check_output(
+        ["pahole", "-C", ",".join(structs), filename]
+    ).decode("UTF-8")
+
+    struct_re = re.compile(r"^struct ([^ ]+) \{([^\}]+)};", flags=re.M | re.S)
+    field_re = re.compile(
+        r"^\s*(?P<type>[^;\(]+)\s+(?P<name>[^;\[\]]+)(?:\[(?P<array>\d+)\])?;\s*\/\*(?P<comment>.*)\*\/\s*$"
+    )
+    comment_re = re.compile(r"^\s*\/\*.*\*\/\s*$")
 
     pastructs = struct_re.findall(pahole)
     out = {}
 
     for sname, data in pastructs:
         this = out.setdefault(sname, {})
-        fields = this.setdefault('fields', [])
+        fields = this.setdefault("fields", [])
 
         lines = data.strip().splitlines()
 
         next_offs = 0
 
         for line in lines:
-            if line.strip() == '':
+            if line.strip() == "":
                 continue
             m = comment_re.match(line)
             if m is not None:
@@ -68,51 +81,55 @@ def extract(filename='lib/.libs/libfrr.s
 
             m = field_re.match(line)
             if m is not None:
-                offs, size = m.group('comment').strip().split()
+                offs, size = m.group("comment").strip().split()
                 offs = int(offs)
                 size = int(size)
-                typ_ = m.group('type').strip()
-                name = m.group('name')
+                typ_ = m.group("type").strip()
+                name = m.group("name")
 
-                if name.startswith('(*'):
+                if name.startswith("(*"):
                     # function pointer
-                    typ_ = typ_ + ' *'
-                    name = name[2:].split(')')[0]
+                    typ_ = typ_ + " *"
+                    name = name[2:].split(")")[0]
 
                 data = {
-                    'name': name,
-                    'type': typ_,
-                #   'offset': offs,
-                #   'size': size,
+                    "name": name,
+                    "type": typ_,
+                    #   'offset': offs,
+                    #   'size': size,
                 }
-                if m.group('array'):
-                    data['array'] = int(m.group('array'))
+                if m.group("array"):
+                    data["array"] = int(m.group("array"))
 
                 fields.append(data)
                 if offs != next_offs:
-                    raise ValueError('%d padding bytes before struct %s.%s' % (offs - next_offs, sname, name))
+                    raise ValueError(
+                        "%d padding bytes before struct %s.%s"
+                        % (offs - next_offs, sname, name)
+                    )
                 next_offs = offs + size
                 continue
 
-            raise ValueError('cannot process line: %s' % line)
+            raise ValueError("cannot process line: %s" % line)
 
     return out
 
+
 class FieldApplicator(object):
-    '''
+    """
     Fill ELFDissectStruct fields list from pahole/JSON
 
     Uses the JSON file created by the above code to fill in the struct fields
     in subclasses of ELFDissectStruct.
-    '''
+    """
 
     # only what we really need.  add more as needed.
     packtypes = {
-        'int': 'i',
-        'uint8_t': 'B',
-        'uint16_t': 'H',
-        'uint32_t': 'I',
-        'char': 's',
+        "int": "i",
+        "uint8_t": "B",
+        "uint16_t": "H",
+        "uint32_t": "I",
+        "char": "s",
     }
 
     def __init__(self, data):
@@ -126,60 +143,65 @@ class FieldApplicator(object):
 
     def resolve(self, cls):
         out = []
-        #offset = 0
+        # offset = 0
+
+        fieldrename = getattr(cls, "fieldrename", {})
 
-        fieldrename = getattr(cls, 'fieldrename', {})
         def mkname(n):
             return (fieldrename.get(n, n),)
 
-        for field in self.data[cls.struct]['fields']:
-            typs = field['type'].split()
-            typs = [i for i in typs if i not in ['const']]
+        for field in self.data[cls.struct]["fields"]:
+            typs = field["type"].split()
+            typs = [i for i in typs if i not in ["const"]]
 
             # this will break reuse of xrefstructs.json across 32bit & 64bit
             # platforms
 
-            #if field['offset'] != offset:
+            # if field['offset'] != offset:
             #    assert offset < field['offset']
             #    out.append(('_pad', '%ds' % (field['offset'] - offset,)))
 
             # pretty hacky C types handling, but covers what we need
 
             ptrlevel = 0
-            while typs[-1] == '*':
+            while typs[-1] == "*":
                 typs.pop(-1)
                 ptrlevel += 1
 
             if ptrlevel > 0:
-                packtype = ('P', None)
+                packtype = ("P", None)
                 if ptrlevel == 1:
-                    if typs[0] == 'char':
-                        packtype = ('P', str)
-                    elif typs[0] == 'struct' and typs[1] in self.clsmap:
-                        packtype = ('P', self.clsmap[typs[1]])
-            elif typs[0] == 'enum':
-                packtype = ('I',)
+                    if typs[0] == "char":
+                        packtype = ("P", str)
+                    elif typs[0] == "struct" and typs[1] in self.clsmap:
+                        packtype = ("P", self.clsmap[typs[1]])
+            elif typs[0] == "enum":
+                packtype = ("I",)
             elif typs[0] in self.packtypes:
                 packtype = (self.packtypes[typs[0]],)
-            elif typs[0] == 'struct':
+            elif typs[0] == "struct":
                 if typs[1] in self.clsmap:
                     packtype = (self.clsmap[typs[1]],)
                 else:
-                    raise ValueError('embedded struct %s not in extracted data' % (typs[1],))
+                    raise ValueError(
+                        "embedded struct %s not in extracted data" % (typs[1],)
+                    )
             else:
-                raise ValueError('cannot decode field %s in struct %s (%s)' % (
-                        cls.struct, field['name'], field['type']))
-
-            if 'array' in field and typs[0] == 'char':
-                packtype = ('%ds' % field['array'],)
-                out.append(mkname(field['name']) + packtype)
-            elif 'array' in field:
-                for i in range(0, field['array']):
-                    out.append(mkname('%s_%d' % (field['name'], i)) + packtype)
+                raise ValueError(
+                    "cannot decode field %s in struct %s (%s)"
+                    % (cls.struct, field["name"], field["type"])
+                )
+
+            if "array" in field and typs[0] == "char":
+                packtype = ("%ds" % field["array"],)
+                out.append(mkname(field["name"]) + packtype)
+            elif "array" in field:
+                for i in range(0, field["array"]):
+                    out.append(mkname("%s_%d" % (field["name"], i)) + packtype)
             else:
-                out.append(mkname(field['name']) + packtype)
+                out.append(mkname(field["name"]) + packtype)
 
-            #offset = field['offset'] + field['size']
+            # offset = field['offset'] + field['size']
 
         cls.fields = out
 
@@ -187,16 +209,30 @@ class FieldApplicator(object):
         for cls in self.classes:
             self.resolve(cls)
 
+
 def main():
-    argp = argparse.ArgumentParser(description = 'FRR DWARF structure extractor')
-    argp.add_argument('-o', dest='output', type=str, help='write JSON output', default='python/xrefstructs.json')
-    argp.add_argument('-i', dest='input',  type=str, help='ELF file to read',  default='lib/.libs/libfrr.so')
+    argp = argparse.ArgumentParser(description="FRR DWARF structure extractor")
+    argp.add_argument(
+        "-o",
+        dest="output",
+        type=str,
+        help="write JSON output",
+        default="python/xrefstructs.json",
+    )
+    argp.add_argument(
+        "-i",
+        dest="input",
+        type=str,
+        help="ELF file to read",
+        default="lib/.libs/libfrr.so",
+    )
     args = argp.parse_args()
 
     out = extract(args.input)
-    with open(args.output + '.tmp', 'w') as fd:
+    with open(args.output + ".tmp", "w") as fd:
         json.dump(out, fd, indent=2, sort_keys=True)
-    os.rename(args.output + '.tmp', args.output)
+    os.rename(args.output + ".tmp", args.output)
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     main()
diff -urpN frr-frr-8.4.2/python/vtysh-cmd-check.py frr-frr-8.5/python/vtysh-cmd-check.py
--- frr-frr-8.4.2/python/vtysh-cmd-check.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/vtysh-cmd-check.py	1970-01-01 06:00:00.000000000 +0600
@@ -1,72 +0,0 @@
-#!/usr/bin/env python3
-#
-# Quick demo program that checks whether files define commands that aren't
-# in vtysh.  Execute after building.
-#
-# This is free and unencumbered software released into the public domain.
-#
-# Anyone is free to copy, modify, publish, use, compile, sell, or
-# distribute this software, either in source code form or as a compiled
-# binary, for any purpose, commercial or non-commercial, and by any
-# means.
-#
-# In jurisdictions that recognize copyright laws, the author or authors
-# of this software dedicate any and all copyright interest in the
-# software to the public domain. We make this dedication for the benefit
-# of the public at large and to the detriment of our heirs and
-# successors. We intend this dedication to be an overt act of
-# relinquishment in perpetuity of all present and future rights to this
-# software under copyright law.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-# OTHER DEALINGS IN THE SOFTWARE.
-#
-# For more information, please refer to <http://unlicense.org/>
-
-import os
-import json
-import subprocess
-
-os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-
-with open("frr.xref", "r") as fd:
-    data = json.load(fd)
-
-vtysh_scan, _ = subprocess.Popen(
-    ["make", "var-vtysh_scan"], stdout=subprocess.PIPE
-).communicate()
-vtysh_scan = set(vtysh_scan.decode("US-ASCII").split())
-
-check = set()
-vtysh = {}
-
-for cmd, defs in data["cli"].items():
-    for binary, clidef in defs.items():
-        if clidef["defun"]["file"].startswith("vtysh/"):
-            vtysh[clidef["string"]] = clidef
-
-for cmd, defs in data["cli"].items():
-    for binary, clidef in defs.items():
-        if clidef["defun"]["file"].startswith("vtysh/"):
-            continue
-
-        if clidef["defun"]["file"] not in vtysh_scan:
-            vtysh_def = vtysh.get(clidef["string"])
-            if vtysh_def is not None:
-                print(
-                    "\033[33m%s defines %s, has a custom define in vtysh %s\033[m"
-                    % (clidef["defun"]["file"], cmd, vtysh_def["defun"]["file"])
-                )
-            else:
-                print(
-                    "\033[31m%s defines %s, not in vtysh_scan\033[m"
-                    % (clidef["defun"]["file"], cmd)
-                )
-                check.add(clidef["defun"]["file"])
-
-print("\nfiles to check:\n\t" + " ".join(sorted(check)))
diff -urpN frr-frr-8.4.2/python/xref2vtysh.py frr-frr-8.5/python/xref2vtysh.py
--- frr-frr-8.4.2/python/xref2vtysh.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/python/xref2vtysh.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,389 @@
+# FRR xref vtysh command extraction
+#
+# Copyright (C) 2022  David Lamparter for NetDEF, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; see the file COPYING; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+
+"""
+Generate vtysh_cmd.c from frr .xref file(s).
+
+This can run either standalone or as part of xrelfo.  The latter saves a
+non-negligible amount of time (0.5s on average systems, more on e.g. slow ARMs)
+since serializing and deserializing JSON is a significant bottleneck in this.
+"""
+
+import sys
+import os
+import re
+import pathlib
+import argparse
+from collections import defaultdict
+import difflib
+
+import json
+
+try:
+    import ujson as json  # type: ignore
+except ImportError:
+    pass
+
+frr_top_src = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+
+# vtysh needs to know which daemon(s) to send commands to.  For lib/, this is
+# not quite obvious...
+
+daemon_flags = {
+    "lib/agentx.c": "VTYSH_ISISD|VTYSH_RIPD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ZEBRA",
+    "lib/filter.c": "VTYSH_ACL",
+    "lib/filter_cli.c": "VTYSH_ACL",
+    "lib/if.c": "VTYSH_INTERFACE",
+    "lib/keychain.c": "VTYSH_RIPD|VTYSH_EIGRPD|VTYSH_OSPF6D",
+    "lib/lib_vty.c": "VTYSH_ALL",
+    "lib/log_vty.c": "VTYSH_ALL",
+    "lib/nexthop_group.c": "VTYSH_NH_GROUP",
+    "lib/resolver.c": "VTYSH_NHRPD|VTYSH_BGPD",
+    "lib/routemap.c": "VTYSH_RMAP",
+    "lib/routemap_cli.c": "VTYSH_RMAP",
+    "lib/spf_backoff.c": "VTYSH_ISISD",
+    "lib/thread.c": "VTYSH_ALL",
+    "lib/vrf.c": "VTYSH_VRF",
+    "lib/vty.c": "VTYSH_ALL",
+}
+
+vtysh_cmd_head = """/* autogenerated file, DO NOT EDIT! */
+#include <zebra.h>
+
+#include "command.h"
+#include "linklist.h"
+
+#include "vtysh/vtysh.h"
+"""
+
+if sys.stderr.isatty():
+    _fmt_red = "\033[31m"
+    _fmt_green = "\033[32m"
+    _fmt_clear = "\033[m"
+else:
+    _fmt_red = _fmt_green = _fmt_clear = ""
+
+
+def c_escape(text: str) -> str:
+    """
+    Escape string for output into C source code.
+
+    Handles only what's needed here.  CLI strings and help text don't contain
+    weird special characters.
+    """
+    return text.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
+
+
+class NodeDict(defaultdict):
+    """
+    CLI node ID (integer) -> dict of commands in that node.
+    """
+
+    nodenames = {}  # Dict[int, str]
+
+    def __init__(self):
+        super().__init__(dict)
+
+    def items_named(self):
+        for k, v in self.items():
+            yield self.nodename(k), v
+
+    @classmethod
+    def nodename(cls, nodeid: int) -> str:
+        return cls.nodenames.get(nodeid, str(nodeid))
+
+    @classmethod
+    def load_nodenames(cls):
+        with open(os.path.join(frr_top_src, "lib", "command.h"), "r") as fd:
+            command_h = fd.read()
+
+        nodes = re.search(r"enum\s+node_type\s+\{(.*?)\}", command_h, re.S)
+        if nodes is None:
+            raise RuntimeError(
+                "regex failed to match on lib/command.h (to get CLI node names)"
+            )
+
+        text = nodes.group(1)
+        text = re.sub(r"/\*.*?\*/", "", text, flags=re.S)
+        text = re.sub(r"//.*?$", "", text, flags=re.M)
+        text = text.replace(",", " ")
+        text = text.split()
+
+        for i, name in enumerate(text):
+            cls.nodenames[i] = name
+
+
+class CommandEntry:
+    """
+    CLI command definition.
+
+    - one DEFUN creates at most one of these, even if the same command is
+      installed in multiple CLI nodes (e.g. BGP address-family nodes)
+    - for each CLI node, commands with the same CLI string are merged.  This
+      is *almost* irrelevant - ospfd & ospf6d define some identical commands
+      in the route-map node.  Those must be merged for things to work
+      correctly.
+    """
+
+    all_defs = []  # List[CommandEntry]
+    warn_counter = 0
+
+    def __init__(self, origin, name, spec):
+        self.origin = origin
+        self.name = name
+        self._spec = spec
+        self._registered = False
+
+        self.cmd = spec["string"]
+        self._cmd_normalized = self.normalize_cmd(self.cmd)
+
+        self.hidden = "hidden" in spec.get("attrs", [])
+        self.daemons = self._get_daemons()
+
+        self.doclines = self._spec["doc"].splitlines(keepends=True)
+        if not self.doclines[-1].endswith("\n"):
+            self.warn_loc("docstring does not end with \\n")
+
+    def warn_loc(self, wtext, nodename=None):
+        """
+        Print warning with parseable (compiler style) location
+
+        Matching the way compilers emit file/lineno means editors/IDE can
+        identify / jump to the error location.
+        """
+
+        if nodename:
+            prefix = ": [%s] %s:" % (nodename, self.name)
+        else:
+            prefix = ": %s:" % (self.name,)
+
+        for line in wtext.rstrip("\n").split("\n"):
+            sys.stderr.write(
+                "%s:%d%s %s\n"
+                % (
+                    self._spec["defun"]["file"],
+                    self._spec["defun"]["line"],
+                    prefix,
+                    line,
+                )
+            )
+            prefix = "-    "
+
+        CommandEntry.warn_counter += 1
+
+    def _get_daemons(self):
+        path = pathlib.Path(self.origin)
+        if path.name == "vtysh":
+            return {}
+
+        defun_file = os.path.relpath(self._spec["defun"]["file"], frr_top_src)
+        defun_path = pathlib.Path(defun_file)
+
+        if defun_path.parts[0] != "lib":
+            if "." not in path.name:
+                # daemons don't have dots in their filename
+                return {"VTYSH_" + path.name.upper()}
+
+            # loadable modules - use directory name to determine daemon
+            return {"VTYSH_" + path.parts[-2].upper()}
+
+        if defun_file in daemon_flags:
+            return {daemon_flags[defun_file]}
+
+        v6_cmd = "ipv6" in self.name
+        if defun_file == "lib/plist.c":
+            if v6_cmd:
+                return {
+                    "VTYSH_RIPNGD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ZEBRA|VTYSH_PIM6D|VTYSH_BABELD|VTYSH_ISISD|VTYSH_FABRICD"
+                }
+            else:
+                return {
+                    "VTYSH_RIPD|VTYSH_OSPFD|VTYSH_BGPD|VTYSH_ZEBRA|VTYSH_PIMD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_ISISD|VTYSH_FABRICD"
+                }
+
+        if defun_file == "lib/if_rmap.c":
+            if v6_cmd:
+                return {"VTYSH_RIPNGD"}
+            else:
+                return {"VTYSH_RIPD"}
+
+        return {}
+
+    def __repr__(self):
+        return "<CommandEntry %s: %r>" % (self.name, self.cmd)
+
+    def register(self):
+        """Track DEFUNs so each is only output once."""
+        if not self._registered:
+            self.all_defs.append(self)
+            self._registered = True
+        return self
+
+    def merge(self, other, nodename):
+        if self._cmd_normalized != other._cmd_normalized:
+            self.warn_loc(
+                "command definition mismatch, first definied as:\n%r" % (self.cmd,),
+                nodename=nodename,
+            )
+            other.warn_loc("later defined as:\n%r" % (other.cmd,), nodename=nodename)
+
+        if self._spec["doc"] != other._spec["doc"]:
+            self.warn_loc(
+                "help string mismatch, first defined here (-)", nodename=nodename
+            )
+            other.warn_loc(
+                "later defined here (+)\nnote: both commands define %r in same node (%s)"
+                % (self.cmd, nodename),
+                nodename=nodename,
+            )
+
+            d = difflib.Differ()
+            for diffline in d.compare(self.doclines, other.doclines):
+                if diffline.startswith("  "):
+                    continue
+                if diffline.startswith("+ "):
+                    diffline = _fmt_green + diffline
+                elif diffline.startswith("- "):
+                    diffline = _fmt_red + diffline
+                sys.stderr.write("\t" + diffline.rstrip("\n") + _fmt_clear + "\n")
+
+        if self.hidden != other.hidden:
+            self.warn_loc(
+                "hidden flag mismatch, first %r here" % (self.hidden,),
+                nodename=nodename,
+            )
+            other.warn_loc(
+                "later %r here (+)\nnote: both commands define %r in same node (%s)"
+                % (other.hidden, self.cmd, nodename),
+                nodename=nodename,
+            )
+
+        # ensure name is deterministic regardless of input DEFUN order
+        self.name = min([self.name, other.name], key=lambda i: (len(i), i))
+        self.daemons.update(other.daemons)
+
+    def get_def(self):
+        doc = "\n".join(['\t"%s"' % c_escape(line) for line in self.doclines])
+        defsh = "DEFSH_HIDDEN" if self.hidden else "DEFSH"
+
+        # make daemon list deterministic
+        daemons = set()
+        for daemon in self.daemons:
+            daemons.update(daemon.split("|"))
+        daemon_str = "|".join(sorted(daemons))
+
+        return """
+%s (%s, %s_vtysh,
+\t"%s",
+%s)
+""" % (
+            defsh,
+            daemon_str,
+            self.name,
+            c_escape(self.cmd),
+            doc,
+        )
+
+    # accept slightly different command definitions that result in the same command
+    re_collapse_ws = re.compile(r"\s+")
+    re_remove_varnames = re.compile(r"\$[a-z][a-z0-9_]*")
+
+    @classmethod
+    def normalize_cmd(cls, cmd):
+        cmd = cmd.strip()
+        cmd = cls.re_collapse_ws.sub(" ", cmd)
+        cmd = cls.re_remove_varnames.sub("", cmd)
+        return cmd
+
+    @classmethod
+    def process(cls, nodes, name, origin, spec):
+        if "nosh" in spec.get("attrs", []):
+            return
+        if origin == "vtysh/vtysh":
+            return
+
+        if origin == "isisd/fabricd":
+            # dirty workaround :(
+            name = "fabricd_" + name
+
+        entry = cls(origin, name, spec)
+        if not entry.daemons:
+            return
+
+        for nodedata in spec.get("nodes", []):
+            node = nodes[nodedata["node"]]
+            if entry._cmd_normalized not in node:
+                node[entry._cmd_normalized] = entry.register()
+            else:
+                node[entry._cmd_normalized].merge(
+                    entry, nodes.nodename(nodedata["node"])
+                )
+
+    @classmethod
+    def load(cls, xref):
+        nodes = NodeDict()
+
+        for cmd_name, origins in xref.get("cli", {}).items():
+            for origin, spec in origins.items():
+                CommandEntry.process(nodes, cmd_name, origin, spec)
+        return nodes
+
+    @classmethod
+    def output_defs(cls, ofd):
+        for entry in sorted(cls.all_defs, key=lambda i: i.name):
+            ofd.write(entry.get_def())
+
+    @classmethod
+    def output_install(cls, ofd, nodes):
+        ofd.write("\nvoid vtysh_init_cmd(void)\n{\n")
+
+        for name, items in sorted(nodes.items_named()):
+            for item in sorted(items.values(), key=lambda i: i.name):
+                ofd.write("\tinstall_element(%s, &%s_vtysh);\n" % (name, item.name))
+
+        ofd.write("}\n")
+
+    @classmethod
+    def run(cls, xref, ofd):
+        ofd.write(vtysh_cmd_head)
+
+        NodeDict.load_nodenames()
+        nodes = cls.load(xref)
+        cls.output_defs(ofd)
+        cls.output_install(ofd, nodes)
+
+
+def main():
+    argp = argparse.ArgumentParser(description="FRR xref to vtysh defs")
+    argp.add_argument(
+        "xreffile", metavar="XREFFILE", type=str, help=".xref file to read"
+    )
+    argp.add_argument("-Werror", action="store_const", const=True)
+    args = argp.parse_args()
+
+    with open(args.xreffile, "r") as fd:
+        data = json.load(fd)
+
+    CommandEntry.run(data, sys.stdout)
+
+    if args.Werror and CommandEntry.warn_counter:
+        sys.exit(1)
+
+
+if __name__ == "__main__":
+    main()
diff -urpN frr-frr-8.4.2/python/xrelfo.py frr-frr-8.5/python/xrelfo.py
--- frr-frr-8.4.2/python/xrelfo.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/python/xrelfo.py	2023-03-13 20:01:47.000000000 +0600
@@ -21,22 +21,34 @@ import os
 import struct
 import re
 import traceback
-import json
+
+json_dump_args = {}
+
+try:
+    import ujson as json
+
+    json_dump_args["escape_forward_slashes"] = False
+except ImportError:
+    import json
+
 import argparse
 
 from clippy.uidhash import uidhash
 from clippy.elf import *
-from clippy import frr_top_src
+from clippy import frr_top_src, CmdAttr
 from tiabwarfo import FieldApplicator
+from xref2vtysh import CommandEntry
 
 try:
-    with open(os.path.join(frr_top_src, 'python', 'xrefstructs.json'), 'r') as fd:
+    with open(os.path.join(frr_top_src, "python", "xrefstructs.json"), "r") as fd:
         xrefstructs = json.load(fd)
 except FileNotFoundError:
-    sys.stderr.write('''
+    sys.stderr.write(
+        """
 The "xrefstructs.json" file (created by running tiabwarfo.py with the pahole
 tool available) could not be found.  It should be included with the sources.
-''')
+"""
+    )
     sys.exit(1)
 
 # constants, need to be kept in sync manually...
@@ -48,7 +60,7 @@ XREFT_INSTALL_ELEMENT = 0x301
 
 # LOG_*
 priovals = {}
-prios = ['0', '1', '2', 'E', 'W', 'N', 'I', 'D']
+prios = ["0", "1", "2", "E", "W", "N", "I", "D"]
 
 
 class XrelfoJson(object):
@@ -61,9 +73,10 @@ class XrelfoJson(object):
     def to_dict(self, refs):
         pass
 
+
 class Xref(ELFDissectStruct, XrelfoJson):
-    struct = 'xref'
-    fieldrename = {'type': 'typ'}
+    struct = "xref"
+    fieldrename = {"type": "typ"}
     containers = {}
 
     def __init__(self, *args, **kwargs):
@@ -76,7 +89,7 @@ class Xref(ELFDissectStruct, XrelfoJson)
     def container(self):
         if self._container is None:
             if self.typ in self.containers:
-                self._container = self.container_of(self.containers[self.typ], 'xref')
+                self._container = self.container_of(self.containers[self.typ], "xref")
         return self._container
 
     def check(self, *args, **kwargs):
@@ -85,10 +98,10 @@ class Xref(ELFDissectStruct, XrelfoJson)
 
 
 class Xrefdata(ELFDissectStruct):
-    struct = 'xrefdata'
+    struct = "xrefdata"
 
     # uid is all zeroes in the data loaded from ELF
-    fieldrename = {'uid': '_uid'}
+    fieldrename = {"uid": "_uid"}
 
     def ref_from(self, xref, typ):
         self.xref = xref
@@ -99,38 +112,84 @@ class Xrefdata(ELFDissectStruct):
             return None
         return uidhash(self.xref.file, self.hashstr, self.hashu32_0, self.hashu32_1)
 
+
 class XrefPtr(ELFDissectStruct):
     fields = [
-        ('xref', 'P', Xref),
+        ("xref", "P", Xref),
     ]
 
+
 class XrefThreadSched(ELFDissectStruct, XrelfoJson):
-    struct = 'xref_threadsched'
+    struct = "xref_threadsched"
+
+
 Xref.containers[XREFT_THREADSCHED] = XrefThreadSched
 
+
 class XrefLogmsg(ELFDissectStruct, XrelfoJson):
-    struct = 'xref_logmsg'
+    struct = "xref_logmsg"
 
     def _warn_fmt(self, text):
-        lines = text.split('\n')
-        yield ((self.xref.file, self.xref.line), '%s:%d: %s (in %s())%s\n' % (self.xref.file, self.xref.line, lines[0], self.xref.func, ''.join(['\n' + l for l in lines[1:]])))
+        lines = text.split("\n")
+        yield (
+            (self.xref.file, self.xref.line),
+            "%s:%d: %s (in %s())%s\n"
+            % (
+                self.xref.file,
+                self.xref.line,
+                lines[0],
+                self.xref.func,
+                "".join(["\n" + l for l in lines[1:]]),
+            ),
+        )
 
     fmt_regexes = [
-        (re.compile(r'([\n\t]+)'), 'error: log message contains tab or newline'),
-    #    (re.compile(r'^(\s+)'),   'warning: log message starts with whitespace'),
-        (re.compile(r'^((?:warn(?:ing)?|error):\s*)', re.I), 'warning: log message starts with severity'),
+        (re.compile(r"([\n\t]+)"), "error: log message contains tab or newline"),
+        #    (re.compile(r'^(\s+)'),   'warning: log message starts with whitespace'),
+        (
+            re.compile(r"^((?:warn(?:ing)?|error):\s*)", re.I),
+            "warning: log message starts with severity",
+        ),
     ]
     arg_regexes = [
-    # the (?<![\?:] ) avoids warning for x ? inet_ntop(...) : "(bla)"
-        (re.compile(r'((?<![\?:] )inet_ntop\s*\(\s*(?:[AP]F_INET|2)\s*,)'),   'cleanup: replace inet_ntop(AF_INET, ...) with %pI4',  lambda s: True),
-        (re.compile(r'((?<![\?:] )inet_ntop\s*\(\s*(?:[AP]F_INET6|10)\s*,)'), 'cleanup: replace inet_ntop(AF_INET6, ...) with %pI6', lambda s: True),
-        (re.compile(r'((?<![\?:] )inet_ntoa)'),                               'cleanup: replace inet_ntoa(...) with %pI4',           lambda s: True),
-        (re.compile(r'((?<![\?:] )ipaddr2str)'),                              'cleanup: replace ipaddr2str(...) with %pIA',          lambda s: True),
-        (re.compile(r'((?<![\?:] )prefix2str)'),                              'cleanup: replace prefix2str(...) with %pFX',          lambda s: True),
-        (re.compile(r'((?<![\?:] )prefix_mac2str)'),                          'cleanup: replace prefix_mac2str(...) with %pEA',      lambda s: True),
-        (re.compile(r'((?<![\?:] )sockunion2str)'),                           'cleanup: replace sockunion2str(...) with %pSU',       lambda s: True),
-
-    #   (re.compile(r'^(\s*__(?:func|FUNCTION|PRETTY_FUNCTION)__\s*)'), 'error: debug message starts with __func__', lambda s: (s.priority & 7 == 7) ),
+        # the (?<![\?:] ) avoids warning for x ? inet_ntop(...) : "(bla)"
+        (
+            re.compile(r"((?<![\?:] )inet_ntop\s*\(\s*(?:[AP]F_INET|2)\s*,)"),
+            "cleanup: replace inet_ntop(AF_INET, ...) with %pI4",
+            lambda s: True,
+        ),
+        (
+            re.compile(r"((?<![\?:] )inet_ntop\s*\(\s*(?:[AP]F_INET6|10)\s*,)"),
+            "cleanup: replace inet_ntop(AF_INET6, ...) with %pI6",
+            lambda s: True,
+        ),
+        (
+            # string split-up here is to not trigger "inet_ntoa forbidden"
+            re.compile(r"((?<![\?:] )inet_" + r"ntoa)"),
+            "cleanup: replace inet_" + "ntoa(...) with %pI4",
+            lambda s: True,
+        ),
+        (
+            re.compile(r"((?<![\?:] )ipaddr2str)"),
+            "cleanup: replace ipaddr2str(...) with %pIA",
+            lambda s: True,
+        ),
+        (
+            re.compile(r"((?<![\?:] )prefix2str)"),
+            "cleanup: replace prefix2str(...) with %pFX",
+            lambda s: True,
+        ),
+        (
+            re.compile(r"((?<![\?:] )prefix_mac2str)"),
+            "cleanup: replace prefix_mac2str(...) with %pEA",
+            lambda s: True,
+        ),
+        (
+            re.compile(r"((?<![\?:] )sockunion2str)"),
+            "cleanup: replace sockunion2str(...) with %pSU",
+            lambda s: True,
+        ),
+        #   (re.compile(r'^(\s*__(?:func|FUNCTION|PRETTY_FUNCTION)__\s*)'), 'error: debug message starts with __func__', lambda s: (s.priority & 7 == 7) ),
     ]
 
     def check(self, wopt):
@@ -140,11 +199,11 @@ class XrefLogmsg(ELFDissectStruct, Xrelf
                 out = []
                 for i, text in enumerate(items):
                     if (i % 2) == 1:
-                        out.append('\033[41;37;1m%s\033[m' % repr(text)[1:-1])
+                        out.append("\033[41;37;1m%s\033[m" % repr(text)[1:-1])
                     else:
                         out.append(repr(text)[1:-1])
 
-                excerpt = ''.join(out)
+                excerpt = "".join(out)
             else:
                 excerpt = repr(itext)[1:-1]
             return excerpt
@@ -165,68 +224,99 @@ class XrefLogmsg(ELFDissectStruct, Xrelf
                     continue
 
                 excerpt = fmt_msg(rex, self.args)
-                yield from self._warn_fmt('%s:\n\t"%s",\n\t%s' % (msg, repr(self.fmtstring)[1:-1], excerpt))
+                yield from self._warn_fmt(
+                    '%s:\n\t"%s",\n\t%s' % (msg, repr(self.fmtstring)[1:-1], excerpt)
+                )
 
     def dump(self):
-        print('%-60s %s%s %-25s [EC %d] %s' % (
-            '%s:%d %s()' % (self.xref.file, self.xref.line, self.xref.func),
-            prios[self.priority & 7],
-            priovals.get(self.priority & 0x30, ' '),
-            self.xref.xrefdata.uid, self.ec, self.fmtstring))
+        print(
+            "%-60s %s%s %-25s [EC %d] %s"
+            % (
+                "%s:%d %s()" % (self.xref.file, self.xref.line, self.xref.func),
+                prios[self.priority & 7],
+                priovals.get(self.priority & 0x30, " "),
+                self.xref.xrefdata.uid,
+                self.ec,
+                self.fmtstring,
+            )
+        )
 
     def to_dict(self, xrelfo):
-        jsobj = dict([(i, getattr(self.xref, i)) for i in ['file', 'line', 'func']])
+        jsobj = dict([(i, getattr(self.xref, i)) for i in ["file", "line", "func"]])
         if self.ec != 0:
-            jsobj['ec'] = self.ec
-        jsobj['fmtstring'] = self.fmtstring
-        jsobj['args'] = self.args
-        jsobj['priority'] = self.priority & 7
-        jsobj['type'] = 'logmsg'
-        jsobj['binary'] = self._elfsect._elfwrap.orig_filename
+            jsobj["ec"] = self.ec
+        jsobj["fmtstring"] = self.fmtstring
+        jsobj["args"] = self.args
+        jsobj["priority"] = self.priority & 7
+        jsobj["type"] = "logmsg"
+        jsobj["binary"] = self._elfsect._elfwrap.orig_filename
 
         if self.priority & 0x10:
-            jsobj.setdefault('flags', []).append('errno')
+            jsobj.setdefault("flags", []).append("errno")
         if self.priority & 0x20:
-            jsobj.setdefault('flags', []).append('getaddrinfo')
+            jsobj.setdefault("flags", []).append("getaddrinfo")
+
+        xrelfo["refs"].setdefault(self.xref.xrefdata.uid, []).append(jsobj)
 
-        xrelfo['refs'].setdefault(self.xref.xrefdata.uid, []).append(jsobj)
 
 Xref.containers[XREFT_LOGMSG] = XrefLogmsg
 
-class CmdElement(ELFDissectStruct, XrelfoJson):
-    struct = 'cmd_element'
 
-    cmd_attrs = { 0: None, 1: 'deprecated', 2: 'hidden'}
+class CmdElement(ELFDissectStruct, XrelfoJson):
+    struct = "cmd_element"
 
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
 
     def to_dict(self, xrelfo):
-        jsobj = xrelfo['cli'].setdefault(self.name, {}).setdefault(self._elfsect._elfwrap.orig_filename, {})
-
-        jsobj.update({
-            'string': self.string,
-            'doc': self.doc,
-            'attr': self.cmd_attrs.get(self.attr, self.attr),
-        })
-        if jsobj['attr'] is None:
-            del jsobj['attr']
+        jsobj = (
+            xrelfo["cli"]
+            .setdefault(self.name, {})
+            .setdefault(self._elfsect._elfwrap.orig_filename, {})
+        )
+
+        jsobj.update(
+            {
+                "string": self.string,
+                "doc": self.doc,
+            }
+        )
+        if self.attr:
+            jsobj["attr"] = attr = self.attr
+            for attrname in CmdAttr.__members__:
+                val = CmdAttr[attrname]
+                if attr & val:
+                    jsobj.setdefault("attrs", []).append(attrname.lower())
+                    attr &= ~val
+
+        jsobj["defun"] = dict(
+            [(i, getattr(self.xref, i)) for i in ["file", "line", "func"]]
+        )
 
-        jsobj['defun'] = dict([(i, getattr(self.xref, i)) for i in ['file', 'line', 'func']])
 
 Xref.containers[XREFT_DEFUN] = CmdElement
 
+
 class XrefInstallElement(ELFDissectStruct, XrelfoJson):
-    struct = 'xref_install_element'
+    struct = "xref_install_element"
 
     def to_dict(self, xrelfo):
-        jsobj = xrelfo['cli'].setdefault(self.cmd_element.name, {}).setdefault(self._elfsect._elfwrap.orig_filename, {})
-        nodes = jsobj.setdefault('nodes', [])
+        jsobj = (
+            xrelfo["cli"]
+            .setdefault(self.cmd_element.name, {})
+            .setdefault(self._elfsect._elfwrap.orig_filename, {})
+        )
+        nodes = jsobj.setdefault("nodes", [])
+
+        nodes.append(
+            {
+                "node": self.node_type,
+                "install": dict(
+                    [(i, getattr(self.xref, i)) for i in ["file", "line", "func"]]
+                ),
+            }
+        )
 
-        nodes.append({
-            'node': self.node_type,
-            'install': dict([(i, getattr(self.xref, i)) for i in ['file', 'line', 'func']]),
-        })
 
 Xref.containers[XREFT_INSTALL_ELEMENT] = XrefInstallElement
 
@@ -243,86 +333,90 @@ fieldapply()
 
 class Xrelfo(dict):
     def __init__(self):
-        super().__init__({
-            'refs': {},
-            'cli': {},
-        })
+        super().__init__(
+            {
+                "refs": {},
+                "cli": {},
+            }
+        )
         self._xrefs = []
 
     def load_file(self, filename):
         orig_filename = filename
-        if filename.endswith('.la') or filename.endswith('.lo'):
-            with open(filename, 'r') as fd:
+        if filename.endswith(".la") or filename.endswith(".lo"):
+            with open(filename, "r") as fd:
                 for line in fd:
                     line = line.strip()
-                    if line.startswith('#') or line == '' or '=' not in line:
+                    if line.startswith("#") or line == "" or "=" not in line:
                         continue
 
-                    var, val = line.split('=', 1)
-                    if var not in ['library_names', 'pic_object']:
+                    var, val = line.split("=", 1)
+                    if var not in ["library_names", "pic_object"]:
                         continue
                     if val.startswith("'") or val.startswith('"'):
                         val = val[1:-1]
 
-                    if var == 'pic_object':
+                    if var == "pic_object":
                         filename = os.path.join(os.path.dirname(filename), val)
                         break
 
                     val = val.strip().split()[0]
-                    filename = os.path.join(os.path.dirname(filename), '.libs', val)
+                    filename = os.path.join(os.path.dirname(filename), ".libs", val)
                     break
                 else:
-                    raise ValueError('could not process libtool file "%s"' % orig_filename)
+                    raise ValueError(
+                        'could not process libtool file "%s"' % orig_filename
+                    )
 
         while True:
-            with open(filename, 'rb') as fd:
+            with open(filename, "rb") as fd:
                 hdr = fd.read(4)
 
-            if hdr == b'\x7fELF':
+            if hdr == b"\x7fELF":
                 self.load_elf(filename, orig_filename)
                 return
 
-            if hdr[:2] == b'#!':
+            if hdr[:2] == b"#!":
                 path, name = os.path.split(filename)
-                filename = os.path.join(path, '.libs', name)
+                filename = os.path.join(path, ".libs", name)
                 continue
 
-            if hdr[:1] == b'{':
-                with open(filename, 'r') as fd:
+            if hdr[:1] == b"{":
+                with open(filename, "r") as fd:
                     self.load_json(fd)
                 return
 
-            raise ValueError('cannot determine file type for %s' % (filename))
+            raise ValueError("cannot determine file type for %s" % (filename))
 
     def load_elf(self, filename, orig_filename):
         edf = ELFDissectFile(filename)
         edf.orig_filename = orig_filename
 
-        note = edf._elffile.find_note('FRRouting', 'XREF')
+        note = edf._elffile.find_note("FRRouting", "XREF")
         if note is not None:
-            endian = '>' if edf._elffile.bigendian else '<'
+            endian = ">" if edf._elffile.bigendian else "<"
             mem = edf._elffile[note]
             if edf._elffile.elfclass == 64:
-                start, end = struct.unpack(endian + 'QQ', mem)
+                start, end = struct.unpack(endian + "QQ", mem)
                 start += note.start
                 end += note.start + 8
             else:
-                start, end = struct.unpack(endian + 'II', mem)
+                start, end = struct.unpack(endian + "II", mem)
                 start += note.start
                 end += note.start + 4
 
             ptrs = edf.iter_data(XrefPtr, slice(start, end))
 
         else:
-            xrefarray = edf.get_section('xref_array')
+            xrefarray = edf.get_section("xref_array")
             if xrefarray is None:
-                raise ValueError('file has neither xref note nor xref_array section')
+                raise ValueError("file has neither xref note nor xref_array section")
 
             ptrs = xrefarray.iter_data(XrefPtr)
 
         for ptr in ptrs:
             if ptr.xref is None:
-                print('NULL xref')
+                print("NULL xref")
                 continue
             self._xrefs.append(ptr.xref)
 
@@ -335,15 +429,15 @@ class Xrelfo(dict):
 
     def load_json(self, fd):
         data = json.load(fd)
-        for uid, items in data['refs'].items():
-            myitems = self['refs'].setdefault(uid, [])
+        for uid, items in data["refs"].items():
+            myitems = self["refs"].setdefault(uid, [])
             for item in items:
                 if item in myitems:
                     continue
                 myitems.append(item)
 
-        for cmd, items in data['cli'].items():
-            self['cli'].setdefault(cmd, {}).update(items)
+        for cmd, items in data["cli"].items():
+            self["cli"].setdefault(cmd, {}).update(items)
 
         return data
 
@@ -351,23 +445,33 @@ class Xrelfo(dict):
         for xref in self._xrefs:
             yield from xref.check(checks)
 
+
 def main():
-    argp = argparse.ArgumentParser(description = 'FRR xref ELF extractor')
-    argp.add_argument('-o', dest='output', type=str, help='write JSON output')
-    argp.add_argument('--out-by-file',     type=str, help='write by-file JSON output')
-    argp.add_argument('-Wlog-format',      action='store_const', const=True)
-    argp.add_argument('-Wlog-args',        action='store_const', const=True)
-    argp.add_argument('-Werror',           action='store_const', const=True)
-    argp.add_argument('--profile',         action='store_const', const=True)
-    argp.add_argument('binaries', metavar='BINARY', nargs='+', type=str, help='files to read (ELF files or libtool objects)')
+    argp = argparse.ArgumentParser(description="FRR xref ELF extractor")
+    argp.add_argument("-o", dest="output", type=str, help="write JSON output")
+    argp.add_argument("--out-by-file", type=str, help="write by-file JSON output")
+    argp.add_argument("-c", dest="vtysh_cmds", type=str, help="write vtysh_cmd.c")
+    argp.add_argument("-Wlog-format", action="store_const", const=True)
+    argp.add_argument("-Wlog-args", action="store_const", const=True)
+    argp.add_argument("-Werror", action="store_const", const=True)
+    argp.add_argument("--profile", action="store_const", const=True)
+    argp.add_argument(
+        "binaries",
+        metavar="BINARY",
+        nargs="+",
+        type=str,
+        help="files to read (ELF files or libtool objects)",
+    )
     args = argp.parse_args()
 
     if args.profile:
         import cProfile
-        cProfile.runctx('_main(args)', globals(), {'args': args}, sort='cumtime')
+
+        cProfile.runctx("_main(args)", globals(), {"args": args}, sort="cumtime")
     else:
         _main(args)
 
+
 def _main(args):
     errors = 0
     xrelfo = Xrelfo()
@@ -377,52 +481,59 @@ def _main(args):
             xrelfo.load_file(fn)
         except:
             errors += 1
-            sys.stderr.write('while processing %s:\n' % (fn))
+            sys.stderr.write("while processing %s:\n" % (fn))
             traceback.print_exc()
 
     for option in dir(args):
-        if option.startswith('W') and option != 'Werror':
+        if option.startswith("W") and option != "Werror":
             checks = sorted(xrelfo.check(args))
-            sys.stderr.write(''.join([c[-1] for c in checks]))
+            sys.stderr.write("".join([c[-1] for c in checks]))
 
             if args.Werror and len(checks) > 0:
                 errors += 1
             break
 
-
-    refs = xrelfo['refs']
+    refs = xrelfo["refs"]
 
     counts = {}
     for k, v in refs.items():
-        strs = set([i['fmtstring'] for i in v])
+        strs = set([i["fmtstring"] for i in v])
         if len(strs) != 1:
-            print('\033[31;1m%s\033[m' % k)
+            print("\033[31;1m%s\033[m" % k)
         counts[k] = len(v)
 
     out = xrelfo
     outbyfile = {}
     for uid, locs in refs.items():
         for loc in locs:
-            filearray = outbyfile.setdefault(loc['file'], [])
+            filearray = outbyfile.setdefault(loc["file"], [])
             loc = dict(loc)
-            del loc['file']
+            del loc["file"]
             filearray.append(loc)
 
     for k in outbyfile.keys():
-        outbyfile[k] = sorted(outbyfile[k], key=lambda x: x['line'])
+        outbyfile[k] = sorted(outbyfile[k], key=lambda x: x["line"])
 
     if errors:
         sys.exit(1)
 
     if args.output:
-        with open(args.output + '.tmp', 'w') as fd:
-            json.dump(out, fd, indent=2, sort_keys=True)
-        os.rename(args.output + '.tmp', args.output)
+        with open(args.output + ".tmp", "w") as fd:
+            json.dump(out, fd, indent=2, sort_keys=True, **json_dump_args)
+        os.rename(args.output + ".tmp", args.output)
 
     if args.out_by_file:
-        with open(args.out_by_file + '.tmp', 'w') as fd:
-            json.dump(outbyfile, fd, indent=2, sort_keys=True)
-        os.rename(args.out_by_file + '.tmp', args.out_by_file)
+        with open(args.out_by_file + ".tmp", "w") as fd:
+            json.dump(outbyfile, fd, indent=2, sort_keys=True, **json_dump_args)
+        os.rename(args.out_by_file + ".tmp", args.out_by_file)
+
+    if args.vtysh_cmds:
+        with open(args.vtysh_cmds + ".tmp", "w") as fd:
+            CommandEntry.run(out, fd)
+        os.rename(args.vtysh_cmds + ".tmp", args.vtysh_cmds)
+        if args.Werror and CommandEntry.warn_counter:
+            sys.exit(1)
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     main()
diff -urpN frr-frr-8.4.2/redhat/frr.pam frr-frr-8.5/redhat/frr.pam
--- frr-frr-8.4.2/redhat/frr.pam	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/redhat/frr.pam	2023-03-13 20:01:47.000000000 +0600
@@ -5,6 +5,7 @@
 # Only allow root (and possibly wheel) to use this because enable access
 # is unrestricted.
 auth       sufficient   pam_rootok.so
+account    sufficient   pam_rootok.so
 
 # Uncomment the following line to implicitly trust users in the "wheel" group.
 #auth       sufficient   pam_wheel.so trust use_uid
diff -urpN frr-frr-8.4.2/redhat/frr.spec.in frr-frr-8.5/redhat/frr.spec.in
--- frr-frr-8.4.2/redhat/frr.spec.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/redhat/frr.spec.in	2023-03-13 20:01:47.000000000 +0600
@@ -24,7 +24,7 @@
 %{!?with_pam:           %global  with_pam           0 }
 %{!?with_pbrd:          %global  with_pbrd          1 }
 %{!?with_pimd:          %global  with_pimd          1 }
-%{!?with_pim6d:         %global  with_pim6d         0 }
+%{!?with_pim6d:         %global  with_pim6d         1 }
 %{!?with_vrrpd:         %global  with_vrrpd         1 }
 %{!?with_rtadv:         %global  with_rtadv         1 }
 %{!?with_watchfrr:      %global  with_watchfrr      1 }
@@ -469,7 +469,7 @@ ln -s %{_sbindir}/frrinit.sh %{buildroot
 install %{zeb_src}/tools/etc/frr/daemons %{buildroot}%{_sysconfdir}/frr
 install %{zeb_src}/tools/etc/frr/frr.conf %{buildroot}%{_sysconfdir}/frr/frr.conf.template
 install -m644 %{zeb_rh_src}/frr.pam %{buildroot}%{_sysconfdir}/pam.d/frr
-install -m644 %{zeb_rh_src}/frr.logrotate %{buildroot}%{_sysconfdir}/logrotate.d/frr
+install -m644 %{zeb_src}/tools/etc/logrotate.d/frr %{buildroot}%{_sysconfdir}/logrotate.d/frr
 install -d -m750 %{buildroot}%{rundir}
 
 %if 0%{?rhel} > 7 || 0%{?fedora} > 29
@@ -793,43 +793,31 @@ sed -i 's/ -M rpki//' %{_sysconfdir}/frr
 
 %changelog
 
-* Mon Jan 09 2023 Martin Winter <mwinter@opensourcerouting.org> - %{version}
+* Fri Mar 10 2023 Martin Winter <mwinter@opensourcerouting.org> - %{version}
 
-* Mon Jan 09 2023 Jafar Al-Gharaibeh <jafar@atcorp.com> - 8.4.2
-- bfdd: fix ipv4 socket source selection
-- bgpd : fix crash for `set ipv4/ipv6 vpn next-hop` command
-- bgpd: stop overriding nexthop when bgp unnumbered
-- bgpd: fix aggregated routes are withdrawn abnormally
-- bgpd: fix a few memory leaks
-- build: enable pim6d by default
-- build: fix sed regex in lua macro
-- doc : add freebsd 13 build docs
-- isisd: fix memory leak
-- lib:  disable vrf before terminating interfaces
-- lib: do not log `echo ping` commands from watchfrr
-- ospf6d:  fix infinite loop when adding asbr route
-- ospfd: fix rfc conformance test cases 25.19 and 27.6
-- ospfd: fix typo and report the P2P link name in the warning
-- ospfd: report the router IP with opaque capability mismatch
-- ospfd: fix memory leak
-- pimd: consistently ignore prefix list mask len
-- staticd: do not crash when modifying an existing static route with color
-- zebra: free all memory associated ctx->u.iptable.interface_name_list
-- zebra: fix tracepoint changes for lttng
-- zebra: free up route map name memory on vrf deletion event
-- zebra: use `mpls enable`, not `mpls` when generating a config
-- tools: Ignore agentx command for frr-reload.py
-
-* Thu Nov 17 2022 Jafar Al-Gharaibeh <jafar@atcorp.com> - 8.4.1
-- zebra: reuse netinet/if_ether.h to avoid redefinition of struct ethhdr
-- zebra: fix build without AF_MPLS
-- ospfd: get route-map name for default-information originate
-- ospfd: allow unnumbered and numbered addresses to co-exist better
-- ospfd: prevent from crashing when processing external lsa
-- bgpd: fix "storing the address of local variable"
-- bgpd: rpki was decrementing the node lock one time too many
-- bgpd: do not send Deconfig/Shutdown message when restarting
-- pimd: convert zlog_warn to debug
+* Fri Mar 10 2023 Jafar Al-Gharaibeh <jafar@atcorp.com> - 8.5
+- Major Highlights:
+-   Add support for per-VRF SRv6 SID
+-   Add BGP labeled-unicast Add-Path functionality
+-   Implementation of SNMP BGP4v2-MIB (IPv6 support) for better network management and monitoring
+-   Add BGP new command neighbor path-attribute discard
+-   Add BGP new command neighbor path-attribute treat-as-withdraw
+-   Implement L3 route-target auto/wildcard configuration
+-   Implement BGP ACCEPT_OWN Community Attribute (rfc7611)
+-   Implement The Accumulated IGP Metric Attribute for BGP (rfc7311)
+-   Implement graceful-shutdown command per neighbor
+-   Add BGP new command to configure TCP keepalives for a peer bgp tcp-keepalive
+-   Traffic control (TC) ZAPI implementation
+-   SRv6 uSID (microSID) implementation
+-   Start deprecating start-shell, ssh, and telnet commands due to security reasons
+-   Add VRRPv3 an ability to disable IPv4 pseudo-header checksum
+-   BFD integration for static routes
+-   Allow protocols to configure BFD sessions with automatic source selection
+-   Allow zero-length opaque LSAs for OSPF (rfc5250)
+-   Add ISIS new command set-overload-bit on-startup
+-   PIMv6 BSM support
+- For a full list of new features and bug fixes, please refer to:
+-   https://frrouting.org/release/
 
 * Tue Nov 01 2022 Jafar Al-Gharaibeh <jafar@atcorp.com> - 8.4
 - New BGP command (neighbor PEER soo) to configure SoO to prevent routing loops and suboptimal routing on dual-homed sites.
diff -urpN frr-frr-8.4.2/ripd/rip_cli.c frr-frr-8.5/ripd/rip_cli.c
--- frr-frr-8.4.2/ripd/rip_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripd/rip_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,9 +30,7 @@
 
 #include "ripd/ripd.h"
 #include "ripd/rip_nb.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ripd/rip_cli_clippy.c"
-#endif
 
 /*
  * XPath: /frr-ripd:ripd/instance
diff -urpN frr-frr-8.4.2/ripd/rip_debug.c frr-frr-8.5/ripd/rip_debug.c
--- frr-frr-8.4.2/ripd/rip_debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripd/rip_debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -55,6 +55,8 @@ DEFUN_NOSH (show_debugging_rip,
 	if (IS_RIP_DEBUG_ZEBRA)
 		vty_out(vty, "  RIP zebra debugging is on\n");
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/ripd/subdir.am frr-frr-8.5/ripd/subdir.am
--- frr-frr-8.4.2/ripd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,11 +4,6 @@
 
 if RIPD
 sbin_PROGRAMS += ripd/ripd
-vtysh_scan += \
-	ripd/rip_cli.c \
-	ripd/rip_debug.c \
-	ripd/ripd.c \
-	# end
 vtysh_daemons += ripd
 
 if SNMP
diff -urpN frr-frr-8.4.2/ripngd/ripng_cli.c frr-frr-8.5/ripngd/ripng_cli.c
--- frr-frr-8.4.2/ripngd/ripng_cli.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripngd/ripng_cli.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,9 +30,7 @@
 
 #include "ripngd/ripngd.h"
 #include "ripngd/ripng_nb.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "ripngd/ripng_cli_clippy.c"
-#endif
 
 /*
  * XPath: /frr-ripngd:ripngd/instance
diff -urpN frr-frr-8.4.2/ripngd/ripng_debug.c frr-frr-8.5/ripngd/ripng_debug.c
--- frr-frr-8.4.2/ripngd/ripng_debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripngd/ripng_debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -56,6 +56,8 @@ DEFUN_NOSH (show_debugging_ripng,
 	if (IS_RIPNG_DEBUG_ZEBRA)
 		vty_out(vty, "  RIPng zebra debugging is on\n");
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
diff -urpN frr-frr-8.4.2/ripngd/subdir.am frr-frr-8.5/ripngd/subdir.am
--- frr-frr-8.4.2/ripngd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/ripngd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,11 +4,6 @@
 
 if RIPNGD
 sbin_PROGRAMS += ripngd/ripngd
-vtysh_scan += \
-	ripngd/ripng_cli.c \
-	ripngd/ripng_debug.c \
-	ripngd/ripngd.c \
-	# end
 vtysh_daemons += ripngd
 man8 += $(MANBUILD)/frr-ripngd.8
 endif
diff -urpN frr-frr-8.4.2/sharpd/sharp_nht.c frr-frr-8.5/sharpd/sharp_nht.c
--- frr-frr-8.4.2/sharpd/sharp_nht.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/sharpd/sharp_nht.c	2023-03-13 20:01:47.000000000 +0600
@@ -124,6 +124,24 @@ static void sharp_nhgroup_add_cb(const c
 	sharp_nhg_rb_add(&nhg_head, snhg);
 }
 
+static void sharp_nhgroup_modify_cb(const struct nexthop_group_cmd *nhgc)
+{
+	struct sharp_nhg lookup;
+	struct sharp_nhg *snhg;
+	struct nexthop_group_cmd *bnhgc = NULL;
+
+	strlcpy(lookup.name, nhgc->name, sizeof(lookup.name));
+	snhg = sharp_nhg_rb_find(&nhg_head, &lookup);
+
+	if (!nhgc->nhg.nexthop)
+		return;
+
+	if (nhgc->backup_list_name[0])
+		bnhgc = nhgc_find(nhgc->backup_list_name);
+
+	nhg_add(snhg->id, &nhgc->nhg, (bnhgc ? &bnhgc->nhg : NULL));
+}
+
 static void sharp_nhgroup_add_nexthop_cb(const struct nexthop_group_cmd *nhgc,
 					 const struct nexthop *nhop)
 {
@@ -215,7 +233,8 @@ void sharp_nhgroup_init(void)
 	sharp_nhg_rb_init(&nhg_head);
 	nhg_id = zclient_get_nhg_start(ZEBRA_ROUTE_SHARP);
 
-	nexthop_group_init(sharp_nhgroup_add_cb, sharp_nhgroup_add_nexthop_cb,
+	nexthop_group_init(sharp_nhgroup_add_cb, sharp_nhgroup_modify_cb,
+			   sharp_nhgroup_add_nexthop_cb,
 			   sharp_nhgroup_del_nexthop_cb,
 			   sharp_nhgroup_delete_cb);
 }
diff -urpN frr-frr-8.4.2/sharpd/sharp_vty.c frr-frr-8.5/sharpd/sharp_vty.c
--- frr-frr-8.4.2/sharpd/sharp_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/sharpd/sharp_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -32,14 +32,13 @@
 #include "linklist.h"
 #include "link_state.h"
 #include "cspf.h"
+#include "tc.h"
 
 #include "sharpd/sharp_globals.h"
 #include "sharpd/sharp_zebra.h"
 #include "sharpd/sharp_nht.h"
 #include "sharpd/sharp_vty.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "sharpd/sharp_vty_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(SHARPD, SRV6_LOCATOR, "SRv6 Locator");
 
@@ -432,7 +431,8 @@ DEFPY (install_seg6local_routes,
 	      End_T$seg6l_endt (1-4294967295)$seg6l_endt_table|\
 	      End_DX4$seg6l_enddx4 A.B.C.D$seg6l_enddx4_nh4|\
 	      End_DT6$seg6l_enddt6 (1-4294967295)$seg6l_enddt6_table|\
-	      End_DT4$seg6l_enddt4 (1-4294967295)$seg6l_enddt4_table>\
+	      End_DT4$seg6l_enddt4 (1-4294967295)$seg6l_enddt4_table|\
+	      End_DT46$seg6l_enddt46 (1-4294967295)$seg6l_enddt46_table>\
 	  (1-1000000)$routes [repeat (2-1000)$rpt]",
        "Sharp routing Protocol\n"
        "install some routes\n"
@@ -453,6 +453,8 @@ DEFPY (install_seg6local_routes,
        "Redirect table id to use\n"
        "SRv6 End.DT4 function to use\n"
        "Redirect table id to use\n"
+       "SRv6 End.DT46 function to use\n"
+       "Redirect table id to use\n"
        "How many to create\n"
        "Should we repeat this command\n"
        "How many times to repeat this command\n")
@@ -508,6 +510,9 @@ DEFPY (install_seg6local_routes,
 	} else if (seg6l_enddt4) {
 		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
 		ctx.table = seg6l_enddt4_table;
+	} else if (seg6l_enddt46) {
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+		ctx.table = seg6l_enddt46_table;
 	} else {
 		action = ZEBRA_SEG6_LOCAL_ACTION_END;
 	}
@@ -615,6 +620,8 @@ DEFUN_NOSH (show_debugging_sharpd,
 {
 	vty_out(vty, "Sharp debugging status:\n");
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -1333,6 +1340,64 @@ DEFPY (no_sharp_interface_protodown,
 	return CMD_SUCCESS;
 }
 
+DEFPY (tc_filter_rate,
+       tc_filter_rate_cmd,
+       "sharp tc dev IFNAME$ifname \
+        source <A.B.C.D/M|X:X::X:X/M>$src \
+        destination <A.B.C.D/M|X:X::X:X/M>$dst \
+        ip-protocol <tcp|udp>$ip_proto \
+        src-port (1-65535)$src_port \
+        dst-port (1-65535)$dst_port \
+        rate RATE$ratestr",
+       SHARP_STR
+       "Traffic control\n"
+       "TC interface (for qdisc, class, filter)\n"
+       "TC interface name\n"
+       "TC filter source\n"
+       "TC filter source IPv4 prefix\n"
+       "TC filter source IPv6 prefix\n"
+       "TC filter destination\n"
+       "TC filter destination IPv4 prefix\n"
+       "TC filter destination IPv6 prefix\n"
+       "TC filter IP protocol\n"
+       "TC filter IP protocol TCP\n"
+       "TC filter IP protocol UDP\n"
+       "TC filter source port\n"
+       "TC filter source port\n"
+       "TC filter destination port\n"
+       "TC filter destination port\n"
+       "TC rate\n"
+       "TC rate number (bits/s) or rate string (suffixed with Bps or bit)\n")
+{
+	struct interface *ifp;
+	struct protoent *p;
+	uint64_t rate;
+
+	ifp = if_lookup_vrf_all(ifname);
+
+	if (!ifp) {
+		vty_out(vty, "%% Can't find interface %s\n", ifname);
+		return CMD_WARNING;
+	}
+
+	p = getprotobyname(ip_proto);
+	if (!p) {
+		vty_out(vty, "Unable to convert %s to proto id\n", ip_proto);
+		return CMD_WARNING;
+	}
+
+	if (tc_getrate(ratestr, &rate) != 0) {
+		vty_out(vty, "Unable to convert %s to rate\n", ratestr);
+		return CMD_WARNING;
+	}
+
+	if (sharp_zebra_send_tc_filter_rate(ifp, src, dst, p->p_proto, src_port,
+					    dst_port, rate) != 0)
+		return CMD_WARNING;
+
+	return CMD_SUCCESS;
+}
+
 void sharp_vty_init(void)
 {
 	install_element(ENABLE_NODE, &install_routes_data_dump_cmd);
@@ -1368,5 +1433,7 @@ void sharp_vty_init(void)
 	install_element(ENABLE_NODE, &sharp_interface_protodown_cmd);
 	install_element(ENABLE_NODE, &no_sharp_interface_protodown_cmd);
 
+	install_element(ENABLE_NODE, &tc_filter_rate_cmd);
+
 	return;
 }
diff -urpN frr-frr-8.4.2/sharpd/sharp_zebra.c frr-frr-8.5/sharpd/sharp_zebra.c
--- frr-frr-8.4.2/sharpd/sharp_zebra.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/sharpd/sharp_zebra.c	2023-03-13 20:01:47.000000000 +0600
@@ -31,6 +31,7 @@
 #include "nexthop.h"
 #include "nexthop_group.h"
 #include "link_state.h"
+#include "tc.h"
 
 #include "sharp_globals.h"
 #include "sharp_nht.h"
@@ -302,8 +303,8 @@ static bool route_add(const struct prefi
 		memcpy(api.opaque.data, opaque, api.opaque.length);
 	}
 
-	if (zclient_route_send(ZEBRA_ROUTE_ADD, zclient, &api)
-	    == ZCLIENT_SEND_BUFFERED)
+	if (zclient_route_send(ZEBRA_ROUTE_ADD, zclient, &api) ==
+	    ZCLIENT_SEND_BUFFERED)
 		return true;
 	else
 		return false;
@@ -326,8 +327,8 @@ static bool route_delete(struct prefix *
 	api.instance = instance;
 	memcpy(&api.prefix, p, sizeof(*p));
 
-	if (zclient_route_send(ZEBRA_ROUTE_DELETE, zclient, &api)
-	    == ZCLIENT_SEND_BUFFERED)
+	if (zclient_route_send(ZEBRA_ROUTE_DELETE, zclient, &api) ==
+	    ZCLIENT_SEND_BUFFERED)
 		return true;
 	else
 		return false;
@@ -360,7 +361,7 @@ static void sharp_install_routes_restart
 
 		if (buffered) {
 			wb.p = *p;
-			wb.count = i+1;
+			wb.count = i + 1;
 			wb.routes = routes;
 			wb.vrf_id = vrf_id;
 			wb.instance = instance;
@@ -447,17 +448,16 @@ static void handle_repeated(bool install
 
 	if (installed) {
 		sg.r.removed_routes = 0;
-		sharp_remove_routes_helper(&p, sg.r.vrf_id,
-					   sg.r.inst, sg.r.total_routes);
+		sharp_remove_routes_helper(&p, sg.r.vrf_id, sg.r.inst,
+					   sg.r.total_routes);
 	}
 
 	if (!installed) {
 		sg.r.installed_routes = 0;
-		sharp_install_routes_helper(&p, sg.r.vrf_id, sg.r.inst,
-					    sg.r.nhgid, &sg.r.nhop_group,
-					    &sg.r.backup_nhop_group,
-					    sg.r.total_routes, sg.r.flags,
-					    sg.r.opaque);
+		sharp_install_routes_helper(
+			&p, sg.r.vrf_id, sg.r.inst, sg.r.nhgid,
+			&sg.r.nhop_group, &sg.r.backup_nhop_group,
+			sg.r.total_routes, sg.r.flags, sg.r.opaque);
 	}
 }
 
@@ -467,8 +467,7 @@ static void sharp_zclient_buffer_ready(v
 	case SHARP_INSTALL_ROUTES_RESTART:
 		sharp_install_routes_restart(
 			&wb.p, wb.count, wb.vrf_id, wb.instance, wb.nhgid,
-			wb.nhg, wb.backup_nhg, wb.routes, wb.flags,
-			wb.opaque);
+			wb.nhg, wb.backup_nhg, wb.routes, wb.flags, wb.opaque);
 		return;
 	case SHARP_DELETE_ROUTES_RESTART:
 		sharp_remove_routes_restart(&wb.p, wb.count, wb.vrf_id,
@@ -484,8 +483,8 @@ static int route_notify_owner(ZAPI_CALLB
 	enum zapi_route_notify_owner note;
 	uint32_t table;
 
-	if (!zapi_route_notify_decode(zclient->ibuf, &p, &table, &note,
-				      NULL, NULL))
+	if (!zapi_route_notify_decode(zclient->ibuf, &p, &table, &note, NULL,
+				      NULL))
 		return -1;
 
 	switch (note) {
@@ -550,6 +549,9 @@ void nhg_add(uint32_t id, const struct n
 	bool is_valid = true;
 
 	api_nhg.id = id;
+
+	api_nhg.resilience = nhg->nhgr;
+
 	for (ALL_NEXTHOPS_PTR(nhg, nh)) {
 		if (api_nhg.nexthop_num >= MULTIPATH_NUM) {
 			zlog_warn(
@@ -571,8 +573,8 @@ void nhg_add(uint32_t id, const struct n
 	}
 
 	if (api_nhg.nexthop_num == 0) {
-		zlog_debug("%s: nhg %u not sent: no valid nexthops",
-			   __func__, id);
+		zlog_debug("%s: nhg %u not sent: no valid nexthops", __func__,
+			   id);
 		is_valid = false;
 		goto done;
 	}
@@ -632,8 +634,7 @@ void sharp_zebra_nexthop_watch(struct pr
 		command = ZEBRA_NEXTHOP_UNREGISTER;
 
 	if (zclient_send_rnh(zclient, command, p, SAFI_UNICAST, connected,
-			     false, vrf_id)
-	    == ZCLIENT_SEND_FAILURE)
+			     false, vrf_id) == ZCLIENT_SEND_FAILURE)
 		zlog_warn("%s: Failure to send nexthop to zebra", __func__);
 }
 
@@ -642,8 +643,7 @@ static int sharp_debug_nexthops(struct z
 	int i;
 
 	if (api->nexthop_num == 0) {
-		zlog_debug(
-			"        Not installed");
+		zlog_debug("        Not installed");
 		return 0;
 	}
 
@@ -708,8 +708,8 @@ static int sharp_redistribute_route(ZAPI
 		zlog_warn("%s: Decode of redistribute failed: %d", __func__,
 			  ZEBRA_REDISTRIBUTE_ROUTE_ADD);
 
-	zlog_debug("%s: %pFX (%s)", zserv_command_string(cmd),
-		   &api.prefix, zebra_route_string(api.type));
+	zlog_debug("%s: %pFX (%s)", zserv_command_string(cmd), &api.prefix,
+		   zebra_route_string(api.type));
 
 	sharp_debug_nexthops(&api);
 
@@ -781,9 +781,9 @@ int sharp_zclient_delete(uint32_t sessio
 	return 0;
 }
 
-static const char *const type2txt[] = { "Generic", "Vertex", "Edge", "Subnet" };
-static const char *const status2txt[] = { "Unknown", "New", "Update",
-					  "Delete", "Sync", "Orphan"};
+static const char *const type2txt[] = {"Generic", "Vertex", "Edge", "Subnet"};
+static const char *const status2txt[] = {"Unknown", "New",  "Update",
+					 "Delete",  "Sync", "Orphan"};
 /* Handler for opaque messages */
 static int sharp_opaque_handler(ZAPI_CALLBACK_ARGS)
 {
@@ -806,8 +806,7 @@ static int sharp_opaque_handler(ZAPI_CAL
 				   status2txt[lse->status],
 				   type2txt[lse->type]);
 			lse->status = SYNC;
-		}
-		else
+		} else
 			zlog_debug(
 				"%s: Error to convert Stream into Link State",
 				__func__);
@@ -844,12 +843,11 @@ void sharp_opaque_send(uint32_t type, ui
 							  instance, session_id,
 							  buf, sizeof(buf));
 		if (ret == ZCLIENT_SEND_FAILURE) {
-			zlog_debug("%s: send_opaque() failed => %d",
-				   __func__, ret);
+			zlog_debug("%s: send_opaque() failed => %d", __func__,
+				   ret);
 			break;
 		}
 	}
-
 }
 
 /*
@@ -880,7 +878,6 @@ void sharp_opaque_reg_send(bool is_reg,
 	stream_putw_at(s, 0, stream_get_endp(s));
 
 	(void)zclient_send_message(zclient);
-
 }
 
 /* Link State registration */
@@ -982,6 +979,64 @@ int sharp_zebra_send_interface_protodown
 	return 0;
 }
 
+int sharp_zebra_send_tc_filter_rate(struct interface *ifp,
+				    const struct prefix *source,
+				    const struct prefix *destination,
+				    uint8_t ip_proto, uint16_t src_port,
+				    uint16_t dst_port, uint64_t rate)
+{
+#define SHARPD_TC_HANDLE 0x0001
+	struct stream *s;
+
+	s = zclient->obuf;
+
+	struct tc_qdisc q = {.ifindex = ifp->ifindex, .kind = TC_QDISC_HTB};
+
+	zapi_tc_qdisc_encode(ZEBRA_TC_QDISC_INSTALL, s, &q);
+	if (zclient_send_message(zclient) == ZCLIENT_SEND_FAILURE)
+		return -1;
+
+	struct tc_class c = {.ifindex = ifp->ifindex,
+			     .handle = SHARPD_TC_HANDLE & 0xffff,
+			     .kind = TC_QDISC_HTB,
+			     .u.htb.ceil = rate,
+			     .u.htb.rate = rate};
+
+	zapi_tc_class_encode(ZEBRA_TC_CLASS_ADD, s, &c);
+	if (zclient_send_message(zclient) == ZCLIENT_SEND_FAILURE)
+		return -1;
+
+	struct tc_filter f = {.ifindex = ifp->ifindex,
+			      .handle = SHARPD_TC_HANDLE,
+			      .priority = 0x1,
+			      .kind = TC_FILTER_FLOWER,
+			      .u.flower.filter_bm = 0};
+
+#ifdef ETH_P_IP
+	f.protocol = ETH_P_IP;
+#else
+	f.protocol = 0x0800;
+#endif
+
+	f.u.flower.filter_bm |= TC_FLOWER_IP_PROTOCOL;
+	f.u.flower.ip_proto = ip_proto;
+	f.u.flower.filter_bm |= TC_FLOWER_SRC_IP;
+	prefix_copy(&f.u.flower.src_ip, source);
+	f.u.flower.filter_bm |= TC_FLOWER_DST_IP;
+	prefix_copy(&f.u.flower.dst_ip, destination);
+	f.u.flower.filter_bm |= TC_FLOWER_SRC_PORT;
+	f.u.flower.src_port_min = f.u.flower.src_port_max = src_port;
+	f.u.flower.filter_bm |= TC_FLOWER_DST_PORT;
+	f.u.flower.dst_port_min = f.u.flower.dst_port_max = dst_port;
+	f.u.flower.classid = SHARPD_TC_HANDLE & 0xffff;
+
+	zapi_tc_filter_encode(ZEBRA_TC_FILTER_ADD, s, &f);
+	if (zclient_send_message(zclient) == ZCLIENT_SEND_FAILURE)
+		return -1;
+
+	return 0;
+}
+
 static zclient_handler *const sharp_handlers[] = {
 	[ZEBRA_INTERFACE_ADDRESS_ADD] = interface_address_add,
 	[ZEBRA_INTERFACE_ADDRESS_DELETE] = interface_address_delete,
@@ -999,8 +1054,8 @@ void sharp_zebra_init(void)
 {
 	struct zclient_options opt = {.receive_notify = true};
 
-	if_zapi_callbacks(sharp_ifp_create, sharp_ifp_up,
-			  sharp_ifp_down, sharp_ifp_destroy);
+	if_zapi_callbacks(sharp_ifp_create, sharp_ifp_up, sharp_ifp_down,
+			  sharp_ifp_destroy);
 
 	zclient = zclient_new(master, &opt, sharp_handlers,
 			      array_size(sharp_handlers));
diff -urpN frr-frr-8.4.2/sharpd/sharp_zebra.h frr-frr-8.5/sharpd/sharp_zebra.h
--- frr-frr-8.4.2/sharpd/sharp_zebra.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/sharpd/sharp_zebra.h	2023-03-13 20:01:47.000000000 +0600
@@ -75,4 +75,9 @@ extern void sharp_install_seg6local_rout
 
 extern int sharp_zebra_send_interface_protodown(struct interface *ifp,
 						bool down);
+extern int sharp_zebra_send_tc_filter_rate(struct interface *ifp,
+					   const struct prefix *source,
+					   const struct prefix *destination,
+					   uint8_t ip_proto, uint16_t src_port,
+					   uint16_t dst_port, uint64_t rate);
 #endif
diff -urpN frr-frr-8.4.2/sharpd/subdir.am frr-frr-8.5/sharpd/subdir.am
--- frr-frr-8.4.2/sharpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/sharpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,7 +5,6 @@
 if SHARPD
 noinst_LIBRARIES += sharpd/libsharp.a
 sbin_PROGRAMS += sharpd/sharpd
-vtysh_scan += sharpd/sharp_vty.c
 vtysh_daemons += sharpd
 man8 += $(MANBUILD)/frr-sharpd.8
 endif
diff -urpN frr-frr-8.4.2/snapcraft/snapcraft.yaml.in frr-frr-8.5/snapcraft/snapcraft.yaml.in
--- frr-frr-8.4.2/snapcraft/snapcraft.yaml.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/snapcraft/snapcraft.yaml.in	2023-03-13 20:01:47.000000000 +0600
@@ -285,7 +285,7 @@ parts:
            - zlib1g
         prime:
            - lib/librtr.so*
-           - usr/lib/x86_64-linux-gnu/libssh.so*
+           - usr/lib/$SNAPCRAFT_ARCH_TRIPLET/libssh.so*
         source: https://github.com/rtrlib/rtrlib.git
         source-type: git
         source-tag: v0.8.0
diff -urpN frr-frr-8.4.2/staticd/static_bfd.c frr-frr-8.5/staticd/static_bfd.c
--- frr-frr-8.4.2/staticd/static_bfd.c	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/staticd/static_bfd.c	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,390 @@
+/*
+ * Static daemon BFD integration.
+ *
+ * Copyright (C) 2020-2022 Network Device Education Foundation, Inc. ("NetDEF")
+ *                         Rafael Zalamena
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <zebra.h>
+
+#include "lib/bfd.h"
+#include "lib/printfrr.h"
+#include "lib/srcdest_table.h"
+
+#include "staticd/static_routes.h"
+#include "staticd/static_zebra.h"
+#include "staticd/static_debug.h"
+
+#include "lib/openbsd-queue.h"
+
+/*
+ * Next hop BFD monitoring settings.
+ */
+static void static_next_hop_bfd_change(struct static_nexthop *sn,
+				       const struct bfd_session_status *bss)
+{
+	switch (bss->state) {
+	case BSS_UNKNOWN:
+		/* FALLTHROUGH: no known state yet. */
+	case BSS_ADMIN_DOWN:
+		/* NOTHING: we or the remote end administratively shutdown. */
+		break;
+	case BSS_DOWN:
+		/* Peer went down, remove this next hop. */
+		DEBUGD(&static_dbg_bfd,
+		       "%s: next hop is down, remove it from RIB", __func__);
+		sn->path_down = true;
+		static_zebra_route_add(sn->pn, true);
+		break;
+	case BSS_UP:
+		/* Peer is back up, add this next hop. */
+		DEBUGD(&static_dbg_bfd, "%s: next hop is up, add it to RIB",
+		       __func__);
+		sn->path_down = false;
+		static_zebra_route_add(sn->pn, true);
+		break;
+	}
+}
+
+static void static_next_hop_bfd_updatecb(
+	__attribute__((unused)) struct bfd_session_params *bsp,
+	const struct bfd_session_status *bss, void *arg)
+{
+	static_next_hop_bfd_change(arg, bss);
+}
+
+static inline int
+static_next_hop_type_to_family(const struct static_nexthop *sn)
+{
+	switch (sn->type) {
+	case STATIC_IPV4_GATEWAY_IFNAME:
+	case STATIC_IPV6_GATEWAY_IFNAME:
+	case STATIC_IPV4_GATEWAY:
+	case STATIC_IPV6_GATEWAY:
+		if (sn->type == STATIC_IPV4_GATEWAY ||
+		    sn->type == STATIC_IPV4_GATEWAY_IFNAME)
+			return AF_INET;
+		else
+			return AF_INET6;
+		break;
+	case STATIC_IFNAME:
+	case STATIC_BLACKHOLE:
+	default:
+		zlog_err("%s: invalid next hop type", __func__);
+		break;
+	}
+
+	return AF_UNSPEC;
+}
+
+void static_next_hop_bfd_monitor_enable(struct static_nexthop *sn,
+					const struct lyd_node *dnode)
+{
+	bool use_interface;
+	bool use_profile;
+	bool use_source;
+	bool onlink;
+	bool mhop;
+	int family;
+	struct ipaddr source;
+
+	use_interface = false;
+	use_source = yang_dnode_exists(dnode, "./source");
+	use_profile = yang_dnode_exists(dnode, "./profile");
+	onlink = yang_dnode_exists(dnode, "../onlink") &&
+		 yang_dnode_get_bool(dnode, "../onlink");
+	mhop = yang_dnode_get_bool(dnode, "./multi-hop");
+
+
+	family = static_next_hop_type_to_family(sn);
+	if (family == AF_UNSPEC)
+		return;
+
+	if (sn->type == STATIC_IPV4_GATEWAY_IFNAME ||
+	    sn->type == STATIC_IPV6_GATEWAY_IFNAME)
+		use_interface = true;
+
+	/* Reconfigure or allocate new memory. */
+	if (sn->bsp == NULL)
+		sn->bsp = bfd_sess_new(static_next_hop_bfd_updatecb, sn);
+
+	/* Configure the session. */
+	if (use_source)
+		yang_dnode_get_ip(&source, dnode, "./source");
+
+	if (onlink || mhop == false)
+		bfd_sess_set_auto_source(sn->bsp, false);
+	else
+		bfd_sess_set_auto_source(sn->bsp, !use_source);
+
+	/* Configure the session.*/
+	if (family == AF_INET)
+		bfd_sess_set_ipv4_addrs(sn->bsp,
+					use_source ? &source.ip._v4_addr : NULL,
+					&sn->addr.ipv4);
+	else if (family == AF_INET6)
+		bfd_sess_set_ipv6_addrs(sn->bsp,
+					use_source ? &source.ip._v6_addr : NULL,
+					&sn->addr.ipv6);
+
+	bfd_sess_set_interface(sn->bsp, use_interface ? sn->ifname : NULL);
+
+	bfd_sess_set_profile(sn->bsp, use_profile ? yang_dnode_get_string(
+							    dnode, "./profile")
+						  : NULL);
+
+	bfd_sess_set_hop_count(sn->bsp, (onlink || mhop == false) ? 1 : 254);
+
+	/* Install or update the session. */
+	bfd_sess_install(sn->bsp);
+
+	/* Update current path status. */
+	sn->path_down = (bfd_sess_status(sn->bsp) != BSS_UP);
+}
+
+void static_next_hop_bfd_monitor_disable(struct static_nexthop *sn)
+{
+	bfd_sess_free(&sn->bsp);
+
+	/* Reset path status. */
+	sn->path_down = false;
+}
+
+void static_next_hop_bfd_source(struct static_nexthop *sn,
+				const struct ipaddr *source)
+{
+	int family;
+
+	if (sn->bsp == NULL)
+		return;
+
+	family = static_next_hop_type_to_family(sn);
+	if (family == AF_UNSPEC)
+		return;
+
+	bfd_sess_set_auto_source(sn->bsp, false);
+	if (family == AF_INET)
+		bfd_sess_set_ipv4_addrs(sn->bsp, &source->ip._v4_addr,
+					&sn->addr.ipv4);
+	else if (family == AF_INET6)
+		bfd_sess_set_ipv6_addrs(sn->bsp, &source->ip._v6_addr,
+					&sn->addr.ipv6);
+
+	bfd_sess_install(sn->bsp);
+}
+
+void static_next_hop_bfd_auto_source(struct static_nexthop *sn)
+{
+	if (sn->bsp == NULL)
+		return;
+
+	bfd_sess_set_auto_source(sn->bsp, true);
+	bfd_sess_install(sn->bsp);
+}
+
+void static_next_hop_bfd_multi_hop(struct static_nexthop *sn, bool mhop)
+{
+	if (sn->bsp == NULL)
+		return;
+
+	bfd_sess_set_hop_count(sn->bsp, mhop ? 254 : 1);
+	bfd_sess_install(sn->bsp);
+}
+
+void static_next_hop_bfd_profile(struct static_nexthop *sn, const char *name)
+{
+	if (sn->bsp == NULL)
+		return;
+
+	bfd_sess_set_profile(sn->bsp, name);
+	bfd_sess_install(sn->bsp);
+}
+
+void static_bfd_initialize(struct zclient *zc, struct thread_master *tm)
+{
+	/* Initialize BFD integration library. */
+	bfd_protocol_integration_init(zc, tm);
+}
+
+/*
+ * Display functions
+ */
+static void static_bfd_show_nexthop_json(struct vty *vty,
+					 struct json_object *jo,
+					 const struct static_nexthop *sn)
+{
+	const struct prefix *dst_p, *src_p;
+	struct json_object *jo_nh;
+
+	jo_nh = json_object_new_object();
+
+	srcdest_rnode_prefixes(sn->rn, &dst_p, &src_p);
+	if (src_p)
+		json_object_string_addf(jo_nh, "from", "%pFX", src_p);
+
+	json_object_string_addf(jo_nh, "prefix", "%pFX", dst_p);
+	json_object_string_add(jo_nh, "vrf", sn->nh_vrfname);
+
+	json_object_boolean_add(jo_nh, "installed", !sn->path_down);
+
+	json_object_array_add(jo, jo_nh);
+}
+
+static void static_bfd_show_path_json(struct vty *vty, struct json_object *jo,
+				      struct route_table *rt)
+{
+	struct route_node *rn;
+
+	for (rn = route_top(rt); rn; rn = srcdest_route_next(rn)) {
+		struct static_route_info *si = static_route_info_from_rnode(rn);
+		struct static_path *sp;
+
+		if (si == NULL)
+			continue;
+
+		frr_each (static_path_list, &si->path_list, sp) {
+			struct static_nexthop *sn;
+
+			frr_each (static_nexthop_list, &sp->nexthop_list, sn) {
+				/* Skip non configured BFD sessions. */
+				if (sn->bsp == NULL)
+					continue;
+
+				static_bfd_show_nexthop_json(vty, jo, sn);
+			}
+		}
+	}
+}
+
+static void static_bfd_show_json(struct vty *vty)
+{
+	struct json_object *jo, *jo_path, *jo_afi_safi;
+	struct vrf *vrf;
+
+	jo = json_object_new_object();
+	jo_path = json_object_new_object();
+
+	json_object_object_add(jo, "path-list", jo_path);
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		const struct static_vrf *svrf = vrf->info;
+		struct route_table *rt;
+
+		jo_afi_safi = json_object_new_array();
+		json_object_object_add(jo_path, "ipv4-unicast", jo_afi_safi);
+		rt = svrf->stable[AFI_IP][SAFI_UNICAST];
+		if (rt)
+			static_bfd_show_path_json(vty, jo_afi_safi, rt);
+
+		jo_afi_safi = json_object_new_array();
+		json_object_object_add(jo_path, "ipv4-multicast", jo_afi_safi);
+		rt = svrf->stable[AFI_IP][SAFI_MULTICAST];
+		if (rt)
+			static_bfd_show_path_json(vty, jo_afi_safi, rt);
+
+		jo_afi_safi = json_object_new_array();
+		json_object_object_add(jo_path, "ipv6-unicast", jo_afi_safi);
+		rt = svrf->stable[AFI_IP6][SAFI_UNICAST];
+		if (rt)
+			static_bfd_show_path_json(vty, jo_afi_safi, rt);
+	}
+
+	vty_out(vty, "%s\n", json_object_to_json_string_ext(jo, 0));
+	json_object_free(jo);
+}
+
+static void static_bfd_show_nexthop(struct vty *vty,
+				    const struct static_nexthop *sn)
+{
+	vty_out(vty, "        %pRN", sn->rn);
+
+	if (sn->bsp == NULL) {
+		vty_out(vty, "\n");
+		return;
+	}
+
+	if (sn->type == STATIC_IPV4_GATEWAY ||
+	    sn->type == STATIC_IPV4_GATEWAY_IFNAME)
+		vty_out(vty, " peer %pI4", &sn->addr.ipv4);
+	else if (sn->type == STATIC_IPV6_GATEWAY ||
+		 sn->type == STATIC_IPV6_GATEWAY_IFNAME)
+		vty_out(vty, " peer %pI6", &sn->addr.ipv6);
+	else
+		vty_out(vty, " peer unknown");
+
+	vty_out(vty, " (status: %s)\n",
+		sn->path_down ? "uninstalled" : "installed");
+}
+
+static void static_bfd_show_path(struct vty *vty, struct route_table *rt)
+{
+	struct route_node *rn;
+
+	for (rn = route_top(rt); rn; rn = srcdest_route_next(rn)) {
+		struct static_route_info *si = static_route_info_from_rnode(rn);
+		struct static_path *sp;
+
+		if (si == NULL)
+			continue;
+
+		frr_each (static_path_list, &si->path_list, sp) {
+			struct static_nexthop *sn;
+
+			frr_each (static_nexthop_list, &sp->nexthop_list, sn) {
+				/* Skip non configured BFD sessions. */
+				if (sn->bsp == NULL)
+					continue;
+
+				static_bfd_show_nexthop(vty, sn);
+			}
+		}
+	}
+}
+
+void static_bfd_show(struct vty *vty, bool json)
+{
+	struct vrf *vrf;
+
+	if (json) {
+		static_bfd_show_json(vty);
+		return;
+	}
+
+	vty_out(vty, "Showing BFD monitored static routes:\n");
+	vty_out(vty, "\n  Next hops:\n");
+	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+		const struct static_vrf *svrf = vrf->info;
+		struct route_table *rt;
+
+		vty_out(vty, "    VRF %s IPv4 Unicast:\n", vrf->name);
+		rt = svrf->stable[AFI_IP][SAFI_UNICAST];
+		if (rt)
+			static_bfd_show_path(vty, rt);
+
+		vty_out(vty, "\n    VRF %s IPv4 Multicast:\n", vrf->name);
+		rt = svrf->stable[AFI_IP][SAFI_MULTICAST];
+		if (rt)
+			static_bfd_show_path(vty, rt);
+
+		vty_out(vty, "\n    VRF %s IPv6 Unicast:\n", vrf->name);
+		rt = svrf->stable[AFI_IP6][SAFI_UNICAST];
+		if (rt)
+			static_bfd_show_path(vty, rt);
+	}
+
+	vty_out(vty, "\n");
+}
diff -urpN frr-frr-8.4.2/staticd/static_debug.c frr-frr-8.5/staticd/static_debug.c
--- frr-frr-8.4.2/staticd/static_debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -24,6 +24,7 @@
 
 #include "lib/command.h"
 #include "lib/debug.h"
+#include "lib/bfd.h"
 
 #include "static_debug.h"
 
@@ -35,15 +36,18 @@
 /* clang-format off */
 struct debug static_dbg_events = {0, "Staticd events"};
 struct debug static_dbg_route = {0, "Staticd route"};
+struct debug static_dbg_bfd = {0, "Staticd bfd"};
 
 struct debug *static_debug_arr[] =  {
 	&static_dbg_events,
-	&static_dbg_route
+	&static_dbg_route,
+	&static_dbg_bfd
 };
 
 const char *static_debugs_conflines[] = {
 	"debug static events",
-	"debug static route"
+	"debug static route",
+	"debug static bfd"
 };
 /* clang-format on */
 
@@ -105,7 +109,8 @@ int static_debug_status_write(struct vty
  *    Debug general internal events
  *
  */
-void static_debug_set(int vtynode, bool onoff, bool events, bool route)
+void static_debug_set(int vtynode, bool onoff, bool events, bool route,
+		      bool bfd)
 {
 	uint32_t mode = DEBUG_NODE2MODE(vtynode);
 
@@ -113,6 +118,10 @@ void static_debug_set(int vtynode, bool
 		DEBUG_MODE_SET(&static_dbg_events, mode, onoff);
 	if (route)
 		DEBUG_MODE_SET(&static_dbg_route, mode, onoff);
+	if (bfd) {
+		DEBUG_MODE_SET(&static_dbg_bfd, mode, onoff);
+		bfd_protocol_integration_set_debug(onoff);
+	}
 }
 
 /*
diff -urpN frr-frr-8.4.2/staticd/static_debug.h frr-frr-8.5/staticd/static_debug.h
--- frr-frr-8.4.2/staticd/static_debug.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_debug.h	2023-03-13 20:01:47.000000000 +0600
@@ -34,6 +34,7 @@ extern "C" {
 /* staticd debugging records */
 extern struct debug static_dbg_events;
 extern struct debug static_dbg_route;
+extern struct debug static_dbg_bfd;
 
 /*
  * Initialize staticd debugging.
@@ -71,7 +72,8 @@ int static_debug_status_write(struct vty
  *    Debug general internal events
  *
  */
-void static_debug_set(int vtynode, bool onoff, bool events, bool route);
+void static_debug_set(int vtynode, bool onoff, bool events, bool route,
+		      bool bfd);
 
 #ifdef __cplusplus
 }
diff -urpN frr-frr-8.4.2/staticd/static_nb.c frr-frr-8.5/staticd/static_nb.c
--- frr-frr-8.4.2/staticd/static_nb.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_nb.c	2023-03-13 20:01:47.000000000 +0600
@@ -117,6 +117,33 @@ const struct frr_yang_module_info frr_st
 			}
 		},
 		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring",
+			.cbs = {
+				.create = route_next_hop_bfd_create,
+				.destroy = route_next_hop_bfd_destroy,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/source",
+			.cbs = {
+				.modify = route_next_hop_bfd_source_modify,
+				.destroy = route_next_hop_bfd_source_destroy,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/multi-hop",
+			.cbs = {
+				.modify = route_next_hop_bfd_multi_hop_modify,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/profile",
+			.cbs = {
+				.modify = route_next_hop_bfd_profile_modify,
+				.destroy = route_next_hop_bfd_profile_destroy,
+			}
+		},
+		{
 			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/src-list",
 			.cbs = {
 				.create = routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_create,
diff -urpN frr-frr-8.4.2/staticd/static_nb.h frr-frr-8.5/staticd/static_nb.h
--- frr-frr-8.4.2/staticd/static_nb.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_nb.h	2023-03-13 20:01:47.000000000 +0600
@@ -63,6 +63,13 @@ int routing_control_plane_protocols_cont
 	struct nb_cb_modify_args *args);
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_path_list_frr_nexthops_nexthop_mpls_label_stack_entry_traffic_class_destroy(
 	struct nb_cb_destroy_args *args);
+int route_next_hop_bfd_create(struct nb_cb_create_args *args);
+int route_next_hop_bfd_destroy(struct nb_cb_destroy_args *args);
+int route_next_hop_bfd_source_modify(struct nb_cb_modify_args *args);
+int route_next_hop_bfd_source_destroy(struct nb_cb_destroy_args *args);
+int route_next_hop_bfd_profile_modify(struct nb_cb_modify_args *args);
+int route_next_hop_bfd_profile_destroy(struct nb_cb_destroy_args *args);
+int route_next_hop_bfd_multi_hop_modify(struct nb_cb_modify_args *args);
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_create(
 	struct nb_cb_create_args *args);
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_destroy(
diff -urpN frr-frr-8.4.2/staticd/static_nb_config.c frr-frr-8.5/staticd/static_nb_config.c
--- frr-frr-8.4.2/staticd/static_nb_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_nb_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -750,6 +750,113 @@ int routing_control_plane_protocols_cont
 
 /*
  * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring
+ */
+int route_next_hop_bfd_create(struct nb_cb_create_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_monitor_enable(sn, args->dnode);
+	return NB_OK;
+}
+
+int route_next_hop_bfd_destroy(struct nb_cb_destroy_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_monitor_disable(sn);
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/source
+ */
+int route_next_hop_bfd_source_modify(struct nb_cb_modify_args *args)
+{
+	struct static_nexthop *sn;
+	struct ipaddr source;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	yang_dnode_get_ip(&source, args->dnode, NULL);
+	static_next_hop_bfd_source(sn, &source);
+	return NB_OK;
+}
+
+int route_next_hop_bfd_source_destroy(struct nb_cb_destroy_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_auto_source(sn);
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/multi-hop
+ */
+int route_next_hop_bfd_multi_hop_modify(struct nb_cb_modify_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_multi_hop(sn,
+				      yang_dnode_get_bool(args->dnode, NULL));
+
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/path-list/frr-nexthops/nexthop/bfd-monitoring/profile
+ */
+int route_next_hop_bfd_profile_modify(struct nb_cb_modify_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_profile(sn,
+				    yang_dnode_get_string(args->dnode, NULL));
+
+	return NB_OK;
+}
+
+int route_next_hop_bfd_profile_destroy(struct nb_cb_destroy_args *args)
+{
+	struct static_nexthop *sn;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sn = nb_running_get_entry(args->dnode, NULL, true);
+	static_next_hop_bfd_profile(sn, NULL);
+
+	return NB_OK;
+}
+
+/*
+ * XPath:
  * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/route-list/src-list
  */
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_create(
diff -urpN frr-frr-8.4.2/staticd/static_routes.c frr-frr-8.5/staticd/static_routes.c
--- frr-frr-8.4.2/staticd/static_routes.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_routes.c	2023-03-13 20:01:47.000000000 +0600
@@ -276,6 +276,8 @@ struct static_nexthop *static_add_nextho
 	/* Make new static route structure. */
 	nh = XCALLOC(MTYPE_STATIC_NEXTHOP, sizeof(struct static_nexthop));
 
+	/* Copy back pointers. */
+	nh->rn = rn;
 	nh->pn = pn;
 
 	nh->type = type;
@@ -393,6 +395,8 @@ void static_delete_nexthop(struct static
 	struct route_node *rn = pn->rn;
 
 	static_nexthop_list_del(&(pn->nexthop_list), nh);
+	/* Remove BFD session/configuration if any. */
+	bfd_sess_free(&nh->bsp);
 
 	if (nh->nh_vrf_id == VRF_UNKNOWN)
 		goto EXIT;
@@ -432,6 +436,8 @@ static void static_ifindex_update_nh(str
 		nh->ifindex = IFINDEX_INTERNAL;
 	}
 
+	/* Remove previously configured route if any. */
+	static_uninstall_path(pn);
 	static_install_path(pn);
 }
 
diff -urpN frr-frr-8.4.2/staticd/static_routes.h frr-frr-8.5/staticd/static_routes.h
--- frr-frr-8.4.2/staticd/static_routes.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_routes.h	2023-03-13 20:01:47.000000000 +0600
@@ -20,6 +20,7 @@
 #ifndef __STATIC_ROUTES_H__
 #define __STATIC_ROUTES_H__
 
+#include "lib/bfd.h"
 #include "lib/mpls.h"
 #include "table.h"
 #include "memory.h"
@@ -30,6 +31,8 @@ extern "C" {
 
 DECLARE_MGROUP(STATIC);
 
+#include "staticd/static_vrf.h"
+
 /* Static route label information */
 struct static_nh_label {
 	uint8_t num_labels;
@@ -148,6 +151,13 @@ struct static_nexthop {
 
 	/* SR-TE color */
 	uint32_t color;
+
+	/** BFD integration data. */
+	struct bfd_session_params *bsp;
+	/** Back pointer for route node. */
+	struct route_node *rn;
+	/** Path connection status. */
+	bool path_down;
 };
 
 DECLARE_DLIST(static_nexthop_list, struct static_nexthop, list);
@@ -218,6 +228,24 @@ extern void zebra_stable_node_cleanup(st
 extern void static_get_nh_str(struct static_nexthop *nh, char *nexthop,
 			      size_t size);
 
+/*
+ * BFD integration.
+ */
+extern void static_next_hop_bfd_source(struct static_nexthop *sn,
+				       const struct ipaddr *source);
+extern void static_next_hop_bfd_auto_source(struct static_nexthop *sn);
+extern void static_next_hop_bfd_monitor_enable(struct static_nexthop *sn,
+					       const struct lyd_node *dnode);
+extern void static_next_hop_bfd_monitor_disable(struct static_nexthop *sn);
+extern void static_next_hop_bfd_profile(struct static_nexthop *sn,
+					const char *name);
+extern void static_next_hop_bfd_multi_hop(struct static_nexthop *sn, bool mhop);
+
+/** Call this function after zebra client initialization. */
+extern void static_bfd_initialize(struct zclient *zc, struct thread_master *tm);
+
+extern void static_bfd_show(struct vty *vty, bool isjson);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/staticd/static_vty.c frr-frr-8.5/staticd/static_vty.c
--- frr-frr-8.4.2/staticd/static_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -36,22 +36,43 @@
 #include "static_vty.h"
 #include "static_routes.h"
 #include "static_debug.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "staticd/static_vty_clippy.c"
-#endif
 #include "static_nb.h"
 
 #define STATICD_STR "Static route daemon\n"
 
-static int static_route_leak(struct vty *vty, const char *svrf,
-			     const char *nh_svrf, afi_t afi, safi_t safi,
-			     const char *negate, const char *dest_str,
-			     const char *mask_str, const char *src_str,
-			     const char *gate_str, const char *ifname,
-			     const char *flag_str, const char *tag_str,
-			     const char *distance_str, const char *label_str,
-			     const char *table_str, bool onlink,
-			     const char *color_str)
+/** All possible route parameters available in CLI. */
+struct static_route_args {
+	/** "no" command? */
+	bool delete;
+	/** Is VRF obtained from XPath? */
+	bool xpath_vrf;
+
+	bool onlink;
+	afi_t afi;
+	safi_t safi;
+
+	const char *vrf;
+	const char *nexthop_vrf;
+	const char *prefix;
+	const char *prefix_mask;
+	const char *source;
+	const char *gateway;
+	const char *interface_name;
+	const char *flag;
+	const char *tag;
+	const char *distance;
+	const char *label;
+	const char *table;
+	const char *color;
+
+	bool bfd;
+	bool bfd_multi_hop;
+	const char *bfd_source;
+	const char *bfd_profile;
+};
+
+static int static_route_nb_run(struct vty *vty, struct static_route_args *args)
 {
 	int ret;
 	struct prefix p, src;
@@ -64,8 +85,8 @@ static int static_route_leak(struct vty
 	char xpath_label[XPATH_MAXLEN];
 	char ab_xpath[XPATH_MAXLEN];
 	char buf_prefix[PREFIX_STRLEN];
-	char buf_src_prefix[PREFIX_STRLEN];
-	char buf_nh_type[PREFIX_STRLEN];
+	char buf_src_prefix[PREFIX_STRLEN] = {};
+	char buf_nh_type[PREFIX_STRLEN] = {};
 	char buf_tag[PREFIX_STRLEN];
 	uint8_t label_stack_id = 0;
 	const char *buf_gate_str;
@@ -73,37 +94,46 @@ static int static_route_leak(struct vty
 	route_tag_t tag = 0;
 	uint32_t table_id = 0;
 	const struct lyd_node *dnode;
+	const struct lyd_node *vrf_dnode;
 
-	memset(buf_src_prefix, 0, PREFIX_STRLEN);
-	memset(buf_nh_type, 0, PREFIX_STRLEN);
+	if (args->xpath_vrf) {
+		vrf_dnode = yang_dnode_get(vty->candidate_config->dnode,
+					   VTY_CURR_XPATH);
+		if (vrf_dnode == NULL) {
+			vty_out(vty,
+				"%% Failed to get vrf dnode in candidate db\n");
+			return CMD_WARNING_CONFIG_FAILED;
+		}
 
-	ret = str2prefix(dest_str, &p);
-	if (ret <= 0) {
-		vty_out(vty, "%% Malformed address\n");
-		return CMD_WARNING_CONFIG_FAILED;
+		args->vrf = yang_dnode_get_string(vrf_dnode, "./name");
+	} else {
+		if (args->vrf == NULL)
+			args->vrf = VRF_DEFAULT_NAME;
 	}
+	if (args->nexthop_vrf == NULL)
+		args->nexthop_vrf = args->vrf;
 
-	switch (afi) {
+	if (args->interface_name &&
+	    !strcasecmp(args->interface_name, "Null0")) {
+		args->flag = "Null0";
+		args->interface_name = NULL;
+	}
+
+	assert(!!str2prefix(args->prefix, &p));
+
+	switch (args->afi) {
 	case AFI_IP:
 		/* Cisco like mask notation. */
-		if (mask_str) {
-			ret = inet_aton(mask_str, &mask);
-			if (ret == 0) {
-				vty_out(vty, "%% Malformed address\n");
-				return CMD_WARNING_CONFIG_FAILED;
-			}
+		if (args->prefix_mask) {
+			assert(inet_pton(AF_INET, args->prefix_mask, &mask) ==
+			       1);
 			p.prefixlen = ip_masklen(mask);
 		}
 		break;
 	case AFI_IP6:
 		/* srcdest routing */
-		if (src_str) {
-			ret = str2prefix(src_str, &src);
-			if (ret <= 0 || src.family != AF_INET6) {
-				vty_out(vty, "%% Malformed source address\n");
-				return CMD_WARNING_CONFIG_FAILED;
-			}
-		}
+		if (args->source)
+			assert(!!str2prefix(args->source, &src));
 		break;
 	default:
 		break;
@@ -111,62 +141,69 @@ static int static_route_leak(struct vty
 
 	/* Apply mask for given prefix. */
 	apply_mask(&p);
-
 	prefix2str(&p, buf_prefix, sizeof(buf_prefix));
 
-	if (src_str)
+	if (args->bfd && args->gateway == NULL) {
+		vty_out(vty, "%% Route monitoring requires a gateway\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	if (args->source)
 		prefix2str(&src, buf_src_prefix, sizeof(buf_src_prefix));
-	if (gate_str)
-		buf_gate_str = gate_str;
+	if (args->gateway)
+		buf_gate_str = args->gateway;
 	else
 		buf_gate_str = "";
 
-	if (gate_str == NULL && ifname == NULL)
+	if (args->gateway == NULL && args->interface_name == NULL)
 		type = STATIC_BLACKHOLE;
-	else if (gate_str && ifname) {
-		if (afi == AFI_IP)
+	else if (args->gateway && args->interface_name) {
+		if (args->afi == AFI_IP)
 			type = STATIC_IPV4_GATEWAY_IFNAME;
 		else
 			type = STATIC_IPV6_GATEWAY_IFNAME;
-	} else if (ifname)
+	} else if (args->interface_name)
 		type = STATIC_IFNAME;
 	else {
-		if (afi == AFI_IP)
+		if (args->afi == AFI_IP)
 			type = STATIC_IPV4_GATEWAY;
 		else
 			type = STATIC_IPV6_GATEWAY;
 	}
 
 	/* Administrative distance. */
-	if (distance_str)
-		distance = atoi(distance_str);
+	if (args->distance)
+		distance = strtol(args->distance, NULL, 10);
 
 	/* tag */
-	if (tag_str)
-		tag = strtoul(tag_str, NULL, 10);
+	if (args->tag)
+		tag = strtoul(args->tag, NULL, 10);
 
 	/* TableID */
-	if (table_str)
-		table_id = atol(table_str);
+	if (args->table)
+		table_id = strtol(args->table, NULL, 10);
 
-	static_get_nh_type(type, buf_nh_type, PREFIX_STRLEN);
-	if (!negate) {
-		if (src_str)
+	static_get_nh_type(type, buf_nh_type, sizeof(buf_nh_type));
+	if (!args->delete) {
+		if (args->source)
 			snprintf(ab_xpath, sizeof(ab_xpath),
 				 FRR_DEL_S_ROUTE_SRC_NH_KEY_NO_DISTANCE_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
-				 buf_src_prefix, table_id, buf_nh_type, nh_svrf,
-				 buf_gate_str, ifname);
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
+				 buf_src_prefix, table_id, buf_nh_type,
+				 args->nexthop_vrf, buf_gate_str,
+				 args->interface_name);
 		else
 			snprintf(ab_xpath, sizeof(ab_xpath),
 				 FRR_DEL_S_ROUTE_NH_KEY_NO_DISTANCE_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
-				 table_id, buf_nh_type, nh_svrf, buf_gate_str,
-				 ifname);
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
+				 table_id, buf_nh_type, args->nexthop_vrf,
+				 buf_gate_str, args->interface_name);
 
 		/*
 		 * If there's already the same nexthop but with a different
@@ -183,19 +220,21 @@ static int static_route_leak(struct vty
 		}
 
 		/* route + path procesing */
-		if (src_str)
+		if (args->source)
 			snprintf(xpath_prefix, sizeof(xpath_prefix),
 				 FRR_S_ROUTE_SRC_INFO_KEY_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
 				 buf_src_prefix, table_id, distance);
 		else
 			snprintf(xpath_prefix, sizeof(xpath_prefix),
 				 FRR_STATIC_ROUTE_INFO_KEY_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
 				 table_id, distance);
 
 		nb_cli_enqueue_change(vty, xpath_prefix, NB_OP_CREATE, NULL);
@@ -210,8 +249,8 @@ static int static_route_leak(struct vty
 		/* nexthop processing */
 
 		snprintf(ab_xpath, sizeof(ab_xpath),
-			 FRR_STATIC_ROUTE_NH_KEY_XPATH, buf_nh_type, nh_svrf,
-			 buf_gate_str, ifname);
+			 FRR_STATIC_ROUTE_NH_KEY_XPATH, buf_nh_type,
+			 args->nexthop_vrf, buf_gate_str, args->interface_name);
 		strlcpy(xpath_nexthop, xpath_prefix, sizeof(xpath_nexthop));
 		strlcat(xpath_nexthop, ab_xpath, sizeof(xpath_nexthop));
 		nb_cli_enqueue_change(vty, xpath_nexthop, NB_OP_CREATE, NULL);
@@ -222,8 +261,8 @@ static int static_route_leak(struct vty
 				sizeof(ab_xpath));
 
 			/* Route flags */
-			if (flag_str) {
-				switch (flag_str[0]) {
+			if (args->flag) {
+				switch (args->flag[0]) {
 				case 'r':
 					bh_type = "reject";
 					break;
@@ -250,7 +289,7 @@ static int static_route_leak(struct vty
 			strlcat(ab_xpath, FRR_STATIC_ROUTE_NH_ONLINK_XPATH,
 				sizeof(ab_xpath));
 
-			if (onlink)
+			if (args->onlink)
 				nb_cli_enqueue_change(vty, ab_xpath,
 						      NB_OP_MODIFY, "true");
 			else
@@ -264,11 +303,12 @@ static int static_route_leak(struct vty
 			strlcpy(ab_xpath, xpath_nexthop, sizeof(ab_xpath));
 			strlcat(ab_xpath, FRR_STATIC_ROUTE_NH_COLOR_XPATH,
 				sizeof(ab_xpath));
-			if (color_str)
+			if (args->color)
 				nb_cli_enqueue_change(vty, ab_xpath,
-						      NB_OP_MODIFY, color_str);
+						      NB_OP_MODIFY,
+						      args->color);
 		}
-		if (label_str) {
+		if (args->label) {
 			/* copy of label string (start) */
 			char *ostr;
 			/* pointer to next segment */
@@ -281,7 +321,7 @@ static int static_route_leak(struct vty
 			nb_cli_enqueue_change(vty, xpath_mpls, NB_OP_DESTROY,
 					      NULL);
 
-			ostr = XSTRDUP(MTYPE_TMP, label_str);
+			ostr = XSTRDUP(MTYPE_TMP, args->label);
 			while ((nump = strsep(&ostr, "/")) != NULL) {
 				snprintf(ab_xpath, sizeof(ab_xpath),
 					 FRR_STATIC_ROUTE_NHLB_KEY_XPATH,
@@ -302,24 +342,62 @@ static int static_route_leak(struct vty
 			nb_cli_enqueue_change(vty, xpath_mpls, NB_OP_DESTROY,
 					      NULL);
 		}
-		ret = nb_cli_apply_changes(vty, xpath_prefix);
+
+		if (args->bfd) {
+			char xpath_bfd[XPATH_MAXLEN];
+
+			if (args->bfd_source) {
+				strlcpy(xpath_bfd, xpath_nexthop,
+					sizeof(xpath_bfd));
+				strlcat(xpath_bfd,
+					"/frr-staticd:bfd-monitoring/source",
+					sizeof(xpath_bfd));
+				nb_cli_enqueue_change(vty, xpath_bfd,
+						      NB_OP_MODIFY,
+						      args->bfd_source);
+			}
+
+			strlcpy(xpath_bfd, xpath_nexthop, sizeof(xpath_bfd));
+			strlcat(xpath_bfd,
+				"/frr-staticd:bfd-monitoring/multi-hop",
+				sizeof(xpath_bfd));
+			nb_cli_enqueue_change(vty, xpath_bfd, NB_OP_MODIFY,
+					      args->bfd_multi_hop ? "true"
+								  : "false");
+
+			if (args->bfd_profile) {
+				strlcpy(xpath_bfd, xpath_nexthop,
+					sizeof(xpath_bfd));
+				strlcat(xpath_bfd,
+					"/frr-staticd:bfd-monitoring/profile",
+					sizeof(xpath_bfd));
+				nb_cli_enqueue_change(vty, xpath_bfd,
+						      NB_OP_MODIFY,
+						      args->bfd_profile);
+			}
+		}
+
+		ret = nb_cli_apply_changes(vty, "%s", xpath_prefix);
 	} else {
-		if (src_str)
+		if (args->source)
 			snprintf(ab_xpath, sizeof(ab_xpath),
 				 FRR_DEL_S_ROUTE_SRC_NH_KEY_NO_DISTANCE_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
-				 buf_src_prefix, table_id, buf_nh_type, nh_svrf,
-				 buf_gate_str, ifname);
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
+				 buf_src_prefix, table_id, buf_nh_type,
+				 args->nexthop_vrf, buf_gate_str,
+				 args->interface_name);
 		else
 			snprintf(ab_xpath, sizeof(ab_xpath),
 				 FRR_DEL_S_ROUTE_NH_KEY_NO_DISTANCE_XPATH,
-				 "frr-staticd:staticd", "staticd", svrf,
+				 "frr-staticd:staticd", "staticd", args->vrf,
 				 buf_prefix,
-				 yang_afi_safi_value2identity(afi, safi),
-				 table_id, buf_nh_type, nh_svrf, buf_gate_str,
-				 ifname);
+				 yang_afi_safi_value2identity(args->afi,
+							      args->safi),
+				 table_id, buf_nh_type, args->nexthop_vrf,
+				 buf_gate_str, args->interface_name);
 
 		dnode = yang_dnode_get(vty->candidate_config->dnode, ab_xpath);
 		if (!dnode) {
@@ -333,43 +411,48 @@ static int static_route_leak(struct vty
 		yang_dnode_get_path(dnode, ab_xpath, XPATH_MAXLEN);
 
 		nb_cli_enqueue_change(vty, ab_xpath, NB_OP_DESTROY, NULL);
-		ret = nb_cli_apply_changes(vty, ab_xpath);
+		ret = nb_cli_apply_changes(vty, "%s", ab_xpath);
 	}
 
 	return ret;
 }
-static int static_route(struct vty *vty, afi_t afi, safi_t safi,
-			const char *negate, const char *dest_str,
-			const char *mask_str, const char *src_str,
-			const char *gate_str, const char *ifname,
-			const char *flag_str, const char *tag_str,
-			const char *distance_str, const char *vrf_name,
-			const char *label_str, const char *table_str)
-{
-	if (!vrf_name)
-		vrf_name = VRF_DEFAULT_NAME;
-
-	return static_route_leak(vty, vrf_name, vrf_name, afi, safi, negate,
-				 dest_str, mask_str, src_str, gate_str, ifname,
-				 flag_str, tag_str, distance_str, label_str,
-				 table_str, false, NULL);
-}
 
 /* Static unicast routes for multicast RPF lookup. */
 DEFPY_YANG (ip_mroute_dist,
        ip_mroute_dist_cmd,
-       "[no] ip mroute A.B.C.D/M$prefix <A.B.C.D$gate|INTERFACE$ifname> [(1-255)$distance]",
+       "[no] ip mroute A.B.C.D/M$prefix <A.B.C.D$gate|INTERFACE$ifname> [{"
+       "(1-255)$distance"
+       "|bfd$bfd [{multi-hop$bfd_multi_hop|source A.B.C.D$bfd_source|profile BFDPROF$bfd_profile}]"
+       "}]",
        NO_STR
        IP_STR
        "Configure static unicast route into MRIB for multicast RPF lookup\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
        "Nexthop address\n"
        "Nexthop interface name\n"
-       "Distance\n")
-{
-	return static_route(vty, AFI_IP, SAFI_MULTICAST, no, prefix_str,
-			    NULL, NULL, gate_str, ifname, NULL, NULL,
-			    distance_str, NULL, NULL, NULL);
+       "Distance\n"
+       BFD_INTEGRATION_STR
+       BFD_INTEGRATION_MULTI_HOP_STR
+       BFD_INTEGRATION_SOURCE_STR
+       BFD_INTEGRATION_SOURCEV4_STR
+       BFD_PROFILE_STR
+       BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_MULTICAST,
+		.prefix = prefix_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.distance = distance_str,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
+
+	return static_route_nb_run(vty, &args);
 }
 
 /* Static route configuration.  */
@@ -400,9 +483,21 @@ DEFPY_YANG(ip_route_blackhole,
       "Table to configure\n"
       "The table number to configure\n")
 {
-	return static_route(vty, AFI_IP, SAFI_UNICAST, no, prefix,
-			    mask_str, NULL, NULL, NULL, flag, tag_str,
-			    distance_str, vrf, label, table_str);
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.flag = flag,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.vrf = vrf,
+	};
+
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ip_route_blackhole_vrf,
@@ -430,26 +525,28 @@ DEFPY_YANG(ip_route_blackhole_vrf,
       "Table to configure\n"
       "The table number to configure\n")
 {
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.flag = flag,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.xpath_vrf = true,
+	};
 
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
 	/*
 	 * Coverity is complaining that prefix could
 	 * be dereferenced, but we know that prefix will
 	 * valid.  Add an assert to make it happy
 	 */
-	assert(prefix);
-	return static_route_leak(vty, vrfname, vrfname, AFI_IP, SAFI_UNICAST,
-				 no, prefix, mask_str, NULL, NULL, NULL, flag,
-				 tag_str, distance_str, label, table_str,
-				 false, NULL);
+	assert(args.prefix);
+
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ip_route_address_interface,
@@ -467,6 +564,7 @@ DEFPY_YANG(ip_route_address_interface,
 	  |nexthop-vrf NAME                            \
 	  |onlink$onlink                               \
 	  |color (1-4294967295)                        \
+	  |bfd$bfd [{multi-hop$bfd_multi_hop|source A.B.C.D$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR IP_STR
       "Establish static routes\n"
@@ -486,27 +584,37 @@ DEFPY_YANG(ip_route_address_interface,
       VRF_CMD_HELP_STR
       "Treat the nexthop as directly attached to the interface\n"
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.onlink = !!onlink,
+		.vrf = vrf,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	if (!vrf)
-		vrf = VRF_DEFAULT_NAME;
-
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrf;
-
-	return static_route_leak(vty, vrf, nh_vrf, AFI_IP, SAFI_UNICAST, no,
-				 prefix, mask_str, NULL, gate_str, ifname, flag,
-				 tag_str, distance_str, label, table_str,
-				 !!onlink, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ip_route_address_interface_vrf,
@@ -523,6 +631,7 @@ DEFPY_YANG(ip_route_address_interface_vr
 	  |nexthop-vrf NAME                            \
 	  |onlink$onlink                               \
 	  |color (1-4294967295)                        \
+	  |bfd$bfd [{multi-hop$bfd_multi_hop|source A.B.C.D$bfd_source|profile BFDPROF$bfd_profile}] \
 	  }]",
       NO_STR IP_STR
       "Establish static routes\n"
@@ -541,34 +650,37 @@ DEFPY_YANG(ip_route_address_interface_vr
       VRF_CMD_HELP_STR
       "Treat the nexthop as directly attached to the interface\n"
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.onlink = !!onlink,
+		.xpath_vrf = true,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrfname;
-
-	return static_route_leak(vty, vrfname, nh_vrf, AFI_IP, SAFI_UNICAST, no,
-				 prefix, mask_str, NULL, gate_str, ifname, flag,
-				 tag_str, distance_str, label, table_str,
-				 !!onlink, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ip_route,
@@ -584,6 +696,7 @@ DEFPY_YANG(ip_route,
 	  |table (1-4294967295)                        \
 	  |nexthop-vrf NAME                            \
 	  |color (1-4294967295)                        \
+	  |bfd$bfd [{multi-hop$bfd_multi_hop|source A.B.C.D$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR IP_STR
       "Establish static routes\n"
@@ -602,28 +715,36 @@ DEFPY_YANG(ip_route,
       "The table number to configure\n"
       VRF_CMD_HELP_STR
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.vrf = vrf,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-
-	if (!vrf)
-		vrf = VRF_DEFAULT_NAME;
-
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrf;
-
-	return static_route_leak(vty, vrf, nh_vrf, AFI_IP, SAFI_UNICAST, no,
-				 prefix, mask_str, NULL, gate_str, ifname, flag,
-				 tag_str, distance_str, label, table_str,
-				 false, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ip_route_vrf,
@@ -638,6 +759,7 @@ DEFPY_YANG(ip_route_vrf,
 	  |table (1-4294967295)                        \
 	  |nexthop-vrf NAME                            \
 	  |color (1-4294967295)                        \
+	  |bfd$bfd [{multi-hop$bfd_multi_hop|source A.B.C.D$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR IP_STR
       "Establish static routes\n"
@@ -655,35 +777,36 @@ DEFPY_YANG(ip_route_vrf,
       "The table number to configure\n"
       VRF_CMD_HELP_STR
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
-
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix,
+		.prefix_mask = mask_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.xpath_vrf = true,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrfname;
-
-	return static_route_leak(vty, vrfname, nh_vrf, AFI_IP, SAFI_UNICAST, no,
-				 prefix, mask_str, NULL, gate_str, ifname, flag,
-				 tag_str, distance_str, label, table_str,
-				 false, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route_blackhole,
@@ -713,9 +836,21 @@ DEFPY_YANG(ipv6_route_blackhole,
       "Table to configure\n"
       "The table number to configure\n")
 {
-	return static_route(vty, AFI_IP6, SAFI_UNICAST, no, prefix_str,
-			    NULL, from_str, NULL, NULL, flag, tag_str,
-			    distance_str, vrf, label, table_str);
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.flag = flag,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.vrf = vrf,
+	};
+
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route_blackhole_vrf,
@@ -743,28 +878,28 @@ DEFPY_YANG(ipv6_route_blackhole_vrf,
       "Table to configure\n"
       "The table number to configure\n")
 {
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
-
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.flag = flag,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.xpath_vrf = true,
+	};
 
 	/*
 	 * Coverity is complaining that prefix could
 	 * be dereferenced, but we know that prefix will
 	 * valid.  Add an assert to make it happy
 	 */
-	assert(prefix);
+	assert(args.prefix);
 
-	return static_route_leak(vty, vrfname, vrfname, AFI_IP6, SAFI_UNICAST,
-				 no, prefix_str, NULL, from_str, NULL, NULL,
-				 flag, tag_str, distance_str, label, table_str,
-				 false, NULL);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route_address_interface,
@@ -781,6 +916,7 @@ DEFPY_YANG(ipv6_route_address_interface,
             |nexthop-vrf NAME                              \
 	    |onlink$onlink                                 \
 	    |color (1-4294967295)                          \
+	    |bfd$bfd [{multi-hop$bfd_multi_hop|source X:X::X:X$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR
       IPV6_STR
@@ -801,28 +937,37 @@ DEFPY_YANG(ipv6_route_address_interface,
       VRF_CMD_HELP_STR
       "Treat the nexthop as directly attached to the interface\n"
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.onlink = !!onlink,
+		.vrf = vrf,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	if (!vrf)
-		vrf = VRF_DEFAULT_NAME;
-
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrf;
-
-	return static_route_leak(vty, vrf, nh_vrf, AFI_IP6, SAFI_UNICAST, no,
-				 prefix_str, NULL, from_str, gate_str, ifname,
-				 flag, tag_str, distance_str, label, table_str,
-				 !!onlink, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route_address_interface_vrf,
@@ -838,6 +983,7 @@ DEFPY_YANG(ipv6_route_address_interface_
             |nexthop-vrf NAME                              \
 	    |onlink$onlink                                 \
 	    |color (1-4294967295)                          \
+	    |bfd$bfd [{multi-hop$bfd_multi_hop|source X:X::X:X$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR
       IPV6_STR
@@ -857,34 +1003,37 @@ DEFPY_YANG(ipv6_route_address_interface_
       VRF_CMD_HELP_STR
       "Treat the nexthop as directly attached to the interface\n"
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.onlink = !!onlink,
+		.xpath_vrf = true,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
-
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrfname;
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	return static_route_leak(vty, vrfname, nh_vrf, AFI_IP6, SAFI_UNICAST,
-				 no, prefix_str, NULL, from_str, gate_str,
-				 ifname, flag, tag_str, distance_str, label,
-				 table_str, !!onlink, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route,
@@ -899,6 +1048,7 @@ DEFPY_YANG(ipv6_route,
 	    |table (1-4294967295)                          \
             |nexthop-vrf NAME                              \
             |color (1-4294967295)                          \
+	    |bfd$bfd [{multi-hop$bfd_multi_hop|source X:X::X:X$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR
       IPV6_STR
@@ -918,27 +1068,36 @@ DEFPY_YANG(ipv6_route,
       "The table number to configure\n"
       VRF_CMD_HELP_STR
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-
-	if (!vrf)
-		vrf = VRF_DEFAULT_NAME;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.vrf = vrf,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrf;
-
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	return static_route_leak(vty, vrf, nh_vrf, AFI_IP6, SAFI_UNICAST, no,
-				 prefix_str, NULL, from_str, gate_str, ifname,
-				 flag, tag_str, distance_str, label, table_str,
-				 false, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 DEFPY_YANG(ipv6_route_vrf,
@@ -952,6 +1111,7 @@ DEFPY_YANG(ipv6_route_vrf,
 	    |table (1-4294967295)                          \
             |nexthop-vrf NAME                              \
 	    |color (1-4294967295)                          \
+	    |bfd$bfd [{multi-hop$bfd_multi_hop|source X:X::X:X$bfd_source|profile BFDPROF$bfd_profile}] \
           }]",
       NO_STR
       IPV6_STR
@@ -970,34 +1130,36 @@ DEFPY_YANG(ipv6_route_vrf,
       "The table number to configure\n"
       VRF_CMD_HELP_STR
       "SR-TE color\n"
-      "The SR-TE color to configure\n")
-{
-	const char *nh_vrf;
-	const char *flag = NULL;
-	const struct lyd_node *vrf_dnode;
-	const char *vrfname;
-
-	vrf_dnode =
-		yang_dnode_get(vty->candidate_config->dnode, VTY_CURR_XPATH);
-	if (!vrf_dnode) {
-		vty_out(vty, "%% Failed to get vrf dnode in candidate db\n");
-		return CMD_WARNING_CONFIG_FAILED;
-	}
-	vrfname = yang_dnode_get_string(vrf_dnode, "./name");
-
-	if (nexthop_vrf)
-		nh_vrf = nexthop_vrf;
-	else
-		nh_vrf = vrfname;
+      "The SR-TE color to configure\n"
+      BFD_INTEGRATION_STR
+      BFD_INTEGRATION_MULTI_HOP_STR
+      BFD_INTEGRATION_SOURCE_STR
+      BFD_INTEGRATION_SOURCEV4_STR
+      BFD_PROFILE_STR
+      BFD_PROFILE_NAME_STR)
+{
+	struct static_route_args args = {
+		.delete = !!no,
+		.afi = AFI_IP6,
+		.safi = SAFI_UNICAST,
+		.prefix = prefix_str,
+		.source = from_str,
+		.gateway = gate_str,
+		.interface_name = ifname,
+		.tag = tag_str,
+		.distance = distance_str,
+		.label = label,
+		.table = table_str,
+		.color = color_str,
+		.xpath_vrf = true,
+		.nexthop_vrf = nexthop_vrf,
+		.bfd = !!bfd,
+		.bfd_multi_hop = !!bfd_multi_hop,
+		.bfd_source = bfd_source_str,
+		.bfd_profile = bfd_profile,
+	};
 
-	if (ifname && !strncasecmp(ifname, "Null0", 5)) {
-		flag = "Null0";
-		ifname = NULL;
-	}
-	return static_route_leak(vty, vrfname, nh_vrf, AFI_IP6, SAFI_UNICAST,
-				 no, prefix_str, NULL, from_str, gate_str,
-				 ifname, flag, tag_str, distance_str, label,
-				 table_str, false, color_str);
+	return static_route_nb_run(vty, &args);
 }
 
 void static_cli_show(struct vty *vty, const struct lyd_node *dnode,
@@ -1149,6 +1311,25 @@ static void nexthop_cli_show(struct vty
 		vty_out(vty, " color %s",
 			yang_dnode_get_string(nexthop, "./srte-color"));
 
+	if (yang_dnode_exists(nexthop, "./bfd-monitoring")) {
+		const struct lyd_node *bfd_dnode =
+			yang_dnode_get(nexthop, "./bfd-monitoring");
+
+		if (yang_dnode_get_bool(bfd_dnode, "./multi-hop")) {
+			vty_out(vty, " bfd multi-hop");
+
+			if (yang_dnode_exists(bfd_dnode, "./source"))
+				vty_out(vty, " source %s",
+					yang_dnode_get_string(bfd_dnode,
+							      "./source"));
+		} else
+			vty_out(vty, " bfd");
+
+		if (yang_dnode_exists(bfd_dnode, "./profile"))
+			vty_out(vty, " profile %s",
+				yang_dnode_get_string(bfd_dnode, "./profile"));
+	}
+
 	vty_out(vty, "\n");
 }
 
@@ -1276,20 +1457,33 @@ int static_path_list_cli_cmp(const struc
 }
 
 DEFPY_YANG(debug_staticd, debug_staticd_cmd,
-	   "[no] debug static [{events$events|route$route}]",
+	   "[no] debug static [{events$events|route$route|bfd$bfd}]",
 	   NO_STR DEBUG_STR STATICD_STR
 	   "Debug events\n"
-	   "Debug route\n")
+	   "Debug route\n"
+	   "Debug bfd\n")
 {
 	/* If no specific category, change all */
 	if (strmatch(argv[argc - 1]->text, "static"))
-		static_debug_set(vty->node, !no, true, true);
+		static_debug_set(vty->node, !no, true, true, true);
 	else
-		static_debug_set(vty->node, !no, !!events, !!route);
+		static_debug_set(vty->node, !no, !!events, !!route, !!bfd);
 
 	return CMD_SUCCESS;
 }
 
+DEFPY(staticd_show_bfd_routes, staticd_show_bfd_routes_cmd,
+      "show bfd static route [json]$isjson",
+      SHOW_STR
+      BFD_INTEGRATION_STR
+      STATICD_STR
+      ROUTE_STR
+      JSON_STR)
+{
+	static_bfd_show(vty, !!isjson);
+	return CMD_SUCCESS;
+}
+
 DEFUN_NOSH (show_debugging_static,
 	    show_debugging_static_cmd,
 	    "show debugging [static]",
@@ -1301,6 +1495,8 @@ DEFUN_NOSH (show_debugging_static,
 
 	static_debug_status_write(vty);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -1334,4 +1530,6 @@ void static_vty_init(void)
 	install_element(ENABLE_NODE, &show_debugging_static_cmd);
 	install_element(ENABLE_NODE, &debug_staticd_cmd);
 	install_element(CONFIG_NODE, &debug_staticd_cmd);
+
+	install_element(ENABLE_NODE, &staticd_show_bfd_routes_cmd);
 }
diff -urpN frr-frr-8.4.2/staticd/static_zebra.c frr-frr-8.5/staticd/static_zebra.c
--- frr-frr-8.4.2/staticd/static_zebra.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/static_zebra.c	2023-03-13 20:01:47.000000000 +0600
@@ -211,6 +211,9 @@ static int static_zebra_nexthop_update(Z
 		return 1;
 	}
 
+	if (zclient->bfd_integration)
+		bfd_nht_update(&matched, &nhr);
+
 	if (matched.family == AF_INET6)
 		afi = AFI_IP6;
 
@@ -313,6 +316,7 @@ static bool static_zebra_nht_get_prefix(
 	}
 
 	assertf(0, "BUG: someone forgot to add nexthop type %u", nh->type);
+	return false;
 }
 
 void static_zebra_nht_register(struct static_nexthop *nh, bool reg)
@@ -440,6 +444,9 @@ extern void static_zebra_route_add(struc
 		api_nh = &api.nexthops[nh_num];
 		if (nh->nh_vrf_id == VRF_UNKNOWN)
 			continue;
+		/* Skip next hop which peer is down. */
+		if (nh->path_down)
+			continue;
 
 		api_nh->vrf_id = nh->nh_vrf_id;
 		if (nh->onlink)
@@ -544,6 +551,7 @@ void static_zebra_init(void)
 	zclient->zebra_connected = zebra_connected;
 
 	static_nht_hash_init(static_nht_hash);
+	static_bfd_initialize(zclient, master);
 }
 
 /* static_zebra_stop used by tests/lib/test_grpc.cpp */
diff -urpN frr-frr-8.4.2/staticd/subdir.am frr-frr-8.5/staticd/subdir.am
--- frr-frr-8.4.2/staticd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/staticd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -5,12 +5,12 @@
 if STATICD
 noinst_LIBRARIES += staticd/libstatic.a
 sbin_PROGRAMS += staticd/staticd
-vtysh_scan += staticd/static_vty.c
 vtysh_daemons += staticd
 man8 += $(MANBUILD)/frr-staticd.8
 endif
 
 staticd_libstatic_a_SOURCES = \
+	staticd/static_bfd.c \
 	staticd/static_debug.c \
 	staticd/static_nht.c \
 	staticd/static_routes.c \
@@ -39,5 +39,6 @@ staticd_staticd_SOURCES = staticd/static
 staticd_staticd_LDADD = staticd/libstatic.a lib/libfrr.la $(LIBCAP)
 
 nodist_staticd_staticd_SOURCES = \
+	yang/frr-bfdd.yang.c \
 	yang/frr-staticd.yang.c \
 	# end
diff -urpN frr-frr-8.4.2/tests/bgpd/test_peer_attr.c frr-frr-8.5/tests/bgpd/test_peer_attr.c
--- frr-frr-8.4.2/tests/bgpd/test_peer_attr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/bgpd/test_peer_attr.c	2023-03-13 20:01:47.000000000 +0600
@@ -20,6 +20,7 @@
 
 #include "memory.h"
 #include "plist.h"
+#include "printfrr.h"
 #include "bgpd/bgpd.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_regex.h"
@@ -44,8 +45,9 @@
 		if ((T)->state != TEST_SUCCESS || (C))                         \
 			break;                                                 \
 		(T)->state = TEST_ASSERT_ERROR;                                \
-		(T)->error = str_printf("assertion failed: %s (%s:%d)", (#C),  \
-					__FILE__, __LINE__);                   \
+		(T)->error =                                                   \
+			asprintfrr(MTYPE_TMP, "assertion failed: %s (%s:%d)",  \
+				   (#C), __FILE__, __LINE__);                  \
 	} while (0)
 
 #define TEST_ASSERT_EQ(T, A, B)                                                \
@@ -53,9 +55,11 @@
 		if ((T)->state != TEST_SUCCESS || ((A) == (B)))                \
 			break;                                                 \
 		(T)->state = TEST_ASSERT_ERROR;                                \
-		(T)->error = str_printf(                                       \
-			"assertion failed: %s[%d] == [%d]%s (%s:%d)", (#A),    \
-			(A), (B), (#B), __FILE__, __LINE__);                   \
+		(T)->error = asprintfrr(                                       \
+			MTYPE_TMP,                                             \
+			"assertion failed: %s[%lld] == [%lld]%s (%s:%d)",      \
+			(#A), (long long)(A), (long long)(B), (#B), __FILE__,  \
+			__LINE__);                                             \
 	} while (0)
 
 #define TEST_HANDLER_MAX 5
@@ -172,9 +176,9 @@ struct test_peer_attr {
 
 	enum test_peer_attr_type type;
 	union {
-		uint32_t flag;
+		uint64_t flag;
 		struct {
-			uint32_t flag;
+			uint64_t flag;
 			size_t direct;
 		} filter;
 	} u;
@@ -212,44 +216,6 @@ static struct test_peer_family test_defa
 	{.afi = AFI_IP6, .safi = SAFI_MULTICAST},
 };
 
-static char *str_vprintf(const char *fmt, va_list ap)
-{
-	int ret;
-	int buf_size = 0;
-	char *buf = NULL;
-	va_list apc;
-
-	while (1) {
-		va_copy(apc, ap);
-		ret = vsnprintf(buf, buf_size, fmt, apc);
-		va_end(apc);
-
-		if (ret >= 0 && ret < buf_size)
-			break;
-
-		if (ret >= 0)
-			buf_size = ret + 1;
-		else
-			buf_size *= 2;
-
-		buf = XREALLOC(MTYPE_TMP, buf, buf_size);
-	}
-
-	return buf;
-}
-
-static char *str_printf(const char *fmt, ...)
-{
-	char *buf;
-	va_list ap;
-
-	va_start(ap, fmt);
-	buf = str_vprintf(fmt, ap);
-	va_end(ap);
-
-	return buf;
-}
-
 TEST_ATTR_HANDLER_DECL(advertisement_interval, v_routeadv, 10, 20);
 TEST_STR_ATTR_HANDLER_DECL(password, password, "FRR-Peer", "FRR-Group");
 TEST_ATTR_HANDLER_DECL(local_as, change_local_as, 1, 2);
@@ -674,6 +640,14 @@ static struct test_peer_attr test_peer_a
 		.u.flag = PEER_FLAG_WEIGHT,
 		.handlers[0] = TEST_HANDLER(weight),
 	},
+	{
+		.cmd = "accept-own",
+		.peer_cmd = "accept-own",
+		.group_cmd = "accept-own",
+		.families[0] = {.afi = AFI_IP, .safi = SAFI_MPLS_VPN},
+		.families[1] = {.afi = AFI_IP6, .safi = SAFI_MPLS_VPN},
+		.u.flag = PEER_FLAG_ACCEPT_OWN,
+	},
 	{NULL}
 };
 /* clang-format on */
@@ -685,21 +659,14 @@ static const char *str_from_afi(afi_t af
 		return "ipv4";
 	case AFI_IP6:
 		return "ipv6";
-	default:
-		return "<unknown AFI>";
+	case AFI_L2VPN:
+		return "l2vpn";
+	case AFI_MAX:
+	case AFI_UNSPEC:
+		return "bad-value";
 	}
-}
 
-static const char *str_from_safi(safi_t safi)
-{
-	switch (safi) {
-	case SAFI_UNICAST:
-		return "unicast";
-	case SAFI_MULTICAST:
-		return "multicast";
-	default:
-		return "<unknown SAFI>";
-	}
+	assert(!"Reached end of function we should never reach");
 }
 
 static const char *str_from_attr_type(enum test_peer_attr_type at)
@@ -724,6 +691,7 @@ static bool is_attr_type_global(enum tes
 	return at == PEER_AT_GLOBAL_FLAG || at == PEER_AT_GLOBAL_CUSTOM;
 }
 
+PRINTFRR(2, 3)
 static void test_log(struct test *test, const char *fmt, ...)
 {
 	va_list ap;
@@ -734,10 +702,11 @@ static void test_log(struct test *test,
 
 	/* Store formatted log message. */
 	va_start(ap, fmt);
-	listnode_add(test->log, str_vprintf(fmt, ap));
+	listnode_add(test->log, vasprintfrr(MTYPE_TMP, fmt, ap));
 	va_end(ap);
 }
 
+PRINTFRR(2, 3)
 static void test_execute(struct test *test, const char *fmt, ...)
 {
 	int ret;
@@ -751,12 +720,12 @@ static void test_execute(struct test *te
 
 	/* Format command string with variadic arguments. */
 	va_start(ap, fmt);
-	cmd = str_vprintf(fmt, ap);
+	cmd = vasprintfrr(MTYPE_TMP, fmt, ap);
 	va_end(ap);
 	if (!cmd) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error =
-			str_printf("could not format command string [%s]", fmt);
+		test->error = asprintfrr(
+			MTYPE_TMP, "could not format command string [%s]", fmt);
 		return;
 	}
 
@@ -764,7 +733,8 @@ static void test_execute(struct test *te
 	vline = cmd_make_strvec(cmd);
 	if (vline == NULL) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error = str_printf(
+		test->error = asprintfrr(
+			MTYPE_TMP,
 			"tokenizing command string [%s] returned empty result",
 			cmd);
 		XFREE(MTYPE_TMP, cmd);
@@ -776,7 +746,8 @@ static void test_execute(struct test *te
 	ret = cmd_execute_command(vline, test->vty, NULL, 0);
 	if (ret != CMD_SUCCESS) {
 		test->state = TEST_COMMAND_ERROR;
-		test->error = str_printf(
+		test->error = asprintfrr(
+			MTYPE_TMP,
 			"execution of command [%s] has failed with code [%d]",
 			cmd, ret);
 	}
@@ -786,6 +757,7 @@ static void test_execute(struct test *te
 	XFREE(MTYPE_TMP, cmd);
 }
 
+PRINTFRR(2, 0)
 static void test_config(struct test *test, const char *fmt, bool invert,
 			va_list ap)
 {
@@ -800,12 +772,12 @@ static void test_config(struct test *tes
 
 	/* Format matcher string with variadic arguments. */
 	va_copy(apc, ap);
-	matcher = str_vprintf(fmt, apc);
+	matcher = vasprintfrr(MTYPE_TMP, fmt, apc);
 	va_end(apc);
 	if (!matcher) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error =
-			str_printf("could not format matcher string [%s]", fmt);
+		test->error = asprintfrr(
+			MTYPE_TMP, "could not format matcher string [%s]", fmt);
 		return;
 	}
 
@@ -818,11 +790,13 @@ static void test_config(struct test *tes
 	matched = !!strstr(config, matcher);
 	if (!matched && !invert) {
 		test->state = TEST_CONFIG_ERROR;
-		test->error = str_printf("expected config [%s] to be present",
+		test->error = asprintfrr(MTYPE_TMP,
+					 "expected config [%s] to be present",
 					 matcher);
 	} else if (matched && invert) {
 		test->state = TEST_CONFIG_ERROR;
-		test->error = str_printf("expected config [%s] to be absent",
+		test->error = asprintfrr(MTYPE_TMP,
+					 "expected config [%s] to be absent",
 					 matcher);
 	}
 
@@ -831,6 +805,7 @@ static void test_config(struct test *tes
 	XFREE(MTYPE_TMP, config);
 }
 
+PRINTFRR(2, 3)
 static void test_config_present(struct test *test, const char *fmt, ...)
 {
 	va_list ap;
@@ -840,6 +815,7 @@ static void test_config_present(struct t
 	va_end(ap);
 }
 
+PRINTFRR(2, 3)
 static void test_config_absent(struct test *test, const char *fmt, ...)
 {
 	va_list ap;
@@ -886,8 +862,8 @@ static void test_initialize(struct test
 	test->bgp = bgp_get_default();
 	if (!test->bgp) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error =
-			str_printf("could not retrieve default bgp instance");
+		test->error = asprintfrr(
+			MTYPE_TMP, "could not retrieve default bgp instance");
 		return;
 	}
 
@@ -901,7 +877,8 @@ static void test_initialize(struct test
 	}
 	if (!test->peer) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error = str_printf(
+		test->error = asprintfrr(
+			MTYPE_TMP,
 			"could not retrieve instance of bgp peer [%s]",
 			cfg.peer_address);
 		return;
@@ -911,7 +888,8 @@ static void test_initialize(struct test
 	test->group = peer_group_lookup(test->bgp, cfg.peer_group);
 	if (!test->group) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error = str_printf(
+		test->error = asprintfrr(
+			MTYPE_TMP,
 			"could not retrieve instance of bgp peer-group [%s]",
 			cfg.peer_group);
 		return;
@@ -1081,7 +1059,8 @@ static void test_custom(struct test *tes
 		if (test->state != TEST_SUCCESS) {
 			test->state = TEST_CUSTOM_ERROR;
 			handler_error = test->error;
-			test->error = str_printf("custom handler failed: %s",
+			test->error = asprintfrr(MTYPE_TMP,
+						 "custom handler failed: %s",
 						 handler_error);
 			XFREE(MTYPE_TMP, handler_error);
 		}
@@ -1123,8 +1102,8 @@ static void test_process(struct test *te
 
 	default:
 		test->state = TEST_INTERNAL_ERROR;
-		test->error =
-			str_printf("invalid attribute type: %d", pa->type);
+		test->error = asprintfrr(
+			MTYPE_TMP, "invalid attribute type: %d", pa->type);
 		break;
 	}
 
@@ -1149,8 +1128,8 @@ static void test_peer_attr(struct test *
 	type = str_from_attr_type(pa->type);
 	if (!type) {
 		test->state = TEST_INTERNAL_ERROR;
-		test->error =
-			str_printf("invalid attribute type: %d", pa->type);
+		test->error = asprintfrr(
+			MTYPE_TMP, "invalid attribute type: %d", pa->type);
 		return;
 	}
 
@@ -1173,7 +1152,7 @@ static void test_peer_attr(struct test *
 		test_log(test, "prepare: switch address-family to [%s]",
 			 get_afi_safi_str(pa->afi, pa->safi, false));
 		test_execute(test, "address-family %s %s",
-			     str_from_afi(pa->afi), str_from_safi(pa->safi));
+			     str_from_afi(pa->afi), safi2str(pa->safi));
 		test_execute(test, "neighbor %s activate", g->name);
 		test_execute(test, "neighbor %s activate", p->host);
 	}
@@ -1240,7 +1219,7 @@ static void test_peer_attr(struct test *
 		test_log(test, "prepare: switch address-family to [%s]",
 			 get_afi_safi_str(pa->afi, pa->safi, false));
 		test_execute(test, "address-family %s %s",
-			     str_from_afi(pa->afi), str_from_safi(pa->safi));
+			     str_from_afi(pa->afi), safi2str(pa->safi));
 		test_execute(test, "neighbor %s activate", g->name);
 		test_execute(test, "neighbor %s activate", p->host);
 	}
@@ -1288,7 +1267,7 @@ static void test_peer_attr(struct test *
 		test_log(test, "prepare: switch address-family to [%s]",
 			 get_afi_safi_str(pa->afi, pa->safi, false));
 		test_execute(test, "address-family %s %s",
-			     str_from_afi(pa->afi), str_from_safi(pa->safi));
+			     str_from_afi(pa->afi), safi2str(pa->safi));
 		test_execute(test, "neighbor %s activate", g->name);
 		test_execute(test, "neighbor %s activate", p->host);
 	}
@@ -1485,11 +1464,11 @@ int main(void)
 
 		/* Build test description string. */
 		if (pa->afi && pa->safi)
-			desc = str_printf("peer\\%s-%s\\%s",
+			desc = asprintfrr(MTYPE_TMP, "peer\\%s-%s\\%s",
 					  str_from_afi(pa->afi),
-					  str_from_safi(pa->safi), pa->cmd);
+					  safi2str(pa->safi), pa->cmd);
 		else
-			desc = str_printf("peer\\%s", pa->cmd);
+			desc = asprintfrr(MTYPE_TMP, "peer\\%s", pa->cmd);
 
 		/* Initialize new test instance. */
 		test = test_new(desc, pa->o.use_ibgp, pa->o.use_iface_peer);
diff -urpN frr-frr-8.4.2/tests/bgpd/test_peer_attr.py frr-frr-8.5/tests/bgpd/test_peer_attr.py
--- frr-frr-8.4.2/tests/bgpd/test_peer_attr.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/bgpd/test_peer_attr.py	2023-03-13 20:01:47.000000000 +0600
@@ -196,3 +196,5 @@ TestFlag.okfail("peer\\ipv4-unicast\\wei
 TestFlag.okfail("peer\\ipv4-multicast\\weight")
 TestFlag.okfail("peer\\ipv6-unicast\\weight")
 TestFlag.okfail("peer\\ipv6-multicast\\weight")
+TestFlag.okfail("peer\\ipv4-vpn\\accept-own")
+TestFlag.okfail("peer\\ipv6-vpn\\accept-own")
diff -urpN frr-frr-8.4.2/tests/isisd/subdir.am frr-frr-8.5/tests/isisd/subdir.am
--- frr-frr-8.4.2/tests/isisd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/isisd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -21,7 +21,7 @@ EXTRA_DIST += \
 	# end
 
 tests/isisd/test_fuzz_isis_tlv_tests.h: $(top_srcdir)/tests/isisd/test_fuzz_isis_tlv_tests.h.gz
-	@mkdir -p tests/isisd
+	@$(MKDIR_P) tests/isisd
 	$(AM_V_GEN)gzip -d < $(top_srcdir)/tests/isisd/test_fuzz_isis_tlv_tests.h.gz > "$@"
 CLEANFILES += tests/isisd/test_fuzz_isis_tlv_tests.h
 
diff -urpN frr-frr-8.4.2/tests/isisd/test_isis_spf.refout frr-frr-8.5/tests/isisd/test_isis_spf.refout
--- frr-frr-8.4.2/tests/isisd/test_isis_spf.refout	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/isisd/test_isis_spf.refout	2023-03-13 20:01:47.000000000 +0600
@@ -823,7 +823,7 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)       
  ----------------------------------------------------------
- 10.0.255.2/32  40      -          rt2      implicit-null  
+ 10.0.255.2/32  50      -          rt2      implicit-null  
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -859,7 +859,7 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)       
  ------------------------------------------------------------
- 2001:db8::2/128  40      -          rt2      implicit-null  
+ 2001:db8::2/128  50      -          rt2      implicit-null  
 
 test# test isis topology 2 root rt4 lfa system-id rt6
 IS-IS paths to level-1 routers that speak IP
@@ -896,7 +896,7 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.6/32  20      -          rt5      16060     
+ 10.0.255.6/32  30      -          rt5      16060     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -932,7 +932,7 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)  
  -------------------------------------------------------
- 2001:db8::6/128  20      -          rt5      16061     
+ 2001:db8::6/128  30      -          rt5      16061     
 
 test# test isis topology 3 root rt1 lfa system-id rt2
 IS-IS paths to level-1 routers that speak IP
@@ -967,10 +967,10 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.2/32  20      -          rt3      16020     
- 10.0.255.4/32  30      -          rt3      16040     
- 10.0.255.5/32  40      -          rt3      16050     
- 10.0.255.6/32  40      -          rt3      16060     
+ 10.0.255.2/32  30      -          rt3      16020     
+ 10.0.255.4/32  40      -          rt3      16040     
+ 10.0.255.5/32  50      -          rt3      16050     
+ 10.0.255.6/32  50      -          rt3      16060     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1017,7 +1017,7 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.3/32  20      -          rt2      16030     
+ 10.0.255.3/32  30      -          rt2      16030     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1085,17 +1085,17 @@ IS-IS L1 IPv4 routing table:
 
  Prefix          Metric  Interface  Nexthop  Label(s)       
  -----------------------------------------------------------
- 10.0.255.2/32   40      -          rt2      implicit-null  
- 10.0.255.3/32   50      -          rt2      16030          
- 10.0.255.4/32   60      -          rt2      16040          
- 10.0.255.5/32   50      -          rt2      16050          
- 10.0.255.6/32   60      -          rt2      16060          
- 10.0.255.7/32   70      -          rt2      16070          
- 10.0.255.8/32   60      -          rt2      16080          
- 10.0.255.9/32   70      -          rt2      16090          
- 10.0.255.10/32  80      -          rt2      16100          
- 10.0.255.11/32  70      -          rt2      16110          
- 10.0.255.12/32  80      -          rt2      16120          
+ 10.0.255.2/32   50      -          rt2      implicit-null  
+ 10.0.255.3/32   60      -          rt2      16030          
+ 10.0.255.4/32   70      -          rt2      16040          
+ 10.0.255.5/32   60      -          rt2      16050          
+ 10.0.255.6/32   70      -          rt2      16060          
+ 10.0.255.7/32   80      -          rt2      16070          
+ 10.0.255.8/32   70      -          rt2      16080          
+ 10.0.255.9/32   80      -          rt2      16090          
+ 10.0.255.10/32  90      -          rt2      16100          
+ 10.0.255.11/32  80      -          rt2      16110          
+ 10.0.255.12/32  90      -          rt2      16120          
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1173,10 +1173,10 @@ IS-IS L1 IPv4 routing table:
 
  Prefix          Metric  Interface  Nexthop  Label(s)  
  ------------------------------------------------------
- 10.0.255.8/32   40      -          rt10     16080     
- 10.0.255.9/32   50      -          rt10     16090     
- 10.0.255.11/32  30      -          rt10     16110     
- 10.0.255.12/32  40      -          rt10     16120     
+ 10.0.255.8/32   50      -          rt10     16080     
+ 10.0.255.9/32   60      -          rt10     16090     
+ 10.0.255.11/32  40      -          rt10     16110     
+ 10.0.255.12/32  50      -          rt10     16120     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1252,7 +1252,7 @@ IS-IS L1 IPv4 routing table:
 
  Prefix          Metric  Interface  Nexthop  Label(s)  
  ------------------------------------------------------
- 10.0.255.10/32  30      -          rt7      16100     
+ 10.0.255.10/32  40      -          rt7      16100     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1313,14 +1313,14 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)       
  ----------------------------------------------------------
- 10.0.255.1/32  120     -          rt4      16010          
- 10.0.255.2/32  110     -          rt4      16020          
- 10.0.255.4/32  100     -          rt4      implicit-null  
- 10.0.255.5/32  110     -          rt4      16050          
- 10.0.255.6/32  130     -          rt4      16060          
- 10.0.255.7/32  130     -          rt4      16070          
- 10.0.255.8/32  130     -          rt4      16080          
- 10.0.255.9/32  120     -          rt4      16090          
+ 10.0.255.1/32  130     -          rt4      16010          
+ 10.0.255.2/32  120     -          rt4      16020          
+ 10.0.255.4/32  110     -          rt4      implicit-null  
+ 10.0.255.5/32  120     -          rt4      16050          
+ 10.0.255.6/32  140     -          rt4      16060          
+ 10.0.255.7/32  140     -          rt4      16070          
+ 10.0.255.8/32  140     -          rt4      16080          
+ 10.0.255.9/32  130     -          rt4      16090          
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1366,14 +1366,14 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)       
  ------------------------------------------------------------
- 2001:db8::1/128  120     -          rt4      16011          
- 2001:db8::2/128  110     -          rt4      16021          
- 2001:db8::4/128  100     -          rt4      implicit-null  
- 2001:db8::5/128  110     -          rt4      16051          
- 2001:db8::6/128  130     -          rt4      16061          
- 2001:db8::7/128  130     -          rt4      16071          
- 2001:db8::8/128  130     -          rt4      16081          
- 2001:db8::9/128  120     -          rt4      16091          
+ 2001:db8::1/128  130     -          rt4      16011          
+ 2001:db8::2/128  120     -          rt4      16021          
+ 2001:db8::4/128  110     -          rt4      implicit-null  
+ 2001:db8::5/128  120     -          rt4      16051          
+ 2001:db8::6/128  140     -          rt4      16061          
+ 2001:db8::7/128  140     -          rt4      16071          
+ 2001:db8::8/128  140     -          rt4      16081          
+ 2001:db8::9/128  130     -          rt4      16091          
 
 test# test isis topology 10 root rt8 lfa system-id rt5
 IS-IS paths to level-1 routers that speak IP
@@ -1414,15 +1414,15 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.1/32  80      -          rt6      16010     
+ 10.0.255.1/32  90      -          rt6      16010     
                         -          rt7      16010     
- 10.0.255.2/32  90      -          rt6      16020     
+ 10.0.255.2/32  100     -          rt6      16020     
                         -          rt7      16020     
- 10.0.255.3/32  60      -          rt6      16030     
+ 10.0.255.3/32  70      -          rt6      16030     
                         -          rt7      16030     
- 10.0.255.4/32  60      -          rt6      16040     
+ 10.0.255.4/32  70      -          rt6      16040     
                         -          rt7      16040     
- 10.0.255.5/32  100     -          rt6      16050     
+ 10.0.255.5/32  110     -          rt6      16050     
                         -          rt7      16050     
 
 IS-IS paths to level-1 routers that speak IPv6
@@ -1463,15 +1463,15 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)  
  -------------------------------------------------------
- 2001:db8::1/128  80      -          rt6      16011     
+ 2001:db8::1/128  90      -          rt6      16011     
                           -          rt7      16011     
- 2001:db8::2/128  90      -          rt6      16021     
+ 2001:db8::2/128  100     -          rt6      16021     
                           -          rt7      16021     
- 2001:db8::3/128  60      -          rt6      16031     
+ 2001:db8::3/128  70      -          rt6      16031     
                           -          rt7      16031     
- 2001:db8::4/128  60      -          rt6      16041     
+ 2001:db8::4/128  70      -          rt6      16041     
                           -          rt7      16041     
- 2001:db8::5/128  100     -          rt6      16051     
+ 2001:db8::5/128  110     -          rt6      16051     
                           -          rt7      16051     
 
 test# test isis topology 11 root rt3 lfa system-id rt5
@@ -1511,8 +1511,8 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.5/32  30      -          rt2      16050     
- 10.0.255.6/32  30      -          rt2      16060     
+ 10.0.255.5/32  40      -          rt2      16050     
+ 10.0.255.6/32  40      -          rt2      16060     
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1550,8 +1550,8 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)  
  -------------------------------------------------------
- 2001:db8::5/128  30      -          rt2      16051     
- 2001:db8::6/128  30      -          rt2      16061     
+ 2001:db8::5/128  40      -          rt2      16051     
+ 2001:db8::6/128  40      -          rt2      16061     
 
 test# test isis topology 13 root rt4 lfa system-id rt3
 IS-IS paths to level-1 routers that speak IP
@@ -1593,10 +1593,10 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)       
  ----------------------------------------------------------
- 10.0.255.3/32  110     -          rt5      16030          
- 10.0.255.5/32  100     -          rt5      implicit-null  
- 10.0.255.6/32  120     -          rt5      16060          
- 10.0.255.7/32  110     -          rt5      16070          
+ 10.0.255.3/32  120     -          rt5      16030          
+ 10.0.255.5/32  110     -          rt5      implicit-null  
+ 10.0.255.6/32  130     -          rt5      16060          
+ 10.0.255.7/32  120     -          rt5      16070          
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1699,7 +1699,7 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.2/32  20      -          rt3      -         
+ 10.0.255.2/32  30      -          rt3      -         
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1731,7 +1731,7 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)  
  -------------------------------------------------------
- 2001:db8::2/128  20      -          rt3      -         
+ 2001:db8::2/128  30      -          rt3      -         
 
 test# test isis topology 14 root rt5 lfa system-id rt4
 IS-IS paths to level-1 routers that speak IP
@@ -1765,10 +1765,10 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.1/32  60      -          rt3      -         
- 10.0.255.2/32  60      -          rt3      -         
- 10.0.255.3/32  50      -          rt3      -         
- 10.0.255.4/32  60      -          rt3      -         
+ 10.0.255.1/32  70      -          rt3      -         
+ 10.0.255.2/32  70      -          rt3      -         
+ 10.0.255.3/32  60      -          rt3      -         
+ 10.0.255.4/32  70      -          rt3      -         
 
 IS-IS paths to level-1 routers that speak IPv6
 Vertex               Type         Metric Next-Hop             Interface Parent
@@ -1801,10 +1801,10 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)  
  -------------------------------------------------------
- 2001:db8::1/128  60      -          rt3      -         
- 2001:db8::2/128  60      -          rt3      -         
- 2001:db8::3/128  50      -          rt3      -         
- 2001:db8::4/128  60      -          rt3      -         
+ 2001:db8::1/128  70      -          rt3      -         
+ 2001:db8::2/128  70      -          rt3      -         
+ 2001:db8::3/128  60      -          rt3      -         
+ 2001:db8::4/128  70      -          rt3      -         
 
 test# 
 test# test isis topology 1 root rt1 remote-lfa system-id rt2
@@ -2174,11 +2174,11 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)  
  -----------------------------------------------------
- 10.0.255.1/32  40      -          rt3      16010     
+ 10.0.255.1/32  50      -          rt3      16010     
                         -          rt6      16010     
- 10.0.255.2/32  30      -          rt3      16020     
+ 10.0.255.2/32  40      -          rt3      16020     
                         -          rt6      16020     
- 10.0.255.4/32  20      -          rt3      16040     
+ 10.0.255.4/32  30      -          rt3      16040     
                         -          rt6      16040     
 
 test# test isis topology 3 root rt5 remote-lfa system-id rt3 ipv4-only
@@ -2535,13 +2535,13 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)     
  --------------------------------------------------------
- 10.0.255.1/32  50      -          rt10     16010        
+ 10.0.255.1/32  60      -          rt10     16010        
  10.0.255.2/32  60      -          rt12     50900/16020  
  10.0.255.3/32  70      -          rt12     50900/16030  
- 10.0.255.4/32  40      -          rt10     16040        
+ 10.0.255.4/32  50      -          rt10     16040        
  10.0.255.5/32  50      -          rt12     50900/16050  
  10.0.255.6/32  60      -          rt12     50900/16060  
- 10.0.255.7/32  30      -          rt10     16070        
+ 10.0.255.7/32  40      -          rt10     16070        
  10.0.255.8/32  40      -          rt12     50900/16080  
 
 test# test isis topology 7 root rt6 remote-lfa system-id rt5 ipv4-only
@@ -2671,13 +2671,13 @@ IS-IS L1 IPv4 routing table:
 
  Prefix          Metric  Interface  Nexthop  Label(s)  
  ------------------------------------------------------
- 10.0.255.1/32   70      -          rt9      16010     
- 10.0.255.4/32   60      -          rt9      16040     
- 10.0.255.5/32   50      -          rt9      16050     
- 10.0.255.7/32   50      -          rt9      16070     
- 10.0.255.8/32   40      -          rt9      16080     
- 10.0.255.10/32  60      -          rt9      16100     
- 10.0.255.11/32  50      -          rt9      16110     
+ 10.0.255.1/32   80      -          rt9      16010     
+ 10.0.255.4/32   70      -          rt9      16040     
+ 10.0.255.5/32   60      -          rt9      16050     
+ 10.0.255.7/32   60      -          rt9      16070     
+ 10.0.255.8/32   50      -          rt9      16080     
+ 10.0.255.10/32  70      -          rt9      16100     
+ 10.0.255.11/32  60      -          rt9      16110     
 
 test# test isis topology 8 root rt2 remote-lfa system-id rt5 ipv4-only
 P-space (self):
@@ -2863,14 +2863,14 @@ IS-IS L1 IPv4 routing table:
 
  Prefix         Metric  Interface  Nexthop  Label(s)       
  ----------------------------------------------------------
- 10.0.255.1/32  50      -          rt1      implicit-null  
+ 10.0.255.1/32  60      -          rt1      implicit-null  
                         -          rt3      16010          
- 10.0.255.3/32  50      -          rt1      16030          
+ 10.0.255.3/32  60      -          rt1      16030          
                         -          rt3      implicit-null  
  10.0.255.4/32  80      -          rt3      50500/16040    
- 10.0.255.5/32  60      -          rt1      16050          
+ 10.0.255.5/32  70      -          rt1      16050          
                         -          rt3      16050          
- 10.0.255.6/32  70      -          rt3      16060          
+ 10.0.255.6/32  80      -          rt3      16060          
 
 P-space (self):
 
@@ -2941,14 +2941,14 @@ IS-IS L1 IPv6 routing table:
 
  Prefix           Metric  Interface  Nexthop  Label(s)       
  ------------------------------------------------------------
- 2001:db8::1/128  50      -          rt1      implicit-null  
+ 2001:db8::1/128  60      -          rt1      implicit-null  
                           -          rt3      16011          
- 2001:db8::3/128  50      -          rt1      16031          
+ 2001:db8::3/128  60      -          rt1      16031          
                           -          rt3      implicit-null  
  2001:db8::4/128  80      -          rt3      50500/16041    
- 2001:db8::5/128  60      -          rt1      16051          
+ 2001:db8::5/128  70      -          rt1      16051          
                           -          rt3      16051          
- 2001:db8::6/128  70      -          rt3      16061          
+ 2001:db8::6/128  80      -          rt3      16061          
 
 test# test isis topology 13 root rt1 remote-lfa system-id rt3 ipv4-only
 P-space (self):
diff -urpN frr-frr-8.4.2/tests/lib/subdir.am frr-frr-8.5/tests/lib/subdir.am
--- frr-frr-8.4.2/tests/lib/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/lib/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -93,7 +93,7 @@ tests_lib_cli_test_commands_LDADD = $(AL
 nodist_tests_lib_cli_test_commands_SOURCES = tests/lib/cli/test_commands_defun.c
 tests_lib_cli_test_commands_SOURCES = tests/lib/cli/test_commands.c tests/helpers/c/prng.c
 tests/lib/cli/test_commands_defun.c: vtysh/vtysh_cmd.c
-	@mkdir -p tests/lib/cli
+	@$(MKDIR_P) tests/lib/cli
 	$(AM_V_GEN)sed \
 		-e 's%"vtysh/vtysh\.h"%"tests/helpers/c/tests.h"%' \
 		-e 's/vtysh_init_cmd/test_init_cmd/' \
diff -urpN frr-frr-8.4.2/tests/lib/test_heavy_wq.c frr-frr-8.5/tests/lib/test_heavy_wq.c
--- frr-frr-8.4.2/tests/lib/test_heavy_wq.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/lib/test_heavy_wq.c	2023-03-13 20:01:47.000000000 +0600
@@ -70,11 +70,6 @@ static void heavy_wq_add(struct vty *vty
 	return;
 }
 
-static void slow_func_err(struct work_queue *wq, struct work_queue_item *item)
-{
-	printf("%s: running error function\n", __func__);
-}
-
 static void slow_func_del(struct work_queue *wq, void *data)
 {
 	struct heavy_wq_node *hn = data;
@@ -143,7 +138,6 @@ static int heavy_wq_init(void)
 	heavy_wq = work_queue_new(master, "heavy_work_queue");
 
 	heavy_wq->spec.workfunc = &slow_func;
-	heavy_wq->spec.errorfunc = &slow_func_err;
 	heavy_wq->spec.del_item_data = &slow_func_del;
 	heavy_wq->spec.max_retries = 3;
 	heavy_wq->spec.hold = 1000;
diff -urpN frr-frr-8.4.2/tests/lib/test_nexthop_iter.c frr-frr-8.5/tests/lib/test_nexthop_iter.c
--- frr-frr-8.4.2/tests/lib/test_nexthop_iter.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/lib/test_nexthop_iter.c	2023-03-13 20:01:47.000000000 +0600
@@ -41,6 +41,7 @@ static void str_append(char **buf, const
 	}
 }
 
+PRINTFRR(2, 3)
 static void str_appendf(char **buf, const char *format, ...)
 {
 	va_list ap;
diff -urpN frr-frr-8.4.2/tests/lib/test_typelist.h frr-frr-8.5/tests/lib/test_typelist.h
--- frr-frr-8.4.2/tests/lib/test_typelist.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/lib/test_typelist.h	2023-03-13 20:01:47.000000000 +0600
@@ -74,7 +74,7 @@ static uint32_t list_hash(const struct i
 {
 #ifdef SHITTY_HASH
 	/* crappy hash to get some hash collisions */
-	return a->val ^ (a->val << 29) ^ 0x55AA0000U;
+	return (a->val & 0xFF) ^ (a->val << 29) ^ 0x55AA0000U;
 #else
 	return jhash_1word(a->val, 0xdeadbeef);
 #endif
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ip_nht.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ip_nht.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ip_nht.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ip_nht.ref	2023-03-13 20:01:47.000000000 +0600
@@ -1,34 +1,34 @@
 1.1.1.1
  resolved via static
- is directly connected, r1-eth1
+ is directly connected, r1-eth1 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.2
  resolved via static
- is directly connected, r1-eth2
+ is directly connected, r1-eth2 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.3
  resolved via static
- is directly connected, r1-eth3
+ is directly connected, r1-eth3 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.4
  resolved via static
- is directly connected, r1-eth4
+ is directly connected, r1-eth4 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.5
  resolved via static
- is directly connected, r1-eth5
+ is directly connected, r1-eth5 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.6
  resolved via static
- is directly connected, r1-eth6
+ is directly connected, r1-eth6 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.7
  resolved via static
- is directly connected, r1-eth7
+ is directly connected, r1-eth7 (vrf default), weight 1
  Client list: pbr(fd XX)
 1.1.1.8
  resolved via static
- is directly connected, r1-eth8
+ is directly connected, r1-eth8 (vrf default), weight 1
  Client list: pbr(fd XX)
 2.2.2.1
  unresolved
@@ -53,19 +53,19 @@
  Client list: pbr(fd XX)
 192.168.0.2
  resolved via connected
- is directly connected, r1-eth0
+ is directly connected, r1-eth0 (vrf default)
  Client list: static(fd XX)
 192.168.0.4
  resolved via connected
- is directly connected, r1-eth0
+ is directly connected, r1-eth0 (vrf default)
  Client list: static(fd XX)
 192.168.7.10
  resolved via connected
- is directly connected, r1-eth7
+ is directly connected, r1-eth7 (vrf default)
  Client list: bgp(fd XX)
 192.168.7.20(Connected)
  resolved via connected
- is directly connected, r1-eth7
+ is directly connected, r1-eth7 (vrf default)
  Client list: bgp(fd XX)
 192.168.161.4
  unresolved
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ipv6_nht.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ipv6_nht.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ipv6_nht.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ipv6_nht.ref	2023-03-13 20:01:47.000000000 +0600
@@ -1,13 +1,13 @@
 fc00::2
  resolved via connected
- is directly connected, r1-eth0
+ is directly connected, r1-eth0 (vrf default)
  Client list: static(fd XX)
 fc00:0:0:8::1000
  resolved via connected
- is directly connected, r1-eth8
+ is directly connected, r1-eth8 (vrf default)
  Client list: bgp(fd XX)
 fc00:0:0:8::2000(Connected)
  resolved via connected
- is directly connected, r1-eth8
+ is directly connected, r1-eth8 (vrf default)
  Client list: bgp(fd XX)
- 
\ No newline at end of file
+ 
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ospf6d.conf frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ospf6d.conf
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ospf6d.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ospf6d.conf	2023-03-13 20:01:47.000000000 +0600
@@ -6,6 +6,7 @@ log file ospf6d.log
 ! debug ospf6 neighbor
 !
 interface r1-eth4
+  ipv6 ospf6 hello-interval 1
 !
 router ospf6
  ospf6 router-id 192.168.0.1
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ospfd.conf frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/ospfd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -3,6 +3,15 @@ log file ospfd.log
 ! debug ospf event
 ! debug ospf zebra
 !
+!
+interface r1-eth0
+  ip ospf hello-interval 1
+  ip ospf dead-interval 5
+!
+interface r1-eth3
+  ip ospf hello-interval 1
+  ip ospf dead-interval 5
+!
 router ospf
  ospf router-id 192.168.0.1
  log-adjacency-changes
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post4.1.ref	2023-03-13 20:01:47.000000000 +0600
@@ -5,5 +5,5 @@ Nexthop codes: @NNN nexthop's vrf id, <
 Origin codes:  i - IGP, e - EGP, ? - incomplete
 RPKI validation codes: V valid, I invalid, N Not found
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> 192.168.0.0      0.0.0.0                  0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> 192.168.0.0      0.0.0.0                  0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post5.0.ref	2023-03-13 20:01:47.000000000 +0600
@@ -5,5 +5,5 @@ Nexthop codes: @NNN nexthop's vrf id, <
 Origin codes:  i - IGP, e - EGP, ? - incomplete
 RPKI validation codes: V valid, I invalid, N Not found
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> 192.168.0.0/24   0.0.0.0                  0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> 192.168.0.0/24   0.0.0.0                  0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4-post6.1.ref	2023-03-13 20:01:47.000000000 +0600
@@ -6,5 +6,5 @@ Nexthop codes: @NNN nexthop's vrf id, <
 Origin codes:  i - IGP, e - EGP, ? - incomplete
 RPKI validation codes: V valid, I invalid, N Not found
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> 192.168.0.0/24   0.0.0.0                  0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> 192.168.0.0/24   0.0.0.0                  0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv4.ref	2023-03-13 20:01:47.000000000 +0600
@@ -3,5 +3,5 @@ Status codes: s suppressed, d damped, h
               i internal, r RIB-failure, S Stale, R Removed
 Origin codes: i - IGP, e - EGP, ? - incomplete
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> 192.168.0.0      0.0.0.0                  0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> 192.168.0.0      0.0.0.0                  0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6-post4.1.ref	2023-03-13 20:01:47.000000000 +0600
@@ -5,5 +5,5 @@ Nexthop codes: @NNN nexthop's vrf id, <
 Origin codes:  i - IGP, e - EGP, ? - incomplete
 RPKI validation codes: V valid, I invalid, N Not found
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> fc00::/64        ::                       0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> fc00::/64        ::                       0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6.ref	2023-03-13 20:01:47.000000000 +0600
@@ -3,5 +3,5 @@ Status codes: s suppressed, d damped, h
               i internal, r RIB-failure, S Stale, R Removed
 Origin codes: i - IGP, e - EGP, ? - incomplete
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> fc00::/64        ::                       0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> fc00::/64        ::                       0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_bgp_ipv6_post6.1.ref	2023-03-13 20:01:47.000000000 +0600
@@ -6,5 +6,5 @@ Nexthop codes: @NNN nexthop's vrf id, <
 Origin codes:  i - IGP, e - EGP, ? - incomplete
 RPKI validation codes: V valid, I invalid, N Not found
 
-   Network          Next Hop            Metric LocPrf Weight Path
-*> fc00::/64        ::                       0         32768 i
+    Network          Next Hop            Metric LocPrf Weight Path
+ *> fc00::/64        ::                       0         32768 i
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_ip_ospf_interface.ref frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_ip_ospf_interface.ref
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/r1/show_ip_ospf_interface.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/r1/show_ip_ospf_interface.ref	2023-03-13 20:01:47.000000000 +0600
@@ -7,7 +7,7 @@ r1-eth0 is up
   Designated Router (ID) 192.168.0.1 Interface Address 192.168.0.1/24
   No backup designated router on this network
   Multicast group memberships: OSPFAllRouters OSPFDesignatedRouters
-  Timer intervals configured, Hello 10s, Dead 40s, Wait 40s, Retransmit 5
+  Timer intervals configured, Hello 1s, Dead 5s, Wait 5s, Retransmit 5
     Hello due in XX.XXXs
   Neighbor Count is 0, Adjacent neighbor count is 0
 r1-eth3 is up
@@ -19,6 +19,6 @@ r1-eth3 is up
   Designated Router (ID) 192.168.0.1 Interface Address 192.168.3.1/26
   No backup designated router on this network
   Multicast group memberships: OSPFAllRouters OSPFDesignatedRouters
-  Timer intervals configured, Hello 10s, Dead 40s, Wait 40s, Retransmit 5
+  Timer intervals configured, Hello 1s, Dead 5s, Wait 5s, Retransmit 5
     Hello due in XX.XXXs
   Neighbor Count is 0, Adjacent neighbor count is 0
diff -urpN frr-frr-8.4.2/tests/topotests/all_protocol_startup/test_all_protocol_startup.py frr-frr-8.5/tests/topotests/all_protocol_startup/test_all_protocol_startup.py
--- frr-frr-8.4.2/tests/topotests/all_protocol_startup/test_all_protocol_startup.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/all_protocol_startup/test_all_protocol_startup.py	2023-03-13 20:01:47.000000000 +0600
@@ -47,6 +47,9 @@ pytestmark = [
 sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 from lib import topotest
 from lib.topogen import Topogen, get_topogen
+from lib.common_config import (
+    required_linux_kernel_version,
+)
 
 fatal_error = ""
 
@@ -301,7 +304,7 @@ def test_converge_protocols():
     print("******************************************\n")
 
     # Not really implemented yet - just sleep 60 secs for now
-    sleep(60)
+    sleep(5)
 
     # Make sure that all daemons are running
     failures = 0
@@ -1591,6 +1594,24 @@ def test_mpls_interfaces():
         assert fatal_error == "", fatal_error
 
 
+def test_resilient_nexthop_group():
+    net = get_topogen().net
+
+    result = required_linux_kernel_version("5.19")
+    if result is not True:
+        pytest.skip("Kernel requirements are not met, kernel version should be >= 5.19")
+
+    net["r1"].cmd(
+        'vtysh -c "conf" -c "nexthop-group resilience" -c "resilient buckets 64 idle-timer 128 unbalanced-timer 256" -c "nexthop 1.1.1.1 r1-eth1 onlink" -c "nexthop 1.1.1.2 r1-eth2 onlink"'
+    )
+
+    output = net["r1"].cmd('vtysh -c "show nexthop-group rib sharp"')
+    output = re.findall(r"Buckets", output)
+
+    verify_nexthop_group(185483878)
+    assert len(output) == 1, "Resilient NHG not created in zebra"
+
+
 def test_shutdown_check_stderr():
     global fatal_error
     net = get_topogen().net
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r1/babeld.conf frr-frr-8.5/tests/topotests/babel_topo1/r1/babeld.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r1/babeld.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r1/babeld.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,21 @@
+log file eigrpd.log
+
+interface r1-eth0
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+interface r1-eth1
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+router babel
+ network r1-eth0
+ network r1-eth1
+ redistribute ipv4 connected
+ redistribute ipv6 connected
+!
+line vty
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r1/show_ip_route.json_ref frr-frr-8.5/tests/topotests/babel_topo1/r1/show_ip_route.json_ref
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r1/show_ip_route.json_ref	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r1/show_ip_route.json_ref	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,80 @@
+{
+  "192.168.1.0/24":[
+    {
+      "prefix":"192.168.1.0/24",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r1-eth0",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "192.168.2.0/24":[
+    {
+      "prefix":"192.168.2.0/24",
+      "prefixLen":24,
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.1.2",
+          "afi":"ipv4",
+          "interfaceName":"r1-eth1"
+        }
+      ]
+    }
+  ],
+  "192.168.3.0/24":[
+    {
+      "prefix":"192.168.3.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.1.2",
+          "afi":"ipv4",
+          "interfaceName":"r1-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.1.0/26":[
+    {
+      "prefix":"193.1.1.0/26",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r1-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.2.0/24":[
+    {
+      "prefix":"193.1.2.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.1.2",
+          "afi":"ipv4",
+          "interfaceName":"r1-eth1",
+          "active":true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r1/zebra.conf frr-frr-8.5/tests/topotests/babel_topo1/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+log file zebra.log
+! debug zebra rib detail
+!
+hostname r1
+!
+interface r1-eth0
+ ip address 192.168.1.1/24
+ ipv6 address 192:168:1::1/64
+!
+interface r1-eth1
+ description to sw2 - babel interface
+ ip address 193.1.1.1/26
+ ipv6 address 193:1:1::1/64
+ no link-detect
+!
+ip forwarding
+ipv6 forwarding
+!
+!
+line vty
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r2/babeld.conf frr-frr-8.5/tests/topotests/babel_topo1/r2/babeld.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r2/babeld.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r2/babeld.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+log file eigrpd.log
+!
+interface r2-eth0
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+interface r2-eth1
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+router babel
+ network r2-eth0
+ network r2-eth1
+ redistribute ipv4 connected
+ redistribute ipv6 connected
+!
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r2/show_ip_route.json_ref frr-frr-8.5/tests/topotests/babel_topo1/r2/show_ip_route.json_ref
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r2/show_ip_route.json_ref	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r2/show_ip_route.json_ref	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,80 @@
+{
+  "192.168.1.0/24":[
+    {
+      "prefix":"192.168.1.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.1.1",
+          "afi":"ipv4",
+          "interfaceName":"r2-eth0",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "192.168.2.0/24":[
+    {
+      "prefix":"192.168.2.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.2.2",
+          "afi":"ipv4",
+          "interfaceName":"r2-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "192.168.3.0/24":[
+    {
+      "prefix":"192.168.3.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.2.2",
+          "afi":"ipv4",
+          "interfaceName":"r2-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.1.0/26":[
+    {
+      "prefix":"193.1.1.0/26",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r2-eth0",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.2.0/24":[
+    {
+      "prefix":"193.1.2.0/24",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r2-eth1",
+          "active":true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r2/zebra.conf frr-frr-8.5/tests/topotests/babel_topo1/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,23 @@
+log file zebra.log
+!
+hostname r2
+!
+interface r2-eth0
+ description to sw2 - babel interface
+ ip address 193.1.1.2/26
+ ipv6 address 193:1:1::2/64
+ no link-detect
+!
+interface r2-eth1
+ description to sw3 - babel interface
+ ip address 193.1.2.1/24
+ ipv6 address 193:1:2::1/64
+ no link-detect
+!
+ip forwarding
+ipv6 forwarding
+!
+!
+line vty
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r3/babeld.conf frr-frr-8.5/tests/topotests/babel_topo1/r3/babeld.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r3/babeld.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r3/babeld.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+log file eigrpd.log
+!
+interface r3-eth0
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+interface r3-eth1
+  babel hello-interval 1000
+  babel wired
+  babel update-interval 50
+!
+router  babel
+ network r3-eth0
+ network r3-eth1
+ redistribute ipv4 connected
+ redistribute ipv4 static
+ redistirbute ipv6 connected
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r3/show_ip_route.json_ref frr-frr-8.5/tests/topotests/babel_topo1/r3/show_ip_route.json_ref
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r3/show_ip_route.json_ref	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r3/show_ip_route.json_ref	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,81 @@
+{
+  "192.168.1.0/24":[
+    {
+      "prefix":"192.168.1.0/24",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.2.1",
+          "afi":"ipv4",
+          "interfaceName":"r3-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "192.168.2.0/24":[
+    {
+      "prefix":"192.168.2.0/24",
+      "protocol":"static",
+      "selected":true,
+      "distance":1,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"192.168.3.10",
+          "afi":"ipv4",
+          "interfaceName":"r3-eth0",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "192.168.3.0/24":[
+    {
+      "prefix":"192.168.3.0/24",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r3-eth0",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.1.0/26":[
+    {
+      "prefix":"193.1.1.0/26",
+      "protocol":"babel",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "ip":"193.1.2.1",
+          "afi":"ipv4",
+          "interfaceName":"r3-eth1",
+          "active":true
+        }
+      ]
+    }
+  ],
+  "193.1.2.0/24":[
+    {
+      "prefix":"193.1.2.0/24",
+      "protocol":"connected",
+      "selected":true,
+      "nexthops":[
+        {
+          "fib":true,
+          "directlyConnected":true,
+          "interfaceName":"r3-eth1",
+          "active":true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/r3/zebra.conf frr-frr-8.5/tests/topotests/babel_topo1/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/babel_topo1/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,25 @@
+log file zebra.log
+!
+hostname r3
+!
+interface r3-eth0
+ description to sw4 - Stub interface
+ ip address 192.168.3.1/24
+ ipv6 address 192:168:3::1/64
+ no link-detect
+!
+interface r3-eth1
+ description to sw3 - RIPv2 interface
+ ip address 193.1.2.2/24
+ ipv6 address 193:1:2::2/64
+ no link-detect
+!
+ip route 192.168.2.0/24 192.168.3.10
+ipv6 route 192:168:2::0/64 192:168:3::10
+!
+ip forwarding
+ipv6 forwarding
+!
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/babel_topo1/test_babel_topo1.py frr-frr-8.5/tests/topotests/babel_topo1/test_babel_topo1.py
--- frr-frr-8.4.2/tests/topotests/babel_topo1/test_babel_topo1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/babel_topo1/test_babel_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,171 @@
+#!/usr/bin/env python
+
+#
+# test_babel_topo1.py
+#
+# Copyright (c) 2017 by
+# Cumulus Networks, Inc.
+# Donald Sharp
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+test_babel_topo1.py: Testing BABEL
+
+"""
+
+import os
+import re
+import sys
+import pytest
+import json
+
+pytestmark = [pytest.mark.babeld]
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+# Required to instantiate the topology builder class.
+
+#####################################################
+##
+##   Network Topology Definition
+##
+#####################################################
+
+
+def build_topo(tgen):
+    for routern in range(1, 4):
+        tgen.add_router("r{}".format(routern))
+
+    # On main router
+    # First switch is for a dummy interface (for local network)
+    switch = tgen.add_switch("sw1")
+    switch.add_link(tgen.gears["r1"])
+
+    # Switches for BABEL
+    # switch 2 switch is for connection to BABEL router
+    switch = tgen.add_switch("sw2")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    # switch 4 is stub on remote BABEL router
+    switch = tgen.add_switch("sw4")
+    switch.add_link(tgen.gears["r3"])
+
+    # switch 3 is between BABEL routers
+    switch = tgen.add_switch("sw3")
+    switch.add_link(tgen.gears["r2"])
+    switch.add_link(tgen.gears["r3"])
+
+
+#####################################################
+##
+##   Tests starting
+##
+#####################################################
+
+
+def setup_module(module):
+    "Setup topology"
+    tgen = Topogen(build_topo, module.__name__)
+    tgen.start_topology()
+
+    # This is a sample of configuration loading.
+    router_list = tgen.routers()
+    for rname, router in router_list.items():
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BABEL, os.path.join(CWD, "{}/babeld.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(_mod):
+    "Teardown the pytest environment"
+    tgen = get_topogen()
+
+    # This function tears down the whole topology.
+    tgen.stop_topology()
+
+
+def test_converge_protocols():
+    "Wait for protocol convergence"
+
+    tgen = get_topogen()
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    topotest.sleep(10, "Waiting for BABEL convergence")
+
+
+def test_zebra_ipv4_routingTable():
+    "Test 'show ip route'"
+
+    tgen = get_topogen()
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    failures = 0
+    router_list = tgen.routers().values()
+    for router in router_list:
+        output = router.vtysh_cmd("show ip route json", isjson=True)
+        refTableFile = "{}/{}/show_ip_route.json_ref".format(CWD, router.name)
+        expected = json.loads(open(refTableFile).read())
+
+        assertmsg = "Zebra IPv4 Routing Table verification failed for router {}".format(
+            router.name
+        )
+        assert topotest.json_cmp(output, expected) is None, assertmsg
+
+def test_shutdown_check_stderr():
+    if os.environ.get("TOPOTESTS_CHECK_STDERR") is None:
+        pytest.skip("Skipping test for Stderr output and memory leaks")
+
+    tgen = get_topogen()
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Verifying unexpected STDERR output from daemons")
+
+    router_list = tgen.routers().values()
+    for router in router_list:
+        router.stop()
+
+        log = tgen.net[router.name].getStdErr("babeld")
+        if log:
+            logger.error("BABELd StdErr Log:" + log)
+        log = tgen.net[router.name].getStdErr("zebra")
+        if log:
+            logger.error("Zebra StdErr Log:" + log)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo1/test_bfd_topo1.py frr-frr-8.5/tests/topotests/bfd_topo1/test_bfd_topo1.py
--- frr-frr-8.4.2/tests/topotests/bfd_topo1/test_bfd_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo1/test_bfd_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -207,7 +207,7 @@ def test_bgp_fast_reconvergence():
         test_func = partial(
             topotest.router_json_cmp, router, "show ip bgp json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "{}: bgp did not converge".format(router.name)
         assert res is None, assertmsg
 
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/bfd-static-down.json frr-frr-8.5/tests/topotests/bfd_topo3/r3/bfd-static-down.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/bfd-static-down.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r3/bfd-static-down.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+{
+    "path-list": {
+        "ipv4-multicast": [],
+        "ipv4-unicast": [],
+        "ipv6-unicast": [
+            {
+                "prefix": "2001:db8:5::\/64",
+                "vrf": "default",
+                "installed": false
+            }
+        ]
+    }}
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/bfd-static.json frr-frr-8.5/tests/topotests/bfd_topo3/r3/bfd-static.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/bfd-static.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r3/bfd-static.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+{
+    "path-list": {
+        "ipv4-multicast": [],
+        "ipv4-unicast": [],
+        "ipv6-unicast": [
+            {
+                "prefix": "2001:db8:5::\/64",
+                "vrf": "default",
+                "installed": true
+            }
+        ]
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/staticd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r3/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r3/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r3/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+ipv6 route 2001:db8:5::/64 2001:db8:4::3 bfd multi-hop profile slow-tx
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/bfd-peers.json frr-frr-8.5/tests/topotests/bfd_topo3/r4/bfd-peers.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/bfd-peers.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r4/bfd-peers.json	2023-03-13 20:01:47.000000000 +0600
@@ -19,7 +19,8 @@
         "remote-transmit-interval": 2000,
         "status": "up",
         "uptime": "*",
-        "transmit-interval": 2000
+        "transmit-interval": 2000,
+        "vrf": "default"
     },
     {
         "detect-multiplier": 3,
@@ -41,6 +42,49 @@
         "remote-transmit-interval": 2000,
         "status": "up",
         "uptime": "*",
-        "transmit-interval": 2000
+        "transmit-interval": 2000,
+        "vrf": "default"
+    },
+    {
+        "detect-multiplier": 3,
+        "diagnostic": "ok",
+        "echo-receive-interval": 50,
+        "echo-transmit-interval": 0,
+        "id": "*",
+        "multihop": false,
+        "passive-mode": false,
+        "peer": "192.168.4.3",
+        "receive-interval": 2000,
+        "remote-detect-multiplier": 3,
+        "remote-diagnostic": "ok",
+        "remote-echo-receive-interval": 50,
+        "remote-id": "*",
+        "remote-receive-interval": 2000,
+        "remote-transmit-interval": 2000,
+        "status": "up",
+        "transmit-interval": 2000,
+        "uptime": "*",
+        "vrf": "default"
+    },
+    {
+        "detect-multiplier": 3,
+        "diagnostic": "ok",
+        "echo-receive-interval": 50,
+        "echo-transmit-interval": 0,
+        "id": "*",
+        "multihop": false,
+        "passive-mode": false,
+        "peer": "192.168.4.2",
+        "receive-interval": 2000,
+        "remote-detect-multiplier": 3,
+        "remote-diagnostic": "ok",
+        "remote-echo-receive-interval": 50,
+        "remote-id": "*",
+        "remote-receive-interval": 2000,
+        "remote-transmit-interval": 2000,
+        "status": "up",
+        "transmit-interval": 2000,
+        "uptime": "*",
+        "vrf": "default"
     }
 ]
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/bgpd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r4/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r4/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -9,6 +9,7 @@ router bgp 400
  neighbor 2001:db8:1::1 bfd profile slow-tx-mh
  address-family ipv4 unicast
   redistribute connected
+  redistribute static
  exit-address-family
  address-family ipv6 unicast
   redistribute connected
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/staticd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r4/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r4/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+ip route 10.254.254.5/32 192.168.4.2 bfd profile slow-tx
+ip route 10.254.254.6/32 192.168.4.3 bfd profile slow-tx
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/zebra.conf frr-frr-8.5/tests/topotests/bfd_topo3/r4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r4/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -8,3 +8,7 @@ interface r4-eth0
  ip address 192.168.3.1/24
  ipv6 address 2001:db8:3::1/64
 !
+interface r4-eth1
+ ip address 192.168.4.1/24
+ ipv6 address 2001:db8:4::1/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/bfd-peers.json frr-frr-8.5/tests/topotests/bfd_topo3/r5/bfd-peers.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/bfd-peers.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r5/bfd-peers.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,23 @@
+[
+    {
+        "detect-multiplier": 3,
+        "diagnostic": "ok",
+        "echo-receive-interval": 50,
+        "echo-transmit-interval": 0,
+        "id": "*",
+        "multihop": false,
+        "passive-mode": false,
+        "peer": "192.168.4.1",
+        "receive-interval": 2000,
+        "remote-detect-multiplier": 3,
+        "remote-diagnostic": "ok",
+        "remote-echo-receive-interval": 50,
+        "remote-id": "*",
+        "remote-receive-interval": 2000,
+        "remote-transmit-interval": 2000,
+        "status": "up",
+        "transmit-interval": 2000,
+        "uptime": "*",
+        "vrf": "default"
+    }
+]
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/bfdd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r5/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r5/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+debug bfd network
+debug bfd peer
+debug bfd zebra
+!
+bfd
+ profile slow-tx
+  receive-interval 2000
+  transmit-interval 2000
+  minimum-ttl 250
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/staticd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r5/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r5/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+ip route 0.0.0.0/0 192.168.4.1
+ip route 10.254.254.4/32 192.168.4.1 bfd profile slow-tx
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/zebra.conf frr-frr-8.5/tests/topotests/bfd_topo3/r5/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r5/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r5/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+ip forwarding
+ipv6 forwarding
+!
+interface lo
+ ip address 10.254.254.5/32
+!
+interface r5-eth0
+ ip address 192.168.4.2/24
+ ipv6 address 2001:db8:4::2/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-peers.json frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-peers.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-peers.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-peers.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,46 @@
+[
+    {
+        "detect-multiplier": 3,
+        "diagnostic": "ok",
+        "echo-receive-interval": 50,
+        "echo-transmit-interval": 0,
+        "id": "*",
+        "multihop": false,
+        "passive-mode": false,
+        "peer": "192.168.4.1",
+        "receive-interval": 2000,
+        "remote-detect-multiplier": 3,
+        "remote-diagnostic": "ok",
+        "remote-echo-receive-interval": 50,
+        "remote-id": "*",
+        "remote-receive-interval": 2000,
+        "remote-transmit-interval": 2000,
+        "status": "up",
+        "transmit-interval": 2000,
+        "uptime": "*",
+        "vrf": "default"
+    },
+    {
+        "detect-multiplier": 3,
+        "diagnostic": "ok",
+        "echo-receive-interval": 50,
+        "echo-transmit-interval": 0,
+        "id": "*",
+        "local": "2001:db8:4::3",
+        "minimum-ttl": 2,
+        "multihop": true,
+        "passive-mode": false,
+        "peer": "2001:db8:3::2",
+        "receive-interval": 2000,
+        "remote-detect-multiplier": 3,
+        "remote-diagnostic": "ok",
+        "remote-echo-receive-interval": 50,
+        "remote-id": "*",
+        "remote-receive-interval": 2000,
+        "remote-transmit-interval": 2000,
+        "status": "up",
+        "transmit-interval": 2000,
+        "uptime": "*",
+        "vrf": "default"
+    }
+]
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-static-down.json frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-static-down.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-static-down.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-static-down.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,19 @@
+{
+    "path-list": {
+        "ipv4-multicast": [],
+        "ipv4-unicast": [
+            {
+                "installed": true,
+                "prefix": "10.254.254.4/32",
+                "vrf": "default"
+            }
+        ],
+        "ipv6-unicast": [
+            {
+                "prefix": "2001:db8:1::\/64",
+                "vrf": "default",
+                "installed": false
+            }
+        ]
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-static.json frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-static.json
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfd-static.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfd-static.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,19 @@
+{
+    "path-list": {
+        "ipv4-multicast": [],
+        "ipv4-unicast": [
+            {
+                "installed": true,
+                "prefix": "10.254.254.4/32",
+                "vrf": "default"
+            }
+        ],
+        "ipv6-unicast": [
+            {
+                "prefix": "2001:db8:1::\/64",
+                "vrf": "default",
+                "installed": true
+            }
+        ]
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfdd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+debug bfd network
+debug bfd peer
+debug bfd zebra
+!
+bfd
+ profile slow-tx
+  receive-interval 2000
+  transmit-interval 2000
+  minimum-ttl 250
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/staticd.conf frr-frr-8.5/tests/topotests/bfd_topo3/r6/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,5 @@
+ip route 0.0.0.0/0 192.168.4.1
+ip route 10.254.254.4/32 192.168.4.1 bfd profile slow-tx
+!
+ipv6 route 2001:db8:3::/64 2001:db8:4::1
+ipv6 route 2001:db8:1::/64 2001:db8:3::2 bfd multi-hop source 2001:db8:4::3 profile slow-tx
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/zebra.conf frr-frr-8.5/tests/topotests/bfd_topo3/r6/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/r6/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/r6/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+ip forwarding
+ipv6 forwarding
+!
+interface lo
+ ip address 10.254.254.6/32
+!
+interface r6-eth0
+ ip address 192.168.4.3/24
+ ipv6 address 2001:db8:4::3/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/test_bfd_topo3.dot frr-frr-8.5/tests/topotests/bfd_topo3/test_bfd_topo3.dot
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/test_bfd_topo3.dot	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/test_bfd_topo3.dot	2023-03-13 20:01:47.000000000 +0600
@@ -40,6 +40,18 @@ graph template {
     fillcolor="#f08080",
     style=filled,
   ];
+  r5 [
+    shape=doubleoctagon
+    label="r5",
+    fillcolor="#f08080",
+    style=filled,
+  ];
+  r6 [
+    shape=doubleoctagon
+    label="r6",
+    fillcolor="#f08080",
+    style=filled,
+  ];
 
   # Switches
   sw1 [
@@ -60,6 +72,12 @@ graph template {
     fillcolor="#d0e0d0",
     style=filled,
   ];
+  sw4 [
+    shape=oval,
+    label="sw4\n192.168.4.0/24\n2001:db8:4::/64",
+    fillcolor="#d0e0d0",
+    style=filled,
+  ];
 
   # Connections
   r1 -- sw1 [label="eth0\n.1"];
@@ -70,4 +88,8 @@ graph template {
 
   r4 -- sw3 [label="eth0\n.1"];
   r3 -- sw3 [label="eth2\n.2"];
+
+  r4 -- sw4 [label="eth1\n.1"];
+  r5 -- sw4 [label="eth0\n.2"];
+  r6 -- sw4 [label="eth0\n.3"];
 }
Binary files frr-frr-8.4.2/tests/topotests/bfd_topo3/test_bfd_topo3.jpg and frr-frr-8.5/tests/topotests/bfd_topo3/test_bfd_topo3.jpg differ
diff -urpN frr-frr-8.4.2/tests/topotests/bfd_topo3/test_bfd_topo3.py frr-frr-8.5/tests/topotests/bfd_topo3/test_bfd_topo3.py
--- frr-frr-8.4.2/tests/topotests/bfd_topo3/test_bfd_topo3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bfd_topo3/test_bfd_topo3.py	2023-03-13 20:01:47.000000000 +0600
@@ -51,6 +51,7 @@ def setup_module(mod):
         "s1": ("r1", "r2"),
         "s2": ("r2", "r3"),
         "s3": ("r3", "r4"),
+        "s4": ("r4", "r5", "r6"),
     }
     tgen = Topogen(topodef, mod.__name__)
     tgen.start_topology()
@@ -69,6 +70,10 @@ def setup_module(mod):
         if os.path.isfile(daemon_file):
             router.load_config(TopoRouter.RD_BGP, daemon_file)
 
+        daemon_file = "{}/{}/staticd.conf".format(CWD, rname)
+        if os.path.isfile(daemon_file):
+            router.load_config(TopoRouter.RD_STATIC, daemon_file)
+
     # Initialize all routers.
     tgen.start_router()
 
@@ -100,6 +105,10 @@ def test_wait_bgp_convergence():
     expect_loopback_route("r1", "ip", "10.254.254.3/32", "bgp")
     # Wait for R1 <-> R4 convergence.
     expect_loopback_route("r1", "ip", "10.254.254.4/32", "bgp")
+    # Wait for R1 <-> R5 convergence.
+    expect_loopback_route("r1", "ip", "10.254.254.5/32", "bgp")
+    # Wait for R1 <-> R6 convergence.
+    expect_loopback_route("r1", "ip", "10.254.254.6/32", "bgp")
 
     # Wait for R2 <-> R1 convergence.
     expect_loopback_route("r2", "ip", "10.254.254.1/32", "bgp")
@@ -107,6 +116,10 @@ def test_wait_bgp_convergence():
     expect_loopback_route("r2", "ip", "10.254.254.3/32", "bgp")
     # Wait for R2 <-> R4 convergence.
     expect_loopback_route("r2", "ip", "10.254.254.4/32", "bgp")
+    # Wait for R2 <-> R5 convergence.
+    expect_loopback_route("r2", "ip", "10.254.254.5/32", "bgp")
+    # Wait for R2 <-> R6 convergence.
+    expect_loopback_route("r2", "ip", "10.254.254.6/32", "bgp")
 
     # Wait for R3 <-> R1 convergence.
     expect_loopback_route("r3", "ip", "10.254.254.1/32", "bgp")
@@ -114,6 +127,10 @@ def test_wait_bgp_convergence():
     expect_loopback_route("r3", "ip", "10.254.254.2/32", "bgp")
     # Wait for R3 <-> R4 convergence.
     expect_loopback_route("r3", "ip", "10.254.254.4/32", "bgp")
+    # Wait for R3 <-> R5 convergence.
+    expect_loopback_route("r3", "ip", "10.254.254.5/32", "bgp")
+    # Wait for R3 <-> R6 convergence.
+    expect_loopback_route("r3", "ip", "10.254.254.6/32", "bgp")
 
     # Wait for R4 <-> R1 convergence.
     expect_loopback_route("r4", "ip", "10.254.254.1/32", "bgp")
@@ -121,6 +138,15 @@ def test_wait_bgp_convergence():
     expect_loopback_route("r4", "ip", "10.254.254.2/32", "bgp")
     # Wait for R4 <-> R3 convergence.
     expect_loopback_route("r4", "ip", "10.254.254.3/32", "bgp")
+    # Wait for R4 <-> R5 convergence.
+    expect_loopback_route("r4", "ip", "10.254.254.5/32", "static")
+    # Wait for R4 <-> R6 convergence.
+    expect_loopback_route("r4", "ip", "10.254.254.6/32", "static")
+
+    # Wait for R5 <-> R6 convergence.
+    expect_loopback_route("r3", "ipv6", "2001:db8:5::/64", "static")
+    # Wait for R6 <-> R5 convergence.
+    expect_loopback_route("r6", "ipv6", "2001:db8:1::/64", "static")
 
 
 def test_wait_bfd_convergence():
@@ -149,6 +175,70 @@ def test_wait_bfd_convergence():
     expect_bfd_configuration("r2")
     expect_bfd_configuration("r3")
     expect_bfd_configuration("r4")
+    expect_bfd_configuration("r5")
+    expect_bfd_configuration("r6")
+
+
+def test_static_route_monitoring():
+    "Test static route monitoring output."
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("test BFD static route status")
+
+    def expect_static_bfd_output(router, filename):
+        "Load JSON file and compare with 'show bfd peer json'"
+        logger.info("waiting BFD configuration on router {}".format(router))
+        bfd_config = json.loads(
+            open("{}/{}/{}.json".format(CWD, router, filename)).read()
+        )
+        test_func = partial(
+            topotest.router_json_cmp,
+            tgen.gears[router],
+            "show bfd static route json",
+            bfd_config,
+        )
+        _, result = topotest.run_and_expect(test_func, None, count=20, wait=1)
+        assertmsg = '"{}" BFD static route status failure'.format(router)
+        assert result is None, assertmsg
+
+    expect_static_bfd_output("r3", "bfd-static")
+    expect_static_bfd_output("r6", "bfd-static")
+
+    logger.info("Setting r4 link down ...")
+
+    tgen.gears["r4"].link_enable("r4-eth0", False)
+
+    expect_static_bfd_output("r3", "bfd-static-down")
+    expect_static_bfd_output("r6", "bfd-static-down")
+
+
+def test_expect_static_rib_removal():
+    "Test that route got removed from RIB (staticd and bgpd)."
+
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def expect_route_missing(router, iptype, route):
+        "Wait until route is present on RIB for protocol."
+        logger.info("waiting route {} to disapear in {}".format(route, router))
+        test_func = partial(
+            topotest.router_json_cmp,
+            tgen.gears[router],
+            "show {} route json".format(iptype),
+            {route: None},
+        )
+        rv, result = topotest.run_and_expect(test_func, None, count=20, wait=1)
+        assertmsg = '"{}" convergence failure'.format(router)
+        assert result is None, assertmsg
+
+    expect_route_missing("r1", "ip", "10.254.254.5/32")
+    expect_route_missing("r2", "ip", "10.254.254.5/32")
+    expect_route_missing("r3", "ip", "10.254.254.5/32")
+    expect_route_missing("r3", "ipv6", "2001:db8:5::/64")
+    expect_route_missing("r6", "ipv6", "2001:db8:1::/64")
 
 
 def teardown_module(_mod):
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/ce1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/ce1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+!
+debug bgp updates
+!
+router bgp 65010
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.2 remote-as external
+ neighbor 192.168.1.2 timers 1 3
+ neighbor 192.168.1.2 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce1/zebra.conf frr-frr-8.5/tests/topotests/bgp_accept_own/ce1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/ce1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 172.16.255.1/32
+!
+interface ce1-eth0
+ ip address 192.168.1.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/ce2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/ce2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+!
+debug bgp updates
+!
+router bgp 65020
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.2 remote-as external
+ neighbor 192.168.2.2 timers 1 3
+ neighbor 192.168.2.2 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce2/zebra.conf frr-frr-8.5/tests/topotests/bgp_accept_own/ce2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/ce2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/ce2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 172.16.255.2/32
+!
+interface ce2-eth0
+ ip address 192.168.2.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,50 @@
+!
+debug bgp updates
+debug bgp vpn leak-from-vrf
+debug bgp vpn leak-to-vrf
+debug bgp nht
+!
+router bgp 65001
+ bgp router-id 10.10.10.10
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 10.10.10.101 remote-as internal
+ neighbor 10.10.10.101 update-source 10.10.10.10
+ neighbor 10.10.10.101 timers 1 3
+ neighbor 10.10.10.101 timers connect 1
+ address-family ipv4 vpn
+  neighbor 10.10.10.101 activate
+  neighbor 10.10.10.101 attribute-unchanged
+ exit-address-family
+!
+router bgp 65001 vrf Customer
+ bgp router-id 192.168.1.2
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as external
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+  label vpn export 10
+  rd vpn export 192.168.1.2:2
+  rt vpn import 192.168.1.2:2
+  rt vpn export 192.168.1.2:2
+  export vpn
+  import vpn
+ exit-address-family
+!
+router bgp 65001 vrf Service
+ bgp router-id 192.168.2.2
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as external
+ neighbor 192.168.2.1 timers 1 3
+ neighbor 192.168.2.1 timers connect 1
+ address-family ipv4 unicast
+  label vpn export 20
+  rd vpn export 192.168.2.2:2
+  rt vpn import 192.168.2.2:2
+  rt vpn export 192.168.2.2:2
+  export vpn
+  import vpn
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/ldpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+mpls ldp
+ router-id 10.10.10.10
+ !
+ address-family ipv4
+  discovery transport-address 10.10.10.10
+  !
+  interface pe1-eth2
+  exit
+  !
+ exit-address-family
+ !
+exit
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/ospfd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+interface pe1-eth2
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+!
+router ospf
+ router-id 10.10.10.10
+ network 0.0.0.0/0 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/zebra.conf frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/pe1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/pe1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+!
+interface lo
+ ip address 10.10.10.10/32
+!
+interface pe1-eth0 vrf Customer
+ ip address 192.168.1.2/24
+!
+interface pe1-eth1 vrf Service
+ ip address 192.168.2.2/24
+!
+interface pe1-eth2
+ ip address 10.0.1.1/24
+!
+interface pe1-eth3 vrf Customer
+ ip address 192.0.2.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,25 @@
+!
+debug bgp updates
+!
+router bgp 65001
+ bgp router-id 10.10.10.101
+ bgp route-reflector allow-outbound-policy
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 10.10.10.10 remote-as internal
+ neighbor 10.10.10.10 update-source 10.10.10.101
+ neighbor 10.10.10.10 timers 1 3
+ neighbor 10.10.10.10 timers connect 1
+ address-family ipv4 vpn
+  neighbor 10.10.10.10 activate
+  neighbor 10.10.10.10 route-reflector-client
+  neighbor 10.10.10.10 route-map pe1 out
+ exit-address-family
+!
+route-map pe1 permit 10
+ set extcommunity rt 192.168.1.2:2 192.168.2.2:2
+ set community 65001:111 accept-own additive
+ set ip next-hop unchanged
+route-map pe1 permit 20
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/ldpd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+mpls ldp
+ router-id 10.10.10.101
+ !
+ address-family ipv4
+  discovery transport-address 10.10.10.101
+  !
+  interface rr1-eth0
+  exit
+  !
+ exit-address-family
+ !
+exit
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/ospfd.conf frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+interface rr1-eth0
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+!
+router ospf
+ router-id 10.10.10.101
+ network 0.0.0.0/0 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/zebra.conf frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/rr1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/rr1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 10.10.10.101/32
+!
+interface rr1-eth0
+ ip address 10.0.1.2/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_accept_own/test_bgp_accept_own.py frr-frr-8.5/tests/topotests/bgp_accept_own/test_bgp_accept_own.py
--- frr-frr-8.4.2/tests/topotests/bgp_accept_own/test_bgp_accept_own.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_accept_own/test_bgp_accept_own.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,229 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    tgen.add_router("ce1")
+    tgen.add_router("ce2")
+    tgen.add_router("pe1")
+    tgen.add_router("rr1")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["ce1"])
+    switch.add_link(tgen.gears["pe1"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["ce2"])
+    switch.add_link(tgen.gears["pe1"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["pe1"])
+    switch.add_link(tgen.gears["rr1"])
+
+    switch = tgen.add_switch("s4")
+    switch.add_link(tgen.gears["pe1"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    pe1 = tgen.gears["pe1"]
+    rr1 = tgen.gears["rr1"]
+
+    pe1.run("ip link add Customer type vrf table 1001")
+    pe1.run("ip link set up dev Customer")
+    pe1.run("ip link set pe1-eth0 master Customer")
+    pe1.run("ip link add Service type vrf table 1002")
+    pe1.run("ip link set up dev Service")
+    pe1.run("ip link set pe1-eth1 master Service")
+    pe1.run("ip link set pe1-eth3 master Customer")
+    pe1.run("sysctl -w net.mpls.conf.pe1-eth2.input=1")
+    rr1.run("sysctl -w net.mpls.conf.rr1-eth0.input=1")
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_OSPF, os.path.join(CWD, "{}/ospfd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_LDP, os.path.join(CWD, "{}/ldpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_accept_own():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    pe1 = tgen.gears["pe1"]
+    ce2 = tgen.gears["ce2"]
+
+    step("Check if routes are not installed in PE1 from RR1 (due to ORIGINATOR_ID)")
+
+    def _bgp_check_received_routes_due_originator_id():
+        output = json.loads(pe1.vtysh_cmd("show bgp ipv4 vpn summary json"))
+        expected = {"peers": {"10.10.10.101": {"pfxRcd": 0, "pfxSnt": 5}}}
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes_due_originator_id)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert result is None, "Failed, received routes from RR1 regardless ORIGINATOR_ID"
+
+    step("Enable ACCEPT_OWN for RR1")
+
+    pe1.vtysh_cmd(
+        """
+    configure terminal
+    router bgp 65001
+     address-family ipv4 vpn
+      neighbor 10.10.10.101 accept-own
+    """
+    )
+
+    step("Check if we received routes due to ACCEPT_OWN from RR1")
+
+    def _bgp_check_received_routes_with_modified_rts():
+        output = json.loads(pe1.vtysh_cmd("show bgp ipv4 vpn summary json"))
+        expected = {"peers": {"10.10.10.101": {"pfxRcd": 5, "pfxSnt": 5}}}
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes_with_modified_rts)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert (
+        result is None
+    ), "Failed, didn't receive routes from RR1 with ACCEPT_OWN enabled"
+
+    step(
+        "Check if 172.16.255.1/32 is imported into vrf Service due to modified RT list at RR1"
+    )
+
+    def _bgp_check_received_routes_with_changed_rts():
+        output = json.loads(
+            pe1.vtysh_cmd("show bgp vrf Service ipv4 unicast 172.16.255.1/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "community": {"string": "65001:111"},
+                    "extendedCommunity": {
+                        "string": "RT:192.168.1.2:2 RT:192.168.2.2:2"
+                    },
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes_with_changed_rts)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert (
+        result is None
+    ), "Failed, routes are not imported from RR1 with modified RT list"
+
+    step("Check if 192.0.2.0/24 is imported to vrf Service from vrf Customer")
+
+    def _bgp_check_imported_local_routes_from_vrf_service():
+        output = json.loads(
+            pe1.vtysh_cmd("show ip route vrf Service 192.0.2.0/24 json")
+        )
+        expected = {
+            "192.0.2.0/24": [
+                {
+                    "vrfName": "Service",
+                    "table": 1002,
+                    "installed": True,
+                    "selected": True,
+                    "nexthops": [
+                        {
+                            "fib": True,
+                            "vrf": "Customer",
+                            "active": True,
+                        }
+                    ],
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_imported_local_routes_from_vrf_service)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert (
+        result is None
+    ), "Failed, didn't import local route 192.0.2.0/24 from vrf Customer to vrf Service"
+
+    step("Check if 172.16.255.1/32 is announced to CE2")
+
+    def _bgp_check_received_routes_from_pe():
+        output = json.loads(ce2.vtysh_cmd("show ip route 172.16.255.1/32 json"))
+        expected = {
+            "172.16.255.1/32": [
+                {
+                    "protocol": "bgp",
+                    "installed": True,
+                    "nexthops": [{"ip": "192.168.2.2"}],
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes_from_pe)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert result is None, "Failed, didn't receive 172.16.255.1/32 from PE1"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 10.0.0.2 remote-as internal
+ neighbor 10.0.0.2 update-source lo
+ neighbor 10.0.0.2 timers 1 3
+ neighbor 10.0.0.2 timers connect 1
+ neighbor 10.0.0.3 remote-as internal
+ neighbor 10.0.0.3 timers 1 3
+ neighbor 10.0.0.3 timers connect 1
+ neighbor 10.0.0.3 update-source lo
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r1/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r1/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,17 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r1-eth0
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 10
+!
+interface r1-eth1
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 30
+!
+router ospf
+ router-id 10.0.0.1
+ network 0.0.0.0/0 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 10.0.0.1/32
+!
+interface r1-eth0
+ ip address 192.168.12.1/24
+!
+interface r1-eth1
+ ip address 192.168.13.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 10.0.0.1 remote-as internal
+ neighbor 10.0.0.1 timers 1 3
+ neighbor 10.0.0.1 timers connect 1
+ neighbor 192.168.24.4 remote-as external
+ neighbor 192.168.24.4 timers 1 3
+ neighbor 192.168.24.4 timers connect 1
+ neighbor 192.168.24.4 aigp
+ address-family ipv4
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r2/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r2/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r2-eth0
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 10
+!
+router ospf
+ router-id 10.0.0.2
+ network 192.168.12.0/24 area 0
+ network 10.0.0.2/32 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 10.0.0.2/32
+!
+interface r2-eth0
+ ip address 192.168.12.2/24
+!
+interface r2-eth1
+ ip address 192.168.24.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 10.0.0.1 remote-as internal
+ neighbor 10.0.0.1 timers 1 3
+ neighbor 10.0.0.1 timers connect 1
+ neighbor 192.168.35.5 remote-as external
+ neighbor 192.168.35.5 timers 1 3
+ neighbor 192.168.35.5 timers connect 1
+ neighbor 192.168.35.5 aigp
+ address-family ipv4
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r3/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r3/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r3-eth0
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 30
+!
+router ospf
+ router-id 10.0.0.3
+ network 192.168.13.0/24 area 0
+ network 10.0.0.3/32 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 10.0.0.3/32
+!
+interface r3-eth0
+ ip address 192.168.13.3/24
+!
+interface r3-eth1
+ ip address 192.168.35.3/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r4/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r4/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 192.168.24.2 remote-as external
+ neighbor 192.168.24.2 timers 1 3
+ neighbor 192.168.24.2 timers connect 1
+ neighbor 192.168.24.2 aigp
+ neighbor 10.0.0.6 remote-as internal
+ neighbor 10.0.0.6 timers 1 3
+ neighbor 10.0.0.6 timers connect 1
+ neighbor 10.0.0.6 update-source lo
+ address-family ipv4
+  redistribute connected
+  redistribute ospf
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r4/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r4/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r4-eth1
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 20
+!
+router ospf
+ router-id 10.0.0.4
+ network 192.168.46.0/24 area 0
+ network 10.0.0.4/32 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r4/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 10.0.0.4/32
+!
+interface r4-eth0
+ ip address 192.168.24.4/24
+!
+interface r4-eth1
+ ip address 192.168.46.4/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r5/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r5/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 192.168.35.3 remote-as external
+ neighbor 192.168.35.3 timers 1 3
+ neighbor 192.168.35.3 timers connect 1
+ neighbor 192.168.35.3 aigp
+ neighbor 10.0.0.6 remote-as internal
+ neighbor 10.0.0.6 timers 1 3
+ neighbor 10.0.0.6 timers connect 1
+ neighbor 10.0.0.6 update-source lo
+ address-family ipv4
+  redistribute connected
+  redistribute ospf
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r5/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r5/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r5-eth1
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 10
+!
+router ospf
+ router-id 10.0.0.5
+ network 192.168.56.0/24 area 0
+ network 10.0.0.5/32 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r5/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r5/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r5/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 10.0.0.5/32
+!
+interface r5-eth0
+ ip address 192.168.35.5/24
+!
+interface r5-eth1
+ ip address 192.168.56.5/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r6/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r6/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 10.0.0.4 remote-as internal
+ neighbor 10.0.0.4 timers 1 3
+ neighbor 10.0.0.4 timers connect 1
+ neighbor 10.0.0.4 route-reflector-client
+ neighbor 10.0.0.4 update-source lo
+ neighbor 10.0.0.5 remote-as internal
+ neighbor 10.0.0.5 timers 1 3
+ neighbor 10.0.0.5 timers connect 1
+ neighbor 10.0.0.5 route-reflector-client
+ neighbor 10.0.0.5 update-source lo
+ neighbor 192.168.67.7 remote-as internal
+ neighbor 192.168.67.7 timers 1 3
+ neighbor 192.168.67.7 timers connect 1
+ address-family ipv4
+  redistribute ospf
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/ospfd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r6/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/ospfd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r6/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,17 @@
+!
+interface lo
+ ip ospf cost 10
+!
+interface r6-eth0
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 20
+!
+interface r6-eth1
+ ip ospf dead-interval 4
+ ip ospf hello-interval 1
+ ip ospf cost 10
+!
+router ospf
+ router-id 10.0.0.6
+ network 0.0.0.0/0 area 0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r6/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r6/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r6/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface lo
+ ip address 10.0.0.6/32
+!
+interface r6-eth0
+ ip address 192.168.46.6/24
+!
+interface r6-eth1
+ ip address 192.168.56.6/24
+!
+interface r6-eth2
+ ip address 192.168.67.6/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r7/bgpd.conf frr-frr-8.5/tests/topotests/bgp_aigp/r7/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r7/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r7/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ neighbor 192.168.67.6 remote-as internal
+ neighbor 192.168.67.6 timers 1 3
+ neighbor 192.168.67.6 timers connect 1
+ address-family ipv4
+  redistribute connected route-map rmap metric 71
+ exit-address-family
+!
+ip prefix-list p71 seq 5 permit 10.0.0.71/32
+ip prefix-list p72 seq 5 permit 10.0.0.72/32
+!
+route-map rmap permit 10
+ match ip address prefix-list p71
+ set aigp igp-metric
+!
+route-map rmap permit 20
+ match ip address prefix-list p72
+ set aigp 72
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/r7/zebra.conf frr-frr-8.5/tests/topotests/bgp_aigp/r7/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/r7/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/r7/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 10.0.0.7/32
+ ip address 10.0.0.71/32
+ ip address 10.0.0.72/32
+!
+interface r7-eth0
+ ip address 192.168.67.7/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_aigp/test_bgp_aigp.py frr-frr-8.5/tests/topotests/bgp_aigp/test_bgp_aigp.py
--- frr-frr-8.4.2/tests/topotests/bgp_aigp/test_bgp_aigp.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_aigp/test_bgp_aigp.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,224 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+r7 sets aigp-metric for 10.0.0.71/32 to 71, and 72 for 10.0.0.72/32.
+
+r6 receives those routes with aigp-metric TLV.
+
+r2 and r3 receives those routes with aigp-metric TLV increased by 20,
+and 30 appropriately.
+
+r1 receives routes with aigp-metric TLV 91,101 and 92,102 appropriately.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 8):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r3"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["r2"])
+    switch.add_link(tgen.gears["r4"])
+
+    switch = tgen.add_switch("s4")
+    switch.add_link(tgen.gears["r3"])
+    switch.add_link(tgen.gears["r5"])
+
+    switch = tgen.add_switch("s5")
+    switch.add_link(tgen.gears["r4"])
+    switch.add_link(tgen.gears["r6"])
+
+    switch = tgen.add_switch("s6")
+    switch.add_link(tgen.gears["r5"])
+    switch.add_link(tgen.gears["r6"])
+
+    switch = tgen.add_switch("s7")
+    switch.add_link(tgen.gears["r6"])
+    switch.add_link(tgen.gears["r7"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_OSPF, os.path.join(CWD, "{}/ospfd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_aigp():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+    r2 = tgen.gears["r2"]
+    r3 = tgen.gears["r3"]
+    r4 = tgen.gears["r4"]
+    r5 = tgen.gears["r5"]
+
+    def _bgp_converge():
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast 10.0.0.71/32 json"))
+        expected = {
+            "paths": [
+                {
+                    "aigpMetric": 101,
+                    "valid": True,
+                    "bestpath": {"selectionReason": "Router ID"},
+                    "nexthops": [{"hostname": "r2", "accessible": True}],
+                },
+                {
+                    "aigpMetric": 91,
+                    "valid": True,
+                    "nexthops": [{"hostname": "r3", "accessible": True}],
+                },
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    def _bgp_check_aigp_metric(router, prefix, aigp):
+        output = json.loads(
+            router.vtysh_cmd("show bgp ipv4 unicast {} json".format(prefix))
+        )
+        expected = {"paths": [{"aigpMetric": aigp, "valid": True}]}
+        return topotest.json_cmp(output, expected)
+
+    def _bgp_check_aigp_metric_bestpath():
+        output = json.loads(
+            r1.vtysh_cmd(
+                "show bgp ipv4 unicast 10.0.0.64/28 longer-prefixes json detail"
+            )
+        )
+        expected = {
+            "routes": {
+                "10.0.0.71/32": [
+                    {
+                        "aigpMetric": 101,
+                        "valid": True,
+                    },
+                    {
+                        "aigpMetric": 91,
+                        "valid": True,
+                        "bestpath": {"selectionReason": "AIGP"},
+                        "nexthops": [{"hostname": "r3", "accessible": True}],
+                    },
+                ],
+                "10.0.0.72/32": [
+                    {
+                        "aigpMetric": 102,
+                        "valid": True,
+                    },
+                    {
+                        "aigpMetric": 92,
+                        "valid": True,
+                        "bestpath": {"selectionReason": "AIGP"},
+                        "nexthops": [{"hostname": "r3", "accessible": True}],
+                    },
+                ],
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    # Initial converge, AIGP is not involved in best-path selection process
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "can't converge initially"
+
+    # Enable `bgp bestpath aigp`
+    r1.vtysh_cmd(
+        """
+    configure terminal
+        router bgp
+            bgp bestpath aigp
+    """
+    )
+
+    # r4, 10.0.0.71/32 with aigp-metric 71
+    test_func = functools.partial(_bgp_check_aigp_metric, r4, "10.0.0.71/32", 71)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "aigp-metric for 10.0.0.71/32 is not 71"
+
+    # r5, 10.0.0.72/32 with aigp-metric 72
+    test_func = functools.partial(_bgp_check_aigp_metric, r5, "10.0.0.72/32", 72)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "aigp-metric for 10.0.0.72/32 is not 72"
+
+    # r2, 10.0.0.71/32 with aigp-metric 101 (71 + 30)
+    test_func = functools.partial(_bgp_check_aigp_metric, r2, "10.0.0.71/32", 101)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "aigp-metric for 10.0.0.71/32 is not 101"
+
+    # r3, 10.0.0.72/32 with aigp-metric 92 (72 + 20)
+    test_func = functools.partial(_bgp_check_aigp_metric, r3, "10.0.0.72/32", 92)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "aigp-metric for 10.0.0.72/32 is not 92"
+
+    # r1, check if AIGP is considered in best-path selection (lowest wins)
+    test_func = functools.partial(_bgp_check_aigp_metric_bestpath)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "AIGP attribute is not considered in best-path selection"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_as_allow_in/test_bgp_as_allow_in.py frr-frr-8.5/tests/topotests/bgp_as_allow_in/test_bgp_as_allow_in.py
--- frr-frr-8.4.2/tests/topotests/bgp_as_allow_in/test_bgp_as_allow_in.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_as_allow_in/test_bgp_as_allow_in.py	2023-03-13 20:01:47.000000000 +0600
@@ -76,15 +76,6 @@ from lib.topojson import build_topo_from
 
 pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
 
-
-# Reading the data from JSON File for topology creation
-jsonFile = "{}/bgp_as_allow_in.json".format(CWD)
-try:
-    with open(jsonFile, "r") as topoJson:
-        topo = json.load(topoJson)
-except IOError:
-    assert False, "Could not read file {}".format(jsonFile)
-
 # Global variables
 BGP_CONVERGENCE = False
 ADDR_TYPES = check_address_types()
@@ -92,13 +83,6 @@ NETWORK = {"ipv4": "2.2.2.2/32", "ipv6":
 NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
 
 
-def build_topo(tgen):
-    """Build function"""
-
-    # Building topology from json file
-    build_topo_from_json(tgen, topo)
-
-
 def setup_module(mod):
     """
     Sets up the pytest environment
@@ -118,7 +102,11 @@ def setup_module(mod):
     logger.info("Running setup_module to create topology")
 
     # This function initiates the topology build with Topogen...
-    tgen = Topogen(build_topo, mod.__name__)
+    json_file = "{}/bgp_as_allow_in.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+
     # ... and here it calls Mininet initialization functions.
 
     # Starting topology, create tmp files which are loaded to routers
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_basic_functionality_topo1/test_bgp_basic_functionality.py frr-frr-8.5/tests/topotests/bgp_basic_functionality_topo1/test_bgp_basic_functionality.py
--- frr-frr-8.4.2/tests/topotests/bgp_basic_functionality_topo1/test_bgp_basic_functionality.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_basic_functionality_topo1/test_bgp_basic_functionality.py	2023-03-13 20:01:47.000000000 +0600
@@ -121,7 +121,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -1148,9 +1148,9 @@ def test_bgp_with_loopback_with_same_sub
             tgen, addr_type, dut, input_dict_r1, expected=False
         )  # pylint: disable=E1123
         assert result is not True, (
-            "Testcase {} : Failed \n".format(tc_name)
-            + "Expected behavior: routes should not present in fib \n"
-            + "Error: {}".format(result)
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     step("Verify Ipv4 and Ipv6 network installed in r3 RIB but not in FIB")
@@ -1169,9 +1169,9 @@ def test_bgp_with_loopback_with_same_sub
             tgen, addr_type, dut, input_dict_r1, expected=False
         )  # pylint: disable=E1123
         assert result is not True, (
-            "Testcase {} : Failed \n".format(tc_name)
-            + "Expected behavior: routes should not present in fib \n"
-            + "Error: {}".format(result)
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     write_test_footer(tc_name)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_delete/test_bgp_comm-list_delete.py frr-frr-8.5/tests/topotests/bgp_comm_list_delete/test_bgp_comm-list_delete.py
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_delete/test_bgp_comm-list_delete.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_delete/test_bgp_comm-list_delete.py	2023-03-13 20:01:47.000000000 +0600
@@ -34,11 +34,13 @@ import os
 import sys
 import json
 import pytest
+import functools
 
 CWD = os.path.dirname(os.path.realpath(__file__))
 sys.path.append(os.path.join(CWD, "../"))
 
 # pylint: disable=C0413
+from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
 
 pytestmark = [pytest.mark.bgpd]
@@ -81,30 +83,34 @@ def test_bgp_maximum_prefix_invalid():
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    def _bgp_converge(router):
-        while True:
-            output = json.loads(
-                tgen.gears[router].vtysh_cmd("show ip bgp neighbor 192.168.255.1 json")
-            )
-            if output["192.168.255.1"]["bgpState"] == "Established":
-                if (
-                    output["192.168.255.1"]["addressFamilyInfo"]["ipv4Unicast"][
-                        "acceptedPrefixCounter"
-                    ]
-                    == 2
-                ):
-                    return True
-
-    def _bgp_comm_list_delete(router):
-        output = json.loads(
-            tgen.gears[router].vtysh_cmd("show ip bgp 172.16.255.254/32 json")
-        )
-        if "333:333" in output["paths"][0]["community"]["list"]:
-            return False
-        return True
+    r2 = tgen.gears["r2"]
 
-    if _bgp_converge("r2"):
-        assert _bgp_comm_list_delete("r2") == True
+    def _bgp_converge():
+        output = json.loads(r2.vtysh_cmd("show ip bgp neighbor 192.168.255.1 json"))
+        expected = {
+            "192.168.255.1": {
+                "bgpState": "Established",
+                "addressFamilyInfo": {
+                    "ipv4Unicast": {
+                        "acceptedPrefixCounter": 2,
+                    }
+                },
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge initially"
+
+    def _bgp_comm_list_delete():
+        output = json.loads(r2.vtysh_cmd("show ip bgp 172.16.255.254/32 json"))
+        expected = {"paths": [{"community": {"list": ["333:333"]}}]}
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_comm_list_delete)
+    _, result = topotest.run_and_expect(test_func, not None, count=60, wait=0.5)
+    assert result is not None, "333:333 community SHOULD be stripped from r1"
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_comm_list_match/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_match/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,23 @@
+!
+router bgp 65001
+ no bgp ebgp-requires-policy
+ neighbor 192.168.0.2 remote-as external
+ neighbor 192.168.0.2 timers 1 3
+ neighbor 192.168.0.2 timers connect 1
+ address-family ipv4
+  redistribute connected
+  neighbor 192.168.0.2 route-map r2 out
+ exit-address-family
+!
+ip prefix-list p1 seq 5 permit 172.16.255.1/32
+ip prefix-list p3 seq 5 permit 172.16.255.3/32
+!
+route-map r2 permit 10
+ match ip address prefix-list p1
+ set community 65001:1 65001:2
+route-map r2 permit 20
+ match ip address prefix-list p3
+ set community 65001:3
+route-map r2 permit 30
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_comm_list_match/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_match/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+!
+interface lo
+ ip address 172.16.255.1/32
+ ip address 172.16.255.2/32
+ ip address 172.16.255.3/32
+!
+interface r1-eth0
+ ip address 192.168.0.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_comm_list_match/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_match/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,21 @@
+!
+debug bgp updates
+!
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 192.168.0.1 remote-as external
+ neighbor 192.168.0.1 timers 1 3
+ neighbor 192.168.0.1 timers connect 1
+ address-family ipv4
+  neighbor 192.168.0.1 route-map r1 in
+  neighbor 192.168.0.1 soft-reconfiguration inbound
+ exit-address-family
+!
+bgp community-list 1 seq 5 permit 65001:1 65001:2
+bgp community-list 1 seq 10 permit 65001:3
+!
+route-map r1 deny 10
+ match community 1
+route-map r1 permit 20
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_comm_list_match/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_match/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+!
+interface r2-eth0
+ ip address 192.168.0.2/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/test_bgp_comm_list_match.py frr-frr-8.5/tests/topotests/bgp_comm_list_match/test_bgp_comm_list_match.py
--- frr-frr-8.4.2/tests/topotests/bgp_comm_list_match/test_bgp_comm_list_match.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_comm_list_match/test_bgp_comm_list_match.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,119 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Check if BGP community-list works as OR if multiple community entries specified,
+like:
+
+bgp community-list 1 seq 5 permit 65001:1 65002:2
+bgp community-list 1 seq 10 permit 65001:3
+!
+route-map test deny 10
+ match community 1
+route-map test permit 20
+
+Here, we should deny routes in/out if the path has:
+(65001:1 AND 65001:2) OR 65001:3.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 3):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_comm_list_match():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    router = tgen.gears["r2"]
+
+    def _bgp_converge():
+        output = json.loads(
+            router.vtysh_cmd(
+                "show bgp ipv4 unicast neighbors 192.168.0.1 filtered-routes json"
+            )
+        )
+        expected = {
+            "receivedRoutes": {
+                "172.16.255.1/32": {
+                    "path": "65001",
+                },
+                "172.16.255.3/32": {
+                    "path": "65001",
+                },
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    step("Initial BGP converge")
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to filter BGP UPDATES with community-list on R2"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_communities_topo1/test_bgp_communities.py frr-frr-8.5/tests/topotests/bgp_communities_topo1/test_bgp_communities.py
--- frr-frr-8.4.2/tests/topotests/bgp_communities_topo1/test_bgp_communities.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_communities_topo1/test_bgp_communities.py	2023-03-13 20:01:47.000000000 +0600
@@ -83,7 +83,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >= 4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -317,17 +317,18 @@ def test_bgp_no_advertise_community_p0(r
         )
 
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict, expected=False)
-        assert result is not True, "Testcase {} : Failed \n ".format(
-            tc_name
-        ) + " Routes still present in R3 router. Error: {}".format(result)
+        assert result is not True, (
+            "Testcase {} : Failed \n Expected: "
+            "Routes still present in {} router. Found: {}".format(tc_name, dut, result)
+        )
 
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n  Routes still present in R3 router. Error: {}".format(
-            tc_name, result
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} router. Found: {}".format(
+            tc_name, dut, result
         )
 
         step("Remove and Add no advertise community")
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_communities_topo1/test_bgp_communities_topo2.py frr-frr-8.5/tests/topotests/bgp_communities_topo1/test_bgp_communities_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_communities_topo1/test_bgp_communities_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_communities_topo1/test_bgp_communities_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -87,7 +87,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.14")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >= 4.14")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -305,8 +305,10 @@ def test_bgp_no_export_local_as_and_inte
                     ],
                     expected=False,
                 )
-                assert result is not True, "Testcase {} : Failed \n Error: {}".format(
-                    tc_name, result
+                assert result is not True, (
+                    "Testcase {} : Failed \n "
+                    "Expected: Routes are still present in rib of r3 \n "
+                    "Found: {}".format(tc_name, result)
                 )
 
         step("Remove route-map from redistribute static on R1")
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgp_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgp_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgp_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgp_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,63 @@
+{
+ "vrfId":0,
+ "vrfName":"default",
+ "routerId":"203.0.113.1",
+ "defaultLocPrf":100,
+ "localAS":100,
+ "routes":{"203.0.113.0/28":[
+  {
+    "network":"203.0.113.0\/28",
+    "peerId":"(unspec)",
+    "path":"",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"0.0.0.0",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.16/28":[
+  {
+    "network":"203.0.113.16\/28",
+    "peerId":"192.0.2.2",
+    "path":"300",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.2",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.32/28":[
+  {
+    "network":"203.0.113.32\/28",
+    "peerId":"192.0.2.2",
+    "path":"300",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.2",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.48/28":[
+  {
+    "network":"203.0.113.48\/28",
+    "peerId":"192.0.2.2",
+    "path":"300 400",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.2",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+] }  }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgp_summary.json frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgp_summary.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgp_summary.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgp_summary.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+{
+    "ipv4Unicast":{
+      "routerId":"203.0.113.1",
+      "as":100,
+      "peers":{
+        "192.0.2.2":{
+          "remoteAs": 300,
+          "state": "Established",
+          "peerState":"OK"  
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+debug bgp neighbor-events
+debug bgp nht
+debug bgp updates in
+debug bgp updates out
+!
+router bgp 100
+ no bgp ebgp-requires-policy
+!
+ neighbor 192.0.2.2 remote-as 300
+ address-family ipv4 unicast
+  network 203.0.113.0/28
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_confed1/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+interface r1-eth0
+ ip address 192.0.2.1/28
+!
+interface lo
+ ip address 203.0.113.1/28
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgp_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgp_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgp_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgp_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,63 @@
+{
+ "vrfId":0,
+ "vrfName":"default",
+ "routerId":"203.0.113.17",
+ "defaultLocPrf":100,
+ "localAS":200,
+ "routes":{"203.0.113.0/28": [
+  {
+    "network":"203.0.113.0\/28",
+    "peerId":"192.0.2.1",
+    "path":"100",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.1",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.16/28":[
+  {
+    "network":"203.0.113.16\/28",
+    "peerId":"(unspec)",
+    "path":"",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"0.0.0.0",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.32/28":[
+  {
+    "network":"203.0.113.32\/28",
+    "peerId":"192.0.2.18",
+    "path":"(300)",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.18",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.48/28":[
+  {
+    "network":"203.0.113.48\/28",
+    "peerId":"192.0.2.18",
+    "path":"(300) 400",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.50",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+] } }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgp_summary.json frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgp_summary.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgp_summary.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgp_summary.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+{
+    "ipv4Unicast":{
+    "routerId":"203.0.113.17",
+    "as":200,
+    "peers":{
+      "192.0.2.1":{
+        "remoteAs":100,
+         "state":"Established",
+         "peerState":"OK"
+      },
+      "192.0.2.18":{
+        "remoteAs":300,
+         "state":"Established",
+         "peerState":"OK"
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+debug bgp neighbor-events
+debug bgp nht
+debug bgp updates in
+debug bgp updates out
+!
+router bgp 200
+ no bgp ebgp-requires-policy
+ bgp confederation identifier 300
+ bgp confederation peers 300
+ neighbor 192.0.2.1 remote-as 100
+ neighbor 192.0.2.18 remote-as 300
+ !
+ address-family ipv4 unicast
+  network 203.0.113.16/28
+  neighbor 192.0.2.18 default-originate
+ exit-address-family
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/isisd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r2/isisd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/isisd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r2/isisd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+interface r2-eth1
+ ip router isis 1
+ isis circuit-type level-2-only
+
+router isis 1
+ is-type level-2-only
+ net 49.0001.0002.0002.0002.00
+ redistribute ipv4 connected level-2
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_confed1/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+interface r2-eth0
+ ip address 192.0.2.2/28
+!
+interface r2-eth1
+ ip address 192.0.2.17/28
+!
+interface lo
+ ip address 203.0.113.17/28
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgp_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgp_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgp_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgp_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,77 @@
+{
+ "vrfId":0,
+ "vrfName":"default",
+ "routerId":"203.0.113.33",
+ "defaultLocPrf":100,
+ "localAS":300,
+ "routes":{"0.0.0.0/0":[
+  {
+    "network":"0.0.0.0\/0",
+    "peerId":"192.0.2.17",
+    "path":"(200)",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.17",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.0/28":[
+  {
+    "network":"203.0.113.0\/28",
+    "peerId":"192.0.2.17",
+    "path":"(200) 100",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.1",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.16/28":[
+  {
+    "network":"203.0.113.16\/28",
+    "peerId":"192.0.2.17",
+    "path":"(200)",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.17",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.32/28":[
+  {
+    "network":"203.0.113.32\/28",
+    "peerId":"(unspec)",
+    "path":"",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"0.0.0.0",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.48/28":[
+  {
+    "network":"203.0.113.48\/28",
+    "peerId":"192.0.2.50",
+    "path":"400",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.50",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+] } }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgp_summary.json frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgp_summary.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgp_summary.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgp_summary.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+{
+    "ipv4Unicast":{
+    "routerId":"203.0.113.33",
+    "as":300,
+    "peers":{
+      "192.0.2.17":{
+        "remoteAs":200,
+         "state":"Established",
+         "peerState":"OK"
+      },
+      "192.0.2.50":{
+        "remoteAs":400,
+         "state":"Established",
+         "peerState":"OK"
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,17 @@
+debug bgp neighbor-events
+debug bgp nht
+debug bgp updates in
+debug bgp updates out
+!
+router bgp 300
+ no bgp ebgp-requires-policy
+ bgp confederation identifier 300
+ bgp confederation peers 200
+ neighbor 192.0.2.17 remote-as 200
+ neighbor 192.0.2.50 remote-as 400
+!
+ address-family ipv4 unicast
+  network 203.0.113.32/28
+ exit-address-family
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/isisd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r3/isisd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/isisd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r3/isisd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+interface r3-eth1
+ ip router isis 1
+ isis circuit-type level-2-only
+
+router isis 1
+ is-type level-2-only
+ net 49.0001.0003.0003.0003.00
+ redistribute ipv4 connected level-2
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_confed1/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface r3-eth0
+ ip address 192.0.2.49/28
+!
+interface r3-eth1
+ ip address 192.0.2.18/28
+!
+interface lo
+ ip address 203.0.113.33/28
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgp_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgp_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgp_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgp_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,77 @@
+{
+ "vrfId":0,
+ "vrfName":"default",
+ "routerId":"203.0.113.49",
+ "defaultLocPrf":100,
+ "localAS":400,
+ "routes":{"0.0.0.0/0":[
+  {
+    "network":"0.0.0.0\/0",
+    "peerId":"192.0.2.49",
+    "path":"300",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.49",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.0/28":[
+  {
+    "network":"203.0.113.0\/28",
+    "peerId":"192.0.2.49",
+    "path":"300 100",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.49",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.16/28":[
+  {
+    "network":"203.0.113.16\/28",
+    "peerId":"192.0.2.49",
+    "path":"300",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.49",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.32/28":[
+  {
+    "network":"203.0.113.32\/28",
+    "peerId":"192.0.2.49",
+    "path":"300",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"192.0.2.49",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+],"203.0.113.48/28":[
+  {
+    "network":"203.0.113.48\/28",
+    "peerId":"(unspec)",
+    "path":"",
+    "origin":"IGP",
+    "nexthops":[
+      {
+        "ip":"0.0.0.0",
+        "afi":"ipv4",
+        "used":true
+      }
+    ]
+  }
+] } }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgp_summary.json frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgp_summary.json
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgp_summary.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgp_summary.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+{
+    "ipv4Unicast":{
+    "routerId":"203.0.113.49",	
+    "as":400,
+    "peers":{
+      "192.0.2.49":{
+        "remoteAs":300,
+         "state":"Established",
+         "peerState":"OK"
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r4/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+debug bgp neighbor-events
+debug bgp nht
+debug bgp updates in
+debug bgp updates out
+!
+router bgp 400
+ no bgp ebgp-requires-policy
+ bgp disable-ebgp-connected-route-check
+!
+ neighbor 192.0.2.49 remote-as 300
+ address-family ipv4 unicast
+  network 203.0.113.48/28
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/zebra.conf frr-frr-8.5/tests/topotests/bgp_confed1/r4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/r4/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/r4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+interface r4-eth0
+ ip address 192.0.2.50/28
+!
+interface lo
+ ip address 203.0.113.49/28
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confed1/test_bgp_confed1.py frr-frr-8.5/tests/topotests/bgp_confed1/test_bgp_confed1.py
--- frr-frr-8.4.2/tests/topotests/bgp_confed1/test_bgp_confed1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confed1/test_bgp_confed1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,129 @@
+#!/usr/bin/env python
+
+#
+# test_bgp_confed1.py
+#
+# Copyright 2022 6WIND S.A.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND 6WIND DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL 6WIND BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+test_bgp_confed1.py: Test the FRR BGP confederations with AS member
+same as confederation Id, verify BGP prefixes and path distribution  
+"""
+
+import os
+import sys
+import json
+from functools import partial
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 5):  
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["r3"])
+    switch.add_link(tgen.gears["r4"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r2"])
+    switch.add_link(tgen.gears["r3"])
+
+def setup_module(mod):
+
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+    for rname, router in router_list.items():
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_ISIS, os.path.join(CWD, "{}/isisd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    # Initialize all routers.
+    tgen.start_router()
+
+def teardown_module(_mod):
+    "Teardown the pytest environment"
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_convergence():
+    "Assert that BGP is converging."
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("waiting for bgp peers to go up")
+
+    for router in tgen.routers().values():
+        ref_file = "{}/{}/bgp_summary.json".format(CWD, router.name)
+        expected = json.loads(open(ref_file).read())
+        test_func = partial(
+            topotest.router_json_cmp, router, "show ip bgp summary json", expected
+        )
+        _, res = topotest.run_and_expect(test_func, None, count=125, wait=2.0)
+        assertmsg = "{}: bgp did not converge".format(router.name)
+        assert res is None, assertmsg
+
+
+def test_bgp_confed_ipv4_unicast():
+    "Assert that BGP is exchanging BGP route."
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("waiting for bgp peers exchanging UPDATES")
+
+    for router in tgen.routers().values():
+        ref_file = "{}/{}/bgp_ipv4_unicast.json".format(CWD, router.name)
+        expected = json.loads(open(ref_file).read())
+        test_func = partial(
+            topotest.router_json_cmp, router, "show bgp ipv4 unicast json", expected
+        )
+        _, res = topotest.run_and_expect(test_func, None, count=40, wait=2.5)
+        assertmsg = "{}: BGP UPDATE exchange failure".format(router.name)
+        assert res is None, assertmsg
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ bgp confederation identifier 65300
+ bgp confederation peers 65002 65003
+ neighbor fabric peer-group
+ neighbor fabric remote-as external
+ neighbor 192.168.1.2 peer-group fabric
+ neighbor 192.168.2.2 remote-as external
+ address-family ipv4 unicast
+  neighbor fabric activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+int r1-eth0
+ ip address 192.168.1.1/24
+!
+int r1-eth1
+ ip address 192.168.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ bgp confederation identifier 65300
+ bgp confederation peers 65001
+ neighbor fabric peer-group
+ neighbor fabric remote-as external
+ neighbor 192.168.1.1 peer-group fabric
+ address-family ipv4 unicast
+  network 172.16.255.254/32
+  neighbor fabric activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+int r2-eth0
+ ip address 192.168.1.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+router bgp 65003
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ bgp confederation identifier 65300
+ bgp confederation peers 65001
+ neighbor 192.168.2.1 remote-as external
+ address-family ipv4 unicast
+  network 172.16.255.254/32
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_confederation_astype/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+int r3-eth0
+ ip address 192.168.2.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/test_bgp_confederation_astype.py frr-frr-8.5/tests/topotests/bgp_confederation_astype/test_bgp_confederation_astype.py
--- frr-frr-8.4.2/tests/topotests/bgp_confederation_astype/test_bgp_confederation_astype.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_confederation_astype/test_bgp_confederation_astype.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,140 @@
+#!/usr/bin/env python
+# SPDX-License-Identifier: ISC
+
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+
+"""
+Test if BGP confederation works properly when using
+remote-as internal/external.
+
+Also, check if the same works with peer-groups as well.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+pytestmark = pytest.mark.bgpd
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def setup_module(mod):
+    topodef = {"s1": ("r1", "r2"), "s2": ("r1", "r3")}
+    tgen = Topogen(topodef, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_confederation_astype():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+
+    def _bgp_converge():
+        output = json.loads(r1.vtysh_cmd("show bgp summary json"))
+        expected = {
+            "ipv4Unicast": {
+                "peerCount": 2,
+                "peers": {
+                    "192.168.1.2": {
+                        "hostname": "r2",
+                        "remoteAs": 65002,
+                        "localAs": 65001,
+                        "pfxRcd": 1,
+                        "state": "Established",
+                    },
+                    "192.168.2.2": {
+                        "hostname": "r3",
+                        "remoteAs": 65003,
+                        "localAs": 65001,
+                        "pfxRcd": 1,
+                        "state": "Established",
+                    },
+                },
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge"
+
+    def _bgp_check_neighbors():
+        output = json.loads(r1.vtysh_cmd("show bgp neighbors json"))
+        expected = {
+            "192.168.1.2": {
+                "nbrCommonAdmin": True,
+                "nbrConfedExternalLink": True,
+                "hostname": "r2",
+            },
+            "192.168.2.2": {
+                "nbrCommonAdmin": True,
+                "nbrConfedExternalLink": True,
+                "hostname": "r3",
+            },
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_neighbors)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't see neighbors to be in BGP confederation"
+
+    def _bgp_check_routes():
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast json"))
+        expected = {
+            "routes": {
+                "172.16.255.254/32": [
+                    {
+                        "valid": True,
+                        "pathFrom": "external",
+                        "path": "(65003)",
+                    },
+                    {
+                        "valid": True,
+                        "pathFrom": "external",
+                        "path": "(65002)",
+                    },
+                ]
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_routes)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't see routes to be in BGP confederation"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.2 remote-as external
+ neighbor 192.168.1.2 timers 1 3
+ neighbor 192.168.1.2 timers connect 1
+ neighbor 192.168.2.2 remote-as external
+ neighbor 192.168.2.2 timers 1 3
+ neighbor 192.168.2.2 timers connect 1
+ address-family ipv4
+  neighbor 192.168.1.2 default-originate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+interface r1-eth0
+ ip address 192.168.1.1/24
+!
+interface r1-eth1
+ ip address 192.168.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as external
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
+ address-family ipv4 unicast
+  network 192.168.2.0/24
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r2-eth0
+ ip address 192.168.1.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+router bgp 65003
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as external
+ neighbor 192.168.2.1 timers 1 3
+ neighbor 192.168.2.1 timers connect 1
+ address-family ipv4 unicast
+  network 0.0.0.0/0
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,5 @@
+!
+interface r3-eth0
+ ip address 192.168.2.2/24
+!
+ip route 0.0.0.0/0 Null0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/test_bgp_default_originate_withdraw.py frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/test_bgp_default_originate_withdraw.py
--- frr-frr-8.4.2/tests/topotests/bgp_default_originate_withdraw/test_bgp_default_originate_withdraw.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_default_originate_withdraw/test_bgp_default_originate_withdraw.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,159 @@
+#!/usr/bin/env python
+# SPDX-License-Identifier: ISC
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+
+"""
+Check if bgpd do not crash if we use default-originate while
+received a default route from the neighbor as well. 0.0.0.0/0
+MUST be kept in RIB even if we remove default-originate from
+the neighbor.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 4):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r3"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_default_originate_with_default_received():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+
+    def _bgp_default_received_from_r3():
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast 0.0.0.0/0 json"))
+        expected = {
+            "paths": [
+                {
+                    "nexthops": [
+                        {
+                            "hostname": "r3",
+                            "ip": "192.168.2.2",
+                        }
+                    ],
+                }
+            ],
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_default_received_from_r3)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Cannot see default route received from r3"
+
+    def _bgp_advertised_default_originate_to_r2():
+        output = json.loads(
+            r1.vtysh_cmd(
+                "show bgp ipv4 unicast neighbors 192.168.1.2 advertised-routes json"
+            )
+        )
+        expected = {
+            "bgpOriginatingDefaultNetwork": "0.0.0.0/0",
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_advertised_default_originate_to_r2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Cannot see default-originate route advertised to r2"
+
+    step("Disable default-originate for r2")
+    r1.vtysh_cmd(
+        """
+    configure
+        router bgp
+            address-family ipv4 unicast
+                no neighbor 192.168.1.2 default-originate
+    """
+    )
+
+    def _bgp_advertised_default_from_r3_to_r2():
+        output = json.loads(
+            r1.vtysh_cmd(
+                "show bgp ipv4 unicast neighbors 192.168.1.2 advertised-routes json"
+            )
+        )
+        expected = {
+            "bgpOriginatingDefaultNetwork": None,
+            "advertisedRoutes": {
+                "0.0.0.0/0": {
+                    "valid": True,
+                }
+            },
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_advertised_default_from_r3_to_r2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Cannot see default route advertised to r2"
+
+    step("Enable default-originate for r2")
+    r1.vtysh_cmd(
+        """
+    configure
+        router bgp
+            address-family ipv4 unicast
+                neighbor 192.168.1.2 default-originate
+    do clear ip bgp *
+    """
+    )
+
+    step("Check if default-originate route advertised to r2")
+    test_func = functools.partial(_bgp_advertised_default_originate_to_r2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Cannot see default-originate route advertised to r2"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,12 @@
 !
+debug bgp neighbor
+!
 router bgp 65001
  no bgp ebgp-requires-policy
+ bgp default show-hostname
+ bgp default show-nexthop-hostname
  neighbor 192.168.1.2 remote-as external
+ neighbor 192.168.1.2 timers 1 3
+ neighbor 192.168.1.2 timers connect 1
  neighbor 192.168.1.2 dont-capability-negotiate
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/r2/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,8 @@
 router bgp 65002
  no bgp ebgp-requires-policy
  neighbor 192.168.1.1 remote-as external
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
  address-family ipv4 unicast
   redistribute connected
  exit-address-family
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/test_bgp_dont_capability_negotiate.py frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/test_bgp_dont_capability_negotiate.py
--- frr-frr-8.4.2/tests/topotests/bgp_dont_capability_negotiate/test_bgp_dont_capability_negotiate.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_dont_capability_negotiate/test_bgp_dont_capability_negotiate.py	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ sys.path.append(os.path.join(CWD, "../")
 # pylint: disable=C0413
 from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
 
 pytestmark = [pytest.mark.bgpd]
 
@@ -64,32 +65,104 @@ def teardown_module(mod):
     tgen.stop_topology()
 
 
+def bgp_converge(router):
+    output = json.loads(router.vtysh_cmd("show bgp ipv4 unicast summary json"))
+    expected = {
+        "peers": {
+            "192.168.1.2": {
+                "pfxRcd": 2,
+                "pfxSnt": 2,
+                "state": "Established",
+                "peerState": "OK",
+            }
+        }
+    }
+    return topotest.json_cmp(output, expected)
+
+
 def test_bgp_dont_capability_negotiate():
     tgen = get_topogen()
 
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    router = tgen.gears["r1"]
+    r1 = tgen.gears["r1"]
+
+    test_func = functools.partial(bgp_converge, r1)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge with dont-capability-negotiate"
+
+
+def test_bgp_check_fqdn():
+    tgen = get_topogen()
 
-    def _bgp_converge(router):
-        output = json.loads(router.vtysh_cmd("show bgp ipv4 unicast summary json"))
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+    r2 = tgen.gears["r2"]
+
+    def _bgp_check_fqdn(fqdn=None):
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast 172.16.16.1/32 json"))
         expected = {
-            "peers": {
-                "192.168.1.2": {
-                    "pfxRcd": 2,
-                    "pfxSnt": 2,
-                    "state": "Established",
-                    "peerState": "OK",
+            "paths": [
+                {
+                    "nexthops": [
+                        {
+                            "hostname": fqdn,
+                        }
+                    ],
+                    "peer": {
+                        "hostname": fqdn,
+                    },
                 }
-            }
+            ]
         }
         return topotest.json_cmp(output, expected)
 
-    test_func = functools.partial(_bgp_converge, router)
-    success, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    step("Enable all capabilities")
+    r1.vtysh_cmd(
+        """
+    configure terminal
+        router bgp
+            address-family ipv4 unicast
+                no neighbor 192.168.1.2 dont-capability-negotiate
+    end
+    clear bgp 192.168.1.2
+    """
+    )
+
+    step("Wait to converge")
+    test_func = functools.partial(bgp_converge, r1)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge with dont-capability-negotiate"
+
+    test_func = functools.partial(_bgp_check_fqdn, "r2")
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "FQDN capability enabled, but r1 can't see it"
+
+    step("Disable sending any capabilities from r2")
+    r2.vtysh_cmd(
+        """
+    configure terminal
+        router bgp
+            address-family ipv4 unicast
+                neighbor 192.168.1.1 dont-capability-negotiate
+    end
+    clear bgp 192.168.1.1
+    """
+    )
+
+    step("Wait to converge")
+    test_func = functools.partial(bgp_converge, r1)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
     assert result is None, "Can't converge with dont-capability-negotiate"
 
+    step("Make sure FQDN capability is reset")
+    test_func = functools.partial(_bgp_check_fqdn)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "FQDN capability disabled, but we still have a hostname"
+
 
 if __name__ == "__main__":
     args = ["-s"] + sys.argv[1:]
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo2/test_ebgp_ecmp_topo2.py frr-frr-8.5/tests/topotests/bgp_ecmp_topo2/test_ebgp_ecmp_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo2/test_ebgp_ecmp_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ecmp_topo2/test_ebgp_ecmp_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -90,7 +90,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -436,7 +436,9 @@ def test_ecmp_remove_redistribute_static
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     logger.info("Enable redistribute static")
     input_dict_2 = {
@@ -621,7 +623,9 @@ def test_ecmp_remove_static_route(reques
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     for addr_type in ADDR_TYPES:
         # Enable static routes
@@ -727,7 +731,9 @@ def test_ecmp_remove_nw_advertise(reques
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     static_or_nw(tgen, topo, tc_name, "advertise_nw", "r2")
     for addr_type in ADDR_TYPES:
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo2/test_ibgp_ecmp_topo2.py frr-frr-8.5/tests/topotests/bgp_ecmp_topo2/test_ibgp_ecmp_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo2/test_ibgp_ecmp_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ecmp_topo2/test_ibgp_ecmp_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -90,7 +90,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -437,7 +437,9 @@ def test_ecmp_remove_redistribute_static
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     logger.info("Enable redistribute static")
     input_dict_2 = {
@@ -622,7 +624,9 @@ def test_ecmp_remove_static_route(reques
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     for addr_type in ADDR_TYPES:
         # Enable static routes
@@ -730,7 +734,9 @@ def test_ecmp_remove_nw_advertise(reques
         )
         assert (
             result is not True
-        ), "Testcase {} : Failed \n Routes still" " present in RIB".format(tc_name)
+        ), "Testcase {} : Failed \n  Expected: Routes still present in {} RIB. Found: {}".format(
+            tc_name, dut, result
+        )
 
     static_or_nw(tgen, topo, tc_name, "advertise_nw", "r2")
     for addr_type in ADDR_TYPES:
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo3/test_ibgp_ecmp_topo3.py frr-frr-8.5/tests/topotests/bgp_ecmp_topo3/test_ibgp_ecmp_topo3.py
--- frr-frr-8.4.2/tests/topotests/bgp_ecmp_topo3/test_ibgp_ecmp_topo3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ecmp_topo3/test_ibgp_ecmp_topo3.py	2023-03-13 20:01:47.000000000 +0600
@@ -39,8 +39,7 @@ sys.path.append(os.path.join(CWD, "../..
 
 # pylint: disable=C0413
 # Import topogen and topotest helpers
-from lib.topogen import get_topogen
-from lib import topojson
+from lib.topogen import Topogen, get_topogen
 
 from lib.common_config import (
     write_test_header,
@@ -51,11 +50,12 @@ from lib.common_config import (
     reset_config_on_routers,
     shutdown_bringup_interface,
     apply_raw_config,
+    start_topology,
 )
 from lib.topolog import logger
+from lib.topojson import build_config_from_json
 from lib.bgp import create_router_bgp, verify_bgp_convergence
 
-
 pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
 
 
@@ -78,9 +78,19 @@ def setup_module(mod):
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
     logger.info("=" * 40)
 
-    tgen = topojson.setup_module_from_json(mod.__file__)
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/ibgp_ecmp_topo3.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
     topo = tgen.json_topo
 
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
     # Don't run this test if we have any failure.
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
@@ -240,17 +250,18 @@ def test_ecmp_fast_convergence(request,
     logger.info("Ensure BGP has processed the cli")
     r2 = tgen.gears["r2"]
     output = r2.vtysh_cmd("show run")
-    verify = re.search(r"fast-convergence", output )
-    assert verify is not None, (
-        "r2 does not have the fast convergence command yet")
+    verify = re.search(r"fast-convergence", output)
+    assert verify is not None, "r2 does not have the fast convergence command yet"
 
     logger.info("Shutdown one link b/w r2 and r3")
     shutdown_bringup_interface(tgen, "r2", intf1, False)
 
     logger.info("Verify bgp neighbors goes down immediately")
     result = verify_bgp_convergence(tgen, topo, dut="r2", expected=False)
-    assert result is not True, "Testcase {} : Failed \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: BGP should not be converged for {} \n "
+        "Found: {}".format(tc_name, "r2", result)
     )
 
     logger.info("Shutdown second link b/w r2 and r3")
@@ -258,8 +269,10 @@ def test_ecmp_fast_convergence(request,
 
     logger.info("Verify bgp neighbors goes down immediately")
     result = verify_bgp_convergence(tgen, topo, dut="r2", expected=False)
-    assert result is not True, "Testcase {} : Failed \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: BGP should not be converged for {} \n "
+        "Found: {}".format(tc_name, "r2", result)
     )
 
     write_test_footer(tc_name)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_features/test_bgp_features.py frr-frr-8.5/tests/topotests/bgp_features/test_bgp_features.py
--- frr-frr-8.4.2/tests/topotests/bgp_features/test_bgp_features.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_features/test_bgp_features.py	2023-03-13 20:01:47.000000000 +0600
@@ -785,7 +785,7 @@ def test_bgp_delayopen_without():
         test_func = functools.partial(
             topotest.router_json_cmp, router, "show ip bgp summary json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "BGP session on r{} did not shut down peer".format(router_num)
         assert res is None, assertmsg
 
@@ -862,7 +862,7 @@ def test_bgp_delayopen_singular():
         test_func = functools.partial(
             topotest.router_json_cmp, router, "show ip bgp summary json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "BGP session on r{} did not shut down peer".format(router_num)
         assert res is None, assertmsg
 
@@ -880,7 +880,7 @@ def test_bgp_delayopen_singular():
     test_func = functools.partial(
         topotest.router_json_cmp, router, "show bgp neighbors json", expected
     )
-    _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+    _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
     assertmsg = "BGP session on r1 failed to set DelayOpenTime for r4"
     assert res is None, assertmsg
 
@@ -974,7 +974,7 @@ def test_bgp_delayopen_dual():
         test_func = functools.partial(
             topotest.router_json_cmp, router, "show ip bgp summary json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "BGP session on r{} did not shut down peer".format(router_num)
         assert res is None, assertmsg
 
@@ -1003,7 +1003,7 @@ def test_bgp_delayopen_dual():
         test_func = functools.partial(
             topotest.router_json_cmp, router, "show bgp neighbors json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "BGP session on r{} failed to set DelayOpenTime".format(router_num)
         assert res is None, assertmsg
 
@@ -1032,7 +1032,7 @@ def test_bgp_delayopen_dual():
         test_func = functools.partial(
             topotest.router_json_cmp, router, "show ip bgp summary json", expected
         )
-        _, res = topotest.run_and_expect(test_func, None, count=3, wait=1)
+        _, res = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = "BGP session on r{} did not enter Connect state with peer".format(
             router_num
         )
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-1.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-1.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-1.py	2023-03-13 20:01:47.000000000 +0600
@@ -160,7 +160,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -1033,11 +1033,9 @@ def test_BGP_GR_TC_4_p0(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         result = verify_rib(
@@ -1045,9 +1043,9 @@ def test_BGP_GR_TC_4_p0(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Phase 5] : R2 is about to come up now  ")
     start_router_daemons(tgen, "r2", ["bgpd"])
@@ -1506,10 +1504,10 @@ def test_BGP_GR_TC_6_1_2_p1(request):
         result = verify_r_bit(
             tgen, topo, addr_type, input_dict, dut="r2", peer="r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r2: R-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: R-bit should not be set to True in r2\n"
+            "Found: {}".format(tc_name, result)
         )
 
     logger.info("Restart BGPd on R2 ")
@@ -1528,10 +1526,10 @@ def test_BGP_GR_TC_6_1_2_p1(request):
         result = verify_r_bit(
             tgen, topo, addr_type, input_dict, dut="r2", peer="r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r2: R-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: R-bit should not be set to True in r2\n"
+            "Found: {}".format(tc_name, result)
         )
 
     write_test_footer(tc_name)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-2.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-2.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-2.py	2023-03-13 20:01:47.000000000 +0600
@@ -160,7 +160,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-3.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-3.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-3.py	2023-03-13 20:01:47.000000000 +0600
@@ -160,7 +160,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -829,11 +829,9 @@ def test_BGP_GR_TC_20_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         result = verify_rib(
@@ -841,9 +839,9 @@ def test_BGP_GR_TC_20_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Phase 5] : R2 is about to come up now  ")
 
@@ -1117,7 +1115,8 @@ def test_BGP_GR_TC_31_1_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     logger.info("[Phase 4] : R1 is about to come up now  ")
@@ -1599,11 +1598,9 @@ def test_BGP_GR_TC_9_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         protocol = "bgp"
@@ -1612,9 +1609,9 @@ def test_BGP_GR_TC_9_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Phase 5] : R2 is about to come up now  ")
     start_router_daemons(tgen, "r2", ["bgpd"])
@@ -1643,10 +1640,10 @@ def test_BGP_GR_TC_9_p1(request):
         result = verify_f_bit(
             tgen, topo, addr_type, input_dict, dut="r1", peer="r2", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r1: F-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: F-bit should not be set to True in r1\n"
+            "Found: {}".format(tc_name, result)
         )
 
     write_test_footer(tc_name)
@@ -1781,11 +1778,9 @@ def test_BGP_GR_TC_17_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         protocol = "bgp"
@@ -1794,9 +1789,9 @@ def test_BGP_GR_TC_17_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Phase 5] : R2 is about to come up now  ")
     start_router_daemons(tgen, "r2", ["bgpd"])
@@ -1817,10 +1812,10 @@ def test_BGP_GR_TC_17_p1(request):
         result = verify_r_bit(
             tgen, topo, addr_type, input_dict, dut="r1", peer="r2", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r1: R-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: R-bit should not be set to True in r1\n"
+            "Found: {}".format(tc_name, result)
         )
 
         # Verifying BGP RIB routes
@@ -2026,10 +2021,10 @@ def test_BGP_GR_TC_43_p1(request):
         result = verify_rib(
             tgen, addr_type, dut, input_topo, next_hop, protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present \n Error {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
         dut = "r2"
@@ -2043,18 +2038,18 @@ def test_BGP_GR_TC_43_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r2: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
+
         protocol = "bgp"
         result = verify_rib(
             tgen, addr_type, dut, input_topo, next_hop, protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present \n Error {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     step(
@@ -2353,17 +2348,17 @@ def test_BGP_GR_TC_44_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
+
         result = verify_rib(
             tgen, addr_type, dut, input_topo, next_hop, protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present \n Error {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     step("Bring up BGPd on R2 and remove GR related config from R1 in global level")
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-4.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-4.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-4.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo1/test_bgp_gr_functionality_topo1-4.py	2023-03-13 20:01:47.000000000 +0600
@@ -160,7 +160,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -1157,7 +1157,8 @@ def test_BGP_GR_TC_48_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
         dut = "r2"
@@ -1171,16 +1172,17 @@ def test_BGP_GR_TC_48_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r2: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
+
         result = verify_rib(
             tgen, addr_type, dut, input_topo, next_hop, protocol, expected=False
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r2: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     step("Bring up BGP on R1 and remove Peer-level GR config from R1")
@@ -1542,16 +1544,17 @@ def BGP_GR_TC_52_p1(request):
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
+
         result = verify_rib(
             tgen, addr_type, dut, input_topo, next_hop, protocol, expected=False
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     step("Bring up BGP on R2 and remove Peer-level GR config from R1")
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-1.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-1.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-1.py	2023-03-13 20:01:47.000000000 +0600
@@ -155,7 +155,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     global ADDR_TYPES
 
@@ -528,10 +528,10 @@ def test_BGP_GR_TC_3_p0(request):
     result = verify_eor(
         tgen, topo, addr_type, input_dict, dut="r2", peer="r1", expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r2: EOR is set to True\n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: EOR should not be set to True in r2\n"
+        "Found: {}".format(tc_name, result)
     )
 
     logger.info(
@@ -675,10 +675,10 @@ def test_BGP_GR_TC_11_p0(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict, dut="r1", peer="r3", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r1: EOR is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r1\n"
+            "Found: {}".format(tc_name, result)
         )
 
     logger.info(
@@ -706,10 +706,10 @@ def test_BGP_GR_TC_11_p0(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict, dut="r3", peer="r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r3: EOR is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r3\n"
+            "Found: {}".format(tc_name, result)
         )
 
     write_test_footer(tc_name)
@@ -1474,38 +1474,33 @@ def test_BGP_GR_18_p1(request):
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r6: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes before shutting down BGPd daemon
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r6: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying BGP RIB routes
         dut = "r2"
-        result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r2: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes before shutting down BGPd daemon
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r6: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-2.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-2.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-2.py	2023-03-13 20:01:47.000000000 +0600
@@ -155,7 +155,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     global ADDR_TYPES
 
@@ -726,19 +726,17 @@ def test_BGP_GR_chaos_29_p1(request):
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes before shutting down BGPd daemon
         result = verify_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Step 4] : Start BGPd daemon on R1..")
 
@@ -981,11 +979,9 @@ def test_BGP_GR_chaos_33_p1(request):
             )
             assert result is not True, (
                 "Testcase {} : Failed \n "
-                "r3: routes are still present in BGP RIB\n Error: {}".format(
-                    tc_name, result
-                )
+                "Expected: Routes should not be present in {} FIB \n "
+                "Found: {}".format(tc_name, dut, result)
             )
-            logger.info(" Expected behavior: {}".format(result))
 
         if addr_type == "ipv6":
             if "link_local" in PREFERRED_NEXT_HOP:
@@ -998,11 +994,9 @@ def test_BGP_GR_chaos_33_p1(request):
             )
             assert result is not True, (
                 "Testcase {} : Failed \n "
-                "r3: routes are still present in ZEBRA\n Error: {}".format(
-                    tc_name, result
-                )
+                "Expected: Routes should not be present in {} FIB \n "
+                "Found: {}".format(tc_name, dut, result)
             )
-            logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Step 4] : Start BGPd daemon on R1 and R4..")
 
@@ -1182,31 +1176,28 @@ def test_BGP_GR_chaos_34_2_p1(request):
         result = verify_f_bit(
             tgen, topo, addr_type, input_dict, "r3", "r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r3: F-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: F-bit should not be set to True in r3\n"
+            "Found: {}".format(tc_name, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying BGP RIB routes after starting BGPd daemon
         input_dict_1 = {key: topo["routers"][key] for key in ["r1"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-3.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-3.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-3.py	2023-03-13 20:01:47.000000000 +0600
@@ -155,7 +155,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     global ADDR_TYPES
 
@@ -380,12 +380,11 @@ def test_BGP_GR_chaos_34_1_p1(request):
         result = verify_f_bit(
             tgen, topo, addr_type, input_dict_2, "r3", "r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r3: F-bit is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: F-bit should not be set to True in r3\n"
+            "Found: {}".format(tc_name, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     logger.info("[Step 3] : Kill BGPd daemon on R1..")
 
@@ -402,19 +401,17 @@ def test_BGP_GR_chaos_34_1_p1(request):
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         result = verify_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     # Start BGPd daemon on R1
     start_router_daemons(tgen, "r1", ["bgpd"])
@@ -587,31 +584,28 @@ def test_BGP_GR_chaos_32_p1(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict_3, dut="r5", peer="r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r5: EOR is set to TRUE\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r5\n"
+            "Found: {}".format(tc_name, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying BGP RIB routes after starting BGPd daemon
         input_dict_1 = {key: topo["routers"][key] for key in ["r5"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -716,12 +710,11 @@ def test_BGP_GR_chaos_37_p1(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict, dut="r3", peer="r1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r3: EOR is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r3\n"
+            "Found: {}".format(tc_name, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying BGP RIB routes after starting BGPd daemon
         dut = "r1"
@@ -783,10 +776,10 @@ def test_BGP_GR_chaos_37_p1(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict_3, dut="r1", peer="r3", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r1: EOR is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r1\n"
+            "Found: {}".format(tc_name, result)
         )
 
     write_test_footer(tc_name)
@@ -941,19 +934,17 @@ def test_BGP_GR_chaos_30_p1(request):
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes before shutting down BGPd daemon
         result = verify_rib(tgen, addr_type, dut, input_dict, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1356,7 +1347,8 @@ def BGP_GR_TC_7_p1(request):
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r1: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     write_test_footer(tc_name)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-4.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-4.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-4.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo2/test_bgp_gr_functionality_topo2-4.py	2023-03-13 20:01:47.000000000 +0600
@@ -157,7 +157,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     global ADDR_TYPES
 
@@ -420,10 +420,10 @@ def test_BGP_GR_TC_23_p1(request):
         result = verify_eor(
             tgen, topo, addr_type, input_dict, dut="r1", peer="r2", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "r1: EOR is set to True\n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: EOR should not be set to True in r2\n"
+            "Found: {}".format(tc_name, result)
         )
 
         # Verifying BGP RIB routes received from router R1
@@ -547,19 +547,17 @@ def test_BGP_GR_20_p1(request):
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in BGP RIB\n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
         # Verifying RIB routes before shutting down BGPd daemon
         result = verify_rib(tgen, addr_type, dut, input_dict_1, expected=False)
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "r3: routes are still present in ZEBRA\n Error: {}".format(tc_name, result)
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info(" Expected behavior: {}".format(result))
 
     # Start BGPd daemon on R1
     start_router_daemons(tgen, "r1", ["bgpd"])
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo3/bgp_gr_functionality_topo3.py frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo3/bgp_gr_functionality_topo3.py
--- frr-frr-8.4.2/tests/topotests/bgp_gr_functionality_topo3/bgp_gr_functionality_topo3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_functionality_topo3/bgp_gr_functionality_topo3.py	2023-03-13 20:01:47.000000000 +0600
@@ -56,15 +56,20 @@ from lib.bgp import (
     verify_graceful_restart_timers,
     verify_bgp_convergence_from_running_config,
 )
+
 # Import common_config to use commomnly used APIs
-from lib.common_config import (create_common_configuration,
-                               InvalidCLIError, retry,
-                               generate_ips, FRRCFG_FILE,
-                               find_interface_with_greater_ip,
-                               check_address_types,
-                               validate_ip_address,
-                               run_frr_cmd,
-                               get_frr_ipv6_linklocal)
+from lib.common_config import (
+    create_common_configuration,
+    InvalidCLIError,
+    retry,
+    generate_ips,
+    FRRCFG_FILE,
+    find_interface_with_greater_ip,
+    check_address_types,
+    validate_ip_address,
+    run_frr_cmd,
+    get_frr_ipv6_linklocal,
+)
 
 from lib.common_config import (
     write_test_header,
@@ -108,8 +113,7 @@ NEXT_HOP_IP = {"ipv4": "Null0", "ipv6":
 PREFERRED_NEXT_HOP = "link_local"
 
 
-def configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name,
-                                   dut, peer):
+def configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name, dut, peer):
     """
     result = configure_gr_followed_by_clear(tgen, topo, dut)
     assert result is True, \
@@ -118,8 +122,7 @@ def configure_gr_followed_by_clear(tgen,
     """
 
     result = create_router_bgp(tgen, topo, input_dict)
-    assert result is True, "Testcase {} : Failed \n Error: {}".format(
-        tc_name, result)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
     for addr_type in ADDR_TYPES:
         clear_bgp(tgen, addr_type, dut)
 
@@ -131,6 +134,7 @@ def configure_gr_followed_by_clear(tgen,
 
     return True
 
+
 def verify_stale_routes_list(tgen, addr_type, dut, input_dict):
     """
     This API is use verify Stale routes on refering the network with next hop value
@@ -175,8 +179,8 @@ def verify_stale_routes_list(tgen, addr_
             command = "show bgp"
             # Static routes
             sleep(2)
-            logger.info('Checking router {} BGP RIB:'.format(dut))
-            if 'static_routes' in input_dict[routerInput]:
+            logger.info("Checking router {} BGP RIB:".format(dut))
+            if "static_routes" in input_dict[routerInput]:
                 static_routes = input_dict[routerInput]["static_routes"]
                 for static_route in static_routes:
                     found_routes = []
@@ -185,30 +189,27 @@ def verify_stale_routes_list(tgen, addr_
                     nh_found = False
                     vrf = static_route.setdefault("vrf", None)
                     community = static_route.setdefault("community", None)
-                    largeCommunity = \
-                        static_route.setdefault("largeCommunity", None)
+                    largeCommunity = static_route.setdefault("largeCommunity", None)
                     if vrf:
-                        cmd = "{} vrf {} {}".\
-                            format(command, vrf, addr_type)
+                        cmd = "{} vrf {} {}".format(command, vrf, addr_type)
                         if community:
-                            cmd = "{} community {}".\
-                                format(cmd, community)
+                            cmd = "{} community {}".format(cmd, community)
                         if largeCommunity:
-                            cmd = "{} large-community {}".\
-                                format(cmd, largeCommunity)
+                            cmd = "{} large-community {}".format(cmd, largeCommunity)
                     else:
-                        cmd = "{} {}".\
-                            format(command, addr_type)
+                        cmd = "{} {}".format(command, addr_type)
                     cmd = "{} json".format(cmd)
                     rib_routes_json = run_frr_cmd(rnode, cmd, isjson=True)
                     # Verifying output dictionary rib_routes_json is not empty
                     if bool(rib_routes_json) == False:
-                        errormsg = "[DUT: {}]: No route found in rib of router". \
-                            format(router)
+                        errormsg = "[DUT: {}]: No route found in rib of router".format(
+                            router
+                        )
                         return errormsg
                     elif "warning" in rib_routes_json:
-                        errormsg = "[DUT: {}]: {}". \
-                            format(router, rib_routes_json["warning"])
+                        errormsg = "[DUT: {}]: {}".format(
+                            router, rib_routes_json["warning"]
+                        )
                         return errormsg
                     network = static_route["network"]
                     if "no_of_ip" in static_route:
@@ -227,15 +228,18 @@ def verify_stale_routes_list(tgen, addr_
                             st_found = True
 
                             found_routes.append(st_rt)
-                            for mnh in range(0, len(rib_routes_json[
-                                'routes'][st_rt])):
-                                found_hops.append([rib_r[
-                                        "ip"] for rib_r in rib_routes_json[
-                                            'routes'][st_rt][
-                                                mnh]["nexthops"]])
+                            for mnh in range(0, len(rib_routes_json["routes"][st_rt])):
+                                found_hops.append(
+                                    [
+                                        rib_r["ip"]
+                                        for rib_r in rib_routes_json["routes"][st_rt][
+                                            mnh
+                                        ]["nexthops"]
+                                    ]
+                                )
                             return found_hops
                         else:
-                            return 'error  msg - no hops found'
+                            return "error  msg - no hops found"
 
 
 def setup_module(mod):
@@ -248,7 +252,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     global ADDR_TYPES
 
@@ -302,6 +306,8 @@ def teardown_module(mod):
         "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
     )
     logger.info("=" * 40)
+
+
 ################################################################################
 #
 #                       TEST CASES
@@ -318,175 +324,160 @@ def test_bgp_gr_stale_routes(request):
 
     step("Creating 5 static Routes in Router R3 with NULL0 as Next hop")
     for addr_type in ADDR_TYPES:
-            input_dict_1 = {
-                "r3": {
-                    "static_routes": [{
-                    "network": [NETWORK1_1[addr_type]] + [NETWORK1_2[addr_type]],
-                    "next_hop": NEXT_HOP_IP[addr_type]
-                },
-                {
-                    "network": [NETWORK2_1[addr_type]] + [NETWORK2_2[addr_type]],
-                    "next_hop": NEXT_HOP_IP[addr_type]
-                },
-                {
-                    "network": [NETWORK3_1[addr_type]] + [NETWORK3_2[addr_type]],
-                    "next_hop": NEXT_HOP_IP[addr_type]
-                },
-                {
-                    "network": [NETWORK4_1[addr_type]] + [NETWORK4_2[addr_type]],
-                    "next_hop": NEXT_HOP_IP[addr_type]
-                },
-                {
-                    "network": [NETWORK5_1[addr_type]] + [NETWORK5_2[addr_type]],
-                    "next_hop": NEXT_HOP_IP[addr_type]
-                }]
-            }
+        input_dict_1 = {
+            "r3": {
+                "static_routes": [
+                    {
+                        "network": [NETWORK1_1[addr_type]] + [NETWORK1_2[addr_type]],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    },
+                    {
+                        "network": [NETWORK2_1[addr_type]] + [NETWORK2_2[addr_type]],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    },
+                    {
+                        "network": [NETWORK3_1[addr_type]] + [NETWORK3_2[addr_type]],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    },
+                    {
+                        "network": [NETWORK4_1[addr_type]] + [NETWORK4_2[addr_type]],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    },
+                    {
+                        "network": [NETWORK5_1[addr_type]] + [NETWORK5_2[addr_type]],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    },
+                ]
             }
-            result = create_static_routes(tgen, input_dict_1)
-            assert result is True, 'Testcase {} : Failed \n Error: {}'.format(
-            tc_name, result)
+        }
+        result = create_static_routes(tgen, input_dict_1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
     step("verifying Created  Route  at R3 in VRF default")
     for addr_type in ADDR_TYPES:
-        dut = 'r3'
-        input_dict_1= {'r3': topo['routers']['r3']}
+        dut = "r3"
+        input_dict_1 = {"r3": topo["routers"]["r3"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
-    #done
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+    # done
     step("verifying Created  Route  at R2 in VRF default")
     for addr_type in ADDR_TYPES:
-        dut = 'r2'
-        input_dict_1= {'r2': topo['routers']['r2']}
+        dut = "r2"
+        input_dict_1 = {"r2": topo["routers"]["r2"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
     step("importing vrf RED on R2 under Address Family")
     for addr_type in ADDR_TYPES:
-        input_import_vrf={
+        input_import_vrf = {
             "r2": {
                 "bgp": [
                     {
                         "local_as": 200,
                         "vrf": "RED",
-                        "address_family": {addr_type: {"unicast": {"import": {"vrf": "default"}}}},
+                        "address_family": {
+                            addr_type: {"unicast": {"import": {"vrf": "default"}}}
+                        },
                     }
                 ]
             }
         }
-        result = create_router_bgp(tgen, topo,input_import_vrf)
-        assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
-    #done
+        result = create_router_bgp(tgen, topo, input_import_vrf)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+    # done
     step("verifying static  Routes  at R2 in VRF RED")
     for addr_type in ADDR_TYPES:
-        dut = 'r2'
-        input_dict_1= {'r2': topo['routers']['r2']}
+        dut = "r2"
+        input_dict_1 = {"r2": topo["routers"]["r2"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
 
     step("verifying static  Routes  at R1 in VRF RED")
     for addr_type in ADDR_TYPES:
-        dut = 'r1'
-        input_dict_1= {'r1': topo['routers']['r1']}
+        dut = "r1"
+        input_dict_1 = {"r1": topo["routers"]["r1"]}
         result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
 
     step("Configuring Graceful restart at R2 and R3 ")
     input_dict = {
         "r2": {
-
             "bgp": {
                 "local_as": "200",
                 "graceful-restart": {
                     "graceful-restart": True,
-                }
+                },
             }
         },
         "r3": {
-            "bgp": {
-                "local_as": "300",
-                "graceful-restart": {
-                    "graceful-restart": True
-                }
-            }
-        }
+            "bgp": {"local_as": "300", "graceful-restart": {"graceful-restart": True}}
+        },
     }
 
-    configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name,dut='r2', peer='r3')
-
-
+    configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name, dut="r2", peer="r3")
 
     step("verify Graceful restart at R2")
     for addr_type in ADDR_TYPES:
-        result = verify_graceful_restart(tgen, topo, addr_type, input_dict,
-                                         dut='r2', peer='r3')
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        result = verify_graceful_restart(
+            tgen, topo, addr_type, input_dict, dut="r2", peer="r3"
+        )
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
 
     step("verify Graceful restart at R3")
     for addr_type in ADDR_TYPES:
-        result = verify_graceful_restart(tgen, topo, addr_type, input_dict,
-                                         dut='r3', peer='r2')
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        result = verify_graceful_restart(
+            tgen, topo, addr_type, input_dict, dut="r3", peer="r2"
+        )
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
 
     step("Configuring Graceful-restart-disable at R3")
     input_dict = {
         "r2": {
-
             "bgp": {
                 "local_as": "200",
                 "graceful-restart": {
                     "graceful-restart": False,
-                }
+                },
             }
         },
         "r3": {
-            "bgp": {
-                "local_as": "300",
-                "graceful-restart": {
-                    "graceful-restart": False
-                }
-            }
-        }
+            "bgp": {"local_as": "300", "graceful-restart": {"graceful-restart": False}}
+        },
     }
-    configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name,dut='r3', peer='r2')
+    configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name, dut="r3", peer="r2")
 
     step("Verify Graceful-restart-disable at R3")
     for addr_type in ADDR_TYPES:
-        result = verify_graceful_restart(tgen, topo, addr_type, input_dict,
-                                         dut='r3', peer='r2')
-        assert result is True, \
-            "Testcase {} :Failed \n Error {}". \
-                format(tc_name, result)
+        result = verify_graceful_restart(
+            tgen, topo, addr_type, input_dict, dut="r3", peer="r2"
+        )
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
 
     for iteration in range(5):
         step("graceful-restart-disable:True  at R3")
         input_dict = {
-        "r3": {
-            "bgp": {
-                "graceful-restart": {
-                    "graceful-restart-disable": True,
+            "r3": {
+                "bgp": {
+                    "graceful-restart": {
+                        "graceful-restart-disable": True,
+                    }
                 }
             }
-            }
         }
-        configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name,
-                                   dut='r3', peer='r2')
+        configure_gr_followed_by_clear(
+            tgen, topo, input_dict, tc_name, dut="r3", peer="r2"
+        )
 
         step("Verifying  Routes at R2 on enabling GRD")
-        dut = 'r2'
+        dut = "r2"
         for addr_type in ADDR_TYPES:
-            input_dict_1= {'r2': topo['routers']['r2']}
+            input_dict_1 = {"r2": topo["routers"]["r2"]}
             result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-            assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+            assert result is True, "Testcase {} :Failed \n Error {}".format(
+                tc_name, result
+            )
 
         step("Verify stale Routes in Router R2 enabling GRD")
         for addr_type in ADDR_TYPES:
@@ -495,39 +486,45 @@ def test_bgp_gr_stale_routes(request):
             verify_nh_for_static_rtes = {
                 "r3": {
                     "static_routes": [
-
                         {
                             "network": [NETWORK1_1[addr_type]],
                             "no_of_ip": 2,
-                            "vrf": "RED"
+                            "vrf": "RED",
                         }
                     ]
                 }
             }
             bgp_rib_next_hops = verify_stale_routes_list(
-            tgen, addr_type, dut, verify_nh_for_static_rtes)
-            assert (len(bgp_rib_next_hops)== 1) is True, "Testcase {} : Failed \n Error: {}".format(
-             tc_name, bgp_rib_next_hops,expected=True)
+                tgen, addr_type, dut, verify_nh_for_static_rtes
+            )
+            assert (
+                len(bgp_rib_next_hops) == 1
+            ) is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, bgp_rib_next_hops, expected=True
+            )
 
         step("graceful-restart-disable:False at R3")
         input_dict = {
-        "r3": {
-            "bgp": {
-                "graceful-restart": {
-                    "graceful-restart-disable": False,
+            "r3": {
+                "bgp": {
+                    "graceful-restart": {
+                        "graceful-restart-disable": False,
+                    }
                 }
             }
-            }
         }
-        configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name,
-                                   dut='r3', peer='r2')
+        configure_gr_followed_by_clear(
+            tgen, topo, input_dict, tc_name, dut="r3", peer="r2"
+        )
 
         step("Verifying  Routes at R2 on disabling GRD")
-        dut = 'r2'
+        dut = "r2"
         for addr_type in ADDR_TYPES:
-            input_dict_1= {'r2': topo['routers']['r2']}
+            input_dict_1 = {"r2": topo["routers"]["r2"]}
             result = verify_bgp_rib(tgen, addr_type, dut, input_dict_1)
-            assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+            assert result is True, "Testcase {} :Failed \n Error {}".format(
+                tc_name, result
+            )
 
         step("Verify stale Routes in Router R2 on disabling GRD")
         for addr_type in ADDR_TYPES:
@@ -536,19 +533,22 @@ def test_bgp_gr_stale_routes(request):
             verify_nh_for_static_rtes = {
                 "r3": {
                     "static_routes": [
-
                         {
                             "network": [NETWORK1_1[addr_type]],
                             "no_of_ip": 2,
-                            "vrf": "RED"
+                            "vrf": "RED",
                         }
                     ]
                 }
             }
-            bgp_rib_next_hops = verify_stale_routes_list(tgen, addr_type, dut, verify_nh_for_static_rtes)
+            bgp_rib_next_hops = verify_stale_routes_list(
+                tgen, addr_type, dut, verify_nh_for_static_rtes
+            )
 
-            stale_route_status=len(bgp_rib_next_hops)== 1
-            assert stale_route_status is True, "Testcase {} : Failed \n Error: {}".format(
-             tc_name, stale_route_status,expected=True)
+            stale_route_status = len(bgp_rib_next_hops) == 1
+            assert (
+                stale_route_status is True
+            ), "Testcase {} : Failed \n Error: {}".format(
+                tc_name, stale_route_status, expected=True
+            )
     write_test_footer(tc_name)
-
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gr_restart_retain_routes/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_gr_restart_retain_routes/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_gr_restart_retain_routes/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gr_restart_retain_routes/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,3 +1,4 @@
+no zebra nexthop kernel enable
 !
 interface r2-eth0
  ip address 192.168.255.2/24
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gshut_topo1/test_ebgp_gshut_topo1.py frr-frr-8.5/tests/topotests/bgp_gshut_topo1/test_ebgp_gshut_topo1.py
--- frr-frr-8.4.2/tests/topotests/bgp_gshut_topo1/test_ebgp_gshut_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gshut_topo1/test_ebgp_gshut_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -92,7 +92,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_gshut_topo1/test_ibgp_gshut_topo1.py frr-frr-8.5/tests/topotests/bgp_gshut_topo1/test_ibgp_gshut_topo1.py
--- frr-frr-8.4.2/tests/topotests/bgp_gshut_topo1/test_ibgp_gshut_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_gshut_topo1/test_ibgp_gshut_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -87,7 +87,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.16")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel requirements are not met, kernel version should be >=4.16")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_instance_del_test/scripts/check_routes.py frr-frr-8.5/tests/topotests/bgp_instance_del_test/scripts/check_routes.py
--- frr-frr-8.4.2/tests/topotests/bgp_instance_del_test/scripts/check_routes.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_instance_del_test/scripts/check_routes.py	2023-03-13 20:01:47.000000000 +0600
@@ -339,7 +339,7 @@ luCommand(
 luCommand(
     "r1",
     'vtysh -c "show bgp vrf r1-cust1 ipv4 uni 6.0.1.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.1.0 shows up on r1",
     10,
@@ -347,7 +347,7 @@ luCommand(
 luCommand(
     "r1",
     'vtysh -c "show bgp vrf r1-cust1 ipv4 uni 6.0.2.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.2.0 shows up on r1",
     10,
@@ -396,9 +396,9 @@ want_r1_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "4.4.4.4", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.1", "bp": True},
-    {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": True},
+    {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.2.0/24", "n": "4.4.4.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.1", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.1", "bp": True},
     {"p": "99.0.0.1/32", "n": "192.168.1.2", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3"},
     {"p": "99.0.0.3/32", "n": "4.4.4.4"},
@@ -473,7 +473,7 @@ luCommand(
 luCommand(
     "r3",
     'vtysh -c "show bgp vrf r3-cust1 ipv4 uni 6.0.1.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.1.0 shows up on r3",
     10,
@@ -481,7 +481,7 @@ luCommand(
 luCommand(
     "r3",
     'vtysh -c "show bgp vrf r3-cust1 ipv4 uni 6.0.2.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.2.0 shows up on r3",
     10,
@@ -522,9 +522,9 @@ want_r3_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "1.1.1.1", "bp": True},
     {"p": "6.0.1.0/24", "n": "4.4.4.4", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.2", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "4.4.4.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.2", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.2", "bp": True},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.3/32", "n": "4.4.4.4", "bp": True},
     {"p": "99.0.0.4/32", "n": "4.4.4.4", "bp": True},
@@ -611,9 +611,9 @@ want_r4_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.4", "bp": False},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3", "bp": True},
@@ -638,9 +638,9 @@ want_r4_remote_cust2_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.4", "bp": False},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3", "bp": True},
@@ -721,7 +721,7 @@ luCommand("r4", 'vtysh -c "show ip route
 luCommand(
     "ce3",
     'vtysh -c "show bgp ipv4 uni"',
-    "12 routes and 14",
+    "12 routes and 13",
     "wait",
     "Local and remote routes",
     10,
@@ -733,7 +733,6 @@ want = [
     {"p": "5.4.2.0/24", "n": "192.168.1.1", "bp": True},
     {"p": "5.4.3.0/24", "n": "192.168.1.1", "bp": True},
     {"p": "6.0.1.0/24", "n": "192.168.1.1", "bp": False},
-    {"p": "6.0.2.0/24", "n": "192.168.1.1", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
 ]
@@ -834,45 +833,36 @@ luCommand(
 luCommand(
     "ce1",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.1 from 0.0.0.0 .99.0.0.1"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.1 from 0.0.0.0 .99.0.0.1"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:11",
     "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce2",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.2 from 0.0.0.0 .99.0.0.2"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.2 from 0.0.0.0 .99.0.0.2"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:12",
     "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce3",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.3 from 0.0.0.0 .99.0.0.3"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.3 from 0.0.0.0 .99.0.0.3"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:13",
     "pass",
-    "Redundant route 2 details",
-)
-luCommand(
-    "ce3",
-    'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 192.168.1.1 from 192.168.1.1 .192.168.1.1"
-    + ".* Origin IGP, metric 100, localpref 100, valid, internal"
-    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:11",
-    "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce4",
     'vtysh -c "show bgp  vrf ce4-cust2 ipv4 6.0.2.0"',
     "2 available, best .*192.168.2.1.* Local.* 192.168.2.1 from 192.168.2.1 .192.168.2.1"
     + ".* Origin IGP, metric 100, localpref 100, valid, internal"
-    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:11",
+    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:13",
     "pass",
     "Redundant route 2 details",
 )
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+router bgp 65001
+ bgp router-id 10.0.0.1
+ no bgp ebgp-requires-policy
+ neighbor fe80:1::2 remote-as external
+ neighbor fe80:1::2 timers 3 10
+ neighbor fe80:1::2 interface r1-eth0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r1-eth0
+ ipv6 address fe80:1::1/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+router bgp 65002
+ bgp router-id 10.0.0.2
+ no bgp ebgp-requires-policy
+ neighbor fe80:1::1 remote-as external
+ neighbor fe80:1::1 timers 3 10
+ neighbor fe80:1::1 interface r2-eth0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r2-eth0
+ ipv6 address fe80:1::2/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/test_bgp_ipv6_ll_peering.py frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/test_bgp_ipv6_ll_peering.py
--- frr-frr-8.4.2/tests/topotests/bgp_ipv6_ll_peering/test_bgp_ipv6_ll_peering.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_ipv6_ll_peering/test_bgp_ipv6_ll_peering.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+# SPDX-License-Identifier: ISC
+
+#
+# Copyright (c) 2023 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+
+"""
+Check if IPv6 Link-Local BGP peering works fine.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 3):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_ipv6_link_local_peering():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+
+    def _bgp_converge():
+        output = json.loads(r1.vtysh_cmd("show bgp summary json"))
+        expected = {
+            "ipv4Unicast": {
+                "peers": {
+                    "fe80:1::2": {
+                        "state": "Established",
+                    }
+                }
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP convergence on R2"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_l3vpn_to_bgp_vrf/scripts/check_routes.py frr-frr-8.5/tests/topotests/bgp_l3vpn_to_bgp_vrf/scripts/check_routes.py
--- frr-frr-8.4.2/tests/topotests/bgp_l3vpn_to_bgp_vrf/scripts/check_routes.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_l3vpn_to_bgp_vrf/scripts/check_routes.py	2023-03-13 20:01:47.000000000 +0600
@@ -339,7 +339,7 @@ luCommand(
 luCommand(
     "r1",
     'vtysh -c "show bgp vrf r1-cust1 ipv4 uni 6.0.1.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.1.0 shows up on r1",
     10,
@@ -347,7 +347,7 @@ luCommand(
 luCommand(
     "r1",
     'vtysh -c "show bgp vrf r1-cust1 ipv4 uni 6.0.2.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.2.0 shows up on r1",
     10,
@@ -396,9 +396,9 @@ want_r1_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "4.4.4.4", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.1", "bp": True},
-    {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": True},
+    {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.2.0/24", "n": "4.4.4.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.1", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.1", "bp": True},
     {"p": "99.0.0.1/32", "n": "192.168.1.2", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3"},
     {"p": "99.0.0.3/32", "n": "4.4.4.4"},
@@ -473,7 +473,7 @@ luCommand(
 luCommand(
     "r3",
     'vtysh -c "show bgp vrf r3-cust1 ipv4 uni 6.0.1.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.1.0 shows up on r3",
     10,
@@ -481,7 +481,7 @@ luCommand(
 luCommand(
     "r3",
     'vtysh -c "show bgp vrf r3-cust1 ipv4 uni 6.0.2.0/24"',
-    "3 available, best",
+    "4 available, best",
     "wait",
     "Ensure 6.0.2.0 shows up on r3",
     10,
@@ -522,9 +522,9 @@ want_r3_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "1.1.1.1", "bp": True},
     {"p": "6.0.1.0/24", "n": "4.4.4.4", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.2", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "4.4.4.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.2", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.2", "bp": True},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.3/32", "n": "4.4.4.4", "bp": True},
     {"p": "99.0.0.4/32", "n": "4.4.4.4", "bp": True},
@@ -611,9 +611,9 @@ want_r4_remote_cust1_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.4", "bp": False},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3", "bp": True},
@@ -638,9 +638,9 @@ want_r4_remote_cust2_routes = [
     {"p": "6.0.1.0/24", "n": "3.3.3.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.4", "bp": False},
-    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": True},
+    {"p": "6.0.2.0/24", "n": "1.1.1.1", "bp": False},
     {"p": "6.0.2.0/24", "n": "3.3.3.3", "bp": False},
-    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": False},
+    {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.4", "bp": False},
     {"p": "99.0.0.1/32", "n": "1.1.1.1", "bp": True},
     {"p": "99.0.0.2/32", "n": "3.3.3.3", "bp": True},
@@ -721,7 +721,7 @@ luCommand("r4", 'vtysh -c "show ip route
 luCommand(
     "ce3",
     'vtysh -c "show bgp ipv4 uni"',
-    "12 routes and 14",
+    "12 routes and 13",
     "wait",
     "Local and remote routes",
     10,
@@ -733,7 +733,6 @@ want = [
     {"p": "5.4.2.0/24", "n": "192.168.1.1", "bp": True},
     {"p": "5.4.3.0/24", "n": "192.168.1.1", "bp": True},
     {"p": "6.0.1.0/24", "n": "192.168.1.1", "bp": False},
-    {"p": "6.0.2.0/24", "n": "192.168.1.1", "bp": False},
     {"p": "6.0.1.0/24", "n": "99.0.0.3", "bp": True},
     {"p": "6.0.2.0/24", "n": "99.0.0.3", "bp": True},
 ]
@@ -834,45 +833,36 @@ luCommand(
 luCommand(
     "ce1",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.1 from 0.0.0.0 .99.0.0.1"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.1 from 0.0.0.0 .99.0.0.1"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:11",
     "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce2",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.2 from 0.0.0.0 .99.0.0.2"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.2 from 0.0.0.0 .99.0.0.2"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:12",
     "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce3",
     'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 99.0.0.3 from 0.0.0.0 .99.0.0.3"
-    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .Weight"
+    "1 available, best .*192.168.1.1.* Local.* 99.0.0.3 from 0.0.0.0 .99.0.0.3"
+    + ".* Origin IGP, metric 100, localpref 100, weight 32768, valid, sourced, local, best .First path received"
     + ".* Community: 0:67.* Extended Community: RT:89:123.* Large Community: 12:34:13",
     "pass",
-    "Redundant route 2 details",
-)
-luCommand(
-    "ce3",
-    'vtysh -c "show bgp ipv4 uni 6.0.2.0"',
-    "2 available, best .*192.168.1.1.* Local.* 192.168.1.1 from 192.168.1.1 .192.168.1.1"
-    + ".* Origin IGP, metric 100, localpref 100, valid, internal"
-    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:11",
-    "pass",
-    "Redundant route 2 details",
+    "Route 2 details",
 )
 luCommand(
     "ce4",
     'vtysh -c "show bgp  vrf ce4-cust2 ipv4 6.0.2.0"',
     "2 available, best .*192.168.2.1.* Local.* 192.168.2.1 from 192.168.2.1 .192.168.2.1"
     + ".* Origin IGP, metric 100, localpref 100, valid, internal"
-    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:11",
+    + ".* Community: 0:67.* Extended Community: RT:52:100 RT:89:123.* Large Community: 12:34:13",
     "pass",
     "Redundant route 2 details",
 )
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 192.168.31.3 remote-as external
+ neighbor 192.168.31.3 timers 1 3
+ neighbor 192.168.31.3 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.31.3 activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+interface lo
+ ip address 10.0.0.1/32
+!
+interface r1-eth0
+ ip address 192.168.31.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 192.168.32.3 remote-as external
+ neighbor 192.168.32.3 timers 1 3
+ neighbor 192.168.32.3 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.32.3 activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+interface lo
+ ip address 10.0.0.1/32
+!
+interface r2-eth0
+ ip address 192.168.32.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,35 @@
+!
+router bgp 65003
+ no bgp default ipv4-unicast
+ no bgp ebgp-requires-policy
+ no bgp suppress-duplicates
+ bgp bestpath as-path multipath-relax
+ neighbor 192.168.31.1 remote-as external
+ neighbor 192.168.31.1 timers 1 3
+ neighbor 192.168.31.1 timers connect 1
+ neighbor 192.168.32.2 remote-as external
+ neighbor 192.168.32.2 timers 1 3
+ neighbor 192.168.32.2 timers connect 1
+ neighbor 192.168.34.4 remote-as external
+ neighbor 192.168.34.4 timers 1 3
+ neighbor 192.168.34.4 timers connect 1
+ neighbor 192.168.35.5 remote-as external
+ neighbor 192.168.35.5 timers 1 3
+ neighbor 192.168.35.5 timers connect 1
+ neighbor 192.168.35.5 shutdown
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.31.1 activate
+  neighbor 192.168.32.2 activate
+  neighbor 192.168.35.5 activate
+  neighbor 192.168.34.4 activate
+  neighbor 192.168.34.4 route-map r4 out
+  neighbor 192.168.34.4 addpath-tx-all-paths
+ exit-address-family
+ !
+!
+ip prefix-list r4 seq 5 permit 10.0.0.1/32
+!
+route-map r4 permit 10
+ match ip address prefix-list r4
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,13 @@
+!
+interface r3-eth0
+ ip address 192.168.31.3/24
+!
+interface r3-eth1
+ ip address 192.168.32.3/24
+!
+interface r3-eth2
+ ip address 192.168.34.3/24
+!
+interface r3-eth3
+ ip address 192.168.35.3/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r4/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r4/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r4/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r4/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+router bgp 65004
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 192.168.34.3 remote-as external
+ neighbor 192.168.34.3 timers 1 3
+ neighbor 192.168.34.3 timers connect 1
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.34.3 activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r4/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r4/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r4-eth0
+ ip address 192.168.34.4/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r5/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r5/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r5/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r5/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65005
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 192.168.35.3 remote-as external
+ neighbor 192.168.35.3 timers 1 3
+ neighbor 192.168.35.3 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.35.3 activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r5/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r5/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/r5/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/r5/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+interface lo
+ ip address 10.0.0.1/32
+!
+interface r5-eth0
+ ip address 192.168.35.5/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/test_bgp_labeled_unicast_addpath.py frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/test_bgp_labeled_unicast_addpath.py
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_addpath/test_bgp_labeled_unicast_addpath.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_addpath/test_bgp_labeled_unicast_addpath.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,179 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Check if labeled-unicast works correctly with addpath capability.
+Initially R3 MUST announce 10.0.0.1/32 multipath(2) from R1 + R2.
+Later, we enable R5 and 10.0.0.1/32 multipath(3) MUST be announced,
+R1 + R2 + R5.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 6):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r3"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r2"])
+    switch.add_link(tgen.gears["r3"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["r3"])
+    switch.add_link(tgen.gears["r4"])
+
+    switch = tgen.add_switch("s4")
+    switch.add_link(tgen.gears["r3"])
+    switch.add_link(tgen.gears["r5"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_addpath_labeled_unicast():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r3 = tgen.gears["r3"]
+    r4 = tgen.gears["r4"]
+
+    def _bgp_check_advertised_routes(prefix_num):
+        output = json.loads(
+            r3.vtysh_cmd(
+                "show bgp ipv4 labeled-unicast neighbors 192.168.34.4 advertised-routes json"
+            )
+        )
+        expected = {
+            "advertisedRoutes": {
+                "10.0.0.1/32": {
+                    "appliedStatusSymbols": {
+                        "*": True,
+                        ">": True,
+                        "=": True,
+                    }
+                }
+            },
+            "totalPrefixCounter": prefix_num,
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_advertised_routes, 2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert (
+        result is None
+    ), "Failed to advertise labeled-unicast with addpath (multipath)"
+
+    def _bgp_check_received_routes():
+        output = json.loads(r4.vtysh_cmd("show bgp ipv4 labeled-unicast json"))
+        expected = {
+            "routes": {
+                "10.0.0.1/32": [
+                    {
+                        "valid": True,
+                        "path": "65003 65001",
+                    },
+                    {
+                        "valid": True,
+                        "path": "65003 65002",
+                    },
+                ]
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to receive labeled-unicast with addpath (multipath)"
+
+    step("Enable BGP session for R5")
+    r3.vtysh_cmd(
+        """
+          configure terminal
+            router bgp 65003
+              no neighbor 192.168.35.5 shutdown
+        """
+    )
+
+    test_func = functools.partial(_bgp_check_advertised_routes, 3)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert (
+        result is None
+    ), "Failed to advertise labeled-unicast with addpath (multipath)"
+
+    step("Disable BGP session for R5")
+    r3.vtysh_cmd(
+        """
+          configure terminal
+            router bgp 65003
+              neighbor 192.168.35.5 shutdown
+        """
+    )
+
+    test_func = functools.partial(_bgp_check_advertised_routes, 2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert (
+        result is None
+    ), "Failed to advertise labeled-unicast with addpath (multipath)"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,21 @@
+!
+router bgp 65001
+ no bgp default ipv4-unicast
+ no bgp ebgp-requires-policy
+ neighbor 192.168.12.2 remote-as external
+ neighbor 192.168.12.2 timers 1 3
+ neighbor 192.168.12.2 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.12.2 activate
+  neighbor 192.168.12.2 default-originate route-map r2
+ exit-address-family
+ !
+!
+route-map r2 permit 10
+ set community 65001:65001
+ set metric 666
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r1-eth0
+ ip address 192.168.12.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+!
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 192.168.12.1 remote-as external
+ neighbor 192.168.12.1 timers 1 3
+ neighbor 192.168.12.1 timers connect 1
+ address-family ipv4 labeled-unicast
+  neighbor 192.168.12.1 activate
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r2-eth0
+ ip address 192.168.12.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/test_bgp_labeled_unicast_default_originate.py frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/test_bgp_labeled_unicast_default_originate.py
--- frr-frr-8.4.2/tests/topotests/bgp_labeled_unicast_default_originate/test_bgp_labeled_unicast_default_originate.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_labeled_unicast_default_originate/test_bgp_labeled_unicast_default_originate.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,122 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Check if labeled-unicast works correctly with default-originate.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 3):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_labeled_unicast_default_originate():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+    r2 = tgen.gears["r2"]
+
+    def _bgp_check_advertised_routes():
+        output = json.loads(
+            r1.vtysh_cmd(
+                "show bgp ipv4 labeled-unicast neighbors 192.168.12.2 advertised-routes json"
+            )
+        )
+        expected = {
+            "bgpOriginatingDefaultNetwork": "0.0.0.0/0",
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_advertised_routes)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to advertise default route for labeled-unicast"
+
+    def _bgp_check_received_routes():
+        output = json.loads(
+            r2.vtysh_cmd("show bgp ipv4 labeled-unicast 0.0.0.0/0 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "metric": 666,
+                    "community": {
+                        "string": "65001:65001",
+                    },
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_routes)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to receive default route for labeled-unicast"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_local_as/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.2 remote-as 65002
+ neighbor 192.168.1.2 local-as 65002
+ neighbor 192.168.1.2 timers 1 3
+ neighbor 192.168.1.2 timers connect 1
+ neighbor PG peer-group
+ neighbor PG remote-as 65003
+ neighbor PG local-as 65003
+ neighbor 192.168.2.2 peer-group PG
+ address-family ipv4
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_local_as/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 172.16.255.1/32
+!
+interface r1-eth0
+ ip address 192.168.1.1/24
+!
+interface r1-eth1
+ ip address 192.168.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_local_as/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as internal
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_local_as/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r2-eth0
+ ip address 192.168.1.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_local_as/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+router bgp 65003
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as internal
+ neighbor 192.168.2.1 timers 1 3
+ neighbor 192.168.2.1 timers connect 1
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_local_as/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r3-eth0
+ ip address 192.168.2.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as/test_bgp_local_as.py frr-frr-8.5/tests/topotests/bgp_local_as/test_bgp_local_as.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_as/test_bgp_local_as.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as/test_bgp_local_as.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,134 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 4):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r3"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_local_as_same_remote_as():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_local_as_same_remote_as():
+        output = json.loads(
+            tgen.gears["r2"].vtysh_cmd("show bgp ipv4 unicast 172.16.255.1/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "Local"},
+                    "nexthops": [{"ip": "192.168.1.1", "hostname": "r1"}],
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    step("Check if iBGP works when local-as == remote-as")
+    test_func = functools.partial(_bgp_check_local_as_same_remote_as)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R2"
+
+
+def test_bgp_peer_group_local_as_same_remote_as():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_local_as_same_remote_as():
+        output = json.loads(
+            tgen.gears["r3"].vtysh_cmd("show bgp ipv4 unicast 172.16.255.1/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "Local"},
+                    "nexthops": [{"ip": "192.168.2.1", "hostname": "r1"}],
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    step("Initial BGP converge")
+    test_func = functools.partial(_bgp_check_local_as_same_remote_as)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R3"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_as_private_remove/test_bgp_local_as_private_remove.py frr-frr-8.5/tests/topotests/bgp_local_as_private_remove/test_bgp_local_as_private_remove.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_as_private_remove/test_bgp_local_as_private_remove.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_as_private_remove/test_bgp_local_as_private_remove.py	2023-03-13 20:01:47.000000000 +0600
@@ -31,13 +31,14 @@ used together with `remove-private-AS`.
 import os
 import sys
 import json
-import time
 import pytest
+import functools
 
 CWD = os.path.dirname(os.path.realpath(__file__))
 sys.path.append(os.path.join(CWD, "../"))
 
 # pylint: disable=C0413
+from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
 
 pytestmark = [pytest.mark.bgpd]
@@ -84,29 +85,43 @@ def test_bgp_remove_private_as():
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    def _bgp_converge(router):
-        while True:
-            output = json.loads(
-                tgen.gears[router].vtysh_cmd("show ip bgp neighbor 192.168.255.1 json")
-            )
-            if output["192.168.255.1"]["bgpState"] == "Established":
-                time.sleep(1)
-                return True
-
-    def _bgp_as_path(router):
-        output = json.loads(
-            tgen.gears[router].vtysh_cmd("show ip bgp 172.16.255.254/32 json")
-        )
-        if output["prefix"] == "172.16.255.254/32":
-            return output["paths"][0]["aspath"]["segments"][0]["list"]
+    r2 = tgen.gears["r2"]
+    r4 = tgen.gears["r4"]
 
-    if _bgp_converge("r2"):
-        assert len(_bgp_as_path("r2")) == 1
-        assert 65000 not in _bgp_as_path("r2")
-
-    if _bgp_converge("r4"):
-        assert len(_bgp_as_path("r4")) == 2
-        assert 3000 in _bgp_as_path("r4")
+    def _bgp_converge():
+        output = json.loads(r2.vtysh_cmd("show ip bgp neighbor 192.168.255.1 json"))
+        expected = {
+            "192.168.255.1": {
+                "bgpState": "Established",
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge initially"
+
+    def _bgp_as_path(router, asn_path, asn_length):
+        output = json.loads(router.vtysh_cmd("show ip bgp 172.16.255.254/32 json"))
+        expected = {
+            "paths": [
+                {
+                    "aspath": {
+                        "string": asn_path,
+                        "length": asn_length,
+                    }
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_as_path, r2, "500", 1)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Private ASNs not stripped"
+
+    test_func = functools.partial(_bgp_as_path, r4, "500 3000", 2)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Private ASNs not stripped"
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_agg.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_agg.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_agg.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_agg.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,147 @@
+{
+    "address_types": ["ipv4", "ipv6"],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 30,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {"ipv4": "10.0.0.0", "v4mask": 30, "ipv6": "fd00::", "v6mask": 64},
+    "lo_prefix": {"ipv4": "1.0.", "v4mask": 32, "ipv6": "2001:db8:f::", "v6mask": 128},
+    "routers": {
+        "r1": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r3": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r3": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    }
+                }
+            },
+            "static_routes":[
+                {
+                "network":"10.1.1.0/32",
+                "next_hop":"Null0"
+                },
+                {
+                "network":"10:1::1:0/128",
+                "next_hop":"Null0"
+                }]
+            },
+        "r2": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "200",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                            ],
+                            "neighbor": {
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                            ],
+                            "neighbor": {
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    }
+                }
+            },
+            "static_routes":[
+                {
+                "network":"10.1.2.0/32",
+                "next_hop":"Null0"
+                },
+                {
+                "network":"10:1::2:0/128",
+                "next_hop":"Null0"
+                }]
+            },
+        "r3": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r1": {"ipv4": "auto", "ipv6": "auto"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"},
+                "r4": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r3": {}}},
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r3": {}}},
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "400",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_ecmp.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_ecmp.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_ecmp.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_ecmp.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,317 @@
+{
+    "address_types": [
+        "ipv4",
+        "ipv6"
+    ],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 24,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {
+        "ipv4": "10.0.0.0",
+        "v4mask": 24,
+        "ipv6": "fd00::",
+        "v6mask": 64
+    },
+    "lo_prefix": {
+        "ipv4": "1.0.",
+        "v4mask": 32,
+        "ipv6": "2001:DB8:F::",
+        "v6mask": 128
+    },
+    "routers": {
+        "r1": {
+            "links": {
+                "lo": {
+                    "ipv4": "auto",
+                    "ipv6": "auto",
+                    "type": "loopback"
+                },
+                "r2-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                }
+            },
+            "bgp": [{
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r2": {
+                                    "dest_link": {
+                                        "r1-link1": {}
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r2": {
+                                    "dest_link": {
+                                        "r1-link1": {}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            ],
+            "static_routes":[
+                {
+                   "network":"10.0.0.1/32",
+                   "next_hop":"Null0"
+                },
+                {
+                   "network":"10::1/128",
+                   "next_hop":"Null0"
+                }
+            ]
+        },
+        "r2": {
+            "links": {
+                "lo": {
+                    "ipv4": "auto",
+                    "ipv6": "auto",
+                    "type": "loopback"
+                },
+                "r1-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                }
+            },
+            "bgp": [{
+                "local_as": "200",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {
+                                    "dest_link": {
+                                        "r2-link1": {}
+                                    }
+                                },
+                                "r3": {
+                                    "dest_link": {
+                                        "r2-link1": {}
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {
+                                    "dest_link": {
+                                        "r2-link1": {}
+                                    }
+                                },
+                                "r3": {
+                                    "dest_link": {
+                                        "r2-link1": {}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        ]
+        },
+        "r3": {
+            "links": {
+                "lo": {
+                    "ipv4": "auto",
+                    "ipv6": "auto",
+                    "type": "loopback"
+                },
+                "r2-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link2": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link3": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link4": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link5": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link6": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link7": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r4-link8": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                }
+            },
+            "bgp": [{
+                "local_as": "300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {
+                                    "dest_link": {
+                                        "r3-link1": {}
+                                    }
+                                },
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {},
+                                        "r3-link2": {},
+                                        "r3-link3": {},
+                                        "r3-link4": {},
+                                        "r3-link5": {},
+                                        "r3-link6": {},
+                                        "r3-link7": {},
+                                        "r3-link8": {}
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {
+                                    "dest_link": {
+                                        "r3-link1": {}
+                                    }
+                                },
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {},
+                                        "r3-link2": {},
+                                        "r3-link3": {},
+                                        "r3-link4": {},
+                                        "r3-link5": {},
+                                        "r3-link6": {},
+                                        "r3-link7": {},
+                                        "r3-link8": {}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        ]
+        },
+        "r4": {
+            "links": {
+                "lo": {
+                    "ipv4": "auto",
+                    "ipv6": "auto",
+                    "type": "loopback"
+                },
+                "r3-link1": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link2": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link3": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link4": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link5": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link6": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link7": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                },
+                "r3-link8": {
+                    "ipv4": "auto",
+                    "ipv6": "auto"
+                }
+            },
+            "bgp": [{
+                "local_as": "400",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {
+                                    "dest_link": {
+                                        "r4-link1": {},
+                                        "r4-link2": {},
+                                        "r4-link3": {},
+                                        "r4-link4": {},
+                                        "r4-link5": {},
+                                        "r4-link6": {},
+                                        "r4-link7": {},
+                                        "r4-link8": {}
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {
+                                    "dest_link": {
+                                        "r4-link1": {},
+                                        "r4-link2": {},
+                                        "r4-link3": {},
+                                        "r4-link4": {},
+                                        "r4-link5": {},
+                                        "r4-link6": {},
+                                        "r4-link7": {},
+                                        "r4-link8": {}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        ]
+        }
+    }
+}
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_topo1.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_topo1.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_topo1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_topo1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,132 @@
+{
+    "address_types": ["ipv4", "ipv6"],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 30,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {"ipv4": "10.0.0.0", "v4mask": 30, "ipv6": "fd00::", "v6mask": 64},
+    "lo_prefix": {"ipv4": "1.0.", "v4mask": 32, "ipv6": "2001:db8:f::", "v6mask": 128},
+    "routers": {
+        "r1": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r2": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+                                "r2": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    }
+                }
+            },
+            "static_routes":[
+                {
+                   "network":"10.1.1.0/32",
+                   "next_hop":"Null0"
+                },
+                {
+                   "network":"10:1::1:0/128",
+                   "next_hop":"Null0"
+                }]
+            },
+        "r2": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r1": {"ipv4": "auto", "ipv6": "auto"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "200",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r2": {}}},
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r2": {}}},
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r3": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"},
+                "r4": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "400",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_topo2.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_topo2.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_topo2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_topo2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,117 @@
+{
+    "address_types": ["ipv4", "ipv6"],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 30,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {"ipv4": "10.0.0.0", "v4mask": 30, "ipv6": "fd00::", "v6mask": 64},
+    "lo_prefix": {"ipv4": "1.0.", "v4mask": 32, "ipv6": "2001:db8:f::", "v6mask": 128},
+    "routers": {
+        "r1": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "12000100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r1": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r2": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r1": {"ipv4": "auto", "ipv6": "auto"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "12000200",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r2": {}}},
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r2": {}}},
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r3": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"},
+                "r4": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "12000300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {}}},
+                                "r4": {"dest_link": {"r3": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp": {
+                "local_as": "12000400",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r4": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo1.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo1.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,152 @@
+{
+    "address_types": ["ipv4", "ipv6"],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 30,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {"ipv4": "10.0.0.0", "v4mask": 30, "ipv6": "fd00::", "v6mask": 64},
+    "lo_prefix": {"ipv4": "1.0.", "v4mask": 32, "ipv6": "2001:db8:f::", "v6mask": 128},
+    "routers": {
+        "r2": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+
+                "r3": {"ipv4": "auto", "ipv6": "auto"}
+            },
+            "bgp":[
+            {
+                "local_as": "200",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"}
+                             ],
+                            "neighbor": {
+
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    }
+                }
+            }
+            ],
+        "static_routes":[
+            {
+                "network":"10.0.0.1/32",
+                "next_hop":"Null0"
+            },
+            {
+                "network":"10::1/128",
+                "next_hop":"Null0"
+            }]
+        },
+        "r3": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto"},
+                "r4": {"ipv4": "auto", "ipv6": "auto","vrf": "BLUE"}
+            },
+            "vrfs":[
+                {
+                    "name": "BLUE",
+                    "id": "1"
+                }
+            ],
+            "bgp":
+            [
+                {
+                    "local_as": "300",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r2": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r2": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        }
+                    }
+                },
+                {
+                    "local_as": "300",
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto","vrf": "BLUE"}
+            },
+            "vrfs":[
+                {
+                    "name": "BLUE",
+                    "id": "1"
+                }
+            ],
+            "bgp":
+            [
+                {
+                    "local_as": "400",
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r4": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r4": {}}}
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        }
+    }
+}
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo2.json frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo2.json
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/bgp_local_asn_vrf_topo2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,128 @@
+{
+    "address_types": ["ipv4", "ipv6"],
+    "ipv4base": "10.0.0.0",
+    "ipv4mask": 30,
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {"ipv4": "10.0.0.0", "v4mask": 30, "ipv6": "fd00::", "v6mask": 64},
+    "lo_prefix": {"ipv4": "1.0.", "v4mask": 32, "ipv6": "2001:db8:f::", "v6mask": 128},
+    "routers": {
+        "r2": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto","vrf": "RED"}
+            },
+            "vrfs":[{"name": "RED","id": "1"}],
+            "bgp":[
+            {
+                "local_as": "200",
+                "vrf": "RED",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r2": {}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r2": {}}}
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        },
+        "r3": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r2": {"ipv4": "auto", "ipv6": "auto","vrf": "RED"},
+                "r4": {"ipv4": "auto", "ipv6": "auto","vrf": "BLUE"}
+            },
+            "vrfs":[{"name": "RED","id": "1"},
+                {"name": "BLUE","id": "2"}],
+            "bgp":
+            [
+                {
+                    "local_as": "300",
+                    "vrf": "RED",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r2": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r2": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        }
+                    }
+                },
+                {
+                    "local_as": "300",
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {"r3": {}}}
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv4": "auto", "ipv6": "auto", "type": "loopback"},
+                "r3": {"ipv4": "auto", "ipv6": "auto","vrf": "BLUE"}
+            },
+            "vrfs":[{"name": "BLUE","id": "1"}],
+            "bgp":
+            [
+                {
+                    "local_as": "400",
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r4": {}}}
+                                }
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r4": {}}}
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        }
+    }
+}
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_agg.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_agg.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_agg.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_agg.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,420 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+
+"""
+Following tests are covered to test BGP Multi-VRF Dynamic Route Leaking:
+1. Verify the BGP Local AS functionality by aggregating routes  in between eBGP Peers.
+"""
+
+import os
+import sys
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    check_address_types,
+    check_router_status
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    verify_bgp_rib,
+    create_router_bgp,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+BGP_CONVERGENCE = False
+ADDR_TYPES = check_address_types()
+NETWORK_1_1 = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NETWORK_1_2 = {"ipv4": "10.1.2.0/32", "ipv6": "10:1::2:0/128"}
+AGGREGATE_NW = {"ipv4": "10.1.0.0/16", "ipv6": "10:1::/96"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_agg.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+####################################################################################################################
+#
+#   Testcases
+#
+####################################################################################################################
+
+
+def test_verify_bgp_local_as_agg_in_EBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality by aggregating routes  in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Done in base config: Advertise prefix 10.1.1.0/24 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/120 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK_1_1[addr_type]}]}
+        }
+
+        input_static_verify_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK_1_2[addr_type]}]}
+        }
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r2", input_static_verify_r2)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure aggregate-address to summarise all the advertised routes.")
+    for addr_type in ADDR_TYPES:
+        route_aggregate = {
+            "r3": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {
+                                "aggregate_address": [
+                                    {
+                                        "network": AGGREGATE_NW[addr_type],
+                                        "summary": True,
+                                        "as_set": True,
+                                    }
+                                ]
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        result = create_router_bgp(tgen, topo, route_aggregate)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that we see a summarised route on advertising router R3 "
+        "and receiving router R4 for both AFIs"
+    )
+
+    for addr_type in ADDR_TYPES:
+        input_static_agg_r1 = {
+            "r1": {"static_routes": [{"network": AGGREGATE_NW[addr_type]}]}
+        }
+        input_static_r1 = {
+            "r1": {"static_routes": [{"network": [NETWORK_1_1[addr_type]]}]}
+        }
+
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": [NETWORK_1_2[addr_type]]}]}
+        }
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_agg_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1", "r2"], [input_static_r1, input_static_r2]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 {100,110,200} by following "
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "{100,110,200}"
+    for addr_type in ADDR_TYPES:
+        input_static_agg_r1 = {
+            "r1": {"static_routes": [{"network": AGGREGATE_NW[addr_type]}]}
+        }
+        result = verify_bgp_rib(
+            tgen, addr_type, dut, input_static_agg_r1, aspath=aspath
+        )
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "{100,200}"
+    for addr_type in ADDR_TYPES:
+        input_static_agg_r1 = {
+            "r1": {"static_routes": [{"network": AGGREGATE_NW[addr_type]}]}
+        }
+        result = verify_bgp_rib(
+            tgen, addr_type, dut, input_static_agg_r1, aspath=aspath
+        )
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 {100,200}"
+    for addr_type in ADDR_TYPES:
+        input_static_agg_r1 = {
+            "r1": {"static_routes": [{"network": AGGREGATE_NW[addr_type]}]}
+        }
+        result = verify_bgp_rib(
+            tgen, addr_type, dut, input_static_agg_r1, aspath=aspath
+        )
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_ecmp.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_ecmp.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_ecmp.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_ecmp.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,524 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+#
+##########################################################################################################################################
+#
+#   Testcases
+#
+###########################################################################################################################################
+###########################################################################################################################################
+#
+# 1.10.1.7. Verify the BGP Local AS functionality with ECMP on 8 links by adding no-prepend and replace-as command in between eBGP Peers.
+#
+#################################################################################################################################################
+
+import os
+import sys
+import time
+import pytest
+import platform
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    create_static_routes,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    check_address_types,
+    check_router_status,
+    create_static_routes,
+    verify_fib_routes,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    verify_bgp_rib,
+    create_router_bgp,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+BGP_CONVERGENCE = False
+NETWORK = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_ecmp.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+##########################################################################################################################################
+#
+#   Testcases
+#
+###########################################################################################################################################
+
+
+def test_verify_bgp_local_as_in_ecmp_EBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality with ECMP on 8 links by
+    adding no-prepend and replace-as command in between eBGP Peers.
+    """
+
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    dut = "r1"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_dict_static_route_redist = {
+            "r1": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {"redistribute": [{"redist_type": "static"}]}
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify IPv4 and IPv6 static routes received on R1")
+        result = verify_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3-link1": {
+                                                    "local_asn": {"local_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    dest_link = {}
+    for link_no in range(1, 9):
+        link = "r3-link" + str(link_no)
+        dest_link[link] = {"local_asn": {"local_as": "110"}}
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {"r4": {"dest_link": dest_link}}
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2-link1": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    dest_link = {}
+    for link_no in range(1, 9):
+        link = "r4-link" + str(link_no)
+        dest_link[link] = {"local_asn": {"remote_as": "110"}}
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {"r3": {"dest_link": dest_link}}
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 & R4")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3-link1": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    dest_link = {}
+    for link_no in range(1, 9):
+        link = "r3-link" + str(link_no)
+        dest_link[link] = {"local_asn": {"local_as": "110"}}
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {"r4": {"dest_link": dest_link}}
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r2": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3-link1": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    dest_link = {}
+    for link_no in range(1, 9):
+        link = "r3-link" + str(link_no)
+        dest_link[link] = {
+            "local_asn": {"local_as": "110", "no_prepend": True, "replace_as": True}
+        }
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {"r4": {"dest_link": dest_link}}
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo1.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo1.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,3655 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+##########################################################################################################
+#
+#   Functionality Testcases
+#
+##########################################################################################################
+"""
+1. Verify the BGP Local AS functionality by adding no-prepend and replace-as command in between eBGP Peers.
+2. Verify the BGP Local AS functionality by configuring 4 Byte AS at R3 and 2 Byte AS at R2 & R4 in between eBGP Peers.
+3. Verify that BGP Local AS functionality by performing graceful restart in between eBGP Peers.
+4. Verify the BGP Local AS functionality by adding another AS & by same AS with AS-Prepend command in between eBGP Peers.
+4. Verify the BGP Local AS functionality by adding no-prepend and replace-as command in between iBGP Peers.
+5. Verify the BGP Local AS functionality with allowas-in in between iBGP Peers.
+6. Verify that BGP Local AS functionality by performing shut/ noshut on the interfaces in between BGP neighbors.
+7. Verify that BGP Local AS functionality by restarting BGP,Zebra  and FRR services and
+   further restarting clear BGP * and shutdown BGP neighbor.
+8. Verify the BGP Local AS functionality with different AS configurations.
+9. Verify the BGP Local AS functionality with R3& R4 with different AS configurations.
+"""
+
+import os
+import sys
+import time
+import pytest
+from copy import deepcopy
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    create_static_routes,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    get_frr_ipv6_linklocal,
+    check_address_types,
+    check_router_status,
+    create_static_routes,
+    verify_fib_routes,
+    create_route_maps,
+    kill_router_daemons,
+    start_router_daemons,
+    shutdown_bringup_interface,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    clear_bgp_and_verify,
+    verify_bgp_rib,
+    modify_as_number,
+    create_router_bgp,
+    verify_bgp_advertised_routes_from_neighbor,
+    verify_graceful_restart,
+    verify_r_bit,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+NETWORK = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+NEXT_HOP_IP_GR = {"ipv4": "10.0.0.5", "ipv6": "fd00:0:0:1::2/64"}
+NEXT_HOP_IP_1 = {"ipv4": "10.0.0.101", "ipv6": "fd00::1"}
+NEXT_HOP_IP_2 = {"ipv4": "10.0.0.102", "ipv6": "fd00::2"}
+
+BGP_CONVERGENCE = False
+PREFERRED_NEXT_HOP = "link_local"
+KEEPALIVETIMER = 1
+HOLDDOWNTIMER = 3
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_topo1.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+##########################################################################################################
+#
+#   Local APIs
+#
+##########################################################################################################
+
+
+def configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name, dut, peer):
+    """
+    This function groups the repetitive function calls into one function.
+    """
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+    return True
+
+
+def next_hop_per_address_family(
+    tgen, dut, peer, addr_type, next_hop_dict, preferred_next_hop=PREFERRED_NEXT_HOP
+):
+    """
+    This function returns link_local or global next_hop per address-family
+    """
+    intferface = topo["routers"][peer]["links"]["{}".format(dut)]["interface"]
+    if addr_type == "ipv6" and "link_local" in preferred_next_hop:
+        next_hop = get_frr_ipv6_linklocal(tgen, peer, intf=intferface)
+    else:
+        next_hop = next_hop_dict[addr_type]
+
+    return next_hop
+
+
+##########################################################################################################
+#
+#   Testcases
+#
+##########################################################################################################
+
+
+def test_verify_bgp_local_as_in_EBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding no-prepend and
+    replace-as command in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_4B_AS_mid_2B_AS_p0(request):
+    """
+    Verify the BGP Local AS functionality by configuring 4 Byte AS
+    at R3 and 2 Byte AS at R2 & R4 in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110"
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {
+                                                    "local_asn": {
+                                                        "remote_as": "12000110"
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-12000110 is got added in the AS list 12000110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "12000110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "12000110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_GR_EBGP_p0(request):
+    """
+    Verify that BGP Local AS functionality by performing graceful restart in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Configure basic BGP Peerings between R1,R2,R3 and R4")
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r1": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP_GR[addr_type],
+                    }
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_dict_static_route_redist = {
+            "r1": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {"redistribute": [{"redist_type": "static"}]}
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        step("Verify IPv4 and IPv6 static routes received on R1")
+        result = verify_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 & R4")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r1": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP_GR[addr_type],
+                    }
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    """
+    GR Steps : Helper BGP router R2, mark and unmark IPV4 routes
+    as stale as the restarting router R3 come up within the restart time
+    """
+    # Create route-map to prefer global next-hop
+    input_dict = {
+        "r2": {
+            "route_maps": {
+                "rmap_global": [
+                    {"action": "permit", "set": {"ipv6": {"nexthop": "prefer-global"}}}
+                ]
+            }
+        },
+        "r3": {
+            "route_maps": {
+                "rmap_global": [
+                    {"action": "permit", "set": {"ipv6": {"nexthop": "prefer-global"}}}
+                ]
+            }
+        },
+    }
+    result = create_route_maps(tgen, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    # Configure neighbor for route map
+    input_dict_neigh_rm = {
+        "r2": {
+            "bgp": {
+                "address_family": {
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {
+                                    "dest_link": {
+                                        "r2": {
+                                            "route_maps": [
+                                                {
+                                                    "name": "rmap_global",
+                                                    "direction": "in",
+                                                }
+                                            ]
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r3": {
+            "bgp": {
+                "address_family": {
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {
+                                    "dest_link": {
+                                        "r3": {
+                                            "route_maps": [
+                                                {
+                                                    "name": "rmap_global",
+                                                    "direction": "in",
+                                                }
+                                            ]
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        },
+    }
+
+    result = create_router_bgp(tgen, topo, input_dict_neigh_rm)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    # Configure graceful-restart
+    input_dict = {
+        "r2": {
+            "bgp": {
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {
+                                    "dest_link": {
+                                        "r2": {
+                                            "graceful-restart-helper": True,
+                                            "local_asn": {"remote_as": "110"},
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {
+                                    "dest_link": {
+                                        "r2": {
+                                            "graceful-restart-helper": True,
+                                            "local_asn": {"remote_as": "110"},
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    },
+                }
+            }
+        },
+        "r3": {
+            "bgp": {
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {"graceful-restart": True}}}
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3": {"graceful-restart": True}}}
+                            }
+                        }
+                    },
+                }
+            }
+        },
+    }
+
+    configure_gr_followed_by_clear(tgen, topo, input_dict, tc_name, dut="r3", peer="r2")
+    for addr_type in ADDR_TYPES:
+        result = verify_graceful_restart(
+            tgen, topo, addr_type, input_dict, dut="r3", peer="r2"
+        )
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        # Verifying BGP RIB routes
+        dut = "r2"
+        peer = "r3"
+        next_hop = next_hop_per_address_family(
+            tgen, dut, peer, addr_type, NEXT_HOP_IP_2, preferred_next_hop="global"
+        )
+        input_topo = {key: topo["routers"][key] for key in ["r3"]}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_topo)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        # Verifying RIB routes
+        result = verify_rib(tgen, addr_type, dut, input_topo, next_hop, "bgp")
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+    logger.info("[Phase 2] : R3 goes for reload  ")
+
+    kill_router_daemons(tgen, "r3", ["bgpd"])
+
+    logger.info(
+        "[Phase 3] : R3 is still down, restart time 120 sec."
+        " So time verify the routes are present in BGP RIB"
+        " and ZEBRA"
+    )
+
+    for addr_type in ADDR_TYPES:
+        # Verifying BGP RIB routes
+        next_hop = next_hop_per_address_family(
+            tgen, dut, peer, addr_type, NEXT_HOP_IP_2, preferred_next_hop="global"
+        )
+        result = verify_bgp_rib(tgen, addr_type, dut, input_topo, next_hop)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        # Verifying RIB routes
+        protocol = "bgp"
+        result = verify_rib(tgen, addr_type, dut, input_topo, next_hop, protocol)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+    logger.info("[Phase 5] : R3 is about to come up now  ")
+    start_router_daemons(tgen, "r3", ["bgpd"])
+
+    logger.info("[Phase 5] : R3 is UP Now !  ")
+
+    for addr_type in ADDR_TYPES:
+        result = verify_bgp_convergence(tgen, topo)
+        assert (
+            result is True
+        ), "BGP Convergence after BGPd restart" " :Failed \n Error:{}".format(result)
+
+        # Verifying GR stats
+        result = verify_graceful_restart(
+            tgen, topo, addr_type, input_dict, dut="r3", peer="r2"
+        )
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        result = verify_r_bit(tgen, topo, addr_type, input_dict, dut="r2", peer="r3")
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        # Verifying BGP RIB routes
+        next_hop = next_hop_per_address_family(
+            tgen, dut, peer, addr_type, NEXT_HOP_IP_2, preferred_next_hop="global"
+        )
+        result = verify_bgp_rib(tgen, addr_type, dut, input_topo, next_hop)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+        # Verifying RIB routes
+        protocol = "bgp"
+        result = verify_rib(tgen, addr_type, dut, input_topo, next_hop, protocol)
+        assert result is True, "Testcase {} :Failed \n Error {}".format(tc_name, result)
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r2": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_aspath_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding another AS & by same AS with AS-Prepend command in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Configure basic BGP Peerings between R1,R2,R3 and R4")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure a route-map on R3 to prepend AS 2 times.")
+    for addr_type in ADDR_TYPES:
+        input_dict_4 = {
+            "r3": {
+                "route_maps": {
+                    "ASP_{}".format(addr_type): [
+                        {
+                            "action": "permit",
+                            "set": {
+                                "path": {"as_num": "1000 1000", "as_action": "prepend"}
+                            },
+                        }
+                    ]
+                }
+            }
+        }
+        result = create_route_maps(tgen, input_dict_4)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure route map in out direction on R4")
+        # Configure neighbor for route map
+        input_dict_7 = {
+            "r3": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {
+                                            "r3": {
+                                                "route_maps": [
+                                                    {
+                                                        "name": "ASP_{}".format(
+                                                            addr_type
+                                                        ),
+                                                        "direction": "out",
+                                                    }
+                                                ]
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        result = create_router_bgp(tgen, topo, input_dict_7)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step(
+        "Verify that AS-300 is got replaced with 200 in the AS list 110 1000 1000 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r4"
+    aspath = "110 1000 1000 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_iBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding no-prepend and replace-as command in between iBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Modify AS Number for R3")
+    input_dict_modify_as_number = {"r3": {"bgp": {"local_as": 200}}}
+    result = modify_as_number(tgen, topo, input_dict_modify_as_number)
+
+    step("Base config is done as part of JSON")
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_dict_static_route_redist = {
+            "r1": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {"redistribute": [{"redist_type": "static"}]}
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify IPv4 and IPv6 static routes received on R1")
+        result = verify_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "next_hop_self": True,
+                                                    "local_asn": {
+                                                        "remote_as": "200",
+                                                    },
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 & R4")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_allow_as_in_iBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality with allowas-in in between iBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Modidy AS Number for R4")
+    input_dict_modify_as_number = {"r4": {"bgp": {"local_as": 100}}}
+    result = modify_as_number(tgen, topo, input_dict_modify_as_number)
+
+    step("Base config is done as part of JSON")
+    dut = "r1"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_dict_static_route_redist = {
+            "r1": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {"redistribute": [{"redist_type": "static"}]}
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify IPv4 and IPv6 static routes received on R1")
+        result = verify_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(tgen, addr_type, "r1", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure allow-as at R4")
+    for addr_type in ADDR_TYPES:
+        allow_as_config_r4 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "allowas-in": {
+                                                        "number_occurences": 1
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+
+        step(
+            "Configuring allow-as for {} address-family on router R4 ".format(addr_type)
+        )
+        result = create_router_bgp(tgen, topo, allow_as_config_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    # now modify the as in r4 and reconfig bgp in r3 with new remote as.
+    topo1 = deepcopy(topo)
+    topo1["routers"]["r4"]["bgp"]["local_as"] = "100"
+
+    delete_bgp = {"r3": {"bgp": {"delete": True}}}
+    result = create_router_bgp(tgen, topo1, delete_bgp)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "100",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo1)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 & R4")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo1)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r2": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo1, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo1)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_port_reset_p0(request):
+    """
+    Verify that BGP Local AS functionality by performing shut/ noshut on the interfaces in between BGP neighbors.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("Api call to modfiy BGP timers at R3")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_timers = {
+            "r3": {
+                "bgp": {
+                    "local_as": "300",
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {
+                                            "r3": {
+                                                "keepalivetimer": KEEPALIVETIMER,
+                                                "holddowntimer": HOLDDOWNTIMER,
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    },
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_timers)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify advertised routes at R3 towards R4")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    for count in range(1, 1):
+        step("Iteration {}".format(count))
+        step("Shut down connecting interface between R3<<>>R4 on R3.")
+
+        intf1 = topo["routers"]["r3"]["links"]["r4"]["interface"]
+
+        interfaces = [intf1]
+        for intf in interfaces:
+            shutdown_bringup_interface(tgen, "r3", intf, False)
+
+        step(
+            "On R3, all BGP peering in respective vrf instances go down"
+            " when the interface is shut"
+        )
+
+        result = verify_bgp_convergence(tgen, topo, expected=False)
+        assert result is not True, (
+            "Testcase {} :Failed \n "
+            "Expected Behaviour: BGP will not be converged \n "
+            "Error {}".format(tc_name, result)
+        )
+
+    step("BGP neighborship is verified after restart of r3")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_negative2_p0(request):
+    """
+    Verify the BGP Local AS functionality with different AS configurations.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Verify that AS-110 is not prepended in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+    step("Verify that AS-300 is replaced with AS-110 at R3 router.")
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    # configure negative scenarios
+    step("Configure local-as at R3 towards R4.")
+    input_dict_r3 = {
+        "r3": {
+            "bgp": {
+                "local_as": "300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3": {"local_asn": {"local_as": "300"}}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                },
+            }
+        }
+    }
+    if "bgp" in topo["routers"]["r3"].keys():
+        result = create_router_bgp(tgen, topo, input_dict_r3)
+        assert result is not True, (
+            "Testcase {} :Failed \n "
+            "Expected Behaviour: Cannot have local-as same as BGP AS number \n "
+            "Error {}".format(tc_name, result)
+        )
+
+    step("Configure another local-as at R3 towards R4.")
+    input_dict_r3 = {
+        "r3": {
+            "bgp": {
+                "local_as": "110",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3": {"local_asn": {"local_as": "110"}}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                },
+            }
+        }
+    }
+    if "bgp" in topo["routers"]["r3"].keys():
+        result = create_router_bgp(tgen, topo, input_dict_r3)
+        assert result is not True, (
+            "Testcase {} :Failed \n "
+            "Expected Behaviour: Cannot have local-as same as BGP AS number \n "
+            "Error {}".format(tc_name, result)
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_negative3_p0(request):
+    """
+    Verify the BGP Local AS functionality with R3& R4 with different AS configurations.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+        reset_config_on_routers(tgen)
+
+    step("Configure basic BGP Peerings between R1,R2,R3 and R4")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    # Perform Negative scenarios
+    step("Configure another local-as at R3 towards R4.")
+    input_dict_r3 = {
+        "r3": {
+            "bgp": {
+                "local_as": "300",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3": {"local_asn": {"local_as": "300"}}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                },
+            }
+        }
+    }
+    if "bgp" in topo["routers"]["r3"].keys():
+        result = create_router_bgp(tgen, topo, input_dict_r3)
+        assert result is not True, (
+            "Testcase {} :Failed \n "
+            "Expected Behaviour: Cannot have local-as same as BGP AS number \n "
+            "Error {}".format(tc_name, result)
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_EBGP_restart_daemons_p0(request):
+    """
+    Verify that BGP Local AS functionality by restarting BGP,Zebra  and FRR services and
+    further restarting clear BGP * and shutdown BGP neighbor.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(["r2", "r4"], ["200", "400"], ["r3", "r3"]):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step("Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Kill BGPd daemon on R3.")
+    kill_router_daemons(tgen, "r3", ["bgpd"])
+
+    step("Bring up BGPd daemon on R3.")
+    start_router_daemons(tgen, "r3", ["bgpd"])
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify advertised routes at R3 towards R4")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step(
+        "Verify that AS-110 is not prepended in the AS list 200 100 by following "
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Kill BGPd daemon on R3.")
+    kill_router_daemons(tgen, "r3", ["bgpd"])
+
+    step("Bring up BGPd daemon on R3.")
+    start_router_daemons(tgen, "r3", ["bgpd"])
+
+    step(
+        "Verify that AS-110 is not prepended in the AS list 200 100 by following "
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step(
+        "Verified that AS-300 is got replaced with original AS-110 at R4 by following commands"
+    )
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verified that AS-300 is got replaced with original AS-110 at R4 by following commands"
+    )
+    dut = "r4"
+    aspath = "110 200 100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo2.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo2.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,699 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+##########################################################################################################
+#
+#   Testcases
+#
+##########################################################################################################
+##########################################################################################################
+#
+# 1.10.1.2. Verify the BGP Local AS functionality by configuring 4 Byte AS  in between eBGP Peers.
+#
+# 1.10.1.4. Verify the BGP Local AS functionality by configuring Old AS(local as) in 2 bytes and New AS in 4 bytes in between eBGP Peers.
+#
+###############################################################################################################
+
+import os
+import sys
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    create_static_routes,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    check_address_types,
+    check_router_status,
+    create_static_routes,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    verify_bgp_rib,
+    create_router_bgp,
+    verify_bgp_advertised_routes_from_neighbor,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+BGP_CONVERGENCE = False
+ADDR_TYPES = check_address_types()
+NETWORK = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_topo2.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+##########################################################################################################
+#
+#   Testcases
+#
+##########################################################################################################
+
+
+def test_verify_bgp_local_as_in_4_Byte_AS_EBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality by configuring 4 Byte AS  in between eBGP Peers.
+    """
+
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110"
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(
+            ["r2", "r4"], ["12000200", "12000400"], ["r3", "r3"]
+        ):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {
+                                                    "local_asn": {
+                                                        "remote_as": "12000110"
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step(
+        "Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-12000100)."
+    )
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-12000100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r2", "r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-12000110 is got added in the AS list 12000110 12000200 12000100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "12000110 12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    dut = "r3"
+    aspath = "12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "12000110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "12000110 12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_bgp_local_as_in_old_AS2_new_AS4_EBGP_p0(request):
+    """
+    Verify the BGP Local AS functionality by configuring Old AS(local as) in
+    2 bytes and New AS in 4 bytes in between eBGP Peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    for addr_type in ADDR_TYPES:
+        for dut, asn, neighbor in zip(
+            ["r2", "r4"], ["12000200", "12000400"], ["r3", "r3"]
+        ):
+            input_dict_r2_r4 = {
+                dut: {
+                    "bgp": {
+                        "local_as": asn,
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                dut: {"local_asn": {"remote_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r2_r4)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    # configure static routes
+    step(
+        "Done in base config: Advertise prefix 10.1.1.0/32 from Router-1(AS-12000100)."
+    )
+    step(
+        "Done in base config: Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-12000100)."
+    )
+    step("Verify that Static routes are redistributed in BGP process")
+
+    dut = "r1"
+    protocol = "bgp"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_static_r1 = {
+            "r1": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_static_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R1")
+
+        input_static_redist_r1 = {
+            "r1": {
+                "bgp": {
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        }
+                    }
+                }
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_static_redist_r1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that Static routes are redistributed in BGP process")
+    for addr_type in ADDR_TYPES:
+        input_static_verify_r1 = {
+            "r1": {"static_routes": [{"network": NETWORK[addr_type]}]}
+        }
+
+        result = verify_rib(tgen, addr_type, "r1", input_static_verify_r1)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        for dut in ["r3", "r4"]:
+            result = verify_rib(tgen, addr_type, dut, input_static_r1)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        for dut, input_routes in zip(["r1"], [input_static_r1]):
+            result = verify_rib(tgen, addr_type, dut, input_routes)
+            assert result is True, "Testcase {}: Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 12000200 12000100 by following"
+        "commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify advertised routes to R4 at R3")
+    expected_routes = {
+        "ipv4": [
+            {"network": "10.1.1.0/32", "nexthop": ""},
+        ],
+        "ipv6": [
+            {"network": "10:1::1:0/128", "nexthop": ""},
+        ],
+    }
+    result = verify_bgp_advertised_routes_from_neighbor(
+        tgen, topo, dut="r3", peer="r4", expected_routes=expected_routes
+    )
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    dut = "r3"
+    aspath = "12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4 & R2.")
+    for addr_type in ADDR_TYPES:
+        for neighbor in ["r2", "r4"]:
+            input_dict_r3 = {
+                "r3": {
+                    "bgp": {
+                        "local_as": "12000300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        neighbor: {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                }
+            }
+            result = create_router_bgp(tgen, topo, input_dict_r3)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 12000200 12000100"
+    for addr_type in ADDR_TYPES:
+        input_static_r1 = {"r1": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r1, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo1.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo1.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,1108 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+1. Verify the BGP Local AS functionality by adding new AS when dynamically import routes
+ from default vrf to non-default vrf with route map by adding AS by as-prepend command.
+2. Verify the BGP Local AS functionality by adding new AS when dynamically import routes
+ from non-default vrf to default vrf and further advertised to eBGP peers.
+"""
+
+import os
+import sys
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    create_static_routes,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    check_address_types,
+    check_router_status,
+    create_static_routes,
+    verify_fib_routes,
+    create_route_maps,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    verify_bgp_rib,
+    create_router_bgp,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+BGP_CONVERGENCE = False
+ADDR_TYPES = check_address_types()
+NETWORK = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_vrf_topo1.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+################################################################################################
+#
+#   Testcases
+#
+###############################################################################################
+
+
+def test_verify_local_asn_ipv4_import_from_default_to_non_default_VRF_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding new AS when dynamically import routes
+    from default vrf to non-default vrf with route map by adding AS by as-prepend command.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+
+    # configure static routes
+    step("Advertise prefix 10.0.0.1/32 from Router-1(AS-100).")
+    step("Advertise an ipv6 prefix 10::1/128 from Router-1(AS-100).")
+    dut = "r2"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r2": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure redistribute static in Router BGP in R2")
+        input_dict_static_route_redist = {
+            "r2": {
+                "bgp": [
+                    {
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {"redistribute": [{"redist_type": "static"}]}
+                            }
+                        }
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure import vrf BLUE on R3 under IPv4 Address Family")
+    input_import_vrf_ipv4 = {
+        "r3": {
+            "bgp": [
+                {
+                    "local_as": 300,
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {"unicast": {"import": {"vrf": "default"}}},
+                        "ipv6": {"unicast": {"import": {"vrf": "default"}}},
+                    },
+                }
+            ]
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_import_vrf_ipv4)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify IPv4 and IPv6 static routes received on R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_static_route = {
+            "r2": {
+                "static_routes": [
+                    {"network": NETWORK[addr_type], "next_hop": NEXT_HOP_IP[addr_type]}
+                ]
+            }
+        }
+        result = verify_rib(tgen, addr_type, "r2", input_dict_static_route)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r2", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(tgen, addr_type, "r2", input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 VRF BLUE & R4 VRF BLUE")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure a route-map on R3 to prepend AS 2 times.")
+    for addr_type in ADDR_TYPES:
+        input_dict_4 = {
+            "r3": {
+                "route_maps": {
+                    "ASP_{}".format(addr_type): [
+                        {
+                            "action": "permit",
+                            "set": {
+                                "path": {"as_num": "1000 1000", "as_action": "prepend"}
+                            },
+                        }
+                    ]
+                }
+            }
+        }
+        result = create_route_maps(tgen, input_dict_4)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("configure route map in out direction on R4")
+        # Configure neighbor for route map
+        input_dict_7 = {
+            "r3": {
+                "bgp": {
+                    "local_as": "300",
+                    "vrf": "BLUE",
+                    "address_family": {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r4": {
+                                        "dest_link": {
+                                            "r3": {
+                                                "route_maps": [
+                                                    {
+                                                        "name": "ASP_{}".format(
+                                                            addr_type
+                                                        ),
+                                                        "direction": "out",
+                                                    }
+                                                ]
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    },
+                }
+            }
+        }
+
+        result = create_router_bgp(tgen, topo, input_dict_7)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 1000 1000 200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+def test_verify_local_asn_ipv4_import_from_non_default_to_default_VRF_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding new AS when dynamically import routes
+    from non-default vrf to default vrf and further advertised to eBGP peers.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Resetting the config from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+    # configure static routes
+    step("Advertise prefix 10.0.0.1/32 from Router-1(AS-100).")
+    step("Advertise an ipv6 prefix 10::1/128 from Router-1(AS-100).")
+    dut = "r4"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("configure redistribute static in Router BGP in R4")
+    input_dict_static_route_redist = {
+        "r4": {
+            "bgp": {
+                "local_as": 400,
+                "vrf": "BLUE",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"},
+                                {"redist_type": "connected"},
+                            ]
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"},
+                                {"redist_type": "connected"},
+                            ]
+                        }
+                    },
+                },
+            }
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Configure import from BLUE vrf to default vrf on R3 under IPv4 Address Family"
+    )
+    input_import_vrf_ipv4 = {
+        "r3": {
+            "bgp": [
+                {
+                    "local_as": 300,
+                    "vrf": "default",
+                    "address_family": {
+                        "ipv4": {"unicast": {"import": {"vrf": "BLUE"}}},
+                        "ipv6": {"unicast": {"import": {"vrf": "BLUE"}}},
+                    },
+                }
+            ]
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_import_vrf_ipv4)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify IPv4 and IPv6 static routes received on R3 VRF BLUE & R4 VRF BLUE")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_static_route_from_r4 = {
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                    }
+                ]
+            }
+        }
+        result = verify_rib(tgen, addr_type, "r2", input_dict_static_route_from_r4)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_bgp_rib(tgen, addr_type, "r2", input_dict_static_route_from_r4)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+        result = verify_fib_routes(
+            tgen, addr_type, "r2", input_dict_static_route_from_r4
+        )
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 400 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 400"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {"r4": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+    dut = "r3"
+    aspath = "400"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {"r4": {"static_routes": [{"network": NETWORK[addr_type]}]}}
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ]
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r2"
+    aspath = "110 400"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                    }
+                ]
+            }
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo2.py frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo2.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_local_asn/test_bgp_local_asn_vrf_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,826 @@
+#!/usr/bin/env python3
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+1. Verify the BGP Local AS functionality by adding new AS when leaking routes
+ from non-default VRF to non-default with route map by prefix lists.
+"""
+
+import os
+import sys
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    create_static_routes,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    check_address_types,
+    check_router_status,
+    create_static_routes,
+    create_prefix_lists,
+    verify_fib_routes,
+    create_route_maps,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    verify_bgp_rib,
+    create_router_bgp,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+BGP_CONVERGENCE = False
+ADDR_TYPES = check_address_types()
+NETWORK = {"ipv4": "10.1.1.0/32", "ipv6": "10:1::1:0/128"}
+NEXT_HOP_IP = {"ipv4": "Null0", "ipv6": "Null0"}
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_local_asn_vrf_topo2.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+################################################################################################
+#
+#   Testcases
+#
+###############################################################################################
+
+
+def test_verify_local_asn_ipv4_import_from_non_default_to_non_default_VRF_p0(request):
+    """
+    Verify the BGP Local AS functionality by adding new AS when leaking routes
+    from non-default VRF to non-default with route map by prefix lists.
+    """
+    tgen = get_topogen()
+    global BGP_CONVERGENCE
+    if BGP_CONVERGENCE != True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+    reset_config_on_routers(tgen)
+
+    step("Base config is done as part of JSON")
+
+    # configure static routes
+    step("Advertise prefix 10.1.1.0/32 from Router-1(AS-100).")
+    step("Advertise an ipv6 prefix 10:1::1:0/128 from Router-1(AS-100).")
+    dut = "r2"
+    for addr_type in ADDR_TYPES:
+        # Enable static routes
+        input_dict_static_route = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "RED",
+                    }
+                ]
+            }
+        }
+
+        logger.info("Configure static routes")
+        result = create_static_routes(tgen, input_dict_static_route)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("configure redistribute static in Router BGP in R2")
+    input_dict_static_route_redist = {
+        "r2": {
+            "bgp": {
+                "local_as": 200,
+                "vrf": "RED",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"},
+                                {"redist_type": "connected"},
+                            ]
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "redistribute": [
+                                {"redist_type": "static"},
+                                {"redist_type": "connected"},
+                            ]
+                        }
+                    },
+                },
+            }
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_dict_static_route_redist)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure import vrf BLUE from vrf RED on R3 under IPv4 Address Family")
+    input_import_vrf_ipv4 = {
+        "r3": {
+            "bgp": [
+                {
+                    "local_as": 300,
+                    "vrf": "BLUE",
+                    "address_family": {
+                        "ipv4": {"unicast": {"import": {"vrf": "RED"}}},
+                        "ipv6": {"unicast": {"import": {"vrf": "RED"}}},
+                    },
+                }
+            ]
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_import_vrf_ipv4)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify IPv4 and IPv6 static routes received on R3 VRF BLUE & R4 VRF BLUE")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step("Configure local-as at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r2 = {
+            "r3": {
+                "vrfs": [{"name": "RED", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "RED",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r3_to_r4 = {
+            "r3": {
+                "vrfs": [{"name": "BLUE", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {"local_asn": {"local_as": "110"}}
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R2 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r2_to_r3 = {
+            "r2": {
+                "vrfs": [{"name": "RED", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "200",
+                        "vrf": "RED",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r2": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r2_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure remote-as at R4 towards R3.")
+    for addr_type in ADDR_TYPES:
+        input_dict_r4_to_r3 = {
+            "r4": {
+                "vrfs": [{"name": "BLUE", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "400",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r3": {
+                                            "dest_link": {
+                                                "r4": {
+                                                    "local_asn": {"remote_as": "110"}
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_r4_to_r3)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    step("Verify IPv4 and IPv6 static routes received on R3 VRF BLUE & R4 VRF BLUE")
+    for addr_type in ADDR_TYPES:
+        static_routes_input = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+        for dut in ["r3", "r4"]:
+            result = verify_fib_routes(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes_input)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Verify that AS-110 is got added in the AS list 110 200 100 by following "
+        " commands at R3 router."
+    )
+    dut = "r3"
+    aspath = "110 200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    # configure the prefix-list and route-maps.
+    for adt in ADDR_TYPES:
+        # Create Static routes
+        input_dict_rm1 = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": NETWORK[adt],
+                        "no_of_ip": 1,
+                        "next_hop": NEXT_HOP_IP[adt],
+                        "vrf": "RED",
+                    }
+                ]
+            }
+        }
+
+        result = create_static_routes(tgen, input_dict_rm1)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        # Api call to redistribute static routes
+        input_dict_rm_rd = {
+            "r2": {
+                "bgp": {
+                    "local_as": 200,
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {
+                                "redistribute": [
+                                    {"redist_type": "static"},
+                                    {"redist_type": "connected"},
+                                ]
+                            }
+                        },
+                        "ipv6": {
+                            "unicast": {
+                                "redistribute": [
+                                    {"redist_type": "static"},
+                                    {"redist_type": "connected"},
+                                ]
+                            }
+                        },
+                    },
+                }
+            }
+        }
+
+        result = create_router_bgp(tgen, topo, input_dict_rm_rd)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        input_dict_rm_pl = {
+            "r3": {
+                "prefix_lists": {
+                    "ipv4": {
+                        "pf_list_1_ipv4": [
+                            {
+                                "seqid": 10,
+                                "action": "permit",
+                                "network": NETWORK["ipv4"],
+                            }
+                        ]
+                    },
+                    "ipv6": {
+                        "pf_list_1_ipv6": [
+                            {
+                                "seqid": 100,
+                                "action": "permit",
+                                "network": NETWORK["ipv6"],
+                            }
+                        ]
+                    },
+                }
+            }
+        }
+        result = create_prefix_lists(tgen, input_dict_rm_pl)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        # Create route map
+        for addr_type in ADDR_TYPES:
+            input_dict_rm_r3 = {
+                "r3": {
+                    "route_maps": {
+                        "rmap_match_tag_1_{}".format(addr_type): [
+                            {
+                                "action": "permit",
+                                "match": {
+                                    addr_type: {
+                                        "prefix_lists": "pf_list_1_{}".format(addr_type)
+                                    }
+                                },
+                            }
+                        ],
+                        "rmap_match_tag_2_{}".format(addr_type): [
+                            {
+                                "action": "permit",
+                                "match": {
+                                    addr_type: {
+                                        "prefix_lists": "pf_list_2_{}".format(addr_type)
+                                    }
+                                },
+                            }
+                        ],
+                    }
+                }
+            }
+            result = create_route_maps(tgen, input_dict_rm_r3)
+            assert result is True, "Testcase {} : Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        # Configure neighbor for route map
+        input_dict_conf_neighbor_rm = {
+            "r3": {
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            "ipv4": {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "route_maps": [
+                                                        {
+                                                            "name": "rmap_match_tag_1_ipv4",
+                                                            "direction": "out",
+                                                        },
+                                                        {
+                                                            "name": "rmap_match_tag_1_ipv4",
+                                                            "direction": "out",
+                                                        },
+                                                    ]
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            },
+                            "ipv6": {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "route_maps": [
+                                                        {
+                                                            "name": "rmap_match_tag_1_ipv6",
+                                                            "direction": "in",
+                                                        },
+                                                        {
+                                                            "name": "rmap_match_tag_1_ipv6",
+                                                            "direction": "out",
+                                                        },
+                                                    ]
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            },
+                        },
+                    }
+                ]
+            }
+        }
+
+        result = create_router_bgp(tgen, topo, input_dict_conf_neighbor_rm)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for adt in ADDR_TYPES:
+        # Verifying RIB routes
+        dut = "r3"
+        input_dict_r2_rib = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": [NETWORK[adt]],
+                        "no_of_ip": 1,
+                        "next_hop": NEXT_HOP_IP[adt],
+                        "vrf": "RED",
+                    }
+                ]
+            }
+        }
+        result = verify_rib(tgen, adt, dut, input_dict_r2_rib)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        # Verifying RIB routes
+        dut = "r4"
+        input_dict_r2_rib = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": [NETWORK[adt]],
+                        "no_of_ip": 1,
+                        "next_hop": NEXT_HOP_IP[adt],
+                        "vrf": "BLUE",
+                    }
+                ]
+            }
+        }
+        result = verify_rib(tgen, adt, dut, input_dict_r2_rib)
+        assert result is True, "Testcase {}: Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R2.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r2 = {
+            "r3": {
+                "vrfs": [{"name": "RED", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "RED",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend at R3 towards R4.")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_r3_to_r4 = {
+            "r3": {
+                "vrfs": [{"name": "BLUE", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r3"
+    aspath = "200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R2")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r2 = {
+            "r3": {
+                "vrfs": [{"name": "RED", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "RED",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r2": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r2)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Configure local-as with no-prepend and replace-as at R3 towards R4")
+    for addr_type in ADDR_TYPES:
+        input_dict_no_prep_rep_as_r3_to_r4 = {
+            "r3": {
+                "vrfs": [{"name": "BLUE", "id": "1"}],
+                "bgp": [
+                    {
+                        "local_as": "300",
+                        "vrf": "BLUE",
+                        "address_family": {
+                            addr_type: {
+                                "unicast": {
+                                    "neighbor": {
+                                        "r4": {
+                                            "dest_link": {
+                                                "r3": {
+                                                    "local_asn": {
+                                                        "local_as": "110",
+                                                        "no_prepend": True,
+                                                        "replace_as": True,
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        },
+                    }
+                ],
+            }
+        }
+        result = create_router_bgp(tgen, topo, input_dict_no_prep_rep_as_r3_to_r4)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("BGP neighborship is verified by following commands in R3 routers")
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "BGP convergence :Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    dut = "r4"
+    aspath = "110 200"
+    for addr_type in ADDR_TYPES:
+        input_static_r2 = {
+            "r2": {"static_routes": [{"network": NETWORK[addr_type], "vrf": "BLUE"}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, dut, input_static_r2, aspath=aspath)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_lu_topo1/R1/labelpool.summ.json frr-frr-8.5/tests/topotests/bgp_lu_topo1/R1/labelpool.summ.json
--- frr-frr-8.4.2/tests/topotests/bgp_lu_topo1/R1/labelpool.summ.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_lu_topo1/R1/labelpool.summ.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,8 +1,8 @@
 {
-  "Ledger":506,
-  "InUse":506,
-  "Requests":0,
-  "LabelChunks":3,
-  "Pending":0,
-  "Reconnects":0
+  "ledger":506,
+  "inUse":506,
+  "requests":0,
+  "labelChunks":3,
+  "pending":0,
+  "reconnects":0
 }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_lu_topo1/R2/labelpool.summ.json frr-frr-8.5/tests/topotests/bgp_lu_topo1/R2/labelpool.summ.json
--- frr-frr-8.4.2/tests/topotests/bgp_lu_topo1/R2/labelpool.summ.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_lu_topo1/R2/labelpool.summ.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,8 +1,8 @@
 {
-  "Ledger":0,
-  "InUse":0,
-  "Requests":0,
-  "LabelChunks":0,
-  "Pending":0,
-  "Reconnects":0
+  "ledger":0,
+  "inUse":0,
+  "requests":0,
+  "labelChunks":0,
+  "pending":0,
+  "reconnects":0
 }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_lu_topo2/R1/labelpool.summ.json frr-frr-8.5/tests/topotests/bgp_lu_topo2/R1/labelpool.summ.json
--- frr-frr-8.4.2/tests/topotests/bgp_lu_topo2/R1/labelpool.summ.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_lu_topo2/R1/labelpool.summ.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,8 +1,8 @@
 {
-  "Ledger":51,
-  "InUse":51,
-  "Requests":0,
-  "LabelChunks":1,
-  "Pending":0,
-  "Reconnects":0
+  "ledger":51,
+  "inUse":51,
+  "requests":0,
+  "labelChunks":1,
+  "pending":0,
+  "reconnects":0
 }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_lu_topo2/R2/labelpool.summ.json frr-frr-8.5/tests/topotests/bgp_lu_topo2/R2/labelpool.summ.json
--- frr-frr-8.4.2/tests/topotests/bgp_lu_topo2/R2/labelpool.summ.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_lu_topo2/R2/labelpool.summ.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,8 +1,8 @@
 {
-  "Ledger":1,
-  "InUse":1,
-  "Requests":0,
-  "LabelChunks":1,
-  "Pending":0,
-  "Reconnects":0
+  "ledger":1,
+  "inUse":1,
+  "requests":0,
+  "labelChunks":1,
+  "pending":0,
+  "reconnects":0
 }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+!
+router bgp 65001
+  bgp max-med on-startup 5 777
+  no bgp ebgp-requires-policy
+  neighbor 192.168.255.2 remote-as 65001
+  neighbor 192.168.255.2 timers 3 10
+  address-family ipv4 unicast
+    redistribute connected
+  exit-address-family
+  !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 172.16.255.254/32
+!
+interface r1-eth0
+ ip address 192.168.255.1/30
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+router bgp 65001
+  no bgp ebgp-requires-policy
+  neighbor 192.168.255.1 remote-as 65001
+  neighbor 192.168.255.1 timers 3 10
+  !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+!
+interface r2-eth0
+ ip address 192.168.255.2/30
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/test_bgp_max_med_on_startup.py frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/test_bgp_max_med_on_startup.py
--- frr-frr-8.4.2/tests/topotests/bgp_max_med_on_startup/test_bgp_max_med_on_startup.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_max_med_on_startup/test_bgp_max_med_on_startup.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,114 @@
+#!/usr/bin/env python
+
+#
+# test_bgp_max_med_on_startup.py
+#
+# Copyright (c) 2022 Rubicon Communications, LLC.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Test whether `bgp max-med on-startup (5-86400) [(0-4294967295)]` is working
+correctly.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 3):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_max_med_on_startup():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    router1 = tgen.gears["r1"]
+    router2 = tgen.gears["r2"]
+
+    def _bgp_converge(router):
+        output = json.loads(router.vtysh_cmd("show ip bgp neighbor 192.168.255.1 json"))
+        expected = {"192.168.255.1": {"bgpState": "Established"}}
+        return topotest.json_cmp(output, expected)
+
+    def _bgp_has_routes(router, metric):
+        output = json.loads(
+            router.vtysh_cmd("show ip bgp neighbor 192.168.255.1 routes json")
+        )
+        expected = {"routes": {"172.16.255.254/32": [{"metric": metric}]}}
+        return topotest.json_cmp(output, expected)
+
+    # Check session is established
+    test_func = functools.partial(_bgp_converge, router2)
+    success, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Failed bgp convergence on r2"
+
+    # Check metric has value of max-med
+    test_func = functools.partial(_bgp_has_routes, router2, 777)
+    success, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "r2 does not receive routes with metric 777"
+
+    # Check that when the max-med timer expires, metric is updated
+    test_func = functools.partial(_bgp_has_routes, router2, 0)
+    success, result = topotest.run_and_expect(test_func, None, count=16, wait=0.5)
+    assert result is None, "r2 does not receive routes with metric 0"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,13 @@
 router bgp 65000
-  no bgp ebgp-requires-policy
-  neighbor 192.168.255.2 remote-as 65001
-  neighbor 192.168.255.2 timers 3 10
-  address-family ipv4 unicast
-    redistribute connected
+ no bgp ebgp-requires-policy
+ neighbor 192.168.255.2 remote-as 65001
+ neighbor 192.168.255.2 timers 3 10
+ address-family ipv4 unicast
+  redistribute connected
+  neighbor 192.168.255.2 prefix-list r2 out
+ exit-address-family
+ !
+!
+ip prefix-list r2 seq 5 permit 172.16.255.253/32
+ip prefix-list r2 seq 10 permit 172.16.255.254/32
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,7 @@
 !
 interface lo
  ip address 172.16.255.254/32
+ ip address 172.16.255.253/32
 !
 interface r1-eth0
  ip address 192.168.255.1/24
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/r2/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,9 @@
 router bgp 65001
-  no bgp ebgp-requires-policy
-  neighbor 192.168.255.1 remote-as 65000
-  neighbor 192.168.255.1 timers 3 10
-  address-family ipv4
-    neighbor 192.168.255.1 maximum-prefix 1
+ no bgp ebgp-requires-policy
+ neighbor 192.168.255.1 remote-as 65000
+ neighbor 192.168.255.1 timers 3 10
+ address-family ipv4
+  neighbor 192.168.255.1 maximum-prefix 1
+ exit-address-family
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/test_bgp_maximum_prefix_invalid_update.py frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/test_bgp_maximum_prefix_invalid_update.py
--- frr-frr-8.4.2/tests/topotests/bgp_maximum_prefix_invalid_update/test_bgp_maximum_prefix_invalid_update.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_maximum_prefix_invalid_update/test_bgp_maximum_prefix_invalid_update.py	2023-03-13 20:01:47.000000000 +0600
@@ -36,11 +36,13 @@ import os
 import sys
 import json
 import pytest
+import functools
 
 CWD = os.path.dirname(os.path.realpath(__file__))
 sys.path.append(os.path.join(CWD, "../"))
 
 # pylint: disable=C0413
+from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
 
 pytestmark = [pytest.mark.bgpd]
@@ -83,29 +85,21 @@ def test_bgp_maximum_prefix_invalid():
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    def _bgp_converge(router):
-        while True:
-            output = json.loads(
-                tgen.gears[router].vtysh_cmd("show ip bgp neighbor 192.168.255.1 json")
-            )
-            if output["192.168.255.1"]["connectionsEstablished"] > 0:
-                return True
-
-    def _bgp_parsing_nlri(router):
-        cmd_max_exceeded = (
-            'grep "%MAXPFXEXCEED: No. of IPv4 Unicast prefix received" bgpd.log'
-        )
-        cmdt_error_parsing_nlri = 'grep "Error parsing NLRI" bgpd.log'
-        output_max_exceeded = tgen.gears[router].run(cmd_max_exceeded)
-        output_error_parsing_nlri = tgen.gears[router].run(cmdt_error_parsing_nlri)
-
-        if len(output_max_exceeded) > 0:
-            if len(output_error_parsing_nlri) > 0:
-                return False
-        return True
+    r2 = tgen.gears["r2"]
 
-    if _bgp_converge("r2"):
-        assert _bgp_parsing_nlri("r2") == True
+    def _bgp_parsing_nlri():
+        output = json.loads(r2.vtysh_cmd("show ip bgp neighbor 192.168.255.1 json"))
+        expected = {
+            "192.168.255.1": {
+                "lastNotificationReason": "Cease/Maximum Number of Prefixes Reached",
+                "lastResetDueTo": "BGP Notification send",
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_parsing_nlri)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Didn't send NOTIFICATION when hitting maximum-prefix"
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/exabgp.env frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/exabgp.env
--- frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/exabgp.env	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/exabgp.env	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,53 @@
+[exabgp.api]
+encoder = text
+highres = false
+respawn = false
+socket = ''
+
+[exabgp.bgp]
+openwait = 60
+
+[exabgp.cache]
+attributes = true
+nexthops = true
+
+[exabgp.daemon]
+daemonize = true
+pid = '/var/run/exabgp/exabgp.pid'
+user = 'exabgp'
+##daemonize = false
+
+[exabgp.log]
+all = false
+configuration = true
+daemon = true
+destination = '/var/log/exabgp.log'
+enable = true
+level = INFO
+message = false
+network = true
+packets = false
+parser = false
+processes = true
+reactor = true
+rib = false
+routes = false
+short = false
+timers = false
+
+[exabgp.pdb]
+enable = false
+
+[exabgp.profile]
+enable = false
+file = ''
+
+[exabgp.reactor]
+speed = 1.0
+
+[exabgp.tcp]
+acl = false
+bind = ''
+delay = 0
+once = false
+port = 179
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/peer1/exabgp.cfg frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/peer1/exabgp.cfg
--- frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/peer1/exabgp.cfg	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/peer1/exabgp.cfg	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,24 @@
+neighbor 10.0.0.1 {
+  router-id 10.0.0.2;
+  local-address 10.0.0.2;
+  local-as 65001;
+  peer-as 65002;
+
+  capability {
+    route-refresh;
+  }
+
+  static {
+    route 192.168.100.101/32 {
+      atomic-aggregate;
+      community 65001:101;
+      next-hop 10.0.0.2;
+    }
+
+    route 192.168.100.102/32 {
+      originator-id 10.0.0.2;
+      community 65001:102;
+      next-hop 10.0.0.2;
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+!
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 10.0.0.2 remote-as external
+ neighbor 10.0.0.2 timers 3 10
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+interface r1-eth0
+ ip address 10.0.0.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/test_bgp_path_attribute_discard.py frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/test_bgp_path_attribute_discard.py
--- frr-frr-8.4.2/tests/topotests/bgp_path_attribute_discard/test_bgp_path_attribute_discard.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_attribute_discard/test_bgp_path_attribute_discard.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,159 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Test if `neighbor path-attribute discard` command works correctly,
+can discard unwanted attributes from UPDATE messages, and ignore them
+by continuing to process UPDATE messages.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    r1 = tgen.add_router("r1")
+    peer1 = tgen.add_exabgp_peer("peer1", ip="10.0.0.2", defaultRoute="via 10.0.0.1")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(r1)
+    switch.add_link(peer1)
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router = tgen.gears["r1"]
+    router.load_config(TopoRouter.RD_ZEBRA, os.path.join(CWD, "r1/zebra.conf"))
+    router.load_config(TopoRouter.RD_BGP, os.path.join(CWD, "r1/bgpd.conf"))
+    router.start()
+
+    peer = tgen.gears["peer1"]
+    peer.start(os.path.join(CWD, "peer1"), os.path.join(CWD, "exabgp.env"))
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_path_attribute_discard():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+
+    def _bgp_converge():
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast json detail"))
+        expected = {
+            "routes": {
+                "192.168.100.101/32": [
+                    {
+                        "valid": True,
+                        "atomicAggregate": True,
+                        "community": {
+                            "string": "65001:101",
+                        },
+                    }
+                ],
+                "192.168.100.102/32": [
+                    {
+                        "valid": True,
+                        "originatorId": "10.0.0.2",
+                        "community": {
+                            "string": "65001:102",
+                        },
+                    }
+                ],
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Failed bgp convergence"
+
+    step("Discard atomic-aggregate, community, and originator-id attributes from peer1")
+    r1.vtysh_cmd(
+        """
+    configure terminal
+        router bgp
+            neighbor 10.0.0.2 path-attribute discard 6 8 9
+    """
+    )
+
+    def _bgp_check_if_attributes_discarded():
+        output = json.loads(r1.vtysh_cmd("show bgp ipv4 unicast json detail"))
+        expected = {
+            "routes": {
+                "192.168.100.101/32": [
+                    {
+                        "valid": True,
+                        "atomicAggregate": None,
+                        "community": None,
+                    }
+                ],
+                "192.168.100.102/32": [
+                    {
+                        "valid": True,
+                        "originatorId": None,
+                        "community": None,
+                    }
+                ],
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_if_attributes_discarded)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert (
+        result is None
+    ), "Failed to discard path attributes (atomic-aggregate, community, and originator-id)"
+
+
+def test_memory_leak():
+    "Run the memory leak test and report results."
+    tgen = get_topogen()
+    if not tgen.is_memleak_enabled():
+        pytest.skip("Memory leak test/report is disabled")
+
+    tgen.report_memory_leaks()
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,28 @@
+router bgp 65001
+ no bgp ebgp-requires-policy
+ neighbor 192.0.2.2 remote-as 65002
+ neighbor 192.0.2.2 timers 1 3
+ neighbor 192.0.2.2 timers connect 1
+ neighbor 192.0.2.2 ebgp-multihop 2
+ neighbor 192.0.2.3 remote-as 65002
+ neighbor 192.0.2.3 timers 1 3
+ neighbor 192.0.2.3 timers connect 1
+ neighbor 192.0.2.3 ebgp-multihop 2
+ address-family ipv4
+  redistribute connected
+ exit-address-family
+ address-family ipv4 vpn
+  neighbor 192.0.2.2 activate
+  neighbor 192.0.2.3 activate
+ exit-address-family
+!
+router bgp 65001 vrf vrf1
+ bgp router-id 192.0.2.1
+ address-family ipv4 unicast
+  label vpn export 101
+  rd vpn export 101:1
+  rt vpn both 52:100
+  import vpn
+  export vpn
+ exit-address-family
+!
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/ldpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r1/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r1/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,26 @@
+hostname r1
+log file ldpd.log
+password zebra
+!
+! debug mpls ldp zebra
+! debug mpls ldp event
+! debug mpls ldp errors
+! debug mpls ldp messages recv
+! debug mpls ldp messages sent
+! debug mpls ldp discovery hello recv
+! debug mpls ldp discovery hello sent
+!
+mpls ldp
+ router-id 192.0.2.1
+ !
+ address-family ipv4
+  discovery transport-address 192.0.2.1
+  !
+  interface r1-eth0
+  !
+  interface r1-eth1
+  !
+ !
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/staticd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r1/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r1/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+ip route 192.0.2.2/32 192.168.1.2
+ip route 192.0.2.3/32 192.168.2.2
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,11 @@
+!
+interface lo
+ ip address 192.0.2.1/32
+ ip address 172.16.255.1/32
+!
+interface r1-eth0
+ ip address 192.168.1.1/24
+!
+interface r1-eth1
+ ip address 192.168.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,25 @@
+router bgp 65002
+ no bgp network import-check
+ network 192.0.2.8/32
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as 65001
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
+ neighbor 192.168.1.1 ebgp-multihop 2
+ neighbor 192.168.1.1 update-source 192.0.2.2
+ address-family ipv4 vpn
+  neighbor 192.168.1.1 activate
+ exit-address-family
+!
+router bgp 65002 vrf vrf1
+ bgp router-id 192.0.2.2
+ no bgp ebgp-requires-policy
+ address-family ipv4 unicast
+  redistribute connected
+  label vpn export 102
+  rd vpn export 102:1
+  rt vpn both 52:100
+  import vpn
+  export vpn
+ exit-address-family
+!
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/ldpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r2/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r2/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,26 @@
+hostname r2
+log file ldpd.log
+password zebra
+!
+! debug mpls ldp zebra
+! debug mpls ldp event
+! debug mpls ldp errors
+! debug mpls ldp messages recv
+! debug mpls ldp messages sent
+! debug mpls ldp discovery hello recv
+! debug mpls ldp discovery hello sent
+!
+mpls ldp
+ router-id 192.0.2.2
+ !
+ address-family ipv4
+  discovery transport-address 192.0.2.2
+  !
+  interface r2-eth0
+  !
+  interface r2-eth1
+  !
+ !
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+int lo
+ ip address 192.0.2.2/32
+!
+interface r2-eth0
+ ip address 192.168.1.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,25 @@
+router bgp 65002
+ no bgp network import-check
+ network 192.0.2.8/32
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as 65001
+ neighbor 192.168.2.1 timers 1 3
+ neighbor 192.168.2.1 timers connect 1
+ neighbor 192.168.2.1 ebgp-multihop 2
+ neighbor 192.168.1.1 update-source 192.0.2.3
+ address-family ipv4 vpn
+  neighbor 192.168.2.1 activate
+ exit-address-family
+!
+router bgp 65002 vrf vrf1
+ bgp router-id 192.0.2.3
+ no bgp ebgp-requires-policy
+ address-family ipv4 unicast
+  redistribute connected
+  label vpn export 103
+  rd vpn export 102:1
+  rt vpn both 52:100
+  import vpn
+  export vpn
+ exit-address-family
+!
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/ldpd.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r3/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r3/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,24 @@
+hostname r3
+password zebra
+log file ldpd.log
+!
+! debug mpls ldp zebra
+! debug mpls ldp event
+! debug mpls ldp errors
+! debug mpls ldp messages recv
+! debug mpls ldp messages sent
+! debug mpls ldp discovery hello recv
+! debug mpls ldp discovery hello sent
+!
+mpls ldp
+ router-id 192.0.2.3
+ !
+ address-family ipv4
+  discovery transport-address 192.0.2.3
+  !
+  interface r3-eth0
+  !
+ !
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_path_selection/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+int lo
+ ip address 192.0.2.3/32
+!
+interface r3-eth0
+ ip address 192.168.2.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_path_selection/test_bgp_path_selection.py frr-frr-8.5/tests/topotests/bgp_path_selection/test_bgp_path_selection.py
--- frr-frr-8.4.2/tests/topotests/bgp_path_selection/test_bgp_path_selection.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_path_selection/test_bgp_path_selection.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,233 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Louis Scalbert <louis.scalbert@6wind.com>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    for routern in range(1, 4):
+        tgen.add_router("r{}".format(routern))
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r3"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for routern in range(1, 4):
+        tgen.gears["r{}".format(routern)].cmd("ip link add vrf1 type vrf table 10")
+        tgen.gears["r{}".format(routern)].cmd("ip link set vrf1 up")
+        tgen.gears["r{}".format(routern)].cmd("ip address add dev vrf1 {}.{}.{}.{}/32".format(routern, routern, routern,routern))
+    tgen.gears["r2"].cmd("ip address add dev vrf1 192.0.2.8/32")
+    tgen.gears["r3"].cmd("ip address add dev vrf1 192.0.2.8/32")
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_LDP, os.path.join(CWD, "{}/ldpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+    tgen.gears["r1"].cmd("ip route add 192.0.2.2 via 192.168.1.2 metric 20")
+    tgen.gears["r1"].cmd("ip route add 192.0.2.3 via 192.168.2.2 metric 20")
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+def test_bgp_path_selection_ecmp():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_path_selection_ecmp():
+        output = json.loads(
+            tgen.gears["r1"].vtysh_cmd("show bgp ipv4 unicast 192.0.2.8/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "multipath": True,
+                    "nexthops": [{"ip": "192.0.2.2", "metric": 20}],
+                },
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "multipath": True,
+                    "nexthops": [{"ip": "192.0.2.3", "metric": 20}],
+                }
+            ]
+        }
+
+        return topotest.json_cmp(output, expected)
+
+    step("Check if two ECMP paths are present")
+    test_func = functools.partial(_bgp_check_path_selection_ecmp)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R1"
+
+
+def test_bgp_path_selection_vpn_ecmp():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_path_selection_vpn_ecmp():
+        output = json.loads(
+            tgen.gears["r1"].vtysh_cmd("show bgp vrf vrf1 ipv4 unicast 192.0.2.8/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "multipath": True,
+                    "nexthops": [{"ip": "192.0.2.2", "metric": 20}],
+                },
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "multipath": True,
+                    "nexthops": [{"ip": "192.0.2.3", "metric": 20}],
+                }
+            ]
+        }
+
+        return topotest.json_cmp(output, expected)
+
+    step("Check if two ECMP paths are present")
+    test_func = functools.partial(_bgp_check_path_selection_vpn_ecmp)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R1"
+
+
+def test_bgp_path_selection_metric():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_path_selection_metric():
+        output = json.loads(
+            tgen.gears["r1"].vtysh_cmd("show bgp ipv4 unicast 192.0.2.8/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "nexthops": [{"ip": "192.0.2.2", "metric": 10}],
+                    "bestpath":{ "selectionReason":"IGP Metric"},
+                },
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "nexthops": [{"ip": "192.0.2.3", "metric": 20}],
+                }
+            ]
+        }
+
+        return topotest.json_cmp(output, expected)
+
+    tgen.gears["r1"].cmd("ip route add 192.0.2.2 via 192.168.1.2 metric 10")
+    tgen.gears["r1"].cmd("ip route del 192.0.2.2 via 192.168.1.2 metric 20")
+
+    step("Check if IGP metric best path is selected")
+    test_func = functools.partial(_bgp_check_path_selection_metric)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R1"
+
+
+def test_bgp_path_selection_vpn_metric():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_check_path_selection_vpn_metric():
+        output = json.loads(
+            tgen.gears["r1"].vtysh_cmd("show bgp vrf vrf1 ipv4 unicast 192.0.2.8/32 json")
+        )
+        expected = {
+            "paths": [
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "nexthops": [{"ip": "192.0.2.2", "metric": 10}],
+                    "bestpath":{ "selectionReason":"IGP Metric"},
+                },
+                {
+                    "valid": True,
+                    "aspath": {"string": "65002"},
+                    "nexthops": [{"ip": "192.0.2.3", "metric": 20}],
+                }
+            ]
+        }
+
+        return topotest.json_cmp(output, expected)
+
+    step("Check if IGP metric best path is selected")
+    test_func = functools.partial(_bgp_check_path_selection_vpn_metric)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed to see BGP prefixes on R1"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+!
+router bgp 65001
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.2 remote-as external
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+int lo
+ ip address 10.10.10.1/32
+!
+int r1-eth0
+ ip address 192.168.1.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as external
+ neighbor 192.168.2.2 remote-as internal
+ address-family ipv4 unicast
+  neighbor 192.168.2.2 next-hop-self
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+!
+int r2-eth0
+ ip address 192.168.1.2/24
+!
+int r2-eth1
+ ip address 192.168.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,5 @@
+!
+router bgp 65002
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as internal
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+int r3-eth0
+ ip address 192.168.2.2/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/test_bgp_peer_graceful_shutdown.py frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/test_bgp_peer_graceful_shutdown.py
--- frr-frr-8.4.2/tests/topotests/bgp_peer_graceful_shutdown/test_bgp_peer_graceful_shutdown.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_peer_graceful_shutdown/test_bgp_peer_graceful_shutdown.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,120 @@
+#!/usr/bin/env python
+
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Check if routes from R1 has local-preference set to 0 and graceful-shutdown
+community.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+pytestmark = pytest.mark.bgpd
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def setup_module(mod):
+    topodef = {"s1": ("r1", "r2"), "s2": ("r2", "r3")}
+    tgen = Topogen(topodef, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_orf():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r2 = tgen.gears["r2"]
+    r3 = tgen.gears["r3"]
+
+    def _bgp_converge():
+        output = json.loads(
+            r2.vtysh_cmd(
+                "show bgp ipv4 unicast neighbor 192.168.2.2 advertised-routes json"
+            )
+        )
+        expected = {"advertisedRoutes": {"10.10.10.1/32": {"locPrf": 100}}}
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Can't converge at R2"
+
+    step("Mark routes from R1 as graceful-shutdown")
+    r2.vtysh_cmd(
+        """
+        configure terminal
+            router bgp
+                neighbor 192.168.1.1 graceful-shutdown
+    """
+    )
+
+    def _bgp_check_peer_graceful_shutdown():
+        output = json.loads(r3.vtysh_cmd("show bgp ipv4 unicast 10.10.10.1/32 json"))
+        expected = {
+            "paths": [
+                {
+                    "locPrf": 0,
+                    "community": {"string": "graceful-shutdown"},
+                }
+            ]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_peer_graceful_shutdown)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert (
+        result is None
+    ), "local-preference is not 0 and/or graceful-shutdown community missing"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_prefix_list_topo1/test_prefix_lists.py frr-frr-8.5/tests/topotests/bgp_prefix_list_topo1/test_prefix_lists.py
--- frr-frr-8.4.2/tests/topotests/bgp_prefix_list_topo1/test_prefix_lists.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_prefix_list_topo1/test_prefix_lists.py	2023-03-13 20:01:47.000000000 +0600
@@ -346,9 +346,12 @@ def test_ip_prefix_lists_out_permit(requ
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} FIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
+
     write_test_footer(tc_name)
 
 
@@ -444,9 +447,11 @@ def test_ip_prefix_lists_in_deny_and_per
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     write_test_footer(tc_name)
 
@@ -644,9 +649,12 @@ def test_ip_prefix_lists_out_deny_and_pe
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
+
     write_test_footer(tc_name)
 
 
@@ -778,9 +786,11 @@ def test_modify_prefix_lists_in_permit_t
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     write_test_footer(tc_name)
 
@@ -882,9 +892,11 @@ def test_modify_prefix_lists_in_deny_to_
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     # Modify  ip prefix list
     input_dict_1 = {
@@ -1051,9 +1063,11 @@ def test_modify_prefix_lists_out_permit_
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     write_test_footer(tc_name)
 
@@ -1157,9 +1171,11 @@ def test_modify_prefix_lists_out_deny_to
     result = verify_rib(
         tgen, "ipv4", dut, input_dict, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     # Modify ip prefix list
     input_dict_1 = {
@@ -1324,9 +1340,11 @@ def test_ip_prefix_lists_implicit_deny(r
     result = verify_rib(
         tgen, "ipv4", dut, input_dict_1, protocol=protocol, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Error: Routes still" " present in RIB".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, dut, result)
+    )
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_route_map/test_route_map_topo1.py frr-frr-8.5/tests/topotests/bgp_route_map/test_route_map_topo1.py
--- frr-frr-8.4.2/tests/topotests/bgp_route_map/test_route_map_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_route_map/test_route_map_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -444,12 +444,11 @@ def test_route_map_inbound_outbound_same
         result = verify_rib(
             tgen, adt, dut, input_dict_2, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present in rib \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} BGP RIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
         # Verifying RIB routes
         dut = "r4"
@@ -467,12 +466,11 @@ def test_route_map_inbound_outbound_same
         result = verify_rib(
             tgen, adt, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present in rib \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -666,12 +664,11 @@ def test_route_map_with_action_values_co
             result = verify_rib(
                 tgen, adt, dut, input_dict_2, protocol=protocol, expected=False
             )
-            assert (
-                result is not True
-            ), "Testcase {} : Failed \nRoutes are still present \n Error: {}".format(
-                tc_name, result
+            assert result is not True, (
+                "Testcase {} : Failed \n "
+                "Expected: Routes should not be present in {} FIB \n "
+                "Found: {}".format(tc_name, dut, result)
             )
-            logger.info("Expected behaviour: {}".format(result))
         else:
             result = verify_rib(tgen, adt, dut, input_dict_2, protocol=protocol)
             assert result is True, "Testcase {} : Failed \n Error: {}".format(
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_route_map/test_route_map_topo2.py frr-frr-8.5/tests/topotests/bgp_route_map/test_route_map_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_route_map/test_route_map_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_route_map/test_route_map_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -1022,12 +1022,11 @@ def test_modify_prefix_list_referenced_b
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     # Verifying RIB routes
     dut = "r4"
@@ -1036,10 +1035,10 @@ def test_modify_prefix_list_referenced_b
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nExpected behaviour: routes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
 
     write_test_footer(tc_name)
@@ -1293,12 +1292,11 @@ def test_remove_prefix_list_referenced_b
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     # Verifying RIB routes
     dut = "r4"
@@ -1307,12 +1305,11 @@ def test_remove_prefix_list_referenced_b
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -2139,12 +2136,11 @@ def test_add_remove_rmap_to_specific_nei
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n Error Routes are still present: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     # Remove applied rmap from neighbor
     input_dict_4 = {
@@ -2553,12 +2549,11 @@ def test_rmap_without_match_and_set_clau
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
     # Uncomment next line for debugging
@@ -2801,12 +2796,11 @@ def test_set_localpref_weight_to_ebgp_an
             input_dict_3_addr_type[addr_type],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nAttributes are not set \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: BGP attributes should not be set in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     # Verifying RIB routes
     dut = "r5"
@@ -2835,12 +2829,11 @@ def test_set_localpref_weight_to_ebgp_an
             input_dict_3_addr_type[addr_type],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nAttributes are not set \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: BGP attributes should not be set in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -3644,12 +3637,11 @@ def test_create_rmap_match_prefix_list_t
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     # Verifying RIB routes
     dut = "r4"
@@ -3658,12 +3650,11 @@ def test_create_rmap_match_prefix_list_t
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are not present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -3963,12 +3954,11 @@ def test_create_rmap_to_match_tag_deny_o
         result = verify_rib(
             tgen, addr_type, dut, input_dict, protocol=protocol, expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \nroutes are denied \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} FIB \n "
+            "Found: {}".format(tc_name, dut, result)
         )
-        logger.info("Expected behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,46 @@
+!
+debug bgp updates
+debug bgp vpn leak-from-vrf
+debug bgp vpn leak-to-vrf
+debug bgp nht
+debug route-map
+!
+router bgp 65001
+ bgp router-id 10.10.10.10
+ no bgp ebgp-requires-policy
+!
+router bgp 65001 vrf Customer
+ bgp router-id 192.168.1.2
+ no bgp ebgp-requires-policy
+ address-family ipv4 unicast
+  redistribute connected
+  rd vpn export 192.168.1.2:2
+  rt vpn import 192.168.1.2:2
+  rt vpn export 192.168.1.2:2
+  export vpn
+  import vpn
+ exit-address-family
+!
+router bgp 65001 vrf Service
+ bgp router-id 192.168.2.2
+ no bgp ebgp-requires-policy
+ address-family ipv4 unicast
+  redistribute connected
+  rd vpn export 192.168.2.2:2
+  rt vpn import 192.168.2.2:2 192.168.1.2:2
+  rt vpn export 192.168.2.2:2
+  route-map vpn import from-customer
+  export vpn
+  import vpn
+ exit-address-family
+!
+bgp extcommunity-list standard from-customer seq 5 permit rt 192.168.1.2:2
+!
+ip prefix-list p1 seq 5 permit 192.0.2.0/24
+!
+route-map from-customer permit 10
+ match extcommunity from-customer
+ match ip address prefix-list p1
+ set local-preference 123
+route-map from-customer permit 20
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+!
+interface lo
+ ip address 10.10.10.10/32
+!
+interface r1-eth0 vrf Customer
+ ip address 192.168.1.2/24
+!
+interface r1-eth1 vrf Service
+ ip address 192.168.2.2/24
+!
+interface r1-eth2
+ ip address 10.0.1.1/24
+!
+interface r1-eth3 vrf Customer
+ ip address 192.0.2.1/24
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/test_bgp_route_map_vpn_import.py frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/test_bgp_route_map_vpn_import.py
--- frr-frr-8.4.2/tests/topotests/bgp_route_map_vpn_import/test_bgp_route_map_vpn_import.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_route_map_vpn_import/test_bgp_route_map_vpn_import.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,126 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Test if `route-map vpn import NAME` works by setting/matching via route-maps.
+Routes from VRF Customer to VRF Service MUST be leaked and modified later
+with `route-map vpn import`.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    tgen.add_router("r1")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["r1"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["r1"])
+
+    switch = tgen.add_switch("s4")
+    switch.add_link(tgen.gears["r1"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    r1 = tgen.gears["r1"]
+
+    r1.run("ip link add Customer type vrf table 1001")
+    r1.run("ip link set up dev Customer")
+    r1.run("ip link set r1-eth0 master Customer")
+    r1.run("ip link add Service type vrf table 1002")
+    r1.run("ip link set up dev Service")
+    r1.run("ip link set r1-eth1 master Service")
+    r1.run("ip link set r1-eth3 master Customer")
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_route_map_vpn_import():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    r1 = tgen.gears["r1"]
+
+    def _bgp_check_received_leaked_with_vpn_import():
+        output = json.loads(r1.vtysh_cmd("show bgp vrf Service ipv4 unicast json"))
+        expected = {
+            "routes": {
+                "192.0.2.0/24": [
+                    {
+                        "locPrf": 123,
+                    },
+                ],
+                "192.168.1.0/24": [
+                    {
+                        "locPrf": None,
+                    }
+                ],
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_check_received_leaked_with_vpn_import)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+    assert result is None, "Failed, imported routes are not modified"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,14 +1,19 @@
 ! exit1
 router bgp 65001
-  no bgp ebgp-requires-policy
-  neighbor 192.168.255.1 remote-as 65002
-  neighbor 192.168.255.1 timers 3 10
-  address-family ipv4 unicast
-    neighbor 192.168.255.1 route-map prepend out
-    redistribute connected
-  exit-address-family
-  !
+ no bgp ebgp-requires-policy
+ neighbor 192.168.255.1 remote-as 65002
+ neighbor 192.168.255.1 timers 3 10
+ address-family ipv4 unicast
+  neighbor 192.168.255.1 route-map prepend out
+  redistribute connected
+ exit-address-family
+ !
+!
+ip prefix-list p1 seq 5 permit 172.16.255.253/32
 !
 route-map prepend permit 10
-  set as-path prepend 65003
+ match ip address prefix-list p1
+ set as-path prepend 65003
+!
+route-map prepend permit 20
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,5 +1,6 @@
 ! exit1
 interface lo
+ ip address 172.16.255.253/32
  ip address 172.16.255.254/32
 !
 interface r1-eth0
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r2/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,11 +1,10 @@
 ! spine
 router bgp 65002
-  no bgp ebgp-requires-policy
-  neighbor 192.168.255.2 remote-as 65001
-  neighbor 192.168.255.2 timers 3 10
-  neighbor 192.168.255.2 solo
-  neighbor 192.168.254.2 remote-as 65003
-  neighbor 192.168.254.2 timers 3 10
-  neighbor 192.168.254.2 solo
-  neighbor 192.168.254.2 sender-as-path-loop-detection
+ no bgp ebgp-requires-policy
+ neighbor 192.168.255.2 remote-as 65001
+ neighbor 192.168.255.2 timers 3 10
+ neighbor 192.168.255.2 sender-as-path-loop-detection
+ neighbor 192.168.254.2 remote-as 65003
+ neighbor 192.168.254.2 timers 3 10
+ neighbor 192.168.254.2 sender-as-path-loop-detection
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/r3/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,6 +1,6 @@
 ! exit2
 router bgp 65003
-  no bgp ebgp-requires-policy
-  neighbor 192.168.254.1 remote-as 65002
-  neighbor 192.168.254.1 timers 3 10
+ no bgp ebgp-requires-policy
+ neighbor 192.168.254.1 remote-as 65002
+ neighbor 192.168.254.1 timers 3 10
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/test_bgp_sender-as-path-loop-detection.py frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/test_bgp_sender-as-path-loop-detection.py
--- frr-frr-8.4.2/tests/topotests/bgp_sender_as_path_loop_detection/test_bgp_sender-as-path-loop-detection.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_sender_as_path_loop_detection/test_bgp_sender-as-path-loop-detection.py	2023-03-13 20:01:47.000000000 +0600
@@ -85,20 +85,20 @@ def test_bgp_sender_as_path_loop_detecti
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    router = tgen.gears["r2"]
+    r2 = tgen.gears["r2"]
 
-    def _bgp_converge(router):
-        output = json.loads(router.vtysh_cmd("show ip bgp neighbor 192.168.255.2 json"))
+    def _bgp_converge():
+        output = json.loads(r2.vtysh_cmd("show ip bgp neighbor 192.168.255.2 json"))
         expected = {
             "192.168.255.2": {
                 "bgpState": "Established",
-                "addressFamilyInfo": {"ipv4Unicast": {"acceptedPrefixCounter": 2}},
+                "addressFamilyInfo": {"ipv4Unicast": {"acceptedPrefixCounter": 3}},
             }
         }
         return topotest.json_cmp(output, expected)
 
-    def _bgp_has_route_from_r1(router):
-        output = json.loads(router.vtysh_cmd("show ip bgp 172.16.255.254/32 json"))
+    def _bgp_has_route_from_r1():
+        output = json.loads(r2.vtysh_cmd("show ip bgp 172.16.255.253/32 json"))
         expected = {
             "paths": [
                 {
@@ -111,31 +111,35 @@ def test_bgp_sender_as_path_loop_detecti
         }
         return topotest.json_cmp(output, expected)
 
-    def _bgp_suppress_route_to_r3(router):
+    def _bgp_suppress_route_to_r1():
         output = json.loads(
-            router.vtysh_cmd(
-                "show ip bgp neighbor 192.168.254.2 advertised-routes json"
-            )
+            r2.vtysh_cmd("show ip bgp neighbor 192.168.255.2 advertised-routes json")
         )
         expected = {"totalPrefixCounter": 0}
         return topotest.json_cmp(output, expected)
 
-    test_func = functools.partial(_bgp_converge, router)
-    success, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
-
-    assert result is None, 'Failed bgp convergence in "{}"'.format(router)
-
-    test_func = functools.partial(_bgp_has_route_from_r1, router)
-    success, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
-
-    assert result is None, 'Failed to see a route from r1 in "{}"'.format(router)
-
-    test_func = functools.partial(_bgp_suppress_route_to_r3, router)
-    success, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    def _bgp_suppress_route_to_r3():
+        output = json.loads(
+            r2.vtysh_cmd("show ip bgp neighbor 192.168.254.2 advertised-routes json")
+        )
+        expected = {"totalPrefixCounter": 2}
+        return topotest.json_cmp(output, expected)
 
-    assert (
-        result is None
-    ), 'Route 172.16.255.254/32 should not be sent to r3 "{}"'.format(router)
+    test_func = functools.partial(_bgp_converge)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Failed bgp to convergence"
+
+    test_func = functools.partial(_bgp_has_route_from_r1)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Failed to see a route from r1"
+
+    test_func = functools.partial(_bgp_suppress_route_to_r3)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Route 172.16.255.253/32 should not be sent to r3 from r2"
+
+    test_func = functools.partial(_bgp_suppress_route_to_r1)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=0.5)
+    assert result is None, "Routes should not be sent to r1 from r2"
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,31 @@
+!
+router bgp 65001
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ no bgp default ipv4-unicast
+ neighbor 192.168.12.2 remote-as external
+ neighbor 192.168.12.2 timers 1 3
+ neighbor 192.168.12.2 timers connect 1
+ neighbor 2001:db8::12:2 remote-as external
+ neighbor 2001:db8::12:2 timers 1 3
+ neighbor 2001:db8::12:2 timers connect 1
+ !
+ address-family ipv4 unicast
+  network 10.0.0.0/31 route-map p1
+  network 10.0.0.2/32 route-map p2
+  neighbor 192.168.12.2 activate
+ exit-address-family
+ address-family ipv6 unicast
+  network 2001:db8::1/128 route-map p1
+  network 2001:db8:1::/56 route-map p2
+  neighbor 2001:db8::12:2 activate
+ exit-address-family
+!
+route-map p1 permit 10
+ set metric 1
+exit
+route-map p2 permit 10
+ set metric 2
+ set origin incomplete
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,5 @@
+!
+interface r1-eth0
+ ip address 192.168.12.1/24
+ ipv6 address 2001:db8::12:1/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,23 @@
+!
+debug bgp updates
+!
+router bgp 65002
+ no bgp ebgp-requires-policy
+ no bgp network import-check
+ no bgp default ipv4-unicast
+ neighbor 192.168.12.1 remote-as external
+ neighbor 192.168.12.1 timers 1 3
+ neighbor 192.168.12.1 timers connect 1
+ neighbor 2001:db8::12:1 remote-as external
+ neighbor 2001:db8::12:1 timers 1 3
+ neighbor 2001:db8::12:1 timers connect 1
+ !
+ address-family ipv4 unicast
+  neighbor 192.168.12.1 activate
+ exit-address-family
+ address-family ipv6 unicast
+  neighbor 2001:db8::12:1 activate
+ exit-address-family
+!
+agentx
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/snmpd.conf frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/snmpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/snmpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/snmpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,17 @@
+agentAddress 127.0.0.1,[::1]
+
+group public_group v1 public
+group public_group v2c public
+access public_group "" any noauth prefix all all none
+
+rocommunity public default
+
+view all included .1
+
+iquerySecName frr
+rouser frr
+
+master agentx
+
+agentXSocket /etc/frr/agentx
+agentXPerms 777 755 root frr
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,5 @@
+!
+interface r2-eth0
+ ip address 192.168.12.2/24
+ ipv6 address 2001:db8::12:2/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/test_bgp_snmp_bgp4v2mib.py frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/test_bgp_snmp_bgp4v2mib.py
--- frr-frr-8.4.2/tests/topotests/bgp_snmp_bgp4v2mib/test_bgp_snmp_bgp4v2mib.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_snmp_bgp4v2mib/test_bgp_snmp_bgp4v2mib.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,248 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Test some of the BGP4V2-MIB entries.
+"""
+
+import os
+import sys
+import json
+from time import sleep
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.snmptest import SnmpTester
+from lib import topotest
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.snmp]
+
+
+def build_topo(tgen):
+    tgen.add_router("r1")
+    tgen.add_router("r2")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    snmpd = os.system("which snmpd")
+    if snmpd:
+        error_msg = "SNMP not installed - skipping"
+        pytest.skip(error_msg)
+
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    for rname, router in tgen.routers().items():
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP,
+            os.path.join(CWD, "{}/bgpd.conf".format(rname)),
+            "-M snmp",
+        )
+        router.load_config(
+            TopoRouter.RD_SNMP,
+            os.path.join(CWD, "{}/snmpd.conf".format(rname)),
+            "-Le -Ivacm_conf,usmConf,iquery -V -DAgentX",
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_snmp_bgp4v2():
+    tgen = get_topogen()
+
+    r2 = tgen.gears["r2"]
+
+    def _bgp_converge_summary():
+        output = json.loads(r2.vtysh_cmd("show bgp summary json"))
+        expected = {
+            "ipv4Unicast": {
+                "peers": {
+                    "192.168.12.1": {
+                        "state": "Established",
+                        "pfxRcd": 2,
+                    }
+                }
+            },
+            "ipv6Unicast": {
+                "peers": {
+                    "2001:db8::12:1": {
+                        "state": "Established",
+                        "pfxRcd": 2,
+                    }
+                }
+            },
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge_summary)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=1)
+    assert result is None, "Can't see connections established"
+
+    def _bgp_converge_prefixes():
+        output = json.loads(r2.vtysh_cmd("show bgp all json"))
+        expected = {
+            "ipv4Unicast": {
+                "routes": {
+                    "10.0.0.0/31": [
+                        {
+                            "metric": 1,
+                            "origin": "IGP",
+                        }
+                    ],
+                    "10.0.0.2/32": [
+                        {
+                            "metric": 2,
+                            "origin": "incomplete",
+                        }
+                    ],
+                }
+            },
+            "ipv6Unicast": {
+                "routes": {
+                    "2001:db8::1/128": [
+                        {
+                            "metric": 1,
+                            "origin": "IGP",
+                        }
+                    ],
+                    "2001:db8:1::/56": [
+                        {
+                            "metric": 2,
+                            "origin": "incomplete",
+                        }
+                    ],
+                }
+            },
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_converge_prefixes)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=1)
+    assert result is None, "Can't see prefixes from R1"
+
+    snmp = SnmpTester(r2, "localhost", "public", "2c", "-Ln -On")
+
+    def _snmpwalk_remote_addr():
+        expected = {
+            "1.3.6.1.3.5.1.1.2.1.5.1.4.192.168.12.1": "C0 A8 0C 01",
+            "1.3.6.1.3.5.1.1.2.1.5.2.16.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "20 01 0D B8 00 00 00 00 00 00 00 00 00 12 00 01",
+        }
+
+        # bgp4V2PeerRemoteAddr
+        output, _ = snmp.walk(".1.3.6.1.3.5.1.1.2.1.5")
+        return output == expected
+
+    _, result = topotest.run_and_expect(_snmpwalk_remote_addr, True, count=10, wait=1)
+    assertmsg = "Can't fetch SNMP for bgp4V2PeerRemoteAddr"
+    assert result, assertmsg
+
+    def _snmpwalk_peer_state():
+        expected = {
+            "1.3.6.1.3.5.1.1.2.1.13.1.4.192.168.12.1": "6",
+            "1.3.6.1.3.5.1.1.2.1.13.2.16.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "6",
+        }
+
+        # bgp4V2PeerState
+        output, _ = snmp.walk(".1.3.6.1.3.5.1.1.2.1.13")
+        return output == expected
+
+    _, result = topotest.run_and_expect(_snmpwalk_peer_state, True, count=10, wait=1)
+    assertmsg = "Can't fetch SNMP for bgp4V2PeerState"
+    assert result, assertmsg
+
+    def _snmpwalk_peer_last_error_code_received():
+        expected = {
+            "1.3.6.1.3.5.1.1.3.1.1.1.4.192.168.12.1": "0",
+            "1.3.6.1.3.5.1.1.3.1.1.2.16.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "0",
+        }
+
+        # bgp4V2PeerLastErrorCodeReceived
+        output, _ = snmp.walk(".1.3.6.1.3.5.1.1.3.1.1")
+        return output == expected
+
+    _, result = topotest.run_and_expect(
+        _snmpwalk_peer_last_error_code_received, True, count=10, wait=1
+    )
+    assertmsg = "Can't fetch SNMP for bgp4V2PeerLastErrorCodeReceived"
+    assert result, assertmsg
+
+    def _snmpwalk_origin():
+        expected = {
+            "1.3.6.1.3.5.1.1.9.1.9.1.4.10.0.0.0.31.192.168.12.1": "1",
+            "1.3.6.1.3.5.1.1.9.1.9.1.4.10.0.0.2.32.192.168.12.1": "3",
+            "1.3.6.1.3.5.1.1.9.1.9.2.16.32.1.13.184.0.0.0.0.0.0.0.0.0.0.0.1.128.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "1",
+            "1.3.6.1.3.5.1.1.9.1.9.2.16.32.1.13.184.0.1.0.0.0.0.0.0.0.0.0.0.56.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "3",
+        }
+
+        # bgp4V2NlriOrigin
+        output, _ = snmp.walk(".1.3.6.1.3.5.1.1.9.1.9")
+        return output == expected
+
+    _, result = topotest.run_and_expect(_snmpwalk_origin, True, count=10, wait=1)
+    assertmsg = "Can't fetch SNMP for bgp4V2NlriOrigin"
+    assert result, assertmsg
+
+    def _snmpwalk_med():
+        expected = {
+            "1.3.6.1.3.5.1.1.9.1.17.1.4.10.0.0.0.31.192.168.12.1": "1",
+            "1.3.6.1.3.5.1.1.9.1.17.1.4.10.0.0.2.32.192.168.12.1": "2",
+            "1.3.6.1.3.5.1.1.9.1.17.2.16.32.1.13.184.0.0.0.0.0.0.0.0.0.0.0.1.128.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "1",
+            "1.3.6.1.3.5.1.1.9.1.17.2.16.32.1.13.184.0.1.0.0.0.0.0.0.0.0.0.0.56.32.1.13.184.0.0.0.0.0.0.0.0.0.18.0.1": "2",
+        }
+
+        # bgp4V2NlriMed
+        output, _ = snmp.walk(".1.3.6.1.3.5.1.1.9.1.17")
+        return output == expected
+
+    _, result = topotest.run_and_expect(_snmpwalk_med, True, count=10, wait=1)
+    assertmsg = "Can't fetch SNMP for bgp4V2NlriMed"
+    assert result, assertmsg
+
+
+def test_memory_leak():
+    "Run the memory leak test and report results."
+    tgen = get_topogen()
+    if not tgen.is_memleak_enabled():
+        pytest.skip("Memory leak test/report is disabled")
+
+    tgen.report_memory_leaks()
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/staticd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+ip route 0.0.0.0/0 192.168.3.254
+ipv6 route ::/0 2001:3::ffff
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c31/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+hostname c31
+!
+interface eth0
+ ip address 192.168.3.1/24
+ ipv6 address 2001:3::1/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/staticd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+!
+ip route 0.0.0.0/0 192.168.3.254
+ipv6 route ::/0 2001:3::ffff
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/c32/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+hostname c32
+!
+interface eth0
+ ip address 192.168.3.1/24
+ ipv6 address 2001:3::1/64
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -11,16 +11,21 @@ router bgp 65001
  bgp router-id 192.0.2.1
  no bgp ebgp-requires-policy
  no bgp default ipv4-unicast
- neighbor 2001:db8::2 remote-as 65002
- neighbor 2001:db8::2 timers 3 10
- neighbor 2001:db8::2 timers connect 1
- neighbor 2001:db8::2 capability extended-nexthop
+ neighbor 2001:db8:12::2 remote-as 65002
+ neighbor 2001:db8:12::2 timers 3 10
+ neighbor 2001:db8:12::2 timers connect 1
+ neighbor 2001:db8:12::2 capability extended-nexthop
+ neighbor 2001:db8:13::3 remote-as 65001
+ neighbor 2001:db8:13::3 timers 3 10
+ neighbor 2001:db8:13::3 timers connect 1
+ neighbor 2001:db8:13::3 capability extended-nexthop
  !
  segment-routing srv6
   locator default
  !
  address-family ipv4 vpn
-  neighbor 2001:db8::2 activate
+  neighbor 2001:db8:12::2 activate
+  neighbor 2001:db8:13::3 activate
  exit-address-family
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/staticd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/staticd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,3 +1,4 @@
 !
-ipv6 route 2001:db8:2:2::/64 2001:db8::2
+ipv6 route 2001:db8:2:2::/64 2001:db8:12::2
+ipv6 route 2001:db8:3:3::/64 2001:db8:13::3
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -6,12 +6,15 @@ interface lo
  ipv6 address 2001:db8:1:1::1/128
 !
 interface eth0
- ipv6 address 2001:db8::1/64
+ ipv6 address 2001:db8:12::1/64
 !
-interface eth1 vrf vrf10
+interface eth1
+ ipv6 address 2001:db8:13::1/64
+!
+interface eth2 vrf vrf10
  ip address 192.168.1.254/24
 !
-interface eth2 vrf vrf20
+interface eth3 vrf vrf20
  ip address 192.168.1.254/24
 !
 segment-routing
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -11,16 +11,16 @@ router bgp 65002
  bgp router-id 192.0.2.2
  no bgp ebgp-requires-policy
  no bgp default ipv4-unicast
- neighbor 2001:db8::1 remote-as 65001
- neighbor 2001:db8::1 timers 3 10
- neighbor 2001:db8::1 timers connect 1
- neighbor 2001:db8::1 capability extended-nexthop
+ neighbor 2001:db8:12::1 remote-as 65001
+ neighbor 2001:db8:12::1 timers 3 10
+ neighbor 2001:db8:12::1 timers connect 1
+ neighbor 2001:db8:12::1 capability extended-nexthop
  !
  segment-routing srv6
   locator default
  !
  address-family ipv4 vpn
-  neighbor 2001:db8::1 activate
+  neighbor 2001:db8:12::1 activate
  exit-address-family
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/staticd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/staticd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,3 +1,4 @@
 !
-ipv6 route 2001:db8:1:1::/64 2001:db8::1
+ipv6 route 2001:db8:1:1::/64 2001:db8:12::1
+ipv6 route 2001:db8:3:3::/64 2001:db8:12::1
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -6,7 +6,7 @@ interface lo
  ipv6 address 2001:db8:2:2::1/128
 !
 interface eth0
- ipv6 address 2001:db8::2/64
+ ipv6 address 2001:db8:12::2/64
 !
 interface eth1 vrf vrf10
  ip address 192.168.2.254/24
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,52 @@
+frr defaults traditional
+!
+hostname r2
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+router bgp 65001
+ bgp router-id 192.0.2.3
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 2001:db8:13::1 remote-as 65001
+ neighbor 2001:db8:13::1 timers 3 10
+ neighbor 2001:db8:13::1 timers connect 1
+ neighbor 2001:db8:13::1 capability extended-nexthop
+ !
+ segment-routing srv6
+  locator default
+ !
+ address-family ipv4 vpn
+  neighbor 2001:db8:13::1 activate
+ exit-address-family
+ !
+!
+router bgp 65001 vrf vrf10
+ bgp router-id 192.0.2.3
+ !
+ address-family ipv4 unicast
+  redistribute connected
+  sid vpn export 1
+  rd vpn export 65001:10
+  rt vpn both 0:10
+  import vpn
+  export vpn
+ exit-address-family
+ !
+!
+router bgp 65001 vrf vrf20
+ bgp router-id 192.0.2.2
+ !
+ address-family ipv4 unicast
+  redistribute connected
+  sid vpn export 2 
+  rd vpn export 65001:20
+  rt vpn both 0:20
+  import vpn
+  export vpn
+ exit-address-family
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/staticd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/staticd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/staticd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/staticd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+!
+ipv6 route 2001:db8:12::/64 2001:db8:13::1
+!
+ipv6 route 2001:db8:1:1::/64 2001:db8:13::1
+ipv6 route 2001:db8:2:2::/64 2001:db8:13::1
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/r3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,29 @@
+log file zebra.log
+!
+hostname r2
+!
+interface lo
+ ipv6 address 2001:db8:3:3::1/128
+!
+interface eth0
+ ipv6 address 2001:db8:13::3/64
+!
+interface eth1 vrf vrf10
+ ip address 192.168.3.254/24
+!
+interface eth2 vrf vrf20
+ ip address 192.168.3.254/24
+!
+segment-routing
+ srv6
+  locators
+   locator default
+    prefix 2001:db8:3:3::/64
+  !
+ !
+!
+ip forwarding
+ipv6 forwarding
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/test_bgp_srv6l3vpn_over_ipv6.py frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/test_bgp_srv6l3vpn_over_ipv6.py
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_over_ipv6/test_bgp_srv6l3vpn_over_ipv6.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_over_ipv6/test_bgp_srv6l3vpn_over_ipv6.py	2023-03-13 20:01:47.000000000 +0600
@@ -44,17 +44,23 @@ pytestmark = [pytest.mark.bgpd]
 def build_topo(tgen):
     tgen.add_router("r1")
     tgen.add_router("r2")
+    tgen.add_router("r3")
 
     tgen.add_router("c11")
     tgen.add_router("c12")
     tgen.add_router("c21")
     tgen.add_router("c22")
+    tgen.add_router("c31")
+    tgen.add_router("c32")
 
     tgen.add_link(tgen.gears["r1"], tgen.gears["r2"], "eth0", "eth0")
-    tgen.add_link(tgen.gears["r1"], tgen.gears["c11"], "eth1", "eth0")
-    tgen.add_link(tgen.gears["r1"], tgen.gears["c12"], "eth2", "eth0")
+    tgen.add_link(tgen.gears["r1"], tgen.gears["r3"], "eth1", "eth0")
+    tgen.add_link(tgen.gears["r1"], tgen.gears["c11"], "eth2", "eth0")
+    tgen.add_link(tgen.gears["r1"], tgen.gears["c12"], "eth3", "eth0")
     tgen.add_link(tgen.gears["r2"], tgen.gears["c21"], "eth1", "eth0")
     tgen.add_link(tgen.gears["r2"], tgen.gears["c22"], "eth2", "eth0")
+    tgen.add_link(tgen.gears["r3"], tgen.gears["c31"], "eth1", "eth0")
+    tgen.add_link(tgen.gears["r3"], tgen.gears["c32"], "eth2", "eth0")
 
 
 def setup_module(mod):
@@ -66,20 +72,23 @@ def setup_module(mod):
     tgen.start_topology()
 
     for rname, router in tgen.routers().items():
-        router.load_config(TopoRouter.RD_ZEBRA,
-                           os.path.join(CWD, '{}/zebra.conf'.format(rname)))
-        router.load_config(TopoRouter.RD_STATIC,
-                           os.path.join(CWD, '{}/staticd.conf'.format(rname)))
-        router.load_config(TopoRouter.RD_BGP,
-                           os.path.join(CWD, '{}/bgpd.conf'.format(rname)))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_STATIC, os.path.join(CWD, "{}/staticd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
 
     tgen.gears["r1"].run("sysctl net.vrf.strict_mode=1")
     tgen.gears["r1"].run("ip link add vrf10 type vrf table 10")
     tgen.gears["r1"].run("ip link set vrf10 up")
     tgen.gears["r1"].run("ip link add vrf20 type vrf table 20")
     tgen.gears["r1"].run("ip link set vrf20 up")
-    tgen.gears["r1"].run("ip link set eth1 master vrf10")
-    tgen.gears["r1"].run("ip link set eth2 master vrf20")
+    tgen.gears["r1"].run("ip link set eth2 master vrf10")
+    tgen.gears["r1"].run("ip link set eth3 master vrf20")
 
     tgen.gears["r2"].run("sysctl net.vrf.strict_mode=1")
     tgen.gears["r2"].run("ip link add vrf10 type vrf table 10")
@@ -89,6 +98,14 @@ def setup_module(mod):
     tgen.gears["r2"].run("ip link set eth1 master vrf10")
     tgen.gears["r2"].run("ip link set eth2 master vrf20")
 
+    tgen.gears["r3"].run("sysctl net.vrf.strict_mode=1")
+    tgen.gears["r3"].run("ip link add vrf10 type vrf table 10")
+    tgen.gears["r3"].run("ip link set vrf10 up")
+    tgen.gears["r3"].run("ip link add vrf20 type vrf table 20")
+    tgen.gears["r3"].run("ip link set vrf20 up")
+    tgen.gears["r3"].run("ip link set eth1 master vrf10")
+    tgen.gears["r3"].run("ip link set eth2 master vrf20")
+
     tgen.start_router()
 
 
@@ -115,12 +132,13 @@ def check_ping4(name, dest_addr, expecte
 
 def test_ping():
     tgen = get_topogen()
-    logger.info(tgen.gears["c11"].run("ip route show"))
-    # tests for ipv4-vpn
+
     check_ping4("c11", "192.168.2.1", True)
+    check_ping4("c11", "192.168.3.1", True)
     check_ping4("c12", "192.168.2.1", True)
-    check_ping4("c21", "192.168.1.1", True)
-    check_ping4("c22", "192.168.1.1", True)
+    check_ping4("c12", "192.168.3.1", True)
+    check_ping4("c21", "192.168.3.1", True)
+    check_ping4("c22", "192.168.3.1", True)
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/ce1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/ce1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/ce1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/ce1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+log file zebra.log
+!
+hostname ce1
+!
+interface eth0
+ ip address 172.16.0.1/24
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,41 @@
+frr defaults traditional
+!
+hostname pe1
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+router bgp 65001
+ bgp router-id 192.0.2.1
+ !
+ segment-routing srv6
+  locator default
+ exit
+ !
+!
+router bgp 65001 vrf vrf10
+ bgp router-id 192.0.2.1
+ !
+ address-family ipv4 unicast
+  redistribute connected
+  sid vpn export auto
+  rd vpn export 65001:10
+  rt vpn both 0:10
+  import vpn
+  export vpn
+ exit-address-family
+ !
+!
+router bgp 65001 vrf vrf20
+ bgp router-id 192.0.2.1
+ !
+ address-family ipv4 unicast
+  rd vpn export 65001:20
+  rt vpn both 0:10
+  import vpn
+  export vpn
+ exit-address-family
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/default_ipv4_vpn.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/default_ipv4_vpn.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/default_ipv4_vpn.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/default_ipv4_vpn.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,31 @@
+{
+    "vrfName": "default",
+    "routerId": "192.0.2.1",
+    "localAS": 65001,
+    "routes": {
+        "routeDistinguishers": {
+            "65001:10": {
+                "172.16.0.0/24": [
+                    {
+                        "valid": true,
+                        "bestpath": true,
+                        "pathFrom": "external",
+                        "prefix": "172.16.0.0",
+                        "prefixLen": 24,
+                        "network": "172.16.0.0\/24",
+                        "origin": "incomplete",
+                        "announceNexthopSelf": true,
+                        "nhVrfName": "vrf10",
+                        "nexthops": [
+                            {
+                                "hostname": "pe1",
+                                "afi": "ipv4",
+                                "used": true
+                            }
+                        ]
+                    }
+                ]
+            }
+        }
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf10_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf10_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf10_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf10_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,25 @@
+{
+    "vrfName": "vrf10",
+    "routerId": "192.0.2.1",
+    "localAS": 65001,
+    "routes": {
+        "172.16.0.0/24": [
+            {
+                "valid": true,
+                "bestpath": true,
+                "pathFrom": "external",
+                "prefix": "172.16.0.0",
+                "prefixLen": 24,
+                "network": "172.16.0.0\/24",
+                "origin": "incomplete",
+                "nexthops": [
+                    {
+                        "hostname": "pe1",
+                        "afi": "ipv4",
+                        "used": true
+                    }
+                ]
+            }
+        ]
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+{
+    "172.16.0.0\/24": [
+        {
+            "prefix": "172.16.0.0\/24",
+            "prefixLen": 24,
+            "protocol": "bgp",
+            "vrfName": "vrf20",
+            "selected": true,
+            "destSelected": true,
+            "installed": true,
+            "nexthops": [
+                {
+                    "fib": true,
+                    "directlyConnected": true,
+                    "interfaceName": "eth0",
+                    "vrf": "vrf10",
+                    "active": true
+                }
+            ]
+        }
+    ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4_unicast.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4_unicast.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4_unicast.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/results/vrf20_ipv4_unicast.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,27 @@
+{
+    "vrfName": "vrf20",
+    "routerId": "192.0.2.1",
+    "localAS": 65001,
+    "routes": {
+        "172.16.0.0/24": [
+            {
+                "valid": true,
+                "bestpath": true,
+                "pathFrom": "external",
+                "prefix": "172.16.0.0",
+                "prefixLen": 24,
+                "network": "172.16.0.0\/24",
+                "origin": "incomplete",
+                "announceNexthopSelf": true,
+                "nhVrfName": "vrf10",
+                "nexthops": [
+                    {
+                        "hostname": "pe1",
+                        "afi": "ipv4",
+                        "used": true
+                    }
+                ]
+            }
+        ]
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/pe1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,27 @@
+log file zebra.log
+!
+hostname pe1
+!
+interface lo
+ ip address 10.0.0.1/32
+!
+interface eth0 vrf vrf10
+ ip address 172.16.0.254/24
+!
+line vty
+!
+segment-routing
+ srv6
+  locators
+   locator default
+    prefix 2001:db8:2::/64 block-len 40 node-len 24 func-bits 16
+   exit
+   !
+  exit
+  !
+ exit
+ !
+exit
+!
+end
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/test_bgp_srv6l3vpn_route_leak.py frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/test_bgp_srv6l3vpn_route_leak.py
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_route_leak/test_bgp_srv6l3vpn_route_leak.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_route_leak/test_bgp_srv6l3vpn_route_leak.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,128 @@
+#!/usr/bin/env python
+
+# Copyright (c) 2022, LINE Corporation
+# Authored by Ryoga Saito <ryoga.saito@linecorp.com>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+import os
+import re
+import sys
+import json
+import functools
+import pytest
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+from lib.common_config import required_linux_kernel_version
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    tgen.add_router("pe1")
+    tgen.add_router("ce1")
+
+    tgen.add_link(tgen.gears["pe1"], tgen.gears["ce1"], "eth0", "eth0")
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    for rname, router in tgen.routers().items():
+        router.load_config(TopoRouter.RD_ZEBRA,
+                           os.path.join(CWD, '{}/zebra.conf'.format(rname)))
+        router.load_config(TopoRouter.RD_BGP,
+                           os.path.join(CWD, '{}/bgpd.conf'.format(rname)))
+
+    tgen.gears["pe1"].run("ip link add vrf10 type vrf table 10")
+    tgen.gears["pe1"].run("ip link set vrf10 up")
+    tgen.gears["pe1"].run("ip link add vrf20 type vrf table 20")
+    tgen.gears["pe1"].run("ip link set vrf20 up")
+    tgen.gears["pe1"].run("ip link set eth0 master vrf10")
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def open_json_file(path):
+    try:
+        with open(path, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(path)
+    
+
+def check(name, command, checker):
+    tgen = get_topogen()
+    router = tgen.gears[name]
+
+    def _check():
+        try:
+            return checker(router.vtysh_cmd(command))
+        except:
+            return False
+
+    logger.info('[+] check {} "{}"'.format(name, command))
+    _, result = topotest.run_and_expect(_check, None, count=10, wait=0.5)
+    assert result is None, "Failed"
+
+
+def check_vrf10_bgp_rib(output):
+    expected = open_json_file("%s/pe1/results/vrf10_ipv4_unicast.json" % CWD) 
+    actual = json.loads(output)
+    return topotest.json_cmp(actual, expected)
+
+
+def check_default_bgp_vpn_rib(output):
+    expected = open_json_file("%s/pe1/results/default_ipv4_vpn.json" % CWD) 
+    actual = json.loads(output)
+    return topotest.json_cmp(actual, expected)
+
+
+def check_vrf20_bgp_rib(output):
+    expected = open_json_file("%s/pe1/results/vrf20_ipv4_unicast.json" % CWD) 
+    actual = json.loads(output)
+    return topotest.json_cmp(actual, expected)
+
+
+def check_vrf20_rib(output):
+    expected = open_json_file("%s/pe1/results/vrf20_ipv4.json" % CWD) 
+    actual = json.loads(output)
+    return topotest.json_cmp(actual, expected)
+
+
+def test_rib():
+    check("pe1", "show bgp vrf vrf10 ipv4 unicast json", check_vrf10_bgp_rib)
+    check("pe1", "show bgp ipv4 vpn json", check_default_bgp_vpn_rib)
+    check("pe1", "show bgp vrf vrf20 ipv4 unicast json", check_vrf20_bgp_rib)
+    check("pe1", "show ip route vrf vrf20 json", check_vrf20_rib)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -27,7 +27,7 @@ segment-routing
  srv6
   locators
    locator loc1
-    prefix 2001:db8:1:1::/64
+    prefix 2001:db8:1:1::/64 func-bits 8
   !
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -27,7 +27,7 @@ segment-routing
  srv6
   locators
    locator loc1
-    prefix 2001:db8:2:2::/64
+    prefix 2001:db8:2:2::/64 func-bits 8
   !
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/test_bgp_srv6l3vpn_to_bgp_vrf.py frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/test_bgp_srv6l3vpn_to_bgp_vrf.py
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/test_bgp_srv6l3vpn_to_bgp_vrf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf/test_bgp_srv6l3vpn_to_bgp_vrf.py	2023-03-13 20:01:47.000000000 +0600
@@ -155,7 +155,7 @@ def check_ping(name, dest_addr, expect_c
         if match not in output:
             return "ping fail"
 
-    match = "{} packet loss".format("0%" if expect_connected else "100%")
+    match = ", {} packet loss".format("0%" if expect_connected else "100%")
     logger.info("[+] check {} {} {}".format(name, dest_addr, match))
     tgen = get_topogen()
     func = functools.partial(_check, name, dest_addr, match)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,5 +1,7 @@
 frr defaults traditional
 !
+bgp send-extra-data zebra
+!
 hostname r1
 password zebra
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -28,7 +28,7 @@ segment-routing
  srv6
   locators
    locator loc1
-    prefix 2001:db8:1:1::/64
+    prefix 2001:db8:1:1::/64 func-bits 8
   !
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -1,5 +1,7 @@
 frr defaults traditional
 !
+bgp send-extra-data zebra
+!
 hostname r2
 password zebra
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -27,7 +27,7 @@ segment-routing
  srv6
   locators
    locator loc1
-    prefix 2001:db8:2:2::/64
+    prefix 2001:db8:2:2::/64 func-bits 8
   !
  !
 !
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/test_bgp_srv6l3vpn_to_bgp_vrf2.py frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/test_bgp_srv6l3vpn_to_bgp_vrf2.py
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/test_bgp_srv6l3vpn_to_bgp_vrf2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf2/test_bgp_srv6l3vpn_to_bgp_vrf2.py	2023-03-13 20:01:47.000000000 +0600
@@ -69,10 +69,12 @@ def setup_module(mod):
     tgen.start_topology()
     for rname, router in tgen.routers().items():
         router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
-        router.load_config(TopoRouter.RD_ZEBRA,
-                           os.path.join(CWD, '{}/zebra.conf'.format(rname)))
-        router.load_config(TopoRouter.RD_BGP,
-                           os.path.join(CWD, '{}/bgpd.conf'.format(rname)))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
 
     tgen.gears["r1"].run("sysctl net.vrf.strict_mode=1")
     tgen.gears["r1"].run("ip link add vrf10 type vrf table 10")
@@ -114,7 +116,7 @@ def check_ping(name, dest_addr, expect_c
         logger.info(output)
         assert match in output, "ping fail"
 
-    match = "{} packet loss".format("0%" if expect_connected else "100%")
+    match = ", {} packet loss".format("0%" if expect_connected else "100%")
     logger.info("[+] check {} {} {}".format(name, dest_addr, match))
     tgen = get_topogen()
     func = functools.partial(_check, name, dest_addr, match)
@@ -131,7 +133,7 @@ def check_rib(name, cmd, expected_file):
         expected = open_json_file("{}/{}".format(CWD, expected_file))
         return topotest.json_cmp(output, expected)
 
-    logger.info("[+] check {} \"{}\" {}".format(name, cmd, expected_file))
+    logger.info('[+] check {} "{}" {}'.format(name, cmd, expected_file))
     tgen = get_topogen()
     func = functools.partial(_check, name, cmd, expected_file)
     success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
@@ -154,16 +156,16 @@ def test_rib():
 
 
 def test_ping():
-    check_ping("ce1", "192.168.2.2", " 0% packet loss")
-    check_ping("ce1", "192.168.3.2", " 0% packet loss")
-    check_ping("ce1", "192.168.4.2", " 100% packet loss")
-    check_ping("ce1", "192.168.5.2", " 100% packet loss")
-    check_ping("ce1", "192.168.6.2", " 100% packet loss")
-    check_ping("ce4", "192.168.1.2", " 100% packet loss")
-    check_ping("ce4", "192.168.2.2", " 100% packet loss")
-    check_ping("ce4", "192.168.3.2", " 100% packet loss")
-    check_ping("ce4", "192.168.5.2", " 0% packet loss")
-    check_ping("ce4", "192.168.6.2", " 0% packet loss")
+    check_ping("ce1", "192.168.2.2", True)
+    check_ping("ce1", "192.168.3.2", True)
+    check_ping("ce1", "192.168.4.2", False)
+    check_ping("ce1", "192.168.5.2", False)
+    check_ping("ce1", "192.168.6.2", False)
+    check_ping("ce4", "192.168.1.2", False)
+    check_ping("ce4", "192.168.2.2", False)
+    check_ping("ce4", "192.168.3.2", False)
+    check_ping("ce4", "192.168.5.2", True)
+    check_ping("ce4", "192.168.6.2", True)
 
 
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce1
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.1.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.1.0/24": [
+    {
+      "prefix": "192.168.1.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:1::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:1::/64": [
+    {
+      "prefix": "2001:1::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce1
+!
+interface eth0
+ ip address 192.168.1.2/24
+ ipv6 address 2001:1::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.1.1
+ipv6 route ::/0 2001:1::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce2
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.2.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.2.0/24": [
+    {
+      "prefix": "192.168.2.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:2::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:2::/64": [
+    {
+      "prefix": "2001:2::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce2
+!
+interface eth0
+ ip address 192.168.2.2/24
+ ipv6 address 2001:2::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.2.1
+ipv6 route ::/0 2001:2::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce3
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.3.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.3.0/24": [
+    {
+      "prefix": "192.168.3.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:3::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:3::/64": [
+    {
+      "prefix": "2001:3::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce3/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce3
+!
+interface eth0
+ ip address 192.168.3.2/24
+ ipv6 address 2001:3::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.3.1
+ipv6 route ::/0 2001:3::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce4
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.4.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.4.0/24": [
+    {
+      "prefix": "192.168.4.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:4::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:4::/64": [
+    {
+      "prefix": "2001:4::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce4
+!
+interface eth0
+ ip address 192.168.4.2/24
+ ipv6 address 2001:4::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.4.1
+ipv6 route ::/0 2001:4::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce5
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.5.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.5.0/24": [
+    {
+      "prefix": "192.168.5.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:5::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:5::/64": [
+    {
+      "prefix": "2001:5::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce5/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce5
+!
+interface eth0
+ ip address 192.168.5.2/24
+ ipv6 address 2001:5::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.5.1
+ipv6 route ::/0 2001:5::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+frr defaults traditional
+!
+hostname ce6
+password zebra
+!
+log stdout notifications
+log commands
+log file bgpd.log
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ip_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ip_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ip_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ip_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "0.0.0.0/0": [
+    {
+      "prefix": "0.0.0.0/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "192.168.6.1",
+          "afi": "ipv4",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "192.168.6.0/24": [
+    {
+      "prefix": "192.168.6.0/24",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ipv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ipv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ipv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/ipv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+{
+  "::/0": [
+    {
+      "prefix": "::/0",
+      "protocol": "static",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 1,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 73,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "ip": "2001:6::1",
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "active": true,
+          "weight": 1
+        }
+      ]
+    }
+  ],
+  "2001:6::/64": [
+    {
+      "prefix": "2001:6::/64",
+      "protocol": "connected",
+      "vrfId": 0,
+      "vrfName": "default",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 254,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth0",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/ce6/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,16 @@
+log file zebra.log
+!
+hostname ce6
+!
+interface eth0
+ ip address 192.168.6.2/24
+ ipv6 address 2001:6::2/64
+!
+ip forwarding
+ipv6 forwarding
+!
+ip route 0.0.0.0/0 192.168.6.1
+ipv6 route ::/0 2001:6::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,87 @@
+frr defaults traditional
+!
+bgp send-extra-data zebra
+!
+hostname r1
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+!debug bgp neighbor-events
+!debug bgp zebra
+!debug bgp vnc verbose
+!debug bgp update-groups
+!debug bgp updates in
+!debug bgp updates out
+!debug bgp vpn label
+!debug bgp vpn leak-from-vrf
+!debug bgp vpn leak-to-vrf
+!debug bgp vpn rmap-event
+!
+router bgp 1
+ bgp router-id 1.1.1.1
+ no bgp ebgp-requires-policy
+ !no bgp default ipv4-unicast
+ neighbor 2001::2 remote-as 2
+ neighbor 2001::2 timers 3 10
+ neighbor 2001::2 timers connect 1
+ neighbor 2001::2 capability extended-nexthop
+ !
+ address-family ipv4 vpn
+  neighbor 2001::2 activate
+ exit-address-family
+ !
+ address-family ipv6 vpn
+  neighbor 2001::2 activate
+ exit-address-family
+ !
+ segment-routing srv6
+  locator loc1
+ !
+!
+router bgp 1 vrf vrf10
+ bgp router-id 1.1.1.1
+ no bgp ebgp-requires-policy
+ sid vpn per-vrf export auto
+ !
+ address-family ipv4 unicast
+  nexthop vpn export 2001::1
+  rd vpn export 1:10
+  rt vpn both 99:99
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv6 unicast
+  rd vpn export 1:10
+  rt vpn both 99:99
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+!
+router bgp 1 vrf vrf20
+ bgp router-id 1.1.1.1
+ no bgp ebgp-requires-policy
+ sid vpn per-vrf export auto
+ !
+ address-family ipv4 unicast
+  nexthop vpn export 2001::1
+  rd vpn export 1:20
+  rt vpn both 88:88
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv6 unicast
+  rd vpn export 1:20
+  rt vpn both 88:88
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,167 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 2,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_deleted.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_deleted.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_deleted.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_deleted.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,90 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_recreated.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_recreated.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_recreated.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_locator_recreated.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,166 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_disabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_disabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_disabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_disabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,115 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 4,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_reenabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_reenabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_reenabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv4_rib_sid_vpn_export_reenabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,167 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 6,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,170 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 2,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_deleted.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_deleted.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_deleted.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_deleted.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,160 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_recreated.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_recreated.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_recreated.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_locator_recreated.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,169 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_disabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_disabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_disabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_disabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,116 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 4,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_reenabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_reenabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_reenabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vpnv6_rib_sid_vpn_export_reenabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,170 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 6,
+  "routerId": "1.1.1.1",
+  "defaultLocPrf": 100,
+  "localAS": 1,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::2",
+            "path": "2",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,86 @@
+{
+  "192.168.1.0/24": [
+    {
+      "prefix": "192.168.1.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth1",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "192.168.2.0/24": [
+    {
+      "prefix": "192.168.2.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:1::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ],
+  "192.168.3.0/24": [
+    {
+      "prefix": "192.168.3.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth2",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf10v6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,86 @@
+{
+  "2001:1::/64": [
+    {
+      "prefix": "2001:1::/64",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth1",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "2001:2::/64": [
+    {
+      "prefix": "2001:2::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:1::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ],
+  "2001:3::/64": [
+    {
+      "prefix": "2001:3::/64",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth2",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,92 @@
+{
+  "192.168.4.0/24": [
+    {
+      "prefix": "192.168.4.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:2::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ],
+  "192.168.5.0/24": [
+    {
+      "prefix": "192.168.5.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth3",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "192.168.6.0/24": [
+    {
+      "prefix": "192.168.6.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:2::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/vrf20v6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,92 @@
+{
+  "2001:4::/64": [
+    {
+      "prefix": "2001:4::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:2::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ],
+  "2001:5::/64": [
+    {
+      "prefix": "2001:5::/64",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth3",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "2001:6::/64": [
+    {
+      "prefix": "2001:6::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:2:2:2::"
+          }
+        }
+      ],
+      "asPath": "2"
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,43 @@
+log file zebra.log
+!
+hostname r1
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+debug zebra packet
+debug zebra dplane
+debug zebra kernel
+!
+interface eth0
+ ipv6 address 2001::1/64
+!
+interface eth1 vrf vrf10
+ ip address 192.168.1.1/24
+ ipv6 address 2001:1::1/64
+!
+interface eth2 vrf vrf10
+ ip address 192.168.3.1/24
+ ipv6 address 2001:3::1/64
+!
+interface eth3 vrf vrf20
+ ip address 192.168.5.1/24
+ ipv6 address 2001:5::1/64
+!
+segment-routing
+ srv6
+  locators
+   locator loc1
+    prefix 2001:db8:1:1::/64
+  !
+ !
+!
+ip forwarding
+ipv6 forwarding
+!
+ipv6 route 2001:db8:2:2::/64 2001::2
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,88 @@
+frr defaults traditional
+!
+bgp send-extra-data zebra
+!
+hostname r2
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+!debug bgp neighbor-events
+!debug bgp zebra
+!debug bgp vnc verbose
+!debug bgp update-groups
+!debug bgp updates in
+!debug bgp updates out
+!debug bgp updates
+!debug bgp vpn label
+!debug bgp vpn leak-from-vrf
+!debug bgp vpn leak-to-vrf
+!debug bgp vpn rmap-event
+!
+router bgp 2
+ bgp router-id 2.2.2.2
+ no bgp ebgp-requires-policy
+ !no bgp default ipv4-unicast
+ neighbor 2001::1 remote-as 1
+ neighbor 2001::1 timers 3 10
+ neighbor 2001::1 timers connect 1
+ neighbor 2001::1 capability extended-nexthop
+ !
+ address-family ipv4 vpn
+  neighbor 2001::1 activate
+ exit-address-family
+ !
+ address-family ipv6 vpn
+  neighbor 2001::1 activate
+ exit-address-family
+ !
+ segment-routing srv6
+  locator loc1
+ !
+!
+router bgp 2 vrf vrf10
+ bgp router-id 2.2.2.2
+ no bgp ebgp-requires-policy
+ sid vpn per-vrf export auto
+ !
+ address-family ipv4 unicast
+  nexthop vpn export 2001::2
+  rd vpn export 2:10
+  rt vpn both 99:99
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv6 unicast
+  rd vpn export 2:10
+  rt vpn both 99:99
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+!
+router bgp 2 vrf vrf20
+ bgp router-id 2.2.2.2
+ no bgp ebgp-requires-policy
+ sid vpn per-vrf export auto
+ !
+ address-family ipv4 unicast
+  nexthop vpn export 2001::2
+  rd vpn export 2:20
+  rt vpn both 88:88
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+ !
+ address-family ipv6 unicast
+  rd vpn export 2:20
+  rt vpn both 88:88
+  import vpn
+  export vpn
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,167 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 2,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_deleted.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_deleted.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_deleted.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_deleted.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,90 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_recreated.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_recreated.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_recreated.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_locator_recreated.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,166 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_disabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_disabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_disabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_disabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,117 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 4,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_reenabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_reenabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_reenabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv4_rib_sid_vpn_export_reenabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,167 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 6,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "192.168.1.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.1.0",
+            "prefixLen": 24,
+            "network": "192.168.1.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.3.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.3.0",
+            "prefixLen": 24,
+            "network": "192.168.3.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "192.168.5.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.5.0",
+            "prefixLen": 24,
+            "network": "192.168.5.0/24",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "192.168.2.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.2.0",
+            "prefixLen": 24,
+            "network": "192.168.2.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "192.168.4.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.4.0",
+            "prefixLen": 24,
+            "network": "192.168.4.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "192.168.6.0/24": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "192.168.6.0",
+            "prefixLen": 24,
+            "network": "192.168.6.0/24",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "2001::2",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,170 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 2,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_deleted.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_deleted.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_deleted.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_deleted.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,93 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_recreated.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_recreated.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_recreated.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_locator_recreated.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,169 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_disabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_disabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_disabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_disabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,120 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 4,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_reenabled.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_reenabled.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_reenabled.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vpnv6_rib_sid_vpn_export_reenabled.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,170 @@
+{
+  "vrfId": 0,
+  "vrfName": "default",
+  "tableVersion": 6,
+  "routerId": "2.2.2.2",
+  "defaultLocPrf": 100,
+  "localAS": 2,
+  "routes": {
+    "routeDistinguishers": {
+      "1:10": {
+        "2001:1::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:1::",
+            "prefixLen": 64,
+            "network": "2001:1::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:3::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:3::",
+            "prefixLen": 64,
+            "network": "2001:3::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "1:20": {
+        "2001:5::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:5::",
+            "prefixLen": 64,
+            "network": "2001:5::/64",
+            "metric": 0,
+            "weight": 0,
+            "peerId": "2001::1",
+            "path": "1",
+            "origin": "incomplete",
+            "nexthops": [
+              {
+                "ip": "2001::1",
+                "hostname": "r1",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:10": {
+        "2001:2::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:2::",
+            "prefixLen": 64,
+            "network": "2001:2::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf10",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      },
+      "2:20": {
+        "2001:4::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:4::",
+            "prefixLen": 64,
+            "network": "2001:4::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ],
+        "2001:6::/64": [
+          {
+            "valid": true,
+            "bestpath": true,
+            "selectionReason": "First path received",
+            "pathFrom": "external",
+            "prefix": "2001:6::",
+            "prefixLen": 64,
+            "network": "2001:6::/64",
+            "metric": 0,
+            "weight": 32768,
+            "peerId": "(unspec)",
+            "path": "",
+            "origin": "incomplete",
+            "announceNexthopSelf": true,
+            "nhVrfName": "vrf20",
+            "nexthops": [
+              {
+                "ip": "::",
+                "hostname": "r2",
+                "afi": "ipv6",
+                "used": true
+              }
+            ]
+          }
+        ]
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,92 @@
+{
+  "192.168.1.0/24": [
+    {
+      "prefix": "192.168.1.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:1::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ],
+  "192.168.2.0/24": [
+    {
+      "prefix": "192.168.2.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth1",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "192.168.3.0/24": [
+    {
+      "prefix": "192.168.3.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:1::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf10v6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,92 @@
+{
+  "2001:1::/64": [
+    {
+      "prefix": "2001:1::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:1::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ],
+  "2001:2::/64": [
+    {
+      "prefix": "2001:2::/64",
+      "protocol": "connected",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth1",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "2001:3::/64": [
+    {
+      "prefix": "2001:3::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf10",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 10,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:1::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v4_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v4_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v4_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v4_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,86 @@
+{
+  "192.168.4.0/24": [
+    {
+      "prefix": "192.168.4.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth2",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "192.168.5.0/24": [
+    {
+      "prefix": "192.168.5.0/24",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:2::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ],
+  "192.168.6.0/24": [
+    {
+      "prefix": "192.168.6.0/24",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth3",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v6_rib.json frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v6_rib.json
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v6_rib.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/vrf20v6_rib.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,86 @@
+{
+  "2001:4::/64": [
+    {
+      "prefix": "2001:4::/64",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth2",
+          "active": true
+        }
+      ]
+    }
+  ],
+  "2001:5::/64": [
+    {
+      "prefix": "2001:5::/64",
+      "protocol": "bgp",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 20,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "afi": "ipv6",
+          "interfaceName": "eth0",
+          "vrf": "default",
+          "active": true,
+          "weight": 1,
+          "seg6": {
+            "segs": "2001:db8:1:1:2::"
+          }
+        }
+      ],
+      "asPath": "1"
+    }
+  ],
+  "2001:6::/64": [
+    {
+      "prefix": "2001:6::/64",
+      "protocol": "connected",
+      "vrfName": "vrf20",
+      "selected": true,
+      "destSelected": true,
+      "distance": 0,
+      "metric": 0,
+      "installed": true,
+      "table": 20,
+      "internalStatus": 16,
+      "internalFlags": 8,
+      "internalNextHopNum": 1,
+      "internalNextHopActiveNum": 1,
+      "nexthops": [
+        {
+          "flags": 3,
+          "fib": true,
+          "directlyConnected": true,
+          "interfaceName": "eth3",
+          "active": true
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,43 @@
+log file zebra.log
+!
+hostname r2
+password zebra
+!
+log stdout notifications
+log monitor notifications
+log commands
+!
+debug zebra packet
+debug zebra dplane
+debug zebra kernel
+!
+interface eth0
+ ipv6 address 2001::2/64
+!
+interface eth1 vrf vrf10
+ ip address 192.168.2.1/24
+ ipv6 address 2001:2::1/64
+!
+interface eth2 vrf vrf20
+ ip address 192.168.4.1/24
+ ipv6 address 2001:4::1/64
+!
+interface eth3 vrf vrf20
+ ip address 192.168.6.1/24
+ ipv6 address 2001:6::1/64
+!
+segment-routing
+ srv6
+  locators
+   locator loc1
+    prefix 2001:db8:2:2::/64
+  !
+ !
+!
+ip forwarding
+ipv6 forwarding
+!
+ipv6 route 2001:db8:1:1::/64 2001::1
+!
+line vty
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/test_bgp_srv6l3vpn_to_bgp_vrf3.py frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/test_bgp_srv6l3vpn_to_bgp_vrf3.py
--- frr-frr-8.4.2/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/test_bgp_srv6l3vpn_to_bgp_vrf3.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_srv6l3vpn_to_bgp_vrf3/test_bgp_srv6l3vpn_to_bgp_vrf3.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,380 @@
+#!/usr/bin/env python
+
+# Copyright (c) 2022, University of Rome Tor Vergata
+# Authored by Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+import os
+import re
+import sys
+import json
+import functools
+import pytest
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+from lib.common_config import required_linux_kernel_version
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    tgen.add_router("r1")
+    tgen.add_router("r2")
+    tgen.add_router("ce1")
+    tgen.add_router("ce2")
+    tgen.add_router("ce3")
+    tgen.add_router("ce4")
+    tgen.add_router("ce5")
+    tgen.add_router("ce6")
+
+    tgen.add_link(tgen.gears["r1"], tgen.gears["r2"], "eth0", "eth0")
+    tgen.add_link(tgen.gears["ce1"], tgen.gears["r1"], "eth0", "eth1")
+    tgen.add_link(tgen.gears["ce2"], tgen.gears["r2"], "eth0", "eth1")
+    tgen.add_link(tgen.gears["ce3"], tgen.gears["r1"], "eth0", "eth2")
+    tgen.add_link(tgen.gears["ce4"], tgen.gears["r2"], "eth0", "eth2")
+    tgen.add_link(tgen.gears["ce5"], tgen.gears["r1"], "eth0", "eth3")
+    tgen.add_link(tgen.gears["ce6"], tgen.gears["r2"], "eth0", "eth3")
+
+
+def setup_module(mod):
+    result = required_linux_kernel_version("5.14")
+    if result is not True:
+        pytest.skip("Kernel requirements are not met")
+
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+    for rname, router in tgen.routers().items():
+        router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.gears["r1"].run("sysctl net.vrf.strict_mode=1")
+    tgen.gears["r1"].run("ip link add vrf10 type vrf table 10")
+    tgen.gears["r1"].run("ip link set vrf10 up")
+    tgen.gears["r1"].run("ip link add vrf20 type vrf table 20")
+    tgen.gears["r1"].run("ip link set vrf20 up")
+    tgen.gears["r1"].run("ip link set eth1 master vrf10")
+    tgen.gears["r1"].run("ip link set eth2 master vrf10")
+    tgen.gears["r1"].run("ip link set eth3 master vrf20")
+
+    tgen.gears["r2"].run("sysctl net.vrf.strict_mode=1")
+    tgen.gears["r2"].run("ip link add vrf10 type vrf table 10")
+    tgen.gears["r2"].run("ip link set vrf10 up")
+    tgen.gears["r2"].run("ip link add vrf20 type vrf table 20")
+    tgen.gears["r2"].run("ip link set vrf20 up")
+    tgen.gears["r2"].run("ip link set eth1 master vrf10")
+    tgen.gears["r2"].run("ip link set eth2 master vrf20")
+    tgen.gears["r2"].run("ip link set eth3 master vrf20")
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def open_json_file(filename):
+    try:
+        with open(filename, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(filename)
+
+
+def check_ping4(name, dest_addr, expect_connected):
+    def _check(name, dest_addr, match):
+        tgen = get_topogen()
+        output = tgen.gears[name].run("ping {} -c 1 -w 1".format(dest_addr))
+        logger.info(output)
+        assert match in output, "ping fail"
+
+    match = ", {} packet loss".format("0%" if expect_connected else "100%")
+    logger.info("[+] check {} {} {}".format(name, dest_addr, match))
+    tgen = get_topogen()
+    func = functools.partial(_check, name, dest_addr, match)
+    success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
+    assert result is None, "Failed"
+
+
+def check_ping6(name, dest_addr, expect_connected):
+    def _check(name, dest_addr, match):
+        tgen = get_topogen()
+        output = tgen.gears[name].run("ping6 {} -c 1 -w 1".format(dest_addr))
+        logger.info(output)
+        if match not in output:
+            return "ping fail"
+
+    match = "{} packet loss".format("0%" if expect_connected else "100%")
+    logger.info("[+] check {} {} {}".format(name, dest_addr, match))
+    tgen = get_topogen()
+    func = functools.partial(_check, name, dest_addr, match)
+    success, result = topotest.run_and_expect(func, None, count=10, wait=1)
+    assert result is None, "Failed"
+
+
+def check_rib(name, cmd, expected_file):
+    def _check(name, dest_addr, match):
+        logger.info("polling")
+        tgen = get_topogen()
+        router = tgen.gears[name]
+        output = json.loads(router.vtysh_cmd(cmd))
+        expected = open_json_file("{}/{}".format(CWD, expected_file))
+        return topotest.json_cmp(output, expected)
+
+    logger.info('[+] check {} "{}" {}'.format(name, cmd, expected_file))
+    tgen = get_topogen()
+    func = functools.partial(_check, name, cmd, expected_file)
+    success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
+    assert result is None, "Failed"
+
+
+def test_rib():
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib.json")
+    check_rib("r1", "show ip route vrf vrf10 json", "r1/vrf10v4_rib.json")
+    check_rib("r1", "show ip route vrf vrf20 json", "r1/vrf20v4_rib.json")
+    check_rib("r2", "show ip route vrf vrf10 json", "r2/vrf10v4_rib.json")
+    check_rib("r2", "show ip route vrf vrf20 json", "r2/vrf20v4_rib.json")
+    check_rib("ce1", "show ip route json", "ce1/ip_rib.json")
+    check_rib("ce2", "show ip route json", "ce2/ip_rib.json")
+    check_rib("ce3", "show ip route json", "ce3/ip_rib.json")
+    check_rib("ce4", "show ip route json", "ce4/ip_rib.json")
+    check_rib("ce5", "show ip route json", "ce5/ip_rib.json")
+    check_rib("ce6", "show ip route json", "ce6/ip_rib.json")
+
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib.json")
+    check_rib("r1", "show ipv6 route vrf vrf10 json", "r1/vrf10v6_rib.json")
+    check_rib("r1", "show ipv6 route vrf vrf20 json", "r1/vrf20v6_rib.json")
+    check_rib("r2", "show ipv6 route vrf vrf10 json", "r2/vrf10v6_rib.json")
+    check_rib("r2", "show ipv6 route vrf vrf20 json", "r2/vrf20v6_rib.json")
+    check_rib("ce1", "show ipv6 route json", "ce1/ipv6_rib.json")
+    check_rib("ce2", "show ipv6 route json", "ce2/ipv6_rib.json")
+    check_rib("ce3", "show ipv6 route json", "ce3/ipv6_rib.json")
+    check_rib("ce4", "show ipv6 route json", "ce4/ipv6_rib.json")
+    check_rib("ce5", "show ipv6 route json", "ce5/ipv6_rib.json")
+    check_rib("ce6", "show ipv6 route json", "ce6/ipv6_rib.json")
+
+
+def test_ping():
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping4("ce1", "192.168.3.2", True)
+    check_ping4("ce1", "192.168.4.2", False)
+    check_ping4("ce1", "192.168.5.2", False)
+    check_ping4("ce1", "192.168.6.2", False)
+    check_ping4("ce4", "192.168.1.2", False)
+    check_ping4("ce4", "192.168.2.2", False)
+    check_ping4("ce4", "192.168.3.2", False)
+    check_ping4("ce4", "192.168.5.2", True)
+    check_ping4("ce4", "192.168.6.2", True)
+
+    check_ping6("ce1", "2001:2::2", True)
+    check_ping6("ce1", "2001:3::2", True)
+    check_ping6("ce1", "2001:4::2", False)
+    check_ping6("ce1", "2001:5::2", False)
+    check_ping6("ce1", "2001:6::2", False)
+    check_ping6("ce4", "2001:1::2", False)
+    check_ping6("ce4", "2001:2::2", False)
+    check_ping6("ce4", "2001:3::2", False)
+    check_ping6("ce4", "2001:5::2", True)
+    check_ping6("ce4", "2001:6::2", True)
+
+
+def test_bgp_sid_vpn_export_disable():
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1 vrf vrf10
+          segment-routing srv6
+           no sid vpn per-vrf export
+        """
+    )
+    check_rib(
+        "r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_sid_vpn_export_disabled.json"
+    )
+    check_rib(
+        "r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_sid_vpn_export_disabled.json"
+    )
+    check_rib(
+        "r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_sid_vpn_export_disabled.json"
+    )
+    check_rib(
+        "r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_sid_vpn_export_disabled.json"
+    )
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+
+
+def test_bgp_sid_vpn_export_reenable():
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1 vrf vrf10
+          segment-routing srv6
+           sid vpn per-vrf export auto
+        """
+    )
+    check_rib(
+        "r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_sid_vpn_export_reenabled.json"
+    )
+    check_rib(
+        "r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_sid_vpn_export_reenabled.json"
+    )
+    check_rib(
+        "r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_sid_vpn_export_reenabled.json"
+    )
+    check_rib(
+        "r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_sid_vpn_export_reenabled.json"
+    )
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+
+
+def test_locator_delete():
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            no locator loc1
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_deleted.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_deleted.json")
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+
+
+def test_locator_recreate():
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            locator loc1
+             prefix 2001:db8:1:1::/64
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_recreated.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_recreated.json")
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+
+
+def test_bgp_locator_unset():
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1
+          segment-routing srv6
+           no locator loc1
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_deleted.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_deleted.json")
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+
+
+def test_bgp_locator_reset():
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1
+          segment-routing srv6
+           locator loc1
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_recreated.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_recreated.json")
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+
+
+def test_bgp_srv6_unset():
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1
+          no segment-routing srv6
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_deleted.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_deleted.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_deleted.json")
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+
+
+def test_bgp_srv6_reset():
+    check_ping4("ce1", "192.168.2.2", False)
+    check_ping6("ce1", "2001:2::2", False)
+    get_topogen().gears["r1"].vtysh_cmd(
+        """
+        configure terminal
+         router bgp 1
+          segment-routing srv6
+           locator loc1
+        """
+    )
+    check_rib("r1", "show bgp ipv4 vpn json", "r1/vpnv4_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv4 vpn json", "r2/vpnv4_rib_locator_recreated.json")
+    check_rib("r1", "show bgp ipv6 vpn json", "r1/vpnv6_rib_locator_recreated.json")
+    check_rib("r2", "show bgp ipv6 vpn json", "r2/vpnv6_rib_locator_recreated.json")
+    check_ping4("ce1", "192.168.2.2", True)
+    check_ping6("ce1", "2001:2::2", True)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_suppress_fib/test_bgp_suppress_fib.py frr-frr-8.5/tests/topotests/bgp_suppress_fib/test_bgp_suppress_fib.py
--- frr-frr-8.4.2/tests/topotests/bgp_suppress_fib/test_bgp_suppress_fib.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_suppress_fib/test_bgp_suppress_fib.py	2023-03-13 20:01:47.000000000 +0600
@@ -106,7 +106,7 @@ def test_bgp_route():
         "show ip route 50.0.0.0 json",
         expected,
     )
-    _, result = topotest.run_and_expect(test_func, None, count=3, wait=0.5)
+    _, result = topotest.run_and_expect(test_func, None, count=10, wait=0.5)
     assertmsg = '"r3" JSON output mismatches'
     assert result is None, assertmsg
 
@@ -118,8 +118,9 @@ def test_bgp_route():
         r3,
         "show ip route 10.0.0.3 json",
         expected,
-        )
-    _, result = topotest.run_and_expect(test_func, None, count=3, wait=0.5)
+    )
+    _, result = topotest.run_and_expect(test_func, None, count=10, wait=0.5)
+
 
 def test_bgp_better_admin_won():
     "A better Admin distance protocol may come along and knock us out"
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_tcp_mss/test_bgp_tcp_mss.py frr-frr-8.5/tests/topotests/bgp_tcp_mss/test_bgp_tcp_mss.py
--- frr-frr-8.4.2/tests/topotests/bgp_tcp_mss/test_bgp_tcp_mss.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_tcp_mss/test_bgp_tcp_mss.py	2023-03-13 20:01:47.000000000 +0600
@@ -153,7 +153,7 @@ def test_bgp_tcp_mss():
         "Verify if TCP MSS value is synced with neighbor in {}".format(router1.name)
     )
     test_func = functools.partial(_bgp_check_neighbor_tcp_mss, router1, "192.168.255.2")
-    success, result = topotest.run_and_expect(test_func, None, count=3, wait=0.5)
+    success, result = topotest.run_and_expect(test_func, None, count=10, wait=0.5)
     assert (
         result is None
     ), 'Failed to sync TCP MSS value over BGP session in "{}"'.format(router1.name)
@@ -163,7 +163,7 @@ def test_bgp_tcp_mss():
         "Verify if TCP MSS value is synced with neighbor in {}".format(router2.name)
     )
     test_func = functools.partial(_bgp_check_neighbor_tcp_mss, router2, "192.168.255.1")
-    success, result = topotest.run_and_expect(test_func, None, count=3, wait=0.5)
+    success, result = topotest.run_and_expect(test_func, None, count=10, wait=0.5)
     assert (
         result is None
     ), 'Failed to sync TCP MSS value over BGP session in "{}"'.format(router2.name)
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unique_rid/bgp_unique_rid.json frr-frr-8.5/tests/topotests/bgp_unique_rid/bgp_unique_rid.json
--- frr-frr-8.4.2/tests/topotests/bgp_unique_rid/bgp_unique_rid.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unique_rid/bgp_unique_rid.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,505 @@
+{
+   "address_types": [
+      "ipv4",
+      "ipv6"
+   ],
+   "ipv4base": "10.0.0.0",
+   "ipv4mask": 30,
+   "ipv6base": "fd00::",
+   "ipv6mask": 64,
+   "link_ip_start": {
+      "ipv4": "10.0.0.0",
+      "v4mask": 30,
+      "ipv6": "fd00::",
+      "v6mask": 64
+   },
+   "lo_prefix": {
+      "ipv4": "1.0.",
+      "v4mask": 32,
+      "ipv6": "2001:DB8:F::",
+      "v6mask": 128
+   },
+   "routers": {
+      "r1": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": {
+            "local_as": "100",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r2": {
+                           "dest_link": {
+                              "r1": {}
+                           }
+                        },
+                        "r3": {
+                           "dest_link": {
+                              "r1": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r2": {
+                           "dest_link": {
+                              "r1": {}
+                           }
+                        },
+                        "r3": {
+                           "dest_link": {
+                              "r1": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               }
+            }
+         }
+      },
+      "r2": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": {
+            "local_as": "100",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r1": {
+                           "dest_link": {
+                              "r2": {}
+                           }
+                        },
+                        "r3": {
+                           "dest_link": {
+                              "r2": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r1": {
+                           "dest_link": {
+                              "r2": {}
+                           }
+                        },
+                        "r3": {
+                           "dest_link": {
+                              "r2": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               }
+            }
+         }
+      },
+      "r3": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "ospf": {
+                  "area": "0.0.0.0",
+                  "hello_interval": 1,
+                  "dead_interval": 4
+               }
+            },
+            "r5": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "ospf": {
+                  "area": "0.0.0.0",
+                  "hello_interval": 1,
+                  "dead_interval": 4
+               }
+            },
+            "r4-link1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link4": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link5": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link6": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link7": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": {
+            "local_as": "100",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r1": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        },
+                        "r2": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        },
+                        "r4": {
+                           "dest_link": {
+                              "r3": {},
+                              "r3-link1": {},
+                              "r3-link2": {},
+                              "r3-link3": {},
+                              "r3-link4": {},
+                              "r3-link5": {},
+                              "r3-link6": {},
+                              "r3-link7": {}
+                           }
+                        },
+                        "r5": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        }
+                     }
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r1": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        },
+                        "r2": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        },
+                        "r4": {
+                           "dest_link": {
+                              "r3": {},
+                              "r3-link1": {},
+                              "r3-link2": {},
+                              "r3-link3": {},
+                              "r3-link4": {},
+                              "r3-link5": {},
+                              "r3-link6": {},
+                              "r3-link7": {}
+                           }
+                        },
+                        "r5": {
+                           "dest_link": {
+                              "r3": {}
+                           }
+                        }
+                     }
+                  }
+               }
+            },
+            "redistribute": [
+               {
+                  "redist_type": "static"
+               },
+               {
+                  "redist_type": "connected"
+               }
+            ]
+         },
+         "ospf": {
+            "router_id": "100.1.1.3",
+            "neighbors": {
+               "r4": {},
+               "r5": {}
+            },
+            "redistribute": [
+               {
+                  "redist_type": "static"
+               },
+               {
+                  "redist_type": "connected"
+               }
+            ]
+         }
+      },
+      "r4": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "ospf": {
+                  "area": "0.0.0.0",
+                  "hello_interval": 1,
+                  "dead_interval": 4
+               }
+            },
+            "r3-link1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link4": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link5": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link6": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link7": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": {
+            "local_as": "200",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r4": {},
+                              "r4-link1": {},
+                              "r4-link2": {},
+                              "r4-link3": {},
+                              "r4-link4": {},
+                              "r4-link5": {},
+                              "r4-link6": {},
+                              "r4-link7": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r4": {},
+                              "r4-link1": {},
+                              "r4-link2": {},
+                              "r4-link3": {},
+                              "r4-link4": {},
+                              "r4-link5": {},
+                              "r4-link6": {},
+                              "r4-link7": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               }
+            }
+         },
+         "ospf": {
+            "router_id": "10.10.10.10",
+            "neighbors": {
+               "r3": {}
+            }
+         }
+      },
+      "r5": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "ospf": {
+                  "area": "0.0.0.0",
+                  "hello_interval": 1,
+                  "dead_interval": 4
+               }
+            }
+         },
+         "bgp": {
+            "local_as": "300",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r5": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r5": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               }
+            }
+         },
+         "ospf": {
+            "router_id": "100.1.1.5",
+            "neighbors": {
+               "r3": {}
+            },
+            "redistribute": [
+               {
+                  "redist_type": "static"
+               },
+               {
+                  "redist_type": "connected"
+               }
+            ]
+         }
+      }
+   }
+}
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unique_rid/bgp_unique_rid_vrf.json frr-frr-8.5/tests/topotests/bgp_unique_rid/bgp_unique_rid_vrf.json
--- frr-frr-8.4.2/tests/topotests/bgp_unique_rid/bgp_unique_rid_vrf.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unique_rid/bgp_unique_rid_vrf.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,529 @@
+{
+   "address_types": [
+      "ipv4",
+      "ipv6"
+   ],
+   "ipv4base": "10.0.0.0",
+   "ipv4mask": 30,
+   "ipv6base": "fd00::",
+   "ipv6mask": 64,
+   "link_ip_start": {
+      "ipv4": "10.0.0.0",
+      "v4mask": 30,
+      "ipv6": "fd00::",
+      "v6mask": 64
+   },
+   "lo_prefix": {
+      "ipv4": "1.0.",
+      "v4mask": 32,
+      "ipv6": "2001:DB8:F::",
+      "v6mask": 128
+   },
+   "routers": {
+      "r1": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback",
+               "vrf": "GREEN"
+            },
+            "r2": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            }
+         },
+         "bgp": [
+            {
+               "local_as": "100",
+               "vrf": "GREEN",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r2": {
+                              "dest_link": {
+                                 "r1": {}
+                              }
+                           },
+                           "r3": {
+                              "dest_link": {
+                                 "r1": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r2": {
+                              "dest_link": {
+                                 "r1": {}
+                              }
+                           },
+                           "r3": {
+                              "dest_link": {
+                                 "r1": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  }
+               }
+            }
+         ],
+         "vrfs": [
+            {
+               "name": "GREEN",
+               "id": "1"
+            }
+         ]
+      },
+      "r2": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback",
+               "vrf": "GREEN"
+            },
+            "r1": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            }
+         },
+         "bgp": [
+            {
+               "local_as": "100",
+               "vrf": "GREEN",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r1": {
+                              "dest_link": {
+                                 "r2": {}
+                              }
+                           },
+                           "r3": {
+                              "dest_link": {
+                                 "r2": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r1": {
+                              "dest_link": {
+                                 "r2": {}
+                              }
+                           },
+                           "r3": {
+                              "dest_link": {
+                                 "r2": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  }
+               }
+            }
+         ],
+         "vrfs": [
+            {
+               "name": "GREEN",
+               "id": "1"
+            }
+         ]
+      },
+      "r3": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback",
+               "vrf": "GREEN"
+            },
+            "r1": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            },
+            "r2": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "GREEN"
+            },
+            "r4": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r5": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "RED"
+            },
+            "r4-link1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link4": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link5": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link6": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r4-link7": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": [
+            {
+               "local_as": "100",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r4": {
+                              "dest_link": {
+                                 "r3": {},
+                                 "r3-link1": {},
+                                 "r3-link2": {},
+                                 "r3-link3": {},
+                                 "r3-link4": {},
+                                 "r3-link5": {},
+                                 "r3-link6": {},
+                                 "r3-link7": {}
+                              }
+                           }
+                        }
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r4": {
+                              "dest_link": {
+                                 "r3": {},
+                                 "r3-link1": {},
+                                 "r3-link2": {},
+                                 "r3-link3": {},
+                                 "r3-link4": {},
+                                 "r3-link5": {},
+                                 "r3-link6": {},
+                                 "r3-link7": {}
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            },
+            {
+               "local_as": "100",
+               "vrf": "GREEN",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r1": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           },
+                           "r2": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           }
+                        }
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r1": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           },
+                           "r2": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            },
+            {
+               "local_as": "100",
+               "vrf": "RED",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r5": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           }
+                        }
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r5": {
+                              "dest_link": {
+                                 "r3": {}
+                              }
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+         ],
+         "vrfs": [
+            {
+               "name": "RED",
+               "id": "1"
+            },
+            {
+               "name": "GREEN",
+               "id": "2"
+            }
+         ]
+      },
+      "r4": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link1": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link2": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link3": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link4": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link5": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link6": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            },
+            "r3-link7": {
+               "ipv4": "auto",
+               "ipv6": "auto"
+            }
+         },
+         "bgp": [{
+            "local_as": "200",
+            "address_family": {
+               "ipv4": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r4": {},
+                              "r4-link1": {},
+                              "r4-link2": {},
+                              "r4-link3": {},
+                              "r4-link4": {},
+                              "r4-link5": {},
+                              "r4-link6": {},
+                              "r4-link7": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               },
+               "ipv6": {
+                  "unicast": {
+                     "neighbor": {
+                        "r3": {
+                           "dest_link": {
+                              "r4": {},
+                              "r4-link1": {},
+                              "r4-link2": {},
+                              "r4-link3": {},
+                              "r4-link4": {},
+                              "r4-link5": {},
+                              "r4-link6": {},
+                              "r4-link7": {}
+                           }
+                        }
+                     },
+                     "redistribute": [
+                        {
+                           "redist_type": "static"
+                        },
+                        {
+                           "redist_type": "connected"
+                        }
+                     ]
+                  }
+               }
+            }
+         }]
+      },
+      "r5": {
+         "links": {
+            "lo": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "type": "loopback",
+               "vrf": "RED"
+            },
+            "r3": {
+               "ipv4": "auto",
+               "ipv6": "auto",
+               "vrf": "RED"
+            }
+         },
+         "bgp": [
+            {
+               "local_as": "300",
+               "vrf":"RED",
+               "address_family": {
+                  "ipv4": {
+                     "unicast": {
+                        "neighbor": {
+                           "r3": {
+                              "dest_link": {
+                                 "r5": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  },
+                  "ipv6": {
+                     "unicast": {
+                        "neighbor": {
+                           "r3": {
+                              "dest_link": {
+                                 "r5": {}
+                              }
+                           }
+                        },
+                        "redistribute": [
+                           {
+                              "redist_type": "static"
+                           },
+                           {
+                              "redist_type": "connected"
+                           }
+                        ]
+                     }
+                  }
+               }
+            }
+         ],
+         "vrfs": [
+            {
+               "name": "RED",
+               "id": "1"
+            }
+         ]
+      }
+   }
+}
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unique_rid/test_bgp_unique_rid.py frr-frr-8.5/tests/topotests/bgp_unique_rid/test_bgp_unique_rid.py
--- frr-frr-8.4.2/tests/topotests/bgp_unique_rid/test_bgp_unique_rid.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unique_rid/test_bgp_unique_rid.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,906 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+import sys
+import time
+import pytest
+import inspect
+import os
+from copy import deepcopy
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+"""Following tests are covered to test bgp unique rid functionality.
+1. Verify eBGP session when same and different router ID is configured.
+2. Verify iBGP session when same and different router ID is configured.
+3. Verify two different eBGP sessions initiated with same router ID.
+4. Chaos - Verify bgp unique rid functionality in chaos scenarios.
+5. Chaos - Verify bgp unique rid functionality when router reboots with same loopback id.
+6. Chaos - Verify bgp unique rid functionality when router reboots without any ip addresses.
+"""
+
+#################################
+# TOPOLOGY
+#################################
+"""
+
+                    +-------+
+         +--------- |  R2   |
+         |          +-------+
+         |iBGP           |
+     +-------+           |
+     |  R1   |           |iBGP
+     +-------+           |
+         |               |
+         |    iBGP   +-------+   eBGP   +-------+
+         +---------- |  R3   |========= |  R4   |
+                     +-------+          +-------+
+                        |
+                        |eBGP
+                        |
+                    +-------+
+                    |  R5   |
+                    +-------+
+
+
+"""
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topojson import build_config_from_json
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.ospfd, pytest.mark.staticd]
+
+# Required to instantiate the topology builder class.
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    step,
+    write_test_footer,
+    verify_rib,
+    check_address_types,
+    reset_config_on_routers,
+    check_router_status,
+    stop_router,
+    kill_router_daemons,
+    start_router_daemons,
+    start_router,
+)
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    create_router_bgp,
+    clear_bgp_and_verify,
+)
+
+# Global variables
+topo = None
+bgp_convergence = False
+NETWORK = {
+    "ipv4": [
+        "192.168.20.1/32",
+        "192.168.20.2/32",
+        "192.168.21.1/32",
+        "192.168.21.2/32",
+        "192.168.22.1/32",
+        "192.168.22.2/32",
+    ],
+    "ipv6": [
+        "fc07:50::1/128",
+        "fc07:50::2/128",
+        "fc07:150::1/128",
+        "fc07:150::2/128",
+        "fc07:1::1/128",
+        "fc07:1::2/128",
+    ],
+}
+
+bgp_convergence = False
+ADDR_TYPES = check_address_types()
+routerid = {"ipv4": "10.10.10.14", "ipv6": "fd00:0:0:3::2"}
+
+
+def setup_module(mod):
+    """setup_module.
+
+    Set up the pytest environment
+    * `mod`: module name
+    """
+    global topo
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_unique_rid.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    # Checking BGP convergence
+    global bgp_convergence
+    global ADDR_TYPES
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    # Api call verify whether BGP is converged
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "setup_module :Failed \n Error:" " {}".format(
+        bgp_convergence
+    )
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+#####################################################
+# Tests starting
+#####################################################
+
+
+def test_bgp_unique_rid_ebgp_p0():
+    """
+    TC: 1
+    Verify eBGP session when same and different router ID is configured.
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R4 and R3 10.10.10.10")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r4": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R5 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r5": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("modify the router id on r3 to different router id (11.11.11.11)")
+    input_dict = {"r3": {"bgp": {"router_id": "11.11.11.11"}}}
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Reset bgp process")
+    step("Verify neighbours are in ESTAB state.")
+    dut = "r3"
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Clear ip bgp process with *")
+    step("Verify neighbours are in ESTAB state.")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure neighbours between R3 and R4 in EVPN address family.")
+    input_dict = {
+        "r3": {
+            "bgp": {
+                "address_family": {
+                    "l2vpn": {
+                        "evpn": {
+                            "advertise": {
+                                "ipv4": {"unicast": {}},
+                                "ipv6": {"unicast": {}},
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "r4": {
+            "bgp": {
+                "address_family": {
+                    "l2vpn": {
+                        "evpn": {
+                            "advertise": {
+                                "ipv4": {"unicast": {}},
+                                "ipv6": {"unicast": {}},
+                            }
+                        }
+                    }
+                }
+            }
+        },
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_ibgp_p0():
+    """
+    TC: 2
+    Verify iBGP session when same and different router ID is configured.
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R1 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r1": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in idle state.")
+    result = verify_bgp_convergence(tgen, topo, expected=False)
+    assert result is not True, "Testcase {} :Failed \n Error: {}".format(
+        tc_name, result
+    )
+
+    step("Configure the same router id between R2 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r2": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in idle state.")
+    result = verify_bgp_convergence(tgen, topo, expected=False)
+    assert result is not True, "Testcase {} :Failed \n Error: {}".format(
+        tc_name, result
+    )
+
+    step("modify the router id on r3 to different router id (11.11.11.11)")
+    input_dict = {"r3": {"bgp": {"router_id": "11.11.11.11"}}}
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo, dut="r3")
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Reset bgp process")
+    step("Verify neighbours are in ESTAB state.")
+    dut = "r3"
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Clear ip bgp process with *")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_multi_bgp_nbrs_p0():
+    """
+    TC: 3
+    3. Verify two different eBGP sessions initiated with same router ID
+
+    """
+    tgen = get_topogen()
+    global bgp_convergence, topo
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R3, R4 and R5 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r4": {"bgp": {"router_id": "10.10.10.10"}},
+        "r5": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Configure the same IP address on on R4 and R5 loopback address and \
+            change the neighborship to loopback neighbours between R3 to R4 \
+            and R3 to R5 respectively."
+    )
+
+    topo1 = deepcopy(topo)
+
+    for rtr in ["r4", "r5"]:
+        topo1["routers"][rtr]["links"]["lo"]["ipv4"] = "192.168.1.1/32"
+
+    topo1["routers"]["r3"]["links"]["lo"]["ipv4"] = "192.168.1.3/32"
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step(
+        "change the neighborship to loopback neighbours between R3 to R4 and R3 to R5 respectively."
+    )
+    for rtr in ["r4", "r5"]:
+        configure_bgp_on_rtr = {
+            "r3": {
+                "bgp": {
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {"neighbor": {rtr: {"dest_link": {"lo": {}}}}}
+                        }
+                    }
+                },
+            }
+        }
+        result = create_router_bgp(tgen, topo1, configure_bgp_on_rtr)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Change the IP address on the R4 loopback.")
+    topo1["routers"]["r4"]["links"]["lo"]["ipv4"] = "192.168.1.4/32"
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step("Verify neighbours should be again in ESTAB state. (show ip bgp neighbours)")
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Clear ip bgp process with *")
+    result = clear_bgp_and_verify(tgen, topo, router="r3")
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_chaos1_p2():
+    """
+    TC: 4
+    4. Chaos - Verify bgp unique rid functionality in chaos scenarios.
+
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R3, R4 and R5 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10"}},
+        "r4": {"bgp": {"router_id": "10.10.10.10"}},
+        "r5": {"bgp": {"router_id": "10.10.10.10"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Verify eBGP session when same router ID is configured and bgpd process is restarted"
+    )
+
+    # restart bgpd router and verify
+    kill_router_daemons(tgen, "r3", ["bgpd"])
+    start_router_daemons(tgen, "r3", ["bgpd"])
+
+    step(
+        "The session should be established between R3 & R4. "
+        "Once after restart bgp, neighbor should come back up ."
+    )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step(
+        "Verify eBGP session when same router ID is configured and neighbor shutdown is issued and again no shutdown."
+    )
+
+    input_dict = {
+        "r3": {
+            "bgp": {
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {"shutdown": True},
+                                        "r3-link2": {"shutdown": True},
+                                        "r3-link3": {"shutdown": True},
+                                        "r3-link4": {"shutdown": True},
+                                        "r3-link5": {"shutdown": True},
+                                        "r3-link6": {"shutdown": True},
+                                        "r3-link7": {"shutdown": True},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {"shutdown": True}}},
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {"shutdown": True},
+                                        "r3-link2": {"shutdown": True},
+                                        "r3-link3": {"shutdown": True},
+                                        "r3-link4": {"shutdown": True},
+                                        "r3-link5": {"shutdown": True},
+                                        "r3-link6": {"shutdown": True},
+                                        "r3-link7": {"shutdown": True},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {"shutdown": True}}},
+                            }
+                        }
+                    },
+                },
+            }
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    input_dict = {
+        "r3": {
+            "bgp": {
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {"shutdown": False},
+                                        "r3-link2": {"shutdown": False},
+                                        "r3-link3": {"shutdown": False},
+                                        "r3-link4": {"shutdown": False},
+                                        "r3-link5": {"shutdown": False},
+                                        "r3-link6": {"shutdown": False},
+                                        "r3-link7": {"shutdown": False},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {"shutdown": False}}},
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {"shutdown": False},
+                                        "r3-link2": {"shutdown": False},
+                                        "r3-link3": {"shutdown": False},
+                                        "r3-link4": {"shutdown": False},
+                                        "r3-link5": {"shutdown": False},
+                                        "r3-link6": {"shutdown": False},
+                                        "r3-link7": {"shutdown": False},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {"shutdown": False}}},
+                            }
+                        }
+                    },
+                },
+            }
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "The session should be established between R3 & R4. "
+        "Once after restart bgp, neighbor should come back up ."
+    )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step(
+        "Verify eBGP session when same router ID is configured and neighbor config is deleted & reconfigured."
+    )
+
+    input_dict = {
+        "r3": {
+            "bgp": {
+                "local_as": "100",
+                "address_family": {
+                    "ipv4": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {},
+                                        "r3-link2": {},
+                                        "r3-link3": {},
+                                        "r3-link4": {},
+                                        "r3-link5": {},
+                                        "r3-link6": {},
+                                        "r3-link7": {},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {}}},
+                            }
+                        }
+                    },
+                    "ipv6": {
+                        "unicast": {
+                            "neighbor": {
+                                "r4": {
+                                    "dest_link": {
+                                        "r3-link1": {},
+                                        "r3-link2": {},
+                                        "r3-link3": {},
+                                        "r3-link4": {},
+                                        "r3-link5": {},
+                                        "r3-link6": {},
+                                        "r3-link7": {},
+                                    }
+                                },
+                                "r5": {"dest_link": {"r3": {}}},
+                            }
+                        }
+                    },
+                },
+            }
+        }
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "The session should be established between R3 & R4. "
+        "Once after restart bgp, neighbor should come back up ."
+    )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step(
+        "Verify eBGP session when same router ID is configured and FRR router is restarted."
+    )
+    stop_router(tgen, "r3")
+    start_router(tgen, "r3")
+
+    step(
+        "The session should be established between R3 & R4. "
+        "Once after restart bgp, neighbor should come back up ."
+    )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step(
+        "Verify eBGP session when same router ID is configured and zebra process is restarted"
+    )
+
+    kill_router_daemons(tgen, "r3", ["zebra"])
+    start_router_daemons(tgen, "r3", ["zebra"])
+
+    step(
+        "The session should be established between R3 & R4. "
+        "Once after restart bgp, neighbor should come back up ."
+    )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_chaos3_p2():
+    """
+    TC: 4
+    4. Chaos - Verify bgp unique rid functionality when router reboots with same loopback id.
+
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    global topo
+    topo1 = deepcopy(topo)
+
+    for rtr in topo["routers"].keys():
+        topo1["routers"][rtr]["links"]["lo"]["ipv4"] = "192.168.1.1/32"
+
+    topo1["routers"]["r3"]["links"]["lo"]["ipv4"] = "192.168.1.3/32"
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step("verify bgp convergence before starting test case")
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo1)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step(
+        "Configure loopback on R1 to R5 with IP address 1.1.1.1 on all the routers. Change neighborship on all the routers using loopback neighborship ids."
+    )
+    for rtr in ["r1", "r2", "r4", "r5"]:
+        configure_bgp_on_rtr = {
+            "r3": {
+                "bgp": {
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {"neighbor": {rtr: {"dest_link": {"lo": {}}}}}
+                        }
+                    }
+                },
+            }
+        }
+        result = create_router_bgp(tgen, topo1, configure_bgp_on_rtr)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Reboot the router (restart frr) or using watch frr.")
+    stop_router(tgen, "r3")
+    start_router(tgen, "r3")
+
+    step("Neighbors between R3, R4 and R3 to R5 should be in ESTB state.")
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Clear bgp process.")
+    clear_bgp_and_verify(tgen, topo, "r3")
+
+    step("Neighbors between R3, R4 and R3 to R5 should be in ESTB state.")
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_chaos4_p2():
+    """
+    TC: 6
+    6. Chaos - Verify bgp unique rid functionality when router reboots without any ip addresses.
+
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    reset_config_on_routers(tgen)
+
+    global topo
+    topo1 = deepcopy(topo)
+    topo2 = deepcopy(topo)
+
+    step(
+        "Configure base config as per the topology without loopback as well as Ip address on any of the interface."
+    )
+    for rtr in topo["routers"].keys():
+        for intf in topo["routers"][rtr]["links"].keys():
+            topo1["routers"][rtr]["links"][intf].pop("ipv4")
+            topo1["routers"][rtr]["links"][intf].pop("ipv6")
+            if intf is "lo":
+                topo1["routers"][rtr]["links"][intf].pop("ipv4")
+
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Configure the ip addresses on the physical interfaces")
+    build_config_from_json(tgen, topo2, save_bkup=False)
+
+    step("All the neighbors should be in ESTAB state.")
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Configure loopback addresses with higher IP address ")
+    build_config_from_json(tgen, topo, save_bkup=False)
+
+    step("All the neighbors should be in ESTAB state.")
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Reboot the router (restart frr) or using watch frr.")
+    stop_router(tgen, "r3")
+    start_router(tgen, "r3")
+
+    step("Neighbors between R3, R4 and R3 to R5 should be in ESTB state.")
+    bgp_convergence = verify_bgp_convergence(tgen, topo, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unique_rid/test_bgp_unique_rid_vrf.py frr-frr-8.5/tests/topotests/bgp_unique_rid/test_bgp_unique_rid_vrf.py
--- frr-frr-8.4.2/tests/topotests/bgp_unique_rid/test_bgp_unique_rid_vrf.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unique_rid/test_bgp_unique_rid_vrf.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,479 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+import sys
+import time
+import pytest
+import inspect
+import os
+from copy import deepcopy
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+"""Following tests are covered to test bgp unique rid functionality.
+1. Verify iBGP session when same and different router ID is configured in user VRF(GREEN).
+2. Verify eBGP session when same and different router ID is configured in user vrf (VRF RED)
+3. Verify two different eBGP sessions initiated with same router ID in user VRf (RED and GREEN)
+"""
+
+#################################
+# TOPOLOGY
+#################################
+"""
+
+                    +-------+
+         +--------- |  R2   |
+         |          +-------+
+         |iBGP           |
+     +-------+           |
+     |  R1   |           |iBGP
+     +-------+           |
+         |               |
+         |    iBGP   +-------+   eBGP   +-------+
+         +---------- |  R3   |========= |  R4   |
+                     +-------+          +-------+
+                        |
+                        |eBGP
+                        |
+                    +-------+
+                    |  R5   |
+                    +-------+
+
+
+"""
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topojson import build_config_from_json
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Required to instantiate the topology builder class.
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    step,
+    write_test_footer,
+    check_address_types,
+    reset_config_on_routers,
+    check_router_status,
+)
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    create_router_bgp,
+    clear_bgp_and_verify,
+)
+
+# Global variables
+topo = None
+bgp_convergence = False
+NETWORK = {
+    "ipv4": [
+        "192.168.20.1/32",
+        "192.168.20.2/32",
+        "192.168.21.1/32",
+        "192.168.21.2/32",
+        "192.168.22.1/32",
+        "192.168.22.2/32",
+    ],
+    "ipv6": [
+        "fc07:50::1/128",
+        "fc07:50::2/128",
+        "fc07:150::1/128",
+        "fc07:150::2/128",
+        "fc07:1::1/128",
+        "fc07:1::2/128",
+    ],
+}
+
+bgp_convergence = False
+ADDR_TYPES = check_address_types()
+
+
+def setup_module(mod):
+    """setup_module.
+
+    Set up the pytest environment
+    * `mod`: module name
+    """
+    global topo
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_unique_rid_vrf.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    # Checking BGP convergence
+    global bgp_convergence
+    global ADDR_TYPES
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    # Api call verify whether BGP is converged
+    bgp_convergence = verify_bgp_convergence(tgen, topo)
+    assert bgp_convergence is True, "setup_module :Failed \n Error:" " {}".format(
+        bgp_convergence
+    )
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+#####################################################
+# Tests starting
+#####################################################
+
+
+def test_bgp_unique_rid_ebgp_vrf_p0():
+    """
+    TC: 1
+    Verify iBGP session when same and different router ID is configured in user VRF(GREEN).
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R4 and R3 10.10.10.10")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+        "r4": {"bgp": {"router_id": "10.10.10.10", "local_as": 200, "vrf": "RED"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R5 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+        "r5": {"bgp": {"router_id": "10.10.10.10", "local_as": 300, "vrf": "RED"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("modify the router id on r3 to different router id (11.11.11.11)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "11.11.11.11", "local_as": 100, "vrf": "RED"}}
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Reset bgp process")
+    step("Verify neighbours are in ESTAB state.")
+    dut = "r3"
+    result = clear_bgp_and_verify(tgen, topo, router="r3")
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Clear ip bgp process with *")
+    step("Verify neighbours are in ESTAB state.")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure neighbours between R3 and R4 in EVPN address family.")
+    input_dict = {
+        "r3": {
+            "bgp": {
+                "local_as": 100,
+                "vrf": "RED",
+                "address_family": {
+                    "l2vpn": {
+                        "evpn": {
+                            "advertise": {
+                                "ipv4": {"unicast": {}},
+                                "ipv6": {"unicast": {}},
+                            }
+                        }
+                    }
+                },
+            }
+        },
+        "r4": {
+            "bgp": {
+                "local_as": 200,
+                "vrf": "RED",
+                "address_family": {
+                    "l2vpn": {
+                        "evpn": {
+                            "advertise": {
+                                "ipv4": {"unicast": {}},
+                                "ipv6": {"unicast": {}},
+                            }
+                        }
+                    }
+                },
+            }
+        },
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_ibgp_vrf_p0():
+    """
+    TC: 2
+    Verify eBGP session when same and different router ID is configured in user vrf (VRF RED)
+    """
+    tgen = get_topogen()
+    global bgp_convergence
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R1 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+        "r1": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R2 and R3 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+        "r2": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("modify the router id on r3 to different router id (11.11.11.11)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "11.11.11.11", "local_as": 100, "vrf": "RED"}}
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo, dut="r3")
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Reset bgp process")
+    step("Verify neighbours are in ESTAB state.")
+    dut = "r3"
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Clear ip bgp process with *")
+    result = clear_bgp_and_verify(tgen, topo, dut)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_bgp_unique_rid_multi_bgp_nbrs_vrf_p0():
+    """
+    TC: 3
+    Verify two different eBGP sessions initiated with same router ID in user VRf (RED and GREEN)
+
+    """
+    tgen = get_topogen()
+    global bgp_convergence, topo
+
+    if bgp_convergence is not True:
+        pytest.skip("skipped because of BGP Convergence failure")
+
+    # test case name
+    tc_name = inspect.stack()[0][3]
+    write_test_header(tc_name)
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Configure base config as per the topology")
+    reset_config_on_routers(tgen)
+
+    step(
+        "Base config should be up, verify using BGP convergence on all \
+    the routers for IPv4 and IPv6 nbrs"
+    )
+
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Configure the same router id between R3, R4 and R5 (10.10.10.10)")
+    input_dict = {
+        "r3": {"bgp": {"router_id": "10.10.10.10", "local_as": 100, "vrf": "RED"}},
+        "r4": {"bgp": {"router_id": "10.10.10.10", "local_as": 200, "vrf": "RED"}},
+        "r5": {"bgp": {"router_id": "10.10.10.10", "local_as": 300, "vrf": "RED"}},
+    }
+    result = create_router_bgp(tgen, topo, input_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify neighbours are in ESTAB state.")
+    result = verify_bgp_convergence(tgen, topo)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Configure the same IP address on on R4 and R5 loopback address and \
+            change the neighborship to loopback neighbours between R3 to R4 \
+            and R3 to R5 respectively."
+    )
+
+    topo1 = deepcopy(topo)
+
+    for rtr in ["r4", "r5"]:
+        topo1["routers"][rtr]["links"]["lo"]["ipv4"] = "192.168.1.1/32"
+
+    topo1["routers"]["r3"]["links"]["lo"]["ipv4"] = "192.168.1.3/32"
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step(
+        "change the neighborship to loopback neighbours between R3 to R4 and R3 to R5 respectively."
+    )
+    for rtr in ["r4", "r5"]:
+        configure_bgp_on_rtr = {
+            "r3": {
+                "bgp": {
+                    "local_as": 100,
+                    "vrf": "RED",
+                    "address_family": {
+                        "ipv4": {
+                            "unicast": {"neighbor": {rtr: {"dest_link": {"lo": {}}}}}
+                        }
+                    },
+                },
+            }
+        }
+        result = create_router_bgp(tgen, topo1, configure_bgp_on_rtr)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Change the IP address on the R4 loopback.")
+    topo1["routers"]["r4"]["links"]["lo"]["ipv4"] = "192.168.1.4/32"
+    build_config_from_json(tgen, topo1, save_bkup=False)
+
+    step("Verify neighbours should be again in ESTAB state. (show ip bgp neighbours)")
+    bgp_convergence = verify_bgp_convergence(tgen, topo1, dut="r3")
+    assert bgp_convergence is True, "Testcase {} : Failed \n Error: {}".format(
+        tc_name, bgp_convergence
+    )
+
+    step("Clear ip bgp process with *")
+    result = clear_bgp_and_verify(tgen, topo, router="r3")
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_unnumbered/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unnumbered/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+router bgp 65001
+  timers bgp 1 9
+  no bgp ebgp-requires-policy
+  neighbor r1-eth0 interface remote-as external
+  address-family ipv4 unicast
+  exit-address-family
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r1/zebra.conf frr-frr-8.5/tests/topotests/bgp_unnumbered/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unnumbered/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+!
+interface lo
+ ip address 172.16.250.254/32
+!
+interface r1-eth0
+ ip address 192.168.0.1/24
+!
+ip forwarding
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_unnumbered/r2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unnumbered/r2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+router bgp 65002
+  no bgp network import-check
+  no bgp ebgp-requires-policy
+  timers bgp 1 9
+  neighbor r2-eth0 interface remote-as external
+  address-family ipv4 uni
+    network 172.16.255.254/32
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r2/zebra.conf frr-frr-8.5/tests/topotests/bgp_unnumbered/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_unnumbered/r2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unnumbered/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+!
+interface r2-eth0
+ ip address 192.168.0.2/24
+!
+interface r2-eth1
+ ip address 192.168.1.1/24
+!
+interface r2-eth2
+ ip address 192.168.2.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_unnumbered/test_bgp_unnumbered.py frr-frr-8.5/tests/topotests/bgp_unnumbered/test_bgp_unnumbered.py
--- frr-frr-8.4.2/tests/topotests/bgp_unnumbered/test_bgp_unnumbered.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_unnumbered/test_bgp_unnumbered.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,132 @@
+#!/usr/bin/env python
+#
+# Copyright (c) 2022 by
+# Donald Sharp
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Test some bgp interface based issues that show up
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+
+    tgen.add_router("r1")
+    tgen.add_router("r2")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["r1"])
+    switch.add_link(tgen.gears["r2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+#
+# Test these events:
+# a) create an unnumbered neighbor
+# b) shutdown the interface
+# c) remove the unnumbered peer in bgp and bgp does not crash
+def test_bgp_unnumbered_removal():
+    tgen = get_topogen()
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_nexthop_cache():
+        output = tgen.gears["r1"].vtysh_cmd("show bgp nexthop")
+        expected = "Current BGP nexthop cache:\n"
+        return output == expected
+
+    def _bgp_converge():
+        output = json.loads(
+            tgen.gears["r1"].vtysh_cmd("show ip bgp 172.16.255.254/32 json")
+        )
+        expected = {"prefix": "172.16.255.254/32"}
+
+        return topotest.json_cmp(output, expected)
+
+    step("Ensure Convergence of BGP")
+    test_func = functools.partial(_bgp_converge)
+    success, result = topotest.run_and_expect(test_func, None, count=60, wait=1)
+
+    assert result is None, 'Failed bgp convergence in "{}"'.format(tgen.gears["r2"])
+
+    step("Shutdown interface r1-eth0")
+
+    tgen.gears["r1"].vtysh_cmd(
+        """
+           configure
+           int r1-eth0
+             shutdown
+        """
+    )
+
+    step("Remove the neighbor from r1")
+    tgen.gears["r1"].vtysh_cmd(
+        """
+           configure
+           router bgp
+            no neighbor r1-eth0 interface remote-as external
+       """
+    )
+
+    step("Ensure that BGP does not crash")
+    test_func = functools.partial(_bgp_nexthop_cache)
+    success, result = topotest.run_and_expect(test_func, True, count=10, wait=1)
+
+    assert result is True, "BGP did not crash on r1"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+router bgp 65000
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.2 remote-as external
+ neighbor 192.168.1.2 timers 1 3
+ neighbor 192.168.1.2 timers connect 1
+ address-family ipv4 unicast
+  redistribute connected
+ exit-address-family
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe1/zebra.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,9 @@
+!
+interface lo
+ ip address 172.16.255.1/32
+!
+interface cpe1-eth0
+ ip address 192.168.1.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+router bgp 65000
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.2 remote-as external
+ neighbor 192.168.2.2 timers 1 3
+ neighbor 192.168.2.2 timers connect 1
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe2/zebra.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/cpe2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/cpe2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,6 @@
+!
+interface cpe2-eth0
+ ip address 192.168.2.1/24
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,38 @@
+router bgp 65001
+ bgp router-id 10.10.10.10
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 2001:db8:1::2 remote-as internal
+ neighbor 2001:db8:1::2 update-source 2001:db8:1::1
+ neighbor 2001:db8:1::2 timers 1 3
+ neighbor 2001:db8:1::2 timers connect 1
+ neighbor 2001:db8:1::2 capability extended-nexthop
+ address-family ipv4 vpn
+  neighbor 2001:db8:1::2 activate
+  neighbor 2001:db8:1::2 route-map pe2 out
+ exit-address-family
+!
+router bgp 65001 vrf RED
+ bgp router-id 192.168.1.2
+ no bgp ebgp-requires-policy
+ neighbor 192.168.1.1 remote-as external
+ neighbor 192.168.1.1 timers 1 3
+ neighbor 192.168.1.1 timers connect 1
+ address-family ipv4 unicast
+  label vpn export 1111
+  rd vpn export 192.168.1.2:2
+  rt vpn import 192.168.2.2:2 192.168.1.2:2
+  rt vpn export 192.168.1.2:2
+  export vpn
+  import vpn
+ exit-address-family
+!
+ip prefix-list cpe1 seq 5 permit 172.16.255.1/32
+!
+route-map pe2 permit 10
+ match ip address prefix-list cpe1
+ set ipv6 vpn next-hop 2001:db8::1
+!
+route-map pe2 permit 20
+exit
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/ldpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+mpls ldp
+ router-id 10.10.10.10
+ !
+ address-family ipv4
+  discovery transport-address 10.10.10.10
+  !
+  interface pe1-eth1
+  !
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/ospf6d.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/ospf6d.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/ospf6d.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/ospf6d.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+!
+interface lo
+ ipv6 ospf6 area 0
+!
+interface pe1-eth1
+ ipv6 ospf6 area 0
+ ipv6 ospf6 hello-interval 1
+ ipv6 ospf6 dead-interval 3
+!
+router ospf6
+ ospf6 router-id 10.10.10.10
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/zebra.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+!
+interface lo
+ ip address 10.10.10.10/32
+ ipv6 address 2001:db8:1::1/128
+!
+interface pe1-eth0 vrf RED
+ ip address 192.168.1.2/24
+!
+interface pe1-eth1
+ ip address 10.0.1.1/24
+ ipv6 address 2001:db8::1/64
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/bgpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/bgpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,29 @@
+router bgp 65001
+ bgp router-id 10.10.10.20
+ no bgp ebgp-requires-policy
+ no bgp default ipv4-unicast
+ neighbor 2001:db8:1::1 remote-as internal
+ neighbor 2001:db8:1::1 update-source 2001:db8:1::2
+ neighbor 2001:db8:1::1 timers 1 3
+ neighbor 2001:db8:1::1 timers connect 1
+ neighbor 2001:db8:1::1 capability extended-nexthop
+ address-family ipv4 vpn
+  neighbor 2001:db8:1::1 activate
+ exit-address-family
+!
+router bgp 65001 vrf RED
+ bgp router-id 192.168.2.2
+ no bgp ebgp-requires-policy
+ neighbor 192.168.2.1 remote-as external
+ neighbor 192.168.2.1 timers 1 3
+ neighbor 192.168.2.1 timers connect 1
+ address-family ipv4 unicast
+  label vpn export 2222
+  rd vpn export 192.168.2.2:2
+  rt vpn import 192.168.2.2:2 192.168.1.2:2
+  rt vpn export 192.168.2.2:2
+  export vpn
+  import vpn
+ exit-address-family
+!
+
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/ldpd.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/ldpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/ldpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/ldpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,10 @@
+mpls ldp
+ router-id 10.10.10.20
+ !
+ address-family ipv4
+  discovery transport-address 10.10.10.20
+  !
+  interface pe2-eth0
+  !
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/ospf6d.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/ospf6d.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/ospf6d.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/ospf6d.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,12 @@
+!
+interface lo
+ ipv6 ospf6 area 0
+!
+interface pe2-eth0
+ ipv6 ospf6 area 0
+ ipv6 ospf6 hello-interval 1
+ ipv6 ospf6 dead-interval 3
+!
+router ospf6
+ ospf6 router-id 10.10.10.20
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/zebra.conf frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/pe2/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/pe2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+!
+interface lo
+ ip address 10.10.10.20/32
+ ipv6 address 2001:db8:1::2/128
+!
+interface pe2-eth1 vrf RED
+ ip address 192.168.2.2/24
+!
+interface pe2-eth0
+ ip address 10.0.1.2/24
+ ipv6 address 2001:db8::2/64
+!
+ip forwarding
+!
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/test_bgp_vpn_5549_route_map.py frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/test_bgp_vpn_5549_route_map.py
--- frr-frr-8.4.2/tests/topotests/bgp_vpn_5549_route_map/test_bgp_vpn_5549_route_map.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpn_5549_route_map/test_bgp_vpn_5549_route_map.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,138 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by
+# Donatas Abraitis <donatas@opensourcerouting.org>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Check if we can override VPN underlay next-hop from PE1 to PE2.
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.common_config import step
+
+pytestmark = [pytest.mark.bgpd]
+
+
+def build_topo(tgen):
+    tgen.add_router("cpe1")
+    tgen.add_router("cpe2")
+    tgen.add_router("pe1")
+    tgen.add_router("pe2")
+
+    switch = tgen.add_switch("s1")
+    switch.add_link(tgen.gears["cpe1"])
+    switch.add_link(tgen.gears["pe1"])
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(tgen.gears["pe1"])
+    switch.add_link(tgen.gears["pe2"])
+
+    switch = tgen.add_switch("s3")
+    switch.add_link(tgen.gears["pe2"])
+    switch.add_link(tgen.gears["cpe2"])
+
+
+def setup_module(mod):
+    tgen = Topogen(build_topo, mod.__name__)
+    tgen.start_topology()
+
+    pe1 = tgen.gears["pe1"]
+    pe2 = tgen.gears["pe2"]
+
+    pe1.run("ip link add RED type vrf table 1001")
+    pe1.run("ip link set up dev RED")
+    pe2.run("ip link add RED type vrf table 1001")
+    pe2.run("ip link set up dev RED")
+    pe1.run("ip link set pe1-eth0 master RED")
+    pe2.run("ip link set pe2-eth1 master RED")
+
+    pe1.run("sysctl -w net.ipv4.ip_forward=1")
+    pe2.run("sysctl -w net.ipv4.ip_forward=1")
+    pe1.run("sysctl -w net.mpls.conf.pe1-eth0.input=1")
+    pe2.run("sysctl -w net.mpls.conf.pe2-eth1.input=1")
+
+    router_list = tgen.routers()
+
+    for i, (rname, router) in enumerate(router_list.items(), 1):
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_OSPF6, os.path.join(CWD, "{}/ospf6d.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_LDP, os.path.join(CWD, "{}/ldpd.conf".format(rname))
+        )
+
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_bgp_vpn_5549():
+    tgen = get_topogen()
+
+    pe2 = tgen.gears["pe2"]
+
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    def _bgp_vpn_nexthop_changed():
+        output = json.loads(pe2.vtysh_cmd("show bgp ipv4 vpn json"))
+        expected = {
+            "routes": {
+                "routeDistinguishers": {
+                    "192.168.1.2:2": {
+                        "172.16.255.1/32": [
+                            {"valid": True, "nexthops": [{"ip": "2001:db8::1"}]}
+                        ],
+                        "192.168.1.0/24": [
+                            {"valid": True, "nexthops": [{"ip": "2001:db8:1::1"}]}
+                        ],
+                    }
+                }
+            }
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = functools.partial(_bgp_vpn_nexthop_changed)
+    _, result = topotest.run_and_expect(test_func, None, count=60, wait=0.5)
+    assert result is None, "Failed overriding IPv6 next-hop for VPN underlay"
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpnv4_gre/r1/bgpd.conf frr-frr-8.5/tests/topotests/bgp_vpnv4_gre/r1/bgpd.conf
--- frr-frr-8.4.2/tests/topotests/bgp_vpnv4_gre/r1/bgpd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpnv4_gre/r1/bgpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -14,6 +14,7 @@ router bgp 65500 vrf vrf1
  bgp router-id 192.0.2.1
  address-family ipv4 unicast
   redistribute connected
+  distance bgp 21 201 41
   label vpn export 101
   rd vpn export 444:1
   rt vpn both 52:100
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpnv4_gre/r1/ipv4_routes.json frr-frr-8.5/tests/topotests/bgp_vpnv4_gre/r1/ipv4_routes.json
--- frr-frr-8.4.2/tests/topotests/bgp_vpnv4_gre/r1/ipv4_routes.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpnv4_gre/r1/ipv4_routes.json	2023-03-13 20:01:47.000000000 +0600
@@ -7,7 +7,7 @@
             "vrfName": "vrf1",
             "selected": true,
             "destSelected": true,
-            "distance": 20,
+            "distance": 201,
             "metric": 0,
             "nexthops": [
                 {
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes.json frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes.json
--- frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,7 +1,6 @@
 {
    "vrfId":0,
    "vrfName":"default",
-   "tableVersion":1,
    "routerId":"1.1.1.1",
    "defaultLocPrf":100,
    "localAS":65500,
@@ -17,7 +16,6 @@
                   "prefix":"10.201.0.0",
                   "prefixLen":24,
                   "network":"10.201.0.0\/24",
-                  "version":1,
                   "metric":0,
                   "weight":32768,
                   "peerId":"(unspec)",
@@ -28,6 +26,7 @@
                   "nexthops":[
                      {
                         "ip":"0.0.0.0",
+                        "hostname":"r1",
                         "afi":"ipv4",
                         "used":true
                      }
@@ -45,7 +44,6 @@
                   "prefix":"10.200.0.0",
                   "prefixLen":24,
                   "network":"10.200.0.0\/24",
-                  "version":1,
                   "metric":0,
                   "locPrf":100,
                   "weight":0,
@@ -55,6 +53,7 @@
                   "nexthops":[
                      {
                         "ip":"10.125.0.2",
+                        "hostname":"r2",
                         "afi":"ipv4",
                         "used":true
                      }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes_unfiltered.json frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes_unfiltered.json
--- frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes_unfiltered.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/r1/ipv4_vpn_routes_unfiltered.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,7 +1,6 @@
 {
    "vrfId":0,
    "vrfName":"default",
-   "tableVersion":1,
    "routerId":"1.1.1.1",
    "defaultLocPrf":100,
    "localAS":65500,
@@ -17,7 +16,6 @@
                   "prefix":"10.201.0.0",
                   "prefixLen":24,
                   "network":"10.201.0.0\/24",
-                  "version":1,
                   "metric":0,
                   "weight":32768,
                   "peerId":"(unspec)",
@@ -28,6 +26,7 @@
                   "nexthops":[
                      {
                         "ip":"0.0.0.0",
+                        "hostname":"r1",
                         "afi":"ipv4",
                         "used":true
                      }
@@ -45,7 +44,6 @@
                   "prefix":"10.200.0.0",
                   "prefixLen":24,
                   "network":"10.200.0.0\/24",
-                  "version":1,
                   "metric":0,
                   "locPrf":100,
                   "weight":0,
@@ -55,6 +53,7 @@
                   "nexthops":[
                      {
                         "ip":"10.125.0.2",
+                        "hostname":"r2",
                         "afi":"ipv4",
                         "used":true
                      }
@@ -72,7 +71,6 @@
                   "prefix":"10.210.0.0",
                   "prefixLen":24,
                   "network":"10.210.0.0\/24",
-                  "version":1,
                   "metric":0,
                   "locPrf":100,
                   "weight":0,
@@ -82,6 +80,7 @@
                   "nexthops":[
                      {
                         "ip":"10.125.0.2",
+                        "hostname":"r2",
                         "afi":"ipv4",
                         "used":true
                      }
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/test_bgp_vpnv4_noretain.py frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/test_bgp_vpnv4_noretain.py
--- frr-frr-8.4.2/tests/topotests/bgp_vpnv4_noretain/test_bgp_vpnv4_noretain.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vpnv4_noretain/test_bgp_vpnv4_noretain.py	2023-03-13 20:01:47.000000000 +0600
@@ -133,27 +133,46 @@ def teardown_module(_mod):
     tgen.stop_topology()
 
 
-def test_protocols_convergence():
+def router_json_cmp_exact_filter(router, cmd, expected):
+    output = router.vtysh_cmd(cmd)
+    logger.info("{}: {}\n{}".format(router.name, cmd, output))
+
+    json_output = json.loads(output)
+
+    # filter out tableVersion, version and nhVrfID
+    json_output.pop("tableVersion")
+    for rd, data in json_output["routes"]["routeDistinguishers"].items():
+        for prefix, attrs in data.items():
+            for attr in attrs:
+                if "nhVrfId" in attr:
+                    attr.pop("nhVrfId")
+                if "version" in attr:
+                    attr.pop("version")
+
+    return topotest.json_cmp(json_output, expected, exact=True)
+
+
+def test_bgp_no_retain():
     """
-    Assert that all protocols have converged
-    statuses as they depend on it.
+    Check bgp no retain route-target all on r1
     """
+
     tgen = get_topogen()
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
     # Check IPv4 VPN routing tables on r1
-    logger.info("Checking IPv4 routes for convergence on r1")
-    router = tgen.gears['r1']
+    logger.info("Checking VPNv4 routes for convergence on r1")
+    router = tgen.gears["r1"]
     json_file = "{}/{}/ipv4_vpn_routes.json".format(CWD, router.name)
     if not os.path.isfile(json_file):
         logger.info("skipping file {}".format(json_file))
-        assert 0, 'ipv4_vpn_routes.json file not found'
+        assert 0, "{} file not found".format(json_file)
         return
 
     expected = json.loads(open(json_file).read())
     test_func = partial(
-        topotest.router_json_cmp,
+        router_json_cmp_exact_filter,
         router,
         "show bgp ipv4 vpn json",
         expected,
@@ -162,23 +181,31 @@ def test_protocols_convergence():
     assertmsg = '"{}" JSON output mismatches'.format(router.name)
     assert result is None, assertmsg
 
-    # Check BGP IPv4 routing tables after unsetting no retain flag
-    logger.info("Checking BGP IPv4 routes for convergence on r2")
-    router = tgen.gears['r1']
-    router.vtysh_cmd("configure\nrouter bgp 65500\naddress-family ipv4 vpn\nbgp retain route-target all\n")
+
+def test_bgp_retain():
+    """
+    Apply and check bgp retain route-target all on r1
+    """
+
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
 
     # Check IPv4 VPN routing tables on r1
-    logger.info("Checking IPv4 routes for convergence on r1")
-    router = tgen.gears['r1']
+    logger.info("Checking VPNv4 routes on r1 after bgp no retain")
+    router = tgen.gears["r1"]
+    router.vtysh_cmd(
+        "configure\nrouter bgp 65500\naddress-family ipv4 vpn\nbgp retain route-target all\n"
+    )
     json_file = "{}/{}/ipv4_vpn_routes_unfiltered.json".format(CWD, router.name)
     if not os.path.isfile(json_file):
         logger.info("skipping file {}".format(json_file))
-        assert 0, 'ipv4_vpn_routes_unfiltered.json file not found'
+        assert 0, "{} file not found".format(json_file)
         return
 
     expected = json.loads(open(json_file).read())
     test_func = partial(
-        topotest.router_json_cmp,
+        router_json_cmp_exact_filter,
         router,
         "show bgp ipv4 vpn json",
         expected,
@@ -187,6 +214,7 @@ def test_protocols_convergence():
     assertmsg = '"{}" JSON output mismatches'.format(router.name)
     assert result is None, assertmsg
 
+
 def test_memory_leak():
     "Run the memory leak test and report results."
     tgen = get_topogen()
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak/test_bgp_vrf_dynamic_route_leak_topo2.py frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak/test_bgp_vrf_dynamic_route_leak_topo2.py
--- frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak/test_bgp_vrf_dynamic_route_leak_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak/test_bgp_vrf_dynamic_route_leak_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -75,15 +75,6 @@ from lib.topojson import build_topo_from
 
 pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
 
-
-# Reading the data from JSON File for topology creation
-jsonFile = "{}/bgp_vrf_dynamic_route_leak_topo2.json".format(CWD)
-try:
-    with open(jsonFile, "r") as topoJson:
-        topo = json.load(topoJson)
-except IOError:
-    assert False, "Could not read file {}".format(jsonFile)
-
 # Global variables
 NETWORK1_1 = {"ipv4": "11.11.11.1/32", "ipv6": "11:11::1/128"}
 NETWORK3_3 = {"ipv4": "50.50.50.5/32", "ipv6": "50:50::5/128"}
@@ -92,13 +83,6 @@ NETWORK3_4 = {"ipv4": "50.50.50.50/32",
 PREFERRED_NEXT_HOP = "global"
 
 
-def build_topo(tgen):
-    """Build function"""
-
-    # Building topology from json file
-    build_topo_from_json(tgen, topo)
-
-
 def setup_module(mod):
     """
     Sets up the pytest environment
@@ -114,7 +98,9 @@ def setup_module(mod):
     logger.info("Running setup_module to create topology")
 
     # This function initiates the topology build with Topogen...
-    tgen = Topogen(build_topo, mod.__name__)
+    json_file = "{}/bgp_vrf_dynamic_route_leak_topo2.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
     # Starting topology, create tmp files which are loaded to routers
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-1.py frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-1.py
--- frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,407 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2021 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Following tests are covered to test BGP Multi-VRF Dynamic Route Leaking:
+1. Verify recursive import among Tenant VRFs.
+2. Verify that dynamic import works fine between two different Tenant VRFs.
+    When next-hop IPs are same across all VRFs.
+    When next-hop IPs are different across all VRFs.
+3. Verify that with multiple tenant VRFs, dynamic import works fine between
+    Tenant VRFs to default VRF.
+    When next-hop IPs and prefixes are same across all VRFs.
+    When next-hop IPs and prefixes are different across all VRFs.
+"""
+
+import os
+import sys
+import time
+import pytest
+import platform
+from time import sleep
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# Required to instantiate the topology builder class.
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    check_address_types,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    create_route_maps,
+    create_static_routes,
+    create_prefix_lists,
+    create_bgp_community_lists,
+    get_frr_ipv6_linklocal,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    create_router_bgp,
+    verify_bgp_community,
+    verify_bgp_rib,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+NETWORK1_1 = {"ipv4": "11.11.11.1/32", "ipv6": "11:11::1/128"}
+NETWORK1_2 = {"ipv4": "11.11.11.11/32", "ipv6": "11:11::11/128"}
+NETWORK1_3 = {"ipv4": "10.10.10.1/32", "ipv6": "10:10::1/128"}
+NETWORK1_4 = {"ipv4": "10.10.10.100/32", "ipv6": "10:10::100/128"}
+NETWORK1_5 = {"ipv4": "110.110.110.1/32", "ipv6": "110:110::1/128"}
+NETWORK1_6 = {"ipv4": "110.110.110.100/32", "ipv6": "110:110::100/128"}
+
+NETWORK2_1 = {"ipv4": "22.22.22.2/32", "ipv6": "22:22::2/128"}
+NETWORK2_2 = {"ipv4": "22.22.22.22/32", "ipv6": "22:22::22/128"}
+NETWORK2_3 = {"ipv4": "20.20.20.20/32", "ipv6": "20:20::20/128"}
+NETWORK2_4 = {"ipv4": "20.20.20.200/32", "ipv6": "20:20::200/128"}
+NETWORK2_5 = {"ipv4": "220.220.220.20/32", "ipv6": "220:220::20/128"}
+NETWORK2_6 = {"ipv4": "220.220.220.200/32", "ipv6": "220:220::200/128"}
+
+NETWORK3_1 = {"ipv4": "30.30.30.3/32", "ipv6": "30:30::3/128"}
+NETWORK3_2 = {"ipv4": "30.30.30.30/32", "ipv6": "30:30::30/128"}
+
+PREFIX_LIST = {
+    "ipv4": ["11.11.11.1", "22.22.22.2", "22.22.22.22"],
+    "ipv6": ["11:11::1", "22:22::2", "22:22::22"],
+}
+PREFERRED_NEXT_HOP = "global"
+VRF_LIST = ["RED", "BLUE", "GREEN"]
+COMM_VAL_1 = "100:100"
+COMM_VAL_2 = "500:500"
+COMM_VAL_3 = "600:600"
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_vrf_dynamic_route_leak_topo4.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Run these tests for kernel version 4.19 or above
+    if version_cmp(platform.release(), "4.19") < 0:
+        error_msg = (
+            "BGP vrf dynamic route leak tests will not run "
+            '(have kernel "{}", but it requires >= 4.19)'.format(platform.release())
+        )
+        pytest.skip(error_msg)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+#####################################################
+#
+#   Testcases
+#
+#####################################################
+
+
+def test_dynamic_import_recursive_import_tenant_vrf_p1(request):
+    """
+    Verify recursive import among Tenant VRFs.
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    reset_config_on_routers(tgen)
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step(
+        "Configure static routes on R2 for vrf RED and redistribute in "
+        "respective BGP instance"
+    )
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r2": {
+                "static_routes": [
+                    {
+                        "network": [NETWORK2_1[addr_type]],
+                        "next_hop": "blackhole",
+                        "vrf": "RED",
+                    }
+                ]
+            }
+        }
+
+        result = create_static_routes(tgen, static_routes)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Redistribute static route on BGP VRF RED")
+    temp = {}
+    for addr_type in ADDR_TYPES:
+        temp.update(
+            {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
+        )
+
+    redist_dict = {
+        "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
+    }
+
+    result = create_router_bgp(tgen, topo, redist_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step("Verify that R2 has installed redistributed routes in vrf RED only")
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r2": {
+                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "RED"}]
+            }
+        }
+        result = verify_bgp_rib(tgen, addr_type, "r2", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r2", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+    step("Import vrf RED's routes into vrf GREEN on R2")
+    temp = {}
+    for addr_type in ADDR_TYPES:
+        temp.update({addr_type: {"unicast": {"import": {"vrf": "RED"}}}})
+
+    import_dict = {
+        "r2": {"bgp": [{"vrf": "GREEN", "local_as": 2, "address_family": temp}]}
+    }
+    result = create_router_bgp(tgen, topo, import_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Verify on R2, that it installs imported routes from vrf RED to vrf "
+        "GREEN's RIB/FIB pointing next-hop to vrf RED"
+    )
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r2": {
+                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "GREEN"}]
+            }
+        }
+        result = verify_bgp_rib(tgen, addr_type, "r2", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r2", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+    step("On R3 import routes from vrf GREEN to vrf default")
+    temp = {}
+    for addr_type in ADDR_TYPES:
+        temp.update({addr_type: {"unicast": {"import": {"vrf": "GREEN"}}}})
+
+    import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
+    result = create_router_bgp(tgen, topo, import_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Verify on R3, that it installs imported routes from vrf GREEN to "
+        "vrf default RIB/FIB pointing next-hop to vrf GREEN. "
+    )
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r2": {"static_routes": [{"network": [NETWORK2_1[addr_type]]}]}
+        }
+        result = verify_bgp_rib(tgen, addr_type, "r3", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r3", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+    step("On R4 import routes from vrf default to vrf BLUE")
+    temp = {}
+    for addr_type in ADDR_TYPES:
+        temp.update({addr_type: {"unicast": {"import": {"vrf": "default"}}}})
+
+    import_dict = {
+        "r4": {"bgp": [{"vrf": "BLUE", "local_as": 4, "address_family": temp}]}
+    }
+    result = create_router_bgp(tgen, topo, import_dict)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
+
+    step(
+        "Verify on R4, that it installs imported routes from vrf default to "
+        "vrf BLUE RIB/FIB pointing next-hop to vrf default."
+    )
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r4": {
+                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "BLUE"}]
+            }
+        }
+        result = verify_bgp_rib(tgen, addr_type, "r4", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r4", static_routes)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+    for dut, vrf_name, vrf_import, as_num in zip(
+        ["r2", "r4"], ["GREEN", "BLUE"], ["RED", "default"], [2, 4]
+    ):
+
+        for action, value in zip(["Delete", "Re-add"], [True, False]):
+            step("{} the import command on {} router".format(action, dut))
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {"import": {"vrf": vrf_import, "delete": value}}
+                        }
+                    }
+                )
+
+            import_dict = {
+                dut: {
+                    "bgp": [
+                        {"vrf": vrf_name, "local_as": as_num, "address_family": temp}
+                    ]
+                }
+            }
+            result = create_router_bgp(tgen, topo, import_dict)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    "r4": {
+                        "static_routes": [
+                            {"network": [NETWORK2_1[addr_type]], "vrf": "BLUE"}
+                        ]
+                    }
+                }
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, "r4", static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes["r4"]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, "r4", static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                        tc_name,
+                        result,
+                        static_routes["r4"]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, "r4", static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, "r4", static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-2.py frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-2.py
--- frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-2.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-2.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,932 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2021 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Following tests are covered to test BGP Multi-VRF Dynamic Route Leaking:
+1. Verify recursive import among Tenant VRFs.
+2. Verify that dynamic import works fine between two different Tenant VRFs.
+    When next-hop IPs are same across all VRFs.
+    When next-hop IPs are different across all VRFs.
+3. Verify that with multiple tenant VRFs, dynamic import works fine between
+    Tenant VRFs to default VRF.
+    When next-hop IPs and prefixes are same across all VRFs.
+    When next-hop IPs and prefixes are different across all VRFs.
+"""
+
+import os
+import sys
+import time
+import pytest
+import platform
+from time import sleep
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# Required to instantiate the topology builder class.
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    check_address_types,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    create_route_maps,
+    create_static_routes,
+    create_prefix_lists,
+    create_bgp_community_lists,
+    get_frr_ipv6_linklocal,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    create_router_bgp,
+    verify_bgp_community,
+    verify_bgp_rib,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+NETWORK1_1 = {"ipv4": "11.11.11.1/32", "ipv6": "11:11::1/128"}
+NETWORK1_2 = {"ipv4": "11.11.11.11/32", "ipv6": "11:11::11/128"}
+NETWORK1_3 = {"ipv4": "10.10.10.1/32", "ipv6": "10:10::1/128"}
+NETWORK1_4 = {"ipv4": "10.10.10.100/32", "ipv6": "10:10::100/128"}
+NETWORK1_5 = {"ipv4": "110.110.110.1/32", "ipv6": "110:110::1/128"}
+NETWORK1_6 = {"ipv4": "110.110.110.100/32", "ipv6": "110:110::100/128"}
+
+NETWORK2_1 = {"ipv4": "22.22.22.2/32", "ipv6": "22:22::2/128"}
+NETWORK2_2 = {"ipv4": "22.22.22.22/32", "ipv6": "22:22::22/128"}
+NETWORK2_3 = {"ipv4": "20.20.20.20/32", "ipv6": "20:20::20/128"}
+NETWORK2_4 = {"ipv4": "20.20.20.200/32", "ipv6": "20:20::200/128"}
+NETWORK2_5 = {"ipv4": "220.220.220.20/32", "ipv6": "220:220::20/128"}
+NETWORK2_6 = {"ipv4": "220.220.220.200/32", "ipv6": "220:220::200/128"}
+
+NETWORK3_1 = {"ipv4": "30.30.30.3/32", "ipv6": "30:30::3/128"}
+NETWORK3_2 = {"ipv4": "30.30.30.30/32", "ipv6": "30:30::30/128"}
+
+PREFIX_LIST = {
+    "ipv4": ["11.11.11.1", "22.22.22.2", "22.22.22.22"],
+    "ipv6": ["11:11::1", "22:22::2", "22:22::22"],
+}
+PREFERRED_NEXT_HOP = "global"
+VRF_LIST = ["RED", "BLUE", "GREEN"]
+COMM_VAL_1 = "100:100"
+COMM_VAL_2 = "500:500"
+COMM_VAL_3 = "600:600"
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_vrf_dynamic_route_leak_topo4.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Run these tests for kernel version 4.19 or above
+    if version_cmp(platform.release(), "4.19") < 0:
+        error_msg = (
+            "BGP vrf dynamic route leak tests will not run "
+            '(have kernel "{}", but it requires >= 4.19)'.format(platform.release())
+        )
+        pytest.skip(error_msg)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+#####################################################
+#
+#   Testcases
+#
+#####################################################
+
+
+def test_dynamic_import_routes_between_two_tenant_vrf_p0(request):
+    """
+    Verify that dynamic import works fine between two different Tenant VRFs.
+
+    When next-hop IPs are same across all VRFs.
+    When next-hop IPs are different across all VRFs.
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    reset_config_on_routers(tgen)
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step(
+        "Configure static routes on R3 for each vrf and redistribute in "
+        "respective BGP instance"
+    )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step("Configure static route for VRF : {}".format(vrf_name))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r3": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = create_static_routes(tgen, static_routes)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
+            )
+
+        redist_dict = {
+            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step(
+            "Verify that R3 has installed redistributed routes in respective "
+            "vrfs: {}".format(vrf_name)
+        )
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r3": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = verify_rib(tgen, addr_type, "r3", static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    step("Import from vrf GREEN+BLUE into vrf RED on R3")
+
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        import_dict = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify on R1, that it installs all the routes(local+imported) in "
+        "vrf RED's RIB/FIB and doesn't get confuse with next-hop attribute, "
+        "as all vrfs on R1 are using same IP address for next-hop"
+    )
+
+    for addr_type in ADDR_TYPES:
+        static_routes = {
+            "r3": {
+                "static_routes": [
+                    {
+                        "network": [
+                            NETWORK1_1[addr_type],
+                            NETWORK2_1[addr_type],
+                            NETWORK3_1[addr_type],
+                        ],
+                        "next_hop": "blackhole",
+                        "vrf": "RED",
+                    }
+                ]
+            }
+        }
+
+        next_hop_1 = topo["routers"]["r3"]["links"]["r1-link1"][addr_type].split("/")[0]
+        result = verify_bgp_rib(
+            tgen, addr_type, "r1", static_routes, next_hop=next_hop_1
+        )
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+        result = verify_rib(tgen, addr_type, "r1", static_routes, next_hop=next_hop_1)
+        assert result is True, "Testcase {} : Failed \n Error {}".format(
+            tc_name, result
+        )
+
+    step("Remove import vrf GREEN/BLUE/Both command from vrf RED's instance on" " R3")
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
+            )
+
+        import_dict = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that R1,R2 & R3 withdraw imported routes from vrf RED's RIB")
+    for dut in ["r1", "r2", "r3"]:
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in BGP table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in Route table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+    step("Add import vrf GREEN/BLUE/Both command from vrf RED's instance on " "R3")
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        import_dict = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    for action, value in zip(["Shut", "No shut"], [True, False]):
+        step(
+            "{} the neighborship between R1-R3 and R1-R2 for vrf GREEN, BLUE "
+            "and default".format(action)
+        )
+        bgp_disable = {"r3": {"bgp": []}}
+        for vrf_name in ["GREEN", "BLUE", "default"]:
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r1": {
+                                        "dest_link": {"r3-link1": {"shutdown": value}}
+                                    },
+                                    "r2": {
+                                        "dest_link": {"r3-link1": {"shutdown": value}}
+                                    },
+                                }
+                            }
+                        }
+                    }
+                )
+
+            bgp_disable["r3"]["bgp"].append(
+                {"vrf": vrf_name, "local_as": 3, "address_family": temp}
+            )
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
+        for dut in ["r1", "r2", "r3"]:
+            step("Verify RIB/FIB for vrf RED on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                                "vrf": "RED",
+                            }
+                        ]
+                    }
+                }
+                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+                result = verify_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+    for action, value, status in zip(
+        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
+    ):
+        step("{} the neighborship between R1-R3 and R1-R2 for vrf RED".format(action))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r3-link1": {"shutdown": value}}},
+                                "r2": {"dest_link": {"r3-link1": {"shutdown": value}}},
+                            }
+                        }
+                    }
+                }
+            )
+
+        bgp_disable = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step(
+            "Verify that R1 and R2 {} all the routes from RED vrf's RIB and"
+            " FIB".format(status)
+        )
+        for dut in ["r1", "r2"]:
+            step("Verify RIB/FIB for vrf RED on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                                "vrf": "RED",
+                            }
+                        ]
+                    }
+                }
+
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in Route table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    step("Remove import command from router R3 and configure the same on R2")
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
+            )
+
+        import_dict = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that once import commands are removed from R3, all imported "
+        "routes are withdrawn from RIB/FIB of vrf RED on R1/R2/R3"
+    )
+
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify RIB/FIB for vrf RED on {}".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in BGP table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert (
+                result is not True
+            ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+            )
+
+    step(
+        "Configure static routes on R2 for each vrf and redistribute in "
+        "respective BGP instance"
+    )
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step("Configure static route for VRF : {}".format(vrf_name))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r2": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = create_static_routes(tgen, static_routes)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
+            )
+
+        redist_dict = {
+            "r2": {"bgp": [{"vrf": vrf_name, "local_as": 2, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Remove redistribute static route on BGP VRF : {} on r3".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "redistribute": [{"redist_type": "static", "delete": True}]
+                        }
+                    }
+                }
+            )
+
+        redist_dict = {
+            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        import_dict = {
+            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify after import commands are re-configured on R2's vrf RED, all "
+        "those routes are installed again in vrf RED of R1,R2,R3"
+    )
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify RIB/FIB for vrf RED on {}".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [
+                                NETWORK1_1[addr_type],
+                                NETWORK2_1[addr_type],
+                                NETWORK3_1[addr_type],
+                            ],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    step(
+        "Remove/add import vrf GREEN/BLUE/both command from vrf RED's " "instance on R2"
+    )
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
+            )
+
+        redist_dict = {
+            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that R1,R2 & R3 withdraw imported routes from vrf RED's RIB")
+    for dut in ["r1", "r2", "r3"]:
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in BGP table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert (
+                result is not True
+            ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+            )
+
+    step("Add import vrf GREEN/BLUE/Both command from vrf RED's instance on " "R2")
+    for vrf_name in ["BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        redist_dict = {
+            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": "RED",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    for action, value in zip(["Shut", "No shut"], [True, False]):
+        step(
+            "{} the neighborship between R2-R3 for vrf GREEN, BLUE and default".format(
+                action
+            )
+        )
+        bgp_disable = {"r2": {"bgp": []}}
+        for vrf_name in ["GREEN", "BLUE", "default"]:
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r2-link1": {"shutdown": value}}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                )
+
+            bgp_disable["r2"]["bgp"].append(
+                {"vrf": vrf_name, "local_as": 2, "address_family": temp}
+            )
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
+        for dut in ["r1", "r2", "r3"]:
+            step("Verify RIB/FIB for vrf RED on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                                "vrf": "RED",
+                            }
+                        ]
+                    }
+                }
+                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+                result = verify_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+    for action, value, status in zip(
+        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
+    ):
+        step("{} the neighborship between R2-R3 for vrf RED".format(action))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "neighbor": {
+                                "r2": {"dest_link": {"r3-link1": {"shutdown": value}}}
+                            }
+                        }
+                    }
+                }
+            )
+
+        bgp_disable = {
+            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
+        }
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step(
+            "Verify that R1 and R2 {} all the routes from RED vrf's RIB and"
+            " FIB".format(status)
+        )
+        for dut in ["r1", "r3"]:
+            step("Verify RIB/FIB for vrf RED on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                                "vrf": "RED",
+                            }
+                        ]
+                    }
+                }
+
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-3.py frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-3.py
--- frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-3.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4-3.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,932 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2021 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Following tests are covered to test BGP Multi-VRF Dynamic Route Leaking:
+1. Verify recursive import among Tenant VRFs.
+2. Verify that dynamic import works fine between two different Tenant VRFs.
+    When next-hop IPs are same across all VRFs.
+    When next-hop IPs are different across all VRFs.
+3. Verify that with multiple tenant VRFs, dynamic import works fine between
+    Tenant VRFs to default VRF.
+    When next-hop IPs and prefixes are same across all VRFs.
+    When next-hop IPs and prefixes are different across all VRFs.
+"""
+
+import os
+import sys
+import time
+import pytest
+import platform
+from time import sleep
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# Required to instantiate the topology builder class.
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+from lib.topotest import version_cmp
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    check_address_types,
+    write_test_footer,
+    reset_config_on_routers,
+    verify_rib,
+    step,
+    create_route_maps,
+    create_static_routes,
+    create_prefix_lists,
+    create_bgp_community_lists,
+    get_frr_ipv6_linklocal,
+)
+
+from lib.topolog import logger
+from lib.bgp import (
+    verify_bgp_convergence,
+    create_router_bgp,
+    verify_bgp_community,
+    verify_bgp_rib,
+)
+from lib.topojson import build_config_from_json
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
+
+# Global variables
+NETWORK1_1 = {"ipv4": "11.11.11.1/32", "ipv6": "11:11::1/128"}
+NETWORK1_2 = {"ipv4": "11.11.11.11/32", "ipv6": "11:11::11/128"}
+NETWORK1_3 = {"ipv4": "10.10.10.1/32", "ipv6": "10:10::1/128"}
+NETWORK1_4 = {"ipv4": "10.10.10.100/32", "ipv6": "10:10::100/128"}
+NETWORK1_5 = {"ipv4": "110.110.110.1/32", "ipv6": "110:110::1/128"}
+NETWORK1_6 = {"ipv4": "110.110.110.100/32", "ipv6": "110:110::100/128"}
+
+NETWORK2_1 = {"ipv4": "22.22.22.2/32", "ipv6": "22:22::2/128"}
+NETWORK2_2 = {"ipv4": "22.22.22.22/32", "ipv6": "22:22::22/128"}
+NETWORK2_3 = {"ipv4": "20.20.20.20/32", "ipv6": "20:20::20/128"}
+NETWORK2_4 = {"ipv4": "20.20.20.200/32", "ipv6": "20:20::200/128"}
+NETWORK2_5 = {"ipv4": "220.220.220.20/32", "ipv6": "220:220::20/128"}
+NETWORK2_6 = {"ipv4": "220.220.220.200/32", "ipv6": "220:220::200/128"}
+
+NETWORK3_1 = {"ipv4": "30.30.30.3/32", "ipv6": "30:30::3/128"}
+NETWORK3_2 = {"ipv4": "30.30.30.30/32", "ipv6": "30:30::30/128"}
+
+PREFIX_LIST = {
+    "ipv4": ["11.11.11.1", "22.22.22.2", "22.22.22.22"],
+    "ipv6": ["11:11::1", "22:22::2", "22:22::22"],
+}
+PREFERRED_NEXT_HOP = "global"
+VRF_LIST = ["RED", "BLUE", "GREEN"]
+COMM_VAL_1 = "100:100"
+COMM_VAL_2 = "500:500"
+COMM_VAL_3 = "600:600"
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: {}".format(testsuite_run_time))
+    logger.info("=" * 40)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/bgp_vrf_dynamic_route_leak_topo4.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global topo
+    topo = tgen.json_topo
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Run these tests for kernel version 4.19 or above
+    if version_cmp(platform.release(), "4.19") < 0:
+        error_msg = (
+            "BGP vrf dynamic route leak tests will not run "
+            '(have kernel "{}", but it requires >= 4.19)'.format(platform.release())
+        )
+        pytest.skip(error_msg)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, topo)
+
+    global BGP_CONVERGENCE
+    global ADDR_TYPES
+    ADDR_TYPES = check_address_types()
+
+    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
+    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
+        BGP_CONVERGENCE
+    )
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info(
+        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
+    )
+    logger.info("=" * 40)
+
+
+#####################################################
+#
+#   Testcases
+#
+#####################################################
+
+
+def test_dynamic_import_routes_between_tenant_to_default_vrf_p0(request):
+    """
+    Verify that with multiple tenant VRFs, dynamic import works fine between
+    Tenant VRFs to default VRF.
+
+    When next-hop IPs and prefixes are same across all VRFs.
+    When next-hop IPs and prefixes are different across all VRFs.
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    reset_config_on_routers(tgen)
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step(
+        "Configure static routes on R3 for each vrf and redistribute in "
+        "respective BGP instance"
+    )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step("Configure static route for VRF : {}".format(vrf_name))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r3": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = create_static_routes(tgen, static_routes)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
+            )
+
+        redist_dict = {
+            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step(
+            "Verify that R3 has installed redistributed routes in respective "
+            "vrfs: {}".format(vrf_name)
+        )
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r3": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = verify_rib(tgen, addr_type, "r3", static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    step("Import all tenant vrfs(GREEN+BLUE+RED) in default vrf on R3")
+
+    for vrf_name in ["RED", "BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        redist_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify on R3 that it installs all the routes(imported from tenant "
+        "VRFs) in default vrf. Additionally, verify that R1 & R2 also "
+        "receive these routes from R3 and install in default vrf, next-hop "
+        "pointing to R3"
+    )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r3": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                        }
+                    ]
+                }
+            }
+
+            for dut in ["r2", "r1"]:
+                next_hop_val = topo["routers"]["r3"]["links"]["{}-link4".format(dut)][
+                    addr_type
+                ].split("/")[0]
+
+                result = verify_bgp_rib(
+                    tgen, addr_type, dut, static_routes, next_hop=next_hop_val
+                )
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+                result = verify_rib(
+                    tgen, addr_type, dut, static_routes, next_hop=next_hop_val
+                )
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+            result = verify_bgp_rib(tgen, addr_type, "r3", static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, "r3", static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    for action, value, status in zip(
+        ["Remove", "Add"], [True, False], ["withdraw", "re-install"]
+    ):
+        step(
+            "{} import vrf GREEN/BLUE/RED/all command from default vrf "
+            "instance on R3".format(action)
+        )
+        for vrf_name in ["RED", "BLUE", "GREEN"]:
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {"import": {"vrf": vrf_name, "delete": value}}
+                        }
+                    }
+                )
+
+            import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
+
+            result = create_router_bgp(tgen, topo, import_dict)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        step(
+            "Verify that R1,R2 & R3 {} imported routes from GREEN/BLUE/RED/all"
+            " in default vrf's RIB".format(status)
+        )
+        for dut in ["r1", "r2", "r3"]:
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK1_1[addr_type],
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                            }
+                        ]
+                    }
+                }
+
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    for action, value in zip(["Shut", "No shut"], [True, False]):
+        step(
+            "{} the neighborship between R1-R3 and R1-R2 for vrf RED, GREEN "
+            "and BLUE".format(action)
+        )
+        bgp_disable = {"r3": {"bgp": []}}
+        for vrf_name in ["RED", "GREEN", "BLUE"]:
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r1": {
+                                        "dest_link": {"r3-link4": {"shutdown": value}}
+                                    },
+                                    "r2": {
+                                        "dest_link": {"r3-link4": {"shutdown": value}}
+                                    },
+                                }
+                            }
+                        }
+                    }
+                )
+
+            bgp_disable["r3"]["bgp"].append(
+                {"vrf": vrf_name, "local_as": 3, "address_family": temp}
+            )
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step(
+            "Verify that when peering is shutdown for tenant vrfs, it "
+            "doesn't impact the RIB/FIB of default vrf on router R1 and R2"
+        )
+        for dut in ["r1", "r2"]:
+            step("Verify RIB/FIB for default vrf on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK1_1[addr_type],
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                            }
+                        ]
+                    }
+                }
+                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+                result = verify_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+    for action, value, status in zip(
+        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
+    ):
+        step(
+            "{} the neighborship between R1-R3 and R2-R3 for default vrf".format(action)
+        )
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "neighbor": {
+                                "r1": {"dest_link": {"r3-link4": {"shutdown": value}}},
+                                "r2": {"dest_link": {"r3-link4": {"shutdown": value}}},
+                            }
+                        }
+                    }
+                }
+            )
+
+        bgp_disable = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step(
+            "Verify that R1 and R2 {} all the routes from default vrf's RIB"
+            " and FIB".format(status)
+        )
+        for dut in ["r1", "r2"]:
+            step("Verify RIB/FIB for default vrf on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK1_1[addr_type],
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                            }
+                        ]
+                    }
+                }
+
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    step("Remove import command from router R3 and configure the same on R2")
+    temp = {}
+    for vrf_name in VRF_LIST:
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
+            )
+
+        import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that once import commands are removed from R3, all imported "
+        "routes are withdrawn from RIB/FIB of default vrf on R1/R2/R3"
+    )
+
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify RIB/FIB for default vrf on {}".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [
+                                NETWORK1_1[addr_type],
+                                NETWORK2_1[addr_type],
+                                NETWORK3_1[addr_type],
+                            ],
+                            "next_hop": "blackhole",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in BGP table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
+        step("Configure static route for VRF : {} on r2".format(vrf_name))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                "r2": {
+                    "static_routes": [
+                        {
+                            "network": [network[addr_type]],
+                            "next_hop": "blackhole",
+                            "vrf": vrf_name,
+                        }
+                    ]
+                }
+            }
+
+            result = create_static_routes(tgen, static_routes)
+            assert result is True, "Testcase {} :Failed \n Error: {}".format(
+                tc_name, result
+            )
+
+        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
+            )
+
+        redist_dict = {
+            "r2": {"bgp": [{"vrf": vrf_name, "local_as": 2, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Remove redistribute static route on BGP VRF : {} on r3".format(vrf_name))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "redistribute": [{"redist_type": "static", "delete": True}]
+                        }
+                    }
+                }
+            )
+
+        redist_dict = {
+            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
+        }
+
+        result = create_router_bgp(tgen, topo, redist_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for vrf_name in ["RED", "BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify after import commands are re-configured on R2's vrf RED, all "
+        "those routes are installed again in default vrf of R1,R2,R3"
+    )
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify RIB/FIB for vrf RED on {}".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [
+                                NETWORK1_1[addr_type],
+                                NETWORK2_1[addr_type],
+                                NETWORK3_1[addr_type],
+                            ],
+                            "next_hop": "blackhole",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    step("Remove import vrf RED/GREEN/BLUE/all one by one from default vrf" " on R2")
+    for vrf_name in ["RED", "BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
+            )
+
+        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step(
+        "Verify that R1, R2 and R3 withdraws imported routes from default "
+        "vrf's RIB and FIB "
+    )
+    for dut in ["r1", "r2", "r3"]:
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [
+                                NETWORK1_1[addr_type],
+                                NETWORK2_1[addr_type],
+                                NETWORK3_1[addr_type],
+                            ],
+                            "next_hop": "blackhole",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, (
+                "Testcase {} : Failed \nError {}\n"
+                "Routes {} still in BGP table".format(
+                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
+                )
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
+            assert result is not True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    step("Add import vrf RED/GREEN/BLUE/all one by one from default vrf on R2")
+    for vrf_name in ["RED", "BLUE", "GREEN"]:
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
+
+        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
+
+        result = create_router_bgp(tgen, topo, import_dict)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    for dut in ["r1", "r2", "r3"]:
+        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
+        for addr_type in ADDR_TYPES:
+            static_routes = {
+                dut: {
+                    "static_routes": [
+                        {
+                            "network": [
+                                NETWORK1_1[addr_type],
+                                NETWORK2_1[addr_type],
+                                NETWORK3_1[addr_type],
+                            ],
+                            "next_hop": "blackhole",
+                        }
+                    ]
+                }
+            }
+            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+            result = verify_rib(tgen, addr_type, dut, static_routes)
+            assert result is True, "Testcase {} : Failed \n Error {}".format(
+                tc_name, result
+            )
+
+    for action, value in zip(["Shut", "No shut"], [True, False]):
+        step(
+            "{} the neighborship between R2-R3 for vrf GREEN, BLUE and RED".format(
+                action
+            )
+        )
+        bgp_disable = {"r2": {"bgp": []}}
+        for vrf_name in ["GREEN", "BLUE", "RED"]:
+            temp = {}
+            for addr_type in ADDR_TYPES:
+                temp.update(
+                    {
+                        addr_type: {
+                            "unicast": {
+                                "neighbor": {
+                                    "r3": {
+                                        "dest_link": {"r2-link4": {"shutdown": value}}
+                                    }
+                                }
+                            }
+                        }
+                    }
+                )
+
+            bgp_disable["r2"]["bgp"].append(
+                {"vrf": vrf_name, "local_as": 2, "address_family": temp}
+            )
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
+        for dut in ["r1", "r2", "r3"]:
+            step("Verify RIB/FIB for vrf RED on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK1_1[addr_type],
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                            }
+                        ]
+                    }
+                }
+
+                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+                result = verify_rib(tgen, addr_type, dut, static_routes)
+                assert result is True, "Testcase {} : Failed \n Error {}".format(
+                    tc_name, result
+                )
+
+    for action, value, status in zip(
+        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
+    ):
+        step("{} the neighborship between R2-R3 for default vrf".format(action))
+        temp = {}
+        for addr_type in ADDR_TYPES:
+            temp.update(
+                {
+                    addr_type: {
+                        "unicast": {
+                            "neighbor": {
+                                "r3": {"dest_link": {"r2-link4": {"shutdown": value}}}
+                            }
+                        }
+                    }
+                }
+            )
+
+        bgp_disable = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
+        result = create_router_bgp(tgen, topo, bgp_disable)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+        step(
+            "Verify that R1 and R2 {} all the routes from default vrfs RIB and"
+            " FIB".format(status)
+        )
+        for dut in ["r1", "r3"]:
+            step("Verify RIB/FIB for default vrf on {}".format(dut))
+            for addr_type in ADDR_TYPES:
+                static_routes = {
+                    dut: {
+                        "static_routes": [
+                            {
+                                "network": [
+                                    NETWORK1_1[addr_type],
+                                    NETWORK2_1[addr_type],
+                                    NETWORK3_1[addr_type],
+                                ],
+                                "next_hop": "blackhole",
+                            }
+                        ]
+                    }
+                }
+
+                if value:
+                    result = verify_bgp_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+
+                    result = verify_rib(
+                        tgen, addr_type, dut, static_routes, expected=False
+                    )
+                    assert (
+                        result is not True
+                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
+                        tc_name,
+                        result,
+                        static_routes[dut]["static_routes"][0]["network"],
+                    )
+                else:
+                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+                    result = verify_rib(tgen, addr_type, dut, static_routes)
+                    assert result is True, "Testcase {} : Failed \n Error {}".format(
+                        tc_name, result
+                    )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4.py frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4.py
--- frr-frr-8.4.2/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/bgp_vrf_dynamic_route_leak_topo4/test_bgp_vrf_dynamic_route_leak_topo4.py	1970-01-01 06:00:00.000000000 +0600
@@ -1,1909 +0,0 @@
-#!/usr/bin/env python
-
-#
-# Copyright (c) 2021 by VMware, Inc. ("VMware")
-# Used Copyright (c) 2018 by Network Device Education Foundation,
-# Inc. ("NetDEF") in this file.
-#
-# Permission to use, copy, modify, and/or distribute this software
-# for any purpose with or without fee is hereby granted, provided
-# that the above copyright notice and this permission notice appear
-# in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
-# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
-# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
-# OF THIS SOFTWARE.
-#
-
-"""
-Following tests are covered to test BGP Multi-VRF Dynamic Route Leaking:
-1. Verify recursive import among Tenant VRFs.
-2. Verify that dynamic import works fine between two different Tenant VRFs.
-    When next-hop IPs are same across all VRFs.
-    When next-hop IPs are different across all VRFs.
-3. Verify that with multiple tenant VRFs, dynamic import works fine between
-    Tenant VRFs to default VRF.
-    When next-hop IPs and prefixes are same across all VRFs.
-    When next-hop IPs and prefixes are different across all VRFs.
-"""
-
-import os
-import sys
-import time
-import pytest
-import platform
-from time import sleep
-
-# Save the Current Working Directory to find configuration files.
-CWD = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(CWD, "../"))
-sys.path.append(os.path.join(CWD, "../lib/"))
-
-# Required to instantiate the topology builder class.
-
-# pylint: disable=C0413
-# Import topogen and topotest helpers
-from lib.topogen import Topogen, get_topogen
-from lib.topotest import version_cmp
-
-from lib.common_config import (
-    start_topology,
-    write_test_header,
-    check_address_types,
-    write_test_footer,
-    reset_config_on_routers,
-    verify_rib,
-    step,
-    create_route_maps,
-    create_static_routes,
-    create_prefix_lists,
-    create_bgp_community_lists,
-    get_frr_ipv6_linklocal,
-)
-
-from lib.topolog import logger
-from lib.bgp import (
-    verify_bgp_convergence,
-    create_router_bgp,
-    verify_bgp_community,
-    verify_bgp_rib,
-)
-from lib.topojson import build_config_from_json
-
-pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
-
-# Global variables
-NETWORK1_1 = {"ipv4": "11.11.11.1/32", "ipv6": "11:11::1/128"}
-NETWORK1_2 = {"ipv4": "11.11.11.11/32", "ipv6": "11:11::11/128"}
-NETWORK1_3 = {"ipv4": "10.10.10.1/32", "ipv6": "10:10::1/128"}
-NETWORK1_4 = {"ipv4": "10.10.10.100/32", "ipv6": "10:10::100/128"}
-NETWORK1_5 = {"ipv4": "110.110.110.1/32", "ipv6": "110:110::1/128"}
-NETWORK1_6 = {"ipv4": "110.110.110.100/32", "ipv6": "110:110::100/128"}
-
-NETWORK2_1 = {"ipv4": "22.22.22.2/32", "ipv6": "22:22::2/128"}
-NETWORK2_2 = {"ipv4": "22.22.22.22/32", "ipv6": "22:22::22/128"}
-NETWORK2_3 = {"ipv4": "20.20.20.20/32", "ipv6": "20:20::20/128"}
-NETWORK2_4 = {"ipv4": "20.20.20.200/32", "ipv6": "20:20::200/128"}
-NETWORK2_5 = {"ipv4": "220.220.220.20/32", "ipv6": "220:220::20/128"}
-NETWORK2_6 = {"ipv4": "220.220.220.200/32", "ipv6": "220:220::200/128"}
-
-NETWORK3_1 = {"ipv4": "30.30.30.3/32", "ipv6": "30:30::3/128"}
-NETWORK3_2 = {"ipv4": "30.30.30.30/32", "ipv6": "30:30::30/128"}
-
-PREFIX_LIST = {
-    "ipv4": ["11.11.11.1", "22.22.22.2", "22.22.22.22"],
-    "ipv6": ["11:11::1", "22:22::2", "22:22::22"],
-}
-PREFERRED_NEXT_HOP = "global"
-VRF_LIST = ["RED", "BLUE", "GREEN"]
-COMM_VAL_1 = "100:100"
-COMM_VAL_2 = "500:500"
-COMM_VAL_3 = "600:600"
-
-
-def setup_module(mod):
-    """
-    Sets up the pytest environment
-
-    * `mod`: module name
-    """
-
-    testsuite_run_time = time.asctime(time.localtime(time.time()))
-    logger.info("Testsuite start time: {}".format(testsuite_run_time))
-    logger.info("=" * 40)
-
-    logger.info("Running setup_module to create topology")
-
-    # This function initiates the topology build with Topogen...
-    json_file = "{}/bgp_vrf_dynamic_route_leak_topo4.json".format(CWD)
-    tgen = Topogen(json_file, mod.__name__)
-    global topo
-    topo = tgen.json_topo
-    # ... and here it calls Mininet initialization functions.
-
-    # Starting topology, create tmp files which are loaded to routers
-    #  to start daemons and then start routers
-    start_topology(tgen)
-
-    # Run these tests for kernel version 4.19 or above
-    if version_cmp(platform.release(), "4.19") < 0:
-        error_msg = (
-            "BGP vrf dynamic route leak tests will not run "
-            '(have kernel "{}", but it requires >= 4.19)'.format(platform.release())
-        )
-        pytest.skip(error_msg)
-
-    # Creating configuration from JSON
-    build_config_from_json(tgen, topo)
-
-    global BGP_CONVERGENCE
-    global ADDR_TYPES
-    ADDR_TYPES = check_address_types()
-
-    BGP_CONVERGENCE = verify_bgp_convergence(tgen, topo)
-    assert BGP_CONVERGENCE is True, "setup_module : Failed \n Error: {}".format(
-        BGP_CONVERGENCE
-    )
-
-    logger.info("Running setup_module() done")
-
-
-def teardown_module():
-    """Teardown the pytest environment"""
-
-    logger.info("Running teardown_module to delete topology")
-
-    tgen = get_topogen()
-
-    # Stop toplogy and Remove tmp files
-    tgen.stop_topology()
-
-    logger.info(
-        "Testsuite end time: {}".format(time.asctime(time.localtime(time.time())))
-    )
-    logger.info("=" * 40)
-
-
-#####################################################
-#
-#   Testcases
-#
-#####################################################
-
-
-def test_dynamic_import_recursive_import_tenant_vrf_p1(request):
-    """
-    Verify recursive import among Tenant VRFs.
-    """
-
-    tgen = get_topogen()
-    tc_name = request.node.name
-    write_test_header(tc_name)
-    reset_config_on_routers(tgen)
-    if tgen.routers_have_failure():
-        pytest.skip(tgen.errors)
-
-    step(
-        "Configure static routes on R2 for vrf RED and redistribute in "
-        "respective BGP instance"
-    )
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r2": {
-                "static_routes": [
-                    {
-                        "network": [NETWORK2_1[addr_type]],
-                        "next_hop": "blackhole",
-                        "vrf": "RED",
-                    }
-                ]
-            }
-        }
-
-        result = create_static_routes(tgen, static_routes)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step("Redistribute static route on BGP VRF RED")
-    temp = {}
-    for addr_type in ADDR_TYPES:
-        temp.update(
-            {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
-        )
-
-    redist_dict = {
-        "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
-    }
-
-    result = create_router_bgp(tgen, topo, redist_dict)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("Verify that R2 has installed redistributed routes in vrf RED only")
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r2": {
-                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "RED"}]
-            }
-        }
-        result = verify_bgp_rib(tgen, addr_type, "r2", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-        result = verify_rib(tgen, addr_type, "r2", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-    step("Import vrf RED's routes into vrf GREEN on R2")
-    temp = {}
-    for addr_type in ADDR_TYPES:
-        temp.update({addr_type: {"unicast": {"import": {"vrf": "RED"}}}})
-
-    import_dict = {
-        "r2": {"bgp": [{"vrf": "GREEN", "local_as": 2, "address_family": temp}]}
-    }
-    result = create_router_bgp(tgen, topo, import_dict)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step(
-        "Verify on R2, that it installs imported routes from vrf RED to vrf "
-        "GREEN's RIB/FIB pointing next-hop to vrf RED"
-    )
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r2": {
-                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "GREEN"}]
-            }
-        }
-        result = verify_bgp_rib(tgen, addr_type, "r2", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-        result = verify_rib(tgen, addr_type, "r2", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-    step("On R3 import routes from vrf GREEN to vrf default")
-    temp = {}
-    for addr_type in ADDR_TYPES:
-        temp.update({addr_type: {"unicast": {"import": {"vrf": "GREEN"}}}})
-
-    import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
-    result = create_router_bgp(tgen, topo, import_dict)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step(
-        "Verify on R3, that it installs imported routes from vrf GREEN to "
-        "vrf default RIB/FIB pointing next-hop to vrf GREEN. "
-    )
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r2": {"static_routes": [{"network": [NETWORK2_1[addr_type]]}]}
-        }
-        result = verify_bgp_rib(tgen, addr_type, "r3", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-        result = verify_rib(tgen, addr_type, "r3", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-    step("On R4 import routes from vrf default to vrf BLUE")
-    temp = {}
-    for addr_type in ADDR_TYPES:
-        temp.update({addr_type: {"unicast": {"import": {"vrf": "default"}}}})
-
-    import_dict = {
-        "r4": {"bgp": [{"vrf": "BLUE", "local_as": 4, "address_family": temp}]}
-    }
-    result = create_router_bgp(tgen, topo, import_dict)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step(
-        "Verify on R4, that it installs imported routes from vrf default to "
-        "vrf BLUE RIB/FIB pointing next-hop to vrf default."
-    )
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r4": {
-                "static_routes": [{"network": [NETWORK2_1[addr_type]], "vrf": "BLUE"}]
-            }
-        }
-        result = verify_bgp_rib(tgen, addr_type, "r4", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-        result = verify_rib(tgen, addr_type, "r4", static_routes)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-    for dut, vrf_name, vrf_import, as_num in zip(
-        ["r2", "r4"], ["GREEN", "BLUE"], ["RED", "default"], [2, 4]
-    ):
-
-        for action, value in zip(["Delete", "Re-add"], [True, False]):
-            step("{} the import command on {} router".format(action, dut))
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {"import": {"vrf": vrf_import, "delete": value}}
-                        }
-                    }
-                )
-
-            import_dict = {
-                dut: {
-                    "bgp": [
-                        {"vrf": vrf_name, "local_as": as_num, "address_family": temp}
-                    ]
-                }
-            }
-            result = create_router_bgp(tgen, topo, import_dict)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    "r4": {
-                        "static_routes": [
-                            {"network": [NETWORK2_1[addr_type]], "vrf": "BLUE"}
-                        ]
-                    }
-                }
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, "r4", static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes["r4"]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, "r4", static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                        tc_name,
-                        result,
-                        static_routes["r4"]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, "r4", static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, "r4", static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    write_test_footer(tc_name)
-
-
-def test_dynamic_import_routes_between_two_tenant_vrf_p0(request):
-    """
-    Verify that dynamic import works fine between two different Tenant VRFs.
-
-    When next-hop IPs are same across all VRFs.
-    When next-hop IPs are different across all VRFs.
-    """
-
-    tgen = get_topogen()
-    tc_name = request.node.name
-    write_test_header(tc_name)
-    reset_config_on_routers(tgen)
-    if tgen.routers_have_failure():
-        pytest.skip(tgen.errors)
-
-    step(
-        "Configure static routes on R3 for each vrf and redistribute in "
-        "respective BGP instance"
-    )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step("Configure static route for VRF : {}".format(vrf_name))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r3": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = create_static_routes(tgen, static_routes)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
-            )
-
-        redist_dict = {
-            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step(
-            "Verify that R3 has installed redistributed routes in respective "
-            "vrfs: {}".format(vrf_name)
-        )
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r3": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = verify_rib(tgen, addr_type, "r3", static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    step("Import from vrf GREEN+BLUE into vrf RED on R3")
-
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        import_dict = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify on R1, that it installs all the routes(local+imported) in "
-        "vrf RED's RIB/FIB and doesn't get confuse with next-hop attribute, "
-        "as all vrfs on R1 are using same IP address for next-hop"
-    )
-
-    for addr_type in ADDR_TYPES:
-        static_routes = {
-            "r3": {
-                "static_routes": [
-                    {
-                        "network": [
-                            NETWORK1_1[addr_type],
-                            NETWORK2_1[addr_type],
-                            NETWORK3_1[addr_type],
-                        ],
-                        "next_hop": "blackhole",
-                        "vrf": "RED",
-                    }
-                ]
-            }
-        }
-
-        next_hop_1 = topo["routers"]["r3"]["links"]["r1-link1"][addr_type].split("/")[0]
-        result = verify_bgp_rib(
-            tgen, addr_type, "r1", static_routes, next_hop=next_hop_1
-        )
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-        result = verify_rib(tgen, addr_type, "r1", static_routes, next_hop=next_hop_1)
-        assert result is True, "Testcase {} : Failed \n Error {}".format(
-            tc_name, result
-        )
-
-    step("Remove import vrf GREEN/BLUE/Both command from vrf RED's instance on" " R3")
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
-            )
-
-        import_dict = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step("Verify that R1,R2 & R3 withdraw imported routes from vrf RED's RIB")
-    for dut in ["r1", "r2", "r3"]:
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in BGP table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in Route table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-    step("Add import vrf GREEN/BLUE/Both command from vrf RED's instance on " "R3")
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        import_dict = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    for action, value in zip(["Shut", "No shut"], [True, False]):
-        step(
-            "{} the neighborship between R1-R3 and R1-R2 for vrf GREEN, BLUE "
-            "and default".format(action)
-        )
-        bgp_disable = {"r3": {"bgp": []}}
-        for vrf_name in ["GREEN", "BLUE", "default"]:
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {
-                                "neighbor": {
-                                    "r1": {
-                                        "dest_link": {"r3-link1": {"shutdown": value}}
-                                    },
-                                    "r2": {
-                                        "dest_link": {"r3-link1": {"shutdown": value}}
-                                    },
-                                }
-                            }
-                        }
-                    }
-                )
-
-            bgp_disable["r3"]["bgp"].append(
-                {"vrf": vrf_name, "local_as": 3, "address_family": temp}
-            )
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
-        for dut in ["r1", "r2", "r3"]:
-            step("Verify RIB/FIB for vrf RED on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                                "vrf": "RED",
-                            }
-                        ]
-                    }
-                }
-                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-                result = verify_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-    for action, value, status in zip(
-        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
-    ):
-        step("{} the neighborship between R1-R3 and R1-R2 for vrf RED".format(action))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "neighbor": {
-                                "r1": {"dest_link": {"r3-link1": {"shutdown": value}}},
-                                "r2": {"dest_link": {"r3-link1": {"shutdown": value}}},
-                            }
-                        }
-                    }
-                }
-            )
-
-        bgp_disable = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step(
-            "Verify that R1 and R2 {} all the routes from RED vrf's RIB and"
-            " FIB".format(status)
-        )
-        for dut in ["r1", "r2"]:
-            step("Verify RIB/FIB for vrf RED on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                                "vrf": "RED",
-                            }
-                        ]
-                    }
-                }
-
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in Route table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    step("Remove import command from router R3 and configure the same on R2")
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
-            )
-
-        import_dict = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify that once import commands are removed from R3, all imported "
-        "routes are withdrawn from RIB/FIB of vrf RED on R1/R2/R3"
-    )
-
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify RIB/FIB for vrf RED on {}".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in BGP table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert (
-                result is not True
-            ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-            )
-
-    step(
-        "Configure static routes on R2 for each vrf and redistribute in "
-        "respective BGP instance"
-    )
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step("Configure static route for VRF : {}".format(vrf_name))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r2": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = create_static_routes(tgen, static_routes)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
-            )
-
-        redist_dict = {
-            "r2": {"bgp": [{"vrf": vrf_name, "local_as": 2, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step("Remove redistribute static route on BGP VRF : {} on r3".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "redistribute": [{"redist_type": "static", "delete": True}]
-                        }
-                    }
-                }
-            )
-
-        redist_dict = {
-            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        import_dict = {
-            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify after import commands are re-configured on R2's vrf RED, all "
-        "those routes are installed again in vrf RED of R1,R2,R3"
-    )
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify RIB/FIB for vrf RED on {}".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [
-                                NETWORK1_1[addr_type],
-                                NETWORK2_1[addr_type],
-                                NETWORK3_1[addr_type],
-                            ],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    step(
-        "Remove/add import vrf GREEN/BLUE/both command from vrf RED's " "instance on R2"
-    )
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
-            )
-
-        redist_dict = {
-            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step("Verify that R1,R2 & R3 withdraw imported routes from vrf RED's RIB")
-    for dut in ["r1", "r2", "r3"]:
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in BGP table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert (
-                result is not True
-            ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-            )
-
-    step("Add import vrf GREEN/BLUE/Both command from vrf RED's instance on " "R2")
-    for vrf_name in ["BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        redist_dict = {
-            "r2": {"bgp": [{"vrf": "RED", "local_as": 2, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [NETWORK2_1[addr_type], NETWORK3_1[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": "RED",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    for action, value in zip(["Shut", "No shut"], [True, False]):
-        step(
-            "{} the neighborship between R2-R3 for vrf GREEN, BLUE and default".format(
-                action
-            )
-        )
-        bgp_disable = {"r2": {"bgp": []}}
-        for vrf_name in ["GREEN", "BLUE", "default"]:
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {
-                                "neighbor": {
-                                    "r3": {
-                                        "dest_link": {"r2-link1": {"shutdown": value}}
-                                    }
-                                }
-                            }
-                        }
-                    }
-                )
-
-            bgp_disable["r2"]["bgp"].append(
-                {"vrf": vrf_name, "local_as": 2, "address_family": temp}
-            )
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
-        for dut in ["r1", "r2", "r3"]:
-            step("Verify RIB/FIB for vrf RED on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                                "vrf": "RED",
-                            }
-                        ]
-                    }
-                }
-                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-                result = verify_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-    for action, value, status in zip(
-        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
-    ):
-        step("{} the neighborship between R2-R3 for vrf RED".format(action))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "neighbor": {
-                                "r2": {"dest_link": {"r3-link1": {"shutdown": value}}}
-                            }
-                        }
-                    }
-                }
-            )
-
-        bgp_disable = {
-            "r3": {"bgp": [{"vrf": "RED", "local_as": 3, "address_family": temp}]}
-        }
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step(
-            "Verify that R1 and R2 {} all the routes from RED vrf's RIB and"
-            " FIB".format(status)
-        )
-        for dut in ["r1", "r3"]:
-            step("Verify RIB/FIB for vrf RED on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                                "vrf": "RED",
-                            }
-                        ]
-                    }
-                }
-
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    write_test_footer(tc_name)
-
-
-def test_dynamic_import_routes_between_tenant_to_default_vrf_p0(request):
-    """
-    Verify that with multiple tenant VRFs, dynamic import works fine between
-    Tenant VRFs to default VRF.
-
-    When next-hop IPs and prefixes are same across all VRFs.
-    When next-hop IPs and prefixes are different across all VRFs.
-    """
-
-    tgen = get_topogen()
-    tc_name = request.node.name
-    write_test_header(tc_name)
-    reset_config_on_routers(tgen)
-    if tgen.routers_have_failure():
-        pytest.skip(tgen.errors)
-
-    step(
-        "Configure static routes on R3 for each vrf and redistribute in "
-        "respective BGP instance"
-    )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step("Configure static route for VRF : {}".format(vrf_name))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r3": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = create_static_routes(tgen, static_routes)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
-            )
-
-        redist_dict = {
-            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step(
-            "Verify that R3 has installed redistributed routes in respective "
-            "vrfs: {}".format(vrf_name)
-        )
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r3": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = verify_rib(tgen, addr_type, "r3", static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    step("Import all tenant vrfs(GREEN+BLUE+RED) in default vrf on R3")
-
-    for vrf_name in ["RED", "BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        redist_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify on R3 that it installs all the routes(imported from tenant "
-        "VRFs) in default vrf. Additionally, verify that R1 & R2 also "
-        "receive these routes from R3 and install in default vrf, next-hop "
-        "pointing to R3"
-    )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r3": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                        }
-                    ]
-                }
-            }
-
-            for dut in ["r2", "r1"]:
-                next_hop_val = topo["routers"]["r3"]["links"]["{}-link4".format(dut)][
-                    addr_type
-                ].split("/")[0]
-
-                result = verify_bgp_rib(
-                    tgen, addr_type, dut, static_routes, next_hop=next_hop_val
-                )
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-                result = verify_rib(
-                    tgen, addr_type, dut, static_routes, next_hop=next_hop_val
-                )
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-            result = verify_bgp_rib(tgen, addr_type, "r3", static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, "r3", static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    for action, value, status in zip(
-        ["Remove", "Add"], [True, False], ["withdraw", "re-install"]
-    ):
-        step(
-            "{} import vrf GREEN/BLUE/RED/all command from default vrf "
-            "instance on R3".format(action)
-        )
-        for vrf_name in ["RED", "BLUE", "GREEN"]:
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {"import": {"vrf": vrf_name, "delete": value}}
-                        }
-                    }
-                )
-
-            import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
-
-            result = create_router_bgp(tgen, topo, import_dict)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-        step(
-            "Verify that R1,R2 & R3 {} imported routes from GREEN/BLUE/RED/all"
-            " in default vrf's RIB".format(status)
-        )
-        for dut in ["r1", "r2", "r3"]:
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK1_1[addr_type],
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                            }
-                        ]
-                    }
-                }
-
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    for action, value in zip(["Shut", "No shut"], [True, False]):
-        step(
-            "{} the neighborship between R1-R3 and R1-R2 for vrf RED, GREEN "
-            "and BLUE".format(action)
-        )
-        bgp_disable = {"r3": {"bgp": []}}
-        for vrf_name in ["RED", "GREEN", "BLUE"]:
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {
-                                "neighbor": {
-                                    "r1": {
-                                        "dest_link": {"r3-link4": {"shutdown": value}}
-                                    },
-                                    "r2": {
-                                        "dest_link": {"r3-link4": {"shutdown": value}}
-                                    },
-                                }
-                            }
-                        }
-                    }
-                )
-
-            bgp_disable["r3"]["bgp"].append(
-                {"vrf": vrf_name, "local_as": 3, "address_family": temp}
-            )
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step(
-            "Verify that when peering is shutdown for tenant vrfs, it "
-            "doesn't impact the RIB/FIB of default vrf on router R1 and R2"
-        )
-        for dut in ["r1", "r2"]:
-            step("Verify RIB/FIB for default vrf on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK1_1[addr_type],
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                            }
-                        ]
-                    }
-                }
-                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-                result = verify_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-    for action, value, status in zip(
-        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
-    ):
-        step(
-            "{} the neighborship between R1-R3 and R2-R3 for default vrf".format(action)
-        )
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "neighbor": {
-                                "r1": {"dest_link": {"r3-link4": {"shutdown": value}}},
-                                "r2": {"dest_link": {"r3-link4": {"shutdown": value}}},
-                            }
-                        }
-                    }
-                }
-            )
-
-        bgp_disable = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step(
-            "Verify that R1 and R2 {} all the routes from default vrf's RIB"
-            " and FIB".format(status)
-        )
-        for dut in ["r1", "r2"]:
-            step("Verify RIB/FIB for default vrf on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK1_1[addr_type],
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                            }
-                        ]
-                    }
-                }
-
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    step("Remove import command from router R3 and configure the same on R2")
-    temp = {}
-    for vrf_name in VRF_LIST:
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
-            )
-
-        import_dict = {"r3": {"bgp": [{"local_as": 3, "address_family": temp}]}}
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify that once import commands are removed from R3, all imported "
-        "routes are withdrawn from RIB/FIB of default vrf on R1/R2/R3"
-    )
-
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify RIB/FIB for default vrf on {}".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [
-                                NETWORK1_1[addr_type],
-                                NETWORK2_1[addr_type],
-                                NETWORK3_1[addr_type],
-                            ],
-                            "next_hop": "blackhole",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in BGP table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    for vrf_name, network in zip(VRF_LIST, [NETWORK1_1, NETWORK2_1, NETWORK3_1]):
-        step("Configure static route for VRF : {} on r2".format(vrf_name))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                "r2": {
-                    "static_routes": [
-                        {
-                            "network": [network[addr_type]],
-                            "next_hop": "blackhole",
-                            "vrf": vrf_name,
-                        }
-                    ]
-                }
-            }
-
-            result = create_static_routes(tgen, static_routes)
-            assert result is True, "Testcase {} :Failed \n Error: {}".format(
-                tc_name, result
-            )
-
-        step("Redistribute static route on BGP VRF : {}".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"redistribute": [{"redist_type": "static"}]}}}
-            )
-
-        redist_dict = {
-            "r2": {"bgp": [{"vrf": vrf_name, "local_as": 2, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step("Remove redistribute static route on BGP VRF : {} on r3".format(vrf_name))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "redistribute": [{"redist_type": "static", "delete": True}]
-                        }
-                    }
-                }
-            )
-
-        redist_dict = {
-            "r3": {"bgp": [{"vrf": vrf_name, "local_as": 3, "address_family": temp}]}
-        }
-
-        result = create_router_bgp(tgen, topo, redist_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for vrf_name in ["RED", "BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify after import commands are re-configured on R2's vrf RED, all "
-        "those routes are installed again in default vrf of R1,R2,R3"
-    )
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify RIB/FIB for vrf RED on {}".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [
-                                NETWORK1_1[addr_type],
-                                NETWORK2_1[addr_type],
-                                NETWORK3_1[addr_type],
-                            ],
-                            "next_hop": "blackhole",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    step("Remove import vrf RED/GREEN/BLUE/all one by one from default vrf" " on R2")
-    for vrf_name in ["RED", "BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {addr_type: {"unicast": {"import": {"vrf": vrf_name, "delete": True}}}}
-            )
-
-        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    step(
-        "Verify that R1, R2 and R3 withdraws imported routes from default "
-        "vrf's RIB and FIB "
-    )
-    for dut in ["r1", "r2", "r3"]:
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [
-                                NETWORK1_1[addr_type],
-                                NETWORK2_1[addr_type],
-                                NETWORK3_1[addr_type],
-                            ],
-                            "next_hop": "blackhole",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, (
-                "Testcase {} : Failed \nError {}\n"
-                "Routes {} still in BGP table".format(
-                    tc_name, result, static_routes[dut]["static_routes"][0]["network"]
-                )
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes, expected=False)
-            assert result is not True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    step("Add import vrf RED/GREEN/BLUE/all one by one from default vrf on R2")
-    for vrf_name in ["RED", "BLUE", "GREEN"]:
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update({addr_type: {"unicast": {"import": {"vrf": vrf_name}}}})
-
-        import_dict = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
-
-        result = create_router_bgp(tgen, topo, import_dict)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-    for dut in ["r1", "r2", "r3"]:
-        step("Verify that {} reinstall imported routes from vrf RED's RIB".format(dut))
-        for addr_type in ADDR_TYPES:
-            static_routes = {
-                dut: {
-                    "static_routes": [
-                        {
-                            "network": [
-                                NETWORK1_1[addr_type],
-                                NETWORK2_1[addr_type],
-                                NETWORK3_1[addr_type],
-                            ],
-                            "next_hop": "blackhole",
-                        }
-                    ]
-                }
-            }
-            result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-            result = verify_rib(tgen, addr_type, dut, static_routes)
-            assert result is True, "Testcase {} : Failed \n Error {}".format(
-                tc_name, result
-            )
-
-    for action, value in zip(["Shut", "No shut"], [True, False]):
-        step(
-            "{} the neighborship between R2-R3 for vrf GREEN, BLUE and RED".format(
-                action
-            )
-        )
-        bgp_disable = {"r2": {"bgp": []}}
-        for vrf_name in ["GREEN", "BLUE", "RED"]:
-            temp = {}
-            for addr_type in ADDR_TYPES:
-                temp.update(
-                    {
-                        addr_type: {
-                            "unicast": {
-                                "neighbor": {
-                                    "r3": {
-                                        "dest_link": {"r2-link4": {"shutdown": value}}
-                                    }
-                                }
-                            }
-                        }
-                    }
-                )
-
-            bgp_disable["r2"]["bgp"].append(
-                {"vrf": vrf_name, "local_as": 2, "address_family": temp}
-            )
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step("Verify RIB/FIB of vrf RED will be unchanged on all 3 routers")
-        for dut in ["r1", "r2", "r3"]:
-            step("Verify RIB/FIB for vrf RED on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK1_1[addr_type],
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                            }
-                        ]
-                    }
-                }
-
-                result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-                result = verify_rib(tgen, addr_type, dut, static_routes)
-                assert result is True, "Testcase {} : Failed \n Error {}".format(
-                    tc_name, result
-                )
-
-    for action, value, status in zip(
-        ["Shut", "No shut"], [True, False], ["Withdraw", "Reinstall"]
-    ):
-        step("{} the neighborship between R2-R3 for default vrf".format(action))
-        temp = {}
-        for addr_type in ADDR_TYPES:
-            temp.update(
-                {
-                    addr_type: {
-                        "unicast": {
-                            "neighbor": {
-                                "r3": {"dest_link": {"r2-link4": {"shutdown": value}}}
-                            }
-                        }
-                    }
-                }
-            )
-
-        bgp_disable = {"r2": {"bgp": [{"local_as": 2, "address_family": temp}]}}
-        result = create_router_bgp(tgen, topo, bgp_disable)
-        assert result is True, "Testcase {} :Failed \n Error: {}".format(
-            tc_name, result
-        )
-
-        step(
-            "Verify that R1 and R2 {} all the routes from default vrfs RIB and"
-            " FIB".format(status)
-        )
-        for dut in ["r1", "r3"]:
-            step("Verify RIB/FIB for default vrf on {}".format(dut))
-            for addr_type in ADDR_TYPES:
-                static_routes = {
-                    dut: {
-                        "static_routes": [
-                            {
-                                "network": [
-                                    NETWORK1_1[addr_type],
-                                    NETWORK2_1[addr_type],
-                                    NETWORK3_1[addr_type],
-                                ],
-                                "next_hop": "blackhole",
-                            }
-                        ]
-                    }
-                }
-
-                if value:
-                    result = verify_bgp_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed \nError {}\n" "Routes {} still in BGP table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-
-                    result = verify_rib(
-                        tgen, addr_type, dut, static_routes, expected=False
-                    )
-                    assert (
-                        result is not True
-                    ), "Testcase {} : Failed Error {}" "Routes {} still in Route table".format(
-                        tc_name,
-                        result,
-                        static_routes[dut]["static_routes"][0]["network"],
-                    )
-                else:
-                    result = verify_bgp_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-                    result = verify_rib(tgen, addr_type, dut, static_routes)
-                    assert result is True, "Testcase {} : Failed \n Error {}".format(
-                        tc_name, result
-                    )
-
-    write_test_footer(tc_name)
-
-
-if __name__ == "__main__":
-    args = ["-s"] + sys.argv[1:]
-    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/config_timing/test_config_timing.py frr-frr-8.5/tests/topotests/config_timing/test_config_timing.py
--- frr-frr-8.4.2/tests/topotests/config_timing/test_config_timing.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/config_timing/test_config_timing.py	2023-03-13 20:01:47.000000000 +0600
@@ -161,8 +161,17 @@ def test_static_timing():
 
         return tot_delta
 
+
     # Number of static routes
-    prefix_count = 10000
+    router = tgen.gears["r1"]
+    output = router.run("vtysh -h | grep address-sanitizer")
+    if output == "":
+        logger.info("No Address Sanitizer, generating 10000 routes")
+        prefix_count = 10000
+    else:
+        logger.info("Address Sanitizer build, only testing 50 routes")
+        prefix_count = 50
+
     prefix_base = [
         [u"10.0.0.0/8", u"11.0.0.0/8"],
         [u"2100:1111:2220::/44", u"2100:3333:4440::/44"],
diff -urpN frr-frr-8.4.2/tests/topotests/cspf_topo1/r1/zebra.conf frr-frr-8.5/tests/topotests/cspf_topo1/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/cspf_topo1/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/cspf_topo1/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -10,6 +10,7 @@ interface r1-eth0
  link-params
   metric 20
   delay 10000
+  max-bw 10e+10
   ava-bw 1.25e+08
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/cspf_topo1/r2/zebra.conf frr-frr-8.5/tests/topotests/cspf_topo1/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/cspf_topo1/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/cspf_topo1/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ interface r2-eth3
  link-params
   metric 25
   delay 25000
+  max-bw 10e+10
   use-bw 1.25e+8
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/cspf_topo1/reference/sharp-ted.json frr-frr-8.5/tests/topotests/cspf_topo1/reference/sharp-ted.json
--- frr-frr-8.4.2/tests/topotests/cspf_topo1/reference/sharp-ted.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/cspf_topo1/reference/sharp-ted.json	2023-03-13 20:01:47.000000000 +0600
@@ -64,32 +64,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:1::1:1",
           "remote-address-v6":"2001:db8:1::1:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000
@@ -107,32 +107,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:1::1:2",
           "remote-address-v6":"2001:db8:1::1:1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000
@@ -150,32 +150,32 @@
           "te-metric":40,
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":40000
@@ -194,32 +194,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000
@@ -237,32 +237,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000
@@ -286,32 +286,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000
@@ -329,32 +329,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -373,32 +373,32 @@
           "te-metric":20,
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000
@@ -416,32 +416,32 @@
           "te-metric":10,
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000
@@ -459,32 +459,32 @@
           "te-metric":10,
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000
@@ -502,32 +502,32 @@
           "te-metric":40,
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":40000
@@ -546,32 +546,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000
@@ -589,32 +589,32 @@
           "te-metric":25,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -633,32 +633,32 @@
           "te-metric":40,
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":40000
diff -urpN frr-frr-8.4.2/tests/topotests/cspf_topo1/test_cspf_topo1.py frr-frr-8.5/tests/topotests/cspf_topo1/test_cspf_topo1.py
--- frr-frr-8.4.2/tests/topotests/cspf_topo1/test_cspf_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/cspf_topo1/test_cspf_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -169,13 +169,19 @@ def compare_cspf_output(tgen, rname, fil
 
     filename = "{}/reference/{}".format(CWD, fileref)
     expected = open(filename).read()
-    command = "show sharp cspf source {} destination {} {} {}".format(src, dst, cost, bw)
+    command = "show sharp cspf source {} destination {} {} {}".format(
+        src, dst, cost, bw
+    )
 
     # Run test function until we get an result. Wait at most 60 seconds.
-    test_func = partial(topotest.router_output_cmp, tgen.gears[rname], command, expected)
-    result, diff = topotest.run_and_expect(test_func, "", count=2, wait=2)
-    assert result, "CSPF output mismatches the expected result on {}:\n{}".format(rname, diff)
-    
+    test_func = partial(
+        topotest.router_output_cmp, tgen.gears[rname], command, expected
+    )
+    result, diff = topotest.run_and_expect(test_func, "", count=5, wait=2)
+    assert result, "CSPF output mismatches the expected result on {}:\n{}".format(
+        rname, diff
+    )
+
 
 def setup_testcase(msg):
     "Setup test case"
@@ -207,10 +213,24 @@ def test_step2():
 
     tgen = setup_testcase("Step2: CSPF(r1, r4, IPv4)")
 
-    compare_cspf_output(tgen, "r1", "cspf-ipv4-metric.txt", "10.0.0.1", "10.0.255.4", "metric 50")
-    compare_cspf_output(tgen, "r1", "cspf-ipv4-te-metric.txt", "10.0.255.1", "10.0.4.4", "te-metric 50")
-    compare_cspf_output(tgen, "r1", "cspf-ipv4-delay.txt", "10.0.255.1", "10.0.255.4", "delay 50000")
-    compare_cspf_output(tgen, "r1", "cspf-ipv4-delay.txt", "10.0.255.1", "10.0.255.4", "delay 50000", "rsv 7 100000000")
+    compare_cspf_output(
+        tgen, "r1", "cspf-ipv4-metric.txt", "10.0.0.1", "10.0.255.4", "metric 50"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-ipv4-te-metric.txt", "10.0.255.1", "10.0.4.4", "te-metric 50"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-ipv4-delay.txt", "10.0.255.1", "10.0.255.4", "delay 50000"
+    )
+    compare_cspf_output(
+        tgen,
+        "r1",
+        "cspf-ipv4-delay.txt",
+        "10.0.255.1",
+        "10.0.255.4",
+        "delay 50000",
+        "rsv 7 1000000",
+    )
 
 
 def test_step3():
@@ -218,10 +238,34 @@ def test_step3():
 
     tgen = setup_testcase("Step2: CSPF(r1, r4, IPv6)")
 
-    compare_cspf_output(tgen, "r1", "cspf-ipv6-metric.txt", "2001:db8:1::1:1", "2001:db8::4", "metric 50")
-    compare_cspf_output(tgen, "r1", "cspf-ipv6-te-metric.txt", "2001:db8::1", "2001:db8:5::3:4", "te-metric 80")
-    compare_cspf_output(tgen, "r1", "cspf-ipv6-delay.txt", "2001:db8::1", "2001:db8::4", "delay 80000")
-    compare_cspf_output(tgen, "r1", "cspf-ipv6-delay.txt", "2001:db8::1", "2001:db8::4", "delay 80000", "rsv 7 100000000")
+    compare_cspf_output(
+        tgen,
+        "r1",
+        "cspf-ipv6-metric.txt",
+        "2001:db8:1::1:1",
+        "2001:db8::4",
+        "metric 50",
+    )
+    compare_cspf_output(
+        tgen,
+        "r1",
+        "cspf-ipv6-te-metric.txt",
+        "2001:db8::1",
+        "2001:db8:5::3:4",
+        "te-metric 80",
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-ipv6-delay.txt", "2001:db8::1", "2001:db8::4", "delay 80000"
+    )
+    compare_cspf_output(
+        tgen,
+        "r1",
+        "cspf-ipv6-delay.txt",
+        "2001:db8::1",
+        "2001:db8::4",
+        "delay 80000",
+        "rsv 7 1000000",
+    )
 
 
 def test_step4():
@@ -229,13 +273,33 @@ def test_step4():
 
     tgen = setup_testcase("Step2: CSPF(r1, r4, failure)")
 
-    compare_cspf_output(tgen, "r1", "cspf-failed.txt", "10.0.255.1", "10.0.255.4", "metric 10")
-    compare_cspf_output(tgen, "r1", "cspf-failed.txt", "2001:db8::1", "2001:db8::4", "te-metric 50")
-    compare_cspf_output(tgen, "r1", "cspf-failed.txt", "10.0.255.1", "10.0.255.4", "delay 5000")
-    compare_cspf_output(tgen, "r1", "cspf-failed.txt", "2001:db8::1", "2001:db8::4", "delay 80000", "rsv 7 1000000000")
-    compare_cspf_output(tgen, "r1", "cspf-failed-src.txt", "10.0.0.3", "10.0.255.4", "metric 10")
-    compare_cspf_output(tgen, "r1", "cspf-failed-dst.txt", "10.0.0.1", "10.0.4.40", "metric 10")
-    compare_cspf_output(tgen, "r1", "cspf-failed-same.txt", "10.0.0.1", "10.0.0.1", "metric 10")
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed.txt", "10.0.255.1", "10.0.255.4", "metric 10"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed.txt", "2001:db8::1", "2001:db8::4", "te-metric 50"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed.txt", "10.0.255.1", "10.0.255.4", "delay 5000"
+    )
+    compare_cspf_output(
+        tgen,
+        "r1",
+        "cspf-failed.txt",
+        "2001:db8::1",
+        "2001:db8::4",
+        "delay 80000",
+        "rsv 7 10000000",
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed-src.txt", "10.0.0.3", "10.0.255.4", "metric 10"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed-dst.txt", "10.0.0.1", "10.0.4.40", "metric 10"
+    )
+    compare_cspf_output(
+        tgen, "r1", "cspf-failed-same.txt", "10.0.0.1", "10.0.0.1", "metric 10"
+    )
 
 
 def test_memory_leak():
diff -urpN frr-frr-8.4.2/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_chaos_topo1.py frr-frr-8.5/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_chaos_topo1.py
--- frr-frr-8.4.2/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_chaos_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_chaos_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -829,10 +829,11 @@ def test_RT_verification_auto_p0(request
         }
 
         result = verify_rib(tgen, addr_type, "d2", input_routes, expected=False)
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-        logger.info("Expected Behavior: {}".format(result))
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "d2", result)
+        )
 
     step(
         "Revert back to original VNI number for all 3 VRFs on Edge-1 "
@@ -965,12 +966,11 @@ def test_RT_verification_auto_p0(request
         result = verify_attributes_for_evpn_routes(
             tgen, topo, "d2", input_routes_1, rt="auto", rt_peer="e1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Malfaromed Auto-RT value accepted: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Malformed Auto-RT value should not be accepted in {} \n "
+            "Found: {}".format(tc_name, "d2", result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     step("Configure VNI number more than boundary limit (16777215)")
 
@@ -1000,12 +1000,11 @@ def test_RT_verification_auto_p0(request
         result = verify_attributes_for_evpn_routes(
             tgen, topo, "d2", input_routes_1, rt="auto", rt_peer="e1", expected=False
         )
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Malfaromed Auto-RT value accepted: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Malformed Auto-RT value should not be accepted in {} \n "
+            "Found: {}".format(tc_name, "d2", result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     step("Un-configure VNI number more than boundary limit (16777215)")
 
diff -urpN frr-frr-8.4.2/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_topo1.py frr-frr-8.5/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_topo1.py
--- frr-frr-8.4.2/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/evpn_type5_test_topo1/test_evpn_type5_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -71,7 +71,7 @@ from lib.common_config import (
     configure_brctl,
     create_interface_in_kernel,
     kill_router_daemons,
-    start_router_daemons
+    start_router_daemons,
 )
 
 from lib.topolog import logger
@@ -86,15 +86,6 @@ from lib.topojson import build_topo_from
 
 pytestmark = [pytest.mark.bgpd, pytest.mark.staticd]
 
-
-# Reading the data from JSON File for topology creation
-jsonFile = "{}/evpn_type5_topo1.json".format(CWD)
-try:
-    with open(jsonFile, "r") as topoJson:
-        topo = json.load(topoJson)
-except IOError:
-    assert False, "Could not read file {}".format(jsonFile)
-
 # Global variables
 NETWORK1_1 = {"ipv4": "10.1.1.1/32", "ipv6": "10::1/128"}
 NETWORK1_2 = {"ipv4": "40.1.1.1/32", "ipv6": "40::1/128"}
@@ -135,10 +126,6 @@ BRCTL = {
 }
 
 
-def build_topo(tgen):
-    build_topo_from_json(tgen, topo)
-
-
 def setup_module(mod):
     """
     Sets up the pytest environment
@@ -154,7 +141,10 @@ def setup_module(mod):
     logger.info("Running setup_module to create topology")
 
     # This function initiates the topology build with Topogen...
-    tgen = Topogen(build_topo, mod.__name__)
+    json_file = "{}/evpn_type5_topo1.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    topo = tgen.json_topo
+
     # ... and here it calls Mininet initialization functions.
 
     # Starting topology, create tmp files which are loaded to routers
@@ -858,17 +848,17 @@ def test_RT_verification_manual_p0(reque
         }
         result = verify_rib(tgen, addr_type, "d1", input_routes, expected=False)
         assert result is not True, (
-            "Testcase {} :Failed \n Expected Behavior: Routes are still "
-            "present \n Error: {}".format(tc_name, result)
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "d1", result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
         result = verify_rib(tgen, addr_type, "d2", input_routes, expected=False)
         assert result is not True, (
-            "Testcase {} :Failed \n Expected Behavior: Routes are still "
-            "present \n Error: {}".format(tc_name, result)
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "d2", result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     step(
         "Configure RT value as 100:100000010000010000101010 to check "
@@ -910,10 +900,10 @@ def test_RT_verification_manual_p0(reque
         tgen, topo, dut, input_routes, rt="100:100000010000010000101010", expected=False
     )
     assert result is not True, (
-        "Testcase {} :Failed \n Expected Behavior: RT value of out"
-        " of boundary \n Error: {}".format(tc_name, result)
+        "Testcase {} : Failed \n "
+        "Expected: RT value out of boundary error in {} \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1326,18 +1316,20 @@ def test_evpn_routes_from_VNFs_p1(reques
     for addr_type in ADDR_TYPES:
         input_routes = {key: topo["routers"][key] for key in ["r1"]}
         result = verify_rib(tgen, addr_type, "d2", input_routes, expected=False)
-        assert (
-            result is not True
-        ), "Testcase :Failed \n Routes are still present: {}".format(result)
-        logger.info("Expected Behavior: {}".format(result))
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "d2", result)
+        )
 
     for addr_type in ADDR_TYPES:
         input_routes = {key: topo["routers"][key] for key in ["r1"]}
         result = verify_rib(tgen, addr_type, "r3", input_routes, expected=False)
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-        logger.info("Expected Behavior: {}".format(result))
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "r3", result)
+        )
 
     step("Re-advertise IP prefixes from VFN(R1).")
     step(
@@ -1411,16 +1403,18 @@ def test_evpn_routes_from_VNFs_p1(reques
         }
 
         result = verify_rib(tgen, addr_type, "d2", input_routes, expected=False)
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-        logger.info("Expected Behavior: {}".format(result))
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "d2", result)
+        )
 
         result = verify_rib(tgen, addr_type, "r4", input_routes, expected=False)
-        assert (
-            result is not True
-        ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-        logger.info("Expected Behavior: {}".format(result))
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: Routes should not be present in {} RIB \n "
+            "Found: {}".format(tc_name, "r4", result)
+        )
 
     step("Add vrf BLUE on router Edge-1 again.")
     interface = topo["routers"]["e1"]["links"]["r2-link1"]["interface"]
@@ -1514,16 +1508,18 @@ def test_evpn_routes_from_VNFs_p1(reques
     }
 
     result = verify_rib(tgen, addr_type, "d2", input_routes, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-    logger.info("Expected Behavior: {}".format(result))
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} RIB \n "
+        "Found: {}".format(tc_name, "d2", result)
+    )
 
     result = verify_rib(tgen, addr_type, "r4", input_routes, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} :Failed \n Routes are still present: {}".format(tc_name, result)
-    logger.info("Expected Behavior: {}".format(result))
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} RIB \n "
+        "Found: {}".format(tc_name, "r4", result)
+    )
 
     step("Advertise IPv6 address-family in EVPN advertisements " "for VRF GREEN.")
     addr_type = "ipv6"
@@ -1775,34 +1771,41 @@ def test_evpn_address_family_with_gracef
     for addr_type in ADDR_TYPES:
         input_dict_1 = {
             "r3": {
-                "static_routes": [{
-                    "network": NETWORK1_2[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "RED"
-                }]
-            },
-            "r4":{
-                "static_routes": [{
-                    "network": NETWORK1_3[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "BLUE"
-                },
-                {
-                    "network": NETWORK1_4[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "GREEN"
-                }]
-            }
+                "static_routes": [
+                    {
+                        "network": NETWORK1_2[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "RED",
+                    }
+                ]
+            },
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK1_3[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    },
+                    {
+                        "network": NETWORK1_4[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "GREEN",
+                    },
+                ]
+            },
         }
 
         result = create_static_routes(tgen, input_dict_1)
-        assert result is True, 'Testcase {} : Failed \n Error: {}'.format(
-            tc_name, result)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
 
-    step("Redistribute static in (IPv4 and IPv6) address-family "
-        "on Edge-1 for all VRFs.")
+    step(
+        "Redistribute static in (IPv4 and IPv6) address-family "
+        "on Edge-1 for all VRFs."
+    )
 
-    input_dict_2={}
+    input_dict_2 = {}
     for dut in ["r3", "r4"]:
         temp = {dut: {"bgp": []}}
         input_dict_2.update(temp)
@@ -1821,108 +1824,116 @@ def test_evpn_address_family_with_gracef
                     "vrf": vrf,
                     "address_family": {
                         "ipv4": {
-                            "unicast": {
-                                "redistribute": [{
-                                    "redist_type": "static"
-                                }]
-                            }
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
                         },
                         "ipv6": {
-                            "unicast": {
-                                "redistribute": [{
-                                    "redist_type": "static"
-                                }]
-                            }
-                        }
-                    }
-                })
+                            "unicast": {"redistribute": [{"redist_type": "static"}]}
+                        },
+                    },
+                }
+            )
 
     result = create_router_bgp(tgen, topo, input_dict_2)
-    assert result is True, "Testcase {} :Failed \n Error: {}". \
-        format(tc_name, result)
+    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
 
-    step("Verify on router Edge-1 that EVPN routes corresponding to "
-        "all VRFs are received from both routers DCG-1 and DCG-2")
+    step(
+        "Verify on router Edge-1 that EVPN routes corresponding to "
+        "all VRFs are received from both routers DCG-1 and DCG-2"
+    )
 
     for addr_type in ADDR_TYPES:
         input_routes = {
             "r3": {
-                "static_routes": [{
-                    "network": NETWORK1_2[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "RED"
-                }]
-            },
-            "r4":{
-                "static_routes": [{
-                    "network": NETWORK1_3[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "BLUE"
-                },
-                {
-                    "network": NETWORK1_4[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "GREEN"
-                }]
-            }
+                "static_routes": [
+                    {
+                        "network": NETWORK1_2[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "RED",
+                    }
+                ]
+            },
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK1_3[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    },
+                    {
+                        "network": NETWORK1_4[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "GREEN",
+                    },
+                ]
+            },
         }
 
         result = verify_rib(tgen, addr_type, "e1", input_routes)
-        assert result is True, "Testcase {} :Failed \n Error: {}". \
-            format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
 
-    step("Configure DCG-2 as GR restarting node for EVPN session between"
+    step(
+        "Configure DCG-2 as GR restarting node for EVPN session between"
         " DCG-2 and EDGE-1, following by a session reset using 'clear bgp *'"
-        " command.")
+        " command."
+    )
 
     input_dict_gr = {
         "d2": {
-            "bgp":
-            [
+            "bgp": [
                 {
                     "local_as": "200",
                     "graceful-restart": {
                         "graceful-restart": True,
-                    }
+                    },
                 }
             ]
         }
     }
 
     result = create_router_bgp(tgen, topo, input_dict_gr)
-    assert result is True, "Testcase {} : Failed \n Error: {}".format(
-        tc_name, result)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
 
-    step("Verify that DCG-2 changes it's role to GR-restarting router "
-        "and EDGE-1 becomes the GR-helper.")
+    step(
+        "Verify that DCG-2 changes it's role to GR-restarting router "
+        "and EDGE-1 becomes the GR-helper."
+    )
 
     step("Kill BGPd daemon on DCG-2.")
     kill_router_daemons(tgen, "d2", ["bgpd"])
 
-    step("Verify that EDGE-1 keep stale entries for EVPN RT-5 routes "
-        "received from DCG-2 before the restart.")
+    step(
+        "Verify that EDGE-1 keep stale entries for EVPN RT-5 routes "
+        "received from DCG-2 before the restart."
+    )
 
     for addr_type in ADDR_TYPES:
         input_routes = {
-            "r4":{
-                "static_routes": [{
-                    "network": NETWORK1_3[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "BLUE"
-                },
-                {
-                    "network": NETWORK1_4[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "GREEN"
-                }]
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK1_3[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    },
+                    {
+                        "network": NETWORK1_4[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "GREEN",
+                    },
+                ]
             }
         }
         result = verify_evpn_routes(tgen, topo, "e1", input_routes)
-        assert result is True, "Testcase {} :Failed \n Error: {}". \
-            format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
 
-    step("Verify that DCG-2 keeps BGP routes in Zebra until BGPd "
-        "comes up or end of 'rib-stale-time'")
+    step(
+        "Verify that DCG-2 keeps BGP routes in Zebra until BGPd "
+        "comes up or end of 'rib-stale-time'"
+    )
 
     step("Start BGPd daemon on DCG-2.")
     start_router_daemons(tgen, "d2", ["bgpd"])
@@ -1930,44 +1941,52 @@ def test_evpn_address_family_with_gracef
     step("Verify that EDGE-1 removed all the stale entries.")
     for addr_type in ADDR_TYPES:
         input_routes = {
-            "r4":{
-                "static_routes": [{
-                    "network": NETWORK1_3[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "BLUE"
-                },
-                {
-                    "network": NETWORK1_4[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "GREEN"
-                }]
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK1_3[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    },
+                    {
+                        "network": NETWORK1_4[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "GREEN",
+                    },
+                ]
             }
         }
         result = verify_evpn_routes(tgen, topo, "e1", input_routes)
-        assert result is True, "Testcase {} :Failed \n Error: {}". \
-            format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
 
-    step("Verify that DCG-2 refresh zebra with EVPN routes. "
-        "(no significance of 'rib-stale-time'")
+    step(
+        "Verify that DCG-2 refresh zebra with EVPN routes. "
+        "(no significance of 'rib-stale-time'"
+    )
 
     for addr_type in ADDR_TYPES:
         input_routes = {
-            "r4":{
-                "static_routes": [{
-                    "network": NETWORK1_3[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "BLUE"
-                },
-                {
-                    "network": NETWORK1_4[addr_type],
-                    "next_hop": NEXT_HOP_IP[addr_type],
-                    "vrf": "GREEN"
-                }]
+            "r4": {
+                "static_routes": [
+                    {
+                        "network": NETWORK1_3[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "BLUE",
+                    },
+                    {
+                        "network": NETWORK1_4[addr_type],
+                        "next_hop": NEXT_HOP_IP[addr_type],
+                        "vrf": "GREEN",
+                    },
+                ]
             }
         }
         result = verify_rib(tgen, addr_type, "d2", input_routes)
-        assert result is True, "Testcase {} :Failed \n Error: {}". \
-            format(tc_name, result)
+        assert result is True, "Testcase {} :Failed \n Error: {}".format(
+            tc_name, result
+        )
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/bgp.py frr-frr-8.5/tests/topotests/grpc_basic/lib/bgp.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/bgp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/bgp.py	2023-03-13 20:01:47.000000000 +0600
@@ -830,22 +830,36 @@ def __create_bgp_neighbor(topo, input_di
     global_connect = input_dict.get("connecttimer", 5)
 
     for name, peer_dict in neigh_data.items():
+        remote_as = 0
         for dest_link, peer in peer_dict["dest_link"].items():
+            local_asn = peer.setdefault("local_asn", {})
+            if local_asn:
+                local_as = local_asn.setdefault("local_as", 0)
+                remote_as = local_asn.setdefault("remote_as", 0)
+                no_prepend = local_asn.setdefault("no_prepend", False)
+                replace_as = local_asn.setdefault("replace_as", False)
+                if local_as == remote_as:
+                    assert False is True, (
+                        " Configuration Error : Router must not have "
+                        "same AS-NUMBER as Local AS NUMBER"
+                    )
             nh_details = topo[name]
 
             if "vrfs" in topo[router] or type(nh_details["bgp"]) is list:
                 for vrf_data in nh_details["bgp"]:
                     if "vrf" in nh_details["links"][dest_link] and "vrf" in vrf_data:
                         if nh_details["links"][dest_link]["vrf"] == vrf_data["vrf"]:
-                            remote_as = vrf_data["local_as"]
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
                             break
                     else:
                         if "vrf" not in vrf_data:
-                            remote_as = vrf_data["local_as"]
-                            break
-
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
+                                break
             else:
-                remote_as = nh_details["bgp"]["local_as"]
+                if not remote_as:
+                    remote_as = nh_details["bgp"]["local_as"]
 
             update_source = None
 
@@ -890,6 +904,14 @@ def __create_bgp_neighbor(topo, input_di
                 elif add_neigh:
                     config_data.append("{} remote-as {}".format(neigh_cxt, remote_as))
 
+                if local_asn and local_as:
+                    cmd = "{} local-as {}".format(neigh_cxt, local_as)
+                    if no_prepend:
+                        cmd = "{} no-prepend".format(cmd)
+                    if replace_as:
+                        cmd = "{} replace-as".format(cmd)
+                    config_data.append("{}".format(cmd))
+
             if addr_type == "ipv6":
                 config_data.append("address-family ipv6 unicast")
                 config_data.append("{} activate".format(neigh_cxt))
@@ -1887,7 +1909,7 @@ def clear_bgp(tgen, addr_type, router, v
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
-def clear_bgp_and_verify(tgen, topo, router):
+def clear_bgp_and_verify(tgen, topo, router, rid=None):
     """
     This API is to clear bgp neighborship and verify bgp neighborship
     is coming up(BGP is converged) usinf "show bgp summary json" command
@@ -1937,7 +1959,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
 
@@ -1997,10 +2023,15 @@ def clear_bgp_and_verify(tgen, topo, rou
     logger.info("Clearing BGP neighborship for router %s..", router)
     for addr_type in bgp_addr_type.keys():
         if addr_type == "ipv4":
-            run_frr_cmd(rnode, "clear ip bgp *")
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv4 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv4 *")
         elif addr_type == "ipv6":
-            run_frr_cmd(rnode, "clear bgp ipv6 *")
-
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv6 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv6 *")
     peer_uptime_after_clear_bgp = {}
     # Verifying BGP convergence after bgp clear command
     for retry in range(50):
@@ -2020,7 +2051,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
             if not check_address_types(addr_type):
@@ -2775,7 +2810,11 @@ def verify_best_path_as_per_admin_distan
         if route in rib_routes_json:
             st_found = True
             # Verify next_hop in rib_routes_json
-            if rib_routes_json[route][0]["nexthops"][0]["ip"] == _next_hop:
+            if [
+                nh
+                for nh in rib_routes_json[route][0]["nexthops"]
+                if nh["ip"] == _next_hop
+            ]:
                 nh_found = True
             else:
                 errormsg = (
@@ -4238,7 +4277,7 @@ def verify_attributes_for_evpn_routes(
                         for _rd, route_data in evpn_rd_value_json.items():
                             if route_data["ip"] == route:
                                 for rt_data in route_data["paths"]:
-                                    if vni_dict[vrf] == rt_data["VNI"]:
+                                    if vni_dict[vrf] == rt_data["vni"]:
                                         rt_string = rt_data["extendedCommunity"][
                                             "string"
                                         ]
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/common_config.py frr-frr-8.5/tests/topotests/grpc_basic/lib/common_config.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/common_config.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/common_config.py	2023-03-13 20:01:47.000000000 +0600
@@ -81,6 +81,26 @@ DEBUG_LOGS = {
         "debug pim packets register",
         "debug pim nht",
     ],
+    "pim6d": [
+        "debug pimv6 events",
+        "debug pimv6 packets",
+        "debug pimv6 packet-dump send",
+        "debug pimv6 packet-dump receive",
+        "debug pimv6 trace",
+        "debug pimv6 trace detail",
+        "debug pimv6 zebra",
+        "debug pimv6 bsm",
+        "debug pimv6 packets hello",
+        "debug pimv6 packets joins",
+        "debug pimv6 packets register",
+        "debug pimv6 nht",
+        "debug pimv6 nht detail",
+        "debug mroute6",
+        "debug mroute6 detail",
+        "debug mld events",
+        "debug mld packets",
+        "debug mld trace",
+    ],
     "bgpd": [
         "debug bgp neighbor-events",
         "debug bgp updates",
@@ -961,7 +981,7 @@ def generate_support_bundle():
     return True
 
 
-def start_topology(tgen, daemon=None):
+def start_topology(tgen):
     """
     Starting topology, create tmp files which are loaded to routers
     to start daemons and then start routers
@@ -1009,38 +1029,70 @@ def start_topology(tgen, daemon=None):
         except IOError as err:
             logger.error("I/O error({0}): {1}".format(err.errno, err.strerror))
 
-        # Loading empty zebra.conf file to router, to start the zebra daemon
+        topo = tgen.json_topo
+        feature = set()
+
+        if "feature" in topo:
+            feature.update(topo["feature"])
+
+        if rname in topo["routers"]:
+            for key in topo["routers"][rname].keys():
+                feature.add(key)
+
+            for val in topo["routers"][rname]["links"].values():
+                if "pim" in val:
+                    feature.add("pim")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "pim6" in val:
+                    feature.add("pim6")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+        if "switches" in topo and rname in topo["switches"]:
+            for val in topo["switches"][rname]["links"].values():
+                if "ospf" in val:
+                    feature.add("ospf")
+                    break
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+
+        # Loading empty zebra.conf file to router, to start the zebra deamon
         router.load_config(
             TopoRouter.RD_ZEBRA, "{}/{}/zebra.conf".format(tgen.logdir, rname)
         )
 
-        # Loading empty bgpd.conf file to router, to start the bgp daemon
-        router.load_config(
-            TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
-        )
+        # Loading empty bgpd.conf file to router, to start the bgp deamon
+        if "bgp" in feature:
+            router.load_config(
+                TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
+            )
 
-        if daemon and "ospfd" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "ospf6d" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim6" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pimd" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim deamon
+        if "ospf" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pim6d" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim6d deamon
+        if "ospf6" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
             )
 
     # Starting routers
@@ -3244,33 +3296,29 @@ def configure_interface_mac(tgen, input_
     return True
 
 
-def socat_send_igmp_join_traffic(
+def socat_send_mld_join(
     tgen,
     server,
     protocol_option,
-    igmp_groups,
+    mld_groups,
     send_from_intf,
     send_from_intf_ip=None,
     port=12345,
     reuseaddr=True,
-    join=False,
-    traffic=False,
 ):
     """
-    API to send IGMP join using SOCAT tool
+    API to send MLD join using SOCAT tool
 
     Parameters:
     -----------
     * `tgen`  : Topogen object
     * `server`: iperf server, from where IGMP join would be sent
     * `protocol_option`: Protocol options, ex: UDP6-RECV
-    * `igmp_groups`: IGMP group for which join has to be sent
+    * `mld_groups`: IGMP group for which join has to be sent
     * `send_from_intf`: Interface from which join would be sent
     * `send_from_intf_ip`: Interface IP, default is None
     * `port`: Port to be used, default is 12345
     * `reuseaddr`: True|False, bydefault True
-    * `join`: If join needs to be sent
-    * `traffic`: If traffic needs to be sent
 
     returns:
     --------
@@ -3280,36 +3328,32 @@ def socat_send_igmp_join_traffic(
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     rnode = tgen.routers()[server]
-    socat_cmd = "socat -u "
+    socat_args = "socat -u "
 
-    # UDP4/TCP4/UDP6/UDP6-RECV
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
     if protocol_option:
-        socat_cmd += "{}".format(protocol_option)
+        socat_args += "{}".format(protocol_option)
 
     if port:
-        socat_cmd += ":{},".format(port)
+        socat_args += ":{},".format(port)
 
     if reuseaddr:
-        socat_cmd += "{},".format("reuseaddr")
+        socat_args += "{},".format("reuseaddr")
 
     # Group address range to cover
-    if igmp_groups:
-        if not isinstance(igmp_groups, list):
-            igmp_groups = [igmp_groups]
-
-    for igmp_group in igmp_groups:
-        if join:
-            join_traffic_option = "ipv6-join-group"
-        elif traffic:
-            join_traffic_option = "ipv6-join-group-source"
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        join_option = "ipv6-join-group"
 
         if send_from_intf and not send_from_intf_ip:
-            socat_cmd += "{}='[{}]:{}'".format(
-                join_traffic_option, igmp_group, send_from_intf
-            )
+            socat_cmd += "{}='[{}]:{}'".format(join_option, mld_group, send_from_intf)
         else:
             socat_cmd += "{}='[{}]:{}:[{}]'".format(
-                join_traffic_option, igmp_group, send_from_intf, send_from_intf_ip
+                join_option, mld_group, send_from_intf, send_from_intf_ip
             )
 
         socat_cmd += " STDOUT"
@@ -3324,6 +3368,124 @@ def socat_send_igmp_join_traffic(
     return True
 
 
+def socat_send_pim6_traffic(
+    tgen,
+    server,
+    protocol_option,
+    mld_groups,
+    send_from_intf,
+    port=12345,
+    multicast_hops=True,
+):
+    """
+    API to send pim6 data taffic using SOCAT tool
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `server`: iperf server, from where IGMP join would be sent
+    * `protocol_option`: Protocol options, ex: UDP6-RECV
+    * `mld_groups`: MLD group for which join has to be sent
+    * `send_from_intf`: Interface from which join would be sent
+    * `port`: Port to be used, default is 12345
+    * `multicast_hops`: multicast-hops count, default is 255
+
+    returns:
+    --------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[server]
+    socat_args = "socat -u STDIO "
+
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
+    if protocol_option:
+        socat_args += "'{}".format(protocol_option)
+
+    # Group address range to cover
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        if port:
+            socat_cmd += ":[{}]:{},".format(mld_group, port)
+
+        if send_from_intf:
+            socat_cmd += "interface={0},so-bindtodevice={0},".format(send_from_intf)
+
+        if multicast_hops:
+            socat_cmd += "multicast-hops=255'"
+
+        socat_cmd += " &>{}/socat.logs &".format(tgen.logdir)
+
+        # Run socat command to send pim6 traffic
+        logger.info(
+            "[DUT: {}]: Running command: [set +m; ( while sleep 1; do date; done ) | {}]".format(
+                server, socat_cmd
+            )
+        )
+
+        # Open a shell script file and write data to it, which will be
+        # used to send pim6 traffic continously
+        traffic_shell_script = "{}/{}/traffic.sh".format(tgen.logdir, server)
+        with open("{}".format(traffic_shell_script), "w") as taffic_sh:
+            taffic_sh.write(
+                "#!/usr/bin/env bash\n( while sleep 1; do date; done ) | {}\n".format(
+                    socat_cmd
+                )
+            )
+
+        rnode.run("chmod 755 {}".format(traffic_shell_script))
+        output = rnode.run("{} &> /dev/null".format(traffic_shell_script))
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def kill_socat(tgen, dut=None, action=None):
+    """
+    Killing socat process if running for any router in topology
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `dut`   : Any iperf hostname to send igmp prune
+    * `action`: to kill mld join using socat
+                to kill mld traffic using socat
+
+    Usage:
+    ------
+    kill_socat(tgen, dut ="i6", action="remove_mld_join")
+
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        if action == "remove_mld_join":
+            cmd = "ps -ef | grep socat | grep UDP6-RECV | grep {}".format(router)
+        elif action == "remove_mld_traffic":
+            cmd = "ps -ef | grep socat | grep UDP6-SEND | grep {}".format(router)
+        else:
+            cmd = "ps -ef | grep socat".format(router)
+
+        awk_cmd = "awk -F' ' '{print $2}' | xargs kill -9 &>/dev/null &"
+        cmd = "{} | {}".format(cmd, awk_cmd)
+
+        logger.debug("[DUT: {}]: Running command: [{}]".format(router, cmd))
+        rnode.run(cmd)
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+
 #############################################
 # Verification APIs
 #############################################
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/lutil.py frr-frr-8.5/tests/topotests/grpc_basic/lib/lutil.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/lutil.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/lutil.py	2023-03-13 20:01:47.000000000 +0600
@@ -50,6 +50,7 @@ class lUtil:
     l_line = 0
     l_dotall_experiment = False
     l_last_nl = None
+    l_wait_strict = 1
 
     fout = ""
     fsum = ""
@@ -189,7 +190,7 @@ Total %-4d
             self.log("unable to read: " + tstFile)
             sys.exit(1)
 
-    def command(self, target, command, regexp, op, result, returnJson, startt=None):
+    def command(self, target, command, regexp, op, result, returnJson, startt=None, force_result=False):
         global net
         if op == "jsoncmp_pass" or op == "jsoncmp_fail":
             returnJson = True
@@ -292,7 +293,7 @@ Total %-4d
                     9,
                 )
         if startt != None:
-            if js != None or ret is not False:
+            if js != None or ret is not False or force_result is not False:
                 delta = time.time() - startt
                 self.result(target, success, "%s +%4.2f secs" % (result, delta))
         elif op == "pass" or op == "fail":
@@ -322,12 +323,23 @@ Total %-4d
         n = 0
         startt = time.time()
 
+        if (op == "wait-strict") or ((op == "wait") and self.l_wait_strict):
+            strict = True
+        else:
+            strict = False
+
         # Calculate the amount of `sleep`s we are going to peform.
         wait_count = int(math.ceil(wait / wait_time)) + 1
 
+        force_result = False
         while wait_count > 0:
             n += 1
-            found = self.command(target, command, regexp, op, result, returnJson, startt)
+
+            # log a failure on last iteration if we don't get desired regexp
+            if strict and (wait_count == 1):
+                force_result = True
+
+            found = self.command(target, command, regexp, op, result, returnJson, startt, force_result)
             if found is not False:
                 break
 
@@ -378,12 +390,14 @@ def luCommand(
     returnJson=False,
     wait_time=0.5,
 ):
-    if op != "wait":
-        return LUtil.command(target, command, regexp, op, result, returnJson)
-    else:
+    waitops = ["wait", "wait-strict", "wait-nostrict"]
+
+    if op in waitops:
         return LUtil.wait(
             target, command, regexp, op, result, time, returnJson, wait_time
         )
+    else:
+        return LUtil.command(target, command, regexp, op, result, returnJson)
 
 
 def luLast(usenl=False):
@@ -454,6 +468,25 @@ def luShowFail():
     if printed > 0:
         logger.error("See %s for details of errors" % LUtil.fout_name)
 
+#
+# Sets default wait type for luCommand(op="wait) (may be overridden by
+# specifying luCommand(op="wait-strict") or luCommand(op="wait-nostrict")).
+#
+# "nostrict" is the historical default behavior, which is to ignore
+# failures to match the specified regexp in the specified time.
+#
+# "strict" means that failure to match the specified regexp in the
+# specified time yields an explicit, logged failure result
+#
+def luSetWaitType(waittype):
+    if waittype == "strict":
+        LUtil.l_wait_strict = 1
+    else:
+        if waittype == "nostrict":
+            LUtil.l_wait_strict = 0
+        else:
+            raise ValueError('waittype must be one of "strict" or "nostrict"')
+
 
 # for testing
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/micronet.py frr-frr-8.5/tests/topotests/grpc_basic/lib/micronet.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/micronet.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/micronet.py	2023-03-13 20:01:47.000000000 +0600
@@ -470,7 +470,8 @@ class LinuxNamespace(Commander):
 
         nslist = []
         cmd = ["/usr/bin/unshare"]
-        flags = "-"
+        flags = ""
+        self.a_flags = []
         self.ifnetns = {}
 
         if cgroup:
@@ -487,6 +488,7 @@ class LinuxNamespace(Commander):
             flags += "n"
         if pid:
             nslist.append("pid")
+            flags += "f"
             flags += "p"
             cmd.append("--mount-proc")
         if time:
@@ -499,9 +501,17 @@ class LinuxNamespace(Commander):
             cmd.append("--keep-caps")
         if uts:
             nslist.append("uts")
-            cmd.append("--uts")
+            flags += "u"
 
-        cmd.append(flags)
+        if flags:
+            aflags = flags.replace("f", "")
+            if aflags:
+                self.a_flags = ["-" + x for x in aflags]
+            cmd.extend(["-" + x for x in flags])
+
+        if pid:
+            cmd.append(commander.get_exec_path("tini"))
+            cmd.append("-vvv")
         cmd.append("/bin/cat")
 
         # Using cat and a stdin PIPE is nice as it will exit when we do. However, we
@@ -516,7 +526,8 @@ class LinuxNamespace(Commander):
             stdin=subprocess.PIPE,
             stdout=open("/dev/null", "w"),
             stderr=open("/dev/null", "w"),
-            preexec_fn=os.setsid,  # detach from pgid so signals don't propogate
+            text=True,
+            start_new_session=True,  # detach from pgid so signals don't propagate
             shell=False,
         )
         self.p = p
@@ -550,7 +561,7 @@ class LinuxNamespace(Commander):
         assert not nslist, "unshare never unshared!"
 
         # Set pre-command based on our namespace proc
-        self.base_pre_cmd = ["/usr/bin/nsenter", "-a", "-t", str(self.pid)]
+        self.base_pre_cmd = ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid)]
         if not pid:
             self.base_pre_cmd.append("-F")
         self.set_pre_cmd(self.base_pre_cmd + ["--wd=" + self.cwd])
@@ -743,7 +754,7 @@ class SharedNamespace(Commander):
     An object that executes commands in an existing pid's linux namespace
     """
 
-    def __init__(self, name, pid, logger=None):
+    def __init__(self, name, pid, aflags=("-a",), logger=None):
         """
         Share a linux namespace.
 
@@ -757,10 +768,11 @@ class SharedNamespace(Commander):
 
         self.pid = pid
         self.intfs = []
+        self.a_flags = aflags
 
         # Set pre-command based on our namespace proc
         self.set_pre_cmd(
-            ["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + self.cwd]
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + self.cwd]
         )
 
     def __str__(self):
@@ -769,7 +781,9 @@ class SharedNamespace(Commander):
     def set_cwd(self, cwd):
         # Set pre-command based on our namespace proc
         self.logger.debug("%s: new CWD %s", self, cwd)
-        self.set_pre_cmd(["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + cwd])
+        self.set_pre_cmd(
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + cwd]
+        )
 
     def register_interface(self, ifname):
         if ifname not in self.intfs:
@@ -800,7 +814,7 @@ class Bridge(SharedNamespace):
             self.brid = "br{}".format(self.brid_ord)
             name = self.brid
 
-        super(Bridge, self).__init__(name, unet.pid, logger)
+        super(Bridge, self).__init__(name, unet.pid, aflags=unet.a_flags, logger=logger)
 
         self.logger.debug("Bridge: Creating")
 
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/ospf.py frr-frr-8.5/tests/topotests/grpc_basic/lib/ospf.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/ospf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/ospf.py	2023-03-13 20:01:47.000000000 +0600
@@ -1533,11 +1533,11 @@ def verify_ospf_summary(tgen, topo, dut,
     -----
     input_dict = {
         "11.0.0.0/8": {
-            "Summary address": "11.0.0.0/8",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5
+            "summaryAddress": "11.0.0.0/8",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5
         }
     }
     result = verify_ospf_summary(tgen, topo, dut, input_dict)
@@ -1586,7 +1586,7 @@ def verify_ospf_summary(tgen, topo, dut,
     for ospf_summ, summ_data in ospf_summary_data.items():
         if ospf_summ not in show_ospf_json:
             continue
-        summary = ospf_summary_data[ospf_summ]["Summary address"]
+        summary = ospf_summary_data[ospf_summ]["summaryAddress"]
 
         if summary in show_ospf_json:
             for summ in summ_data:
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/pim.py frr-frr-8.5/tests/topotests/grpc_basic/lib/pim.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/pim.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/pim.py	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ from lib.common_config import (
     retry,
     run_frr_cmd,
     validate_ip_address,
+    get_frr_ipv6_linklocal,
 )
 from lib.micronet import get_exec_path
 from lib.topolog import logger
@@ -48,7 +49,7 @@ CWD = os.path.dirname(os.path.realpath(_
 
 def create_pim_config(tgen, topo, input_dict=None, build=False, load_config=True):
     """
-    API to configure pim/pimv6 on router
+    API to configure pim/pim6 on router
 
     Parameters
     ----------
@@ -149,7 +150,7 @@ def _add_pim_rp_config(tgen, topo, input
         if "rp" in input_dict[router]["pim"]:
             rp_data += pim_data["rp"]
 
-    # PIMv6
+    # pim6
     pim6_data = None
     if "pim6" in input_dict[router]:
         pim6_data = input_dict[router]["pim6"]
@@ -370,7 +371,7 @@ def create_igmp_config(tgen, topo, input
 
 def create_mld_config(tgen, topo, input_dict=None, build=False):
     """
-    API to configure mld for PIMv6 on router
+    API to configure mld for pim6 on router
 
     Parameters
     ----------
@@ -515,6 +516,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ip pim")
 
+        if "pim" in input_dict[router]:
+            if "disable" in input_dict[router]["pim"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ip pim")
+
         if "pim6" in data and data["pim6"] == "enable":
             # Loopback interfaces
             if "type" in data and data["type"] == "loopback":
@@ -526,6 +540,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ipv6 pim")
 
+        if "pim6" in input_dict[router]:
+            if "disable" in input_dict[router]["pim6"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim6"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ipv6 pim")
+
     # pim global config
     if "pim" in input_dict[router]:
         pim_data = input_dict[router]["pim"]
@@ -797,6 +824,134 @@ def verify_pim_neighbors(tgen, topo, dut
     return True
 
 
+@retry(retry_timeout=12)
+def verify_pim6_neighbors(tgen, topo, dut=None, iface=None, nbr_ip=None, expected=True):
+    """
+    Verify all pim6 neighbors are up and running, config is verified
+    using "show ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `iface` : link for which PIM nbr need to check
+    * `nbr_ip` : neighbor ip of interface
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_pim6_neighbors(tgen, topo, dut, iface=ens192, nbr_ip=20.1.1.2)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if dut is not None and dut != router:
+            continue
+
+        rnode = tgen.routers()[router]
+        show_ip_pim_neighbor_json = rnode.vtysh_cmd(
+            "show ipv6 pim neighbor json", isjson=True
+        )
+
+        for destLink, data in topo["routers"][router]["links"].items():
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if iface is not None and iface != data["interface"]:
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            if "pim6" in data and data["pim6"] == "disable":
+                continue
+
+            if "pim6" in data and data["pim6"] == "enable":
+                local_interface = data["interface"]
+
+            if "-" in destLink:
+                # Spliting and storing destRouterLink data in tempList
+                tempList = destLink.split("-")
+
+                # destRouter
+                destLink = tempList.pop(0)
+
+                # Current Router Link
+                tempList.insert(0, router)
+                curRouter = "-".join(tempList)
+            else:
+                curRouter = router
+            if destLink not in topo["routers"]:
+                continue
+            data = topo["routers"][destLink]["links"][curRouter]
+            peer_interface = data["interface"]
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            logger.info("[DUT: %s]: Verifying PIM neighbor status:", router)
+
+            if "pim6" in data and data["pim6"] == "enable":
+                pim_nh_intf_ip = get_frr_ipv6_linklocal(tgen, destLink, peer_interface)
+
+                # Verifying PIM neighbor
+                if local_interface in show_ip_pim_neighbor_json:
+                    if show_ip_pim_neighbor_json[local_interface]:
+                        if (
+                            show_ip_pim_neighbor_json[local_interface][pim_nh_intf_ip][
+                                "neighbor"
+                            ]
+                            != pim_nh_intf_ip
+                        ):
+                            errormsg = (
+                                "[DUT %s]: Local interface: %s, PIM6"
+                                " neighbor check failed "
+                                "Expected neighbor: %s, Found neighbor:"
+                                " %s"
+                                % (
+                                    router,
+                                    local_interface,
+                                    pim_nh_intf_ip,
+                                    show_ip_pim_neighbor_json[local_interface][
+                                        pim_nh_intf_ip
+                                    ]["neighbor"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: Local interface: %s, Found"
+                            " expected PIM6 neighbor %s",
+                            router,
+                            local_interface,
+                            pim_nh_intf_ip,
+                        )
+                    else:
+                        errormsg = (
+                            "[DUT %s]: Local interface: %s, and"
+                            "interface ip: %s is not found in "
+                            "PIM6 neighbor " % (router, local_interface, pim_nh_intf_ip)
+                        )
+                        return errormsg
+                else:
+                    errormsg = (
+                        "[DUT %s]: Local interface: %s, is not "
+                        "present in PIM6 neighbor " % (router, local_interface)
+                    )
+                    return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_igmp_groups(tgen, dut, interface, group_addresses, expected=True):
     """
@@ -871,7 +1026,7 @@ def verify_igmp_groups(tgen, dut, interf
     return True
 
 
-@retry(retry_timeout=60, diag_pct=0)
+@retry(retry_timeout=60, diag_pct=2)
 def verify_upstream_iif(
     tgen,
     dut,
@@ -879,7 +1034,9 @@ def verify_upstream_iif(
     src_address,
     group_addresses,
     joinState=None,
+    regState=None,
     refCount=1,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -910,7 +1067,6 @@ def verify_upstream_iif(
     -------
     errormsg(str) or True
     """
-
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     if dut not in tgen.routers():
@@ -919,7 +1075,8 @@ def verify_upstream_iif(
     rnode = tgen.routers()[dut]
 
     logger.info(
-        "[DUT: %s]: Verifying upstream Inbound Interface" " for IGMP groups received:",
+        "[DUT: %s]: Verifying upstream Inbound Interface"
+        " for IGMP/MLD groups received:",
         dut,
     )
 
@@ -979,16 +1136,18 @@ def verify_upstream_iif(
                         if group_addr_json[src_address]["joinState"] != "Joined":
                             errormsg = (
                                 "[DUT %s]: Verifying iif "
-                                "(Inbound Interface) for (%s,%s) and"
-                                " joinState :%s [FAILED]!! "
-                                " Expected: %s, Found: %s"
+                                "(Inbound Interface) and joinState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "joinState :%s , Found joinState: %s"
                                 % (
                                     dut,
                                     src_address,
                                     grp_addr,
-                                    group_addr_json[src_address]["joinState"],
                                     in_interface,
                                     group_addr_json[src_address]["inboundInterface"],
+                                    joinState,
+                                    group_addr_json[src_address]["joinState"],
                                 )
                             )
                             return errormsg
@@ -996,28 +1155,51 @@ def verify_upstream_iif(
                     elif group_addr_json[src_address]["joinState"] != joinState:
                         errormsg = (
                             "[DUT %s]: Verifying iif "
-                            "(Inbound Interface) for (%s,%s) and"
-                            " joinState :%s [FAILED]!! "
-                            " Expected: %s, Found: %s"
+                            "(Inbound Interface) and joinState "
+                            "for (%s, %s), Expected iif: %s, "
+                            "Found iif : %s,  and Expected "
+                            "joinState :%s , Found joinState: %s"
                             % (
                                 dut,
                                 src_address,
                                 grp_addr,
-                                group_addr_json[src_address]["joinState"],
                                 in_interface,
                                 group_addr_json[src_address]["inboundInterface"],
+                                joinState,
+                                group_addr_json[src_address]["joinState"],
                             )
                         )
                         return errormsg
 
+                    if regState:
+                        if group_addr_json[src_address]["regState"] != regState:
+                            errormsg = (
+                                "[DUT %s]: Verifying iif "
+                                "(Inbound Interface) and regState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "regState :%s , Found regState: %s"
+                                % (
+                                    dut,
+                                    src_address,
+                                    grp_addr,
+                                    in_interface,
+                                    group_addr_json[src_address]["inboundInterface"],
+                                    regState,
+                                    group_addr_json[src_address]["regState"],
+                                )
+                            )
+                            return errormsg
+
                     logger.info(
                         "[DUT %s]: Verifying iif(Inbound Interface)"
-                        " for (%s,%s) and joinState is %s [PASSED]!! "
+                        " for (%s,%s) and joinState is %s regstate is %s [PASSED]!! "
                         " Found Expected: (%s)",
                         dut,
                         src_address,
                         grp_addr,
                         group_addr_json[src_address]["joinState"],
+                        group_addr_json[src_address]["regState"],
                         group_addr_json[src_address]["inboundInterface"],
                     )
         if not found:
@@ -1036,13 +1218,13 @@ def verify_upstream_iif(
             )
             return errormsg
 
-        logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
-        return True
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
 
 
 @retry(retry_timeout=12)
 def verify_join_state_and_timer(
-    tgen, dut, iif, src_address, group_addresses, expected=True
+    tgen, dut, iif, src_address, group_addresses, addr_type="ipv4", expected=True
 ):
     """
     Verify  join state is updated correctly and join timer is
@@ -1178,6 +1360,7 @@ def verify_mroutes(
     oil,
     return_uptime=False,
     mwait=0,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1393,6 +1576,7 @@ def verify_pim_rp_info(
     rp=None,
     source=None,
     iamrp=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1578,6 +1762,7 @@ def verify_pim_state(
     group_addresses,
     src_address=None,
     installed_fl=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1642,12 +1827,12 @@ def verify_pim_state(
         else:
             pim_state_json = show_pim_state_json[grp_addr][src_address]
 
-        if pim_state_json["Installed"] == installed_fl:
+        if pim_state_json["installed"] == installed_fl:
             logger.info(
                 "[DUT %s]: group  %s is installed flag: %s",
                 dut,
                 grp_addr,
-                pim_state_json["Installed"],
+                pim_state_json["installed"],
             )
             for interface, data in pim_state_json[iif].items():
                 if interface != oil:
@@ -1697,7 +1882,7 @@ def verify_pim_state(
 
 def get_pim_interface_traffic(tgen, input_dict):
     """
-    get ip pim interface traffice by running
+    get ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -1768,9 +1953,82 @@ def get_pim_interface_traffic(tgen, inpu
     return output_dict
 
 
+def get_pim6_interface_traffic(tgen, input_dict):
+    """
+    get ipv6 pim interface traffic by running
+    "show ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict(dict)`: defines DUT, what and from which interfaces
+                          traffic needs to be retrieved
+    Usage
+    -----
+    input_dict = {
+        "r1": {
+            "r1-r0-eth0": {
+                "helloRx": 0,
+                "helloTx": 1,
+                "joinRx": 0,
+                "joinTx": 0
+            }
+        }
+    }
+
+    result = get_pim_interface_traffic(tgen, input_dict)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    output_dict = {}
+    for dut in input_dict.keys():
+        if dut not in tgen.routers():
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Verifying pim interface traffic", dut)
+
+        def show_pim_intf_traffic(rnode, dut, input_dict, output_dict):
+            show_pim_intf_traffic_json = run_frr_cmd(
+                rnode, "show ipv6 pim interface traffic json", isjson=True
+            )
+
+            output_dict[dut] = {}
+            for intf, data in input_dict[dut].items():
+                interface_json = show_pim_intf_traffic_json[intf]
+                for state in data:
+
+                    # Verify Tx/Rx
+                    if state in interface_json:
+                        output_dict[dut][state] = interface_json[state]
+                    else:
+                        errormsg = (
+                            "[DUT %s]: %s is not present"
+                            "for interface %s [FAILED]!! " % (dut, state, intf)
+                        )
+                        return errormsg
+            return None
+
+        test_func = functools.partial(
+            show_pim_intf_traffic, rnode, dut, input_dict, output_dict
+        )
+        (result, out) = topotest.run_and_expect(test_func, None, count=20, wait=1)
+        if not result:
+            return out
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return output_dict
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_pim_interface(
-    tgen, topo, dut, interface=None, interface_ip=None, expected=True
+    tgen, topo, dut, interface=None, interface_ip=None, addr_type="ipv4", expected=True
 ):
     """
     Verify all PIM interface are up and running, config is verified
@@ -1803,29 +2061,48 @@ def verify_pim_interface(
         logger.info("[DUT: %s]: Verifying PIM interface status:", dut)
 
         rnode = tgen.routers()[dut]
-        show_ip_pim_interface_json = rnode.vtysh_cmd(
-            "show ip pim interface json", isjson=True
+
+        if addr_type == "ipv4":
+            addr_cmd = "ip"
+            pim_cmd = "pim"
+        elif addr_type == "ipv6":
+            addr_cmd = "ipv6"
+            pim_cmd = "pim6"
+        show_pim_interface_json = rnode.vtysh_cmd(
+            "show {} pim interface json".format(addr_cmd), isjson=True
         )
 
-        logger.info("show_ip_pim_interface_json: \n %s", show_ip_pim_interface_json)
+        logger.info("show_pim_interface_json: \n %s", show_pim_interface_json)
 
         if interface_ip:
-            if interface in show_ip_pim_interface_json:
-                pim_intf_json = show_ip_pim_interface_json[interface]
+            if interface in show_pim_interface_json:
+                pim_intf_json = show_pim_interface_json[interface]
                 if pim_intf_json["address"] != interface_ip:
                     errormsg = (
-                        "[DUT %s]: PIM interface "
-                        "ip is not correct "
+                        "[DUT %s]: %s interface "
+                        "%s is not correct "
                         "[FAILED]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return errormsg
                 else:
                     logger.info(
-                        "[DUT %s]: PIM interface "
-                        "ip is correct "
+                        "[DUT %s]: %s interface "
+                        "%s is correct "
                         "[Passed]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return True
         else:
@@ -1833,17 +2110,17 @@ def verify_pim_interface(
                 if "type" in data and data["type"] == "loopback":
                     continue
 
-                if "pim" in data and data["pim"] == "enable":
+                if pim_cmd in data and data[pim_cmd] == "enable":
                     pim_interface = data["interface"]
-                    pim_intf_ip = data["ipv4"].split("/")[0]
+                    pim_intf_ip = data[addr_type].split("/")[0]
 
-                    if pim_interface in show_ip_pim_interface_json:
-                        pim_intf_json = show_ip_pim_interface_json[pim_interface]
+                    if pim_interface in show_pim_interface_json:
+                        pim_intf_json = show_pim_interface_json[pim_interface]
                     else:
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, not Found"
-                            % (dut, pim_interface, pim_intf_ip)
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, not Found"
+                            % (dut, pim_cmd, pim_interface, addr_cmd, pim_intf_ip)
                         )
                         return errormsg
 
@@ -1853,12 +2130,14 @@ def verify_pim_interface(
                         and pim_intf_json["state"] != "up"
                     ):
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, status check "
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, status check "
                             "[FAILED]!! Expected : %s, Found : %s"
                             % (
                                 dut,
+                                pim_cmd,
                                 pim_interface,
+                                addr_cmd,
                                 pim_intf_ip,
                                 pim_interface,
                                 pim_intf_json["state"],
@@ -1867,11 +2146,13 @@ def verify_pim_interface(
                         return errormsg
 
                     logger.info(
-                        "[DUT %s]: PIM interface: %s, "
-                        "interface ip: %s, status: %s"
+                        "[DUT %s]: %s interface: %s, "
+                        "interface %s: %s, status: %s"
                         " [PASSED]!!",
                         dut,
+                        pim_cmd,
                         pim_interface,
+                        addr_cmd,
                         pim_intf_ip,
                         pim_intf_json["state"],
                     )
@@ -1882,8 +2163,8 @@ def verify_pim_interface(
 
 def clear_pim_interface_traffic(tgen, topo):
     """
-    Clear ip/ipv6 pim interface traffice by running
-    "clear ip/ipv6 pim interface traffic" cli
+    Clear ip pim interface traffic by running
+    "clear ip pim interface traffic" cli
 
     Parameters
     ----------
@@ -1914,6 +2195,74 @@ def clear_pim_interface_traffic(tgen, to
     return True
 
 
+def clear_pim6_interface_traffic(tgen, topo):
+    """
+    Clear ipv6 pim interface traffic by running
+    "clear ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interface_traffic(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interface traffic", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface traffic")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
+def clear_pim6_interfaces(tgen, topo):
+    """
+    Clear ipv6 pim interface by running
+    "clear ipv6 pim interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interfaces(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interfaces", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def clear_pim_interfaces(tgen, dut):
     """
     Clear ip/ipv6 pim interface by running
@@ -1961,8 +2310,8 @@ def clear_pim_interfaces(tgen, dut):
     # Waiting for maximum 60 sec
     fail_intf = []
     for retry in range(1, 13):
-        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         sleep(5)
+        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         run_json_after = run_frr_cmd(rnode, "show ip pim neighbor json", isjson=True)
         found = True
         for pim_intf in nh_before_clear.keys():
@@ -2212,6 +2561,35 @@ def clear_mroute(tgen, dut=None):
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
+def clear_pim6_mroute(tgen, dut=None):
+    """
+    Clear ipv6 mroute by running "clear ipv6 mroute" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test, default None
+
+    Usage
+    -----
+    clear_mroute(tgen, dut)
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        logger.debug("[DUT: %s]: Clearing ipv6 mroute", router)
+        rnode.vtysh_cmd("clear ipv6 mroute")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def reconfig_interfaces(tgen, topo, senderRouter, receiverRouter, packet=None):
     """
     Configure interface ip for sender and receiver routers
@@ -2812,7 +3190,14 @@ def enable_disable_pim_bsm(tgen, router,
 
 @retry(retry_timeout=60, diag_pct=0)
 def verify_pim_join(
-    tgen, topo, dut, interface, group_addresses, src_address=None, expected=True
+    tgen,
+    topo,
+    dut,
+    interface,
+    group_addresses,
+    src_address=None,
+    addr_type="ipv4",
+    expected=True,
 ):
     """
     Verify ip/ipv6 pim join by running "show ip/ipv6 pim join" cli
@@ -2846,11 +3231,22 @@ def verify_pim_join(
     rnode = tgen.routers()[dut]
 
     logger.info("[DUT: %s]: Verifying pim join", dut)
-    show_pim_join_json = run_frr_cmd(rnode, "show ip pim join json", isjson=True)
 
     if type(group_addresses) is not list:
         group_addresses = [group_addresses]
 
+    for grp in group_addresses:
+        addr_type = validate_ip_address(grp)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    show_pim_join_json = run_frr_cmd(
+        rnode, "show {} pim join json".format(ip_cmd), isjson=True
+    )
+
     for grp_addr in group_addresses:
         # Verify if IGMP is enabled in DUT
         if "igmp" not in topo["routers"][dut]:
@@ -3660,7 +4056,7 @@ def verify_multicast_flag_state(
 
 
 @retry(retry_timeout=40, diag_pct=0)
-def verify_igmp_interface(tgen, topo, dut, igmp_iface, interface_ip, expected=True):
+def verify_igmp_interface(tgen, dut, igmp_iface, interface_ip, expected=True):
     """
     Verify all IGMP interface are up and running, config is verified
     using "show ip igmp interface" cli
@@ -3884,7 +4280,7 @@ def verify_local_igmp_groups(tgen, dut,
 
 def verify_pim_interface_traffic(tgen, input_dict, return_stats=True, addr_type="ipv4"):
     """
-    Verify ip pim interface traffice by running
+    Verify ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -3950,6 +4346,661 @@ def verify_pim_interface_traffic(tgen, i
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
     return True if return_stats == False else output_dict
 
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_groups(tgen, dut, interface, group_addresses, expected=True):
+    """
+    Verify IGMP groups are received from an intended interface
+    by running "show ip mld groups" command
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `interface`: interface, from which MLD groups would be received
+    * `group_addresses`: MLD group address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    dut = "r1"
+    interface = "r1-r0-eth0"
+    group_address = "ffaa::1"
+    result = verify_mld_groups(tgen, dut, interface, group_address)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mld groups received:", dut)
+    show_mld_json = run_frr_cmd(rnode, "show ipv6 mld groups json", isjson=True)
+
+    if type(group_addresses) is not list:
+        group_addresses = [group_addresses]
+
+    if interface in show_mld_json:
+        show_mld_json = show_mld_json[interface]["groups"]
+    else:
+        errormsg = (
+            "[DUT %s]: Verifying MLD group received"
+            " from interface %s [FAILED]!! " % (dut, interface)
+        )
+        return errormsg
+
+    found = False
+    for grp_addr in group_addresses:
+        for index in show_mld_json:
+            if index["group"] == grp_addr:
+                found = True
+                break
+        if found is not True:
+            errormsg = (
+                "[DUT %s]: Verifying MLD group received"
+                " from interface %s [FAILED]!! "
+                " Expected not found: %s" % (dut, interface, grp_addr)
+            )
+            return errormsg
+
+        logger.info(
+            "[DUT %s]: Verifying MLD group %s received "
+            "from interface %s [PASSED]!! ",
+            dut,
+            grp_addr,
+            interface,
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_interface(tgen, dut, mld_iface, interface_ip, expected=True):
+    """
+    Verify all IGMP interface are up and running, config is verified
+    using "show ip mld interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : device under test
+    * `mld_iface` : interface name
+    * `interface_ip` : interface ip address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_mld_interface(tgen, topo, dut, mld_iface, interface_ip)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if router != dut:
+            continue
+
+        logger.info("[DUT: %s]: Verifying MLD interface status:", dut)
+
+        rnode = tgen.routers()[dut]
+        show_mld_interface_json = run_frr_cmd(
+            rnode, "show ipv6 mld interface json", isjson=True
+        )
+
+        if mld_iface in show_mld_interface_json:
+            mld_intf_json = show_mld_interface_json[mld_iface]
+            # Verifying igmp interface
+            if mld_intf_json["address"] != interface_ip:
+                errormsg = (
+                    "[DUT %s]: igmp interface ip is not correct "
+                    "[FAILED]!! Expected : %s, Found : %s"
+                    % (dut, mld_intf_json["address"], interface_ip)
+                )
+                return errormsg
+
+            logger.info(
+                "[DUT %s]: igmp interface: %s, " "interface ip: %s" " [PASSED]!!",
+                dut,
+                mld_iface,
+                interface_ip,
+            )
+        else:
+            errormsg = (
+                "[DUT %s]: igmp interface: %s "
+                "igmp interface ip: %s, is not present "
+                % (dut, mld_iface, interface_ip)
+            )
+            return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mld_config(tgen, input_dict, stats_return=False, expected=True):
+    """
+    Verify mld interface details, verifying following configs:
+    timerQueryInterval
+    timerQueryResponseIntervalMsec
+    lastMemberQueryCount
+    timerLastMemberQueryMsec
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict` : Input dict data, required to verify
+                     timer
+    * `stats_return`: If user wants API to return statistics
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    input_dict ={
+        "l1": {
+            "mld": {
+                "interfaces": {
+                    "l1-i1-eth1": {
+                        "mld": {
+                            "query": {
+                                "query-interval" : 200,
+                                "query-max-response-time" : 100
+                            },
+                            "statistics": {
+                                "queryV2" : 2,
+                                "reportV2" : 1
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    result = verify_mld_config(tgen, input_dict, stats_return)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in input_dict.keys():
+        rnode = tgen.routers()[dut]
+
+        for interface, data in input_dict[dut]["igmp"]["interfaces"].items():
+
+            statistics = False
+            report = False
+            if "statistics" in input_dict[dut]["igmp"]["interfaces"][interface]["igmp"]:
+                statistics = True
+                cmd = "show ipv6 mld statistics"
+            else:
+                cmd = "show ipv6 mld"
+
+            logger.info("[DUT: %s]: Verifying MLD interface %s detail:", dut, interface)
+
+            if statistics:
+                if (
+                    "report"
+                    in input_dict[dut]["mld"]["interfaces"][interface]["mld"][
+                        "statistics"
+                    ]
+                ):
+                    report = True
+
+            if statistics and report:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} json".format(cmd), isjson=True
+                )
+                intf_detail_json = show_ipv6_mld_intf_json["global"]
+            else:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} interface {} json".format(cmd, interface), isjson=True
+                )
+
+            if not report:
+                if interface not in show_ipv6_mld_intf_json:
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " is not present in CLI output "
+                        "[FAILED]!! " % (dut, interface)
+                    )
+                    return errormsg
+
+                else:
+                    intf_detail_json = show_ipv6_mld_intf_json[interface]
+
+            if stats_return:
+                mld_stats = {}
+
+            if "statistics" in data["mld"]:
+                if stats_return:
+                    mld_stats["statistics"] = {}
+                for query, value in data["mld"]["statistics"].items():
+                    if query == "queryV1":
+                        # Verifying IGMP interface queryV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json["queryV1"]
+
+                        else:
+                            if intf_detail_json["queryV1"] != value:
+                                errormsg = (
+                                    "[DUT %s]: MLD interface: %s "
+                                    " queryV1 statistics verification "
+                                    "[FAILED]!! Expected : %s,"
+                                    " Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                        intf_detail_json["queryV1"],
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD interface: %s "
+                                "queryV1 statistics is %s",
+                                dut,
+                                interface,
+                                value,
+                            )
+
+                    if query == "reportV1":
+                        # Verifying IGMP interface timerV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json[
+                                "reportV1"
+                            ]
+
+                        else:
+                            if intf_detail_json["reportV1"] <= value:
+                                errormsg = (
+                                    "[DUT %s]: MLD reportV1 "
+                                    "statistics verification "
+                                    "[FAILED]!! Expected : %s "
+                                    "or more, Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD reportV1 " "statistics is %s",
+                                dut,
+                                intf_detail_json["reportV1"],
+                            )
+
+            if "query" in data["mld"]:
+                for query, value in data["mld"]["query"].items():
+                    if query == "query-interval":
+                        # Verifying IGMP interface query interval timer
+                        if intf_detail_json["timerQueryInterval"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                " query-interval verification "
+                                "[FAILED]!! Expected : %s,"
+                                " Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["timerQueryInterval"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s " "query-interval is %s",
+                            dut,
+                            interface,
+                            value,
+                        )
+
+                    if query == "query-max-response-time":
+                        # Verifying IGMP interface query max response timer
+                        if (
+                            intf_detail_json["timerQueryResponseIntervalMsec"]
+                            != value * 100
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "query-max-response-time "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerQueryResponseIntervalMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "query-max-response-time is %s ms",
+                            dut,
+                            interface,
+                            value * 100,
+                        )
+
+                    if query == "last-member-query-count":
+                        # Verifying IGMP interface last member query count
+                        if intf_detail_json["lastMemberQueryCount"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-count "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["lastMemberQueryCount"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-count is %s ms",
+                            dut,
+                            interface,
+                            value * 1000,
+                        )
+
+                    if query == "last-member-query-interval":
+                        # Verifying IGMP interface last member query interval
+                        if (
+                            intf_detail_json["timerLastMemberQueryMsec"]
+                            != value * 100 * intf_detail_json["lastMemberQueryCount"]
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-interval "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerLastMemberQueryMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-interval is %s ms",
+                            dut,
+                            interface,
+                            value * intf_detail_json["lastMemberQueryCount"] * 100,
+                        )
+
+            if "version" in data["mld"]:
+                # Verifying IGMP interface state is up
+                if intf_detail_json["state"] != "up":
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " state: %s verification "
+                        "[FAILED]!!" % (dut, interface, intf_detail_json["state"])
+                    )
+                    return errormsg
+
+                logger.info(
+                    "[DUT %s]: MLD interface: %s " "state: %s",
+                    dut,
+                    interface,
+                    intf_detail_json["state"],
+                )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True if stats_return == False else mld_stats
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_pim_nexthop(tgen, topo, dut, nexthop, addr_type):
+    """
+    Verify all PIM nexthop details using "show ip/ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `nexthop` : nexthop ip/ipv6 address
+
+    Usage
+    -----
+    result = verify_pim_nexthop(tgen, topo, dut, nexthop)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[dut]
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} pim nexthop".format(addr_type)
+    pim_nexthop = rnode.vtysh_cmd(cmd)
+
+    if nexthop in pim_nexthop:
+        logger.info("[DUT %s]: Expected nexthop: %s, Found", dut, nexthop)
+        return True
+    else:
+        errormsg = "[DUT %s]: Nexthop not found: %s" % (dut, nexthop)
+        return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mroute_summary(
+    tgen, dut, sg_mroute=None, starg_mroute=None, total_mroute=None, addr_type="ipv4"
+):
+    """
+    Verify ip mroute summary has correct (*,g) (s,G) and total mroutes
+    by running "show ip mroutes summary json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `sg_mroute`: Number of installed (s,g) mroute
+    * `starg_mroute`: Number installed of (*,g) mroute
+    * `Total_mroute`: Total number of installed mroutes
+    * 'addr_type : IPv4 or IPv6 address
+    * `return_json`: Whether to return raw json data
+
+    Usage
+    -----
+    dut = "r1"
+    sg_mroute = "4000"
+    starg_mroute= "2000"
+    total_mroute = "6000"
+    addr_type=IPv4 or IPv6
+    result = verify_mroute_summary(tgen, dut, sg_mroute=None, starg_mroute=None,
+                                        total_mroute= None)
+    Returns
+    -------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mroute summary", dut)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} mroute summary json".format(ip_cmd)
+    show_mroute_summary_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if starg_mroute is not None:
+        if show_mroute_summary_json["wildcardGroup"]["installed"] != starg_mroute:
+            logger.error(
+                "Number of installed starg are: %s but expected: %s",
+                show_mroute_summary_json["wildcardGroup"]["installed"],
+                starg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed starg routes are %s",
+            show_mroute_summary_json["wildcardGroup"]["installed"],
+        )
+
+    if sg_mroute is not None:
+        if show_mroute_summary_json["sourceGroup"]["installed"] != sg_mroute:
+            logger.error(
+                "Number of installed SG routes are: %s but expected: %s",
+                show_mroute_summary_json["sourceGroup"]["installed"],
+                sg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed SG routes are %s",
+            show_mroute_summary_json["sourceGroup"]["installed"],
+        )
+
+    if total_mroute is not None:
+        if show_mroute_summary_json["totalNumOfInstalledMroutes"] != total_mroute:
+            logger.error(
+                "Total number of installed mroutes are: %s but expected: %s",
+                show_mroute_summary_json["totalNumOfInstalledMroutes"],
+                total_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed Total mroute are %s",
+            show_mroute_summary_json["totalNumOfInstalledMroutes"],
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def verify_sg_traffic(tgen, dut, groups, src, addr_type="ipv4"):
+    """
+    Verify multicast traffic by running
+    "show ip mroute count json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `groups`: igmp or mld groups where traffic needs to be verified
+
+    Usage
+    -----
+    result = verify_sg_traffic(tgen, "r1", igmp_groups, srcaddress)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+    result = False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying multicast " "SG traffic", dut)
+
+    if addr_type == "ipv4":
+        cmd = "show ip mroute count json"
+    elif addr_type == "ipv6":
+        cmd = "show ipv6 mroute count json"
+    # import pdb; pdb.set_trace()
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if bool(show_mroute_sg_traffic_json) is False:
+        errormsg = "[DUT %s]: Json output is empty" % (dut)
+        return errormsg
+
+    before_traffic = {}
+    after_traffic = {}
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        before_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    logger.info("Waiting for 10sec traffic to increament")
+    sleep(10)
+
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        after_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    for grp in groups:
+        if after_traffic[grp] < before_traffic[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying igmp group %s source %s not increamenting traffic"
+                " [FAILED]!! " % (dut, grp, src)
+            )
+            return errormsg
+        else:
+            logger.info(
+                "[DUT %s]:igmp group %s source %s receiving traffic"
+                " [PASSED]!! " % (dut, grp, src)
+            )
+            result = True
+
+    return result
+
     # def cleanup(self):
     #     super(McastTesterHelper, self).cleanup()
 
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/snmptest.py frr-frr-8.5/tests/topotests/grpc_basic/lib/snmptest.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/snmptest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/snmptest.py	2023-03-13 20:01:47.000000000 +0600
@@ -36,11 +36,12 @@ from lib.topolog import logger
 class SnmpTester(object):
     "A helper class for testing SNMP"
 
-    def __init__(self, router, iface, community, version):
+    def __init__(self, router, iface, community, version, options=""):
         self.community = community
         self.version = version
         self.router = router
         self.iface = iface
+        self.options = options
         logger.info(
             "created SNMP tester: SNMPv{0} community:{1}".format(
                 self.version, self.community
@@ -52,7 +53,9 @@ class SnmpTester(object):
         Helper function to build a string with SNMP
         configuration for commands.
         """
-        return "-v {0} -c {1} {2}".format(self.version, self.community, self.iface)
+        return "-v {0} -c {1} {2} {3}".format(
+            self.version, self.community, self.options, self.iface
+        )
 
     @staticmethod
     def _get_snmp_value(snmp_output):
diff -urpN frr-frr-8.4.2/tests/topotests/grpc_basic/lib/topotest.py frr-frr-8.5/tests/topotests/grpc_basic/lib/topotest.py
--- frr-frr-8.4.2/tests/topotests/grpc_basic/lib/topotest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/grpc_basic/lib/topotest.py	2023-03-13 20:01:47.000000000 +0600
@@ -355,6 +355,16 @@ def run_and_expect(func, what, count=20,
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum {} tries)".format(
             func_name, wait, count
@@ -402,6 +412,16 @@ def run_and_expect_type(func, etype, cou
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum wait {} secs)".format(
             func_name, wait, int(wait * count)
@@ -1868,15 +1888,16 @@ class Router(Node):
                 # Exclude empty string at end of list
                 for d in dmns[:-1]:
                     if re.search(r"%s" % daemon, d):
-                        daemonpid = self.cmd("cat %s" % d.rstrip()).rstrip()
+                        daemonpidfile = d.rstrip()
+                        daemonpid = self.cmd("cat %s" % daemonpidfile).rstrip()
                         if daemonpid.isdigit() and pid_exists(int(daemonpid)):
                             logger.info(
                                 "{}: killing {}".format(
                                     self.name,
-                                    os.path.basename(d.rstrip().rsplit(".", 1)[0]),
+                                    os.path.basename(daemonpidfile.rsplit(".", 1)[0]),
                                 )
                             )
-                            self.cmd("kill -9 %s" % daemonpid)
+                            os.kill(int(daemonpid), signal.SIGKILL)
                             if pid_exists(int(daemonpid)):
                                 numRunning += 1
                         while wait and numRunning > 0:
@@ -1902,12 +1923,12 @@ class Router(Node):
                                                 ),
                                             )
                                         )
-                                        self.cmd("kill -9 %s" % daemonpid)
+                                        os.kill(int(daemonpid), signal.SIGKILL)
                                     if daemonpid.isdigit() and not pid_exists(
                                         int(daemonpid)
                                     ):
                                         numRunning -= 1
-                        self.cmd("rm -- {}".format(d.rstrip()))
+                        self.cmd("rm -- {}".format(daemonpidfile))
                     if wait:
                         errors = self.checkRouterCores(reportOnce=True)
                         if self.checkRouterVersion("<", minErrorVersion):
diff -urpN frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/bfdd.conf frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+hostname rt1
+!
+bfd
+!
diff -urpN frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/step15/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/step15/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/step15/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/step15/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,50 @@
+--- a/rt1/step14/show_ipv6_route.ref
++++ b/rt1/step15/show_ipv6_route.ref
+@@ -6,22 +6,12 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":25,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+           "afi":"ipv6",
+-          "interfaceName":"eth-rt2",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+           "interfaceName":"eth-rt3",
+           "active":true
+         }
+@@ -151,22 +141,12 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":25,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+           "afi":"ipv6",
+-          "interfaceName":"eth-rt2",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+           "interfaceName":"eth-rt6",
+           "active":true
+         }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/step16/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/step16/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt1/step16/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt1/step16/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,53 @@
+--- a/rt1/step15/show_ipv6_route.ref
++++ b/rt1/step16/show_ipv6_route.ref
+@@ -32,16 +32,6 @@
+           "fib":true,
+           "afi":"ipv6",
+           "interfaceName":"eth-rt3",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt2",
+           "active":true
+         }
+       ]
+@@ -90,16 +80,6 @@
+           "fib":true,
+           "afi":"ipv6",
+           "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt2",
+           "active":true
+         }
+       ]
+@@ -119,16 +99,6 @@
+           "fib":true,
+           "afi":"ipv6",
+           "interfaceName":"eth-rt6",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt2",
+           "active":true
+         }
+       ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt2/bfdd.conf frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt2/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/rt2/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_lfa_topo1/rt2/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+hostname rt2
+!
+bfd
+!
diff -urpN frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/test_isis_lfa_topo1.py frr-frr-8.5/tests/topotests/isis_lfa_topo1/test_isis_lfa_topo1.py
--- frr-frr-8.4.2/tests/topotests/isis_lfa_topo1/test_isis_lfa_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_lfa_topo1/test_isis_lfa_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -55,6 +55,7 @@ import os
 import sys
 import pytest
 import json
+import time
 import tempfile
 from functools import partial
 
@@ -128,7 +129,7 @@ def build_topo(tgen):
     files = ["show_ipv6_route.ref", "show_yang_interface_isis_adjacencies.ref"]
     for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6", "rt7"]:
         outputs[rname] = {}
-        for step in range(1, 13 + 1):
+        for step in range(1, 16 + 1):
             outputs[rname][step] = {}
             for file in files:
                 if step == 1:
@@ -174,6 +175,9 @@ def setup_module(mod):
         router.load_config(
             TopoRouter.RD_ISIS, os.path.join(CWD, "{}/isisd.conf".format(rname))
         )
+        router.load_config(
+            TopoRouter.RD_BFD, os.path.join(CWD, "/dev/null".format(rname))
+        )
 
     tgen.start_router()
 
@@ -186,7 +190,7 @@ def teardown_module(mod):
     tgen.stop_topology()
 
 
-def router_compare_json_output(rname, command, reference):
+def router_compare_json_output(rname, command, reference, wait=0.5, count=120):
     "Compare router JSON output"
 
     logger.info('Comparing router "%s" "%s" output', rname, command)
@@ -196,7 +200,7 @@ def router_compare_json_output(rname, co
 
     # Run test function until we get an result. Wait at most 60 seconds.
     test_func = partial(topotest.router_json_cmp, tgen.gears[rname], command, expected)
-    _, diff = topotest.run_and_expect(test_func, None, count=120, wait=0.5)
+    _, diff = topotest.run_and_expect(test_func, None, count=count, wait=wait)
     assertmsg = '"{}" JSON output mismatches the expected result'.format(rname)
     assert diff is None, assertmsg
 
@@ -616,6 +620,470 @@ def test_rib_ipv6_step13():
         )
 
 
+#
+# Step 14
+#
+# Action(s):
+# - Setting spf-delay-ietf init-delay of 15s
+#
+# Expected changes:
+# - No routing table change
+# - At the end of test, SPF reacts to a failure in 15s
+#
+def test_rib_ipv6_step14():
+    logger.info("Test (step 14): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Setting spf-delay-ietf init-delay of 15s")
+    tgen.net["rt1"].cmd(
+        'vtysh -c "conf t" -c "router isis 1" -c "spf-delay-ietf init-delay 15000 short-delay 0 long-delay 0 holddown 0 time-to-learn 0"'
+    )
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][14]["show_ipv6_route.ref"],
+        )
+
+
+#
+# Step 15
+#
+# Action(s):
+# - shut the eth-rt2 interface on rt1
+#
+# Expected changes:
+# - Route switchover of routes via eth-rt2
+#
+def test_rib_ipv6_step15():
+    logger.info("Test (step 15): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Shut the interface to rt2 from the switch side and check fast-reroute")
+    tgen.net.cmd_raises("ip link set %s down" % tgen.net["s1"].intfs[0])
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][15]["show_ipv6_route.ref"],
+            count=10,
+            wait=0.5,
+        )
+
+
+#
+# Step 16
+#
+# Action(s): wait for the convergence and SPF computation on rt1
+#
+# Expected changes:
+# - convergence of IPv6 RIB
+#
+def test_rib_ipv6_step16():
+    logger.info("Test (step 16): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][16]["show_ipv6_route.ref"],
+        )
+
+
+#
+# Step 17
+#
+# Action(s):
+# - Unshut the interface to rt2 from the switch sid
+#
+# Expected changes:
+# - The routing table converges
+#
+def test_rib_ipv6_step17():
+    logger.info("Test (step 17): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    rname = "rt1"
+
+    logger.info("Unsetting spf-delay-ietf init-delay of 15s")
+    tgen.net[rname].cmd('vtysh -c "conf t" -c "router isis 1" -c "no spf-delay-ietf"')
+
+    logger.info(
+        "Unshut the interface to rt2 from the switch side and check fast-reroute"
+    )
+    tgen.net.cmd_raises("ip link set %s up" % tgen.net["s1"].intfs[0])
+
+    logger.info("Setting spf-delay-ietf init-delay of 15s")
+    tgen.net[rname].cmd(
+        'vtysh -c "conf t" -c "router isis 1" -c "spf-delay-ietf init-delay 15000 short-delay 0 long-delay 0 holddown 0 time-to-learn 0"'
+    )
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][14]["show_ipv6_route.ref"],
+    )
+
+
+#
+# Step 18
+#
+# Action(s):
+# - drop traffic between rt1 and rt2 by shutting down the bridge between
+#   the routers. Interfaces on rt1 and rt2 stay up.
+#
+#
+# Expected changes:
+# - Route switchover of routes via eth-rt2
+#
+def test_rib_ipv6_step18():
+    def _rt2_neigh_down(router):
+        output = json.loads(router.vtysh_cmd("show isis neighbor rt2 json"))
+
+        """
+        Previous output was:
+        {
+          "areas":[
+            {
+              "area":"1",
+              "circuits":[
+                {
+                  "circuit":0,
+                  "adj":"rt2",
+                  "interface":{
+                    "name":"eth-rt2",
+                    "state":"Up",
+                    "adj-flaps":1,
+                    "last-ago":"21s",
+                    "circuit-type":"L1",
+                    "speaks":"IPv6",
+                    "topologies":{
+                      "topo-0":"ipv6-unicast"
+                    },
+                    "snpa":"2020.2020.2020",
+                    "area-address":{
+                      "isonet":"49.0000"
+                    },
+                    "ipv6-link-local":{
+                      "ipv6":"fe80::ac19:a8ff:fee5:f48f"
+                    },
+                    "adj-sid":{
+                    }
+                  },
+                  "level":1,
+                  "expires-in":"2s"
+                },
+                {
+                  "circuit":0
+                },
+                {
+                  "circuit":0
+                },
+                {
+                  "circuit":0
+                },
+                {
+                  "circuit":0
+                },
+                {
+                  "circuit":0
+                }
+              ]
+            }
+          ]
+        """
+
+        expected = {
+            "areas": [
+                {
+                    "area": "1",
+                    "circuits": [
+                        {"circuit": 0},
+                        {"circuit": 0},
+                        {"circuit": 0},
+                        {"circuit": 0},
+                        {"circuit": 0},
+                        {"circuit": 0},
+                    ],
+                }
+            ]
+        }
+
+        return topotest.json_cmp(output, expected, exact=True)
+
+    logger.info("Test (step 18): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Drop traffic between rt1 and rt2")
+    tgen.net.cmd_raises("ip link set s1 down")
+
+    rname = "rt1"
+    router = tgen.gears[rname]
+    test_func = partial(_rt2_neigh_down, router)
+    success, result = topotest.run_and_expect(test_func, None, count=200, wait=0.05)
+    assert result is None, 'rt2 neighbor is still present on "{}"'.format(router)
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][15]["show_ipv6_route.ref"],
+        count=10,
+        wait=0.5,
+    )
+
+
+#
+# Step 19
+#
+# Action(s): wait for the convergence and SPF computation on rt1
+#
+# Expected changes:
+# - convergence of IPv6 RIB
+#
+def test_rib_ipv6_step19():
+    logger.info("Test (step 19): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][16]["show_ipv6_route.ref"],
+        )
+
+
+#
+# Step 20
+#
+# Action(s):
+# - Unshut the switch from rt1 to rt2
+#
+# Expected changes:
+# - The routing table goes back to the nominal state
+#
+def test_rib_ipv6_step20():
+    logger.info("Test (step 20): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    rname = "rt1"
+
+    logger.info("Unsetting spf-delay-ietf init-delay of 15s")
+    tgen.net[rname].cmd('vtysh -c "conf t" -c "router isis 1" -c "no spf-delay-ietf"')
+
+    logger.info(
+        "Unshut the interface to rt2 from the switch side and check fast-reroute"
+    )
+    tgen.net.cmd_raises("ip link set s1 up")
+
+    logger.info("Setting spf-delay-ietf init-delay of 15s")
+    tgen.net[rname].cmd(
+        'vtysh -c "conf t" -c "router isis 1" -c "spf-delay-ietf init-delay 15000 short-delay 0 long-delay 0 holddown 0 time-to-learn 0"'
+    )
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][14]["show_ipv6_route.ref"],
+    )
+
+
+#
+# Step 21
+#
+# Action(s):
+# - clear the rt2 ISIS neighbor on rt1
+#
+# Expected changes:
+# - Route switchover of routes via eth-rt2
+#
+def test_rib_ipv6_step21():
+    logger.info("Test (step 21): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    rname = "rt1"
+
+    logger.info("Clear the rt2 ISIS neighbor on rt1 and check fast-reroute")
+    tgen.gears[rname].vtysh_cmd("clear isis neighbor rt2")
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][15]["show_ipv6_route.ref"],
+        count=10,
+        wait=0.5,
+    )
+
+
+#
+# Step 22
+#
+# Action(s): wait for the convergence and SPF computation on rt1
+#
+# Expected changes:
+# - convergence of IPv6 RIB
+#
+def test_rib_ipv6_step22():
+    logger.info("Test (step 22): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][16]["show_ipv6_route.ref"],
+        )
+
+
+#
+# Step 23
+#
+# Action(s):
+# - Setting BFD
+#
+# Expected changes:
+# - No routing table change
+# - BFD comes up
+#
+def test_rib_ipv6_step23():
+    logger.info("Test (step 23): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Setup BFD on rt1 and rt2")
+    for rname in ["rt1", "rt2"]:
+        conf_file = os.path.join(CWD, "{}/bfdd.conf".format(rname))
+        tgen.net[rname].cmd("vtysh -f {}".format(conf_file))
+
+    logger.info("Set ISIS BFD")
+    tgen.net["rt1"].cmd('vtysh -c "conf t" -c "int eth-rt2" -c "isis bfd"')
+    tgen.net["rt2"].cmd('vtysh -c "conf t" -c "int eth-rt1" -c "isis bfd"')
+
+    rname = "rt1"
+    expect = '[{"multihop":false,"interface":"eth-rt2","status":"up"}]'
+    router_compare_json_output(rname, "show bfd peers json", expect)
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][14]["show_ipv6_route.ref"],
+    )
+
+
+#
+# Step 24
+#
+# Action(s):
+# - drop traffic between rt1 and rt2 by shutting down the bridge between
+#   the routers. Interfaces on rt1 and rt2 stay up.
+#
+# Expected changes:
+# - BFD comes down before IS-IS
+# - Route switchover of routes via eth-rt2
+#
+def test_rib_ipv6_step24():
+    def _bfd_down(router):
+        output = json.loads(router.vtysh_cmd("show bfd peers json"))
+        expected = []
+        return topotest.json_cmp(output, expected, exact=True)
+
+    logger.info("Test (step 24): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Shut the interface to rt2 from the switch side and check fast-reroute")
+    tgen.net.cmd_raises("ip link set s1 down")
+
+    rname = "rt1"
+    router = tgen.gears[rname]
+    test_func = partial(_bfd_down, router)
+    success, result = topotest.run_and_expect(test_func, None, count=30, wait=0.3)
+    assert result is None, 'BFD session is still up on "{}"'.format(router)
+
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][15]["show_ipv6_route.ref"],
+        count=10,
+    )
+
+
+#
+# Step 25
+#
+# Action(s): wait for the convergence and SPF computation on rt1
+#
+# Expected changes:
+# - convergence of IPv6 RIB
+#
+def test_rib_ipv6_step25():
+    logger.info("Test (step 25): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+
+    for rname in ["rt1"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][16]["show_ipv6_route.ref"],
+        )
+
+
 # Memory leak test template
 def test_memory_leak():
     "Run the memory leak test and report results."
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/r1/zebra.conf frr-frr-8.5/tests/topotests/isis_te_topo1/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -10,6 +10,7 @@ interface r1-eth0
  link-params
   metric 20
   delay 10000
+  max-bw 10e+10
   ava-bw 1.25e+08
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/r2/zebra.conf frr-frr-8.5/tests/topotests/isis_te_topo1/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -31,6 +31,7 @@ interface r2-eth3
  link-params
   metric 30
   delay 25000
+  max-bw 10e+10
   use-bw 1.25e+8
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step1.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step1.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step1.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step1.json	2023-03-13 20:01:47.000000000 +0600
@@ -60,32 +60,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:1",
           "remote-address-v6":"2001:db8:1::1:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -101,32 +101,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:2",
           "remote-address-v6":"2001:db8:1::1:1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -142,32 +142,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -184,32 +184,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -225,32 +225,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -274,32 +274,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -317,32 +317,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -360,32 +360,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -401,32 +401,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -442,32 +442,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -483,32 +483,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -525,32 +525,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -567,32 +567,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -610,32 +610,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step2.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step2.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step2.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step2.json	2023-03-13 20:01:47.000000000 +0600
@@ -60,32 +60,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -102,32 +102,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -143,32 +143,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -192,32 +192,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -235,32 +235,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -278,32 +278,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -319,32 +319,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -361,32 +361,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -403,32 +403,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -446,32 +446,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step3.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step3.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step3.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step3.json	2023-03-13 20:01:47.000000000 +0600
@@ -61,32 +61,32 @@
           "te-metric":20,
           "local-address-v6":"2001:db8::1",
           "remote-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -103,32 +103,32 @@
         "metric":10,
         "edge-attributes":{
           "local-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -144,32 +144,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -186,32 +186,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -227,32 +227,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -276,32 +276,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -319,32 +319,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -362,32 +362,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -403,32 +403,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -445,32 +445,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -487,32 +487,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -530,32 +530,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step4.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step4.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step4.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step4.json	2023-03-13 20:01:47.000000000 +0600
@@ -61,32 +61,32 @@
           "te-metric":20,
           "local-address-v6":"2001:db8::1",
           "remote-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -103,32 +103,32 @@
         "metric":10,
         "edge-attributes":{
           "local-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -144,32 +144,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -186,32 +186,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -227,32 +227,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -276,32 +276,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -319,32 +319,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -362,32 +362,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -403,32 +403,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -445,32 +445,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -487,32 +487,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -530,32 +530,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step5.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step5.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step5.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step5.json	2023-03-13 20:01:47.000000000 +0600
@@ -61,32 +61,32 @@
           "te-metric":20,
           "local-address-v6":"2001:db8::1",
           "remote-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -103,32 +103,32 @@
         "metric":10,
         "edge-attributes":{
           "local-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -144,32 +144,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:1",
           "remote-address-v6":"2001:db8:1::1:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -185,32 +185,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:2",
           "remote-address-v6":"2001:db8:1::1:1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -226,32 +226,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -268,32 +268,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -309,32 +309,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -358,32 +358,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -401,32 +401,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -444,32 +444,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -485,32 +485,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -526,32 +526,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -567,32 +567,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -609,32 +609,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -651,32 +651,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -694,32 +694,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step6.json frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step6.json
--- frr-frr-8.4.2/tests/topotests/isis_te_topo1/reference/ted_step6.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_te_topo1/reference/ted_step6.json	2023-03-13 20:01:47.000000000 +0600
@@ -61,32 +61,32 @@
           "te-metric":20,
           "local-address-v6":"2001:db8::1",
           "remote-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -103,32 +103,32 @@
         "metric":10,
         "edge-attributes":{
           "local-address-v6":"2001:db8::2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -144,32 +144,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:1",
           "remote-address-v6":"2001:db8:1::1:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -185,32 +185,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:1::1:2",
           "remote-address-v6":"2001:db8:1::1:1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -226,32 +226,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:3::3:2",
           "remote-address-v6":"2001:db8:3::3:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -268,32 +268,32 @@
           "admin-group":32,
           "local-address-v6":"2001:db8:3::3:3",
           "remote-address-v6":"2001:db8:3::3:2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -309,32 +309,32 @@
         "edge-attributes":{
           "local-address-v6":"2001:db8:5::3:4",
           "remote-address-v6":"2001:db8:5::4:3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -358,32 +358,32 @@
           "te-metric":10,
           "local-address-v6":"2001:db8:5::4:3",
           "remote-address-v6":"2001:db8:5::3:4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":50000
@@ -401,32 +401,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -444,32 +444,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -485,32 +485,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -526,32 +526,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -567,32 +567,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.3",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -609,32 +609,32 @@
           "admin-group":32,
           "local-address":"10.0.3.3",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -651,32 +651,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.4",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000
@@ -693,32 +693,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.4",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000,
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,19 @@
+--- a/rt1/step11/show_ip_route.ref
++++ b/rt1/step12/show_ip_route.ref
+@@ -110,16 +110,6 @@
+           "labels":[
+             16060
+           ]
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.1.3",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-sw1",
+-          "active":true,
+-          "labels":[
+-            16060
+-          ]
+         }
+       ]
+     }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,18 @@
+--- a/rt1/step11/show_ipv6_route.ref
++++ b/rt1/step12/show_ipv6_route.ref
+@@ -105,15 +105,6 @@
+           "labels":[
+             16061
+           ]
+-        },
+-        {
+-          "fib":true,
+-          "afi":"ipv6",
+-          "interfaceName":"eth-sw1",
+-          "active":true,
+-          "labels":[
+-            16061
+-          ]
+         }
+       ]
+     }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt1/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt1/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,28 @@
+--- a/rt1/step11/show_mpls_table.ref
++++ b/rt1/step12/show_mpls_table.ref
+@@ -79,12 +79,6 @@
+         "type":"SR (IS-IS)",
+         "outLabel":16060,
+         "installed":true,
+-        "nexthop":"10.0.1.3"
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16060,
+-        "installed":true,
+         "nexthop":"10.0.1.2"
+       }
+     ]
+@@ -96,12 +90,6 @@
+       {
+         "type":"SR (IS-IS)",
+         "outLabel":16061,
+-        "installed":true,
+-        "interface":"eth-sw1"
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16061,
+         "installed":true,
+         "interface":"eth-sw1"
+       }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt2/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt2/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt2/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt2/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+--- a/rt2/step11/show_mpls_table.ref
++++ b/rt2/step12/show_mpls_table.ref
+@@ -199,7 +199,7 @@
+     "backupNexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":16060,
++        "outLabel":16500,
+         "nexthop":"10.0.1.3"
+       }
+     ]
+@@ -230,7 +230,7 @@
+     "backupNexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":16061,
++        "outLabel":16501,
+         "interface":"eth-sw1"
+       }
+     ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,58 @@
+--- a/rt3/step11/show_ip_route.ref
++++ b/rt3/step12/show_ip_route.ref
+@@ -198,44 +198,37 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":30,
++      "metric":40,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.4.5",
++          "ip":"10.0.1.2",
+           "afi":"ipv4",
+-          "interfaceName":"eth-rt5-1",
++          "interfaceName":"eth-sw1",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+-            30060
++            16060
+           ]
+         },
+         {
+           "fib":true,
+-          "ip":"10.0.5.5",
++          "ip":"10.0.4.5",
+           "afi":"ipv4",
+-          "interfaceName":"eth-rt5-2",
++          "interfaceName":"eth-rt5-1",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             30060
+           ]
+-        }
+-      ],
+-      "backupNexthops":[
++        },
+         {
+-          "ip":"10.0.1.2",
++          "fib":true,
++          "ip":"10.0.5.5",
+           "afi":"ipv4",
+-          "interfaceName":"eth-sw1",
++          "interfaceName":"eth-rt5-2",
+           "active":true,
+           "labels":[
+-            16060
++            30060
+           ]
+         }
+       ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,45 @@
+--- a/rt3/step11/show_ipv6_route.ref
++++ b/rt3/step12/show_ipv6_route.ref
+@@ -186,7 +186,7 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":30,
++      "metric":40,
+       "installed":true,
+       "nexthops":[
+         {
+@@ -194,9 +194,6 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt5-1",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             30061
+           ]
+@@ -206,23 +203,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt5-2",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             30061
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-sw1",
+-          "active":true,
+-          "labels":[
+-            16061
+-          ]
+-        }
+       ]
+     }
+   ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt3/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt3/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,60 @@
+--- a/rt3/step11/show_mpls_table.ref
++++ b/rt3/step12/show_mpls_table.ref
+@@ -165,27 +165,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":30060,
+-        "installed":true,
+-        "nexthop":"10.0.5.5",
+-        "backupIndex":[
+-          0
+-        ]
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30060,
+-        "installed":true,
+-        "nexthop":"10.0.4.5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16060,
++        "installed":true,
+         "nexthop":"10.0.1.2"
+       }
+     ]
+@@ -196,27 +177,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":30061,
+-        "installed":true,
+-        "interface":"eth-rt5-2",
+-        "backupIndex":[
+-          0
+-        ]
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30061,
+-        "installed":true,
+-        "interface":"eth-rt5-1",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16061,
++        "installed":true,
+         "interface":"eth-sw1"
+       }
+     ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,144 @@
+--- a/rt4/step11/show_ip_route.ref
++++ b/rt4/step12/show_ip_route.ref
+@@ -160,23 +160,13 @@
+           "interfaceName":"eth-rt5",
+           "active":true,
+           "backupIndex":[
+-            0
++            0,
++            1
+           ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.7.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "labels":[
+-            16500
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -196,24 +186,10 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt6",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.6.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30060
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -352,19 +328,12 @@
+           "active":true,
+           "backupIndex":[
+             0,
+-            1,
+-            2
++            1
+           ]
+         }
+       ],
+       "backupNexthops":[
+         {
+-          "ip":"10.0.7.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        },
+-        {
+           "ip":"10.0.2.2",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt2-1",
+@@ -397,19 +366,12 @@
+           "active":true,
+           "backupIndex":[
+             0,
+-            1,
+-            2
++            1
+           ]
+         }
+       ],
+       "backupNexthops":[
+         {
+-          "ip":"10.0.7.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        },
+-        {
+           "ip":"10.0.2.2",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt2-1",
+@@ -439,14 +401,6 @@
+             0
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.7.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        }
+       ]
+     }
+   ],
+@@ -460,18 +414,7 @@
+         {
+           "ip":"10.0.7.6",
+           "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.6.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true
++          "interfaceName":"eth-rt6"
+         }
+       ]
+     }
+@@ -492,13 +435,6 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt5",
+           "active":true
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.7.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+         }
+       ]
+     }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,50 @@
+--- a/rt4/step11/show_ipv6_route.ref
++++ b/rt4/step12/show_ipv6_route.ref
+@@ -149,23 +149,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt5",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "labels":[
+-            16501
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -184,23 +171,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt6",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30061
+-          ]
+-        }
+       ]
+     }
+   ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt4/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt4/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,78 @@
+--- a/rt4/step11/show_mpls_table.ref
++++ b/rt4/step12/show_mpls_table.ref
+@@ -179,17 +179,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "nexthop":"10.0.7.6",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30060,
+-        "nexthop":"10.0.6.5"
++        "nexthop":"10.0.7.6"
+       }
+     ]
+   },
+@@ -201,17 +191,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "interface":"eth-rt6",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30061,
+-        "interface":"eth-rt5"
++        "interface":"eth-rt6"
+       }
+     ]
+   },
+@@ -223,17 +203,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "nexthop":"10.0.6.5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16500,
+-        "nexthop":"10.0.7.6"
++        "nexthop":"10.0.6.5"
+       }
+     ]
+   },
+@@ -245,17 +215,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "interface":"eth-rt5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16501,
+-        "interface":"eth-rt6"
++        "interface":"eth-rt5"
+       }
+     ]
+   }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/bfdd.conf frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+hostname rt5
+!
+#debug bfd network
+#debug bfd peer
+#debug bfd zebra
+!
+bfd
+ peer 10.0.8.6 interface eth-rt6
+  detect-multiplier 3
+  receive-interval 300
+  transmit-interval 300
+  no shutdown
+ !
+!
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,151 @@
+--- a/rt5/step11/show_ip_route.ref
++++ b/rt5/step12/show_ip_route.ref
+@@ -159,24 +159,10 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "labels":[
+-            16040
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -187,25 +173,11 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            3
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.6.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+@@ -276,19 +248,12 @@
+           "active":true,
+           "backupIndex":[
+             0,
+-            1,
+-            2
++            1
+           ]
+         }
+       ],
+       "backupNexthops":[
+         {
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        },
+-        {
+           "ip":"10.0.4.3",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt3-1",
+@@ -321,19 +286,12 @@
+           "active":true,
+           "backupIndex":[
+             0,
+-            1,
+-            2
++            1
+           ]
+         }
+       ],
+       "backupNexthops":[
+         {
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        },
+-        {
+           "ip":"10.0.4.3",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt3-1",
+@@ -439,14 +397,6 @@
+             0
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        }
+       ]
+     }
+   ],
+@@ -465,39 +415,6 @@
+           "ip":"10.0.6.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+-          "active":true
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "active":true
+-        }
+-      ]
+-    }
+-  ],
+-  "10.0.8.0\/24":[
+-    {
+-      "prefix":"10.0.8.0\/24",
+-      "protocol":"isis",
+-      "distance":115,
+-      "metric":20,
+-      "nexthops":[
+-        {
+-          "ip":"10.0.8.6",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt6",
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.6.4",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt4",
+           "active":true
+         }
+       ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,53 @@
+--- a/rt5/step11/show_ipv6_route.ref
++++ b/rt5/step12/show_ipv6_route.ref
+@@ -149,23 +149,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "labels":[
+-            16041
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -176,25 +163,12 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+           "afi":"ipv6",
+-          "interfaceName":"eth-rt6",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            3
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+           "labels":[
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt5/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt5/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,80 @@
+--- a/rt5/step11/show_mpls_table.ref
++++ b/rt5/step12/show_mpls_table.ref
+@@ -179,17 +179,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "nexthop":"10.0.6.4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16040,
+-        "nexthop":"10.0.8.6"
++        "nexthop":"10.0.6.4"
+       }
+     ]
+   },
+@@ -201,17 +191,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "interface":"eth-rt4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":16041,
+-        "interface":"eth-rt6"
++        "interface":"eth-rt4"
+       }
+     ]
+   },
+@@ -221,18 +201,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":3,
+-        "installed":true,
+-        "nexthop":"10.0.8.6",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16060,
++        "installed":true,
+         "nexthop":"10.0.6.4"
+       }
+     ]
+@@ -243,18 +213,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":3,
+-        "installed":true,
+-        "interface":"eth-rt6",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16061,
++        "installed":true,
+         "interface":"eth-rt4"
+       }
+     ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/bfdd.conf frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/bfdd.conf
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/bfdd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/bfdd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,14 @@
+hostname rt6
+!
+#debug bfd network
+#debug bfd peer
+#debug bfd zebra
+!
+bfd
+ peer 10.0.8.5 interface eth-rt5
+  detect-multiplier 3
+  receive-interval 300
+  transmit-interval 300
+  no shutdown
+ !
+!
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,125 @@
+--- a/rt6/step10/show_ip_route.ref
++++ b/rt6/step11/show_ip_route.ref
+@@ -76,25 +76,11 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":30,
++      "metric":40,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            30030
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+@@ -150,25 +136,11 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            3
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+@@ -276,22 +248,11 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+@@ -307,22 +268,11 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+@@ -389,19 +339,9 @@
+       "prefix":"10.0.8.0\/24",
+       "protocol":"isis",
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "nexthops":[
+         {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,56 @@
+--- a/rt6/step10/show_ipv6_route.ref
++++ b/rt6/step11/show_ipv6_route.ref
+@@ -72,25 +72,12 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":30,
++      "metric":40,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+           "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            30031
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+           "labels":[
+@@ -142,25 +129,12 @@
+       "selected":true,
+       "destSelected":true,
+       "distance":115,
+-      "metric":20,
++      "metric":30,
+       "installed":true,
+       "nexthops":[
+         {
+           "fib":true,
+           "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+-          "labels":[
+-            3
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+           "labels":[
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step11/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step11/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,106 @@
+--- a/rt6/step10/show_mpls_table.ref
++++ b/rt6/step11/show_mpls_table.ref
+@@ -8,12 +8,6 @@
+         "outLabel":16010,
+         "installed":true,
+         "nexthop":"10.0.7.4"
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30010,
+-        "installed":true,
+-        "nexthop":"10.0.8.5"
+       }
+     ]
+   },
+@@ -26,12 +20,6 @@
+         "outLabel":16011,
+         "installed":true,
+         "interface":"eth-rt4"
+-      },
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30011,
+-        "installed":true,
+-        "interface":"eth-rt5"
+       }
+     ]
+   },
+@@ -85,18 +73,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":30030,
+-        "installed":true,
+-        "nexthop":"10.0.8.5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16030,
++        "installed":true,
+         "nexthop":"10.0.7.4"
+       }
+     ]
+@@ -107,17 +85,6 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":30031,
+-        "installed":true,
+-        "interface":"eth-rt5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16031,
+         "interface":"eth-rt4"
+       }
+@@ -173,18 +140,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":3,
+-        "installed":true,
+-        "nexthop":"10.0.8.5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16500,
++        "installed":true,
+         "nexthop":"10.0.7.4"
+       }
+     ]
+@@ -195,18 +152,8 @@
+     "nexthops":[
+       {
+         "type":"SR (IS-IS)",
+-        "outLabel":3,
+-        "installed":true,
+-        "interface":"eth-rt5",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+         "outLabel":16501,
++        "installed":true,
+         "interface":"eth-rt4"
+       }
+     ]
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ip_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ip_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ip_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ip_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,153 @@
+--- a/rt6/step12/show_ip_route.ref
++++ b/rt6/step12/show_ip_route.ref
+@@ -18,16 +18,6 @@
+           "labels":[
+             16010
+           ]
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30010
+-          ]
+         }
+       ]
+     }
+@@ -48,24 +38,10 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             16020
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30020
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -108,24 +84,10 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30040
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -168,13 +130,6 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+           "active":true
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true
+         }
+       ]
+     }
+@@ -194,17 +149,6 @@
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+           "active":true
+         }
+       ]
+@@ -225,17 +169,6 @@
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+-          "active":true,
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+           "active":true
+         }
+       ]
+@@ -297,13 +230,6 @@
+           "afi":"ipv4",
+           "interfaceName":"eth-rt4",
+           "active":true
+-        },
+-        {
+-          "fib":true,
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true
+         }
+       ]
+     }
+@@ -318,18 +244,7 @@
+         {
+           "ip":"10.0.7.4",
+           "afi":"ipv4",
+-          "interfaceName":"eth-rt4",
+-          "backupIndex":[
+-            0
+-          ]
+-        }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "ip":"10.0.8.5",
+-          "afi":"ipv4",
+-          "interfaceName":"eth-rt5",
+-          "active":true
++          "interfaceName":"eth-rt4"
+         }
+       ]
+     }
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ipv6_route.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ipv6_route.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ipv6_route.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_ipv6_route.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,66 @@
+--- a/rt6/step12/show_ipv6_route.ref
++++ b/rt6/step12/show_ipv6_route.ref
+@@ -17,15 +17,6 @@
+           "labels":[
+             16011
+           ]
+-        },
+-        {
+-          "fib":true,
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30011
+-          ]
+         }
+       ]
+     }
+@@ -45,23 +36,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             16021
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30021
+-          ]
+-        }
+       ]
+     }
+   ],
+@@ -102,23 +80,10 @@
+           "afi":"ipv6",
+           "interfaceName":"eth-rt4",
+           "active":true,
+-          "backupIndex":[
+-            0
+-          ],
+           "labels":[
+             3
+           ]
+         }
+-      ],
+-      "backupNexthops":[
+-        {
+-          "afi":"ipv6",
+-          "interfaceName":"eth-rt5",
+-          "active":true,
+-          "labels":[
+-            30041
+-          ]
+-        }
+       ]
+     }
+   ],
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_mpls_table.ref.diff frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_mpls_table.ref.diff
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/rt6/step12/show_mpls_table.ref.diff	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/rt6/step12/show_mpls_table.ref.diff	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,78 @@
+--- a/rt6/step12/show_mpls_table.ref
++++ b/rt6/step12/show_mpls_table.ref
+@@ -31,17 +31,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":16020,
+         "installed":true,
+-        "nexthop":"10.0.7.4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30020,
+-        "nexthop":"10.0.8.5"
++        "nexthop":"10.0.7.4"
+       }
+     ]
+   },
+@@ -53,17 +43,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":16021,
+         "installed":true,
+-        "interface":"eth-rt4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30021,
+-        "interface":"eth-rt5"
++        "interface":"eth-rt4"
+       }
+     ]
+   },
+@@ -98,17 +78,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "nexthop":"10.0.7.4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30040,
+-        "nexthop":"10.0.8.5"
++        "nexthop":"10.0.7.4"
+       }
+     ]
+   },
+@@ -120,17 +90,7 @@
+         "type":"SR (IS-IS)",
+         "outLabel":3,
+         "installed":true,
+-        "interface":"eth-rt4",
+-        "backupIndex":[
+-          0
+-        ]
+-      }
+-    ],
+-    "backupNexthops":[
+-      {
+-        "type":"SR (IS-IS)",
+-        "outLabel":30041,
+-        "interface":"eth-rt5"
++        "interface":"eth-rt4"
+       }
+     ]
+   },
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/test_isis_tilfa_topo1.py frr-frr-8.5/tests/topotests/isis_tilfa_topo1/test_isis_tilfa_topo1.py
--- frr-frr-8.4.2/tests/topotests/isis_tilfa_topo1/test_isis_tilfa_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_tilfa_topo1/test_isis_tilfa_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -144,7 +144,7 @@ def build_topo(tgen):
     ]
     for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
         outputs[rname] = {}
-        for step in range(1, 9 + 1):
+        for step in range(1, 12 + 1):
             outputs[rname][step] = {}
             for file in files:
                 if step == 1:
@@ -188,6 +188,9 @@ def setup_module(mod):
         router.load_config(
             TopoRouter.RD_ISIS, os.path.join(CWD, "{}/isisd.conf".format(rname))
         )
+        router.load_config(
+            TopoRouter.RD_BFD, os.path.join(CWD, "/dev/null".format(rname))
+        )
 
     tgen.start_router()
 
@@ -200,7 +203,7 @@ def teardown_module(mod):
     tgen.stop_topology()
 
 
-def router_compare_json_output(rname, command, reference):
+def router_compare_json_output(rname, command, reference, count=120, wait=0.5):
     "Compare router JSON output"
 
     logger.info('Comparing router "%s" "%s" output', rname, command)
@@ -210,7 +213,7 @@ def router_compare_json_output(rname, co
 
     # Run test function until we get an result. Wait at most 60 seconds.
     test_func = partial(topotest.router_json_cmp, tgen.gears[rname], command, expected)
-    _, diff = topotest.run_and_expect(test_func, None, count=120, wait=0.5)
+    _, diff = topotest.run_and_expect(test_func, None, count=count, wait=wait)
     assertmsg = '"{}" JSON output mismatches the expected result'.format(rname)
     assert diff is None, assertmsg
 
@@ -740,6 +743,364 @@ def test_mpls_lib_step9():
         )
 
 
+#
+# Step 10
+#
+# Action(s):
+# - Setting spf-delay-ietf init-delay of 15s
+#
+# Expected changes:
+# - No routing table change
+# - At the end of test, SPF reacts to a failure in 15s
+#
+def test_rib_ipv4_step10():
+    logger.info("Test (step 10): verify IPv4 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Setting spf-delay-ietf init-delay of 15s")
+    tgen.net["rt6"].cmd(
+        'vtysh -c "conf t" -c "router isis 1" -c "spf-delay-ietf init-delay 15000 short-delay 0 long-delay 0 holddown 0 time-to-learn 0"'
+    )
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname, "show ip route isis json", outputs[rname][10]["show_ip_route.ref"]
+        )
+
+
+def test_rib_ipv6_step10():
+    logger.info("Test (step 10): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][10]["show_ipv6_route.ref"],
+        )
+
+
+def test_mpls_lib_step10():
+    logger.info("Test (step 10): verify MPLS LIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname, "show mpls table json", outputs[rname][10]["show_mpls_table.ref"]
+        )
+
+
+#
+# Step 11
+#
+# Action(s):
+# - shut the eth-rt5 interface on rt6
+#
+# Expected changes:
+# - Route switchover of routes via eth-rt5
+#
+def test_rt6_step11():
+    logger.info(
+        "Test (step 11): Check IPv4/6 RIB and MPLS table after a LFA switchover"
+    )
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info(
+        "Shut a rt6 interface to rt5 from the switch side and check fast-reroute"
+    )
+    tgen.net.cmd_raises("ip link set %s down" % tgen.net["s8"].intfs[1])
+
+    rname = "rt6"
+    router_compare_json_output(
+        rname,
+        "show ip route isis json",
+        outputs[rname][11]["show_ip_route.ref"],
+        count=10,
+    )
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][11]["show_ipv6_route.ref"],
+        count=10,
+    )
+    router_compare_json_output(
+        rname,
+        "show mpls table json",
+        outputs[rname][11]["show_mpls_table.ref"],
+        count=10,
+    )
+
+
+#
+# Step 12
+#
+# Action(s): wait for the convergence and SPF computation on rt6
+#
+# Expected changes:
+# - convergence of IPv4/6 RIB and MPLS table
+#
+def test_rib_ipv4_step12():
+    logger.info("Test (step 12): verify IPv4 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ip route isis json",
+            outputs[rname][12]["show_ip_route.ref"],
+        )
+
+
+def test_rib_ipv6_step12():
+    logger.info("Test (step 12): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][12]["show_ipv6_route.ref"],
+        )
+
+
+def test_mpls_lib_step12():
+    logger.info("Test (step 12): verify MPLS LIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show mpls table json",
+            outputs[rname][12]["show_mpls_table.ref"],
+        )
+
+
+#
+# Step 13
+#
+# Action(s):
+# - unshut the rt6 to rt5 interface
+# - Setup BFD
+#
+# Expected changes:
+# - All route tables go back to previous state situation
+# - At the end of test, next SPF is scheduled in approximatively 15s
+#
+def test_rib_ipv4_step13():
+    logger.info("Test (step 13): verify IPv4 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Unsetting spf-delay-ietf init-delay of 15s")
+    tgen.net["rt6"].cmd('vtysh -c "conf t" -c "router isis 1" -c "no spf-delay-ietf"')
+
+    logger.info(
+        "Unshut the rt6 interface to rt5 from the switch side and check fast-reroute"
+    )
+    tgen.net.cmd_raises("ip link set %s up" % tgen.net["s8"].intfs[1])
+
+    logger.info("Setup BFD on rt5 and rt6")
+    for rname in ["rt5", "rt6"]:
+        conf_file = os.path.join(CWD, "{}/bfdd.conf".format(rname))
+        tgen.net[rname].cmd("vtysh -f {}".format(conf_file))
+
+    expect = (
+        '[{"multihop":false,"peer":"10.0.8.5","interface":"eth-rt5","status":"up"}]'
+    )
+    router_compare_json_output("rt6", "show bfd peers json", expect)
+
+    # Unset link detection. We want zebra to consider linkdow as operationaly up
+    # in order that BFD triggers LFA instead of the interface down
+
+    # reset spf-interval
+    logger.info("Set spf-interval to 15s")
+    tgen.net["rt6"].cmd(
+        'vtysh -c "conf t" -c "router isis 1" -c "spf-delay-ietf init-delay 15000 short-delay 0 long-delay 0 holddown 0 time-to-learn 0"'
+    )
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname, "show ip route isis json", outputs[rname][10]["show_ip_route.ref"]
+        )
+
+    logger.info("Set ISIS BFD")
+    tgen.net["rt5"].cmd('vtysh -c "conf t" -c "int eth-rt6" -c "isis bfd"')
+    tgen.net["rt6"].cmd('vtysh -c "conf t" -c "int eth-rt5" -c "isis bfd"')
+
+
+def test_rib_ipv6_step13():
+    logger.info("Test (step 13): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][10]["show_ipv6_route.ref"],
+        )
+
+
+def test_mpls_lib_step13():
+    logger.info("Test (step 13): verify MPLS LIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname, "show mpls table json", outputs[rname][10]["show_mpls_table.ref"]
+        )
+
+
+#
+# Step 14
+#
+# Action(s):
+# - drop traffic between rt5 and rt6 by shutting down the bridge between
+#   the routers. Interfaces on rt5 and rt6 stay up.
+#
+# Expected changes:
+# - Route switchover of routes via eth-rt5
+#
+def test_rt6_step14():
+    logger.info("Test (step 14): verify IPv4/6 RIB and MPLS table")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Drop traffic between rt5 and rt6")
+    tgen.net.cmd_raises("ip link set s8 down")
+
+    rname = "rt6"
+
+    expect = (
+        '[{"multihop":false,"peer":"10.0.8.5","interface":"eth-rt5","status":"down"}]'
+    )
+    router_compare_json_output(
+        rname,
+        "show bfd peers json",
+        expect,
+        count=40,
+        wait=0.5,
+    )
+
+    router_compare_json_output(
+        rname,
+        "show ip route isis json",
+        outputs[rname][11]["show_ip_route.ref"],
+        count=10,
+    )
+    router_compare_json_output(
+        rname,
+        "show ipv6 route isis json",
+        outputs[rname][11]["show_ipv6_route.ref"],
+        count=10,
+    )
+    router_compare_json_output(
+        rname,
+        "show mpls table json",
+        outputs[rname][11]["show_mpls_table.ref"],
+        count=10,
+    )
+
+
+#
+# Step 15
+#
+# Action(s): wait for the convergence and SPF computation on rt6
+#
+# Expected changes:
+# - convergence of IPv4/6 RIB and MPLS table
+#
+def test_rib_ipv4_step15():
+    logger.info("Test (step 15): verify IPv4 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Check SPF convergence")
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ip route isis json",
+            outputs[rname][12]["show_ip_route.ref"],
+        )
+
+
+def test_rib_ipv6_step15():
+    logger.info("Test (step 15): verify IPv6 RIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show ipv6 route isis json",
+            outputs[rname][12]["show_ipv6_route.ref"],
+        )
+
+
+def test_mpls_lib_step15():
+    logger.info("Test (step 15): verify MPLS LIB")
+    tgen = get_topogen()
+
+    # Skip if previous fatal error condition is raised
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    for rname in ["rt1", "rt2", "rt3", "rt4", "rt5", "rt6"]:
+        router_compare_json_output(
+            rname,
+            "show mpls table json",
+            outputs[rname][12]["show_mpls_table.ref"],
+        )
+
+
 # Memory leak test template
 def test_memory_leak():
     "Run the memory leak test and report results."
diff -urpN frr-frr-8.4.2/tests/topotests/isis_topo1/test_isis_topo1.py frr-frr-8.5/tests/topotests/isis_topo1/test_isis_topo1.py
--- frr-frr-8.4.2/tests/topotests/isis_topo1/test_isis_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/isis_topo1/test_isis_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -25,7 +25,7 @@
 """
 test_isis_topo1.py: Test ISIS topology.
 """
-
+import datetime
 import functools
 import json
 import os
@@ -38,6 +38,11 @@ sys.path.append(os.path.join(CWD, "../")
 
 # pylint: disable=C0413
 from lib import topotest
+from lib.common_config import (
+    retry,
+    stop_router,
+    start_router,
+)
 from lib.topogen import Topogen, TopoRouter, get_topogen
 from lib.topolog import logger
 
@@ -248,10 +253,12 @@ def test_isis_summary_json():
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
         json_output = tgen.gears[rname].vtysh_cmd("show isis summary json", isjson=True)
-        assertmsg = "Test isis summary json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['vrf'] == "default", assertmsg
-        assert json_output['areas'][0]['area'] == "1", assertmsg
-        assert json_output['areas'][0]['levels'][0]['id'] != '3', assertmsg
+        assertmsg = "Test isis summary json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert json_output["vrf"] == "default", assertmsg
+        assert json_output["areas"][0]["area"] == "1", assertmsg
+        assert json_output["areas"][0]["levels"][0]["id"] != "3", assertmsg
 
 
 def test_isis_interface_json():
@@ -265,15 +272,29 @@ def test_isis_interface_json():
     logger.info("Checking 'show isis interface json'")
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis interface json", isjson=True)
-        assertmsg = "Test isis interface json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['circuits'][0]['interface']['name'] == rname+"-eth0", assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis interface json", isjson=True
+        )
+        assertmsg = "Test isis interface json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert (
+            json_output["areas"][0]["circuits"][0]["interface"]["name"]
+            == rname + "-eth0"
+        ), assertmsg
 
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis interface detail json", isjson=True)
-        assertmsg = "Test isis interface json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['circuits'][0]['interface']['name'] == rname+"-eth0", assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis interface detail json", isjson=True
+        )
+        assertmsg = "Test isis interface json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert (
+            json_output["areas"][0]["circuits"][0]["interface"]["name"]
+            == rname + "-eth0"
+        ), assertmsg
 
 
 def test_isis_neighbor_json():
@@ -284,19 +305,32 @@ def test_isis_neighbor_json():
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    #tgen.mininet_cli()
+    # tgen.mininet_cli()
     logger.info("Checking 'show isis neighbor json'")
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis neighbor json", isjson=True)
-        assertmsg = "Test isis neighbor json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['circuits'][0]['interface'] == rname+"-eth0", assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis neighbor json", isjson=True
+        )
+        assertmsg = "Test isis neighbor json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert (
+            json_output["areas"][0]["circuits"][0]["interface"] == rname + "-eth0"
+        ), assertmsg
 
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis neighbor detail json", isjson=True)
-        assertmsg = "Test isis neighbor json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['circuits'][0]['interface']['name'] == rname+"-eth0", assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis neighbor detail json", isjson=True
+        )
+        assertmsg = "Test isis neighbor json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert (
+            json_output["areas"][0]["circuits"][0]["interface"]["name"]
+            == rname + "-eth0"
+        ), assertmsg
 
 
 def test_isis_database_json():
@@ -307,21 +341,246 @@ def test_isis_database_json():
     if tgen.routers_have_failure():
         pytest.skip(tgen.errors)
 
-    #tgen.mininet_cli()
+    # tgen.mininet_cli()
     logger.info("Checking 'show isis database json'")
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis database json", isjson=True)
-        assertmsg = "Test isis database json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['area']['name'] == "1", assertmsg
-        assert json_output['areas'][0]['levels'][0]['id'] != '3', assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis database json", isjson=True
+        )
+        assertmsg = "Test isis database json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert json_output["areas"][0]["area"]["name"] == "1", assertmsg
+        assert json_output["areas"][0]["levels"][0]["id"] != "3", assertmsg
 
     for rname, router in tgen.routers().items():
         logger.info("Checking router %s", rname)
-        json_output = tgen.gears[rname].vtysh_cmd("show isis database detail json", isjson=True)
-        assertmsg = "Test isis database json failed in '{}' data '{}'".format(rname, json_output)
-        assert json_output['areas'][0]['area']['name'] == "1", assertmsg
-        assert json_output['areas'][0]['levels'][0]['id'] != '3', assertmsg
+        json_output = tgen.gears[rname].vtysh_cmd(
+            "show isis database detail json", isjson=True
+        )
+        assertmsg = "Test isis database json failed in '{}' data '{}'".format(
+            rname, json_output
+        )
+        assert json_output["areas"][0]["area"]["name"] == "1", assertmsg
+        assert json_output["areas"][0]["levels"][0]["id"] != "3", assertmsg
+
+
+def test_isis_overload_on_startup():
+    "Check that overload on startup behaves as expected"
+
+    tgen = get_topogen()
+    net = get_topogen().net
+    overload_time = 120
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info("Testing overload on startup behavior")
+
+    # Configure set-overload-bit on-startup on r3
+    r3 = tgen.gears["r3"]
+    r3.vtysh_cmd(
+        f"""
+          configure
+            router isis 1
+              set-overload-bit on-startup {overload_time}
+        """
+    )
+    # Restart r3
+    logger.info("Stop router")
+    stop_router(tgen, "r3")
+    logger.info("Start router")
+
+    tstamp_before_start_router = datetime.datetime.now()
+    start_router(tgen, "r3")
+    tstamp_after_start_router = datetime.datetime.now()
+    startup_router_time = (
+        tstamp_after_start_router - tstamp_before_start_router
+    ).total_seconds()
+
+    # Check that the overload bit is set in r3's LSP
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/1")
+    check_lsp_overload_bit("r1", "r3.00-00", "0/0/1")
+
+    # Attempt to unset overload bit while timer is still running
+    r3.vtysh_cmd(
+        """
+          configure
+            router isis 1
+              no set-overload-bit on-startup
+              no set-overload-bit
+        """
+    )
+
+    # Check overload bit is still set
+    check_lsp_overload_bit("r1", "r3.00-00", "0/0/1")
+
+    # Check that overload bit is unset after timer completes
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/0")
+    tstamp_after_bit_unset = datetime.datetime.now()
+    check_lsp_overload_bit("r1", "r3.00-00", "0/0/0")
+
+    # Collect time overloaded
+    time_overloaded = (
+        tstamp_after_bit_unset - tstamp_after_start_router
+    ).total_seconds()
+    logger.info(f"Time Overloaded: {time_overloaded}")
+
+    # Use time it took to startup router as lower bound
+    logger.info(
+        f"Assert that overload time falls in range: {overload_time - startup_router_time} < {time_overloaded} <= {overload_time}"
+    )
+    result = overload_time - startup_router_time < time_overloaded <= overload_time
+    assert result
+
+
+def test_isis_overload_on_startup_cancel_timer():
+    "Check that overload on startup timer is cancelled when overload bit is set/unset"
+
+    tgen = get_topogen()
+    net = get_topogen().net
+    overload_time = 90
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info(
+        "Testing overload on startup behavior with set overload bit: cancel timer"
+    )
+
+    # Configure set-overload-bit on-startup on r3
+    r3 = tgen.gears["r3"]
+    r3.vtysh_cmd(
+        f"""
+          configure
+            router isis 1
+              set-overload-bit on-startup {overload_time}
+              set-overload-bit
+        """
+    )
+    # Restart r3
+    logger.info("Stop router")
+    stop_router(tgen, "r3")
+    logger.info("Start router")
+    start_router(tgen, "r3")
+
+    # Check that the overload bit is set in r3's LSP
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/1")
+
+    # Check that overload timer is running
+    check_overload_timer("r3", True)
+
+    # Unset overload bit while timer is running
+    r3.vtysh_cmd(
+        """
+          configure
+            router isis 1
+              no set-overload-bit
+        """
+    )
+
+    # Check that overload timer is cancelled
+    check_overload_timer("r3", False)
+
+    # Check overload bit is unset
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/0")
+
+
+def test_isis_overload_on_startup_override_timer():
+    "Check that overload bit remains set after overload timer expires if overload bit is configured"
+
+    tgen = get_topogen()
+    net = get_topogen().net
+    overload_time = 60
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    logger.info(
+        "Testing overload on startup behavior with set overload bit: override timer"
+    )
+
+    # Configure set-overload-bit on-startup on r3
+    r3 = tgen.gears["r3"]
+    r3.vtysh_cmd(
+        f"""
+          configure
+            router isis 1
+              set-overload-bit on-startup {overload_time}
+              set-overload-bit
+        """
+    )
+    # Restart r3
+    logger.info("Stop router")
+    stop_router(tgen, "r3")
+    logger.info("Start router")
+    start_router(tgen, "r3")
+
+    # Check that the overload bit is set in r3's LSP
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/1")
+
+    # Check that overload timer is running
+    check_overload_timer("r3", True)
+
+    # Check that overload timer expired
+    check_overload_timer("r3", False)
+
+    # Check overload bit is still set
+    check_lsp_overload_bit("r3", "r3.00-00", "0/0/1")
+
+
+@retry(retry_timeout=200)
+def _check_lsp_overload_bit(router, overloaded_router_lsp, att_p_ol_expected):
+    "Verfiy overload bit in router's LSP"
+
+    tgen = get_topogen()
+    router = tgen.gears[router]
+    logger.info(f"check_overload_bit {router}")
+    isis_database_output = router.vtysh_cmd(
+        "show isis database {} json".format(overloaded_router_lsp)
+    )
+
+    database_json = json.loads(isis_database_output)
+    att_p_ol = database_json["areas"][0]["levels"][1]["att-p-ol"]
+    if att_p_ol == att_p_ol_expected:
+        return True
+    return "{} peer with expected att_p_ol {} got {} ".format(
+        router.name, att_p_ol_expected, att_p_ol
+    )
+
+
+def check_lsp_overload_bit(router, overloaded_router_lsp, att_p_ol_expected):
+    "Verfiy overload bit in router's LSP"
+
+    assertmsg = _check_lsp_overload_bit(
+        router, overloaded_router_lsp, att_p_ol_expected
+    )
+    assert assertmsg is True, assertmsg
+
+
+@retry(retry_timeout=200)
+def _check_overload_timer(router, timer_expected):
+    "Verfiy overload bit in router's LSP"
+
+    tgen = get_topogen()
+    router = tgen.gears[router]
+    thread_output = router.vtysh_cmd("show thread timers")
+
+    timer_running = "set_overload_on_start_timer" in thread_output
+    if timer_running == timer_expected:
+        return True
+    return "Expected timer running status: {}".format(timer_expected)
+
+
+def check_overload_timer(router, timer_expected):
+    "Verfiy overload bit in router's LSP"
+
+    assertmsg = _check_overload_timer(router, timer_expected)
+    assert assertmsg is True, assertmsg
 
 
 def test_memory_leak():
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_snmp/r1/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_snmp/r1/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_snmp/r1/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_snmp/r1/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r1-mpw0":{
     "peerId":"2.2.2.2",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_snmp/r2/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_snmp/r2/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_snmp/r2/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_snmp/r2/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r2-mpw0":{
     "peerId":"1.1.1.1",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_sync_isis_topo1/r1/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_sync_isis_topo1/r1/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_sync_isis_topo1/r1/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_sync_isis_topo1/r1/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r1-mpw0":{
     "peerId":"2.2.2.2",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_sync_isis_topo1/r2/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_sync_isis_topo1/r2/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_sync_isis_topo1/r2/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_sync_isis_topo1/r2/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r2-mpw0":{
     "peerId":"1.1.1.1",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_sync_ospf_topo1/r1/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_sync_ospf_topo1/r1/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_sync_ospf_topo1/r1/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_sync_ospf_topo1/r1/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r1-mpw0":{
     "peerId":"2.2.2.2",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_sync_ospf_topo1/r2/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_sync_ospf_topo1/r2/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_sync_ospf_topo1/r2/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_sync_ospf_topo1/r2/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r2-mpw0":{
     "peerId":"1.1.1.1",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_vpls_topo1/r1/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_vpls_topo1/r1/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_vpls_topo1/r1/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_vpls_topo1/r1/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r1-mpw0":{
     "peerId":"2.2.2.2",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/ldp_vpls_topo1/r2/show_l2vpn_vc.ref frr-frr-8.5/tests/topotests/ldp_vpls_topo1/r2/show_l2vpn_vc.ref
--- frr-frr-8.4.2/tests/topotests/ldp_vpls_topo1/r2/show_l2vpn_vc.ref	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ldp_vpls_topo1/r2/show_l2vpn_vc.ref	2023-03-13 20:01:47.000000000 +0600
@@ -2,7 +2,7 @@
   "r2-mpw0":{
     "peerId":"1.1.1.1",
     "vcId":100,
-    "VpnName":"CUST_A",
+    "vpnName":"CUST_A",
     "status":"up"
   }
 }
diff -urpN frr-frr-8.4.2/tests/topotests/lib/bgp.py frr-frr-8.5/tests/topotests/lib/bgp.py
--- frr-frr-8.4.2/tests/topotests/lib/bgp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/bgp.py	2023-03-13 20:01:47.000000000 +0600
@@ -830,22 +830,36 @@ def __create_bgp_neighbor(topo, input_di
     global_connect = input_dict.get("connecttimer", 5)
 
     for name, peer_dict in neigh_data.items():
+        remote_as = 0
         for dest_link, peer in peer_dict["dest_link"].items():
+            local_asn = peer.setdefault("local_asn", {})
+            if local_asn:
+                local_as = local_asn.setdefault("local_as", 0)
+                remote_as = local_asn.setdefault("remote_as", 0)
+                no_prepend = local_asn.setdefault("no_prepend", False)
+                replace_as = local_asn.setdefault("replace_as", False)
+                if local_as == remote_as:
+                    assert False is True, (
+                        " Configuration Error : Router must not have "
+                        "same AS-NUMBER as Local AS NUMBER"
+                    )
             nh_details = topo[name]
 
             if "vrfs" in topo[router] or type(nh_details["bgp"]) is list:
                 for vrf_data in nh_details["bgp"]:
                     if "vrf" in nh_details["links"][dest_link] and "vrf" in vrf_data:
                         if nh_details["links"][dest_link]["vrf"] == vrf_data["vrf"]:
-                            remote_as = vrf_data["local_as"]
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
                             break
                     else:
                         if "vrf" not in vrf_data:
-                            remote_as = vrf_data["local_as"]
-                            break
-
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
+                                break
             else:
-                remote_as = nh_details["bgp"]["local_as"]
+                if not remote_as:
+                    remote_as = nh_details["bgp"]["local_as"]
 
             update_source = None
 
@@ -890,6 +904,14 @@ def __create_bgp_neighbor(topo, input_di
                 elif add_neigh:
                     config_data.append("{} remote-as {}".format(neigh_cxt, remote_as))
 
+                if local_asn and local_as:
+                    cmd = "{} local-as {}".format(neigh_cxt, local_as)
+                    if no_prepend:
+                        cmd = "{} no-prepend".format(cmd)
+                    if replace_as:
+                        cmd = "{} replace-as".format(cmd)
+                    config_data.append("{}".format(cmd))
+
             if addr_type == "ipv6":
                 config_data.append("address-family ipv6 unicast")
                 config_data.append("{} activate".format(neigh_cxt))
@@ -1887,7 +1909,7 @@ def clear_bgp(tgen, addr_type, router, v
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
-def clear_bgp_and_verify(tgen, topo, router):
+def clear_bgp_and_verify(tgen, topo, router, rid=None):
     """
     This API is to clear bgp neighborship and verify bgp neighborship
     is coming up(BGP is converged) usinf "show bgp summary json" command
@@ -1937,7 +1959,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
 
@@ -1997,10 +2023,15 @@ def clear_bgp_and_verify(tgen, topo, rou
     logger.info("Clearing BGP neighborship for router %s..", router)
     for addr_type in bgp_addr_type.keys():
         if addr_type == "ipv4":
-            run_frr_cmd(rnode, "clear ip bgp *")
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv4 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv4 *")
         elif addr_type == "ipv6":
-            run_frr_cmd(rnode, "clear bgp ipv6 *")
-
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv6 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv6 *")
     peer_uptime_after_clear_bgp = {}
     # Verifying BGP convergence after bgp clear command
     for retry in range(50):
@@ -2020,7 +2051,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
             if not check_address_types(addr_type):
@@ -2775,7 +2810,11 @@ def verify_best_path_as_per_admin_distan
         if route in rib_routes_json:
             st_found = True
             # Verify next_hop in rib_routes_json
-            if rib_routes_json[route][0]["nexthops"][0]["ip"] == _next_hop:
+            if [
+                nh
+                for nh in rib_routes_json[route][0]["nexthops"]
+                if nh["ip"] == _next_hop
+            ]:
                 nh_found = True
             else:
                 errormsg = (
@@ -4238,7 +4277,7 @@ def verify_attributes_for_evpn_routes(
                         for _rd, route_data in evpn_rd_value_json.items():
                             if route_data["ip"] == route:
                                 for rt_data in route_data["paths"]:
-                                    if vni_dict[vrf] == rt_data["VNI"]:
+                                    if vni_dict[vrf] == rt_data["vni"]:
                                         rt_string = rt_data["extendedCommunity"][
                                             "string"
                                         ]
diff -urpN frr-frr-8.4.2/tests/topotests/lib/common_config.py frr-frr-8.5/tests/topotests/lib/common_config.py
--- frr-frr-8.4.2/tests/topotests/lib/common_config.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/common_config.py	2023-03-13 20:01:47.000000000 +0600
@@ -81,6 +81,26 @@ DEBUG_LOGS = {
         "debug pim packets register",
         "debug pim nht",
     ],
+    "pim6d": [
+        "debug pimv6 events",
+        "debug pimv6 packets",
+        "debug pimv6 packet-dump send",
+        "debug pimv6 packet-dump receive",
+        "debug pimv6 trace",
+        "debug pimv6 trace detail",
+        "debug pimv6 zebra",
+        "debug pimv6 bsm",
+        "debug pimv6 packets hello",
+        "debug pimv6 packets joins",
+        "debug pimv6 packets register",
+        "debug pimv6 nht",
+        "debug pimv6 nht detail",
+        "debug mroute6",
+        "debug mroute6 detail",
+        "debug mld events",
+        "debug mld packets",
+        "debug mld trace",
+    ],
     "bgpd": [
         "debug bgp neighbor-events",
         "debug bgp updates",
@@ -961,7 +981,7 @@ def generate_support_bundle():
     return True
 
 
-def start_topology(tgen, daemon=None):
+def start_topology(tgen):
     """
     Starting topology, create tmp files which are loaded to routers
     to start daemons and then start routers
@@ -1009,38 +1029,70 @@ def start_topology(tgen, daemon=None):
         except IOError as err:
             logger.error("I/O error({0}): {1}".format(err.errno, err.strerror))
 
-        # Loading empty zebra.conf file to router, to start the zebra daemon
+        topo = tgen.json_topo
+        feature = set()
+
+        if "feature" in topo:
+            feature.update(topo["feature"])
+
+        if rname in topo["routers"]:
+            for key in topo["routers"][rname].keys():
+                feature.add(key)
+
+            for val in topo["routers"][rname]["links"].values():
+                if "pim" in val:
+                    feature.add("pim")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "pim6" in val:
+                    feature.add("pim6")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+        if "switches" in topo and rname in topo["switches"]:
+            for val in topo["switches"][rname]["links"].values():
+                if "ospf" in val:
+                    feature.add("ospf")
+                    break
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+
+        # Loading empty zebra.conf file to router, to start the zebra deamon
         router.load_config(
             TopoRouter.RD_ZEBRA, "{}/{}/zebra.conf".format(tgen.logdir, rname)
         )
 
-        # Loading empty bgpd.conf file to router, to start the bgp daemon
-        router.load_config(
-            TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
-        )
+        # Loading empty bgpd.conf file to router, to start the bgp deamon
+        if "bgp" in feature:
+            router.load_config(
+                TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
+            )
 
-        if daemon and "ospfd" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "ospf6d" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim6" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pimd" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim deamon
+        if "ospf" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pim6d" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim6d deamon
+        if "ospf6" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
             )
 
     # Starting routers
@@ -3244,33 +3296,29 @@ def configure_interface_mac(tgen, input_
     return True
 
 
-def socat_send_igmp_join_traffic(
+def socat_send_mld_join(
     tgen,
     server,
     protocol_option,
-    igmp_groups,
+    mld_groups,
     send_from_intf,
     send_from_intf_ip=None,
     port=12345,
     reuseaddr=True,
-    join=False,
-    traffic=False,
 ):
     """
-    API to send IGMP join using SOCAT tool
+    API to send MLD join using SOCAT tool
 
     Parameters:
     -----------
     * `tgen`  : Topogen object
     * `server`: iperf server, from where IGMP join would be sent
     * `protocol_option`: Protocol options, ex: UDP6-RECV
-    * `igmp_groups`: IGMP group for which join has to be sent
+    * `mld_groups`: IGMP group for which join has to be sent
     * `send_from_intf`: Interface from which join would be sent
     * `send_from_intf_ip`: Interface IP, default is None
     * `port`: Port to be used, default is 12345
     * `reuseaddr`: True|False, bydefault True
-    * `join`: If join needs to be sent
-    * `traffic`: If traffic needs to be sent
 
     returns:
     --------
@@ -3280,36 +3328,32 @@ def socat_send_igmp_join_traffic(
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     rnode = tgen.routers()[server]
-    socat_cmd = "socat -u "
+    socat_args = "socat -u "
 
-    # UDP4/TCP4/UDP6/UDP6-RECV
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
     if protocol_option:
-        socat_cmd += "{}".format(protocol_option)
+        socat_args += "{}".format(protocol_option)
 
     if port:
-        socat_cmd += ":{},".format(port)
+        socat_args += ":{},".format(port)
 
     if reuseaddr:
-        socat_cmd += "{},".format("reuseaddr")
+        socat_args += "{},".format("reuseaddr")
 
     # Group address range to cover
-    if igmp_groups:
-        if not isinstance(igmp_groups, list):
-            igmp_groups = [igmp_groups]
-
-    for igmp_group in igmp_groups:
-        if join:
-            join_traffic_option = "ipv6-join-group"
-        elif traffic:
-            join_traffic_option = "ipv6-join-group-source"
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        join_option = "ipv6-join-group"
 
         if send_from_intf and not send_from_intf_ip:
-            socat_cmd += "{}='[{}]:{}'".format(
-                join_traffic_option, igmp_group, send_from_intf
-            )
+            socat_cmd += "{}='[{}]:{}'".format(join_option, mld_group, send_from_intf)
         else:
             socat_cmd += "{}='[{}]:{}:[{}]'".format(
-                join_traffic_option, igmp_group, send_from_intf, send_from_intf_ip
+                join_option, mld_group, send_from_intf, send_from_intf_ip
             )
 
         socat_cmd += " STDOUT"
@@ -3324,6 +3368,124 @@ def socat_send_igmp_join_traffic(
     return True
 
 
+def socat_send_pim6_traffic(
+    tgen,
+    server,
+    protocol_option,
+    mld_groups,
+    send_from_intf,
+    port=12345,
+    multicast_hops=True,
+):
+    """
+    API to send pim6 data taffic using SOCAT tool
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `server`: iperf server, from where IGMP join would be sent
+    * `protocol_option`: Protocol options, ex: UDP6-RECV
+    * `mld_groups`: MLD group for which join has to be sent
+    * `send_from_intf`: Interface from which join would be sent
+    * `port`: Port to be used, default is 12345
+    * `multicast_hops`: multicast-hops count, default is 255
+
+    returns:
+    --------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[server]
+    socat_args = "socat -u STDIO "
+
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
+    if protocol_option:
+        socat_args += "'{}".format(protocol_option)
+
+    # Group address range to cover
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        if port:
+            socat_cmd += ":[{}]:{},".format(mld_group, port)
+
+        if send_from_intf:
+            socat_cmd += "interface={0},so-bindtodevice={0},".format(send_from_intf)
+
+        if multicast_hops:
+            socat_cmd += "multicast-hops=255'"
+
+        socat_cmd += " &>{}/socat.logs &".format(tgen.logdir)
+
+        # Run socat command to send pim6 traffic
+        logger.info(
+            "[DUT: {}]: Running command: [set +m; ( while sleep 1; do date; done ) | {}]".format(
+                server, socat_cmd
+            )
+        )
+
+        # Open a shell script file and write data to it, which will be
+        # used to send pim6 traffic continously
+        traffic_shell_script = "{}/{}/traffic.sh".format(tgen.logdir, server)
+        with open("{}".format(traffic_shell_script), "w") as taffic_sh:
+            taffic_sh.write(
+                "#!/usr/bin/env bash\n( while sleep 1; do date; done ) | {}\n".format(
+                    socat_cmd
+                )
+            )
+
+        rnode.run("chmod 755 {}".format(traffic_shell_script))
+        output = rnode.run("{} &> /dev/null".format(traffic_shell_script))
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def kill_socat(tgen, dut=None, action=None):
+    """
+    Killing socat process if running for any router in topology
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `dut`   : Any iperf hostname to send igmp prune
+    * `action`: to kill mld join using socat
+                to kill mld traffic using socat
+
+    Usage:
+    ------
+    kill_socat(tgen, dut ="i6", action="remove_mld_join")
+
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        if action == "remove_mld_join":
+            cmd = "ps -ef | grep socat | grep UDP6-RECV | grep {}".format(router)
+        elif action == "remove_mld_traffic":
+            cmd = "ps -ef | grep socat | grep UDP6-SEND | grep {}".format(router)
+        else:
+            cmd = "ps -ef | grep socat".format(router)
+
+        awk_cmd = "awk -F' ' '{print $2}' | xargs kill -9 &>/dev/null &"
+        cmd = "{} | {}".format(cmd, awk_cmd)
+
+        logger.debug("[DUT: {}]: Running command: [{}]".format(router, cmd))
+        rnode.run(cmd)
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+
 #############################################
 # Verification APIs
 #############################################
diff -urpN frr-frr-8.4.2/tests/topotests/lib/lutil.py frr-frr-8.5/tests/topotests/lib/lutil.py
--- frr-frr-8.4.2/tests/topotests/lib/lutil.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/lutil.py	2023-03-13 20:01:47.000000000 +0600
@@ -50,6 +50,7 @@ class lUtil:
     l_line = 0
     l_dotall_experiment = False
     l_last_nl = None
+    l_wait_strict = 1
 
     fout = ""
     fsum = ""
@@ -189,7 +190,7 @@ Total %-4d
             self.log("unable to read: " + tstFile)
             sys.exit(1)
 
-    def command(self, target, command, regexp, op, result, returnJson, startt=None):
+    def command(self, target, command, regexp, op, result, returnJson, startt=None, force_result=False):
         global net
         if op == "jsoncmp_pass" or op == "jsoncmp_fail":
             returnJson = True
@@ -292,7 +293,7 @@ Total %-4d
                     9,
                 )
         if startt != None:
-            if js != None or ret is not False:
+            if js != None or ret is not False or force_result is not False:
                 delta = time.time() - startt
                 self.result(target, success, "%s +%4.2f secs" % (result, delta))
         elif op == "pass" or op == "fail":
@@ -322,12 +323,23 @@ Total %-4d
         n = 0
         startt = time.time()
 
+        if (op == "wait-strict") or ((op == "wait") and self.l_wait_strict):
+            strict = True
+        else:
+            strict = False
+
         # Calculate the amount of `sleep`s we are going to peform.
         wait_count = int(math.ceil(wait / wait_time)) + 1
 
+        force_result = False
         while wait_count > 0:
             n += 1
-            found = self.command(target, command, regexp, op, result, returnJson, startt)
+
+            # log a failure on last iteration if we don't get desired regexp
+            if strict and (wait_count == 1):
+                force_result = True
+
+            found = self.command(target, command, regexp, op, result, returnJson, startt, force_result)
             if found is not False:
                 break
 
@@ -378,12 +390,14 @@ def luCommand(
     returnJson=False,
     wait_time=0.5,
 ):
-    if op != "wait":
-        return LUtil.command(target, command, regexp, op, result, returnJson)
-    else:
+    waitops = ["wait", "wait-strict", "wait-nostrict"]
+
+    if op in waitops:
         return LUtil.wait(
             target, command, regexp, op, result, time, returnJson, wait_time
         )
+    else:
+        return LUtil.command(target, command, regexp, op, result, returnJson)
 
 
 def luLast(usenl=False):
@@ -454,6 +468,25 @@ def luShowFail():
     if printed > 0:
         logger.error("See %s for details of errors" % LUtil.fout_name)
 
+#
+# Sets default wait type for luCommand(op="wait) (may be overridden by
+# specifying luCommand(op="wait-strict") or luCommand(op="wait-nostrict")).
+#
+# "nostrict" is the historical default behavior, which is to ignore
+# failures to match the specified regexp in the specified time.
+#
+# "strict" means that failure to match the specified regexp in the
+# specified time yields an explicit, logged failure result
+#
+def luSetWaitType(waittype):
+    if waittype == "strict":
+        LUtil.l_wait_strict = 1
+    else:
+        if waittype == "nostrict":
+            LUtil.l_wait_strict = 0
+        else:
+            raise ValueError('waittype must be one of "strict" or "nostrict"')
+
 
 # for testing
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/lib/micronet.py frr-frr-8.5/tests/topotests/lib/micronet.py
--- frr-frr-8.4.2/tests/topotests/lib/micronet.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/micronet.py	2023-03-13 20:01:47.000000000 +0600
@@ -470,7 +470,8 @@ class LinuxNamespace(Commander):
 
         nslist = []
         cmd = ["/usr/bin/unshare"]
-        flags = "-"
+        flags = ""
+        self.a_flags = []
         self.ifnetns = {}
 
         if cgroup:
@@ -487,6 +488,7 @@ class LinuxNamespace(Commander):
             flags += "n"
         if pid:
             nslist.append("pid")
+            flags += "f"
             flags += "p"
             cmd.append("--mount-proc")
         if time:
@@ -499,9 +501,17 @@ class LinuxNamespace(Commander):
             cmd.append("--keep-caps")
         if uts:
             nslist.append("uts")
-            cmd.append("--uts")
+            flags += "u"
 
-        cmd.append(flags)
+        if flags:
+            aflags = flags.replace("f", "")
+            if aflags:
+                self.a_flags = ["-" + x for x in aflags]
+            cmd.extend(["-" + x for x in flags])
+
+        if pid:
+            cmd.append(commander.get_exec_path("tini"))
+            cmd.append("-vvv")
         cmd.append("/bin/cat")
 
         # Using cat and a stdin PIPE is nice as it will exit when we do. However, we
@@ -516,7 +526,8 @@ class LinuxNamespace(Commander):
             stdin=subprocess.PIPE,
             stdout=open("/dev/null", "w"),
             stderr=open("/dev/null", "w"),
-            preexec_fn=os.setsid,  # detach from pgid so signals don't propogate
+            text=True,
+            start_new_session=True,  # detach from pgid so signals don't propagate
             shell=False,
         )
         self.p = p
@@ -550,7 +561,7 @@ class LinuxNamespace(Commander):
         assert not nslist, "unshare never unshared!"
 
         # Set pre-command based on our namespace proc
-        self.base_pre_cmd = ["/usr/bin/nsenter", "-a", "-t", str(self.pid)]
+        self.base_pre_cmd = ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid)]
         if not pid:
             self.base_pre_cmd.append("-F")
         self.set_pre_cmd(self.base_pre_cmd + ["--wd=" + self.cwd])
@@ -743,7 +754,7 @@ class SharedNamespace(Commander):
     An object that executes commands in an existing pid's linux namespace
     """
 
-    def __init__(self, name, pid, logger=None):
+    def __init__(self, name, pid, aflags=("-a",), logger=None):
         """
         Share a linux namespace.
 
@@ -757,10 +768,11 @@ class SharedNamespace(Commander):
 
         self.pid = pid
         self.intfs = []
+        self.a_flags = aflags
 
         # Set pre-command based on our namespace proc
         self.set_pre_cmd(
-            ["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + self.cwd]
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + self.cwd]
         )
 
     def __str__(self):
@@ -769,7 +781,9 @@ class SharedNamespace(Commander):
     def set_cwd(self, cwd):
         # Set pre-command based on our namespace proc
         self.logger.debug("%s: new CWD %s", self, cwd)
-        self.set_pre_cmd(["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + cwd])
+        self.set_pre_cmd(
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + cwd]
+        )
 
     def register_interface(self, ifname):
         if ifname not in self.intfs:
@@ -800,7 +814,7 @@ class Bridge(SharedNamespace):
             self.brid = "br{}".format(self.brid_ord)
             name = self.brid
 
-        super(Bridge, self).__init__(name, unet.pid, logger)
+        super(Bridge, self).__init__(name, unet.pid, aflags=unet.a_flags, logger=logger)
 
         self.logger.debug("Bridge: Creating")
 
diff -urpN frr-frr-8.4.2/tests/topotests/lib/ospf.py frr-frr-8.5/tests/topotests/lib/ospf.py
--- frr-frr-8.4.2/tests/topotests/lib/ospf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/ospf.py	2023-03-13 20:01:47.000000000 +0600
@@ -1533,11 +1533,11 @@ def verify_ospf_summary(tgen, topo, dut,
     -----
     input_dict = {
         "11.0.0.0/8": {
-            "Summary address": "11.0.0.0/8",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5
+            "summaryAddress": "11.0.0.0/8",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5
         }
     }
     result = verify_ospf_summary(tgen, topo, dut, input_dict)
@@ -1586,7 +1586,7 @@ def verify_ospf_summary(tgen, topo, dut,
     for ospf_summ, summ_data in ospf_summary_data.items():
         if ospf_summ not in show_ospf_json:
             continue
-        summary = ospf_summary_data[ospf_summ]["Summary address"]
+        summary = ospf_summary_data[ospf_summ]["summaryAddress"]
 
         if summary in show_ospf_json:
             for summ in summ_data:
diff -urpN frr-frr-8.4.2/tests/topotests/lib/pim.py frr-frr-8.5/tests/topotests/lib/pim.py
--- frr-frr-8.4.2/tests/topotests/lib/pim.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/pim.py	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ from lib.common_config import (
     retry,
     run_frr_cmd,
     validate_ip_address,
+    get_frr_ipv6_linklocal,
 )
 from lib.micronet import get_exec_path
 from lib.topolog import logger
@@ -48,7 +49,7 @@ CWD = os.path.dirname(os.path.realpath(_
 
 def create_pim_config(tgen, topo, input_dict=None, build=False, load_config=True):
     """
-    API to configure pim/pimv6 on router
+    API to configure pim/pim6 on router
 
     Parameters
     ----------
@@ -149,7 +150,7 @@ def _add_pim_rp_config(tgen, topo, input
         if "rp" in input_dict[router]["pim"]:
             rp_data += pim_data["rp"]
 
-    # PIMv6
+    # pim6
     pim6_data = None
     if "pim6" in input_dict[router]:
         pim6_data = input_dict[router]["pim6"]
@@ -370,7 +371,7 @@ def create_igmp_config(tgen, topo, input
 
 def create_mld_config(tgen, topo, input_dict=None, build=False):
     """
-    API to configure mld for PIMv6 on router
+    API to configure mld for pim6 on router
 
     Parameters
     ----------
@@ -515,6 +516,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ip pim")
 
+        if "pim" in input_dict[router]:
+            if "disable" in input_dict[router]["pim"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ip pim")
+
         if "pim6" in data and data["pim6"] == "enable":
             # Loopback interfaces
             if "type" in data and data["type"] == "loopback":
@@ -526,6 +540,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ipv6 pim")
 
+        if "pim6" in input_dict[router]:
+            if "disable" in input_dict[router]["pim6"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim6"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ipv6 pim")
+
     # pim global config
     if "pim" in input_dict[router]:
         pim_data = input_dict[router]["pim"]
@@ -797,6 +824,134 @@ def verify_pim_neighbors(tgen, topo, dut
     return True
 
 
+@retry(retry_timeout=12)
+def verify_pim6_neighbors(tgen, topo, dut=None, iface=None, nbr_ip=None, expected=True):
+    """
+    Verify all pim6 neighbors are up and running, config is verified
+    using "show ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `iface` : link for which PIM nbr need to check
+    * `nbr_ip` : neighbor ip of interface
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_pim6_neighbors(tgen, topo, dut, iface=ens192, nbr_ip=20.1.1.2)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if dut is not None and dut != router:
+            continue
+
+        rnode = tgen.routers()[router]
+        show_ip_pim_neighbor_json = rnode.vtysh_cmd(
+            "show ipv6 pim neighbor json", isjson=True
+        )
+
+        for destLink, data in topo["routers"][router]["links"].items():
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if iface is not None and iface != data["interface"]:
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            if "pim6" in data and data["pim6"] == "disable":
+                continue
+
+            if "pim6" in data and data["pim6"] == "enable":
+                local_interface = data["interface"]
+
+            if "-" in destLink:
+                # Spliting and storing destRouterLink data in tempList
+                tempList = destLink.split("-")
+
+                # destRouter
+                destLink = tempList.pop(0)
+
+                # Current Router Link
+                tempList.insert(0, router)
+                curRouter = "-".join(tempList)
+            else:
+                curRouter = router
+            if destLink not in topo["routers"]:
+                continue
+            data = topo["routers"][destLink]["links"][curRouter]
+            peer_interface = data["interface"]
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            logger.info("[DUT: %s]: Verifying PIM neighbor status:", router)
+
+            if "pim6" in data and data["pim6"] == "enable":
+                pim_nh_intf_ip = get_frr_ipv6_linklocal(tgen, destLink, peer_interface)
+
+                # Verifying PIM neighbor
+                if local_interface in show_ip_pim_neighbor_json:
+                    if show_ip_pim_neighbor_json[local_interface]:
+                        if (
+                            show_ip_pim_neighbor_json[local_interface][pim_nh_intf_ip][
+                                "neighbor"
+                            ]
+                            != pim_nh_intf_ip
+                        ):
+                            errormsg = (
+                                "[DUT %s]: Local interface: %s, PIM6"
+                                " neighbor check failed "
+                                "Expected neighbor: %s, Found neighbor:"
+                                " %s"
+                                % (
+                                    router,
+                                    local_interface,
+                                    pim_nh_intf_ip,
+                                    show_ip_pim_neighbor_json[local_interface][
+                                        pim_nh_intf_ip
+                                    ]["neighbor"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: Local interface: %s, Found"
+                            " expected PIM6 neighbor %s",
+                            router,
+                            local_interface,
+                            pim_nh_intf_ip,
+                        )
+                    else:
+                        errormsg = (
+                            "[DUT %s]: Local interface: %s, and"
+                            "interface ip: %s is not found in "
+                            "PIM6 neighbor " % (router, local_interface, pim_nh_intf_ip)
+                        )
+                        return errormsg
+                else:
+                    errormsg = (
+                        "[DUT %s]: Local interface: %s, is not "
+                        "present in PIM6 neighbor " % (router, local_interface)
+                    )
+                    return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_igmp_groups(tgen, dut, interface, group_addresses, expected=True):
     """
@@ -871,7 +1026,7 @@ def verify_igmp_groups(tgen, dut, interf
     return True
 
 
-@retry(retry_timeout=60, diag_pct=0)
+@retry(retry_timeout=60, diag_pct=2)
 def verify_upstream_iif(
     tgen,
     dut,
@@ -879,7 +1034,9 @@ def verify_upstream_iif(
     src_address,
     group_addresses,
     joinState=None,
+    regState=None,
     refCount=1,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -910,7 +1067,6 @@ def verify_upstream_iif(
     -------
     errormsg(str) or True
     """
-
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     if dut not in tgen.routers():
@@ -919,7 +1075,8 @@ def verify_upstream_iif(
     rnode = tgen.routers()[dut]
 
     logger.info(
-        "[DUT: %s]: Verifying upstream Inbound Interface" " for IGMP groups received:",
+        "[DUT: %s]: Verifying upstream Inbound Interface"
+        " for IGMP/MLD groups received:",
         dut,
     )
 
@@ -979,16 +1136,18 @@ def verify_upstream_iif(
                         if group_addr_json[src_address]["joinState"] != "Joined":
                             errormsg = (
                                 "[DUT %s]: Verifying iif "
-                                "(Inbound Interface) for (%s,%s) and"
-                                " joinState :%s [FAILED]!! "
-                                " Expected: %s, Found: %s"
+                                "(Inbound Interface) and joinState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "joinState :%s , Found joinState: %s"
                                 % (
                                     dut,
                                     src_address,
                                     grp_addr,
-                                    group_addr_json[src_address]["joinState"],
                                     in_interface,
                                     group_addr_json[src_address]["inboundInterface"],
+                                    joinState,
+                                    group_addr_json[src_address]["joinState"],
                                 )
                             )
                             return errormsg
@@ -996,28 +1155,51 @@ def verify_upstream_iif(
                     elif group_addr_json[src_address]["joinState"] != joinState:
                         errormsg = (
                             "[DUT %s]: Verifying iif "
-                            "(Inbound Interface) for (%s,%s) and"
-                            " joinState :%s [FAILED]!! "
-                            " Expected: %s, Found: %s"
+                            "(Inbound Interface) and joinState "
+                            "for (%s, %s), Expected iif: %s, "
+                            "Found iif : %s,  and Expected "
+                            "joinState :%s , Found joinState: %s"
                             % (
                                 dut,
                                 src_address,
                                 grp_addr,
-                                group_addr_json[src_address]["joinState"],
                                 in_interface,
                                 group_addr_json[src_address]["inboundInterface"],
+                                joinState,
+                                group_addr_json[src_address]["joinState"],
                             )
                         )
                         return errormsg
 
+                    if regState:
+                        if group_addr_json[src_address]["regState"] != regState:
+                            errormsg = (
+                                "[DUT %s]: Verifying iif "
+                                "(Inbound Interface) and regState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "regState :%s , Found regState: %s"
+                                % (
+                                    dut,
+                                    src_address,
+                                    grp_addr,
+                                    in_interface,
+                                    group_addr_json[src_address]["inboundInterface"],
+                                    regState,
+                                    group_addr_json[src_address]["regState"],
+                                )
+                            )
+                            return errormsg
+
                     logger.info(
                         "[DUT %s]: Verifying iif(Inbound Interface)"
-                        " for (%s,%s) and joinState is %s [PASSED]!! "
+                        " for (%s,%s) and joinState is %s regstate is %s [PASSED]!! "
                         " Found Expected: (%s)",
                         dut,
                         src_address,
                         grp_addr,
                         group_addr_json[src_address]["joinState"],
+                        group_addr_json[src_address]["regState"],
                         group_addr_json[src_address]["inboundInterface"],
                     )
         if not found:
@@ -1036,13 +1218,13 @@ def verify_upstream_iif(
             )
             return errormsg
 
-        logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
-        return True
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
 
 
 @retry(retry_timeout=12)
 def verify_join_state_and_timer(
-    tgen, dut, iif, src_address, group_addresses, expected=True
+    tgen, dut, iif, src_address, group_addresses, addr_type="ipv4", expected=True
 ):
     """
     Verify  join state is updated correctly and join timer is
@@ -1178,6 +1360,7 @@ def verify_mroutes(
     oil,
     return_uptime=False,
     mwait=0,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1393,6 +1576,7 @@ def verify_pim_rp_info(
     rp=None,
     source=None,
     iamrp=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1578,6 +1762,7 @@ def verify_pim_state(
     group_addresses,
     src_address=None,
     installed_fl=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1642,12 +1827,12 @@ def verify_pim_state(
         else:
             pim_state_json = show_pim_state_json[grp_addr][src_address]
 
-        if pim_state_json["Installed"] == installed_fl:
+        if pim_state_json["installed"] == installed_fl:
             logger.info(
                 "[DUT %s]: group  %s is installed flag: %s",
                 dut,
                 grp_addr,
-                pim_state_json["Installed"],
+                pim_state_json["installed"],
             )
             for interface, data in pim_state_json[iif].items():
                 if interface != oil:
@@ -1697,7 +1882,7 @@ def verify_pim_state(
 
 def get_pim_interface_traffic(tgen, input_dict):
     """
-    get ip pim interface traffice by running
+    get ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -1768,9 +1953,82 @@ def get_pim_interface_traffic(tgen, inpu
     return output_dict
 
 
+def get_pim6_interface_traffic(tgen, input_dict):
+    """
+    get ipv6 pim interface traffic by running
+    "show ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict(dict)`: defines DUT, what and from which interfaces
+                          traffic needs to be retrieved
+    Usage
+    -----
+    input_dict = {
+        "r1": {
+            "r1-r0-eth0": {
+                "helloRx": 0,
+                "helloTx": 1,
+                "joinRx": 0,
+                "joinTx": 0
+            }
+        }
+    }
+
+    result = get_pim_interface_traffic(tgen, input_dict)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    output_dict = {}
+    for dut in input_dict.keys():
+        if dut not in tgen.routers():
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Verifying pim interface traffic", dut)
+
+        def show_pim_intf_traffic(rnode, dut, input_dict, output_dict):
+            show_pim_intf_traffic_json = run_frr_cmd(
+                rnode, "show ipv6 pim interface traffic json", isjson=True
+            )
+
+            output_dict[dut] = {}
+            for intf, data in input_dict[dut].items():
+                interface_json = show_pim_intf_traffic_json[intf]
+                for state in data:
+
+                    # Verify Tx/Rx
+                    if state in interface_json:
+                        output_dict[dut][state] = interface_json[state]
+                    else:
+                        errormsg = (
+                            "[DUT %s]: %s is not present"
+                            "for interface %s [FAILED]!! " % (dut, state, intf)
+                        )
+                        return errormsg
+            return None
+
+        test_func = functools.partial(
+            show_pim_intf_traffic, rnode, dut, input_dict, output_dict
+        )
+        (result, out) = topotest.run_and_expect(test_func, None, count=20, wait=1)
+        if not result:
+            return out
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return output_dict
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_pim_interface(
-    tgen, topo, dut, interface=None, interface_ip=None, expected=True
+    tgen, topo, dut, interface=None, interface_ip=None, addr_type="ipv4", expected=True
 ):
     """
     Verify all PIM interface are up and running, config is verified
@@ -1803,29 +2061,48 @@ def verify_pim_interface(
         logger.info("[DUT: %s]: Verifying PIM interface status:", dut)
 
         rnode = tgen.routers()[dut]
-        show_ip_pim_interface_json = rnode.vtysh_cmd(
-            "show ip pim interface json", isjson=True
+
+        if addr_type == "ipv4":
+            addr_cmd = "ip"
+            pim_cmd = "pim"
+        elif addr_type == "ipv6":
+            addr_cmd = "ipv6"
+            pim_cmd = "pim6"
+        show_pim_interface_json = rnode.vtysh_cmd(
+            "show {} pim interface json".format(addr_cmd), isjson=True
         )
 
-        logger.info("show_ip_pim_interface_json: \n %s", show_ip_pim_interface_json)
+        logger.info("show_pim_interface_json: \n %s", show_pim_interface_json)
 
         if interface_ip:
-            if interface in show_ip_pim_interface_json:
-                pim_intf_json = show_ip_pim_interface_json[interface]
+            if interface in show_pim_interface_json:
+                pim_intf_json = show_pim_interface_json[interface]
                 if pim_intf_json["address"] != interface_ip:
                     errormsg = (
-                        "[DUT %s]: PIM interface "
-                        "ip is not correct "
+                        "[DUT %s]: %s interface "
+                        "%s is not correct "
                         "[FAILED]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return errormsg
                 else:
                     logger.info(
-                        "[DUT %s]: PIM interface "
-                        "ip is correct "
+                        "[DUT %s]: %s interface "
+                        "%s is correct "
                         "[Passed]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return True
         else:
@@ -1833,17 +2110,17 @@ def verify_pim_interface(
                 if "type" in data and data["type"] == "loopback":
                     continue
 
-                if "pim" in data and data["pim"] == "enable":
+                if pim_cmd in data and data[pim_cmd] == "enable":
                     pim_interface = data["interface"]
-                    pim_intf_ip = data["ipv4"].split("/")[0]
+                    pim_intf_ip = data[addr_type].split("/")[0]
 
-                    if pim_interface in show_ip_pim_interface_json:
-                        pim_intf_json = show_ip_pim_interface_json[pim_interface]
+                    if pim_interface in show_pim_interface_json:
+                        pim_intf_json = show_pim_interface_json[pim_interface]
                     else:
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, not Found"
-                            % (dut, pim_interface, pim_intf_ip)
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, not Found"
+                            % (dut, pim_cmd, pim_interface, addr_cmd, pim_intf_ip)
                         )
                         return errormsg
 
@@ -1853,12 +2130,14 @@ def verify_pim_interface(
                         and pim_intf_json["state"] != "up"
                     ):
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, status check "
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, status check "
                             "[FAILED]!! Expected : %s, Found : %s"
                             % (
                                 dut,
+                                pim_cmd,
                                 pim_interface,
+                                addr_cmd,
                                 pim_intf_ip,
                                 pim_interface,
                                 pim_intf_json["state"],
@@ -1867,11 +2146,13 @@ def verify_pim_interface(
                         return errormsg
 
                     logger.info(
-                        "[DUT %s]: PIM interface: %s, "
-                        "interface ip: %s, status: %s"
+                        "[DUT %s]: %s interface: %s, "
+                        "interface %s: %s, status: %s"
                         " [PASSED]!!",
                         dut,
+                        pim_cmd,
                         pim_interface,
+                        addr_cmd,
                         pim_intf_ip,
                         pim_intf_json["state"],
                     )
@@ -1882,8 +2163,8 @@ def verify_pim_interface(
 
 def clear_pim_interface_traffic(tgen, topo):
     """
-    Clear ip/ipv6 pim interface traffice by running
-    "clear ip/ipv6 pim interface traffic" cli
+    Clear ip pim interface traffic by running
+    "clear ip pim interface traffic" cli
 
     Parameters
     ----------
@@ -1914,6 +2195,74 @@ def clear_pim_interface_traffic(tgen, to
     return True
 
 
+def clear_pim6_interface_traffic(tgen, topo):
+    """
+    Clear ipv6 pim interface traffic by running
+    "clear ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interface_traffic(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interface traffic", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface traffic")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
+def clear_pim6_interfaces(tgen, topo):
+    """
+    Clear ipv6 pim interface by running
+    "clear ipv6 pim interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interfaces(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interfaces", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def clear_pim_interfaces(tgen, dut):
     """
     Clear ip/ipv6 pim interface by running
@@ -1961,8 +2310,8 @@ def clear_pim_interfaces(tgen, dut):
     # Waiting for maximum 60 sec
     fail_intf = []
     for retry in range(1, 13):
-        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         sleep(5)
+        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         run_json_after = run_frr_cmd(rnode, "show ip pim neighbor json", isjson=True)
         found = True
         for pim_intf in nh_before_clear.keys():
@@ -2212,6 +2561,35 @@ def clear_mroute(tgen, dut=None):
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
+def clear_pim6_mroute(tgen, dut=None):
+    """
+    Clear ipv6 mroute by running "clear ipv6 mroute" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test, default None
+
+    Usage
+    -----
+    clear_mroute(tgen, dut)
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        logger.debug("[DUT: %s]: Clearing ipv6 mroute", router)
+        rnode.vtysh_cmd("clear ipv6 mroute")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def reconfig_interfaces(tgen, topo, senderRouter, receiverRouter, packet=None):
     """
     Configure interface ip for sender and receiver routers
@@ -2812,7 +3190,14 @@ def enable_disable_pim_bsm(tgen, router,
 
 @retry(retry_timeout=60, diag_pct=0)
 def verify_pim_join(
-    tgen, topo, dut, interface, group_addresses, src_address=None, expected=True
+    tgen,
+    topo,
+    dut,
+    interface,
+    group_addresses,
+    src_address=None,
+    addr_type="ipv4",
+    expected=True,
 ):
     """
     Verify ip/ipv6 pim join by running "show ip/ipv6 pim join" cli
@@ -2846,11 +3231,22 @@ def verify_pim_join(
     rnode = tgen.routers()[dut]
 
     logger.info("[DUT: %s]: Verifying pim join", dut)
-    show_pim_join_json = run_frr_cmd(rnode, "show ip pim join json", isjson=True)
 
     if type(group_addresses) is not list:
         group_addresses = [group_addresses]
 
+    for grp in group_addresses:
+        addr_type = validate_ip_address(grp)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    show_pim_join_json = run_frr_cmd(
+        rnode, "show {} pim join json".format(ip_cmd), isjson=True
+    )
+
     for grp_addr in group_addresses:
         # Verify if IGMP is enabled in DUT
         if "igmp" not in topo["routers"][dut]:
@@ -3660,7 +4056,7 @@ def verify_multicast_flag_state(
 
 
 @retry(retry_timeout=40, diag_pct=0)
-def verify_igmp_interface(tgen, topo, dut, igmp_iface, interface_ip, expected=True):
+def verify_igmp_interface(tgen, dut, igmp_iface, interface_ip, expected=True):
     """
     Verify all IGMP interface are up and running, config is verified
     using "show ip igmp interface" cli
@@ -3884,7 +4280,7 @@ def verify_local_igmp_groups(tgen, dut,
 
 def verify_pim_interface_traffic(tgen, input_dict, return_stats=True, addr_type="ipv4"):
     """
-    Verify ip pim interface traffice by running
+    Verify ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -3950,6 +4346,661 @@ def verify_pim_interface_traffic(tgen, i
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
     return True if return_stats == False else output_dict
 
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_groups(tgen, dut, interface, group_addresses, expected=True):
+    """
+    Verify IGMP groups are received from an intended interface
+    by running "show ip mld groups" command
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `interface`: interface, from which MLD groups would be received
+    * `group_addresses`: MLD group address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    dut = "r1"
+    interface = "r1-r0-eth0"
+    group_address = "ffaa::1"
+    result = verify_mld_groups(tgen, dut, interface, group_address)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mld groups received:", dut)
+    show_mld_json = run_frr_cmd(rnode, "show ipv6 mld groups json", isjson=True)
+
+    if type(group_addresses) is not list:
+        group_addresses = [group_addresses]
+
+    if interface in show_mld_json:
+        show_mld_json = show_mld_json[interface]["groups"]
+    else:
+        errormsg = (
+            "[DUT %s]: Verifying MLD group received"
+            " from interface %s [FAILED]!! " % (dut, interface)
+        )
+        return errormsg
+
+    found = False
+    for grp_addr in group_addresses:
+        for index in show_mld_json:
+            if index["group"] == grp_addr:
+                found = True
+                break
+        if found is not True:
+            errormsg = (
+                "[DUT %s]: Verifying MLD group received"
+                " from interface %s [FAILED]!! "
+                " Expected not found: %s" % (dut, interface, grp_addr)
+            )
+            return errormsg
+
+        logger.info(
+            "[DUT %s]: Verifying MLD group %s received "
+            "from interface %s [PASSED]!! ",
+            dut,
+            grp_addr,
+            interface,
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_interface(tgen, dut, mld_iface, interface_ip, expected=True):
+    """
+    Verify all IGMP interface are up and running, config is verified
+    using "show ip mld interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : device under test
+    * `mld_iface` : interface name
+    * `interface_ip` : interface ip address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_mld_interface(tgen, topo, dut, mld_iface, interface_ip)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if router != dut:
+            continue
+
+        logger.info("[DUT: %s]: Verifying MLD interface status:", dut)
+
+        rnode = tgen.routers()[dut]
+        show_mld_interface_json = run_frr_cmd(
+            rnode, "show ipv6 mld interface json", isjson=True
+        )
+
+        if mld_iface in show_mld_interface_json:
+            mld_intf_json = show_mld_interface_json[mld_iface]
+            # Verifying igmp interface
+            if mld_intf_json["address"] != interface_ip:
+                errormsg = (
+                    "[DUT %s]: igmp interface ip is not correct "
+                    "[FAILED]!! Expected : %s, Found : %s"
+                    % (dut, mld_intf_json["address"], interface_ip)
+                )
+                return errormsg
+
+            logger.info(
+                "[DUT %s]: igmp interface: %s, " "interface ip: %s" " [PASSED]!!",
+                dut,
+                mld_iface,
+                interface_ip,
+            )
+        else:
+            errormsg = (
+                "[DUT %s]: igmp interface: %s "
+                "igmp interface ip: %s, is not present "
+                % (dut, mld_iface, interface_ip)
+            )
+            return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mld_config(tgen, input_dict, stats_return=False, expected=True):
+    """
+    Verify mld interface details, verifying following configs:
+    timerQueryInterval
+    timerQueryResponseIntervalMsec
+    lastMemberQueryCount
+    timerLastMemberQueryMsec
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict` : Input dict data, required to verify
+                     timer
+    * `stats_return`: If user wants API to return statistics
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    input_dict ={
+        "l1": {
+            "mld": {
+                "interfaces": {
+                    "l1-i1-eth1": {
+                        "mld": {
+                            "query": {
+                                "query-interval" : 200,
+                                "query-max-response-time" : 100
+                            },
+                            "statistics": {
+                                "queryV2" : 2,
+                                "reportV2" : 1
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    result = verify_mld_config(tgen, input_dict, stats_return)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in input_dict.keys():
+        rnode = tgen.routers()[dut]
+
+        for interface, data in input_dict[dut]["igmp"]["interfaces"].items():
+
+            statistics = False
+            report = False
+            if "statistics" in input_dict[dut]["igmp"]["interfaces"][interface]["igmp"]:
+                statistics = True
+                cmd = "show ipv6 mld statistics"
+            else:
+                cmd = "show ipv6 mld"
+
+            logger.info("[DUT: %s]: Verifying MLD interface %s detail:", dut, interface)
+
+            if statistics:
+                if (
+                    "report"
+                    in input_dict[dut]["mld"]["interfaces"][interface]["mld"][
+                        "statistics"
+                    ]
+                ):
+                    report = True
+
+            if statistics and report:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} json".format(cmd), isjson=True
+                )
+                intf_detail_json = show_ipv6_mld_intf_json["global"]
+            else:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} interface {} json".format(cmd, interface), isjson=True
+                )
+
+            if not report:
+                if interface not in show_ipv6_mld_intf_json:
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " is not present in CLI output "
+                        "[FAILED]!! " % (dut, interface)
+                    )
+                    return errormsg
+
+                else:
+                    intf_detail_json = show_ipv6_mld_intf_json[interface]
+
+            if stats_return:
+                mld_stats = {}
+
+            if "statistics" in data["mld"]:
+                if stats_return:
+                    mld_stats["statistics"] = {}
+                for query, value in data["mld"]["statistics"].items():
+                    if query == "queryV1":
+                        # Verifying IGMP interface queryV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json["queryV1"]
+
+                        else:
+                            if intf_detail_json["queryV1"] != value:
+                                errormsg = (
+                                    "[DUT %s]: MLD interface: %s "
+                                    " queryV1 statistics verification "
+                                    "[FAILED]!! Expected : %s,"
+                                    " Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                        intf_detail_json["queryV1"],
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD interface: %s "
+                                "queryV1 statistics is %s",
+                                dut,
+                                interface,
+                                value,
+                            )
+
+                    if query == "reportV1":
+                        # Verifying IGMP interface timerV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json[
+                                "reportV1"
+                            ]
+
+                        else:
+                            if intf_detail_json["reportV1"] <= value:
+                                errormsg = (
+                                    "[DUT %s]: MLD reportV1 "
+                                    "statistics verification "
+                                    "[FAILED]!! Expected : %s "
+                                    "or more, Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD reportV1 " "statistics is %s",
+                                dut,
+                                intf_detail_json["reportV1"],
+                            )
+
+            if "query" in data["mld"]:
+                for query, value in data["mld"]["query"].items():
+                    if query == "query-interval":
+                        # Verifying IGMP interface query interval timer
+                        if intf_detail_json["timerQueryInterval"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                " query-interval verification "
+                                "[FAILED]!! Expected : %s,"
+                                " Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["timerQueryInterval"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s " "query-interval is %s",
+                            dut,
+                            interface,
+                            value,
+                        )
+
+                    if query == "query-max-response-time":
+                        # Verifying IGMP interface query max response timer
+                        if (
+                            intf_detail_json["timerQueryResponseIntervalMsec"]
+                            != value * 100
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "query-max-response-time "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerQueryResponseIntervalMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "query-max-response-time is %s ms",
+                            dut,
+                            interface,
+                            value * 100,
+                        )
+
+                    if query == "last-member-query-count":
+                        # Verifying IGMP interface last member query count
+                        if intf_detail_json["lastMemberQueryCount"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-count "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["lastMemberQueryCount"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-count is %s ms",
+                            dut,
+                            interface,
+                            value * 1000,
+                        )
+
+                    if query == "last-member-query-interval":
+                        # Verifying IGMP interface last member query interval
+                        if (
+                            intf_detail_json["timerLastMemberQueryMsec"]
+                            != value * 100 * intf_detail_json["lastMemberQueryCount"]
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-interval "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerLastMemberQueryMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-interval is %s ms",
+                            dut,
+                            interface,
+                            value * intf_detail_json["lastMemberQueryCount"] * 100,
+                        )
+
+            if "version" in data["mld"]:
+                # Verifying IGMP interface state is up
+                if intf_detail_json["state"] != "up":
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " state: %s verification "
+                        "[FAILED]!!" % (dut, interface, intf_detail_json["state"])
+                    )
+                    return errormsg
+
+                logger.info(
+                    "[DUT %s]: MLD interface: %s " "state: %s",
+                    dut,
+                    interface,
+                    intf_detail_json["state"],
+                )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True if stats_return == False else mld_stats
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_pim_nexthop(tgen, topo, dut, nexthop, addr_type):
+    """
+    Verify all PIM nexthop details using "show ip/ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `nexthop` : nexthop ip/ipv6 address
+
+    Usage
+    -----
+    result = verify_pim_nexthop(tgen, topo, dut, nexthop)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[dut]
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} pim nexthop".format(addr_type)
+    pim_nexthop = rnode.vtysh_cmd(cmd)
+
+    if nexthop in pim_nexthop:
+        logger.info("[DUT %s]: Expected nexthop: %s, Found", dut, nexthop)
+        return True
+    else:
+        errormsg = "[DUT %s]: Nexthop not found: %s" % (dut, nexthop)
+        return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mroute_summary(
+    tgen, dut, sg_mroute=None, starg_mroute=None, total_mroute=None, addr_type="ipv4"
+):
+    """
+    Verify ip mroute summary has correct (*,g) (s,G) and total mroutes
+    by running "show ip mroutes summary json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `sg_mroute`: Number of installed (s,g) mroute
+    * `starg_mroute`: Number installed of (*,g) mroute
+    * `Total_mroute`: Total number of installed mroutes
+    * 'addr_type : IPv4 or IPv6 address
+    * `return_json`: Whether to return raw json data
+
+    Usage
+    -----
+    dut = "r1"
+    sg_mroute = "4000"
+    starg_mroute= "2000"
+    total_mroute = "6000"
+    addr_type=IPv4 or IPv6
+    result = verify_mroute_summary(tgen, dut, sg_mroute=None, starg_mroute=None,
+                                        total_mroute= None)
+    Returns
+    -------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mroute summary", dut)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} mroute summary json".format(ip_cmd)
+    show_mroute_summary_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if starg_mroute is not None:
+        if show_mroute_summary_json["wildcardGroup"]["installed"] != starg_mroute:
+            logger.error(
+                "Number of installed starg are: %s but expected: %s",
+                show_mroute_summary_json["wildcardGroup"]["installed"],
+                starg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed starg routes are %s",
+            show_mroute_summary_json["wildcardGroup"]["installed"],
+        )
+
+    if sg_mroute is not None:
+        if show_mroute_summary_json["sourceGroup"]["installed"] != sg_mroute:
+            logger.error(
+                "Number of installed SG routes are: %s but expected: %s",
+                show_mroute_summary_json["sourceGroup"]["installed"],
+                sg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed SG routes are %s",
+            show_mroute_summary_json["sourceGroup"]["installed"],
+        )
+
+    if total_mroute is not None:
+        if show_mroute_summary_json["totalNumOfInstalledMroutes"] != total_mroute:
+            logger.error(
+                "Total number of installed mroutes are: %s but expected: %s",
+                show_mroute_summary_json["totalNumOfInstalledMroutes"],
+                total_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed Total mroute are %s",
+            show_mroute_summary_json["totalNumOfInstalledMroutes"],
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def verify_sg_traffic(tgen, dut, groups, src, addr_type="ipv4"):
+    """
+    Verify multicast traffic by running
+    "show ip mroute count json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `groups`: igmp or mld groups where traffic needs to be verified
+
+    Usage
+    -----
+    result = verify_sg_traffic(tgen, "r1", igmp_groups, srcaddress)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+    result = False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying multicast " "SG traffic", dut)
+
+    if addr_type == "ipv4":
+        cmd = "show ip mroute count json"
+    elif addr_type == "ipv6":
+        cmd = "show ipv6 mroute count json"
+    # import pdb; pdb.set_trace()
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if bool(show_mroute_sg_traffic_json) is False:
+        errormsg = "[DUT %s]: Json output is empty" % (dut)
+        return errormsg
+
+    before_traffic = {}
+    after_traffic = {}
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        before_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    logger.info("Waiting for 10sec traffic to increament")
+    sleep(10)
+
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        after_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    for grp in groups:
+        if after_traffic[grp] < before_traffic[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying igmp group %s source %s not increamenting traffic"
+                " [FAILED]!! " % (dut, grp, src)
+            )
+            return errormsg
+        else:
+            logger.info(
+                "[DUT %s]:igmp group %s source %s receiving traffic"
+                " [PASSED]!! " % (dut, grp, src)
+            )
+            result = True
+
+    return result
+
     # def cleanup(self):
     #     super(McastTesterHelper, self).cleanup()
 
diff -urpN frr-frr-8.4.2/tests/topotests/lib/snmptest.py frr-frr-8.5/tests/topotests/lib/snmptest.py
--- frr-frr-8.4.2/tests/topotests/lib/snmptest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/snmptest.py	2023-03-13 20:01:47.000000000 +0600
@@ -36,11 +36,12 @@ from lib.topolog import logger
 class SnmpTester(object):
     "A helper class for testing SNMP"
 
-    def __init__(self, router, iface, community, version):
+    def __init__(self, router, iface, community, version, options=""):
         self.community = community
         self.version = version
         self.router = router
         self.iface = iface
+        self.options = options
         logger.info(
             "created SNMP tester: SNMPv{0} community:{1}".format(
                 self.version, self.community
@@ -52,7 +53,9 @@ class SnmpTester(object):
         Helper function to build a string with SNMP
         configuration for commands.
         """
-        return "-v {0} -c {1} {2}".format(self.version, self.community, self.iface)
+        return "-v {0} -c {1} {2} {3}".format(
+            self.version, self.community, self.options, self.iface
+        )
 
     @staticmethod
     def _get_snmp_value(snmp_output):
diff -urpN frr-frr-8.4.2/tests/topotests/lib/topotest.py frr-frr-8.5/tests/topotests/lib/topotest.py
--- frr-frr-8.4.2/tests/topotests/lib/topotest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/lib/topotest.py	2023-03-13 20:01:47.000000000 +0600
@@ -355,6 +355,16 @@ def run_and_expect(func, what, count=20,
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum {} tries)".format(
             func_name, wait, count
@@ -402,6 +412,16 @@ def run_and_expect_type(func, etype, cou
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum wait {} secs)".format(
             func_name, wait, int(wait * count)
@@ -1868,15 +1888,16 @@ class Router(Node):
                 # Exclude empty string at end of list
                 for d in dmns[:-1]:
                     if re.search(r"%s" % daemon, d):
-                        daemonpid = self.cmd("cat %s" % d.rstrip()).rstrip()
+                        daemonpidfile = d.rstrip()
+                        daemonpid = self.cmd("cat %s" % daemonpidfile).rstrip()
                         if daemonpid.isdigit() and pid_exists(int(daemonpid)):
                             logger.info(
                                 "{}: killing {}".format(
                                     self.name,
-                                    os.path.basename(d.rstrip().rsplit(".", 1)[0]),
+                                    os.path.basename(daemonpidfile.rsplit(".", 1)[0]),
                                 )
                             )
-                            self.cmd("kill -9 %s" % daemonpid)
+                            os.kill(int(daemonpid), signal.SIGKILL)
                             if pid_exists(int(daemonpid)):
                                 numRunning += 1
                         while wait and numRunning > 0:
@@ -1902,12 +1923,12 @@ class Router(Node):
                                                 ),
                                             )
                                         )
-                                        self.cmd("kill -9 %s" % daemonpid)
+                                        os.kill(int(daemonpid), signal.SIGKILL)
                                     if daemonpid.isdigit() and not pid_exists(
                                         int(daemonpid)
                                     ):
                                         numRunning -= 1
-                        self.cmd("rm -- {}".format(d.rstrip()))
+                        self.cmd("rm -- {}".format(daemonpidfile))
                     if wait:
                         errors = self.checkRouterCores(reportOnce=True)
                         if self.checkRouterVersion("<", minErrorVersion):
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/multicast_pim6_static_rp.json frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/multicast_pim6_static_rp.json
--- frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/multicast_pim6_static_rp.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/multicast_pim6_static_rp.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,197 @@
+{
+    "address_types": ["ipv6"],
+    "ipv6base": "fd00::",
+    "ipv6mask": 64,
+    "link_ip_start": {
+        "ipv6": "fd00::",
+        "v6mask": 64
+    },
+    "lo_prefix": {
+        "ipv6": "2001:db8:f::",
+        "v6mask": 128
+    },
+    "routers": {
+        "r0": {
+            "links": {
+                "r1": {"ipv6": "auto"}
+            }
+        },
+        "r1": {
+            "links": {
+                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r0": {"ipv6": "auto", "pim6": "enable"},
+                "r2": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r3": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r4": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }}
+            },
+            "ospf6": {
+                "router_id": "100.1.1.0",
+                "neighbors": {
+                    "r2": {},
+                    "r3": {},
+                    "r4": {}
+                },
+                "redistribute": [
+                    {
+                        "redist_type": "static"
+                    },
+                    {
+                        "redist_type": "connected"
+                    }
+                ]
+            },
+            "mld": {
+                "interfaces": {
+                    "r1-r0-eth0" :{
+                        "mld":{
+                        }
+                    }
+                }
+            }
+        },
+        "r2": {
+            "links": {
+                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r1": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r3": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }}
+            },
+            "ospf6": {
+                "router_id": "100.1.1.1",
+                "neighbors": {
+                    "r1": {},
+                    "r3": {}
+                },
+                "redistribute": [
+                    {
+                        "redist_type": "static"
+                    },
+                    {
+                        "redist_type": "connected"
+                    }
+                ]
+            }
+        },
+        "r3": {
+            "links": {
+                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r1": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r2": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r4": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r5": {"ipv6": "auto", "pim6": "enable"}
+            },
+            "ospf6": {
+                "router_id": "100.1.1.2",
+                "neighbors": {
+                    "r1": {},
+                    "r2": {},
+                    "r4": {}
+                },
+                "redistribute": [
+                    {
+                        "redist_type": "static"
+                    },
+                    {
+                        "redist_type": "connected"
+                    }
+                ]
+            }
+        },
+        "r4": {
+            "links": {
+                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r1": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }},
+                "r3": {"ipv6": "auto", "pim6": "enable",
+                "ospf6": {
+                    "area": "0.0.0.0",
+                    "hello_interval": 1,
+                    "dead_interval": 4
+                }}
+            },
+            "ospf6": {
+                "router_id": "100.1.1.3",
+                "neighbors": {
+                    "r1": {},
+                    "r3": {}
+                },
+                "redistribute": [
+                    {
+                        "redist_type": "static"
+                    },
+                    {
+                        "redist_type": "connected"
+                    }
+                ]
+            }
+        },
+        "r5": {
+            "links": {
+                "r3": {"ipv6": "auto"}
+            }
+        }
+    }
+}
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp1.py frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp1.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp1.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp1.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,1308 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Following tests are covered to test Multicast basic functionality:
+
+Topology:
+
+                 _______r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+                |             |
+                |_____________|
+                        r4
+
+Test steps
+- Create topology (setup module)
+- Bring up topology
+
+1. Verify upstream interfaces(IIF) and join state are updated
+    properly after adding and deleting the static RP
+2. Verify IIF and OIL in "show ipv6 PIM6 state" updated properly when
+    RP becomes unreachable
+3. Verify RP becomes reachable after MLD join received, PIM6 join
+    towards RP is sent immediately
+4. Verify (*,G) and (S,G) populated correctly when SPT and RPT
+    share the same path
+5. Verify OIF and RPF for (*,G) and (S,G) when static RP configure
+    in LHR router
+6. Verify OIF and RFP for (*,G) and (S,G) when static RP configure
+    in FHR router
+7. Verify (*,G) and (S,G) populated correctly when RPT and SPT path
+    are different
+8. Verify PIM6 join send towards the higher preferred RP
+9. Verify PIM6 prune send towards the lower preferred RP
+"""
+
+import os
+import sys
+import json
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# Required to instantiate the topology builder class.
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    write_test_footer,
+    reset_config_on_routers,
+    step,
+    shutdown_bringup_interface,
+    kill_router_daemons,
+    start_router_daemons,
+    create_static_routes,
+    check_router_status,
+    socat_send_mld_join,
+    socat_send_pim6_traffic,
+    kill_socat,
+)
+from lib.pim import (
+    create_pim_config,
+    verify_upstream_iif,
+    verify_join_state_and_timer,
+    verify_mroutes,
+    verify_pim_neighbors,
+    verify_pim_interface_traffic,
+    verify_pim_rp_info,
+    verify_pim_state,
+    clear_pim6_interface_traffic,
+    clear_pim6_mroute,
+    verify_pim6_neighbors,
+    get_pim6_interface_traffic,
+    clear_pim6_interfaces,
+    verify_mld_groups,
+)
+from lib.topolog import logger
+from lib.topojson import build_topo_from_json, build_config_from_json
+
+# Global variables
+GROUP_RANGE_1 = "ff08::/64"
+GROUP_ADDRESS_1 = "ff08::1"
+GROUP_RANGE_3 = "ffaa::/64"
+GROUP_ADDRESS_3 = "ffaa::1"
+GROUP_RANGE_4 = "ff00::/8"
+GROUP_ADDRESS_4 = "ff00::1"
+STAR = "*"
+SOURCE = "Static"
+ASSERT_MSG = "Testcase {} : Failed Error: {}"
+
+pytestmark = [pytest.mark.pim6d]
+
+
+def build_topo(tgen):
+    """Build function"""
+
+    # Building topology from json file
+    build_topo_from_json(tgen, TOPO)
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: %s", testsuite_run_time)
+    logger.info("=" * 40)
+
+    topology = """
+
+                 _______r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+                |             |
+                |_____________|
+                        r4
+
+    """
+    logger.info("Master Topology: \n %s", topology)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/multicast_pim6_static_rp.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global TOPO
+    TOPO = tgen.json_topo
+
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, TOPO)
+
+    # Verify PIM6 neighbors
+    result = verify_pim6_neighbors(tgen, TOPO)
+    assert result is True, "setup_module :Failed \n Error:" " {}".format(result)
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info("Testsuite end time: %s", time.asctime(time.localtime(time.time())))
+    logger.info("=" * 40)
+
+
+#####################################################
+#
+#   Local API
+#
+#####################################################
+
+
+def verify_state_incremented(state_before, state_after):
+    """
+    API to compare interface traffic state incrementing
+
+    Parameters
+    ----------
+    * `state_before` : State dictionary for any particular instance
+    * `state_after` : State dictionary for any particular instance
+    """
+
+    for router, state_data in state_before.items():
+        for state, value in state_data.items():
+            if state_before[router][state] >= state_after[router][state]:
+                errormsg = (
+                    "[DUT: %s]: state %s value has not"
+                    " incremented, Initial value: %s, "
+                    "Current value: %s [FAILED!!]"
+                    % (
+                        router,
+                        state,
+                        state_before[router][state],
+                        state_after[router][state],
+                    )
+                )
+                return errormsg
+
+            logger.info(
+                "[DUT: %s]: State %s value is "
+                "incremented, Initial value: %s, Current value: %s"
+                " [PASSED!!]",
+                router,
+                state,
+                state_before[router][state],
+                state_after[router][state],
+            )
+
+    return True
+
+
+#####################################################
+#
+#   Testcases
+#
+#####################################################
+
+
+def test_pim6_add_delete_static_RP_p0(request):
+    """
+    Verify upstream interfaces(IIF) and join state are updated
+        properly after adding and deleting the static RP
+    Verify IIF and OIL in "show ipv6 PIM6 state" updated properly when
+        RP becomes unreachable
+    Verify RP becomes reachable after MLD join received, PIM6 join
+               towards RP is sent immediately
+
+    TOPOlogy used:
+         r0------r1-----r2
+       iperf    DUT     RP
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Shut link b/w R1 and R3 and R1 and R4 as per testcase topology")
+    intf_r1_r3 = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    intf_r1_r4 = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    for intf in [intf_r1_r3, intf_r1_r4]:
+        shutdown_bringup_interface(tgen, "r1", intf, ifaceaction=False)
+
+    step("Enable PIM6 between r1 and r2")
+    step(
+        "Enable MLD on r1 interface and send MLD " "join {} to r1".format(GROUP_RANGE_1)
+    )
+    step("Configure r2 loopback interface as RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify show ipv6 mld group without any MLD join")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1, expected=False)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r1: mld group present without any MLD join \n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("Verify show ipv6 PIM6 interface traffic without any mld join")
+    state_dict = {
+        "r1": {TOPO["routers"]["r1"]["links"]["r2"]["interface"]: ["pruneTx"]}
+    }
+
+    state_before = verify_pim_interface_traffic(tgen, state_dict, addr_type="ipv6")
+    assert isinstance(
+        state_before, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    step("send mld join {} to R1".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify RP info")
+    dut = "r1"
+    oif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    iif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(tgen, TOPO, dut, GROUP_RANGE_1, oif, rp_address, SOURCE)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, oif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, oif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify PIM6 state")
+    result = verify_pim_state(tgen, dut, oif, iif, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify ip mroutes")
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, oif, iif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Delete RP configuration")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                        "delete": True,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify RP info")
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_RANGE_1, oif, rp_address, SOURCE, expected=False
+    )
+    assert (
+        result is not True
+    ), "Testcase {} :Failed \n " "RP: {} info is still present \n Error: {}".format(
+        tc_name, rp_address, result
+    )
+
+    step("r1: Verify upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, oif, STAR, GROUP_ADDRESS_1, expected=False)
+    assert result is not True, (
+        "Testcase {} :Failed \n "
+        "Upstream ({}, {}) is still in join state \n Error: {}".format(
+            tc_name, STAR, GROUP_ADDRESS_1, result
+        )
+    )
+
+    step("r1: Verify upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, oif, STAR, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} :Failed \n "
+        "Upstream ({}, {}) timer is still running \n Error: {}".format(
+            tc_name, STAR, GROUP_ADDRESS_1, result
+        )
+    )
+
+    step("r1: Verify PIM6 state")
+    result = verify_pim_state(tgen, dut, oif, iif, GROUP_ADDRESS_1, expected=False)
+    assert result is not True, (
+        "Testcase {} :Failed \n "
+        "PIM state for group: {} is still Active \n Error: {}".format(
+            tc_name, GROUP_ADDRESS_1, result
+        )
+    )
+
+    step("r1: Verify ip mroutes")
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, oif, iif, expected=False)
+    assert result is not True, (
+        "Testcase {} :Failed \n "
+        "mroute ({}, {}) is still present \n Error: {}".format(
+            tc_name, STAR, GROUP_ADDRESS_1, result
+        )
+    )
+
+    step("r1: Verify show ipv6 PIM6 interface traffic without any MLD join")
+    state_after = verify_pim_interface_traffic(tgen, state_dict, addr_type="ipv6")
+    assert isinstance(
+        state_after, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    result = verify_state_incremented(state_before, state_after)
+    assert result is True, "Testcase{} : Failed Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_SPT_RPT_path_same_p1(request):
+    """
+    Verify (*,G) and (S,G) populated correctly when SPT and RPT
+        share the same path
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1             r3-----r5
+
+    r1 : LHR
+    r2 : RP
+    r3 : FHR
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Shut link b/w R1->R3, R1->R4 and R3->R1, R3->R4 as per " "testcase topology")
+    intf_r1_r3 = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    intf_r1_r4 = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    intf_r3_r1 = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    intf_r3_r4 = TOPO["routers"]["r3"]["links"]["r4"]["interface"]
+    for intf in [intf_r1_r3, intf_r1_r4]:
+        shutdown_bringup_interface(tgen, "r1", intf, ifaceaction=False)
+
+    for intf in [intf_r3_r1, intf_r3_r4]:
+        shutdown_bringup_interface(tgen, "r3", intf, ifaceaction=False)
+
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step(
+        "Configure RP on r2 (loopback interface) for the group range {}".format(
+            GROUP_ADDRESS_1
+        )
+    )
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step(
+        "Enable MLD on r1 interface and send MLD join {} to R1".format(GROUP_ADDRESS_1)
+    )
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("Send multicast traffic from R5")
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", GROUP_ADDRESS_1, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r2: Verify RP info")
+    dut = "r2"
+    oif = "lo"
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(tgen, TOPO, dut, GROUP_RANGE_1, oif, rp_address, SOURCE)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S, G) upstream join state is up and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r2"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_RP_configured_as_LHR_p1(request):
+    """
+    Verify OIF and RPF for (*,G) and (S,G) when static RP configure
+        in LHR router
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+
+    r1 : LHR/RP
+    r3 : FHR
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+
+    step("r1: Configure r1(LHR) as RP")
+    input_dict = {
+        "r1": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r1"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Shut not Shut loopback interface")
+    shutdown_bringup_interface(tgen, "r1", "lo", False)
+    shutdown_bringup_interface(tgen, "r1", "lo", True)
+
+    step("r1: Verify RP info")
+    dut = "r1"
+    iif = "lo"
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    rp_address = TOPO["routers"]["r1"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(tgen, TOPO, dut, GROUP_RANGE_1, iif, rp_address, SOURCE)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("send mld join {} to R1".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r5: Send multicast traffic for group {}".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", GROUP_ADDRESS_1, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S, G) upstream join state is joined and join"
+        " timer is running \n Error: {}".format(tc_name, result)
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_RP_configured_as_FHR_p1(request):
+    """
+    Verify OIF and RFP for (*,G) and (S,G) when static RP configure
+        in FHR router
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+
+    r1 : LHR
+    r3 : FHR/RP
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step("r3: Configure r3(FHR) as RP")
+    input_dict = {
+        "r3": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r3"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify RP info")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    rp_address = TOPO["routers"]["r3"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(tgen, TOPO, dut, GROUP_RANGE_1, iif, rp_address, SOURCE)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("send mld join {} to R1".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r5: Send multicast traffic for group {}".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", GROUP_ADDRESS_1, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_SPT_RPT_path_different_p1(request):
+    """
+    Verify (*,G) and (S,G) populated correctly when RPT and SPT path
+        are different
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+
+    r1: LHR
+    r2: RP
+    r3: FHR
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step("r2: Configure r2 as RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r2: Verify RP info")
+    dut = "r2"
+    iif = "lo"
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_ADDRESS_1, iif, rp_address, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("send mld join {} to R1".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r5: Send multicast traffic for group {}".format(GROUP_ADDRESS_1))
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", GROUP_ADDRESS_1, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream IIF interface")
+    dut = "r2"
+    iif = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_1, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r2: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_send_join_on_higher_preffered_rp_p1(request):
+    """
+    Verify PIM6 join send towards the higher preferred RP
+    Verify PIM6 prune send towards the lower preferred RP
+
+    Topology used:
+                  _______r2
+                 |
+       iperf     |
+         r0-----r1
+                 |
+                 |_______r4
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM66 on all the interfaces of r1, r2, r3 and r4 routers")
+    step(
+        "Configure RP on r2 (loopback interface) for the group range {}".format(
+            GROUP_RANGE_4
+        )
+    )
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_4,
+                    }
+                ]
+            }
+        }
+    }
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r3 : Make all interface not reachable")
+    intf_r3_r1 = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    intf_r3_r2 = TOPO["routers"]["r3"]["links"]["r2"]["interface"]
+    intf_r3_r4 = TOPO["routers"]["r3"]["links"]["r4"]["interface"]
+    intf_r1_r3 = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    intf_r2_r3 = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    intf_r4_r3 = TOPO["routers"]["r4"]["links"]["r3"]["interface"]
+
+    for dut, intf in zip(["r1", "r2", "r3"], [intf_r1_r3, intf_r2_r3, intf_r4_r3]):
+        shutdown_bringup_interface(tgen, dut, intf, ifaceaction=False)
+
+    for intf in [intf_r3_r1, intf_r3_r4, intf_r3_r4]:
+        shutdown_bringup_interface(tgen, "r3", intf, ifaceaction=False)
+
+    step("Verify show ipv6 PIM6 interface traffic without any mld join")
+    state_dict = {"r1": {TOPO["routers"]["r1"]["links"]["r4"]["interface"]: ["joinTx"]}}
+
+    state_before = get_pim6_interface_traffic(tgen, state_dict)
+    assert isinstance(
+        state_before, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    step("r0: send mld join {} to R1".format(GROUP_ADDRESS_3))
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_3, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("Configure RP on r4 (loopback interface) for the group range " "ffaa::/128")
+    input_dict = {
+        "r4": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_3,
+                    }
+                ]
+            }
+        }
+    }
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1 : Verify RP info for group {}".format(GROUP_ADDRESS_4))
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    rp_address_1 = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_ADDRESS_4, iif, rp_address_1, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify RP info for group {}".format(GROUP_ADDRESS_3))
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    rp_address_2 = TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_ADDRESS_3, iif, rp_address_2, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify join is sent to higher preferred RP")
+    step("r1 : Verify prune is sent to lower preferred RP")
+    state_after = get_pim6_interface_traffic(tgen, state_dict)
+    assert isinstance(
+        state_after, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    result = verify_state_incremented(state_before, state_after)
+    assert result is True, "Testcase{} : Failed Error: {}".format(tc_name, result)
+
+    step("r1 : Verify ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_3, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify PIM6 state")
+    result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify upstream join state and join timer")
+    result = verify_join_state_and_timer(tgen, dut, iif, STAR, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    clear_pim6_interface_traffic(tgen, TOPO)
+
+    step("r1 : Verify joinTx, pruneTx count before RP gets deleted")
+    state_dict = {
+        "r1": {
+            TOPO["routers"]["r1"]["links"]["r2"]["interface"]: ["joinTx"],
+            TOPO["routers"]["r1"]["links"]["r4"]["interface"]: ["pruneTx"],
+        }
+    }
+    state_before = get_pim6_interface_traffic(tgen, state_dict)
+    assert isinstance(
+        state_before, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    step("r1 : Delete RP configuration for {}".format(GROUP_RANGE_3))
+    input_dict = {
+        "r4": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_3,
+                        "delete": True,
+                    }
+                ]
+            }
+        }
+    }
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1 : Verify rp-info for group {}".format(GROUP_RANGE_3))
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_RANGE_3, iif, rp_address_1, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1 : Verify rp-info for group {}".format(GROUP_RANGE_4))
+    iif = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_RANGE_4, oif, rp_address_2, SOURCE, expected=False
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r1: rp-info is present for group {} \n Error: {}".format(
+            tc_name, GROUP_RANGE_4, result
+        )
+    )
+
+    step(
+        "r1 : Verify RPF interface updated in mroute when higher preferred"
+        "RP gets deleted"
+    )
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_3, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+    logger.info("Expected behavior: %s", result)
+
+    step(
+        "r1 : Verify IIF and OIL in show ipv6 PIM6 state updated when higher"
+        "preferred overlapping RP is deleted"
+    )
+    result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step(
+        "r1 : Verify upstream IIF updated when higher preferred overlapping"
+        "RP deleted"
+    )
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_3)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step(
+        "r1 : Verify upstream join state and join timer updated when higher"
+        "preferred overlapping RP deleted"
+    )
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_3, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step(
+        "r1 : Verify join is sent to lower preferred RP, when higher"
+        "preferred RP gets deleted"
+    )
+    step(
+        "r1 : Verify prune is sent to higher preferred RP when higher"
+        " preferred RP gets deleted"
+    )
+    state_after = get_pim6_interface_traffic(tgen, state_dict)
+    assert isinstance(
+        state_after, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
+
+    result = verify_state_incremented(state_before, state_after)
+    assert result is True, "Testcase{} : Failed Error: {}".format(tc_name, result)
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp2.py frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp2.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp2.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim6_static_rp_topo1/test_multicast_pim6_static_rp2.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,1326 @@
+#!/usr/bin/env python
+
+#
+# Copyright (c) 2022 by VMware, Inc. ("VMware")
+# Used Copyright (c) 2018 by Network Device Education Foundation,
+# Inc. ("NetDEF") in this file.
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+Following tests are covered to test Multicast basic functionality:
+
+Topology:
+
+                 _______r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+                |             |
+                |_____________|
+                        r4
+
+Test steps
+- Create topology (setup module)
+- Bring up topology
+
+1. Configure multiple  groups (10 grps) with same RP address
+2. Verify IIF and OIL in updated in mroute when upstream interface
+   configure as RP
+3. Verify RP info and (*,G) mroute after deleting the RP and shut /
+    no shut the RPF interface.
+"""
+
+import os
+import sys
+import json
+import time
+import pytest
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+# Required to instantiate the topology builder class.
+
+# pylint: disable=C0413
+# Import topogen and topotest helpers
+from lib.topogen import Topogen, get_topogen
+
+from lib.common_config import (
+    start_topology,
+    write_test_header,
+    write_test_footer,
+    reset_config_on_routers,
+    step,
+    shutdown_bringup_interface,
+    kill_router_daemons,
+    start_router_daemons,
+    create_static_routes,
+    check_router_status,
+    socat_send_mld_join,
+    socat_send_pim6_traffic,
+    kill_socat,
+    create_debug_log_config,
+)
+from lib.pim import (
+    create_pim_config,
+    verify_upstream_iif,
+    verify_join_state_and_timer,
+    verify_mroutes,
+    verify_pim_neighbors,
+    verify_pim_interface_traffic,
+    verify_pim_rp_info,
+    verify_pim_state,
+    clear_pim6_interface_traffic,
+    clear_pim6_mroute,
+    verify_pim6_neighbors,
+    get_pim6_interface_traffic,
+    clear_pim6_interfaces,
+    verify_mld_groups,
+)
+from lib.topolog import logger
+from lib.topojson import build_topo_from_json, build_config_from_json
+
+# Global variables
+GROUP_RANGE_1 = "ff08::/64"
+GROUP_ADDRESS_1 = "ff08::1"
+GROUP_RANGE_3 = "ffaa::/64"
+GROUP_ADDRESS_3 = "ffaa::1"
+GROUP_RANGE_LIST_1 = [
+    "ffaa::1/128",
+    "ffaa::2/128",
+    "ffaa::3/128",
+    "ffaa::4/128",
+    "ffaa::5/128",
+]
+GROUP_RANGE_LIST_2 = [
+    "ffaa::6/128",
+    "ffaa::7/128",
+    "ffaa::8/128",
+    "ffaa::9/128",
+    "ffaa::10/128",
+]
+GROUP_ADDRESS_LIST_1 = ["ffaa::1", "ffaa::2", "ffaa::3", "ffaa::4", "ffaa::5"]
+GROUP_ADDRESS_LIST_2 = ["ffaa::6", "ffaa::7", "ffaa::8", "ffaa::9", "ffaa::10"]
+STAR = "*"
+SOURCE = "Static"
+ASSERT_MSG = "Testcase {} : Failed Error: {}"
+
+pytestmark = [pytest.mark.pim6d]
+
+
+def build_topo(tgen):
+    """Build function"""
+
+    # Building topology from json file
+    build_topo_from_json(tgen, TOPO)
+
+
+def setup_module(mod):
+    """
+    Sets up the pytest environment
+
+    * `mod`: module name
+    """
+
+    testsuite_run_time = time.asctime(time.localtime(time.time()))
+    logger.info("Testsuite start time: %s", testsuite_run_time)
+    logger.info("=" * 40)
+
+    topology = """
+
+                 _______r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+                |             |
+                |_____________|
+                        r4
+
+    """
+    logger.info("Master Topology: \n %s", topology)
+
+    logger.info("Running setup_module to create topology")
+
+    # This function initiates the topology build with Topogen...
+    json_file = "{}/multicast_pim6_static_rp.json".format(CWD)
+    tgen = Topogen(json_file, mod.__name__)
+    global TOPO
+    TOPO = tgen.json_topo
+
+    # ... and here it calls Mininet initialization functions.
+
+    # Starting topology, create tmp files which are loaded to routers
+    #  to start daemons and then start routers
+    start_topology(tgen)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    # Creating configuration from JSON
+    build_config_from_json(tgen, TOPO)
+
+    # Verify PIM6 neighbors
+    result = verify_pim6_neighbors(tgen, TOPO)
+    assert result is True, "setup_module :Failed \n Error:" " {}".format(result)
+
+    logger.info("Running setup_module() done")
+
+
+def teardown_module():
+    """Teardown the pytest environment"""
+
+    logger.info("Running teardown_module to delete topology")
+    tgen = get_topogen()
+
+    # Stop toplogy and Remove tmp files
+    tgen.stop_topology()
+
+    logger.info("Testsuite end time: %s", time.asctime(time.localtime(time.time())))
+    logger.info("=" * 40)
+
+
+#####################################################
+#
+#   Local API
+#
+#####################################################
+
+
+def verify_state_incremented(state_before, state_after):
+    """
+    API to compare interface traffic state incrementing
+
+    Parameters
+    ----------
+    * `state_before` : State dictionary for any particular instance
+    * `state_after` : State dictionary for any particular instance
+    """
+
+    for router, state_data in state_before.items():
+        for state, value in state_data.items():
+            if state_before[router][state] >= state_after[router][state]:
+                errormsg = (
+                    "[DUT: %s]: state %s value has not"
+                    " incremented, Initial value: %s, "
+                    "Current value: %s [FAILED!!]"
+                    % (
+                        router,
+                        state,
+                        state_before[router][state],
+                        state_after[router][state],
+                    )
+                )
+                return errormsg
+
+            logger.info(
+                "[DUT: %s]: State %s value is "
+                "incremented, Initial value: %s, Current value: %s"
+                " [PASSED!!]",
+                router,
+                state,
+                state_before[router][state],
+                state_after[router][state],
+            )
+
+    return True
+
+
+#####################################################
+#
+#   Testcases
+#
+#####################################################
+
+
+def test_pim6_multiple_groups_same_RP_address_p2(request):
+    """
+    Configure multiple  groups (10 grps) with same RP address
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+
+    r1 : LHR
+    r2 : RP
+    r3 : FHR
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    input_dict = {
+        "r1": {"debug": {"log_file": "r1_debug.log", "enable": ["pim6d"]}},
+        "r2": {"debug": {"log_file": "r2_debug.log", "enable": ["pim6d"]}},
+        "r3": {"debug": {"log_file": "r3_debug.log", "enable": ["pim6d"]}},
+        "r4": {"debug": {"log_file": "r4_debug.log", "enable": ["pim6d"]}},
+    }
+
+    result = create_debug_log_config(tgen, input_dict)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step("r2: Configure r2 as RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_3,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r2: verify rp-info")
+    dut = "r2"
+    oif = "lo"
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(tgen, TOPO, dut, GROUP_RANGE_3, oif, rp_address, SOURCE)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    group_address_list = GROUP_ADDRESS_LIST_1 + GROUP_ADDRESS_LIST_2
+    step("r0: Send MLD join for 10 groups")
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", group_address_list, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r5: Send multicast traffic for group {}".format(group_address_list))
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", group_address_list, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        group_address_list,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream IIF interface")
+    dut = "r2"
+    iif = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, group_address_list, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        group_address_list,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r2: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Delete RP configuration")
+    input_dict = {
+        "r1": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_3,
+                        "delete": True,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Shut the interface r1-r2-eth1 from R1 to R2")
+    dut = "r1"
+    intf = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    shutdown_bringup_interface(tgen, dut, intf, False)
+
+    step("r1: No Shut the interface r1-r2-eth1 from R1 to R2")
+    shutdown_bringup_interface(tgen, dut, intf, True)
+
+    step("r1: Configure RP")
+    input_dict = {
+        "r1": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_3,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Shut the interface r1-r0-eth0 from R1 to R2")
+    intf = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    shutdown_bringup_interface(tgen, dut, intf, False)
+
+    step("r1: No Shut the interface r1-r0-eth0 from R1 to R2")
+    shutdown_bringup_interface(tgen, dut, intf, True)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, group_address_list, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        group_address_list,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, group_address_list, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_multiple_groups_different_RP_address_p2(request):
+    """
+    Verify IIF and OIL in updated in mroute when upstream interface
+    configure as RP
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |     iperf
+        r0-----r1-------------r3-----r5
+                |             |
+                |_____________|
+                        r4
+    r1 : LHR
+    r2 & r4 : RP
+    r3 : FHR
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step("r2: Configure r2 as RP")
+    step("r4: Configure r4 as RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_1,
+                    }
+                ]
+            }
+        },
+        "r4": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_2,
+                    }
+                ]
+            }
+        },
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r2: Verify RP info")
+    dut = "r2"
+    oif = "lo"
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_RANGE_LIST_1, oif, rp_address, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify RP info")
+    dut = "r4"
+    rp_address = TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_RANGE_LIST_2, oif, rp_address, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    group_address_list = GROUP_ADDRESS_LIST_1 + GROUP_ADDRESS_LIST_2
+    step("r0: Send MLD join for 10 groups")
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", group_address_list, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, group_address_list)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r5: Send multicast traffic for group {}".format(group_address_list))
+    intf = TOPO["routers"]["r5"]["links"]["r3"]["interface"]
+    SOURCE_ADDRESS = TOPO["routers"]["r5"]["links"]["r3"]["ipv6"].split("/")[0]
+    result = socat_send_pim6_traffic(tgen, "r5", "UDP6-SEND", group_address_list, intf)
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif1 = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    iif2 = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+
+    for _iif, _group in zip([iif1, iif2], [GROUP_ADDRESS_LIST_1, GROUP_ADDRESS_LIST_2]):
+        result = verify_upstream_iif(tgen, dut, _iif, STAR, _group)
+        assert result is True, ASSERT_MSG.format(tc_name, result)
+
+        step("r1: Verify (*, G) upstream join state and join timer")
+        result = verify_join_state_and_timer(
+            tgen, dut, _iif, STAR, _group, addr_type="ipv6"
+        )
+        assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_1,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r2: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_1,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) upstream IIF interface")
+    dut = "r4"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r4"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r4"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_2,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r4: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r4: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_2,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, "Testcase {} :Failed \n Error: {}".format(
+        tc_name, result
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("Delete RP configuration")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_1,
+                        "delete": True,
+                    }
+                ]
+            }
+        },
+        "r4": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_2,
+                        "delete": True,
+                    }
+                ]
+            }
+        },
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1, r2, r3, r4: Re-configure RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_1,
+                    }
+                ]
+            }
+        },
+        "r4": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r4"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_LIST_2,
+                    }
+                ]
+            }
+        },
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Shut/No Shut the interfacesfrom R1 to R2, R4 and R0")
+    dut = "r1"
+    intf1 = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    intf2 = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    intf3 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    for intf in [intf1, intf2, intf3]:
+        shutdown_bringup_interface(tgen, dut, intf, False)
+        shutdown_bringup_interface(tgen, dut, intf, True)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream IIF interface")
+    dut = "r2"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_1, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r2"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_1,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r2: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_1,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream IIF interface")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (S, G) ip mroutes")
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) upstream IIF interface")
+    dut = "r4"
+    iif = "lo"
+    result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen, dut, iif, STAR, GROUP_ADDRESS_LIST_2, addr_type="ipv6"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (*, G) ip mroutes")
+    oif = TOPO["routers"]["r4"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (S, G) upstream IIF interface")
+    iif = TOPO["routers"]["r4"]["links"]["r3"]["interface"]
+    result = verify_upstream_iif(
+        tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, joinState="NotJoined"
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r4: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_2,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r4: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r4: Verify (S, G) ip mroutes")
+    oif = "none"
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream IIF interface")
+    dut = "r3"
+    iif = TOPO["routers"]["r3"]["links"]["r5"]["interface"]
+    result = verify_upstream_iif(tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r3: Verify (S, G) upstream join state and join timer")
+    result = verify_join_state_and_timer(
+        tgen,
+        dut,
+        iif,
+        SOURCE_ADDRESS,
+        GROUP_ADDRESS_LIST_2,
+        addr_type="ipv6",
+        expected=False,
+    )
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r3: Verify (S, G) ip mroutes")
+    oif = TOPO["routers"]["r3"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    write_test_footer(tc_name)
+
+
+def test_pim6_delete_RP_shut_noshut_upstream_interface_p1(request):
+    """
+    Verify RP info and (*,G) mroute after deleting the RP and shut /
+    no shut the RPF interface.
+
+    Topology used:
+                ________r2_____
+                |             |
+      iperf     |             |
+        r0-----r1-------------r3
+    """
+
+    tgen = get_topogen()
+    tc_name = request.node.name
+    write_test_header(tc_name)
+
+    # Don"t run this test if we have any failure.
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+
+    step("Creating configuration from JSON")
+    reset_config_on_routers(tgen)
+
+    step("Enable MLD on r1 interface")
+    step("Enable the PIM6 on all the interfaces of r1, r2, r3 and r4 routers")
+    step("r2: Configure r2 as RP")
+    input_dict = {
+        "r2": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r2: verify rp-info")
+    dut = "r2"
+    oif = "lo"
+    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
+    result = verify_pim_rp_info(
+        tgen, TOPO, dut, GROUP_ADDRESS_1, oif, rp_address, SOURCE
+    )
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r0: Send MLD join")
+    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
+    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
+    result = socat_send_mld_join(
+        tgen, "r0", "UDP6-RECV", GROUP_ADDRESS_1, intf, intf_ip
+    )
+    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
+
+    step("r1: Verify MLD groups")
+    dut = "r1"
+    intf_r1_r0 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mld_groups(tgen, dut, intf_r1_r0, GROUP_ADDRESS_1)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Verify (*, G) ip mroutes created")
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r2: Verify (*, G) ip mroutes created")
+    dut = "r2"
+    iif = "lo"
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif)
+    assert result is True, ASSERT_MSG.format(tc_name, result)
+
+    step("r1: Delete RP configuration")
+    input_dict = {
+        "r1": {
+            "pim6": {
+                "rp": [
+                    {
+                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
+                            "/"
+                        )[0],
+                        "group_addr_range": GROUP_RANGE_1,
+                        "delete": True,
+                    }
+                ]
+            }
+        }
+    }
+
+    result = create_pim_config(tgen, TOPO, input_dict)
+    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
+
+    step("r1: Shut/No Shut the interface r1-r2-eth1/r1-r0-eth0 from R1 to R2")
+    dut = "r1"
+    intf1 = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    intf2 = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    for intf in [intf1, intf2]:
+        shutdown_bringup_interface(tgen, dut, intf, False)
+        shutdown_bringup_interface(tgen, dut, intf, True)
+
+    step("r2: Shut the RP interface lo")
+    dut = "r2"
+    intf = "lo"
+    shutdown_bringup_interface(tgen, dut, intf, False)
+
+    step("r1: Shut the interface r1-r2-eth1/r1-r3-eth2 towards RP")
+    intf3 = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
+    for intf in [intf1, intf3]:
+        shutdown_bringup_interface(tgen, dut, intf, False)
+
+    step("r1: Verify (*, G) ip mroutes cleared")
+    dut = "r1"
+    iif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
+    oif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif, expected=False)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r1: (*,G) mroutes are not cleared after shut of R1 to R0 link\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    step("r2: Verify (*, G) ip mroutes cleared")
+    dut = "r2"
+    iif = "lo"
+    oif = TOPO["routers"]["r2"]["links"]["r1"]["interface"]
+    result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS_1, iif, oif, expected=False)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "r2: (*,G) mroutes are not cleared after shut of R1 to R0 link\n Error: {}".format(
+            tc_name, result
+        )
+    )
+
+    write_test_footer(tc_name)
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_bsm_topo1/test_mcast_pim_bsmp_01.py frr-frr-8.5/tests/topotests/multicast_pim_bsm_topo1/test_mcast_pim_bsmp_01.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_bsm_topo1/test_mcast_pim_bsmp_01.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_bsm_topo1/test_mcast_pim_bsmp_01.py	2023-03-13 20:01:47.000000000 +0600
@@ -83,7 +83,6 @@ from lib.common_config import (
     apply_raw_config,
     run_frr_cmd,
     required_linux_kernel_version,
-    topo_daemons,
     verify_rib,
 )
 
@@ -152,7 +151,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -168,12 +167,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -695,10 +691,10 @@ def test_BSR_CRP_with_blackhole_address_
     result = verify_rib(
         tgen, "ipv4", "f1", input_routes, protocol="static", expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "Route is still present \n Error {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} RIB \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
 
     # Use scapy to send pre-defined packet from senser to receiver
@@ -744,10 +740,10 @@ def test_BSR_CRP_with_blackhole_address_
 
     step("Verify if b1 chosen as BSR in l1")
     result = verify_pim_bsr(tgen, topo, "l1", BSR_IP_1, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "b1 is not chosen as BSR in l1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: b1 should be chosen as BSR in {} \n "
+        "Found: {}".format(tc_name, "l1", result)
     )
 
     state_after = get_pim_interface_traffic(tgen, state_dict)
@@ -792,9 +788,8 @@ def test_BSR_CRP_with_blackhole_address_
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "Routes:[{}, {}] are still present \n Error {}".format(
-            tc_name, BSR1_ADDR, CRP, result
-        )
+        "Expected: Routes should not be present in {} RIB \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
 
     step("Sending BSR after removing black-hole address for BSR and candidate RP")
@@ -919,9 +914,8 @@ def test_new_router_fwd_p0(request):
     result = verify_pim_bsr(tgen, topo, "l1", bsr_ip, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "BSR data is present after no-forward bsm also \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: BSR data should not be present after no-forward bsm \n "
+        "Found: {}".format(tc_name, "l1", result)
     )
 
     # unconfigure unicast bsm on f1-i1-eth2
@@ -1046,10 +1040,10 @@ def test_int_bsm_config_p1(request):
     result = verify_mroutes(
         tgen, "i1", src_addr, GROUP_ADDRESS, iif, oil, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "Mroutes are still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should be cleared from mroute table\n "
+        "Found: {}".format(tc_name, "i1", result)
     )
 
     # unconfigure bsm processing on f1 on  f1-i1-eth2
@@ -1070,10 +1064,10 @@ def test_int_bsm_config_p1(request):
     # Verify bsr state in i1
     step("Verify if b1 is not chosen as BSR in i1")
     result = verify_pim_bsr(tgen, topo, "i1", bsr_ip, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "b1 is chosen as BSR in i1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: b1 should not be chosen as BSR \n "
+        "Found: {}".format(tc_name, "i1", result)
     )
 
     # check if mroute still not installed because of rp not available
@@ -1083,7 +1077,8 @@ def test_int_bsm_config_p1(request):
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "mroute installed but rp not available \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: mroute (S, G) should not be installed as RP is not available\n "
+        "Found: {}".format(tc_name, "i1", result)
     )
 
     # configure bsm processing on i1 on  f1-i1-eth2
@@ -1540,11 +1535,10 @@ def test_BSM_timeout_p0(request):
     result = verify_pim_grp_rp_source(
         tgen, topo, "f1", group, rp_source="BSR", expected=False
     )
-
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "bsr has not aged out in f1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: bsr should be aged out \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
 
     # Verify RP mapping removed after hold timer expires
@@ -1571,9 +1565,8 @@ def test_BSM_timeout_p0(request):
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "join state is up and join timer is running in l1 \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     # Verify ip mroute is not installed
@@ -1581,10 +1574,10 @@ def test_BSM_timeout_p0(request):
     result = verify_mroutes(
         tgen, dut, src_addr, GROUP_ADDRESS, iif, oil, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "mroute installed in l1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be installed \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("clear  BSM database before moving to next case")
@@ -1721,10 +1714,10 @@ def test_iif_join_state_p0(request):
     result = verify_rib(
         tgen, "ipv4", "l1", input_dict, protocol="static", expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "Routes:{} are still present \n Error {}".format(
-        tc_name, rp_ip, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: Routes should not be present in {} BGP RIB \n "
+        "Found: {}".format(tc_name, "l1", result)
     )
 
     # Check RP unreachable
@@ -1746,10 +1739,10 @@ def test_iif_join_state_p0(request):
     result = verify_mroutes(
         tgen, dut, src_addr, GROUP_ADDRESS, iif, oil, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "mroute installed in l1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be installed \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     # Add back route for RP to make it reachable
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_bsm_topo2/test_mcast_pim_bsmp_02.py frr-frr-8.5/tests/topotests/multicast_pim_bsm_topo2/test_mcast_pim_bsmp_02.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_bsm_topo2/test_mcast_pim_bsmp_02.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_bsm_topo2/test_mcast_pim_bsmp_02.py	2023-03-13 20:01:47.000000000 +0600
@@ -67,7 +67,6 @@ from lib.common_config import (
     reset_config_on_routers,
     run_frr_cmd,
     required_linux_kernel_version,
-    topo_daemons,
     verify_rib,
 )
 
@@ -132,7 +131,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.15")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.15")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -148,12 +147,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -459,10 +455,10 @@ def test_starg_mroute_p0(request):
     result = verify_mroutes(
         tgen, dut, src_addr, GROUP_ADDRESS, iif, oil, retry_timeout=20, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "mroute installed in l1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be installed \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     # Send BSM again to configure rp
@@ -806,10 +802,10 @@ def test_BSR_election_p0(request):
     # Verify bsr state in FHR
     step("Verify if b2 is not chosen as bsr in f1")
     result = verify_pim_bsr(tgen, topo, "f1", bsr_ip2, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "b2 is chosen as bsr in f1 \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: b2 should not be chosen as bsr \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
 
     # Verify if b1 is still chosen as bsr
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_ospf_topo2.py frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_ospf_topo2.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_ospf_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_ospf_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -166,12 +166,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, tgen.json_topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start deamons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -919,7 +916,9 @@ def test_configuring_igmp_local_join_on_
         )
 
         for dut, intf in zip(["r1", "r2"], [intf_r1_s1, intf_r2_s1]):
-            result = verify_igmp_groups(tgen, dut, intf, IGMP_JOIN_RANGE_3, expected=False)
+            result = verify_igmp_groups(
+                tgen, dut, intf, IGMP_JOIN_RANGE_3, expected=False
+            )
             assert result is not True, (
                 "Testcase {} : Failed \n "
                 "IGMP groups are still present \n Error: {}".format(tc_name, result)
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_static_routes_topo1.py frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_static_routes_topo1.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_static_routes_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_static_routes_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -180,12 +180,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, tgen.json_topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start deamons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_transit_router_topo3.py frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_transit_router_topo3.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_transit_router_topo3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_dr_nondr_test/test_pim_dr_nondr_with_transit_router_topo3.py	2023-03-13 20:01:47.000000000 +0600
@@ -185,12 +185,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, tgen.json_topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start deamons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo1/test_multicast_pim_sm_topo1.py frr-frr-8.5/tests/topotests/multicast_pim_sm_topo1/test_multicast_pim_sm_topo1.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo1/test_multicast_pim_sm_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_sm_topo1/test_multicast_pim_sm_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -159,7 +159,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.19")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.19")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -175,12 +175,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, tgen.json_topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -883,12 +880,11 @@ def test_verify_mroute_when_same_receive
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     step(
         "Source which is stopped got removed , other source"
@@ -1103,12 +1099,11 @@ def test_verify_mroute_when_frr_is_trans
     result = verify_mroutes(
         tgen, "c1", "*", IGMP_JOIN, "c1-c2-eth1", "c1-l1-eth0", expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (*, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, "c1", result)
     )
-    logger.info("Expected Behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1212,12 +1207,11 @@ def test_verify_mroute_when_RP_unreachab
     result = verify_mroutes(
         tgen, "f1", "*", IGMP_JOIN, "f1-r2-eth3", "f1-i8-eth2", expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (*, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
-    logger.info("Expected Behavior: {}".format(result))
 
     step("IGMP groups are present verify using 'show ip igmp group'")
     dut = "l1"
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo2/test_multicast_pim_sm_topo2.py frr-frr-8.5/tests/topotests/multicast_pim_sm_topo2/test_multicast_pim_sm_topo2.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo2/test_multicast_pim_sm_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_sm_topo2/test_multicast_pim_sm_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -157,7 +157,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.19")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.19")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -172,12 +172,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -457,12 +454,11 @@ def test_verify_mroute_and_traffic_when_
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -666,12 +662,11 @@ def test_verify_mroute_and_traffic_when_
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1056,8 +1051,9 @@ def test_verify_mroute_after_shut_noshut
         tgen, "l1", "Unknown", source, IGMP_JOIN_RANGE_2, expected=False
     )
     assert result is not True, (
-        "Testcase {} : Failed Error: \n "
-        "mroutes are still present, after waiting for 10 mins".format(tc_name)
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Upstream IIF should be unknown \n "
+        "Found: {}".format(tc_name, "l1", result)
     )
 
     step("No shut the Source interface just after the upstream is expired" " from FRR1")
@@ -1088,12 +1084,11 @@ def test_verify_mroute_after_shut_noshut
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1413,9 +1408,11 @@ def test_verify_mroute_when_FRR_is_FHR_a
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed Error: \nmroutes are still present".format(tc_name)
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
+        )
 
     write_test_footer(tc_name)
 
@@ -1610,12 +1607,11 @@ def test_verify_mroute_when_5_different_
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behavior: {}".format(result))
 
     step(
         "No traffic impact observed on other receivers verify using"
@@ -1823,12 +1819,11 @@ def test_verify_oil_iif_for_mroute_after
         "f1-i8-eth2",
         expected=False,
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n mroutes are" " still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, data["dut"], result)
     )
-    logger.info("Expected Behavior: {}".format(result))
 
     result = verify_upstream_iif(
         tgen, "f1", "Unknown", "10.0.5.2", _IGMP_JOIN_RANGE, joinState="NotJoined"
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo3.py frr-frr-8.5/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo3.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo3.py	2023-03-13 20:01:47.000000000 +0600
@@ -171,7 +171,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.19")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.19")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -186,12 +186,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -552,12 +549,11 @@ def test_verify_oil_when_join_prune_sent
 
     input_traffic = {"l1": {"traffic_sent": [intf_l1_i1]}}
     result = verify_multicast_traffic(tgen, input_traffic, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " " Traffic is not stopped yet \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Multicast traffic should be stopped \n "
+        "Found: {}".format(tc_name, "l1", result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step(
         "IGMP groups are remove from FRR1 node 'show ip igmp groups'"
@@ -568,12 +564,11 @@ def test_verify_oil_when_join_prune_sent
     result = verify_igmp_groups(
         tgen, dut, intf_l1_i1, IGMP_JOIN_RANGE_1, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "IGMP groups are not deleted \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: IGMP groups should be deleted \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     dut = "f1"
     result = verify_igmp_groups(tgen, dut, intf_f1_i8, IGMP_JOIN_RANGE_1)
@@ -612,12 +607,11 @@ def test_verify_oil_when_join_prune_sent
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     for data in input_dict_l1:
         result = verify_upstream_iif(
@@ -630,9 +624,9 @@ def test_verify_oil_when_join_prune_sent
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream entries are still present \n Error: {}".format(tc_name, result)
+            "Expected: [{}]: Upstream IIF {} should not be present \n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     input_dict_f1 = [
         {
@@ -680,12 +674,11 @@ def test_verify_oil_when_join_prune_sent
 
     input_traffic = {"f1": {"traffic_sent": [intf_f1_i8]}}
     result = verify_multicast_traffic(tgen, input_traffic, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " " Traffic is not stopped yet \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Multicast traffic should be stopped \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step(
         "IGMP groups are remove from FRR1 node 'show ip igmp groups'"
@@ -696,12 +689,11 @@ def test_verify_oil_when_join_prune_sent
     result = verify_igmp_groups(
         tgen, dut, intf_f1_i8, IGMP_JOIN_RANGE_1, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "IGMP groups are not deleted \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: IGMP groups should be deleted \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step(
         "(*,G) and (S,G) OIL got prune state (none) from all the nodes"
@@ -735,12 +727,11 @@ def test_verify_oil_when_join_prune_sent
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     for data in input_dict_l1:
         result = verify_upstream_iif(
@@ -753,9 +744,9 @@ def test_verify_oil_when_join_prune_sent
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream entries are still present \n Error: {}".format(tc_name, result)
+            "Expected: [{}]: Upstream IIF {} should not be present \n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     shutdown_bringup_interface(tgen, "f1", intf_f1_i8, True)
     shutdown_bringup_interface(tgen, "l1", intf_l1_i1, True)
@@ -923,12 +914,11 @@ def test_verify_oil_when_join_prune_sent
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     input_dict_l1_r2 = [
         {
@@ -987,12 +977,11 @@ def test_verify_oil_when_join_prune_sent
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     step("After prune is sent verify upstream got removed in FRR1 node")
 
@@ -1007,9 +996,9 @@ def test_verify_oil_when_join_prune_sent
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream entries are still present \n Error: {}".format(tc_name, result)
+            "Expected: [{}]: Upstream IIF {} should not be present \n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1146,12 +1135,11 @@ def test_shut_noshut_source_interface_wh
     result = verify_mroutes(
         tgen, "f1", source_i2, IGMP_JOIN_RANGE_1, intf_f1_i2, intf_f1_r2, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n mroutes are" " still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, "f1", result)
     )
-    logger.info("Expected Behavior: {}".format(result))
 
     step(
         "After waiting for (S,G) timeout from FRR1 for same"
@@ -1162,9 +1150,11 @@ def test_shut_noshut_source_interface_wh
     result = verify_upstream_iif(
         tgen, "l1", "Unknown", source_i2, IGMP_JOIN_RANGE_1, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed Error: \n mroutes are still present".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Upstream IIF should be Unknown \n "
+        "Found: {}".format(tc_name, "l1", result)
+    )
 
     step("No shut the Source interface just after the upstream is expired" " from FRR1")
     shutdown_bringup_interface(tgen, "f1", intf_f1_i2, True)
@@ -1355,9 +1345,11 @@ def test_shut_noshut_receiver_interface_
     result = verify_upstream_iif(
         tgen, "l1", "Unknown", source_i2, IGMP_JOIN_RANGE_1, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed Error: \nmroutes are still present".format(tc_name)
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Upstream IIF should be Unknown \n "
+        "Found: {}".format(tc_name, "l1", result)
+    )
 
     step("No shut the Source interface just after the upstream is expired" " from FRR1")
     shutdown_bringup_interface(tgen, "l1", intf_l1_i1, True)
@@ -1559,12 +1551,11 @@ def test_verify_remove_add_igmp_config_t
     dut = "l1"
     interface = topo["routers"]["l1"]["links"]["i1"]["interface"]
     result = verify_igmp_groups(tgen, dut, interface, IGMP_JOIN_RANGE_1, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Groups are not" " present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: IGMP groups should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     intf_l1_r2 = topo["routers"]["l1"]["links"]["r2"]["interface"]
     intf_l1_i1 = topo["routers"]["l1"]["links"]["i1"]["interface"]
@@ -1658,12 +1649,11 @@ def test_verify_remove_add_igmp_config_t
     dut = "l1"
     interface = topo["routers"]["l1"]["links"]["i1"]["interface"]
     result = verify_igmp_groups(tgen, dut, interface, IGMP_JOIN_RANGE_1, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n Groups are not" " present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: IGMP groups should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     result = verify_multicast_traffic(tgen, input_traffic)
     assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
@@ -1780,12 +1770,11 @@ def test_verify_remove_add_igmp_config_t
     result = verify_mroutes(
         tgen, dut, source, IGMP_JOIN_RANGE_1, iif, oil, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n routes are still" " present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
@@ -1965,12 +1954,11 @@ def test_verify_remove_add_igmp_commands
     )
 
     result = verify_igmp_config(tgen, input_dict_1, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "IGMP interface is not removed \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: IGMP interface should be removed \n "
+        "Found: {}".format(tc_name, data["dut"], result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step("Verify that no core is observed")
     if tgen.routers_have_failure():
@@ -2852,12 +2840,11 @@ def test_mroute_after_removing_RP_sendin
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroute still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     for data in input_dict_sg:
         result = verify_mroutes(
@@ -2889,9 +2876,9 @@ def test_mroute_after_removing_RP_sendin
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "IGMP groups still present  still present \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: IGMP groups should not present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step(
         "After receiving the IGMP prune from FRR1 , verify traffic "
@@ -3183,12 +3170,11 @@ def test_prune_sent_to_LHR_and_FHR_when_
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroute still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     for data in input_dict_sg_i1:
         result = verify_mroutes(
@@ -3212,12 +3198,11 @@ def test_prune_sent_to_LHR_and_FHR_when_
             IGMP_JOIN_RANGE_1,
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "upstream still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: Upstream IIF interface {} should not be present\n"
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     for data in input_dict_sg_i1:
         result = verify_upstream_iif(
@@ -3237,12 +3222,11 @@ def test_prune_sent_to_LHR_and_FHR_when_
     result = verify_pim_rp_info(
         tgen, topo, dut, GROUP_RANGE_1, "Unknown", rp_address, SOURCE, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "RP iif is not updated \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: RP IIF should be updated as Unknown \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step("Verify mroute  after No shut the link from LHR to RP from RP node")
 
@@ -3369,8 +3353,9 @@ def test_prune_sent_to_LHR_and_FHR_when_
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream is still present after shut the link from "
-            "FHR to RP from RP node \n Error: {}".format(tc_name, result)
+            "Expected: [{}]: Upstream IIF interface {} should not be present"
+            " after shutting link from RP to FHR \n"
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
 
     step(" No shut the link from FHR to RP from RP node")
@@ -3386,12 +3371,11 @@ def test_prune_sent_to_LHR_and_FHR_when_
     result = verify_pim_rp_info(
         tgen, topo, dut, GROUP_RANGE_1, "Unknown", rp_address, SOURCE, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "RP iif is not updated \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: RP IIF should be updated as Unknown \n"
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step("Verify mroute after Noshut the link from FHR to RP from RP node")
 
@@ -3518,8 +3502,9 @@ def test_prune_sent_to_LHR_and_FHR_when_
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream is still present after shut the link from "
-            "FHR to RP from FHR node \n Error: {}".format(tc_name, result)
+            "Expected: [{}]: Upstream IIF interface {} should not be present"
+            " after shutting link from FHR to RP \n"
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
 
     step(" No shut the link from FHR to RP from FHR node")
@@ -3534,12 +3519,11 @@ def test_prune_sent_to_LHR_and_FHR_when_
     result = verify_pim_rp_info(
         tgen, topo, dut, GROUP_RANGE_1, "Unknown", rp_address, SOURCE, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "RP iif is not updated \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: RP IIF should be updated as Unknown \n"
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     step("Verify mroute after No Shut the link from FHR to RP from FHR node")
 
@@ -3969,12 +3953,10 @@ def test_verify_multicast_traffic_when_L
             expected=False,
         )
         assert result is not True, (
-            "Testcase {} : Failed \n"
-            " Expected Behaviour: mroutes are cleared \n Error: {}".format(
-                tc_name, result
-            )
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     shutdown_bringup_interface(tgen, "r2", intf_r2_i3, True)
 
@@ -4038,12 +4020,11 @@ def test_verify_multicast_traffic_when_L
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n" "mroutes are cleared \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     shutdown_bringup_interface(tgen, "l1", intf_l1_i1, True)
 
@@ -4113,12 +4094,11 @@ def test_verify_multicast_traffic_when_L
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n" " mroutes are cleared \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     shutdown_bringup_interface(tgen, "r2", intf_r2_f1, True)
 
@@ -4181,12 +4161,11 @@ def test_verify_multicast_traffic_when_L
     result = verify_mroutes(
         tgen, dut, src_address, _IGMP_JOIN_RANGE, iif, oil, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n" " mroutes are cleared \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected Behaviour: {}".format(result))
 
     shutdown_bringup_interface(tgen, "l1", intf_l1_r2, True)
 
@@ -4383,12 +4362,11 @@ def test_verify_multicast_traffic_when_F
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n" " mroutes are cleared \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     step("No shut the receiver(l1) port in 1 min interval")
 
@@ -4449,12 +4427,11 @@ def test_verify_multicast_traffic_when_F
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n" " mroutes are cleared \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     step("No shut the source(r2) port in 1 min interval")
 
@@ -4521,12 +4498,11 @@ def test_verify_multicast_traffic_when_F
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n" " mroutes are cleared \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
-        logger.info("Expected Behaviour: {}".format(result))
 
     write_test_footer(tc_name)
 
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo4.py frr-frr-8.5/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo4.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo4.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_sm_topo3/test_multicast_pim_sm_topo4.py	2023-03-13 20:01:47.000000000 +0600
@@ -136,7 +136,7 @@ def setup_module(mod):
     # Required linux kernel version for this suite to run.
     result = required_linux_kernel_version("4.19")
     if result is not True:
-        pytest.skip("Kernel requirements are not met")
+        pytest.skip("Kernel version should be >= 4.19")
 
     testsuite_run_time = time.asctime(time.localtime(time.time()))
     logger.info("Testsuite start time: {}".format(testsuite_run_time))
@@ -151,12 +151,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -427,9 +424,8 @@ def test_mroute_when_RP_reachable_defaul
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "mroutes(S,G) are present after delete of static routes on c1 \n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
 
         result = verify_upstream_iif(
@@ -442,9 +438,8 @@ def test_mroute_when_RP_reachable_defaul
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream is present after delete of static routes on c1 \n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: [{}]: Upstream IIF interface {} should not be present\n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
 
     for data in input_dict_starg:
@@ -459,9 +454,8 @@ def test_mroute_when_RP_reachable_defaul
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "mroutes(*,G) are present after delete of static routes on c1 \n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
 
         result = verify_upstream_iif(
@@ -474,9 +468,8 @@ def test_mroute_when_RP_reachable_defaul
         )
         assert result is not True, (
             "Testcase {} : Failed \n "
-            "upstream is present after delete of static routes on c1 \n Error: {}".format(
-                tc_name, result
-            )
+            "Expected: [{}]: Upstream IIF interface {} should not be present\n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
 
     step("Configure default routes on c2")
@@ -502,9 +495,9 @@ def test_mroute_when_RP_reachable_defaul
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "RP info is unknown after removing static route from c2 \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: RP Info should not be Unknown after removing static"
+        " route from c2 \n"
+        "Found: {}".format(tc_name, data["dut"], result)
     )
 
     step("Verify (s,g) populated after adding default route ")
@@ -723,10 +716,10 @@ def test_mroute_with_RP_default_route_al
             data["oil"],
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "mroutes are still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: mroute (S, G) should not be present in mroute table \n "
+            "Found: {}".format(tc_name, data["dut"], result)
         )
 
         result = verify_upstream_iif(
@@ -737,10 +730,10 @@ def test_mroute_with_RP_default_route_al
             IGMP_JOIN_RANGE_1,
             expected=False,
         )
-        assert (
-            result is not True
-        ), "Testcase {} : Failed \n " "upstream is still present \n Error: {}".format(
-            tc_name, result
+        assert result is not True, (
+            "Testcase {} : Failed \n "
+            "Expected: [{}]: Upstream IIF interface {} should not be present\n "
+            "Found: {}".format(tc_name, data["dut"], data["iif"], result)
         )
 
     step("Configure default routes on all the nodes")
@@ -780,9 +773,9 @@ def test_mroute_with_RP_default_route_al
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "RP info is unknown after removing static route from c2 \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: RP Info should not be Unknown after removing static"
+        " route from c2 \n"
+        "Found: {}".format(tc_name, data["dut"], result)
     )
 
     step("Verify (s,g) populated after adding default route ")
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/multicast_pimv6_static_rp.json frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/multicast_pimv6_static_rp.json
--- frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/multicast_pimv6_static_rp.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/multicast_pimv6_static_rp.json	1970-01-01 06:00:00.000000000 +0600
@@ -1,197 +0,0 @@
-{
-    "address_types": ["ipv6"],
-    "ipv6base": "fd00::",
-    "ipv6mask": 64,
-    "link_ip_start": {
-        "ipv6": "fd00::",
-        "v6mask": 64
-    },
-    "lo_prefix": {
-        "ipv6": "2001:db8:f::",
-        "v6mask": 128
-    },
-    "routers": {
-        "r0": {
-            "links": {
-                "r1": {"ipv6": "auto"}
-            }
-        },
-        "r1": {
-            "links": {
-                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r0": {"ipv6": "auto", "pim6": "enable"},
-                "r2": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r3": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r4": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }}
-            },
-            "ospf6": {
-                "router_id": "100.1.1.0",
-                "neighbors": {
-                    "r2": {},
-                    "r3": {},
-                    "r4": {}
-                },
-                "redistribute": [
-                    {
-                        "redist_type": "static"
-                    },
-                    {
-                        "redist_type": "connected"
-                    }
-                ]
-            },
-            "mld": {
-                "interfaces": {
-                    "r1-r0-eth0" :{
-                        "mld":{
-                        }
-                    }
-                }
-            }
-        },
-        "r2": {
-            "links": {
-                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r1": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r3": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }}
-            },
-            "ospf6": {
-                "router_id": "100.1.1.1",
-                "neighbors": {
-                    "r1": {},
-                    "r3": {}
-                },
-                "redistribute": [
-                    {
-                        "redist_type": "static"
-                    },
-                    {
-                        "redist_type": "connected"
-                    }
-                ]
-            }
-        },
-        "r3": {
-            "links": {
-                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r1": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r2": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r4": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r5": {"ipv6": "auto", "pim6": "enable"}
-            },
-            "ospf6": {
-                "router_id": "100.1.1.2",
-                "neighbors": {
-                    "r1": {},
-                    "r2": {},
-                    "r4": {}
-                },
-                "redistribute": [
-                    {
-                        "redist_type": "static"
-                    },
-                    {
-                        "redist_type": "connected"
-                    }
-                ]
-            }
-        },
-        "r4": {
-            "links": {
-                "lo": {"ipv6": "auto", "type": "loopback", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r1": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }},
-                "r3": {"ipv6": "auto", "pim6": "enable",
-                "ospf6": {
-                    "area": "0.0.0.0",
-                    "hello_interval": 1,
-                    "dead_interval": 4
-                }}
-            },
-            "ospf6": {
-                "router_id": "100.1.1.3",
-                "neighbors": {
-                    "r1": {},
-                    "r3": {}
-                },
-                "redistribute": [
-                    {
-                        "redist_type": "static"
-                    },
-                    {
-                        "redist_type": "connected"
-                    }
-                ]
-            }
-        },
-        "r5": {
-            "links": {
-                "r3": {"ipv6": "auto"}
-            }
-        }
-    }
-}
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp.py frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp.py	2023-03-13 20:01:47.000000000 +0600
@@ -223,12 +223,9 @@ def setup_module(mod):
 
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, TOPO)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -378,9 +375,8 @@ def test_add_delete_static_RP_p0(request
     result = verify_igmp_groups(tgen, dut, interface, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: igmp group present without any IGMP join \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: IGMP groups should not be present without any IGMP join\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify show ip pim interface traffic without any IGMP join")
@@ -448,17 +444,18 @@ def test_add_delete_static_RP_p0(request
     result = verify_pim_rp_info(
         tgen, TOPO, dut, GROUP_RANGE_ALL, iif, rp_address, SOURCE, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: RP info present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: RP info should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify upstream IIF interface")
     result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream IIF interface present \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: Upstream IIF interface {} should not be present\n "
+        "Found: {}".format(tc_name, dut, iif, result)
     )
 
     step("r1: Verify upstream join state and join timer")
@@ -467,24 +464,25 @@ def test_add_delete_static_RP_p0(request
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream join state is up and join timer is running \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     # 20
     step("r1: Verify PIM state")
     result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS, expected=False)
-    assert result is not True, "Testcase {} :Failed \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: PIM state should not be up \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify ip mroutes")
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: mroutes are still present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (*, G) should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify show ip pim interface traffic without any IGMP join")
@@ -641,9 +639,8 @@ def test_SPT_RPT_path_same_p1(request):
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S, G) upstream join state is up and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -770,16 +767,16 @@ def test_not_reachable_static_RP_p0(requ
     result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "OIL is not same and IIF is not cleared on R1 \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: OIL should be same and IIF should be cleared\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: upstream IIF should be unknown , verify using show ip pim" "upstream")
     result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream IIF is not unknown \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: Upstream IIF interface {} should be unknown \n "
+        "Found: {}".format(tc_name, dut, iif, result)
     )
 
     step(
@@ -791,9 +788,8 @@ def test_not_reachable_static_RP_p0(requ
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: join state is joined and timer is not stopped \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step(
@@ -814,11 +810,9 @@ def test_not_reachable_static_RP_p0(requ
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: (*, G) are not cleared from mroute table \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared from mroute table\n "
+        "Found: {}".format(tc_name, dut, result)
     )
-    logger.info("Expected behavior: %s", result)
 
     # Uncomment next line for debugging
     # tgen.mininet_cli()
@@ -880,10 +874,10 @@ def test_add_RP_after_join_received_p1(r
     result = verify_pim_rp_info(
         tgen, TOPO, dut, GROUP_RANGE_ALL, iif, rp_address, SOURCE, expected=False
     )
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: rp-info is present \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: RP-info should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("joinTx value before join sent")
@@ -908,7 +902,8 @@ def test_add_RP_after_join_received_p1(r
     result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream IFF interface is present \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: Upstream IIF interface {} should not be present \n "
+        "Found: {}".format(tc_name, dut, iif, result)
     )
 
     step("r1: Verify upstream join state and join timer")
@@ -918,25 +913,24 @@ def test_add_RP_after_join_received_p1(r
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream join state is joined and timer is running \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify PIM state")
     result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: PIM state is up\n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: PIM state should not be up\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Verify ip mroutes")
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: mroutes are still present\n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (*, G) should not be present in mroute table \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Configure static RP")
@@ -1061,7 +1055,8 @@ def test_reachable_static_RP_after_join_
     result = verify_upstream_iif(tgen, dut, iif, STAR, GROUP_ADDRESS, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream IIF interface is present\n Error: {}".format(tc_name, result)
+        "Expected: [{}]: Upstream IIF interface {} should not be present \n "
+        "Found: {}".format(tc_name, dut, iif, result)
     )
 
     step("r1 : Verify upstream join state and join timer")
@@ -1070,25 +1065,24 @@ def test_reachable_static_RP_after_join_
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: upstream join state is joined and timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1 : Verify PIM state")
     result = verify_pim_state(tgen, dut, iif, oif, GROUP_ADDRESS, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: PIM state is up\n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: PIM state should not be up \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1 : Verify ip mroutes")
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
-    assert (
-        result is not True
-    ), "Testcase {} : Failed \n " "r1: mroutes are still present\n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: mroute (*, G) should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r1: Make RP reachable")
@@ -1332,9 +1326,8 @@ def test_send_join_on_higher_preffered_r
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: rp-info is present for group 225.1.1.1 \n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: RP-info should not be present \n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step(
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp1.py frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp1.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp1.py	2023-03-13 20:01:47.000000000 +0600
@@ -128,7 +128,6 @@ from lib.common_config import (
     kill_router_daemons,
     start_router_daemons,
     create_static_routes,
-    topo_daemons,
 )
 from lib.pim import (
     create_pim_config,
@@ -223,12 +222,9 @@ def setup_module(mod):
 
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, TOPO)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -540,8 +536,9 @@ def test_RP_configured_as_LHR_1_p1(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S, G) upstream join state is joined and join"
-        " timer is running \n Error: {}".format(tc_name, result)
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -745,9 +742,9 @@ def test_RP_configured_as_LHR_2_p1(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -951,9 +948,9 @@ def test_RP_configured_as_FHR_1_p1(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1158,9 +1155,9 @@ def test_RP_configured_as_FHR_2_p2(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1283,9 +1280,9 @@ def test_SPT_RPT_path_different_p1(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1307,9 +1304,9 @@ def test_SPT_RPT_path_different_p1(reque
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (S, G) ip mroutes")
@@ -1417,8 +1414,6 @@ def test_clear_pim_configuration_p1(requ
     write_test_footer(tc_name)
 
 
-
-
 if __name__ == "__main__":
     ARGS = ["-s"] + sys.argv[1:]
     sys.exit(pytest.main(ARGS))
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp2.py frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp2.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pim_static_rp2.py	2023-03-13 20:01:47.000000000 +0600
@@ -128,7 +128,6 @@ from lib.common_config import (
     kill_router_daemons,
     start_router_daemons,
     create_static_routes,
-    topo_daemons,
 )
 from lib.pim import (
     create_pim_config,
@@ -223,12 +222,9 @@ def setup_module(mod):
 
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, TOPO)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -456,9 +452,9 @@ def test_restart_pimd_process_p2(request
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -624,9 +620,9 @@ def test_multiple_groups_same_RP_address
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -648,9 +644,9 @@ def test_multiple_groups_same_RP_address
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (S, G) ip mroutes")
@@ -769,9 +765,9 @@ def test_multiple_groups_same_RP_address
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (S, G) ip mroutes")
@@ -791,9 +787,9 @@ def test_multiple_groups_same_RP_address
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -967,9 +963,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (S, G) ip mroutes")
@@ -989,9 +985,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1057,9 +1053,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r4: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r4: Verify (S, G) ip mroutes")
@@ -1077,8 +1073,11 @@ def test_multiple_groups_different_RP_ad
     result = verify_join_state_and_timer(
         tgen, dut, iif, SOURCE_ADDRESS, GROUP_ADDRESS_LIST_2, expected=False
     )
-    assert result is not True, "Testcase {} :Failed \n Error: {}".format(
-        tc_name, result
+    assert result is not True, (
+        "Testcase {} : Failed \n "
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1228,9 +1227,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (S, G) ip mroutes")
@@ -1250,9 +1249,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1318,9 +1317,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r4: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r4: Verify (S, G) ip mroutes")
@@ -1340,9 +1339,9 @@ def test_multiple_groups_different_RP_ad
     )
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (S,G) upstream state is joined and join timer is running\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: Upstream Join State should not be Joined and "
+        "join timer should not run\n "
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (S, G) ip mroutes")
@@ -1466,9 +1465,8 @@ def test_shutdown_primary_path_p1(reques
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: (*,G) mroutes are not cleared after shut of R1 to R3 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (*, G) ip mroutes")
@@ -1478,9 +1476,8 @@ def test_shutdown_primary_path_p1(reques
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (*,G) mroutes are not cleared after shut of R1 to R3 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: Verify (*, G) ip mroutes")
@@ -1490,9 +1487,9 @@ def test_shutdown_primary_path_p1(reques
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r3: (*,G) mroutes are not cleared after shut of R1 to R3 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared after shutting"
+        "link from R1 to R3 \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r3: No shutdown the link from R1 to R3 from R3 node")
@@ -1651,9 +1648,9 @@ def test_delete_RP_shut_noshut_upstream_
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: (*,G) mroutes are not cleared after shut of R1 to R0 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared after shutting"
+        "link from R1 to R0 \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (*, G) ip mroutes cleared")
@@ -1663,9 +1660,9 @@ def test_delete_RP_shut_noshut_upstream_
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (*,G) mroutes are not cleared after shut of R1 to R0 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared after shutting"
+        "link from R1 to R0 \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     write_test_footer(tc_name)
@@ -1774,9 +1771,9 @@ def test_delete_RP_shut_noshut_RP_interf
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r1: (*,G) mroutes are not cleared after shut of R1 to R2 and R3 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared after shutting"
+        "link from R2 to R3 \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     step("r2: Verify (*, G) ip mroutes cleared")
@@ -1786,9 +1783,9 @@ def test_delete_RP_shut_noshut_RP_interf
     result = verify_mroutes(tgen, dut, STAR, GROUP_ADDRESS, iif, oif, expected=False)
     assert result is not True, (
         "Testcase {} : Failed \n "
-        "r2: (*,G) mroutes are not cleared after shut of R1 to R2 and R3 link\n Error: {}".format(
-            tc_name, result
-        )
+        "Expected: [{}]: mroute (*, G) should be cleared after shutting"
+        "link from R2 to R3 \n"
+        "Found: {}".format(tc_name, dut, result)
     )
 
     write_test_footer(tc_name)
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pimv6_static_rp.py frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pimv6_static_rp.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pimv6_static_rp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_static_rp_topo1/test_multicast_pimv6_static_rp.py	1970-01-01 06:00:00.000000000 +0600
@@ -1,414 +0,0 @@
-#!/usr/bin/env python
-
-#
-# Copyright (c) 2022 by VMware, Inc. ("VMware")
-# Used Copyright (c) 2018 by Network Device Education Foundation,
-# Inc. ("NetDEF") in this file.
-#
-# Permission to use, copy, modify, and/or distribute this software
-# for any purpose with or without fee is hereby granted, provided
-# that the above copyright notice and this permission notice appear
-# in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND VMWARE DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL VMWARE BE LIABLE FOR
-# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
-# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
-# OF THIS SOFTWARE.
-#
-
-"""
-Following tests are covered to test Multicast basic functionality:
-
-Topology:
-
-                 _______r2_____
-                |             |
-      iperf     |             |     iperf
-        r0-----r1-------------r3-----r5
-                |             |
-                |_____________|
-                        r4
-
-Test steps
-- Create topology (setup module)
-- Bring up topology
-
-TC_1 : Verify upstream interfaces(IIF) and join state are updated properly
-       after adding and deleting the static RP
-TC_2 : Verify IIF and OIL in "show ip pim state" updated properly after
-       adding and deleting the static RP
-TC_3: (*, G) Mroute entry are cleared when static RP gets deleted
-TC_4: Verify (*,G) prune is send towards the RP after deleting the static RP
-TC_24 : Verify (*,G) and (S,G) populated correctly when SPT and RPT share the
-        same path
-"""
-
-import os
-import sys
-import json
-import time
-import pytest
-from time import sleep
-import datetime
-
-# Save the Current Working Directory to find configuration files.
-CWD = os.path.dirname(os.path.realpath(__file__))
-sys.path.append(os.path.join(CWD, "../"))
-sys.path.append(os.path.join(CWD, "../lib/"))
-
-# Required to instantiate the topology builder class.
-
-# pylint: disable=C0413
-# Import topogen and topotest helpers
-from lib.topogen import Topogen, get_topogen
-
-from lib.common_config import (
-    start_topology,
-    write_test_header,
-    write_test_footer,
-    reset_config_on_routers,
-    step,
-    shutdown_bringup_interface,
-    kill_router_daemons,
-    start_router_daemons,
-    create_static_routes,
-    check_router_status,
-    socat_send_igmp_join_traffic,
-    topo_daemons
-)
-from lib.pim import (
-    create_pim_config,
-    verify_igmp_groups,
-    verify_upstream_iif,
-    verify_join_state_and_timer,
-    verify_mroutes,
-    verify_pim_neighbors,
-    verify_pim_interface_traffic,
-    verify_pim_rp_info,
-    verify_pim_state,
-    clear_pim_interface_traffic,
-    clear_igmp_interfaces,
-    clear_pim_interfaces,
-    clear_mroute,
-    clear_mroute_verify,
-)
-from lib.topolog import logger
-from lib.topojson import build_topo_from_json, build_config_from_json
-
-# Global variables
-GROUP_RANGE_V6 = "ff08::/64"
-IGMP_JOIN_V6 = "ff08::1"
-STAR = "*"
-SOURCE = "Static"
-
-pytestmark = [pytest.mark.pimd]
-
-
-def build_topo(tgen):
-    """Build function"""
-
-    # Building topology from json file
-    build_topo_from_json(tgen, TOPO)
-
-
-def setup_module(mod):
-    """
-    Sets up the pytest environment
-
-    * `mod`: module name
-    """
-
-    testsuite_run_time = time.asctime(time.localtime(time.time()))
-    logger.info("Testsuite start time: %s", testsuite_run_time)
-    logger.info("=" * 40)
-
-    topology = """
-
-                 _______r2_____
-                |             |
-      iperf     |             |     iperf
-        r0-----r1-------------r3-----r5
-                |             |
-                |_____________|
-                        r4
-
-    """
-    logger.info("Master Topology: \n %s", topology)
-
-    logger.info("Running setup_module to create topology")
-
-    # This function initiates the topology build with Topogen...
-    json_file = "{}/multicast_pimv6_static_rp.json".format(CWD)
-    tgen = Topogen(json_file, mod.__name__)
-    global TOPO
-    TOPO = tgen.json_topo
-
-    # ... and here it calls Mininet initialization functions.
-
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, TOPO)
-
-    # Starting topology, create tmp files which are loaded to routers
-    #  to start daemons and then start routers
-    start_topology(tgen, daemons)
-
-    # Don"t run this test if we have any failure.
-    if tgen.routers_have_failure():
-        pytest.skip(tgen.errors)
-
-    # Creating configuration from JSON
-    build_config_from_json(tgen, TOPO)
-
-    # Verify PIM neighbors
-    result = verify_pim_neighbors(tgen, TOPO)
-    assert result is True, "setup_module :Failed \n Error:" " {}".format(result)
-
-    logger.info("Running setup_module() done")
-
-
-def teardown_module():
-    """Teardown the pytest environment"""
-
-    logger.info("Running teardown_module to delete topology")
-    tgen = get_topogen()
-
-    # Stop toplogy and Remove tmp files
-    tgen.stop_topology()
-
-    logger.info("Testsuite end time: %s", time.asctime(time.localtime(time.time())))
-    logger.info("=" * 40)
-
-
-#####################################################
-#
-#   Testcases
-#
-#####################################################
-
-
-def verify_state_incremented(state_before, state_after):
-    """
-    API to compare interface traffic state incrementing
-
-    Parameters
-    ----------
-    * `state_before` : State dictionary for any particular instance
-    * `state_after` : State dictionary for any particular instance
-    """
-
-    for router, state_data in state_before.items():
-        for state, value in state_data.items():
-            if state_before[router][state] >= state_after[router][state]:
-                errormsg = (
-                    "[DUT: %s]: state %s value has not"
-                    " incremented, Initial value: %s, "
-                    "Current value: %s [FAILED!!]"
-                    % (
-                        router,
-                        state,
-                        state_before[router][state],
-                        state_after[router][state],
-                    )
-                )
-                return errormsg
-
-            logger.info(
-                "[DUT: %s]: State %s value is "
-                "incremented, Initial value: %s, Current value: %s"
-                " [PASSED!!]",
-                router,
-                state,
-                state_before[router][state],
-                state_after[router][state],
-            )
-
-    return True
-
-
-#####################################################
-
-def test_pimv6_add_delete_static_RP_p0(request):
-    """
-    TC_1: Verify upstream interfaces(IIF) and join state are updated
-        properly after adding and deleting the static RP
-    TC_2: Verify IIF and OIL in "show ip pim state" updated properly
-        after adding and deleting the static RP
-    TC_3: (*, G) Mroute entry are cleared when static RP gets deleted
-    TC_4: Verify (*,G) prune is send towards the RP after deleting the
-        static RP
-
-    TOPOlogy used:
-         r0------r1-----r2
-       iperf    DUT     RP
-    """
-
-    tgen = get_topogen()
-    tc_name = request.node.name
-    write_test_header(tc_name)
-
-    # Don"t run this test if we have any failure.
-    if tgen.routers_have_failure():
-        check_router_status(tgen)
-
-    step("Shut link b/w R1 and R3 and R1 and R4 as per tescase topology")
-    intf_r1_r3 = TOPO["routers"]["r1"]["links"]["r3"]["interface"]
-    intf_r1_r4 = TOPO["routers"]["r1"]["links"]["r4"]["interface"]
-    for intf in [intf_r1_r3, intf_r1_r4]:
-        shutdown_bringup_interface(tgen, "r1", intf, ifaceaction=False)
-
-    step("Enable PIM between r1 and r2")
-    step("Enable MLD on r1 interface and send IGMP " "join (FF08::1) to r1")
-    step("Configure r2 loopback interface as RP")
-    input_dict = {
-        "r2": {
-            "pim6": {
-                "rp": [
-                    {
-                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
-                            "/"
-                        )[0],
-                        "group_addr_range": GROUP_RANGE_V6,
-                    }
-                ]
-            }
-        }
-    }
-
-    result = create_pim_config(tgen, TOPO, input_dict)
-    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
-
-    step("Verify show ip pim interface traffic without any mld join")
-    state_dict = {
-        "r1": {TOPO["routers"]["r1"]["links"]["r2"]["interface"]: ["pruneTx"]}
-    }
-
-    state_before = verify_pim_interface_traffic(tgen, state_dict, addr_type="ipv6")
-    assert isinstance(
-        state_before, dict
-    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
-        tc_name, result
-    )
-
-    step("send mld join (FF08::1) to R1")
-    intf = TOPO["routers"]["r0"]["links"]["r1"]["interface"]
-    intf_ip = TOPO["routers"]["r0"]["links"]["r1"]["ipv6"].split("/")[0]
-    result = socat_send_igmp_join_traffic(
-        tgen, "r0", "UDP6-RECV", IGMP_JOIN_V6, intf, intf_ip, join=True
-    )
-    assert result is True, "Testcase {}: Failed Error: {}".format(tc_name, result)
-
-    step("r1: Verify RP info")
-    dut = "r1"
-    oif = TOPO["routers"]["r1"]["links"]["r2"]["interface"]
-    iif = TOPO["routers"]["r1"]["links"]["r0"]["interface"]
-    rp_address = TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split("/")[0]
-    result = verify_pim_rp_info(
-        tgen, TOPO, dut, GROUP_RANGE_V6, oif, rp_address, SOURCE
-    )
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("r1: Verify upstream IIF interface")
-    result = verify_upstream_iif(tgen, dut, oif, STAR, IGMP_JOIN_V6)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("r1: Verify upstream join state and join timer")
-    result = verify_join_state_and_timer(tgen, dut, oif, STAR, IGMP_JOIN_V6)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("r1: Verify PIM state")
-    result = verify_pim_state(tgen, dut, oif, iif, IGMP_JOIN_V6)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("r1: Verify ip mroutes")
-    result = verify_mroutes(tgen, dut, STAR, IGMP_JOIN_V6, oif, iif)
-    assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
-
-    step("r1: Delete RP configuration")
-    input_dict = {
-        "r2": {
-            "pim6": {
-                "rp": [
-                    {
-                        "rp_addr": TOPO["routers"]["r2"]["links"]["lo"]["ipv6"].split(
-                            "/"
-                        )[0],
-                        "group_addr_range": GROUP_RANGE_V6,
-                        "delete": True,
-                    }
-                ]
-            }
-        }
-    }
-
-    result = create_pim_config(tgen, TOPO, input_dict)
-    assert result is True, "Testcase {} : Failed Error: {}".format(tc_name, result)
-
-    step("r1: Verify RP info")
-    result = verify_pim_rp_info(
-        tgen, TOPO, dut, GROUP_RANGE_V6, oif, rp_address, SOURCE, expected=False
-    )
-    assert (
-        result is not True
-    ), "Testcase {} :Failed \n " "RP: {} info is still present \n Error: {}".format(
-        tc_name, rp_address, result
-    )
-
-    step("r1: Verify upstream IIF interface")
-    result = verify_upstream_iif(tgen, dut, oif, STAR, IGMP_JOIN_V6, expected=False)
-    assert result is not True, (
-        "Testcase {} :Failed \n "
-        "Upstream ({}, {}) is still in join state \n Error: {}".format(
-            tc_name, STAR, IGMP_JOIN_V6, result
-        )
-    )
-
-    step("r1: Verify upstream join state and join timer")
-    result = verify_join_state_and_timer(
-        tgen, dut, oif, STAR, IGMP_JOIN_V6, expected=False
-    )
-    assert result is not True, (
-        "Testcase {} :Failed \n "
-        "Upstream ({}, {}) timer is still running \n Error: {}".format(
-            tc_name, STAR, IGMP_JOIN_V6, result
-        )
-    )
-
-    step("r1: Verify PIM state")
-    result = verify_pim_state(tgen, dut, oif, iif, IGMP_JOIN_V6, expected=False)
-    assert result is not True, (
-        "Testcase {} :Failed \n "
-        "PIM state for group: {} is still Active \n Error: {}".format(
-            tc_name, IGMP_JOIN_V6, result
-        )
-    )
-
-    step("r1: Verify ip mroutes")
-    result = verify_mroutes(tgen, dut, STAR, IGMP_JOIN_V6, oif, iif, expected=False)
-    assert result is not True, (
-        "Testcase {} :Failed \n "
-        "mroute ({}, {}) is still present \n Error: {}".format(
-            tc_name, STAR, IGMP_JOIN_V6, result
-        )
-    )
-
-    step("r1: Verify show ip pim interface traffic without any IGMP join")
-    state_after = verify_pim_interface_traffic(tgen, state_dict, addr_type="ipv6")
-    assert isinstance(
-        state_after, dict
-    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
-        tc_name, result
-    )
-
-    result = verify_state_incremented(state_before, state_after)
-    assert result is True, "Testcase{} : Failed Error: {}".format(tc_name, result)
-
-    write_test_footer(tc_name)
-
-
-if __name__ == "__main__":
-    args = ["-s"] + sys.argv[1:]
-    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/multicast_pim_uplink_topo1/test_multicast_pim_uplink_topo1.py frr-frr-8.5/tests/topotests/multicast_pim_uplink_topo1/test_multicast_pim_uplink_topo1.py
--- frr-frr-8.4.2/tests/topotests/multicast_pim_uplink_topo1/test_multicast_pim_uplink_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/multicast_pim_uplink_topo1/test_multicast_pim_uplink_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -64,7 +64,6 @@ from lib.common_config import (
     stop_router,
     create_static_routes,
     required_linux_kernel_version,
-    topo_daemons,
 )
 from lib.bgp import create_router_bgp
 from lib.pim import (
@@ -148,12 +147,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, tgen.json_topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start deamons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Don"t run this test if we have any failure.
     if tgen.routers_have_failure():
@@ -349,8 +345,9 @@ def configure_static_routes_for_rp_reach
         }
 
         result = create_static_routes(tgen, static_routes)
-        assert result is True, "API {} : Failed Error: {}".\
-            format(sys._getframe().f_code.co_name, result)
+        assert result is True, "API {} : Failed Error: {}".format(
+            sys._getframe().f_code.co_name, result
+        )
 
 
 def verify_state_incremented(state_before, state_after):
@@ -1666,9 +1663,10 @@ def test_mroutes_updated_correctly_after
             data["oil"],
             expected=False,
         )
-        assert result is not True, (
-            "Testcase {} : Failed "
-            "Mroute IIF and OIF are same \n Error: {}".format(tc_name, result)
+        assert (
+            result is not True
+        ), "Testcase {} : Failed " "Mroute IIF and OIF are same \n Error: {}".format(
+            tc_name, result
         )
 
     step("Shut and No shut source interface multiple time")
@@ -2339,9 +2337,10 @@ def test_mroutes_updated_after_sending_I
             data["oil"],
             expected=False,
         )
-        assert result is not True, (
-            "Testcase {} : Failed "
-            " mroute are still present \n Error: {}".format(tc_name, result)
+        assert (
+            result is not True
+        ), "Testcase {} : Failed " " mroute are still present \n Error: {}".format(
+            tc_name, result
         )
 
     for data in input_dict_sg:
@@ -2354,9 +2353,10 @@ def test_mroutes_updated_after_sending_I
             data["oil"],
             expected=False,
         )
-        assert result is not True, (
-            "Testcase {} : Failed "
-            " mroute are still present \n Error: {}".format(tc_name, result)
+        assert (
+            result is not True
+        ), "Testcase {} : Failed " " mroute are still present \n Error: {}".format(
+            tc_name, result
         )
 
     step(
@@ -2795,10 +2795,11 @@ def test_mroutes_updated_after_changing_
     intf_traffic = topo["routers"]["r4"]["links"]["r3-link1"]["interface"]
     state_dict = {"r4": {intf_traffic: ["registerStopRx"]}}
     state_before = verify_pim_interface_traffic(tgen, state_dict)
-    assert  isinstance(state_before, dict), \
-    ("Testcase{} : Failed \n state_before is not dictionary \n "
-    "Error: {}".\
-        format(tc_name, result))
+    assert isinstance(
+        state_before, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
 
     step("Change the RP to R3 loopback for same group range (225.1.1.1-5)")
 
@@ -2888,10 +2889,11 @@ def test_mroutes_updated_after_changing_
     step("Verify pim interface traffic after changing RP")
 
     state_after = verify_pim_interface_traffic(tgen, state_dict)
-    assert  isinstance(state_before, dict), \
-    ("Testcase{} : Failed \n state_before is not dictionary \n "
-    "Error: {}".\
-        format(tc_name, result))
+    assert isinstance(
+        state_before, dict
+    ), "Testcase{} : Failed \n state_before is not dictionary \n " "Error: {}".format(
+        tc_name, result
+    )
 
     result = verify_state_incremented(state_before, state_after)
     assert result is True, "Testcase{} : Failed Error: {}".format(tc_name, result)
@@ -3285,9 +3287,10 @@ def test_mroutes_after_restart_frr_servi
                 data["oil"],
                 expected=False,
             )
-            assert result is not True, (
-                "Testcase {}: Failed "
-                "mroutes are still present \n Error: {}".format(tc_name, result)
+            assert (
+                result is not True
+            ), "Testcase {}: Failed " "mroutes are still present \n Error: {}".format(
+                tc_name, result
             )
 
     step("Stop FRR on R4 node")
@@ -3310,9 +3313,10 @@ def test_mroutes_after_restart_frr_servi
             data["oil"],
             expected=False,
         )
-        assert result is not True, (
-            "Testcase {} : Failed "
-            " Mroutes are still present \n Error: {}".format(tc_name, result)
+        assert (
+            result is not True
+        ), "Testcase {} : Failed " " Mroutes are still present \n Error: {}".format(
+            tc_name, result
         )
 
     step("Start FRR on R4 node")
diff -urpN frr-frr-8.4.2/tests/topotests/ospf6_gr_topo1/test_ospf6_gr_topo1.py frr-frr-8.5/tests/topotests/ospf6_gr_topo1/test_ospf6_gr_topo1.py
--- frr-frr-8.4.2/tests/topotests/ospf6_gr_topo1/test_ospf6_gr_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf6_gr_topo1/test_ospf6_gr_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -224,7 +224,7 @@ def check_routers(initial_convergence=Fa
             if restarting != None:
                 tries = 40
             else:
-                tries = 1
+                tries = 10
         router_compare_json_output(
             rname, "show ipv6 route ospf json", "show_ipv6_route.json", tries
         )
@@ -246,7 +246,7 @@ def check_routers(initial_convergence=Fa
             if initial_convergence == True or restarting == rname:
                 tries = 240
             else:
-                tries = 1
+                tries = 10
             router_compare_json_output(
                 rname,
                 "show ipv6 ospf database json",
diff -urpN frr-frr-8.4.2/tests/topotests/ospf6_topo2/test_ospf6_topo2.py frr-frr-8.5/tests/topotests/ospf6_topo2/test_ospf6_topo2.py
--- frr-frr-8.4.2/tests/topotests/ospf6_topo2/test_ospf6_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf6_topo2/test_ospf6_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -243,7 +243,7 @@ def test_ospf6_default_route():
             "show ipv6 route json",
             {route: [{"metric": metric}]},
         )
-        _, result = topotest.run_and_expect(test_func, None, count=4, wait=1)
+        _, result = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = '"{}" convergence failure'.format(router)
         assert result is None, assertmsg
 
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/ospf_rte_calc.json frr-frr-8.5/tests/topotests/ospf_basic_functionality/ospf_rte_calc.json
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/ospf_rte_calc.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/ospf_rte_calc.json	2023-03-13 20:01:47.000000000 +0600
@@ -1,5 +1,5 @@
 {
-
+    "feature": ["bgp"],
     "ipv4base": "10.0.0.0",
     "ipv4mask": 24,
     "link_ip_start": {
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_topo1.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_topo1.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -53,7 +53,6 @@ from lib.common_config import (
     start_router_daemons,
     create_route_maps,
     shutdown_bringup_interface,
-    topo_daemons,
     create_prefix_lists,
     create_route_maps,
     create_interfaces_cfg,
@@ -142,12 +141,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -312,11 +308,11 @@ def test_ospf_type5_summary_tc43_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -340,11 +336,11 @@ def test_ospf_type5_summary_tc43_p0(requ
 
     input_dict = {
         "11.0.0.0/16": {
-            "Summary address": "11.0.0.0/16",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": "11.0.0.0/16",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -384,11 +380,11 @@ def test_ospf_type5_summary_tc43_p0(requ
 
     input_dict = {
         "11.0.0.0/16": {
-            "Summary address": "11.0.0.0/24",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 0,
+            "summaryAddress": "11.0.0.0/24",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 0,
         }
     }
     dut = "r0"
@@ -560,11 +556,11 @@ def test_ospf_type5_summary_tc48_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -656,11 +652,11 @@ def test_ospf_type5_summary_tc48_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -753,11 +749,11 @@ def test_ospf_type5_summary_tc42_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -824,11 +820,11 @@ def test_ospf_type5_summary_tc42_p0(requ
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -863,11 +859,11 @@ def test_ospf_type5_summary_tc42_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -946,11 +942,11 @@ def test_ospf_type5_summary_tc42_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1082,11 +1078,11 @@ def test_ospf_type5_summary_tc42_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1246,11 +1242,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1234,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1234,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1298,11 +1294,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1234,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1234,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1339,11 +1335,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1388,11 +1384,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     )
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 4294967295,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 4294967295,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1445,11 +1441,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     )
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 88888,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 88888,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1677,11 +1673,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1234,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1234,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1726,11 +1722,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1234,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1234,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1767,11 +1763,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1816,11 +1812,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     )
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 4294967295,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 4294967295,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1873,11 +1869,11 @@ def test_ospf_type5_summary_tc45_p0(requ
     )
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 88888,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 88888,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2064,8 +2060,8 @@ def test_ospf_type5_summary_tc46_p0(requ
     step("Verify that show ip ospf summary should show the " "configured summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2115,11 +2111,11 @@ def test_ospf_type5_summary_tc46_p0(requ
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 1234,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 1234,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2171,8 +2167,8 @@ def test_ospf_type5_summary_tc46_p0(requ
     step("Verify that show ip ospf summary should show the " "configured summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2233,11 +2229,11 @@ def test_ospf_type5_summary_tc46_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2347,11 +2343,11 @@ def test_ospf_type5_summary_tc47_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2444,11 +2440,11 @@ def test_ospf_type5_summary_tc47_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2532,11 +2528,11 @@ def test_ospf_type5_summary_tc47_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2627,11 +2623,11 @@ def test_ospf_type5_summary_tc47_p0(requ
 
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2795,11 +2791,11 @@ def test_ospf_type5_summary_tc47_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         "12.0.0.0/8": {
-            "Summary address": "12.0.0.0/8",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": "12.0.0.0/8",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -3001,11 +2997,11 @@ def test_ospf_type5_summary_tc51_p2(requ
 
     input_dict = {
         SUMMARY["ipv4"][2]: {
-            "Summary address": SUMMARY["ipv4"][2],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 0,
+            "summaryAddress": SUMMARY["ipv4"][2],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 0,
         }
     }
     dut = "r0"
@@ -3096,11 +3092,11 @@ def test_ospf_type5_summary_tc49_p2(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -3152,11 +3148,11 @@ def test_ospf_type5_summary_tc49_p2(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -3216,11 +3212,11 @@ def test_ospf_type5_summary_tc49_p2(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -3273,11 +3269,11 @@ def test_ospf_type5_summary_tc49_p2(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][0]: {
-            "Summary address": SUMMARY["ipv4"][0],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][0],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_type7_lsa.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_type7_lsa.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_type7_lsa.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_asbr_summary_type7_lsa.py	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,6 @@ from lib.common_config import (
     verify_rib,
     create_static_routes,
     step,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -134,12 +133,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -294,11 +290,11 @@ def test_ospf_type5_summary_tc44_p0(requ
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv4"][3]: {
-            "Summary address": SUMMARY["ipv4"][3],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][3],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -346,11 +342,11 @@ def test_ospf_type5_summary_tc44_p0(requ
     step("Verify that type7 LSAs received from neighbor are not summarised.")
     input_dict = {
         "13.0.0.0/8": {
-            "Summary address": "13.0.0.0/8",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 0,
+            "summaryAddress": "13.0.0.0/8",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 0,
         }
     }
     dut = "r0"
@@ -362,11 +358,11 @@ def test_ospf_type5_summary_tc44_p0(requ
     step("Verify that already originated summary is intact.")
     input_dict = {
         SUMMARY["ipv4"][3]: {
-            "Summary address": SUMMARY["ipv4"][3],
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv4"][3],
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_authentication.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_authentication.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_authentication.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_authentication.py	2023-03-13 20:01:47.000000000 +0600
@@ -47,7 +47,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     shutdown_bringup_interface,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -102,12 +101,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_chaos.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_chaos.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_chaos.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_chaos.py	2023-03-13 20:01:47.000000000 +0600
@@ -43,7 +43,6 @@ from lib.common_config import (
     write_test_footer,
     reset_config_on_routers,
     step,
-    topo_daemons,
     verify_rib,
     stop_router,
     start_router,
@@ -113,12 +112,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_ecmp.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_ecmp.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_ecmp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_ecmp.py	2023-03-13 20:01:47.000000000 +0600
@@ -47,7 +47,6 @@ from lib.common_config import (
     create_static_routes,
     step,
     shutdown_bringup_interface,
-    topo_daemons,
 )
 from lib.topolog import logger
 
@@ -116,12 +115,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_ecmp_lan.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_ecmp_lan.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_ecmp_lan.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_ecmp_lan.py	2023-03-13 20:01:47.000000000 +0600
@@ -45,7 +45,6 @@ from lib.common_config import (
     verify_rib,
     create_static_routes,
     step,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -117,12 +116,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_lan.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_lan.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_lan.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_lan.py	2023-03-13 20:01:47.000000000 +0600
@@ -49,7 +49,6 @@ from lib.common_config import (
     shutdown_bringup_interface,
     stop_router,
     start_router,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -116,12 +115,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -147,7 +143,7 @@ def teardown_module():
 
     try:
         # Stop toplogy and Remove tmp files
-        tgen.stop_topology
+        tgen.stop_topology()
 
     except OSError:
         # OSError exception is raised when mininet tries to stop switch
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_nssa.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_nssa.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_nssa.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_nssa.py	2023-03-13 20:01:47.000000000 +0600
@@ -39,7 +39,6 @@ from lib.common_config import (
     verify_rib,
     create_static_routes,
     step,
-    topo_daemons,
 )
 from lib.topogen import Topogen, get_topogen
 import os
@@ -114,12 +113,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_p2mp.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_p2mp.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_p2mp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_p2mp.py	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
     retry,
     run_frr_cmd,
 )
@@ -105,12 +104,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_routemaps.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_routemaps.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_routemaps.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_routemaps.py	2023-03-13 20:01:47.000000000 +0600
@@ -48,7 +48,6 @@ from lib.common_config import (
     step,
     create_route_maps,
     verify_prefix_lists,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -129,12 +128,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_rte_calc.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_rte_calc.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_rte_calc.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_rte_calc.py	2023-03-13 20:01:47.000000000 +0600
@@ -48,7 +48,6 @@ from lib.common_config import (
     create_static_routes,
     step,
     shutdown_bringup_interface,
-    topo_daemons,
 )
 from lib.bgp import verify_bgp_convergence, create_router_bgp
 from lib.topolog import logger
@@ -125,12 +124,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_single_area.py frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_single_area.py
--- frr-frr-8.4.2/tests/topotests/ospf_basic_functionality/test_ospf_single_area.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_basic_functionality/test_ospf_single_area.py	2023-03-13 20:01:47.000000000 +0600
@@ -48,7 +48,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -110,12 +109,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_dual_stack/test_ospf_dual_stack.py frr-frr-8.5/tests/topotests/ospf_dual_stack/test_ospf_dual_stack.py
--- frr-frr-8.4.2/tests/topotests/ospf_dual_stack/test_ospf_dual_stack.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_dual_stack/test_ospf_dual_stack.py	2023-03-13 20:01:47.000000000 +0600
@@ -17,7 +17,6 @@ from lib.common_config import (
     write_test_footer,
     reset_config_on_routers,
     step,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -48,12 +47,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_helper/ospf_gr_helper.json frr-frr-8.5/tests/topotests/ospf_gr_helper/ospf_gr_helper.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_helper/ospf_gr_helper.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_helper/ospf_gr_helper.json	2023-03-13 20:01:47.000000000 +0600
@@ -17,7 +17,7 @@
                     "ospf": {
                         "area": "0.0.0.0",
                         "hello_interval": 1,
-                        "dead_interval": 40,
+                        "dead_interval": 4,
                         "priority": 98
                     }
                 },
@@ -26,7 +26,7 @@
                     "ospf": {
                         "area": "0.0.0.0",
                         "hello_interval": 1,
-                        "dead_interval": 40,
+                        "dead_interval": 4,
                         "priority": 99
                     }
                 },
@@ -35,7 +35,7 @@
                     "ospf": {
                         "area": "0.0.0.0",
                         "hello_interval": 1,
-                        "dead_interval": 40,
+                        "dead_interval": 4,
                         "priority": 0
                     }
                 },
@@ -44,7 +44,7 @@
                     "ospf": {
                         "area": "0.0.0.0",
                         "hello_interval": 1,
-                        "dead_interval": 40,
+                        "dead_interval": 4,
                         "priority": 0
                     }
                 }
@@ -116,4 +116,4 @@
             }
         }
     }
-}
\ No newline at end of file
+}
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper1.py frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper1.py
--- frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper1.py	2023-03-13 20:01:47.000000000 +0600
@@ -43,7 +43,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
     scapy_send_raw_packet,
 )
 
@@ -121,12 +120,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -157,7 +153,7 @@ def teardown_module():
 
     try:
         # Stop toplogy and Remove tmp files
-        tgen.stop_topology
+        tgen.stop_topology()
 
     except OSError:
         # OSError exception is raised when mininet tries to stop switch
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper2.py frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper2.py
--- frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper2.py	2023-03-13 20:01:47.000000000 +0600
@@ -43,7 +43,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
     scapy_send_raw_packet,
 )
 
@@ -121,12 +120,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -157,7 +153,7 @@ def teardown_module():
 
     try:
         # Stop toplogy and Remove tmp files
-        tgen.stop_topology
+        tgen.stop_topology()
 
     except OSError:
         # OSError exception is raised when mininet tries to stop switch
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper3.py frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper3.py
--- frr-frr-8.4.2/tests/topotests/ospf_gr_helper/test_ospf_gr_helper3.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_helper/test_ospf_gr_helper3.py	2023-03-13 20:01:47.000000000 +0600
@@ -43,7 +43,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
     scapy_send_raw_packet,
 )
 
@@ -121,12 +120,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -157,7 +153,7 @@ def teardown_module():
 
     try:
         # Stop toplogy and Remove tmp files
-        tgen.stop_topology
+        tgen.stop_topology()
 
     except OSError:
         # OSError exception is raised when mininet tries to stop switch
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt1/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt1/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt1/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt1/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -6,7 +6,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -83,7 +83,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt2"
+        "directlyAttachedTo":"eth-rt2"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt2/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt2/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt2/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt2/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -17,7 +17,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -83,7 +83,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt1"
+        "directlyAttachedTo":"eth-rt1"
       }
     ]
   },
@@ -94,7 +94,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt3"
+        "directlyAttachedTo":"eth-rt3"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt3/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt3/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt3/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt3/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -28,7 +28,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -94,7 +94,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt2"
+        "directlyAttachedTo":"eth-rt2"
       }
     ]
   },
@@ -105,7 +105,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt4"
+        "directlyAttachedTo":"eth-rt4"
       }
     ]
   },
@@ -116,7 +116,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt6"
+        "directlyAttachedTo":"eth-rt6"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt4/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt4/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt4/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt4/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -39,7 +39,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -105,7 +105,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt3"
+        "directlyAttachedTo":"eth-rt3"
       }
     ]
   },
@@ -127,7 +127,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt5"
+        "directlyAttachedTo":"eth-rt5"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt5/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt5/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt5/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt5/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -50,7 +50,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -127,7 +127,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt4"
+        "directlyAttachedTo":"eth-rt4"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt6/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt6/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt6/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt6/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -61,7 +61,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -116,7 +116,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt3"
+        "directlyAttachedTo":"eth-rt3"
       }
     ]
   },
@@ -138,7 +138,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt7"
+        "directlyAttachedTo":"eth-rt7"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt7/show_ip_ospf_route.json frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt7/show_ip_ospf_route.json
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/rt7/show_ip_ospf_route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/rt7/show_ip_ospf_route.json	2023-03-13 20:01:47.000000000 +0600
@@ -83,7 +83,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"lo"
+        "directlyAttachedTo":"lo"
       }
     ]
   },
@@ -149,7 +149,7 @@
     "nexthops":[
       {
         "ip":" ",
-        "directly attached to":"eth-rt6"
+        "directlyAttachedTo":"eth-rt6"
       }
     ]
   },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/test_ospf_gr_topo1.py frr-frr-8.5/tests/topotests/ospf_gr_topo1/test_ospf_gr_topo1.py
--- frr-frr-8.4.2/tests/topotests/ospf_gr_topo1/test_ospf_gr_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_gr_topo1/test_ospf_gr_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -233,7 +233,7 @@ def check_routers(initial_convergence=Fa
             if restarting != None:
                 tries = 60
             else:
-                tries = 1
+                tries = 10
         router_compare_json_output(
             rname, "show ip route ospf json", "show_ip_route.json", tries
         )
@@ -252,7 +252,7 @@ def check_routers(initial_convergence=Fa
             if initial_convergence == True or restarting == rname:
                 tries = 240
             else:
-                tries = 1
+                tries = 10
             router_compare_json_output(
                 rname, "show ip ospf database json", "show_ip_ospf_database.json", tries
             )
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/r1/zebra.conf frr-frr-8.5/tests/topotests/ospf_te_topo1/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -7,6 +7,7 @@ interface r1-eth0
  link-params
   metric 20
   delay 10000
+  max-bw 10e+10
   ava-bw 1.25e+08
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/r2/zebra.conf frr-frr-8.5/tests/topotests/ospf_te_topo1/r2/zebra.conf
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/r2/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/r2/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -25,6 +25,7 @@ interface r2-eth3
  link-params
   metric 30
   delay 25000
+  max-bw 10e+10
   use-bw 1.25e+8
   enable
   exit-link-params
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step1.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step1.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step1.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step1.json	2023-03-13 20:01:47.000000000 +0600
@@ -68,32 +68,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -111,32 +111,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -152,32 +152,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -193,32 +193,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -235,32 +235,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -276,32 +276,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -317,32 +317,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -371,32 +371,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -414,32 +414,32 @@
         "edge-attributes":{
           "te-metric":10,
           "local-address":"10.0.5.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "remote-asn":65535,
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step2.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step2.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step2.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step2.json	2023-03-13 20:01:47.000000000 +0600
@@ -68,32 +68,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -111,32 +111,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -153,32 +153,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -194,32 +194,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -235,32 +235,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -289,32 +289,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
@@ -332,32 +332,32 @@
         "edge-attributes":{
           "te-metric":10,
           "local-address":"10.0.5.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "remote-asn":65535,
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step3.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step3.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step3.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step3.json	2023-03-13 20:01:47.000000000 +0600
@@ -60,32 +60,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -103,32 +103,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -145,32 +145,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -186,32 +186,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -227,32 +227,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -281,32 +281,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step4.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step4.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step4.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step4.json	2023-03-13 20:01:47.000000000 +0600
@@ -83,32 +83,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -138,32 +138,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -192,32 +192,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -233,32 +233,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -286,32 +286,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -340,32 +340,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step5.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step5.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step5.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step5.json	2023-03-13 20:01:47.000000000 +0600
@@ -83,32 +83,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -138,32 +138,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -191,32 +191,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -244,32 +244,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -298,32 +298,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -339,32 +339,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -392,32 +392,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -446,32 +446,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000,
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step6.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step6.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step6.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step6.json	2023-03-13 20:01:47.000000000 +0600
@@ -83,32 +83,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -138,32 +138,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -191,32 +191,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -244,32 +244,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -298,32 +298,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -339,32 +339,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -392,32 +392,32 @@
         "edge-attributes":{
           "local-address":"10.0.4.1",
           "remote-address":"10.0.4.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":20000,
@@ -448,32 +448,32 @@
           "te-metric":30,
           "local-address":"10.0.4.2",
           "remote-address":"10.0.4.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":25000
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step7.json frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step7.json
--- frr-frr-8.4.2/tests/topotests/ospf_te_topo1/reference/ted_step7.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_te_topo1/reference/ted_step7.json	2023-03-13 20:01:47.000000000 +0600
@@ -64,32 +64,32 @@
           "te-metric":20,
           "local-address":"10.0.0.1",
           "remote-address":"10.0.0.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":99999997952,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ],
           "delay":10000,
@@ -119,32 +119,32 @@
         "edge-attributes":{
           "local-address":"10.0.0.2",
           "remote-address":"10.0.0.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -172,32 +172,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.1",
           "remote-address":"10.0.1.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -225,32 +225,32 @@
         "edge-attributes":{
           "local-address":"10.0.1.2",
           "remote-address":"10.0.1.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
@@ -279,32 +279,32 @@
           "admin-group":32,
           "local-address":"10.0.3.1",
           "remote-address":"10.0.3.2",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         }
@@ -320,32 +320,32 @@
         "edge-attributes":{
           "local-address":"10.0.3.2",
           "remote-address":"10.0.3.1",
-          "max-link-bandwidth":176258176.0,
-          "max-resv-link-bandwidth":176258176.0,
+          "max-link-bandwidth":1250000,
+          "max-resv-link-bandwidth":1250000,
           "unreserved-bandwidth":[
             {
-              "class-type-0":176258176.0
+              "class-type-0":1250000
             },
             {
-              "class-type-1":176258176.0
+              "class-type-1":1250000
             },
             {
-              "class-type-2":176258176.0
+              "class-type-2":1250000
             },
             {
-              "class-type-3":176258176.0
+              "class-type-3":1250000
             },
             {
-              "class-type-4":176258176.0
+              "class-type-4":1250000
             },
             {
-              "class-type-5":176258176.0
+              "class-type-5":1250000
             },
             {
-              "class-type-6":176258176.0
+              "class-type-6":1250000
             },
             {
-              "class-type-7":176258176.0
+              "class-type-7":1250000
             }
           ]
         },
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_unnumbered/r1/ospf-route.json frr-frr-8.5/tests/topotests/ospf_unnumbered/r1/ospf-route.json
--- frr-frr-8.4.2/tests/topotests/ospf_unnumbered/r1/ospf-route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_unnumbered/r1/ospf-route.json	2023-03-13 20:01:47.000000000 +0600
@@ -1 +1 @@
-{ "10.0.1.1\/32": { "routeType": "N", "cost": 10, "area": "0.0.0.0", "nexthops": [ { "ip": " ", "directly attached to": "r1-eth0" } ] }, "10.0.20.1\/32": { "routeType": "N", "cost": 20, "area": "0.0.0.0", "nexthops": [ { "ip": "10.0.3.2", "via": "r1-eth1" } ] }, "10.0.255.2": { "routeType": "R ", "cost": 10, "area": "0.0.0.0", "routerType": "asbr", "nexthops": [ { "ip": "10.0.3.2", "via": "r1-eth1" } ] } }
+{ "10.0.1.1\/32": { "routeType": "N", "cost": 10, "area": "0.0.0.0", "nexthops": [ { "ip": " ", "directlyAttachedTo": "r1-eth0" } ] }, "10.0.20.1\/32": { "routeType": "N", "cost": 20, "area": "0.0.0.0", "nexthops": [ { "ip": "10.0.3.2", "via": "r1-eth1" } ] }, "10.0.255.2": { "routeType": "R ", "cost": 10, "area": "0.0.0.0", "routerType": "asbr", "nexthops": [ { "ip": "10.0.3.2", "via": "r1-eth1" } ] } }
diff -urpN frr-frr-8.4.2/tests/topotests/ospf_unnumbered/r2/ospf-route.json frr-frr-8.5/tests/topotests/ospf_unnumbered/r2/ospf-route.json
--- frr-frr-8.4.2/tests/topotests/ospf_unnumbered/r2/ospf-route.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospf_unnumbered/r2/ospf-route.json	2023-03-13 20:01:47.000000000 +0600
@@ -1 +1 @@
-{ "10.0.1.1\/32": { "routeType": "N", "cost": 20, "area": "0.0.0.0", "nexthops": [ { "ip": "10.0.3.4", "via": "r2-eth1" } ] }, "10.0.20.1\/32": { "routeType": "N", "cost": 10, "area": "0.0.0.0", "nexthops": [ { "ip": " ", "directly attached to": "r2-eth0" } ] }, "10.0.255.1": { "routeType": "R ", "cost": 10, "area": "0.0.0.0", "routerType": "asbr", "nexthops": [ { "ip": "10.0.3.4", "via": "r2-eth1" } ] } }
+{ "10.0.1.1\/32": { "routeType": "N", "cost": 20, "area": "0.0.0.0", "nexthops": [ { "ip": "10.0.3.4", "via": "r2-eth1" } ] }, "10.0.20.1\/32": { "routeType": "N", "cost": 10, "area": "0.0.0.0", "nexthops": [ { "ip": " ", "directlyAttachedTo": "r2-eth0" } ] }, "10.0.255.1": { "routeType": "R ", "cost": 10, "area": "0.0.0.0", "routerType": "asbr", "nexthops": [ { "ip": "10.0.3.4", "via": "r2-eth1" } ] } }
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/bgp.py frr-frr-8.5/tests/topotests/ospfapi/lib/bgp.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/bgp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/bgp.py	2023-03-13 20:01:47.000000000 +0600
@@ -830,22 +830,36 @@ def __create_bgp_neighbor(topo, input_di
     global_connect = input_dict.get("connecttimer", 5)
 
     for name, peer_dict in neigh_data.items():
+        remote_as = 0
         for dest_link, peer in peer_dict["dest_link"].items():
+            local_asn = peer.setdefault("local_asn", {})
+            if local_asn:
+                local_as = local_asn.setdefault("local_as", 0)
+                remote_as = local_asn.setdefault("remote_as", 0)
+                no_prepend = local_asn.setdefault("no_prepend", False)
+                replace_as = local_asn.setdefault("replace_as", False)
+                if local_as == remote_as:
+                    assert False is True, (
+                        " Configuration Error : Router must not have "
+                        "same AS-NUMBER as Local AS NUMBER"
+                    )
             nh_details = topo[name]
 
             if "vrfs" in topo[router] or type(nh_details["bgp"]) is list:
                 for vrf_data in nh_details["bgp"]:
                     if "vrf" in nh_details["links"][dest_link] and "vrf" in vrf_data:
                         if nh_details["links"][dest_link]["vrf"] == vrf_data["vrf"]:
-                            remote_as = vrf_data["local_as"]
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
                             break
                     else:
                         if "vrf" not in vrf_data:
-                            remote_as = vrf_data["local_as"]
-                            break
-
+                            if not remote_as:
+                                remote_as = vrf_data["local_as"]
+                                break
             else:
-                remote_as = nh_details["bgp"]["local_as"]
+                if not remote_as:
+                    remote_as = nh_details["bgp"]["local_as"]
 
             update_source = None
 
@@ -890,6 +904,14 @@ def __create_bgp_neighbor(topo, input_di
                 elif add_neigh:
                     config_data.append("{} remote-as {}".format(neigh_cxt, remote_as))
 
+                if local_asn and local_as:
+                    cmd = "{} local-as {}".format(neigh_cxt, local_as)
+                    if no_prepend:
+                        cmd = "{} no-prepend".format(cmd)
+                    if replace_as:
+                        cmd = "{} replace-as".format(cmd)
+                    config_data.append("{}".format(cmd))
+
             if addr_type == "ipv6":
                 config_data.append("address-family ipv6 unicast")
                 config_data.append("{} activate".format(neigh_cxt))
@@ -1887,7 +1909,7 @@ def clear_bgp(tgen, addr_type, router, v
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
-def clear_bgp_and_verify(tgen, topo, router):
+def clear_bgp_and_verify(tgen, topo, router, rid=None):
     """
     This API is to clear bgp neighborship and verify bgp neighborship
     is coming up(BGP is converged) usinf "show bgp summary json" command
@@ -1937,7 +1959,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
 
@@ -1997,10 +2023,15 @@ def clear_bgp_and_verify(tgen, topo, rou
     logger.info("Clearing BGP neighborship for router %s..", router)
     for addr_type in bgp_addr_type.keys():
         if addr_type == "ipv4":
-            run_frr_cmd(rnode, "clear ip bgp *")
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv4 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv4 *")
         elif addr_type == "ipv6":
-            run_frr_cmd(rnode, "clear bgp ipv6 *")
-
+            if rid:
+                run_frr_cmd(rnode, "clear bgp ipv6 {}".format(rid))
+            else:
+                run_frr_cmd(rnode, "clear bgp ipv6 *")
     peer_uptime_after_clear_bgp = {}
     # Verifying BGP convergence after bgp clear command
     for retry in range(50):
@@ -2020,7 +2051,11 @@ def clear_bgp_and_verify(tgen, topo, rou
             return errormsg
 
         # To find neighbor ip type
-        bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        try:
+            bgp_addr_type = topo["routers"][router]["bgp"]["address_family"]
+        except TypeError:
+            bgp_addr_type = topo["routers"][router]["bgp"][0]["address_family"]
+
         total_peer = 0
         for addr_type in bgp_addr_type.keys():
             if not check_address_types(addr_type):
@@ -2775,7 +2810,11 @@ def verify_best_path_as_per_admin_distan
         if route in rib_routes_json:
             st_found = True
             # Verify next_hop in rib_routes_json
-            if rib_routes_json[route][0]["nexthops"][0]["ip"] == _next_hop:
+            if [
+                nh
+                for nh in rib_routes_json[route][0]["nexthops"]
+                if nh["ip"] == _next_hop
+            ]:
                 nh_found = True
             else:
                 errormsg = (
@@ -4238,7 +4277,7 @@ def verify_attributes_for_evpn_routes(
                         for _rd, route_data in evpn_rd_value_json.items():
                             if route_data["ip"] == route:
                                 for rt_data in route_data["paths"]:
-                                    if vni_dict[vrf] == rt_data["VNI"]:
+                                    if vni_dict[vrf] == rt_data["vni"]:
                                         rt_string = rt_data["extendedCommunity"][
                                             "string"
                                         ]
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/common_config.py frr-frr-8.5/tests/topotests/ospfapi/lib/common_config.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/common_config.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/common_config.py	2023-03-13 20:01:47.000000000 +0600
@@ -81,6 +81,26 @@ DEBUG_LOGS = {
         "debug pim packets register",
         "debug pim nht",
     ],
+    "pim6d": [
+        "debug pimv6 events",
+        "debug pimv6 packets",
+        "debug pimv6 packet-dump send",
+        "debug pimv6 packet-dump receive",
+        "debug pimv6 trace",
+        "debug pimv6 trace detail",
+        "debug pimv6 zebra",
+        "debug pimv6 bsm",
+        "debug pimv6 packets hello",
+        "debug pimv6 packets joins",
+        "debug pimv6 packets register",
+        "debug pimv6 nht",
+        "debug pimv6 nht detail",
+        "debug mroute6",
+        "debug mroute6 detail",
+        "debug mld events",
+        "debug mld packets",
+        "debug mld trace",
+    ],
     "bgpd": [
         "debug bgp neighbor-events",
         "debug bgp updates",
@@ -961,7 +981,7 @@ def generate_support_bundle():
     return True
 
 
-def start_topology(tgen, daemon=None):
+def start_topology(tgen):
     """
     Starting topology, create tmp files which are loaded to routers
     to start daemons and then start routers
@@ -1009,38 +1029,70 @@ def start_topology(tgen, daemon=None):
         except IOError as err:
             logger.error("I/O error({0}): {1}".format(err.errno, err.strerror))
 
-        # Loading empty zebra.conf file to router, to start the zebra daemon
+        topo = tgen.json_topo
+        feature = set()
+
+        if "feature" in topo:
+            feature.update(topo["feature"])
+
+        if rname in topo["routers"]:
+            for key in topo["routers"][rname].keys():
+                feature.add(key)
+
+            for val in topo["routers"][rname]["links"].values():
+                if "pim" in val:
+                    feature.add("pim")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "pim6" in val:
+                    feature.add("pim6")
+                    break
+            for val in topo["routers"][rname]["links"].values():
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+        if "switches" in topo and rname in topo["switches"]:
+            for val in topo["switches"][rname]["links"].values():
+                if "ospf" in val:
+                    feature.add("ospf")
+                    break
+                if "ospf6" in val:
+                    feature.add("ospf6")
+                    break
+
+        # Loading empty zebra.conf file to router, to start the zebra deamon
         router.load_config(
             TopoRouter.RD_ZEBRA, "{}/{}/zebra.conf".format(tgen.logdir, rname)
         )
 
-        # Loading empty bgpd.conf file to router, to start the bgp daemon
-        router.load_config(
-            TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
-        )
+        # Loading empty bgpd.conf file to router, to start the bgp deamon
+        if "bgp" in feature:
+            router.load_config(
+                TopoRouter.RD_BGP, "{}/{}/bgpd.conf".format(tgen.logdir, rname)
+            )
 
-        if daemon and "ospfd" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "ospf6d" in daemon:
-            # Loading empty ospf.conf file to router, to start the bgp daemon
+        # Loading empty pimd.conf file to router, to start the pim deamon
+        if "pim6" in feature:
             router.load_config(
-                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pimd" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim deamon
+        if "ospf" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM, "{}/{}/pimd.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF, "{}/{}/ospfd.conf".format(tgen.logdir, rname)
             )
 
-        if daemon and "pim6d" in daemon:
-            # Loading empty pimd.conf file to router, to start the pim6d deamon
+        if "ospf6" in feature:
+            # Loading empty ospf.conf file to router, to start the ospf deamon
             router.load_config(
-                TopoRouter.RD_PIM6, "{}/{}/pim6d.conf".format(tgen.logdir, rname)
+                TopoRouter.RD_OSPF6, "{}/{}/ospf6d.conf".format(tgen.logdir, rname)
             )
 
     # Starting routers
@@ -3244,33 +3296,29 @@ def configure_interface_mac(tgen, input_
     return True
 
 
-def socat_send_igmp_join_traffic(
+def socat_send_mld_join(
     tgen,
     server,
     protocol_option,
-    igmp_groups,
+    mld_groups,
     send_from_intf,
     send_from_intf_ip=None,
     port=12345,
     reuseaddr=True,
-    join=False,
-    traffic=False,
 ):
     """
-    API to send IGMP join using SOCAT tool
+    API to send MLD join using SOCAT tool
 
     Parameters:
     -----------
     * `tgen`  : Topogen object
     * `server`: iperf server, from where IGMP join would be sent
     * `protocol_option`: Protocol options, ex: UDP6-RECV
-    * `igmp_groups`: IGMP group for which join has to be sent
+    * `mld_groups`: IGMP group for which join has to be sent
     * `send_from_intf`: Interface from which join would be sent
     * `send_from_intf_ip`: Interface IP, default is None
     * `port`: Port to be used, default is 12345
     * `reuseaddr`: True|False, bydefault True
-    * `join`: If join needs to be sent
-    * `traffic`: If traffic needs to be sent
 
     returns:
     --------
@@ -3280,36 +3328,32 @@ def socat_send_igmp_join_traffic(
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     rnode = tgen.routers()[server]
-    socat_cmd = "socat -u "
+    socat_args = "socat -u "
 
-    # UDP4/TCP4/UDP6/UDP6-RECV
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
     if protocol_option:
-        socat_cmd += "{}".format(protocol_option)
+        socat_args += "{}".format(protocol_option)
 
     if port:
-        socat_cmd += ":{},".format(port)
+        socat_args += ":{},".format(port)
 
     if reuseaddr:
-        socat_cmd += "{},".format("reuseaddr")
+        socat_args += "{},".format("reuseaddr")
 
     # Group address range to cover
-    if igmp_groups:
-        if not isinstance(igmp_groups, list):
-            igmp_groups = [igmp_groups]
-
-    for igmp_group in igmp_groups:
-        if join:
-            join_traffic_option = "ipv6-join-group"
-        elif traffic:
-            join_traffic_option = "ipv6-join-group-source"
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        join_option = "ipv6-join-group"
 
         if send_from_intf and not send_from_intf_ip:
-            socat_cmd += "{}='[{}]:{}'".format(
-                join_traffic_option, igmp_group, send_from_intf
-            )
+            socat_cmd += "{}='[{}]:{}'".format(join_option, mld_group, send_from_intf)
         else:
             socat_cmd += "{}='[{}]:{}:[{}]'".format(
-                join_traffic_option, igmp_group, send_from_intf, send_from_intf_ip
+                join_option, mld_group, send_from_intf, send_from_intf_ip
             )
 
         socat_cmd += " STDOUT"
@@ -3324,6 +3368,124 @@ def socat_send_igmp_join_traffic(
     return True
 
 
+def socat_send_pim6_traffic(
+    tgen,
+    server,
+    protocol_option,
+    mld_groups,
+    send_from_intf,
+    port=12345,
+    multicast_hops=True,
+):
+    """
+    API to send pim6 data taffic using SOCAT tool
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `server`: iperf server, from where IGMP join would be sent
+    * `protocol_option`: Protocol options, ex: UDP6-RECV
+    * `mld_groups`: MLD group for which join has to be sent
+    * `send_from_intf`: Interface from which join would be sent
+    * `port`: Port to be used, default is 12345
+    * `multicast_hops`: multicast-hops count, default is 255
+
+    returns:
+    --------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[server]
+    socat_args = "socat -u STDIO "
+
+    # UDP4/TCP4/UDP6/UDP6-RECV/UDP6-SEND
+    if protocol_option:
+        socat_args += "'{}".format(protocol_option)
+
+    # Group address range to cover
+    if mld_groups:
+        if not isinstance(mld_groups, list):
+            mld_groups = [mld_groups]
+
+    for mld_group in mld_groups:
+        socat_cmd = socat_args
+        if port:
+            socat_cmd += ":[{}]:{},".format(mld_group, port)
+
+        if send_from_intf:
+            socat_cmd += "interface={0},so-bindtodevice={0},".format(send_from_intf)
+
+        if multicast_hops:
+            socat_cmd += "multicast-hops=255'"
+
+        socat_cmd += " &>{}/socat.logs &".format(tgen.logdir)
+
+        # Run socat command to send pim6 traffic
+        logger.info(
+            "[DUT: {}]: Running command: [set +m; ( while sleep 1; do date; done ) | {}]".format(
+                server, socat_cmd
+            )
+        )
+
+        # Open a shell script file and write data to it, which will be
+        # used to send pim6 traffic continously
+        traffic_shell_script = "{}/{}/traffic.sh".format(tgen.logdir, server)
+        with open("{}".format(traffic_shell_script), "w") as taffic_sh:
+            taffic_sh.write(
+                "#!/usr/bin/env bash\n( while sleep 1; do date; done ) | {}\n".format(
+                    socat_cmd
+                )
+            )
+
+        rnode.run("chmod 755 {}".format(traffic_shell_script))
+        output = rnode.run("{} &> /dev/null".format(traffic_shell_script))
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def kill_socat(tgen, dut=None, action=None):
+    """
+    Killing socat process if running for any router in topology
+
+    Parameters:
+    -----------
+    * `tgen`  : Topogen object
+    * `dut`   : Any iperf hostname to send igmp prune
+    * `action`: to kill mld join using socat
+                to kill mld traffic using socat
+
+    Usage:
+    ------
+    kill_socat(tgen, dut ="i6", action="remove_mld_join")
+
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        if action == "remove_mld_join":
+            cmd = "ps -ef | grep socat | grep UDP6-RECV | grep {}".format(router)
+        elif action == "remove_mld_traffic":
+            cmd = "ps -ef | grep socat | grep UDP6-SEND | grep {}".format(router)
+        else:
+            cmd = "ps -ef | grep socat".format(router)
+
+        awk_cmd = "awk -F' ' '{print $2}' | xargs kill -9 &>/dev/null &"
+        cmd = "{} | {}".format(cmd, awk_cmd)
+
+        logger.debug("[DUT: {}]: Running command: [{}]".format(router, cmd))
+        rnode.run(cmd)
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+
 #############################################
 # Verification APIs
 #############################################
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/lutil.py frr-frr-8.5/tests/topotests/ospfapi/lib/lutil.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/lutil.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/lutil.py	2023-03-13 20:01:47.000000000 +0600
@@ -50,6 +50,7 @@ class lUtil:
     l_line = 0
     l_dotall_experiment = False
     l_last_nl = None
+    l_wait_strict = 1
 
     fout = ""
     fsum = ""
@@ -189,7 +190,7 @@ Total %-4d
             self.log("unable to read: " + tstFile)
             sys.exit(1)
 
-    def command(self, target, command, regexp, op, result, returnJson, startt=None):
+    def command(self, target, command, regexp, op, result, returnJson, startt=None, force_result=False):
         global net
         if op == "jsoncmp_pass" or op == "jsoncmp_fail":
             returnJson = True
@@ -292,7 +293,7 @@ Total %-4d
                     9,
                 )
         if startt != None:
-            if js != None or ret is not False:
+            if js != None or ret is not False or force_result is not False:
                 delta = time.time() - startt
                 self.result(target, success, "%s +%4.2f secs" % (result, delta))
         elif op == "pass" or op == "fail":
@@ -322,12 +323,23 @@ Total %-4d
         n = 0
         startt = time.time()
 
+        if (op == "wait-strict") or ((op == "wait") and self.l_wait_strict):
+            strict = True
+        else:
+            strict = False
+
         # Calculate the amount of `sleep`s we are going to peform.
         wait_count = int(math.ceil(wait / wait_time)) + 1
 
+        force_result = False
         while wait_count > 0:
             n += 1
-            found = self.command(target, command, regexp, op, result, returnJson, startt)
+
+            # log a failure on last iteration if we don't get desired regexp
+            if strict and (wait_count == 1):
+                force_result = True
+
+            found = self.command(target, command, regexp, op, result, returnJson, startt, force_result)
             if found is not False:
                 break
 
@@ -378,12 +390,14 @@ def luCommand(
     returnJson=False,
     wait_time=0.5,
 ):
-    if op != "wait":
-        return LUtil.command(target, command, regexp, op, result, returnJson)
-    else:
+    waitops = ["wait", "wait-strict", "wait-nostrict"]
+
+    if op in waitops:
         return LUtil.wait(
             target, command, regexp, op, result, time, returnJson, wait_time
         )
+    else:
+        return LUtil.command(target, command, regexp, op, result, returnJson)
 
 
 def luLast(usenl=False):
@@ -454,6 +468,25 @@ def luShowFail():
     if printed > 0:
         logger.error("See %s for details of errors" % LUtil.fout_name)
 
+#
+# Sets default wait type for luCommand(op="wait) (may be overridden by
+# specifying luCommand(op="wait-strict") or luCommand(op="wait-nostrict")).
+#
+# "nostrict" is the historical default behavior, which is to ignore
+# failures to match the specified regexp in the specified time.
+#
+# "strict" means that failure to match the specified regexp in the
+# specified time yields an explicit, logged failure result
+#
+def luSetWaitType(waittype):
+    if waittype == "strict":
+        LUtil.l_wait_strict = 1
+    else:
+        if waittype == "nostrict":
+            LUtil.l_wait_strict = 0
+        else:
+            raise ValueError('waittype must be one of "strict" or "nostrict"')
+
 
 # for testing
 if __name__ == "__main__":
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/micronet.py frr-frr-8.5/tests/topotests/ospfapi/lib/micronet.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/micronet.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/micronet.py	2023-03-13 20:01:47.000000000 +0600
@@ -470,7 +470,8 @@ class LinuxNamespace(Commander):
 
         nslist = []
         cmd = ["/usr/bin/unshare"]
-        flags = "-"
+        flags = ""
+        self.a_flags = []
         self.ifnetns = {}
 
         if cgroup:
@@ -487,6 +488,7 @@ class LinuxNamespace(Commander):
             flags += "n"
         if pid:
             nslist.append("pid")
+            flags += "f"
             flags += "p"
             cmd.append("--mount-proc")
         if time:
@@ -499,9 +501,17 @@ class LinuxNamespace(Commander):
             cmd.append("--keep-caps")
         if uts:
             nslist.append("uts")
-            cmd.append("--uts")
+            flags += "u"
 
-        cmd.append(flags)
+        if flags:
+            aflags = flags.replace("f", "")
+            if aflags:
+                self.a_flags = ["-" + x for x in aflags]
+            cmd.extend(["-" + x for x in flags])
+
+        if pid:
+            cmd.append(commander.get_exec_path("tini"))
+            cmd.append("-vvv")
         cmd.append("/bin/cat")
 
         # Using cat and a stdin PIPE is nice as it will exit when we do. However, we
@@ -516,7 +526,8 @@ class LinuxNamespace(Commander):
             stdin=subprocess.PIPE,
             stdout=open("/dev/null", "w"),
             stderr=open("/dev/null", "w"),
-            preexec_fn=os.setsid,  # detach from pgid so signals don't propogate
+            text=True,
+            start_new_session=True,  # detach from pgid so signals don't propagate
             shell=False,
         )
         self.p = p
@@ -550,7 +561,7 @@ class LinuxNamespace(Commander):
         assert not nslist, "unshare never unshared!"
 
         # Set pre-command based on our namespace proc
-        self.base_pre_cmd = ["/usr/bin/nsenter", "-a", "-t", str(self.pid)]
+        self.base_pre_cmd = ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid)]
         if not pid:
             self.base_pre_cmd.append("-F")
         self.set_pre_cmd(self.base_pre_cmd + ["--wd=" + self.cwd])
@@ -743,7 +754,7 @@ class SharedNamespace(Commander):
     An object that executes commands in an existing pid's linux namespace
     """
 
-    def __init__(self, name, pid, logger=None):
+    def __init__(self, name, pid, aflags=("-a",), logger=None):
         """
         Share a linux namespace.
 
@@ -757,10 +768,11 @@ class SharedNamespace(Commander):
 
         self.pid = pid
         self.intfs = []
+        self.a_flags = aflags
 
         # Set pre-command based on our namespace proc
         self.set_pre_cmd(
-            ["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + self.cwd]
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + self.cwd]
         )
 
     def __str__(self):
@@ -769,7 +781,9 @@ class SharedNamespace(Commander):
     def set_cwd(self, cwd):
         # Set pre-command based on our namespace proc
         self.logger.debug("%s: new CWD %s", self, cwd)
-        self.set_pre_cmd(["/usr/bin/nsenter", "-a", "-t", str(self.pid), "--wd=" + cwd])
+        self.set_pre_cmd(
+            ["/usr/bin/nsenter", *self.a_flags, "-t", str(self.pid), "--wd=" + cwd]
+        )
 
     def register_interface(self, ifname):
         if ifname not in self.intfs:
@@ -800,7 +814,7 @@ class Bridge(SharedNamespace):
             self.brid = "br{}".format(self.brid_ord)
             name = self.brid
 
-        super(Bridge, self).__init__(name, unet.pid, logger)
+        super(Bridge, self).__init__(name, unet.pid, aflags=unet.a_flags, logger=logger)
 
         self.logger.debug("Bridge: Creating")
 
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/ospf.py frr-frr-8.5/tests/topotests/ospfapi/lib/ospf.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/ospf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/ospf.py	2023-03-13 20:01:47.000000000 +0600
@@ -1533,11 +1533,11 @@ def verify_ospf_summary(tgen, topo, dut,
     -----
     input_dict = {
         "11.0.0.0/8": {
-            "Summary address": "11.0.0.0/8",
-            "Metric-type": "E2",
-            "Metric": 20,
-            "Tag": 0,
-            "External route count": 5
+            "summaryAddress": "11.0.0.0/8",
+            "metricType": "E2",
+            "metric": 20,
+            "tag": 0,
+            "externalRouteCount": 5
         }
     }
     result = verify_ospf_summary(tgen, topo, dut, input_dict)
@@ -1586,7 +1586,7 @@ def verify_ospf_summary(tgen, topo, dut,
     for ospf_summ, summ_data in ospf_summary_data.items():
         if ospf_summ not in show_ospf_json:
             continue
-        summary = ospf_summary_data[ospf_summ]["Summary address"]
+        summary = ospf_summary_data[ospf_summ]["summaryAddress"]
 
         if summary in show_ospf_json:
             for summ in summ_data:
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/pim.py frr-frr-8.5/tests/topotests/ospfapi/lib/pim.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/pim.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/pim.py	2023-03-13 20:01:47.000000000 +0600
@@ -37,6 +37,7 @@ from lib.common_config import (
     retry,
     run_frr_cmd,
     validate_ip_address,
+    get_frr_ipv6_linklocal,
 )
 from lib.micronet import get_exec_path
 from lib.topolog import logger
@@ -48,7 +49,7 @@ CWD = os.path.dirname(os.path.realpath(_
 
 def create_pim_config(tgen, topo, input_dict=None, build=False, load_config=True):
     """
-    API to configure pim/pimv6 on router
+    API to configure pim/pim6 on router
 
     Parameters
     ----------
@@ -149,7 +150,7 @@ def _add_pim_rp_config(tgen, topo, input
         if "rp" in input_dict[router]["pim"]:
             rp_data += pim_data["rp"]
 
-    # PIMv6
+    # pim6
     pim6_data = None
     if "pim6" in input_dict[router]:
         pim6_data = input_dict[router]["pim6"]
@@ -370,7 +371,7 @@ def create_igmp_config(tgen, topo, input
 
 def create_mld_config(tgen, topo, input_dict=None, build=False):
     """
-    API to configure mld for PIMv6 on router
+    API to configure mld for pim6 on router
 
     Parameters
     ----------
@@ -515,6 +516,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ip pim")
 
+        if "pim" in input_dict[router]:
+            if "disable" in input_dict[router]["pim"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ip pim")
+
         if "pim6" in data and data["pim6"] == "enable":
             # Loopback interfaces
             if "type" in data and data["type"] == "loopback":
@@ -526,6 +540,19 @@ def _enable_disable_pim_config(tgen, top
             config_data.append(cmd)
             config_data.append("ipv6 pim")
 
+        if "pim6" in input_dict[router]:
+            if "disable" in input_dict[router]["pim6"]:
+                enable_flag = False
+                interfaces = input_dict[router]["pim6"]["disable"]
+
+                if type(interfaces) is not list:
+                    interfaces = [interfaces]
+
+                for interface in interfaces:
+                    cmd = "interface {}".format(interface)
+                    config_data.append(cmd)
+                    config_data.append("no ipv6 pim")
+
     # pim global config
     if "pim" in input_dict[router]:
         pim_data = input_dict[router]["pim"]
@@ -797,6 +824,134 @@ def verify_pim_neighbors(tgen, topo, dut
     return True
 
 
+@retry(retry_timeout=12)
+def verify_pim6_neighbors(tgen, topo, dut=None, iface=None, nbr_ip=None, expected=True):
+    """
+    Verify all pim6 neighbors are up and running, config is verified
+    using "show ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `iface` : link for which PIM nbr need to check
+    * `nbr_ip` : neighbor ip of interface
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_pim6_neighbors(tgen, topo, dut, iface=ens192, nbr_ip=20.1.1.2)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if dut is not None and dut != router:
+            continue
+
+        rnode = tgen.routers()[router]
+        show_ip_pim_neighbor_json = rnode.vtysh_cmd(
+            "show ipv6 pim neighbor json", isjson=True
+        )
+
+        for destLink, data in topo["routers"][router]["links"].items():
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if iface is not None and iface != data["interface"]:
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            if "pim6" in data and data["pim6"] == "disable":
+                continue
+
+            if "pim6" in data and data["pim6"] == "enable":
+                local_interface = data["interface"]
+
+            if "-" in destLink:
+                # Spliting and storing destRouterLink data in tempList
+                tempList = destLink.split("-")
+
+                # destRouter
+                destLink = tempList.pop(0)
+
+                # Current Router Link
+                tempList.insert(0, router)
+                curRouter = "-".join(tempList)
+            else:
+                curRouter = router
+            if destLink not in topo["routers"]:
+                continue
+            data = topo["routers"][destLink]["links"][curRouter]
+            peer_interface = data["interface"]
+            if "type" in data and data["type"] == "loopback":
+                continue
+
+            if "pim6" not in data:
+                continue
+
+            logger.info("[DUT: %s]: Verifying PIM neighbor status:", router)
+
+            if "pim6" in data and data["pim6"] == "enable":
+                pim_nh_intf_ip = get_frr_ipv6_linklocal(tgen, destLink, peer_interface)
+
+                # Verifying PIM neighbor
+                if local_interface in show_ip_pim_neighbor_json:
+                    if show_ip_pim_neighbor_json[local_interface]:
+                        if (
+                            show_ip_pim_neighbor_json[local_interface][pim_nh_intf_ip][
+                                "neighbor"
+                            ]
+                            != pim_nh_intf_ip
+                        ):
+                            errormsg = (
+                                "[DUT %s]: Local interface: %s, PIM6"
+                                " neighbor check failed "
+                                "Expected neighbor: %s, Found neighbor:"
+                                " %s"
+                                % (
+                                    router,
+                                    local_interface,
+                                    pim_nh_intf_ip,
+                                    show_ip_pim_neighbor_json[local_interface][
+                                        pim_nh_intf_ip
+                                    ]["neighbor"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: Local interface: %s, Found"
+                            " expected PIM6 neighbor %s",
+                            router,
+                            local_interface,
+                            pim_nh_intf_ip,
+                        )
+                    else:
+                        errormsg = (
+                            "[DUT %s]: Local interface: %s, and"
+                            "interface ip: %s is not found in "
+                            "PIM6 neighbor " % (router, local_interface, pim_nh_intf_ip)
+                        )
+                        return errormsg
+                else:
+                    errormsg = (
+                        "[DUT %s]: Local interface: %s, is not "
+                        "present in PIM6 neighbor " % (router, local_interface)
+                    )
+                    return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_igmp_groups(tgen, dut, interface, group_addresses, expected=True):
     """
@@ -871,7 +1026,7 @@ def verify_igmp_groups(tgen, dut, interf
     return True
 
 
-@retry(retry_timeout=60, diag_pct=0)
+@retry(retry_timeout=60, diag_pct=2)
 def verify_upstream_iif(
     tgen,
     dut,
@@ -879,7 +1034,9 @@ def verify_upstream_iif(
     src_address,
     group_addresses,
     joinState=None,
+    regState=None,
     refCount=1,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -910,7 +1067,6 @@ def verify_upstream_iif(
     -------
     errormsg(str) or True
     """
-
     logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
 
     if dut not in tgen.routers():
@@ -919,7 +1075,8 @@ def verify_upstream_iif(
     rnode = tgen.routers()[dut]
 
     logger.info(
-        "[DUT: %s]: Verifying upstream Inbound Interface" " for IGMP groups received:",
+        "[DUT: %s]: Verifying upstream Inbound Interface"
+        " for IGMP/MLD groups received:",
         dut,
     )
 
@@ -979,16 +1136,18 @@ def verify_upstream_iif(
                         if group_addr_json[src_address]["joinState"] != "Joined":
                             errormsg = (
                                 "[DUT %s]: Verifying iif "
-                                "(Inbound Interface) for (%s,%s) and"
-                                " joinState :%s [FAILED]!! "
-                                " Expected: %s, Found: %s"
+                                "(Inbound Interface) and joinState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "joinState :%s , Found joinState: %s"
                                 % (
                                     dut,
                                     src_address,
                                     grp_addr,
-                                    group_addr_json[src_address]["joinState"],
                                     in_interface,
                                     group_addr_json[src_address]["inboundInterface"],
+                                    joinState,
+                                    group_addr_json[src_address]["joinState"],
                                 )
                             )
                             return errormsg
@@ -996,28 +1155,51 @@ def verify_upstream_iif(
                     elif group_addr_json[src_address]["joinState"] != joinState:
                         errormsg = (
                             "[DUT %s]: Verifying iif "
-                            "(Inbound Interface) for (%s,%s) and"
-                            " joinState :%s [FAILED]!! "
-                            " Expected: %s, Found: %s"
+                            "(Inbound Interface) and joinState "
+                            "for (%s, %s), Expected iif: %s, "
+                            "Found iif : %s,  and Expected "
+                            "joinState :%s , Found joinState: %s"
                             % (
                                 dut,
                                 src_address,
                                 grp_addr,
-                                group_addr_json[src_address]["joinState"],
                                 in_interface,
                                 group_addr_json[src_address]["inboundInterface"],
+                                joinState,
+                                group_addr_json[src_address]["joinState"],
                             )
                         )
                         return errormsg
 
+                    if regState:
+                        if group_addr_json[src_address]["regState"] != regState:
+                            errormsg = (
+                                "[DUT %s]: Verifying iif "
+                                "(Inbound Interface) and regState "
+                                "for (%s, %s), Expected iif: %s, "
+                                "Found iif : %s,  and Expected "
+                                "regState :%s , Found regState: %s"
+                                % (
+                                    dut,
+                                    src_address,
+                                    grp_addr,
+                                    in_interface,
+                                    group_addr_json[src_address]["inboundInterface"],
+                                    regState,
+                                    group_addr_json[src_address]["regState"],
+                                )
+                            )
+                            return errormsg
+
                     logger.info(
                         "[DUT %s]: Verifying iif(Inbound Interface)"
-                        " for (%s,%s) and joinState is %s [PASSED]!! "
+                        " for (%s,%s) and joinState is %s regstate is %s [PASSED]!! "
                         " Found Expected: (%s)",
                         dut,
                         src_address,
                         grp_addr,
                         group_addr_json[src_address]["joinState"],
+                        group_addr_json[src_address]["regState"],
                         group_addr_json[src_address]["inboundInterface"],
                     )
         if not found:
@@ -1036,13 +1218,13 @@ def verify_upstream_iif(
             )
             return errormsg
 
-        logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
-        return True
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
 
 
 @retry(retry_timeout=12)
 def verify_join_state_and_timer(
-    tgen, dut, iif, src_address, group_addresses, expected=True
+    tgen, dut, iif, src_address, group_addresses, addr_type="ipv4", expected=True
 ):
     """
     Verify  join state is updated correctly and join timer is
@@ -1178,6 +1360,7 @@ def verify_mroutes(
     oil,
     return_uptime=False,
     mwait=0,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1393,6 +1576,7 @@ def verify_pim_rp_info(
     rp=None,
     source=None,
     iamrp=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1578,6 +1762,7 @@ def verify_pim_state(
     group_addresses,
     src_address=None,
     installed_fl=None,
+    addr_type="ipv4",
     expected=True,
 ):
     """
@@ -1642,12 +1827,12 @@ def verify_pim_state(
         else:
             pim_state_json = show_pim_state_json[grp_addr][src_address]
 
-        if pim_state_json["Installed"] == installed_fl:
+        if pim_state_json["installed"] == installed_fl:
             logger.info(
                 "[DUT %s]: group  %s is installed flag: %s",
                 dut,
                 grp_addr,
-                pim_state_json["Installed"],
+                pim_state_json["installed"],
             )
             for interface, data in pim_state_json[iif].items():
                 if interface != oil:
@@ -1697,7 +1882,7 @@ def verify_pim_state(
 
 def get_pim_interface_traffic(tgen, input_dict):
     """
-    get ip pim interface traffice by running
+    get ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -1768,9 +1953,82 @@ def get_pim_interface_traffic(tgen, inpu
     return output_dict
 
 
+def get_pim6_interface_traffic(tgen, input_dict):
+    """
+    get ipv6 pim interface traffic by running
+    "show ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict(dict)`: defines DUT, what and from which interfaces
+                          traffic needs to be retrieved
+    Usage
+    -----
+    input_dict = {
+        "r1": {
+            "r1-r0-eth0": {
+                "helloRx": 0,
+                "helloTx": 1,
+                "joinRx": 0,
+                "joinTx": 0
+            }
+        }
+    }
+
+    result = get_pim_interface_traffic(tgen, input_dict)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    output_dict = {}
+    for dut in input_dict.keys():
+        if dut not in tgen.routers():
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Verifying pim interface traffic", dut)
+
+        def show_pim_intf_traffic(rnode, dut, input_dict, output_dict):
+            show_pim_intf_traffic_json = run_frr_cmd(
+                rnode, "show ipv6 pim interface traffic json", isjson=True
+            )
+
+            output_dict[dut] = {}
+            for intf, data in input_dict[dut].items():
+                interface_json = show_pim_intf_traffic_json[intf]
+                for state in data:
+
+                    # Verify Tx/Rx
+                    if state in interface_json:
+                        output_dict[dut][state] = interface_json[state]
+                    else:
+                        errormsg = (
+                            "[DUT %s]: %s is not present"
+                            "for interface %s [FAILED]!! " % (dut, state, intf)
+                        )
+                        return errormsg
+            return None
+
+        test_func = functools.partial(
+            show_pim_intf_traffic, rnode, dut, input_dict, output_dict
+        )
+        (result, out) = topotest.run_and_expect(test_func, None, count=20, wait=1)
+        if not result:
+            return out
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return output_dict
+
+
 @retry(retry_timeout=40, diag_pct=0)
 def verify_pim_interface(
-    tgen, topo, dut, interface=None, interface_ip=None, expected=True
+    tgen, topo, dut, interface=None, interface_ip=None, addr_type="ipv4", expected=True
 ):
     """
     Verify all PIM interface are up and running, config is verified
@@ -1803,29 +2061,48 @@ def verify_pim_interface(
         logger.info("[DUT: %s]: Verifying PIM interface status:", dut)
 
         rnode = tgen.routers()[dut]
-        show_ip_pim_interface_json = rnode.vtysh_cmd(
-            "show ip pim interface json", isjson=True
+
+        if addr_type == "ipv4":
+            addr_cmd = "ip"
+            pim_cmd = "pim"
+        elif addr_type == "ipv6":
+            addr_cmd = "ipv6"
+            pim_cmd = "pim6"
+        show_pim_interface_json = rnode.vtysh_cmd(
+            "show {} pim interface json".format(addr_cmd), isjson=True
         )
 
-        logger.info("show_ip_pim_interface_json: \n %s", show_ip_pim_interface_json)
+        logger.info("show_pim_interface_json: \n %s", show_pim_interface_json)
 
         if interface_ip:
-            if interface in show_ip_pim_interface_json:
-                pim_intf_json = show_ip_pim_interface_json[interface]
+            if interface in show_pim_interface_json:
+                pim_intf_json = show_pim_interface_json[interface]
                 if pim_intf_json["address"] != interface_ip:
                     errormsg = (
-                        "[DUT %s]: PIM interface "
-                        "ip is not correct "
+                        "[DUT %s]: %s interface "
+                        "%s is not correct "
                         "[FAILED]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return errormsg
                 else:
                     logger.info(
-                        "[DUT %s]: PIM interface "
-                        "ip is correct "
+                        "[DUT %s]: %s interface "
+                        "%s is correct "
                         "[Passed]!! Expected : %s, Found : %s"
-                        % (dut, pim_intf_json["address"], interface_ip)
+                        % (
+                            dut,
+                            pim_cmd,
+                            addr_cmd,
+                            pim_intf_json["address"],
+                            interface_ip,
+                        )
                     )
                     return True
         else:
@@ -1833,17 +2110,17 @@ def verify_pim_interface(
                 if "type" in data and data["type"] == "loopback":
                     continue
 
-                if "pim" in data and data["pim"] == "enable":
+                if pim_cmd in data and data[pim_cmd] == "enable":
                     pim_interface = data["interface"]
-                    pim_intf_ip = data["ipv4"].split("/")[0]
+                    pim_intf_ip = data[addr_type].split("/")[0]
 
-                    if pim_interface in show_ip_pim_interface_json:
-                        pim_intf_json = show_ip_pim_interface_json[pim_interface]
+                    if pim_interface in show_pim_interface_json:
+                        pim_intf_json = show_pim_interface_json[pim_interface]
                     else:
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, not Found"
-                            % (dut, pim_interface, pim_intf_ip)
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, not Found"
+                            % (dut, pim_cmd, pim_interface, addr_cmd, pim_intf_ip)
                         )
                         return errormsg
 
@@ -1853,12 +2130,14 @@ def verify_pim_interface(
                         and pim_intf_json["state"] != "up"
                     ):
                         errormsg = (
-                            "[DUT %s]: PIM interface: %s "
-                            "PIM interface ip: %s, status check "
+                            "[DUT %s]: %s interface: %s "
+                            "PIM interface %s: %s, status check "
                             "[FAILED]!! Expected : %s, Found : %s"
                             % (
                                 dut,
+                                pim_cmd,
                                 pim_interface,
+                                addr_cmd,
                                 pim_intf_ip,
                                 pim_interface,
                                 pim_intf_json["state"],
@@ -1867,11 +2146,13 @@ def verify_pim_interface(
                         return errormsg
 
                     logger.info(
-                        "[DUT %s]: PIM interface: %s, "
-                        "interface ip: %s, status: %s"
+                        "[DUT %s]: %s interface: %s, "
+                        "interface %s: %s, status: %s"
                         " [PASSED]!!",
                         dut,
+                        pim_cmd,
                         pim_interface,
+                        addr_cmd,
                         pim_intf_ip,
                         pim_intf_json["state"],
                     )
@@ -1882,8 +2163,8 @@ def verify_pim_interface(
 
 def clear_pim_interface_traffic(tgen, topo):
     """
-    Clear ip/ipv6 pim interface traffice by running
-    "clear ip/ipv6 pim interface traffic" cli
+    Clear ip pim interface traffic by running
+    "clear ip pim interface traffic" cli
 
     Parameters
     ----------
@@ -1914,6 +2195,74 @@ def clear_pim_interface_traffic(tgen, to
     return True
 
 
+def clear_pim6_interface_traffic(tgen, topo):
+    """
+    Clear ipv6 pim interface traffic by running
+    "clear ipv6 pim interface traffic" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interface_traffic(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interface traffic", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface traffic")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
+def clear_pim6_interfaces(tgen, topo):
+    """
+    Clear ipv6 pim interface by running
+    "clear ipv6 pim interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    Usage
+    -----
+
+    result = clear_pim6_interfaces(tgen, topo)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in tgen.routers():
+        if "pim" not in topo["routers"][dut]:
+            continue
+
+        rnode = tgen.routers()[dut]
+
+        logger.info("[DUT: %s]: Clearing pim6 interfaces", dut)
+        result = run_frr_cmd(rnode, "clear ipv6 pim interface")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def clear_pim_interfaces(tgen, dut):
     """
     Clear ip/ipv6 pim interface by running
@@ -1961,8 +2310,8 @@ def clear_pim_interfaces(tgen, dut):
     # Waiting for maximum 60 sec
     fail_intf = []
     for retry in range(1, 13):
-        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         sleep(5)
+        logger.info("[DUT: %s]: Waiting for 5 sec for PIM neighbors" " to come up", dut)
         run_json_after = run_frr_cmd(rnode, "show ip pim neighbor json", isjson=True)
         found = True
         for pim_intf in nh_before_clear.keys():
@@ -2212,6 +2561,35 @@ def clear_mroute(tgen, dut=None):
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
 
 
+def clear_pim6_mroute(tgen, dut=None):
+    """
+    Clear ipv6 mroute by running "clear ipv6 mroute" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test, default None
+
+    Usage
+    -----
+    clear_mroute(tgen, dut)
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    router_list = tgen.routers()
+    for router, rnode in router_list.items():
+        if dut is not None and router != dut:
+            continue
+
+        logger.debug("[DUT: %s]: Clearing ipv6 mroute", router)
+        rnode.vtysh_cmd("clear ipv6 mroute")
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+
+    return True
+
+
 def reconfig_interfaces(tgen, topo, senderRouter, receiverRouter, packet=None):
     """
     Configure interface ip for sender and receiver routers
@@ -2812,7 +3190,14 @@ def enable_disable_pim_bsm(tgen, router,
 
 @retry(retry_timeout=60, diag_pct=0)
 def verify_pim_join(
-    tgen, topo, dut, interface, group_addresses, src_address=None, expected=True
+    tgen,
+    topo,
+    dut,
+    interface,
+    group_addresses,
+    src_address=None,
+    addr_type="ipv4",
+    expected=True,
 ):
     """
     Verify ip/ipv6 pim join by running "show ip/ipv6 pim join" cli
@@ -2846,11 +3231,22 @@ def verify_pim_join(
     rnode = tgen.routers()[dut]
 
     logger.info("[DUT: %s]: Verifying pim join", dut)
-    show_pim_join_json = run_frr_cmd(rnode, "show ip pim join json", isjson=True)
 
     if type(group_addresses) is not list:
         group_addresses = [group_addresses]
 
+    for grp in group_addresses:
+        addr_type = validate_ip_address(grp)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    show_pim_join_json = run_frr_cmd(
+        rnode, "show {} pim join json".format(ip_cmd), isjson=True
+    )
+
     for grp_addr in group_addresses:
         # Verify if IGMP is enabled in DUT
         if "igmp" not in topo["routers"][dut]:
@@ -3660,7 +4056,7 @@ def verify_multicast_flag_state(
 
 
 @retry(retry_timeout=40, diag_pct=0)
-def verify_igmp_interface(tgen, topo, dut, igmp_iface, interface_ip, expected=True):
+def verify_igmp_interface(tgen, dut, igmp_iface, interface_ip, expected=True):
     """
     Verify all IGMP interface are up and running, config is verified
     using "show ip igmp interface" cli
@@ -3884,7 +4280,7 @@ def verify_local_igmp_groups(tgen, dut,
 
 def verify_pim_interface_traffic(tgen, input_dict, return_stats=True, addr_type="ipv4"):
     """
-    Verify ip pim interface traffice by running
+    Verify ip pim interface traffic by running
     "show ip pim interface traffic" cli
 
     Parameters
@@ -3950,6 +4346,661 @@ def verify_pim_interface_traffic(tgen, i
     logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
     return True if return_stats == False else output_dict
 
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_groups(tgen, dut, interface, group_addresses, expected=True):
+    """
+    Verify IGMP groups are received from an intended interface
+    by running "show ip mld groups" command
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `interface`: interface, from which MLD groups would be received
+    * `group_addresses`: MLD group address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    dut = "r1"
+    interface = "r1-r0-eth0"
+    group_address = "ffaa::1"
+    result = verify_mld_groups(tgen, dut, interface, group_address)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mld groups received:", dut)
+    show_mld_json = run_frr_cmd(rnode, "show ipv6 mld groups json", isjson=True)
+
+    if type(group_addresses) is not list:
+        group_addresses = [group_addresses]
+
+    if interface in show_mld_json:
+        show_mld_json = show_mld_json[interface]["groups"]
+    else:
+        errormsg = (
+            "[DUT %s]: Verifying MLD group received"
+            " from interface %s [FAILED]!! " % (dut, interface)
+        )
+        return errormsg
+
+    found = False
+    for grp_addr in group_addresses:
+        for index in show_mld_json:
+            if index["group"] == grp_addr:
+                found = True
+                break
+        if found is not True:
+            errormsg = (
+                "[DUT %s]: Verifying MLD group received"
+                " from interface %s [FAILED]!! "
+                " Expected not found: %s" % (dut, interface, grp_addr)
+            )
+            return errormsg
+
+        logger.info(
+            "[DUT %s]: Verifying MLD group %s received "
+            "from interface %s [PASSED]!! ",
+            dut,
+            grp_addr,
+            interface,
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=40, diag_pct=0)
+def verify_mld_interface(tgen, dut, mld_iface, interface_ip, expected=True):
+    """
+    Verify all IGMP interface are up and running, config is verified
+    using "show ip mld interface" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : device under test
+    * `mld_iface` : interface name
+    * `interface_ip` : interface ip address
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    result = verify_mld_interface(tgen, topo, dut, mld_iface, interface_ip)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for router in tgen.routers():
+        if router != dut:
+            continue
+
+        logger.info("[DUT: %s]: Verifying MLD interface status:", dut)
+
+        rnode = tgen.routers()[dut]
+        show_mld_interface_json = run_frr_cmd(
+            rnode, "show ipv6 mld interface json", isjson=True
+        )
+
+        if mld_iface in show_mld_interface_json:
+            mld_intf_json = show_mld_interface_json[mld_iface]
+            # Verifying igmp interface
+            if mld_intf_json["address"] != interface_ip:
+                errormsg = (
+                    "[DUT %s]: igmp interface ip is not correct "
+                    "[FAILED]!! Expected : %s, Found : %s"
+                    % (dut, mld_intf_json["address"], interface_ip)
+                )
+                return errormsg
+
+            logger.info(
+                "[DUT %s]: igmp interface: %s, " "interface ip: %s" " [PASSED]!!",
+                dut,
+                mld_iface,
+                interface_ip,
+            )
+        else:
+            errormsg = (
+                "[DUT %s]: igmp interface: %s "
+                "igmp interface ip: %s, is not present "
+                % (dut, mld_iface, interface_ip)
+            )
+            return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mld_config(tgen, input_dict, stats_return=False, expected=True):
+    """
+    Verify mld interface details, verifying following configs:
+    timerQueryInterval
+    timerQueryResponseIntervalMsec
+    lastMemberQueryCount
+    timerLastMemberQueryMsec
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `input_dict` : Input dict data, required to verify
+                     timer
+    * `stats_return`: If user wants API to return statistics
+    * `expected` : expected results from API, by-default True
+
+    Usage
+    -----
+    input_dict ={
+        "l1": {
+            "mld": {
+                "interfaces": {
+                    "l1-i1-eth1": {
+                        "mld": {
+                            "query": {
+                                "query-interval" : 200,
+                                "query-max-response-time" : 100
+                            },
+                            "statistics": {
+                                "queryV2" : 2,
+                                "reportV2" : 1
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    result = verify_mld_config(tgen, input_dict, stats_return)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    for dut in input_dict.keys():
+        rnode = tgen.routers()[dut]
+
+        for interface, data in input_dict[dut]["igmp"]["interfaces"].items():
+
+            statistics = False
+            report = False
+            if "statistics" in input_dict[dut]["igmp"]["interfaces"][interface]["igmp"]:
+                statistics = True
+                cmd = "show ipv6 mld statistics"
+            else:
+                cmd = "show ipv6 mld"
+
+            logger.info("[DUT: %s]: Verifying MLD interface %s detail:", dut, interface)
+
+            if statistics:
+                if (
+                    "report"
+                    in input_dict[dut]["mld"]["interfaces"][interface]["mld"][
+                        "statistics"
+                    ]
+                ):
+                    report = True
+
+            if statistics and report:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} json".format(cmd), isjson=True
+                )
+                intf_detail_json = show_ipv6_mld_intf_json["global"]
+            else:
+                show_ipv6_mld_intf_json = run_frr_cmd(
+                    rnode, "{} interface {} json".format(cmd, interface), isjson=True
+                )
+
+            if not report:
+                if interface not in show_ipv6_mld_intf_json:
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " is not present in CLI output "
+                        "[FAILED]!! " % (dut, interface)
+                    )
+                    return errormsg
+
+                else:
+                    intf_detail_json = show_ipv6_mld_intf_json[interface]
+
+            if stats_return:
+                mld_stats = {}
+
+            if "statistics" in data["mld"]:
+                if stats_return:
+                    mld_stats["statistics"] = {}
+                for query, value in data["mld"]["statistics"].items():
+                    if query == "queryV1":
+                        # Verifying IGMP interface queryV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json["queryV1"]
+
+                        else:
+                            if intf_detail_json["queryV1"] != value:
+                                errormsg = (
+                                    "[DUT %s]: MLD interface: %s "
+                                    " queryV1 statistics verification "
+                                    "[FAILED]!! Expected : %s,"
+                                    " Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                        intf_detail_json["queryV1"],
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD interface: %s "
+                                "queryV1 statistics is %s",
+                                dut,
+                                interface,
+                                value,
+                            )
+
+                    if query == "reportV1":
+                        # Verifying IGMP interface timerV2 statistics
+                        if stats_return:
+                            mld_stats["statistics"][query] = intf_detail_json[
+                                "reportV1"
+                            ]
+
+                        else:
+                            if intf_detail_json["reportV1"] <= value:
+                                errormsg = (
+                                    "[DUT %s]: MLD reportV1 "
+                                    "statistics verification "
+                                    "[FAILED]!! Expected : %s "
+                                    "or more, Found : %s"
+                                    % (
+                                        dut,
+                                        interface,
+                                        value,
+                                    )
+                                )
+                                return errormsg
+
+                            logger.info(
+                                "[DUT %s]: MLD reportV1 " "statistics is %s",
+                                dut,
+                                intf_detail_json["reportV1"],
+                            )
+
+            if "query" in data["mld"]:
+                for query, value in data["mld"]["query"].items():
+                    if query == "query-interval":
+                        # Verifying IGMP interface query interval timer
+                        if intf_detail_json["timerQueryInterval"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                " query-interval verification "
+                                "[FAILED]!! Expected : %s,"
+                                " Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["timerQueryInterval"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s " "query-interval is %s",
+                            dut,
+                            interface,
+                            value,
+                        )
+
+                    if query == "query-max-response-time":
+                        # Verifying IGMP interface query max response timer
+                        if (
+                            intf_detail_json["timerQueryResponseIntervalMsec"]
+                            != value * 100
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "query-max-response-time "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerQueryResponseIntervalMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "query-max-response-time is %s ms",
+                            dut,
+                            interface,
+                            value * 100,
+                        )
+
+                    if query == "last-member-query-count":
+                        # Verifying IGMP interface last member query count
+                        if intf_detail_json["lastMemberQueryCount"] != value:
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-count "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value,
+                                    intf_detail_json["lastMemberQueryCount"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-count is %s ms",
+                            dut,
+                            interface,
+                            value * 1000,
+                        )
+
+                    if query == "last-member-query-interval":
+                        # Verifying IGMP interface last member query interval
+                        if (
+                            intf_detail_json["timerLastMemberQueryMsec"]
+                            != value * 100 * intf_detail_json["lastMemberQueryCount"]
+                        ):
+                            errormsg = (
+                                "[DUT %s]: MLD interface: %s "
+                                "last-member-query-interval "
+                                "verification [FAILED]!!"
+                                " Expected : %s, Found : %s"
+                                % (
+                                    dut,
+                                    interface,
+                                    value * 1000,
+                                    intf_detail_json["timerLastMemberQueryMsec"],
+                                )
+                            )
+                            return errormsg
+
+                        logger.info(
+                            "[DUT %s]: MLD interface: %s "
+                            "last-member-query-interval is %s ms",
+                            dut,
+                            interface,
+                            value * intf_detail_json["lastMemberQueryCount"] * 100,
+                        )
+
+            if "version" in data["mld"]:
+                # Verifying IGMP interface state is up
+                if intf_detail_json["state"] != "up":
+                    errormsg = (
+                        "[DUT %s]: MLD interface: %s "
+                        " state: %s verification "
+                        "[FAILED]!!" % (dut, interface, intf_detail_json["state"])
+                    )
+                    return errormsg
+
+                logger.info(
+                    "[DUT %s]: MLD interface: %s " "state: %s",
+                    dut,
+                    interface,
+                    intf_detail_json["state"],
+                )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True if stats_return == False else mld_stats
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_pim_nexthop(tgen, topo, dut, nexthop, addr_type):
+    """
+    Verify all PIM nexthop details using "show ip/ipv6 pim neighbor" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `topo` : json file data
+    * `dut` : dut info
+    * `nexthop` : nexthop ip/ipv6 address
+
+    Usage
+    -----
+    result = verify_pim_nexthop(tgen, topo, dut, nexthop)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    rnode = tgen.routers()[dut]
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} pim nexthop".format(addr_type)
+    pim_nexthop = rnode.vtysh_cmd(cmd)
+
+    if nexthop in pim_nexthop:
+        logger.info("[DUT %s]: Expected nexthop: %s, Found", dut, nexthop)
+        return True
+    else:
+        errormsg = "[DUT %s]: Nexthop not found: %s" % (dut, nexthop)
+        return errormsg
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+@retry(retry_timeout=60, diag_pct=0)
+def verify_mroute_summary(
+    tgen, dut, sg_mroute=None, starg_mroute=None, total_mroute=None, addr_type="ipv4"
+):
+    """
+    Verify ip mroute summary has correct (*,g) (s,G) and total mroutes
+    by running "show ip mroutes summary json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `dut`: device under test
+    * `sg_mroute`: Number of installed (s,g) mroute
+    * `starg_mroute`: Number installed of (*,g) mroute
+    * `Total_mroute`: Total number of installed mroutes
+    * 'addr_type : IPv4 or IPv6 address
+    * `return_json`: Whether to return raw json data
+
+    Usage
+    -----
+    dut = "r1"
+    sg_mroute = "4000"
+    starg_mroute= "2000"
+    total_mroute = "6000"
+    addr_type=IPv4 or IPv6
+    result = verify_mroute_summary(tgen, dut, sg_mroute=None, starg_mroute=None,
+                                        total_mroute= None)
+    Returns
+    -------
+    errormsg or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+
+    if dut not in tgen.routers():
+        return False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying mroute summary", dut)
+
+    if addr_type == "ipv4":
+        ip_cmd = "ip"
+    elif addr_type == "ipv6":
+        ip_cmd = "ipv6"
+
+    cmd = "show {} mroute summary json".format(ip_cmd)
+    show_mroute_summary_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if starg_mroute is not None:
+        if show_mroute_summary_json["wildcardGroup"]["installed"] != starg_mroute:
+            logger.error(
+                "Number of installed starg are: %s but expected: %s",
+                show_mroute_summary_json["wildcardGroup"]["installed"],
+                starg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed starg routes are %s",
+            show_mroute_summary_json["wildcardGroup"]["installed"],
+        )
+
+    if sg_mroute is not None:
+        if show_mroute_summary_json["sourceGroup"]["installed"] != sg_mroute:
+            logger.error(
+                "Number of installed SG routes are: %s but expected: %s",
+                show_mroute_summary_json["sourceGroup"]["installed"],
+                sg_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed SG routes are %s",
+            show_mroute_summary_json["sourceGroup"]["installed"],
+        )
+
+    if total_mroute is not None:
+        if show_mroute_summary_json["totalNumOfInstalledMroutes"] != total_mroute:
+            logger.error(
+                "Total number of installed mroutes are: %s but expected: %s",
+                show_mroute_summary_json["totalNumOfInstalledMroutes"],
+                total_mroute,
+            )
+            return False
+        logger.info(
+            "Number of installed Total mroute are %s",
+            show_mroute_summary_json["totalNumOfInstalledMroutes"],
+        )
+
+    logger.debug("Exiting lib API: {}".format(sys._getframe().f_code.co_name))
+    return True
+
+
+def verify_sg_traffic(tgen, dut, groups, src, addr_type="ipv4"):
+    """
+    Verify multicast traffic by running
+    "show ip mroute count json" cli
+
+    Parameters
+    ----------
+    * `tgen`: topogen object
+    * `groups`: igmp or mld groups where traffic needs to be verified
+
+    Usage
+    -----
+    result = verify_sg_traffic(tgen, "r1", igmp_groups, srcaddress)
+
+    Returns
+    -------
+    errormsg(str) or True
+    """
+
+    logger.debug("Entering lib API: {}".format(sys._getframe().f_code.co_name))
+    result = False
+
+    rnode = tgen.routers()[dut]
+
+    logger.info("[DUT: %s]: Verifying multicast " "SG traffic", dut)
+
+    if addr_type == "ipv4":
+        cmd = "show ip mroute count json"
+    elif addr_type == "ipv6":
+        cmd = "show ipv6 mroute count json"
+    # import pdb; pdb.set_trace()
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    if bool(show_mroute_sg_traffic_json) is False:
+        errormsg = "[DUT %s]: Json output is empty" % (dut)
+        return errormsg
+
+    before_traffic = {}
+    after_traffic = {}
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        before_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    logger.info("Waiting for 10sec traffic to increament")
+    sleep(10)
+
+    show_mroute_sg_traffic_json = run_frr_cmd(rnode, cmd, isjson=True)
+
+    for grp in groups:
+        if grp not in show_mroute_sg_traffic_json:
+            errormsg = "[DUT %s]: Verifying (%s, %s) mroute," "[FAILED]!! " % (
+                dut,
+                src,
+                grp,
+            )
+        if src not in show_mroute_sg_traffic_json[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying  source is not present in "
+                " %s [FAILED]!! " % (dut, src)
+            )
+            return errormsg
+
+        after_traffic[grp] = show_mroute_sg_traffic_json[grp][src]["packets"]
+
+    for grp in groups:
+        if after_traffic[grp] < before_traffic[grp]:
+            errormsg = (
+                "[DUT %s]: Verifying igmp group %s source %s not increamenting traffic"
+                " [FAILED]!! " % (dut, grp, src)
+            )
+            return errormsg
+        else:
+            logger.info(
+                "[DUT %s]:igmp group %s source %s receiving traffic"
+                " [PASSED]!! " % (dut, grp, src)
+            )
+            result = True
+
+    return result
+
     # def cleanup(self):
     #     super(McastTesterHelper, self).cleanup()
 
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/snmptest.py frr-frr-8.5/tests/topotests/ospfapi/lib/snmptest.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/snmptest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/snmptest.py	2023-03-13 20:01:47.000000000 +0600
@@ -36,11 +36,12 @@ from lib.topolog import logger
 class SnmpTester(object):
     "A helper class for testing SNMP"
 
-    def __init__(self, router, iface, community, version):
+    def __init__(self, router, iface, community, version, options=""):
         self.community = community
         self.version = version
         self.router = router
         self.iface = iface
+        self.options = options
         logger.info(
             "created SNMP tester: SNMPv{0} community:{1}".format(
                 self.version, self.community
@@ -52,7 +53,9 @@ class SnmpTester(object):
         Helper function to build a string with SNMP
         configuration for commands.
         """
-        return "-v {0} -c {1} {2}".format(self.version, self.community, self.iface)
+        return "-v {0} -c {1} {2} {3}".format(
+            self.version, self.community, self.options, self.iface
+        )
 
     @staticmethod
     def _get_snmp_value(snmp_output):
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/lib/topotest.py frr-frr-8.5/tests/topotests/ospfapi/lib/topotest.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/lib/topotest.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/lib/topotest.py	2023-03-13 20:01:47.000000000 +0600
@@ -355,6 +355,16 @@ def run_and_expect(func, what, count=20,
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum {} tries)".format(
             func_name, wait, count
@@ -402,6 +412,16 @@ def run_and_expect_type(func, etype, cou
     else:
         func_name = func.__name__
 
+    # Just a safety-check to avoid running topotests with very
+    # small wait/count arguments.
+    wait_time = wait * count
+    if wait_time < 5:
+        assert (
+            wait_time >= 5
+        ), "Waiting time is too small (count={}, wait={}), adjust timer values".format(
+            count, wait
+        )
+
     logger.info(
         "'{}' polling started (interval {} secs, maximum wait {} secs)".format(
             func_name, wait, int(wait * count)
@@ -1868,15 +1888,16 @@ class Router(Node):
                 # Exclude empty string at end of list
                 for d in dmns[:-1]:
                     if re.search(r"%s" % daemon, d):
-                        daemonpid = self.cmd("cat %s" % d.rstrip()).rstrip()
+                        daemonpidfile = d.rstrip()
+                        daemonpid = self.cmd("cat %s" % daemonpidfile).rstrip()
                         if daemonpid.isdigit() and pid_exists(int(daemonpid)):
                             logger.info(
                                 "{}: killing {}".format(
                                     self.name,
-                                    os.path.basename(d.rstrip().rsplit(".", 1)[0]),
+                                    os.path.basename(daemonpidfile.rsplit(".", 1)[0]),
                                 )
                             )
-                            self.cmd("kill -9 %s" % daemonpid)
+                            os.kill(int(daemonpid), signal.SIGKILL)
                             if pid_exists(int(daemonpid)):
                                 numRunning += 1
                         while wait and numRunning > 0:
@@ -1902,12 +1923,12 @@ class Router(Node):
                                                 ),
                                             )
                                         )
-                                        self.cmd("kill -9 %s" % daemonpid)
+                                        os.kill(int(daemonpid), signal.SIGKILL)
                                     if daemonpid.isdigit() and not pid_exists(
                                         int(daemonpid)
                                     ):
                                         numRunning -= 1
-                        self.cmd("rm -- {}".format(d.rstrip()))
+                        self.cmd("rm -- {}".format(daemonpidfile))
                     if wait:
                         errors = self.checkRouterCores(reportOnce=True)
                         if self.checkRouterVersion("<", minErrorVersion):
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r1/ospfd.conf frr-frr-8.5/tests/topotests/ospfapi/r1/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r1/ospfd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r1/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -4,7 +4,12 @@ interface r1-eth0
   ip ospf dead-interval 10
   ip ospf area 1.2.3.4
 !
+interface r1-eth1
+  ip ospf hello-interval 2
+  ip ospf dead-interval 10
+  ip ospf area 1.2.3.4
+!
 router ospf
-  ospf router-id 192.168.0.1
+  ospf router-id 1.0.0.0
   capability opaque
 !
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r1/zebra.conf frr-frr-8.5/tests/topotests/ospfapi/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r1/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -2,3 +2,5 @@
 interface r1-eth0
  ip address 10.0.1.1/24
 !
+interface r1-eth1
+ ip address 10.0.4.1/24
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r2/ospfd.conf frr-frr-8.5/tests/topotests/ospfapi/r2/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r2/ospfd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r2/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -10,6 +10,6 @@ interface r2-eth1
   ip ospf area 1.2.3.4
 !
 router ospf
-  ospf router-id 192.168.0.2
+  ospf router-id 2.0.0.0
   capability opaque
 !
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r3/ospfd.conf frr-frr-8.5/tests/topotests/ospfapi/r3/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r3/ospfd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r3/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -10,6 +10,6 @@ interface r3-eth1
   ip ospf area 1.2.3.4
 !
 router ospf
-  ospf router-id 192.168.0.3
+  ospf router-id 3.0.0.0
   capability opaque
 !
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r4/ospfd.conf frr-frr-8.5/tests/topotests/ospfapi/r4/ospfd.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r4/ospfd.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r4/ospfd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -4,7 +4,12 @@ interface r4-eth0
   ip ospf dead-interval 10
   ip ospf area 1.2.3.4
 !
+interface r4-eth1
+  ip ospf hello-interval 2
+  ip ospf dead-interval 10
+  ip ospf area 1.2.3.4
+!
 router ospf
-  ospf router-id 192.168.0.4
+  ospf router-id 4.0.0.0
   capability opaque
 !
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/r4/zebra.conf frr-frr-8.5/tests/topotests/ospfapi/r4/zebra.conf
--- frr-frr-8.4.2/tests/topotests/ospfapi/r4/zebra.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/r4/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -2,3 +2,5 @@
 interface r4-eth0
  ip address 10.0.3.4/24
 !
+interface r4-eth1
+ ip address 10.0.4.4/24
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/ospfapi/test_ospf_clientapi.py frr-frr-8.5/tests/topotests/ospfapi/test_ospf_clientapi.py
--- frr-frr-8.4.2/tests/topotests/ospfapi/test_ospf_clientapi.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfapi/test_ospf_clientapi.py	2023-03-13 20:01:47.000000000 +0600
@@ -34,7 +34,7 @@ from datetime import datetime, timedelta
 import pytest
 
 from lib.common_config import retry, run_frr_cmd, step
-from lib.micronet import comm_error
+from lib.micronet import Timeout, comm_error
 from lib.topogen import Topogen, TopoRouter
 from lib.topotest import interface_set_status, json_cmp
 
@@ -56,15 +56,20 @@ assert os.path.exists(
 # Test Setup
 # ----------
 
+#
+#  r1 - r2
+#  |    |
+#  r4 - r3
+#
+
 
 @pytest.fixture(scope="function", name="tgen")
 def _tgen(request):
     "Setup/Teardown the environment and provide tgen argument to tests"
     nrouters = request.param
-    if nrouters == 1:
-        topodef = {"sw1:": ("r1",)}
-    else:
-        topodef = {f"sw{i}": (f"r{i}", f"r{i+1}") for i in range(1, nrouters)}
+    topodef = {f"sw{i}": (f"r{i}", f"r{i+1}") for i in range(1, nrouters)}
+    if nrouters == 4:
+        topodef["sw4"] = ("r4", "r1")
 
     tgen = Topogen(topodef, request.module.__name__)
     tgen.start_topology()
@@ -107,23 +112,23 @@ def verify_ospf_database(tgen, dut, inpu
 def myreadline(f):
     buf = b""
     while True:
-        # logging.info("READING 1 CHAR")
+        # logging.debug("READING 1 CHAR")
         c = f.read(1)
         if not c:
             return buf if buf else None
         buf += c
-        # logging.info("READ CHAR: '%s'", c)
+        # logging.debug("READ CHAR: '%s'", c)
         if c == b"\n":
             return buf
 
 
-def _wait_output(p, regex, timeout=120):
-    retry_until = datetime.now() + timedelta(seconds=timeout)
-    while datetime.now() < retry_until:
+def _wait_output(p, regex, maxwait=120):
+    timeout = Timeout(maxwait)
+    while not timeout.is_expired():
         # line = p.stdout.readline()
         line = myreadline(p.stdout)
         if not line:
-            assert None, "Timeout waiting for '{}'".format(regex)
+            assert None, "EOF waiting for '{}'".format(regex)
         line = line.decode("utf-8")
         line = line.rstrip()
         if line:
@@ -131,7 +136,9 @@ def _wait_output(p, regex, timeout=120):
         m = re.search(regex, line)
         if m:
             return m
-    assert None, "Failed to get output withint {}s".format(timeout)
+    assert None, "Failed to get output matching '{}' withint {} actual {}s".format(
+        regex, maxwait, timeout.elapsed()
+    )
 
 
 # -----
@@ -141,12 +148,13 @@ def _wait_output(p, regex, timeout=120):
 
 def _test_reachability(tgen, testbin):
     waitlist = [
-        "192.168.0.1,192.168.0.2,192.168.0.4",
-        "192.168.0.2,192.168.0.4",
-        "192.168.0.1,192.168.0.2,192.168.0.4",
+        "1.0.0.0,2.0.0.0,4.0.0.0",
+        "2.0.0.0,4.0.0.0",
+        "1.0.0.0,2.0.0.0,4.0.0.0",
     ]
     r2 = tgen.gears["r2"]
     r3 = tgen.gears["r3"]
+    r4 = tgen.gears["r4"]
 
     wait_args = [f"--wait={x}" for x in waitlist]
 
@@ -164,10 +172,12 @@ def _test_reachability(tgen, testbin):
 
         step("reachable: check for modified reachability")
         interface_set_status(r2, "r2-eth0", False)
+        interface_set_status(r4, "r4-eth1", False)
         _wait_output(p, "SUCCESS: {}".format(waitlist[1]))
 
         step("reachable: check for restored reachability")
         interface_set_status(r2, "r2-eth0", True)
+        interface_set_status(r4, "r4-eth1", True)
         _wait_output(p, "SUCCESS: {}".format(waitlist[2]))
     except Exception as error:
         logging.error("ERROR: %s", error)
@@ -182,16 +192,16 @@ def _test_reachability(tgen, testbin):
 def test_ospf_reachability(tgen):
     testbin = os.path.join(TESTDIR, "ctester.py")
     rc, o, e = tgen.gears["r2"].net.cmd_status([testbin, "--help"])
-    logging.info("%s --help: rc: %s stdout: '%s' stderr: '%s'", testbin, rc, o, e)
+    logging.debug("%s --help: rc: %s stdout: '%s' stderr: '%s'", testbin, rc, o, e)
     _test_reachability(tgen, testbin)
 
 
 def _test_router_id(tgen, testbin):
     r1 = tgen.gears["r1"]
     waitlist = [
-        "192.168.0.1",
+        "1.0.0.0",
         "1.1.1.1",
-        "192.168.0.1",
+        "1.0.0.0",
     ]
 
     mon_args = [f"--monitor={x}" for x in waitlist]
@@ -213,7 +223,7 @@ def _test_router_id(tgen, testbin):
         _wait_output(p, "SUCCESS: {}".format(waitlist[1]))
 
         step("router id: check for restored router id")
-        r1.vtysh_multicmd("conf t\nrouter ospf\nospf router-id 192.168.0.1")
+        r1.vtysh_multicmd("conf t\nrouter ospf\nospf router-id 1.0.0.0")
         _wait_output(p, "SUCCESS: {}".format(waitlist[2]))
     except Exception as error:
         logging.error("ERROR: %s", error)
@@ -228,7 +238,7 @@ def _test_router_id(tgen, testbin):
 def test_ospf_router_id(tgen):
     testbin = os.path.join(TESTDIR, "ctester.py")
     rc, o, e = tgen.gears["r1"].net.cmd_status([testbin, "--help"])
-    logging.info("%s --help: rc: %s stdout: '%s' stderr: '%s'", testbin, rc, o, e)
+    logging.debug("%s --help: rc: %s stdout: '%s' stderr: '%s'", testbin, rc, o, e)
     _test_router_id(tgen, testbin)
 
 
@@ -243,13 +253,13 @@ def _test_add_data(tgen, apibin):
     try:
         p = r1.popen([apibin, "-v", "add,9,10.0.1.1,230,2,00000202"])
         input_dict = {
-            "routerId": "192.168.0.1",
+            "routerId": "1.0.0.0",
             "areas": {
                 "1.2.3.4": {
                     "linkLocalOpaqueLsa": [
                         {
                             "lsId": "230.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
                         }
                     ],
@@ -265,7 +275,7 @@ def _test_add_data(tgen, apibin):
                     "1.2.3.4": [
                         {
                             "linkStateId": "230.0.0.2",
-                            "advertisingRouter": "192.168.0.1",
+                            "advertisingRouter": "1.0.0.0",
                             "lsaSeqNumber": "80000001",
                             "opaqueData": "00000202",
                         },
@@ -285,13 +295,13 @@ def _test_add_data(tgen, apibin):
         p = None
         p = r1.popen([apibin, "-v", "add,10,1.2.3.4,231,1,00010101"])
         input_dict = {
-            "routerId": "192.168.0.1",
+            "routerId": "1.0.0.0",
             "areas": {
                 "1.2.3.4": {
                     "linkLocalOpaqueLsa": [
                         {
                             "lsId": "230.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
                             "lsaAge": 3600,
                         }
@@ -299,7 +309,7 @@ def _test_add_data(tgen, apibin):
                     "areaLocalOpaqueLsa": [
                         {
                             "lsId": "231.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
                         },
                     ],
@@ -315,7 +325,7 @@ def _test_add_data(tgen, apibin):
                     "1.2.3.4": [
                         {
                             "linkStateId": "231.0.0.1",
-                            "advertisingRouter": "192.168.0.1",
+                            "advertisingRouter": "1.0.0.0",
                             "lsaSeqNumber": "80000001",
                             "opaqueData": "00010101",
                         },
@@ -336,13 +346,13 @@ def _test_add_data(tgen, apibin):
 
         p = r1.popen([apibin, "-v", "add,11,232,3,deadbeaf01234567"])
         input_dict = {
-            "routerId": "192.168.0.1",
+            "routerId": "1.0.0.0",
             "areas": {
                 "1.2.3.4": {
                     "areaLocalOpaqueLsa": [
                         {
                             "lsId": "231.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
                             "lsaAge": 3600,
                         },
@@ -352,7 +362,7 @@ def _test_add_data(tgen, apibin):
             "asExternalOpaqueLsa": [
                 {
                     "lsId": "232.0.0.3",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000001",
                 },
             ],
@@ -364,7 +374,7 @@ def _test_add_data(tgen, apibin):
             "asExternalOpaqueLsa": [
                 {
                     "linkStateId": "232.0.0.3",
-                    "advertisingRouter": "192.168.0.1",
+                    "advertisingRouter": "1.0.0.0",
                     "lsaSeqNumber": "80000001",
                     "opaqueData": "deadbeaf01234567",
                 },
@@ -382,11 +392,11 @@ def _test_add_data(tgen, apibin):
         p = None
 
         input_dict = {
-            "routerId": "192.168.0.1",
+            "routerId": "1.0.0.0",
             "asExternalOpaqueLsa": [
                 {
                     "lsId": "232.0.0.3",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000001",
                     "lsaAge": 3600,
                 },
@@ -400,11 +410,11 @@ def _test_add_data(tgen, apibin):
         # Originate it again
         p = r1.popen([apibin, "-v", "add,11,232,3,ebadf00d"])
         input_dict = {
-            "routerId": "192.168.0.1",
+            "routerId": "1.0.0.0",
             "asExternalOpaqueLsa": [
                 {
                     "lsId": "232.0.0.3",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000002",
                 },
             ],
@@ -415,7 +425,7 @@ def _test_add_data(tgen, apibin):
             "asExternalOpaqueLsa": [
                 {
                     "linkStateId": "232.0.0.3",
-                    "advertisingRouter": "192.168.0.1",
+                    "advertisingRouter": "1.0.0.0",
                     "lsaSeqNumber": "80000002",
                     "opaqueData": "ebadf00d",
                 },
@@ -425,6 +435,7 @@ def _test_add_data(tgen, apibin):
         json_cmd = "show ip ospf da opaque-as json"
         assert verify_ospf_database(tgen, r1, input_dict, json_cmd) is None
 
+        logging.debug("sending interrupt to writer api client")
         p.send_signal(signal.SIGINT)
         time.sleep(2)
         p.wait()
@@ -439,6 +450,7 @@ def _test_add_data(tgen, apibin):
         raise
     finally:
         if p:
+            logging.debug("cleanup: sending interrupt to writer api client")
             p.terminate()
             p.wait()
 
@@ -447,7 +459,7 @@ def _test_add_data(tgen, apibin):
 def test_ospf_opaque_add_data3(tgen):
     apibin = os.path.join(CLIENTDIR, "ospfclient.py")
     rc, o, e = tgen.gears["r2"].net.cmd_status([apibin, "--help"])
-    logging.info("%s --help: rc: %s stdout: '%s' stderr: '%s'", apibin, rc, o, e)
+    logging.debug("%s --help: rc: %s stdout: '%s' stderr: '%s'", apibin, rc, o, e)
     _test_add_data(tgen, apibin)
 
 
@@ -459,10 +471,12 @@ def _test_opaque_add_del(tgen, apibin):
 
     p = None
     pread = None
+    # Log to our stdin, stderr
+    pout = open(os.path.join(r1.net.logdir, "r1/add-del.log"), "a+")
     try:
         step("reachable: check for add notification")
         pread = r2.popen(
-            ["/usr/bin/timeout", "120", apibin, "-v"],
+            ["/usr/bin/timeout", "120", apibin, "-v", "--logtag=READER", "wait,120"],
             encoding=None,  # don't buffer
             stdin=subprocess.DEVNULL,
             stdout=subprocess.PIPE,
@@ -492,30 +506,30 @@ def _test_opaque_add_del(tgen, apibin):
                     "linkLocalOpaqueLsa": [
                         {
                             "lsId": "230.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "6d5f",
+                            "checksum": "76bf",
                         },
                         {
                             "lsId": "230.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "8142",
+                            "checksum": "8aa2",
                         },
                     ],
                     "linkLocalOpaqueLsaCount": 2,
                     "areaLocalOpaqueLsa": [
                         {
                             "lsId": "231.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "5278",
+                            "checksum": "5bd8",
                         },
                         {
                             "lsId": "231.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "6d30",
+                            "checksum": "7690",
                         },
                     ],
                     "areaLocalOpaqueLsaCount": 2,
@@ -524,15 +538,15 @@ def _test_opaque_add_del(tgen, apibin):
             "asExternalOpaqueLsa": [
                 {
                     "lsId": "232.0.0.1",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000001",
-                    "checksum": "5575",
+                    "checksum": "5ed5",
                 },
                 {
                     "lsId": "232.0.0.2",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000001",
-                    "checksum": "d05d",
+                    "checksum": "d9bd",
                 },
             ],
             "asExternalOpaqueLsaCount": 2,
@@ -556,17 +570,17 @@ def _test_opaque_add_del(tgen, apibin):
                         "1.2.3.4": [
                             {
                                 "linkStateId": "230.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "6d5f",
+                                "checksum": "76bf",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "linkStateId": "230.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "8142",
+                                "checksum": "8aa2",
                                 "length": 24,
                                 "opaqueId": 2,
                                 "opaqueDataLength": 4,
@@ -581,17 +595,17 @@ def _test_opaque_add_del(tgen, apibin):
                         "1.2.3.4": [
                             {
                                 "linkStateId": "231.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "5278",
+                                "checksum": "5bd8",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "linkStateId": "231.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "6d30",
+                                "checksum": "7690",
                                 "length": 28,
                                 "opaqueDataLength": 8,
                             },
@@ -603,17 +617,17 @@ def _test_opaque_add_del(tgen, apibin):
                 "asExternalOpaqueLsa": [
                     {
                         "linkStateId": "232.0.0.1",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaSeqNumber": "80000001",
-                        "checksum": "5575",
+                        "checksum": "5ed5",
                         "length": 20,
                         "opaqueDataLength": 0,
                     },
                     {
                         "linkStateId": "232.0.0.2",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaSeqNumber": "80000001",
-                        "checksum": "d05d",
+                        "checksum": "d9bd",
                         "length": 24,
                         "opaqueDataLength": 4,
                     },
@@ -655,32 +669,32 @@ def _test_opaque_add_del(tgen, apibin):
                     "linkLocalOpaqueLsa": [
                         {
                             "lsId": "230.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "6d5f",
+                            "checksum": "76bf",
                         },
                         {
                             "lsId": "230.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "lsaAge": 3600,
                             "sequenceNumber": "80000001",
-                            "checksum": "8142",
+                            "checksum": "8aa2",
                         },
                     ],
                     "linkLocalOpaqueLsaCount": 2,
                     "areaLocalOpaqueLsa": [
                         {
                             "lsId": "231.0.0.1",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "sequenceNumber": "80000001",
-                            "checksum": "5278",
+                            "checksum": "5bd8",
                         },
                         {
                             "lsId": "231.0.0.2",
-                            "advertisedRouter": "192.168.0.1",
+                            "advertisedRouter": "1.0.0.0",
                             "lsaAge": 3600,
                             "sequenceNumber": "80000002",
-                            "checksum": "4682",
+                            "checksum": "4fe2",
                         },
                     ],
                     "areaLocalOpaqueLsaCount": 2,
@@ -689,16 +703,16 @@ def _test_opaque_add_del(tgen, apibin):
             "asExternalOpaqueLsa": [
                 {
                     "lsId": "232.0.0.1",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "lsaAge": 3600,
                     "sequenceNumber": "80000001",
-                    "checksum": "5575",
+                    "checksum": "5ed5",
                 },
                 {
                     "lsId": "232.0.0.2",
-                    "advertisedRouter": "192.168.0.1",
+                    "advertisedRouter": "1.0.0.0",
                     "sequenceNumber": "80000001",
-                    "checksum": "d05d",
+                    "checksum": "d9bd",
                 },
             ],
             "asExternalOpaqueLsaCount": 2,
@@ -716,18 +730,18 @@ def _test_opaque_add_del(tgen, apibin):
                         "1.2.3.4": [
                             {
                                 "linkStateId": "230.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "6d5f",
+                                "checksum": "76bf",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "linkStateId": "230.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaAge": 3600,
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "8142",
+                                "checksum": "8aa2",
                                 "length": 24,
                                 "opaqueId": 2,
                                 "opaqueDataLength": 4,
@@ -742,18 +756,18 @@ def _test_opaque_add_del(tgen, apibin):
                         "1.2.3.4": [
                             {
                                 "linkStateId": "231.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "5278",
+                                "checksum": "5bd8",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "lsaAge": 3600,
                                 "linkStateId": "231.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000002",
-                                "checksum": "4682",
+                                "checksum": "4fe2",
                                 # data removed
                                 "length": 20,
                                 "opaqueDataLength": 0,
@@ -766,18 +780,18 @@ def _test_opaque_add_del(tgen, apibin):
                 "asExternalOpaqueLsa": [
                     {
                         "linkStateId": "232.0.0.1",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaAge": 3600,
                         "lsaSeqNumber": "80000001",
-                        "checksum": "5575",
+                        "checksum": "5ed5",
                         "length": 20,
                         "opaqueDataLength": 0,
                     },
                     {
                         "linkStateId": "232.0.0.2",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaSeqNumber": "80000001",
-                        "checksum": "d05d",
+                        "checksum": "d9bd",
                         "length": 24,
                         "opaqueDataLength": 4,
                     },
@@ -808,19 +822,19 @@ def _test_opaque_add_del(tgen, apibin):
                         "1.2.3.4": [
                             {
                                 "linkStateId": "230.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaAge": 3600,
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "6d5f",
+                                "checksum": "76bf",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "linkStateId": "230.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaAge": 3600,
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "8142",
+                                "checksum": "8aa2",
                                 "length": 24,
                                 "opaqueId": 2,
                                 "opaqueDataLength": 4,
@@ -836,18 +850,18 @@ def _test_opaque_add_del(tgen, apibin):
                             {
                                 "lsaAge": 3600,
                                 "linkStateId": "231.0.0.1",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000001",
-                                "checksum": "5278",
+                                "checksum": "5bd8",
                                 "length": 20,
                                 "opaqueDataLength": 0,
                             },
                             {
                                 "lsaAge": 3600,
                                 "linkStateId": "231.0.0.2",
-                                "advertisingRouter": "192.168.0.1",
+                                "advertisingRouter": "1.0.0.0",
                                 "lsaSeqNumber": "80000002",
-                                "checksum": "4682",
+                                "checksum": "4fe2",
                                 # data removed
                                 "length": 20,
                                 "opaqueDataLength": 0,
@@ -860,19 +874,19 @@ def _test_opaque_add_del(tgen, apibin):
                 "asExternalOpaqueLsa": [
                     {
                         "linkStateId": "232.0.0.1",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaAge": 3600,
                         "lsaSeqNumber": "80000001",
-                        "checksum": "5575",
+                        "checksum": "5ed5",
                         "length": 20,
                         "opaqueDataLength": 0,
                     },
                     {
                         "linkStateId": "232.0.0.2",
-                        "advertisingRouter": "192.168.0.1",
+                        "advertisingRouter": "1.0.0.0",
                         "lsaAge": 3600,
                         "lsaSeqNumber": "80000001",
-                        "checksum": "d05d",
+                        "checksum": "d9bd",
                         "length": 24,
                         "opaqueDataLength": 4,
                     },
@@ -931,7 +945,7 @@ def _test_opaque_add_del(tgen, apibin):
 def test_ospf_opaque_delete_data3(tgen):
     apibin = os.path.join(CLIENTDIR, "ospfclient.py")
     rc, o, e = tgen.gears["r2"].net.cmd_status([apibin, "--help"])
-    logging.info("%s --help: rc: %s stdout: '%s' stderr: '%s'", apibin, rc, o, e)
+    logging.debug("%s --help: rc: %s stdout: '%s' stderr: '%s'", apibin, rc, o, e)
     _test_opaque_add_del(tgen, apibin)
 
 
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_asbr_summary_topo1.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_asbr_summary_topo1.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_asbr_summary_topo1.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_asbr_summary_topo1.py	2023-03-13 20:01:47.000000000 +0600
@@ -55,7 +55,6 @@ from lib.common_config import (
     shutdown_bringup_interface,
     create_prefix_lists,
     create_route_maps,
-    topo_daemons,
     create_interfaces_cfg,
 )
 from lib.topolog import logger
@@ -158,12 +157,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -336,11 +332,11 @@ def test_ospfv3_type5_summary_tc42_p0(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -407,11 +403,11 @@ def test_ospfv3_type5_summary_tc42_p0(re
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -448,11 +444,11 @@ def test_ospfv3_type5_summary_tc42_p0(re
 
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -531,11 +527,11 @@ def test_ospfv3_type5_summary_tc42_p0(re
 
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -669,11 +665,11 @@ def test_ospfv3_type5_summary_tc42_p0(re
 
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -826,11 +822,11 @@ def test_ospfv3_type5_summary_tc43_p0(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -861,11 +857,11 @@ def test_ospfv3_type5_summary_tc43_p0(re
 
     input_dict = {
         "2011::/16": {
-            "Summary address": "2011::/16",
-            "Metric-type": "E2",
+            "summaryAddress": "2011::/16",
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -905,11 +901,11 @@ def test_ospfv3_type5_summary_tc43_p0(re
 
     input_dict = {
         "2011::/32": {
-            "Summary address": "2011::/32",
-            "Metric-type": "E2",
+            "summaryAddress": "2011::/32",
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 0,
+            "externalRouteCount": 0,
         }
     }
     dut = "r0"
@@ -1088,11 +1084,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1234,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1140,11 +1136,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1234,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1183,11 +1179,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1232,11 +1228,11 @@ def ospfv3_type5_summary_tc45_p0(request
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 4294967295,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1291,11 +1287,11 @@ def ospfv3_type5_summary_tc45_p0(request
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 88888,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1525,11 +1521,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1234,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1574,11 +1570,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1234,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1617,11 +1613,11 @@ def ospfv3_type5_summary_tc45_p0(request
     step("Verify that show ip ospf summary should show the summaries with tag.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1666,11 +1662,11 @@ def ospfv3_type5_summary_tc45_p0(request
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 4294967295,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1725,11 +1721,11 @@ def ospfv3_type5_summary_tc45_p0(request
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 88888,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1918,8 +1914,8 @@ def test_ospfv3_type5_summary_tc46_p0(re
     step("Verify that show ip ospf summary should show the " "configured summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -1969,11 +1965,11 @@ def test_ospfv3_type5_summary_tc46_p0(re
     step("show ip ospf summary should not have any summary address.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 1234,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2027,8 +2023,8 @@ def test_ospfv3_type5_summary_tc46_p0(re
     step("Verify that show ip ospf summary should show the " "configured summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "External route count": 5,
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2089,11 +2085,11 @@ def test_ospfv3_type5_summary_tc46_p0(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2211,11 +2207,11 @@ def test_ospfv3_type5_summary_tc48_p0(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2308,11 +2304,11 @@ def test_ospfv3_type5_summary_tc48_p0(re
 
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2345,11 +2341,11 @@ def test_ospfv3_type5_summary_tc48_p0(re
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2382,11 +2378,11 @@ def test_ospfv3_type5_summary_tc48_p0(re
     )
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2562,11 +2558,11 @@ def test_ospfv3_type5_summary_tc51_p2(re
 
     input_dict = {
         SUMMARY["ipv6"][3]: {
-            "Summary address": SUMMARY["ipv6"][3],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][3],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 0,
+            "externalRouteCount": 0,
         }
     }
     dut = "r0"
@@ -2657,11 +2653,11 @@ def test_ospfv3_type5_summary_tc49_p2(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
@@ -2713,11 +2709,11 @@ def test_ospfv3_type5_summary_tc49_p2(re
     step("Verify that show ip ospf summary should show the summaries.")
     input_dict = {
         SUMMARY["ipv6"][0]: {
-            "Summary address": SUMMARY["ipv6"][0],
-            "Metric-type": "E2",
+            "summaryAddress": SUMMARY["ipv6"][0],
+            "metricType": "E2",
             "Metric": 20,
             "Tag": 0,
-            "External route count": 5,
+            "externalRouteCount": 5,
         }
     }
     dut = "r0"
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_authentication.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_authentication.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_authentication.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_authentication.py	2023-03-13 20:01:47.000000000 +0600
@@ -50,7 +50,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     shutdown_bringup_interface,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_topo_from_json, build_config_from_json
@@ -94,6 +93,7 @@ TESTCASES =
 
  """
 
+
 def setup_module(mod):
     """
     Sets up the pytest environment
@@ -112,12 +112,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -157,6 +154,7 @@ def teardown_module(mod):
 # Test cases start here.
 # ##################################
 
+
 def test_ospf6_auth_trailer_tc1_md5(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -233,9 +231,7 @@ def test_ospf6_auth_trailer_tc1_md5(requ
         tc_name, ospf6_covergence
     )
 
-    step(
-        "Disable authentication on R2 "
-    )
+    step("Disable authentication on R2 ")
 
     r2_ospf6_auth = {
         "r2": {
@@ -245,7 +241,7 @@ def test_ospf6_auth_trailer_tc1_md5(requ
                         "hash-algo": "md5",
                         "key": "ospf6",
                         "key-id": "10",
-                        "del_action": True
+                        "del_action": True,
                     }
                 }
             }
@@ -401,9 +397,7 @@ def test_ospf6_auth_trailer_tc2_sha256(r
         tc_name, ospf6_covergence
     )
 
-    step(
-        "Disable authentication on R2 "
-    )
+    step("Disable authentication on R2 ")
 
     r2_ospf6_auth = {
         "r2": {
@@ -413,7 +407,7 @@ def test_ospf6_auth_trailer_tc2_sha256(r
                         "hash-algo": "hmac-sha-256",
                         "key": "ospf6",
                         "key-id": "10",
-                        "del_action": True
+                        "del_action": True,
                     }
                 }
             }
@@ -492,6 +486,7 @@ def test_ospf6_auth_trailer_tc2_sha256(r
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc3_keychain_md5(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -583,21 +578,10 @@ def test_ospf6_auth_trailer_tc3_keychain
         tc_name, ospf6_covergence
     )
 
-    step(
-        "Disable authentication on R2 "
-    )
+    step("Disable authentication on R2 ")
 
     r2_ospf6_auth = {
-        "r2": {
-            "links": {
-                "r1": {
-                    "ospf6": {
-                        "keychain": "auth",
-                        "del_action": True
-                    }
-                }
-            }
-        }
+        "r2": {"links": {"r1": {"ospf6": {"keychain": "auth", "del_action": True}}}}
     }
     result = config_ospf6_interface(tgen, topo, r2_ospf6_auth)
     assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
@@ -670,6 +654,7 @@ def test_ospf6_auth_trailer_tc3_keychain
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc4_keychain_sha256(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -761,21 +746,10 @@ def test_ospf6_auth_trailer_tc4_keychain
         tc_name, ospf6_covergence
     )
 
-    step(
-        "Disable authentication on R2 "
-    )
+    step("Disable authentication on R2 ")
 
     r2_ospf6_auth = {
-        "r2": {
-            "links": {
-                "r1": {
-                    "ospf6": {
-                        "keychain": "auth",
-                        "del_action": True
-                    }
-                }
-            }
-        }
+        "r2": {"links": {"r1": {"ospf6": {"keychain": "auth", "del_action": True}}}}
     }
     result = config_ospf6_interface(tgen, topo, r2_ospf6_auth)
     assert result is True, "Testcase {} :Failed \n Error: {}".format(tc_name, result)
@@ -848,6 +822,7 @@ def test_ospf6_auth_trailer_tc4_keychain
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc5_md5_keymissmatch(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -963,6 +938,7 @@ def test_ospf6_auth_trailer_tc5_md5_keym
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc6_sha256_mismatch(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -1073,6 +1049,7 @@ def test_ospf6_auth_trailer_tc6_sha256_m
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc7_keychain_md5_missmatch(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -1204,6 +1181,7 @@ def test_ospf6_auth_trailer_tc7_keychain
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc8_keychain_sha256_missmatch(request):
     """
     OSPFv3 Authentication Trailer - Verify ospfv3 authentication trailer
@@ -1335,6 +1313,7 @@ def test_ospf6_auth_trailer_tc8_keychain
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc9_keychain_not_configured(request):
     """
     OSPFv3 Neighborship without Authentication Trailer -
@@ -1412,6 +1391,7 @@ def test_ospf6_auth_trailer_tc9_keychain
 
     write_test_footer(tc_name)
 
+
 def test_ospf6_auth_trailer_tc10_no_auth_trailer(request):
     """
     OSPFv3 Neighborship without Authentication Trailer -
@@ -1441,6 +1421,7 @@ def test_ospf6_auth_trailer_tc10_no_auth
 
     write_test_footer(tc_name)
 
+
 if __name__ == "__main__":
     args = ["-s"] + sys.argv[1:]
     sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp.py	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,6 @@ from lib.common_config import (
     create_static_routes,
     step,
     shutdown_bringup_interface,
-    topo_daemons,
     get_frr_ipv6_linklocal,
 )
 from lib.topolog import logger
@@ -117,12 +116,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp_lan.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp_lan.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp_lan.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_ecmp_lan.py	2023-03-13 20:01:47.000000000 +0600
@@ -53,7 +53,6 @@ from lib.common_config import (
     create_route_maps,
     shutdown_bringup_interface,
     create_interfaces_cfg,
-    topo_daemons,
     get_frr_ipv6_linklocal,
 )
 from lib.topolog import logger
@@ -130,12 +129,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa.py	2023-03-13 20:01:47.000000000 +0600
@@ -7,7 +7,6 @@ from lib.common_config import (
     write_test_footer,
     reset_config_on_routers,
     step,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -62,12 +61,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa2.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa2.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_nssa2.py	2023-03-13 20:01:47.000000000 +0600
@@ -57,7 +57,6 @@ from lib.common_config import (
     verify_rib,
     create_static_routes,
     step,
-    topo_daemons,
     create_route_maps,
     shutdown_bringup_interface,
     create_interfaces_cfg,
@@ -139,12 +138,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
@@ -404,6 +400,124 @@ def test_ospfv3_nssa_tc26_p0(request):
     assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
 
     write_test_footer(tc_name)
+
+
+def test_ospfv3_learning_tc15_p0(request):
+    """Verify OSPF can learn different types of LSA and processes them.
+
+    OSPF Learning : Edge learning different types of LSAs.
+    """
+    tc_name = request.node.name
+    write_test_header(tc_name)
+    tgen = get_topogen()
+
+    # Don't run this test if we have any failure.
+    if tgen.routers_have_failure():
+        check_router_status(tgen)
+
+    global topo
+    step("Bring up the base config as per the topology")
+    step("Configure area 1 as NSSA Area")
+
+    reset_config_on_routers(tgen)
+
+    step("Verify that Type 3 summary LSA is originated for the same Area 0")
+    ip = topo["routers"]["r1"]["links"]["r3-link0"]["ipv6"]
+    ip_net = str(ipaddress.ip_interface(u"{}".format(ip)).network)
+
+    input_dict = {
+        "r1": {
+            "static_routes": [
+                {
+                    "network": ip_net,
+                    "no_of_ip": 1,
+                    "routeType": "Network",
+                    "pathtype": "Inter-Area",
+                }
+            ]
+        }
+    }
+
+    dut = "r0"
+    result = verify_ospf6_rib(tgen, dut, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    protocol = "ospf6"
+    result = verify_rib(tgen, "ipv6", dut, input_dict, protocol=protocol)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    input_dict = {
+        "r2": {
+            "static_routes": [
+                {"network": NETWORK["ipv6"][0], "no_of_ip": 5, "next_hop": "Null0"}
+            ]
+        }
+    }
+    result = create_static_routes(tgen, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Redistribute static route in R2 ospf.")
+    dut = "r2"
+    red_static(dut)
+
+    step("Verify that Type 5 LSA is originated by R2.")
+    dut = "r0"
+    protocol = "ospf6"
+    result = verify_rib(tgen, "ipv6", dut, input_dict, protocol=protocol)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    input_dict = {
+        "r1": {
+            "static_routes": [
+                {"network": NETWORK["ipv6"][0], "no_of_ip": 1, "routeType": "Network"}
+            ]
+        }
+    }
+
+    dut = "r1"
+    result = verify_ospf6_rib(tgen, dut, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    result = verify_rib(tgen, "ipv6", dut, input_dict, protocol=protocol)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    result = verify_ospf6_neighbor(tgen, topo)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    step("Change area 1 as non nssa area (on the fly changing area" " type on DUT).")
+
+    for rtr in ["r1", "r2", "r3"]:
+        input_dict = {
+            rtr: {
+                "ospf6": {"area": [{"id": "0.0.0.2", "type": "nssa", "delete": True}]}
+            }
+        }
+        result = create_router_ospf(tgen, topo, input_dict)
+        assert result is True, "Testcase {} : Failed \n Error: {}".format(
+            tc_name, result
+        )
+
+    step("Verify that OSPF neighbours are reset after changing area type.")
+    step("Verify that ABR R2 originates type 5 LSA in area 1.")
+    step("Verify that R1 installs type 5 lsa in its database.")
+    step("Verify that route is calculated and installed in R1.")
+
+    input_dict = {
+        "r1": {
+            "static_routes": [
+                {"network": NETWORK["ipv6"][0], "no_of_ip": 1, "routeType": "Network"}
+            ]
+        }
+    }
+
+    dut = "r1"
+    result = verify_ospf6_rib(tgen, dut, input_dict)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    result = verify_rib(tgen, "ipv6", dut, input_dict, protocol=protocol)
+    assert result is True, "Testcase {} : Failed \n Error: {}".format(tc_name, result)
+
+    write_test_footer(tc_name)
 
 
 # As per internal discussion, this script has to be removed as translator
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_routemaps.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_routemaps.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_routemaps.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_routemaps.py	2023-03-13 20:01:47.000000000 +0600
@@ -48,7 +48,6 @@ from lib.common_config import (
     step,
     create_route_maps,
     verify_prefix_lists,
-    topo_daemons,
 )
 from lib.topolog import logger
 from lib.topojson import build_config_from_json
@@ -131,12 +130,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_rte_calc.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_rte_calc.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_rte_calc.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_rte_calc.py	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,6 @@ from lib.common_config import (
     step,
     shutdown_bringup_interface,
     create_interfaces_cfg,
-    topo_daemons,
     get_frr_ipv6_linklocal,
     check_router_status,
     create_static_routes,
@@ -122,12 +121,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_single_area.py frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_single_area.py
--- frr-frr-8.4.2/tests/topotests/ospfv3_basic_functionality/test_ospfv3_single_area.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/ospfv3_basic_functionality/test_ospfv3_single_area.py	2023-03-13 20:01:47.000000000 +0600
@@ -48,7 +48,6 @@ from lib.common_config import (
     reset_config_on_routers,
     step,
     create_interfaces_cfg,
-    topo_daemons,
     create_debug_log_config,
     apply_raw_config,
 )
@@ -116,12 +115,9 @@ def setup_module(mod):
     topo = tgen.json_topo
     # ... and here it calls Mininet initialization functions.
 
-    # get list of daemons needs to be started for this suite.
-    daemons = topo_daemons(tgen, topo)
-
     # Starting topology, create tmp files which are loaded to routers
     #  to start daemons and then start routers
-    start_topology(tgen, daemons)
+    start_topology(tgen)
 
     # Creating configuration from JSON
     build_config_from_json(tgen, topo)
diff -urpN frr-frr-8.4.2/tests/topotests/pim_basic/test_pim.py frr-frr-8.5/tests/topotests/pim_basic/test_pim.py
--- frr-frr-8.4.2/tests/topotests/pim_basic/test_pim.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/pim_basic/test_pim.py	2023-03-13 20:01:47.000000000 +0600
@@ -125,7 +125,7 @@ def test_pim_rp_setup():
     test_func = partial(
         topotest.router_json_cmp, r1, "show ip pim rp-info json", expected
     )
-    _, result = topotest.run_and_expect(test_func, None, count=15, wait=5)
+    _, result = topotest.run_and_expect(test_func, None, count=30, wait=1)
     assertmsg = '"{}" JSON output mismatches'.format(r1.name)
     assert result is None, assertmsg
     # tgen.mininet_cli()
@@ -148,13 +148,13 @@ def test_pim_send_mcast_stream():
     # Let's establish a S,G stream from r2 -> r1
     CWD = os.path.dirname(os.path.realpath(__file__))
     r2.run(
-        "{}/mcast-tx.py --ttl 5 --count 5 --interval 10 229.1.1.1 r2-eth0 > /tmp/bar".format(
+        "{}/mcast-tx.py --ttl 5 --count 40 --interval 2 229.1.1.1 r2-eth0 > /tmp/bar".format(
             CWD
         )
     )
     # And from r3 -> r1
     r3.run(
-        "{}/mcast-tx.py --ttl 5 --count 5 --interval 10 229.1.1.1 r3-eth0 > /tmp/bar".format(
+        "{}/mcast-tx.py --ttl 5 --count 40 --interval 2 229.1.1.1 r3-eth0 > /tmp/bar".format(
             CWD
         )
     )
@@ -175,7 +175,7 @@ def test_pim_send_mcast_stream():
     test_func = partial(
         topotest.router_json_cmp, r1, "show ip pim upstream json", expected
     )
-    _, result = topotest.run_and_expect(test_func, None, count=20, wait=1)
+    _, result = topotest.run_and_expect(test_func, None, count=40, wait=1)
     assert result is None, "failed to converge pim"
     # tgen.mininet_cli()
 
@@ -191,7 +191,7 @@ def test_pim_rp_sees_stream():
     test_func = partial(
         topotest.router_json_cmp, rp, "show ip pim upstream json", expected
     )
-    _, result = topotest.run_and_expect(test_func, None, count=20, wait=0.5)
+    _, result = topotest.run_and_expect(test_func, None, count=40, wait=1)
     assertmsg = '"{}" JSON output mismatches'.format(rp.name)
     assert result is None, assertmsg
 
@@ -225,7 +225,7 @@ def test_pim_igmp_report():
         test_func = partial(
             topotest.router_json_cmp, r1, "show ip pim upstream json", expected
         )
-        _, result = topotest.run_and_expect(test_func, None, count=5, wait=0.5)
+        _, result = topotest.run_and_expect(test_func, None, count=40, wait=1)
         assertmsg = '"{}" JSON output mismatches'.format(r1.name)
         assert result is None, assertmsg
     finally:
diff -urpN frr-frr-8.4.2/tests/topotests/pim_basic_topo2/test_pim_basic_topo2.py frr-frr-8.5/tests/topotests/pim_basic_topo2/test_pim_basic_topo2.py
--- frr-frr-8.4.2/tests/topotests/pim_basic_topo2/test_pim_basic_topo2.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/pim_basic_topo2/test_pim_basic_topo2.py	2023-03-13 20:01:47.000000000 +0600
@@ -175,7 +175,7 @@ def test_pim_reconvergence():
             "show ip pim neighbor json",
             {interface: {peer: None}},
         )
-        _, result = topotest.run_and_expect(test_func, None, count=4, wait=1)
+        _, result = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = '"{}" PIM convergence failure'.format(router)
         assert result is None, assertmsg
 
@@ -201,7 +201,7 @@ def test_pim_bfd_profile():
             "show bfd peers json",
             [settings],
         )
-        _, result = topotest.run_and_expect(test_func, None, count=4, wait=1)
+        _, result = topotest.run_and_expect(test_func, None, count=5, wait=1)
         assertmsg = '"{}" BFD convergence failure'.format(router)
         assert result is None, assertmsg
 
diff -urpN frr-frr-8.4.2/tests/topotests/pim_igmp_vrf/test_pim_vrf.py frr-frr-8.5/tests/topotests/pim_igmp_vrf/test_pim_vrf.py
--- frr-frr-8.4.2/tests/topotests/pim_igmp_vrf/test_pim_vrf.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/pim_igmp_vrf/test_pim_vrf.py	2023-03-13 20:01:47.000000000 +0600
@@ -166,6 +166,11 @@ def setup_module(module):
     tgen = Topogen(build_topo, module.__name__)
     tgen.start_topology()
 
+    # Required linux kernel version for this suite to run.
+    result = required_linux_kernel_version("4.19")
+    if result is not True:
+        pytest.skip("Kernel requirements are not met")
+
     vrf_setup_cmds = [
         "ip link add name blue type vrf table 11",
         "ip link add name red type vrf table 12",
@@ -210,11 +215,6 @@ def test_ospf_convergence():
     "Test for OSPFv2 convergence"
     tgen = get_topogen()
 
-    # Required linux kernel version for this suite to run.
-    result = required_linux_kernel_version("4.15")
-    if result is not True:
-        pytest.skip("Kernel requirements are not met")
-
     # iproute2 needs to support VRFs for this suite to run.
     if not iproute2_is_vrf_capable():
         pytest.skip("Installed iproute2 version does not support VRFs")
diff -urpN frr-frr-8.4.2/tests/topotests/pytest.ini frr-frr-8.5/tests/topotests/pytest.ini
--- frr-frr-8.4.2/tests/topotests/pytest.ini	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/pytest.ini	2023-03-13 20:01:47.000000000 +0600
@@ -46,6 +46,7 @@ markers =
 	pathd: Tests that run against PATHD
 	pbrd: Tests that run against PBRD
 	pimd: Tests that run against PIMD
+	pim6d: Tests that run against PIM6D
 	ripd: Tests that run against RIPD
 	ripngd: Tests that run against RIPNGD
 	sharpd: Tests that run against SHARPD
diff -urpN frr-frr-8.4.2/tests/topotests/route_scale/scale_test_common.py frr-frr-8.5/tests/topotests/route_scale/scale_test_common.py
--- frr-frr-8.4.2/tests/topotests/route_scale/scale_test_common.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/route_scale/scale_test_common.py	2023-03-13 20:01:47.000000000 +0600
@@ -178,7 +178,7 @@ def route_install_helper(iter):
 
     # Table of defaults, used for timeout values and 'expected' objects
     scale_defaults = dict(
-        zip(scale_keys, [None, None, 7, 30, expected_installed, expected_removed])
+        zip(scale_keys, [None, None, 10, 50, expected_installed, expected_removed])
     )
 
     # List of params for each step in the test; note extra time given
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator/test_srv6_locator.py frr-frr-8.5/tests/topotests/srv6_locator/test_srv6_locator.py
--- frr-frr-8.4.2/tests/topotests/srv6_locator/test_srv6_locator.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator/test_srv6_locator.py	2023-03-13 20:01:47.000000000 +0600
@@ -94,12 +94,12 @@ def test_srv6():
 
     def check_srv6_locator(router, expected_file):
         func = functools.partial(_check_srv6_locator, router, expected_file)
-        success, result = topotest.run_and_expect(func, None, count=5, wait=0.5)
+        success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
         assert result is None, "Failed"
 
     def check_sharpd_chunk(router, expected_file):
         func = functools.partial(_check_sharpd_chunk, router, expected_file)
-        success, result = topotest.run_and_expect(func, None, count=5, wait=0.5)
+        success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
         assert result is None, "Failed"
 
     # FOR DEVELOPER:
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks1.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks1.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+[]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks2.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks2.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+[
+  {
+    "name": "loc1",
+    "chunks": [
+      "2001:db8:1::/64"
+    ]
+  }
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks3.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks3.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks3.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks3.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+[]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks4.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks4.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks4.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks4.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks5.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks5.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks5.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks5.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks6.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks6.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_chunks6.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_chunks6.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators1.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators1.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,34 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "2001:db8:1::/64",
+      "blockBitsLength": 40,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:1::/64",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "2001:db8:2::/48",
+      "blockBitsLength": 24,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators2.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators2.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,34 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "2001:db8:1::/64",
+      "blockBitsLength": 40,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:1::/64",
+          "proto": "sharp"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "2001:db8:2::/48",
+      "blockBitsLength": 24,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators3.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators3.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators3.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators3.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,34 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "2001:db8:1::/64",
+      "blockBitsLength": 40,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:1::/64",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "2001:db8:2::/48",
+      "blockBitsLength": 24,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators4.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators4.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators4.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators4.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,49 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "2001:db8:1::/64",
+      "blockBitsLength": 40,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:1::/64",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "2001:db8:2::/48",
+      "blockBitsLength": 24,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:2::/48",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc3",
+      "prefix": "2001:db8:3::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:3::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators5.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators5.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators5.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators5.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,34 @@
+{
+  "locators":[
+    {
+      "name": "loc2",
+      "prefix": "2001:db8:2::/48",
+      "blockBitsLength": 24,
+      "nodeBitsLength": 24,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "2001:db8:2::/48",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc3",
+      "prefix": "2001:db8:3::/48",
+      "statusUp": true,
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "chunks":[
+        {
+          "prefix": "2001:db8:3::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators6.json frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators6.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/expected_locators6.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/expected_locators6.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+{
+  "locators":[
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/setup.sh frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/setup.sh
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/setup.sh	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/setup.sh	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+ip link add dummy0 type dummy
+ip link set dummy0 up
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/sharpd.conf frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/sharpd.conf
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/sharpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/sharpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+hostname r1
+!
+log stdout notifications
+log monitor notifications
+log commands
+log file sharpd.log debugging
+!
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/zebra.conf frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,22 @@
+hostname r1
+!
+! debug zebra events
+! debug zebra rib detailed
+!
+log stdout notifications
+log monitor notifications
+log commands
+log file zebra.log debugging
+!
+segment-routing
+ srv6
+  locators
+   locator loc1
+    prefix 2001:db8:1::/64
+   !
+   locator loc2
+    prefix 2001:db8:2::/48
+   !
+  !
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/test_srv6_locator.py frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/test_srv6_locator.py
--- frr-frr-8.4.2/tests/topotests/srv6_locator_custom_bits_length/test_srv6_locator.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_custom_bits_length/test_srv6_locator.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,160 @@
+#!/usr/bin/env python
+
+# Copyright (c) 2022, University of Rome Tor Vergata
+# Authored by Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+test_srv6_manager.py:
+Test for SRv6 manager on zebra
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.sharpd]
+
+
+def open_json_file(filename):
+    try:
+        with open(filename, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(filename)
+
+
+def setup_module(mod):
+    tgen = Topogen({None: "r1"}, mod.__name__)
+    tgen.start_topology()
+    for rname, router in tgen.routers().items():
+        router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_BGP, os.path.join(CWD, "{}/bgpd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_SHARP, os.path.join(CWD, "{}/sharpd.conf".format(rname))
+        )
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_srv6():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    def _check_srv6_locator(router, expected_locator_file):
+        logger.info("checking zebra locator status")
+        output = json.loads(router.vtysh_cmd("show segment-routing srv6 locator json"))
+        expected = open_json_file("{}/{}".format(CWD, expected_locator_file))
+        return topotest.json_cmp(output, expected)
+
+    def _check_sharpd_chunk(router, expected_chunk_file):
+        logger.info("checking sharpd locator chunk status")
+        output = json.loads(router.vtysh_cmd("show sharp segment-routing srv6 json"))
+        expected = open_json_file("{}/{}".format(CWD, expected_chunk_file))
+        return topotest.json_cmp(output, expected)
+
+    def check_srv6_locator(router, expected_file):
+        func = functools.partial(_check_srv6_locator, router, expected_file)
+        success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
+        assert result is None, "Failed"
+
+    def check_sharpd_chunk(router, expected_file):
+        func = functools.partial(_check_sharpd_chunk, router, expected_file)
+        success, result = topotest.run_and_expect(func, None, count=10, wait=0.5)
+        assert result is None, "Failed"
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Test1 for Locator Configuration")
+    check_srv6_locator(router, "expected_locators1.json")
+    check_sharpd_chunk(router, "expected_chunks1.json")
+
+    logger.info("Test2 get chunk for locator loc1")
+    router.vtysh_cmd("sharp srv6-manager get-locator-chunk loc1")
+    check_srv6_locator(router, "expected_locators2.json")
+    check_sharpd_chunk(router, "expected_chunks2.json")
+
+    logger.info("Test3 release chunk for locator loc1")
+    router.vtysh_cmd("sharp srv6-manager release-locator-chunk loc1")
+    check_srv6_locator(router, "expected_locators3.json")
+    check_sharpd_chunk(router, "expected_chunks3.json")
+
+    logger.info("Test4 additional locator loc3")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            locator loc3
+             prefix 2001:db8:3::/48 block-len 32 node-len 16 func-bits 16
+        """
+    )
+    check_srv6_locator(router, "expected_locators4.json")
+    check_sharpd_chunk(router, "expected_chunks4.json")
+
+    logger.info("Test5 delete locator and chunk is released automatically")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            no locator loc1
+        """
+    )
+    check_srv6_locator(router, "expected_locators5.json")
+    check_sharpd_chunk(router, "expected_chunks5.json")
+
+    logger.info("Test6 delete srv6 all configuration")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          no srv6
+        """
+    )
+    check_srv6_locator(router, "expected_locators6.json")
+    check_sharpd_chunk(router, "expected_chunks6.json")
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_1.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_1.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+[]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_2.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_2.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,8 @@
+[
+  {
+    "name": "loc1",
+    "chunks": [
+      "fc00:0:1::/48"
+    ]
+  }
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_3.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_3.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_3.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_3.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+[]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_4.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_4.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_4.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_4.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1 @@
+[]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_5.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_5.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_5.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_5.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_6.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_6.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_6.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_6.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_7.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_7.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_7.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_7.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_8.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_8.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_chunks_8.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_chunks_8.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+[
+]
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_1.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_1.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_1.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_1.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_2.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_2.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_2.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_2.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "sharp"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_3.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_3.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_3.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_3.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_4.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_4.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_4.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_4.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,35 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "fc00:0:2::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_5.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_5.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_5.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_5.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,36 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "fc00:0:2::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_6.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_6.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_6.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_6.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,35 @@
+{
+  "locators":[
+    {
+      "name": "loc1",
+      "prefix": "fc00:0:1::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "behavior": "usid",
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:1::/48",
+          "proto": "system"
+        }
+      ]
+    },
+    {
+      "name": "loc2",
+      "prefix": "fc00:0:2::/48",
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "statusUp": true,
+      "chunks": [
+        {
+          "prefix": "fc00:0:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_7.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_7.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_7.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_7.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,19 @@
+{
+  "locators":[
+    {
+      "name": "loc2",
+      "prefix": "fc00:0:2::/48",
+      "statusUp": true,
+      "blockBitsLength": 32,
+      "nodeBitsLength": 16,
+      "functionBitsLength": 16,
+      "argumentBitsLength": 0,
+      "chunks":[
+        {
+          "prefix": "fc00:0:2::/48",
+          "proto": "system"
+        }
+      ]
+    }
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_8.json frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_8.json
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/expected_locators_8.json	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/expected_locators_8.json	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,4 @@
+{
+  "locators":[
+  ]
+}
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/setup.sh frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/setup.sh
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/setup.sh	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/setup.sh	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,2 @@
+ip link add dummy0 type dummy
+ip link set dummy0 up
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/sharpd.conf frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/sharpd.conf
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/sharpd.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/sharpd.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,7 @@
+hostname r1
+!
+log stdout notifications
+log monitor notifications
+log commands
+log file sharpd.log debugging
+!
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/zebra.conf frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/zebra.conf
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/r1/zebra.conf	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/r1/zebra.conf	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,20 @@
+hostname r1
+!
+! debug zebra events
+! debug zebra rib detailed
+!
+log stdout notifications
+log monitor notifications
+log commands
+log file zebra.log debugging
+!
+segment-routing
+ srv6
+  locators
+   locator loc1
+    prefix fc00:0:1::/48 block-len 32 node-len 16 func-bits 16
+    behavior usid
+   !
+  !
+ !
+!
diff -urpN frr-frr-8.4.2/tests/topotests/srv6_locator_usid/test_srv6_locator_usid.py frr-frr-8.5/tests/topotests/srv6_locator_usid/test_srv6_locator_usid.py
--- frr-frr-8.4.2/tests/topotests/srv6_locator_usid/test_srv6_locator_usid.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/srv6_locator_usid/test_srv6_locator_usid.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,268 @@
+#!/usr/bin/env python
+
+# Copyright (c) 2022, University of Rome Tor Vergata
+# Authored by Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+"""
+test_srv6_locator_usid.py:
+Test for SRv6 Locator uSID on zebra
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.bgpd, pytest.mark.sharpd]
+
+
+def open_json_file(filename):
+    try:
+        with open(filename, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(filename)
+
+
+def setup_module(mod):
+    tgen = Topogen({None: "r1"}, mod.__name__)
+    tgen.start_topology()
+    for rname, router in tgen.routers().items():
+        router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_SHARP, os.path.join(CWD, "{}/sharpd.conf".format(rname))
+        )
+    tgen.start_router()
+
+
+def teardown_module(mod):
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def _check_srv6_locator(router, expected_locator_file):
+    logger.info("checking zebra locator status")
+    output = json.loads(router.vtysh_cmd("show segment-routing srv6 locator json"))
+    expected = open_json_file("{}/{}".format(CWD, expected_locator_file))
+    return topotest.json_cmp(output, expected)
+
+
+def _check_sharpd_chunk(router, expected_chunk_file):
+    logger.info("checking sharpd locator chunk status")
+    output = json.loads(router.vtysh_cmd("show sharp segment-routing srv6 json"))
+    expected = open_json_file("{}/{}".format(CWD, expected_chunk_file))
+    return topotest.json_cmp(output, expected)
+
+
+def check_srv6_locator(router, expected_file):
+    func = functools.partial(_check_srv6_locator, router, expected_file)
+    success, result = topotest.run_and_expect(func, None, count=5, wait=3)
+    assert result is None, "Failed"
+
+
+def check_sharpd_chunk(router, expected_file):
+    func = functools.partial(_check_sharpd_chunk, router, expected_file)
+    success, result = topotest.run_and_expect(func, None, count=5, wait=3)
+    assert result is None, "Failed"
+
+
+def test_srv6_usid_locator_configuration():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Verify SRv6 Locators instantiated from config file")
+    check_srv6_locator(router, "expected_locators_1.json")
+    check_sharpd_chunk(router, "expected_chunks_1.json")
+
+
+def test_srv6_usid_locator_get_chunk():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Get chunk for the locator loc1")
+    router.vtysh_cmd("sharp srv6-manager get-locator-chunk loc1")
+    check_srv6_locator(router, "expected_locators_2.json")
+    check_sharpd_chunk(router, "expected_chunks_2.json")
+
+
+def test_srv6_usid_locator_release_chunk():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Release chunk for the locator loc1")
+    router.vtysh_cmd("sharp srv6-manager release-locator-chunk loc1")
+    check_srv6_locator(router, "expected_locators_3.json")
+    check_sharpd_chunk(router, "expected_chunks_3.json")
+
+
+def test_srv6_usid_locator_create_locator():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Create an additional SRv6 Locator")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            locator loc2
+             prefix fc00:0:2::/48 block-len 32 node-len 16 func-bits 16
+        """
+    )
+    check_srv6_locator(router, "expected_locators_4.json")
+    check_sharpd_chunk(router, "expected_chunks_4.json")
+
+
+def test_srv6_usid_locator_set_behavior_usid():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Specify the SRv6 Locator loc2 as a Micro-segment (uSID) Locator")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            locator loc2
+             behavior usid
+        """
+    )
+    check_srv6_locator(router, "expected_locators_5.json")
+    check_sharpd_chunk(router, "expected_chunks_5.json")
+
+
+def test_srv6_usid_locator_unset_behavior_usid():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Clear Micro-segment (uSID) Locator flag for loc2")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            locator loc2
+             no behavior usid
+        """
+    )
+    check_srv6_locator(router, "expected_locators_6.json")
+    check_sharpd_chunk(router, "expected_chunks_6.json")
+
+
+def test_srv6_usid_locator_delete():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info(
+        "Delete locator loc1 and verify that the chunk is released automatically"
+    )
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          srv6
+           locators
+            no locator loc1
+        """
+    )
+    check_srv6_locator(router, "expected_locators_7.json")
+    check_sharpd_chunk(router, "expected_chunks_7.json")
+
+
+def test_srv6_usid_locator_delete_all():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Delete all the SRv6 configuration")
+    router.vtysh_cmd(
+        """
+        configure terminal
+         segment-routing
+          no srv6
+        """
+    )
+    check_srv6_locator(router, "expected_locators_8.json")
+    check_sharpd_chunk(router, "expected_chunks_8.json")
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff -urpN frr-frr-8.4.2/tests/topotests/tc_basic/test_tc_basic.py frr-frr-8.5/tests/topotests/tc_basic/test_tc_basic.py
--- frr-frr-8.4.2/tests/topotests/tc_basic/test_tc_basic.py	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tests/topotests/tc_basic/test_tc_basic.py	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,133 @@
+#!/usr/bin/python
+
+#
+# test_tc_basic.py
+#
+# Copyright (c) 2022 by Shichu Yang
+#
+# Permission to use, copy, modify, and/or distribute this software
+# for any purpose with or without fee is hereby granted, provided
+# that the above copyright notice and this permission notice appear
+# in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND NETDEF DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NETDEF BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
+# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+"""
+test_tc_basic.py: Test basic TC filters, classes and qdiscs.
+"""
+import sys
+import os
+import pytest
+import time
+
+# Save the Current Working Directory to find configuration files.
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+sys.path.append(os.path.join(CWD, "../lib/"))
+
+from lib.topogen import Topogen, TopoRouter
+from lib.topolog import logger
+
+pytestmark = [
+    pytest.mark.sharpd
+]
+
+def build_topo(tgen):
+    "Build function"
+
+    r1 = tgen.add_router("r1")
+    r2 = tgen.add_router("r2")
+
+    # Create a p2p connection between r1 and r2
+    tgen.add_link(r1, r2)
+
+    # Create switches with each router connected to it to simulate a empty network.
+    switch = tgen.add_switch("s1")
+    switch.add_link(r1)
+
+    switch = tgen.add_switch("s2")
+    switch.add_link(r2)
+
+# New form of setup/teardown using pytest fixture
+@pytest.fixture(scope="module")
+def tgen(request):
+    "Setup/Teardown the environment and provide tgen argument to tests"
+
+    # This function initiates the topology build with Topogen...
+    tgen = Topogen(build_topo, request.module.__name__)
+
+    # ... and here it calls initialization functions.
+    tgen.start_topology()
+
+    # This is a sample of configuration loading.
+    router_list = tgen.routers()
+
+    # For all routers arrange for:
+    # - starting zebra using config file from <rtrname>/zebra.conf
+    # - starting ospfd using an empty config file.
+    for _, router in router_list.items():
+        router.load_config(TopoRouter.RD_ZEBRA)
+        router.load_config(TopoRouter.RD_SHARP)
+
+    # Start and configure the router daemons
+    tgen.start_router()
+
+    # Provide tgen as argument to each test function
+    yield tgen
+
+    # Teardown after last test runs
+    tgen.stop_topology()
+
+
+# Fixture that executes before each test
+@pytest.fixture(autouse=True)
+def skip_on_failure(tgen):
+    if tgen.routers_have_failure():
+        pytest.skip("skipped because of previous test failure")
+
+def fetch_iproute2_tc_info(r, interface):
+    qdisc = r.cmd("tc qdisc show dev %s" % interface)
+    tclass = r.cmd("tc class show dev %s" % interface)
+    tfilter = r.cmd("tc filter show dev %s" % interface)
+    return qdisc, tclass, tfilter
+
+# ===================
+# The tests functions
+# ===================
+
+def test_tc_basic(tgen):
+    "Test installing one pair of filter & class by sharpd"
+
+    r1 = tgen.gears["r1"]
+    intf = "r1-eth0"
+    r1.vtysh_cmd("sharp tc dev %s source 192.168.100.0/24 destination 192.168.101.0/24 ip-protocol tcp src-port 8000 dst-port 8001 rate 20mbit" % intf)
+
+    time.sleep(3)
+
+    qdisc, tclass, tfilter = fetch_iproute2_tc_info(r1, intf)
+
+    logger.info("tc qdisc on %s: %s", intf, qdisc)
+    logger.info("tc class on %s: %s", intf, tclass)
+    logger.info("tc filter on %s: %s", intf, tfilter)
+
+    assert "htb" in qdisc
+    assert "beef:" in qdisc
+
+    assert "20Mbit" in tclass
+
+    assert "tcp" in tfilter
+    assert "dst_ip 192.168.101.0/24" in tfilter
+    assert "src_ip 192.168.100.0/24" in tfilter
+    assert "dst_port 8001" in tfilter
+    assert "src_port 8000" in tfilter
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
\ No newline at end of file
diff -urpN frr-frr-8.4.2/tests/topotests/zebra_netlink/test_zebra_netlink.py frr-frr-8.5/tests/topotests/zebra_netlink/test_zebra_netlink.py
--- frr-frr-8.4.2/tests/topotests/zebra_netlink/test_zebra_netlink.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/zebra_netlink/test_zebra_netlink.py	2023-03-13 20:01:47.000000000 +0600
@@ -109,7 +109,7 @@ def test_zebra_netlink_batching(tgen):
         pfx = str(ipaddress.ip_network((i, 32)))
         match[pfx] = [dict(entry, prefix=pfx)]
 
-    ok = topotest.router_json_cmp_retry(r1, "show ip route json", match)
+    ok = topotest.router_json_cmp_retry(r1, "show ip route json", match, False, 30)
     assert ok, '"r1" JSON output mismatches'
 
     r1.vtysh_cmd("sharp remove routes 2.1.3.7 " + str(count))
diff -urpN frr-frr-8.4.2/tests/topotests/zebra_rib/test_zebra_rib.py frr-frr-8.5/tests/topotests/zebra_rib/test_zebra_rib.py
--- frr-frr-8.4.2/tests/topotests/zebra_rib/test_zebra_rib.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/zebra_rib/test_zebra_rib.py	2023-03-13 20:01:47.000000000 +0600
@@ -203,7 +203,16 @@ def test_route_map_usage():
     r1.vtysh_cmd("conf\nip route 10.100.100.100/32 192.168.216.3")
     r1.vtysh_cmd("conf\nip route 10.100.100.101/32 10.0.0.44")
     r1.vtysh_cmd("sharp install route 10.0.0.0 nexthop 192.168.216.3 500")
-    sleep(4)
+
+    def check_initial_routes_installed(router):
+        output = json.loads(router.vtysh_cmd("show ip route summ json"))
+        expected = {
+            "routes": [{"type": "static", "rib": 2}, {"type": "sharp", "rib": 500}]
+        }
+        return topotest.json_cmp(output, expected)
+
+    test_func = partial(check_initial_routes_installed, r1)
+    success, result = topotest.run_and_expect(test_func, None, count=40, wait=1)
 
     static_rmapfile = "%s/r1/static_rmap.ref" % (thisDir)
     expected = open(static_rmapfile).read().rstrip()
diff -urpN frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/r1/routes.json frr-frr-8.5/tests/topotests/zebra_seg6local_route/r1/routes.json
--- frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/r1/routes.json	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/zebra_seg6local_route/r1/routes.json	2023-03-13 20:01:47.000000000 +0600
@@ -94,5 +94,30 @@
             "seg6local": { "action": "End.DX4" }
         }]
     }]
+  },
+  {
+    "in": {
+      "dest": "5::1",
+      "context": "End_DT46 10"
+    },
+    "out":[{
+        "prefix":"5::1/128",
+        "protocol":"sharp",
+        "selected":true,
+        "destSelected":true,
+        "distance":150,
+        "metric":0,
+        "installed":true,
+        "table":254,
+        "nexthops":[{
+            "flags":3,
+            "fib":true,
+            "active":true,
+            "directlyConnected":true,
+            "interfaceName": "dum0",
+            "seg6local": { "action": "End.DT46" }
+        }]
+    }],
+    "required_kernel": "5.14"
   }
 ]
diff -urpN frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/r1/setup.sh frr-frr-8.5/tests/topotests/zebra_seg6local_route/r1/setup.sh
--- frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/r1/setup.sh	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/zebra_seg6local_route/r1/setup.sh	2023-03-13 20:01:47.000000000 +0600
@@ -1,3 +1,6 @@
 ip link add dum0 type dummy
 ip link set dum0 up
+ip link add vrf10 type vrf table 10
+ip link set vrf10 up
 sysctl -w net.ipv6.conf.dum0.disable_ipv6=0
+sysctl -w net.vrf.strict_mode=1
diff -urpN frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/test_zebra_seg6local_route.py frr-frr-8.5/tests/topotests/zebra_seg6local_route/test_zebra_seg6local_route.py
--- frr-frr-8.4.2/tests/topotests/zebra_seg6local_route/test_zebra_seg6local_route.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tests/topotests/zebra_seg6local_route/test_zebra_seg6local_route.py	2023-03-13 20:01:47.000000000 +0600
@@ -38,6 +38,7 @@ sys.path.append(os.path.join(CWD, "../")
 from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
 from lib.topolog import logger
+from lib.common_config import required_linux_kernel_version
 
 pytestmark = [pytest.mark.sharpd]
 
@@ -93,6 +94,15 @@ def test_zebra_seg6local_routes():
 
         logger.info("CHECK {} {}".format(dest, context))
 
+        if manifest.get("required_kernel") is not None:
+            if required_linux_kernel_version(manifest["required_kernel"]) is not True:
+                logger.info(
+                    "Kernel requirements are not met. Skipping {} {}".format(
+                        dest, context
+                    )
+                )
+                continue
+
         r1.vtysh_cmd(
             "sharp install seg6local-routes {} nexthop-seg6local dum0 {} 1".format(
                 dest, context
diff -urpN frr-frr-8.4.2/tools/etc/frr/daemons frr-frr-8.5/tools/etc/frr/daemons
--- frr-frr-8.4.2/tools/etc/frr/daemons	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/etc/frr/daemons	2023-03-13 20:01:47.000000000 +0600
@@ -91,6 +91,11 @@ pathd_options="  -A 127.0.0.1"
 #
 #MAX_FDS=1024
 
+# Uncomment this option if you want to run FRR as a non-root user. Note that
+# you should know what you are doing since most of the daemons need root
+# to work. This could be useful if you want to run FRR in a container
+# for instance.
+# FRR_NO_ROOT="yes"
 
 # For any daemon, you can specify a "wrap" command to start instead of starting
 # the daemon directly. This will simply be prepended to the daemon invocation.
diff -urpN frr-frr-8.4.2/tools/etc/frr/support_bundle_commands.conf frr-frr-8.5/tools/etc/frr/support_bundle_commands.conf
--- frr-frr-8.4.2/tools/etc/frr/support_bundle_commands.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/etc/frr/support_bundle_commands.conf	2023-03-13 20:01:47.000000000 +0600
@@ -208,3 +208,34 @@ show ipv6 ospf6 vrf all spf tree
 show ipv6 ospf6 vrf all summary-address detail
 show ipv6 ospf6 zebra
 CMD_LIST_END
+
+#PIMv6 Support Bundle Command List
+PROC_NAME:pim6
+CMD_LIST_START
+show ipv6 pim channel
+show ipv6 pim interface
+show ipv6 pim interface traffic
+show ipv6 pim join
+show ipv6 jp-agg
+show ipv6 pim nexthop
+show ipv6 pim nexthop-lookup
+show ipv6 pim neighbor
+show ipv6 pim local-membership
+show ipv6 pim rp-info
+show ipv6 pim rpf
+show ipv6 pim secondary
+show ipv6 pim state
+show ipv6 pim statistics
+show ipv6 pim upstream
+show ipv6 pim upstream-join-desired
+show ipv6 pim upstream-rpf
+show ipv6 mld interface
+show ipv6 mld statistics
+show ipv6 mld joins
+show ipv6 mld groups
+show ipv6 multicast
+show ipv6 mroute
+show ipv6 pim bsr
+show ipv6 pim bsrp-info
+show ipv6 pim bsm-databases
+CMD_LIST_END
diff -urpN frr-frr-8.4.2/tools/etc/logrotate.d/frr frr-frr-8.5/tools/etc/logrotate.d/frr
--- frr-frr-8.4.2/tools/etc/logrotate.d/frr	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/tools/etc/logrotate.d/frr	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,27 @@
+/var/log/frr/*.log {
+        size 500k
+        sharedscripts
+        missingok
+        compress
+        rotate 14
+        create 0640 frr frr
+
+        postrotate
+            pid=$(lsof -t -a -c /syslog/ /var/log/frr/* 2>/dev/null)
+            if [ -n "$pid" ]
+            then # using syslog
+                 kill -HUP $pid
+            fi
+            # in case using file logging; if switching back and forth
+            # between file and syslog, rsyslogd might still have file
+            # open, as well as the daemons, so always signal the daemons.
+            # It's safe, a NOP if (only) syslog is being used.
+            for i in babeld bgpd eigrpd isisd ldpd nhrpd ospf6d ospfd sharpd \
+                pimd pim6d ripd ripngd zebra pathd pbrd staticd bfdd fabricd vrrpd; do
+                if [ -e /var/run/frr/$i.pid ] ; then
+                    pids="$pids $(cat /var/run/frr/$i.pid)"
+                fi
+            done
+            [ -n "$pids" ] && kill -USR1 $pids || true
+        endscript
+}
diff -urpN frr-frr-8.4.2/tools/etc/rsyslog.d/45-frr.conf frr-frr-8.5/tools/etc/rsyslog.d/45-frr.conf
--- frr-frr-8.4.2/tools/etc/rsyslog.d/45-frr.conf	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/etc/rsyslog.d/45-frr.conf	2023-03-13 20:01:47.000000000 +0600
@@ -17,6 +17,7 @@ if  $programname == 'babeld' or
     $programname == 'pimd' or
     $programname == 'pim6d' or
     $programname == 'pathd' or
+    $programname == 'pbrd' or
     $programname == 'ripd' or
     $programname == 'ripngd' or
     $programname == 'vrrpd' or
@@ -38,6 +39,7 @@ if  $programname == 'babeld' or
     $programname == 'pimd' or
     $programname == 'pim6d' or
     $programname == 'pathd' or
+    $programname == 'pbrd' or
     $programname == 'ripd' or
     $programname == 'ripngd' or
     $programname == 'vrrpd' or
diff -urpN frr-frr-8.4.2/tools/frr-reload.py frr-frr-8.5/tools/frr-reload.py
--- frr-frr-8.4.2/tools/frr-reload.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frr-reload.py	2023-03-13 20:01:47.000000000 +0600
@@ -1914,6 +1914,7 @@ if __name__ == "__main__":
         "bgpd",
         "fabricd",
         "isisd",
+        "babeld",
         "ospf6d",
         "ospfd",
         "pbrd",
@@ -1925,6 +1926,7 @@ if __name__ == "__main__":
         "staticd",
         "vrrpd",
         "ldpd",
+        "nhrpd",
         "pathd",
         "bfdd",
         "eigrpd",
diff -urpN frr-frr-8.4.2/tools/frr.in frr-frr-8.5/tools/frr.in
--- frr-frr-8.4.2/tools/frr.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frr.in	2023-03-13 20:01:47.000000000 +0600
@@ -582,7 +582,7 @@ case "$1" in
 		NEW_CONFIG_FILE="${2:-$C_PATH/frr.conf}"
 		[ ! -r $NEW_CONFIG_FILE ] && echo "Unable to read new configuration file $NEW_CONFIG_FILE" && exit 1
 		echo "Applying only incremental changes to running configuration from frr.conf"
-		"$RELOAD_SCRIPT" --reload $C_PATH/frr.conf
+		"$RELOAD_SCRIPT" --reload --bindir "$D_PATH" --confdir "$C_PATH" --rundir "$V_PATH" "$C_PATH/frr.conf"
 		exit $?
 		;;
 
diff -urpN frr-frr-8.4.2/tools/frr.service.in frr-frr-8.5/tools/frr.service.in
--- frr-frr-8.4.2/tools/frr.service.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frr.service.in	2023-03-13 20:01:47.000000000 +0600
@@ -15,7 +15,7 @@ StartLimitBurst=3
 TimeoutSec=@TIMEOUT_MIN@m
 WatchdogSec=60s
 RestartSec=5
-Restart=on-abnormal
+Restart=always
 LimitNOFILE=1024
 PIDFile=@CFG_STATE@/watchfrr.pid
 ExecStart=@CFG_SBIN@/frrinit.sh start
diff -urpN frr-frr-8.4.2/tools/frr.vim frr-frr-8.5/tools/frr.vim
--- frr-frr-8.4.2/tools/frr.vim	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frr.vim	2023-03-13 20:01:47.000000000 +0600
@@ -34,3 +34,44 @@ endfunction
 
 " auto-apply the above based on path rules
 "autocmd BufRead,BufNewFile /home/.../frr/*.[ch] call CStyleFRR()
+
+" only load xref file once, remember on script-scope
+let s:xrefjson = ""
+let s:xrefpath = ""
+
+" call directly to force reload with :call FRRLoadXrefJson()
+function! FRRLoadXrefJson() abort
+	let s:xrefpath = findfile("frr.xref", ".;")
+	if empty(s:xrefpath)
+		throw "frr.xref JSON file not found in current or parent directories"
+	endif
+	let xreflines = readfile(s:xrefpath)
+	let s:xrefjson = json_decode(join(xreflines, "\n"))
+endfunction
+
+function! FRRXrefJson() abort
+	if empty(s:xrefjson)
+		call FRRLoadXrefJson()
+	endif
+	return s:xrefjson
+endfunction
+
+function! FRRGotoXref(ident) abort
+	let refs = FRRXrefJson()["refs"]
+	if has_key(refs, a:ident)
+		" TODO: in rare cases, one ID may occur in multiple places.
+		" Add some UI for that.  (This happens if the exact same
+		" format string is logged in multiple places in the same
+		" file.)
+		let loc = refs[a:ident][0]
+		let basepath = fnamemodify(s:xrefpath, ":p:h")
+		let path = fnamemodify(basepath . "/" . loc["file"], ":.")
+		execute "e ".fnameescape(path)
+		execute ":".loc["line"]
+	else
+		echoerr printf("cannot find xref with ID %s", a:ident)
+	endif
+endfunction
+
+" invoke as :GotoXref 23456-ABCDE
+command! -bang -nargs=1 GotoXref :call FRRGotoXref(<q-args>)
diff -urpN frr-frr-8.4.2/tools/frr@.service.in frr-frr-8.5/tools/frr@.service.in
--- frr-frr-8.4.2/tools/frr@.service.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frr@.service.in	2023-03-13 20:01:47.000000000 +0600
@@ -15,7 +15,7 @@ StartLimitBurst=3
 TimeoutSec=@TIMEOUT_MIN@m
 WatchdogSec=60s
 RestartSec=5
-Restart=on-abnormal
+Restart=always
 LimitNOFILE=1024
 PIDFile=@CFG_STATE@/%I/watchfrr.pid
 ExecStart=@CFG_SBIN@/frrinit.sh start %I
diff -urpN frr-frr-8.4.2/tools/frrcommon.sh.in frr-frr-8.5/tools/frrcommon.sh.in
--- frr-frr-8.4.2/tools/frrcommon.sh.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frrcommon.sh.in	2023-03-13 20:01:47.000000000 +0600
@@ -43,6 +43,10 @@ RELOAD_SCRIPT="$D_PATH/frr-reload.py"
 #
 
 is_user_root () {
+	if [[ ! -z $FRR_NO_ROOT  &&  "${FRR_NO_ROOT}" == "yes" ]]; then
+		return 0
+	fi
+
 	[ "${EUID:-$(id -u)}" -eq 0 ] || {
 		log_failure_msg "Only users having EUID=0 can start/stop daemons"
 		return 1
@@ -262,7 +266,7 @@ all_start() {
 }
 
 all_stop() {
-	local pids reversed need_zebra
+	local pids reversed
 
 	daemon_list enabled_daemons disabled_daemons
 	[ "$1" = "--reallyall" ] && enabled_daemons="$enabled_daemons $disabled_daemons"
@@ -272,23 +276,13 @@ all_stop() {
 		reversed="$dmninst $reversed"
 	done
 
-	# Stop zebra last, after trying to stop the other daemons
 	for dmninst in $reversed; do
-		if [ "$dmninst" = "zebra" ]; then
-			need_zebra="yes"
-			continue
-		fi
-
 		daemon_stop "$dmninst" "$1" &
 		pids="$pids $!"
 	done
 	for pid in $pids; do
 		wait $pid
 	done
-
-	if [ -n "$need_zebra" ]; then
-		daemon_stop "zebra"
-	fi
 }
 
 all_status() {
diff -urpN frr-frr-8.4.2/tools/frrinit.sh.in frr-frr-8.5/tools/frrinit.sh.in
--- frr-frr-8.4.2/tools/frrinit.sh.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/frrinit.sh.in	2023-03-13 20:01:47.000000000 +0600
@@ -122,7 +122,7 @@ reload)
 
 	NEW_CONFIG_FILE="${2:-$C_PATH/frr.conf}"
 	[ ! -r $NEW_CONFIG_FILE ] && log_failure_msg "Unable to read new configuration file $NEW_CONFIG_FILE" && exit 1
-	"$RELOAD_SCRIPT" --reload "$NEW_CONFIG_FILE" `echo $nsopt`
+	"$RELOAD_SCRIPT" --reload --bindir "$D_PATH" --confdir "$C_PATH" --rundir "$V_PATH" "$NEW_CONFIG_FILE" `echo $nsopt`
 	exit $?
 	;;
 
diff -urpN frr-frr-8.4.2/tools/permutations.c frr-frr-8.5/tools/permutations.c
--- frr-frr-8.4.2/tools/permutations.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/tools/permutations.c	2023-03-13 20:01:47.000000000 +0600
@@ -80,8 +80,7 @@ void permute(struct graph_node *start)
 	for (unsigned int i = 0; i < vector_active(start->to); i++) {
 		struct graph_node *gn = vector_slot(start->to, i);
 		struct cmd_token *tok = gn->data;
-		if (tok->attr == CMD_ATTR_HIDDEN
-		    || tok->attr == CMD_ATTR_DEPRECATED)
+		if (tok->attr & CMD_ATTR_HIDDEN)
 			continue;
 		else if (tok->type == END_TKN || gn == start) {
 			fprintf(stdout, " ");
diff -urpN frr-frr-8.4.2/vrrpd/subdir.am frr-frr-8.5/vrrpd/subdir.am
--- frr-frr-8.4.2/vrrpd/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,7 +4,6 @@
 
 if VRRPD
 sbin_PROGRAMS += vrrpd/vrrpd
-vtysh_scan += vrrpd/vrrp_vty.c
 vtysh_daemons += vrrpd
 man8 += $(MANBUILD)/frr-vrrpd.8
 endif
diff -urpN frr-frr-8.4.2/vrrpd/vrrp.c frr-frr-8.5/vrrpd/vrrp.c
--- frr-frr-8.4.2/vrrpd/vrrp.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp.c	2023-03-13 20:01:47.000000000 +0600
@@ -647,6 +647,8 @@ struct vrrp_vrouter *vrrp_vrouter_create
 	vr->priority = vd.priority;
 	vr->preempt_mode = vd.preempt_mode;
 	vr->accept_mode = vd.accept_mode;
+	vr->checksum_with_ipv4_pseudoheader =
+		vd.checksum_with_ipv4_pseudoheader;
 	vr->shutdown = vd.shutdown;
 
 	vr->v4 = vrrp_router_create(vr, AF_INET);
@@ -669,6 +671,9 @@ void vrrp_vrouter_destroy(struct vrrp_vr
 
 struct vrrp_vrouter *vrrp_lookup(const struct interface *ifp, uint8_t vrid)
 {
+	if (!ifp)
+		return NULL;
+
 	struct vrrp_vrouter vr;
 
 	vr.vrid = vrid;
@@ -789,7 +794,8 @@ static void vrrp_send_advertisement(stru
 
 	pktsz = vrrp_pkt_adver_build(&pkt, &r->src, r->vr->version, r->vr->vrid,
 				     r->priority, r->vr->advertisement_interval,
-				     r->addrs->count, (struct ipaddr **)&addrs);
+				     r->addrs->count, (struct ipaddr **)&addrs,
+				     r->vr->checksum_with_ipv4_pseudoheader);
 
 	if (DEBUG_MODE_CHECK(&vrrp_dbg_pkt, DEBUG_MODE_ALL))
 		zlog_hexdump(pkt, (size_t)pktsz);
@@ -1027,8 +1033,10 @@ static void vrrp_read(struct thread *thr
 		zlog_hexdump(r->ibuf, nbytes);
 	}
 
-	pktsize = vrrp_pkt_parse_datagram(r->family, r->vr->version, &m, nbytes,
-					  &src, &pkt, errbuf, sizeof(errbuf));
+	pktsize = vrrp_pkt_parse_datagram(
+		r->family, r->vr->version,
+		r->vr->checksum_with_ipv4_pseudoheader, &m, nbytes, &src, &pkt,
+		errbuf, sizeof(errbuf));
 
 	if (pktsize < 0)
 		DEBUGD(&vrrp_dbg_pkt,
@@ -2347,6 +2355,12 @@ int vrrp_config_write_global(struct vty
 		vty_out(vty, "%svrrp default accept\n",
 			!vd.accept_mode ? "no " : "");
 
+	if (vd.checksum_with_ipv4_pseudoheader !=
+		    VRRP_DEFAULT_CHECKSUM_WITH_IPV4_PSEUDOHEADER &&
+	    ++writes)
+		vty_out(vty, "%svrrp default checksum-with-ipv4-pseudoheader\n",
+			!vd.checksum_with_ipv4_pseudoheader ? "no " : "");
+
 	if (vd.shutdown != VRRP_DEFAULT_SHUTDOWN && ++writes)
 		vty_out(vty, "%svrrp default shutdown\n",
 			!vd.shutdown ? "no " : "");
@@ -2387,6 +2401,8 @@ void vrrp_init(void)
 	vd.preempt_mode = yang_get_default_bool("%s/preempt", VRRP_XPATH_FULL);
 	vd.accept_mode =
 		yang_get_default_bool("%s/accept-mode", VRRP_XPATH_FULL);
+	vd.checksum_with_ipv4_pseudoheader = yang_get_default_bool(
+		"%s/checksum-with-ipv4-pseudoheader", VRRP_XPATH_FULL);
 	vd.shutdown = VRRP_DEFAULT_SHUTDOWN;
 
 	vrrp_autoconfig_version = 3;
diff -urpN frr-frr-8.4.2/vrrpd/vrrp.h frr-frr-8.5/vrrpd/vrrp.h
--- frr-frr-8.4.2/vrrpd/vrrp.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp.h	2023-03-13 20:01:47.000000000 +0600
@@ -53,6 +53,7 @@
 #define VRRP_DEFAULT_ADVINT 100
 #define VRRP_DEFAULT_PREEMPT true
 #define VRRP_DEFAULT_ACCEPT true
+#define VRRP_DEFAULT_CHECKSUM_WITH_IPV4_PSEUDOHEADER true
 #define VRRP_DEFAULT_SHUTDOWN false
 
 /* User compatibility constant */
@@ -70,6 +71,7 @@ struct vrrp_defaults {
 	uint16_t advertisement_interval;
 	bool preempt_mode;
 	bool accept_mode;
+	bool checksum_with_ipv4_pseudoheader;
 	bool shutdown;
 };
 
@@ -266,6 +268,14 @@ struct vrrp_vrouter {
 	 */
 	bool accept_mode;
 
+	/*
+	 * Indicates whether this router computes and accepts VRRPv3 checksums
+	 * without pseudoheader, for device interoperability.
+	 *
+	 * This option should only affect IPv4 virtual routers.
+	 */
+	bool checksum_with_ipv4_pseudoheader;
+
 	struct vrrp_router *v4;
 	struct vrrp_router *v6;
 };
diff -urpN frr-frr-8.4.2/vrrpd/vrrp_northbound.c frr-frr-8.5/vrrpd/vrrp_northbound.c
--- frr-frr-8.4.2/vrrpd/vrrp_northbound.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp_northbound.c	2023-03-13 20:01:47.000000000 +0600
@@ -602,6 +602,26 @@ lib_interface_vrrp_vrrp_group_shutdown_m
 	return NB_OK;
 }
 
+/*
+ * XPath: /frr-interface:lib/interface/frr-vrrpd:vrrp/vrrp-group/checksum-with-
+ *        ipv4-pseudoheader
+ */
+static int lib_interface_vrrp_vrrp_group_checksum_with_ipv4_pseudoheader_modify(
+	struct nb_cb_modify_args *args)
+{
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	struct vrrp_vrouter *vr;
+	bool checksum_with_ipv4_ph;
+
+	vr = nb_running_get_entry(args->dnode, NULL, true);
+	checksum_with_ipv4_ph = yang_dnode_get_bool(args->dnode, NULL);
+	vr->checksum_with_ipv4_pseudoheader = checksum_with_ipv4_ph;
+
+	return NB_OK;
+}
+
 /* clang-format off */
 const struct frr_yang_module_info frr_vrrpd_info = {
 	.name = "frr-vrrpd",
@@ -644,6 +664,13 @@ const struct frr_yang_module_info frr_vr
 			}
 		},
 		{
+			.xpath = "/frr-interface:lib/interface/frr-vrrpd:vrrp/vrrp-group/checksum-with-ipv4-pseudoheader",
+			.cbs = {
+				.modify = lib_interface_vrrp_vrrp_group_checksum_with_ipv4_pseudoheader_modify,
+				.cli_show = cli_show_checksum_with_ipv4_pseudoheader,
+			}
+		},
+		{
 			.xpath = "/frr-interface:lib/interface/frr-vrrpd:vrrp/vrrp-group/advertisement-interval",
 			.cbs = {
 				.modify = lib_interface_vrrp_vrrp_group_advertisement_interval_modify,
diff -urpN frr-frr-8.4.2/vrrpd/vrrp_packet.c frr-frr-8.5/vrrpd/vrrp_packet.c
--- frr-frr-8.4.2/vrrpd/vrrp_packet.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp_packet.c	2023-03-13 20:01:47.000000000 +0600
@@ -71,7 +71,7 @@ static const char *const vrrp_packet_nam
  *    VRRP checksum in network byte order.
  */
 static uint16_t vrrp_pkt_checksum(struct vrrp_pkt *pkt, size_t pktsize,
-				  struct ipaddr *src)
+				  struct ipaddr *src, bool ipv4_ph)
 {
 	uint16_t chksum;
 	bool v6 = (src->ipa_type == IPADDR_V6);
@@ -89,13 +89,16 @@ static uint16_t vrrp_pkt_checksum(struct
 		ph.next_hdr = IPPROTO_VRRP;
 		chksum = in_cksum_with_ph6(&ph, pkt, pktsize);
 	} else if (!v6 && ((pkt->hdr.vertype >> 4) == 3)) {
-		struct ipv4_ph ph = {};
+		if (ipv4_ph) {
+			struct ipv4_ph ph = {};
 
-		ph.src = src->ipaddr_v4;
-		inet_pton(AF_INET, VRRP_MCASTV4_GROUP_STR, &ph.dst);
-		ph.proto = IPPROTO_VRRP;
-		ph.len = htons(pktsize);
-		chksum = in_cksum_with_ph4(&ph, pkt, pktsize);
+			ph.src = src->ipaddr_v4;
+			inet_pton(AF_INET, VRRP_MCASTV4_GROUP_STR, &ph.dst);
+			ph.proto = IPPROTO_VRRP;
+			ph.len = htons(pktsize);
+			chksum = in_cksum_with_ph4(&ph, pkt, pktsize);
+		} else
+			chksum = in_cksum(pkt, pktsize);
 	} else if (!v6 && ((pkt->hdr.vertype >> 4) == 2)) {
 		chksum = in_cksum(pkt, pktsize);
 	} else {
@@ -110,7 +113,7 @@ static uint16_t vrrp_pkt_checksum(struct
 ssize_t vrrp_pkt_adver_build(struct vrrp_pkt **pkt, struct ipaddr *src,
 			     uint8_t version, uint8_t vrid, uint8_t prio,
 			     uint16_t max_adver_int, uint8_t numip,
-			     struct ipaddr **ips)
+			     struct ipaddr **ips, bool ipv4_ph)
 {
 	bool v6 = false;
 	size_t addrsz = 0;
@@ -147,7 +150,7 @@ ssize_t vrrp_pkt_adver_build(struct vrrp
 		aptr += addrsz;
 	}
 
-	(*pkt)->hdr.chksum = vrrp_pkt_checksum(*pkt, pktsize, src);
+	(*pkt)->hdr.chksum = vrrp_pkt_checksum(*pkt, pktsize, src, ipv4_ph);
 
 	return pktsize;
 }
@@ -188,10 +191,10 @@ size_t vrrp_pkt_adver_dump(char *buf, si
 	return rs;
 }
 
-ssize_t vrrp_pkt_parse_datagram(int family, int version, struct msghdr *m,
-				size_t read, struct ipaddr *src,
-				struct vrrp_pkt **pkt, char *errmsg,
-				size_t errmsg_len)
+ssize_t vrrp_pkt_parse_datagram(int family, int version, bool ipv4_ph,
+				struct msghdr *m, size_t read,
+				struct ipaddr *src, struct vrrp_pkt **pkt,
+				char *errmsg, size_t errmsg_len)
 {
 	/* Source (MAC & IP), Dest (MAC & IP) TTL validation done by kernel */
 	size_t addrsz = (family == AF_INET) ? sizeof(struct in_addr)
@@ -289,7 +292,7 @@ ssize_t vrrp_pkt_parse_datagram(int fami
 	VRRP_PKT_VCHECK(pktver == version, "Bad version %u", pktver);
 
 	/* Checksum check */
-	uint16_t chksum = vrrp_pkt_checksum(*pkt, pktsize, src);
+	uint16_t chksum = vrrp_pkt_checksum(*pkt, pktsize, src, ipv4_ph);
 
 	VRRP_PKT_VCHECK((*pkt)->hdr.chksum == chksum,
 			"Bad VRRP checksum %hx; should be %hx",
diff -urpN frr-frr-8.4.2/vrrpd/vrrp_packet.h frr-frr-8.5/vrrpd/vrrp_packet.h
--- frr-frr-8.4.2/vrrpd/vrrp_packet.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp_packet.h	2023-03-13 20:01:47.000000000 +0600
@@ -131,7 +131,7 @@ struct vrrp_pkt {
 ssize_t vrrp_pkt_adver_build(struct vrrp_pkt **pkt, struct ipaddr *src,
 			     uint8_t version, uint8_t vrid, uint8_t prio,
 			     uint16_t max_adver_int, uint8_t numip,
-			     struct ipaddr **ips);
+			     struct ipaddr **ips, bool ipv4_ph);
 
 /* free memory allocated by vrrp_pkt_adver_build's pkt arg */
 void vrrp_pkt_free(struct vrrp_pkt *pkt);
@@ -195,9 +195,9 @@ size_t vrrp_pkt_adver_dump(char *buf, si
  * Returns:
  *    Size of VRRP packet, or -1 upon error
  */
-ssize_t vrrp_pkt_parse_datagram(int family, int version, struct msghdr *m,
-				size_t read, struct ipaddr *src,
-				struct vrrp_pkt **pkt, char *errmsg,
-				size_t errmsg_len);
+ssize_t vrrp_pkt_parse_datagram(int family, int version, bool ipv4_ph,
+				struct msghdr *m, size_t read,
+				struct ipaddr *src, struct vrrp_pkt **pkt,
+				char *errmsg, size_t errmsg_len);
 
 #endif /* __VRRP_PACKET_H__ */
diff -urpN frr-frr-8.4.2/vrrpd/vrrp_vty.c frr-frr-8.5/vrrpd/vrrp_vty.c
--- frr-frr-8.4.2/vrrpd/vrrp_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -33,9 +33,7 @@
 #include "vrrp_debug.h"
 #include "vrrp_vty.h"
 #include "vrrp_zebra.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "vrrpd/vrrp_vty_clippy.c"
-#endif
 
 
 #define VRRP_STR "Virtual Router Redundancy Protocol\n"
@@ -121,7 +119,7 @@ DEFPY_YANG(vrrp_priority,
       VRRP_STR
       VRRP_VRID_STR
       VRRP_PRIORITY_STR
-      "Priority value")
+      "Priority value\n")
 {
 	nb_cli_enqueue_change(vty, "./priority", NB_OP_MODIFY, priority_str);
 
@@ -138,7 +136,7 @@ DEFPY_YANG(no_vrrp_priority,
       VRRP_STR
       VRRP_VRID_STR
       VRRP_PRIORITY_STR
-      "Priority value")
+      "Priority value\n")
 {
 	nb_cli_enqueue_change(vty, "./priority", NB_OP_MODIFY, NULL);
 
@@ -162,7 +160,7 @@ DEFPY_YANG(vrrp_advertisement_interval,
       vrrp_advertisement_interval_cmd,
       "vrrp (1-255)$vrid advertisement-interval (10-40950)",
       VRRP_STR VRRP_VRID_STR VRRP_ADVINT_STR
-      "Advertisement interval in milliseconds; must be multiple of 10")
+      "Advertisement interval in milliseconds; must be multiple of 10\n")
 {
 	char val[20];
 
@@ -183,7 +181,7 @@ DEFPY_YANG(no_vrrp_advertisement_interva
       no_vrrp_advertisement_interval_cmd,
       "no vrrp (1-255)$vrid advertisement-interval [(10-40950)]",
       NO_STR VRRP_STR VRRP_VRID_STR VRRP_ADVINT_STR
-      "Advertisement interval in milliseconds; must be multiple of 10")
+      "Advertisement interval in milliseconds; must be multiple of 10\n")
 {
 	nb_cli_enqueue_change(vty, "./advertisement-interval", NB_OP_MODIFY,
 			      NULL);
@@ -283,6 +281,35 @@ void cli_show_preempt(struct vty *vty, c
 	vty_out(vty, " %svrrp %s preempt\n", pre ? "" : "no ", vrid);
 }
 
+/*
+ * XPath: /frr-interface:lib/interface/frr-vrrpd:vrrp/vrrp-group/checksum-with-
+ *        ipv4-pseudoheader
+ */
+DEFPY_YANG(vrrp_checksum_with_ipv4_pseudoheader,
+      vrrp_checksum_with_ipv4_pseudoheader_cmd,
+      "[no] vrrp (1-255)$vrid checksum-with-ipv4-pseudoheader",
+      NO_STR
+      VRRP_STR
+      VRRP_VRID_STR
+      "Checksum mode in VRRPv3\n")
+{
+	nb_cli_enqueue_change(vty, "./checksum-with-ipv4-pseudoheader",
+			      NB_OP_MODIFY, no ? "false" : "true");
+
+	return nb_cli_apply_changes(vty, VRRP_XPATH_ENTRY, vrid);
+}
+
+void cli_show_checksum_with_ipv4_pseudoheader(struct vty *vty,
+					      const struct lyd_node *dnode,
+					      bool show_defaults)
+{
+	const char *vrid = yang_dnode_get_string(dnode, "../virtual-router-id");
+	const bool pre = yang_dnode_get_bool(dnode, NULL);
+
+	vty_out(vty, " %svrrp %s checksum-with-ipv4-pseudoheader\n",
+		pre ? "" : "no ", vrid);
+}
+
 /* XXX: yang conversion */
 DEFPY_YANG(vrrp_autoconfigure,
       vrrp_autoconfigure_cmd,
@@ -306,7 +333,7 @@ DEFPY_YANG(vrrp_autoconfigure,
 /* XXX: yang conversion */
 DEFPY_YANG(vrrp_default,
       vrrp_default_cmd,
-      "[no] vrrp default <advertisement-interval$adv (10-40950)$advint|preempt$p|priority$prio (1-254)$prioval|shutdown$s>",
+      "[no] vrrp default <advertisement-interval$adv (10-40950)$advint|preempt$p|priority$prio (1-254)$prioval|checksum-with-ipv4-pseudoheader$ipv4ph|shutdown$s>",
       NO_STR
       VRRP_STR
       "Configure defaults for new VRRP instances\n"
@@ -315,6 +342,7 @@ DEFPY_YANG(vrrp_default,
       "Preempt mode\n"
       VRRP_PRIORITY_STR
       "Priority value\n"
+      "Checksum mode in VRRPv3\n"
       "Force VRRP router into administrative shutdown\n")
 {
 	if (adv) {
@@ -331,6 +359,8 @@ DEFPY_YANG(vrrp_default,
 		vd.preempt_mode = !no;
 	if (prio)
 		vd.priority = no ? VRRP_DEFAULT_PRIORITY : prioval;
+	if (ipv4ph)
+		vd.checksum_with_ipv4_pseudoheader = !no;
 	if (s)
 		vd.shutdown = !no;
 
@@ -376,6 +406,8 @@ static struct json_object *vrrp_build_js
 	json_object_boolean_add(j, "shutdown", vr->shutdown);
 	json_object_boolean_add(j, "preemptMode", vr->preempt_mode);
 	json_object_boolean_add(j, "acceptMode", vr->accept_mode);
+	json_object_boolean_add(j, "checksumWithIpv4Pseudoheader",
+				vr->checksum_with_ipv4_pseudoheader);
 	json_object_string_add(j, "interface", vr->ifp->name);
 	json_object_int_add(j, "advertisementInterval",
 			    vr->advertisement_interval * CS2MS);
@@ -501,6 +533,8 @@ static void vrrp_show(struct vty *vty, s
 		       vr->preempt_mode ? "Yes" : "No");
 	ttable_add_row(tt, "%s|%s", "Accept Mode",
 		       vr->accept_mode ? "Yes" : "No");
+	ttable_add_row(tt, "%s|%s", "Checksum with IPv4 Pseudoheader",
+		       vr->checksum_with_ipv4_pseudoheader ? "Yes" : "No");
 	ttable_add_row(tt, "%s|%d ms", "Advertisement Interval",
 		       vr->advertisement_interval * CS2MS);
 	ttable_add_row(tt, "%s|%d ms (stale)",
@@ -710,6 +744,8 @@ DEFUN_NOSH (show_debugging_vrrp,
 
 	vrrp_debug_status_write(vty);
 
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -752,4 +788,6 @@ void vrrp_vty_init(void)
 	install_element(INTERFACE_NODE, &vrrp_ip_cmd);
 	install_element(INTERFACE_NODE, &vrrp_ip6_cmd);
 	install_element(INTERFACE_NODE, &vrrp_preempt_cmd);
+	install_element(INTERFACE_NODE,
+			&vrrp_checksum_with_ipv4_pseudoheader_cmd);
 }
diff -urpN frr-frr-8.4.2/vrrpd/vrrp_vty.h frr-frr-8.5/vrrpd/vrrp_vty.h
--- frr-frr-8.4.2/vrrpd/vrrp_vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vrrpd/vrrp_vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -40,5 +40,8 @@ void cli_show_ipv6(struct vty *vty, cons
 		   bool show_defaults);
 void cli_show_preempt(struct vty *vty, const struct lyd_node *dnode,
 		      bool show_defaults);
+void cli_show_checksum_with_ipv4_pseudoheader(struct vty *vty,
+					      const struct lyd_node *dnode,
+					      bool show_defaults);
 
 #endif /* __VRRP_VTY_H__ */
diff -urpN frr-frr-8.4.2/vtysh/.gitignore frr-frr-8.5/vtysh/.gitignore
--- frr-frr-8.4.2/vtysh/.gitignore	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/.gitignore	2023-03-13 20:01:47.000000000 +0600
@@ -1,4 +1,6 @@
 vtysh
 vtysh_cmd.c
-extract.pl
 vtysh_daemons.h
+
+# does not exist anymore - remove 2023-10-04 or so
+extract.pl
diff -urpN frr-frr-8.4.2/vtysh/extract.pl.in frr-frr-8.5/vtysh/extract.pl.in
--- frr-frr-8.4.2/vtysh/extract.pl.in	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/extract.pl.in	1970-01-01 06:00:00.000000000 +0600
@@ -1,282 +0,0 @@
-#! @PERL@
-##
-## @configure_input@
-##
-## Virtual terminal interface shell command extractor.
-## Copyright (C) 2000 Kunihiro Ishiguro
-## 
-## This file is part of GNU Zebra.
-## 
-## GNU Zebra is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-## 
-## GNU Zebra is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-## 
-## You should have received a copy of the GNU General Public License
-## along with GNU Zebra; see the file COPYING.  If not, write to the Free
-## Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-## 02111-1307, USA.  
-##
-
-use Getopt::Long;
-
-print <<EOF;
-#include <zebra.h>
-
-#include "command.h"
-#include "linklist.h"
-
-#include "vtysh/vtysh.h"
-
-EOF
-
-my $cli_stomp = 0;
-
-sub scan_file {
-    my ( $file, $fabricd) = @_;
-
-    $cppadd = $fabricd ? "-DFABRICD=1" : "";
-
-    $command_line = "@CPP@ -P -std=gnu11 -DHAVE_CONFIG_H -DVTYSH_EXTRACT_PL -Ivtysh/@top_builddir@ -Ivtysh/@top_srcdir@ -Ivtysh/@top_srcdir@/lib -Ivtysh/@top_builddir@/lib -Ivtysh/@top_srcdir@/bgpd -Ivtysh/@top_srcdir@/bgpd/rfapi @LUA_INCLUDE@ @CPPFLAGS@ @LIBYANG_CFLAGS@ $cppadd $file |";
-    open (FH, $command_line)
-	|| die "Open to the pipeline failed: $!\n\nCommand Issued:\n$command_line";
-    local $/; undef $/;
-    $line = <FH>;
-    if (!close (FH)) {
-	die "File: $file failed to compile:\n$!\nwhen extracting cli from it please inspect\n"
-    }
-
-    # ?: makes a group non-capturing
-    @defun = ($line =~ /((?:DEFUN|DEFUN_HIDDEN|DEFUN_YANG|ALIAS|ALIAS_HIDDEN|ALIAS_YANG|DEFPY|DEFPY_HIDDEN|DEFPY_YANG)\s*\(.+?\));?\s?\s?\n/sg);
-    @install = ($line =~ /install_element\s*\(\s*[0-9A-Z_]+,\s*&[^;]*;\s*\n/sg);
-
-    # DEFUN process
-    foreach (@defun) {
-        # $_ will contain the entire string including the DEFUN, ALIAS, etc.
-        # We need to extract the DEFUN/ALIAS from everything in ()s.
-        # The /s at the end tells the regex to allow . to match newlines.
-        $_ =~ /^(.*?)\s*\((.*)\)$/s;
-
-        my (@defun_array);
-        $defun_or_alias = $1;
-        @defun_array = split (/,/, $2);
-
-        if ($defun_or_alias =~ /_HIDDEN/) {
-            $hidden = 1;
-        } else {
-            $hidden = 0;
-        }
-
-        $defun_array[0] = '';
-
-        # Actual input command string.
-        $str = "$defun_array[2]";
-        $str =~ s/^\s+//g;
-        $str =~ s/\s+$//g;
-
-        # Get VTY command structure.  This is needed for searching
-        # install_element() command.
-        $cmd = "$defun_array[1]";
-        $cmd =~ s/^\s+//g;
-        $cmd =~ s/\s+$//g;
-
-        if ($fabricd) {
-            $cmd = "fabricd_" . $cmd;
-        }
-
-        # $protocol is VTYSH_PROTO format for redirection of user input
-        if ($file =~ /lib\/keychain\.c$/) {
-            $protocol = "VTYSH_RIPD|VTYSH_EIGRPD|VTYSH_OSPF6D";
-        }
-        elsif ($file =~ /lib\/routemap\.c$/ || $file =~ /lib\/routemap_cli\.c$/) {
-            $protocol = "VTYSH_RMAP";
-        }
-        elsif ($file =~ /lib\/vrf\.c$/) {
-            $protocol = "VTYSH_VRF";
-        }
-        elsif ($file =~ /lib\/if\.c$/) {
-            $protocol = "VTYSH_INTERFACE";
-        }
-        elsif ($file =~ /lib\/(filter|filter_cli)\.c$/) {
-            $protocol = "VTYSH_ACL";
-        }
-        elsif ($file =~ /lib\/(lib|log)_vty\.c$/) {
-            $protocol = "VTYSH_ALL";
-        }
-	elsif ($file =~ /lib\/agentx\.c$/) {
-	    $protocol = "VTYSH_ISISD|VTYSH_RIPD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ZEBRA";
-	}
-	elsif ($file =~ /lib\/nexthop_group\.c$/) {
-	    $protocol = "VTYSH_NH_GROUP";
-	}
-        elsif ($file =~ /lib\/plist\.c$/) {
-            if ($defun_array[1] =~ m/ipv6/) {
-                $protocol = "VTYSH_RIPNGD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ZEBRA|VTYSH_PIM6D|VTYSH_BABELD|VTYSH_ISISD|VTYSH_FABRICD";
-            } else {
-                $protocol = "VTYSH_RIPD|VTYSH_OSPFD|VTYSH_BGPD|VTYSH_ZEBRA|VTYSH_PIMD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_ISISD|VTYSH_FABRICD";
-            }
-        }
-        elsif ($file =~ /lib\/if_rmap\.c$/) {
-            if ($defun_array[1] =~ m/ipv6/) {
-                $protocol = "VTYSH_RIPNGD";
-            } else {
-                $protocol = "VTYSH_RIPD";
-            }
-        }
-	elsif ($file =~ /lib\/resolver\.c$/) {
-	    $protocol = "VTYSH_NHRPD|VTYSH_BGPD";
-	}
-	elsif ($file =~ /lib\/spf_backoff\.c$/) {
-	    $protocol = "VTYSH_ISISD";
-	}
-        elsif ($file =~ /lib\/(vty|thread)\.c$/) {
-           $protocol = "VTYSH_ALL";
-        }
-        elsif ($file =~ /librfp\/.*\.c$/ || $file =~ /rfapi\/.*\.c$/) {
-           $protocol = "VTYSH_BGPD";
-        }
-        elsif ($fabricd) {
-           $protocol = "VTYSH_FABRICD";
-        }
-        elsif ($file =~ /pimd\/pim6_.*\.c$/) {
-           $protocol = "VTYSH_PIM6D";
-        }
-        else {
-           ($protocol) = ($file =~ /^(?:.*\/)?([a-z0-9]+)\/[a-zA-Z0-9_\-]+\.c$/);
-           $protocol = "VTYSH_" . uc $protocol;
-        }
-
-        # Append _vtysh to structure then build DEFUN again
-        $defun_array[1] = $cmd . "_vtysh";
-        $defun_body = join (", ", @defun_array);
-
-	# $cmd -> $str hash for lookup
-	if (exists($cmd2str{$cmd})) {
-	    warn "Duplicate CLI Function: $cmd\n";
-	    warn "\tFrom cli: $cmd2str{$cmd} to New cli: $str\n";
-	    warn "\tOriginal Protocol: $cmd2proto{$cmd} to New Protocol: $protocol\n";
-	    $cli_stomp++;
-	}
-        $cmd2str{$cmd} = $str;
-        $cmd2defun{$cmd} = $defun_body;
-        $cmd2proto{$cmd} = $protocol;
-        $cmd2hidden{$cmd} = $hidden;
-    }
-
-    # install_element() process
-    foreach (@install) {
-        my (@element_array);
-        @element_array = split (/,/);
-
-        # Install node
-        $enode = $element_array[0];
-        $enode =~ s/^\s+//g;
-        $enode =~ s/\s+$//g;
-        ($enode) = ($enode =~ /([0-9A-Z_]+)$/);
-
-        # VTY command structure.
-        ($ecmd) = ($element_array[1] =~ /&([^\)]+)/);
-        $ecmd =~ s/^\s+//g;
-        $ecmd =~ s/\s+$//g;
-
-        if ($fabricd) {
-            $ecmd = "fabricd_" . $ecmd;
-        }
-
-        # Register $ecmd
-        if (defined ($cmd2str{$ecmd})) {
-            my ($key);
-            $key = $enode . "," . $cmd2str{$ecmd};
-            $ocmd{$key} = $ecmd;
-            $odefun{$key} = $cmd2defun{$ecmd};
-
-            if ($cmd2hidden{$ecmd}) {
-                $defsh{$key} = "DEFSH_HIDDEN"
-            } else {
-                $defsh{$key} = "DEFSH"
-            }
-            push (@{$oproto{$key}}, $cmd2proto{$ecmd});
-        }
-    }
-}
-
-my $have_isisd = 0;
-my $have_fabricd = 0;
-
-GetOptions('have-isisd' => \$have_isisd, 'have-fabricd' => \$have_fabricd);
-
-foreach (@ARGV) {
-    if (/(^|\/)isisd\//) {
-        # We scan all the IS-IS files twice, once for isisd,
-        # once for fabricd. Exceptions are made for the files
-        # that are not shared between the two.
-        if (/isis_vty_isisd.c/) {
-            if ( $have_isisd ) {
-                scan_file($_, 0);
-            }
-        } elsif (/isis_vty_fabricd.c/) {
-            if ( $have_fabricd ) {
-                scan_file($_, 1);
-            }
-        } else {
-            if ( $have_isisd ) {
-                scan_file($_, 0);
-            }
-            if ( $have_fabricd ) {
-                scan_file($_, 1);
-            }
-        }
-    } else {
-        scan_file($_, 0);
-    }
-}
-
-# When we have cli commands that map to the same function name, we
-# can introduce subtle bugs due to code not being called when
-# we think it is.
-#
-# If extract.pl fails with a error message and you've been
-# modifying the cli, then go back and fix your code to
-# not have cli command function collisions.
-# please fix your code before submittal
-if ($cli_stomp) {
-    warn "There are $cli_stomp command line stomps\n";
-}
-
-# Check finaly alive $cmd;
-foreach (keys %odefun) {
-    my ($node, $str) = (split (/,/));
-    my ($cmd) = $ocmd{$_};
-    $live{$cmd} = $_;
-}
-
-# Output DEFSH
-foreach (sort keys %live) {
-    my ($proto);
-    my ($key);
-    $key = $live{$_};
-    $proto = join ("|", @{$oproto{$key}});
-    printf "$defsh{$key} ($proto$odefun{$key})\n\n";
-}
-
-# Output install_element
-print <<EOF;
-void vtysh_init_cmd(void)
-{
-EOF
-
-foreach (sort keys %odefun) {
-    my ($node, $str) = (split (/,/));
-    $cmd = $ocmd{$_};
-    $cmd =~ s/_cmd$/_cmd_vtysh/;
-    printf "  install_element ($node, &$cmd);\n";
-}
-
-print <<EOF
-}
-EOF
diff -urpN frr-frr-8.4.2/vtysh/subdir.am frr-frr-8.5/vtysh/subdir.am
--- frr-frr-8.4.2/vtysh/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -20,7 +20,6 @@ vtysh_vtysh_SOURCES = \
 nodist_vtysh_vtysh_SOURCES = \
 	vtysh/vtysh_cmd.c \
 	# end
-CLEANFILES += vtysh/vtysh_cmd.c
 
 noinst_HEADERS += \
 	vtysh/vtysh.h \
@@ -38,24 +37,5 @@ $(vtysh_vtysh_OBJECTS): vtysh/vtysh_daem
 
 CLEANFILES += vtysh/vtysh_daemons.h
 vtysh/vtysh_daemons.h:
+	@$(MKDIR_P) vtysh
 	$(PERL) $(top_srcdir)/vtysh/daemons.pl $(vtysh_daemons) > vtysh/vtysh_daemons.h
-
-AM_V_EXTRACT = $(am__v_EXTRACT_$(V))
-am__v_EXTRACT_ = $(am__v_EXTRACT_$(AM_DEFAULT_VERBOSITY))
-am__v_EXTRACT_0 = @echo "  EXTRACT " $@;
-am__v_EXTRACT_1 =
-
-if ISISD
-HAVE_ISISD = --have-isisd
-else
-HAVE_ISISD =
-endif
-
-if FABRICD
-HAVE_FABRICD = --have-fabricd
-else
-HAVE_FABRICD =
-endif
-
-vtysh/vtysh_cmd.c: vtysh/extract.pl $(vtysh_scan)
-	$(AM_V_EXTRACT) $^ $(HAVE_ISISD) $(HAVE_FABRICD) > vtysh/vtysh_cmd.c
diff -urpN frr-frr-8.4.2/vtysh/vtysh.c frr-frr-8.5/vtysh/vtysh.c
--- frr-frr-8.4.2/vtysh/vtysh.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/vtysh.c	2023-03-13 20:01:47.000000000 +0600
@@ -2759,6 +2759,15 @@ static char *do_prepend(struct vty *vty,
 	return frrstr_join(argstr, argc + off, " ");
 }
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+/* 'headline' is a format string with a %s for the daemon name
+ *
+ * Also for some reason GCC emits the warning on the end of the function
+ * (optimization maybe?) rather than on the vty_out line, so this pragma
+ * wraps the entire function rather than just the vty_out line.
+ */
+
 static int show_per_daemon(struct vty *vty, struct cmd_token **argv, int argc,
 			   const char *headline)
 {
@@ -2777,6 +2786,7 @@ static int show_per_daemon(struct vty *v
 
 	return ret;
 }
+#pragma GCC diagnostic pop
 
 static int show_one_daemon(struct vty *vty, struct cmd_token **argv, int argc,
 			   const char *name)
@@ -2951,7 +2961,7 @@ DEFUN_HIDDEN (show_config_running,
        show_config_running_cmd,
        "show configuration running\
           [<json|xml> [translate WORD]]\
-          [with-defaults]" DAEMONS_LIST,
+          [with-defaults] " DAEMONS_LIST,
        SHOW_STR
        "Configuration information\n"
        "Running configuration\n"
@@ -2972,7 +2982,7 @@ DEFUN (show_yang_operational_data,
 	   format <json|xml>\
 	   |translate WORD\
 	   |with-config\
-	 }]" DAEMONS_LIST,
+	 }] " DAEMONS_LIST,
        SHOW_STR
        "YANG information\n"
        "Show YANG operational data\n"
@@ -3413,6 +3423,30 @@ int vtysh_write_config_integrated(void)
 	return CMD_SUCCESS;
 }
 
+DEFUN_HIDDEN(start_config, start_config_cmd, "XFRR_start_configuration",
+	     "The Beginning of Configuration\n")
+{
+	unsigned int i;
+	char line[] = "XFRR_start_configuration";
+
+	for (i = 0; i < array_size(vtysh_client); i++)
+		vtysh_client_execute(&vtysh_client[i], line);
+
+	return CMD_SUCCESS;
+}
+
+DEFUN_HIDDEN(end_config, end_config_cmd, "XFRR_end_configuration",
+	     "The End of Configuration\n")
+{
+	unsigned int i;
+	char line[] = "XFRR_end_configuration";
+
+	for (i = 0; i < array_size(vtysh_client); i++)
+		vtysh_client_execute(&vtysh_client[i], line);
+
+	return CMD_SUCCESS;
+}
+
 static bool want_config_integrated(void)
 {
 	struct stat s;
@@ -3915,6 +3949,12 @@ DEFUN (vtysh_ping,
 	return CMD_SUCCESS;
 }
 
+DEFUN(vtysh_motd, vtysh_motd_cmd, "show motd", SHOW_STR "Show motd\n")
+{
+	vty_hello(vty);
+	return CMD_SUCCESS;
+}
+
 ALIAS(vtysh_ping, vtysh_ping_ip_cmd, "ping ip WORD",
       "Send echo messages\n"
       "IP echo\n"
@@ -3974,6 +4014,9 @@ DEFUN (vtysh_traceroute6,
 	return CMD_SUCCESS;
 }
 
+#if CONFDATE > 20240201
+CPP_NOTICE("Remove HAVE_SHELL_ACCESS and it's documentation");
+#endif
 #if defined(HAVE_SHELL_ACCESS)
 DEFUN (vtysh_telnet,
        vtysh_telnet_cmd,
@@ -4323,7 +4366,11 @@ char *vtysh_prompt(void)
 {
 	static char buf[512];
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+	/* prompt formatting has a %s in the cmd_node prompt string. */
 	snprintf(buf, sizeof(buf), cmd_prompt(vty->node), cmd_hostname_get());
+#pragma GCC diagnostic pop
 	return buf;
 }
 
@@ -4870,6 +4917,9 @@ void vtysh_init_vty(void)
 	/* "write memory" command. */
 	install_element(ENABLE_NODE, &vtysh_write_memory_cmd);
 
+	install_element(CONFIG_NODE, &start_config_cmd);
+	install_element(CONFIG_NODE, &end_config_cmd);
+
 	install_element(CONFIG_NODE, &vtysh_terminal_paginate_cmd);
 	install_element(VIEW_NODE, &vtysh_terminal_paginate_cmd);
 	install_element(VIEW_NODE, &vtysh_terminal_length_cmd);
@@ -4880,6 +4930,7 @@ void vtysh_init_vty(void)
 	install_element(VIEW_NODE, &no_vtysh_terminal_monitor_cmd);
 
 	install_element(VIEW_NODE, &vtysh_ping_cmd);
+	install_element(VIEW_NODE, &vtysh_motd_cmd);
 	install_element(VIEW_NODE, &vtysh_ping_ip_cmd);
 	install_element(VIEW_NODE, &vtysh_traceroute_cmd);
 	install_element(VIEW_NODE, &vtysh_traceroute_ip_cmd);
diff -urpN frr-frr-8.4.2/vtysh/vtysh.h frr-frr-8.5/vtysh/vtysh.h
--- frr-frr-8.4.2/vtysh/vtysh.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/vtysh.h	2023-03-13 20:01:47.000000000 +0600
@@ -59,7 +59,7 @@ extern struct thread_master *master;
  * things like prefix lists are not even initialised) */
 #define VTYSH_ALL        VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_PIM6D|VTYSH_NHRPD|VTYSH_EIGRPD|VTYSH_BABELD|VTYSH_SHARPD|VTYSH_PBRD|VTYSH_STATICD|VTYSH_BFDD|VTYSH_FABRICD|VTYSH_VRRPD|VTYSH_PATHD
 #define VTYSH_ACL         VTYSH_BFDD|VTYSH_BABELD|VTYSH_BGPD|VTYSH_EIGRPD|VTYSH_ISISD|VTYSH_FABRICD|VTYSH_LDPD|VTYSH_NHRPD|VTYSH_OSPF6D|VTYSH_OSPFD|VTYSH_PBRD|VTYSH_PIMD|VTYSH_PIM6D|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_VRRPD|VTYSH_ZEBRA
-#define VTYSH_RMAP       VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_PIM6D|VTYSH_EIGRPD|VTYSH_FABRICD
+#define VTYSH_RMAP       VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD|VTYSH_PIMD|VTYSH_EIGRPD|VTYSH_FABRICD
 #define VTYSH_INTERFACE_SUBSET                                                 \
 	VTYSH_ZEBRA | VTYSH_RIPD | VTYSH_RIPNGD | VTYSH_OSPFD | VTYSH_OSPF6D | \
 		VTYSH_ISISD | VTYSH_PIMD | VTYSH_PIM6D | VTYSH_NHRPD |         \
diff -urpN frr-frr-8.4.2/vtysh/vtysh_config.c frr-frr-8.5/vtysh/vtysh_config.c
--- frr-frr-8.4.2/vtysh/vtysh_config.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/vtysh_config.c	2023-03-13 20:01:47.000000000 +0600
@@ -261,6 +261,11 @@ static void config_add_line_uniq_end(str
 		listnode_move_to_tail(config, node);
 }
 
+static void config_add_line_head(struct list *config, const char *line)
+{
+	listnode_add_head(config, XSTRDUP(MTYPE_VTYSH_CONFIG_LINE, line));
+}
+
 void vtysh_config_parse_line(void *arg, const char *line)
 {
 	char c;
@@ -324,21 +329,32 @@ void vtysh_config_parse_line(void *arg,
 			} else if (!strncmp(line, " ip mroute",
 					    strlen(" ip mroute"))) {
 				config_add_line_uniq_end(config->line, line);
-			} else if (config->index == RMAP_NODE
-				   || config->index == INTERFACE_NODE
-				   || config->index == VTY_NODE
-				   || config->index == NH_GROUP_NODE)
+			} else if (config->index == RMAP_NODE ||
+				   config->index == INTERFACE_NODE ||
+				   config->index == VTY_NODE)
 				config_add_line_uniq(config->line, line);
-			else
+			else if (config->index == NH_GROUP_NODE) {
+				if (strncmp(line, " resilient",
+					    strlen(" resilient")) == 0)
+					config_add_line_head(config->line,
+							     line);
+				else
+					config_add_line_uniq_end(config->line,
+								 line);
+			} else
 				config_add_line(config->line, line);
 		} else
 			config_add_line(config_top, line);
 		break;
 	default:
 		if (strncmp(line, "exit", strlen("exit")) == 0) {
-			if (config)
+			if (config) {
+				if (config->exit)
+					XFREE(MTYPE_VTYSH_CONFIG_LINE,
+					      config->exit);
 				config->exit =
 					XSTRDUP(MTYPE_VTYSH_CONFIG_LINE, line);
+			}
 		} else if (strncmp(line, "interface", strlen("interface")) == 0)
 			config = config_get(INTERFACE_NODE, line);
 		else if (strncmp(line, "pseudowire", strlen("pseudowire")) == 0)
@@ -492,8 +508,8 @@ void vtysh_config_parse_line(void *arg,
 				    strlen("no ip prefix-list")) == 0 ||
 			    strncmp(line, "no ipv6 prefix-list",
 				    strlen("no ipv6 prefix-list")) == 0 ||
-			    strncmp(line, "service cputime-stats",
-				    strlen("service cputime-stats")) == 0 ||
+			    strncmp(line, "service ", strlen("service ")) ==
+				    0 ||
 			    strncmp(line, "no service cputime-stats",
 				    strlen("no service cputime-stats")) == 0 ||
 			    strncmp(line, "service cputime-warning",
@@ -652,18 +668,21 @@ int vtysh_read_config(const char *config
  */
 void vtysh_config_write(void)
 {
+	const char *name;
 	char line[512];
 
-	if (cmd_hostname_get()) {
-		snprintf(line, sizeof(line), "hostname %s", cmd_hostname_get());
+	name = cmd_hostname_get();
+	if (name && name[0] != '\0') {
+		snprintf(line, sizeof(line), "hostname %s", name);
 		vtysh_config_parse_line(NULL, line);
 	}
 
-	if (cmd_domainname_get()) {
-		snprintf(line, sizeof(line), "domainname %s",
-			 cmd_domainname_get());
+	name = cmd_domainname_get();
+	if (name && name[0] != '\0') {
+		snprintf(line, sizeof(line), "domainname %s", name);
 		vtysh_config_parse_line(NULL, line);
 	}
+
 	if (vtysh_write_integrated == WRITE_INTEGRATED_NO)
 		vtysh_config_parse_line(NULL,
 					"no service integrated-vtysh-config");
diff -urpN frr-frr-8.4.2/vtysh/vtysh_main.c frr-frr-8.5/vtysh/vtysh_main.c
--- frr-frr-8.4.2/vtysh/vtysh_main.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/vtysh/vtysh_main.c	2023-03-13 20:01:47.000000000 +0600
@@ -111,6 +111,8 @@ static void vtysh_rl_callback(char *line
 
 	if (!vtysh_loop_exited)
 		rl_callback_handler_install(vtysh_prompt(), vtysh_rl_callback);
+
+	free(line_read);
 }
 
 /* SIGTSTP handler.  This function care user's ^Z input. */
diff -urpN frr-frr-8.4.2/watchfrr/subdir.am frr-frr-8.5/watchfrr/subdir.am
--- frr-frr-8.4.2/watchfrr/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/watchfrr/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,7 +4,6 @@
 
 if WATCHFRR
 sbin_PROGRAMS += watchfrr/watchfrr
-vtysh_scan += watchfrr/watchfrr_vty.c
 man8 += $(MANBUILD)/frr-watchfrr.8
 endif
 
diff -urpN frr-frr-8.4.2/watchfrr/watchfrr.c frr-frr-8.5/watchfrr/watchfrr.c
--- frr-frr-8.4.2/watchfrr/watchfrr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/watchfrr/watchfrr.c	2023-03-13 20:01:47.000000000 +0600
@@ -112,6 +112,7 @@ static struct global_state {
 	long period;
 	long timeout;
 	long restart_timeout;
+	bool reading_configuration;
 	long min_restart_interval;
 	long max_restart_interval;
 	long operational_timeout;
@@ -365,6 +366,16 @@ static void restart_kill(struct thread *
 	struct timeval delay;
 
 	time_elapsed(&delay, &restart->time);
+
+	if (gs.reading_configuration) {
+		zlog_err(
+			"%s %s child process appears to still be reading configuration, delaying for another %lu time",
+			restart->what, restart->name, gs.restart_timeout);
+		thread_add_timer(master, restart_kill, restart,
+				 gs.restart_timeout, &restart->t_kill);
+		return;
+	}
+
 	zlog_warn(
 		"%s %s child process %d still running after %ld seconds, sending signal %d",
 		restart->what, restart->name, (int)restart->pid,
@@ -501,7 +512,11 @@ static int run_job(struct restart_info *
 	restart->kills = 0;
 	{
 		char cmd[strlen(command) + strlen(restart->name) + 1];
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-nonliteral"
+		/* user supplied command string has a %s for the daemon name */
 		snprintf(cmd, sizeof(cmd), command, restart->name);
+#pragma GCC diagnostic pop
 		if ((restart->pid = run_background(cmd)) > 0) {
 			thread_add_timer(master, restart_kill, restart,
 					 gs.restart_timeout, &restart->t_kill);
@@ -930,13 +945,10 @@ static void phase_check(void)
 		if (!IS_UP(gs.special))
 			break;
 		zlog_info("Phased restart: %s is now up.", gs.special->name);
-		{
-			struct daemon *dmn;
-			for (dmn = gs.daemons; dmn; dmn = dmn->next) {
-				if (dmn != gs.special)
-					run_job(&dmn->restart, "start",
-						gs.start_command, 1, 0);
-			}
+		for (dmn = gs.daemons; dmn; dmn = dmn->next) {
+			if (dmn != gs.special)
+				run_job(&dmn->restart, "start",
+					gs.start_command, 1, 0);
 		}
 		gs.phase = PHASE_NONE;
 		THREAD_OFF(gs.t_phase_hanging);
@@ -1059,6 +1071,8 @@ void watchfrr_status(struct vty *vty)
 	vty_out(vty, " Min Restart Interval: %ld\n", gs.min_restart_interval);
 	vty_out(vty, " Max Restart Interval: %ld\n", gs.max_restart_interval);
 	vty_out(vty, " Restart Timeout: %ld\n", gs.restart_timeout);
+	vty_out(vty, " Reading Configuration: %s\n",
+		gs.reading_configuration ? "yes" : "no");
 	if (gs.restart.pid)
 		vty_out(vty, "    global restart running, pid %ld\n",
 			(long)gs.restart.pid);
@@ -1264,6 +1278,16 @@ static void netns_setup(const char *nsna
 }
 #endif
 
+static void watchfrr_start_config(void)
+{
+	gs.reading_configuration = true;
+}
+
+static void watchfrr_end_config(void)
+{
+	gs.reading_configuration = false;
+}
+
 static void watchfrr_init(int argc, char **argv)
 {
 	const char *special = "zebra";
@@ -1558,6 +1582,7 @@ int main(int argc, char **argv)
 	master = frr_init();
 	watchfrr_error_init();
 	watchfrr_init(argc, argv);
+	cmd_init_config_callbacks(watchfrr_start_config, watchfrr_end_config);
 	watchfrr_vty_init();
 
 	frr_config_fork();
diff -urpN frr-frr-8.4.2/watchfrr/watchfrr_vty.c frr-frr-8.5/watchfrr/watchfrr_vty.c
--- frr-frr-8.4.2/watchfrr/watchfrr_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/watchfrr/watchfrr_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -125,6 +125,8 @@ DEFUN_NOSH (show_debugging_watchfrr,
             DEBUG_STR
             WATCHFRR_STR)
 {
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -151,9 +153,7 @@ DEFUN_NOSH (show_logging,
 	return CMD_SUCCESS;
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "watchfrr/watchfrr_vty_clippy.c"
-#endif
 
 DEFPY (watchfrr_ignore_daemon,
        watchfrr_ignore_daemon_cmd,
diff -urpN frr-frr-8.4.2/yang/embedmodel.py frr-frr-8.5/yang/embedmodel.py
--- frr-frr-8.4.2/yang/embedmodel.py	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/embedmodel.py	2023-03-13 20:01:47.000000000 +0600
@@ -12,8 +12,10 @@ inname = sys.argv[1]
 outname = sys.argv[2]
 
 outdir = os.path.dirname(os.path.abspath(outname))
-if not os.path.isdir(outdir):
+try:
     os.makedirs(outdir)
+except FileExistsError:
+    pass
 
 # these are regexes to avoid a compile-time/host dependency on yang-tools
 # or python-yang.  Cross-compiling FRR is already somewhat involved, no need
diff -urpN frr-frr-8.4.2/yang/frr-bfdd.yang frr-frr-8.5/yang/frr-bfdd.yang
--- frr-frr-8.4.2/yang/frr-bfdd.yang	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/frr-bfdd.yang	2023-03-13 20:01:47.000000000 +0600
@@ -242,6 +242,36 @@ module frr-bfdd {
     }
   }
 
+  grouping bfd-monitoring {
+    description
+      "BFD monitoring template for protocol integration.";
+
+    leaf source {
+      type inet:ip-address;
+      description
+        "Source address to use for liveness check.
+
+         When source is not set and multi-hop is `false` the source
+         address will be `0.0.0.0` (any).
+
+         When source is not set and multi-hop is `true` the source
+         address will be automatic selected through Next Hop Tracking (NHT).";
+    }
+
+    leaf multi-hop {
+      description
+        "Use multi hop session instead of single hop.";
+      type boolean;
+      default false;
+    }
+
+    leaf profile {
+      description
+        "BFD pre configured profile.";
+      type frr-bfdd:profile-ref;
+    }
+  }
+
   grouping session-states {
     /*
      * Local settings.
diff -urpN frr-frr-8.4.2/yang/frr-bgp-route-map.yang frr-frr-8.5/yang/frr-bgp-route-map.yang
--- frr-frr-8.4.2/yang/frr-bgp-route-map.yang	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/frr-bgp-route-map.yang	2023-03-13 20:01:47.000000000 +0600
@@ -276,6 +276,12 @@ module frr-bgp-route-map {
       "Set BGP atomic-aggregate attribute";
   }
 
+  identity aigp-metric {
+    base frr-route-map:rmap-set-type;
+    description
+      "Set BGP AIGP attribute (AIGP TLV Metric)";
+  }
+
   identity as-path-prepend {
     base frr-route-map:rmap-set-type;
     description
@@ -800,6 +806,15 @@ module frr-bgp-route-map {
       }
     }
 
+    case aigp-metric {
+      when "derived-from-or-self(/frr-route-map:lib/frr-route-map:route-map/frr-route-map:entry/frr-route-map:set-action/frr-route-map:action, 'frr-bgp-route-map:aigp-metric')";
+      leaf aigp-metric {
+        type string;
+        description
+          "Set BGP AIGP attribute (AIGP Metric TLV)";
+      }
+    }
+
     case as-path-prepend {
       when "derived-from-or-self(/frr-route-map:lib/frr-route-map:route-map/frr-route-map:entry/frr-route-map:set-action/frr-route-map:action, 'frr-bgp-route-map:as-path-prepend')";
       choice as-path-prepend {
diff -urpN frr-frr-8.4.2/yang/frr-isisd.yang frr-frr-8.5/yang/frr-isisd.yang
--- frr-frr-8.4.2/yang/frr-isisd.yang	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/frr-isisd.yang	2023-03-13 20:01:47.000000000 +0600
@@ -881,6 +881,9 @@ module frr-isisd {
           description
             "This leaf describes the state of the interface.";
         }
+
+        uses adjacency-sids;
+        uses lan-adjacency-sids;
       }
     }
   }
@@ -1004,6 +1007,76 @@ module frr-isisd {
     }
   }
 
+  grouping adjacency-sids {
+    description
+      "IS-IS segment routing adjacency SID grouping.";
+    container adjacency-sids {
+      description
+        "This container lists the information of adjacency SID.";
+      list adjacency-sid {
+        leaf af {
+          type uint8;
+          description
+            "This leaf describes the protocol-family associated with the
+              adjacency SID.";
+        }
+
+        leaf value {
+          type uint32;
+          description
+            "This leaf describes the value of adjacency SID.";
+        }
+
+        leaf weight {
+          type uint8;
+          description
+            "This leaf describes the weight of the adjacency SID.";
+        }
+
+        leaf protection-requested {
+          type boolean;
+          description
+            "This leaf describes if the adjacency SID must be protected.";
+        }
+      }
+    }
+  }
+
+  grouping lan-adjacency-sids {
+    description
+      "IS-IS segment routing LAN adjacency SID grouping.";
+    container lan-adjacency-sids {
+      description
+        "This container lists the information of LAN adjacency SID.";
+      list lan-adjacency-sid {
+        leaf af {
+          type uint8;
+          description
+            "This leaf describes the protocol-family associated with the
+              LAN adjacency SID.";
+        }
+
+        leaf value {
+          type uint32;
+          description
+            "This leaf describes the value of LAN adjacency SID.";
+        }
+
+        leaf weight {
+          type uint8;
+          description
+            "This leaf describes the weight of the LAN adjacency SID.";
+        }
+
+        leaf protection-requested {
+          type boolean;
+          description
+            "This leaf describes if the LAN adjacency SID must be protected.";
+        }
+      }
+    }
+  }
+
   container isis {
     description
       "Configuration of the IS-IS routing daemon.";
@@ -1066,11 +1139,25 @@ module frr-isisd {
           "If true, identify as L1/L2 router for inter-area traffic.";
       }
 
-      leaf overload {
-        type boolean;
-        default "false";
+      container overload {
         description
-          "If true, avoid any transit traffic.";
+          "Overload bit configuration.";
+        leaf enabled {
+          type boolean;
+          default "false";
+          description
+            "If true, avoid any transit traffic.";
+        }
+
+        leaf on-startup {
+          type uint32 {
+            range "0..86400";
+          }
+          units "seconds";
+          default "0";
+          description
+            "The duration the overload bit should be set on startup.";
+        }
       }
 
       leaf metric-style {
diff -urpN frr-frr-8.4.2/yang/frr-staticd.yang frr-frr-8.5/yang/frr-staticd.yang
--- frr-frr-8.4.2/yang/frr-staticd.yang	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/frr-staticd.yang	2023-03-13 20:01:47.000000000 +0600
@@ -15,6 +15,10 @@ module frr-staticd {
     prefix inet;
   }
 
+  import frr-bfdd {
+    prefix frr-bfdd;
+  }
+
   organization
     "FRRouting";
   contact
@@ -114,7 +118,19 @@ module frr-staticd {
             "AFI-SAFI type.";
         }
 
-        uses staticd-prefix-attributes;
+        uses staticd-prefix-attributes {
+          augment "path-list/frr-nexthops/nexthop" {
+            container bfd-monitoring {
+              description "BFD monitoring options.";
+              presence
+                "Present if BFD configuration is available.";
+
+              when "../nh-type = 'ip4' or ../nh-type = 'ip4-ifindex' or
+                    ../nh-type = 'ip6' or ../nh-type = 'ip6-ifindex'";
+              uses frr-bfdd:bfd-monitoring;
+            }
+          }
+        }
 
         list src-list {
           key "src-prefix";
diff -urpN frr-frr-8.4.2/yang/frr-vrrpd.yang frr-frr-8.5/yang/frr-vrrpd.yang
--- frr-frr-8.4.2/yang/frr-vrrpd.yang	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/yang/frr-vrrpd.yang	2023-03-13 20:01:47.000000000 +0600
@@ -110,6 +110,13 @@ module frr-vrrpd {
          address is not owned by the router interface";
     }
 
+    leaf checksum-with-ipv4-pseudoheader {
+      type boolean;
+      default "true";
+      description
+        "Enabled if VRRPv3 checksum for IPv4 involves pseudoheader";
+    }
+
     leaf advertisement-interval {
       type uint16 {
         range "1..4095";
diff -urpN frr-frr-8.4.2/zebra/debug.c frr-frr-8.5/zebra/debug.c
--- frr-frr-8.4.2/zebra/debug.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/debug.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,9 +23,7 @@
 #include "command.h"
 #include "debug.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/debug_clippy.c"
-#endif
 
 /* For debug statement. */
 unsigned long zebra_debug_event;
@@ -44,6 +42,7 @@ unsigned long zebra_debug_nexthop;
 unsigned long zebra_debug_evpn_mh;
 unsigned long zebra_debug_pbr;
 unsigned long zebra_debug_neigh;
+unsigned long zebra_debug_tc;
 
 DEFINE_HOOK(zebra_debug_show_debugging, (struct vty *vty), (vty));
 
@@ -137,6 +136,9 @@ DEFUN_NOSH (show_debugging_zebra,
 		vty_out(vty, "  Zebra PBR debugging is on\n");
 
 	hook_call(zebra_debug_show_debugging, vty);
+
+	cmd_show_lib_debugs(vty);
+
 	return CMD_SUCCESS;
 }
 
@@ -339,7 +341,7 @@ DEFPY(debug_zebra_dplane_dpdk, debug_zeb
 		SET_FLAG(zebra_debug_dplane_dpdk, ZEBRA_DEBUG_DPLANE_DPDK);
 
 		if (detail)
-			SET_FLAG(zebra_debug_dplane,
+			SET_FLAG(zebra_debug_dplane_dpdk,
 				 ZEBRA_DEBUG_DPLANE_DPDK_DETAIL);
 	}
 
@@ -373,6 +375,17 @@ DEFPY (debug_zebra_neigh,
 	return CMD_SUCCESS;
 }
 
+DEFUN (debug_zebra_tc,
+       debug_zebra_tc_cmd,
+       "debug zebra tc",
+       DEBUG_STR
+       "Zebra configuration\n"
+       "Debug zebra tc events\n")
+{
+	SET_FLAG(zebra_debug_tc, ZEBRA_DEBUG_TC);
+	return CMD_SUCCESS;
+}
+
 DEFPY (debug_zebra_mlag,
        debug_zebra_mlag_cmd,
        "[no$no] debug zebra mlag",
@@ -727,10 +740,12 @@ static int config_write_debug(struct vty
 		write++;
 	}
 
-	if (CHECK_FLAG(zebra_debug_dplane, ZEBRA_DEBUG_DPLANE_DPDK_DETAIL)) {
+	if (CHECK_FLAG(zebra_debug_dplane_dpdk,
+		       ZEBRA_DEBUG_DPLANE_DPDK_DETAIL)) {
 		vty_out(vty, "debug zebra dplane dpdk detailed\n");
 		write++;
-	} else if (CHECK_FLAG(zebra_debug_dplane, ZEBRA_DEBUG_DPLANE_DPDK)) {
+	} else if (CHECK_FLAG(zebra_debug_dplane_dpdk,
+			      ZEBRA_DEBUG_DPLANE_DPDK)) {
 		vty_out(vty, "debug zebra dplane dpdk\n");
 		write++;
 	}
@@ -796,6 +811,7 @@ void zebra_debug_init(void)
 	install_element(ENABLE_NODE, &debug_zebra_nexthop_cmd);
 	install_element(ENABLE_NODE, &debug_zebra_pbr_cmd);
 	install_element(ENABLE_NODE, &debug_zebra_neigh_cmd);
+	install_element(ENABLE_NODE, &debug_zebra_tc_cmd);
 	install_element(ENABLE_NODE, &debug_zebra_dplane_dpdk_cmd);
 	install_element(ENABLE_NODE, &no_debug_zebra_events_cmd);
 	install_element(ENABLE_NODE, &no_debug_zebra_nht_cmd);
diff -urpN frr-frr-8.4.2/zebra/debug.h frr-frr-8.5/zebra/debug.h
--- frr-frr-8.4.2/zebra/debug.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/debug.h	2023-03-13 20:01:47.000000000 +0600
@@ -75,6 +75,8 @@ extern "C" {
 
 #define ZEBRA_DEBUG_NEIGH 0x01
 
+#define ZEBRA_DEBUG_TC 0x01
+
 /* Debug related macro. */
 #define IS_ZEBRA_DEBUG_EVENT  (zebra_debug_event & ZEBRA_DEBUG_EVENT)
 
@@ -109,9 +111,9 @@ extern "C" {
 	(zebra_debug_dplane & ZEBRA_DEBUG_DPLANE_DETAILED)
 
 #define IS_ZEBRA_DEBUG_DPLANE_DPDK                                             \
-	(zebra_debug_dplane & ZEBRA_DEBUG_DPLANE_DPDK)
+	(zebra_debug_dplane_dpdk & ZEBRA_DEBUG_DPLANE_DPDK)
 #define IS_ZEBRA_DEBUG_DPLANE_DPDK_DETAIL                                      \
-	(zebra_debug_dplane & ZEBRA_DEBUG_DPLANE_DPDK_DETAIL)
+	(zebra_debug_dplane_dpdk & ZEBRA_DEBUG_DPLANE_DPDK_DETAIL)
 
 #define IS_ZEBRA_DEBUG_MLAG (zebra_debug_mlag & ZEBRA_DEBUG_MLAG)
 
@@ -133,6 +135,8 @@ extern "C" {
 
 #define IS_ZEBRA_DEBUG_NEIGH (zebra_debug_neigh & ZEBRA_DEBUG_NEIGH)
 
+#define IS_ZEBRA_DEBUG_TC (zebra_debug_tc & ZEBRA_DEBUG_TC)
+
 extern unsigned long zebra_debug_event;
 extern unsigned long zebra_debug_packet;
 extern unsigned long zebra_debug_kernel;
@@ -149,6 +153,7 @@ extern unsigned long zebra_debug_nexthop
 extern unsigned long zebra_debug_evpn_mh;
 extern unsigned long zebra_debug_pbr;
 extern unsigned long zebra_debug_neigh;
+extern unsigned long zebra_debug_tc;
 
 extern void zebra_debug_init(void);
 
diff -urpN frr-frr-8.4.2/zebra/dpdk/zebra_dplane_dpdk_vty.c frr-frr-8.5/zebra/dpdk/zebra_dplane_dpdk_vty.c
--- frr-frr-8.4.2/zebra/dpdk/zebra_dplane_dpdk_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/dpdk/zebra_dplane_dpdk_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,9 +23,7 @@
 #include "lib/json.h"
 #include "zebra/dpdk/zebra_dplane_dpdk.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/dpdk/zebra_dplane_dpdk_vty_clippy.c"
-#endif
 
 #define ZD_STR "Zebra dataplane information\n"
 #define ZD_DPDK_STR "DPDK offload information\n"
diff -urpN frr-frr-8.4.2/zebra/dplane_fpm_nl.c frr-frr-8.5/zebra/dplane_fpm_nl.c
--- frr-frr-8.4.2/zebra/dplane_fpm_nl.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/dplane_fpm_nl.c	2023-03-13 20:01:47.000000000 +0600
@@ -51,6 +51,7 @@
 #include "zebra/kernel_netlink.h"
 #include "zebra/rt_netlink.h"
 #include "zebra/debug.h"
+#include "fpm/fpm.h"
 
 #define SOUTHBOUND_DEFAULT_ADDR INADDR_LOOPBACK
 #define SOUTHBOUND_DEFAULT_PORT 2620
@@ -88,7 +89,7 @@ struct fpm_nl_ctx {
 	 * When a FPM server connection becomes a bottleneck, we must keep the
 	 * data plane contexts until we get a chance to process them.
 	 */
-	struct dplane_ctx_q ctxqueue;
+	struct dplane_ctx_list_head ctxqueue;
 	pthread_mutex_t ctxqueue_mutex;
 
 	/* data plane events. */
@@ -462,18 +463,17 @@ static void fpm_reconnect(struct fpm_nl_
 static void fpm_read(struct thread *t)
 {
 	struct fpm_nl_ctx *fnc = THREAD_ARG(t);
+	fpm_msg_hdr_t fpm;
 	ssize_t rv;
+	char buf[65535];
+	struct nlmsghdr *hdr;
+	struct zebra_dplane_ctx *ctx;
+	size_t available_bytes;
+	size_t hdr_available_bytes;
 
 	/* Let's ignore the input at the moment. */
 	rv = stream_read_try(fnc->ibuf, fnc->socket,
 			     STREAM_WRITEABLE(fnc->ibuf));
-	/* We've got an interruption. */
-	if (rv == -2) {
-		/* Schedule next read. */
-		thread_add_read(fnc->fthread->master, fpm_read, fnc,
-				fnc->socket, &fnc->t_read);
-		return;
-	}
 	if (rv == 0) {
 		atomic_fetch_add_explicit(&fnc->counters.connection_closes, 1,
 					  memory_order_relaxed);
@@ -492,14 +492,134 @@ static void fpm_read(struct thread *t)
 		FPM_RECONNECT(fnc);
 		return;
 	}
-	stream_reset(fnc->ibuf);
+
+	/* Schedule the next read */
+	thread_add_read(fnc->fthread->master, fpm_read, fnc, fnc->socket,
+			&fnc->t_read);
+
+	/* We've got an interruption. */
+	if (rv == -2)
+		return;
+
 
 	/* Account all bytes read. */
 	atomic_fetch_add_explicit(&fnc->counters.bytes_read, rv,
 				  memory_order_relaxed);
 
-	thread_add_read(fnc->fthread->master, fpm_read, fnc, fnc->socket,
-			&fnc->t_read);
+	available_bytes = STREAM_READABLE(fnc->ibuf);
+	while (available_bytes) {
+		if (available_bytes < (ssize_t)FPM_MSG_HDR_LEN) {
+			stream_pulldown(fnc->ibuf);
+			return;
+		}
+
+		fpm.version = stream_getc(fnc->ibuf);
+		fpm.msg_type = stream_getc(fnc->ibuf);
+		fpm.msg_len = stream_getw(fnc->ibuf);
+
+		if (fpm.version != FPM_PROTO_VERSION &&
+		    fpm.msg_type != FPM_MSG_TYPE_NETLINK) {
+			stream_reset(fnc->ibuf);
+			zlog_warn(
+				"%s: Received version/msg_type %u/%u, expected 1/1",
+				__func__, fpm.version, fpm.msg_type);
+
+			FPM_RECONNECT(fnc);
+			return;
+		}
+
+		/*
+		 * If the passed in length doesn't even fill in the header
+		 * something is wrong and reset.
+		 */
+		if (fpm.msg_len < FPM_MSG_HDR_LEN) {
+			zlog_warn(
+				"%s: Received message length: %u that does not even fill the FPM header",
+				__func__, fpm.msg_len);
+			FPM_RECONNECT(fnc);
+			return;
+		}
+
+		/*
+		 * If we have not received the whole payload, reset the stream
+		 * back to the beginning of the header and move it to the
+		 * top.
+		 */
+		if (fpm.msg_len > available_bytes) {
+			stream_rewind_getp(fnc->ibuf, FPM_MSG_HDR_LEN);
+			stream_pulldown(fnc->ibuf);
+			return;
+		}
+
+		available_bytes -= FPM_MSG_HDR_LEN;
+
+		/*
+		 * Place the data from the stream into a buffer
+		 */
+		hdr = (struct nlmsghdr *)buf;
+		stream_get(buf, fnc->ibuf, fpm.msg_len - FPM_MSG_HDR_LEN);
+		hdr_available_bytes = fpm.msg_len - FPM_MSG_HDR_LEN;
+		available_bytes -= hdr_available_bytes;
+
+		/* Sanity check: must be at least header size. */
+		if (hdr->nlmsg_len < sizeof(*hdr)) {
+			zlog_warn(
+				"%s: [seq=%u] invalid message length %u (< %zu)",
+				__func__, hdr->nlmsg_seq, hdr->nlmsg_len,
+				sizeof(*hdr));
+			continue;
+		}
+		if (hdr->nlmsg_len > fpm.msg_len) {
+			zlog_warn(
+				"%s: Received a inner header length of %u that is greater than the fpm total length of %u",
+				__func__, hdr->nlmsg_len, fpm.msg_len);
+			FPM_RECONNECT(fnc);
+		}
+		/* Not enough bytes available. */
+		if (hdr->nlmsg_len > hdr_available_bytes) {
+			zlog_warn(
+				"%s: [seq=%u] invalid message length %u (> %zu)",
+				__func__, hdr->nlmsg_seq, hdr->nlmsg_len,
+				available_bytes);
+			continue;
+		}
+
+		if (!(hdr->nlmsg_flags & NLM_F_REQUEST)) {
+			if (IS_ZEBRA_DEBUG_FPM)
+				zlog_debug(
+					"%s: [seq=%u] not a request, skipping",
+					__func__, hdr->nlmsg_seq);
+
+			/*
+			 * This request is a bust, go to the next one
+			 */
+			continue;
+		}
+
+		switch (hdr->nlmsg_type) {
+		case RTM_NEWROUTE:
+			ctx = dplane_ctx_alloc();
+			dplane_ctx_set_op(ctx, DPLANE_OP_ROUTE_NOTIFY);
+			if (netlink_route_change_read_unicast_internal(
+				    hdr, 0, false, ctx) != 1) {
+				dplane_ctx_fini(&ctx);
+				stream_pulldown(fnc->ibuf);
+				/*
+				 * Let's continue to read other messages
+				 * Even if we ignore this one.
+				 */
+			}
+			break;
+		default:
+			if (IS_ZEBRA_DEBUG_FPM)
+				zlog_debug(
+					"%s: Received message type %u which is not currently handled",
+					__func__, hdr->nlmsg_type);
+			break;
+		}
+	}
+
+	stream_reset(fnc->ibuf);
 }
 
 static void fpm_write(struct thread *t)
@@ -746,7 +866,7 @@ static int fpm_nl_enqueue(struct fpm_nl_
 
 	case DPLANE_OP_NH_DELETE:
 		rv = netlink_nexthop_msg_encode(RTM_DELNEXTHOP, ctx, nl_buf,
-						sizeof(nl_buf));
+						sizeof(nl_buf), true);
 		if (rv <= 0) {
 			zlog_err("%s: netlink_nexthop_msg_encode failed",
 				 __func__);
@@ -758,7 +878,7 @@ static int fpm_nl_enqueue(struct fpm_nl_
 	case DPLANE_OP_NH_INSTALL:
 	case DPLANE_OP_NH_UPDATE:
 		rv = netlink_nexthop_msg_encode(RTM_NEWNEXTHOP, ctx, nl_buf,
-						sizeof(nl_buf));
+						sizeof(nl_buf), true);
 		if (rv <= 0) {
 			zlog_err("%s: netlink_nexthop_msg_encode failed",
 				 __func__);
@@ -816,9 +936,14 @@ static int fpm_nl_enqueue(struct fpm_nl_
 	case DPLANE_OP_INTF_INSTALL:
 	case DPLANE_OP_INTF_UPDATE:
 	case DPLANE_OP_INTF_DELETE:
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 	case DPLANE_OP_NONE:
 		break;
 
@@ -1348,7 +1473,7 @@ static int fpm_nl_start(struct zebra_dpl
 	fnc->socket = -1;
 	fnc->disabled = true;
 	fnc->prov = prov;
-	TAILQ_INIT(&fnc->ctxqueue);
+	dplane_ctx_q_init(&fnc->ctxqueue);
 	pthread_mutex_init(&fnc->ctxqueue_mutex, NULL);
 
 	/* Set default values. */
diff -urpN frr-frr-8.4.2/zebra/if_netlink.c frr-frr-8.5/zebra/if_netlink.c
--- frr-frr-8.4.2/zebra/if_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/if_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -1081,8 +1081,8 @@ static int netlink_interface(struct nlms
 	zif->link_ifindex = link_ifindex;
 
 	if (desc) {
-		XFREE(MTYPE_TMP, zif->desc);
-		zif->desc = XSTRDUP(MTYPE_TMP, desc);
+		XFREE(MTYPE_ZIF_DESC, zif->desc);
+		zif->desc = XSTRDUP(MTYPE_ZIF_DESC, desc);
 	}
 
 	/* Hardware type and address. */
@@ -1996,7 +1996,15 @@ int netlink_link_change(struct nlmsghdr
 
 			if (tb[IFLA_PROTO_DOWN])
 				netlink_proc_dplane_if_protodown(ifp->info, tb);
-
+			if (IS_ZEBRA_IF_BRIDGE(ifp)) {
+				zif = ifp->info;
+				if (IS_ZEBRA_DEBUG_KERNEL)
+					zlog_debug(
+						"RTM_NEWLINK ADD for %s(%u), vlan-aware %d",
+						name, ifp->ifindex,
+						IS_ZEBRA_IF_BRIDGE_VLAN_AWARE(
+							zif));
+			}
 		} else if (ifp->vrf->vrf_id != vrf_id) {
 			/* VRF change for an interface. */
 			if (IS_ZEBRA_DEBUG_KERNEL)
@@ -2132,13 +2140,21 @@ int netlink_link_change(struct nlmsghdr
 			else if (IS_ZEBRA_IF_BOND_SLAVE(ifp) || was_bond_slave)
 				zebra_l2if_update_bond_slave(ifp, bond_ifindex,
 							     !!bypass);
+			if (IS_ZEBRA_IF_BRIDGE(ifp)) {
+				if (IS_ZEBRA_DEBUG_KERNEL)
+					zlog_debug(
+						"RTM_NEWLINK update for %s(%u), vlan-aware %d",
+						name, ifp->ifindex,
+						IS_ZEBRA_IF_BRIDGE_VLAN_AWARE(
+							zif));
+			}
 		}
 
 		zif = ifp->info;
 		if (zif) {
-			XFREE(MTYPE_TMP, zif->desc);
+			XFREE(MTYPE_ZIF_DESC, zif->desc);
 			if (desc)
-				zif->desc = XSTRDUP(MTYPE_TMP, desc);
+				zif->desc = XSTRDUP(MTYPE_ZIF_DESC, desc);
 		}
 	} else {
 		/* Delete interface notification from kernel */
diff -urpN frr-frr-8.4.2/zebra/interface.c frr-frr-8.5/zebra/interface.c
--- frr-frr-8.4.2/zebra/interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -61,6 +61,7 @@ DEFINE_HOOK(zebra_if_extra_info, (struct
 DEFINE_HOOK(zebra_if_config_wr, (struct vty * vty, struct interface *ifp),
 	    (vty, ifp));
 
+DEFINE_MTYPE(ZEBRA, ZIF_DESC, "Intf desc");
 
 static void if_down_del_nbr_connected(struct interface *ifp);
 
@@ -233,7 +234,7 @@ static int if_zebra_delete_hook(struct i
 		if_nhg_dependents_release(ifp);
 		zebra_if_nhg_dependents_free(zebra_if);
 
-		XFREE(MTYPE_TMP, zebra_if->desc);
+		XFREE(MTYPE_ZIF_DESC, zebra_if->desc);
 
 		THREAD_OFF(zebra_if->speed_update);
 
@@ -1435,7 +1436,8 @@ static void zebra_if_netconf_update_ctx(
 			if (IS_ZEBRA_DEBUG_KERNEL)
 				zlog_debug(
 					"%s: if %s(%u) zebra info pointer is NULL",
-					__func__, ifp->name, ifp->ifindex);
+					__func__, ifp ? ifp->name : "(null)",
+					ifp ? ifp->ifindex : ifindex);
 			return;
 		}
 		if (afi == AFI_IP) {
@@ -1573,9 +1575,14 @@ void zebra_if_dplane_result(struct zebra
 	case DPLANE_OP_IPSET_ENTRY_DELETE:
 	case DPLANE_OP_NEIGH_TABLE_UPDATE:
 	case DPLANE_OP_GRE_SET:
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		break; /* should never hit here */
 	}
 }
@@ -2603,9 +2610,7 @@ static void interface_update_stats(void)
 #endif /* HAVE_NET_RT_IFLIST */
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/interface_clippy.c"
-#endif
 /* Show all interfaces to vty. */
 DEFPY(show_interface, show_interface_cmd,
       "show interface vrf NAME$vrf_name [brief$brief] [json$uj]",
@@ -3279,14 +3284,8 @@ DEFUN (link_params_enable,
 			"Link-params: enable TE link parameters on interface %s",
 			ifp->name);
 
-	if (!if_link_params_get(ifp)) {
-		if (IS_ZEBRA_DEBUG_EVENT || IS_ZEBRA_DEBUG_MPLS)
-			zlog_debug(
-				"Link-params: failed to init TE link parameters  %s",
-				ifp->name);
-
-		return CMD_WARNING_CONFIG_FAILED;
-	}
+	if (!if_link_params_get(ifp))
+		if_link_params_enable(ifp);
 
 	/* force protocols to update LINK STATE due to parameters change */
 	if (if_is_operative(ifp))
@@ -3330,6 +3329,9 @@ DEFUN (link_params_metric,
 
 	metric = strtoul(argv[idx_number]->arg, NULL, 10);
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update TE metric if needed */
 	link_param_cmd_set_uint32(ifp, &iflp->te_metric, LP_TE_METRIC, metric);
 
@@ -3370,17 +3372,20 @@ DEFUN (link_params_maxbw,
 
 	/* Check that Maximum bandwidth is not lower than other bandwidth
 	 * parameters */
-	if ((bw <= iflp->max_rsv_bw) || (bw <= iflp->unrsv_bw[0])
-	    || (bw <= iflp->unrsv_bw[1]) || (bw <= iflp->unrsv_bw[2])
-	    || (bw <= iflp->unrsv_bw[3]) || (bw <= iflp->unrsv_bw[4])
-	    || (bw <= iflp->unrsv_bw[5]) || (bw <= iflp->unrsv_bw[6])
-	    || (bw <= iflp->unrsv_bw[7]) || (bw <= iflp->ava_bw)
-	    || (bw <= iflp->res_bw) || (bw <= iflp->use_bw)) {
+	if (iflp && ((bw <= iflp->max_rsv_bw) || (bw <= iflp->unrsv_bw[0]) ||
+		     (bw <= iflp->unrsv_bw[1]) || (bw <= iflp->unrsv_bw[2]) ||
+		     (bw <= iflp->unrsv_bw[3]) || (bw <= iflp->unrsv_bw[4]) ||
+		     (bw <= iflp->unrsv_bw[5]) || (bw <= iflp->unrsv_bw[6]) ||
+		     (bw <= iflp->unrsv_bw[7]) || (bw <= iflp->ava_bw) ||
+		     (bw <= iflp->res_bw) || (bw <= iflp->use_bw))) {
 		vty_out(vty,
 			"Maximum Bandwidth could not be lower than others bandwidth\n");
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Maximum Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->max_bw, LP_MAX_BW, bw);
 
@@ -3406,13 +3411,16 @@ DEFUN (link_params_max_rsv_bw,
 
 	/* Check that bandwidth is not greater than maximum bandwidth parameter
 	 */
-	if (bw > iflp->max_bw) {
+	if (iflp && bw > iflp->max_bw) {
 		vty_out(vty,
 			"Maximum Reservable Bandwidth could not be greater than Maximum Bandwidth (%g)\n",
 			iflp->max_bw);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Maximum Reservable Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->max_rsv_bw, LP_MAX_RSV_BW, bw);
 
@@ -3448,13 +3456,16 @@ DEFUN (link_params_unrsv_bw,
 
 	/* Check that bandwidth is not greater than maximum bandwidth parameter
 	 */
-	if (bw > iflp->max_bw) {
+	if (iflp && bw > iflp->max_bw) {
 		vty_out(vty,
 			"UnReserved Bandwidth could not be greater than Maximum Bandwidth (%g)\n",
 			iflp->max_bw);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Unreserved Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->unrsv_bw[priority], LP_UNRSV_BW,
 				 bw);
@@ -3479,6 +3490,9 @@ DEFUN (link_params_admin_grp,
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Administrative Group if needed */
 	link_param_cmd_set_uint32(ifp, &iflp->admin_grp, LP_ADM_GRP, value);
 
@@ -3521,6 +3535,9 @@ DEFUN (link_params_inter_as,
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	as = strtoul(argv[idx_number]->arg, NULL, 10);
 
 	/* Update Remote IP and Remote AS fields if needed */
@@ -3548,6 +3565,9 @@ DEFUN (no_link_params_inter_as,
 	VTY_DECLVAR_CONTEXT(interface, ifp);
 	struct if_link_params *iflp = if_link_params_get(ifp);
 
+	if (!iflp)
+		return CMD_SUCCESS;
+
 	/* Reset Remote IP and AS neighbor */
 	iflp->rmt_as = 0;
 	iflp->rmt_ip.s_addr = 0;
@@ -3595,13 +3615,17 @@ DEFUN (link_params_delay,
 		 * Therefore, it is also allowed that the average
 		 * delay be equal to the min delay or max delay.
 		 */
-		if (IS_PARAM_SET(iflp, LP_MM_DELAY)
-		    && (delay < iflp->min_delay || delay > iflp->max_delay)) {
+		if (iflp && IS_PARAM_SET(iflp, LP_MM_DELAY) &&
+		    (delay < iflp->min_delay || delay > iflp->max_delay)) {
 			vty_out(vty,
 				"Average delay should be in range Min (%d) - Max (%d) delay\n",
 				iflp->min_delay, iflp->max_delay);
 			return CMD_WARNING_CONFIG_FAILED;
 		}
+
+		if (!iflp)
+			iflp = if_link_params_enable(ifp);
+
 		/* Update delay if value is not set or change */
 		if (IS_PARAM_UNSET(iflp, LP_DELAY) || iflp->av_delay != delay) {
 			iflp->av_delay = delay;
@@ -3626,6 +3650,10 @@ DEFUN (link_params_delay,
 				low, high);
 			return CMD_WARNING_CONFIG_FAILED;
 		}
+
+		if (!iflp)
+			iflp = if_link_params_enable(ifp);
+
 		/* Update Delays if needed */
 		if (IS_PARAM_UNSET(iflp, LP_DELAY)
 		    || IS_PARAM_UNSET(iflp, LP_MM_DELAY)
@@ -3656,6 +3684,9 @@ DEFUN (no_link_params_delay,
 	VTY_DECLVAR_CONTEXT(interface, ifp);
 	struct if_link_params *iflp = if_link_params_get(ifp);
 
+	if (!iflp)
+		return CMD_SUCCESS;
+
 	/* Unset Delays */
 	iflp->av_delay = 0;
 	UNSET_PARAM(iflp, LP_DELAY);
@@ -3683,6 +3714,9 @@ DEFUN (link_params_delay_var,
 
 	value = strtoul(argv[idx_number]->arg, NULL, 10);
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Delay Variation if needed */
 	link_param_cmd_set_uint32(ifp, &iflp->delay_var, LP_DELAY_VAR, value);
 
@@ -3723,6 +3757,9 @@ DEFUN (link_params_pkt_loss,
 	if (fval > MAX_PKT_LOSS)
 		fval = MAX_PKT_LOSS;
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Packet Loss if needed */
 	link_param_cmd_set_float(ifp, &iflp->pkt_loss, LP_PKT_LOSS, fval);
 
@@ -3762,13 +3799,16 @@ DEFUN (link_params_res_bw,
 
 	/* Check that bandwidth is not greater than maximum bandwidth parameter
 	 */
-	if (bw > iflp->max_bw) {
+	if (iflp && bw > iflp->max_bw) {
 		vty_out(vty,
 			"Residual Bandwidth could not be greater than Maximum Bandwidth (%g)\n",
 			iflp->max_bw);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Residual Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->res_bw, LP_RES_BW, bw);
 
@@ -3808,13 +3848,16 @@ DEFUN (link_params_ava_bw,
 
 	/* Check that bandwidth is not greater than maximum bandwidth parameter
 	 */
-	if (bw > iflp->max_bw) {
+	if (iflp && bw > iflp->max_bw) {
 		vty_out(vty,
 			"Available Bandwidth could not be greater than Maximum Bandwidth (%g)\n",
 			iflp->max_bw);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Residual Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->ava_bw, LP_AVA_BW, bw);
 
@@ -3854,13 +3897,16 @@ DEFUN (link_params_use_bw,
 
 	/* Check that bandwidth is not greater than maximum bandwidth parameter
 	 */
-	if (bw > iflp->max_bw) {
+	if (iflp && bw > iflp->max_bw) {
 		vty_out(vty,
 			"Utilised Bandwidth could not be greater than Maximum Bandwidth (%g)\n",
 			iflp->max_bw);
 		return CMD_WARNING_CONFIG_FAILED;
 	}
 
+	if (!iflp)
+		iflp = if_link_params_enable(ifp);
+
 	/* Update Utilized Bandwidth if needed */
 	link_param_cmd_set_float(ifp, &iflp->use_bw, LP_USE_BW, bw);
 
diff -urpN frr-frr-8.4.2/zebra/interface.h frr-frr-8.5/zebra/interface.h
--- frr-frr-8.4.2/zebra/interface.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/interface.h	2023-03-13 20:01:47.000000000 +0600
@@ -109,6 +109,9 @@ enum zebra_if_flags {
 #define ZEBRA_IF_IS_PROTODOWN_ONLY_EXTERNAL(zif)                               \
 	((zif)->protodown_rc == ZEBRA_PROTODOWN_EXTERNAL)
 
+/* Mem type for zif desc */
+DECLARE_MTYPE(ZIF_DESC);
+
 /* `zebra' daemon local interface structure. */
 struct zebra_if {
 	/* back pointer to the interface */
diff -urpN frr-frr-8.4.2/zebra/irdp_interface.c frr-frr-8.5/zebra/irdp_interface.c
--- frr-frr-8.4.2/zebra/irdp_interface.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/irdp_interface.c	2023-03-13 20:01:47.000000000 +0600
@@ -200,12 +200,12 @@ static void if_set_defaults(struct irdp_
 
 static struct Adv *Adv_new(void)
 {
-	return XCALLOC(MTYPE_TMP, sizeof(struct Adv));
+	return XCALLOC(MTYPE_IRDP_IF, sizeof(struct Adv));
 }
 
 static void Adv_free(struct Adv *adv)
 {
-	XFREE(MTYPE_TMP, adv);
+	XFREE(MTYPE_IRDP_IF, adv);
 }
 
 static void irdp_if_start(struct interface *ifp, int multicast,
diff -urpN frr-frr-8.4.2/zebra/kernel_netlink.c frr-frr-8.5/zebra/kernel_netlink.c
--- frr-frr-8.4.2/zebra/kernel_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/kernel_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -202,13 +202,13 @@ struct nl_batch {
 
 	const struct zebra_dplane_info *zns;
 
-	struct dplane_ctx_q ctx_list;
+	struct dplane_ctx_list_head ctx_list;
 
 	/*
 	 * Pointer to the queue of completed contexts outbound back
 	 * towards the dataplane module.
 	 */
-	struct dplane_ctx_q *ctx_out_q;
+	struct dplane_ctx_list_head *ctx_out_q;
 };
 
 int netlink_config_write_helper(struct vty *vty)
@@ -423,6 +423,15 @@ static int netlink_information_fetch(str
 		return netlink_nexthop_change(h, ns_id, startup);
 	case RTM_DELNEXTHOP:
 		return netlink_nexthop_change(h, ns_id, startup);
+	case RTM_NEWQDISC:
+	case RTM_DELQDISC:
+		return netlink_qdisc_change(h, ns_id, startup);
+	case RTM_NEWTCLASS:
+	case RTM_DELTCLASS:
+		return netlink_tclass_change(h, ns_id, startup);
+	case RTM_NEWTFILTER:
+	case RTM_DELTFILTER:
+		return netlink_tfilter_change(h, ns_id, startup);
 
 	/* Messages handled in the dplane thread */
 	case RTM_NEWADDR:
@@ -1437,10 +1446,11 @@ static void nl_batch_reset(struct nl_bat
 	bth->msgcnt = 0;
 	bth->zns = NULL;
 
-	TAILQ_INIT(&(bth->ctx_list));
+	dplane_ctx_q_init(&(bth->ctx_list));
 }
 
-static void nl_batch_init(struct nl_batch *bth, struct dplane_ctx_q *ctx_out_q)
+static void nl_batch_init(struct nl_batch *bth,
+			  struct dplane_ctx_list_head *ctx_out_q)
 {
 	/*
 	 * If the size of the buffer has changed, free and then allocate a new
@@ -1640,23 +1650,30 @@ static enum netlink_msg_status nl_put_ms
 	case DPLANE_OP_INTF_DELETE:
 		return netlink_put_intf_update_msg(bth, ctx);
 
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
-		return netlink_put_tc_update_msg(bth, ctx);
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+		return netlink_put_tc_qdisc_update_msg(bth, ctx);
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+		return netlink_put_tc_class_update_msg(bth, ctx);
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
+		return netlink_put_tc_filter_update_msg(bth, ctx);
 	}
 
 	return FRR_NETLINK_ERROR;
 }
 
-void kernel_update_multi(struct dplane_ctx_q *ctx_list)
+void kernel_update_multi(struct dplane_ctx_list_head *ctx_list)
 {
 	struct nl_batch batch;
 	struct zebra_dplane_ctx *ctx;
-	struct dplane_ctx_q handled_list;
+	struct dplane_ctx_list_head handled_list;
 	enum netlink_msg_status res;
 
-	TAILQ_INIT(&handled_list);
+	dplane_ctx_q_init(&handled_list);
 	nl_batch_init(&batch, &handled_list);
 
 	while (true) {
@@ -1687,7 +1704,7 @@ void kernel_update_multi(struct dplane_c
 
 	nl_batch_send(&batch);
 
-	TAILQ_INIT(ctx_list);
+	dplane_ctx_q_init(ctx_list);
 	dplane_ctx_list_append(ctx_list, &handled_list);
 }
 
@@ -1757,15 +1774,16 @@ void kernel_init(struct zebra_ns *zns)
 	 * RTNLGRP_XXX to a bit position for ourself
 	 */
 	groups = RTMGRP_LINK                   |
-		RTMGRP_IPV4_ROUTE              |
-		RTMGRP_IPV4_IFADDR             |
-		RTMGRP_IPV6_ROUTE              |
-		RTMGRP_IPV6_IFADDR             |
-		RTMGRP_IPV4_MROUTE             |
-		RTMGRP_NEIGH                   |
-		((uint32_t) 1 << (RTNLGRP_IPV4_RULE - 1)) |
-		((uint32_t) 1 << (RTNLGRP_IPV6_RULE - 1)) |
-		((uint32_t) 1 << (RTNLGRP_NEXTHOP - 1));
+			RTMGRP_IPV4_ROUTE              |
+			RTMGRP_IPV4_IFADDR             |
+			RTMGRP_IPV6_ROUTE              |
+			RTMGRP_IPV6_IFADDR             |
+			RTMGRP_IPV4_MROUTE             |
+			RTMGRP_NEIGH                   |
+			((uint32_t) 1 << (RTNLGRP_IPV4_RULE - 1)) |
+			((uint32_t) 1 << (RTNLGRP_IPV6_RULE - 1)) |
+			((uint32_t) 1 << (RTNLGRP_NEXTHOP - 1))   |
+			((uint32_t) 1 << (RTNLGRP_TC - 1));
 
 	dplane_groups = (RTMGRP_LINK            |
 			 RTMGRP_IPV4_IFADDR     |
diff -urpN frr-frr-8.4.2/zebra/kernel_socket.c frr-frr-8.5/zebra/kernel_socket.c
--- frr-frr-8.4.2/zebra/kernel_socket.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/kernel_socket.c	2023-03-13 20:01:47.000000000 +0600
@@ -1516,13 +1516,13 @@ int kernel_dplane_read(struct zebra_dpla
 	return 0;
 }
 
-void kernel_update_multi(struct dplane_ctx_q *ctx_list)
+void kernel_update_multi(struct dplane_ctx_list_head *ctx_list)
 {
 	struct zebra_dplane_ctx *ctx;
-	struct dplane_ctx_q handled_list;
+	struct dplane_ctx_list_head handled_list;
 	enum zebra_dplane_result res = ZEBRA_DPLANE_REQUEST_SUCCESS;
 
-	TAILQ_INIT(&handled_list);
+	dplane_ctx_q_init(&handled_list);
 
 	while (true) {
 		ctx = dplane_ctx_dequeue(ctx_list);
@@ -1594,9 +1594,14 @@ void kernel_update_multi(struct dplane_c
 			res = kernel_intf_update(ctx);
 			break;
 
-		case DPLANE_OP_TC_INSTALL:
-		case DPLANE_OP_TC_UPDATE:
-		case DPLANE_OP_TC_DELETE:
+		case DPLANE_OP_TC_QDISC_INSTALL:
+		case DPLANE_OP_TC_QDISC_UNINSTALL:
+		case DPLANE_OP_TC_CLASS_ADD:
+		case DPLANE_OP_TC_CLASS_DELETE:
+		case DPLANE_OP_TC_CLASS_UPDATE:
+		case DPLANE_OP_TC_FILTER_ADD:
+		case DPLANE_OP_TC_FILTER_DELETE:
+		case DPLANE_OP_TC_FILTER_UPDATE:
 			res = kernel_tc_update(ctx);
 			break;
 
@@ -1637,7 +1642,7 @@ void kernel_update_multi(struct dplane_c
 		dplane_ctx_enqueue_tail(&handled_list, ctx);
 	}
 
-	TAILQ_INIT(ctx_list);
+	dplane_ctx_q_init(ctx_list);
 	dplane_ctx_list_append(ctx_list, &handled_list);
 }
 
diff -urpN frr-frr-8.4.2/zebra/main.c frr-frr-8.5/zebra/main.c
--- frr-frr-8.4.2/zebra/main.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/main.c	2023-03-13 20:01:47.000000000 +0600
@@ -221,12 +221,12 @@ void zebra_finalize(struct thread *dummy
 {
 	zlog_info("Zebra final shutdown");
 
-	/* Final shutdown of ns resources */
-	ns_walk_func(zebra_ns_final_shutdown, NULL, NULL);
-
 	/* Stop dplane thread and finish any cleanup */
 	zebra_dplane_shutdown();
 
+	/* Final shutdown of ns resources */
+	ns_walk_func(zebra_ns_final_shutdown, NULL, NULL);
+
 	zebra_router_terminate();
 
 	ns_terminate();
diff -urpN frr-frr-8.4.2/zebra/rib.h frr-frr-8.5/zebra/rib.h
--- frr-frr-8.4.2/zebra/rib.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rib.h	2023-03-13 20:01:47.000000000 +0600
@@ -158,6 +158,13 @@ struct route_entry {
  * differs from the rib/normal set of nexthops.
  */
 #define ROUTE_ENTRY_USE_FIB_NHG      0x40
+/*
+ * Route entries that are going to the dplane for a Route Replace
+ * let's note the fact that this is happening.  This will
+ * be useful when zebra is determing if a route can be
+ * used for nexthops
+ */
+#define ROUTE_ENTRY_ROUTE_REPLACING 0x80
 
 	/* Sequence value incremented for each dataplane operation */
 	uint32_t dplane_sequence;
diff -urpN frr-frr-8.4.2/zebra/rt.h frr-frr-8.5/zebra/rt.h
--- frr-frr-8.4.2/zebra/rt.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rt.h	2023-03-13 20:01:47.000000000 +0600
@@ -35,6 +35,8 @@
 extern "C" {
 #endif
 
+#define ROUTE_INSTALLATION_METRIC 20
+
 #define RKERNEL_ROUTE(type) ((type) == ZEBRA_ROUTE_KERNEL)
 
 #define RSYSTEM_ROUTE(type)                                                    \
@@ -119,7 +121,7 @@ extern int kernel_del_mac_nhg(uint32_t n
 /*
  * Message batching interface.
  */
-extern void kernel_update_multi(struct dplane_ctx_q *ctx_list);
+extern void kernel_update_multi(struct dplane_ctx_list_head *ctx_list);
 
 /*
  * Called by the dplane pthread to read incoming OS messages and dispatch them.
diff -urpN frr-frr-8.4.2/zebra/rt_netlink.c frr-frr-8.5/zebra/rt_netlink.c
--- frr-frr-8.4.2/zebra/rt_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rt_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -223,7 +223,7 @@ static inline bool is_selfroute(int prot
 	return false;
 }
 
-static inline int zebra2proto(int proto)
+int zebra2proto(int proto)
 {
 	switch (proto) {
 	case ZEBRA_ROUTE_BABEL:
@@ -692,8 +692,9 @@ static uint8_t parse_multipath_nexthops_
 }
 
 /* Looking up routing table by netlink interface. */
-static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
-					     int startup)
+int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
+					       ns_id_t ns_id, int startup,
+					       struct zebra_dplane_ctx *ctx)
 {
 	int len;
 	struct rtmsg *rtm;
@@ -768,9 +769,8 @@ static int netlink_route_change_read_uni
 
 	selfroute = is_selfroute(rtm->rtm_protocol);
 
-	if (!startup && selfroute
-	    && h->nlmsg_type == RTM_NEWROUTE
-	    && !zrouter.asic_offloaded) {
+	if (!startup && selfroute && h->nlmsg_type == RTM_NEWROUTE &&
+	    !zrouter.asic_offloaded && !ctx) {
 		if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("Route type: %d Received that we think we have originated, ignoring",
 				   rtm->rtm_protocol);
@@ -803,6 +803,9 @@ static int netlink_route_change_read_uni
 	if (rtm->rtm_flags & RTM_F_OFFLOAD_FAILED)
 		flags |= ZEBRA_FLAG_OFFLOAD_FAILED;
 
+	if (h->nlmsg_flags & NLM_F_APPEND)
+		flags |= ZEBRA_FLAG_OUTOFSYNC;
+
 	/* Route which inserted by Zebra. */
 	if (selfroute) {
 		flags |= ZEBRA_FLAG_SELFROUTE;
@@ -984,10 +987,12 @@ static int netlink_route_change_read_uni
 				}
 			}
 		}
-		if (nhe_id || ng)
-			rib_add_multipath(afi, SAFI_UNICAST, &p, &src_p, re, ng,
-					  startup);
-		else {
+		if (nhe_id || ng) {
+			dplane_rib_add_multipath(afi, SAFI_UNICAST, &p, &src_p,
+						 re, ng, startup, ctx);
+			if (ng)
+				nexthop_group_delete(&ng);
+		} else {
 			/*
 			 * I really don't see how this is possible
 			 * but since we are testing for it let's
@@ -1001,6 +1006,13 @@ static int netlink_route_change_read_uni
 			XFREE(MTYPE_RE, re);
 		}
 	} else {
+		if (ctx) {
+			zlog_err(
+				"%s: %pFX RTM_DELROUTE received but received a context as well",
+				__func__, &p);
+			return 0;
+		}
+
 		if (nhe_id) {
 			rib_delete(afi, SAFI_UNICAST, vrf_id, proto, 0, flags,
 				   &p, &src_p, NULL, nhe_id, table, metric,
@@ -1025,7 +1037,14 @@ static int netlink_route_change_read_uni
 		}
 	}
 
-	return 0;
+	return 1;
+}
+
+static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
+					     int startup)
+{
+	return netlink_route_change_read_unicast_internal(h, ns_id, startup,
+							  NULL);
 }
 
 static struct mcast_route_data *mroute = NULL;
@@ -1540,6 +1559,16 @@ static bool _netlink_route_build_singlep
 						   ctx->table))
 					return false;
 				break;
+			case ZEBRA_SEG6_LOCAL_ACTION_END_DT46:
+				if (!nl_attr_put32(nlmsg, req_size,
+						   SEG6_LOCAL_ACTION,
+						   SEG6_LOCAL_ACTION_END_DT46))
+					return false;
+				if (!nl_attr_put32(nlmsg, req_size,
+						   SEG6_LOCAL_VRFTABLE,
+						   ctx->table))
+					return false;
+				break;
 			default:
 				zlog_err("%s: unsupport seg6local behaviour action=%u",
 					 __func__,
@@ -2048,7 +2077,7 @@ ssize_t netlink_route_multipath_msg_enco
 	 * by the routing protocol and for communicating with protocol peers.
 	 */
 	if (!nl_attr_put32(&req->n, datalen, RTA_PRIORITY,
-			   NL_DEFAULT_ROUTE_METRIC))
+			   ROUTE_INSTALLATION_METRIC))
 		return 0;
 
 #if defined(SUPPORT_REALMS)
@@ -2402,7 +2431,8 @@ int kernel_get_ipmr_sg_stats(struct zebr
 static bool _netlink_nexthop_build_group(struct nlmsghdr *n, size_t req_size,
 					 uint32_t id,
 					 const struct nh_grp *z_grp,
-					 const uint8_t count)
+					 const uint8_t count, bool resilient,
+					 const struct nhg_resilience *nhgr)
 {
 	struct nexthop_grp grp[count];
 	/* Need space for max group size, "/", and null term */
@@ -2432,6 +2462,24 @@ static bool _netlink_nexthop_build_group
 		if (!nl_attr_put(n, req_size, NHA_GROUP, grp,
 				 count * sizeof(*grp)))
 			return false;
+
+		if (resilient) {
+			struct rtattr *nest;
+
+			nest = nl_attr_nest(n, req_size, NHA_RES_GROUP);
+
+			nl_attr_put16(n, req_size, NHA_RES_GROUP_BUCKETS,
+				      nhgr->buckets);
+			nl_attr_put32(n, req_size, NHA_RES_GROUP_IDLE_TIMER,
+				      nhgr->idle_timer * 1000);
+			nl_attr_put32(n, req_size,
+				      NHA_RES_GROUP_UNBALANCED_TIMER,
+				      nhgr->unbalanced_timer * 1000);
+			nl_attr_nest_end(n, nest);
+
+			nl_attr_put16(n, req_size, NHA_GROUP_TYPE,
+				      NEXTHOP_GRP_TYPE_RES);
+		}
 	}
 
 	if (IS_ZEBRA_DEBUG_KERNEL)
@@ -2453,7 +2501,7 @@ static bool _netlink_nexthop_build_group
  */
 ssize_t netlink_nexthop_msg_encode(uint16_t cmd,
 				   const struct zebra_dplane_ctx *ctx,
-				   void *buf, size_t buflen)
+				   void *buf, size_t buflen, bool fpm)
 {
 	struct {
 		struct nlmsghdr n;
@@ -2480,9 +2528,10 @@ ssize_t netlink_nexthop_msg_encode(uint1
 
 	/*
 	 * Nothing to do if the kernel doesn't support nexthop objects or
-	 * we dont want to install this type of NHG
+	 * we dont want to install this type of NHG, but FPM may possible to
+	 * handle this.
 	 */
-	if (!kernel_nexthops_supported()) {
+	if (!fpm && !kernel_nexthops_supported()) {
 		if (IS_ZEBRA_DEBUG_KERNEL || IS_ZEBRA_DEBUG_NHG)
 			zlog_debug(
 				"%s: nhg_id %u (%s): kernel nexthops not supported, ignoring",
@@ -2528,10 +2577,16 @@ ssize_t netlink_nexthop_msg_encode(uint1
 		 * other ids.
 		 */
 		if (dplane_ctx_get_nhe_nh_grp_count(ctx)) {
+			const struct nexthop_group *nhg;
+			const struct nhg_resilience *nhgr;
+
+			nhg = dplane_ctx_get_nhe_ng(ctx);
+			nhgr = &nhg->nhgr;
 			if (!_netlink_nexthop_build_group(
 				    &req->n, buflen, id,
 				    dplane_ctx_get_nhe_nh_grp(ctx),
-				    dplane_ctx_get_nhe_nh_grp_count(ctx)))
+				    dplane_ctx_get_nhe_nh_grp_count(ctx),
+				    !!nhgr->buckets, nhgr))
 				return 0;
 		} else {
 			const struct nexthop *nh =
@@ -2706,6 +2761,18 @@ ssize_t netlink_nexthop_msg_encode(uint1
 							    ctx->table))
 							return 0;
 						break;
+					case SEG6_LOCAL_ACTION_END_DT46:
+						if (!nl_attr_put32(
+							    &req->n, buflen,
+							    SEG6_LOCAL_ACTION,
+							    SEG6_LOCAL_ACTION_END_DT46))
+							return 0;
+						if (!nl_attr_put32(
+							    &req->n, buflen,
+							    SEG6_LOCAL_VRFTABLE,
+							    ctx->table))
+							return 0;
+						break;
 					default:
 						zlog_err("%s: unsupport seg6local behaviour action=%u",
 							 __func__, action);
@@ -2784,7 +2851,7 @@ static ssize_t netlink_nexthop_msg_encod
 		return -1;
 	}
 
-	return netlink_nexthop_msg_encode(cmd, ctx, buf, buflen);
+	return netlink_nexthop_msg_encode(cmd, ctx, buf, buflen, false);
 }
 
 enum netlink_msg_status
@@ -2963,7 +3030,8 @@ static struct nexthop netlink_nexthop_pr
 }
 
 static int netlink_nexthop_process_group(struct rtattr **tb,
-					 struct nh_grp *z_grp, int z_grp_size)
+					 struct nh_grp *z_grp, int z_grp_size,
+					 struct nhg_resilience *nhgr)
 {
 	uint8_t count = 0;
 	/* linux/nexthop.h group struct */
@@ -2982,6 +3050,36 @@ static int netlink_nexthop_process_group
 		z_grp[i].id = n_grp[i].id;
 		z_grp[i].weight = n_grp[i].weight + 1;
 	}
+
+	memset(nhgr, 0, sizeof(*nhgr));
+	if (tb[NHA_RES_GROUP]) {
+		struct rtattr *tbn[NHA_RES_GROUP_MAX + 1];
+		struct rtattr *rta;
+		struct rtattr *res_group = tb[NHA_RES_GROUP];
+
+		netlink_parse_rtattr_nested(tbn, NHA_RES_GROUP_MAX, res_group);
+
+		if (tbn[NHA_RES_GROUP_BUCKETS]) {
+			rta = tbn[NHA_RES_GROUP_BUCKETS];
+			nhgr->buckets = *(uint16_t *)RTA_DATA(rta);
+		}
+
+		if (tbn[NHA_RES_GROUP_IDLE_TIMER]) {
+			rta = tbn[NHA_RES_GROUP_IDLE_TIMER];
+			nhgr->idle_timer = *(uint32_t *)RTA_DATA(rta);
+		}
+
+		if (tbn[NHA_RES_GROUP_UNBALANCED_TIMER]) {
+			rta = tbn[NHA_RES_GROUP_UNBALANCED_TIMER];
+			nhgr->unbalanced_timer = *(uint32_t *)RTA_DATA(rta);
+		}
+
+		if (tbn[NHA_RES_GROUP_UNBALANCED_TIME]) {
+			rta = tbn[NHA_RES_GROUP_UNBALANCED_TIME];
+			nhgr->unbalanced_time = *(uint64_t *)RTA_DATA(rta);
+		}
+	}
+
 	return count;
 }
 
@@ -3065,13 +3163,15 @@ int netlink_nexthop_change(struct nlmsgh
 
 
 	if (h->nlmsg_type == RTM_NEWNEXTHOP) {
+		struct nhg_resilience nhgr = {};
+
 		if (tb[NHA_GROUP]) {
 			/**
 			 * If this is a group message its only going to have
 			 * an array of nexthop IDs associated with it
 			 */
 			grp_count = netlink_nexthop_process_group(
-				tb, grp, array_size(grp));
+				tb, grp, array_size(grp), &nhgr);
 		} else {
 			if (tb[NHA_BLACKHOLE]) {
 				/**
@@ -3103,7 +3203,7 @@ int netlink_nexthop_change(struct nlmsgh
 		}
 
 		if (zebra_nhg_kernel_find(id, &nh, grp, grp_count, vrf_id, afi,
-					  type, startup))
+					  type, startup, &nhgr))
 			return -1;
 
 	} else if (h->nlmsg_type == RTM_DELNEXTHOP)
@@ -4289,7 +4389,7 @@ static ssize_t netlink_neigh_update_ctx(
 			"Tx %s family %s IF %s(%u) Neigh %pIA %s %s flags 0x%x state 0x%x %sext_flags 0x%x",
 			nl_msg_type_to_str(cmd), nl_family_to_str(family),
 			dplane_ctx_get_ifname(ctx), dplane_ctx_get_ifindex(ctx),
-			ip, link_ip ? "Link " : "MAC ", buf2, flags, state,
+			ip, link_ip ? "Link" : "MAC", buf2, flags, state,
 			ext ? "ext " : "", ext_flags);
 
 	return netlink_neigh_update_msg_encode(
diff -urpN frr-frr-8.4.2/zebra/rt_netlink.h frr-frr-8.5/zebra/rt_netlink.h
--- frr-frr-8.4.2/zebra/rt_netlink.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rt_netlink.h	2023-03-13 20:01:47.000000000 +0600
@@ -30,7 +30,6 @@
 extern "C" {
 #endif
 
-#define NL_DEFAULT_ROUTE_METRIC 20
 
 /*
  * Additional protocol strings to push into routes
@@ -84,7 +83,7 @@ extern int netlink_nexthop_change(struct
 extern int netlink_nexthop_read(struct zebra_ns *zns);
 extern ssize_t netlink_nexthop_msg_encode(uint16_t cmd,
 					  const struct zebra_dplane_ctx *ctx,
-					  void *buf, size_t buflen);
+					  void *buf, size_t buflen, bool fpm);
 
 extern ssize_t netlink_lsp_msg_encoder(struct zebra_dplane_ctx *ctx, void *buf,
 				       size_t buflen);
@@ -122,6 +121,10 @@ netlink_put_lsp_update_msg(struct nl_bat
 extern enum netlink_msg_status
 netlink_put_pw_update_msg(struct nl_batch *bth, struct zebra_dplane_ctx *ctx);
 
+int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
+					       ns_id_t ns_id, int startup,
+					       struct zebra_dplane_ctx *ctx);
+
 #ifdef NETLINK_DEBUG
 const char *nlmsg_type2str(uint16_t type);
 const char *af_type2str(int type);
@@ -147,6 +150,9 @@ const char *ifa_flags2str(uint32_t flags
 const char *nh_flags2str(uint32_t flags, char *buf, size_t buflen);
 
 void nl_dump(void *msg, size_t msglen);
+
+extern int zebra2proto(int proto);
+
 #endif /* NETLINK_DEBUG */
 
 #ifdef __cplusplus
diff -urpN frr-frr-8.4.2/zebra/rtadv.c frr-frr-8.5/zebra/rtadv.c
--- frr-frr-8.4.2/zebra/rtadv.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rtadv.c	2023-03-13 20:01:47.000000000 +0600
@@ -51,9 +51,7 @@ static uint32_t interfaces_configured_fo
 
 #if defined(HAVE_RTADV)
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/rtadv_clippy.c"
-#endif
 
 DEFINE_MTYPE_STATIC(ZEBRA, RTADV_PREFIX, "Router Advertisement Prefix");
 DEFINE_MTYPE_STATIC(ZEBRA, ADV_IF, "Advertised Interface");
@@ -587,6 +585,28 @@ static void rtadv_process_solicit(struct
 		zif->rtadv.AdvIntervalTimer = MIN_DELAY_BETWEEN_RAS;
 }
 
+static const char *rtadv_optionalhdr2str(uint8_t opt_type)
+{
+	switch (opt_type) {
+	case ND_OPT_SOURCE_LINKADDR:
+		return "Optional Source Link Address";
+	case ND_OPT_TARGET_LINKADDR:
+		return "Optional Target Link Address";
+	case ND_OPT_PREFIX_INFORMATION:
+		return "Optional Prefix Information";
+	case ND_OPT_REDIRECTED_HEADER:
+		return "Optional Redirected Header";
+	case ND_OPT_MTU:
+		return "Optional MTU";
+	case ND_OPT_RTR_ADV_INTERVAL:
+		return "Optional Advertisement Interval";
+	case ND_OPT_HOME_AGENT_INFO:
+		return "Optional Home Agent Information";
+	}
+
+	return "Unknown Optional Type";
+}
+
 /*
  * This function processes optional attributes off of
  * end of a RA packet received.  At this point in
@@ -611,6 +631,13 @@ static void rtadv_process_optional(uint8
 							  &addr->sin6_addr, 1);
 			break;
 		default:
+			if (IS_ZEBRA_DEBUG_PACKET)
+				zlog_debug(
+					"%s:Received Packet with optional Header type %s(%u) that is being ignored",
+					__func__,
+					rtadv_optionalhdr2str(
+						opt_hdr->nd_opt_type),
+					opt_hdr->nd_opt_type);
 			break;
 		}
 
@@ -664,8 +691,9 @@ static void rtadv_process_advert(uint8_t
 	     zif->rtadv.lastadvcurhoplimit.tv_sec == 0)) {
 		flog_warn(
 			EC_ZEBRA_RA_PARAM_MISMATCH,
-			"%s(%u): Rx RA - our AdvCurHopLimit doesn't agree with %s",
-			ifp->name, ifp->ifindex, addr_str);
+			"%s(%u): Rx RA - our AdvCurHopLimit (%u) doesn't agree with %s (%u)",
+			ifp->name, ifp->ifindex, zif->rtadv.AdvCurHopLimit,
+			addr_str, radvert->nd_ra_curhoplimit);
 		monotime(&zif->rtadv.lastadvcurhoplimit);
 	}
 
@@ -676,8 +704,11 @@ static void rtadv_process_advert(uint8_t
 	     zif->rtadv.lastadvmanagedflag.tv_sec == 0)) {
 		flog_warn(
 			EC_ZEBRA_RA_PARAM_MISMATCH,
-			"%s(%u): Rx RA - our AdvManagedFlag doesn't agree with %s",
-			ifp->name, ifp->ifindex, addr_str);
+			"%s(%u): Rx RA - our AdvManagedFlag (%u) doesn't agree with %s (%u)",
+			ifp->name, ifp->ifindex, zif->rtadv.AdvManagedFlag,
+			addr_str,
+			!!CHECK_FLAG(radvert->nd_ra_flags_reserved,
+				     ND_RA_FLAG_MANAGED));
 		monotime(&zif->rtadv.lastadvmanagedflag);
 	}
 
@@ -688,8 +719,11 @@ static void rtadv_process_advert(uint8_t
 	     zif->rtadv.lastadvotherconfigflag.tv_sec == 0)) {
 		flog_warn(
 			EC_ZEBRA_RA_PARAM_MISMATCH,
-			"%s(%u): Rx RA - our AdvOtherConfigFlag doesn't agree with %s",
-			ifp->name, ifp->ifindex, addr_str);
+			"%s(%u): Rx RA - our AdvOtherConfigFlag (%u) doesn't agree with %s (%u)",
+			ifp->name, ifp->ifindex, zif->rtadv.AdvOtherConfigFlag,
+			addr_str,
+			!!CHECK_FLAG(radvert->nd_ra_flags_reserved,
+				     ND_RA_FLAG_OTHER));
 		monotime(&zif->rtadv.lastadvotherconfigflag);
 	}
 
@@ -700,20 +734,23 @@ static void rtadv_process_advert(uint8_t
 	     zif->rtadv.lastadvreachabletime.tv_sec == 0)) {
 		flog_warn(
 			EC_ZEBRA_RA_PARAM_MISMATCH,
-			"%s(%u): Rx RA - our AdvReachableTime doesn't agree with %s",
-			ifp->name, ifp->ifindex, addr_str);
+			"%s(%u): Rx RA - our AdvReachableTime (%u) doesn't agree with %s (%u)",
+			ifp->name, ifp->ifindex, zif->rtadv.AdvReachableTime,
+			addr_str, ntohl(radvert->nd_ra_reachable));
 		monotime(&zif->rtadv.lastadvreachabletime);
 	}
 
-	if ((ntohl(radvert->nd_ra_retransmit) !=
+	if ((radvert->nd_ra_retransmit && zif->rtadv.AdvRetransTimer) &&
+	    (ntohl(radvert->nd_ra_retransmit) !=
 	     (unsigned int)zif->rtadv.AdvRetransTimer) &&
 	    (monotime_since(&zif->rtadv.lastadvretranstimer, NULL) >
 		     SIXHOUR2USEC ||
 	     zif->rtadv.lastadvretranstimer.tv_sec == 0)) {
 		flog_warn(
 			EC_ZEBRA_RA_PARAM_MISMATCH,
-			"%s(%u): Rx RA - our AdvRetransTimer doesn't agree with %s",
-			ifp->name, ifp->ifindex, addr_str);
+			"%s(%u): Rx RA - our AdvRetransTimer (%u) doesn't agree with %s (%u)",
+			ifp->name, ifp->ifindex, zif->rtadv.AdvRetransTimer,
+			addr_str, ntohl(radvert->nd_ra_retransmit));
 		monotime(&zif->rtadv.lastadvretranstimer);
 	}
 
diff -urpN frr-frr-8.4.2/zebra/rtadv.h frr-frr-8.5/zebra/rtadv.h
--- frr-frr-8.4.2/zebra/rtadv.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rtadv.h	2023-03-13 20:01:47.000000000 +0600
@@ -308,6 +308,7 @@ struct rtadv_prefix {
 #define ND_OPT_HA_INFORMATION	8   /* HA Information Option */
 #endif
 
+
 #ifndef HAVE_STRUCT_ND_OPT_ADV_INTERVAL
 struct nd_opt_adv_interval { /* Advertisement interval option */
 	uint8_t nd_opt_ai_type;
@@ -324,6 +325,12 @@ struct nd_opt_adv_interval { /* Advertis
 #define nd_opt_ai_interval	nd_opt_adv_interval_ival
 #endif
 #endif
+#ifndef ND_OPT_RTR_ADV_INTERVAL
+#define ND_OPT_RTR_ADV_INTERVAL 7
+#endif
+#ifndef ND_OPT_HOME_AGENT_INFO
+#define ND_OPT_HOME_AGENT_INFO 8
+#endif
 
 #ifndef HAVE_STRUCT_ND_OPT_HOMEAGENT_INFO
 struct nd_opt_homeagent_info { /* Home Agent info */
diff -urpN frr-frr-8.4.2/zebra/rtread_netlink.c frr-frr-8.5/zebra/rtread_netlink.c
--- frr-frr-8.4.2/zebra/rtread_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rtread_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -26,8 +26,10 @@
 #include "vty.h"
 #include "zebra/rt.h"
 #include "zebra/zebra_pbr.h"
+#include "zebra/zebra_tc.h"
 #include "zebra/rt_netlink.h"
 #include "zebra/rule_netlink.h"
+#include "zebra/tc_netlink.h"
 
 void route_read(struct zebra_ns *zns)
 {
@@ -71,4 +73,9 @@ void kernel_read_pbr_rules(struct zebra_
 	netlink_rules_read(zns);
 }
 
+void kernel_read_tc_qdisc(struct zebra_ns *zns)
+{
+	netlink_qdisc_read(zns);
+}
+
 #endif /* GNU_LINUX */
diff -urpN frr-frr-8.4.2/zebra/rtread_sysctl.c frr-frr-8.5/zebra/rtread_sysctl.c
--- frr-frr-8.4.2/zebra/rtread_sysctl.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/rtread_sysctl.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,6 +30,7 @@
 #include "zebra/rt.h"
 #include "zebra/kernel_socket.h"
 #include "zebra/zebra_pbr.h"
+#include "zebra/zebra_tc.h"
 #include "zebra/zebra_errors.h"
 
 /* Kernel routing table read up by sysctl function. */
@@ -108,4 +109,8 @@ void kernel_read_pbr_rules(struct zebra_
 {
 }
 
+void kernel_read_tc_qdisc(struct zebra_ns *zns)
+{
+}
+
 #endif /* !defined(GNU_LINUX) */
diff -urpN frr-frr-8.4.2/zebra/subdir.am frr-frr-8.5/zebra/subdir.am
--- frr-frr-8.4.2/zebra/subdir.am	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/subdir.am	2023-03-13 20:01:47.000000000 +0600
@@ -4,29 +4,6 @@
 
 if ZEBRA
 sbin_PROGRAMS += zebra/zebra
-vtysh_scan += \
-	zebra/debug.c \
-	zebra/interface.c \
-	zebra/router-id.c \
-	zebra/rtadv.c \
-	zebra/zebra_gr.c \
-	zebra/zebra_mlag_vty.c \
-	zebra/zebra_evpn_mh.c \
-	zebra/zebra_mpls_vty.c \
-	zebra/zebra_srv6_vty.c \
-	zebra/zebra_ptm.c \
-	zebra/zebra_pw.c \
-	zebra/zebra_routemap.c \
-	zebra/zebra_vty.c \
-	zebra/zserv.c \
-	zebra/zebra_vrf.c \
-	zebra/dpdk/zebra_dplane_dpdk_vty.c \
-	# end
-
-# can be loaded as DSO - always include for vtysh
-vtysh_scan += zebra/irdp_interface.c
-vtysh_scan += zebra/zebra_fpm.c
-
 vtysh_daemons += zebra
 
 if IRDP
@@ -123,6 +100,7 @@ zebra_zebra_SOURCES = \
 	zebra/zebra_routemap_nb_config.c \
 	zebra/zebra_script.c \
 	zebra/zebra_srte.c \
+	zebra/zebra_tc.c \
 	zebra/zebra_trace.c \
 	zebra/zebra_vrf.c \
 	zebra/zebra_vty.c \
@@ -198,6 +176,7 @@ noinst_HEADERS += \
 	zebra/zebra_router.h \
 	zebra/zebra_script.h \
 	zebra/zebra_srte.h \
+	zebra/zebra_tc.h \
 	zebra/zebra_trace.h \
 	zebra/zebra_vrf.h \
 	zebra/zebra_vxlan.h \
@@ -255,8 +234,6 @@ module_LTLIBRARIES += zebra/dplane_fpm_n
 zebra_dplane_fpm_nl_la_SOURCES = zebra/dplane_fpm_nl.c
 zebra_dplane_fpm_nl_la_LDFLAGS = $(MODULE_LDFLAGS)
 zebra_dplane_fpm_nl_la_LIBADD  =
-
-vtysh_scan += zebra/dplane_fpm_nl.c
 endif
 
 if NETLINK_DEBUG
diff -urpN frr-frr-8.4.2/zebra/tc_netlink.c frr-frr-8.5/zebra/tc_netlink.c
--- frr-frr-8.4.2/zebra/tc_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/tc_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -3,28 +3,27 @@
  *
  * Copyright (C) 2022 Shichu Yang
  *
- * This file is part of FRR.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
  *
- * FRR is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
- * FRR is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FRR; see the file COPYING.  If not, write to the Free
- * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #include <zebra.h>
 
 #ifdef HAVE_NETLINK
 
+#include <linux/pkt_cls.h>
+#include <linux/pkt_sched.h>
 #include <netinet/if_ether.h>
 #include <sys/socket.h>
 
@@ -32,34 +31,24 @@
 #include "prefix.h"
 #include "vrf.h"
 
-#include <linux/fib_rules.h>
-#include <linux/pkt_cls.h>
-#include <linux/pkt_sched.h>
 #include "zebra/zserv.h"
 #include "zebra/zebra_ns.h"
-#include "zebra/zebra_vrf.h"
 #include "zebra/rt.h"
 #include "zebra/interface.h"
 #include "zebra/debug.h"
-#include "zebra/rtadv.h"
 #include "zebra/kernel_netlink.h"
 #include "zebra/tc_netlink.h"
 #include "zebra/zebra_errors.h"
 #include "zebra/zebra_dplane.h"
+#include "zebra/zebra_tc.h"
 #include "zebra/zebra_trace.h"
 
-/* TODO: move these bitflags to zebra_tc.h */
-#define TC_FILTER_SRC_IP (1 << 0)
-#define TC_FILTER_DST_IP (1 << 1)
-#define TC_FILTER_IP_PROTOCOL (1 << 9)
-
 #define TC_FREQ_DEFAULT (100)
 
-#define TC_MAJOR_BASE (0x1000u)
+/* some magic number */
+#define TC_QDISC_MAJOR_ZEBRA (0xbeef0000u)
 #define TC_MINOR_NOCLASS (0xffffu)
 
-#define TC_FILTER_MASK (0x8000u)
-
 #define TIME_UNITS_PER_SEC (1000000)
 #define xmittime(r, s) (TIME_UNITS_PER_SEC * ((double)(s) / (double)(r)))
 
@@ -81,19 +70,6 @@ static uint32_t tc_get_freq(void)
 	return freq == 0 ? TC_FREQ_DEFAULT : freq;
 }
 
-static inline uint32_t tc_make_handle(uint16_t major, uint16_t minor)
-{
-	return (major) << 16 | (minor);
-}
-
-static inline uint32_t tc_get_handle(struct zebra_dplane_ctx *ctx,
-				     uint16_t minor)
-{
-	uint16_t major = TC_MAJOR_BASE + (uint16_t)dplane_ctx_get_ifindex(ctx);
-
-	return tc_make_handle(major, minor);
-}
-
 static void tc_calc_rate_table(struct tc_ratespec *ratespec, uint32_t *table,
 			       uint32_t mtu)
 {
@@ -189,11 +165,7 @@ static ssize_t netlink_qdisc_msg_encode(
 					void *data, size_t datalen)
 {
 	struct nlsock *nl;
-
-	const char *kind = "htb";
-
-	struct tc_htb_glob htb_glob = {
-		.rate2quantum = 10, .version = 3, .defcls = TC_MINOR_NOCLASS};
+	const char *kind_str = NULL;
 
 	struct rtattr *nest;
 
@@ -221,16 +193,41 @@ static ssize_t netlink_qdisc_msg_encode(
 
 	req->t.tcm_family = AF_UNSPEC;
 	req->t.tcm_ifindex = dplane_ctx_get_ifindex(ctx);
-	req->t.tcm_handle = tc_get_handle(ctx, 0);
+	req->t.tcm_info = 0;
+	req->t.tcm_handle = 0;
 	req->t.tcm_parent = TC_H_ROOT;
 
-	nl_attr_put(&req->n, datalen, TCA_KIND, kind, strlen(kind) + 1);
+	if (cmd == RTM_NEWQDISC) {
+		req->t.tcm_handle = TC_H_MAKE(TC_QDISC_MAJOR_ZEBRA, 0);
 
-	nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
+		kind_str = dplane_ctx_tc_qdisc_get_kind_str(ctx);
 
-	nl_attr_put(&req->n, datalen, TCA_HTB_INIT, &htb_glob,
-		    sizeof(htb_glob));
-	nl_attr_nest_end(&req->n, nest);
+		nl_attr_put(&req->n, datalen, TCA_KIND, kind_str,
+			    strlen(kind_str) + 1);
+
+		nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
+
+		switch (dplane_ctx_tc_qdisc_get_kind(ctx)) {
+		case TC_QDISC_HTB: {
+			struct tc_htb_glob htb_glob = {
+				.rate2quantum = 10,
+				.version = 3,
+				.defcls = TC_MINOR_NOCLASS};
+			nl_attr_put(&req->n, datalen, TCA_HTB_INIT, &htb_glob,
+				    sizeof(htb_glob));
+			break;
+		}
+		case TC_QDISC_NOQUEUE:
+			break;
+		default:
+			break;
+			/* not implemented */
+		}
+
+		nl_attr_nest_end(&req->n, nest);
+	} else {
+		/* ifindex are enough for del/get qdisc */
+	}
 
 	return NLMSG_ALIGN(req->n.nlmsg_len);
 }
@@ -241,17 +238,10 @@ static ssize_t netlink_qdisc_msg_encode(
 static ssize_t netlink_tclass_msg_encode(int cmd, struct zebra_dplane_ctx *ctx,
 					 void *data, size_t datalen)
 {
-	struct nlsock *nl;
-	struct tc_htb_opt htb_opt = {};
-
-	uint64_t rate, ceil;
-	uint64_t buffer, cbuffer;
+	enum dplane_op_e op = dplane_ctx_get_op(ctx);
 
-	/* TODO: fetch mtu from interface */
-	uint32_t mtu = 0;
-
-	uint32_t rtab[256];
-	uint32_t ctab[256];
+	struct nlsock *nl;
+	const char *kind_str = NULL;
 
 	struct rtattr *nest;
 
@@ -271,73 +261,239 @@ static ssize_t netlink_tclass_msg_encode
 	req->n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
 	req->n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;
 
+	if (op == DPLANE_OP_TC_CLASS_UPDATE)
+		req->n.nlmsg_flags |= NLM_F_REPLACE;
+
 	req->n.nlmsg_type = cmd;
 
 	req->n.nlmsg_pid = nl->snl.nl_pid;
 
 	req->t.tcm_family = AF_UNSPEC;
 	req->t.tcm_ifindex = dplane_ctx_get_ifindex(ctx);
-	req->t.tcm_handle = tc_get_handle(ctx, 1);
-	req->t.tcm_parent = tc_get_handle(ctx, 0);
 
-	rate = dplane_ctx_tc_get_rate(ctx);
-	ceil = dplane_ctx_tc_get_ceil(ctx);
+	req->t.tcm_handle = TC_H_MAKE(TC_QDISC_MAJOR_ZEBRA,
+				      dplane_ctx_tc_class_get_handle(ctx));
+	req->t.tcm_parent = TC_H_MAKE(TC_QDISC_MAJOR_ZEBRA, 0);
+	req->t.tcm_info = 0;
+
+	kind_str = dplane_ctx_tc_class_get_kind_str(ctx);
+
+	if (op == DPLANE_OP_TC_CLASS_ADD || op == DPLANE_OP_TC_CLASS_UPDATE) {
+		zlog_debug("netlink tclass encoder: op: %s kind: %s handle: %u",
+			   op == DPLANE_OP_TC_CLASS_UPDATE ? "update" : "add",
+			   kind_str, dplane_ctx_tc_class_get_handle(ctx));
+
+		nl_attr_put(&req->n, datalen, TCA_KIND, kind_str,
+			    strlen(kind_str) + 1);
+
+		nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
 
-	ceil = ceil < rate ? rate : ceil;
+		switch (dplane_ctx_tc_class_get_kind(ctx)) {
+		case TC_QDISC_HTB: {
+			struct tc_htb_opt htb_opt = {};
 
-	htb_opt.rate.rate = (rate >> 32 != 0) ? ~0U : rate;
-	htb_opt.ceil.rate = (ceil >> 32 != 0) ? ~0U : ceil;
+			uint64_t rate = dplane_ctx_tc_class_get_rate(ctx),
+				 ceil = dplane_ctx_tc_class_get_ceil(ctx);
 
-	buffer = rate / tc_get_freq(), cbuffer = ceil / tc_get_freq();
+			uint64_t buffer, cbuffer;
 
-	htb_opt.buffer = buffer;
-	htb_opt.cbuffer = cbuffer;
+			/* TODO: fetch mtu from interface */
+			uint32_t mtu = 1500;
 
-	tc_calc_rate_table(&htb_opt.rate, rtab, mtu);
-	tc_calc_rate_table(&htb_opt.ceil, ctab, mtu);
+			uint32_t rtab[256];
+			uint32_t ctab[256];
 
-	htb_opt.ceil.mpu = htb_opt.rate.mpu = 0;
-	htb_opt.ceil.overhead = htb_opt.rate.overhead = 0;
+			ceil = MAX(rate, ceil);
 
-	nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
+			htb_opt.rate.rate = (rate >> 32 != 0) ? ~0U : rate;
+			htb_opt.ceil.rate = (ceil >> 32 != 0) ? ~0U : ceil;
 
-	if (rate >> 32 != 0) {
-		nl_attr_put(&req->n, datalen, TCA_HTB_CEIL64, &rate,
-			    sizeof(rate));
+			buffer = rate / tc_get_freq() + mtu;
+			cbuffer = ceil / tc_get_freq() + mtu;
+
+			htb_opt.buffer = buffer;
+			htb_opt.cbuffer = cbuffer;
+
+			tc_calc_rate_table(&htb_opt.rate, rtab, mtu);
+			tc_calc_rate_table(&htb_opt.ceil, ctab, mtu);
+
+			htb_opt.ceil.mpu = htb_opt.rate.mpu = 0;
+			htb_opt.ceil.overhead = htb_opt.rate.overhead = 0;
+
+			if (rate >> 32 != 0) {
+				nl_attr_put(&req->n, datalen, TCA_HTB_RATE64,
+					    &rate, sizeof(rate));
+			}
+
+			if (ceil >> 32 != 0) {
+				nl_attr_put(&req->n, datalen, TCA_HTB_CEIL64,
+					    &ceil, sizeof(ceil));
+			}
+
+			nl_attr_put(&req->n, datalen, TCA_HTB_PARMS, &htb_opt,
+				    sizeof(htb_opt));
+
+			nl_attr_put(&req->n, datalen, TCA_HTB_RTAB, rtab,
+				    sizeof(rtab));
+			nl_attr_put(&req->n, datalen, TCA_HTB_CTAB, ctab,
+				    sizeof(ctab));
+			break;
+		}
+		default:
+			break;
+		}
+
+		nl_attr_nest_end(&req->n, nest);
 	}
 
-	if (ceil >> 32 != 0) {
-		nl_attr_put(&req->n, datalen, TCA_HTB_CEIL64, &ceil,
-			    sizeof(ceil));
+	return NLMSG_ALIGN(req->n.nlmsg_len);
+}
+
+static int netlink_tfilter_flower_port_type(uint8_t ip_proto, bool src)
+{
+	if (ip_proto == IPPROTO_TCP)
+		return src ? TCA_FLOWER_KEY_TCP_SRC : TCA_FLOWER_KEY_TCP_DST;
+	else if (ip_proto == IPPROTO_UDP)
+		return src ? TCA_FLOWER_KEY_UDP_SRC : TCA_FLOWER_KEY_UDP_DST;
+	else if (ip_proto == IPPROTO_SCTP)
+		return src ? TCA_FLOWER_KEY_SCTP_SRC : TCA_FLOWER_KEY_SCTP_DST;
+	else
+		return -1;
+}
+
+static void netlink_tfilter_flower_put_options(struct nlmsghdr *n,
+					       size_t datalen,
+					       struct zebra_dplane_ctx *ctx)
+{
+	struct inet_prefix addr;
+	uint32_t flags = 0, classid;
+	uint8_t protocol = htons(dplane_ctx_tc_filter_get_eth_proto(ctx));
+	uint32_t filter_bm = dplane_ctx_tc_filter_get_filter_bm(ctx);
+
+	if (filter_bm & TC_FLOWER_SRC_IP) {
+		const struct prefix *src_p =
+			dplane_ctx_tc_filter_get_src_ip(ctx);
+
+		if (tc_flower_get_inet_prefix(src_p, &addr) != 0)
+			return;
+
+		nl_attr_put(n, datalen,
+			    (addr.family == AF_INET) ? TCA_FLOWER_KEY_IPV4_SRC
+						     : TCA_FLOWER_KEY_IPV6_SRC,
+			    addr.data, addr.bytelen);
+
+		if (tc_flower_get_inet_mask(src_p, &addr) != 0)
+			return;
+
+		nl_attr_put(n, datalen,
+			    (addr.family == AF_INET)
+				    ? TCA_FLOWER_KEY_IPV4_SRC_MASK
+				    : TCA_FLOWER_KEY_IPV6_SRC_MASK,
+			    addr.data, addr.bytelen);
 	}
 
-	nl_attr_put(&req->n, datalen, TCA_HTB_PARMS, &htb_opt, sizeof(htb_opt));
+	if (filter_bm & TC_FLOWER_DST_IP) {
+		const struct prefix *dst_p =
+			dplane_ctx_tc_filter_get_dst_ip(ctx);
 
-	nl_attr_put(&req->n, datalen, TCA_HTB_RTAB, rtab, sizeof(rtab));
-	nl_attr_put(&req->n, datalen, TCA_HTB_CTAB, ctab, sizeof(ctab));
-	nl_attr_nest_end(&req->n, nest);
+		if (tc_flower_get_inet_prefix(dst_p, &addr) != 0)
+			return;
 
-	return NLMSG_ALIGN(req->n.nlmsg_len);
+		nl_attr_put(n, datalen,
+			    (addr.family == AF_INET) ? TCA_FLOWER_KEY_IPV4_DST
+						     : TCA_FLOWER_KEY_IPV6_DST,
+			    addr.data, addr.bytelen);
+
+		if (tc_flower_get_inet_mask(dst_p, &addr) != 0)
+			return;
+
+		nl_attr_put(n, datalen,
+			    (addr.family == AF_INET)
+				    ? TCA_FLOWER_KEY_IPV4_DST_MASK
+				    : TCA_FLOWER_KEY_IPV6_DST_MASK,
+			    addr.data, addr.bytelen);
+	}
+
+	if (filter_bm & TC_FLOWER_IP_PROTOCOL) {
+		nl_attr_put8(n, datalen, TCA_FLOWER_KEY_IP_PROTO,
+			     dplane_ctx_tc_filter_get_ip_proto(ctx));
+	}
+
+	if (filter_bm & TC_FLOWER_SRC_PORT) {
+		uint16_t min, max;
+
+		min = dplane_ctx_tc_filter_get_src_port_min(ctx);
+		max = dplane_ctx_tc_filter_get_src_port_max(ctx);
+
+		if (max > min) {
+			nl_attr_put16(n, datalen, TCA_FLOWER_KEY_PORT_SRC_MIN,
+				      htons(min));
+
+			nl_attr_put16(n, datalen, TCA_FLOWER_KEY_PORT_SRC_MAX,
+				      htons(max));
+		} else {
+			int type = netlink_tfilter_flower_port_type(
+				dplane_ctx_tc_filter_get_ip_proto(ctx), true);
+
+			if (type < 0)
+				return;
+
+			nl_attr_put16(n, datalen, type, htons(min));
+		}
+	}
+
+	if (filter_bm & TC_FLOWER_DST_PORT) {
+		uint16_t min = dplane_ctx_tc_filter_get_dst_port_min(ctx),
+			 max = dplane_ctx_tc_filter_get_dst_port_max(ctx);
+
+		if (max > min) {
+			nl_attr_put16(n, datalen, TCA_FLOWER_KEY_PORT_DST_MIN,
+				      htons(min));
+
+			nl_attr_put16(n, datalen, TCA_FLOWER_KEY_PORT_DST_MAX,
+				      htons(max));
+		} else {
+			int type = netlink_tfilter_flower_port_type(
+				dplane_ctx_tc_filter_get_ip_proto(ctx), false);
+
+			if (type < 0)
+				return;
+
+			nl_attr_put16(n, datalen, type, htons(min));
+		}
+	}
+
+	if (filter_bm & TC_FLOWER_DSFIELD) {
+		nl_attr_put8(n, datalen, TCA_FLOWER_KEY_IP_TOS,
+			     dplane_ctx_tc_filter_get_dsfield(ctx));
+		nl_attr_put8(n, datalen, TCA_FLOWER_KEY_IP_TOS_MASK,
+			     dplane_ctx_tc_filter_get_dsfield_mask(ctx));
+	}
+
+	classid = TC_H_MAKE(TC_QDISC_MAJOR_ZEBRA,
+			    dplane_ctx_tc_filter_get_classid(ctx));
+	nl_attr_put32(n, datalen, TCA_FLOWER_CLASSID, classid);
+
+	nl_attr_put32(n, datalen, TCA_FLOWER_FLAGS, flags);
+
+	nl_attr_put16(n, datalen, TCA_FLOWER_KEY_ETH_TYPE, protocol);
 }
 
 /*
- * Traffic control filter encoding (only "flower" supported)
+ * Traffic control filter encoding
  */
 static ssize_t netlink_tfilter_msg_encode(int cmd, struct zebra_dplane_ctx *ctx,
 					  void *data, size_t datalen)
 {
+	enum dplane_op_e op = dplane_ctx_get_op(ctx);
+
 	struct nlsock *nl;
-	struct rtattr *nest;
+	const char *kind_str = NULL;
 
-	const char *kind = "flower";
+	struct rtattr *nest;
 
 	uint16_t priority;
 	uint16_t protocol;
-	uint32_t classid;
-	uint32_t filter_bm;
-	uint32_t flags = 0;
-
-	struct inet_prefix addr;
 
 	struct {
 		struct nlmsghdr n;
@@ -355,7 +511,8 @@ static ssize_t netlink_tfilter_msg_encod
 	req->n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
 	req->n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;
 
-	req->n.nlmsg_flags |= NLM_F_EXCL;
+	if (op == DPLANE_OP_TC_FILTER_UPDATE)
+		req->n.nlmsg_flags |= NLM_F_REPLACE;
 
 	req->n.nlmsg_type = cmd;
 
@@ -364,105 +521,361 @@ static ssize_t netlink_tfilter_msg_encod
 	req->t.tcm_family = AF_UNSPEC;
 	req->t.tcm_ifindex = dplane_ctx_get_ifindex(ctx);
 
-	/* TODO: priority and layer-3 protocol support */
-	priority = 0;
-	protocol = htons(ETH_P_IP);
-	classid = tc_get_handle(ctx, 1);
-	filter_bm = dplane_ctx_tc_get_filter_bm(ctx);
+	priority = dplane_ctx_tc_filter_get_priority(ctx);
+	protocol = htons(dplane_ctx_tc_filter_get_eth_proto(ctx));
+
+	req->t.tcm_info = TC_H_MAKE(priority << 16, protocol);
+	req->t.tcm_handle = dplane_ctx_tc_filter_get_handle(ctx);
+	req->t.tcm_parent = TC_H_MAKE(TC_QDISC_MAJOR_ZEBRA, 0);
+
+	kind_str = dplane_ctx_tc_filter_get_kind_str(ctx);
+
+	if (op == DPLANE_OP_TC_FILTER_ADD || op == DPLANE_OP_TC_FILTER_UPDATE) {
+		nl_attr_put(&req->n, datalen, TCA_KIND, kind_str,
+			    strlen(kind_str) + 1);
+
+		zlog_debug(
+			"netlink tfilter encoder: op: %s priority: %u protocol: %u kind: %s handle: %u filter_bm: %u ip_proto: %u",
+			op == DPLANE_OP_TC_FILTER_UPDATE ? "update" : "add",
+			priority, protocol, kind_str,
+			dplane_ctx_tc_filter_get_handle(ctx),
+			dplane_ctx_tc_filter_get_filter_bm(ctx),
+			dplane_ctx_tc_filter_get_ip_proto(ctx));
+
+		nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
+		switch (dplane_ctx_tc_filter_get_kind(ctx)) {
+		case TC_FILTER_FLOWER: {
+			netlink_tfilter_flower_put_options(&req->n, datalen,
+							   ctx);
+			break;
+		}
+		default:
+			break;
+		}
+		nl_attr_nest_end(&req->n, nest);
+	}
+
+	return NLMSG_ALIGN(req->n.nlmsg_len);
+}
+
+static ssize_t netlink_newqdisc_msg_encoder(struct zebra_dplane_ctx *ctx,
+					    void *buf, size_t buflen)
+{
+	return netlink_qdisc_msg_encode(RTM_NEWQDISC, ctx, buf, buflen);
+}
+
+static ssize_t netlink_delqdisc_msg_encoder(struct zebra_dplane_ctx *ctx,
+					    void *buf, size_t buflen)
+{
+	return netlink_qdisc_msg_encode(RTM_DELQDISC, ctx, buf, buflen);
+}
+
+static ssize_t netlink_newtclass_msg_encoder(struct zebra_dplane_ctx *ctx,
+					     void *buf, size_t buflen)
+{
+	return netlink_tclass_msg_encode(RTM_NEWTCLASS, ctx, buf, buflen);
+}
 
-	req->t.tcm_info = tc_make_handle(priority, protocol);
+static ssize_t netlink_deltclass_msg_encoder(struct zebra_dplane_ctx *ctx,
+					     void *buf, size_t buflen)
+{
+	return netlink_tclass_msg_encode(RTM_DELTCLASS, ctx, buf, buflen);
+}
 
-	req->t.tcm_handle = 1;
-	req->t.tcm_parent = tc_get_handle(ctx, 0);
+static ssize_t netlink_newtfilter_msg_encoder(struct zebra_dplane_ctx *ctx,
+					      void *buf, size_t buflen)
+{
+	return netlink_tfilter_msg_encode(RTM_NEWTFILTER, ctx, buf, buflen);
+}
 
-	nl_attr_put(&req->n, datalen, TCA_KIND, kind, strlen(kind) + 1);
-	nest = nl_attr_nest(&req->n, datalen, TCA_OPTIONS);
+static ssize_t netlink_deltfilter_msg_encoder(struct zebra_dplane_ctx *ctx,
+					      void *buf, size_t buflen)
+{
+	return netlink_tfilter_msg_encode(RTM_DELTFILTER, ctx, buf, buflen);
+}
 
-	nl_attr_put(&req->n, datalen, TCA_FLOWER_CLASSID, &classid,
-		    sizeof(classid));
+enum netlink_msg_status
+netlink_put_tc_qdisc_update_msg(struct nl_batch *bth,
+				struct zebra_dplane_ctx *ctx)
+{
+	enum dplane_op_e op;
+	enum netlink_msg_status ret;
 
-	if (filter_bm & TC_FILTER_SRC_IP) {
-		const struct prefix *src_p = dplane_ctx_tc_get_src_ip(ctx);
+	op = dplane_ctx_get_op(ctx);
 
-		if (tc_flower_get_inet_prefix(src_p, &addr) != 0)
-			return 0;
+	if (op == DPLANE_OP_TC_QDISC_INSTALL) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_newqdisc_msg_encoder, false);
+	} else if (op == DPLANE_OP_TC_QDISC_UNINSTALL) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_delqdisc_msg_encoder, false);
+	} else {
+		return FRR_NETLINK_ERROR;
+	}
 
-		nl_attr_put(&req->n, datalen,
-			    (addr.family == AF_INET) ? TCA_FLOWER_KEY_IPV4_SRC
-						     : TCA_FLOWER_KEY_IPV6_SRC,
-			    addr.data, addr.bytelen);
+	return ret;
+}
 
-		if (tc_flower_get_inet_mask(src_p, &addr) != 0)
-			return 0;
+enum netlink_msg_status
+netlink_put_tc_class_update_msg(struct nl_batch *bth,
+				struct zebra_dplane_ctx *ctx)
+{
+	enum dplane_op_e op;
+	enum netlink_msg_status ret;
 
-		nl_attr_put(&req->n, datalen,
-			    (addr.family == AF_INET)
-				    ? TCA_FLOWER_KEY_IPV4_SRC_MASK
-				    : TCA_FLOWER_KEY_IPV6_SRC_MASK,
-			    addr.data, addr.bytelen);
+	op = dplane_ctx_get_op(ctx);
+
+	if (op == DPLANE_OP_TC_CLASS_ADD || op == DPLANE_OP_TC_CLASS_UPDATE) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_newtclass_msg_encoder, false);
+	} else if (op == DPLANE_OP_TC_CLASS_DELETE) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_deltclass_msg_encoder, false);
+	} else {
+		return FRR_NETLINK_ERROR;
 	}
 
-	if (filter_bm & TC_FILTER_DST_IP) {
-		const struct prefix *dst_p = dplane_ctx_tc_get_dst_ip(ctx);
+	return ret;
+}
 
-		if (tc_flower_get_inet_prefix(dst_p, &addr) != 0)
-			return 0;
+enum netlink_msg_status
+netlink_put_tc_filter_update_msg(struct nl_batch *bth,
+				 struct zebra_dplane_ctx *ctx)
+{
+	enum dplane_op_e op;
+	enum netlink_msg_status ret;
+
+	op = dplane_ctx_get_op(ctx);
+
+	if (op == DPLANE_OP_TC_FILTER_ADD) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_newtfilter_msg_encoder, false);
+	} else if (op == DPLANE_OP_TC_FILTER_UPDATE) {
+		/*
+		 * Replace will fail if either filter type or the number of
+		 * filter options is changed, so DEL then NEW
+		 *
+		 * TFILTER may have refs to TCLASS.
+		 */
+
+		(void)netlink_batch_add_msg(
+			bth, ctx, netlink_deltfilter_msg_encoder, false);
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_newtfilter_msg_encoder, false);
+	} else if (op == DPLANE_OP_TC_FILTER_DELETE) {
+		ret = netlink_batch_add_msg(
+			bth, ctx, netlink_deltfilter_msg_encoder, false);
+	} else {
+		return FRR_NETLINK_ERROR;
+	}
 
-		nl_attr_put(&req->n, datalen,
-			    (addr.family == AF_INET) ? TCA_FLOWER_KEY_IPV4_DST
-						     : TCA_FLOWER_KEY_IPV6_DST,
-			    addr.data, addr.bytelen);
+	return ret;
+}
 
-		if (tc_flower_get_inet_mask(dst_p, &addr) != 0)
-			return 0;
+/*
+ * Request filters from the kernel
+ */
+static int netlink_request_filters(struct zebra_ns *zns, int family, int type,
+				   ifindex_t ifindex)
+{
+	struct {
+		struct nlmsghdr n;
+		struct tcmsg tc;
+	} req;
 
-		nl_attr_put(&req->n, datalen,
-			    (addr.family == AF_INET)
-				    ? TCA_FLOWER_KEY_IPV4_DST_MASK
-				    : TCA_FLOWER_KEY_IPV6_DST_MASK,
-			    addr.data, addr.bytelen);
+	memset(&req, 0, sizeof(req));
+	req.n.nlmsg_type = type;
+	req.n.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
+	req.tc.tcm_family = family;
+	req.tc.tcm_ifindex = ifindex;
+
+	return netlink_request(&zns->netlink_cmd, &req);
+}
+
+/*
+ * Request queue discipline from the kernel
+ */
+static int netlink_request_qdiscs(struct zebra_ns *zns, int family, int type)
+{
+	struct {
+		struct nlmsghdr n;
+		struct tcmsg tc;
+	} req;
+
+	memset(&req, 0, sizeof(req));
+	req.n.nlmsg_type = type;
+	req.n.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
+	req.tc.tcm_family = family;
+
+	return netlink_request(&zns->netlink_cmd, &req);
+}
+
+int netlink_qdisc_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
+{
+	struct tcmsg *tcm;
+	struct zebra_tc_qdisc qdisc = {};
+
+	int len;
+	struct rtattr *tb[TCA_MAX + 1];
+
+	frrtrace(3, frr_zebra, netlink_tc_qdisc_change, h, ns_id, startup);
+
+	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct tcmsg));
+
+	if (len < 0) {
+		zlog_err(
+			"%s: Message received from netlink is of a broken size %d %zu",
+			__func__, h->nlmsg_len,
+			(size_t)NLMSG_LENGTH(sizeof(struct tcmsg)));
+		return -1;
 	}
 
-	if (filter_bm & TC_FILTER_IP_PROTOCOL) {
-		nl_attr_put8(&req->n, datalen, TCA_FLOWER_KEY_IP_PROTO,
-			     dplane_ctx_tc_get_ip_proto(ctx));
+	tcm = NLMSG_DATA(h);
+	netlink_parse_rtattr(tb, TCA_MAX, TCA_RTA(tcm), len);
+
+	const char *kind_str = (const char *)RTA_DATA(tb[TCA_KIND]);
+
+	enum tc_qdisc_kind kind = tc_qdisc_str2kind(kind_str);
+
+	qdisc.qdisc.ifindex = tcm->tcm_ifindex;
+
+	switch (kind) {
+	case TC_QDISC_NOQUEUE:
+		/* "noqueue" is the default qdisc */
+		break;
+	default:
+		break;
 	}
 
-	nl_attr_put32(&req->n, datalen, TCA_FLOWER_FLAGS, flags);
+	if (tb[TCA_OPTIONS] != NULL) {
+		struct rtattr *options[TCA_HTB_MAX + 1];
 
-	nl_attr_put16(&req->n, datalen, TCA_FLOWER_KEY_ETH_TYPE, protocol);
-	nl_attr_nest_end(&req->n, nest);
+		netlink_parse_rtattr_nested(options, TCA_HTB_MAX,
+					    tb[TCA_OPTIONS]);
 
-	return NLMSG_ALIGN(req->n.nlmsg_len);
+		/* TODO: more details */
+		/* struct tc_htb_glob *glob = RTA_DATA(options[TCA_HTB_INIT]);
+		 */
+	}
+
+	if (h->nlmsg_type == RTM_NEWQDISC) {
+		if (startup &&
+		    TC_H_MAJ(tcm->tcm_handle) == TC_QDISC_MAJOR_ZEBRA) {
+			enum zebra_dplane_result ret;
+
+			ret = dplane_tc_qdisc_uninstall(&qdisc);
+
+			zlog_debug("%s: %s leftover qdisc: ifindex %d kind %s",
+				   __func__,
+				   ((ret == ZEBRA_DPLANE_REQUEST_FAILURE)
+					    ? "Failed to remove"
+					    : "Removed"),
+				   qdisc.qdisc.ifindex, kind_str);
+		}
+	}
+
+	return 0;
 }
 
-static ssize_t netlink_newqdisc_msg_encoder(struct zebra_dplane_ctx *ctx,
-					    void *buf, size_t buflen)
+int netlink_tclass_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
-	return netlink_qdisc_msg_encode(RTM_NEWQDISC, ctx, buf, buflen);
+	struct tcmsg *tcm;
+
+	int len;
+	struct rtattr *tb[TCA_MAX + 1];
+
+	frrtrace(3, frr_zebra, netlink_tc_class_change, h, ns_id, startup);
+
+	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct tcmsg));
+
+	if (len < 0) {
+		zlog_err(
+			"%s: Message received from netlink is of a broken size %d %zu",
+			__func__, h->nlmsg_len,
+			(size_t)NLMSG_LENGTH(sizeof(struct tcmsg)));
+		return -1;
+	}
+
+	tcm = NLMSG_DATA(h);
+	netlink_parse_rtattr(tb, TCA_MAX, TCA_RTA(tcm), len);
+
+
+	if (tb[TCA_OPTIONS] != NULL) {
+		struct rtattr *options[TCA_HTB_MAX + 1];
+
+		netlink_parse_rtattr_nested(options, TCA_HTB_MAX,
+					    tb[TCA_OPTIONS]);
+
+		/* TODO: more details */
+		/* struct tc_htb_opt *opt = RTA_DATA(options[TCA_HTB_PARMS]); */
+	}
+
+	return 0;
 }
 
-static ssize_t netlink_newtclass_msg_encoder(struct zebra_dplane_ctx *ctx,
-					     void *buf, size_t buflen)
+int netlink_tfilter_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 {
-	return netlink_tclass_msg_encode(RTM_NEWTCLASS, ctx, buf, buflen);
+	struct tcmsg *tcm;
+
+	int len;
+	struct rtattr *tb[TCA_MAX + 1];
+
+	frrtrace(3, frr_zebra, netlink_tc_filter_change, h, ns_id, startup);
+
+	len = h->nlmsg_len - NLMSG_LENGTH(sizeof(struct tcmsg));
+
+	if (len < 0) {
+		zlog_err(
+			"%s: Message received from netlink is of a broken size %d %zu",
+			__func__, h->nlmsg_len,
+			(size_t)NLMSG_LENGTH(sizeof(struct tcmsg)));
+		return -1;
+	}
+
+	tcm = NLMSG_DATA(h);
+	netlink_parse_rtattr(tb, TCA_MAX, TCA_RTA(tcm), len);
+
+	return 0;
 }
 
-static ssize_t netlink_newtfilter_msg_encoder(struct zebra_dplane_ctx *ctx,
-					      void *buf, size_t buflen)
+int netlink_qdisc_read(struct zebra_ns *zns)
 {
-	return netlink_tfilter_msg_encode(RTM_NEWTFILTER, ctx, buf, buflen);
+	int ret;
+	struct zebra_dplane_info dp_info;
+
+	zebra_dplane_info_from_zns(&dp_info, zns, true);
+
+	ret = netlink_request_qdiscs(zns, AF_UNSPEC, RTM_GETQDISC);
+	if (ret < 0)
+		return ret;
+
+	ret = netlink_parse_info(netlink_qdisc_change, &zns->netlink_cmd,
+				 &dp_info, 0, true);
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
-enum netlink_msg_status netlink_put_tc_update_msg(struct nl_batch *bth,
-						  struct zebra_dplane_ctx *ctx)
+int netlink_tfilter_read_for_interface(struct zebra_ns *zns, ifindex_t ifindex)
 {
-	/* TODO: error handling and other actions (delete, replace, ...) */
+	int ret;
+	struct zebra_dplane_info dp_info;
+
+	zebra_dplane_info_from_zns(&dp_info, zns, true);
 
-	netlink_batch_add_msg(bth, ctx, netlink_newqdisc_msg_encoder, false);
-	netlink_batch_add_msg(bth, ctx, netlink_newtclass_msg_encoder, false);
-	return netlink_batch_add_msg(bth, ctx, netlink_newtfilter_msg_encoder,
-				     false);
+	ret = netlink_request_filters(zns, AF_UNSPEC, RTM_GETTFILTER, ifindex);
+	if (ret < 0)
+		return ret;
+
+	ret = netlink_parse_info(netlink_tfilter_change, &zns->netlink_cmd,
+				 &dp_info, 0, true);
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
 #endif /* HAVE_NETLINK */
diff -urpN frr-frr-8.4.2/zebra/tc_netlink.h frr-frr-8.5/zebra/tc_netlink.h
--- frr-frr-8.4.2/zebra/tc_netlink.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/tc_netlink.h	2023-03-13 20:01:47.000000000 +0600
@@ -3,22 +3,19 @@
  *
  * Copyright (C) 2022 Shichu Yang
  *
- * This file is part of FRR.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
  *
- * FRR is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
- * FRR is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FRR; see the file COPYING.  If not, write to the Free
- * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #ifndef _ZEBRA_TC_NETLINK_H
@@ -51,7 +48,30 @@ enum {
 };
 
 extern enum netlink_msg_status
-netlink_put_tc_update_msg(struct nl_batch *bth, struct zebra_dplane_ctx *ctx);
+netlink_put_tc_qdisc_update_msg(struct nl_batch *bth,
+				struct zebra_dplane_ctx *ctx);
+extern enum netlink_msg_status
+netlink_put_tc_class_update_msg(struct nl_batch *bth,
+				struct zebra_dplane_ctx *ctx);
+extern enum netlink_msg_status
+netlink_put_tc_filter_update_msg(struct nl_batch *bth,
+				 struct zebra_dplane_ctx *ctx);
+
+/**
+ * "filter" & "class" in the following become "tfilter" & "tclass" for
+ * the sake of consistency with kernel message types (RTM_NEWTFILTER etc.)
+ */
+
+extern int netlink_qdisc_read(struct zebra_ns *zns);
+extern int netlink_tfilter_read_for_interface(struct zebra_ns *zns,
+					      ifindex_t ifindex);
+
+extern int netlink_tfilter_change(struct nlmsghdr *h, ns_id_t ns_id,
+				  int startup);
+extern int netlink_tclass_change(struct nlmsghdr *h, ns_id_t ns_id,
+				 int startup);
+extern int netlink_qdisc_change(struct nlmsghdr *h, ns_id_t ns_id, int startup);
+
 
 #ifdef __cplusplus
 }
diff -urpN frr-frr-8.4.2/zebra/tc_socket.c frr-frr-8.5/zebra/tc_socket.c
--- frr-frr-8.4.2/zebra/tc_socket.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/tc_socket.c	2023-03-13 20:01:47.000000000 +0600
@@ -3,22 +3,19 @@
  *
  * Copyright (C) 2022 Shichu Yang
  *
- * This file is part of FRR.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
  *
- * FRR is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
- * FRR is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FRR; see the file COPYING.  If not, write to the Free
- * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #include <zebra.h>
@@ -30,6 +27,7 @@
 #include "zebra/rt.h"
 #include "zebra/zebra_dplane.h"
 #include "zebra/zebra_errors.h"
+#include "zebra/zebra_tc.h"
 
 enum zebra_dplane_result kernel_tc_update(struct zebra_dplane_ctx *ctx)
 {
diff -urpN frr-frr-8.4.2/zebra/zapi_msg.c frr-frr-8.5/zebra/zapi_msg.c
--- frr-frr-8.4.2/zebra/zapi_msg.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zapi_msg.c	2023-03-13 20:01:47.000000000 +0600
@@ -53,6 +53,7 @@
 #include "zebra/zebra_evpn_mh.h"
 #include "zebra/rt.h"
 #include "zebra/zebra_pbr.h"
+#include "zebra/zebra_tc.h"
 #include "zebra/table_manager.h"
 #include "zebra/zapi_msg.h"
 #include "zebra/zebra_errors.h"
@@ -133,8 +134,6 @@ static int zserv_encode_nexthop(struct s
 		stream_putl(s, nexthop->ifindex);
 		break;
 	case NEXTHOP_TYPE_IPV6:
-		stream_put(s, &nexthop->gate.ipv6, 16);
-		break;
 	case NEXTHOP_TYPE_IPV6_IFINDEX:
 		stream_put(s, &nexthop->gate.ipv6, 16);
 		stream_putl(s, nexthop->ifindex);
@@ -232,11 +231,6 @@ int zsend_interface_link_params(struct z
 {
 	struct stream *s = stream_new(ZEBRA_MAX_PACKET_SIZ);
 
-	if (!ifp->link_params) {
-		stream_free(s);
-		return 0;
-	}
-
 	zclient_create_header(s, ZEBRA_INTERFACE_LINK_PARAMS, ifp->vrf->vrf_id);
 
 	/* Add Interface Index */
@@ -1879,6 +1873,10 @@ static int zapi_nhg_decode(struct stream
 	if (cmd == ZEBRA_NHG_DEL)
 		goto done;
 
+	STREAM_GETW(s, api_nhg->resilience.buckets);
+	STREAM_GETL(s, api_nhg->resilience.idle_timer);
+	STREAM_GETL(s, api_nhg->resilience.unbalanced_timer);
+
 	/* Nexthops */
 	STREAM_GETW(s, api_nhg->nexthop_num);
 
@@ -2003,6 +2001,8 @@ static void zread_nhg_add(ZAPI_HANDLER_A
 	nhe->nhg.nexthop = nhg->nexthop;
 	nhg->nexthop = NULL;
 
+	nhe->nhg.nhgr = api_nhg.resilience;
+
 	if (bnhg) {
 		nhe->backup_info = bnhg;
 		bnhg = NULL;
@@ -2605,8 +2605,10 @@ static void zread_sr_policy_set(ZAPI_HAN
 		return;
 
 	policy = zebra_sr_policy_find(zp.color, &zp.endpoint);
-	if (!policy)
+	if (!policy) {
 		policy = zebra_sr_policy_add(zp.color, &zp.endpoint, zp.name);
+		policy->sock = client->sock;
+	}
 	/* TODO: per-VRF list of SR-TE policies. */
 	policy->zvrf = zvrf;
 
@@ -2709,6 +2711,7 @@ int zsend_srv6_manager_get_locator_chunk
 	chunk.keep = 0;
 	chunk.proto = client->proto;
 	chunk.instance = client->instance;
+	chunk.flags = loc->flags;
 
 	zclient_create_header(s, ZEBRA_SRV6_MANAGER_GET_LOCATOR_CHUNK, vrf_id);
 	zapi_srv6_locator_chunk_encode(s, &chunk);
@@ -3268,6 +3271,171 @@ stream_failure:
 	return;
 }
 
+static inline void zread_tc_qdisc(ZAPI_HANDLER_ARGS)
+{
+	struct zebra_tc_qdisc qdisc;
+	struct stream *s;
+	uint32_t total, i;
+
+	s = msg;
+	STREAM_GETL(s, total);
+
+	for (i = 0; i < total; i++) {
+		memset(&qdisc, 0, sizeof(qdisc));
+
+		qdisc.sock = client->sock;
+		STREAM_GETL(s, qdisc.qdisc.ifindex);
+		STREAM_GETL(s, qdisc.qdisc.kind);
+
+		if (hdr->command == ZEBRA_TC_QDISC_INSTALL)
+			zebra_tc_qdisc_install(&qdisc);
+		else
+			zebra_tc_qdisc_uninstall(&qdisc);
+	}
+
+stream_failure:
+	return;
+}
+
+static inline void zread_tc_class(ZAPI_HANDLER_ARGS)
+{
+	struct zebra_tc_class class;
+	struct stream *s;
+	uint32_t total, i;
+
+	s = msg;
+	STREAM_GETL(s, total);
+
+	for (i = 0; i < total; i++) {
+		memset(&class, 0, sizeof(class));
+
+		class.sock = client->sock;
+		STREAM_GETL(s, class.class.ifindex);
+		STREAM_GETL(s, class.class.handle);
+		STREAM_GETL(s, class.class.kind);
+		STREAM_GETQ(s, class.class.u.htb.rate);
+		STREAM_GETQ(s, class.class.u.htb.ceil);
+
+		if (hdr->command == ZEBRA_TC_CLASS_ADD)
+			zebra_tc_class_add(&class);
+		else
+			zebra_tc_class_delete(&class);
+	}
+
+stream_failure:
+	return;
+}
+
+static inline void zread_tc_filter(ZAPI_HANDLER_ARGS)
+{
+	struct zebra_tc_filter filter;
+	struct stream *s;
+	uint32_t total, i;
+
+	s = msg;
+	STREAM_GETL(s, total);
+
+	for (i = 0; i < total; i++) {
+		memset(&filter, 0, sizeof(filter));
+
+		filter.sock = client->sock;
+		STREAM_GETL(s, filter.filter.ifindex);
+		STREAM_GETL(s, filter.filter.handle);
+		STREAM_GETL(s, filter.filter.priority);
+		STREAM_GETL(s, filter.filter.protocol);
+		STREAM_GETL(s, filter.filter.kind);
+		switch (filter.filter.kind) {
+		case TC_FILTER_FLOWER: {
+			STREAM_GETL(s, filter.filter.u.flower.filter_bm);
+			uint32_t filter_bm = filter.filter.u.flower.filter_bm;
+
+			if (filter_bm & TC_FLOWER_IP_PROTOCOL)
+				STREAM_GETC(s, filter.filter.u.flower.ip_proto);
+			if (filter_bm & TC_FLOWER_SRC_IP) {
+				STREAM_GETC(
+					s,
+					filter.filter.u.flower.src_ip.family);
+				STREAM_GETC(s, filter.filter.u.flower.src_ip
+						       .prefixlen);
+				STREAM_GET(
+					&filter.filter.u.flower.src_ip.u.prefix,
+					s,
+					prefix_blen(&filter.filter.u.flower
+							     .src_ip));
+
+				if (!(filter.filter.u.flower.src_ip.family ==
+					      AF_INET ||
+				      filter.filter.u.flower.src_ip.family ==
+					      AF_INET6)) {
+					zlog_warn(
+						"Unsupported TC source IP family: %s (%hhu)",
+						family2str(
+							filter.filter.u.flower
+								.src_ip.family),
+						filter.filter.u.flower.src_ip
+							.family);
+					return;
+				}
+			}
+			if (filter_bm & TC_FLOWER_SRC_PORT) {
+				STREAM_GETW(
+					s, filter.filter.u.flower.src_port_min);
+				STREAM_GETW(
+					s, filter.filter.u.flower.src_port_max);
+			}
+			if (filter_bm & TC_FLOWER_DST_IP) {
+				STREAM_GETC(
+					s,
+					filter.filter.u.flower.dst_ip.family);
+				STREAM_GETC(s, filter.filter.u.flower.dst_ip
+						       .prefixlen);
+				STREAM_GET(
+					&filter.filter.u.flower.dst_ip.u.prefix,
+					s,
+					prefix_blen(&filter.filter.u.flower
+							     .dst_ip));
+				if (!(filter.filter.u.flower.dst_ip.family ==
+					      AF_INET ||
+				      filter.filter.u.flower.dst_ip.family ==
+					      AF_INET6)) {
+					zlog_warn(
+						"Unsupported TC destination IP family: %s (%hhu)",
+						family2str(
+							filter.filter.u.flower
+								.dst_ip.family),
+						filter.filter.u.flower.dst_ip
+							.family);
+					return;
+				}
+			}
+			if (filter_bm & TC_FLOWER_DST_PORT) {
+				STREAM_GETW(
+					s, filter.filter.u.flower.dst_port_min);
+				STREAM_GETW(
+					s, filter.filter.u.flower.dst_port_max);
+			}
+			if (filter_bm & TC_FLOWER_DSFIELD) {
+				STREAM_GETC(s, filter.filter.u.flower.dsfield);
+				STREAM_GETC(
+					s, filter.filter.u.flower.dsfield_mask);
+			}
+			STREAM_GETL(s, filter.filter.u.flower.classid);
+			break;
+		}
+		default:
+			break;
+		}
+
+		if (hdr->command == ZEBRA_TC_FILTER_ADD)
+			zebra_tc_filter_add(&filter);
+		else
+			zebra_tc_filter_delete(&filter);
+	}
+
+stream_failure:
+	return;
+}
+
 static inline void zread_ipset(ZAPI_HANDLER_ARGS)
 {
 	struct zebra_pbr_ipset zpi;
@@ -3528,7 +3696,7 @@ static inline void zebra_neigh_ip_del(ZA
 static inline void zread_iptable(ZAPI_HANDLER_ARGS)
 {
 	struct zebra_pbr_iptable *zpi =
-		XCALLOC(MTYPE_TMP, sizeof(struct zebra_pbr_iptable));
+		XCALLOC(MTYPE_PBR_OBJ, sizeof(struct zebra_pbr_iptable));
 	struct stream *s;
 
 	s = msg;
@@ -3768,6 +3936,12 @@ void (*const zserv_handlers[])(ZAPI_HAND
 	[ZEBRA_CONFIGURE_ARP] = zebra_configure_arp,
 	[ZEBRA_GRE_GET] = zebra_gre_get,
 	[ZEBRA_GRE_SOURCE_SET] = zebra_gre_source_set,
+	[ZEBRA_TC_QDISC_INSTALL] = zread_tc_qdisc,
+	[ZEBRA_TC_QDISC_UNINSTALL] = zread_tc_qdisc,
+	[ZEBRA_TC_CLASS_ADD] = zread_tc_class,
+	[ZEBRA_TC_CLASS_DELETE] = zread_tc_class,
+	[ZEBRA_TC_FILTER_ADD] = zread_tc_filter,
+	[ZEBRA_TC_FILTER_DELETE] = zread_tc_filter,
 };
 
 /*
diff -urpN frr-frr-8.4.2/zebra/zebra_dplane.c frr-frr-8.5/zebra/zebra_dplane.c
--- frr-frr-8.4.2/zebra/zebra_dplane.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_dplane.c	2023-03-13 20:01:47.000000000 +0600
@@ -26,7 +26,6 @@
 #include "lib/frratomic.h"
 #include "lib/frr_pthread.h"
 #include "lib/memory.h"
-#include "lib/queue.h"
 #include "lib/zebra.h"
 #include "zebra/netconf_netlink.h"
 #include "zebra/zebra_router.h"
@@ -37,6 +36,7 @@
 #include "zebra/debug.h"
 #include "zebra/zebra_pbr.h"
 #include "zebra/zebra_neigh.h"
+#include "zebra/zebra_tc.h"
 #include "printfrr.h"
 
 /* Memory types */
@@ -102,7 +102,7 @@ struct dplane_intf_extra {
 	uint32_t flags;
 	uint32_t status;
 
-	TAILQ_ENTRY(dplane_intf_extra) link;
+	struct dplane_intf_extra_list_item dlink;
 };
 
 /*
@@ -134,6 +134,8 @@ struct dplane_route_info {
 	uint32_t zd_mtu;
 	uint32_t zd_nexthop_mtu;
 
+	uint32_t zd_flags;
+
 	/* Nexthop hash entry info */
 	struct dplane_nexthop_info nhe;
 
@@ -149,7 +151,7 @@ struct dplane_route_info {
 	struct nexthop_group old_backup_ng;
 
 	/* Optional list of extra interface info */
-	TAILQ_HEAD(dp_intf_extra_q, dplane_intf_extra) intf_extra_q;
+	struct dplane_intf_extra_list_head intf_extra_list;
 };
 
 /*
@@ -313,23 +315,36 @@ struct dplane_netconf_info {
 	enum dplane_netconf_status_e linkdown_val;
 };
 
-/*
- * Traffic control contexts for the dplane
- */
-struct dplane_tc_info {
-	/* Rate spec (unit: Bytes/s) */
+struct dplane_tc_qdisc_info {
+	enum tc_qdisc_kind kind;
+	const char *kind_str;
+};
+
+struct dplane_tc_class_info {
+	uint32_t handle;
+	enum tc_qdisc_kind kind;
+	const char *kind_str;
 	uint64_t rate;
 	uint64_t ceil;
+};
 
-	/* TODO: custom burst */
-
-	/* Filter components for "tfilter" */
+struct dplane_tc_filter_info {
+	uint32_t handle;
+	uint16_t priority;
+	enum tc_filter_kind kind;
+	const char *kind_str;
 	uint32_t filter_bm;
+	uint16_t eth_proto;
+	uint8_t ip_proto;
 	struct prefix src_ip;
 	struct prefix dst_ip;
-	uint8_t ip_proto;
-
-	/* TODO: more filter components */
+	uint16_t src_port_min;
+	uint16_t src_port_max;
+	uint16_t dst_port_min;
+	uint16_t dst_port_max;
+	uint8_t dsfield;
+	uint8_t dsfield_mask;
+	uint32_t classid;
 };
 
 /*
@@ -381,7 +396,9 @@ struct zebra_dplane_ctx {
 		struct dplane_mac_info macinfo;
 		struct dplane_neigh_info neigh;
 		struct dplane_rule_info rule;
-		struct dplane_tc_info tc;
+		struct dplane_tc_qdisc_info tc_qdisc;
+		struct dplane_tc_class_info tc_class;
+		struct dplane_tc_filter_info tc_filter;
 		struct zebra_pbr_iptable iptable;
 		struct zebra_pbr_ipset ipset;
 		struct {
@@ -397,7 +414,7 @@ struct zebra_dplane_ctx {
 	struct zebra_dplane_info zd_ns_info;
 
 	/* Embedded list linkage */
-	TAILQ_ENTRY(zebra_dplane_ctx) zd_q_entries;
+	struct dplane_ctx_list_item zd_entries;
 };
 
 /* Flag that can be set by a pre-kernel provider as a signal that an update
@@ -405,6 +422,12 @@ struct zebra_dplane_ctx {
  */
 #define DPLANE_CTX_FLAG_NO_KERNEL 0x01
 
+/* List types declared now that the structs involved are defined. */
+DECLARE_DLIST(dplane_ctx_list, struct zebra_dplane_ctx, zd_entries);
+DECLARE_DLIST(dplane_intf_extra_list, struct dplane_intf_extra, dlink);
+
+/* List for dplane plugins/providers */
+PREDECL_DLIST(dplane_prov_list);
 
 /*
  * Registration block for one dataplane provider.
@@ -443,17 +466,20 @@ struct zebra_dplane_provider {
 	_Atomic uint32_t dp_error_counter;
 
 	/* Queue of contexts inbound to the provider */
-	struct dplane_ctx_q dp_ctx_in_q;
+	struct dplane_ctx_list_head dp_ctx_in_list;
 
 	/* Queue of completed contexts outbound from the provider back
 	 * towards the dataplane module.
 	 */
-	struct dplane_ctx_q dp_ctx_out_q;
+	struct dplane_ctx_list_head dp_ctx_out_list;
 
 	/* Embedded list linkage for provider objects */
-	TAILQ_ENTRY(zebra_dplane_provider) dp_prov_link;
+	struct dplane_prov_list_item dp_link;
 };
 
+/* Declare list of providers/plugins */
+DECLARE_DLIST(dplane_prov_list, struct zebra_dplane_provider, dp_link);
+
 /* Declare types for list of zns info objects */
 PREDECL_DLIST(zns_info_list);
 
@@ -478,7 +504,7 @@ static struct zebra_dplane_globals {
 	pthread_mutex_t dg_mutex;
 
 	/* Results callback registered by zebra 'core' */
-	int (*dg_results_cb)(struct dplane_ctx_q *ctxlist);
+	int (*dg_results_cb)(struct dplane_ctx_list_head *ctxlist);
 
 	/* Sentinel for beginning of shutdown */
 	volatile bool dg_is_shutdown;
@@ -487,10 +513,10 @@ static struct zebra_dplane_globals {
 	volatile bool dg_run;
 
 	/* Update context queue inbound to the dataplane */
-	TAILQ_HEAD(zdg_ctx_q, zebra_dplane_ctx) dg_update_ctx_q;
+	struct dplane_ctx_list_head dg_update_list;
 
 	/* Ordered list of providers */
-	TAILQ_HEAD(zdg_prov_q, zebra_dplane_provider) dg_providers_q;
+	struct dplane_prov_list_head dg_providers;
 
 	/* List of info about each zns */
 	struct zns_info_list_head dg_zns_list;
@@ -650,7 +676,7 @@ void dplane_enable_sys_route_notifs(void
  */
 static void dplane_ctx_free_internal(struct zebra_dplane_ctx *ctx)
 {
-	struct dplane_intf_extra *if_extra, *if_tmp;
+	struct dplane_intf_extra *if_extra;
 
 	/*
 	 * Some internal allocations may need to be freed, depending on
@@ -695,12 +721,9 @@ static void dplane_ctx_free_internal(str
 		}
 
 		/* Optional extra interface info */
-		TAILQ_FOREACH_SAFE(if_extra, &ctx->u.rinfo.intf_extra_q,
-				   link, if_tmp) {
-			TAILQ_REMOVE(&ctx->u.rinfo.intf_extra_q, if_extra,
-				     link);
+		while ((if_extra = dplane_intf_extra_list_pop(
+				&ctx->u.rinfo.intf_extra_list)))
 			XFREE(MTYPE_DP_INTF, if_extra);
-		}
 
 		break;
 
@@ -800,9 +823,14 @@ static void dplane_ctx_free_internal(str
 	case DPLANE_OP_INTF_INSTALL:
 	case DPLANE_OP_INTF_UPDATE:
 	case DPLANE_OP_INTF_DELETE:
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		break;
 
 	case DPLANE_OP_IPSET_ENTRY_ADD:
@@ -862,39 +890,40 @@ void dplane_ctx_fini(struct zebra_dplane
 	dplane_ctx_free(pctx);
 }
 
+/* Init a list of contexts */
+void dplane_ctx_q_init(struct dplane_ctx_list_head *q)
+{
+	dplane_ctx_list_init(q);
+}
+
 /* Enqueue a context block */
-void dplane_ctx_enqueue_tail(struct dplane_ctx_q *q,
+void dplane_ctx_enqueue_tail(struct dplane_ctx_list_head *list,
 			     const struct zebra_dplane_ctx *ctx)
 {
-	TAILQ_INSERT_TAIL(q, (struct zebra_dplane_ctx *)ctx, zd_q_entries);
+	dplane_ctx_list_add_tail(list, (struct zebra_dplane_ctx *)ctx);
 }
 
 /* Append a list of context blocks to another list */
-void dplane_ctx_list_append(struct dplane_ctx_q *to_list,
-			    struct dplane_ctx_q *from_list)
+void dplane_ctx_list_append(struct dplane_ctx_list_head *to_list,
+			    struct dplane_ctx_list_head *from_list)
 {
-	if (TAILQ_FIRST(from_list)) {
-		TAILQ_CONCAT(to_list, from_list, zd_q_entries);
+	struct zebra_dplane_ctx *ctx;
 
-		/* And clear 'from' list */
-		TAILQ_INIT(from_list);
-	}
+	while ((ctx = dplane_ctx_list_pop(from_list)) != NULL)
+		dplane_ctx_list_add_tail(to_list, ctx);
 }
 
-struct zebra_dplane_ctx *dplane_ctx_get_head(struct dplane_ctx_q *q)
+struct zebra_dplane_ctx *dplane_ctx_get_head(struct dplane_ctx_list_head *q)
 {
-	struct zebra_dplane_ctx *ctx = TAILQ_FIRST(q);
+	struct zebra_dplane_ctx *ctx = dplane_ctx_list_first(q);
 
 	return ctx;
 }
 
 /* Dequeue a context block from the head of a list */
-struct zebra_dplane_ctx *dplane_ctx_dequeue(struct dplane_ctx_q *q)
+struct zebra_dplane_ctx *dplane_ctx_dequeue(struct dplane_ctx_list_head *q)
 {
-	struct zebra_dplane_ctx *ctx = TAILQ_FIRST(q);
-
-	if (ctx)
-		TAILQ_REMOVE(q, ctx, zd_q_entries);
+	struct zebra_dplane_ctx *ctx = dplane_ctx_list_pop(q);
 
 	return ctx;
 }
@@ -1115,14 +1144,29 @@ const char *dplane_op2str(enum dplane_op
 		ret = "INTF_DELETE";
 		break;
 
-	case DPLANE_OP_TC_INSTALL:
-		ret = "TC_INSTALL";
+	case DPLANE_OP_TC_QDISC_INSTALL:
+		ret = "TC_QDISC_INSTALL";
+		break;
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+		ret = "TC_QDISC_UNINSTALL";
+		break;
+	case DPLANE_OP_TC_CLASS_ADD:
+		ret = "TC_CLASS_ADD";
 		break;
-	case DPLANE_OP_TC_UPDATE:
-		ret = "TC_UPDATE";
+	case DPLANE_OP_TC_CLASS_DELETE:
+		ret = "TC_CLASS_DELETE";
 		break;
-	case DPLANE_OP_TC_DELETE:
-		ret = "TC_DELETE";
+	case DPLANE_OP_TC_CLASS_UPDATE:
+		ret = "TC_CLASS_UPDATE";
+		break;
+	case DPLANE_OP_TC_FILTER_ADD:
+		ret = "TC_FILTER_ADD";
+		break;
+	case DPLANE_OP_TC_FILTER_DELETE:
+		ret = "TC_FILTER_DELETE";
+		break;
+	case DPLANE_OP_TC_FILTER_UPDATE:
+		ret = "TC__FILTER_UPDATE";
 		break;
 	}
 
@@ -1394,6 +1438,20 @@ uint16_t dplane_ctx_get_old_instance(con
 	return ctx->u.rinfo.zd_old_instance;
 }
 
+uint32_t dplane_ctx_get_flags(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.rinfo.zd_flags;
+}
+
+void dplane_ctx_set_flags(struct zebra_dplane_ctx *ctx, uint32_t flags)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	ctx->u.rinfo.zd_flags = flags;
+}
+
 uint32_t dplane_ctx_get_metric(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
@@ -1443,48 +1501,175 @@ uint8_t dplane_ctx_get_old_distance(cons
 	return ctx->u.rinfo.zd_old_distance;
 }
 
-uint64_t dplane_ctx_tc_get_rate(const struct zebra_dplane_ctx *ctx)
+int dplane_ctx_tc_qdisc_get_kind(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_qdisc.kind;
+}
+
+const char *dplane_ctx_tc_qdisc_get_kind_str(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_qdisc.kind_str;
+}
+
+uint32_t dplane_ctx_tc_class_get_handle(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return ctx->u.tc.rate;
+	return ctx->u.tc_class.handle;
 }
 
-uint64_t dplane_ctx_tc_get_ceil(const struct zebra_dplane_ctx *ctx)
+int dplane_ctx_tc_class_get_kind(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return ctx->u.tc.ceil;
+	return ctx->u.tc_class.kind;
 }
 
-uint32_t dplane_ctx_tc_get_filter_bm(const struct zebra_dplane_ctx *ctx)
+const char *dplane_ctx_tc_class_get_kind_str(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return ctx->u.tc.filter_bm;
+	return ctx->u.tc_class.kind_str;
+}
+
+uint64_t dplane_ctx_tc_class_get_rate(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_class.rate;
+}
+
+uint64_t dplane_ctx_tc_class_get_ceil(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_class.ceil;
+}
+
+int dplane_ctx_tc_filter_get_kind(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.kind;
+}
+
+const char *
+dplane_ctx_tc_filter_get_kind_str(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.kind_str;
+}
+
+uint32_t dplane_ctx_tc_filter_get_priority(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.priority;
+}
+
+uint32_t dplane_ctx_tc_filter_get_handle(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.handle;
+}
+
+uint16_t dplane_ctx_tc_filter_get_eth_proto(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.eth_proto;
+}
+
+uint32_t dplane_ctx_tc_filter_get_filter_bm(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.filter_bm;
 }
 
 const struct prefix *
-dplane_ctx_tc_get_src_ip(const struct zebra_dplane_ctx *ctx)
+dplane_ctx_tc_filter_get_src_ip(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return &(ctx->u.tc.src_ip);
+	return &ctx->u.tc_filter.src_ip;
+}
+
+uint16_t
+dplane_ctx_tc_filter_get_src_port_min(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.src_port_min;
+}
+
+
+uint16_t
+dplane_ctx_tc_filter_get_src_port_max(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.src_port_max;
 }
 
 const struct prefix *
-dplane_ctx_tc_get_dst_ip(const struct zebra_dplane_ctx *ctx)
+dplane_ctx_tc_filter_get_dst_ip(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return &ctx->u.tc_filter.dst_ip;
+}
+
+uint16_t
+dplane_ctx_tc_filter_get_dst_port_min(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.dst_port_min;
+}
+
+
+uint16_t
+dplane_ctx_tc_filter_get_dst_port_max(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.dst_port_max;
+}
+
+uint8_t dplane_ctx_tc_filter_get_ip_proto(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.ip_proto;
+}
+
+uint8_t dplane_ctx_tc_filter_get_dsfield(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.tc_filter.dsfield;
+}
+
+uint8_t
+dplane_ctx_tc_filter_get_dsfield_mask(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return &(ctx->u.tc.dst_ip);
+	return ctx->u.tc_filter.dsfield_mask;
 }
 
-uint8_t dplane_ctx_tc_get_ip_proto(const struct zebra_dplane_ctx *ctx)
+uint32_t dplane_ctx_tc_filter_get_classid(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
 
-	return ctx->u.tc.ip_proto;
+	return ctx->u.tc_filter.classid;
 }
 
 /*
@@ -2418,14 +2603,16 @@ void dplane_ctx_rule_set_dp_flow_ptr(str
 const struct dplane_intf_extra *
 dplane_ctx_get_intf_extra(const struct zebra_dplane_ctx *ctx)
 {
-	return TAILQ_FIRST(&ctx->u.rinfo.intf_extra_q);
+	return dplane_intf_extra_list_const_first(
+		&ctx->u.rinfo.intf_extra_list);
 }
 
 const struct dplane_intf_extra *
 dplane_ctx_intf_extra_next(const struct zebra_dplane_ctx *ctx,
 			   const struct dplane_intf_extra *ptr)
 {
-	return TAILQ_NEXT(ptr, link);
+	return dplane_intf_extra_list_const_next(&ctx->u.rinfo.intf_extra_list,
+						 ptr);
 }
 
 vrf_id_t dplane_intf_extra_get_vrfid(const struct dplane_intf_extra *ptr)
@@ -2603,27 +2790,18 @@ static int dplane_ctx_ns_init(struct zeb
 	return AOK;
 }
 
-/*
- * Initialize a context block for a route update from zebra data structs.
- */
-int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
-			  struct route_node *rn, struct route_entry *re)
+int dplane_ctx_route_init_basic(struct zebra_dplane_ctx *ctx,
+				enum dplane_op_e op, struct route_entry *re,
+				const struct prefix *p,
+				const struct prefix_ipv6 *src_p, afi_t afi,
+				safi_t safi)
 {
 	int ret = EINVAL;
-	const struct route_table *table = NULL;
-	const struct rib_table_info *info;
-	const struct prefix *p, *src_p;
-	struct zebra_ns *zns;
-	struct zebra_vrf *zvrf;
-	struct nexthop *nexthop;
-	struct zebra_l3vni *zl3vni;
-	const struct interface *ifp;
-	struct dplane_intf_extra *if_extra;
 
-	if (!ctx || !rn || !re)
-		goto done;
+	if (!ctx || !re)
+		return ret;
 
-	TAILQ_INIT(&ctx->u.rinfo.intf_extra_q);
+	dplane_intf_extra_list_init(&ctx->u.rinfo.intf_extra_list);
 
 	ctx->zd_op = op;
 	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
@@ -2631,9 +2809,6 @@ int dplane_ctx_route_init(struct zebra_d
 	ctx->u.rinfo.zd_type = re->type;
 	ctx->u.rinfo.zd_old_type = re->type;
 
-	/* Prefixes: dest, and optional source */
-	srcdest_rnode_prefixes(rn, &p, &src_p);
-
 	prefix_copy(&(ctx->u.rinfo.zd_dest), p);
 
 	if (src_p)
@@ -2643,6 +2818,7 @@ int dplane_ctx_route_init(struct zebra_d
 
 	ctx->zd_table_id = re->table;
 
+	ctx->u.rinfo.zd_flags = re->flags;
 	ctx->u.rinfo.zd_metric = re->metric;
 	ctx->u.rinfo.zd_old_metric = re->metric;
 	ctx->zd_vrf_id = re->vrf_id;
@@ -2653,11 +2829,46 @@ int dplane_ctx_route_init(struct zebra_d
 	ctx->u.rinfo.zd_old_tag = re->tag;
 	ctx->u.rinfo.zd_distance = re->distance;
 
+	ctx->u.rinfo.zd_afi = afi;
+	ctx->u.rinfo.zd_safi = safi;
+
+	return AOK;
+}
+
+/*
+ * Initialize a context block for a route update from zebra data structs.
+ */
+int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
+			  struct route_node *rn, struct route_entry *re)
+{
+	int ret = EINVAL;
+	const struct route_table *table = NULL;
+	const struct rib_table_info *info;
+	const struct prefix *p;
+	const struct prefix_ipv6 *src_p;
+	struct zebra_ns *zns;
+	struct zebra_vrf *zvrf;
+	struct nexthop *nexthop;
+	struct zebra_l3vni *zl3vni;
+	const struct interface *ifp;
+	struct dplane_intf_extra *if_extra;
+
+	if (!ctx || !rn || !re)
+		return ret;
+
+	/*
+	 * Let's grab the data from the route_node
+	 * so that we can call a helper function
+	 */
+
+	/* Prefixes: dest, and optional source */
+	srcdest_rnode_prefixes(rn, &p, (const struct prefix **)&src_p);
 	table = srcdest_rnode_table(rn);
 	info = table->info;
 
-	ctx->u.rinfo.zd_afi = info->afi;
-	ctx->u.rinfo.zd_safi = info->safi;
+	if (dplane_ctx_route_init_basic(ctx, op, re, p, src_p, info->afi,
+					info->safi) != AOK)
+		return ret;
 
 	/* Copy nexthops; recursive info is included too */
 	copy_nexthops(&(ctx->u.rinfo.zd_ng.nexthop),
@@ -2693,8 +2904,9 @@ int dplane_ctx_route_init(struct zebra_d
 				if_extra->flags = ifp->flags;
 				if_extra->status = ifp->status;
 
-				TAILQ_INSERT_TAIL(&ctx->u.rinfo.intf_extra_q,
-						  if_extra, link);
+				dplane_intf_extra_list_add_tail(
+					&ctx->u.rinfo.intf_extra_list,
+					if_extra);
 			}
 		}
 
@@ -2712,8 +2924,7 @@ int dplane_ctx_route_init(struct zebra_d
 	/* Don't need some info when capturing a system notification */
 	if (op == DPLANE_OP_SYS_ROUTE_ADD ||
 	    op == DPLANE_OP_SYS_ROUTE_DELETE) {
-		ret = AOK;
-		goto done;
+		return AOK;
 	}
 
 	/* Extract ns info - can't use pointers to 'core' structs */
@@ -2734,14 +2945,12 @@ int dplane_ctx_route_init(struct zebra_d
 		 * If its a delete we only use the prefix anyway, so this only
 		 * matters for INSTALL/UPDATE.
 		 */
-		if (zebra_nhg_kernel_nexthops_enabled()
-		    && (((op == DPLANE_OP_ROUTE_INSTALL)
-			 || (op == DPLANE_OP_ROUTE_UPDATE))
-			&& !CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_INSTALLED)
-			&& !CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_QUEUED))) {
-			ret = ENOENT;
-			goto done;
-		}
+		if (zebra_nhg_kernel_nexthops_enabled() &&
+		    (((op == DPLANE_OP_ROUTE_INSTALL) ||
+		      (op == DPLANE_OP_ROUTE_UPDATE)) &&
+		     !CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_INSTALLED) &&
+		     !CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_QUEUED)))
+			return ENOENT;
 
 		re->nhe_installed_id = nhe->id;
 	}
@@ -2753,13 +2962,36 @@ int dplane_ctx_route_init(struct zebra_d
 	re->dplane_sequence = zebra_router_get_next_sequence();
 	ctx->zd_seq = re->dplane_sequence;
 
+	return AOK;
+}
+
+static int dplane_ctx_tc_qdisc_init(struct zebra_dplane_ctx *ctx,
+				    enum dplane_op_e op,
+				    const struct zebra_tc_qdisc *qdisc)
+{
+	int ret = EINVAL;
+
+	struct zebra_ns *zns = NULL;
+
+	ctx->zd_op = op;
+	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
+	ctx->zd_ifindex = qdisc->qdisc.ifindex;
+	ctx->u.tc_qdisc.kind = qdisc->qdisc.kind;
+	ctx->u.tc_qdisc.kind_str = tc_qdisc_kind2str(qdisc->qdisc.kind);
+
+	/* TODO: init traffic control qdisc */
+	zns = zebra_ns_lookup(NS_DEFAULT);
+
+	dplane_ctx_ns_init(ctx, zns, true);
+
 	ret = AOK;
 
-done:
 	return ret;
 }
 
-int dplane_ctx_tc_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op)
+static int dplane_ctx_tc_class_init(struct zebra_dplane_ctx *ctx,
+				    enum dplane_op_e op,
+				    struct zebra_tc_class *class)
 {
 	int ret = EINVAL;
 
@@ -2767,8 +2999,55 @@ int dplane_ctx_tc_init(struct zebra_dpla
 
 	ctx->zd_op = op;
 	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
+	ctx->zd_ifindex = class->class.ifindex;
+
+	ctx->u.tc_class.handle = class->class.handle;
+	ctx->u.tc_class.kind = class->class.kind;
+	ctx->u.tc_class.kind_str = tc_qdisc_kind2str(class->class.kind);
+	ctx->u.tc_class.rate = class->class.u.htb.rate;
+	ctx->u.tc_class.ceil = class->class.u.htb.ceil;
+
+	zns = zebra_ns_lookup(NS_DEFAULT);
+
+	dplane_ctx_ns_init(ctx, zns, true);
+
+	ret = AOK;
+
+	return ret;
+}
+
+static int dplane_ctx_tc_filter_init(struct zebra_dplane_ctx *ctx,
+				     enum dplane_op_e op,
+				     struct zebra_tc_filter *filter)
+{
+	int ret = EINVAL;
+
+	struct zebra_ns *zns = NULL;
+
+	ctx->zd_op = op;
+	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
+	ctx->zd_ifindex = filter->filter.ifindex;
+
+	ctx->u.tc_filter.eth_proto = filter->filter.protocol;
+	ctx->u.tc_filter.ip_proto = filter->filter.u.flower.ip_proto;
+
+	ctx->u.tc_filter.kind = filter->filter.kind;
+	ctx->u.tc_filter.kind_str = tc_filter_kind2str(filter->filter.kind);
+
+	ctx->u.tc_filter.filter_bm = filter->filter.u.flower.filter_bm;
+	prefix_copy(&ctx->u.tc_filter.src_ip, &filter->filter.u.flower.src_ip);
+	ctx->u.tc_filter.src_port_min = filter->filter.u.flower.src_port_min;
+	ctx->u.tc_filter.src_port_max = filter->filter.u.flower.src_port_max;
+	prefix_copy(&ctx->u.tc_filter.dst_ip, &filter->filter.u.flower.dst_ip);
+	ctx->u.tc_filter.dst_port_min = filter->filter.u.flower.dst_port_min;
+	ctx->u.tc_filter.dst_port_max = filter->filter.u.flower.dst_port_max;
+	ctx->u.tc_filter.dsfield = filter->filter.u.flower.dsfield;
+	ctx->u.tc_filter.dsfield_mask = filter->filter.u.flower.dsfield_mask;
+	ctx->u.tc_filter.classid = filter->filter.u.flower.classid;
+
+	ctx->u.tc_filter.priority = filter->filter.priority;
+	ctx->u.tc_filter.handle = filter->filter.handle;
 
-	/* TODO: init traffic control qdisc */
 	zns = zebra_ns_lookup(NS_DEFAULT);
 
 	dplane_ctx_ns_init(ctx, zns, true);
@@ -2795,7 +3074,7 @@ int dplane_ctx_nexthop_init(struct zebra
 	int ret = EINVAL;
 
 	if (!ctx || !nhe)
-		goto done;
+		return ret;
 
 	ctx->zd_op = op;
 	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
@@ -2830,7 +3109,6 @@ int dplane_ctx_nexthop_init(struct zebra
 
 	ret = AOK;
 
-done:
 	return ret;
 }
 
@@ -2852,7 +3130,7 @@ int dplane_ctx_intf_init(struct zebra_dp
 	bool set_pdown, unset_pdown;
 
 	if (!ctx || !ifp)
-		goto done;
+		return ret;
 
 	ctx->zd_op = op;
 	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
@@ -2897,7 +3175,6 @@ int dplane_ctx_intf_init(struct zebra_dp
 
 	ret = AOK;
 
-done:
 	return ret;
 }
 
@@ -2925,10 +3202,8 @@ int dplane_ctx_lsp_init(struct zebra_dpl
 	/* This may be called to create/init a dplane context, not necessarily
 	 * to copy an lsp object.
 	 */
-	if (lsp == NULL) {
-		ret = AOK;
-		goto done;
-	}
+	if (lsp == NULL)
+		return ret;
 
 	if (IS_ZEBRA_DEBUG_DPLANE_DETAIL)
 		zlog_debug("init dplane ctx %s: in-label %u ecmp# %d",
@@ -2971,7 +3246,7 @@ int dplane_ctx_lsp_init(struct zebra_dpl
 	}
 
 	if (ret != AOK)
-		goto done;
+		return ret;
 
 	/* Capture backup nhlfes/nexthops */
 	frr_each(nhlfe_list, &lsp->backup_nhlfe_list, nhlfe) {
@@ -2992,11 +3267,6 @@ int dplane_ctx_lsp_init(struct zebra_dpl
 		new_nhlfe->nexthop->flags = nhlfe->nexthop->flags;
 	}
 
-	/* On error the ctx will be cleaned-up, so we don't need to
-	 * deal with any allocated nhlfe or nexthop structs here.
-	 */
-done:
-
 	return ret;
 }
 
@@ -3057,11 +3327,11 @@ static int dplane_ctx_pw_init(struct zeb
 	afi = (pw->af == AF_INET) ? AFI_IP : AFI_IP6;
 	table = zebra_vrf_table(afi, SAFI_UNICAST, pw->vrf_id);
 	if (table == NULL)
-		goto done;
+		return ret;
 
 	rn = route_node_match(table, &p);
 	if (rn == NULL)
-		goto done;
+		return ret;
 
 	re = NULL;
 	RNODE_FOREACH_RE(rn, re) {
@@ -3129,10 +3399,7 @@ static int dplane_ctx_pw_init(struct zeb
 	}
 	route_unlock_node(rn);
 
-	ret = AOK;
-
-done:
-	return ret;
+	return AOK;
 }
 
 /**
@@ -3364,8 +3631,7 @@ static int dplane_update_enqueue(struct
 	/* Enqueue for processing by the dataplane pthread */
 	DPLANE_LOCK();
 	{
-		TAILQ_INSERT_TAIL(&zdplane_info.dg_update_ctx_q, ctx,
-				  zd_q_entries);
+		dplane_ctx_list_add_tail(&zdplane_info.dg_update_list, ctx);
 	}
 	DPLANE_UNLOCK();
 
@@ -3503,7 +3769,83 @@ dplane_route_update_internal(struct rout
 	return result;
 }
 
-static enum zebra_dplane_result dplane_tc_update_internal(enum dplane_op_e op)
+static enum zebra_dplane_result
+tc_qdisc_update_internal(enum dplane_op_e op,
+			 const struct zebra_tc_qdisc *qdisc)
+{
+	enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
+	int ret;
+	struct zebra_dplane_ctx *ctx = NULL;
+
+	/* Obtain context block */
+	ctx = dplane_ctx_alloc();
+
+	if (!ctx) {
+		ret = ENOMEM;
+		goto done;
+	}
+
+	/* Init context with info from zebra data structs */
+	ret = dplane_ctx_tc_qdisc_init(ctx, op, qdisc);
+
+	if (ret == AOK)
+		ret = dplane_update_enqueue(ctx);
+
+done:
+	/* Update counter */
+	atomic_fetch_add_explicit(&zdplane_info.dg_tcs_in, 1,
+				  memory_order_relaxed);
+	if (ret == AOK) {
+		result = ZEBRA_DPLANE_REQUEST_QUEUED;
+	} else {
+		atomic_fetch_add_explicit(&zdplane_info.dg_tcs_errors, 1,
+					  memory_order_relaxed);
+		if (ctx)
+			dplane_ctx_free(&ctx);
+	}
+
+	return result;
+}
+
+static enum zebra_dplane_result
+tc_class_update_internal(enum dplane_op_e op, struct zebra_tc_class *class)
+{
+	enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
+	int ret;
+	struct zebra_dplane_ctx *ctx = NULL;
+
+	/* Obtain context block */
+	ctx = dplane_ctx_alloc();
+
+	if (!ctx) {
+		ret = ENOMEM;
+		goto done;
+	}
+
+	/* Init context with info from zebra data structs */
+	ret = dplane_ctx_tc_class_init(ctx, op, class);
+
+	if (ret == AOK)
+		ret = dplane_update_enqueue(ctx);
+
+done:
+	/* Update counter */
+	atomic_fetch_add_explicit(&zdplane_info.dg_tcs_in, 1,
+				  memory_order_relaxed);
+	if (ret == AOK) {
+		result = ZEBRA_DPLANE_REQUEST_QUEUED;
+	} else {
+		atomic_fetch_add_explicit(&zdplane_info.dg_tcs_errors, 1,
+					  memory_order_relaxed);
+		if (ctx)
+			dplane_ctx_free(&ctx);
+	}
+
+	return result;
+}
+
+static enum zebra_dplane_result
+tc_filter_update_internal(enum dplane_op_e op, struct zebra_tc_filter *filter)
 {
 	enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
 	int ret;
@@ -3518,7 +3860,7 @@ static enum zebra_dplane_result dplane_t
 	}
 
 	/* Init context with info from zebra data structs */
-	ret = dplane_ctx_tc_init(ctx, op);
+	ret = dplane_ctx_tc_filter_init(ctx, op, filter);
 
 	if (ret == AOK)
 		ret = dplane_update_enqueue(ctx);
@@ -3539,9 +3881,44 @@ done:
 	return result;
 }
 
-enum zebra_dplane_result dplane_tc_update(void)
+enum zebra_dplane_result dplane_tc_qdisc_install(struct zebra_tc_qdisc *qdisc)
+{
+	return tc_qdisc_update_internal(DPLANE_OP_TC_QDISC_INSTALL, qdisc);
+}
+
+enum zebra_dplane_result dplane_tc_qdisc_uninstall(struct zebra_tc_qdisc *qdisc)
+{
+	return tc_qdisc_update_internal(DPLANE_OP_TC_QDISC_UNINSTALL, qdisc);
+}
+
+enum zebra_dplane_result dplane_tc_class_add(struct zebra_tc_class *class)
+{
+	return tc_class_update_internal(DPLANE_OP_TC_CLASS_ADD, class);
+}
+
+enum zebra_dplane_result dplane_tc_class_delete(struct zebra_tc_class *class)
 {
-	return dplane_tc_update_internal(DPLANE_OP_TC_UPDATE);
+	return tc_class_update_internal(DPLANE_OP_TC_CLASS_DELETE, class);
+}
+
+enum zebra_dplane_result dplane_tc_class_update(struct zebra_tc_class *class)
+{
+	return tc_class_update_internal(DPLANE_OP_TC_CLASS_UPDATE, class);
+}
+
+enum zebra_dplane_result dplane_tc_filter_add(struct zebra_tc_filter *filter)
+{
+	return tc_filter_update_internal(DPLANE_OP_TC_FILTER_ADD, filter);
+}
+
+enum zebra_dplane_result dplane_tc_filter_delete(struct zebra_tc_filter *filter)
+{
+	return tc_filter_update_internal(DPLANE_OP_TC_FILTER_DELETE, filter);
+}
+
+enum zebra_dplane_result dplane_tc_filter_update(struct zebra_tc_filter *filter)
+{
+	return tc_filter_update_internal(DPLANE_OP_TC_FILTER_UPDATE, filter);
 }
 
 /**
@@ -3596,12 +3973,11 @@ enum zebra_dplane_result dplane_route_ad
 	enum zebra_dplane_result ret = ZEBRA_DPLANE_REQUEST_FAILURE;
 
 	if (rn == NULL || re == NULL)
-		goto done;
+		return ret;
 
 	ret = dplane_route_update_internal(rn, re, NULL,
 					   DPLANE_OP_ROUTE_INSTALL);
 
-done:
 	return ret;
 }
 
@@ -3615,11 +3991,11 @@ enum zebra_dplane_result dplane_route_up
 	enum zebra_dplane_result ret = ZEBRA_DPLANE_REQUEST_FAILURE;
 
 	if (rn == NULL || re == NULL)
-		goto done;
+		return ret;
 
 	ret = dplane_route_update_internal(rn, re, old_re,
 					   DPLANE_OP_ROUTE_UPDATE);
-done:
+
 	return ret;
 }
 
@@ -3632,12 +4008,11 @@ enum zebra_dplane_result dplane_route_de
 	enum zebra_dplane_result ret = ZEBRA_DPLANE_REQUEST_FAILURE;
 
 	if (rn == NULL || re == NULL)
-		goto done;
+		return ret;
 
 	ret = dplane_route_update_internal(rn, re, NULL,
 					   DPLANE_OP_ROUTE_DELETE);
 
-done:
 	return ret;
 }
 
@@ -3650,18 +4025,16 @@ enum zebra_dplane_result dplane_sys_rout
 	enum zebra_dplane_result ret = ZEBRA_DPLANE_REQUEST_FAILURE;
 
 	/* Ignore this event unless a provider plugin has requested it. */
-	if (!zdplane_info.dg_sys_route_notifs) {
-		ret = ZEBRA_DPLANE_REQUEST_SUCCESS;
-		goto done;
-	}
+	if (!zdplane_info.dg_sys_route_notifs)
+		return ZEBRA_DPLANE_REQUEST_SUCCESS;
+
 
 	if (rn == NULL || re == NULL)
-		goto done;
+		return ret;
 
 	ret = dplane_route_update_internal(rn, re, NULL,
 					   DPLANE_OP_SYS_ROUTE_ADD);
 
-done:
 	return ret;
 }
 
@@ -3674,18 +4047,15 @@ enum zebra_dplane_result dplane_sys_rout
 	enum zebra_dplane_result ret = ZEBRA_DPLANE_REQUEST_FAILURE;
 
 	/* Ignore this event unless a provider plugin has requested it. */
-	if (!zdplane_info.dg_sys_route_notifs) {
-		ret = ZEBRA_DPLANE_REQUEST_SUCCESS;
-		goto done;
-	}
+	if (!zdplane_info.dg_sys_route_notifs)
+		return ZEBRA_DPLANE_REQUEST_SUCCESS;
 
 	if (rn == NULL || re == NULL)
-		goto done;
+		return ret;
 
 	ret = dplane_route_update_internal(rn, re, NULL,
 					   DPLANE_OP_SYS_ROUTE_DELETE);
 
-done:
 	return ret;
 }
 
@@ -4708,8 +5078,8 @@ neigh_update_internal(enum dplane_op_e o
 			ipaddr2str(link_ip, buf1, sizeof(buf1));
 		zlog_debug("init neigh ctx %s: ifp %s, %s %s, ip %pIA",
 			   dplane_op2str(op), ifp->name,
-			   link_family == AF_ETHERNET ? "mac " : "link ",
-			   buf1, ip);
+			   link_family == AF_ETHERNET ? "mac" : "link", buf1,
+			   ip);
 	}
 
 	ctx = dplane_ctx_alloc();
@@ -5158,7 +5528,7 @@ int dplane_show_provs_helper(struct vty
 	vty_out(vty, "Zebra dataplane providers:\n");
 
 	DPLANE_LOCK();
-	prov = TAILQ_FIRST(&zdplane_info.dg_providers_q);
+	prov = dplane_prov_list_first(&zdplane_info.dg_providers);
 	DPLANE_UNLOCK();
 
 	/* Show counters, useful info from each registered provider */
@@ -5181,9 +5551,7 @@ int dplane_show_provs_helper(struct vty
 			prov->dp_name, prov->dp_id, in, in_q, in_max,
 			out, out_q, out_max);
 
-		DPLANE_LOCK();
-		prov = TAILQ_NEXT(prov, dp_prov_link);
-		DPLANE_UNLOCK();
+		prov = dplane_prov_list_next(&zdplane_info.dg_providers, prov);
 	}
 
 	return CMD_SUCCESS;
@@ -5233,8 +5601,8 @@ int dplane_provider_register(const char
 	p = XCALLOC(MTYPE_DP_PROV, sizeof(struct zebra_dplane_provider));
 
 	pthread_mutex_init(&(p->dp_mutex), NULL);
-	TAILQ_INIT(&(p->dp_ctx_in_q));
-	TAILQ_INIT(&(p->dp_ctx_out_q));
+	dplane_ctx_list_init(&p->dp_ctx_in_list);
+	dplane_ctx_list_init(&p->dp_ctx_out_list);
 
 	p->dp_flags = flags;
 	p->dp_priority = prio;
@@ -5255,16 +5623,15 @@ int dplane_provider_register(const char
 			 "provider-%u", p->dp_id);
 
 	/* Insert into list ordered by priority */
-	TAILQ_FOREACH(last, &zdplane_info.dg_providers_q, dp_prov_link) {
+	frr_each (dplane_prov_list, &zdplane_info.dg_providers, last) {
 		if (last->dp_priority > p->dp_priority)
 			break;
 	}
 
 	if (last)
-		TAILQ_INSERT_BEFORE(last, p, dp_prov_link);
+		dplane_prov_list_add_after(&zdplane_info.dg_providers, last, p);
 	else
-		TAILQ_INSERT_TAIL(&zdplane_info.dg_providers_q, p,
-				  dp_prov_link);
+		dplane_prov_list_add_tail(&zdplane_info.dg_providers, p);
 
 	/* And unlock */
 	DPLANE_UNLOCK();
@@ -5326,10 +5693,8 @@ struct zebra_dplane_ctx *dplane_provider
 
 	dplane_provider_lock(prov);
 
-	ctx = TAILQ_FIRST(&(prov->dp_ctx_in_q));
+	ctx = dplane_ctx_list_pop(&(prov->dp_ctx_in_list));
 	if (ctx) {
-		TAILQ_REMOVE(&(prov->dp_ctx_in_q), ctx, zd_q_entries);
-
 		atomic_fetch_sub_explicit(&prov->dp_in_queued, 1,
 					  memory_order_relaxed);
 	}
@@ -5343,7 +5708,7 @@ struct zebra_dplane_ctx *dplane_provider
  * Dequeue work to a list, return count
  */
 int dplane_provider_dequeue_in_list(struct zebra_dplane_provider *prov,
-				    struct dplane_ctx_q *listp)
+				    struct dplane_ctx_list_head *listp)
 {
 	int limit, ret;
 	struct zebra_dplane_ctx *ctx;
@@ -5353,14 +5718,11 @@ int dplane_provider_dequeue_in_list(stru
 	dplane_provider_lock(prov);
 
 	for (ret = 0; ret < limit; ret++) {
-		ctx = TAILQ_FIRST(&(prov->dp_ctx_in_q));
-		if (ctx) {
-			TAILQ_REMOVE(&(prov->dp_ctx_in_q), ctx, zd_q_entries);
-
-			TAILQ_INSERT_TAIL(listp, ctx, zd_q_entries);
-		} else {
+		ctx = dplane_ctx_list_pop(&(prov->dp_ctx_in_list));
+		if (ctx)
+			dplane_ctx_list_add_tail(listp, ctx);
+		else
 			break;
-		}
 	}
 
 	if (ret > 0)
@@ -5388,8 +5750,7 @@ void dplane_provider_enqueue_out_ctx(str
 
 	dplane_provider_lock(prov);
 
-	TAILQ_INSERT_TAIL(&(prov->dp_ctx_out_q), ctx,
-			  zd_q_entries);
+	dplane_ctx_list_add_tail(&(prov->dp_ctx_out_list), ctx);
 
 	/* Maintain out-queue counters */
 	atomic_fetch_add_explicit(&(prov->dp_out_queued), 1,
@@ -5559,12 +5920,12 @@ int dplane_provider_work_ready(void)
  */
 void dplane_provider_enqueue_to_zebra(struct zebra_dplane_ctx *ctx)
 {
-	struct dplane_ctx_q temp_list;
+	struct dplane_ctx_list_head temp_list;
 
 	/* Zebra's api takes a list, so we need to use a temporary list */
-	TAILQ_INIT(&temp_list);
+	dplane_ctx_list_init(&temp_list);
 
-	TAILQ_INSERT_TAIL(&temp_list, ctx, zd_q_entries);
+	dplane_ctx_list_add_tail(&temp_list, ctx);
 	(zdplane_info.dg_results_cb)(&temp_list);
 }
 
@@ -5727,10 +6088,18 @@ static void kernel_dplane_log_detail(str
 		break;
 
 	/* TODO: more detailed log */
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
-		zlog_debug("Dplane tc ifidx %u", dplane_ctx_get_ifindex(ctx));
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+		zlog_debug("Dplane tc qdisc ifidx %u",
+			   dplane_ctx_get_ifindex(ctx));
+		break;
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+		break;
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		break;
 	}
 }
@@ -5875,9 +6244,14 @@ static void kernel_dplane_handle_result(
 						  1, memory_order_relaxed);
 		break;
 
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		if (res != ZEBRA_DPLANE_REQUEST_SUCCESS)
 			atomic_fetch_add_explicit(&zdplane_info.dg_tcs_errors,
 						  1, memory_order_relaxed);
@@ -5927,16 +6301,30 @@ kernel_dplane_process_ipset_entry(struct
 	dplane_provider_enqueue_out_ctx(prov, ctx);
 }
 
+void dplane_rib_add_multipath(afi_t afi, safi_t safi, struct prefix *p,
+			      struct prefix_ipv6 *src_p, struct route_entry *re,
+			      struct nexthop_group *ng, int startup,
+			      struct zebra_dplane_ctx *ctx)
+{
+	if (!ctx)
+		rib_add_multipath(afi, safi, p, src_p, re, ng, startup);
+	else {
+		dplane_ctx_route_init_basic(ctx, dplane_ctx_get_op(ctx), re, p,
+					    src_p, afi, safi);
+		dplane_provider_enqueue_to_zebra(ctx);
+	}
+}
+
 /*
  * Kernel provider callback
  */
 static int kernel_dplane_process_func(struct zebra_dplane_provider *prov)
 {
-	struct zebra_dplane_ctx *ctx, *tctx;
-	struct dplane_ctx_q work_list;
+	struct zebra_dplane_ctx *ctx;
+	struct dplane_ctx_list_head work_list;
 	int counter, limit;
 
-	TAILQ_INIT(&work_list);
+	dplane_ctx_list_init(&work_list);
 
 	limit = dplane_provider_get_work_limit(prov);
 
@@ -5962,15 +6350,14 @@ static int kernel_dplane_process_func(st
 				     == DPLANE_OP_IPSET_ENTRY_DELETE))
 			kernel_dplane_process_ipset_entry(prov, ctx);
 		else
-			TAILQ_INSERT_TAIL(&work_list, ctx, zd_q_entries);
+			dplane_ctx_list_add_tail(&work_list, ctx);
 	}
 
 	kernel_update_multi(&work_list);
 
-	TAILQ_FOREACH_SAFE (ctx, &work_list, zd_q_entries, tctx) {
+	while ((ctx = dplane_ctx_list_pop(&work_list)) != NULL) {
 		kernel_dplane_handle_result(ctx);
 
-		TAILQ_REMOVE(&work_list, ctx, zd_q_entries);
 		dplane_provider_enqueue_out_ctx(prov, ctx);
 	}
 
@@ -6097,23 +6484,21 @@ static void dplane_provider_init(void)
 int dplane_clean_ctx_queue(bool (*context_cb)(struct zebra_dplane_ctx *ctx,
 					      void *arg), void *val)
 {
-	struct zebra_dplane_ctx *ctx, *temp;
-	struct dplane_ctx_q work_list;
+	struct zebra_dplane_ctx *ctx;
+	struct dplane_ctx_list_head work_list;
 
-	TAILQ_INIT(&work_list);
+	dplane_ctx_list_init(&work_list);
 
 	if (context_cb == NULL)
-		goto done;
+		return AOK;
 
 	/* Walk the pending context queue under the dplane lock. */
 	DPLANE_LOCK();
 
-	TAILQ_FOREACH_SAFE(ctx, &zdplane_info.dg_update_ctx_q, zd_q_entries,
-			   temp) {
+	frr_each_safe (dplane_ctx_list, &zdplane_info.dg_update_list, ctx) {
 		if (context_cb(ctx, val)) {
-			TAILQ_REMOVE(&zdplane_info.dg_update_ctx_q, ctx,
-				     zd_q_entries);
-			TAILQ_INSERT_TAIL(&work_list, ctx, zd_q_entries);
+			dplane_ctx_list_del(&zdplane_info.dg_update_list, ctx);
+			dplane_ctx_list_add_tail(&work_list, ctx);
 		}
 	}
 
@@ -6122,14 +6507,10 @@ int dplane_clean_ctx_queue(bool (*contex
 	/* Now free any contexts selected by the caller, without holding
 	 * the lock.
 	 */
-	TAILQ_FOREACH_SAFE(ctx, &work_list, zd_q_entries, temp) {
-		TAILQ_REMOVE(&work_list, ctx, zd_q_entries);
+	while ((ctx = dplane_ctx_list_pop(&work_list)) != NULL)
 		dplane_ctx_fini(&ctx);
-	}
 
-done:
-
-	return 0;
+	return AOK;
 }
 
 /* Indicates zebra shutdown/exit is in progress. Some operations may be
@@ -6165,7 +6546,7 @@ void zebra_dplane_pre_finish(void)
 	zdplane_info.dg_is_shutdown = true;
 
 	/* Notify provider(s) of pending shutdown. */
-	TAILQ_FOREACH(prov, &zdplane_info.dg_providers_q, dp_prov_link) {
+	frr_each (dplane_prov_list, &zdplane_info.dg_providers, prov) {
 		if (prov->dp_fini == NULL)
 			continue;
 
@@ -6188,38 +6569,33 @@ static bool dplane_work_pending(void)
 	 */
 	DPLANE_LOCK();
 	{
-		ctx = TAILQ_FIRST(&zdplane_info.dg_update_ctx_q);
-		prov = TAILQ_FIRST(&zdplane_info.dg_providers_q);
+		ctx = dplane_ctx_list_first(&zdplane_info.dg_update_list);
+		prov = dplane_prov_list_first(&zdplane_info.dg_providers);
 	}
 	DPLANE_UNLOCK();
 
-	if (ctx != NULL) {
-		ret = true;
-		goto done;
-	}
+	if (ctx != NULL)
+		return true;
 
 	while (prov) {
 
 		dplane_provider_lock(prov);
 
-		ctx = TAILQ_FIRST(&(prov->dp_ctx_in_q));
+		ctx = dplane_ctx_list_first(&(prov->dp_ctx_in_list));
 		if (ctx == NULL)
-			ctx = TAILQ_FIRST(&(prov->dp_ctx_out_q));
+			ctx = dplane_ctx_list_first(&(prov->dp_ctx_out_list));
 
 		dplane_provider_unlock(prov);
 
 		if (ctx != NULL)
 			break;
 
-		DPLANE_LOCK();
-		prov = TAILQ_NEXT(prov, dp_prov_link);
-		DPLANE_UNLOCK();
+		prov = dplane_prov_list_next(&zdplane_info.dg_providers, prov);
 	}
 
 	if (ctx != NULL)
 		ret = true;
 
-done:
 	return ret;
 }
 
@@ -6299,10 +6675,10 @@ void zebra_dplane_finish(void)
  */
 static void dplane_thread_loop(struct thread *event)
 {
-	struct dplane_ctx_q work_list;
-	struct dplane_ctx_q error_list;
+	struct dplane_ctx_list_head work_list;
+	struct dplane_ctx_list_head error_list;
 	struct zebra_dplane_provider *prov;
-	struct zebra_dplane_ctx *ctx, *tctx;
+	struct zebra_dplane_ctx *ctx;
 	int limit, counter, error_counter;
 	uint64_t curr, high;
 	bool reschedule = false;
@@ -6311,8 +6687,9 @@ static void dplane_thread_loop(struct th
 	limit = zdplane_info.dg_updates_per_cycle;
 
 	/* Init temporary lists used to move contexts among providers */
-	TAILQ_INIT(&work_list);
-	TAILQ_INIT(&error_list);
+	dplane_ctx_list_init(&work_list);
+	dplane_ctx_list_init(&error_list);
+
 	error_counter = 0;
 
 	/* Check for zebra shutdown */
@@ -6325,18 +6702,15 @@ static void dplane_thread_loop(struct th
 	DPLANE_LOCK();
 
 	/* Locate initial registered provider */
-	prov = TAILQ_FIRST(&zdplane_info.dg_providers_q);
+	prov = dplane_prov_list_first(&zdplane_info.dg_providers);
 
 	/* Move new work from incoming list to temp list */
 	for (counter = 0; counter < limit; counter++) {
-		ctx = TAILQ_FIRST(&zdplane_info.dg_update_ctx_q);
+		ctx = dplane_ctx_list_pop(&zdplane_info.dg_update_list);
 		if (ctx) {
-			TAILQ_REMOVE(&zdplane_info.dg_update_ctx_q, ctx,
-				     zd_q_entries);
-
 			ctx->zd_provider = prov->dp_id;
 
-			TAILQ_INSERT_TAIL(&work_list, ctx, zd_q_entries);
+			dplane_ctx_list_add_tail(&work_list, ctx);
 		} else {
 			break;
 		}
@@ -6366,7 +6740,7 @@ static void dplane_thread_loop(struct th
 		/* Capture current provider id in each context; check for
 		 * error status.
 		 */
-		TAILQ_FOREACH_SAFE(ctx, &work_list, zd_q_entries, tctx) {
+		frr_each_safe (dplane_ctx_list, &work_list, ctx) {
 			if (dplane_ctx_get_status(ctx) ==
 			    ZEBRA_DPLANE_REQUEST_SUCCESS) {
 				ctx->zd_provider = prov->dp_id;
@@ -6380,9 +6754,8 @@ static void dplane_thread_loop(struct th
 				/* Move to error list; will be returned
 				 * zebra main.
 				 */
-				TAILQ_REMOVE(&work_list, ctx, zd_q_entries);
-				TAILQ_INSERT_TAIL(&error_list,
-						  ctx, zd_q_entries);
+				dplane_ctx_list_del(&work_list, ctx);
+				dplane_ctx_list_add_tail(&error_list, ctx);
 				error_counter++;
 			}
 		}
@@ -6390,9 +6763,8 @@ static void dplane_thread_loop(struct th
 		/* Enqueue new work to the provider */
 		dplane_provider_lock(prov);
 
-		if (TAILQ_FIRST(&work_list))
-			TAILQ_CONCAT(&(prov->dp_ctx_in_q), &work_list,
-				     zd_q_entries);
+		while ((ctx = dplane_ctx_list_pop(&work_list)) != NULL)
+			dplane_ctx_list_add_tail(&(prov->dp_ctx_in_list), ctx);
 
 		atomic_fetch_add_explicit(&prov->dp_in_counter, counter,
 					  memory_order_relaxed);
@@ -6411,7 +6783,7 @@ static void dplane_thread_loop(struct th
 		/* Reset the temp list (though the 'concat' may have done this
 		 * already), and the counter
 		 */
-		TAILQ_INIT(&work_list);
+		dplane_ctx_list_init(&work_list);
 		counter = 0;
 
 		/* Call into the provider code. Note that this is
@@ -6428,13 +6800,9 @@ static void dplane_thread_loop(struct th
 		dplane_provider_lock(prov);
 
 		while (counter < limit) {
-			ctx = TAILQ_FIRST(&(prov->dp_ctx_out_q));
+			ctx = dplane_ctx_list_pop(&(prov->dp_ctx_out_list));
 			if (ctx) {
-				TAILQ_REMOVE(&(prov->dp_ctx_out_q), ctx,
-					     zd_q_entries);
-
-				TAILQ_INSERT_TAIL(&work_list,
-						  ctx, zd_q_entries);
+				dplane_ctx_list_add_tail(&work_list, ctx);
 				counter++;
 			} else
 				break;
@@ -6450,9 +6818,7 @@ static void dplane_thread_loop(struct th
 				   counter, dplane_provider_get_name(prov));
 
 		/* Locate next provider */
-		DPLANE_LOCK();
-		prov = TAILQ_NEXT(prov, dp_prov_link);
-		DPLANE_UNLOCK();
+		prov = dplane_prov_list_next(&zdplane_info.dg_providers, prov);
 	}
 
 	/*
@@ -6477,12 +6843,12 @@ static void dplane_thread_loop(struct th
 	/* Call through to zebra main */
 	(zdplane_info.dg_results_cb)(&error_list);
 
-	TAILQ_INIT(&error_list);
+	dplane_ctx_list_init(&error_list);
 
 	/* Call through to zebra main */
 	(zdplane_info.dg_results_cb)(&work_list);
 
-	TAILQ_INIT(&work_list);
+	dplane_ctx_list_init(&work_list);
 }
 
 /*
@@ -6515,7 +6881,7 @@ void zebra_dplane_shutdown(void)
 	 * Note that this call is in the main pthread, so providers must
 	 * be prepared for that.
 	 */
-	TAILQ_FOREACH(dp, &zdplane_info.dg_providers_q, dp_prov_link) {
+	frr_each (dplane_prov_list, &zdplane_info.dg_providers, dp) {
 		if (dp->dp_fini == NULL)
 			continue;
 
@@ -6536,8 +6902,9 @@ static void zebra_dplane_init_internal(v
 
 	pthread_mutex_init(&zdplane_info.dg_mutex, NULL);
 
-	TAILQ_INIT(&zdplane_info.dg_update_ctx_q);
-	TAILQ_INIT(&zdplane_info.dg_providers_q);
+	dplane_prov_list_init(&zdplane_info.dg_providers);
+
+	dplane_ctx_list_init(&zdplane_info.dg_update_list);
 	zns_info_list_init(&zdplane_info.dg_zns_list);
 
 	zdplane_info.dg_updates_per_cycle = DPLANE_DEFAULT_NEW_WORK;
@@ -6586,7 +6953,7 @@ void zebra_dplane_start(void)
 	/* Call start callbacks for registered providers */
 
 	DPLANE_LOCK();
-	prov = TAILQ_FIRST(&zdplane_info.dg_providers_q);
+	prov = dplane_prov_list_first(&zdplane_info.dg_providers);
 	DPLANE_UNLOCK();
 
 	while (prov) {
@@ -6595,9 +6962,7 @@ void zebra_dplane_start(void)
 			(prov->dp_start)(prov);
 
 		/* Locate next provider */
-		DPLANE_LOCK();
-		prov = TAILQ_NEXT(prov, dp_prov_link);
-		DPLANE_UNLOCK();
+		prov = dplane_prov_list_next(&zdplane_info.dg_providers, prov);
 	}
 
 	frr_pthread_run(zdplane_info.dg_pthread, NULL);
@@ -6606,7 +6971,7 @@ void zebra_dplane_start(void)
 /*
  * Initialize the dataplane module at startup; called by zebra rib_init()
  */
-void zebra_dplane_init(int (*results_fp)(struct dplane_ctx_q *))
+void zebra_dplane_init(int (*results_fp)(struct dplane_ctx_list_head *))
 {
 	zebra_dplane_init_internal();
 	zdplane_info.dg_results_cb = results_fp;
diff -urpN frr-frr-8.4.2/zebra/zebra_dplane.h frr-frr-8.5/zebra/zebra_dplane.h
--- frr-frr-8.4.2/zebra/zebra_dplane.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_dplane.h	2023-03-13 20:01:47.000000000 +0600
@@ -24,7 +24,6 @@
 #include "lib/prefix.h"
 #include "lib/nexthop.h"
 #include "lib/nexthop_group.h"
-#include "lib/queue.h"
 #include "lib/vlan.h"
 #include "zebra/zebra_ns.h"
 #include "zebra/rib.h"
@@ -195,9 +194,14 @@ enum dplane_op_e {
 	DPLANE_OP_INTF_DELETE,
 
 	/* Traffic control */
-	DPLANE_OP_TC_INSTALL,
-	DPLANE_OP_TC_UPDATE,
-	DPLANE_OP_TC_DELETE,
+	DPLANE_OP_TC_QDISC_INSTALL,
+	DPLANE_OP_TC_QDISC_UNINSTALL,
+	DPLANE_OP_TC_CLASS_ADD,
+	DPLANE_OP_TC_CLASS_DELETE,
+	DPLANE_OP_TC_CLASS_UPDATE,
+	DPLANE_OP_TC_FILTER_ADD,
+	DPLANE_OP_TC_FILTER_DELETE,
+	DPLANE_OP_TC_FILTER_UPDATE
 };
 
 /*
@@ -260,14 +264,15 @@ void dplane_enable_sys_route_notifs(void
  * they cannot share existing global data structures safely.
  */
 
-/* Define a tailq list type for context blocks. The list is exposed/public,
+/* Define a list type for context blocks. The list is exposed/public,
  * but the internal linkage in the context struct is private, so there
  * are accessor apis that support enqueue and dequeue.
  */
-TAILQ_HEAD(dplane_ctx_q, zebra_dplane_ctx);
+
+PREDECL_DLIST(dplane_ctx_list);
 
 /* Declare a type for (optional) extended interface info objects. */
-TAILQ_HEAD(dplane_intf_extra_q, dplane_intf_extra);
+PREDECL_DLIST(dplane_intf_extra_list);
 
 /* Allocate a context object */
 struct zebra_dplane_ctx *dplane_ctx_alloc(void);
@@ -295,18 +300,21 @@ void dplane_ctx_fini(struct zebra_dplane
 /* Enqueue a context block to caller's tailq. This exists so that the
  * context struct can remain opaque.
  */
-void dplane_ctx_enqueue_tail(struct dplane_ctx_q *q,
+void dplane_ctx_enqueue_tail(struct dplane_ctx_list_head *q,
 			     const struct zebra_dplane_ctx *ctx);
 
 /* Append a list of context blocks to another list - again, just keeping
  * the context struct opaque.
  */
-void dplane_ctx_list_append(struct dplane_ctx_q *to_list,
-			    struct dplane_ctx_q *from_list);
+void dplane_ctx_list_append(struct dplane_ctx_list_head *to_list,
+			    struct dplane_ctx_list_head *from_list);
 
 /* Dequeue a context block from the head of caller's tailq */
-struct zebra_dplane_ctx *dplane_ctx_dequeue(struct dplane_ctx_q *q);
-struct zebra_dplane_ctx *dplane_ctx_get_head(struct dplane_ctx_q *q);
+struct zebra_dplane_ctx *dplane_ctx_dequeue(struct dplane_ctx_list_head *q);
+struct zebra_dplane_ctx *dplane_ctx_get_head(struct dplane_ctx_list_head *q);
+
+/* Init a list of contexts */
+void dplane_ctx_q_init(struct dplane_ctx_list_head *q);
 
 /*
  * Accessors for information from the context object
@@ -375,6 +383,8 @@ route_tag_t dplane_ctx_get_old_tag(const
 uint16_t dplane_ctx_get_instance(const struct zebra_dplane_ctx *ctx);
 void dplane_ctx_set_instance(struct zebra_dplane_ctx *ctx, uint16_t instance);
 uint16_t dplane_ctx_get_old_instance(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_get_flags(const struct zebra_dplane_ctx *ctx);
+void dplane_ctx_set_flags(struct zebra_dplane_ctx *ctx, uint32_t flags);
 uint32_t dplane_ctx_get_metric(const struct zebra_dplane_ctx *ctx);
 uint32_t dplane_ctx_get_old_metric(const struct zebra_dplane_ctx *ctx);
 uint32_t dplane_ctx_get_mtu(const struct zebra_dplane_ctx *ctx);
@@ -384,14 +394,42 @@ void dplane_ctx_set_distance(struct zebr
 uint8_t dplane_ctx_get_old_distance(const struct zebra_dplane_ctx *ctx);
 
 /* Accessors for traffic control context */
-uint64_t dplane_ctx_tc_get_rate(const struct zebra_dplane_ctx *ctx);
-uint64_t dplane_ctx_tc_get_ceil(const struct zebra_dplane_ctx *ctx);
-uint32_t dplane_ctx_tc_get_filter_bm(const struct zebra_dplane_ctx *ctx);
+int dplane_ctx_tc_qdisc_get_kind(const struct zebra_dplane_ctx *ctx);
+const char *
+dplane_ctx_tc_qdisc_get_kind_str(const struct zebra_dplane_ctx *ctx);
+
+uint32_t dplane_ctx_tc_class_get_handle(const struct zebra_dplane_ctx *ctx);
+int dplane_ctx_tc_class_get_kind(const struct zebra_dplane_ctx *ctx);
+const char *
+dplane_ctx_tc_class_get_kind_str(const struct zebra_dplane_ctx *ctx);
+uint64_t dplane_ctx_tc_class_get_rate(const struct zebra_dplane_ctx *ctx);
+uint64_t dplane_ctx_tc_class_get_ceil(const struct zebra_dplane_ctx *ctx);
+
+int dplane_ctx_tc_filter_get_kind(const struct zebra_dplane_ctx *ctx);
+const char *
+dplane_ctx_tc_filter_get_kind_str(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_tc_filter_get_priority(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_tc_filter_get_handle(const struct zebra_dplane_ctx *ctx);
+uint16_t dplane_ctx_tc_filter_get_minor(const struct zebra_dplane_ctx *ctx);
+uint16_t dplane_ctx_tc_filter_get_eth_proto(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_tc_filter_get_filter_bm(const struct zebra_dplane_ctx *ctx);
 const struct prefix *
-dplane_ctx_tc_get_src_ip(const struct zebra_dplane_ctx *ctx);
+dplane_ctx_tc_filter_get_src_ip(const struct zebra_dplane_ctx *ctx);
+uint16_t
+dplane_ctx_tc_filter_get_src_port_min(const struct zebra_dplane_ctx *ctx);
+uint16_t
+dplane_ctx_tc_filter_get_src_port_max(const struct zebra_dplane_ctx *ctx);
 const struct prefix *
-dplane_ctx_tc_get_dst_ip(const struct zebra_dplane_ctx *ctx);
-uint8_t dplane_ctx_tc_get_ip_proto(const struct zebra_dplane_ctx *ctx);
+dplane_ctx_tc_filter_get_dst_ip(const struct zebra_dplane_ctx *ctx);
+uint16_t
+dplane_ctx_tc_filter_get_dst_port_min(const struct zebra_dplane_ctx *ctx);
+uint16_t
+dplane_ctx_tc_filter_get_dst_port_max(const struct zebra_dplane_ctx *ctx);
+uint8_t dplane_ctx_tc_filter_get_ip_proto(const struct zebra_dplane_ctx *ctx);
+uint8_t dplane_ctx_tc_filter_get_dsfield(const struct zebra_dplane_ctx *ctx);
+uint8_t
+dplane_ctx_tc_filter_get_dsfield_mask(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_tc_filter_get_classid(const struct zebra_dplane_ctx *ctx);
 
 void dplane_ctx_set_nexthops(struct zebra_dplane_ctx *ctx, struct nexthop *nh);
 void dplane_ctx_set_backup_nhg(struct zebra_dplane_ctx *ctx,
@@ -723,11 +761,23 @@ enum zebra_dplane_result dplane_intf_upd
 enum zebra_dplane_result dplane_intf_delete(const struct interface *ifp);
 
 /*
- * Enqueue interface link changes for the dataplane.
+ * Enqueue tc link changes for the dataplane.
  */
-enum zebra_dplane_result dplane_tc_add(void);
-enum zebra_dplane_result dplane_tc_update(void);
-enum zebra_dplane_result dplane_tc_delete(void);
+
+struct zebra_tc_qdisc;
+struct zebra_tc_class;
+struct zebra_tc_filter;
+enum zebra_dplane_result dplane_tc_qdisc_install(struct zebra_tc_qdisc *qdisc);
+enum zebra_dplane_result
+dplane_tc_qdisc_uninstall(struct zebra_tc_qdisc *qdisc);
+enum zebra_dplane_result dplane_tc_class_add(struct zebra_tc_class *class);
+enum zebra_dplane_result dplane_tc_class_delete(struct zebra_tc_class *class);
+enum zebra_dplane_result dplane_tc_class_update(struct zebra_tc_class *class);
+enum zebra_dplane_result dplane_tc_filter_add(struct zebra_tc_filter *filter);
+enum zebra_dplane_result
+dplane_tc_filter_delete(struct zebra_tc_filter *filter);
+enum zebra_dplane_result
+dplane_tc_filter_update(struct zebra_tc_filter *filter);
 
 /*
  * Link layer operations for the dataplane.
@@ -863,6 +913,12 @@ dplane_pbr_ipset_entry_delete(struct zeb
 int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 			  struct route_node *rn, struct route_entry *re);
 
+int dplane_ctx_route_init_basic(struct zebra_dplane_ctx *ctx,
+				enum dplane_op_e op, struct route_entry *re,
+				const struct prefix *p,
+				const struct prefix_ipv6 *src_p, afi_t afi,
+				safi_t safi);
+
 /* Encode next hop information into data plane context. */
 int dplane_ctx_nexthop_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 			    struct nhg_hash_entry *nhe);
@@ -983,7 +1039,7 @@ struct zebra_dplane_ctx *dplane_provider
 
 /* Dequeue work to a list, maintain counter and locking, return count */
 int dplane_provider_dequeue_in_list(struct zebra_dplane_provider *prov,
-				    struct dplane_ctx_q *listp);
+				    struct dplane_ctx_list_head *listp);
 
 /* Current completed work queue length */
 uint32_t dplane_provider_out_ctx_queue_len(struct zebra_dplane_provider *prov);
@@ -1008,7 +1064,7 @@ void dplane_enable_intf_extra_info(void)
  * so the expectation is that the contexts are queued for the zebra
  * main pthread.
  */
-void zebra_dplane_init(int (*) (struct dplane_ctx_q *));
+void zebra_dplane_init(int (*)(struct dplane_ctx_list_head *));
 
 /*
  * Start the dataplane pthread. This step needs to be run later than the
@@ -1028,6 +1084,16 @@ void zebra_dplane_pre_finish(void);
 void zebra_dplane_finish(void);
 void zebra_dplane_shutdown(void);
 
+/*
+ * decision point for sending a routing update through the old
+ * straight to zebra master pthread or through the dplane to
+ * the master pthread for handling
+ */
+void dplane_rib_add_multipath(afi_t afi, safi_t safi, struct prefix *p,
+			      struct prefix_ipv6 *src_p, struct route_entry *re,
+			      struct nexthop_group *ng, int startup,
+			      struct zebra_dplane_ctx *ctx);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn.c frr-frr-8.5/zebra/zebra_evpn.c
--- frr-frr-8.4.2/zebra/zebra_evpn.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn.c	2023-03-13 20:01:47.000000000 +0600
@@ -1327,11 +1327,11 @@ static void zebra_evpn_process_sync_maci
 					      uint8_t flags, uint32_t seq,
 					      const esi_t *esi)
 {
-	struct sync_mac_ip_ctx ctx;
 	char ipbuf[INET6_ADDRSTRLEN];
 	bool sticky;
 	bool remote_gw;
 	struct zebra_neigh *n = NULL;
+	struct zebra_mac *mac = NULL;
 
 	sticky = !!CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_STICKY);
 	remote_gw = !!CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_GW);
@@ -1352,22 +1352,30 @@ static void zebra_evpn_process_sync_maci
 		return;
 	}
 
-	if (ipa_len) {
+	if (!ipa_len) {
+		/* MAC update */
+		(void)zebra_evpn_proc_sync_mac_update(zevpn, macaddr, ipa_len,
+						      ipaddr, flags, seq, esi);
+	} else {
+		/* MAC-IP update */
+		mac = zebra_evpn_mac_lookup(zevpn, macaddr);
+		if (!mac) {
+			mac = zebra_evpn_proc_sync_mac_update(zevpn, macaddr,
+							      ipa_len, ipaddr,
+							      flags, seq, esi);
+		}
+		if (!mac)
+			return;
+
 		n = zebra_evpn_neigh_lookup(zevpn, ipaddr);
 		if (n
 		    && !zebra_evpn_neigh_is_bgp_seq_ok(zevpn, n, macaddr, seq,
 						       true))
 			return;
-	}
-
-	memset(&ctx, 0, sizeof(ctx));
-	ctx.mac = zebra_evpn_proc_sync_mac_update(
-		zevpn, macaddr, ipa_len, ipaddr, flags, seq, esi, &ctx);
-	if (ctx.ignore_macip || !ctx.mac || !ipa_len)
-		return;
 
-	zebra_evpn_proc_sync_neigh_update(zevpn, n, ipa_len, ipaddr, flags, seq,
-					  esi, &ctx);
+		zebra_evpn_proc_sync_neigh_update(zevpn, n, ipa_len, ipaddr,
+						  flags, seq, esi, mac);
+	}
 }
 
 /************************** remote mac-ip handling **************************/
@@ -1452,14 +1460,30 @@ void zebra_evpn_rem_macip_add(vni_t vni,
 	}
 
 	zvrf = zebra_vrf_get_evpn();
-	if (zebra_evpn_mac_remote_macip_add(zevpn, zvrf, macaddr, ipa_len,
-					    ipaddr, &mac, vtep_ip, flags, seq,
-					    esi)
-	    != 0)
+	if (!zvrf)
 		return;
 
-	zebra_evpn_neigh_remote_macip_add(zevpn, zvrf, ipaddr, mac, vtep_ip,
-					  flags, seq);
+	if (!ipa_len) {
+		/* MAC update */
+		zebra_evpn_mac_remote_macip_add(zevpn, zvrf, macaddr, vtep_ip,
+						flags, seq, esi);
+	} else {
+		/* MAC-IP update
+		 * Add auto MAC if it doesn't exist.
+		 */
+		mac = zebra_evpn_mac_lookup(zevpn, macaddr);
+		if (!mac) {
+			mac = zebra_evpn_mac_add_auto(zevpn, macaddr);
+
+			if (IS_ZEBRA_DEBUG_VXLAN)
+				zlog_debug(
+					"Neigh %pIA: MAC %pEA not found, Auto MAC created",
+					ipaddr, macaddr);
+		}
+
+		zebra_evpn_neigh_remote_macip_add(zevpn, zvrf, ipaddr, mac,
+						  vtep_ip, flags, seq);
+	}
 }
 
 /* Process a remote MACIP delete from BGP. */
@@ -1504,7 +1528,7 @@ void zebra_evpn_rem_macip_del(vni_t vni,
 
 	if (n && !mac) {
 		zlog_warn(
-			"Failed to locate MAC %pEA for neigh %pIA VNI %u upon remote MACIP DEL",
+			"Failed to locate MAC %pEA for Neigh %pIA VNI %u upon remote MACIP DEL",
 			macaddr, ipaddr, vni);
 		return;
 	}
@@ -1512,8 +1536,13 @@ void zebra_evpn_rem_macip_del(vni_t vni,
 	/* If the remote mac or neighbor doesn't exist there is nothing
 	 * more to do. Otherwise, uninstall the entry and then remove it.
 	 */
-	if (!mac && !n)
+	if (!mac && !n) {
+		if (IS_ZEBRA_DEBUG_VXLAN)
+			zlog_debug(
+				"Failed to locate MAC %pEA & Neigh %pIA VNI %u upon remote MACIP DEL",
+				macaddr, ipaddr, vni);
 		return;
+	}
 
 	zvrf = zevpn->vxlan_if->vrf->info;
 
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn_mac.c frr-frr-8.5/zebra/zebra_evpn_mac.c
--- frr-frr-8.4.2/zebra/zebra_evpn_mac.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn_mac.c	2023-03-13 20:01:47.000000000 +0600
@@ -653,8 +653,13 @@ void zebra_evpn_print_mac(struct zebra_m
 				json_object_int_add(json_mac, "vlan", vid);
 		} else if (CHECK_FLAG(mac->flags, ZEBRA_MAC_REMOTE)) {
 			json_object_string_add(json_mac, "type", "remote");
-			json_object_string_addf(json_mac, "remoteVtep", "%pI4",
-						&mac->fwd_info.r_vtep_ip);
+			if (mac->es)
+				json_object_string_add(json_mac, "remoteEs",
+						       mac->es->esi_str);
+			else
+				json_object_string_addf(
+					json_mac, "remoteVtep", "%pI4",
+					&mac->fwd_info.r_vtep_ip);
 		} else if (CHECK_FLAG(mac->flags, ZEBRA_MAC_AUTO))
 			json_object_string_add(json_mac, "type", "auto");
 
@@ -937,8 +942,13 @@ void zebra_evpn_print_mac_hash(struct ha
 				"", mac->loc_seq, mac->rem_seq);
 		} else {
 			json_object_string_add(json_mac, "type", "remote");
-			json_object_string_addf(json_mac, "remoteVtep", "%pI4",
-						&mac->fwd_info.r_vtep_ip);
+			if (mac->es)
+				json_object_string_add(json_mac, "remoteEs",
+						       mac->es->esi_str);
+			else
+				json_object_string_addf(
+					json_mac, "remoteVtep", "%pI4",
+					&mac->fwd_info.r_vtep_ip);
 			json_object_object_add(json_mac_hdr, buf1, json_mac);
 			json_object_int_add(json_mac, "localSequence",
 					    mac->loc_seq);
@@ -1179,6 +1189,25 @@ int zebra_evpn_mac_del(struct zebra_evpn
 	return 0;
 }
 
+/*
+ * Add Auto MAC entry.
+ */
+struct zebra_mac *zebra_evpn_mac_add_auto(struct zebra_evpn *zevpn,
+					  const struct ethaddr *macaddr)
+{
+	struct zebra_mac *mac;
+
+	mac = zebra_evpn_mac_add(zevpn, macaddr);
+	if (!mac)
+		return NULL;
+
+	zebra_evpn_mac_clear_fwd_info(mac);
+	memset(&mac->flags, 0, sizeof(uint32_t));
+	SET_FLAG(mac->flags, ZEBRA_MAC_AUTO);
+
+	return mac;
+}
+
 static bool zebra_evpn_check_mac_del_from_db(struct mac_walk_ctx *wctx,
 					     struct zebra_mac *mac)
 {
@@ -1592,43 +1621,44 @@ void zebra_evpn_sync_mac_del(struct zebr
 
 static inline bool zebra_evpn_mac_is_bgp_seq_ok(struct zebra_evpn *zevpn,
 						struct zebra_mac *mac,
-						uint32_t seq, uint16_t ipa_len,
-						const struct ipaddr *ipaddr,
-						bool sync)
+						uint32_t seq, bool sync)
 {
-	char ipbuf[INET6_ADDRSTRLEN];
+	char mac_buf[MAC_BUF_SIZE];
 	uint32_t tmp_seq;
 	const char *n_type;
+	bool is_local = false;
 
 	if (CHECK_FLAG(mac->flags, ZEBRA_MAC_LOCAL)) {
 		tmp_seq = mac->loc_seq;
 		n_type = "local";
+		is_local = true;
 	} else {
 		tmp_seq = mac->rem_seq;
 		n_type = "remote";
 	}
 
 	if (seq < tmp_seq) {
+
+		if (is_local && !zebra_evpn_mac_is_ready_for_bgp(mac->flags)) {
+			if (IS_ZEBRA_DEBUG_EVPN_MH_MAC || IS_ZEBRA_DEBUG_VXLAN)
+				zlog_debug(
+					"%s-macip not ready vni %u %s-mac %pEA lower seq %u f 0x%x",
+					sync ? "sync" : "rem", zevpn->vni,
+					n_type, &mac->macaddr, tmp_seq,
+					mac->flags);
+			return true;
+		}
+
 		/* if the mac was never advertised to bgp we must accept
 		 * whatever sequence number bgp sends
-		 * XXX - check with Vivek
 		 */
-		if (CHECK_FLAG(mac->flags, ZEBRA_MAC_LOCAL)
-		    && !zebra_evpn_mac_is_ready_for_bgp(mac->flags)) {
-			if (IS_ZEBRA_DEBUG_EVPN_MH_MAC
-			    || IS_ZEBRA_DEBUG_VXLAN) {
-				char mac_buf[MAC_BUF_SIZE];
-
+		if (!is_local && zebra_vxlan_get_accept_bgp_seq()) {
+			if (IS_ZEBRA_DEBUG_EVPN_MH_MAC ||
+			    IS_ZEBRA_DEBUG_VXLAN) {
 				zlog_debug(
-					"%s-macip accept vni %u %s-mac %pEA%s%s lower seq %u f %s",
+					"%s-macip accept vni %u %s-mac %pEA lower seq %u f %s",
 					sync ? "sync" : "rem", zevpn->vni,
-					n_type,
-					&mac->macaddr,
-					ipa_len ? " IP " : "",
-					ipa_len ? ipaddr2str(ipaddr, ipbuf,
-							     sizeof(ipbuf))
-						: "",
-					tmp_seq,
+					n_type, &mac->macaddr, tmp_seq,
 					zebra_evpn_zebra_mac_flag_dump(
 						mac, mac_buf, sizeof(mac_buf)));
 			}
@@ -1637,30 +1667,26 @@ static inline bool zebra_evpn_mac_is_bgp
 		}
 
 		if (IS_ZEBRA_DEBUG_EVPN_MH_MAC || IS_ZEBRA_DEBUG_VXLAN) {
-			char mac_buf[MAC_BUF_SIZE];
-
 			zlog_debug(
-				"%s-macip ignore vni %u %s-mac %pEA%s%s as existing has higher seq %u f %s",
+				"%s-macip ignore vni %u %s-mac %pEA as existing has higher seq %u f %s",
 				sync ? "sync" : "rem", zevpn->vni, n_type,
-				&mac->macaddr,
-				ipa_len ? " IP " : "",
-				ipa_len ? ipaddr2str(ipaddr, ipbuf,
-						     sizeof(ipbuf))
-					: "",
-				tmp_seq,
+				&mac->macaddr, tmp_seq,
 				zebra_evpn_zebra_mac_flag_dump(
 					mac, mac_buf, sizeof(mac_buf)));
 		}
+
 		return false;
 	}
 
 	return true;
 }
 
-struct zebra_mac *zebra_evpn_proc_sync_mac_update(
-	struct zebra_evpn *zevpn, const struct ethaddr *macaddr,
-	uint16_t ipa_len, const struct ipaddr *ipaddr, uint8_t flags,
-	uint32_t seq, const esi_t *esi, struct sync_mac_ip_ctx *ctx)
+struct zebra_mac *zebra_evpn_proc_sync_mac_update(struct zebra_evpn *zevpn,
+						  const struct ethaddr *macaddr,
+						  uint16_t ipa_len,
+						  const struct ipaddr *ipaddr,
+						  uint8_t flags, uint32_t seq,
+						  const esi_t *esi)
 {
 	struct zebra_mac *mac;
 	bool inform_bgp = false;
@@ -1672,6 +1698,7 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 	bool old_local = false;
 	bool old_bgp_ready;
 	bool new_bgp_ready;
+	bool created = false;
 
 	mac = zebra_evpn_mac_lookup(zevpn, macaddr);
 	if (!mac) {
@@ -1680,8 +1707,6 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		 */
 		inform_bgp = true;
 		inform_dataplane = true;
-		ctx->mac_created = true;
-		ctx->mac_inactive = true;
 
 		/* create the MAC and associate it with the dest ES */
 		mac = zebra_evpn_mac_add(zevpn, macaddr);
@@ -1699,6 +1724,7 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		SET_FLAG(mac->flags, ZEBRA_MAC_LOCAL_INACTIVE);
 		old_bgp_ready = false;
 		new_bgp_ready = zebra_evpn_mac_is_ready_for_bgp(mac->flags);
+		created = true;
 	} else {
 		uint32_t old_flags;
 		uint32_t new_flags;
@@ -1723,14 +1749,10 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 						: "",
 					sticky ? " sticky" : "",
 					remote_gw ? " remote_gw" : "");
-			ctx->ignore_macip = true;
 			return NULL;
 		}
-		if (!zebra_evpn_mac_is_bgp_seq_ok(zevpn, mac, seq, ipa_len,
-						  ipaddr, true)) {
-			ctx->ignore_macip = true;
+		if (!zebra_evpn_mac_is_bgp_seq_ok(zevpn, mac, seq, true))
 			return NULL;
-		}
 
 		old_local = !!CHECK_FLAG(old_flags, ZEBRA_MAC_LOCAL);
 		old_static = zebra_evpn_mac_is_static(mac);
@@ -1739,12 +1761,11 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		new_flags = 0;
 		SET_FLAG(new_flags, ZEBRA_MAC_LOCAL);
 		/* retain old local activity flag */
-		if (old_flags & ZEBRA_MAC_LOCAL) {
+		if (old_flags & ZEBRA_MAC_LOCAL)
 			new_flags |= (old_flags & ZEBRA_MAC_LOCAL_INACTIVE);
-		} else {
+		else
 			new_flags |= ZEBRA_MAC_LOCAL_INACTIVE;
-			ctx->mac_inactive = true;
-		}
+
 		if (ipa_len) {
 			/* if mac-ip route do NOT update the peer flags
 			 * i.e. retain only flags as is
@@ -1797,7 +1818,6 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		if (es_change) {
 			inform_bgp = true;
 			inform_dataplane = true;
-			ctx->mac_inactive = true;
 		}
 
 		/* if peer-flag is being set notify dataplane that the
@@ -1828,8 +1848,7 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		char mac_buf[MAC_BUF_SIZE];
 
 		zlog_debug("sync-mac %s vni %u mac %pEA es %s seq %d f %s%s%s",
-			   ctx->mac_created ? "created" : "updated",
-			   zevpn->vni, macaddr,
+			   created ? "created" : "updated", zevpn->vni, macaddr,
 			   mac->es ? mac->es->esi_str : "-", mac->loc_seq,
 			   zebra_evpn_zebra_mac_flag_dump(mac, mac_buf,
 							  sizeof(mac_buf)),
@@ -1848,22 +1867,15 @@ struct zebra_mac *zebra_evpn_proc_sync_m
 		zebra_evpn_process_neigh_on_local_mac_change(
 			zevpn, mac, seq_change, es_change);
 
-	if (inform_dataplane) {
-		if (ipa_len)
-			/* if the mac is being created as a part of MAC-IP
-			 * route wait for the neigh to be updated or
-			 * created before programming the mac
-			 */
-			ctx->mac_dp_update_deferred = true;
-		else
-			/* program the local mac in the kernel. when the ES
-			 * change we need to force the dataplane to reset
-			 * the activity as we are yet to establish activity
-			 * locally
-			 */
-			zebra_evpn_sync_mac_dp_install(
-				mac, ctx->mac_inactive,
-				false /* force_clear_static */, __func__);
+	if (inform_dataplane && !ipa_len) {
+		/* program the local mac in the kernel. when the ES
+		 * change we need to force the dataplane to reset
+		 * the activity as we are yet to establish activity
+		 * locally
+		 */
+		zebra_evpn_sync_mac_dp_install(mac, false /* set_inactive */,
+					       false /* force_clear_static */,
+					       __func__);
 	}
 
 	return mac;
@@ -1987,13 +1999,12 @@ void zebra_evpn_print_dad_mac_hash_detai
 		zebra_evpn_print_mac_hash_detail(bucket, ctxt);
 }
 
-int zebra_evpn_mac_remote_macip_add(
-	struct zebra_evpn *zevpn, struct zebra_vrf *zvrf,
-	const struct ethaddr *macaddr, uint16_t ipa_len,
-	const struct ipaddr *ipaddr, struct zebra_mac **macp,
-	struct in_addr vtep_ip, uint8_t flags, uint32_t seq, const esi_t *esi)
+int zebra_evpn_mac_remote_macip_add(struct zebra_evpn *zevpn,
+				    struct zebra_vrf *zvrf,
+				    const struct ethaddr *macaddr,
+				    struct in_addr vtep_ip, uint8_t flags,
+				    uint32_t seq, const esi_t *esi)
 {
-	char buf1[INET6_ADDRSTRLEN];
 	bool sticky;
 	bool remote_gw;
 	int update_mac = 0;
@@ -2015,11 +2026,8 @@ int zebra_evpn_mac_remote_macip_add(
 	    && CHECK_FLAG(flags, ZEBRA_MACIP_TYPE_GW)) {
 		if (IS_ZEBRA_DEBUG_VXLAN)
 			zlog_debug(
-				"Ignore remote MACIP ADD VNI %u MAC %pEA%s%s as MAC is already configured as gateway MAC",
-				zevpn->vni, macaddr,
-				ipa_len ? " IP " : "",
-				ipa_len ? ipaddr2str(ipaddr, buf1, sizeof(buf1))
-					: "");
+				"Ignore remote MACIP ADD VNI %u MAC %pEA as MAC is already configured as gateway MAC",
+				zevpn->vni, macaddr);
 		return -1;
 	}
 
@@ -2040,10 +2048,6 @@ int zebra_evpn_mac_remote_macip_add(
 		if (!mac) {
 			mac = zebra_evpn_mac_add(zevpn, macaddr);
 			zebra_evpn_es_mac_ref(mac, esi);
-
-			/* Is this MAC created for a MACIP? */
-			if (ipa_len)
-				SET_FLAG(mac->flags, ZEBRA_MAC_AUTO);
 		} else {
 			/* When host moves but changes its (MAC,IP)
 			 * binding, BGP may install a MACIP entry that
@@ -2053,8 +2057,8 @@ int zebra_evpn_mac_remote_macip_add(
 			 * the sequence number and ignore this update
 			 * if appropriate.
 			 */
-			if (!zebra_evpn_mac_is_bgp_seq_ok(
-				    zevpn, mac, seq, ipa_len, ipaddr, false))
+			if (!zebra_evpn_mac_is_bgp_seq_ok(zevpn, mac, seq,
+							  false))
 				return -1;
 
 			old_es_present = !!mac->es;
@@ -2138,12 +2142,7 @@ int zebra_evpn_mac_remote_macip_add(
 	/* Update seq number. */
 	mac->rem_seq = seq;
 
-	/* If there is no IP, return after clearing AUTO flag of MAC. */
-	if (!ipa_len) {
-		UNSET_FLAG(mac->flags, ZEBRA_MAC_AUTO);
-		return -1;
-	}
-	*macp = mac;
+	UNSET_FLAG(mac->flags, ZEBRA_MAC_AUTO);
 	return 0;
 }
 
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn_mac.h frr-frr-8.5/zebra/zebra_evpn_mac.h
--- frr-frr-8.4.2/zebra/zebra_evpn_mac.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn_mac.h	2023-03-13 20:01:47.000000000 +0600
@@ -176,17 +176,6 @@ struct rmac_walk_ctx {
 	struct json_object *json;
 };
 
-/* temporary datastruct to pass info between the mac-update and
- * neigh-update while handling mac-ip routes
- */
-struct sync_mac_ip_ctx {
-	bool ignore_macip;
-	bool mac_created;
-	bool mac_inactive;
-	bool mac_dp_update_deferred;
-	struct zebra_mac *mac;
-};
-
 /**************************** SYNC MAC handling *****************************/
 /* if the mac has been added of a mac-route from the peer
  * or if it is being referenced by a neigh added by the
@@ -232,6 +221,8 @@ struct zebra_mac *zebra_evpn_mac_lookup(
 					const struct ethaddr *mac);
 struct zebra_mac *zebra_evpn_mac_add(struct zebra_evpn *zevi,
 				     const struct ethaddr *macaddr);
+struct zebra_mac *zebra_evpn_mac_add_auto(struct zebra_evpn *zevi,
+					  const struct ethaddr *macaddr);
 int zebra_evpn_mac_del(struct zebra_evpn *zevi, struct zebra_mac *mac);
 int zebra_evpn_macip_send_msg_to_client(uint32_t id,
 					const struct ethaddr *macaddr,
@@ -255,20 +246,22 @@ int zebra_evpn_mac_send_add_to_client(vn
 int zebra_evpn_mac_send_del_to_client(vni_t vni, const struct ethaddr *macaddr,
 				      uint32_t flags, bool force);
 void zebra_evpn_send_mac_list_to_client(struct zebra_evpn *zevi);
-struct zebra_mac *zebra_evpn_proc_sync_mac_update(
-	struct zebra_evpn *zevi, const struct ethaddr *macaddr,
-	uint16_t ipa_len, const struct ipaddr *ipaddr, uint8_t flags,
-	uint32_t seq, const esi_t *esi, struct sync_mac_ip_ctx *ctx);
+struct zebra_mac *zebra_evpn_proc_sync_mac_update(struct zebra_evpn *zevi,
+						  const struct ethaddr *macaddr,
+						  uint16_t ipa_len,
+						  const struct ipaddr *ipaddr,
+						  uint8_t flags, uint32_t seq,
+						  const esi_t *esi);
 void zebra_evpn_sync_mac_del(struct zebra_mac *mac);
 void zebra_evpn_rem_mac_del(struct zebra_evpn *zevi, struct zebra_mac *mac);
 void zebra_evpn_print_dad_mac_hash(struct hash_bucket *bucket, void *ctxt);
 void zebra_evpn_print_dad_mac_hash_detail(struct hash_bucket *bucket,
 					  void *ctxt);
-int zebra_evpn_mac_remote_macip_add(
-	struct zebra_evpn *zevpn, struct zebra_vrf *zvrf,
-	const struct ethaddr *macaddr, uint16_t ipa_len,
-	const struct ipaddr *ipaddr, struct zebra_mac **macp,
-	struct in_addr vtep_ip, uint8_t flags, uint32_t seq, const esi_t *esi);
+int zebra_evpn_mac_remote_macip_add(struct zebra_evpn *zevpn,
+				    struct zebra_vrf *zvrf,
+				    const struct ethaddr *macaddr,
+				    struct in_addr vtep_ip, uint8_t flags,
+				    uint32_t seq, const esi_t *esi);
 
 int zebra_evpn_add_update_local_mac(struct zebra_vrf *zvrf,
 				    struct zebra_evpn *zevpn,
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn_mh.c frr-frr-8.5/zebra/zebra_evpn_mh.c
--- frr-frr-8.4.2/zebra/zebra_evpn_mh.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn_mh.c	2023-03-13 20:01:47.000000000 +0600
@@ -3258,9 +3258,7 @@ int zebra_evpn_mh_if_write(struct vty *v
 	return 0;
 }
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_evpn_mh_clippy.c"
-#endif
 /* CLI for setting an ES in bypass mode */
 DEFPY_HIDDEN(zebra_evpn_es_bypass, zebra_evpn_es_bypass_cmd,
 	     "[no] evpn mh bypass",
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn_neigh.c frr-frr-8.5/zebra/zebra_evpn_neigh.c
--- frr-frr-8.4.2/zebra/zebra_evpn_neigh.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn_neigh.c	2023-03-13 20:01:47.000000000 +0600
@@ -501,22 +501,33 @@ bool zebra_evpn_neigh_is_bgp_seq_ok(stru
 {
 	uint32_t tmp_seq;
 	const char *n_type;
+	bool is_local = false;
 
 	if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_LOCAL)) {
 		tmp_seq = n->loc_seq;
 		n_type = "local";
+		is_local = true;
 	} else {
 		tmp_seq = n->rem_seq;
 		n_type = "remote";
 	}
 
 	if (seq < tmp_seq) {
+		if (is_local && !zebra_evpn_neigh_is_ready_for_bgp(n)) {
+			if (IS_ZEBRA_DEBUG_EVPN_MH_NEIGH ||
+			    IS_ZEBRA_DEBUG_VXLAN)
+				zlog_debug(
+					"%s-macip not ready vni %u %s mac %pEA IP %pIA lower seq %u f 0x%x",
+					sync ? "sync" : "remote", zevpn->vni,
+					n_type, macaddr, &n->ip, tmp_seq,
+					n->flags);
+			return true;
+		}
+
 		/* if the neigh was never advertised to bgp we must accept
 		 * whatever sequence number bgp sends
-		 * XXX - check with Vivek
 		 */
-		if (CHECK_FLAG(n->flags, ZEBRA_NEIGH_LOCAL)
-		    && !zebra_evpn_neigh_is_ready_for_bgp(n)) {
+		if (!is_local && zebra_vxlan_get_accept_bgp_seq()) {
 			if (IS_ZEBRA_DEBUG_EVPN_MH_NEIGH
 			    || IS_ZEBRA_DEBUG_VXLAN)
 				zlog_debug(
@@ -615,11 +626,10 @@ void zebra_evpn_sync_neigh_del(struct ze
 struct zebra_neigh *zebra_evpn_proc_sync_neigh_update(
 	struct zebra_evpn *zevpn, struct zebra_neigh *n, uint16_t ipa_len,
 	const struct ipaddr *ipaddr, uint8_t flags, uint32_t seq,
-	const esi_t *esi, struct sync_mac_ip_ctx *ctx)
+	const esi_t *esi, struct zebra_mac *mac)
 {
 	struct interface *ifp = NULL;
 	bool is_router;
-	struct zebra_mac *mac = ctx->mac;
 	uint32_t tmp_seq;
 	bool old_router = false;
 	bool old_bgp_ready = false;
@@ -780,8 +790,8 @@ struct zebra_neigh *zebra_evpn_proc_sync
 		inform_bgp = true;
 
 	new_mac_static = zebra_evpn_mac_is_static(mac);
-	if ((old_mac_static != new_mac_static) || ctx->mac_dp_update_deferred)
-		zebra_evpn_sync_mac_dp_install(mac, ctx->mac_inactive,
+	if (old_mac_static != new_mac_static)
+		zebra_evpn_sync_mac_dp_install(mac, false /* set_inactive */,
 					       false /* force_clear_static */,
 					       __func__);
 
@@ -1275,10 +1285,12 @@ int zebra_evpn_local_neigh_update(struct
 			zlog_debug("AUTO MAC %pEA created for neigh %pIA on VNI %u",
 				   macaddr, ip, zevpn->vni);
 
-		zmac = zebra_evpn_mac_add(zevpn, macaddr);
-		zebra_evpn_mac_clear_fwd_info(zmac);
-		memset(&zmac->flags, 0, sizeof(uint32_t));
-		SET_FLAG(zmac->flags, ZEBRA_MAC_AUTO);
+		zmac = zebra_evpn_mac_add_auto(zevpn, macaddr);
+		if (!zmac) {
+			zlog_debug("Failed to add MAC %pEA VNI %u", macaddr,
+				   zevpn->vni);
+			return -1;
+		}
 	} else {
 		if (CHECK_FLAG(zmac->flags, ZEBRA_MAC_REMOTE)) {
 			/*
@@ -2233,6 +2245,12 @@ void zebra_evpn_neigh_remote_uninstall(s
 			zebra_evpn_neigh_del(zevpn, n);
 			zebra_evpn_deref_ip2mac(zevpn, mac);
 		}
+	} else {
+		if (IS_ZEBRA_DEBUG_VXLAN)
+			zlog_debug(
+				"%s: IP %pIA MAC %pEA (flags 0x%x) found doesn't match MAC %pEA, ignoring Neigh DEL",
+				__func__, ipaddr, &n->emac, n->flags,
+				&mac->macaddr);
 	}
 }
 
diff -urpN frr-frr-8.4.2/zebra/zebra_evpn_neigh.h frr-frr-8.5/zebra/zebra_evpn_neigh.h
--- frr-frr-8.4.2/zebra/zebra_evpn_neigh.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_evpn_neigh.h	2023-03-13 20:01:47.000000000 +0600
@@ -231,7 +231,7 @@ void zebra_evpn_sync_neigh_del(struct ze
 struct zebra_neigh *zebra_evpn_proc_sync_neigh_update(
 	struct zebra_evpn *zevpn, struct zebra_neigh *n, uint16_t ipa_len,
 	const struct ipaddr *ipaddr, uint8_t flags, uint32_t seq,
-	const esi_t *esi, struct sync_mac_ip_ctx *ctx);
+	const esi_t *esi, struct zebra_mac *mac);
 void zebra_evpn_neigh_del_all(struct zebra_evpn *zevpn, int uninstall,
 			      int upd_client, uint32_t flags);
 struct zebra_neigh *zebra_evpn_neigh_lookup(struct zebra_evpn *zevpn,
diff -urpN frr-frr-8.4.2/zebra/zebra_fpm.c frr-frr-8.5/zebra/zebra_fpm.c
--- frr-frr-8.4.2/zebra/zebra_fpm.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_fpm.c	2023-03-13 20:01:47.000000000 +0600
@@ -899,7 +899,6 @@ static inline int zfpm_encode_route(rib_
 		len = zfpm_netlink_encode_route(cmd, dest, re, in_buf,
 						in_buf_len);
 		assert(fpm_msg_align(len) == len);
-		*msg_type = FPM_MSG_TYPE_NETLINK;
 #endif /* HAVE_NETLINK */
 		break;
 
@@ -1841,12 +1840,15 @@ DEFUN (clear_zebra_fpm_stats,
 /*
  * update fpm connection information
  */
-DEFUN ( fpm_remote_ip,
+DEFUN (fpm_remote_ip,
        fpm_remote_ip_cmd,
-        "fpm connection ip A.B.C.D port (1-65535)",
-        "fpm connection remote ip and port\n"
-        "Remote fpm server ip A.B.C.D\n"
-        "Enter ip ")
+       "fpm connection ip A.B.C.D port (1-65535)",
+       "Forwarding Path Manager\n"
+       "Configure FPM connection\n"
+       "Connect to IPv4 address\n"
+       "Connect to IPv4 address\n"
+       "TCP port number\n"
+       "TCP port number\n")
 {
 
 	in_addr_t fpm_server;
@@ -1867,13 +1869,16 @@ DEFUN ( fpm_remote_ip,
 	return CMD_SUCCESS;
 }
 
-DEFUN ( no_fpm_remote_ip,
+DEFUN (no_fpm_remote_ip,
        no_fpm_remote_ip_cmd,
-        "no fpm connection ip A.B.C.D port (1-65535)",
-        "fpm connection remote ip and port\n"
-        "Connection\n"
-        "Remote fpm server ip A.B.C.D\n"
-        "Enter ip ")
+       "no fpm connection ip A.B.C.D port (1-65535)",
+       NO_STR
+       "Forwarding Path Manager\n"
+       "Remove configured FPM connection\n"
+       "Connect to IPv4 address\n"
+       "Connect to IPv4 address\n"
+       "TCP port number\n"
+       "TCP port number\n")
 {
 	if (zfpm_g->fpm_server != inet_addr(argv[4]->arg)
 	    || zfpm_g->fpm_port != atoi(argv[6]->arg))
diff -urpN frr-frr-8.4.2/zebra/zebra_fpm_netlink.c frr-frr-8.5/zebra/zebra_fpm_netlink.c
--- frr-frr-8.4.2/zebra/zebra_fpm_netlink.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_fpm_netlink.c	2023-03-13 20:01:47.000000000 +0600
@@ -253,14 +253,7 @@ static int netlink_route_info_add_nh(str
  */
 static uint8_t netlink_proto_from_route_type(int type)
 {
-	switch (type) {
-	case ZEBRA_ROUTE_KERNEL:
-	case ZEBRA_ROUTE_CONNECT:
-		return RTPROT_KERNEL;
-
-	default:
-		return RTPROT_ZEBRA;
-	}
+	return zebra2proto(type);
 }
 
 /*
@@ -511,7 +504,7 @@ static int netlink_route_info_encode(str
 done:
 
 	if (ri->pref_src) {
-		nl_attr_put(&req->n, in_buf_len, RTA_PREFSRC, &ri->pref_src,
+		nl_attr_put(&req->n, in_buf_len, RTA_PREFSRC, ri->pref_src,
 			    bytelen);
 	}
 
@@ -539,10 +532,15 @@ static void zfpm_log_route_info(struct n
 	for (i = 0; i < ri->num_nhs; i++) {
 		nhi = &ri->nhs[i];
 
-		if (ri->af == AF_INET)
-			inet_ntop(AF_INET, &nhi->gateway, buf, sizeof(buf));
-		else
-			inet_ntop(AF_INET6, &nhi->gateway, buf, sizeof(buf));
+		if (nhi->gateway) {
+			if (ri->af == AF_INET)
+				inet_ntop(AF_INET, nhi->gateway, buf,
+					  sizeof(buf));
+			else
+				inet_ntop(AF_INET6, nhi->gateway, buf,
+					  sizeof(buf));
+		} else
+			strlcpy(buf, "none", sizeof(buf));
 
 		zfpm_debug("  Intf: %u, Gateway: %s, Recursive: %s, Type: %s, Encap type: %s",
 			   nhi->if_index, buf, nhi->recursive ? "yes" : "no",
diff -urpN frr-frr-8.4.2/zebra/zebra_gr.c frr-frr-8.5/zebra/zebra_gr.c
--- frr-frr-8.4.2/zebra/zebra_gr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_gr.c	2023-03-13 20:01:47.000000000 +0600
@@ -46,6 +46,7 @@
 #include "zebra/debug.h"
 #include "zebra/zapi_msg.h"
 
+DEFINE_MTYPE_STATIC(ZEBRA, ZEBRA_GR, "GR");
 
 /*
  * Forward declaration.
@@ -111,7 +112,7 @@ static struct client_gr_info *zebra_gr_c
 {
 	struct client_gr_info *info;
 
-	info = XCALLOC(MTYPE_TMP, sizeof(struct client_gr_info));
+	info = XCALLOC(MTYPE_ZEBRA_GR, sizeof(struct client_gr_info));
 
 	TAILQ_INSERT_TAIL(&(client->gr_info_queue), info, gr_info);
 	return info;
@@ -127,7 +128,7 @@ static void zebra_gr_client_info_delte(s
 
 	THREAD_OFF(info->t_stale_removal);
 
-	XFREE(MTYPE_TMP, info->current_prefix);
+	XFREE(MTYPE_ZEBRA_GR, info->current_prefix);
 
 	LOG_GR("%s: Instance info is being deleted for client %s", __func__,
 	       zebra_route_string(client->proto));
@@ -136,7 +137,7 @@ static void zebra_gr_client_info_delte(s
 	info->do_delete = true;
 	zebra_gr_delete_stale_routes(info);
 
-	XFREE(MTYPE_TMP, info);
+	XFREE(MTYPE_ZEBRA_GR, info);
 }
 
 /*
@@ -222,8 +223,8 @@ static void zebra_gr_delete_stale_client
 	TAILQ_INIT(&(s_client->gr_info_queue));
 	listnode_delete(zrouter.stale_client_list, s_client);
 	if (info->stale_client)
-		XFREE(MTYPE_TMP, s_client);
-	XFREE(MTYPE_TMP, info);
+		zserv_client_delete(s_client);
+	XFREE(MTYPE_ZEBRA_GR, info);
 }
 
 /*
@@ -288,7 +289,7 @@ void zebra_gr_client_reconnect(struct zs
 	/* Delete the stale client */
 	listnode_delete(zrouter.stale_client_list, old_client);
 	/* Delete old client */
-	XFREE(MTYPE_TMP, old_client);
+	zserv_client_delete(old_client);
 }
 
 /*
@@ -474,7 +475,7 @@ static void zebra_gr_route_stale_delete_
 		LOG_GR("%s: Client %s all stale routes processed", __func__,
 		       zebra_route_string(client->proto));
 
-		XFREE(MTYPE_TMP, info->current_prefix);
+		XFREE(MTYPE_ZEBRA_GR, info->current_prefix);
 		info->current_afi = 0;
 		zebra_gr_delete_stale_client(info);
 	}
@@ -579,7 +580,7 @@ static int32_t zebra_gr_delete_stale_rou
 					    && (info->do_delete == false)) {
 						info->current_afi = afi;
 						info->current_prefix = XCALLOC(
-							MTYPE_TMP,
+							MTYPE_ZEBRA_GR,
 							sizeof(struct prefix));
 						prefix_copy(
 							info->current_prefix,
@@ -593,7 +594,7 @@ static int32_t zebra_gr_delete_stale_rou
 		 * Reset the current prefix to indicate processing completion
 		 * of the current AFI
 		 */
-		XFREE(MTYPE_TMP, info->current_prefix);
+		XFREE(MTYPE_ZEBRA_GR, info->current_prefix);
 	}
 	return 0;
 }
diff -urpN frr-frr-8.4.2/zebra/zebra_mlag_vty.c frr-frr-8.5/zebra/zebra_mlag_vty.c
--- frr-frr-8.4.2/zebra/zebra_mlag_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_mlag_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -29,9 +29,7 @@
 #include "debug.h"
 #include "zapi_msg.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_mlag_vty_clippy.c"
-#endif
 
 DEFUN_HIDDEN (show_mlag,
 	      show_mlag_cmd,
diff -urpN frr-frr-8.4.2/zebra/zebra_mpls.c frr-frr-8.5/zebra/zebra_mpls.c
--- frr-frr-8.4.2/zebra/zebra_mpls.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_mpls.c	2023-03-13 20:01:47.000000000 +0600
@@ -1754,7 +1754,6 @@ static void mpls_processq_init(void)
 
 	zrouter.lsp_process_q->spec.workfunc = &lsp_process;
 	zrouter.lsp_process_q->spec.del_item_data = &lsp_processq_del;
-	zrouter.lsp_process_q->spec.errorfunc = NULL;
 	zrouter.lsp_process_q->spec.completion_func = &lsp_processq_complete;
 	zrouter.lsp_process_q->spec.max_retries = 0;
 	zrouter.lsp_process_q->spec.hold = 10;
diff -urpN frr-frr-8.4.2/zebra/zebra_netns_id.c frr-frr-8.5/zebra/zebra_netns_id.c
--- frr-frr-8.4.2/zebra/zebra_netns_id.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_netns_id.c	2023-03-13 20:01:47.000000000 +0600
@@ -23,6 +23,7 @@
 #include "vrf.h"
 #include "log.h"
 #include "lib_errors.h"
+#include "network.h"
 
 #include "zebra/rib.h"
 #include "zebra/zebra_dplane.h"
@@ -73,7 +74,7 @@ static struct nlmsghdr *initiate_nlh(cha
 	nlh->nlmsg_flags = NLM_F_REQUEST;
 	if (type == RTM_NEWNSID)
 		nlh->nlmsg_flags |= NLM_F_ACK;
-	nlh->nlmsg_seq = *seq = time(NULL);
+	nlh->nlmsg_seq = *seq = frr_sequence32_next();
 	return nlh;
 }
 
diff -urpN frr-frr-8.4.2/zebra/zebra_netns_notify.c frr-frr-8.5/zebra/zebra_netns_notify.c
--- frr-frr-8.4.2/zebra/zebra_netns_notify.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_netns_notify.c	2023-03-13 20:01:47.000000000 +0600
@@ -288,6 +288,7 @@ static void zebra_ns_notify_read(struct
 	struct inotify_event *event;
 	char buf[BUFSIZ];
 	ssize_t len;
+	char event_name[NAME_MAX + 1];
 
 	thread_add_read(zrouter.master, zebra_ns_notify_read, NULL, fd_monitor,
 			&zebra_netns_notify_current);
@@ -320,11 +321,41 @@ static void zebra_ns_notify_read(struct
 			break;
 		}
 
+		/*
+		 * Coverity Scan extra steps to satisfy `STRING_NULL` warning:
+		 * - Make sure event name is present by checking `len != 0`
+		 * - Event name length must be at most `NAME_MAX + 1`
+		 *   (null byte inclusive)
+		 * - Copy event name to a stack buffer to make sure it
+		 *   includes the null byte. `event->name` includes at least
+		 *   one null byte and `event->len` accounts the null bytes,
+		 *   so the operation after `memcpy` will look like a
+		 *   truncation to satisfy Coverity Scan null byte ending.
+		 *
+		 *   Example:
+		 *   if `event->name` is `abc\0` and `event->len` is 4,
+		 *   `memcpy` will copy the 4 bytes and then we set the
+		 *   null byte again at the position 4.
+		 *
+		 * For more information please read inotify(7) man page.
+		 */
+		if (event->len == 0)
+			continue;
+
+		if (event->len > sizeof(event_name)) {
+			flog_err(EC_ZEBRA_NS_NOTIFY_READ,
+				 "NS notify error: unexpected big event name");
+			break;
+		}
+
+		memcpy(event_name, event->name, event->len);
+		event_name[event->len - 1] = 0;
+
 		if (event->mask & IN_DELETE) {
-			zebra_ns_delete(event->name);
+			zebra_ns_delete(event_name);
 			continue;
 		}
-		netnspath = ns_netns_pathname(NULL, event->name);
+		netnspath = ns_netns_pathname(NULL, event_name);
 		if (!netnspath)
 			continue;
 		netnspath = XSTRDUP(MTYPE_NETNS_MISC, netnspath);
diff -urpN frr-frr-8.4.2/zebra/zebra_nhg.c frr-frr-8.5/zebra/zebra_nhg.c
--- frr-frr-8.4.2/zebra/zebra_nhg.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_nhg.c	2023-03-13 20:01:47.000000000 +0600
@@ -563,6 +563,15 @@ bool zebra_nhg_hash_equal(const void *ar
 	if (nhe1->afi != nhe2->afi)
 		return false;
 
+	if (nhe1->nhg.nhgr.buckets != nhe2->nhg.nhgr.buckets)
+		return false;
+
+	if (nhe1->nhg.nhgr.idle_timer != nhe2->nhg.nhgr.idle_timer)
+		return false;
+
+	if (nhe1->nhg.nhgr.unbalanced_timer != nhe2->nhg.nhgr.unbalanced_timer)
+		return false;
+
 	/* Nexthops should be in-order, so we simply compare them in-place */
 	for (nexthop1 = nhe1->nhg.nexthop, nexthop2 = nhe2->nhg.nexthop;
 	     nexthop1 && nexthop2;
@@ -621,7 +630,8 @@ bool zebra_nhg_hash_id_equal(const void
 
 static int zebra_nhg_process_grp(struct nexthop_group *nhg,
 				 struct nhg_connected_tree_head *depends,
-				 struct nh_grp *grp, uint8_t count)
+				 struct nh_grp *grp, uint8_t count,
+				 struct nhg_resilience *resilience)
 {
 	nhg_connected_tree_init(depends);
 
@@ -652,6 +662,9 @@ static int zebra_nhg_process_grp(struct
 		copy_nexthops(&nhg->nexthop, depend->nhg.nexthop, NULL);
 	}
 
+	if (resilience)
+		nhg->nhgr = *resilience;
+
 	return 0;
 }
 
@@ -985,6 +998,11 @@ static struct nh_grp *nhg_ctx_get_grp(st
 	return ctx->u.grp;
 }
 
+static struct nhg_resilience *nhg_ctx_get_resilience(struct nhg_ctx *ctx)
+{
+	return &ctx->resilience;
+}
+
 static struct nhg_ctx *nhg_ctx_new(void)
 {
 	struct nhg_ctx *new;
@@ -1018,7 +1036,8 @@ done:
 
 static struct nhg_ctx *nhg_ctx_init(uint32_t id, struct nexthop *nh,
 				    struct nh_grp *grp, vrf_id_t vrf_id,
-				    afi_t afi, int type, uint8_t count)
+				    afi_t afi, int type, uint8_t count,
+				    struct nhg_resilience *resilience)
 {
 	struct nhg_ctx *ctx = NULL;
 
@@ -1030,6 +1049,9 @@ static struct nhg_ctx *nhg_ctx_init(uint
 	ctx->type = type;
 	ctx->count = count;
 
+	if (resilience)
+		ctx->resilience = *resilience;
+
 	if (count)
 		/* Copy over the array */
 		memcpy(&ctx->u.grp, grp, count * sizeof(struct nh_grp));
@@ -1176,7 +1198,8 @@ static int nhg_ctx_process_new(struct nh
 	if (nhg_ctx_get_count(ctx)) {
 		nhg = nexthop_group_new();
 		if (zebra_nhg_process_grp(nhg, &nhg_depends,
-					  nhg_ctx_get_grp(ctx), count)) {
+					  nhg_ctx_get_grp(ctx), count,
+					  nhg_ctx_get_resilience(ctx))) {
 			depends_decrement_free(&nhg_depends);
 			nexthop_group_delete(&nhg);
 			return -ENOENT;
@@ -1306,7 +1329,7 @@ int nhg_ctx_process(struct nhg_ctx *ctx)
 /* Kernel-side, you either get a single new nexthop or a array of ID's */
 int zebra_nhg_kernel_find(uint32_t id, struct nexthop *nh, struct nh_grp *grp,
 			  uint8_t count, vrf_id_t vrf_id, afi_t afi, int type,
-			  int startup)
+			  int startup, struct nhg_resilience *nhgr)
 {
 	struct nhg_ctx *ctx = NULL;
 
@@ -1320,7 +1343,7 @@ int zebra_nhg_kernel_find(uint32_t id, s
 		 */
 		id_counter = id;
 
-	ctx = nhg_ctx_init(id, nh, grp, vrf_id, afi, type, count);
+	ctx = nhg_ctx_init(id, nh, grp, vrf_id, afi, type, count, nhgr);
 	nhg_ctx_set_op(ctx, NHG_CTX_OP_NEW);
 
 	/* Under statup conditions, we need to handle them immediately
@@ -1343,7 +1366,7 @@ int zebra_nhg_kernel_del(uint32_t id, vr
 {
 	struct nhg_ctx *ctx = NULL;
 
-	ctx = nhg_ctx_init(id, NULL, NULL, vrf_id, 0, 0, 0);
+	ctx = nhg_ctx_init(id, NULL, NULL, vrf_id, 0, 0, 0, NULL);
 
 	nhg_ctx_set_op(ctx, NHG_CTX_OP_DEL);
 
@@ -1797,7 +1820,7 @@ static struct nexthop *nexthop_set_resol
 
 	/* Copy labels of the resolved route and the parent resolving to it */
 	if (policy) {
-		int i = 0;
+		int label_num = 0;
 
 		/*
 		 * Don't push the first SID if the corresponding action in the
@@ -1805,10 +1828,11 @@ static struct nexthop *nexthop_set_resol
 		 */
 		if (!newhop->nh_label || !newhop->nh_label->num_labels
 		    || newhop->nh_label->label[0] == MPLS_LABEL_IMPLICIT_NULL)
-			i = 1;
+			label_num = 1;
 
-		for (; i < policy->segment_list.label_num; i++)
-			labels[num_labels++] = policy->segment_list.labels[i];
+		for (; label_num < policy->segment_list.label_num; label_num++)
+			labels[num_labels++] =
+				policy->segment_list.labels[label_num];
 		label_type = policy->segment_list.type;
 	} else if (newhop->nh_label) {
 		for (i = 0; i < newhop->nh_label->num_labels; i++) {
@@ -2369,11 +2393,33 @@ static int nexthop_active(struct nexthop
 
 			resolved = 0;
 
-			/* Only useful if installed */
-			if (!CHECK_FLAG(match->status, ROUTE_ENTRY_INSTALLED)) {
+			/*
+			 * Only useful if installed or being Route Replacing
+			 * Why Being Route Replaced as well?
+			 * Imagine a route A and route B( that depends on A )
+			 * for recursive resolution and A already exists in the
+			 * zebra rib.  If zebra receives the routes
+			 * for resolution at aproximately the same time in the [
+			 * B, A ] order on the workQ.  If this happens then
+			 * normal route resolution will happen and B will be
+			 * resolved successfully and then A will be resolved
+			 * successfully. Now imagine the reversed order [A, B].
+			 * A will be resolved and then scheduled for installed
+			 * (Thus not having the ROUTE_ENTRY_INSTALLED flag ).  B
+			 * will then get resolved and fail to be installed
+			 * because the original below test.  Let's `loosen` this
+			 * up a tiny bit and allow the
+			 * ROUTE_ENTRY_ROUTE_REPLACING flag ( that is set when a
+			 * Route Replace operation is being initiated on A now )
+			 * to now satisfy this situation.  This will allow
+			 * either order in the workQ to work properly.
+			 */
+			if (!CHECK_FLAG(match->status, ROUTE_ENTRY_INSTALLED) &&
+			    !CHECK_FLAG(match->status,
+					ROUTE_ENTRY_ROUTE_REPLACING)) {
 				if (IS_ZEBRA_DEBUG_RIB_DETAILED)
 					zlog_debug(
-						"%s: match %p (%pNG) not installed",
+						"%s: match %p (%pNG) not installed or being Route Replaced",
 						__func__, match, match->nhe);
 
 				goto done_with_match;
@@ -3123,9 +3169,14 @@ void zebra_nhg_dplane_result(struct zebr
 	case DPLANE_OP_INTF_INSTALL:
 	case DPLANE_OP_INTF_UPDATE:
 	case DPLANE_OP_INTF_DELETE:
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		break;
 	}
 }
@@ -3322,6 +3373,7 @@ struct nhg_hash_entry *zebra_nhg_proto_a
 
 	zebra_nhe_init(&lookup, afi, nhg->nexthop);
 	lookup.nhg.nexthop = nhg->nexthop;
+	lookup.nhg.nhgr = nhg->nhgr;
 	lookup.id = id;
 	lookup.type = type;
 
diff -urpN frr-frr-8.4.2/zebra/zebra_nhg.h frr-frr-8.5/zebra/zebra_nhg.h
--- frr-frr-8.4.2/zebra/zebra_nhg.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_nhg.h	2023-03-13 20:01:47.000000000 +0600
@@ -228,6 +228,7 @@ struct nhg_ctx {
 		struct nh_grp grp[MULTIPATH_NUM];
 	} u;
 
+	struct nhg_resilience resilience;
 	enum nhg_ctx_op_e op;
 	enum nhg_ctx_status status;
 };
@@ -308,7 +309,8 @@ void nhg_ctx_free(struct nhg_ctx **ctx);
 extern int zebra_nhg_kernel_find(uint32_t id, struct nexthop *nh,
 				 struct nh_grp *grp, uint8_t count,
 				 vrf_id_t vrf_id, afi_t afi, int type,
-				 int startup);
+				 int startup,
+				 struct nhg_resilience *resilience);
 /* Del via kernel */
 extern int zebra_nhg_kernel_del(uint32_t id, vrf_id_t vrf_id);
 
diff -urpN frr-frr-8.4.2/zebra/zebra_ns.c frr-frr-8.5/zebra/zebra_ns.c
--- frr-frr-8.4.2/zebra/zebra_ns.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_ns.c	2023-03-13 20:01:47.000000000 +0600
@@ -34,6 +34,7 @@
 #include "zebra_netns_notify.h"
 #include "zebra_netns_id.h"
 #include "zebra_pbr.h"
+#include "zebra_tc.h"
 #include "rib.h"
 #include "table_manager.h"
 #include "zebra_errors.h"
@@ -127,6 +128,7 @@ int zebra_ns_enable(ns_id_t ns_id, void
 	interface_list(zns);
 	route_read(zns);
 	kernel_read_pbr_rules(zns);
+	kernel_read_tc_qdisc(zns);
 
 	return 0;
 }
@@ -136,7 +138,9 @@ int zebra_ns_enable(ns_id_t ns_id, void
  */
 static int zebra_ns_disable_internal(struct zebra_ns *zns, bool complete)
 {
-	route_table_finish(zns->if_table);
+	if (zns->if_table)
+		route_table_finish(zns->if_table);
+	zns->if_table = NULL;
 
 	zebra_dplane_ns_enable(zns, false /*Disable*/);
 
diff -urpN frr-frr-8.4.2/zebra/zebra_pbr.c frr-frr-8.5/zebra/zebra_pbr.c
--- frr-frr-8.4.2/zebra/zebra_pbr.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_pbr.c	2023-03-13 20:01:47.000000000 +0600
@@ -36,6 +36,7 @@
 
 /* definitions */
 DEFINE_MTYPE_STATIC(ZEBRA, PBR_IPTABLE_IFNAME, "PBR interface list");
+DEFINE_MTYPE(ZEBRA, PBR_OBJ, "PBR");
 
 /* definitions */
 static const struct message ipset_type_msg[] = {
@@ -163,7 +164,7 @@ void zebra_pbr_rules_free(void *arg)
 	rule = (struct zebra_pbr_rule *)arg;
 
 	(void)dplane_pbr_rule_delete(rule);
-	XFREE(MTYPE_TMP, rule);
+	XFREE(MTYPE_PBR_OBJ, rule);
 }
 
 uint32_t zebra_pbr_rules_hash_key(const void *arg)
@@ -275,7 +276,7 @@ void zebra_pbr_ipset_free(void *arg)
 
 	ipset = (struct zebra_pbr_ipset *)arg;
 	hook_call(zebra_pbr_ipset_update, 0, ipset);
-	XFREE(MTYPE_TMP, ipset);
+	XFREE(MTYPE_PBR_OBJ, ipset);
 }
 
 uint32_t zebra_pbr_ipset_hash_key(const void *arg)
@@ -319,7 +320,7 @@ void zebra_pbr_ipset_entry_free(void *ar
 
 	hook_call(zebra_pbr_ipset_entry_update, 0, ipset);
 
-	XFREE(MTYPE_TMP, ipset);
+	XFREE(MTYPE_PBR_OBJ, ipset);
 }
 
 uint32_t zebra_pbr_ipset_entry_hash_key(const void *arg)
@@ -396,7 +397,7 @@ static void _zebra_pbr_iptable_free_all(
 		}
 		list_delete(&iptable->interface_name_list);
 	}
-	XFREE(MTYPE_TMP, iptable);
+	XFREE(MTYPE_PBR_OBJ, iptable);
 }
 
 void zebra_pbr_iptable_free(void *arg)
@@ -478,7 +479,7 @@ static void *pbr_rule_alloc_intern(void
 
 	zpr = (struct zebra_pbr_rule *)arg;
 
-	new = XCALLOC(MTYPE_TMP, sizeof(*new));
+	new = XCALLOC(MTYPE_PBR_OBJ, sizeof(*new));
 
 	memcpy(new, zpr, sizeof(*zpr));
 
@@ -492,7 +493,7 @@ static struct zebra_pbr_rule *pbr_rule_f
 		zebra_neigh_deref(hash_data);
 	hash_release(zrouter.rules_hash, hash_data);
 	if (free_data) {
-		XFREE(MTYPE_TMP, hash_data);
+		XFREE(MTYPE_PBR_OBJ, hash_data);
 		return NULL;
 	}
 
@@ -688,7 +689,7 @@ void zebra_pbr_add_rule(struct zebra_pbr
 		(void)dplane_pbr_rule_update(found, new);
 		/* release the old hash data */
 		if (old)
-			XFREE(MTYPE_TMP, old);
+			XFREE(MTYPE_PBR_OBJ, old);
 	} else {
 		if (IS_ZEBRA_DEBUG_PBR)
 			zlog_debug(
@@ -856,7 +857,7 @@ static void *pbr_ipset_alloc_intern(void
 
 	zpi = (struct zebra_pbr_ipset *)arg;
 
-	new = XCALLOC(MTYPE_TMP, sizeof(struct zebra_pbr_ipset));
+	new = XCALLOC(MTYPE_PBR_OBJ, sizeof(struct zebra_pbr_ipset));
 
 	memcpy(new, zpi, sizeof(*zpi));
 
@@ -877,7 +878,7 @@ void zebra_pbr_destroy_ipset(struct zebr
 	(void)dplane_pbr_ipset_delete(ipset);
 	if (lookup) {
 		hash_release(zrouter.ipset_hash, lookup);
-		XFREE(MTYPE_TMP, lookup);
+		XFREE(MTYPE_PBR_OBJ, lookup);
 	} else
 		zlog_debug(
 			"%s: IPSet Entry being deleted we know nothing about",
@@ -930,7 +931,7 @@ static void *pbr_ipset_entry_alloc_inter
 
 	zpi = (struct zebra_pbr_ipset_entry *)arg;
 
-	new = XCALLOC(MTYPE_TMP, sizeof(struct zebra_pbr_ipset_entry));
+	new = XCALLOC(MTYPE_PBR_OBJ, sizeof(struct zebra_pbr_ipset_entry));
 
 	memcpy(new, zpi, sizeof(*zpi));
 
@@ -952,7 +953,7 @@ void zebra_pbr_del_ipset_entry(struct ze
 	(void)dplane_pbr_ipset_entry_delete(ipset);
 	if (lookup) {
 		hash_release(zrouter.ipset_entry_hash, lookup);
-		XFREE(MTYPE_TMP, lookup);
+		XFREE(MTYPE_PBR_OBJ, lookup);
 	} else
 		zlog_debug("%s: IPSet being deleted we know nothing about",
 			   __func__);
@@ -967,7 +968,7 @@ static void *pbr_iptable_alloc_intern(vo
 
 	zpi = (struct zebra_pbr_iptable *)arg;
 
-	new = XCALLOC(MTYPE_TMP, sizeof(struct zebra_pbr_iptable));
+	new = XCALLOC(MTYPE_PBR_OBJ, sizeof(struct zebra_pbr_iptable));
 
 	/* Deep structure copy */
 	memcpy(new, zpi, sizeof(*zpi));
@@ -1009,7 +1010,7 @@ void zebra_pbr_del_iptable(struct zebra_
 					 node);
 		}
 		list_delete(&iptable->interface_name_list);
-		XFREE(MTYPE_TMP, lookup);
+		XFREE(MTYPE_PBR_OBJ, lookup);
 	} else
 		zlog_debug("%s: IPTable being deleted we know nothing about",
 			   __func__);
diff -urpN frr-frr-8.4.2/zebra/zebra_pbr.h frr-frr-8.5/zebra/zebra_pbr.h
--- frr-frr-8.4.2/zebra/zebra_pbr.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_pbr.h	2023-03-13 20:01:47.000000000 +0600
@@ -36,6 +36,9 @@
 extern "C" {
 #endif
 
+/* Memory type for PBR objects. */
+DECLARE_MTYPE(PBR_OBJ);
+
 struct zebra_pbr_action {
 	afi_t afi;
 
diff -urpN frr-frr-8.4.2/zebra/zebra_ptm.h frr-frr-8.5/zebra/zebra_ptm.h
--- frr-frr-8.4.2/zebra/zebra_ptm.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_ptm.h	2023-03-13 20:01:47.000000000 +0600
@@ -63,14 +63,12 @@ struct zebra_ptm_cb {
 #define ZEBRA_IF_PTM_ENABLE_ON     1
 #define ZEBRA_IF_PTM_ENABLE_UNSPEC 2
 
-#define IS_BFD_ENABLED_PROTOCOL(protocol) ( \
-	(protocol) == ZEBRA_ROUTE_BGP || \
-	(protocol) == ZEBRA_ROUTE_OSPF || \
-	(protocol) == ZEBRA_ROUTE_OSPF6 || \
-	(protocol) == ZEBRA_ROUTE_ISIS || \
-	(protocol) == ZEBRA_ROUTE_PIM || \
-	(protocol) == ZEBRA_ROUTE_OPENFABRIC \
-)
+#define IS_BFD_ENABLED_PROTOCOL(protocol)                                      \
+	((protocol) == ZEBRA_ROUTE_BGP || (protocol) == ZEBRA_ROUTE_OSPF ||    \
+	 (protocol) == ZEBRA_ROUTE_OSPF6 || (protocol) == ZEBRA_ROUTE_ISIS ||  \
+	 (protocol) == ZEBRA_ROUTE_PIM ||                                      \
+	 (protocol) == ZEBRA_ROUTE_OPENFABRIC ||                               \
+	 (protocol) == ZEBRA_ROUTE_STATIC)
 
 void zebra_ptm_init(void);
 void zebra_ptm_finish(void);
diff -urpN frr-frr-8.4.2/zebra/zebra_rib.c frr-frr-8.5/zebra/zebra_rib.c
--- frr-frr-8.4.2/zebra/zebra_rib.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_rib.c	2023-03-13 20:01:47.000000000 +0600
@@ -72,7 +72,7 @@ DEFINE_MTYPE_STATIC(ZEBRA, WQ_WRAPPER, "
  */
 static pthread_mutex_t dplane_mutex;
 static struct thread *t_dplane;
-static struct dplane_ctx_q rib_dplane_q;
+static struct dplane_ctx_list_head rib_dplane_q;
 
 DEFINE_HOOK(rib_update, (struct route_node * rn, const char *reason),
 	    (rn, reason));
@@ -292,13 +292,16 @@ static char *_dump_re_status(const struc
 	}
 
 	snprintfrr(
-		buf, len, "%s%s%s%s%s%s%s",
+		buf, len, "%s%s%s%s%s%s%s%s",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_REMOVED) ? "Removed " : "",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_CHANGED) ? "Changed " : "",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_LABELS_CHANGED)
 			? "Label Changed "
 			: "",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_QUEUED) ? "Queued " : "",
+		CHECK_FLAG(re->status, ROUTE_ENTRY_ROUTE_REPLACING)
+			? "Replacing"
+			: "",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_INSTALLED) ? "Installed "
 							      : "",
 		CHECK_FLAG(re->status, ROUTE_ENTRY_FAILED) ? "Failed " : "",
@@ -713,6 +716,7 @@ void rib_install_kernel(struct route_nod
 
 		if (old) {
 			SET_FLAG(old->status, ROUTE_ENTRY_QUEUED);
+			SET_FLAG(re->status, ROUTE_ENTRY_ROUTE_REPLACING);
 
 			/* Free old FIB nexthop group */
 			UNSET_FLAG(old->status, ROUTE_ENTRY_USE_FIB_NHG);
@@ -1302,6 +1306,7 @@ static void rib_process(struct route_nod
 									vrf),
 								vrf_id, rn);
 						rib_unlink(rn, re);
+						continue;
 					} else
 						SET_FLAG(re->status,
 							 ROUTE_ENTRY_REMOVED);
@@ -1519,8 +1524,7 @@ static bool rib_route_match_ctx(const st
 	}
 
 done:
-
-	return (result);
+	return result;
 }
 
 static void zebra_rib_fixup_system(struct route_node *rn)
@@ -1538,6 +1542,7 @@ static void zebra_rib_fixup_system(struc
 
 		SET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
 		UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
+		UNSET_FLAG(re->status, ROUTE_ENTRY_ROUTE_REPLACING);
 
 		for (ALL_NEXTHOPS(re->nhe->nhg, nhop)) {
 			if (CHECK_FLAG(nhop->flags, NEXTHOP_FLAG_RECURSIVE))
@@ -1783,9 +1788,12 @@ no_nexthops:
 			ctxnhg->nexthop != NULL ? "" : " (empty)");
 
 	/* Set the flag about the dedicated fib list */
-	SET_FLAG(re->status, ROUTE_ENTRY_USE_FIB_NHG);
-	if (ctxnhg->nexthop)
-		copy_nexthops(&(re->fib_ng.nexthop), ctxnhg->nexthop, NULL);
+	if (zrouter.asic_notification_nexthop_control) {
+		SET_FLAG(re->status, ROUTE_ENTRY_USE_FIB_NHG);
+		if (ctxnhg->nexthop)
+			copy_nexthops(&(re->fib_ng.nexthop), ctxnhg->nexthop,
+				      NULL);
+	}
 
 check_backups:
 
@@ -1995,8 +2003,12 @@ static void rib_process_result(struct ze
 		} else {
 			if (!zrouter.asic_offloaded ||
 			    (CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED) ||
-			     CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED)))
+			     CHECK_FLAG(re->flags,
+					ZEBRA_FLAG_OFFLOAD_FAILED))) {
+				UNSET_FLAG(re->status,
+					   ROUTE_ENTRY_ROUTE_REPLACING);
 				UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
+			}
 		}
 	}
 
@@ -2252,8 +2264,8 @@ static void rib_process_dplane_notify(st
 	}
 
 	/* Ensure we clear the QUEUED flag */
-	if (!zrouter.asic_offloaded)
-		UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
+	UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
+	UNSET_FLAG(re->status, ROUTE_ENTRY_ROUTE_REPLACING);
 
 	/* Is this a notification that ... matters? We mostly care about
 	 * the route that is currently selected for installation; we may also
@@ -2296,6 +2308,19 @@ static void rib_process_dplane_notify(st
 						dplane_ctx_get_type(ctx)));
 		}
 		goto done;
+	} else {
+		uint32_t flags = dplane_ctx_get_flags(ctx);
+
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_OFFLOADED)) {
+			UNSET_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED);
+			SET_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED);
+		}
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_OFFLOAD_FAILED)) {
+			UNSET_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED);
+			SET_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED);
+		}
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_TRAPPED))
+			SET_FLAG(re->flags, ZEBRA_FLAG_TRAPPED);
 	}
 
 	/* We'll want to determine whether the installation status of the
@@ -2329,55 +2354,70 @@ static void rib_process_dplane_notify(st
 	/* Various fib transitions: changed nexthops; from installed to
 	 * not-installed; or not-installed to installed.
 	 */
-	if (start_count > 0 && end_count > 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN applied nexthop changes from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+	if (zrouter.asic_notification_nexthop_control) {
+		if (start_count > 0 && end_count > 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN applied nexthop changes from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re,
-					  DPLANE_OP_ROUTE_UPDATE, ctx);
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_UPDATE, ctx);
 
-	} else if (start_count == 0 && end_count > 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN installed transition from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+		} else if (start_count == 0 && end_count > 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN installed transition from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* We expect this to be the selected route, so we want
-		 * to tell others about this transition.
-		 */
-		SET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
+			/* We expect this to be the selected route, so we want
+			 * to tell others about this transition.
+			 */
+			SET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re, DPLANE_OP_ROUTE_UPDATE, ctx);
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_UPDATE, ctx);
 
-		/* Redistribute, lsp, and nht update */
-		redistribute_update(rn, re, NULL);
+			/* Redistribute, lsp, and nht update */
+			redistribute_update(rn, re, NULL);
 
-	} else if (start_count > 0 && end_count == 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN un-installed transition from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+		} else if (start_count > 0 && end_count == 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN un-installed transition from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* Transition from _something_ installed to _nothing_
-		 * installed.
-		 */
-		/* We expect this to be the selected route, so we want
-		 * to tell others about this transistion.
-		 */
-		UNSET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
+			/* Transition from _something_ installed to _nothing_
+			 * installed.
+			 */
+			/* We expect this to be the selected route, so we want
+			 * to tell others about this transistion.
+			 */
+			UNSET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
+
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_DELETE, ctx);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re, DPLANE_OP_ROUTE_DELETE, ctx);
+			/* Redistribute, lsp, and nht update */
+			redistribute_delete(rn, re, NULL);
+		}
+	}
 
-		/* Redistribute, lsp, and nht update */
-		redistribute_delete(rn, re, NULL);
+	if (!zebra_router_notify_on_ack()) {
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED))
+			zsend_route_notify_owner_ctx(ctx, ZAPI_ROUTE_INSTALLED);
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED))
+			zsend_route_notify_owner_ctx(ctx,
+						     ZAPI_ROUTE_FAIL_INSTALL);
 	}
 
 	/* Make any changes visible for lsp and nexthop-tracking processing */
@@ -2675,10 +2715,6 @@ static void process_subq_early_route_add
 	if (ere->src_p_provided)
 		apply_mask_ipv6(&ere->src_p);
 
-	/* Set default distance by route type. */
-	if (re->distance == 0)
-		re->distance = route_distance(re->type);
-
 	/* Lookup route node.*/
 	rn = srcdest_rnode_get(table, &ere->p,
 			       ere->src_p_provided ? &ere->src_p : NULL);
@@ -2725,6 +2761,22 @@ static void process_subq_early_route_add
 		}
 	}
 
+	/* Set default distance by route type. */
+	if (re->distance == 0) {
+		if (same && !zebra_router_notify_on_ack())
+			re->distance = same->distance;
+		else
+			re->distance = route_distance(re->type);
+	}
+
+	if (re->metric == ROUTE_INSTALLATION_METRIC &&
+	    CHECK_FLAG(re->flags, ZEBRA_FLAG_SELFROUTE)) {
+		if (same && !zebra_router_notify_on_ack())
+			re->metric = same->metric;
+		else
+			re->metric = 0;
+	}
+
 	/* If this route is kernel/connected route, notify the dataplane. */
 	if (RIB_SYSTEM_ROUTE(re)) {
 		/* Notify dataplane */
@@ -3645,14 +3697,14 @@ static void rib_meta_queue_free(struct m
 static void early_route_meta_queue_free(struct meta_queue *mq, struct list *l,
 					struct zebra_vrf *zvrf)
 {
-	struct zebra_early_route *zer;
+	struct zebra_early_route *ere;
 	struct listnode *node, *nnode;
 
-	for (ALL_LIST_ELEMENTS(l, node, nnode, zer)) {
-		if (zvrf && zer->re->vrf_id != zvrf->vrf->vrf_id)
+	for (ALL_LIST_ELEMENTS(l, node, nnode, ere)) {
+		if (zvrf && ere->re->vrf_id != zvrf->vrf->vrf_id)
 			continue;
 
-		XFREE(MTYPE_RE, zer);
+		early_route_memory_free(ere);
 		node->data = NULL;
 		list_delete_node(l, node);
 		mq->size--;
@@ -3707,7 +3759,6 @@ static void rib_queue_init(void)
 
 	/* fill in the work queue spec */
 	zrouter.ribq->spec.workfunc = &meta_queue_process;
-	zrouter.ribq->spec.errorfunc = NULL;
 	zrouter.ribq->spec.completion_func = NULL;
 	/* XXX: TODO: These should be runtime configurable via vty */
 	zrouter.ribq->spec.max_retries = 3;
@@ -3800,7 +3851,9 @@ static void rib_link(struct route_node *
 
 		rmap_name = zebra_get_import_table_route_map(afi, re->table);
 		zebra_add_import_table_entry(zvrf, rn, re, rmap_name);
-	} else if (process)
+	}
+
+	if (process)
 		rib_queue_add(rn);
 }
 
@@ -3875,11 +3928,9 @@ void rib_delnode(struct route_node *rn,
 			zlog_debug("%s(%u):%pRN: Freeing route rn %p, re %p (%s)",
 				   vrf_id_to_name(re->vrf_id), re->vrf_id, rn,
 				   rn, re, zebra_route_string(re->type));
-
-		rib_unlink(rn, re);
-	} else {
-		rib_queue_add(rn);
 	}
+
+	rib_queue_add(rn);
 }
 
 /*
@@ -4289,25 +4340,6 @@ void rib_update_table(struct route_table
 	}
 }
 
-static void rib_update_handle_vrf(vrf_id_t vrf_id, enum rib_update_event event,
-				  int rtype)
-{
-	struct route_table *table;
-
-	if (IS_ZEBRA_DEBUG_EVENT)
-		zlog_debug("%s: Handling VRF %s event %s", __func__,
-			   vrf_id_to_name(vrf_id), rib_update_event2str(event));
-
-	/* Process routes of interested address-families. */
-	table = zebra_vrf_table(AFI_IP, SAFI_UNICAST, vrf_id);
-	if (table)
-		rib_update_table(table, event, rtype);
-
-	table = zebra_vrf_table(AFI_IP6, SAFI_UNICAST, vrf_id);
-	if (table)
-		rib_update_table(table, event, rtype);
-}
-
 static void rib_update_handle_vrf_all(enum rib_update_event event, int rtype)
 {
 	struct zebra_router_table *zrt;
@@ -4323,7 +4355,6 @@ static void rib_update_handle_vrf_all(en
 
 struct rib_update_ctx {
 	enum rib_update_event event;
-	bool vrf_all;
 	vrf_id_t vrf_id;
 };
 
@@ -4351,10 +4382,7 @@ static void rib_update_handler(struct th
 
 	ctx = THREAD_ARG(thread);
 
-	if (ctx->vrf_all)
-		rib_update_handle_vrf_all(ctx->event, ZEBRA_ROUTE_ALL);
-	else
-		rib_update_handle_vrf(ctx->vrf_id, ctx->event, ZEBRA_ROUTE_ALL);
+	rib_update_handle_vrf_all(ctx->event, ZEBRA_ROUTE_ALL);
 
 	rib_update_ctx_fini(&ctx);
 }
@@ -4374,7 +4402,6 @@ void rib_update(enum rib_update_event ev
 		return;
 
 	ctx = rib_update_ctx_init(0, event);
-	ctx->vrf_all = true;
 
 	thread_add_event(zrouter.master, rib_update_handler, ctx, 0,
 			 &t_rib_update_threads[event]);
@@ -4565,13 +4592,13 @@ static void handle_pw_result(struct zebr
 static void rib_process_dplane_results(struct thread *thread)
 {
 	struct zebra_dplane_ctx *ctx;
-	struct dplane_ctx_q ctxlist;
+	struct dplane_ctx_list_head ctxlist;
 	bool shut_p = false;
 
 	/* Dequeue a list of completed updates with one lock/unlock cycle */
 
 	do {
-		TAILQ_INIT(&ctxlist);
+		dplane_ctx_q_init(&ctxlist);
 
 		/* Take lock controlling queue of results */
 		frr_with_mutex (&dplane_mutex) {
@@ -4699,9 +4726,14 @@ static void rib_process_dplane_results(s
 				zebra_if_dplane_result(ctx);
 				break;
 
-			case DPLANE_OP_TC_INSTALL:
-			case DPLANE_OP_TC_UPDATE:
-			case DPLANE_OP_TC_DELETE:
+			case DPLANE_OP_TC_QDISC_INSTALL:
+			case DPLANE_OP_TC_QDISC_UNINSTALL:
+			case DPLANE_OP_TC_CLASS_ADD:
+			case DPLANE_OP_TC_CLASS_DELETE:
+			case DPLANE_OP_TC_CLASS_UPDATE:
+			case DPLANE_OP_TC_FILTER_ADD:
+			case DPLANE_OP_TC_FILTER_DELETE:
+			case DPLANE_OP_TC_FILTER_UPDATE:
 				break;
 
 			/* Some op codes not handled here */
@@ -4735,7 +4767,7 @@ static void rib_process_dplane_results(s
  * the dataplane pthread. We enqueue the results here for processing by
  * the main thread later.
  */
-static int rib_dplane_results(struct dplane_ctx_q *ctxlist)
+static int rib_dplane_results(struct dplane_ctx_list_head *ctxlist)
 {
 	/* Take lock controlling queue of results */
 	frr_with_mutex (&dplane_mutex) {
@@ -4780,7 +4812,7 @@ void rib_init(void)
 
 	/* Init dataplane, and register for results */
 	pthread_mutex_init(&dplane_mutex, NULL);
-	TAILQ_INIT(&rib_dplane_q);
+	dplane_ctx_q_init(&rib_dplane_q);
 	zebra_dplane_init(rib_dplane_results);
 }
 
diff -urpN frr-frr-8.4.2/zebra/zebra_rnh.c frr-frr-8.5/zebra/zebra_rnh.c
--- frr-frr-8.4.2/zebra/zebra_rnh.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_rnh.c	2023-03-13 20:01:47.000000000 +0600
@@ -62,7 +62,8 @@ static void free_state(vrf_id_t vrf_id,
 static void copy_state(struct rnh *rnh, const struct route_entry *re,
 		       struct route_node *rn);
 static bool compare_state(struct route_entry *r1, struct route_entry *r2);
-static void print_rnh(struct route_node *rn, struct vty *vty);
+static void print_rnh(struct route_node *rn, struct vty *vty,
+		      json_object *json);
 static int zebra_client_cleanup_rnh(struct zserv *client);
 
 void zebra_rnh_init(void)
@@ -803,7 +804,8 @@ void zebra_evaluate_rnh(struct zebra_vrf
 }
 
 void zebra_print_rnh_table(vrf_id_t vrfid, afi_t afi, safi_t safi,
-			   struct vty *vty, const struct prefix *p)
+			   struct vty *vty, const struct prefix *p,
+			   json_object *json)
 {
 	struct route_table *table;
 	struct route_node *rn;
@@ -820,7 +822,7 @@ void zebra_print_rnh_table(vrf_id_t vrfi
 			continue;
 
 		if (rn->info)
-			print_rnh(rn, vty);
+			print_rnh(rn, vty, json);
 	}
 }
 
@@ -1268,10 +1270,185 @@ failure:
 	return -1;
 }
 
-static void print_nh(struct nexthop *nexthop, struct vty *vty)
+
+/*
+ * Render a nexthop into a json object; the caller allocates and owns
+ * the json object memory.
+ */
+void show_nexthop_json_helper(json_object *json_nexthop,
+			      const struct nexthop *nexthop,
+			      const struct route_entry *re)
+{
+	json_object *json_labels = NULL;
+	json_object *json_backups = NULL;
+	json_object *json_seg6local = NULL;
+	json_object *json_seg6 = NULL;
+	int i;
+
+	json_object_int_add(json_nexthop, "flags", nexthop->flags);
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_DUPLICATE))
+		json_object_boolean_true_add(json_nexthop, "duplicate");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB))
+		json_object_boolean_true_add(json_nexthop, "fib");
+
+	switch (nexthop->type) {
+	case NEXTHOP_TYPE_IPV4:
+	case NEXTHOP_TYPE_IPV4_IFINDEX:
+		json_object_string_addf(json_nexthop, "ip", "%pI4",
+					&nexthop->gate.ipv4);
+		json_object_string_add(json_nexthop, "afi", "ipv4");
+
+		if (nexthop->ifindex) {
+			json_object_int_add(json_nexthop, "interfaceIndex",
+					    nexthop->ifindex);
+			json_object_string_add(json_nexthop, "interfaceName",
+					       ifindex2ifname(nexthop->ifindex,
+							      nexthop->vrf_id));
+		}
+		break;
+	case NEXTHOP_TYPE_IPV6:
+	case NEXTHOP_TYPE_IPV6_IFINDEX:
+		json_object_string_addf(json_nexthop, "ip", "%pI6",
+					&nexthop->gate.ipv6);
+		json_object_string_add(json_nexthop, "afi", "ipv6");
+
+		if (nexthop->ifindex) {
+			json_object_int_add(json_nexthop, "interfaceIndex",
+					    nexthop->ifindex);
+			json_object_string_add(json_nexthop, "interfaceName",
+					       ifindex2ifname(nexthop->ifindex,
+							      nexthop->vrf_id));
+		}
+		break;
+
+	case NEXTHOP_TYPE_IFINDEX:
+		json_object_boolean_true_add(json_nexthop, "directlyConnected");
+		json_object_int_add(json_nexthop, "interfaceIndex",
+				    nexthop->ifindex);
+		json_object_string_add(
+			json_nexthop, "interfaceName",
+			ifindex2ifname(nexthop->ifindex, nexthop->vrf_id));
+		break;
+	case NEXTHOP_TYPE_BLACKHOLE:
+		json_object_boolean_true_add(json_nexthop, "unreachable");
+		switch (nexthop->bh_type) {
+		case BLACKHOLE_REJECT:
+			json_object_boolean_true_add(json_nexthop, "reject");
+			break;
+		case BLACKHOLE_ADMINPROHIB:
+			json_object_boolean_true_add(json_nexthop,
+						     "adminProhibited");
+			break;
+		case BLACKHOLE_NULL:
+			json_object_boolean_true_add(json_nexthop, "blackhole");
+			break;
+		case BLACKHOLE_UNSPEC:
+			break;
+		}
+		break;
+	}
+
+	/* This nexthop is a resolver for the parent nexthop.
+	 * Set resolver flag for better clarity and delimiter
+	 * in flat list of nexthops in json.
+	 */
+	if (nexthop->rparent)
+		json_object_boolean_true_add(json_nexthop, "resolver");
+
+	if ((re == NULL || (nexthop->vrf_id != re->vrf_id)))
+		json_object_string_add(json_nexthop, "vrf",
+				       vrf_id_to_name(nexthop->vrf_id));
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_DUPLICATE))
+		json_object_boolean_true_add(json_nexthop, "duplicate");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
+		json_object_boolean_true_add(json_nexthop, "active");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ONLINK))
+		json_object_boolean_true_add(json_nexthop, "onLink");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_LINKDOWN))
+		json_object_boolean_true_add(json_nexthop, "linkDown");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
+		json_object_boolean_true_add(json_nexthop, "recursive");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
+		json_backups = json_object_new_array();
+		for (i = 0; i < nexthop->backup_num; i++) {
+			json_object_array_add(
+				json_backups,
+				json_object_new_int(nexthop->backup_idx[i]));
+		}
+
+		json_object_object_add(json_nexthop, "backupIndex",
+				       json_backups);
+	}
+
+	switch (nexthop->type) {
+	case NEXTHOP_TYPE_IPV4:
+	case NEXTHOP_TYPE_IPV4_IFINDEX:
+		if (nexthop->src.ipv4.s_addr)
+			json_object_string_addf(json_nexthop, "source", "%pI4",
+						&nexthop->src.ipv4);
+		break;
+	case NEXTHOP_TYPE_IPV6:
+	case NEXTHOP_TYPE_IPV6_IFINDEX:
+		if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+			json_object_string_addf(json_nexthop, "source", "%pI6",
+						&nexthop->src.ipv6);
+		break;
+	default:
+		break;
+	}
+
+	if (nexthop->nh_label && nexthop->nh_label->num_labels) {
+		json_labels = json_object_new_array();
+
+		for (int label_index = 0;
+		     label_index < nexthop->nh_label->num_labels; label_index++)
+			json_object_array_add(
+				json_labels,
+				json_object_new_int(
+					nexthop->nh_label->label[label_index]));
+
+		json_object_object_add(json_nexthop, "labels", json_labels);
+	}
+
+	if (nexthop->weight)
+		json_object_int_add(json_nexthop, "weight", nexthop->weight);
+
+	if (nexthop->srte_color)
+		json_object_int_add(json_nexthop, "srteColor",
+				    nexthop->srte_color);
+
+	if (nexthop->nh_srv6) {
+		json_seg6local = json_object_new_object();
+		json_object_string_add(
+			json_seg6local, "action",
+			seg6local_action2str(
+				nexthop->nh_srv6->seg6local_action));
+		json_object_object_add(json_nexthop, "seg6local",
+				       json_seg6local);
+
+		json_seg6 = json_object_new_object();
+		json_object_string_addf(json_seg6, "segs", "%pI6",
+					&nexthop->nh_srv6->seg6_segs);
+		json_object_object_add(json_nexthop, "seg6", json_seg6);
+	}
+}
+
+/*
+ * Helper for nexthop output, used in the 'show ip route' path
+ */
+void show_route_nexthop_helper(struct vty *vty, const struct route_entry *re,
+			       const struct nexthop *nexthop)
 {
-	char buf[BUFSIZ];
-	struct zebra_ns *zns = zebra_ns_lookup(nexthop->vrf_id);
+	char buf[MPLS_LABEL_STRLEN];
+	int i;
 
 	switch (nexthop->type) {
 	case NEXTHOP_TYPE_IPV4:
@@ -1279,62 +1456,215 @@ static void print_nh(struct nexthop *nex
 		vty_out(vty, " via %pI4", &nexthop->gate.ipv4);
 		if (nexthop->ifindex)
 			vty_out(vty, ", %s",
-				ifindex2ifname_per_ns(zns, nexthop->ifindex));
+				ifindex2ifname(nexthop->ifindex,
+					       nexthop->vrf_id));
 		break;
 	case NEXTHOP_TYPE_IPV6:
 	case NEXTHOP_TYPE_IPV6_IFINDEX:
-		vty_out(vty, " %s",
-			inet_ntop(AF_INET6, &nexthop->gate.ipv6, buf, BUFSIZ));
+		vty_out(vty, " via %s",
+			inet_ntop(AF_INET6, &nexthop->gate.ipv6, buf,
+				  sizeof(buf)));
 		if (nexthop->ifindex)
-			vty_out(vty, ", via %s",
-				ifindex2ifname_per_ns(zns, nexthop->ifindex));
+			vty_out(vty, ", %s",
+				ifindex2ifname(nexthop->ifindex,
+					       nexthop->vrf_id));
 		break;
+
 	case NEXTHOP_TYPE_IFINDEX:
 		vty_out(vty, " is directly connected, %s",
-			ifindex2ifname_per_ns(zns, nexthop->ifindex));
+			ifindex2ifname(nexthop->ifindex, nexthop->vrf_id));
 		break;
 	case NEXTHOP_TYPE_BLACKHOLE:
-		vty_out(vty, " is directly connected, Null0");
+		vty_out(vty, " unreachable");
+		switch (nexthop->bh_type) {
+		case BLACKHOLE_REJECT:
+			vty_out(vty, " (ICMP unreachable)");
+			break;
+		case BLACKHOLE_ADMINPROHIB:
+			vty_out(vty, " (ICMP admin-prohibited)");
+			break;
+		case BLACKHOLE_NULL:
+			vty_out(vty, " (blackhole)");
+			break;
+		case BLACKHOLE_UNSPEC:
+			break;
+		}
+		break;
+	}
+
+	if ((re == NULL || (nexthop->vrf_id != re->vrf_id)))
+		vty_out(vty, " (vrf %s)", vrf_id_to_name(nexthop->vrf_id));
+
+	if (!CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
+		vty_out(vty, " inactive");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ONLINK))
+		vty_out(vty, " onlink");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_LINKDOWN))
+		vty_out(vty, " linkdown");
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
+		vty_out(vty, " (recursive)");
+
+	switch (nexthop->type) {
+	case NEXTHOP_TYPE_IPV4:
+	case NEXTHOP_TYPE_IPV4_IFINDEX:
+		if (nexthop->src.ipv4.s_addr) {
+			vty_out(vty, ", src %pI4", &nexthop->src.ipv4);
+			/* SR-TE information */
+			if (nexthop->srte_color)
+				vty_out(vty, ", SR-TE color %u",
+					nexthop->srte_color);
+		}
+		break;
+	case NEXTHOP_TYPE_IPV6:
+	case NEXTHOP_TYPE_IPV6_IFINDEX:
+		if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+			vty_out(vty, ", src %pI6", &nexthop->src.ipv6);
 		break;
 	default:
 		break;
 	}
-	vty_out(vty, "\n");
+
+	/* Label information */
+	if (nexthop->nh_label && nexthop->nh_label->num_labels) {
+		vty_out(vty, ", label %s",
+			mpls_label2str(nexthop->nh_label->num_labels,
+				       nexthop->nh_label->label, buf,
+				       sizeof(buf), 1));
+	}
+
+	if (nexthop->nh_srv6) {
+		seg6local_context2str(buf, sizeof(buf),
+				      &nexthop->nh_srv6->seg6local_ctx,
+				      nexthop->nh_srv6->seg6local_action);
+		vty_out(vty, ", seg6local %s %s",
+			seg6local_action2str(
+				nexthop->nh_srv6->seg6local_action),
+			buf);
+		vty_out(vty, ", seg6 %pI6", &nexthop->nh_srv6->seg6_segs);
+	}
+
+	if (nexthop->weight)
+		vty_out(vty, ", weight %u", nexthop->weight);
+
+	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
+		vty_out(vty, ", backup %d", nexthop->backup_idx[0]);
+
+		for (i = 1; i < nexthop->backup_num; i++)
+			vty_out(vty, ",%d", nexthop->backup_idx[i]);
+	}
 }
 
-static void print_rnh(struct route_node *rn, struct vty *vty)
+static void print_rnh(struct route_node *rn, struct vty *vty, json_object *json)
 {
 	struct rnh *rnh;
 	struct nexthop *nexthop;
 	struct listnode *node;
 	struct zserv *client;
 	char buf[BUFSIZ];
+	json_object *json_nht = NULL;
+	json_object *json_client_array = NULL;
+	json_object *json_client = NULL;
+	json_object *json_nexthop_array = NULL;
+	json_object *json_nexthop = NULL;
 
 	rnh = rn->info;
-	vty_out(vty, "%s%s\n",
-		inet_ntop(rn->p.family, &rn->p.u.prefix, buf, BUFSIZ),
-		CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED) ? "(Connected)"
-							    : "");
-	if (rnh->state) {
-		vty_out(vty, " resolved via %s\n",
-			zebra_route_string(rnh->state->type));
-		for (nexthop = rnh->state->nhe->nhg.nexthop; nexthop;
-		     nexthop = nexthop->next)
-			print_nh(nexthop, vty);
-	} else
-		vty_out(vty, " unresolved%s\n",
+
+	if (json) {
+		json_nht = json_object_new_object();
+		json_nexthop_array = json_object_new_array();
+		json_client_array = json_object_new_array();
+
+		json_object_object_add(
+			json,
+			inet_ntop(rn->p.family, &rn->p.u.prefix, buf, BUFSIZ),
+			json_nht);
+		json_object_boolean_add(
+			json_nht, "nhtConnected",
+			CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED));
+		json_object_object_add(json_nht, "clientList",
+				       json_client_array);
+		json_object_object_add(json_nht, "nexthops",
+				       json_nexthop_array);
+	} else {
+		vty_out(vty, "%s%s\n",
+			inet_ntop(rn->p.family, &rn->p.u.prefix, buf, BUFSIZ),
 			CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED)
 				? "(Connected)"
 				: "");
+	}
+
+	if (rnh->state) {
+		if (json)
+			json_object_string_add(
+				json_nht, "resolvedProtocol",
+				zebra_route_string(rnh->state->type));
+		else
+			vty_out(vty, " resolved via %s\n",
+				zebra_route_string(rnh->state->type));
+
+		for (nexthop = rnh->state->nhe->nhg.nexthop; nexthop;
+		     nexthop = nexthop->next) {
+			if (json) {
+				json_nexthop = json_object_new_object();
+				json_object_array_add(json_nexthop_array,
+						      json_nexthop);
+				show_nexthop_json_helper(json_nexthop, nexthop,
+							 NULL);
+			} else {
+				show_route_nexthop_helper(vty, NULL, nexthop);
+				vty_out(vty, "\n");
+			}
+		}
+	} else {
+		if (json)
+			json_object_boolean_add(
+				json_nht, "unresolved",
+				CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED));
+		else
+			vty_out(vty, " unresolved%s\n",
+				CHECK_FLAG(rnh->flags, ZEBRA_NHT_CONNECTED)
+					? "(Connected)"
+					: "");
+	}
+
+	if (!json)
+		vty_out(vty, " Client list:");
+
+	for (ALL_LIST_ELEMENTS_RO(rnh->client_list, node, client)) {
+		if (json) {
+			json_client = json_object_new_object();
+			json_object_array_add(json_client_array, json_client);
+
+			json_object_string_add(
+				json_client, "protocol",
+				zebra_route_string(client->proto));
+			json_object_int_add(json_client, "socket",
+					    client->sock);
+			json_object_string_add(json_client, "protocolFiltered",
+					       (rnh->filtered[client->proto]
+							? "(filtered)"
+							: "none"));
+		} else {
+			vty_out(vty, " %s(fd %d)%s",
+				zebra_route_string(client->proto), client->sock,
+				rnh->filtered[client->proto] ? "(filtered)"
+							     : "");
+		}
+	}
+
+	if (!list_isempty(rnh->zebra_pseudowire_list)) {
+		if (json)
+			json_object_boolean_true_add(json_nht,
+						     "zebraPseudowires");
+		else
+			vty_out(vty, " zebra[pseudowires]");
+	}
 
-	vty_out(vty, " Client list:");
-	for (ALL_LIST_ELEMENTS_RO(rnh->client_list, node, client))
-		vty_out(vty, " %s(fd %d)%s", zebra_route_string(client->proto),
-			client->sock,
-			rnh->filtered[client->proto] ? "(filtered)" : "");
-	if (!list_isempty(rnh->zebra_pseudowire_list))
-		vty_out(vty, " zebra[pseudowires]");
-	vty_out(vty, "\n");
+	if (!json)
+		vty_out(vty, "\n");
 }
 
 static int zebra_cleanup_rnh_client(vrf_id_t vrf_id, afi_t afi, safi_t safi,
diff -urpN frr-frr-8.4.2/zebra/zebra_rnh.h frr-frr-8.5/zebra/zebra_rnh.h
--- frr-frr-8.4.2/zebra/zebra_rnh.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_rnh.h	2023-03-13 20:01:47.000000000 +0600
@@ -46,7 +46,8 @@ extern void zebra_remove_rnh_client(stru
 extern void zebra_evaluate_rnh(struct zebra_vrf *zvrf, afi_t afi, int force,
 			       const struct prefix *p, safi_t safi);
 extern void zebra_print_rnh_table(vrf_id_t vrfid, afi_t afi, safi_t safi,
-				  struct vty *vty, const struct prefix *p);
+				  struct vty *vty, const struct prefix *p,
+				  json_object *json);
 
 extern int rnh_resolve_via_default(struct zebra_vrf *zvrf, int family);
 
@@ -57,6 +58,12 @@ extern bool rnh_nexthop_valid(const stru
 void rnh_set_hide_backups(bool hide_p);
 bool rnh_get_hide_backups(void);
 
+void show_nexthop_json_helper(json_object *json_nexthop,
+			      const struct nexthop *nexthop,
+			      const struct route_entry *re);
+void show_route_nexthop_helper(struct vty *vty, const struct route_entry *re,
+			       const struct nexthop *nexthop);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/zebra/zebra_routemap.c frr-frr-8.5/zebra/zebra_routemap.c
--- frr-frr-8.4.2/zebra/zebra_routemap.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_routemap.c	2023-03-13 20:01:47.000000000 +0600
@@ -40,9 +40,7 @@
 #include "zebra/zebra_rnh.h"
 #include "zebra/zebra_routemap.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_routemap_clippy.c"
-#endif
 
 static uint32_t zebra_rmap_update_timer = ZEBRA_RMAP_DEFAULT_UPDATE_TIMER;
 static struct thread *zebra_t_rmap_update = NULL;
@@ -145,26 +143,48 @@ static void show_vrf_proto_rm(struct vty
 }
 
 static void show_vrf_nht_rm(struct vty *vty, struct zebra_vrf *zvrf,
-			    int af_type)
+			    int af_type, json_object *json)
 {
 	int i;
 
-	vty_out(vty, "Protocol                  : route-map\n");
-	vty_out(vty, "-------------------------------------\n");
+	if (!json) {
+		vty_out(vty, "Protocol                  : route-map\n");
+		vty_out(vty, "-------------------------------------\n");
+	}
 
 	for (i = 0; i < ZEBRA_ROUTE_MAX; i++) {
+		if (json) {
+			if (NHT_RM_NAME(zvrf, af_type, i))
+				json_object_string_add(
+					json, zebra_route_string(i),
+					NHT_RM_NAME(zvrf, af_type, i));
+			else
+				json_object_string_add(
+					json, zebra_route_string(i), "none");
+		} else {
+			if (NHT_RM_NAME(zvrf, af_type, i))
+				vty_out(vty, "%-24s  : %-10s\n",
+					zebra_route_string(i),
+					NHT_RM_NAME(zvrf, af_type, i));
+			else
+				vty_out(vty, "%-24s  : none\n",
+					zebra_route_string(i));
+		}
+	}
+
+	if (json) {
 		if (NHT_RM_NAME(zvrf, af_type, i))
-			vty_out(vty, "%-24s  : %-10s\n", zebra_route_string(i),
+			json_object_string_add(json, "any",
+					       NHT_RM_NAME(zvrf, af_type, i));
+		else
+			json_object_string_add(json, "any", "none");
+	} else {
+		if (NHT_RM_NAME(zvrf, af_type, i))
+			vty_out(vty, "%-24s  : %-10s\n", "any",
 				NHT_RM_NAME(zvrf, af_type, i));
 		else
-			vty_out(vty, "%-24s  : none\n", zebra_route_string(i));
+			vty_out(vty, "%-24s  : none\n", "any");
 	}
-
-	if (NHT_RM_NAME(zvrf, af_type, i))
-		vty_out(vty, "%-24s  : %-10s\n", "any",
-			NHT_RM_NAME(zvrf, af_type, i));
-	else
-		vty_out(vty, "%-24s  : none\n", "any");
 }
 
 static int show_proto_rm(struct vty *vty, int af_type, const char *vrf_all,
@@ -200,35 +220,78 @@ static int show_proto_rm(struct vty *vty
 }
 
 static int show_nht_rm(struct vty *vty, int af_type, const char *vrf_all,
-		       const char *vrf_name)
+		       const char *vrf_name, bool use_json)
 {
 	struct zebra_vrf *zvrf;
+	json_object *json = NULL;
+	json_object *json_vrfs = NULL;
+
+	if (use_json) {
+		json = json_object_new_object();
+		json_vrfs = json_object_new_object();
+		json_object_string_add(json, "afi",
+				       (af_type == AFI_IP) ? "ipv4" : "ipv6");
+	}
 
 	if (vrf_all) {
 		struct vrf *vrf;
 
+		if (use_json)
+			json_object_object_add(json, "vrfs", json_vrfs);
+
 		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
 			zvrf = (struct zebra_vrf *)vrf->info;
 			if (zvrf == NULL)
 				continue;
 
-			vty_out(vty, "VRF: %s\n", zvrf->vrf->name);
-			show_vrf_nht_rm(vty, zvrf, af_type);
+			if (use_json) {
+				json_object *json_proto = NULL;
+				json_object *json_vrf = NULL;
+				json_vrf = json_object_new_object();
+				json_object_object_add(
+					json_vrfs, zvrf->vrf->name, json_vrf);
+				json_proto = json_object_new_object();
+				json_object_object_add(json_vrf, "protocols",
+						       json_proto);
+				show_vrf_nht_rm(vty, zvrf, af_type, json_proto);
+			} else {
+				vty_out(vty, "VRF: %s\n", zvrf->vrf->name);
+				show_vrf_nht_rm(vty, zvrf, af_type, NULL);
+			}
 		}
 	} else {
+		json_object *json_proto = NULL;
+		json_object *json_vrf = NULL;
 		vrf_id_t vrf_id = VRF_DEFAULT;
 
 		if (vrf_name)
 			VRF_GET_ID(vrf_id, vrf_name, false);
 
 		zvrf = zebra_vrf_lookup_by_id(vrf_id);
-		if (!zvrf)
+		if (!zvrf) {
+			json_object_free(json);
+			json_object_free(json_vrfs);
 			return CMD_SUCCESS;
+		}
 
-		vty_out(vty, "VRF: %s\n", zvrf->vrf->name);
-		show_vrf_nht_rm(vty, zvrf, af_type);
+		if (use_json) {
+			json_object_object_add(json, "vrfs", json_vrfs);
+			json_vrf = json_object_new_object();
+			json_object_object_add(json_vrfs, zvrf->vrf->name,
+					       json_vrf);
+			json_proto = json_object_new_object();
+			json_object_object_add(json_vrf, "protocols",
+					       json_proto);
+			show_vrf_nht_rm(vty, zvrf, af_type, json_proto);
+		} else {
+			vty_out(vty, "VRF: %s\n", zvrf->vrf->name);
+			show_vrf_nht_rm(vty, zvrf, af_type, NULL);
+		}
 	}
 
+	if (use_json)
+		vty_json(vty, json);
+
 	return CMD_SUCCESS;
 }
 
@@ -856,14 +919,19 @@ DEFPY_YANG (no_ip_protocol_nht_rmap,
 
 DEFPY_YANG (show_ip_protocol_nht,
        show_ip_protocol_nht_cmd,
-       "show ip nht route-map [vrf <NAME$vrf_name|all$vrf_all>]",
+       "show ip nht route-map [vrf <NAME$vrf_name|all$vrf_all>] [json]",
        SHOW_STR
        IP_STR
-       "IP nexthop tracking table\n"
-       "IP Next Hop tracking filtering status\n"
-       VRF_FULL_CMD_HELP_STR)
+       "IPv4 nexthop tracking table\n"
+       "IPv4 Next Hop tracking filtering status\n"
+       VRF_CMD_HELP_STR
+       "All VRFs\n"
+       JSON_STR)
 {
-	int ret = show_nht_rm(vty, AFI_IP, vrf_all, vrf_name);
+	int ret;
+	bool uj = use_json(argc, argv);
+
+	ret = show_nht_rm(vty, AFI_IP, vrf_all, vrf_name, uj);
 
 	return ret;
 }
@@ -938,14 +1006,19 @@ DEFPY_YANG (no_ipv6_protocol_nht_rmap,
 
 DEFPY_YANG (show_ipv6_protocol_nht,
        show_ipv6_protocol_nht_cmd,
-       "show ipv6 nht route-map [vrf <NAME$vrf_name|all$vrf_all>]",
+       "show ipv6 nht route-map [vrf <NAME$vrf_name|all$vrf_all>] [json]",
        SHOW_STR
        IP6_STR
-       "Next Hop filtering status\n"
-       "Route-map\n"
-       VRF_FULL_CMD_HELP_STR)
+       "IPv6 nexthop tracking table\n"
+       "IPv6 Next Hop tracking filtering status\n"
+       VRF_CMD_HELP_STR
+       "All VRFs\n"
+       JSON_STR)
 {
-	int ret = show_nht_rm(vty, AFI_IP6, vrf_all, vrf_name);
+	int ret;
+	bool uj = use_json(argc, argv);
+
+	ret = show_nht_rm(vty, AFI_IP6, vrf_all, vrf_name, uj);
 
 	return ret;
 }
diff -urpN frr-frr-8.4.2/zebra/zebra_router.c frr-frr-8.5/zebra/zebra_router.c
--- frr-frr-8.4.2/zebra/zebra_router.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_router.c	2023-03-13 20:01:47.000000000 +0600
@@ -30,6 +30,7 @@
 #include "zebra_mlag.h"
 #include "zebra_nhg.h"
 #include "zebra_neigh.h"
+#include "zebra/zebra_tc.h"
 #include "debug.h"
 #include "zebra_script.h"
 
@@ -312,9 +313,34 @@ void zebra_router_init(bool asic_offload
 		hash_create_size(8, zebra_nhg_id_key, zebra_nhg_hash_id_equal,
 				 "Zebra Router Nexthop Groups ID index");
 
+	zrouter.rules_hash =
+		hash_create_size(8, zebra_pbr_rules_hash_key,
+				 zebra_pbr_rules_hash_equal, "Rules Hash");
+
+	zrouter.qdisc_hash =
+		hash_create_size(8, zebra_tc_qdisc_hash_key,
+				 zebra_tc_qdisc_hash_equal, "TC (qdisc) Hash");
+	zrouter.class_hash = hash_create_size(8, zebra_tc_class_hash_key,
+					      zebra_tc_class_hash_equal,
+					      "TC (classes) Hash");
+	zrouter.filter_hash = hash_create_size(8, zebra_tc_filter_hash_key,
+					       zebra_tc_filter_hash_equal,
+					       "TC (filter) Hash");
+
 	zrouter.asic_offloaded = asic_offload;
 	zrouter.notify_on_ack = notify_on_ack;
 
+	/*
+	 * If you start using asic_notification_nexthop_control
+	 * come talk to the FRR community about what you are doing
+	 * We would like to know.
+	 */
+#if CONFDATE > 20251231
+	CPP_NOTICE(
+		"Remove zrouter.asic_notification_nexthop_control as that it's not being maintained or used");
+#endif
+	zrouter.asic_notification_nexthop_control = false;
+
 #ifdef HAVE_SCRIPTING
 	zebra_script_init();
 #endif
diff -urpN frr-frr-8.4.2/zebra/zebra_router.h frr-frr-8.5/zebra/zebra_router.h
--- frr-frr-8.4.2/zebra/zebra_router.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_router.h	2023-03-13 20:01:47.000000000 +0600
@@ -172,6 +172,10 @@ struct zebra_router {
 
 	struct hash *iptable_hash;
 
+	struct hash *qdisc_hash;
+	struct hash *class_hash;
+	struct hash *filter_hash;
+
 	/* A sequence number used for tracking routes */
 	_Atomic uint32_t sequence_num;
 
@@ -220,6 +224,14 @@ struct zebra_router {
 	bool asic_offloaded;
 	bool notify_on_ack;
 
+	/*
+	 * If the asic is notifying us about successful nexthop
+	 * allocation/control.  Some developers have made their
+	 * asic take control of how many nexthops/ecmp they can
+	 * have and will report what is successfull or not
+	 */
+	bool asic_notification_nexthop_control;
+
 	bool supports_nhgs;
 
 	bool all_mc_forwardingv4, default_mc_forwardingv4;
diff -urpN frr-frr-8.4.2/zebra/zebra_script.c frr-frr-8.5/zebra/zebra_script.c
--- frr-frr-8.4.2/zebra/zebra_script.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_script.c	2023-03-13 20:01:47.000000000 +0600
@@ -417,12 +417,17 @@ void lua_pushzebra_dplane_ctx(lua_State
 	case DPLANE_OP_INTF_INSTALL:
 	case DPLANE_OP_INTF_UPDATE:
 	case DPLANE_OP_INTF_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
 		/* Not currently handled */
 	case DPLANE_OP_INTF_NETCONFIG: /*NYI*/
 	case DPLANE_OP_NONE:
-	case DPLANE_OP_TC_INSTALL:
-	case DPLANE_OP_TC_UPDATE:
-	case DPLANE_OP_TC_DELETE:
 		break;
 	} /* Dispatch by op code */
 }
diff -urpN frr-frr-8.4.2/zebra/zebra_srte.c frr-frr-8.5/zebra/zebra_srte.c
--- frr-frr-8.4.2/zebra/zebra_srte.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srte.c	2023-03-13 20:01:47.000000000 +0600
@@ -384,6 +384,23 @@ int zebra_sr_policy_label_update(mpls_la
 	return 0;
 }
 
+static int zebra_srte_client_close_cleanup(struct zserv *client)
+{
+	int sock = client->sock;
+	struct zebra_sr_policy *policy, *policy_temp;
+
+	if (!sock)
+		return 0;
+
+	RB_FOREACH_SAFE (policy, zebra_sr_policy_instance_head,
+			 &zebra_sr_policy_instances, policy_temp) {
+		if (policy->sock == sock)
+			zebra_sr_policy_del(policy);
+	}
+	return 1;
+}
+
 void zebra_srte_init(void)
 {
+	hook_register(zserv_client_close, zebra_srte_client_close_cleanup);
 }
diff -urpN frr-frr-8.4.2/zebra/zebra_srte.h frr-frr-8.5/zebra/zebra_srte.h
--- frr-frr-8.4.2/zebra/zebra_srte.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srte.h	2023-03-13 20:01:47.000000000 +0600
@@ -45,6 +45,7 @@ struct zebra_sr_policy {
 	struct zapi_srte_tunnel segment_list;
 	struct zebra_lsp *lsp;
 	struct zebra_vrf *zvrf;
+	int sock;
 };
 RB_HEAD(zebra_sr_policy_instance_head, zebra_sr_policy);
 RB_PROTOTYPE(zebra_sr_policy_instance_head, zebra_sr_policy, entry,
diff -urpN frr-frr-8.4.2/zebra/zebra_srv6.c frr-frr-8.5/zebra/zebra_srv6.c
--- frr-frr-8.4.2/zebra/zebra_srv6.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srv6.c	2023-03-13 20:01:47.000000000 +0600
@@ -177,6 +177,58 @@ struct srv6_locator *zebra_srv6_locator_
 	return NULL;
 }
 
+void zebra_notify_srv6_locator_add(struct srv6_locator *locator)
+{
+	struct listnode *node;
+	struct zserv *client;
+
+	/*
+	 * Notify new locator info to zclients.
+	 *
+	 * The srv6 locators and their prefixes are managed by zserv(zebra).
+	 * And an actual configuration the srv6 sid in the srv6 locator is done
+	 * by zclient(bgpd, isisd, etc). The configuration of each locator
+	 * allocation and specify it by zserv and zclient should be
+	 * asynchronous. For that, zclient should be received the event via
+	 * ZAPI when a srv6 locator is added on zebra.
+	 * Basically, in SRv6, adding/removing SRv6 locators is performed less
+	 * frequently than adding rib entries, so a broad to all zclients will
+	 * not degrade the overall performance of FRRouting.
+	 */
+	for (ALL_LIST_ELEMENTS_RO(zrouter.client_list, node, client))
+		zsend_zebra_srv6_locator_add(client, locator);
+}
+
+void zebra_notify_srv6_locator_delete(struct srv6_locator *locator)
+{
+	struct listnode *n;
+	struct srv6_locator_chunk *c;
+	struct zserv *client;
+
+	/*
+	 * Notify deleted locator info to zclients if needed.
+	 *
+	 * zclient(bgpd,isisd,etc) allocates a sid from srv6 locator chunk and
+	 * uses it for its own purpose. For example, in the case of BGP L3VPN,
+	 * the SID assigned to vpn unicast rib will be given.
+	 * And when the locator is deleted by zserv(zebra), those SIDs need to
+	 * be withdrawn. The zclient must initiate the withdrawal of the SIDs
+	 * by ZEBRA_SRV6_LOCATOR_DELETE, and this notification is sent to the
+	 * owner of each chunk.
+	 */
+	for (ALL_LIST_ELEMENTS_RO((struct list *)locator->chunks, n, c)) {
+		if (c->proto == ZEBRA_ROUTE_SYSTEM)
+			continue;
+		client = zserv_find_client(c->proto, c->instance);
+		if (!client) {
+			zlog_warn("Not found zclient(proto=%u, instance=%u).",
+				  c->proto, c->instance);
+			continue;
+		}
+		zsend_zebra_srv6_locator_delete(client, locator);
+	}
+}
+
 struct zebra_srv6 *zebra_srv6_get_default(void)
 {
 	static struct zebra_srv6 srv6;
diff -urpN frr-frr-8.4.2/zebra/zebra_srv6.h frr-frr-8.5/zebra/zebra_srv6.h
--- frr-frr-8.4.2/zebra/zebra_srv6.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srv6.h	2023-03-13 20:01:47.000000000 +0600
@@ -61,6 +61,9 @@ extern void zebra_srv6_locator_add(struc
 extern void zebra_srv6_locator_delete(struct srv6_locator *locator);
 extern struct srv6_locator *zebra_srv6_locator_lookup(const char *name);
 
+void zebra_notify_srv6_locator_add(struct srv6_locator *locator);
+void zebra_notify_srv6_locator_delete(struct srv6_locator *locator);
+
 extern void zebra_srv6_init(void);
 extern struct zebra_srv6 *zebra_srv6_get_default(void);
 extern bool zebra_srv6_is_enable(void);
diff -urpN frr-frr-8.4.2/zebra/zebra_srv6_vty.c frr-frr-8.5/zebra/zebra_srv6_vty.c
--- frr-frr-8.4.2/zebra/zebra_srv6_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srv6_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -40,9 +40,7 @@
 #include "zebra/zebra_routemap.h"
 #include "zebra/zebra_dplane.h"
 
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_srv6_vty_clippy.c"
-#endif
 
 static int zebra_sr_config(struct vty *vty);
 
@@ -167,8 +165,15 @@ DEFUN (show_srv6_locator_detail,
 		prefix2str(&locator->prefix, str, sizeof(str));
 		vty_out(vty, "Name: %s\n", locator->name);
 		vty_out(vty, "Prefix: %s\n", str);
+		vty_out(vty, "Block-Bit-Len: %u\n", locator->block_bits_length);
+		vty_out(vty, "Node-Bit-Len: %u\n", locator->node_bits_length);
 		vty_out(vty, "Function-Bit-Len: %u\n",
 			locator->function_bits_length);
+		vty_out(vty, "Argument-Bit-Len: %u\n",
+			locator->argument_bits_length);
+
+		if (CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))
+			vty_out(vty, "Behavior: uSID\n");
 
 		vty_out(vty, "Chunks:\n");
 		for (ALL_LIST_ELEMENTS_RO((struct list *)locator->chunks, node,
@@ -271,9 +276,14 @@ DEFUN (no_srv6_locator,
 
 DEFPY (locator_prefix,
        locator_prefix_cmd,
-       "prefix X:X::X:X/M$prefix [func-bits (16-64)$func_bit_len]",
+       "prefix X:X::X:X/M$prefix [block-len (16-64)$block_bit_len]  \
+	        [node-len (16-64)$node_bit_len] [func-bits (0-64)$func_bit_len]",
        "Configure SRv6 locator prefix\n"
        "Specify SRv6 locator prefix\n"
+       "Configure SRv6 locator block length in bits\n"
+       "Specify SRv6 locator block length in bits\n"
+       "Configure SRv6 locator node length in bits\n"
+       "Specify SRv6 locator node length in bits\n"
        "Configure SRv6 locator function length in bits\n"
        "Specify SRv6 locator function length in bits\n")
 {
@@ -282,24 +292,48 @@ DEFPY (locator_prefix,
 	struct listnode *node = NULL;
 
 	locator->prefix = *prefix;
+	func_bit_len = func_bit_len ?: ZEBRA_SRV6_FUNCTION_LENGTH;
+
+	/* Resolve optional arguments */
+	if (block_bit_len == 0 && node_bit_len == 0) {
+		block_bit_len =
+			prefix->prefixlen - ZEBRA_SRV6_LOCATOR_NODE_LENGTH;
+		node_bit_len = ZEBRA_SRV6_LOCATOR_NODE_LENGTH;
+	} else if (block_bit_len == 0) {
+		block_bit_len = prefix->prefixlen - node_bit_len;
+	} else if (node_bit_len == 0) {
+		node_bit_len = prefix->prefixlen - block_bit_len;
+	} else {
+		if (block_bit_len + node_bit_len != prefix->prefixlen) {
+			vty_out(vty,
+				"%% block-len + node-len must be equal to the selected prefix length %d\n",
+				prefix->prefixlen);
+			return CMD_WARNING_CONFIG_FAILED;
+		}
+	}
+
+	if (prefix->prefixlen + func_bit_len + 0 > 128) {
+		vty_out(vty,
+			"%% prefix-len + function-len + arg-len (%ld) cannot be greater than 128\n",
+			prefix->prefixlen + func_bit_len + 0);
+		return CMD_WARNING_CONFIG_FAILED;
+	}
 
 	/*
-	 * TODO(slankdev): please support variable node-bit-length.
-	 * In draft-ietf-bess-srv6-services-05#section-3.2.1.
-	 * Locator block length and Locator node length are defined.
-	 * Which are defined as "locator-len == block-len + node-len".
-	 * In current implementation, node bits length is hardcoded as 24.
-	 * It should be supported various val.
-	 *
-	 * Cisco IOS-XR support only following pattern.
-	 *  (1) Teh locator length should be 64-bits long.
-	 *  (2) The SID block portion (MSBs) cannot exceed 40 bits.
-	 *      If this value is less than 40 bits,
-	 *      user should use a pattern of zeros as a filler.
-	 *  (3) The Node Id portion (LSBs) cannot exceed 24 bits.
+	 * Currently, the SID transposition algorithm implemented in bgpd
+	 * handles incorrectly the SRv6 locators with function length greater
+	 * than 20 bits. To prevent issues, we currently limit the function
+	 * length to 20 bits.
+	 * This limit will be removed when the bgpd SID transposition is fixed.
 	 */
-	locator->block_bits_length = prefix->prefixlen - 24;
-	locator->node_bits_length = 24;
+	if (func_bit_len > 20) {
+		vty_out(vty,
+			"%% currently func_bit_len > 20 is not supported\n");
+		return CMD_WARNING_CONFIG_FAILED;
+	}
+
+	locator->block_bits_length = block_bit_len;
+	locator->node_bits_length = node_bit_len;
 	locator->function_bits_length = func_bit_len;
 	locator->argument_bits_length = 0;
 
@@ -338,6 +372,38 @@ DEFPY (locator_prefix,
 	return CMD_SUCCESS;
 }
 
+DEFPY (locator_behavior,
+       locator_behavior_cmd,
+       "[no] behavior usid",
+       NO_STR
+       "Configure SRv6 behavior\n"
+       "Specify SRv6 behavior uSID\n")
+{
+	VTY_DECLVAR_CONTEXT(srv6_locator, locator);
+
+	if (no && !CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))
+		/* SRv6 locator uSID flag already unset, nothing to do */
+		return CMD_SUCCESS;
+
+	if (!no && CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))
+		/* SRv6 locator uSID flag already set, nothing to do */
+		return CMD_SUCCESS;
+
+	/* Remove old locator from zclients */
+	zebra_notify_srv6_locator_delete(locator);
+
+	/* Set/Unset the SRV6_LOCATOR_USID */
+	if (no)
+		UNSET_FLAG(locator->flags, SRV6_LOCATOR_USID);
+	else
+		SET_FLAG(locator->flags, SRV6_LOCATOR_USID);
+
+	/* Notify the new locator to zclients */
+	zebra_notify_srv6_locator_add(locator);
+
+	return CMD_SUCCESS;
+}
+
 static int zebra_sr_config(struct vty *vty)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -356,10 +422,21 @@ static int zebra_sr_config(struct vty *v
 			vty_out(vty, "   locator %s\n", locator->name);
 			vty_out(vty, "    prefix %s/%u", str,
 				locator->prefix.prefixlen);
+			if (locator->block_bits_length)
+				vty_out(vty, " block-len %u",
+					locator->block_bits_length);
+			if (locator->node_bits_length)
+				vty_out(vty, " node-len %u",
+					locator->node_bits_length);
 			if (locator->function_bits_length)
 				vty_out(vty, " func-bits %u",
 					locator->function_bits_length);
+			if (locator->argument_bits_length)
+				vty_out(vty, " arg-len %u",
+					locator->argument_bits_length);
 			vty_out(vty, "\n");
+			if (CHECK_FLAG(locator->flags, SRV6_LOCATOR_USID))
+				vty_out(vty, "    behavior usid\n");
 			vty_out(vty, "   exit\n");
 			vty_out(vty, "   !\n");
 		}
@@ -395,6 +472,7 @@ void zebra_srv6_vty_init(void)
 
 	/* Command for configuration */
 	install_element(SRV6_LOC_NODE, &locator_prefix_cmd);
+	install_element(SRV6_LOC_NODE, &locator_behavior_cmd);
 
 	/* Command for operation */
 	install_element(VIEW_NODE, &show_srv6_locator_cmd);
diff -urpN frr-frr-8.4.2/zebra/zebra_srv6_vty.h frr-frr-8.5/zebra/zebra_srv6_vty.h
--- frr-frr-8.4.2/zebra/zebra_srv6_vty.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_srv6_vty.h	2023-03-13 20:01:47.000000000 +0600
@@ -20,6 +20,10 @@
 #ifndef _ZEBRA_SRV6_VTY_H
 #define _ZEBRA_SRV6_VTY_H
 
+#define ZEBRA_SRV6_LOCATOR_BLOCK_LENGTH 40
+#define ZEBRA_SRV6_LOCATOR_NODE_LENGTH 24
+#define ZEBRA_SRV6_FUNCTION_LENGTH 16
+
 extern void zebra_srv6_vty_init(void);
 
 #endif /* _ZEBRA_SRV6_VTY_H */
diff -urpN frr-frr-8.4.2/zebra/zebra_tc.c frr-frr-8.5/zebra/zebra_tc.c
--- frr-frr-8.4.2/zebra/zebra_tc.c	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_tc.c	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,444 @@
+/*
+ * Zebra Traffic Control (TC) main handling.
+ *
+ * Copyright (C) 2022 Shichu Yang
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#include <jhash.h>
+#include <hash.h>
+#include <memory.h>
+#include <hook.h>
+
+#include "zebra/zebra_router.h"
+#include "zebra/zebra_dplane.h"
+#include "zebra/zebra_tc.h"
+#include "zebra/debug.h"
+
+DEFINE_MTYPE_STATIC(ZEBRA, TC_QDISC, "TC queue discipline");
+DEFINE_MTYPE_STATIC(ZEBRA, TC_CLASS, "TC class");
+DEFINE_MTYPE_STATIC(ZEBRA, TC_FILTER, "TC filter");
+
+const struct message tc_qdisc_kinds[] = {
+	{TC_QDISC_HTB, "htb"},
+	{TC_QDISC_NOQUEUE, "noqueue"},
+	{0},
+};
+
+const struct message tc_filter_kinds[] = {
+	{TC_FILTER_BPF, "bpf"},
+	{TC_FILTER_FLOW, "flow"},
+	{TC_FILTER_FLOWER, "flower"},
+	{TC_FILTER_U32, "u32"},
+	{0},
+};
+
+const struct message *tc_class_kinds = tc_qdisc_kinds;
+
+static uint32_t lookup_key(const struct message *mz, const char *msg,
+			   uint32_t nf)
+{
+	static struct message nt = {0};
+	uint32_t rz = nf ? nf : UINT32_MAX;
+	const struct message *pnt;
+
+	for (pnt = mz; memcmp(pnt, &nt, sizeof(struct message)); pnt++)
+		if (strcmp(pnt->str, msg) == 0) {
+			rz = pnt->key;
+			break;
+		}
+	return rz;
+}
+
+const char *tc_qdisc_kind2str(uint32_t type)
+{
+	return lookup_msg(tc_qdisc_kinds, type, "Unrecognized QDISC Type");
+}
+
+enum tc_qdisc_kind tc_qdisc_str2kind(const char *type)
+{
+	return lookup_key(tc_qdisc_kinds, type, TC_QDISC_UNSPEC);
+}
+
+uint32_t zebra_tc_qdisc_hash_key(const void *arg)
+{
+	const struct zebra_tc_qdisc *qdisc;
+	uint32_t key;
+
+	qdisc = arg;
+
+	key = jhash_1word(qdisc->qdisc.ifindex, 0);
+
+	return key;
+}
+
+bool zebra_tc_qdisc_hash_equal(const void *arg1, const void *arg2)
+{
+	const struct zebra_tc_qdisc *q1, *q2;
+
+	q1 = (const struct zebra_tc_qdisc *)arg1;
+	q2 = (const struct zebra_tc_qdisc *)arg2;
+
+	if (q1->qdisc.ifindex != q2->qdisc.ifindex)
+		return false;
+
+	return true;
+}
+
+struct tc_qdisc_ifindex_lookup {
+	struct zebra_tc_qdisc *qdisc;
+	ifindex_t ifindex;
+};
+
+
+static int tc_qdisc_lookup_ifindex_walker(struct hash_bucket *b, void *data)
+{
+	struct tc_qdisc_ifindex_lookup *lookup = data;
+	struct zebra_tc_qdisc *qdisc = b->data;
+
+	if (lookup->ifindex == qdisc->qdisc.ifindex) {
+		lookup->qdisc = qdisc;
+		return HASHWALK_ABORT;
+	}
+
+	return HASHWALK_CONTINUE;
+}
+
+static struct zebra_tc_qdisc *
+tc_qdisc_lookup_ifindex(struct zebra_tc_qdisc *qdisc)
+{
+	struct tc_qdisc_ifindex_lookup lookup;
+
+	lookup.ifindex = qdisc->qdisc.ifindex;
+	lookup.qdisc = NULL;
+	hash_walk(zrouter.rules_hash, &tc_qdisc_lookup_ifindex_walker, &lookup);
+
+	return lookup.qdisc;
+}
+
+static void *tc_qdisc_alloc_intern(void *arg)
+{
+	struct zebra_tc_qdisc *ztq;
+	struct zebra_tc_qdisc *new;
+
+	ztq = (struct zebra_tc_qdisc *)arg;
+
+	new = XCALLOC(MTYPE_TC_QDISC, sizeof(*new));
+
+	memcpy(new, ztq, sizeof(*ztq));
+
+	return new;
+}
+
+static struct zebra_tc_qdisc *tc_qdisc_free(struct zebra_tc_qdisc *hash_data,
+					    bool free_data)
+{
+	hash_release(zrouter.qdisc_hash, hash_data);
+
+	if (free_data) {
+		XFREE(MTYPE_TC_QDISC, hash_data);
+		return NULL;
+	}
+
+	return hash_data;
+}
+
+static struct zebra_tc_qdisc *tc_qdisc_release(struct zebra_tc_qdisc *qdisc,
+					       bool free_data)
+{
+	struct zebra_tc_qdisc *lookup;
+
+	lookup = hash_lookup(zrouter.qdisc_hash, qdisc);
+
+	if (!lookup)
+		return NULL;
+
+	return tc_qdisc_free(lookup, free_data);
+}
+
+void zebra_tc_qdisc_install(struct zebra_tc_qdisc *qdisc)
+{
+	if (IS_ZEBRA_DEBUG_TC)
+		zlog_debug("%s: install tc qdisc ifindex %d kind %s", __func__,
+			   qdisc->qdisc.ifindex,
+			   tc_qdisc_kind2str(qdisc->qdisc.kind));
+
+	struct zebra_tc_qdisc *found;
+	struct zebra_tc_qdisc *old;
+	struct zebra_tc_qdisc *new;
+
+	found = tc_qdisc_lookup_ifindex(qdisc);
+
+	if (found) {
+		if (!zebra_tc_qdisc_hash_equal(qdisc, found)) {
+			old = tc_qdisc_release(found, false);
+			(void)dplane_tc_qdisc_uninstall(old);
+			new = hash_get(zrouter.qdisc_hash, qdisc,
+				       tc_qdisc_alloc_intern);
+			(void)dplane_tc_qdisc_install(new);
+			XFREE(MTYPE_TC_QDISC, old);
+		}
+	} else {
+		new = hash_get(zrouter.qdisc_hash, qdisc,
+			       tc_qdisc_alloc_intern);
+		(void)dplane_tc_qdisc_install(new);
+	}
+}
+
+void zebra_tc_qdisc_uninstall(struct zebra_tc_qdisc *qdisc)
+{
+	if (IS_ZEBRA_DEBUG_TC)
+		zlog_debug("%s: uninstall tc qdisc ifindex %d kind %s",
+			   __func__, qdisc->qdisc.ifindex,
+			   tc_qdisc_kind2str(qdisc->qdisc.kind));
+
+	(void)dplane_tc_qdisc_uninstall(qdisc);
+
+	if (tc_qdisc_release(qdisc, true))
+		zlog_debug("%s: tc qdisc being deleted we know nothing about",
+			   __func__);
+}
+
+uint32_t zebra_tc_class_hash_key(const void *arg)
+{
+	const struct zebra_tc_class *class;
+	uint32_t key;
+
+	class = arg;
+
+	key = jhash_2words(class->class.ifindex, class->class.handle, 0);
+
+	return key;
+}
+
+bool zebra_tc_class_hash_equal(const void *arg1, const void *arg2)
+{
+	const struct zebra_tc_class *c1, *c2;
+
+	c1 = (const struct zebra_tc_class *)arg1;
+	c2 = (const struct zebra_tc_class *)arg2;
+
+	if (c1->class.ifindex != c2->class.ifindex)
+		return false;
+
+	if (c1->class.handle != c2->class.handle)
+		return false;
+
+	return true;
+}
+
+static void *tc_class_alloc_intern(void *arg)
+{
+	struct zebra_tc_class *class;
+	struct zebra_tc_class *new;
+
+	class = (struct zebra_tc_class *)arg;
+
+	new = XCALLOC(MTYPE_TC_CLASS, sizeof(*new));
+
+	memcpy(new, class, sizeof(*class));
+
+	return new;
+}
+
+static struct zebra_tc_class *tc_class_free(struct zebra_tc_class *hash_data,
+					    bool free_data)
+{
+	hash_release(zrouter.class_hash, hash_data);
+
+	if (free_data) {
+		XFREE(MTYPE_TC_CLASS, hash_data);
+		return NULL;
+	}
+
+	return hash_data;
+}
+
+static struct zebra_tc_class *tc_class_release(struct zebra_tc_class *class,
+					       bool free_data)
+{
+	struct zebra_tc_class *lookup;
+
+	lookup = hash_lookup(zrouter.class_hash, class);
+
+	if (!lookup)
+		return NULL;
+
+	return tc_class_free(lookup, free_data);
+}
+
+void zebra_tc_class_add(struct zebra_tc_class *class)
+{
+	if (IS_ZEBRA_DEBUG_TC)
+		zlog_debug(
+			"%s: add tc class ifindex %d handle %04x:%04x kind %s",
+			__func__, class->class.ifindex,
+			(class->class.handle & 0xffff0000u) >> 16,
+			class->class.handle & 0x0000ffffu,
+			tc_qdisc_kind2str(class->class.kind));
+
+	struct zebra_tc_class *found;
+	struct zebra_tc_class *new;
+
+	/*
+	 * We find the class in the hash by (ifindex, handle) directly, and by
+	 * testing their deep equality to seek out whether it's an update.
+	 *
+	 * Currently deep equality is not checked since it will be okay to
+	 * update the totally same class again.
+	 */
+	found = hash_lookup(zrouter.class_hash, class);
+	new = hash_get(zrouter.class_hash, class, tc_class_alloc_intern);
+
+	if (found)
+		(void)dplane_tc_class_update(new);
+	else
+		(void)dplane_tc_class_add(new);
+}
+
+void zebra_tc_class_delete(struct zebra_tc_class *class)
+{
+	if (IS_ZEBRA_DEBUG_TC)
+		zlog_debug(
+			"%s: delete tc class ifindex %d handle %04x:%04x kind %s",
+			__func__, class->class.ifindex,
+			(class->class.handle & 0xffff0000u) >> 16,
+			class->class.handle & 0x0000ffffu,
+			tc_qdisc_kind2str(class->class.kind));
+
+	(void)dplane_tc_class_delete(class);
+
+	if (tc_class_release(class, true))
+		zlog_debug("%s: tc class being deleted we know nothing about",
+			   __func__);
+}
+
+const char *tc_filter_kind2str(uint32_t type)
+{
+	return lookup_msg(tc_filter_kinds, type, "Unrecognized TFILTER Type");
+}
+
+enum tc_qdisc_kind tc_filter_str2kind(const char *type)
+{
+	return lookup_key(tc_filter_kinds, type, TC_FILTER_UNSPEC);
+}
+
+uint32_t zebra_tc_filter_hash_key(const void *arg)
+{
+	const struct zebra_tc_filter *filter;
+	uint32_t key;
+
+	filter = arg;
+
+	key = jhash_2words(filter->filter.ifindex, filter->filter.handle, 0);
+
+	return key;
+}
+
+bool zebra_tc_filter_hash_equal(const void *arg1, const void *arg2)
+{
+	const struct zebra_tc_filter *f1, *f2;
+
+	f1 = (const struct zebra_tc_filter *)arg1;
+	f2 = (const struct zebra_tc_filter *)arg2;
+
+	if (f1->filter.ifindex != f2->filter.ifindex)
+		return false;
+
+	if (f1->filter.handle != f2->filter.handle)
+		return false;
+
+	return true;
+}
+
+static struct zebra_tc_filter *tc_filter_free(struct zebra_tc_filter *hash_data,
+					      bool free_data)
+{
+	hash_release(zrouter.filter_hash, hash_data);
+
+	if (free_data) {
+		XFREE(MTYPE_TC_FILTER, hash_data);
+		return NULL;
+	}
+
+	return hash_data;
+}
+
+static struct zebra_tc_filter *tc_filter_release(struct zebra_tc_filter *filter,
+						 bool free_data)
+{
+	struct zebra_tc_filter *lookup;
+
+	lookup = hash_lookup(zrouter.filter_hash, filter);
+
+	if (!lookup)
+		return NULL;
+
+	return tc_filter_free(lookup, free_data);
+}
+
+static void *tc_filter_alloc_intern(void *arg)
+{
+	struct zebra_tc_filter *ztf;
+	struct zebra_tc_filter *new;
+
+	ztf = (struct zebra_tc_filter *)arg;
+
+	new = XCALLOC(MTYPE_TC_FILTER, sizeof(*new));
+
+	memcpy(new, ztf, sizeof(*ztf));
+
+	return new;
+}
+
+void zebra_tc_filter_add(struct zebra_tc_filter *filter)
+{
+	if (IS_ZEBRA_DEBUG_TC)
+		zlog_debug(
+			"%s: add tc filter ifindex %d priority %u handle %08x kind %s",
+			__func__, filter->filter.ifindex,
+			filter->filter.priority, filter->filter.handle,
+			tc_filter_kind2str(filter->filter.kind));
+
+	struct zebra_tc_filter *found;
+	struct zebra_tc_filter *new;
+
+	found = hash_lookup(zrouter.filter_hash, filter);
+	new = hash_get(zrouter.filter_hash, filter, tc_filter_alloc_intern);
+
+	if (found)
+		(void)dplane_tc_filter_update(new);
+	else
+		(void)dplane_tc_filter_add(new);
+}
+
+void zebra_tc_filter_delete(struct zebra_tc_filter *filter)
+{
+	if (IS_ZEBRA_DEBUG_PBR)
+		zlog_debug(
+			"%s: delete tc filter ifindex %d priority %u handle %08x kind %s",
+			__func__, filter->filter.ifindex,
+			filter->filter.priority, filter->filter.handle,
+			tc_filter_kind2str(filter->filter.kind));
+
+	(void)dplane_tc_filter_delete(filter);
+
+	if (tc_filter_release(filter, true))
+		zlog_debug("%s: tc filter being deleted we know nothing about",
+			   __func__);
+}
diff -urpN frr-frr-8.4.2/zebra/zebra_tc.h frr-frr-8.5/zebra/zebra_tc.h
--- frr-frr-8.4.2/zebra/zebra_tc.h	1970-01-01 06:00:00.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_tc.h	2023-03-13 20:01:47.000000000 +0600
@@ -0,0 +1,79 @@
+/*
+ * Zebra Traffic Control (TC) Data structures and definitions
+ * These are public definitions referenced by multiple files.
+ *
+ * Copyright (C) 2022 Shichu Yang
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _ZEBRA_TC_H
+#define _ZEBRA_TC_H
+
+#include <zebra.h>
+#include "rt.h"
+#include "tc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct zebra_tc_qdisc {
+	int sock;
+
+	struct tc_qdisc qdisc;
+};
+
+struct zebra_tc_class {
+	int sock;
+
+	struct tc_class class;
+};
+
+struct zebra_tc_filter {
+	int sock;
+
+	struct tc_filter filter;
+};
+
+const char *tc_qdisc_kind2str(uint32_t type);
+enum tc_qdisc_kind tc_qdisc_str2kind(const char *type);
+
+uint32_t zebra_tc_qdisc_hash_key(const void *arg);
+bool zebra_tc_qdisc_hash_equal(const void *arg1, const void *arg2);
+void zebra_tc_qdisc_install(struct zebra_tc_qdisc *qdisc);
+void zebra_tc_qdisc_uninstall(struct zebra_tc_qdisc *qdisc);
+
+uint32_t zebra_tc_class_hash_key(const void *arg);
+bool zebra_tc_class_hash_equal(const void *arg1, const void *arg2);
+void zebra_tc_class_add(struct zebra_tc_class *class);
+void zebra_tc_class_delete(struct zebra_tc_class *class);
+
+const char *tc_filter_kind2str(uint32_t type);
+enum tc_qdisc_kind tc_filter_str2kind(const char *type);
+void zebra_tc_filter_add(struct zebra_tc_filter *filter);
+void zebra_tc_filter_delete(struct zebra_tc_filter *filter);
+
+void zebra_tc_filters_free(void *arg);
+uint32_t zebra_tc_filter_hash_key(const void *arg);
+bool zebra_tc_filter_hash_equal(const void *arg1, const void *arg2);
+
+void kernel_read_tc_qdisc(struct zebra_ns *zns);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZEBRA_TC_H */
diff -urpN frr-frr-8.4.2/zebra/zebra_vrf.c frr-frr-8.5/zebra/zebra_vrf.c
--- frr-frr-8.4.2/zebra/zebra_vrf.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_vrf.c	2023-03-13 20:01:47.000000000 +0600
@@ -44,9 +44,7 @@
 #include "zebra/zebra_vxlan.h"
 #include "zebra/zebra_netns_notify.h"
 #include "zebra/zebra_routemap.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_vrf_clippy.c"
-#endif
 #include "zebra/table_manager.h"
 
 static void zebra_vrf_table_create(struct zebra_vrf *zvrf, afi_t afi,
diff -urpN frr-frr-8.4.2/zebra/zebra_vty.c frr-frr-8.5/zebra/zebra_vty.c
--- frr-frr-8.4.2/zebra/zebra_vty.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_vty.c	2023-03-13 20:01:47.000000000 +0600
@@ -46,9 +46,7 @@
 #include "lib/route_opaque.h"
 #include "zebra/zebra_vxlan.h"
 #include "zebra/zebra_evpn_mh.h"
-#ifndef VTYSH_EXTRACT_PL
 #include "zebra/zebra_vty_clippy.c"
-#endif
 #include "zebra/zserv.h"
 #include "zebra/router-id.h"
 #include "zebra/ipforward.h"
@@ -224,6 +222,9 @@ static char re_status_output_char(const
 		    && CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED))
 			return 'o';
 
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_OUTOFSYNC))
+			return 'd';
+
 		if (star_p)
 			return '*';
 		else
@@ -597,340 +598,6 @@ static void vty_show_ip_route_detail(str
 	}
 }
 
-/*
- * Helper for nexthop output, used in the 'show ip route' path
- */
-static void show_route_nexthop_helper(struct vty *vty,
-				      const struct route_entry *re,
-				      const struct nexthop *nexthop)
-{
-	char buf[MPLS_LABEL_STRLEN];
-	int i;
-
-	switch (nexthop->type) {
-	case NEXTHOP_TYPE_IPV4:
-	case NEXTHOP_TYPE_IPV4_IFINDEX:
-		vty_out(vty, " via %pI4", &nexthop->gate.ipv4);
-		if (nexthop->ifindex)
-			vty_out(vty, ", %s",
-				ifindex2ifname(nexthop->ifindex,
-					       nexthop->vrf_id));
-		break;
-	case NEXTHOP_TYPE_IPV6:
-	case NEXTHOP_TYPE_IPV6_IFINDEX:
-		vty_out(vty, " via %s",
-			inet_ntop(AF_INET6, &nexthop->gate.ipv6, buf,
-				  sizeof(buf)));
-		if (nexthop->ifindex)
-			vty_out(vty, ", %s",
-				ifindex2ifname(nexthop->ifindex,
-					       nexthop->vrf_id));
-		break;
-
-	case NEXTHOP_TYPE_IFINDEX:
-		vty_out(vty, " is directly connected, %s",
-			ifindex2ifname(nexthop->ifindex,
-				       nexthop->vrf_id));
-		break;
-	case NEXTHOP_TYPE_BLACKHOLE:
-		vty_out(vty, " unreachable");
-		switch (nexthop->bh_type) {
-		case BLACKHOLE_REJECT:
-			vty_out(vty, " (ICMP unreachable)");
-			break;
-		case BLACKHOLE_ADMINPROHIB:
-			vty_out(vty, " (ICMP admin-prohibited)");
-			break;
-		case BLACKHOLE_NULL:
-			vty_out(vty, " (blackhole)");
-			break;
-		case BLACKHOLE_UNSPEC:
-			break;
-		}
-		break;
-	}
-
-	if ((re == NULL || (nexthop->vrf_id != re->vrf_id)))
-		vty_out(vty, " (vrf %s)", vrf_id_to_name(nexthop->vrf_id));
-
-	if (!CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
-		vty_out(vty, " inactive");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ONLINK))
-		vty_out(vty, " onlink");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_LINKDOWN))
-		vty_out(vty, " linkdown");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
-		vty_out(vty, " (recursive)");
-
-	switch (nexthop->type) {
-	case NEXTHOP_TYPE_IPV4:
-	case NEXTHOP_TYPE_IPV4_IFINDEX:
-		if (nexthop->src.ipv4.s_addr) {
-			if (inet_ntop(AF_INET, &nexthop->src.ipv4, buf,
-				      sizeof(buf)))
-				vty_out(vty, ", src %s", buf);
-			/* SR-TE information */
-			if (nexthop->srte_color)
-				vty_out(vty, ", SR-TE color %u",
-					nexthop->srte_color);
-		}
-		break;
-	case NEXTHOP_TYPE_IPV6:
-	case NEXTHOP_TYPE_IPV6_IFINDEX:
-		if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any)) {
-			if (inet_ntop(AF_INET6, &nexthop->src.ipv6, buf,
-				      sizeof(buf)))
-				vty_out(vty, ", src %s", buf);
-		}
-		break;
-	default:
-		break;
-	}
-
-	/* Label information */
-	if (nexthop->nh_label && nexthop->nh_label->num_labels) {
-		vty_out(vty, ", label %s",
-			mpls_label2str(nexthop->nh_label->num_labels,
-				       nexthop->nh_label->label, buf,
-				       sizeof(buf), 1));
-	}
-
-	if (nexthop->nh_srv6) {
-		seg6local_context2str(buf, sizeof(buf),
-				      &nexthop->nh_srv6->seg6local_ctx,
-				      nexthop->nh_srv6->seg6local_action);
-		vty_out(vty, ", seg6local %s %s", seg6local_action2str(
-			nexthop->nh_srv6->seg6local_action), buf);
-
-		inet_ntop(AF_INET6, &nexthop->nh_srv6->seg6_segs, buf,
-			  sizeof(buf));
-		vty_out(vty, ", seg6 %s", buf);
-	}
-
-	if (nexthop->weight)
-		vty_out(vty, ", weight %u", nexthop->weight);
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
-		vty_out(vty, ", backup %d", nexthop->backup_idx[0]);
-
-		for (i = 1; i < nexthop->backup_num; i++)
-			vty_out(vty, ",%d", nexthop->backup_idx[i]);
-	}
-}
-
-/*
- * Render a nexthop into a json object; the caller allocates and owns
- * the json object memory.
- */
-static void show_nexthop_json_helper(json_object *json_nexthop,
-				     const struct nexthop *nexthop,
-				     const struct route_entry *re)
-{
-	char buf[SRCDEST2STR_BUFFER];
-	json_object *json_labels = NULL;
-	json_object *json_backups = NULL;
-	json_object *json_seg6local = NULL;
-	json_object *json_seg6 = NULL;
-	int i;
-
-	json_object_int_add(json_nexthop, "flags",
-			    nexthop->flags);
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_DUPLICATE))
-		json_object_boolean_true_add(json_nexthop,
-					     "duplicate");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB))
-		json_object_boolean_true_add(json_nexthop,
-					     "fib");
-
-	switch (nexthop->type) {
-	case NEXTHOP_TYPE_IPV4:
-	case NEXTHOP_TYPE_IPV4_IFINDEX:
-		json_object_string_addf(json_nexthop, "ip", "%pI4",
-					&nexthop->gate.ipv4);
-		json_object_string_add(json_nexthop, "afi",
-				       "ipv4");
-
-		if (nexthop->ifindex) {
-			json_object_int_add(json_nexthop,
-					    "interfaceIndex",
-					    nexthop->ifindex);
-			json_object_string_add(
-				json_nexthop, "interfaceName",
-				ifindex2ifname(
-					nexthop->ifindex,
-					nexthop->vrf_id));
-		}
-		break;
-	case NEXTHOP_TYPE_IPV6:
-	case NEXTHOP_TYPE_IPV6_IFINDEX:
-		json_object_string_addf(json_nexthop, "ip", "%pI6",
-					&nexthop->gate.ipv6);
-		json_object_string_add(json_nexthop, "afi",
-				       "ipv6");
-
-		if (nexthop->ifindex) {
-			json_object_int_add(json_nexthop,
-					    "interfaceIndex",
-					    nexthop->ifindex);
-			json_object_string_add(
-				json_nexthop, "interfaceName",
-				ifindex2ifname(
-					nexthop->ifindex,
-					nexthop->vrf_id));
-		}
-		break;
-
-	case NEXTHOP_TYPE_IFINDEX:
-		json_object_boolean_true_add(
-			json_nexthop, "directlyConnected");
-		json_object_int_add(json_nexthop,
-				    "interfaceIndex",
-				    nexthop->ifindex);
-		json_object_string_add(
-			json_nexthop, "interfaceName",
-			ifindex2ifname(nexthop->ifindex,
-				       nexthop->vrf_id));
-		break;
-	case NEXTHOP_TYPE_BLACKHOLE:
-		json_object_boolean_true_add(json_nexthop,
-					     "unreachable");
-		switch (nexthop->bh_type) {
-		case BLACKHOLE_REJECT:
-			json_object_boolean_true_add(
-				json_nexthop, "reject");
-			break;
-		case BLACKHOLE_ADMINPROHIB:
-			json_object_boolean_true_add(
-				json_nexthop,
-				"admin-prohibited");
-			break;
-		case BLACKHOLE_NULL:
-			json_object_boolean_true_add(
-				json_nexthop, "blackhole");
-			break;
-		case BLACKHOLE_UNSPEC:
-			break;
-		}
-		break;
-	}
-
-	/* This nexthop is a resolver for the parent nexthop.
-	 * Set resolver flag for better clarity and delimiter
-	 * in flat list of nexthops in json.
-	 */
-	if (nexthop->rparent)
-		json_object_boolean_true_add(json_nexthop, "resolver");
-
-	if (nexthop->vrf_id != re->vrf_id)
-		json_object_string_add(json_nexthop, "vrf",
-				       vrf_id_to_name(nexthop->vrf_id));
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_DUPLICATE))
-		json_object_boolean_true_add(json_nexthop,
-					     "duplicate");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
-		json_object_boolean_true_add(json_nexthop,
-					     "active");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ONLINK))
-		json_object_boolean_true_add(json_nexthop,
-					     "onLink");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_LINKDOWN))
-		json_object_boolean_true_add(json_nexthop, "linkDown");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
-		json_object_boolean_true_add(json_nexthop,
-					     "recursive");
-
-	if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
-		json_backups = json_object_new_array();
-		for (i = 0; i < nexthop->backup_num; i++) {
-			json_object_array_add(
-				json_backups,
-				json_object_new_int(nexthop->backup_idx[i]));
-		}
-
-		json_object_object_add(json_nexthop, "backupIndex",
-				       json_backups);
-	}
-
-	switch (nexthop->type) {
-	case NEXTHOP_TYPE_IPV4:
-	case NEXTHOP_TYPE_IPV4_IFINDEX:
-		if (nexthop->src.ipv4.s_addr) {
-			if (inet_ntop(AF_INET,
-				      &nexthop->src.ipv4, buf,
-				      sizeof(buf)))
-				json_object_string_add(
-					json_nexthop, "source",
-					buf);
-		}
-		break;
-	case NEXTHOP_TYPE_IPV6:
-	case NEXTHOP_TYPE_IPV6_IFINDEX:
-		if (!IPV6_ADDR_SAME(&nexthop->src.ipv6,
-				    &in6addr_any)) {
-			if (inet_ntop(AF_INET6,
-				      &nexthop->src.ipv6, buf,
-				      sizeof(buf)))
-				json_object_string_add(
-					json_nexthop, "source",
-					buf);
-		}
-		break;
-	default:
-		break;
-	}
-
-	if (nexthop->nh_label
-	    && nexthop->nh_label->num_labels) {
-		json_labels = json_object_new_array();
-
-		for (int label_index = 0;
-		     label_index
-			     < nexthop->nh_label->num_labels;
-		     label_index++)
-			json_object_array_add(
-				json_labels,
-				json_object_new_int(
-					nexthop->nh_label->label
-					[label_index]));
-
-		json_object_object_add(json_nexthop, "labels",
-				       json_labels);
-	}
-
-	if (nexthop->weight)
-		json_object_int_add(json_nexthop, "weight",
-				    nexthop->weight);
-
-	if (nexthop->srte_color)
-		json_object_int_add(json_nexthop, "srteColor",
-				    nexthop->srte_color);
-
-	if (nexthop->nh_srv6) {
-		json_seg6local = json_object_new_object();
-		json_object_string_add(
-			json_seg6local, "action", seg6local_action2str(
-			nexthop->nh_srv6->seg6local_action));
-		json_object_object_add(json_nexthop, "seg6local",
-				       json_seg6local);
-
-		json_seg6 = json_object_new_object();
-		inet_ntop(AF_INET6, &nexthop->nh_srv6->seg6_segs, buf,
-			  sizeof(buf));
-		json_object_string_add(json_seg6, "segs", buf);
-		json_object_object_add(json_nexthop, "seg6", json_seg6);
-	}
-}
-
 static void vty_show_ip_route(struct vty *vty, struct route_node *rn,
 			      struct route_entry *re, json_object *json,
 			      bool is_fib, bool show_ng)
@@ -1369,7 +1036,7 @@ static int do_show_ip_route(struct vty *
 
 DEFPY (show_ip_nht,
        show_ip_nht_cmd,
-       "show <ip$ipv4|ipv6$ipv6> <nht|import-check>$type [<A.B.C.D|X:X::X:X>$addr|vrf NAME$vrf_name [<A.B.C.D|X:X::X:X>$addr]|vrf all$vrf_all] [mrib$mrib]",
+       "show <ip$ipv4|ipv6$ipv6> <nht|import-check>$type [<A.B.C.D|X:X::X:X>$addr|vrf NAME$vrf_name [<A.B.C.D|X:X::X:X>$addr]|vrf all$vrf_all] [mrib$mrib] [json]",
        SHOW_STR
        IP_STR
        IP6_STR
@@ -1381,23 +1048,50 @@ DEFPY (show_ip_nht,
        "IPv4 Address\n"
        "IPv6 Address\n"
        VRF_ALL_CMD_HELP_STR
-       "Show Multicast (MRIB) NHT state\n")
+       "Show Multicast (MRIB) NHT state\n"
+       JSON_STR)
 {
 	afi_t afi = ipv4 ? AFI_IP : AFI_IP6;
 	vrf_id_t vrf_id = VRF_DEFAULT;
 	struct prefix prefix, *p = NULL;
 	safi_t safi = mrib ? SAFI_MULTICAST : SAFI_UNICAST;
+	bool uj = use_json(argc, argv);
+	json_object *json = NULL;
+	json_object *json_vrf = NULL;
+	json_object *json_nexthop = NULL;
+
+	if (uj)
+		json = json_object_new_object();
 
 	if (vrf_all) {
 		struct vrf *vrf;
 		struct zebra_vrf *zvrf;
 
-		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name)
+		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
 			if ((zvrf = vrf->info) != NULL) {
-				vty_out(vty, "\nVRF %s:\n", zvrf_name(zvrf));
+				if (uj) {
+					json_vrf = json_object_new_object();
+					json_nexthop = json_object_new_object();
+					json_object_object_add(json,
+							       zvrf_name(zvrf),
+							       json_vrf);
+					json_object_object_add(json_vrf,
+							       (afi == AFI_IP)
+								       ? "ipv4"
+								       : "ipv6",
+							       json_nexthop);
+				} else {
+					vty_out(vty, "\nVRF %s:\n",
+						zvrf_name(zvrf));
+				}
 				zebra_print_rnh_table(zvrf_id(zvrf), afi, safi,
-						      vty, NULL);
+						      vty, NULL, json_nexthop);
 			}
+		}
+
+		if (uj)
+			vty_json(vty, json);
+
 		return CMD_SUCCESS;
 	}
 	if (vrf_name)
@@ -1406,11 +1100,31 @@ DEFPY (show_ip_nht,
 	memset(&prefix, 0, sizeof(prefix));
 	if (addr) {
 		p = sockunion2hostprefix(addr, &prefix);
-		if (!p)
+		if (!p) {
+			if (uj)
+				json_object_free(json);
 			return CMD_WARNING;
+		}
+	}
+
+	if (uj) {
+		json_vrf = json_object_new_object();
+		json_nexthop = json_object_new_object();
+		if (vrf_name)
+			json_object_object_add(json, vrf_name, json_vrf);
+		else
+			json_object_object_add(json, "default", json_vrf);
+
+		json_object_object_add(json_vrf,
+				       (afi == AFI_IP) ? "ipv4" : "ipv6",
+				       json_nexthop);
 	}
 
-	zebra_print_rnh_table(vrf_id, afi, safi, vty, p);
+	zebra_print_rnh_table(vrf_id, afi, safi, vty, p, json_nexthop);
+
+	if (uj)
+		vty_json(vty, json);
+
 	return CMD_SUCCESS;
 }
 
@@ -1435,119 +1149,264 @@ DEFUN (ip_nht_default_route,
 	return CMD_SUCCESS;
 }
 
-static void show_nexthop_group_out(struct vty *vty, struct nhg_hash_entry *nhe)
+static void show_nexthop_group_out(struct vty *vty, struct nhg_hash_entry *nhe,
+				   json_object *json_nhe_hdr)
 {
 	struct nexthop *nexthop = NULL;
 	struct nhg_connected *rb_node_dep = NULL;
 	struct nexthop_group *backup_nhg;
 	char up_str[MONOTIME_STRLEN];
 	char time_left[MONOTIME_STRLEN];
+	json_object *json_dependants = NULL;
+	json_object *json_depends = NULL;
+	json_object *json_nexthop_array = NULL;
+	json_object *json_nexthops = NULL;
+	json_object *json = NULL;
+	json_object *json_backup_nexthop_array = NULL;
+	json_object *json_backup_nexthops = NULL;
+
 
 	uptime2str(nhe->uptime, up_str, sizeof(up_str));
 
-	vty_out(vty, "ID: %u (%s)\n", nhe->id, zebra_route_string(nhe->type));
-	vty_out(vty, "     RefCnt: %u", nhe->refcnt);
-	if (thread_is_scheduled(nhe->timer))
-		vty_out(vty, " Time to Deletion: %s",
-			thread_timer_to_hhmmss(time_left, sizeof(time_left),
-					       nhe->timer));
-	vty_out(vty, "\n");
+	if (json_nhe_hdr)
+		json = json_object_new_object();
+
+	if (json) {
+		json_object_string_add(json, "type",
+				       zebra_route_string(nhe->type));
+		json_object_int_add(json, "refCount", nhe->refcnt);
+		if (thread_is_scheduled(nhe->timer))
+			json_object_string_add(
+				json, "timeToDeletion",
+				thread_timer_to_hhmmss(time_left,
+						       sizeof(time_left),
+						       nhe->timer));
+		json_object_string_add(json, "uptime", up_str);
+		json_object_string_add(json, "vrf",
+				       vrf_id_to_name(nhe->vrf_id));
 
-	vty_out(vty, "     Uptime: %s\n", up_str);
-	vty_out(vty, "     VRF: %s\n", vrf_id_to_name(nhe->vrf_id));
+	} else {
+		vty_out(vty, "ID: %u (%s)\n", nhe->id,
+			zebra_route_string(nhe->type));
+		vty_out(vty, "     RefCnt: %u", nhe->refcnt);
+		if (thread_is_scheduled(nhe->timer))
+			vty_out(vty, " Time to Deletion: %s",
+				thread_timer_to_hhmmss(time_left,
+						       sizeof(time_left),
+						       nhe->timer));
+		vty_out(vty, "\n");
 
+		vty_out(vty, "     Uptime: %s\n", up_str);
+		vty_out(vty, "     VRF: %s\n", vrf_id_to_name(nhe->vrf_id));
+	}
 
 	if (CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_VALID)) {
-		vty_out(vty, "     Valid");
-		if (CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_INSTALLED))
-			vty_out(vty, ", Installed");
-		vty_out(vty, "\n");
+		if (json)
+			json_object_boolean_true_add(json, "valid");
+		else
+			vty_out(vty, "     Valid");
+
+		if (CHECK_FLAG(nhe->flags, NEXTHOP_GROUP_INSTALLED)) {
+			if (json)
+				json_object_boolean_true_add(json, "installed");
+			else
+				vty_out(vty, ", Installed");
+		}
+		if (!json)
+			vty_out(vty, "\n");
+	}
+	if (nhe->ifp) {
+		if (json)
+			json_object_int_add(json, "interfaceIndex",
+					    nhe->ifp->ifindex);
+		else
+			vty_out(vty, "     Interface Index: %d\n",
+				nhe->ifp->ifindex);
 	}
-	if (nhe->ifp)
-		vty_out(vty, "     Interface Index: %d\n", nhe->ifp->ifindex);
 
 	if (!zebra_nhg_depends_is_empty(nhe)) {
-		vty_out(vty, "     Depends:");
+		if (json)
+			json_depends = json_object_new_array();
+		else
+			vty_out(vty, "     Depends:");
 		frr_each(nhg_connected_tree, &nhe->nhg_depends, rb_node_dep) {
-			vty_out(vty, " (%u)", rb_node_dep->nhe->id);
+			if (json_depends)
+				json_object_array_add(
+					json_depends,
+					json_object_new_int(
+						rb_node_dep->nhe->id));
+			else
+				vty_out(vty, " (%u)", rb_node_dep->nhe->id);
 		}
-		vty_out(vty, "\n");
+		if (!json_depends)
+			vty_out(vty, "\n");
+		else
+			json_object_object_add(json, "depends", json_depends);
 	}
 
 	/* Output nexthops */
-	for (ALL_NEXTHOPS(nhe->nhg, nexthop)) {
-		if (!CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
-			vty_out(vty, "          ");
-		else
-			/* Make recursive nexthops a bit more clear */
-			vty_out(vty, "       ");
+	if (json)
+		json_nexthop_array = json_object_new_array();
+
 
-		show_route_nexthop_helper(vty, NULL, nexthop);
+	for (ALL_NEXTHOPS(nhe->nhg, nexthop)) {
+		if (json_nexthop_array) {
+			json_nexthops = json_object_new_object();
+			show_nexthop_json_helper(json_nexthops, nexthop, NULL);
+		} else {
+			if (!CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
+				vty_out(vty, "          ");
+			else
+				/* Make recursive nexthops a bit more clear */
+				vty_out(vty, "       ");
+			show_route_nexthop_helper(vty, NULL, nexthop);
+		}
 
 		if (nhe->backup_info == NULL || nhe->backup_info->nhe == NULL) {
 			if (CHECK_FLAG(nexthop->flags,
-				       NEXTHOP_FLAG_HAS_BACKUP))
-				vty_out(vty, " [backup %d]",
-					nexthop->backup_idx[0]);
+				       NEXTHOP_FLAG_HAS_BACKUP)) {
+				if (json)
+					json_object_int_add(
+						json_nexthops, "backup",
+						nexthop->backup_idx[0]);
+				else
+					vty_out(vty, " [backup %d]",
+						nexthop->backup_idx[0]);
+			}
+
+			if (!json)
+				vty_out(vty, "\n");
+			else
+				json_object_array_add(json_nexthop_array,
+						      json_nexthops);
 
-			vty_out(vty, "\n");
 			continue;
 		}
 
-		/* TODO -- print more useful backup info */
-		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
-			int i;
-
-			vty_out(vty, "[backup");
-			for (i = 0; i < nexthop->backup_num; i++)
-				vty_out(vty, " %d", nexthop->backup_idx[i]);
+		if (!json) {
+			/* TODO -- print more useful backup info */
+			if (CHECK_FLAG(nexthop->flags,
+				       NEXTHOP_FLAG_HAS_BACKUP)) {
+				int i;
 
-			vty_out(vty, "]");
+				vty_out(vty, "[backup");
+				for (i = 0; i < nexthop->backup_num; i++)
+					vty_out(vty, " %d",
+						nexthop->backup_idx[i]);
+				vty_out(vty, "]");
+			}
+			vty_out(vty, "\n");
+		} else {
+			json_object_array_add(json_nexthop_array,
+					      json_nexthops);
 		}
-
-		vty_out(vty, "\n");
 	}
 
+	if (json)
+		json_object_object_add(json, "nexthops", json_nexthop_array);
+
 	/* Output backup nexthops (if any) */
 	backup_nhg = zebra_nhg_get_backup_nhg(nhe);
 	if (backup_nhg) {
-		vty_out(vty, "     Backups:\n");
+		if (json)
+			json_backup_nexthop_array = json_object_new_array();
+		else
+			vty_out(vty, "     Backups:\n");
 
 		for (ALL_NEXTHOPS_PTR(backup_nhg, nexthop)) {
-			if (!CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
-				vty_out(vty, "          ");
-			else
-				/* Make recursive nexthops a bit more clear */
-				vty_out(vty, "       ");
+			if (json_backup_nexthop_array) {
+				json_backup_nexthops = json_object_new_object();
+				show_nexthop_json_helper(json_backup_nexthops,
+							 nexthop, NULL);
+				json_object_array_add(json_backup_nexthop_array,
+						      json_backup_nexthops);
+			} else {
 
-			show_route_nexthop_helper(vty, NULL, nexthop);
-			vty_out(vty, "\n");
+				if (!CHECK_FLAG(nexthop->flags,
+						NEXTHOP_FLAG_RECURSIVE))
+					vty_out(vty, "          ");
+				else
+					/* Make recursive nexthops a bit more
+					 * clear
+					 */
+					vty_out(vty, "       ");
+				show_route_nexthop_helper(vty, NULL, nexthop);
+				vty_out(vty, "\n");
+			}
 		}
+
+		if (json)
+			json_object_object_add(json, "backupNexthops",
+					       json_backup_nexthop_array);
 	}
 
 	if (!zebra_nhg_dependents_is_empty(nhe)) {
-		vty_out(vty, "     Dependents:");
+		if (json)
+			json_dependants = json_object_new_array();
+		else
+			vty_out(vty, "     Dependents:");
 		frr_each(nhg_connected_tree, &nhe->nhg_dependents,
 			  rb_node_dep) {
-			vty_out(vty, " (%u)", rb_node_dep->nhe->id);
+			if (json)
+				json_object_array_add(
+					json_dependants,
+					json_object_new_int(
+						rb_node_dep->nhe->id));
+			else
+				vty_out(vty, " (%u)", rb_node_dep->nhe->id);
+		}
+		if (json)
+			json_object_object_add(json, "dependents",
+					       json_dependants);
+		else
+			vty_out(vty, "\n");
+	}
+
+	if (nhe->nhg.nhgr.buckets) {
+		if (json) {
+			json_object_int_add(json, "buckets",
+					    nhe->nhg.nhgr.buckets);
+			json_object_int_add(json, "idleTimer",
+					    nhe->nhg.nhgr.idle_timer);
+			json_object_int_add(json, "unbalancedTimer",
+					    nhe->nhg.nhgr.unbalanced_timer);
+			json_object_int_add(json, "unbalancedTime",
+					    nhe->nhg.nhgr.unbalanced_time);
+		} else {
+			vty_out(vty,
+				"     Buckets: %u Idle Timer: %u Unbalanced Timer: %u Unbalanced time: %" PRIu64
+				"\n",
+				nhe->nhg.nhgr.buckets, nhe->nhg.nhgr.idle_timer,
+				nhe->nhg.nhgr.unbalanced_timer,
+				nhe->nhg.nhgr.unbalanced_time);
 		}
-		vty_out(vty, "\n");
 	}
 
+	if (json_nhe_hdr)
+		json_object_object_addf(json_nhe_hdr, json, "%u", nhe->id);
 }
 
-static int show_nexthop_group_id_cmd_helper(struct vty *vty, uint32_t id)
+static int show_nexthop_group_id_cmd_helper(struct vty *vty, uint32_t id,
+					    json_object *json)
 {
 	struct nhg_hash_entry *nhe = NULL;
 
 	nhe = zebra_nhg_lookup_id(id);
 
 	if (nhe)
-		show_nexthop_group_out(vty, nhe);
+		show_nexthop_group_out(vty, nhe, json);
 	else {
-		vty_out(vty, "Nexthop Group ID: %u does not exist\n", id);
+		if (json)
+			vty_json(vty, json);
+		else
+			vty_out(vty, "Nexthop Group ID: %u does not exist\n",
+				id);
 		return CMD_WARNING;
 	}
+
+	if (json)
+		vty_json(vty, json);
+
 	return CMD_SUCCESS;
 }
 
@@ -1558,6 +1417,7 @@ struct nhe_show_context {
 	vrf_id_t vrf_id;
 	afi_t afi;
 	int type;
+	json_object *json;
 };
 
 static int nhe_show_walker(struct hash_bucket *bucket, void *arg)
@@ -1576,7 +1436,7 @@ static int nhe_show_walker(struct hash_b
 	if (ctx->type && nhe->type != ctx->type)
 		goto done;
 
-	show_nexthop_group_out(ctx->vty, nhe);
+	show_nexthop_group_out(ctx->vty, nhe, ctx->json);
 
 done:
 	return HASHWALK_CONTINUE;
@@ -1584,7 +1444,7 @@ done:
 
 static void show_nexthop_group_cmd_helper(struct vty *vty,
 					  struct zebra_vrf *zvrf, afi_t afi,
-					  int type)
+					  int type, json_object *json)
 {
 	struct nhe_show_context ctx;
 
@@ -1592,6 +1452,7 @@ static void show_nexthop_group_cmd_helpe
 	ctx.afi = afi;
 	ctx.vrf_id = zvrf->vrf->vrf_id;
 	ctx.type = type;
+	ctx.json = json;
 
 	hash_walk(zrouter.nhgs_id, nhe_show_walker, &ctx);
 }
@@ -1609,7 +1470,7 @@ static void if_nexthop_group_dump_vty(st
 		frr_each(nhg_connected_tree, &zebra_if->nhg_dependents,
 			  rb_node_dep) {
 			vty_out(vty, "   ");
-			show_nexthop_group_out(vty, rb_node_dep->nhe);
+			show_nexthop_group_out(vty, rb_node_dep->nhe, NULL);
 		}
 	}
 }
@@ -1648,29 +1509,36 @@ DEFPY (show_interface_nexthop_group,
 	return CMD_SUCCESS;
 }
 
-DEFPY (show_nexthop_group,
-       show_nexthop_group_cmd,
-       "show nexthop-group rib <(0-4294967295)$id|[singleton <ip$v4|ipv6$v6>] [<kernel|zebra|bgp|sharp>$type_str] [vrf <NAME$vrf_name|all$vrf_all>]>",
-       SHOW_STR
-       "Show Nexthop Groups\n"
-       "RIB information\n"
-       "Nexthop Group ID\n"
-       "Show Singleton Nexthop-Groups\n"
-       IP_STR
-       IP6_STR
-       "Kernel (not installed via the zebra RIB)\n"
-       "Zebra (implicitly created by zebra)\n"
-       "Border Gateway Protocol (BGP)\n"
-       "Super Happy Advanced Routing Protocol (SHARP)\n"
-       VRF_FULL_CMD_HELP_STR)
+DEFPY(show_nexthop_group,
+      show_nexthop_group_cmd,
+      "show nexthop-group rib <(0-4294967295)$id|[singleton <ip$v4|ipv6$v6>] [<kernel|zebra|bgp|sharp>$type_str] [vrf <NAME$vrf_name|all$vrf_all>]> [json]",
+      SHOW_STR
+      "Show Nexthop Groups\n"
+      "RIB information\n"
+      "Nexthop Group ID\n"
+      "Show Singleton Nexthop-Groups\n"
+      IP_STR
+      IP6_STR
+      "Kernel (not installed via the zebra RIB)\n"
+      "Zebra (implicitly created by zebra)\n"
+      "Border Gateway Protocol (BGP)\n"
+      "Super Happy Advanced Routing Protocol (SHARP)\n"
+      VRF_FULL_CMD_HELP_STR
+      JSON_STR)
 {
 
 	struct zebra_vrf *zvrf = NULL;
 	afi_t afi = AFI_UNSPEC;
 	int type = 0;
+	bool uj = use_json(argc, argv);
+	json_object *json = NULL;
+	json_object *json_vrf = NULL;
+
+	if (uj)
+		json = json_object_new_object();
 
 	if (id)
-		return show_nexthop_group_id_cmd_helper(vty, id);
+		return show_nexthop_group_id_cmd_helper(vty, id, json);
 
 	if (v4)
 		afi = AFI_IP;
@@ -1686,8 +1554,11 @@ DEFPY (show_nexthop_group,
 	}
 
 	if (!vrf_is_backend_netns() && (vrf_name || vrf_all)) {
-		vty_out(vty,
-			"VRF subcommand does not make any sense in l3mdev based vrf's\n");
+		if (uj)
+			vty_json(vty, json);
+		else
+			vty_out(vty,
+				"VRF subcommand does not make any sense in l3mdev based vrf's\n");
 		return CMD_WARNING;
 	}
 
@@ -1700,11 +1571,21 @@ DEFPY (show_nexthop_group,
 			zvrf = vrf->info;
 			if (!zvrf)
 				continue;
+			if (uj)
+				json_vrf = json_object_new_object();
+			else
+				vty_out(vty, "VRF: %s\n", vrf->name);
 
-			vty_out(vty, "VRF: %s\n", vrf->name);
-			show_nexthop_group_cmd_helper(vty, zvrf, afi, type);
+			show_nexthop_group_cmd_helper(vty, zvrf, afi, type,
+						      json_vrf);
+			if (uj)
+				json_object_object_add(json, vrf->name,
+						       json_vrf);
 		}
 
+		if (uj)
+			vty_json(vty, json);
+
 		return CMD_SUCCESS;
 	}
 
@@ -1714,12 +1595,18 @@ DEFPY (show_nexthop_group,
 		zvrf = zebra_vrf_lookup_by_name(VRF_DEFAULT_NAME);
 
 	if (!zvrf) {
-		vty_out(vty, "%% VRF '%s' specified does not exist\n",
-			vrf_name);
+		if (uj)
+			vty_json(vty, json);
+		else
+			vty_out(vty, "%% VRF '%s' specified does not exist\n",
+				vrf_name);
 		return CMD_WARNING;
 	}
 
-	show_nexthop_group_cmd_helper(vty, zvrf, afi, type);
+	show_nexthop_group_cmd_helper(vty, zvrf, afi, type, json);
+
+	if (uj)
+		vty_json(vty, json);
 
 	return CMD_SUCCESS;
 }
@@ -1991,7 +1878,7 @@ DEFPY (show_route_detail,
 	 [json$json] [nexthop-group$ng]",
        SHOW_STR
        IP_STR
-       "IPv6 forwarding table\n"
+       "IP forwarding table\n"
        "IP routing table\n"
        VRF_FULL_CMD_HELP_STR
        "Network in the IP routing table to display\n"
@@ -2952,11 +2839,11 @@ DEFUN (no_vrf_vni_mapping,
 }
 
 /* show vrf */
-DEFUN (show_vrf_vni,
+DEFPY (show_vrf_vni,
        show_vrf_vni_cmd,
-       "show vrf vni [json]",
+       "show vrf [<NAME$vrf_name|all$vrf_all>] vni [json]",
        SHOW_STR
-       "VRF\n"
+       VRF_FULL_CMD_HELP_STR
        "VNI\n"
        JSON_STR)
 {
@@ -2965,20 +2852,69 @@ DEFUN (show_vrf_vni,
 	json_object *json = NULL;
 	json_object *json_vrfs = NULL;
 	bool uj = use_json(argc, argv);
+	bool use_vrf = false;
 
-	if (uj) {
+	if (uj)
 		json = json_object_new_object();
-		json_vrfs = json_object_new_array();
+
+	/* show vrf vni used to display across all vrfs
+	 * This is enhanced to support only for specific
+	 * vrf based output.
+	 */
+	if (vrf_all || !vrf_name) {
+		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+			zvrf = vrf->info;
+			if (!zvrf)
+				continue;
+
+			use_vrf = true;
+			break;
+		}
+		if (use_vrf) {
+			if (!uj)
+				vty_out(vty,
+					"%-37s %-10s %-20s %-20s %-5s %-18s\n",
+					"VRF", "VNI", "VxLAN IF", "L3-SVI",
+					"State", "Rmac");
+			else
+				json_vrfs = json_object_new_array();
+		} else {
+			if (uj)
+				vty_json(vty, json);
+			else
+				vty_out(vty, "%% VRF does not exist\n");
+
+			return CMD_WARNING;
+		}
 	}
 
-	if (!uj)
-		vty_out(vty, "%-37s %-10s %-20s %-20s %-5s %-18s\n", "VRF",
-			"VNI", "VxLAN IF", "L3-SVI", "State", "Rmac");
+	if (use_vrf) {
+		RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
+			zvrf = vrf->info;
+			if (!zvrf)
+				continue;
 
-	RB_FOREACH (vrf, vrf_name_head, &vrfs_by_name) {
-		zvrf = vrf->info;
-		if (!zvrf)
-			continue;
+			zebra_vxlan_print_vrf_vni(vty, zvrf, json_vrfs);
+		}
+	} else if (vrf_name) {
+		zvrf = zebra_vrf_lookup_by_name(vrf_name);
+		if (!zvrf) {
+			if (uj)
+				vty_json(vty, json);
+			else
+				vty_out(vty,
+					"%% VRF '%s' specified does not exist\n",
+					vrf_name);
+
+			return CMD_WARNING;
+		}
+
+		if (!uj)
+			vty_out(vty, "%-37s %-10s %-20s %-20s %-5s %-18s\n",
+				"VRF", "VNI", "VxLAN IF", "L3-SVI", "State",
+				"Rmac");
+		else
+			json_vrfs = json_object_new_array();
 
 		zebra_vxlan_print_vrf_vni(vty, zvrf, json_vrfs);
 	}
@@ -3294,7 +3230,26 @@ DEFUN (show_evpn_mac_vni,
 
 	vni = strtoul(argv[4]->arg, NULL, 10);
 	zvrf = zebra_vrf_get_evpn();
-	zebra_vxlan_print_macs_vni(vty, zvrf, vni, uj);
+	zebra_vxlan_print_macs_vni(vty, zvrf, vni, uj, false);
+	return CMD_SUCCESS;
+}
+
+DEFPY (show_evpn_mac_vni_detail,
+       show_evpn_mac_vni_detail_cmd,
+       "show evpn mac vni " CMD_VNI_RANGE " detail [json]",
+       SHOW_STR
+       "EVPN\n"
+       "MAC addresses\n"
+       "VXLAN Network Identifier\n"
+       "VNI number\n"
+       "Detailed Information On Each VNI MAC\n"
+       JSON_STR)
+{
+	struct zebra_vrf *zvrf;
+	bool uj = use_json(argc, argv);
+
+	zvrf = zebra_vrf_get_evpn();
+	zebra_vxlan_print_macs_vni(vty, zvrf, vni, uj, true);
 	return CMD_SUCCESS;
 }
 
@@ -3740,6 +3695,27 @@ DEFPY (clear_evpn_dup_addr,
 	return ret;
 }
 
+DEFPY_HIDDEN (evpn_accept_bgp_seq,
+              evpn_accept_bgp_seq_cmd,
+              "evpn accept-bgp-seq",
+              "EVPN\n"
+	      "Accept all sequence numbers from BGP\n")
+{
+	zebra_vxlan_set_accept_bgp_seq(true);
+	return CMD_SUCCESS;
+}
+
+DEFPY_HIDDEN (no_evpn_accept_bgp_seq,
+              no_evpn_accept_bgp_seq_cmd,
+              "no evpn accept-bgp-seq",
+              NO_STR
+              "EVPN\n"
+	      "Accept all sequence numbers from BGP\n")
+{
+	zebra_vxlan_set_accept_bgp_seq(false);
+	return CMD_SUCCESS;
+}
+
 /* Static ip route configuration write function. */
 static int zebra_ip_config(struct vty *vty)
 {
@@ -3945,6 +3921,9 @@ static int config_write_protocol(struct
 
 	zebra_pbr_config_write(vty);
 
+	if (!zebra_vxlan_get_accept_bgp_seq())
+		vty_out(vty, "no evpn accept-bgp-seq\n");
+
 	/* Include nexthop-group config */
 	if (!zebra_nhg_kernel_nexthops_enabled())
 		vty_out(vty, "no zebra nexthop kernel enable\n");
@@ -3999,6 +3978,15 @@ DEFUN (show_zebra,
 	ttable_add_row(table, "ASIC offload|%s",
 		       zrouter.asic_offloaded ? "Used" : "Unavailable");
 
+	/*
+	 * Do not display this unless someone is actually using it
+	 *
+	 * Why this distinction?  I think this is effectively dead code
+	 * and should not be exposed.  Maybe someone proves me wrong.
+	 */
+	if (zrouter.asic_notification_nexthop_control)
+		ttable_add_row(table, "ASIC offload and nexthop control|Used");
+
 	ttable_add_row(table, "RA|%s",
 		       rtadv_compiled_in() ? "Compiled in" : "Not Compiled in");
 	ttable_add_row(table, "RFC 5549|%s",
@@ -4569,6 +4557,7 @@ void zebra_vty_init(void)
 	install_element(VIEW_NODE, &show_evpn_mac_vni_cmd);
 	install_element(VIEW_NODE, &show_evpn_mac_vni_all_cmd);
 	install_element(VIEW_NODE, &show_evpn_mac_vni_all_detail_cmd);
+	install_element(VIEW_NODE, &show_evpn_mac_vni_detail_cmd);
 	install_element(VIEW_NODE, &show_evpn_mac_vni_all_vtep_cmd);
 	install_element(VIEW_NODE, &show_evpn_mac_vni_mac_cmd);
 	install_element(VIEW_NODE, &show_evpn_mac_vni_vtep_cmd);
@@ -4582,6 +4571,8 @@ void zebra_vty_init(void)
 	install_element(VIEW_NODE, &show_evpn_neigh_vni_dad_cmd);
 	install_element(VIEW_NODE, &show_evpn_neigh_vni_all_dad_cmd);
 	install_element(ENABLE_NODE, &clear_evpn_dup_addr_cmd);
+	install_element(CONFIG_NODE, &evpn_accept_bgp_seq_cmd);
+	install_element(CONFIG_NODE, &no_evpn_accept_bgp_seq_cmd);
 
 	install_element(VIEW_NODE, &show_neigh_cmd);
 
diff -urpN frr-frr-8.4.2/zebra/zebra_vxlan.c frr-frr-8.5/zebra/zebra_vxlan.c
--- frr-frr-8.4.2/zebra/zebra_vxlan.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_vxlan.c	2023-03-13 20:01:47.000000000 +0600
@@ -69,6 +69,9 @@ DEFINE_HOOK(zebra_rmac_update,
 	     const char *reason),
 	    (rmac, zl3vni, delete, reason));
 
+/* config knobs */
+static bool accept_bgp_seq = true;
+
 /* static function declarations */
 static void zevpn_print_neigh_hash_all_evpn(struct hash_bucket *bucket,
 					    void **args);
@@ -2866,7 +2869,7 @@ void zebra_vxlan_print_neigh_vni_dad(str
  * Display MACs for a VNI (VTY command handler).
  */
 void zebra_vxlan_print_macs_vni(struct vty *vty, struct zebra_vrf *zvrf,
-				vni_t vni, bool use_json)
+				vni_t vni, bool use_json, bool detail)
 {
 	struct zebra_evpn *zevpn;
 	uint32_t num_macs;
@@ -2899,17 +2902,28 @@ void zebra_vxlan_print_macs_vni(struct v
 	wctx.json = json_mac;
 
 	if (!use_json) {
-		vty_out(vty,
-			"Number of MACs (local and remote) known for this VNI: %u\n",
-			num_macs);
-		vty_out(vty,
-			"Flags: N=sync-neighs, I=local-inactive, P=peer-active, X=peer-proxy\n");
-		vty_out(vty, "%-17s %-6s %-5s %-30s %-5s %s\n", "MAC", "Type",
-			"Flags", "Intf/Remote ES/VTEP", "VLAN", "Seq #'s");
+		if (detail) {
+			vty_out(vty, "\nVNI %u #MACs (local and remote) %u\n\n",
+				zevpn->vni, num_macs);
+		} else {
+			vty_out(vty,
+				"Number of MACs (local and remote) known for this VNI: %u\n",
+				num_macs);
+			vty_out(vty,
+				"Flags: N=sync-neighs, I=local-inactive, P=peer-active, X=peer-proxy\n");
+			vty_out(vty, "%-17s %-6s %-5s %-30s %-5s %s\n", "MAC",
+				"Type", "Flags", "Intf/Remote ES/VTEP", "VLAN",
+				"Seq #'s");
+		}
 	} else
 		json_object_int_add(json, "numMacs", num_macs);
 
-	hash_iterate(zevpn->mac_table, zebra_evpn_print_mac_hash, &wctx);
+	if (detail)
+		hash_iterate(zevpn->mac_table, zebra_evpn_print_mac_hash_detail,
+			     &wctx);
+	else
+		hash_iterate(zevpn->mac_table, zebra_evpn_print_mac_hash,
+			     &wctx);
 
 	if (use_json) {
 		json_object_object_add(json, "macs", json_mac);
@@ -3508,6 +3522,12 @@ void zebra_vxlan_print_evpn(struct vty *
 		json = json_object_new_object();
 		json_object_string_add(json, "advertiseGatewayMacip",
 				       zvrf->advertise_gw_macip ? "Yes" : "No");
+		json_object_string_add(json, "advertiseSviMacip",
+				       zvrf->advertise_svi_macip ? "Yes"
+								 : "No");
+		json_object_string_add(json, "advertiseSviMac",
+				       zebra_evpn_mh_do_adv_svi_mac() ? "Yes"
+								      : "No");
 		json_object_int_add(json, "numVnis", num_vnis);
 		json_object_int_add(json, "numL2Vnis", num_l2vnis);
 		json_object_int_add(json, "numL3Vnis", num_l3vnis);
@@ -5534,6 +5554,7 @@ void zebra_vxlan_advertise_svi_macip(ZAP
 		struct zebra_if *zif = NULL;
 		struct zebra_l2info_vxlan zl2_info;
 		struct interface *vlan_if = NULL;
+		int old_advertise;
 
 		zevpn = zebra_evpn_lookup(vni);
 		if (!zevpn)
@@ -5541,19 +5562,20 @@ void zebra_vxlan_advertise_svi_macip(ZAP
 
 		if (IS_ZEBRA_DEBUG_VXLAN)
 			zlog_debug(
-				"EVPN SVI macip Adv %s on VNI %d , currently %s",
+				"EVPN SVI macip Adv %s on VNI %d, currently %s",
 				advertise ? "enabled" : "disabled", vni,
 				advertise_svi_macip_enabled(zevpn)
 					? "enabled"
 					: "disabled");
 
-		if (zevpn->advertise_svi_macip == advertise)
-			return;
+		old_advertise = advertise_svi_macip_enabled(zevpn);
 
 		/* Store flag even though SVI is not present.
 		 * Once SVI comes up triggers self MAC-IP route add.
 		 */
 		zevpn->advertise_svi_macip = advertise;
+		if (advertise_svi_macip_enabled(zevpn) == old_advertise)
+			return;
 
 		ifp = zevpn->vxlan_if;
 		if (!ifp)
@@ -5617,7 +5639,7 @@ void zebra_vxlan_advertise_subnet(ZAPI_H
 		return;
 
 	if (IS_ZEBRA_DEBUG_VXLAN)
-		zlog_debug("EVPN subnet Adv %s on VNI %d , currently %s",
+		zlog_debug("EVPN subnet Adv %s on VNI %d, currently %s",
 			   advertise ? "enabled" : "disabled", vni,
 			   zevpn->advertise_subnet ? "enabled" : "disabled");
 
@@ -5699,6 +5721,7 @@ void zebra_vxlan_advertise_gw_macip(ZAPI
 		struct zebra_l2info_vxlan zl2_info;
 		struct interface *vlan_if = NULL;
 		struct interface *vrr_if = NULL;
+		int old_advertise;
 
 		zevpn = zebra_evpn_lookup(vni);
 		if (!zevpn)
@@ -5706,15 +5729,16 @@ void zebra_vxlan_advertise_gw_macip(ZAPI
 
 		if (IS_ZEBRA_DEBUG_VXLAN)
 			zlog_debug(
-				"EVPN gateway macip Adv %s on VNI %d , currently %s",
+				"EVPN gateway macip Adv %s on VNI %d, currently %s",
 				advertise ? "enabled" : "disabled", vni,
 				advertise_gw_macip_enabled(zevpn) ? "enabled"
-								 : "disabled");
+								  : "disabled");
 
-		if (zevpn->advertise_gw_macip == advertise)
-			return;
+		old_advertise = advertise_gw_macip_enabled(zevpn);
 
 		zevpn->advertise_gw_macip = advertise;
+		if (advertise_gw_macip_enabled(zevpn) == old_advertise)
+			return;
 
 		ifp = zevpn->vxlan_if;
 		if (!ifp)
@@ -6284,6 +6308,17 @@ extern void zebra_vxlan_handle_result(st
 	return;
 }
 
+/* Config knob for accepting lower sequence numbers */
+void zebra_vxlan_set_accept_bgp_seq(bool set)
+{
+	accept_bgp_seq = set;
+}
+
+bool zebra_vxlan_get_accept_bgp_seq(void)
+{
+	return accept_bgp_seq;
+}
+
 /* Cleanup BGP EVPN configuration upon client disconnect */
 extern void zebra_evpn_init(void)
 {
diff -urpN frr-frr-8.4.2/zebra/zebra_vxlan.h frr-frr-8.5/zebra/zebra_vxlan.h
--- frr-frr-8.4.2/zebra/zebra_vxlan.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zebra_vxlan.h	2023-03-13 20:01:47.000000000 +0600
@@ -95,7 +95,7 @@ extern void zebra_vxlan_print_specific_r
 						  struct ethaddr *rmac,
 						  bool use_json);
 extern void zebra_vxlan_print_macs_vni(struct vty *vty, struct zebra_vrf *zvrf,
-				       vni_t vni, bool use_json);
+				       vni_t vni, bool use_json, bool detail);
 extern void zebra_vxlan_print_macs_all_vni(struct vty *vty,
 					   struct zebra_vrf *zvrf,
 					   bool print_dup,
@@ -225,6 +225,9 @@ extern int zebra_vxlan_dp_network_mac_de
 					  struct ethaddr *macaddr,
 					  vlanid_t vid);
 
+extern void zebra_vxlan_set_accept_bgp_seq(bool set);
+extern bool zebra_vxlan_get_accept_bgp_seq(void);
+
 #ifdef __cplusplus
 }
 #endif
diff -urpN frr-frr-8.4.2/zebra/zserv.c frr-frr-8.5/zebra/zserv.c
--- frr-frr-8.4.2/zebra/zserv.c	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zserv.c	2023-03-13 20:01:47.000000000 +0600
@@ -78,6 +78,8 @@ static struct zserv *find_client_interna
 					  unsigned short instance,
 					  uint32_t session_id);
 
+/* Mem type for zclients. */
+DEFINE_MTYPE_STATIC(ZEBRA, ZSERV_CLIENT, "ZClients");
 
 /*
  * Client thread events.
@@ -146,6 +148,14 @@ static void zserv_event(struct zserv *cl
 /* Client thread lifecycle -------------------------------------------------- */
 
 /*
+ * Free a zserv client object.
+ */
+void zserv_client_delete(struct zserv *client)
+{
+	XFREE(MTYPE_ZSERV_CLIENT, client);
+}
+
+/*
  * Log zapi message to zlog.
  *
  * errmsg (optional)
@@ -648,7 +658,7 @@ static void zserv_client_free(struct zse
 		if (IS_ZEBRA_DEBUG_EVENT)
 			zlog_debug("%s: Deleting client %s", __func__,
 				   zebra_route_string(client->proto));
-		XFREE(MTYPE_TMP, client);
+		zserv_client_delete(client);
 	} else {
 		/* Handle cases where client has GR instance. */
 		if (IS_ZEBRA_DEBUG_EVENT)
@@ -737,7 +747,7 @@ static struct zserv *zserv_client_create
 	int i;
 	afi_t afi;
 
-	client = XCALLOC(MTYPE_TMP, sizeof(struct zserv));
+	client = XCALLOC(MTYPE_ZSERV_CLIENT, sizeof(struct zserv));
 
 	/* Make client input/output buffer. */
 	client->sock = sock;
@@ -1036,7 +1046,8 @@ static void zebra_show_client_detail(str
 	} else
 		vty_out(vty, "Not registered for Nexthop Updates\n");
 
-	vty_out(vty, "Client will %sbe notified about it's routes status\n",
+	vty_out(vty,
+		"Client will %sbe notified about the status of its routes.\n",
 		client->notify_owner ? "" : "Not ");
 
 	vty_out(vty, "Last Msg Rx Time: %s \n",
diff -urpN frr-frr-8.4.2/zebra/zserv.h frr-frr-8.5/zebra/zserv.h
--- frr-frr-8.4.2/zebra/zserv.h	2023-01-10 21:02:10.000000000 +0600
+++ frr-frr-8.5/zebra/zserv.h	2023-03-13 20:01:47.000000000 +0600
@@ -369,6 +369,13 @@ extern void zserv_release_client(struct
 extern void zserv_close_client(struct zserv *client);
 
 /*
+ * Free memory for a zserv client object - note that this does not
+ * clean up the internal allocations associated with the zserv client,
+ * this just free the struct's memory.
+ */
+void zserv_client_delete(struct zserv *client);
+
+/*
  * Log a ZAPI message hexdump.
  *
  * errmsg

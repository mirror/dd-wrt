/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_uim_reset_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0000);

	return 0;
}

int qmi_parse_uim_reset_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_get_supported_messages_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x001E);

	return 0;
}

int qmi_parse_uim_get_supported_messages_response(struct qmi_msg *msg, struct qmi_uim_get_supported_messages_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.list = __qmi_alloc_static(i * sizeof(res->data.list[0]));
			while(i-- > 0) {
				res->data.list[res->data.list_n] = *(uint8_t *) get_next(1);
				res->data.list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_read_transparent_request(struct qmi_msg *msg, struct qmi_uim_read_transparent_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0020);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.read_information) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.read_information.offset), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.read_information.length), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x03, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.encrypt_data) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.encrypt_data, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_read_transparent_response(struct qmi_msg *msg, struct qmi_uim_read_transparent_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.read_result = __qmi_alloc_static(i * sizeof(res->data.read_result[0]));
			while(i-- > 0) {
				res->data.read_result[res->data.read_result_n] = *(uint8_t *) get_next(1);
				res->data.read_result_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			qmi_set(res, encrypted_data, *(uint8_t *) get_next(1));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_read_record_request(struct qmi_msg *msg, struct qmi_uim_read_record_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0021);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.record) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.record.record_number), 2);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.record.record_length), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x03, ofs, buf);
	}

	if (req->set.last_record) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.last_record), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_read_record_response(struct qmi_msg *msg, struct qmi_uim_read_record_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.read_result = __qmi_alloc_static(i * sizeof(res->data.read_result[0]));
			while(i-- > 0) {
				res->data.read_result[res->data.read_result_n] = *(uint8_t *) get_next(1);
				res->data.read_result_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.additional_read_result = __qmi_alloc_static(i * sizeof(res->data.additional_read_result[0]));
			while(i-- > 0) {
				res->data.additional_read_result[res->data.additional_read_result_n] = *(uint8_t *) get_next(1);
				res->data.additional_read_result_n++;
			}

			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_get_file_attributes_request(struct qmi_msg *msg, struct qmi_uim_get_file_attributes_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0024);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.file) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.file.file_id), 2);
		put_tlv_var(uint8_t, req->data.file.file_path_n, 1);
		for (i = 0; i < req->data.file.file_path_n; i++) {
			put_tlv_var(uint8_t, req->data.file.file_path[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_get_file_attributes_response(struct qmi_msg *msg, struct qmi_uim_get_file_attributes_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			res->set.file_attributes = 1;
			res->data.file_attributes.file_size = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.file_id = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.file_type = *(uint8_t *) get_next(1);
			res->data.file_attributes.record_size = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.record_count = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.read_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.read_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.write_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.write_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.increase_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.increase_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.deactivate_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.deactivate_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.activate_security_attributes_logic = *(uint8_t *) get_next(1);
			res->data.file_attributes.activate_security_attributes = le16_to_cpu(*(uint16_t *) get_next(2));
			i = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.file_attributes.raw_data = __qmi_alloc_static(i * sizeof(res->data.file_attributes.raw_data[0]));
			while(i-- > 0) {
				res->data.file_attributes.raw_data[res->data.file_attributes.raw_data_n] = *(uint8_t *) get_next(1);
				res->data.file_attributes.raw_data_n++;
			}
			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_set_pin_protection_request(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0025);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		put_tlv_var(uint8_t, req->data.info.pin_enabled, 1);
		i = strlen(req->data.info.pin_value);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin_value, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_set_pin_protection_response(struct qmi_msg *msg, struct qmi_uim_set_pin_protection_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_verify_pin_request(struct qmi_msg *msg, struct qmi_uim_verify_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0026);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.pin_value);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.pin_value, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x12, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_verify_pin_response(struct qmi_msg *msg, struct qmi_uim_verify_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_unblock_pin_request(struct qmi_msg *msg, struct qmi_uim_unblock_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0027);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.puk);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.puk, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_unblock_pin_response(struct qmi_msg *msg, struct qmi_uim_unblock_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_change_pin_request(struct qmi_msg *msg, struct qmi_uim_change_pin_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0028);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.pin_id, 1);
		i = strlen(req->data.info.old_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.old_pin, i);
		i = strlen(req->data.info.new_pin);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.new_pin, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	if (req->set.response_in_indication_token) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.response_in_indication_token), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x11, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_change_pin_response(struct qmi_msg *msg, struct qmi_uim_change_pin_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_retries_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_retries_left = *(uint8_t *) get_next(1);
			break;

		case 0x12:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			qmi_set(res, response_in_indication_token, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		case 0x13:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			res->set.card_result = 1;
			res->data.card_result.sw1 = *(uint8_t *) get_next(1);
			res->data.card_result.sw2 = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_refresh_register_request(struct qmi_msg *msg, struct qmi_uim_refresh_register_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x002A);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.register_flag, 1);
		put_tlv_var(uint8_t, req->data.info.vote_for_init, 1);
		put_tlv_var(uint16_t, cpu_to_le16(req->data.info.files_n), 2);
		for (i = 0; i < req->data.info.files_n; i++) {
			unsigned int ii;
			put_tlv_var(uint16_t, cpu_to_le16(req->data.info.files[i].file_id), 2);
			put_tlv_var(uint8_t, req->data.info.files[i].path_n, 1);
			for (ii = 0; ii < req->data.info.files[i].path_n; ii++) {
				put_tlv_var(uint8_t, req->data.info.files[i].path[ii], 1);
			}
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_refresh_register_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_refresh_complete_request(struct qmi_msg *msg, struct qmi_uim_refresh_complete_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x002C);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.refresh_success, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_refresh_complete_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_register_events_request(struct qmi_msg *msg, struct qmi_uim_register_events_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x002E);

	if (req->set.event_registration_mask) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.event_registration_mask), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_register_events_response(struct qmi_msg *msg, struct qmi_uim_register_events_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, event_registration_mask, le32_to_cpu(*(uint32_t *) get_next(4)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_get_card_status_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x002F);

	return 0;
}

int qmi_parse_uim_get_card_status_response(struct qmi_msg *msg, struct qmi_uim_get_card_status_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.card_status = 1;
			res->data.card_status.index_gw_primary = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_1x_primary = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_gw_secondary = le16_to_cpu(*(uint16_t *) get_next(2));
			res->data.card_status.index_1x_secondary = le16_to_cpu(*(uint16_t *) get_next(2));
			i = *(uint8_t *) get_next(1);
			res->data.card_status.cards = __qmi_alloc_static(i * sizeof(res->data.card_status.cards[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.card_status.cards[res->data.card_status.cards_n].card_state = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upin_state = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upin_retries = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].upuk_retries = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].error_code = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.card_status.cards[res->data.card_status.cards_n].applications = __qmi_alloc_static(ii * sizeof(res->data.card_status.cards[res->data.card_status.cards_n].applications[0]));
				while(ii-- > 0) {
					unsigned int iii;
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].type = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_feature = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].personalization_unblock_retries = *(uint8_t *) get_next(1);
					iii = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value = __qmi_alloc_static(iii * sizeof(res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value[0]));
					while(iii-- > 0) {
						res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value[res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value_n] = *(uint8_t *) get_next(1);
						res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].application_identifier_value_n++;
					}
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].upin_replaces_pin1 = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin1_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin1_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].puk1_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin2_state = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].pin2_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications[res->data.card_status.cards[res->data.card_status.cards_n].applications_n].puk2_retries = *(uint8_t *) get_next(1);
					res->data.card_status.cards[res->data.card_status.cards_n].applications_n++;
				}
				res->data.card_status.cards_n++;
			}
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_power_off_sim_request(struct qmi_msg *msg, struct qmi_uim_power_off_sim_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0030);

	if (req->set.slot) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.slot, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_power_off_sim_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_power_on_sim_request(struct qmi_msg *msg, struct qmi_uim_power_on_sim_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0031);

	if (req->set.slot) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.slot, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_power_on_sim_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_change_provisioning_session_request(struct qmi_msg *msg, struct qmi_uim_change_provisioning_session_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0038);

	if (req->set.session_change) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session_change.session_type, 1);
		put_tlv_var(uint8_t, req->data.session_change.activate, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.application_information) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.application_information.slot, 1);
		put_tlv_var(uint8_t, req->data.application_information.application_identifier_n, 1);
		for (i = 0; i < req->data.application_information.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.application_information.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_change_provisioning_session_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_depersonalization_request(struct qmi_msg *msg, struct qmi_uim_depersonalization_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0029);

	if (req->set.info) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.feature, 1);
		put_tlv_var(uint8_t, req->data.info.operation, 1);
		i = strlen(req->data.info.control_key);
		put_tlv_var(uint8_t, i, 1);
		strncpy(__qmi_alloc_static(i), req->data.info.control_key, i);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.slot) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.slot, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_depersonalization_response(struct qmi_msg *msg, struct qmi_uim_depersonalization_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.retries_remaining = 1;
			res->data.retries_remaining.verify_left = *(uint8_t *) get_next(1);
			res->data.retries_remaining.unblock_left = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_get_configuration_request(struct qmi_msg *msg, struct qmi_uim_get_configuration_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x003A);

	if (req->set.configuration_mask) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.configuration_mask), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_get_configuration_response(struct qmi_msg *msg, struct qmi_uim_get_configuration_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, automatic_selection, *(uint8_t *) get_next(1));
			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = *(uint8_t *) get_next(1);
			res->data.personalization_status = __qmi_alloc_static(i * sizeof(res->data.personalization_status[0]));
			while(i-- > 0) {
				res->data.personalization_status[res->data.personalization_status_n].feature = *(uint8_t *) get_next(1);
				res->data.personalization_status[res->data.personalization_status_n].verify_left = *(uint8_t *) get_next(1);
				res->data.personalization_status[res->data.personalization_status_n].unblock_left = *(uint8_t *) get_next(1);
				res->data.personalization_status_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			qmi_set(res, halt_subscription, *(uint8_t *) get_next(1));
			break;

		case 0x13:
			if (found[0] & (1 << 4))
				break;

			found[0] |= (1 << 4);
			i = *(uint8_t *) get_next(1);
			res->data.personalization_status_other_slots = __qmi_alloc_static(i * sizeof(res->data.personalization_status_other_slots[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.personalization_status_other_slots_i = 0;
				ii = *(uint8_t *) get_next(1);
				res->data.personalization_status_other_slots[res->data.personalization_status_other_slots_n] = __qmi_alloc_static(ii * sizeof(res->data.personalization_status_other_slots[res->data.personalization_status_other_slots_n][0]));
				while(ii-- > 0) {
					res->data.personalization_status_other_slots[res->data.personalization_status_other_slots_n][res->data.personalization_status_other_slots_i].feature = *(uint8_t *) get_next(1);
					res->data.personalization_status_other_slots[res->data.personalization_status_other_slots_n][res->data.personalization_status_other_slots_i].verify_left = *(uint8_t *) get_next(1);
					res->data.personalization_status_other_slots[res->data.personalization_status_other_slots_n][res->data.personalization_status_other_slots_i].unblock_left = *(uint8_t *) get_next(1);
					res->data.personalization_status_other_slots_i++;
				}
				res->data.personalization_status_other_slots_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_uim_refresh_register_all_request(struct qmi_msg *msg, struct qmi_uim_refresh_register_all_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0044);

	if (req->set.session) {
		void *buf;
		unsigned int ofs;
		unsigned int i;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.session.session_type, 1);
		put_tlv_var(uint8_t, req->data.session.application_identifier_n, 1);
		for (i = 0; i < req->data.session.application_identifier_n; i++) {
			put_tlv_var(uint8_t, req->data.session.application_identifier[i], 1);
		}

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.info.register_flag, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_refresh_register_all_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_switch_slot_request(struct qmi_msg *msg, struct qmi_uim_switch_slot_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0046);

	if (req->set.logical_slot) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.logical_slot, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.physical_slot) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.physical_slot), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x02, ofs, buf);
	}

	return 0;
}

int qmi_parse_uim_switch_slot_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}

int qmi_set_uim_get_slot_status_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_UIM);
	msg->svc.message = cpu_to_le16(0x0047);

	return 0;
}

int qmi_parse_uim_get_slot_status_response(struct qmi_msg *msg, struct qmi_uim_get_slot_status_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.physical_slot_status = __qmi_alloc_static(i * sizeof(res->data.physical_slot_status[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.physical_slot_status[res->data.physical_slot_status_n].physical_card_status = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.physical_slot_status[res->data.physical_slot_status_n].physical_slot_status = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.physical_slot_status[res->data.physical_slot_status_n].logical_slot = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.physical_slot_status[res->data.physical_slot_status_n].iccid = __qmi_alloc_static(ii * sizeof(res->data.physical_slot_status[res->data.physical_slot_status_n].iccid[0]));
				while(ii-- > 0) {
					res->data.physical_slot_status[res->data.physical_slot_status_n].iccid[res->data.physical_slot_status[res->data.physical_slot_status_n].iccid_n] = *(uint8_t *) get_next(1);
					res->data.physical_slot_status[res->data.physical_slot_status_n].iccid_n++;
				}
				res->data.physical_slot_status_n++;
			}

			break;

		case 0x11:
			if (found[0] & (1 << 2))
				break;

			found[0] |= (1 << 2);
			i = *(uint8_t *) get_next(1);
			res->data.physical_slot_information = __qmi_alloc_static(i * sizeof(res->data.physical_slot_information[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.physical_slot_information[res->data.physical_slot_information_n].card_protocol = le32_to_cpu(*(uint32_t *) get_next(4));
				res->data.physical_slot_information[res->data.physical_slot_information_n].valid_applications = *(uint8_t *) get_next(1);
				ii = *(uint8_t *) get_next(1);
				res->data.physical_slot_information[res->data.physical_slot_information_n].atr_value = __qmi_alloc_static(ii * sizeof(res->data.physical_slot_information[res->data.physical_slot_information_n].atr_value[0]));
				while(ii-- > 0) {
					res->data.physical_slot_information[res->data.physical_slot_information_n].atr_value[res->data.physical_slot_information[res->data.physical_slot_information_n].atr_value_n] = *(uint8_t *) get_next(1);
					res->data.physical_slot_information[res->data.physical_slot_information_n].atr_value_n++;
				}
				res->data.physical_slot_information[res->data.physical_slot_information_n].is_euicc = *(uint8_t *) get_next(1);
				res->data.physical_slot_information_n++;
			}

			break;

		case 0x12:
			if (found[0] & (1 << 3))
				break;

			found[0] |= (1 << 3);
			i = *(uint8_t *) get_next(1);
			res->data.slot_eid_information = __qmi_alloc_static(i * sizeof(res->data.slot_eid_information[0]));
			while(i-- > 0) {
				unsigned int ii;
				res->data.slot_eid_information_i = 0;
				ii = *(uint8_t *) get_next(1);
				res->data.slot_eid_information[res->data.slot_eid_information_n] = __qmi_alloc_static(ii * sizeof(res->data.slot_eid_information[res->data.slot_eid_information_n][0]));
				while(ii-- > 0) {
					res->data.slot_eid_information[res->data.slot_eid_information_n][res->data.slot_eid_information_i] = *(uint8_t *) get_next(1);
					res->data.slot_eid_information_i++;
				}
				res->data.slot_eid_information_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}


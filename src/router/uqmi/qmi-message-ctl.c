/* generated by uqmi gen-code.pl */
#include <stdio.h>
#include <string.h>
#include "qmi-message.h"

#define get_next(_size) ({ void *_buf = &tlv->data[ofs]; ofs += _size; if (ofs > cur_tlv_len) goto error_len; _buf; })
#define copy_tlv(_val, _size) \
	do { \
		unsigned int __size = _size; \
		if (__size > 0) \
			memcpy(__qmi_alloc_static(__size), _val, __size); \
	} while (0);

#define put_tlv_var(_type, _val, _size) \
	do { \
		_type __var = _val; \
		copy_tlv(&__var, _size); \
	} while(0)

int qmi_set_ctl_set_instance_id_request(struct qmi_msg *msg, struct qmi_ctl_set_instance_id_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0020);

	if (req->set.id) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.id, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_ctl_set_instance_id_response(struct qmi_msg *msg, struct qmi_ctl_set_instance_id_response *res)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, link_id, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_ctl_get_version_info_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0021);

	return 0;
}

int qmi_parse_ctl_get_version_info_response(struct qmi_msg *msg, struct qmi_ctl_get_version_info_response *res)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			i = *(uint8_t *) get_next(1);
			res->data.service_list = __qmi_alloc_static(i * sizeof(res->data.service_list[0]));
			while(i-- > 0) {
				res->data.service_list[res->data.service_list_n].service = *(uint8_t *) get_next(1);
				res->data.service_list[res->data.service_list_n].major_version = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.service_list[res->data.service_list_n].minor_version = le16_to_cpu(*(uint16_t *) get_next(2));
				res->data.service_list_n++;
			}

			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_ctl_allocate_cid_request(struct qmi_msg *msg, struct qmi_ctl_allocate_cid_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0022);

	if (req->set.service) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.service, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_ctl_allocate_cid_response(struct qmi_msg *msg, struct qmi_ctl_allocate_cid_response *res)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.allocation_info = 1;
			res->data.allocation_info.service = *(uint8_t *) get_next(1);
			res->data.allocation_info.cid = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_ctl_release_cid_request(struct qmi_msg *msg, struct qmi_ctl_release_cid_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0023);

	if (req->set.release_info) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.release_info.service, 1);
		put_tlv_var(uint8_t, req->data.release_info.cid, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	return 0;
}

int qmi_parse_ctl_release_cid_response(struct qmi_msg *msg, struct qmi_ctl_release_cid_response *res)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.release_info = 1;
			res->data.release_info.service = *(uint8_t *) get_next(1);
			res->data.release_info.cid = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_ctl_set_data_format_request(struct qmi_msg *msg, struct qmi_ctl_set_data_format_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0026);

	if (req->set.format) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint8_t, req->data.format, 1);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x01, ofs, buf);
	}

	if (req->set.protocol) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint16_t, cpu_to_le16(req->data.protocol), 2);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}

int qmi_parse_ctl_set_data_format_response(struct qmi_msg *msg, struct qmi_ctl_set_data_format_response *res)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x10:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			qmi_set(res, protocol, le16_to_cpu(*(uint16_t *) get_next(2)));
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}

int qmi_set_ctl_sync_request(struct qmi_msg *msg)
{
	qmi_init_request_message(msg, QMI_SERVICE_CTL);
	msg->ctl.message = cpu_to_le16(0x0027);

	return 0;
}

int qmi_parse_ctl_sync_response(struct qmi_msg *msg)
{
	void *tlv_buf = &msg->ctl.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->ctl.tlv_len);

	return qmi_check_message_status(tlv_buf, tlv_len);
}


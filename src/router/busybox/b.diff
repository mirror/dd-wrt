diff -urpN busybox-1.33.1/0003-httpd-fix-offset-for-sendfile.patch busybox-1.34.0/0003-httpd-fix-offset-for-sendfile.patch
--- busybox-1.33.1/0003-httpd-fix-offset-for-sendfile.patch	2021-03-09 06:23:30.000000000 +0700
+++ busybox-1.34.0/0003-httpd-fix-offset-for-sendfile.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,48 +0,0 @@
-From 04e0d8e579b289178b0303a92c705012237f4ca3 Mon Sep 17 00:00:00 2001
-From: Maxim Storchak <m.storchak@gmail.com>
-Date: Tue, 29 Dec 2020 17:29:05 +0200
-Subject: [PATCH 03/65] httpd: fix offset for sendfile
-
-If the Range: header is not present it the request,
-the offset passed to sendfile is wrong,
-and httpd falls back to the read-write loop.
-
-function                                             old     new   delta
-send_file_and_exit                                   857     865      +8
-handle_incoming_and_exit                            2239    2230      -9
-------------------------------------------------------------------------------
-(add/remove: 0/0 grow/shrink: 1/1 up/down: 8/-9)               Total: -1 bytes
-
-Signed-off-by: Maxim Storchak <m.storchak@gmail.com>
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- networking/httpd.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
-diff --git a/networking/httpd.c b/networking/httpd.c
-index 4346141ee..4c014bc71 100644
---- a/networking/httpd.c
-+++ b/networking/httpd.c
-@@ -1871,7 +1871,7 @@ static NOINLINE void send_file_and_exit(const char *url, int what)
- 		send_headers(HTTP_OK);
- #if ENABLE_FEATURE_USE_SENDFILE
- 	{
--		off_t offset = range_start;
-+		off_t offset = (range_start < 0) ? 0 : range_start;
- 		while (1) {
- 			/* sz is rounded down to 64k */
- 			ssize_t sz = MAXINT(ssize_t) - 0xffff;
-@@ -2486,8 +2486,8 @@ static void handle_incoming_and_exit(const len_and_sockaddr *fromAddr)
- 		if (STRNCASECMP(iobuf, "Range:") == 0) {
- 			/* We know only bytes=NNN-[MMM] */
- 			char *s = skip_whitespace(iobuf + sizeof("Range:")-1);
--			if (is_prefixed_with(s, "bytes=")) {
--				s += sizeof("bytes=")-1;
-+			s = is_prefixed_with(s, "bytes=");
-+			if (s) {
- 				range_start = BB_STRTOOFF(s, &s, 10);
- 				if (s[0] != '-' || range_start < 0) {
- 					range_start = -1;
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0011-ash-make-a-strdup-copy-of-HISTFILE-for-line-editing.patch busybox-1.34.0/0011-ash-make-a-strdup-copy-of-HISTFILE-for-line-editing.patch
--- busybox-1.33.1/0011-ash-make-a-strdup-copy-of-HISTFILE-for-line-editing.patch	2021-03-09 06:23:30.000000000 +0700
+++ busybox-1.34.0/0011-ash-make-a-strdup-copy-of-HISTFILE-for-line-editing.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,40 +0,0 @@
-From 3f8ec00b0c54790283cfec675716ef4b8e00bd8a Mon Sep 17 00:00:00 2001
-From: Denys Vlasenko <vda.linux@googlemail.com>
-Date: Sun, 3 Jan 2021 10:55:39 +0100
-Subject: [PATCH 11/65] ash: make a strdup copy of $HISTFILE for line editing
-
-Otherwise if $HISTFILE is unset or reassigned, bad things can happen.
-
-function                                             old     new   delta
-ash_main                                            1210    1218      +8
-
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- shell/ash.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/shell/ash.c b/shell/ash.c
-index 54f004375..f9d59e50e 100644
---- a/shell/ash.c
-+++ b/shell/ash.c
-@@ -14499,7 +14499,7 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
- 
- 	if (sflag || minusc == NULL) {
- #if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY
--		if (iflag) {
-+		if (line_input_state) {
- 			const char *hp = lookupvar("HISTFILE");
- 			if (!hp) {
- 				hp = lookupvar("HOME");
-@@ -14513,7 +14513,7 @@ int ash_main(int argc UNUSED_PARAM, char **argv)
- 				}
- 			}
- 			if (hp)
--				line_input_state->hist_file = hp;
-+				line_input_state->hist_file = xstrdup(hp);
- # if ENABLE_FEATURE_SH_HISTFILESIZE
- 			hp = lookupvar("HISTFILESIZE");
- 			line_input_state->max_history = size_from_HISTFILESIZE(hp);
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0030-ash-fix-unset_var-pattern-repl.patch busybox-1.34.0/0030-ash-fix-unset_var-pattern-repl.patch
--- busybox-1.33.1/0030-ash-fix-unset_var-pattern-repl.patch	2021-05-04 01:02:47.000000000 +0700
+++ busybox-1.34.0/0030-ash-fix-unset_var-pattern-repl.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,50 +0,0 @@
-From 883cdb79a440d0425766f67aaef0cabde0a5060e Mon Sep 17 00:00:00 2001
-From: Denys Vlasenko <vda.linux@googlemail.com>
-Date: Sat, 9 Jan 2021 08:27:37 +0100
-Subject: [PATCH 030/187] ash: fix ${unset_var/pattern/repl}
-
-function                                             old     new   delta
-subevalvar                                          1349    1353      +4
-
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- shell/ash.c                                           | 3 ++-
- shell/ash_test/ash-vars/var_bash_repl_empty_var.right | 1 +
- shell/ash_test/ash-vars/var_bash_repl_empty_var.tests | 2 ++
- 3 files changed, 5 insertions(+), 1 deletion(-)
-
-diff --git a/shell/ash.c b/shell/ash.c
-index 37f9dd71b..76bf39ec2 100644
---- a/shell/ash.c
-+++ b/shell/ash.c
-@@ -7015,7 +7015,8 @@ subevalvar(char *start, char *str, int strloc,
- 	slash_pos = -1;
- 	if (repl) {
- 		slash_pos = expdest - ((char *)stackblock() + strloc);
--		STPUTC('/', expdest);
-+		if (!(flag & EXP_DISCARD))
-+			STPUTC('/', expdest);
- 		//bb_error_msg("repl+1:'%s'", repl + 1);
- 		p = argstr(repl + 1, (flag & EXP_DISCARD) | EXP_TILDE); /* EXP_TILDE: echo "${v/x/~}" expands ~ ! */
- 		*repl = '/';
-diff --git a/shell/ash_test/ash-vars/var_bash_repl_empty_var.right b/shell/ash_test/ash-vars/var_bash_repl_empty_var.right
-index 892916783..cf8f088c1 100644
---- a/shell/ash_test/ash-vars/var_bash_repl_empty_var.right
-+++ b/shell/ash_test/ash-vars/var_bash_repl_empty_var.right
-@@ -1,2 +1,3 @@
- 
-+
- Ok:0
-diff --git a/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests b/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests
-index 73a43d38e..22aaba560 100755
---- a/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests
-+++ b/shell/ash_test/ash-vars/var_bash_repl_empty_var.tests
-@@ -1,3 +1,5 @@
-+unset v
-+echo ${v/*/w}
- v=''
- echo ${v/*/w}
- echo Ok:$?
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0032-update_passwd-fix-context-variable.patch busybox-1.34.0/0032-update_passwd-fix-context-variable.patch
--- busybox-1.33.1/0032-update_passwd-fix-context-variable.patch	2021-03-09 06:23:30.000000000 +0700
+++ busybox-1.34.0/0032-update_passwd-fix-context-variable.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,39 +0,0 @@
-From 808d93c0eca49e0b22056e23d965f0d967433fbb Mon Sep 17 00:00:00 2001
-From: Bernd Kuhls <bernd.kuhls@t-online.de>
-Date: Sun, 10 Jan 2021 13:20:44 +0100
-Subject: [PATCH 32/65] update_passwd: fix context variable
-
-Commit
-https://git.busybox.net/busybox/commit/libbb/update_passwd.c?id=2496616b0a8d1c80cd1416b73a4847b59b9f969a
-
-changed the variable used from context to seuser but forgot this
-change resulting in build errors detected by buildroot autobuilders:
-
-http://autobuild.buildroot.net/results/b89/b89b7d0f0601bb706e76cea31cf4e43326e5540c//build-end.log
-
-libbb/update_passwd.c:51:11: error: 'context' undeclared (first use in
- this function); did you mean 'ucontext'?
-   freecon(context);
-
-Signed-off-by: Bernd Kuhls <bernd.kuhls@t-online.de>
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- libbb/update_passwd.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/libbb/update_passwd.c b/libbb/update_passwd.c
-index 7b67f30cd..a228075cc 100644
---- a/libbb/update_passwd.c
-+++ b/libbb/update_passwd.c
-@@ -48,7 +48,7 @@ static void check_selinux_update_passwd(const char *username)
- 			bb_simple_error_msg_and_die("SELinux: access denied");
- 	}
- 	if (ENABLE_FEATURE_CLEAN_UP)
--		freecon(context);
-+		freecon(seuser);
- }
- #else
- # define check_selinux_update_passwd(username) ((void)0)
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0033-traceroute-fix-option-parsing.patch busybox-1.34.0/0033-traceroute-fix-option-parsing.patch
--- busybox-1.33.1/0033-traceroute-fix-option-parsing.patch	2021-03-09 06:23:30.000000000 +0700
+++ busybox-1.34.0/0033-traceroute-fix-option-parsing.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,26 +0,0 @@
-From f3a55b306ed3803133ab028b72b255c65d94197f Mon Sep 17 00:00:00 2001
-From: Denys Vlasenko <vda.linux@googlemail.com>
-Date: Tue, 2 Feb 2021 13:48:21 +0100
-Subject: [PATCH 33/65] traceroute: fix option parsing
-
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- networking/traceroute.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/networking/traceroute.c b/networking/traceroute.c
-index 8f5cd0bf2..057f8591a 100644
---- a/networking/traceroute.c
-+++ b/networking/traceroute.c
-@@ -896,7 +896,7 @@ traceroute_init(int op, char **argv)
- 
- 	op |= getopt32(argv, "^"
- 		OPT_STRING
--		"\0" "-1:x-x" /* minimum 1 arg */
-+		"\0" "-1" /* minimum 1 arg */
- 		, &tos_str, &device, &max_ttl_str, &port_str, &nprobes_str
- 		, &source, &waittime_str, &pausemsecs_str, &first_ttl_str
- 	);
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0070-decompress_gunzip-Fix-DoS-if-gzip-is-corrupt.patch busybox-1.34.0/0070-decompress_gunzip-Fix-DoS-if-gzip-is-corrupt.patch
--- busybox-1.33.1/0070-decompress_gunzip-Fix-DoS-if-gzip-is-corrupt.patch	2021-03-12 16:48:57.000000000 +0700
+++ busybox-1.34.0/0070-decompress_gunzip-Fix-DoS-if-gzip-is-corrupt.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,57 +0,0 @@
-From f25d254dfd4243698c31a4f3153d4ac72aa9e9bd Mon Sep 17 00:00:00 2001
-From: Samuel Sapalski <samuel.sapalski@nokia.com>
-Date: Wed, 3 Mar 2021 16:31:22 +0100
-Subject: [PATCH 70/70] decompress_gunzip: Fix DoS if gzip is corrupt
-
-On certain corrupt gzip files, huft_build will set the error bit on
-the result pointer. If afterwards abort_unzip is called huft_free
-might run into a segmentation fault or an invalid pointer to
-free(p).
-
-In order to mitigate this, we check in huft_free if the error bit
-is set and clear it before the linked list is freed.
-
-Signed-off-by: Samuel Sapalski <samuel.sapalski@nokia.com>
-Signed-off-by: Peter Kaestle <peter.kaestle@nokia.com>
-Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
----
- archival/libarchive/decompress_gunzip.c | 12 ++++++++++--
- 1 file changed, 10 insertions(+), 2 deletions(-)
-
-diff --git a/archival/libarchive/decompress_gunzip.c b/archival/libarchive/decompress_gunzip.c
-index eb3b64930..e93cd5005 100644
---- a/archival/libarchive/decompress_gunzip.c
-+++ b/archival/libarchive/decompress_gunzip.c
-@@ -220,10 +220,20 @@ static const uint8_t border[] ALIGN1 = {
-  * each table.
-  * t: table to free
-  */
-+#define BAD_HUFT(p) ((uintptr_t)(p) & 1)
-+#define ERR_RET     ((huft_t*)(uintptr_t)1)
- static void huft_free(huft_t *p)
- {
- 	huft_t *q;
- 
-+	/*
-+	 * If 'p' has the error bit set we have to clear it, otherwise we might run
-+	 * into a segmentation fault or an invalid pointer to free(p)
-+	 */
-+	if (BAD_HUFT(p)) {
-+		p = (huft_t*)((uintptr_t)(p) ^ (uintptr_t)(ERR_RET));
-+	}
-+
- 	/* Go through linked list, freeing from the malloced (t[-1]) address. */
- 	while (p) {
- 		q = (--p)->v.t;
-@@ -289,8 +299,6 @@ static unsigned fill_bitbuffer(STATE_PARAM unsigned bitbuffer, unsigned *current
-  * or a valid pointer to a Huffman table, ORed with 0x1 if incompete table
-  * is given: "fixed inflate" decoder feeds us such data.
-  */
--#define BAD_HUFT(p) ((uintptr_t)(p) & 1)
--#define ERR_RET     ((huft_t*)(uintptr_t)1)
- static huft_t* huft_build(const unsigned *b, const unsigned n,
- 			const unsigned s, const struct cp_ext *cp_ext,
- 			unsigned *m)
--- 
-2.30.0
-
diff -urpN busybox-1.33.1/0MKPATCH busybox-1.34.0/0MKPATCH
--- busybox-1.33.1/0MKPATCH	2021-05-03 19:48:57.000000000 +0700
+++ busybox-1.34.0/0MKPATCH	1970-01-01 07:00:00.000000000 +0700
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-git format-patch a4c3a341394a1fb25be8c15d2ddfe3ec77cbb83c
diff -urpN busybox-1.33.1/Makefile busybox-1.34.0/Makefile
--- busybox-1.33.1/Makefile	2021-05-04 01:07:13.000000000 +0700
+++ busybox-1.34.0/Makefile	2021-08-19 20:04:35.000000000 +0700
@@ -1,6 +1,6 @@
 VERSION = 1
-PATCHLEVEL = 33
-SUBLEVEL = 1
+PATCHLEVEL = 34
+SUBLEVEL = 0
 EXTRAVERSION =
 NAME = Unnamed
 
@@ -612,6 +612,7 @@ quiet_cmd_busybox__ ?= LINK    $@
       "$(core-y)" \
       "$(libs-y)" \
       "$(LDLIBS)" \
+      "$(CONFIG_EXTRA_LDLIBS)" \
       && $(srctree)/scripts/generate_BUFSIZ.sh --post include/common_bufsiz.h
 
 # Generate System.map
diff -urpN busybox-1.33.1/Makefile.flags busybox-1.34.0/Makefile.flags
--- busybox-1.33.1/Makefile.flags	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/Makefile.flags	2021-04-15 00:05:01.000000000 +0700
@@ -145,18 +145,21 @@ CFLAGS += --sysroot=$(CONFIG_SYSROOT)
 export SYSROOT=$(CONFIG_SYSROOT)
 endif
 
+# libm may be needed for dc, awk, ntpd
+LDLIBS += m
 # Android has no separate crypt library
 # gcc-4.2.1 fails if we try to feed C source on stdin:
 #  echo 'int main(void){return 0;}' | $(CC) $(CFLAGS) -lcrypt -o /dev/null -xc -
 # fall back to using a temp file:
-CRYPT_AVAILABLE := $(shell echo 'int main(void){return 0;}' >crypttest.c; $(CC) $(CFLAGS) -lcrypt -o /dev/null crypttest.c >/dev/null 2>&1 && echo "y"; rm crypttest.c)
+CRYPT_AVAILABLE := $(shell echo 'int main(void){return 0;}' >bb_libtest.c; $(CC) $(CFLAGS) -lcrypt -o /dev/null bb_libtest.c >/dev/null 2>&1 && echo "y"; rm bb_libtest.c)
+RT_AVAILABLE    := $(shell echo 'int main(void){return 0;}' >bb_libtest.c; $(CC) $(CFLAGS) -lrt    -o /dev/null bb_libtest.c >/dev/null 2>&1 && echo "y"; rm bb_libtest.c)
 ifeq ($(CRYPT_AVAILABLE),y)
-LDLIBS += m rt crypt
-else
-LDLIBS += m rt
+LDLIBS += crypt
 endif
-# libm may be needed for dc, awk, ntpd
 # librt may be needed for clock_gettime()
+ifeq ($(RT_AVAILABLE),y)
+LDLIBS += rt
+endif
 
 # libpam may use libpthread, libdl and/or libaudit.
 # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
@@ -181,8 +184,10 @@ LDLIBS += $(if $(SELINUX_LIBS),$(SELINUX
 endif
 
 ifeq ($(CONFIG_FEATURE_NSLOOKUP_BIG),y)
+ifneq (,$(findstring linux,$(shell $(CC) $(CFLAGS) -dumpmachine)))
 LDLIBS += resolv
 endif
+endif
 
 ifeq ($(CONFIG_EFENCE),y)
 LDLIBS += efence
@@ -207,11 +212,6 @@ LDFLAGS += $(strip $(subst ",,$(CONFIG_E
 #"))
 endif
 
-ifneq ($(CONFIG_EXTRA_LDLIBS),)
-LDLIBS += $(strip $(subst ",,$(CONFIG_EXTRA_LDLIBS)))
-#"))
-endif
-
 # Busybox is a stack-fatty so make sure we increase default size
 # TODO: use "make stksizes" to find & fix big stack users
 # (we stole scripts/checkstack.pl from the kernel... thanks guys!)
diff -urpN busybox-1.33.1/applets/applet_tables.c busybox-1.34.0/applets/applet_tables.c
--- busybox-1.33.1/applets/applet_tables.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/applets/applet_tables.c	2021-04-27 00:21:10.000000000 +0700
@@ -56,7 +56,7 @@ static int cmp_name(const void *a, const
 static int str_isalnum_(const char *s)
 {
 	while (*s) {
-		if (!isalnum(*s) && *s != '_')
+		if (!isalnum((unsigned char)*s) && *s != '_')
 			return 0;
 		s++;
 	}
diff -urpN busybox-1.33.1/applets/individual.c busybox-1.34.0/applets/individual.c
--- busybox-1.33.1/applets/individual.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/applets/individual.c	2021-04-15 00:05:01.000000000 +0700
@@ -19,6 +19,6 @@ int main(int argc, char **argv)
 
 void bb_show_usage(void)
 {
-	fputs(APPLET_full_usage "\n", stdout);
+	fputs_stdout(APPLET_full_usage "\n");
 	exit(EXIT_FAILURE);
 }
diff -urpN busybox-1.33.1/applets/usage_pod.c busybox-1.34.0/applets/usage_pod.c
--- busybox-1.33.1/applets/usage_pod.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/applets/usage_pod.c	2021-04-15 00:05:01.000000000 +0700
@@ -71,7 +71,7 @@ int main(void)
 		} else {
 			printf(", ");
 		}
-		printf(usage_array[i].aname);
+		printf("%s", usage_array[i].aname);
 		col += len2;
 	}
 	printf("\n\n");
diff -urpN busybox-1.33.1/archival/bbunzip.c busybox-1.34.0/archival/bbunzip.c
--- busybox-1.33.1/archival/bbunzip.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/bbunzip.c	2021-06-16 17:02:16.000000000 +0700
@@ -284,7 +284,7 @@ int uncompress_main(int argc UNUSED_PARA
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
-//usage:     "\n	-t	Test file integrity"
+//usage:     "\n	-t	Test integrity"
 //usage:
 //usage:#define gunzip_example_usage
 //usage:       "$ ls -la /tmp/BusyBox*\n"
@@ -407,6 +407,8 @@ int gunzip_main(int argc UNUSED_PARAM, c
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:     "\n	-t	Test integrity"
+//usage:
 //usage:#define bzcat_trivial_usage
 //usage:       "[FILE]..."
 //usage:#define bzcat_full_usage "\n\n"
@@ -465,6 +467,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:     "\n	-t	Test integrity"
 //usage:
 //usage:#define lzma_trivial_usage
 //usage:       "-d [-cfk] [FILE]..."
@@ -474,6 +477,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:     "\n	-t	Test integrity"
 //usage:
 //usage:#define lzcat_trivial_usage
 //usage:       "[FILE]..."
@@ -536,7 +540,7 @@ int unlzma_main(int argc UNUSED_PARAM, c
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
-//usage:     "\n	-t	Test file integrity"
+//usage:     "\n	-t	Test integrity"
 //usage:
 //usage:#define xz_trivial_usage
 //usage:       "-d [-cfk] [FILE]..."
@@ -546,7 +550,7 @@ int unlzma_main(int argc UNUSED_PARAM, c
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
-//usage:     "\n	-t	Test file integrity"
+//usage:     "\n	-t	Test integrity"
 //usage:
 //usage:#define xzcat_trivial_usage
 //usage:       "[FILE]..."
diff -urpN busybox-1.33.1/archival/bzip2.c busybox-1.34.0/archival/bzip2.c
--- busybox-1.33.1/archival/bzip2.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/bzip2.c	2021-06-16 17:02:16.000000000 +0700
@@ -56,11 +56,13 @@
 //usage:     "\n	-1..9	Compression level"
 //usage:	IF_FEATURE_BZIP2_DECOMPRESS(
 //usage:     "\n	-d	Decompress"
-//usage:     "\n	-t	Test file integrity"
 //usage:	)
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:	IF_FEATURE_BZIP2_DECOMPRESS(
+//usage:     "\n	-t	Test integrity"
+//usage:	)
 
 #include "libbb.h"
 #include "bb_archive.h"
diff -urpN busybox-1.33.1/archival/cpio.c busybox-1.34.0/archival/cpio.c
--- busybox-1.33.1/archival/cpio.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/cpio.c	2021-06-16 17:02:16.000000000 +0700
@@ -418,7 +418,8 @@ int cpio_main(int argc UNUSED_PARAM, cha
 		if (argv[0] == NULL)
 			bb_show_usage();
 		if (opt & OPT_CREATE_LEADING_DIR)
-			mkdir(argv[0], 0777);
+			/* GNU cpio 2.13: "cpio -d -p a/b/c" works */
+			bb_make_directory(argv[0], -1, FILEUTILS_RECUR);
 		/* Crude existence check:
 		 * close(xopen(argv[0], O_RDONLY | O_DIRECTORY));
 		 * We can also xopen, fstat, IS_DIR, later fchdir.
@@ -428,6 +429,11 @@ int cpio_main(int argc UNUSED_PARAM, cha
 		 * a diffrerent problem earlier.
 		 * This is good enough for now.
 		 */
+//FIXME: GNU cpio -d -p DIR does not immediately create DIR -
+//it just prepends "DIR/" to the names of files to be created.
+//The first file (fails to) be copied, and then the -d logic
+//triggers and creates all necessary directories.
+//IOW: bare "cpio -d -p DIR" + ^C shouldn't create anything.
 #if !BB_MMU
 		pp.rd = 3;
 		pp.wr = 4;
diff -urpN busybox-1.33.1/archival/gzip.c busybox-1.34.0/archival/gzip.c
--- busybox-1.33.1/archival/gzip.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/gzip.c	2021-06-16 17:02:16.000000000 +0700
@@ -77,11 +77,13 @@ aa:      85.1% -- replaced with aa.gz
 //usage:	)
 //usage:	IF_FEATURE_GZIP_DECOMPRESS(
 //usage:     "\n	-d	Decompress"
-//usage:     "\n	-t	Test file integrity"
 //usage:	)
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
 //usage:     "\n	-k	Keep input files"
+//usage:	IF_FEATURE_GZIP_DECOMPRESS(
+//usage:     "\n	-t	Test integrity"
+//usage:	)
 //usage:
 //usage:#define gzip_example_usage
 //usage:       "$ ls -la /tmp/busybox*\n"
diff -urpN busybox-1.33.1/archival/libarchive/data_extract_all.c busybox-1.34.0/archival/libarchive/data_extract_all.c
--- busybox-1.33.1/archival/libarchive/data_extract_all.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/archival/libarchive/data_extract_all.c	2021-01-08 15:30:27.000000000 +0700
@@ -159,6 +159,10 @@ void FAST_FUNC data_extract_all(archive_
 		break;
 	}
 	case S_IFDIR:
+//TODO: this causes problems if tarball contains a r-xr-xr-x directory:
+// we create this directory, and then fail to create files inside it
+// (if tar xf isn't run as root).
+// GNU tar works around this by chmod-ing directories *after* all files are extracted.
 		res = mkdir(dst_name, file_header->mode);
 		if ((res != 0)
 		 && (errno != EISDIR) /* btw, Linux doesn't return this */
diff -urpN busybox-1.33.1/archival/libarchive/decompress_gunzip.c busybox-1.34.0/archival/libarchive/decompress_gunzip.c
--- busybox-1.33.1/archival/libarchive/decompress_gunzip.c	2021-05-03 19:50:09.000000000 +0700
+++ busybox-1.34.0/archival/libarchive/decompress_gunzip.c	2021-05-05 02:35:15.000000000 +0700
@@ -230,9 +230,8 @@ static void huft_free(huft_t *p)
 	 * If 'p' has the error bit set we have to clear it, otherwise we might run
 	 * into a segmentation fault or an invalid pointer to free(p)
 	 */
-	if (BAD_HUFT(p)) {
-		p = (huft_t*)((uintptr_t)(p) ^ (uintptr_t)(ERR_RET));
-	}
+	//if (BAD_HUFT(p)) // commented out, since bit clearing has effect only if condition is true
+		p = (huft_t*)((uintptr_t)p & ~(uintptr_t)ERR_RET);
 
 	/* Go through linked list, freeing from the malloced (t[-1]) address. */
 	while (p) {
diff -urpN busybox-1.33.1/archival/libarchive/decompress_unlzma.c busybox-1.34.0/archival/libarchive/decompress_unlzma.c
--- busybox-1.33.1/archival/libarchive/decompress_unlzma.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/libarchive/decompress_unlzma.c	2021-06-16 17:02:16.000000000 +0700
@@ -290,8 +290,11 @@ unpack_lzma_stream(transformer_state_t *
 				uint32_t pos;
 
 				pos = buffer_pos - rep0;
-				if ((int32_t)pos < 0)
+				if ((int32_t)pos < 0) {
 					pos += header.dict_size;
+					if ((int32_t)pos < 0)
+						goto bad;
+				}
 				match_byte = buffer[pos];
 				do {
 					int bit;
diff -urpN busybox-1.33.1/archival/libarchive/get_header_cpio.c busybox-1.34.0/archival/libarchive/get_header_cpio.c
--- busybox-1.33.1/archival/libarchive/get_header_cpio.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/libarchive/get_header_cpio.c	2021-07-20 21:57:20.000000000 +0700
@@ -20,7 +20,7 @@ typedef struct hardlinks_t {
 char FAST_FUNC get_header_cpio(archive_handle_t *archive_handle)
 {
 	file_header_t *file_header = archive_handle->file_header;
-	char cpio_header[110];
+	char cpio_header[111];
 	int namesize;
 	int major, minor, nlink, mode, inode;
 	unsigned size, uid, gid, mtime;
@@ -43,6 +43,7 @@ char FAST_FUNC get_header_cpio(archive_h
 		bb_simple_error_msg_and_die("unsupported cpio format, use newc or crc");
 	}
 
+	cpio_header[110] = '\0'; /* sscanf may call strlen which may break without this */
 	if (sscanf(cpio_header + 6,
 			"%8x" "%8x" "%8x" "%8x"
 			"%8x" "%8x" "%8x" /*maj,min:*/ "%*16c"
diff -urpN busybox-1.33.1/archival/lzop.c busybox-1.34.0/archival/lzop.c
--- busybox-1.33.1/archival/lzop.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/lzop.c	2021-06-16 17:02:16.000000000 +0700
@@ -86,6 +86,7 @@
 //usage:     "\n	-f	Force"
 //usage:     "\n	-U	Delete input files"
 ///////:     "\n	-k	Keep input files" (default, so why bother documenting?)
+//usage:     "\n	-t	Test integrity"
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-F	Don't verify checksum"
 
diff -urpN busybox-1.33.1/archival/tar.c busybox-1.34.0/archival/tar.c
--- busybox-1.33.1/archival/tar.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/tar.c	2021-08-16 00:57:08.000000000 +0700
@@ -507,6 +507,9 @@ static int FAST_FUNC writeFileToTarball(
 	if (header_name[0] == '\0')
 		return TRUE;
 
+	if (exclude_file(tbInfo->excludeList, header_name))
+		return SKIP; /* "do not recurse on this directory", no error message printed */
+
 	/* It is against the rules to archive a socket */
 	if (S_ISSOCK(statbuf->st_mode)) {
 		bb_error_msg("%s: socket ignored", fileName);
@@ -540,9 +543,6 @@ static int FAST_FUNC writeFileToTarball(
 		return TRUE;
 	}
 
-	if (exclude_file(tbInfo->excludeList, header_name))
-		return SKIP;
-
 # if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 	if (strlen(header_name) >= NAME_SIZE) {
 		bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
@@ -555,13 +555,13 @@ static int FAST_FUNC writeFileToTarball(
 		/* open the file we want to archive, and make sure all is well */
 		inputFileFd = open_or_warn(fileName, O_RDONLY);
 		if (inputFileFd < 0) {
-			return FALSE;
+			return FALSE; /* make recursive_action() return FALSE */
 		}
 	}
 
 	/* Add an entry to the tarball */
 	if (writeTarHeader(tbInfo, header_name, fileName, statbuf) == FALSE) {
-		return FALSE;
+		return FALSE; /* make recursive_action() return FALSE */
 	}
 
 	/* If it was a regular file, write out the body */
@@ -775,7 +775,7 @@ static llist_t *append_file_list_to_list
 //usage:	IF_FEATURE_TAR_NOPRESERVE_TIME("m")
 //usage:	"vokO] "
 //usage:	"[-f TARFILE] [-C DIR] "
-//usage:	IF_FEATURE_TAR_FROM("[-T FILE] [-X FILE] "IF_FEATURE_TAR_LONG_OPTIONS("[OPTION]... "))
+//usage:	IF_FEATURE_TAR_FROM("[-T FILE] [-X FILE] "IF_FEATURE_TAR_LONG_OPTIONS("[LONGOPT]... "))
 //usage:	"[FILE]..."
 //usage:#define tar_full_usage "\n\n"
 //usage:	IF_FEATURE_TAR_CREATE("Create, extract, ")
@@ -1132,14 +1132,15 @@ int tar_main(int argc UNUSED_PARAM, char
 		tar_handle->ah_flags &= ~ARCHIVE_RESTORE_DATE;
 
 #if ENABLE_FEATURE_TAR_FROM
+	/* Convert each -X EXCLFILE to list of to-be-rejected glob patterns */
 	tar_handle->reject = append_file_list_to_list(tar_handle->reject);
 # if ENABLE_FEATURE_TAR_LONG_OPTIONS
-	/* Append excludes to reject */
-	while (excludes) {
-		llist_t *next = excludes->link;
-		excludes->link = tar_handle->reject;
-		tar_handle->reject = excludes;
-		excludes = next;
+	/* Append --exclude=GLOBPATTERNs to reject */
+	if (excludes) {
+		llist_t **p2next = &tar_handle->reject;
+		while (*p2next)
+			p2next = &((*p2next)->link);
+		*p2next = excludes;
 	}
 # endif
 	tar_handle->accept = append_file_list_to_list(tar_handle->accept);
diff -urpN busybox-1.33.1/archival/unzip.c busybox-1.34.0/archival/unzip.c
--- busybox-1.33.1/archival/unzip.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/archival/unzip.c	2021-06-16 17:02:16.000000000 +0700
@@ -56,14 +56,15 @@
 //kbuild:lib-$(CONFIG_UNZIP) += unzip.o
 
 //usage:#define unzip_trivial_usage
-//usage:       "[-lnojpq] FILE[.zip] [FILE]... [-x FILE...] [-d DIR]"
+//usage:       "[-lnojpq] FILE[.zip] [FILE]... [-x FILE]... [-d DIR]"
 //usage:#define unzip_full_usage "\n\n"
 //usage:       "Extract FILEs from ZIP archive\n"
 //usage:     "\n	-l	List contents (with -q for short form)"
 //usage:     "\n	-n	Never overwrite files (default: ask)"
 //usage:     "\n	-o	Overwrite"
 //usage:     "\n	-j	Do not restore paths"
-//usage:     "\n	-p	Print to stdout"
+//usage:     "\n	-p	Write to stdout"
+//usage:     "\n	-t	Test"
 //usage:     "\n	-q	Quiet"
 //usage:     "\n	-x FILE	Exclude FILEs"
 //usage:     "\n	-d DIR	Extract into DIR"
@@ -82,11 +83,13 @@ enum {
 	ZIP_FILEHEADER_MAGIC = 0x504b0304,
 	ZIP_CDF_MAGIC        = 0x504b0102, /* CDF item */
 	ZIP_CDE_MAGIC        = 0x504b0506, /* End of CDF */
+	ZIP64_CDE_MAGIC      = 0x504b0606, /* End of Zip64 CDF */
 	ZIP_DD_MAGIC         = 0x504b0708,
 #else
 	ZIP_FILEHEADER_MAGIC = 0x04034b50,
 	ZIP_CDF_MAGIC        = 0x02014b50,
 	ZIP_CDE_MAGIC        = 0x06054b50,
+	ZIP64_CDE_MAGIC      = 0x06064b50,
 	ZIP_DD_MAGIC         = 0x08074b50,
 #endif
 };
@@ -260,6 +263,12 @@ static uint32_t find_cdf_offset(void)
 			continue;
 		/* we found CDE! */
 		memcpy(cde.raw, p + 1, CDE_LEN);
+		dbg("cde.this_disk_no:%d",             cde.fmt.this_disk_no            );
+		dbg("cde.disk_with_cdf_no:%d",         cde.fmt.disk_with_cdf_no        );
+		dbg("cde.cdf_entries_on_this_disk:%d", cde.fmt.cdf_entries_on_this_disk);
+		dbg("cde.cdf_entries_total:%d",        cde.fmt.cdf_entries_total       );
+		dbg("cde.cdf_size:%d",                 cde.fmt.cdf_size                );
+		dbg("cde.cdf_offset:%x",               cde.fmt.cdf_offset              );
 		FIX_ENDIANNESS_CDE(cde);
 		/*
 		 * I've seen .ZIP files with seemingly valid CDEs
@@ -302,19 +311,27 @@ static uint32_t read_next_cdf(uint32_t c
 		dbg("got ZIP_CDE_MAGIC");
 		return 0; /* EOF */
 	}
+	if (magic == ZIP64_CDE_MAGIC) { /* seen in .zip with >4GB files */
+		dbg("got ZIP64_CDE_MAGIC");
+		return 0; /* EOF */
+	}
 	xread(zip_fd, cdf->raw, CDF_HEADER_LEN);
 
 	FIX_ENDIANNESS_CDF(*cdf);
-	dbg("  filename_len:%u extra_len:%u file_comment_length:%u",
+	dbg("  magic:%08x filename_len:%u extra_len:%u file_comment_length:%u",
+		magic,
 		(unsigned)cdf->fmt.filename_len,
 		(unsigned)cdf->fmt.extra_len,
 		(unsigned)cdf->fmt.file_comment_length
 	);
+//TODO: require that magic == ZIP_CDF_MAGIC?
+
 	cdf_offset += 4 + CDF_HEADER_LEN
 		+ cdf->fmt.filename_len
 		+ cdf->fmt.extra_len
 		+ cdf->fmt.file_comment_length;
 
+	dbg("Next cdf_offset 0x%x", cdf_offset);
 	return cdf_offset;
 };
 #endif
@@ -436,7 +453,9 @@ static void unzip_extract(zip_header_t *
 	}
 
 	/* Validate decompression - size */
-	if (zip->fmt.ucmpsize != xstate.bytes_out) {
+	if (zip->fmt.ucmpsize != 0xffffffff /* seen on files with >4GB uncompressed data */
+	 && zip->fmt.ucmpsize != xstate.bytes_out
+	) {
 		/* Don't die. Who knows, maybe len calculation
 		 * was botched somewhere. After all, crc matched! */
 		bb_simple_error_msg("bad length");
@@ -538,7 +557,7 @@ int unzip_main(int argc, char **argv)
 
 	opts = 0;
 	/* '-' makes getopt return 1 for non-options */
-	while ((i = getopt(argc, argv, "-d:lnopqxjv")) != -1) {
+	while ((i = getopt(argc, argv, "-d:lnotpqxjv")) != -1) {
 		switch (i) {
 		case 'd':  /* Extract to base directory */
 			base_dir = optarg;
@@ -556,8 +575,13 @@ int unzip_main(int argc, char **argv)
 			overwrite = O_ALWAYS;
 			break;
 
-		case 'p': /* Extract files to stdout and fall through to set verbosity */
+		case 't': /* Extract files to /dev/null */
+			xmove_fd(xopen("/dev/null", O_WRONLY), STDOUT_FILENO);
+			/*fallthrough*/
+
+		case 'p': /* Extract files to stdout */
 			dst_fd = STDOUT_FILENO;
+			/*fallthrough*/
 
 		case 'q': /* Be quiet */
 			quiet++;
@@ -966,7 +990,6 @@ int unzip_main(int argc, char **argv)
 			/* O_NOFOLLOW defends against symlink attacks */
 			dst_fd = xopen(dst_fn, O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW);
 #endif
- do_extract:
 			if (!quiet) {
 				printf(/* zip.fmt.method == 0
 					? " extracting: %s\n"
@@ -974,6 +997,7 @@ int unzip_main(int argc, char **argv)
 					printable_string(dst_fn)
 				);
 			}
+ do_extract:
 #if ENABLE_FEATURE_UNZIP_CDF
 			if (S_ISLNK(file_mode)) {
 				if (dst_fd != STDOUT_FILENO) /* not -p? */
diff -urpN busybox-1.33.1/configs/android_502_defconfig busybox-1.34.0/configs/android_502_defconfig
--- busybox-1.33.1/configs/android_502_defconfig	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/configs/android_502_defconfig	2021-08-16 01:46:38.000000000 +0700
@@ -33,7 +33,6 @@
 ## Assorted header problems:
 ## # CONFIG_HOSTID is not set
 ## # CONFIG_FEATURE_SYNC_FANCY is not set - syncfs()
-## # CONFIG_FEATURE_TOUCH_NODEREF is not set - lutimes()
 ## # CONFIG_LOGNAME is not set - getlogin_r()
 ## # CONFIG_LOADFONT is not set
 ## # CONFIG_SETFONT is not set
@@ -269,7 +268,6 @@ CONFIG_SYNC=y
 CONFIG_TEST=y
 CONFIG_FEATURE_TEST_64=y
 CONFIG_TOUCH=y
-# CONFIG_FEATURE_TOUCH_NODEREF is not set
 CONFIG_FEATURE_TOUCH_SUSV3=y
 CONFIG_TR=y
 CONFIG_FEATURE_TR_CLASSES=y
diff -urpN busybox-1.33.1/configs/android_ndk_defconfig busybox-1.34.0/configs/android_ndk_defconfig
--- busybox-1.33.1/configs/android_ndk_defconfig	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/configs/android_ndk_defconfig	2021-08-16 01:45:59.000000000 +0700
@@ -193,7 +193,6 @@ CONFIG_SYNC=y
 CONFIG_TEST=y
 CONFIG_FEATURE_TEST_64=y
 CONFIG_TOUCH=y
-# CONFIG_FEATURE_TOUCH_NODEREF is not set
 CONFIG_FEATURE_TOUCH_SUSV3=y
 CONFIG_TR=y
 CONFIG_FEATURE_TR_CLASSES=y
diff -urpN busybox-1.33.1/console-tools/loadfont.c busybox-1.34.0/console-tools/loadfont.c
--- busybox-1.33.1/console-tools/loadfont.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/console-tools/loadfont.c	2021-06-16 17:02:16.000000000 +0700
@@ -399,7 +399,7 @@ setfont [-O font+umap.orig] [-o font.ori
 -V     Version
 */
 //usage:#define setfont_trivial_usage
-//usage:       "FONT [-m MAPFILE] [-C TTY]"
+//usage:       "[-m MAPFILE] [-C TTY] FILE"
 //usage:#define setfont_full_usage "\n\n"
 //usage:       "Load a console font\n"
 //usage:     "\n	-m MAPFILE	Load console screen map"
diff -urpN busybox-1.33.1/console-tools/showkey.c busybox-1.34.0/console-tools/showkey.c
--- busybox-1.33.1/console-tools/showkey.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/console-tools/showkey.c	2021-06-16 17:02:16.000000000 +0700
@@ -106,7 +106,7 @@ int showkey_main(int argc UNUSED_PARAM,
 		xioctl(STDIN_FILENO, KDSKBMODE, (void *)(ptrdiff_t)((option_mask32 & OPT_k) ? K_MEDIUMRAW : K_RAW));
 
 		// we should exit on any signal; signals should interrupt read
-		bb_signals_recursive_norestart(BB_FATAL_SIGS, record_signo);
+		bb_signals_norestart(BB_FATAL_SIGS, record_signo);
 
 		// inform user that program ends after time of inactivity
 		printf(press_keys, "10s after last keypress");
diff -urpN busybox-1.33.1/coreutils/cat.c busybox-1.34.0/coreutils/cat.c
--- busybox-1.33.1/coreutils/cat.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/cat.c	2021-04-15 00:05:01.000000000 +0700
@@ -152,7 +152,7 @@ static int catv(unsigned opts, char **ar
 				eol_seen = (c == eol_char);
 #endif
 				visible(c, buf, opts);
-				fputs(buf, stdout);
+				fputs_stdout(buf);
 			}
 		}
 		if (ENABLE_FEATURE_CLEAN_UP && fd)
@@ -201,7 +201,7 @@ int cat_main(int argc UNUSED_PARAM, char
 		ns.start = 1;
 		ns.inc = 1;
 		ns.sep = "\t";
-		ns.empty_str = "\n";
+		ns.empty_str = NULL;
 		ns.all = !(opts & CAT_OPT_b); /* -n without -b */
 		ns.nonempty = (opts & CAT_OPT_b); /* -b (with or without -n) */
 		exitcode = EXIT_SUCCESS;
diff -urpN busybox-1.33.1/coreutils/chgrp.c busybox-1.34.0/coreutils/chgrp.c
--- busybox-1.33.1/coreutils/chgrp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/chgrp.c	2021-06-16 17:02:16.000000000 +0700
@@ -23,13 +23,17 @@
 //usage:#define chgrp_trivial_usage
 //usage:       "[-Rh"IF_DESKTOP("LHPcvf")"]... GROUP FILE..."
 //usage:#define chgrp_full_usage "\n\n"
-//usage:       "Change the group membership of each FILE to GROUP\n"
-//usage:     "\n	-R	Recurse"
+//usage:       "Change the group membership of FILEs to GROUP"
+//usage:     "\n"
 //usage:     "\n	-h	Affect symlinks instead of symlink targets"
 //usage:	IF_DESKTOP(
 //usage:     "\n	-L	Traverse all symlinks to directories"
 //usage:     "\n	-H	Traverse symlinks on command line only"
 //usage:     "\n	-P	Don't traverse symlinks (default)"
+//usage:	)
+//next 4 options are the same for chmod/chown/chgrp:
+//usage:     "\n	-R	Recurse"
+//usage:	IF_DESKTOP(
 //usage:     "\n	-c	List changed files"
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-f	Hide errors"
diff -urpN busybox-1.33.1/coreutils/chmod.c busybox-1.34.0/coreutils/chmod.c
--- busybox-1.33.1/coreutils/chmod.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/chmod.c	2021-06-16 17:02:16.000000000 +0700
@@ -26,12 +26,13 @@
 //usage:#define chmod_trivial_usage
 //usage:       "[-R"IF_DESKTOP("cvf")"] MODE[,MODE]... FILE..."
 //usage:#define chmod_full_usage "\n\n"
-//usage:       "Each MODE is one or more of the letters ugoa, one of the\n"
-//usage:       "symbols +-= and one or more of the letters rwxst\n"
+//usage:       "MODE is octal number (bit pattern sstrwxrwxrwx) or [ugoa]{+|-|=}[rwxXst]"
+//usage:     "\n"
+//next 4 options are the same for chmod/chown/chgrp:
 //usage:     "\n	-R	Recurse"
 //usage:	IF_DESKTOP(
 //usage:     "\n	-c	List changed files"
-//usage:     "\n	-v	List all files"
+//usage:     "\n	-v	Verbose"
 //usage:     "\n	-f	Hide errors"
 //usage:	)
 //usage:
diff -urpN busybox-1.33.1/coreutils/chown.c busybox-1.34.0/coreutils/chown.c
--- busybox-1.33.1/coreutils/chown.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/chown.c	2021-06-16 17:02:16.000000000 +0700
@@ -28,15 +28,19 @@
 //usage:#define chown_trivial_usage
 //usage:       "[-Rh"IF_DESKTOP("LHPcvf")"]... USER[:[GRP]] FILE..."
 //usage:#define chown_full_usage "\n\n"
-//usage:       "Change the owner and/or group of each FILE to USER and/or GRP\n"
-//usage:     "\n	-R	Recurse"
+//usage:       "Change the owner and/or group of FILEs to USER and/or GRP"
+//usage:     "\n"
 //usage:     "\n	-h	Affect symlinks instead of symlink targets"
 //usage:	IF_DESKTOP(
 //usage:     "\n	-L	Traverse all symlinks to directories"
 //usage:     "\n	-H	Traverse symlinks on command line only"
 //usage:     "\n	-P	Don't traverse symlinks (default)"
+//usage:	)
+//next 4 options are the same for chmod/chown/chgrp:
+//usage:     "\n	-R	Recurse"
+//usage:	IF_DESKTOP(
 //usage:     "\n	-c	List changed files"
-//usage:     "\n	-v	List all files"
+//usage:     "\n	-v	Verbose"
 //usage:     "\n	-f	Hide errors"
 //usage:	)
 //usage:
diff -urpN busybox-1.33.1/coreutils/cksum.c busybox-1.34.0/coreutils/cksum.c
--- busybox-1.33.1/coreutils/cksum.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/cksum.c	2021-07-20 21:57:20.000000000 +0700
@@ -9,32 +9,40 @@
 //config:config CKSUM
 //config:	bool "cksum (4.1 kb)"
 //config:	default y
-//config:	help
-//config:	cksum is used to calculate the CRC32 checksum of a file.
+//config:
+//config:config CRC32
+//config:	bool "crc32 (4.1 kb)"
+//config:	default y
 
+//                APPLET_NOEXEC:name   main   location        suid_type     help
 //applet:IF_CKSUM(APPLET_NOEXEC(cksum, cksum, BB_DIR_USR_BIN, BB_SUID_DROP, cksum))
+//applet:IF_CRC32(APPLET_NOEXEC(crc32, cksum, BB_DIR_USR_BIN, BB_SUID_DROP, cksum))
 /* bb_common_bufsiz1 usage here is safe wrt NOEXEC: not expecting it to be zeroed. */
 
 //kbuild:lib-$(CONFIG_CKSUM) += cksum.o
+//kbuild:lib-$(CONFIG_CRC32) += cksum.o
 
 //usage:#define cksum_trivial_usage
 //usage:       "FILE..."
 //usage:#define cksum_full_usage "\n\n"
-//usage:       "Calculate the CRC32 checksums of FILEs"
+//usage:       "Calculate CRC32 checksum of FILEs"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
 
 /* This is a NOEXEC applet. Be very careful! */
 
+#define IS_CKSUM (ENABLE_CKSUM && (!ENABLE_CRC32 || applet_name[1] == 'k'))
+#define IS_CRC32 (ENABLE_CRC32 && (!ENABLE_CKSUM || applet_name[1] == 'r'))
+
 int cksum_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int cksum_main(int argc UNUSED_PARAM, char **argv)
 {
-	uint32_t *crc32_table = crc32_filltable(NULL, 1);
+	uint32_t *crc32_table = crc32_filltable(NULL, IS_CKSUM);
 	int exit_code = EXIT_SUCCESS;
 
 #if ENABLE_DESKTOP
-	getopt32(argv, ""); /* coreutils 6.9 compat */
+	getopt32(argv, ""); /* cksum coreutils 6.9 compat */
 	argv += optind;
 #else
 	argv++;
@@ -43,41 +51,55 @@ int cksum_main(int argc UNUSED_PARAM, ch
 	setup_common_bufsiz();
 	do {
 		uint32_t crc;
-		off_t filesize;
-		int fd = open_or_warn_stdin(*argv ? *argv : bb_msg_standard_input);
+		IF_CKSUM(off_t filesize;)
+		const char *fname = *argv ? *argv : bb_msg_standard_input;
+		int fd = open_or_warn_stdin(fname);
 
 		if (fd < 0) {
 			exit_code = EXIT_FAILURE;
 			continue;
 		}
 
-		crc = 0;
-		filesize = 0;
+		crc = IS_CKSUM ? 0 : 0xffffffff;
+		IF_CKSUM(filesize = 0;)
 #define read_buf bb_common_bufsiz1
 		for (;;) {
-			uoff_t t;
 			int bytes_read = safe_read(fd, read_buf, COMMON_BUFSIZE);
+			if (bytes_read < 0)
+				bb_simple_perror_msg_and_die(fname);
 			if (bytes_read > 0) {
-				filesize += bytes_read;
+				IF_CKSUM(filesize += bytes_read;)
 			} else {
-				/* Checksum filesize bytes, LSB first, and exit */
+				IF_CKSUM(uoff_t t;)
+
 				close(fd);
+				if (IS_CRC32)
+					break;
+#if ENABLE_CKSUM
 				fd = -1; /* break flag */
+				/* Checksum filesize bytes, LSB first */
 				t = filesize;
-				bytes_read = 0;
+				/*bytes_read = 0; - already is */
 				while (t != 0) {
 					read_buf[bytes_read++] = (uint8_t)t;
 					t >>= 8;
 				}
+#endif
 			}
-			crc = crc32_block_endian1(crc, read_buf, bytes_read, crc32_table);
-			if (fd < 0)
+			crc = (IS_CKSUM ? crc32_block_endian1 : crc32_block_endian0)(crc, read_buf, bytes_read, crc32_table);
+			if (ENABLE_CKSUM && fd < 0)
 				break;
 		}
 
 		crc = ~crc;
-		printf((*argv ? "%u %"OFF_FMT"u %s\n" : "%u %"OFF_FMT"u\n"),
+#if ENABLE_CKSUM
+		if (IS_CKSUM)
+			printf((*argv ? "%u %"OFF_FMT"u %s\n" : "%u %"OFF_FMT"u\n"),
 				(unsigned)crc, filesize, *argv);
+		else
+#endif
+			printf((*argv ? "%08x %s\n" : "%08x\n"),
+				(unsigned)crc, *argv);
 	} while (*argv && *++argv);
 
 	fflush_stdout_and_exit(exit_code);
diff -urpN busybox-1.33.1/coreutils/cp.c busybox-1.34.0/coreutils/cp.c
--- busybox-1.33.1/coreutils/cp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/cp.c	2021-08-16 00:57:08.000000000 +0700
@@ -37,10 +37,57 @@
 
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/cp.html */
 
+// Options of cp from GNU coreutils 6.10:
+// -a, --archive
+// -f, --force
+// -i, --interactive
+// -l, --link
+// -L, --dereference
+// -P, --no-dereference
+// -R, -r, --recursive
+// -s, --symbolic-link
+// -v, --verbose
+// -H	follow command-line symbolic links in SOURCE
+// -d	same as --no-dereference --preserve=links
+// -p	same as --preserve=mode,ownership,timestamps
+// -c	same as --preserve=context
+// -u, --update
+//	copy only when the SOURCE file is newer than the destination
+//	file or when the destination file is missing
+// --remove-destination
+//	remove each existing destination file before attempting to open
+// --parents
+//	use full source file name under DIRECTORY
+// -T, --no-target-directory
+//	treat DEST as a normal file
+// NOT SUPPORTED IN BBOX:
+// --backup[=CONTROL]
+//	make a backup of each existing destination file
+// -b	like --backup but does not accept an argument
+// --copy-contents
+//	copy contents of special files when recursive
+// --preserve[=ATTR_LIST]
+//	preserve attributes (default: mode,ownership,timestamps),
+//	if possible additional attributes: security context,links,all
+// --no-preserve=ATTR_LIST
+// --sparse=WHEN
+//	control creation of sparse files
+// --strip-trailing-slashes
+//	remove any trailing slashes from each SOURCE argument
+// -S, --suffix=SUFFIX
+//	override the usual backup suffix
+// -t, --target-directory=DIRECTORY
+//	copy all SOURCE arguments into DIRECTORY
+// -x, --one-file-system
+//	stay on this file system
+// -Z, --context=CONTEXT
+//	(SELinux) set SELinux security context of copy to CONTEXT
+
 //usage:#define cp_trivial_usage
-//usage:       "[-arPLHpfilsTu] SOURCE... DEST"
+//usage:       "[-arPLHpfinlsTu] SOURCE DEST\n"
+//usage:       "or: cp [-arPLHpfinlsu] SOURCE... { -t DIRECTORY | DIRECTORY }"
 //usage:#define cp_full_usage "\n\n"
-//usage:       "Copy SOURCE(s) to DEST\n"
+//usage:       "Copy SOURCEs to DEST\n"
 //usage:     "\n	-a	Same as -dpR"
 //usage:	IF_SELINUX(
 //usage:     "\n	-c	Preserve security context"
@@ -52,8 +99,10 @@
 //usage:     "\n	-p	Preserve file attributes if possible"
 //usage:     "\n	-f	Overwrite"
 //usage:     "\n	-i	Prompt before overwrite"
+//usage:     "\n	-n	Don't overwrite"
 //usage:     "\n	-l,-s	Create (sym)links"
-//usage:     "\n	-T	Treat DEST as a normal file"
+//usage:     "\n	-T	Refuse to copy if DEST is a directory"
+//usage:     "\n	-t DIR	Copy all SOURCEs into DIR"
 //usage:     "\n	-u	Copy only newer files"
 
 #include "libbb.h"
@@ -72,44 +121,46 @@ int cp_main(int argc, char **argv)
 	int d_flags;
 	int flags;
 	int status;
-	enum {
-		FILEUTILS_CP_OPTNUM = sizeof(FILEUTILS_CP_OPTSTR)-1,
 #if ENABLE_FEATURE_CP_LONG_OPTIONS
-		/*OPT_rmdest  = FILEUTILS_RMDEST = 1 << FILEUTILS_CP_OPTNUM */
-		OPT_parents = 1 << (FILEUTILS_CP_OPTNUM+1),
-		OPT_reflink = 1 << (FILEUTILS_CP_OPTNUM+2),
-#endif
+	enum {
+		/*OPT_rmdest  = FILEUTILS_RMDEST = 1 << FILEUTILS_CP_OPTBITS */
+		OPT_parents = 1 << (FILEUTILS_CP_OPTBITS+1),
+		OPT_reflink = 1 << (FILEUTILS_CP_OPTBITS+2),
 	};
-
-#if ENABLE_FEATURE_CP_LONG_OPTIONS
 # if ENABLE_FEATURE_CP_REFLINK
 	char *reflink = NULL;
 # endif
 	flags = getopt32long(argv, "^"
 		FILEUTILS_CP_OPTSTR
 		"\0"
-		// Need at least two arguments
+		// Need at least one argument. (Usually two+, but -t DIR can have only one)
 		// Soft- and hardlinking doesn't mix
 		// -P and -d are the same (-P is POSIX, -d is GNU)
 		// -r and -R are the same
 		// -R (and therefore -r) turns on -d (coreutils does this)
 		// -a = -pdR
-		"-2:l--s:s--l:Pd:rRd:Rd:apdR",
+		// -i overrides -n and vice versa (last wins)
+		"-1:l--s:s--l:Pd:rRd:Rd:apdR:i-n:n-i",
 		"archive\0"        No_argument "a"
 		"force\0"          No_argument "f"
 		"interactive\0"    No_argument "i"
+		"no-clobber\0"     No_argument "n"
 		"link\0"           No_argument "l"
 		"dereference\0"    No_argument "L"
 		"no-dereference\0" No_argument "P"
 		"recursive\0"      No_argument "R"
 		"symbolic-link\0"  No_argument "s"
 		"no-target-directory\0" No_argument "T"
+		"target-directory\0" Required_argument "t"
 		"verbose\0"        No_argument "v"
 		"update\0"         No_argument "u"
 		"remove-destination\0" No_argument "\xff"
 		"parents\0"        No_argument "\xfe"
 # if ENABLE_FEATURE_CP_REFLINK
 		"reflink\0"        Optional_argument "\xfd"
+# endif
+		, &last
+# if ENABLE_FEATURE_CP_REFLINK
 		, &reflink
 # endif
 	);
@@ -128,55 +179,10 @@ int cp_main(int argc, char **argv)
 	flags = getopt32(argv, "^"
 		FILEUTILS_CP_OPTSTR
 		"\0"
-		"-2:l--s:s--l:Pd:rRd:Rd:apdR"
+		"-1:l--s:s--l:Pd:rRd:Rd:apdR"
+		, &last
 	);
 #endif
-	/* Options of cp from GNU coreutils 6.10:
-	 * -a, --archive
-	 * -f, --force
-	 * -i, --interactive
-	 * -l, --link
-	 * -L, --dereference
-	 * -P, --no-dereference
-	 * -R, -r, --recursive
-	 * -s, --symbolic-link
-	 * -v, --verbose
-	 * -H	follow command-line symbolic links in SOURCE
-	 * -d	same as --no-dereference --preserve=links
-	 * -p	same as --preserve=mode,ownership,timestamps
-	 * -c	same as --preserve=context
-	 * -u, --update
-	 *	copy only when the SOURCE file is newer than the destination
-	 *	file or when the destination file is missing
-	 * --remove-destination
-	 *	remove each existing destination file before attempting to open
-	 * --parents
-	 *	use full source file name under DIRECTORY
-	 * -T, --no-target-directory
-	 *	treat DEST as a normal file
-	 * NOT SUPPORTED IN BBOX:
-	 * --backup[=CONTROL]
-	 *	make a backup of each existing destination file
-	 * -b	like --backup but does not accept an argument
-	 * --copy-contents
-	 *	copy contents of special files when recursive
-	 * --preserve[=ATTR_LIST]
-	 *	preserve attributes (default: mode,ownership,timestamps),
-	 *	if possible additional attributes: security context,links,all
-	 * --no-preserve=ATTR_LIST
-	 * --sparse=WHEN
-	 *	control creation of sparse files
-	 * --strip-trailing-slashes
-	 *	remove any trailing slashes from each SOURCE argument
-	 * -S, --suffix=SUFFIX
-	 *	override the usual backup suffix
-	 * -t, --target-directory=DIRECTORY
-	 *	copy all SOURCE arguments into DIRECTORY
-	 * -x, --one-file-system
-	 *	stay on this file system
-	 * -Z, --context=CONTEXT
-	 *	(SELinux) set SELinux security context of copy to CONTEXT
-	 */
 	argc -= optind;
 	argv += optind;
 	/* Reverse this bit. If there is -d, bit is not set: */
@@ -195,49 +201,56 @@ int cp_main(int argc, char **argv)
 #endif
 
 	status = EXIT_SUCCESS;
-	last = argv[argc - 1];
-	/* If there are only two arguments and...  */
-	if (argc == 2) {
-		s_flags = cp_mv_stat2(*argv, &source_stat,
-				(flags & FILEUTILS_DEREFERENCE) ? stat : lstat);
-		if (s_flags < 0)
-			return EXIT_FAILURE;
-		d_flags = cp_mv_stat(last, &dest_stat);
-		if (d_flags < 0)
-			return EXIT_FAILURE;
-
-		if (flags & FILEUTILS_NO_TARGET_DIR) { /* -T */
-			if (!(s_flags & 2) && (d_flags & 2))
-				/* cp -T NOTDIR DIR */
-				bb_error_msg_and_die("'%s' is a directory", last);
-		}
+	if (!(flags & FILEUTILS_TARGET_DIR)) {
+		last = argv[argc - 1];
+		if (argc < 2)
+			bb_show_usage();
+		if (argc != 2) {
+			if (flags & FILEUTILS_NO_TARGET_DIR)
+				bb_show_usage();
+			/* "cp A B C... DIR" - target must be dir */
+		} else /* argc == 2 */ {
+			/* "cp A B" - only case where target can be not a dir */
+			s_flags = cp_mv_stat2(*argv, &source_stat,
+					(flags & FILEUTILS_DEREFERENCE) ? stat : lstat);
+			if (s_flags < 0) /* error other than ENOENT */
+				return EXIT_FAILURE;
+			d_flags = cp_mv_stat(last, &dest_stat);
+			if (d_flags < 0) /* error other than ENOENT */
+				return EXIT_FAILURE;
+
+			if (flags & FILEUTILS_NO_TARGET_DIR) { /* -T */
+				if (!(s_flags & 2) && (d_flags & 2))
+					/* cp -T NOTDIR DIR */
+					bb_error_msg_and_die("'%s' is a directory", last);
+			}
 
 #if ENABLE_FEATURE_CP_LONG_OPTIONS
-		//bb_error_msg("flags:%x FILEUTILS_RMDEST:%x OPT_parents:%x",
-		//	flags, FILEUTILS_RMDEST, OPT_parents);
-		if (flags & OPT_parents) {
-			if (!(d_flags & 2)) {
-				bb_simple_error_msg_and_die("with --parents, the destination must be a directory");
+			//bb_error_msg("flags:%x FILEUTILS_RMDEST:%x OPT_parents:%x",
+			//	flags, FILEUTILS_RMDEST, OPT_parents);
+			if (flags & OPT_parents) {
+				if (!(d_flags & 2)) {
+					bb_simple_error_msg_and_die("with --parents, the destination must be a directory");
+				}
+			}
+			if (flags & FILEUTILS_RMDEST) {
+				flags |= FILEUTILS_FORCE;
 			}
-		}
-		if (flags & FILEUTILS_RMDEST) {
-			flags |= FILEUTILS_FORCE;
-		}
 #endif
 
-		/* ...if neither is a directory...  */
-		if (!((s_flags | d_flags) & 2)
-		    /* ...or: recursing, the 1st is a directory, and the 2nd doesn't exist... */
-		 || ((flags & FILEUTILS_RECUR) && (s_flags & 2) && !d_flags)
-		 || (flags & FILEUTILS_NO_TARGET_DIR)
-		) {
-			/* Do a simple copy */
-			dest = last;
-			goto DO_COPY; /* NB: argc==2 -> *++argv==last */
+			/* ...if neither is a directory...  */
+			if (!((s_flags | d_flags) & 2)
+			    /* ...or: recursing, the 1st is a directory, and the 2nd doesn't exist... */
+			 || ((flags & FILEUTILS_RECUR) && (s_flags & 2) && !d_flags)
+			 || (flags & FILEUTILS_NO_TARGET_DIR)
+			) {
+				/* Do a simple copy */
+				dest = last;
+				goto DO_COPY; /* NB: argc==2 -> *++argv==last */
+			}
 		}
-	} else if (flags & FILEUTILS_NO_TARGET_DIR) {
-		bb_simple_error_msg_and_die("too many arguments");
 	}
+	/* else: last is DIR from "-t DIR" */
 
 	while (1) {
 #if ENABLE_FEATURE_CP_LONG_OPTIONS
@@ -259,7 +272,7 @@ int cp_main(int argc, char **argv)
 		if (copy_file(*argv, dest, flags) < 0) {
 			status = EXIT_FAILURE;
 		}
-		if (*++argv == last) {
+		if (!*++argv || *argv == last) {
 			/* possibly leaking dest... */
 			break;
 		}
diff -urpN busybox-1.33.1/coreutils/cut.c busybox-1.34.0/coreutils/cut.c
--- busybox-1.33.1/coreutils/cut.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/cut.c	2021-07-20 21:57:20.000000000 +0700
@@ -14,6 +14,13 @@
 //config:	help
 //config:	cut is used to print selected parts of lines from
 //config:	each file to stdout.
+//config:
+//config:config FEATURE_CUT_REGEX
+//config:	bool "cut -F"
+//config:	default y
+//config:	depends on CUT
+//config:	help
+//config:	Allow regex based delimiters.
 
 //applet:IF_CUT(APPLET_NOEXEC(cut, cut, BB_DIR_USR_BIN, BB_SUID_DROP, cut))
 
@@ -22,13 +29,19 @@
 //usage:#define cut_trivial_usage
 //usage:       "[OPTIONS] [FILE]..."
 //usage:#define cut_full_usage "\n\n"
-//usage:       "Print selected fields from each input FILE to stdout\n"
+//usage:       "Print selected fields from FILEs to stdout\n"
 //usage:     "\n	-b LIST	Output only bytes from LIST"
 //usage:     "\n	-c LIST	Output only characters from LIST"
-//usage:     "\n	-d CHAR	Use CHAR instead of tab as the field delimiter"
-//usage:     "\n	-s	Output only the lines containing delimiter"
-//usage:     "\n	-f N	Print only these fields"
+//usage:     "\n	-d SEP	Field delimiter for input (default -f TAB, -F run of whitespace)"
+//usage:     "\n	-O SEP	Field delimeter for output (default = -d for -f, one space for -F)"
+//usage:     "\n	-D	Don't sort/collate sections or match -fF lines without delimeter"
+//usage:     "\n	-f LIST	Print only these fields (-d is single char)"
+//usage:     IF_FEATURE_CUT_REGEX(
+//usage:     "\n	-F LIST	Print only these fields (-d is regex)"
+//usage:     )
+//usage:     "\n	-s	Output only lines containing delimiter"
 //usage:     "\n	-n	Ignored"
+//(manpage:-n	with -b: don't split multibyte characters)
 //usage:
 //usage:#define cut_example_usage
 //usage:       "$ echo \"Hello world\" | cut -f 1 -d ' '\n"
@@ -38,38 +51,49 @@
 
 #include "libbb.h"
 
+#if ENABLE_FEATURE_CUT_REGEX
+#include "xregex.h"
+#else
+#define regex_t int
+typedef struct { int rm_eo, rm_so; } regmatch_t;
+#define xregcomp(x, ...) *(x) = 0
+#define regexec(...)     0
+#endif
+
 /* This is a NOEXEC applet. Be very careful! */
 
 
 /* option vars */
-#define OPT_STR "b:c:f:d:sn"
+#define OPT_STR "b:c:f:d:O:sD"IF_FEATURE_CUT_REGEX("F:")"n"
 #define CUT_OPT_BYTE_FLGS     (1 << 0)
 #define CUT_OPT_CHAR_FLGS     (1 << 1)
 #define CUT_OPT_FIELDS_FLGS   (1 << 2)
 #define CUT_OPT_DELIM_FLGS    (1 << 3)
-#define CUT_OPT_SUPPRESS_FLGS (1 << 4)
+#define CUT_OPT_ODELIM_FLGS   (1 << 4)
+#define CUT_OPT_SUPPRESS_FLGS (1 << 5)
+#define CUT_OPT_NOSORT_FLGS   (1 << 6)
+#define CUT_OPT_REGEX_FLGS    ((1 << 7) * ENABLE_FEATURE_CUT_REGEX)
 
 struct cut_list {
 	int startpos;
 	int endpos;
 };
 
-enum {
-	BOL = 0,
-	EOL = INT_MAX,
-	NON_RANGE = -1
-};
-
 static int cmpfunc(const void *a, const void *b)
 {
 	return (((struct cut_list *) a)->startpos -
 			((struct cut_list *) b)->startpos);
 }
 
-static void cut_file(FILE *file, char delim, const struct cut_list *cut_lists, unsigned nlists)
+static void cut_file(FILE *file, const char *delim, const char *odelim,
+		const struct cut_list *cut_lists, unsigned nlists)
 {
 	char *line;
 	unsigned linenum = 0;	/* keep these zero-based to be consistent */
+	regex_t reg;
+	int spos, shoe = option_mask32 & CUT_OPT_REGEX_FLGS;
+
+	if (shoe) xregcomp(&reg, delim, REG_EXTENDED);
 
 	/* go through every line in the file */
 	while ((line = xmalloc_fgetline(file)) != NULL) {
@@ -79,29 +103,22 @@ static void cut_file(FILE *file, char de
 		char *printed = xzalloc(linelen + 1);
 		char *orig_line = line;
 		unsigned cl_pos = 0;
-		int spos;
 
 		/* cut based on chars/bytes XXX: only works when sizeof(char) == byte */
 		if (option_mask32 & (CUT_OPT_CHAR_FLGS | CUT_OPT_BYTE_FLGS)) {
 			/* print the chars specified in each cut list */
 			for (; cl_pos < nlists; cl_pos++) {
-				spos = cut_lists[cl_pos].startpos;
-				while (spos < linelen) {
+				for (spos = cut_lists[cl_pos].startpos; spos < linelen;) {
 					if (!printed[spos]) {
 						printed[spos] = 'X';
 						putchar(line[spos]);
 					}
-					spos++;
-					if (spos > cut_lists[cl_pos].endpos
-					/* NON_RANGE is -1, so if below is true,
-					 * the above was true too (spos is >= 0) */
-					/* || cut_lists[cl_pos].endpos == NON_RANGE */
-					) {
+					if (++spos > cut_lists[cl_pos].endpos) {
 						break;
 					}
 				}
 			}
-		} else if (delim == '\n') {	/* cut by lines */
+		} else if (*delim == '\n') {	/* cut by lines */
 			spos = cut_lists[cl_pos].startpos;
 
 			/* get out if we have no more lists to process or if the lines
@@ -114,9 +131,7 @@ static void cut_file(FILE *file, char de
 			while (spos < (int)linenum) {
 				spos++;
 				/* go to the next list if we're at the end of this one */
-				if (spos > cut_lists[cl_pos].endpos
-				 || cut_lists[cl_pos].endpos == NON_RANGE
-				) {
+				if (spos > cut_lists[cl_pos].endpos) {
 					cl_pos++;
 					/* get out if there's no more lists to process */
 					if (cl_pos >= nlists)
@@ -134,55 +149,56 @@ static void cut_file(FILE *file, char de
 			puts(line);
 			goto next_line;
 		} else {		/* cut by fields */
-			int ndelim = -1;	/* zero-based / one-based problem */
-			int nfields_printed = 0;
-			char *field = NULL;
-			char delimiter[2];
-
-			delimiter[0] = delim;
-			delimiter[1] = 0;
-
-			/* does this line contain any delimiters? */
-			if (strchr(line, delim) == NULL) {
-				if (!(option_mask32 & CUT_OPT_SUPPRESS_FLGS))
-					puts(line);
-				goto next_line;
-			}
-
-			/* process each list on this line, for as long as we've got
-			 * a line to process */
-			for (; cl_pos < nlists && line; cl_pos++) {
-				spos = cut_lists[cl_pos].startpos;
-				do {
-					/* find the field we're looking for */
-					while (line && ndelim < spos) {
-						field = strsep(&line, delimiter);
-						ndelim++;
-					}
+			unsigned uu = 0, start = 0, end = 0, out = 0;
+			int dcount = 0;
 
-					/* we found it, and it hasn't been printed yet */
-					if (field && ndelim == spos && !printed[ndelim]) {
-						/* if this isn't our first time through, we need to
-						 * print the delimiter after the last field that was
-						 * printed */
-						if (nfields_printed > 0)
-							putchar(delim);
-						fputs(field, stdout);
-						printed[ndelim] = 'X';
-						nfields_printed++;	/* shouldn't overflow.. */
+			/* Loop through bytes, finding next delimiter */
+			for (;;) {
+				/* End of current range? */
+				if (end == linelen || dcount > cut_lists[cl_pos].endpos) {
+					if (++cl_pos >= nlists) break;
+					if (option_mask32 & CUT_OPT_NOSORT_FLGS)
+						start = dcount = uu = 0;
+					end = 0;
+				}
+				/* End of current line? */
+				if (uu == linelen) {
+					/* If we've seen no delimiters, check -s */
+					if (!cl_pos && !dcount && !shoe) {
+						if (option_mask32 & CUT_OPT_SUPPRESS_FLGS)
+							goto next_line;
+					} else if (dcount<cut_lists[cl_pos].startpos)
+						start = linelen;
+					end = linelen;
+				} else {
+					/* Find next delimiter */
+					if (shoe) {
+						regmatch_t rr = {-1, -1};
+
+						if (!regexec(&reg, line+uu, 1, &rr, REG_NOTBOL|REG_NOTEOL)) {
+							end = uu + rr.rm_so;
+							uu += rr.rm_eo;
+						} else {
+							uu = linelen;
+							continue;
+						}
+					} else if (line[end = uu++] != *delim)
+						continue;
+
+					/* Got delimiter. Loop if not yet within range. */
+					if (dcount++ < cut_lists[cl_pos].startpos) {
+						start = uu;
+						continue;
 					}
-
-					spos++;
-
-					/* keep going as long as we have a line to work with,
-					 * this is a list, and we're not at the end of that
-					 * list */
-				} while (spos <= cut_lists[cl_pos].endpos && line
-						&& cut_lists[cl_pos].endpos != NON_RANGE);
+				}
+				if (end != start || !shoe)
+					printf("%s%.*s", out++ ? odelim : "", end-start, line + start);
+				start = uu;
+				if (!dcount)
+					break;
 			}
 		}
-		/* if we printed anything at all, we need to finish it with a
-		 * newline cuz we were handed a chomped line */
+		/* if we printed anything, finish with newline */
 		putchar('\n');
  next_line:
 		linenum++;
@@ -197,37 +213,35 @@ int cut_main(int argc UNUSED_PARAM, char
 	/* growable array holding a series of lists */
 	struct cut_list *cut_lists = NULL;
 	unsigned nlists = 0;	/* number of elements in above list */
-	char delim = '\t';	/* delimiter, default is tab */
 	char *sopt, *ltok;
+	const char *delim = NULL;
+	const char *odelim = NULL;
 	unsigned opt;
 
+#define ARG "bcf"IF_FEATURE_CUT_REGEX("F")
 	opt = getopt32(argv, "^"
-			OPT_STR
-			"\0" "b--bcf:c--bcf:f--bcf",
-			&sopt, &sopt, &sopt, &ltok
+			OPT_STR  // = "b:c:f:d:O:sD"IF_FEATURE_CUT_REGEX("F:")"n"
+			"\0" "b--"ARG":c--"ARG":f--"ARG IF_FEATURE_CUT_REGEX("F--"ARG),
+			&sopt, &sopt, &sopt, &delim, &odelim IF_FEATURE_CUT_REGEX(, &sopt)
 	);
+	if (!delim || !*delim)
+		delim = (opt & CUT_OPT_REGEX_FLGS) ? "[[:space:]]+" : "\t";
+	if (!odelim) odelim = (opt & CUT_OPT_REGEX_FLGS) ? " " : delim;
+
 //	argc -= optind;
 	argv += optind;
-	if (!(opt & (CUT_OPT_BYTE_FLGS | CUT_OPT_CHAR_FLGS | CUT_OPT_FIELDS_FLGS)))
+	if (!(opt & (CUT_OPT_BYTE_FLGS | CUT_OPT_CHAR_FLGS | CUT_OPT_FIELDS_FLGS | CUT_OPT_REGEX_FLGS)))
 		bb_simple_error_msg_and_die("expected a list of bytes, characters, or fields");
 
-	if (opt & CUT_OPT_DELIM_FLGS) {
-		if (ltok[0] && ltok[1]) { /* more than 1 char? */
-			bb_simple_error_msg_and_die("the delimiter must be a single character");
-		}
-		delim = ltok[0];
-	}
-
 	/*  non-field (char or byte) cutting has some special handling */
-	if (!(opt & CUT_OPT_FIELDS_FLGS)) {
+	if (!(opt & (CUT_OPT_FIELDS_FLGS|CUT_OPT_REGEX_FLGS))) {
 		static const char _op_on_field[] ALIGN1 = " only when operating on fields";
 
 		if (opt & CUT_OPT_SUPPRESS_FLGS) {
 			bb_error_msg_and_die
-				("suppressing non-delimited lines makes sense%s",
-				_op_on_field);
+				("suppressing non-delimited lines makes sense%s", _op_on_field);
 		}
-		if (delim != '\t') {
+		if (opt & CUT_OPT_DELIM_FLGS) {
 			bb_error_msg_and_die
 				("a delimiter may be specified%s", _op_on_field);
 		}
@@ -252,7 +266,7 @@ int cut_main(int argc UNUSED_PARAM, char
 			/* get the start pos */
 			ntok = strsep(&ltok, "-");
 			if (!ntok[0]) {
-				s = BOL;
+				s = 0;
 			} else {
 				s = xatoi_positive(ntok);
 				/* account for the fact that arrays are zero based, while
@@ -263,24 +277,23 @@ int cut_main(int argc UNUSED_PARAM, char
 
 			/* get the end pos */
 			if (ltok == NULL) {
-				e = NON_RANGE;
+				e = s;
 			} else if (!ltok[0]) {
-				e = EOL;
+				e = INT_MAX;
 			} else {
 				e = xatoi_positive(ltok);
 				/* if the user specified and end position of 0,
 				 * that means "til the end of the line" */
-				if (e == 0)
-					e = EOL;
+				if (!*ltok)
+					e = INT_MAX;
+				else if (e < s)
+					bb_error_msg_and_die("%d<%d", e, s);
 				e--;	/* again, arrays are zero based, lines are 1 based */
-				if (e == s)
-					e = NON_RANGE;
 			}
 
 			/* add the new list */
 			cut_lists = xrealloc_vector(cut_lists, 4, nlists);
-			/* NB: startpos is always >= 0,
-			 * while endpos may be = NON_RANGE (-1) */
+			/* NB: startpos is always >= 0 */
 			cut_lists[nlists].startpos = s;
 			cut_lists[nlists].endpos = e;
 			nlists++;
@@ -293,7 +306,8 @@ int cut_main(int argc UNUSED_PARAM, char
 		/* now that the lists are parsed, we need to sort them to make life
 		 * easier on us when it comes time to print the chars / fields / lines
 		 */
-		qsort(cut_lists, nlists, sizeof(cut_lists[0]), cmpfunc);
+		if (!(opt & CUT_OPT_NOSORT_FLGS))
+			qsort(cut_lists, nlists, sizeof(cut_lists[0]), cmpfunc);
 	}
 
 	{
@@ -308,7 +322,7 @@ int cut_main(int argc UNUSED_PARAM, char
 				retval = EXIT_FAILURE;
 				continue;
 			}
-			cut_file(file, delim, cut_lists, nlists);
+			cut_file(file, delim, odelim, cut_lists, nlists);
 			fclose_if_not_stdin(file);
 		} while (*++argv);
 
diff -urpN busybox-1.33.1/coreutils/dd.c busybox-1.34.0/coreutils/dd.c
--- busybox-1.33.1/coreutils/dd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/dd.c	2021-08-16 04:06:08.000000000 +0700
@@ -56,10 +56,10 @@
 //kbuild:lib-$(CONFIG_DD) += dd.o
 
 //usage:#define dd_trivial_usage
-//usage:       "[if=FILE] [of=FILE] [" IF_FEATURE_DD_IBS_OBS("ibs=N obs=N/") "bs=N] [count=N] [skip=N] [seek=N]\n"
-//usage:	IF_FEATURE_DD_IBS_OBS(
+//usage:       "[if=FILE] [of=FILE] [" IF_FEATURE_DD_IBS_OBS("ibs=N obs=N/") "bs=N] [count=N] [skip=N] [seek=N]"
+//usage:	IF_FEATURE_DD_IBS_OBS("\n"
 //usage:       "	[conv=notrunc|noerror|sync|fsync]\n"
-//usage:       "	[iflag=skip_bytes|fullblock|direct] [oflag=seek_bytes|append|direct]"
+//usage:       "	[iflag=skip_bytes|count_bytes|fullblock|direct] [oflag=seek_bytes|append|direct]"
 //usage:	)
 //usage:#define dd_full_usage "\n\n"
 //usage:       "Copy a file with converting and formatting\n"
@@ -82,6 +82,7 @@
 //usage:     "\n	conv=fsync	Physically write data out before finishing"
 //usage:     "\n	conv=swab	Swap every pair of bytes"
 //usage:     "\n	iflag=skip_bytes	skip=N is in bytes"
+//usage:     "\n	iflag=count_bytes	count=N is in bytes"
 //usage:     "\n	oflag=seek_bytes	seek=N is in bytes"
 //usage:     "\n	iflag=direct	O_DIRECT input"
 //usage:     "\n	oflag=direct	O_DIRECT output"
@@ -136,21 +137,22 @@ enum {
 	FLAG_SWAB    = (1 << 4) * ENABLE_FEATURE_DD_IBS_OBS,
 	/* end of conv flags */
 	/* start of input flags */
-	FLAG_IFLAG_SHIFT = 5,
-	FLAG_SKIP_BYTES = (1 << 5) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_FULLBLOCK = (1 << 6) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_IDIRECT = (1 << 7) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_IFLAG_SHIFT   = 5,
+	FLAG_SKIP_BYTES    = (1 << 5) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_COUNT_BYTES   = (1 << 6) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_FULLBLOCK     = (1 << 7) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_IDIRECT       = (1 << 8) * ENABLE_FEATURE_DD_IBS_OBS,
 	/* end of input flags */
 	/* start of output flags */
-	FLAG_OFLAG_SHIFT = 8,
-	FLAG_SEEK_BYTES = (1 << 8) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_APPEND = (1 << 9) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_ODIRECT = (1 << 10) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_OFLAG_SHIFT   = 9,
+	FLAG_SEEK_BYTES    = (1 << 9) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_APPEND        = (1 << 10) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_ODIRECT       = (1 << 11) * ENABLE_FEATURE_DD_IBS_OBS,
 	/* end of output flags */
-	FLAG_TWOBUFS = (1 << 11) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_COUNT   = 1 << 12,
-	FLAG_STATUS_NONE = 1 << 13,
-	FLAG_STATUS_NOXFER = 1 << 14,
+	FLAG_TWOBUFS       = (1 << 12) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_COUNT         = 1 << 13,
+	FLAG_STATUS_NONE   = 1 << 14,
+	FLAG_STATUS_NOXFER = 1 << 15,
 };
 
 static void dd_output_status(int UNUSED_PARAM cur_signal)
@@ -175,8 +177,9 @@ static void dd_output_status(int UNUSED_
 	//So far we react to it (we print the stats),
 	//status=none only suppresses final, non-USR1 generated status message.
 # endif
-	fprintf(stderr, "%llu bytes (%sB) copied, ",
-			G.total_bytes,
+	fprintf(stderr, /*G.total_bytes < 1024
+				? "%llu bytes copied, " : */ "%llu bytes (%sB) copied, "
+			, G.total_bytes,
 			/* show fractional digit, use suffixes */
 			make_human_readable_str(G.total_bytes, 1, 0)
 	);
@@ -317,7 +320,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	static const char conv_words[] ALIGN1 =
 		"notrunc\0""sync\0""noerror\0""fsync\0""swab\0";
 	static const char iflag_words[] ALIGN1 =
-		"skip_bytes\0""fullblock\0""direct\0";
+		"skip_bytes\0""count_bytes\0""fullblock\0""direct\0";
 	static const char oflag_words[] ALIGN1 =
 		"seek_bytes\0append\0""direct\0";
 #endif
@@ -359,6 +362,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	/* Partially implemented: */
 	//swab          swap every pair of input bytes: will abort on non-even reads
 		OP_iflag_skip_bytes,
+		OP_iflag_count_bytes,
 		OP_iflag_fullblock,
 		OP_iflag_direct,
 		OP_oflag_seek_bytes,
@@ -551,8 +555,17 @@ int dd_main(int argc UNUSED_PARAM, char
 			goto die_outfile;
 	}
 
-	while (!(G.flags & FLAG_COUNT) || (G.in_full + G.in_part != count)) {
-		ssize_t n = dd_read(ibuf, ibs);
+	while (1) {
+		ssize_t n = ibs;
+
+		if (G.flags & FLAG_COUNT) {
+			if (count == 0)
+				break;
+			if ((G.flags & FLAG_COUNT_BYTES) && count < ibs)
+				n = count;
+		}
+
+		n = dd_read(ibuf, n);
 		if (n == 0)
 			break;
 		if (n < 0) {
@@ -587,6 +600,7 @@ int dd_main(int argc UNUSED_PARAM, char
 				p16++;
 			}
 		}
+		count -= (G.flags & FLAG_COUNT_BYTES) ? n : 1;
 		if ((size_t)n == ibs)
 			G.in_full++;
 		else {
diff -urpN busybox-1.33.1/coreutils/df.c busybox-1.34.0/coreutils/df.c
--- busybox-1.33.1/coreutils/df.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/df.c	2021-07-20 21:57:20.000000000 +0700
@@ -45,7 +45,7 @@
 //usage:	IF_FEATURE_HUMAN_READABLE("mh")
 //usage:	"T"
 //usage:	IF_FEATURE_DF_FANCY("ai] [-B SIZE")
-//usage:	"] [FILESYSTEM]..."
+//usage:	"] [-t TYPE] [FILESYSTEM]..."
 //usage:#define df_full_usage "\n\n"
 //usage:       "Print filesystem usage statistics\n"
 //usage:     "\n	-P	POSIX output format"
@@ -55,6 +55,7 @@
 //usage:     "\n	-h	Human readable (e.g. 1K 243M 2G)"
 //usage:	)
 //usage:     "\n	-T	Print filesystem type"
+//usage:     "\n	-t TYPE	Print only mounts of this type"
 //usage:	IF_FEATURE_DF_FANCY(
 //usage:     "\n	-a	Show all filesystems"
 //usage:     "\n	-i	Inodes"
@@ -97,24 +98,31 @@ int df_main(int argc UNUSED_PARAM, char
 	FILE *mount_table;
 	struct mntent *mount_entry;
 	struct statvfs s;
-
 	enum {
-		OPT_KILO  = (1 << 0),
-		OPT_POSIX = (1 << 1),
-		OPT_FSTYPE  = (1 << 2),
-		OPT_ALL   = (1 << 3) * ENABLE_FEATURE_DF_FANCY,
-		OPT_INODE = (1 << 4) * ENABLE_FEATURE_DF_FANCY,
-		OPT_BSIZE = (1 << 5) * ENABLE_FEATURE_DF_FANCY,
-		OPT_HUMAN = (1 << (3 + 3*ENABLE_FEATURE_DF_FANCY)) * ENABLE_FEATURE_HUMAN_READABLE,
-		OPT_MEGA  = (1 << (4 + 3*ENABLE_FEATURE_DF_FANCY)) * ENABLE_FEATURE_HUMAN_READABLE,
+		OPT_KILO   = (1 << 0),
+		OPT_POSIX  = (1 << 1),
+		OPT_FSTYPE = (1 << 2),
+		OPT_t      = (1 << 3),
+		OPT_ALL    = (1 << 4) * ENABLE_FEATURE_DF_FANCY,
+		OPT_INODE  = (1 << 5) * ENABLE_FEATURE_DF_FANCY,
+		OPT_BSIZE  = (1 << 6) * ENABLE_FEATURE_DF_FANCY,
+		OPT_HUMAN  = (1 << (4 + 3*ENABLE_FEATURE_DF_FANCY)) * ENABLE_FEATURE_HUMAN_READABLE,
+		OPT_MEGA   = (1 << (5 + 3*ENABLE_FEATURE_DF_FANCY)) * ENABLE_FEATURE_HUMAN_READABLE,
 	};
 	const char *disp_units_hdr = NULL;
-	char *chp;
+	char *chp, *opt_t;
 
 	init_unicode();
 
+	/* From the manpage of df from coreutils-6.10:
+	 * Disk space is shown in 1K blocks by default, unless the environment
+	 * variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used.
+	 */
+	if (getenv("POSIXLY_CORRECT")) /* TODO - a new libbb function? */
+		df_disp_hr = 512;
+
 	opt = getopt32(argv, "^"
-			"kPT"
+			"kPTt:"
 			IF_FEATURE_DF_FANCY("aiB:")
 			IF_FEATURE_HUMAN_READABLE("hm")
 			"\0"
@@ -123,6 +131,7 @@ int df_main(int argc UNUSED_PARAM, char
 #elif ENABLE_FEATURE_HUMAN_READABLE
 			"k-m:m-k"
 #endif
+			, &opt_t
 			IF_FEATURE_DF_FANCY(, &chp)
 	);
 	if (opt & OPT_MEGA)
@@ -142,13 +151,6 @@ int df_main(int argc UNUSED_PARAM, char
  got_it: ;
 	}
 
-	/* From the manpage of df from coreutils-6.10:
-	 * Disk space is shown in 1K blocks by default, unless the environment
-	 * variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used.
-	 */
-	if (getenv("POSIXLY_CORRECT")) /* TODO - a new libbb function? */
-		df_disp_hr = 512;
-
 	if (opt & OPT_HUMAN) {
 		df_disp_hr = 0;
 		disp_units_hdr = "     Size";
@@ -214,6 +216,11 @@ int df_main(int argc UNUSED_PARAM, char
 		mount_point = mount_entry->mnt_dir;
 		fs_type = mount_entry->mnt_type;
 
+		if (opt & OPT_t) {
+			if (strcmp(fs_type, opt_t) != 0)
+				continue;
+		}
+
 		if (statvfs(mount_point, &s) != 0) {
 			bb_simple_perror_msg(mount_point);
 			goto set_error;
diff -urpN busybox-1.33.1/coreutils/du.c busybox-1.34.0/coreutils/du.c
--- busybox-1.33.1/coreutils/du.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/du.c	2021-07-20 21:57:20.000000000 +0700
@@ -40,8 +40,9 @@
 //usage:#define du_trivial_usage
 //usage:       "[-aHLdclsx" IF_FEATURE_HUMAN_READABLE("hm") "k] [FILE]..."
 //usage:#define du_full_usage "\n\n"
-//usage:       "Summarize disk space used for each FILE and/or directory\n"
+//usage:       "Summarize disk space used for FILEs (or directories)\n"
 //usage:     "\n	-a	Show file sizes too"
+//usage:     "\n	-b	Apparent size (including holes)"
 //usage:     "\n	-L	Follow all symlinks"
 //usage:     "\n	-H	Follow symlinks on command line"
 //usage:     "\n	-d N	Limit output to directories (and files with -a) of depth < N"
@@ -84,8 +85,9 @@ enum {
 	OPT_d_maxdepth     = (1 << 6),
 	OPT_l_hardlinks    = (1 << 7),
 	OPT_c_total        = (1 << 8),
-	OPT_h_for_humans   = (1 << 9),
-	OPT_m_mbytes       = (1 << 10),
+	OPT_b              = (1 << 9),
+	OPT_h_for_humans   = (1 << 10),
+	OPT_m_mbytes       = (1 << 11),
 };
 
 struct globals {
@@ -109,7 +111,7 @@ static void print(unsigned long long siz
 	/* TODO - May not want to defer error checking here. */
 #if ENABLE_FEATURE_HUMAN_READABLE
 # if ENABLE_DESKTOP
-	/* ~30 bytes of code for extra comtat:
+	/* ~30 bytes of code for extra compat:
 	 * coreutils' du rounds sizes up:
 	 * for example,  1025k file is shown as "2" by du -m.
 	 * We round to nearest if human-readable [too hard to fix],
@@ -124,12 +126,16 @@ static void print(unsigned long long siz
 			 * If G.disp_unit == 0, show one fractional
 			 * and use suffixes
 			 */
-			make_human_readable_str(size, 512, G.disp_unit),
+			make_human_readable_str(size, (option_mask32 & OPT_b) ? 1 : 512, G.disp_unit),
 			filename);
 #else
 	if (G.disp_k) {
-		size++;
-		size >>= 1;
+		if (!(option_mask32 & OPT_b)) {
+			size++;
+			size >>= 1;
+		} else {
+			size >>= 10;
+		}
 	}
 	printf("%llu\t%s\n", size, filename);
 #endif
@@ -155,7 +161,7 @@ static unsigned long long du(const char
 		}
 	}
 
-	sum = statbuf.st_blocks;
+	sum = ((option_mask32 & OPT_b) ? statbuf.st_size : statbuf.st_blocks);
 
 	if (S_ISLNK(statbuf.st_mode)) {
 		if (G.slink_depth > G.du_depth) { /* -H or -L */
@@ -164,7 +170,7 @@ static unsigned long long du(const char
 				G.status = EXIT_FAILURE;
 				return 0;
 			}
-			sum = statbuf.st_blocks;
+			sum = ((option_mask32 & OPT_b) ? statbuf.st_size : statbuf.st_blocks);
 			if (G.slink_depth == 1) {
 				/* Convert -H to -L */
 				G.slink_depth = INT_MAX;
@@ -241,11 +247,14 @@ int du_main(int argc UNUSED_PARAM, char
 	 */
 #if ENABLE_FEATURE_HUMAN_READABLE
 	opt = getopt32(argv, "^"
-			"aHkLsxd:+lchm"
+			"aHkLsxd:+lcbhm"
 			"\0" "h-km:k-hm:m-hk:H-L:L-H:s-d:d-s",
 			&G.max_print_depth
 	);
 	argv += optind;
+	if (opt & OPT_b) {
+		G.disp_unit = 1;
+	}
 	if (opt & OPT_h_for_humans) {
 		G.disp_unit = 0;
 	}
@@ -257,16 +266,16 @@ int du_main(int argc UNUSED_PARAM, char
 	}
 #else
 	opt = getopt32(argv, "^"
-			"aHkLsxd:+lc"
+			"aHkLsxd:+lcb"
 			"\0" "H-L:L-H:s-d:d-s",
 			&G.max_print_depth
 	);
 	argv += optind;
-#if !ENABLE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K
+# if !ENABLE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K
 	if (opt & OPT_k_kbytes) {
 		G.disp_k = 1;
 	}
-#endif
+# endif
 #endif
 	if (opt & OPT_H_follow_links) {
 		G.slink_depth = 1;
diff -urpN busybox-1.33.1/coreutils/echo.c busybox-1.34.0/coreutils/echo.c
--- busybox-1.33.1/coreutils/echo.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/echo.c	2021-06-16 17:02:16.000000000 +0700
@@ -43,10 +43,10 @@
 //usage:#define echo_trivial_usage
 //usage:	IF_FEATURE_FANCY_ECHO("[-neE] ") "[ARG]..."
 //usage:#define echo_full_usage "\n\n"
-//usage:       "Print the specified ARGs to stdout"
+//usage:       "Print ARGs to stdout"
 //usage:	IF_FEATURE_FANCY_ECHO( "\n"
-//usage:     "\n	-n	Suppress trailing newline"
-//usage:     "\n	-e	Interpret backslash escapes (i.e., \\t=tab)"
+//usage:     "\n	-n	No trailing newline"
+//usage:     "\n	-e	Interpret backslash escapes (\\t=tab etc)"
 //usage:     "\n	-E	Don't interpret backslash escapes (default)"
 //usage:	)
 //usage:
@@ -87,6 +87,7 @@ int echo_main(int argc UNUSED_PARAM, cha
 	char *out;
 	char *buffer;
 	unsigned buflen;
+	int err;
 #if !ENABLE_FEATURE_FANCY_ECHO
 	enum {
 		eflag = 0,  /* 0 -- disable escape sequences */
@@ -185,13 +186,12 @@ int echo_main(int argc UNUSED_PARAM, cha
  do_write:
 	/* Careful to error out on partial writes too (think ENOSPC!) */
 	errno = 0;
-	/*r =*/ full_write(STDOUT_FILENO, buffer, out - buffer);
-	free(buffer);
-	if (/*WRONG:r < 0*/ errno) {
+	err = full_write(STDOUT_FILENO, buffer, out - buffer) != out - buffer;
+	if (err) {
 		bb_simple_perror_msg(bb_msg_write_error);
-		return 1;
 	}
-	return 0;
+	free(buffer);
+	return err;
 }
 
 /*
diff -urpN busybox-1.33.1/coreutils/env.c busybox-1.34.0/coreutils/env.c
--- busybox-1.33.1/coreutils/env.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/env.c	2021-07-20 21:57:20.000000000 +0700
@@ -39,12 +39,15 @@
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/env.html */
 
 //usage:#define env_trivial_usage
-//usage:       "[-iu] [-] [name=value]... [PROG ARGS]"
+//usage:       "[-i0] [-u NAME]... [-] [NAME=VALUE]... [PROG ARGS]"
+// The "-" can occur only once (unlike, say, -i): it terminates option processing,
+// so if it is followed by another "-" arg (or any option-looking arg),
+// that arg will be taken as PROG (or even as NAME=VALUE, example: "-z=QWE").
 //usage:#define env_full_usage "\n\n"
-//usage:       "Print the current environment or run PROG after setting up\n"
-//usage:       "the specified environment\n"
-//usage:     "\n	-, -i	Start with an empty environment"
-//usage:     "\n	-u	Remove variable from the environment"
+//usage:       "Print current environment or run PROG after setting up environment\n"
+//usage:     "\n	-, -i	Start with empty environment"
+//usage:     "\n	-0	NUL terminated output"
+//usage:     "\n	-u NAME	Remove variable from environment"
 
 #include "libbb.h"
 
@@ -54,8 +57,9 @@ int env_main(int argc UNUSED_PARAM, char
 	unsigned opts;
 	llist_t *unset_env = NULL;
 
-	opts = getopt32long(argv, "+iu:*",
+	opts = getopt32long(argv, "+i0u:*",
 			"ignore-environment\0" No_argument       "i"
+			"null\0"               No_argument       "0"
 			"unset\0"              Required_argument "u"
 			, &unset_env
 	);
@@ -90,8 +94,9 @@ int env_main(int argc UNUSED_PARAM, char
 
 	if (environ) { /* clearenv() may set environ == NULL! */
 		char **ep;
+		opts = (opts & 2) ? 0 : '\n';
 		for (ep = environ; *ep; ep++) {
-			puts(*ep);
+			printf("%s%c", *ep, opts);
 		}
 	}
 
diff -urpN busybox-1.33.1/coreutils/expand.c busybox-1.34.0/coreutils/expand.c
--- busybox-1.33.1/coreutils/expand.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/expand.c	2021-04-15 00:05:01.000000000 +0700
@@ -123,7 +123,7 @@ static void expand(FILE *file, unsigned
 			}
 			ptr++;
 		}
-		fputs(ptr_strbeg, stdout);
+		fputs_stdout(ptr_strbeg);
 		free(line);
 	}
 }
diff -urpN busybox-1.33.1/coreutils/expr.c busybox-1.34.0/coreutils/expr.c
--- busybox-1.33.1/coreutils/expr.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/expr.c	2021-06-16 17:02:16.000000000 +0700
@@ -45,7 +45,7 @@
 //usage:#define expr_trivial_usage
 //usage:       "EXPRESSION"
 //usage:#define expr_full_usage "\n\n"
-//usage:       "Print the value of EXPRESSION to stdout\n"
+//usage:       "Print the value of EXPRESSION\n"
 //usage:    "\n"
 //usage:       "EXPRESSION may be:\n"
 //usage:       "	ARG1 | ARG2	ARG1 if it is neither null nor 0, otherwise ARG2\n"
@@ -63,7 +63,7 @@
 //usage:       "	ARG1 % ARG2\n"
 //usage:       "	STRING : REGEXP		Anchored pattern match of REGEXP in STRING\n"
 //usage:       "	match STRING REGEXP	Same as STRING : REGEXP\n"
-//usage:       "	substr STRING POS LENGTH Substring of STRING, POS counted from 1\n"
+//usage:       "	substr STRING POS LEN	Substring of STRING, POS counts from 1\n"
 //usage:       "	index STRING CHARS	Index in STRING where any CHARS is found, or 0\n"
 //usage:       "	length STRING		Length of STRING\n"
 //usage:       "	quote TOKEN		Interpret TOKEN as a string, even if\n"
diff -urpN busybox-1.33.1/coreutils/fold.c busybox-1.34.0/coreutils/fold.c
--- busybox-1.33.1/coreutils/fold.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/fold.c	2021-04-15 00:05:01.000000000 +0700
@@ -23,7 +23,7 @@
 //usage:#define fold_trivial_usage
 //usage:       "[-bs] [-w WIDTH] [FILE]..."
 //usage:#define fold_full_usage "\n\n"
-//usage:       "Wrap input lines in each FILE (or stdin), writing to stdout\n"
+//usage:       "Wrap input lines in FILEs (or stdin), writing to stdout\n"
 //usage:     "\n	-b	Count bytes rather than columns"
 //usage:     "\n	-s	Break at spaces"
 //usage:     "\n	-w	Use WIDTH columns instead of 80"
diff -urpN busybox-1.33.1/coreutils/head.c busybox-1.34.0/coreutils/head.c
--- busybox-1.33.1/coreutils/head.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/head.c	2021-06-16 17:02:16.000000000 +0700
@@ -29,17 +29,18 @@
 //usage:#define head_trivial_usage
 //usage:       "[OPTIONS] [FILE]..."
 //usage:#define head_full_usage "\n\n"
-//usage:       "Print first 10 lines of each FILE (or stdin) to stdout.\n"
+//usage:       "Print first 10 lines of FILEs (or stdin).\n"
 //usage:       "With more than one FILE, precede each with a filename header.\n"
-//usage:     "\n	-n N[kbm]	Print first N lines"
+//usage:     "\n	-n N[bkm]	Print first N lines"
+//usage:	IF_FEATURE_FANCY_HEAD(
+//usage:     "\n	-n -N[bkm]	Print all except N last lines"
+//usage:     "\n	-c [-]N[bkm]	Print first N bytes"
+//usage:	)
+//usage:     "\n			(b:*512 k:*1024 m:*1024^2)"
 //usage:	IF_FEATURE_FANCY_HEAD(
-//usage:     "\n	-n -N[kbm]	Print all except N last lines"
-//usage:     "\n	-c [-]N[kbm]	Print first N bytes"
 //usage:     "\n	-q		Never print headers"
 //usage:     "\n	-v		Always print headers"
 //usage:	)
-//usage:     "\n"
-//usage:     "\nN may be suffixed by k (x1024), b (x512), or m (x1024^2)."
 //usage:
 //usage:#define head_example_usage
 //usage:       "$ head -n 2 /etc/passwd\n"
@@ -117,7 +118,7 @@ print_except_N_last_lines(FILE *fp, unsi
 		char *c;
 		if (head == count)
 			head = 0;
-		fputs(circle[head], stdout);
+		fputs_stdout(circle[head]);
 		c = xmalloc_fgets(fp);
 		if (!c)
 			goto ret;
diff -urpN busybox-1.33.1/coreutils/id.c busybox-1.34.0/coreutils/id.c
--- busybox-1.33.1/coreutils/id.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/id.c	2021-06-16 17:02:16.000000000 +0700
@@ -52,7 +52,7 @@
 //usage:#define groups_trivial_usage
 //usage:       "[USER]"
 //usage:#define groups_full_usage "\n\n"
-//usage:       "Print the group memberships of USER or for the current process"
+//usage:       "Print the groups USER is in"
 //usage:
 //usage:#define groups_example_usage
 //usage:       "$ groups\n"
@@ -258,7 +258,7 @@ int id_main(int argc UNUSED_PARAM, char
 			bb_error_msg_and_die("can't get process context%s",
 				username ? " for a different user" : "");
 		}
-		fputs(scontext, stdout);
+		fputs_stdout(scontext);
 	}
 	/* freecon(NULL) seems to be harmless */
 	if (ENABLE_FEATURE_CLEAN_UP)
diff -urpN busybox-1.33.1/coreutils/ls.c busybox-1.34.0/coreutils/ls.c
--- busybox-1.33.1/coreutils/ls.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/ls.c	2021-06-16 17:02:16.000000000 +0700
@@ -109,11 +109,11 @@
 //usage:#define ls_full_usage "\n\n"
 //usage:       "List directory contents\n"
 //usage:     "\n	-1	One column output"
-//usage:     "\n	-a	Include entries which start with ."
+//usage:     "\n	-a	Include names starting with ."
 //usage:     "\n	-A	Like -a, but exclude . and .."
 ////usage:     "\n	-C	List by columns" - don't show, this is a default anyway
 //usage:     "\n	-x	List by lines"
-//usage:     "\n	-d	List directory entries instead of contents"
+//usage:     "\n	-d	List directory names, not contents"
 //usage:	IF_FEATURE_LS_FOLLOWLINKS(
 //usage:     "\n	-L	Follow symlinks"
 //usage:     "\n	-H	Follow symlinks on command line"
@@ -122,10 +122,10 @@
 //usage:     "\n	-R	Recurse"
 //usage:	)
 //usage:	IF_FEATURE_LS_FILETYPES(
-//usage:     "\n	-p	Append / to dir entries"
-//usage:     "\n	-F	Append indicator (one of */=@|) to entries"
+//usage:     "\n	-p	Append / to directory names"
+//usage:     "\n	-F	Append indicator (one of */=@|) to names"
 //usage:	)
-//usage:     "\n	-l	Long listing format"
+//usage:     "\n	-l	Long format"
 //usage:     "\n	-i	List inode numbers"
 //usage:     "\n	-n	List numeric UIDs and GIDs instead of names"
 //usage:     "\n	-s	List allocated blocks"
@@ -134,7 +134,7 @@
 //usage:     "\n	-lu	List atime"
 //usage:	)
 //usage:	IF_FEATURE_LS_TIMESTAMPS(IF_LONG_OPTS(
-//usage:     "\n	--full-time	List full date and time"
+//usage:     "\n	--full-time	List full date/time"
 //usage:	))
 //usage:	IF_FEATURE_HUMAN_READABLE(
 //usage:     "\n	-h	Human readable sizes (1K 243M 2G)"
@@ -160,7 +160,7 @@
 //usage:     "\n	-w N	Format N columns wide"
 //usage:	)
 //usage:	IF_FEATURE_LS_COLOR(
-//usage:     "\n	--color[={always,never,auto}]	Control coloring"
+//usage:     "\n	--color[={always,never,auto}]"
 //usage:	)
 
 #include "libbb.h"
@@ -187,7 +187,7 @@
 
 
 enum {
-TERMINAL_WIDTH  = 80,           /* use 79 if terminal has linefold bug */
+TERMINAL_WIDTH  = 80, /* use 79 if terminal has linefold bug */
 
 SPLIT_FILE      = 0,
 SPLIT_DIR       = 1,
@@ -298,7 +298,7 @@ struct dnode {
 // but there are invisible fields as well
 // (such as nanosecond-resolution timespamps)
 // and padding, which we also don't want to store.
-// We also can pre-parse dev_t dn_rdev (in glibc, it's huge).
+// We also pre-parse dev_t dn_rdev (in glibc, it's huge).
 // On 32-bit uclibc: dnode size went from 112 to 84 bytes.
 //
 	/* Same names as in struct stat, but with dn_ instead of st_ pfx: */
@@ -453,7 +453,7 @@ static unsigned print_name(const char *n
 	name = printable_string2(&uni_stat, name);
 
 	if (!(option_mask32 & OPT_Q)) {
-		fputs(name, stdout);
+		fputs_stdout(name);
 		return uni_stat.unicode_width;
 	}
 
@@ -1145,11 +1145,15 @@ int ls_main(int argc UNUSED_PARAM, char
 
 #if ENABLE_FEATURE_LS_COLOR
 	/* set G_show_color = 1/0 */
-	if (ENABLE_FEATURE_LS_COLOR_IS_DEFAULT && isatty(STDOUT_FILENO)) {
+	if (ENABLE_FEATURE_LS_COLOR_IS_DEFAULT && !is_TERM_dumb()) {
 		char *p = getenv("LS_COLORS");
 		/* LS_COLORS is unset, or (not empty && not "none") ? */
-		if (!p || (p[0] && strcmp(p, "none") != 0))
-			G_show_color = 1;
+		if (!p || (p[0] && strcmp(p, "none") != 0)) {
+			if (isatty(STDOUT_FILENO)) {
+				/* check isatty() last because it's expensive (syscall) */
+				G_show_color = 1;
+			}
+		}
 	}
 	if (opt & OPT_color) {
 		if (color_opt[0] == 'n')
@@ -1158,7 +1162,7 @@ int ls_main(int argc UNUSED_PARAM, char
 		case 3:
 		case 4:
 		case 5:
-			if (isatty(STDOUT_FILENO)) {
+			if (!is_TERM_dumb() && isatty(STDOUT_FILENO)) {
 		case 0:
 		case 1:
 		case 2:
diff -urpN busybox-1.33.1/coreutils/mknod.c busybox-1.34.0/coreutils/mknod.c
--- busybox-1.33.1/coreutils/mknod.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/mknod.c	2021-01-08 15:30:27.000000000 +0700
@@ -36,7 +36,9 @@
 //usage:       "$ mknod /dev/fd0 b 2 0\n"
 //usage:       "$ mknod -m 644 /tmp/pipe p\n"
 
-#include <sys/sysmacros.h>  // For makedev
+#ifdef __linux__
+# include <sys/sysmacros.h>  // For makedev
+#endif
 
 #include "libbb.h"
 #include "libcoreutils/coreutils.h"
diff -urpN busybox-1.33.1/coreutils/mv.c busybox-1.34.0/coreutils/mv.c
--- busybox-1.33.1/coreutils/mv.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/mv.c	2021-07-20 21:57:20.000000000 +0700
@@ -23,13 +23,15 @@
 //kbuild:lib-$(CONFIG_MV) += mv.o
 
 //usage:#define mv_trivial_usage
-//usage:       "[-fin] SOURCE DEST\n"
-//usage:       "or: mv [-fin] SOURCE... DIRECTORY"
+//usage:       "[-finT] SOURCE DEST\n"
+//usage:       "or: mv [-fin] SOURCE... { -t DIRECTORY | DIRECTORY }"
 //usage:#define mv_full_usage "\n\n"
-//usage:       "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY\n"
+//usage:       "Rename SOURCE to DEST, or move SOURCEs to DIRECTORY\n"
 //usage:     "\n	-f	Don't prompt before overwriting"
 //usage:     "\n	-i	Interactive, prompt before overwrite"
 //usage:     "\n	-n	Don't overwrite an existing file"
+//usage:     "\n	-T	Refuse to move if DEST is a directory"
+//usage:     "\n	-t DIR	Move all SOURCEs into DIR"
 //usage:
 //usage:#define mv_example_usage
 //usage:       "$ mv /tmp/foo /bin/bar\n"
@@ -40,7 +42,7 @@
 int mv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int mv_main(int argc, char **argv)
 {
-	struct stat dest_stat;
+	struct stat statbuf;
 	const char *last;
 	const char *dest;
 	unsigned flags;
@@ -51,41 +53,66 @@ int mv_main(int argc, char **argv)
 #define OPT_FORCE       (1 << 0)
 #define OPT_INTERACTIVE (1 << 1)
 #define OPT_NOCLOBBER   (1 << 2)
-#define OPT_VERBOSE     ((1 << 3) * ENABLE_FEATURE_VERBOSE)
-	/* Need at least two arguments.
-	 * If more than one of -f, -i, -n is specified , only the final one
-	 * takes effect (it unsets previous options).
-	 */
+#define OPT_DESTNOTDIR  (1 << 3)
+#define OPT_DESTDIR     (1 << 4)
+#define OPT_VERBOSE     ((1 << 5) * ENABLE_FEATURE_VERBOSE)
 	flags = getopt32long(argv, "^"
-			"finv"
+			"finTt:v"
 			"\0"
-			"-2:f-in:i-fn:n-fi",
+	/* At least one argument. (Usually two+, but -t DIR can have only one) */
+			"-1"
+	/* only the final one of -f, -i, -n takes effect */
+			":f-in:i-fn:n-fi"
+	/* -t and -T don't mix */
+			":t--T:T--t",
 			"interactive\0" No_argument "i"
 			"force\0"       No_argument "f"
 			"no-clobber\0"  No_argument "n"
+			"no-target-directory\0" No_argument "T"
+			"target-directory\0" Required_argument "t"
 			IF_FEATURE_VERBOSE(
-			"verbose\0"     No_argument "v"
+			"verbose\0"     No_argument "v",
+			&last
 			)
 	);
 	argc -= optind;
 	argv += optind;
-	last = argv[argc - 1];
 
-	if (argc == 2) {
-		dest_exists = cp_mv_stat(last, &dest_stat);
-		if (dest_exists < 0) {
-			return EXIT_FAILURE;
-		}
-
-		if (!(dest_exists & 2)) { /* last is not a directory */
-			dest = last;
-			goto DO_MOVE;
+	if (!(flags & OPT_DESTDIR)) {
+		last = argv[argc - 1];
+		if (argc < 2)
+			bb_show_usage();
+		if (argc != 2) {
+			if (flags & OPT_DESTNOTDIR)
+				bb_show_usage();
+			/* "mv A B C... DIR" - target must be dir */
+		} else /* argc == 2 */ {
+			/* "mv A B" - only case where target can be not a dir */
+			dest_exists = cp_mv_stat(last, &statbuf);
+			if (dest_exists < 0) { /* error other than ENOENT */
+				return EXIT_FAILURE;
+			}
+			if (!(dest_exists & 2)) {
+				/* last is not a directory */
+				dest = last;
+				goto DO_MOVE;
+			}
+			/* last is a directory */
+			if (flags & OPT_DESTNOTDIR) {
+				if (stat(argv[0], &statbuf) == 0 && !S_ISDIR(statbuf.st_mode))
+					bb_error_msg_and_die("'%s' is a directory", last);
+				/* "mv -T DIR1 DIR2" is allowed (renames a dir) */
+				dest = last;
+				goto DO_MOVE;
+			}
+			/* else: fall through into "do { move SRC to DIR/SRC } while" loop */
 		}
 	}
+	/* else: last is DIR from "-t DIR" */
 
 	do {
 		dest = concat_path_file(last, bb_get_last_path_component_strip(*argv));
-		dest_exists = cp_mv_stat(dest, &dest_stat);
+		dest_exists = cp_mv_stat(dest, &statbuf);
 		if (dest_exists < 0) {
 			goto RET_1;
 		}
@@ -108,11 +135,10 @@ int mv_main(int argc, char **argv)
 		}
 
 		if (rename(*argv, dest) < 0) {
-			struct stat source_stat;
 			int source_exists;
 
 			if (errno != EXDEV
-			 || (source_exists = cp_mv_stat2(*argv, &source_stat, lstat)) < 1
+			 || (source_exists = cp_mv_stat2(*argv, &statbuf, lstat)) < 1
 			) {
 				bb_perror_msg("can't rename '%s'", *argv);
 			} else {
@@ -159,7 +185,7 @@ int mv_main(int argc, char **argv)
 		if (dest != last) {
 			free((void *) dest);
 		}
-	} while (*++argv != last);
+	} while (*++argv && *argv != last);
 
 	return status;
 }
diff -urpN busybox-1.33.1/coreutils/nl.c busybox-1.34.0/coreutils/nl.c
--- busybox-1.33.1/coreutils/nl.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/nl.c	2021-04-15 00:05:01.000000000 +0700
@@ -68,7 +68,7 @@ int nl_main(int argc UNUSED_PARAM, char
 			&ns.width, &ns.sep, &ns.start, &ns.inc, &opt_b);
 	ns.all = (opt_b[0] == 'a');
 	ns.nonempty = (opt_b[0] == 't');
-	ns.empty_str = xasprintf("%*s\n", ns.width + (int)strlen(ns.sep), "");
+	ns.empty_str = xasprintf("%*s", ns.width + (int)strlen(ns.sep), "");
 
 	argv += optind;
 	if (!*argv)
diff -urpN busybox-1.33.1/coreutils/nproc.c busybox-1.34.0/coreutils/nproc.c
--- busybox-1.33.1/coreutils/nproc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/nproc.c	2021-07-20 21:57:20.000000000 +0700
@@ -14,7 +14,7 @@
 //kbuild:lib-$(CONFIG_NPROC) += nproc.o
 
 //usage:#define nproc_trivial_usage
-//usage:	""IF_LONG_OPTS("--all --ignore=N")
+//usage:	""IF_LONG_OPTS("[--all] [--ignore=N]")
 //usage:#define nproc_full_usage "\n\n"
 //usage:	"Print number of available CPUs"
 //usage:	IF_LONG_OPTS(
@@ -48,7 +48,7 @@ int nproc_main(int argc UNUSED_PARAM, ch
 				if (cpuid && isdigit(cpuid[strlen(cpuid) - 1]))
 					count++;
 			}
-			closedir(cpusd);
+			IF_FEATURE_CLEAN_UP(closedir(cpusd);)
 		}
 	} else
 #endif
diff -urpN busybox-1.33.1/coreutils/od_bloaty.c busybox-1.34.0/coreutils/od_bloaty.c
--- busybox-1.33.1/coreutils/od_bloaty.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/od_bloaty.c	2021-04-15 00:05:01.000000000 +0700
@@ -422,19 +422,19 @@ print_named_ascii(size_t n_bytes, const
 
 		masked_c &= 0x7f;
 		if (masked_c == 0x7f) {
-			fputs(" del", stdout);
+			fputs_stdout(" del");
 			continue;
 		}
 		if (masked_c > ' ') {
 			buf[3] = masked_c;
-			fputs(buf, stdout);
+			fputs_stdout(buf);
 			continue;
 		}
 		/* Why? Because printf(" %3.3s") is much slower... */
 		buf[6] = charname[masked_c][0];
 		buf[7] = charname[masked_c][1];
 		buf[8] = charname[masked_c][2];
-		fputs(buf+5, stdout);
+		fputs_stdout(buf+5);
 	}
 }
 
@@ -451,7 +451,7 @@ print_ascii(size_t n_bytes, const char *
 
 		if (ISPRINT(c)) {
 			buf[3] = c;
-			fputs(buf, stdout);
+			fputs_stdout(buf);
 			continue;
 		}
 		switch (c) {
@@ -485,7 +485,7 @@ print_ascii(size_t n_bytes, const char *
 			buf[8] = (c & 7) + '0';
 			s = buf + 5;
 		}
-		fputs(s, stdout);
+		fputs_stdout(s);
 	}
 }
 
@@ -881,7 +881,7 @@ format_address_label(off_t address, char
 static void
 dump_hexl_mode_trailer(size_t n_bytes, const char *block)
 {
-	fputs("  >", stdout);
+	fputs_stdout("  >");
 	while (n_bytes--) {
 		unsigned c = *(unsigned char *) block++;
 		c = (ISPRINT(c) ? c : '.');
@@ -1121,13 +1121,13 @@ dump_strings(off_t address, off_t end_of
 
 		for (i = 0; (c = buf[i]); i++) {
 			switch (c) {
-			case '\007': fputs("\\a", stdout); break;
-			case '\b': fputs("\\b", stdout); break;
-			case '\f': fputs("\\f", stdout); break;
-			case '\n': fputs("\\n", stdout); break;
-			case '\r': fputs("\\r", stdout); break;
-			case '\t': fputs("\\t", stdout); break;
-			case '\v': fputs("\\v", stdout); break;
+			case '\007': fputs_stdout("\\a"); break;
+			case '\b': fputs_stdout("\\b"); break;
+			case '\f': fputs_stdout("\\f"); break;
+			case '\n': fputs_stdout("\\n"); break;
+			case '\r': fputs_stdout("\\r"); break;
+			case '\t': fputs_stdout("\\t"); break;
+			case '\v': fputs_stdout("\\v"); break;
 			default: putchar(c);
 			}
 		}
diff -urpN busybox-1.33.1/coreutils/paste.c busybox-1.34.0/coreutils/paste.c
--- busybox-1.33.1/coreutils/paste.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/paste.c	2021-04-15 00:05:01.000000000 +0700
@@ -53,7 +53,7 @@ static void paste_files(FILE** files, in
 				--active_files;
 				continue;
 			}
-			fputs(line, stdout);
+			fputs_stdout(line);
 			free(line);
 			delim = '\n';
 			if (i != file_cnt - 1) {
@@ -79,7 +79,7 @@ static void paste_files_separate(FILE**
 		line = NULL;
 		while ((next_line = xmalloc_fgetline(files[i])) != NULL) {
 			if (line) {
-				fputs(line, stdout);
+				fputs_stdout(line);
 				free(line);
 				delim = delims[del_idx++];
 				if (del_idx == del_cnt)
diff -urpN busybox-1.33.1/coreutils/printf.c busybox-1.34.0/coreutils/printf.c
--- busybox-1.33.1/coreutils/printf.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/printf.c	2021-04-15 00:05:01.000000000 +0700
@@ -122,6 +122,7 @@ static void FAST_FUNC conv_strtod(const
 	char *end;
 	/* Well, this one allows leading whitespace... so what? */
 	/* What I like much less is that "-" accepted too! :( */
+//TODO: needs setlocale(LC_NUMERIC, "C")?
 	*(double*)result = strtod(arg, &end);
 	if (end[0]) {
 		errno = ERANGE;
diff -urpN busybox-1.33.1/coreutils/realpath.c busybox-1.34.0/coreutils/realpath.c
--- busybox-1.33.1/coreutils/realpath.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/realpath.c	2021-04-15 00:05:01.000000000 +0700
@@ -23,7 +23,7 @@
 //usage:#define realpath_trivial_usage
 //usage:       "FILE..."
 //usage:#define realpath_full_usage "\n\n"
-//usage:       "Return the absolute pathnames of given FILE"
+//usage:       "Print absolute pathnames of FILEs"
 
 #include "libbb.h"
 
diff -urpN busybox-1.33.1/coreutils/shred.c busybox-1.34.0/coreutils/shred.c
--- busybox-1.33.1/coreutils/shred.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/shred.c	2021-07-20 21:57:20.000000000 +0700
@@ -15,14 +15,15 @@
 //kbuild:lib-$(CONFIG_SHRED) += shred.o
 
 //usage:#define shred_trivial_usage
-//usage:       "FILE..."
+//usage:       "[-fuz] [-n N] [-s SIZE] FILE..."
 //usage:#define shred_full_usage "\n\n"
 //usage:       "Overwrite/delete FILEs\n"
 //usage:     "\n	-f	Chmod to ensure writability"
+//usage:     "\n	-s SIZE	Size to write"
 //usage:     "\n	-n N	Overwrite N times (default 3)"
 //usage:     "\n	-z	Final overwrite with zeros"
 //usage:     "\n	-u	Remove file"
-//-x and -v are accepted but have no effect
+//-x (exact: don't round up to 4k) and -v (verbose) are accepted but have no effect
 
 /* shred (GNU coreutils) 8.25:
 -f, --force		change permissions to allow writing if necessary
@@ -41,6 +42,7 @@
 int shred_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int shred_main(int argc UNUSED_PARAM, char **argv)
 {
+	char *opt_s;
 	int rand_fd = rand_fd; /* for compiler */
 	int zero_fd;
 	unsigned num_iter = 3;
@@ -52,18 +54,16 @@ int shred_main(int argc UNUSED_PARAM, ch
 		OPT_n = (1 << 3),
 		OPT_v = (1 << 4),
 		OPT_x = (1 << 5),
+		OPT_s = (1 << 6),
 	};
 
-	opt = getopt32(argv, "fuzn:+vx", &num_iter);
+	opt = getopt32(argv, "^" "fuzn:+vxs:" "\0" "-1"/*min 1 arg*/, &num_iter, &opt_s);
 	argv += optind;
 
 	zero_fd = xopen("/dev/zero", O_RDONLY);
 	if (num_iter != 0)
 		rand_fd = xopen("/dev/urandom", O_RDONLY);
 
-	if (!*argv)
-		bb_show_usage();
-
 	for (;;) {
 		struct stat sb;
 		const char *fname;
@@ -85,6 +85,11 @@ int shred_main(int argc UNUSED_PARAM, ch
 		if (fstat(fd, &sb) == 0 && sb.st_size > 0) {
 			off_t size = sb.st_size;
 
+			if (opt & OPT_s) {
+				size = BB_STRTOOFF(opt_s, NULL, 0); /* accepts oct/hex */
+				if (errno || size < 0) bb_show_usage();
+			}
+
 			for (i = 0; i < num_iter; i++) {
 				bb_copyfd_size(rand_fd, fd, size);
 				fdatasync(fd);
@@ -94,12 +99,12 @@ int shred_main(int argc UNUSED_PARAM, ch
 				bb_copyfd_size(zero_fd, fd, size);
 				fdatasync(fd);
 			}
-			if (opt & OPT_u) {
-				ftruncate(fd, 0);
-				xunlink(fname);
-			}
-			xclose(fd);
 		}
+		if (opt & OPT_u) {
+			ftruncate(fd, 0);
+			xunlink(fname);
+		}
+		xclose(fd);
 	}
 
 	return EXIT_SUCCESS;
diff -urpN busybox-1.33.1/coreutils/sleep.c busybox-1.34.0/coreutils/sleep.c
--- busybox-1.33.1/coreutils/sleep.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/sleep.c	2021-04-15 00:05:01.000000000 +0700
@@ -74,10 +74,6 @@ int sleep_main(int argc UNUSED_PARAM, ch
 			sleep(INT_MAX);
 
 #if ENABLE_FEATURE_FANCY_SLEEP
-# if ENABLE_FLOAT_DURATION
-	/* undo busybox.c setlocale */
-	setlocale(LC_NUMERIC, "C");
-# endif
 	duration = 0;
 	do {
 		duration += parse_duration_str(*argv);
diff -urpN busybox-1.33.1/coreutils/sort.c busybox-1.34.0/coreutils/sort.c
--- busybox-1.33.1/coreutils/sort.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/sort.c	2021-07-20 21:57:20.000000000 +0700
@@ -67,7 +67,7 @@
 //usage:     "\n	-r	Reverse sort order"
 //usage:     "\n	-s	Stable (don't sort ties alphabetically)"
 //usage:     "\n	-u	Suppress duplicate lines"
-//usage:     "\n	-z	Lines are terminated by NUL, not newline"
+//usage:     "\n	-z	NUL terminated input and output"
 ///////:     "\n	-m	Ignored for GNU compatibility"
 ///////:     "\n	-S BUFSZ Ignored for GNU compatibility"
 ///////:     "\n	-T TMPDIR Ignored for GNU compatibility"
@@ -295,6 +295,7 @@ static int compare_keys(const void *xarg
 #if ENABLE_FEATURE_SORT_BIG
 		case FLAG_g: {
 			char *xx, *yy;
+//TODO: needs setlocale(LC_NUMERIC, "C")?
 			double dx = strtod(x, &xx);
 			double dy = strtod(y, &yy);
 			/* not numbers < NaN < -infinity < numbers < +infinity) */
diff -urpN busybox-1.33.1/coreutils/stat.c busybox-1.34.0/coreutils/stat.c
--- busybox-1.33.1/coreutils/stat.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/stat.c	2021-04-15 00:05:01.000000000 +0700
@@ -439,7 +439,7 @@ static void print_it(const char *masterf
 
 		/* print preceding string */
 		*p = '\0';
-		fputs(b, stdout);
+		fputs_stdout(b);
 
 		p += len;
 		b = p + 1;
diff -urpN busybox-1.33.1/coreutils/stty.c busybox-1.34.0/coreutils/stty.c
--- busybox-1.33.1/coreutils/stty.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/stty.c	2021-04-15 00:05:01.000000000 +0700
@@ -855,7 +855,7 @@ static void wrapf(const char *message, .
 			}
 		}
 	}
-	fputs(buf, stdout);
+	fputs_stdout(buf);
 	G.current_col += buflen;
 	if (buf[buflen-1] == '\n')
 		G.current_col = 0;
diff -urpN busybox-1.33.1/coreutils/tail.c busybox-1.34.0/coreutils/tail.c
--- busybox-1.33.1/coreutils/tail.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/tail.c	2021-06-16 17:02:16.000000000 +0700
@@ -48,19 +48,20 @@
 //usage:#define tail_trivial_usage
 //usage:       "[OPTIONS] [FILE]..."
 //usage:#define tail_full_usage "\n\n"
-//usage:       "Print last 10 lines of each FILE (or stdin) to stdout.\n"
+//usage:       "Print last 10 lines of FILEs (or stdin) to.\n"
 //usage:       "With more than one FILE, precede each with a filename header.\n"
-//usage:     "\n	-f		Print data as file grows"
-//usage:     "\n	-c [+]N[kbm]	Print last N bytes"
-//usage:     "\n	-n N[kbm]	Print last N lines"
-//usage:     "\n	-n +N[kbm]	Start on Nth line and print the rest"
+//usage:     "\n	-c [+]N[bkm]	Print last N bytes"
+//usage:     "\n	-n N[bkm]	Print last N lines"
+//usage:     "\n	-n +N[bkm]	Start on Nth line and print the rest"
+//usage:     "\n			(b:*512 k:*1024 m:*1024^2)"
 //usage:	IF_FEATURE_FANCY_TAIL(
 //usage:     "\n	-q		Never print headers"
-//usage:     "\n	-s SECONDS	Wait SECONDS between reads with -f"
 //usage:     "\n	-v		Always print headers"
+//usage:	)
+//usage:     "\n	-f		Print data as file grows"
+//usage:	IF_FEATURE_FANCY_TAIL(
 //usage:     "\n	-F		Same as -f, but keep retrying"
-//usage:     "\n"
-//usage:     "\nN may be suffixed by k (x1024), b (x512), or m (x1024^2)."
+//usage:     "\n	-s SECONDS	Wait SECONDS between reads with -f"
 //usage:	)
 //usage:
 //usage:#define tail_example_usage
@@ -118,7 +119,7 @@ int tail_main(int argc, char **argv)
 
 	char *tailbuf;
 	size_t tailbufsize;
-	unsigned header_threshhold = 1;
+	unsigned header_threshold = 1;
 	unsigned nfiles;
 	int i, opt;
 
@@ -151,10 +152,10 @@ int tail_main(int argc, char **argv)
 	if (opt & 0x2) count = eat_num(str_c); // -c
 	if (opt & 0x4) count = eat_num(str_n); // -n
 #if ENABLE_FEATURE_FANCY_TAIL
-	/* q: make it impossible for nfiles to be > header_threshhold */
-	if (opt & 0x8) header_threshhold = UINT_MAX; // -q
+	/* q: make it impossible for nfiles to be > header_threshold */
+	if (opt & 0x8) header_threshold = UINT_MAX; // -q
 	//if (opt & 0x10) // -s
-	if (opt & 0x20) header_threshhold = 0; // -v
+	if (opt & 0x20) header_threshold = 0; // -v
 # define FOLLOW_RETRY (opt & 0x40)
 #else
 # define FOLLOW_RETRY 0
@@ -215,7 +216,7 @@ int tail_main(int argc, char **argv)
 		if (ENABLE_FEATURE_FANCY_TAIL && fd < 0)
 			continue; /* may happen with -F */
 
-		if (nfiles > header_threshhold) {
+		if (nfiles > header_threshold) {
 			tail_xprint_header(fmt, argv[i]);
 			fmt = header_fmt_str;
 		}
@@ -345,9 +346,11 @@ int tail_main(int argc, char **argv)
 			int nread;
 			const char *filename = argv[i];
 			int fd = fds[i];
+			int new_fd = -1;
+			struct stat sbuf;
 
 			if (FOLLOW_RETRY) {
-				struct stat sbuf, fsbuf;
+				struct stat fsbuf;
 
 				if (fd < 0
 				 || fstat(fd, &fsbuf) < 0
@@ -355,39 +358,51 @@ int tail_main(int argc, char **argv)
 				 || fsbuf.st_dev != sbuf.st_dev
 				 || fsbuf.st_ino != sbuf.st_ino
 				) {
-					int new_fd;
-
-					if (fd >= 0)
-						close(fd);
+					/* Looks like file has been created/renamed/deleted */
 					new_fd = open(filename, O_RDONLY);
 					if (new_fd >= 0) {
 						bb_error_msg("%s has %s; following end of new file",
 							filename, (fd < 0) ? "appeared" : "been replaced"
 						);
+						if (fd < 0) {
+							/* No previously open fd for this file,
+							 * start using new_fd immediately. */
+							fds[i] = fd = new_fd;
+							new_fd = -1;
+						}
 					} else if (fd >= 0) {
-						bb_perror_msg("%s has become inaccessible", filename);
+						bb_perror_msg("%s has been renamed or deleted", filename);
 					}
-					fds[i] = fd = new_fd;
 				}
 			}
 			if (ENABLE_FEATURE_FANCY_TAIL && fd < 0)
 				continue;
-			if (nfiles > header_threshhold) {
+			if (nfiles > header_threshold) {
 				fmt = header_fmt_str;
 			}
 			for (;;) {
 				/* tail -f keeps following files even if they are truncated */
-				struct stat sbuf;
 				/* /proc files report zero st_size, don't lseek them */
-				if (fstat(fd, &sbuf) == 0 && sbuf.st_size > 0) {
+				if (fstat(fd, &sbuf) == 0
+				 /* && S_ISREG(sbuf.st_mode) TODO? */
+				 && sbuf.st_size > 0
+				) {
 					off_t current = lseek(fd, 0, SEEK_CUR);
-					if (sbuf.st_size < current)
+					if (sbuf.st_size < current) {
+						//bb_perror_msg("%s: file truncated", filename); - says coreutils 8.32
 						xlseek(fd, 0, SEEK_SET);
+					}
 				}
 
 				nread = tail_read(fd, tailbuf, BUFSIZ);
-				if (nread <= 0)
-					break;
+				if (nread <= 0) {
+					if (new_fd < 0)
+						break;
+					/* Switch to "tail -F"ing the new file */
+					xmove_fd(new_fd, fd);
+					new_fd = -1;
+					continue;
+				}
 				if (fmt && (fd != prev_fd)) {
 					tail_xprint_header(fmt, filename);
 					fmt = NULL;
diff -urpN busybox-1.33.1/coreutils/touch.c busybox-1.34.0/coreutils/touch.c
--- busybox-1.33.1/coreutils/touch.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/touch.c	2021-08-16 01:44:35.000000000 +0700
@@ -19,16 +19,8 @@
 //config:	touch is used to create or change the access and/or
 //config:	modification timestamp of specified files.
 //config:
-//config:config FEATURE_TOUCH_NODEREF
-//config:	bool "Add support for -h"
-//config:	default y
-//config:	depends on TOUCH
-//config:	help
-//config:	Enable touch to have the -h option.
-//config:	This requires libc support for lutimes() function.
-//config:
 //config:config FEATURE_TOUCH_SUSV3
-//config:	bool "Add support for SUSV3 features (-d -t -r)"
+//config:	bool "Add support for SUSV3 features (-a -d -m -t -r)"
 //config:	default y
 //config:	depends on TOUCH
 //config:	help
@@ -38,18 +30,17 @@
 
 //kbuild:lib-$(CONFIG_TOUCH) += touch.o
 
-/* BB_AUDIT SUSv3 _NOT_ compliant -- options -a, -m not supported. */
-/* http://www.opengroup.org/onlinepubs/007904975/utilities/touch.html */
-
 //usage:#define touch_trivial_usage
-//usage:       "[-c]" IF_FEATURE_TOUCH_SUSV3(" [-d DATE] [-t DATE] [-r FILE]") " FILE..."
+//usage:       "[-ch" IF_FEATURE_TOUCH_SUSV3("am") "]"
+//usage:       IF_FEATURE_TOUCH_SUSV3(" [-d DATE] [-t DATE] [-r FILE]")
+//usage:       " FILE..."
 //usage:#define touch_full_usage "\n\n"
-//usage:       "Update the last-modified date on the given FILE[s]\n"
+//usage:       "Update mtime of FILEs\n"
 //usage:     "\n	-c	Don't create files"
-//usage:	IF_FEATURE_TOUCH_NODEREF(
 //usage:     "\n	-h	Don't follow links"
-//usage:	)
 //usage:	IF_FEATURE_TOUCH_SUSV3(
+//usage:     "\n	-a	Change only atime"
+//usage:     "\n	-m	Change only mtime"
 //usage:     "\n	-d DT	Date/time to use"
 //usage:     "\n	-t DT	Date/time to use"
 //usage:     "\n	-r FILE	Use FILE's date/time"
@@ -85,70 +76,68 @@ int touch_main(int argc, char **argv) MA
 int touch_main(int argc UNUSED_PARAM, char **argv)
 {
 	int fd;
-	int status = EXIT_SUCCESS;
 	int opts;
+	smalluint status = EXIT_SUCCESS;
+#if ENABLE_FEATURE_TOUCH_SUSV3
+	char *reference_file;
+	char *date_str;
+	/* timebuf[0] is atime, timebuf[1] is mtime */
+	struct timespec timebuf[2];
+#else
+# define reference_file NULL
+# define date_str       NULL
+# define timebuf        ((struct timespec*)NULL)
+#endif
+
 	enum {
 		OPT_c = (1 << 0),
-		OPT_r = (1 << 1) * ENABLE_FEATURE_TOUCH_SUSV3,
-		OPT_d = (1 << 2) * ENABLE_FEATURE_TOUCH_SUSV3,
-		OPT_t = (1 << 3) * ENABLE_FEATURE_TOUCH_SUSV3,
-		OPT_h = (1 << 4) * ENABLE_FEATURE_TOUCH_NODEREF,
+		OPT_h = (1 << 1),
+		OPT_r = (1 << 2) * ENABLE_FEATURE_TOUCH_SUSV3,
+		OPT_d = (1 << 3) * ENABLE_FEATURE_TOUCH_SUSV3,
+		OPT_t = (1 << 4) * ENABLE_FEATURE_TOUCH_SUSV3,
+		OPT_a = (1 << 5) * ENABLE_FEATURE_TOUCH_SUSV3,
+		OPT_m = (1 << 6) * ENABLE_FEATURE_TOUCH_SUSV3,
 	};
-#if ENABLE_FEATURE_TOUCH_SUSV3
-# if ENABLE_LONG_OPTS
+#if ENABLE_LONG_OPTS
 	static const char touch_longopts[] ALIGN1 =
 		/* name, has_arg, val */
-		"no-create\0"         No_argument       "c"
-		"reference\0"         Required_argument "r"
-		"date\0"              Required_argument "d"
-		IF_FEATURE_TOUCH_NODEREF("no-dereference\0" No_argument "h")
+		"no-create\0"        No_argument       "c"
+		"no-dereference\0"   No_argument       "h"
+		IF_FEATURE_TOUCH_SUSV3("reference\0"        Required_argument "r")
+		IF_FEATURE_TOUCH_SUSV3("date\0"             Required_argument "d")
 	;
-#  define GETOPT32 getopt32long
-#  define LONGOPTS ,touch_longopts
-# else
-#  define GETOPT32 getopt32
-#  define LONGOPTS
-# endif
-	char *reference_file = NULL;
-	char *date_str = NULL;
-	struct timeval timebuf[2];
-	timebuf[1].tv_usec = timebuf[0].tv_usec = 0;
-#else
-# define reference_file NULL
-# define date_str       NULL
-# define timebuf        ((struct timeval*)NULL)
-# define GETOPT32 getopt32
-# define LONGOPTS
 #endif
-
 	/* -d and -t both set time. In coreutils,
 	 * accepted data format differs a bit between -d and -t.
-	 * We accept the same formats for both */
-	opts = GETOPT32(argv, "c" IF_FEATURE_TOUCH_SUSV3("r:d:t:")
-				IF_FEATURE_TOUCH_NODEREF("h")
-				/*ignored:*/ "fma"
-				LONGOPTS
-				IF_FEATURE_TOUCH_SUSV3(, &reference_file)
-				IF_FEATURE_TOUCH_SUSV3(, &date_str)
-				IF_FEATURE_TOUCH_SUSV3(, &date_str)
+	 * We accept the same formats for both
+	 */
+	opts = getopt32long(argv, "^"
+		"ch"
+		IF_FEATURE_TOUCH_SUSV3("r:d:t:am")
+		/*ignored:*/ "f" IF_NOT_FEATURE_TOUCH_SUSV3("am")
+		"\0" /* opt_complementary: */
+		/* at least one arg: */ "-1"
+		/* coreutils forbids -r and -t at once: */ IF_FEATURE_TOUCH_SUSV3(":r--t:t--r")
+		/* but allows these combinations: "r--d:d--r:t--d:d--t" */
+		, touch_longopts
+#if ENABLE_FEATURE_TOUCH_SUSV3
+		, &reference_file
+		, &date_str
+		, &date_str
+#endif
 	);
 
-	argv += optind;
-	if (!*argv) {
-		bb_show_usage();
-	}
-
-	if (reference_file) {
+#if ENABLE_FEATURE_TOUCH_SUSV3
+	timebuf[0].tv_nsec = timebuf[1].tv_nsec = UTIME_NOW;
+	if (opts & OPT_r) {
 		struct stat stbuf;
 		xstat(reference_file, &stbuf);
-		timebuf[1].tv_sec = timebuf[0].tv_sec = stbuf.st_mtime;
-		/* Can use .st_mtim.tv_nsec
-		 * (or is it .st_mtimensec?? see date.c)
-		 * to set microseconds too.
-		 */
+		timebuf[0].tv_sec = stbuf.st_atime;
+		timebuf[1].tv_sec = stbuf.st_mtime;
+		timebuf[0].tv_nsec = stbuf.st_atim.tv_nsec;
+		timebuf[1].tv_nsec = stbuf.st_mtim.tv_nsec;
 	}
-
-	if (date_str) {
+	if (opts & (OPT_d|OPT_t)) {
 		struct tm tm_time;
 		time_t t;
 
@@ -163,15 +152,21 @@ int touch_main(int argc UNUSED_PARAM, ch
 		t = validate_tm_time(date_str, &tm_time);
 
 		timebuf[1].tv_sec = timebuf[0].tv_sec = t;
+		timebuf[1].tv_nsec = timebuf[0].tv_nsec = 0;
 	}
+	/* If both -a and -m specified, both times should be set.
+	 * IOW: set OMIT only if one, not both, of them is given!
+	 */
+	if ((opts & (OPT_a|OPT_m)) == OPT_a)
+		timebuf[1].tv_nsec = UTIME_OMIT;
+	if ((opts & (OPT_a|OPT_m)) == OPT_m)
+		timebuf[0].tv_nsec = UTIME_OMIT;
+#endif
 
+	argv += optind;
 	do {
-		int result;
-		result = (
-#if ENABLE_FEATURE_TOUCH_NODEREF
-			(opts & OPT_h) ? lutimes :
-#endif
-			utimes)(*argv, (reference_file || date_str) ? timebuf : NULL);
+		int result = utimensat(AT_FDCWD, *argv, timebuf,
+				(opts & OPT_h) ? AT_SYMLINK_NOFOLLOW : 0);
 		if (result != 0) {
 			if (errno == ENOENT) { /* no such file? */
 				if (opts & OPT_c) {
@@ -181,9 +176,9 @@ int touch_main(int argc UNUSED_PARAM, ch
 				/* Try to create the file */
 				fd = open(*argv, O_RDWR | O_CREAT, 0666);
 				if (fd >= 0) {
+					if (opts & (OPT_r|OPT_d|OPT_t))
+						futimens(fd, timebuf);
 					xclose(fd);
-					if (reference_file || date_str)
-						utimes(*argv, timebuf);
 					continue;
 				}
 			}
diff -urpN busybox-1.33.1/coreutils/truncate.c busybox-1.34.0/coreutils/truncate.c
--- busybox-1.33.1/coreutils/truncate.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/truncate.c	2021-04-15 00:05:01.000000000 +0700
@@ -19,9 +19,9 @@
 //usage:#define truncate_trivial_usage
 //usage:       "[-c] -s SIZE FILE..."
 //usage:#define truncate_full_usage "\n\n"
-//usage:	"Truncate FILEs to the given size\n"
+//usage:	"Truncate FILEs to SIZE\n"
 //usage:	"\n	-c	Do not create files"
-//usage:	"\n	-s SIZE	Truncate to SIZE"
+//usage:	"\n	-s SIZE"
 //usage:
 //usage:#define truncate_example_usage
 //usage:	"$ truncate -s 1G foo"
diff -urpN busybox-1.33.1/coreutils/tty.c busybox-1.34.0/coreutils/tty.c
--- busybox-1.33.1/coreutils/tty.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/tty.c	2021-06-16 17:02:16.000000000 +0700
@@ -21,7 +21,7 @@
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/tty.html */
 
 //usage:#define tty_trivial_usage
-//usage:       ""
+//usage:       "" IF_INCLUDE_SUSv2("[-s]")
 //usage:#define tty_full_usage "\n\n"
 //usage:       "Print file name of stdin's terminal"
 //usage:	IF_INCLUDE_SUSv2( "\n"
diff -urpN busybox-1.33.1/coreutils/uname.c busybox-1.34.0/coreutils/uname.c
--- busybox-1.33.1/coreutils/uname.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/uname.c	2021-06-16 17:02:16.000000000 +0700
@@ -79,13 +79,13 @@
 //usage:#define uname_full_usage "\n\n"
 //usage:       "Print system information\n"
 //usage:     "\n	-a	Print all"
-//usage:     "\n	-m	The machine (hardware) type"
+//usage:     "\n	-m	Machine (hardware) type"
 //usage:     "\n	-n	Hostname"
 //usage:     "\n	-r	Kernel release"
 //usage:     "\n	-s	Kernel name (default)"
 //usage:     "\n	-p	Processor type"
 //usage:     "\n	-v	Kernel version"
-//usage:     "\n	-i	The hardware platform"
+//usage:     "\n	-i	Hardware platform"
 //usage:     "\n	-o	OS name"
 //usage:
 //usage:#define uname_example_usage
diff -urpN busybox-1.33.1/coreutils/uniq.c busybox-1.34.0/coreutils/uniq.c
--- busybox-1.33.1/coreutils/uniq.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/uniq.c	2021-07-20 21:57:20.000000000 +0700
@@ -20,13 +20,14 @@
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/uniq.html */
 
 //usage:#define uniq_trivial_usage
-//usage:       "[-cdui] [-f,s,w N] [INPUT [OUTPUT]]"
+//usage:       "[-cduiz] [-f,s,w N] [FILE [OUTFILE]]"
 //usage:#define uniq_full_usage "\n\n"
 //usage:       "Discard duplicate lines\n"
 //usage:     "\n	-c	Prefix lines by the number of occurrences"
 //usage:     "\n	-d	Only print duplicate lines"
 //usage:     "\n	-u	Only print unique lines"
 //usage:     "\n	-i	Ignore case"
+//usage:     "\n	-z	NUL terminated output"
 //usage:     "\n	-f N	Skip first N fields"
 //usage:     "\n	-s N	Skip first N chars (after any skipped fields)"
 //usage:     "\n	-w N	Compare N characters in line"
@@ -45,23 +46,25 @@ int uniq_main(int argc UNUSED_PARAM, cha
 	const char *input_filename;
 	unsigned skip_fields, skip_chars, max_chars;
 	unsigned opt;
+	char eol;
 	char *cur_line;
 	const char *cur_compare;
 
 	enum {
-		OPT_c = 0x1,
-		OPT_d = 0x2, /* print only dups */
-		OPT_u = 0x4, /* print only uniq */
-		OPT_f = 0x8,
-		OPT_s = 0x10,
-		OPT_w = 0x20,
-		OPT_i = 0x40,
+		OPT_c = 1 << 0,
+		OPT_d = 1 << 1, /* print only dups */
+		OPT_u = 1 << 2, /* print only uniq */
+		OPT_f = 1 << 3,
+		OPT_s = 1 << 4,
+		OPT_w = 1 << 5,
+		OPT_i = 1 << 6,
+		OPT_z = 1 << 7,
 	};
 
 	skip_fields = skip_chars = 0;
 	max_chars = INT_MAX;
 
-	opt = getopt32(argv, "cduf:+s:+w:+i", &skip_fields, &skip_chars, &max_chars);
+	opt = getopt32(argv, "cduf:+s:+w:+iz", &skip_fields, &skip_chars, &max_chars);
 	argv += optind;
 
 	input_filename = argv[0];
@@ -86,6 +89,7 @@ int uniq_main(int argc UNUSED_PARAM, cha
 	}
 
 	cur_compare = cur_line = NULL; /* prime the pump */
+	eol = (opt & OPT_z) ? 0 : '\n';
 
 	do {
 		unsigned i;
@@ -127,7 +131,7 @@ int uniq_main(int argc UNUSED_PARAM, cha
 					/* %7lu matches GNU coreutils 6.9 */
 					printf("%7lu ", dups + 1);
 				}
-				puts(old_line);
+				printf("%s%c", old_line, eol);
 			}
 			free(old_line);
 		}
diff -urpN busybox-1.33.1/coreutils/uudecode.c busybox-1.34.0/coreutils/uudecode.c
--- busybox-1.33.1/coreutils/uudecode.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/uudecode.c	2021-06-16 17:02:16.000000000 +0700
@@ -183,7 +183,7 @@ int uudecode_main(int argc UNUSED_PARAM,
 //usage:#define base32_trivial_usage
 //usage:	"[-d] [-w COL] [FILE]"
 //usage:#define base32_full_usage "\n\n"
-//usage:       "Base32 encode or decode FILE to standard output"
+//usage:       "Base32 encode or decode FILE to standard output\n"
 //usage:     "\n	-d	Decode data"
 //usage:     "\n	-w COL	Wrap lines at COL (default 76, 0 disables)"
 ////usage:     "\n	-i	When decoding, ignore non-alphabet characters"
@@ -191,10 +191,12 @@ int uudecode_main(int argc UNUSED_PARAM,
 //usage:#define base64_trivial_usage
 //usage:	"[-d] [-w COL] [FILE]"
 //usage:#define base64_full_usage "\n\n"
-//usage:       "Base64 encode or decode FILE to standard output"
+//usage:       "Base64 encode or decode FILE to standard output\n"
 //usage:     "\n	-d	Decode data"
 //usage:     "\n	-w COL	Wrap lines at COL (default 76, 0 disables)"
-////usage:     "\n	-i	When decoding, ignore non-alphabet characters"
+///////:     "\n	-i	When decoding, ignore non-alphabet characters"
+// -i is accepted but has no effect: currently, decode_base32/64() functions
+// (called via read_base64()) skip invalid chars unconditionally.
 
 //                 APPLET_ODDNAME:name    main     location    suid_type     help
 //applet:IF_BASE32(APPLET_ODDNAME(base32, baseNUM, BB_DIR_BIN, BB_SUID_DROP, base32))
@@ -272,7 +274,7 @@ int baseNUM_main(int argc UNUSED_PARAM,
 	unsigned opts;
 	unsigned col = 76;
 
-	opts = getopt32(argv, "^" "dw:+" "\0" "?1"/* 1 arg max*/, &col);
+	opts = getopt32(argv, "^" "diw:+" "\0" "?1"/* 1 arg max*/, &col);
 	argv += optind;
 
 	if (!argv[0])
@@ -319,7 +321,7 @@ int baseNUM_main(int argc UNUSED_PARAM,
 			}
 
 			if (col == 0) {
-				fputs(dst_buf, stdout);
+				fputs_stdout(dst_buf);
 			} else {
 				char *result = dst_buf;
 				if (rem == 0)
diff -urpN busybox-1.33.1/coreutils/wc.c busybox-1.34.0/coreutils/wc.c
--- busybox-1.33.1/coreutils/wc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/wc.c	2021-04-15 00:05:01.000000000 +0700
@@ -80,7 +80,7 @@
 //usage:       "[-c"IF_UNICODE_SUPPORT("m")"lwL] [FILE]..."
 //usage:
 //usage:#define wc_full_usage "\n\n"
-//usage:       "Count lines, words, and bytes for each FILE (or stdin)\n"
+//usage:       "Count lines, words, and bytes for FILEs (or stdin)\n"
 //usage:     "\n	-c	Count bytes"
 //usage:	IF_UNICODE_SUPPORT(
 //usage:     "\n	-m	Count characters"
diff -urpN busybox-1.33.1/coreutils/who.c busybox-1.34.0/coreutils/who.c
--- busybox-1.33.1/coreutils/who.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/who.c	2021-06-16 17:02:16.000000000 +0700
@@ -78,7 +78,7 @@
 // root     pts/1     Mon13    3:24m  1:01   0.01s w
 
 //usage:#define who_trivial_usage
-//usage:       "[-a]"
+//usage:       "[-aH]"
 //usage:#define who_full_usage "\n\n"
 //usage:       "Show who is logged on\n"
 //usage:     "\n	-a	Show all"
diff -urpN busybox-1.33.1/coreutils/yes.c busybox-1.34.0/coreutils/yes.c
--- busybox-1.33.1/coreutils/yes.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/coreutils/yes.c	2021-06-16 17:02:16.000000000 +0700
@@ -27,7 +27,7 @@
 //usage:#define yes_trivial_usage
 //usage:       "[STRING]"
 //usage:#define yes_full_usage "\n\n"
-//usage:       "Repeatedly output a line with STRING, or 'y'"
+//usage:       "Repeatedly print a line with STRING, or 'y'"
 
 #include "libbb.h"
 
@@ -43,7 +43,7 @@ int yes_main(int argc UNUSED_PARAM, char
 	do {
 		pp = argv;
 		while (1) {
-			fputs(*pp, stdout);
+			fputs_stdout(*pp);
 			if (!*++pp)
 				break;
 			putchar(' ');
diff -urpN busybox-1.33.1/debianutils/run_parts.c busybox-1.34.0/debianutils/run_parts.c
--- busybox-1.33.1/debianutils/run_parts.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/debianutils/run_parts.c	2021-06-16 17:02:16.000000000 +0700
@@ -113,13 +113,24 @@ enum {
 };
 
 /* Is this a valid filename (upper/lower alpha, digits,
- * underscores, and hyphens only?)
+ * underscores, hyphens, and non-leading dots only?)
  */
 static bool invalid_name(const char *c)
 {
 	c = bb_basename(c);
 
-	while (*c && (isalnum(*c) || *c == '_' || *c == '-'))
+	if (*c == '.')
+		return *c;
+
+	/* Debian run-parts 4.8.3, manpage:
+	 * "...the names must consist entirely of ASCII letters,
+	 * ASCII digits, ASCII underscores, and ASCII minus-hyphens.
+	 * However, the name must not begin with a period."
+	 * The last sentence is a giveaway that something is fishy
+	 * (why mention leading dot if dots are not allowed anyway?).
+	 * Yes, you guessed it right: in fact non-leading dots ARE allowed.
+	 */
+	while (isalnum(*c) || *c == '_' || *c == '-' || *c == '.')
 		c++;
 
 	return *c; /* TRUE (!0) if terminating NUL is not reached */
diff -urpN busybox-1.33.1/docs/busybox_footer.pod busybox-1.34.0/docs/busybox_footer.pod
--- busybox-1.33.1/docs/busybox_footer.pod	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/docs/busybox_footer.pod	2021-06-16 17:02:16.000000000 +0700
@@ -37,6 +37,7 @@ incorrect, please send in an update.
 =for html <br>
 
 Emanuele Aina <emanuele.aina@tiscali.it>
+
     run-parts
 
 =for html <br>
diff -urpN busybox-1.33.1/e2fsprogs/chattr.c busybox-1.34.0/e2fsprogs/chattr.c
--- busybox-1.33.1/e2fsprogs/chattr.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/e2fsprogs/chattr.c	2021-07-20 21:57:20.000000000 +0700
@@ -20,40 +20,52 @@
 //kbuild:lib-$(CONFIG_CHATTR) += chattr.o e2fs_lib.o
 
 //usage:#define chattr_trivial_usage
-//usage:       "[-R] [-v VERSION] [-+=AacDdijsStTu] FILE..."
+//usage:       "[-R] [-v VERSION] [-p PROJID] [-+=AacDdijsStTu] FILE..."
 //usage:#define chattr_full_usage "\n\n"
 //usage:       "Change ext2 file attributes\n"
 //usage:     "\n	-R	Recurse"
-//usage:     "\n	-v VER	Set version/generation number"
+//usage:     "\n	-v NUM	Set version/generation number"
+//usage:     "\n	-p NUM	Set project number"
 //-V, -f accepted but ignored
 //usage:     "\nModifiers:"
 //usage:     "\n	-,+,=	Remove/add/set attributes"
 //usage:     "\nAttributes:"
-//usage:     "\n	A	Don't track atime"
-//usage:     "\n	a	Append mode only"
-//usage:     "\n	c	Enable compress"
-//usage:     "\n	D	Write dir contents synchronously"
+//usage:     "\n	A	No atime"
+//usage:     "\n	a	Append only"
+//usage:     "\n	C	No copy-on-write"
+//usage:     "\n	c	Compressed"
+//usage:     "\n	D	Synchronous dir updates"
 //usage:     "\n	d	Don't backup with dump"
-//usage:     "\n	i	Cannot be modified (immutable)"
-//usage:     "\n	j	Write all data to journal first"
-//usage:     "\n	s	Zero disk storage when deleted"
-//usage:     "\n	S	Write synchronously"
-//usage:     "\n	t	Disable tail-merging of partial blocks with other files"
-//usage:     "\n	u	Allow file to be undeleted"
+//usage:     "\n	E	Encrypted"
+//usage:     "\n	e	File uses extents"
+//usage:     "\n	F	Case-insensitive dir"
+//usage:     "\n	I	Indexed dir"
+//usage:     "\n	i	Immutable"
+//usage:     "\n	j	Write data to journal first"
+//usage:     "\n	N	File is stored in inode"
+//usage:     "\n	P	Hierarchical project ID dir"
+//usage:     "\n	S	Synchronous file updates"
+//usage:     "\n	s	Zero storage when deleted"
+//usage:     "\n	T	Top of dir hierarchy"
+//usage:     "\n	t	Don't tail-merge with other files"
+//usage:     "\n	u	Allow undelete"
+//usage:     "\n	V	Verity"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
 
-#define OPT_ADD 1
-#define OPT_REM 2
-#define OPT_SET 4
-#define OPT_SET_VER 8
+#define OPT_ADD      (1 << 0)
+#define OPT_REM      (1 << 1)
+#define OPT_SET      (1 << 2)
+#define OPT_SET_VER  (1 << 3)
+#define OPT_SET_PROJ (1 << 4)
 
 struct globals {
-	unsigned long version;
-	unsigned long af;
-	unsigned long rf;
+	unsigned version;
+	unsigned af;
+	unsigned rf;
 	int flags;
+	uint32_t projid;
 	smallint recursive;
 };
 
@@ -67,13 +79,15 @@ static unsigned long get_flag(char c)
 
 static char** decode_arg(char **argv, struct globals *gp)
 {
-	unsigned long *fl;
+	unsigned *fl;
 	const char *arg = *argv;
 	char opt = *arg;
 
 	fl = &gp->af;
 	if (opt == '-') {
-		gp->flags |= OPT_REM;
+		/* gp->flags |= OPT_REM; - WRONG, it can be an option */
+		/* testcase: chattr =ae -R FILE should not complain "= is incompatible with - and +" */
+		/* (and should not read flags, with =FLAGS they can be just set directly) */
 		fl = &gp->rf;
 	} else if (opt == '+') {
 		gp->flags |= OPT_ADD;
@@ -103,14 +117,21 @@ static char** decode_arg(char **argv, st
 			if (*arg == 'v') {
 				if (!*++argv)
 					bb_show_usage();
-				gp->version = xatoul(*argv);
+				gp->version = xatou(*argv);
 				gp->flags |= OPT_SET_VER;
 				continue;
 			}
-//TODO: "-p PROJECT_NUM" ?
+			if (*arg == 'p') {
+				if (!*++argv)
+					bb_show_usage();
+				gp->projid = xatou32(*argv);
+				gp->flags |= OPT_SET_PROJ;
+				continue;
+			}
 			/* not a known option, try as an attribute */
+			gp->flags |= OPT_REM;
 		}
-		*fl |= get_flag(*arg);
+		*fl |= get_flag(*arg); /* aborts on bad flag letter */
 	}
 
 	return argv;
@@ -120,6 +141,8 @@ static void change_attributes(const char
 
 static int FAST_FUNC chattr_dir_proc(const char *dir_name, struct dirent *de, void *gp)
 {
+//TODO: use de->d_type (if it's not DT_UNKNOWN) to skip !(REG || DIR || LNK) entries without lstat?
+
 	char *path = concat_subpath_file(dir_name, de->d_name);
 	/* path is NULL if de->d_name is "." or "..", else... */
 	if (path) {
@@ -131,15 +154,14 @@ static int FAST_FUNC chattr_dir_proc(con
 
 static void change_attributes(const char *name, struct globals *gp)
 {
-	unsigned long fsflags;
+	unsigned fsflags;
+	int fd;
 	struct stat st;
 
 	if (lstat(name, &st) != 0) {
-		bb_perror_msg("stat %s", name);
+		bb_perror_msg("can't stat '%s'", name);
 		return;
 	}
-	if (S_ISLNK(st.st_mode) && gp->recursive)
-		return;
 
 	/* Don't try to open device files, fifos etc.  We probably
 	 * ought to display an error if the file was explicitly given
@@ -148,29 +170,58 @@ static void change_attributes(const char
 	if (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode) && !S_ISDIR(st.st_mode))
 		return;
 
-	if (gp->flags & OPT_SET_VER)
-		if (fsetversion(name, gp->version) != 0)
-			bb_perror_msg("setting version on %s", name);
-
-	if (gp->flags & OPT_SET) {
-		fsflags = gp->af;
-	} else {
-		if (fgetflags(name, &fsflags) != 0) {
-			bb_perror_msg("reading flags on %s", name);
-			goto skip_setflags;
+	/* There is no way to run needed ioctls on a symlink.
+	 * open(O_PATH | O_NOFOLLOW) _can_ be used to get a fd referring to the symlink,
+	 * but ioctls fail on such a fd (tried on 4.12.0 kernel).
+	 * e2fsprogs-1.46.2 uses open(O_NOFOLLOW), it fails on symlinks.
+	 */
+	fd = open_or_warn(name, O_RDONLY | O_NONBLOCK | O_NOCTTY | O_NOFOLLOW);
+	if (fd >= 0) {
+		int r;
+
+		if (gp->flags & OPT_SET_VER) {
+			r = ioctl(fd, EXT2_IOC_SETVERSION, &gp->version);
+			if (r != 0)
+				bb_perror_msg("setting %s on %s", "version", name);
+		}
+
+		if (gp->flags & OPT_SET_PROJ) {
+			struct ext2_fsxattr fsxattr;
+			r = ioctl(fd, EXT2_IOC_FSGETXATTR, &fsxattr);
+			/* note: ^^^ may fail in 32-bit userspace on 64-bit kernel (seen on 4.12.0) */
+			if (r != 0) {
+				bb_perror_msg("getting %s on %s", "project ID", name);
+			} else {
+				fsxattr.fsx_projid = gp->projid;
+				r = ioctl(fd, EXT2_IOC_FSSETXATTR, &fsxattr);
+				if (r != 0)
+					bb_perror_msg("setting %s on %s", "project ID", name);
+			}
 		}
-		/*if (gp->flags & OPT_REM) - not needed, rf is zero otherwise */
-			fsflags &= ~gp->rf;
-		/*if (gp->flags & OPT_ADD) - not needed, af is zero otherwise */
-			fsflags |= gp->af;
+
+		if (gp->flags & OPT_SET) {
+			fsflags = gp->af;
+		} else {
+			r = ioctl(fd, EXT2_IOC_GETFLAGS, &fsflags);
+			if (r != 0) {
+				bb_perror_msg("getting %s on %s", "flags", name);
+				goto skip_setflags;
+			}
+			/*if (gp->flags & OPT_REM) - not needed, rf is zero otherwise */
+				fsflags &= ~gp->rf;
+			/*if (gp->flags & OPT_ADD) - not needed, af is zero otherwise */
+				fsflags |= gp->af;
 // What is this? And why it's not done for SET case?
-		if (!S_ISDIR(st.st_mode))
-			fsflags &= ~EXT2_DIRSYNC_FL;
+			if (!S_ISDIR(st.st_mode))
+				fsflags &= ~EXT2_DIRSYNC_FL;
+		}
+		r = ioctl(fd, EXT2_IOC_SETFLAGS, &fsflags);
+		if (r != 0)
+			bb_perror_msg("setting %s on %s", "flags", name);
+ skip_setflags:
+		close(fd);
 	}
-	if (fsetflags(name, fsflags) != 0)
-		bb_perror_msg("setting flags on %s", name);
 
- skip_setflags:
 	if (gp->recursive && S_ISDIR(st.st_mode))
 		iterate_on_dir(name, chattr_dir_proc, gp);
 }
@@ -200,7 +251,7 @@ int chattr_main(int argc UNUSED_PARAM, c
 	if (g.rf & g.af)
 		bb_simple_error_msg_and_die("can't set and unset a flag");
 	if (!g.flags)
-		bb_simple_error_msg_and_die("must use '-v', =, - or +");
+		bb_simple_error_msg_and_die("must use -v, -p, =, - or +");
 
 	/* now run chattr on all the files passed to us */
 	do change_attributes(*argv, &g); while (*++argv);
diff -urpN busybox-1.33.1/e2fsprogs/e2fs_lib.c busybox-1.34.0/e2fsprogs/e2fs_lib.c
--- busybox-1.33.1/e2fsprogs/e2fs_lib.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/e2fsprogs/e2fs_lib.c	2021-07-20 21:57:20.000000000 +0700
@@ -8,133 +8,13 @@
 #include "libbb.h"
 #include "e2fs_lib.h"
 
-#define HAVE_EXT2_IOCTLS 1
-
-#if INT_MAX == LONG_MAX
-#define IF_LONG_IS_SAME(...) __VA_ARGS__
-#define IF_LONG_IS_WIDER(...)
-#else
-#define IF_LONG_IS_SAME(...)
-#define IF_LONG_IS_WIDER(...) __VA_ARGS__
-#endif
-
-static void close_silently(int fd)
-{
-	int e = errno;
-	close(fd);
-	errno = e;
-}
-
-
-/* Iterate a function on each entry of a directory */
-int iterate_on_dir(const char *dir_name,
-		int FAST_FUNC (*func)(const char *, struct dirent *, void *),
-		void *private)
-{
-	DIR *dir;
-	struct dirent *de;
-
-	dir = opendir(dir_name);
-	if (dir == NULL) {
-		return -1;
-	}
-	while ((de = readdir(dir)) != NULL) {
-		func(dir_name, de, private);
-	}
-	closedir(dir);
-	return 0;
-}
-
-
-/* Get/set a file version on an ext2 file system */
-int fgetsetversion(const char *name, unsigned long *get_version, unsigned long set_version)
-{
-#if HAVE_EXT2_IOCTLS
-	int fd, r;
-	IF_LONG_IS_WIDER(int ver;)
-
-	fd = open(name, O_RDONLY | O_NONBLOCK);
-	if (fd == -1)
-		return -1;
-	if (!get_version) {
-		IF_LONG_IS_WIDER(
-			ver = (int) set_version;
-			r = ioctl(fd, EXT2_IOC_SETVERSION, &ver);
-		)
-		IF_LONG_IS_SAME(
-			r = ioctl(fd, EXT2_IOC_SETVERSION, (void*)&set_version);
-		)
-	} else {
-		IF_LONG_IS_WIDER(
-			r = ioctl(fd, EXT2_IOC_GETVERSION, &ver);
-			*get_version = ver;
-		)
-		IF_LONG_IS_SAME(
-			r = ioctl(fd, EXT2_IOC_GETVERSION, (void*)get_version);
-		)
-	}
-	close_silently(fd);
-	return r;
-#else /* ! HAVE_EXT2_IOCTLS */
-	errno = EOPNOTSUPP;
-	return -1;
-#endif /* ! HAVE_EXT2_IOCTLS */
-}
-
-
-/* Get/set a file flags on an ext2 file system */
-int fgetsetflags(const char *name, unsigned long *get_flags, unsigned long set_flags)
-{
-#if HAVE_EXT2_IOCTLS
-	struct stat buf;
-	int fd, r;
-	IF_LONG_IS_WIDER(int f;)
-
-	if (stat(name, &buf) == 0 /* stat is ok */
-	 && !S_ISREG(buf.st_mode) && !S_ISDIR(buf.st_mode)
-	) {
-		goto notsupp;
-	}
-	fd = open(name, O_RDONLY | O_NONBLOCK); /* neither read nor write asked for */
-	if (fd == -1)
-		return -1;
-
-	if (!get_flags) {
-		IF_LONG_IS_WIDER(
-			f = (int) set_flags;
-			r = ioctl(fd, EXT2_IOC_SETFLAGS, &f);
-		)
-		IF_LONG_IS_SAME(
-			r = ioctl(fd, EXT2_IOC_SETFLAGS, (void*)&set_flags);
-		)
-	} else {
-		IF_LONG_IS_WIDER(
-			r = ioctl(fd, EXT2_IOC_GETFLAGS, &f);
-			*get_flags = f;
-		)
-		IF_LONG_IS_SAME(
-			r = ioctl(fd, EXT2_IOC_GETFLAGS, (void*)get_flags);
-		)
-	}
-
-	close_silently(fd);
-	return r;
- notsupp:
-#endif /* HAVE_EXT2_IOCTLS */
-	errno = EOPNOTSUPP;
-	return -1;
-}
-
-
 /* Print file attributes on an ext2 file system */
 const uint32_t e2attr_flags_value[] ALIGN4 = {
 #ifdef ENABLE_COMPRESSION
 	EXT2_COMPRBLK_FL,
 	EXT2_DIRTY_FL,
 	EXT2_NOCOMPR_FL,
-	EXT2_ECOMPR_FL,
 #endif
-	EXT2_INDEX_FL,
 	EXT2_SECRM_FL,
 	EXT2_UNRM_FL,
 	EXT2_SYNC_FL,
@@ -144,26 +24,31 @@ const uint32_t e2attr_flags_value[] ALIG
 	EXT2_NODUMP_FL,
 	EXT2_NOATIME_FL,
 	EXT2_COMPR_FL,
+	EXT2_ECOMPR_FL,
 	EXT3_JOURNAL_DATA_FL,
+	EXT2_INDEX_FL,
 	EXT2_NOTAIL_FL,
-	EXT2_TOPDIR_FL
+	EXT2_TOPDIR_FL,
+	EXT2_EXTENT_FL,
+	EXT2_NOCOW_FL,
+	EXT2_CASEFOLD_FL,
+	EXT2_INLINE_DATA_FL,
+	EXT2_PROJINHERIT_FL,
+	EXT2_VERITY_FL,
 };
 
 const char e2attr_flags_sname[] ALIGN1 =
 #ifdef ENABLE_COMPRESSION
-	"BZXE"
+	"BZX"
 #endif
-	"I"
-	"suSDiadAcjtT";
+	"suSDiadAcEjItTeCFNPV";
 
 static const char e2attr_flags_lname[] ALIGN1 =
 #ifdef ENABLE_COMPRESSION
 	"Compressed_File" "\0"
 	"Compressed_Dirty_File" "\0"
 	"Compression_Raw_Access" "\0"
-	"Compression_Error" "\0"
 #endif
-	"Indexed_directory" "\0"
 	"Secure_Deletion" "\0"
 	"Undelete" "\0"
 	"Synchronous_Updates" "\0"
@@ -173,41 +58,54 @@ static const char e2attr_flags_lname[] A
 	"No_Dump" "\0"
 	"No_Atime" "\0"
 	"Compression_Requested" "\0"
+	"Encrypted" "\0"
 	"Journaled_Data" "\0"
+	"Indexed_directory" "\0"
 	"No_Tailmerging" "\0"
 	"Top_of_Directory_Hierarchies" "\0"
+	"Extents" "\0"
+	"No_COW" "\0"
+	"Casefold" "\0"
+	"Inline_Data" "\0"
+	"Project_Hierarchy" "\0"
+	"Verity" "\0"
 	/* Another trailing NUL is added by compiler */;
 
-void print_e2flags(FILE *f, unsigned long flags, unsigned options)
+void print_e2flags_long(unsigned flags)
+{
+	const uint32_t *fv;
+	const char *fn;
+	int first = 1;
+
+	fv = e2attr_flags_value;
+	fn = e2attr_flags_lname;
+	do {
+		if (flags & *fv) {
+			if (!first)
+				fputs(", ", stdout);
+			fputs(fn, stdout);
+			first = 0;
+		}
+		fv++;
+		fn += strlen(fn) + 1;
+	} while (*fn);
+	if (first)
+		fputs("---", stdout);
+}
+
+void print_e2flags(unsigned flags)
 {
 	const uint32_t *fv;
 	const char *fn;
 
 	fv = e2attr_flags_value;
-	if (options & PFOPT_LONG) {
-		int first = 1;
-		fn = e2attr_flags_lname;
-		do {
-			if (flags & *fv) {
-				if (!first)
-					fputs(", ", f);
-				fputs(fn, f);
-				first = 0;
-			}
-			fv++;
-			fn += strlen(fn) + 1;
-		} while (*fn);
-		if (first)
-			fputs("---", f);
-	} else {
-		fn = e2attr_flags_sname;
-		do  {
-			char c = '-';
-			if (flags & *fv)
-				c = *fn;
-			fputc(c, f);
-			fv++;
-			fn++;
-		} while (*fn);
-	}
+	fn = e2attr_flags_sname;
+	do  {
+		char c = '-';
+		if (flags & *fv)
+			c = *fn;
+		putchar(c);
+		fv++;
+		fn++;
+	} while (*fn);
 }
diff -urpN busybox-1.33.1/e2fsprogs/e2fs_lib.h busybox-1.34.0/e2fsprogs/e2fs_lib.h
--- busybox-1.33.1/e2fsprogs/e2fs_lib.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/e2fsprogs/e2fs_lib.h	2021-07-20 21:57:20.000000000 +0700
@@ -11,25 +11,9 @@
 
 PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
 
-/* Iterate a function on each entry of a directory */
-int iterate_on_dir(const char *dir_name,
-		int FAST_FUNC (*func)(const char *, struct dirent *, void *),
-		void *private);
-
-/* Get/set a file version on an ext2 file system */
-int fgetsetversion(const char *name, unsigned long *get_version, unsigned long set_version);
-#define fgetversion(name, version) fgetsetversion(name, version, 0)
-#define fsetversion(name, version) fgetsetversion(name, NULL, version)
-
-/* Get/set a file flags on an ext2 file system */
-int fgetsetflags(const char *name, unsigned long *get_flags, unsigned long set_flags);
-#define fgetflags(name, flags) fgetsetflags(name, flags, 0)
-#define fsetflags(name, flags) fgetsetflags(name, NULL, flags)
-
-/* Must be 1 for compatibility with 'int long_format'. */
-#define PFOPT_LONG  1
 /* Print file attributes on an ext2 file system */
-void print_e2flags(FILE *f, unsigned long flags, unsigned options);
+void print_e2flags_long(unsigned flags);
+void print_e2flags(unsigned flags);
 
 extern const uint32_t e2attr_flags_value[];
 extern const char e2attr_flags_sname[];
diff -urpN busybox-1.33.1/e2fsprogs/lsattr.c busybox-1.34.0/e2fsprogs/lsattr.c
--- busybox-1.33.1/e2fsprogs/lsattr.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/e2fsprogs/lsattr.c	2021-07-20 21:57:20.000000000 +0700
@@ -21,52 +21,79 @@
 //kbuild:lib-$(CONFIG_LSATTR) += lsattr.o e2fs_lib.o
 
 //usage:#define lsattr_trivial_usage
-//usage:       "[-Radlv] [FILE]..."
+//usage:       "[-Radlpv] [FILE]..."
 //usage:#define lsattr_full_usage "\n\n"
 //usage:       "List ext2 file attributes\n"
 //usage:     "\n	-R	Recurse"
-//usage:     "\n	-a	Don't hide entries starting with ."
-//usage:     "\n	-d	List directory entries instead of contents"
+//usage:     "\n	-a	Include names starting with ."
+//usage:     "\n	-d	List directory names, not contents"
+// -a,-d text should match ls --help
 //usage:     "\n	-l	List long flag names"
+//usage:     "\n	-p	List project ID"
 //usage:     "\n	-v	List version/generation number"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
 
 enum {
-	OPT_RECUR      = 0x1,
-	OPT_ALL        = 0x2,
-	OPT_DIRS_OPT   = 0x4,
-	OPT_PF_LONG    = 0x8,
-	OPT_GENERATION = 0x10,
+	OPT_RECUR      = 1 << 0,
+	OPT_ALL        = 1 << 1,
+	OPT_DIRS_OPT   = 1 << 2,
+	OPT_PF_LONG    = 1 << 3,
+	OPT_GENERATION = 1 << 4,
+	OPT_PROJID     = 1 << 5,
 };
 
 static void list_attributes(const char *name)
 {
-	unsigned long fsflags;
-	unsigned long generation;
+	unsigned fsflags;
+	int fd, r;
 
-	if (fgetflags(name, &fsflags) != 0)
-		goto read_err;
+	/* There is no way to run needed ioctls on a symlink.
+	 * open(O_PATH | O_NOFOLLOW) _can_ be used to get a fd referring to the symlink,
+	 * but ioctls fail on such a fd (tried on 4.12.0 kernel).
+	 * e2fsprogs-1.46.2 uses open(O_NOFOLLOW), it fails on symlinks.
+	 */
+	fd = open_or_warn(name, O_RDONLY | O_NONBLOCK | O_NOCTTY | O_NOFOLLOW);
+	if (fd < 0)
+		return;
+
+	if (option_mask32 & OPT_PROJID) {
+		struct ext2_fsxattr fsxattr;
+		r = ioctl(fd, EXT2_IOC_FSGETXATTR, &fsxattr);
+		/* note: ^^^ may fail in 32-bit userspace on 64-bit kernel (seen on 4.12.0) */
+		if (r != 0)
+			goto read_err;
+		printf("%5u ", (unsigned)fsxattr.fsx_projid);
+	}
 
 	if (option_mask32 & OPT_GENERATION) {
-		if (fgetversion(name, &generation) != 0)
+		unsigned generation;
+		r = ioctl(fd, EXT2_IOC_GETVERSION, &generation);
+		if (r != 0)
 			goto read_err;
-		printf("%5lu ", generation);
+		printf("%-10u ", generation);
 	}
 
+	r = ioctl(fd, EXT2_IOC_GETFLAGS, &fsflags);
+	if (r != 0)
+		goto read_err;
+
+	close(fd);
+
 	if (option_mask32 & OPT_PF_LONG) {
 		printf("%-28s ", name);
-		print_e2flags(stdout, fsflags, PFOPT_LONG);
+		print_e2flags_long(fsflags);
 		bb_putchar('\n');
 	} else {
-		print_e2flags(stdout, fsflags, 0);
+		print_e2flags(fsflags);
 		printf(" %s\n", name);
 	}
 
 	return;
  read_err:
 	bb_perror_msg("reading %s", name);
+	close(fd);
 }
 
 static int FAST_FUNC lsattr_dir_proc(const char *dir_name,
@@ -79,9 +106,13 @@ static int FAST_FUNC lsattr_dir_proc(con
 	path = concat_path_file(dir_name, de->d_name);
 
 	if (lstat(path, &st) != 0)
-		bb_perror_msg("stat %s", path);
+		bb_perror_msg("can't stat '%s'", path);
+
 	else if (de->d_name[0] != '.' || (option_mask32 & OPT_ALL)) {
-		list_attributes(path);
+	        /* Don't try to open device files, fifos etc */
+		if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode) || S_ISDIR(st.st_mode))
+			list_attributes(path);
+
 		if (S_ISDIR(st.st_mode) && (option_mask32 & OPT_RECUR)
 		 && !DOT_OR_DOTDOT(de->d_name)
 		) {
@@ -100,7 +131,7 @@ static void lsattr_args(const char *name
 	struct stat st;
 
 	if (lstat(name, &st) == -1) {
-		bb_perror_msg("stat %s", name);
+		bb_perror_msg("can't stat '%s'", name);
 	} else if (S_ISDIR(st.st_mode) && !(option_mask32 & OPT_DIRS_OPT)) {
 		iterate_on_dir(name, lsattr_dir_proc, NULL);
 	} else {
@@ -111,7 +142,7 @@ static void lsattr_args(const char *name
 int lsattr_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int lsattr_main(int argc UNUSED_PARAM, char **argv)
 {
-	getopt32(argv, "Radlv");
+	getopt32(argv, "Radlvp");
 	argv += optind;
 
 	if (!*argv)
diff -urpN busybox-1.33.1/editors/awk.c busybox-1.34.0/editors/awk.c
--- busybox-1.33.1/editors/awk.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/awk.c	2021-07-20 21:57:20.000000000 +0700
@@ -66,6 +66,8 @@
 #endif
 #ifndef debug_printf_parse
 # define debug_printf_parse(...) (fprintf(stderr, __VA_ARGS__))
+#else
+# define debug_parse_print_tc(...) ((void)0)
 #endif
 
 
@@ -91,7 +93,6 @@ enum {
 };
 
 #define	MAXVARFMT       240
-#define	MINNVBLOCK      64
 
 /* variable flags */
 #define	VF_NUMBER       0x0001	/* 1 = primary type is number */
@@ -101,7 +102,7 @@ enum {
 #define	VF_USER         0x0200	/* 1 = user input (may be numeric string) */
 #define	VF_SPECIAL      0x0400	/* 1 = requires extra handling when changed */
 #define	VF_WALK         0x0800	/* 1 = variable has alloc'd x.walker list */
-#define	VF_FSTR         0x1000	/* 1 = var::string points to fstring buffer */
+#define	VF_FSTR         0x1000	/* 1 = don't free() var::string (not malloced, or is owned by something else) */
 #define	VF_CHILD        0x2000	/* 1 = function arg; x.parent points to source */
 #define	VF_DIRTY        0x4000	/* 1 = variable was set explicitly */
 
@@ -118,8 +119,8 @@ typedef struct walker_list {
 /* Variable */
 typedef struct var_s {
 	unsigned type;            /* flags */
-	double number;
 	char *string;
+	double number;
 	union {
 		int aidx;               /* func arg idx (for compilation stage) */
 		struct xhash_s *array;  /* array ptr */
@@ -138,6 +139,7 @@ typedef struct chain_s {
 /* Function */
 typedef struct func_s {
 	unsigned nargs;
+	smallint defined;
 	struct chain_s body;
 } func;
 
@@ -177,7 +179,7 @@ typedef struct node_s {
 		struct node_s *n;
 		var *v;
 		int aidx;
-		char *new_progname;
+		const char *new_progname;
 		regex_t *re;
 	} l;
 	union {
@@ -190,91 +192,120 @@ typedef struct node_s {
 	} a;
 } node;
 
-/* Block of temporary variables */
-typedef struct nvblock_s {
-	int size;
-	var *pos;
-	struct nvblock_s *prev;
-	struct nvblock_s *next;
-	var nv[];
-} nvblock;
-
 typedef struct tsplitter_s {
 	node n;
 	regex_t re[2];
 } tsplitter;
 
 /* simple token classes */
-/* Order and hex values are very important!!!  See next_token() */
-#define	TC_SEQSTART	(1 << 0)		/* ( */
-#define	TC_SEQTERM	(1 << 1)		/* ) */
-#define	TC_REGEXP	(1 << 2)		/* /.../ */
-#define	TC_OUTRDR	(1 << 3)		/* | > >> */
-#define	TC_UOPPOST	(1 << 4)		/* unary postfix operator */
-#define	TC_UOPPRE1	(1 << 5)		/* unary prefix operator */
-#define	TC_BINOPX	(1 << 6)		/* two-opnd operator */
-#define	TC_IN		(1 << 7)
-#define	TC_COMMA	(1 << 8)
-#define	TC_PIPE		(1 << 9)		/* input redirection pipe */
-#define	TC_UOPPRE2	(1 << 10)		/* unary prefix operator */
-#define	TC_ARRTERM	(1 << 11)		/* ] */
-#define	TC_GRPSTART	(1 << 12)		/* { */
-#define	TC_GRPTERM	(1 << 13)		/* } */
-#define	TC_SEMICOL	(1 << 14)
-#define	TC_NEWLINE	(1 << 15)
-#define	TC_STATX	(1 << 16)		/* ctl statement (for, next...) */
-#define	TC_WHILE	(1 << 17)
-#define	TC_ELSE		(1 << 18)
-#define	TC_BUILTIN	(1 << 19)
+/* order and hex values are very important!!!  See next_token() */
+#define TC_LPAREN       (1 << 0)        /* ( */
+#define TC_RPAREN       (1 << 1)        /* ) */
+#define TC_REGEXP       (1 << 2)        /* /.../ */
+#define TC_OUTRDR       (1 << 3)        /* | > >> */
+#define TC_UOPPOST      (1 << 4)        /* unary postfix operator ++ -- */
+#define TC_UOPPRE1      (1 << 5)        /* unary prefix operator ++ -- $ */
+#define TC_BINOPX       (1 << 6)        /* two-opnd operator */
+#define TC_IN           (1 << 7)        /* 'in' */
+#define TC_COMMA        (1 << 8)        /* , */
+#define TC_PIPE         (1 << 9)        /* input redirection pipe | */
+#define TC_UOPPRE2      (1 << 10)       /* unary prefix operator + - ! */
+#define TC_ARRTERM      (1 << 11)       /* ] */
+#define TC_LBRACE       (1 << 12)       /* { */
+#define TC_RBRACE       (1 << 13)       /* } */
+#define TC_SEMICOL      (1 << 14)       /* ; */
+#define TC_NEWLINE      (1 << 15)
+#define TC_STATX        (1 << 16)       /* ctl statement (for, next...) */
+#define TC_WHILE        (1 << 17)       /* 'while' */
+#define TC_ELSE         (1 << 18)       /* 'else' */
+#define TC_BUILTIN      (1 << 19)
 /* This costs ~50 bytes of code.
  * A separate class to support deprecated "length" form. If we don't need that
  * (i.e. if we demand that only "length()" with () is valid), then TC_LENGTH
  * can be merged with TC_BUILTIN:
  */
-#define	TC_LENGTH	(1 << 20)
-#define	TC_GETLINE	(1 << 21)
-#define	TC_FUNCDECL	(1 << 22)		/* 'function' 'func' */
-#define	TC_BEGIN	(1 << 23)
-#define	TC_END		(1 << 24)
-#define	TC_EOF		(1 << 25)
-#define	TC_VARIABLE	(1 << 26)
-#define	TC_ARRAY	(1 << 27)
-#define	TC_FUNCTION	(1 << 28)
-#define	TC_STRING	(1 << 29)
-#define	TC_NUMBER	(1 << 30)
-
-#define	TC_UOPPRE  (TC_UOPPRE1 | TC_UOPPRE2)
-
-/* combined token classes */
-#define	TC_BINOP   (TC_BINOPX | TC_COMMA | TC_PIPE | TC_IN)
-//#define	TC_UNARYOP (TC_UOPPRE | TC_UOPPOST)
-#define	TC_OPERAND (TC_VARIABLE | TC_ARRAY | TC_FUNCTION \
-                   | TC_BUILTIN | TC_LENGTH | TC_GETLINE \
-                   | TC_SEQSTART | TC_STRING | TC_NUMBER)
+#define TC_LENGTH       (1 << 20)       /* 'length' */
+#define TC_GETLINE      (1 << 21)       /* 'getline' */
+#define TC_FUNCDECL     (1 << 22)       /* 'function' 'func' */
+#define TC_BEGIN        (1 << 23)       /* 'BEGIN' */
+#define TC_END          (1 << 24)       /* 'END' */
+#define TC_EOF          (1 << 25)
+#define TC_VARIABLE     (1 << 26)       /* name */
+#define TC_ARRAY        (1 << 27)       /* name[ */
+#define TC_FUNCTION     (1 << 28)       /* name( */
+#define TC_STRING       (1 << 29)       /* "..." */
+#define TC_NUMBER       (1 << 30)
+
+#ifndef debug_parse_print_tc
+static void debug_parse_print_tc(uint32_t n)
+{
+	if (n & TC_LPAREN  ) debug_printf_parse(" LPAREN"  );
+	if (n & TC_RPAREN  ) debug_printf_parse(" RPAREN"  );
+	if (n & TC_REGEXP  ) debug_printf_parse(" REGEXP"  );
+	if (n & TC_OUTRDR  ) debug_printf_parse(" OUTRDR"  );
+	if (n & TC_UOPPOST ) debug_printf_parse(" UOPPOST" );
+	if (n & TC_UOPPRE1 ) debug_printf_parse(" UOPPRE1" );
+	if (n & TC_BINOPX  ) debug_printf_parse(" BINOPX"  );
+	if (n & TC_IN      ) debug_printf_parse(" IN"      );
+	if (n & TC_COMMA   ) debug_printf_parse(" COMMA"   );
+	if (n & TC_PIPE    ) debug_printf_parse(" PIPE"    );
+	if (n & TC_UOPPRE2 ) debug_printf_parse(" UOPPRE2" );
+	if (n & TC_ARRTERM ) debug_printf_parse(" ARRTERM" );
+	if (n & TC_LBRACE  ) debug_printf_parse(" LBRACE"  );
+	if (n & TC_RBRACE  ) debug_printf_parse(" RBRACE"  );
+	if (n & TC_SEMICOL ) debug_printf_parse(" SEMICOL" );
+	if (n & TC_NEWLINE ) debug_printf_parse(" NEWLINE" );
+	if (n & TC_STATX   ) debug_printf_parse(" STATX"   );
+	if (n & TC_WHILE   ) debug_printf_parse(" WHILE"   );
+	if (n & TC_ELSE    ) debug_printf_parse(" ELSE"    );
+	if (n & TC_BUILTIN ) debug_printf_parse(" BUILTIN" );
+	if (n & TC_LENGTH  ) debug_printf_parse(" LENGTH"  );
+	if (n & TC_GETLINE ) debug_printf_parse(" GETLINE" );
+	if (n & TC_FUNCDECL) debug_printf_parse(" FUNCDECL");
+	if (n & TC_BEGIN   ) debug_printf_parse(" BEGIN"   );
+	if (n & TC_END     ) debug_printf_parse(" END"     );
+	if (n & TC_EOF     ) debug_printf_parse(" EOF"     );
+	if (n & TC_VARIABLE) debug_printf_parse(" VARIABLE");
+	if (n & TC_ARRAY   ) debug_printf_parse(" ARRAY"   );
+	if (n & TC_FUNCTION) debug_printf_parse(" FUNCTION");
+	if (n & TC_STRING  ) debug_printf_parse(" STRING"  );
+	if (n & TC_NUMBER  ) debug_printf_parse(" NUMBER"  );
+}
+#endif
+
+/* combined token classes ("token [class] sets") */
+#define	TS_UOPPRE   (TC_UOPPRE1 | TC_UOPPRE2)
 
-#define	TC_STATEMNT (TC_STATX | TC_WHILE)
-#define	TC_OPTERM  (TC_SEMICOL | TC_NEWLINE)
+#define	TS_BINOP    (TC_BINOPX | TC_COMMA | TC_PIPE | TC_IN)
+//#define TS_UNARYOP (TS_UOPPRE | TC_UOPPOST)
+#define	TS_OPERAND  (TC_VARIABLE | TC_ARRAY | TC_FUNCTION \
+                    | TC_BUILTIN | TC_LENGTH | TC_GETLINE \
+                    | TC_LPAREN | TC_STRING | TC_NUMBER)
+
+#define	TS_LVALUE   (TC_VARIABLE | TC_ARRAY)
+#define	TS_STATEMNT (TC_STATX | TC_WHILE)
 
 /* word tokens, cannot mean something else if not expected */
-#define	TC_WORD    (TC_IN | TC_STATEMNT | TC_ELSE \
-                   | TC_BUILTIN | TC_LENGTH | TC_GETLINE \
-                   | TC_FUNCDECL | TC_BEGIN | TC_END)
+#define	TS_WORD     (TC_IN | TS_STATEMNT | TC_ELSE \
+                    | TC_BUILTIN | TC_LENGTH | TC_GETLINE \
+                    | TC_FUNCDECL | TC_BEGIN | TC_END)
 
 /* discard newlines after these */
-#define	TC_NOTERM  (TC_COMMA | TC_GRPSTART | TC_GRPTERM \
-                   | TC_BINOP | TC_OPTERM)
+#define	TS_NOTERM   (TS_BINOP | TC_COMMA | TC_LBRACE | TC_RBRACE \
+                    | TC_SEMICOL | TC_NEWLINE)
 
 /* what can expression begin with */
-#define	TC_OPSEQ   (TC_OPERAND | TC_UOPPRE | TC_REGEXP)
+#define	TS_OPSEQ    (TS_OPERAND | TS_UOPPRE | TC_REGEXP)
 /* what can group begin with */
-#define	TC_GRPSEQ  (TC_OPSEQ | TC_OPTERM | TC_STATEMNT | TC_GRPSTART)
+#define	TS_GRPSEQ   (TS_OPSEQ | TS_STATEMNT \
+                    | TC_SEMICOL | TC_NEWLINE | TC_LBRACE)
 
-/* if previous token class is CONCAT1 and next is CONCAT2, concatenation */
+/* if previous token class is CONCAT_L and next is CONCAT_R, concatenation */
 /* operator is inserted between them */
-#define	TC_CONCAT1 (TC_VARIABLE | TC_ARRTERM | TC_SEQTERM \
+#define	TS_CONCAT_L (TC_VARIABLE | TC_ARRTERM | TC_RPAREN \
                    | TC_STRING | TC_NUMBER | TC_UOPPOST \
                    | TC_LENGTH)
-#define	TC_CONCAT2 (TC_OPERAND | TC_UOPPRE)
+#define	TS_CONCAT_R (TS_OPERAND | TS_UOPPRE)
 
 #define	OF_RES1     0x010000
 #define	OF_RES2     0x020000
@@ -284,13 +315,12 @@ typedef struct tsplitter_s {
 #define	OF_CHECKED  0x200000
 #define	OF_REQUIRED 0x400000
 
-
 /* combined operator flags */
 #define	xx	0
 #define	xV	OF_RES2
 #define	xS	(OF_RES2 | OF_STR2)
 #define	Vx	OF_RES1
-#define	Rx	(OF_RES1 | OF_NUM1 | OF_REQUIRED)
+#define	Rx	OF_REQUIRED
 #define	VV	(OF_RES1 | OF_RES2)
 #define	Nx	(OF_RES1 | OF_NUM1)
 #define	NV	(OF_RES1 | OF_NUM1 | OF_RES2)
@@ -302,8 +332,7 @@ typedef struct tsplitter_s {
 #define	OPNMASK   0x007F
 
 /* operator priority is a highest byte (even: r->l, odd: l->r grouping)
- * For builtins it has different meaning: n n s3 s2 s1 v3 v2 v1,
- * n - min. number of args, vN - resolve Nth arg to var, sN - resolve to string
+ * (for builtins it has different meaning)
  */
 #undef P
 #undef PRIMASK
@@ -313,10 +342,8 @@ typedef struct tsplitter_s {
 #define PRIMASK2  0x7E000000
 
 /* Operation classes */
-
 #define	SHIFT_TIL_THIS	0x0600
 #define	RECUR_FROM_THIS	0x1000
-
 enum {
 	OC_DELETE = 0x0100,     OC_EXEC = 0x0200,       OC_NEWSOURCE = 0x0300,
 	OC_PRINT = 0x0400,      OC_PRINTF = 0x0500,     OC_WALKINIT = 0x0600,
@@ -358,8 +385,8 @@ enum {
 #define NTCC    '\377'
 
 static const char tokenlist[] ALIGN1 =
-	"\1("         NTC                                   /* TC_SEQSTART */
-	"\1)"         NTC                                   /* TC_SEQTERM */
+	"\1("         NTC                                   /* TC_LPAREN */
+	"\1)"         NTC                                   /* TC_RPAREN */
 	"\1/"         NTC                                   /* TC_REGEXP */
 	"\2>>"        "\1>"         "\1|"       NTC         /* TC_OUTRDR */
 	"\2++"        "\2--"        NTC                     /* TC_UOPPOST */
@@ -376,8 +403,8 @@ static const char tokenlist[] ALIGN1 =
 	"\1|"         NTC                                   /* TC_PIPE */
 	"\1+"         "\1-"         "\1!"       NTC         /* TC_UOPPRE2 */
 	"\1]"         NTC                                   /* TC_ARRTERM */
-	"\1{"         NTC                                   /* TC_GRPSTART */
-	"\1}"         NTC                                   /* TC_GRPTERM */
+	"\1{"         NTC                                   /* TC_LBRACE */
+	"\1}"         NTC                                   /* TC_RBRACE */
 	"\1;"         NTC                                   /* TC_SEMICOL */
 	"\1\n"        NTC                                   /* TC_NEWLINE */
 	"\2if"        "\2do"        "\3for"     "\5break"   /* TC_STATX */
@@ -391,7 +418,7 @@ static const char tokenlist[] ALIGN1 =
 	"\5close"     "\6system"    "\6fflush"  "\5atan2"
 	"\3cos"       "\3exp"       "\3int"     "\3log"
 	"\4rand"      "\3sin"       "\4sqrt"    "\5srand"
-	"\6gensub"    "\4gsub"      "\5index"	/* "\6length" was here */
+	"\6gensub"    "\4gsub"      "\5index"   /* "\6length" was here */
 	"\5match"     "\5split"     "\7sprintf" "\3sub"
 	"\6substr"    "\7systime"   "\10strftime" "\6mktime"
 	"\7tolower"   "\7toupper"   NTC
@@ -403,25 +430,32 @@ static const char tokenlist[] ALIGN1 =
 	/* compiler adds trailing "\0" */
 	;
 
-#define OC_B  OC_BUILTIN
-
 static const uint32_t tokeninfo[] ALIGN4 = {
 	0,
 	0,
-	OC_REGEXP,
+#define TI_REGEXP OC_REGEXP
+	TI_REGEXP,
 	xS|'a',                  xS|'w',                  xS|'|',
 	OC_UNARY|xV|P(9)|'p',    OC_UNARY|xV|P(9)|'m',
-	OC_UNARY|xV|P(9)|'P',    OC_UNARY|xV|P(9)|'M',    OC_FIELD|xV|P(5),
+#define TI_PREINC (OC_UNARY|xV|P(9)|'P')
+#define TI_PREDEC (OC_UNARY|xV|P(9)|'M')
+	TI_PREINC,               TI_PREDEC,               OC_FIELD|xV|P(5),
 	OC_COMPARE|VV|P(39)|5,   OC_MOVE|VV|P(74),        OC_REPLACE|NV|P(74)|'+', OC_REPLACE|NV|P(74)|'-',
 	OC_REPLACE|NV|P(74)|'*', OC_REPLACE|NV|P(74)|'/', OC_REPLACE|NV|P(74)|'%', OC_REPLACE|NV|P(74)|'&',
 	OC_BINARY|NV|P(29)|'+',  OC_BINARY|NV|P(29)|'-',  OC_REPLACE|NV|P(74)|'&', OC_BINARY|NV|P(15)|'&',
 	OC_BINARY|NV|P(25)|'/',  OC_BINARY|NV|P(25)|'%',  OC_BINARY|NV|P(15)|'&',  OC_BINARY|NV|P(25)|'*',
 	OC_COMPARE|VV|P(39)|4,   OC_COMPARE|VV|P(39)|3,   OC_COMPARE|VV|P(39)|0,   OC_COMPARE|VV|P(39)|1,
-	OC_COMPARE|VV|P(39)|2,   OC_MATCH|Sx|P(45)|'!',   OC_MATCH|Sx|P(45)|'~',   OC_LAND|Vx|P(55),
-	OC_LOR|Vx|P(59),         OC_TERNARY|Vx|P(64)|'?', OC_COLON|xx|P(67)|':',
-	OC_IN|SV|P(49), /* TC_IN */
-	OC_COMMA|SS|P(80),
-	OC_PGETLINE|SV|P(37),
+#define TI_LESS     (OC_COMPARE|VV|P(39)|2)
+	TI_LESS,                 OC_MATCH|Sx|P(45)|'!',   OC_MATCH|Sx|P(45)|'~',   OC_LAND|Vx|P(55),
+#define TI_TERNARY  (OC_TERNARY|Vx|P(64)|'?')
+#define TI_COLON    (OC_COLON|xx|P(67)|':')
+	OC_LOR|Vx|P(59),         TI_TERNARY,              TI_COLON,
+#define TI_IN       (OC_IN|SV|P(49))
+	TI_IN,
+#define TI_COMMA    (OC_COMMA|SS|P(80))
+	TI_COMMA,
+#define TI_PGETLINE (OC_PGETLINE|SV|P(37))
+	TI_PGETLINE,
 	OC_UNARY|xV|P(19)|'+',   OC_UNARY|xV|P(19)|'-',   OC_UNARY|xV|P(19)|'!',
 	0, /* ] */
 	0,
@@ -434,20 +468,45 @@ static const uint32_t tokeninfo[] ALIGN4
 	OC_RETURN|Vx, OC_EXIT|Nx,
 	ST_WHILE,
 	0, /* else */
-	OC_B|B_an|P(0x83), OC_B|B_co|P(0x41), OC_B|B_ls|P(0x83), OC_B|B_or|P(0x83),
-	OC_B|B_rs|P(0x83), OC_B|B_xo|P(0x83),
-	OC_FBLTIN|Sx|F_cl, OC_FBLTIN|Sx|F_sy, OC_FBLTIN|Sx|F_ff, OC_B|B_a2|P(0x83),
-	OC_FBLTIN|Nx|F_co, OC_FBLTIN|Nx|F_ex, OC_FBLTIN|Nx|F_in, OC_FBLTIN|Nx|F_lg,
-	OC_FBLTIN|F_rn,    OC_FBLTIN|Nx|F_si, OC_FBLTIN|Nx|F_sq, OC_FBLTIN|Nx|F_sr,
-	OC_B|B_ge|P(0xd6), OC_B|B_gs|P(0xb6), OC_B|B_ix|P(0x9b), /* OC_FBLTIN|Sx|F_le, was here */
-	OC_B|B_ma|P(0x89), OC_B|B_sp|P(0x8b), OC_SPRINTF,        OC_B|B_su|P(0xb6),
-	OC_B|B_ss|P(0x8f), OC_FBLTIN|F_ti,    OC_B|B_ti|P(0x0b), OC_B|B_mt|P(0x0b),
-	OC_B|B_lo|P(0x49), OC_B|B_up|P(0x49),
-	OC_FBLTIN|Sx|F_le, /* TC_LENGTH */
-	OC_GETLINE|SV|P(0),
-	0,                 0,
-	0,
-	0 /* TC_END */
+// OC_B's are builtins with enforced minimum number of arguments (two upper bits).
+//  Highest byte bit pattern: nn s3s2s1 v3v2v1
+//  nn - min. number of args, sN - resolve Nth arg to string, vN - resolve to var
+// OC_F's are builtins with zero or one argument.
+//  |Rx| enforces that arg is present for: system, close, cos, sin, exp, int, log, sqrt
+//  Check for no args is present in builtins' code (not in this table): rand, systime
+//  Have one _optional_ arg: fflush, srand, length
+#define OC_B   OC_BUILTIN
+#define OC_F   OC_FBLTIN
+#define A1     P(0x40) /*one arg*/
+#define A2     P(0x80) /*two args*/
+#define A3     P(0xc0) /*three args*/
+#define __v    P(1)
+#define _vv    P(3)
+#define __s__v P(9)
+#define __s_vv P(0x0b)
+#define __svvv P(0x0f)
+#define _ss_vv P(0x1b)
+#define _s_vv_ P(0x16)
+#define ss_vv_ P(0x36)
+	OC_B|B_an|_vv|A2,   OC_B|B_co|__v|A1,   OC_B|B_ls|_vv|A2,   OC_B|B_or|_vv|A2,   // and    compl   lshift   or
+	OC_B|B_rs|_vv|A2,   OC_B|B_xo|_vv|A2,                                           // rshift xor
+	OC_F|F_cl|Sx|Rx,    OC_F|F_sy|Sx|Rx,    OC_F|F_ff|Sx,       OC_B|B_a2|_vv|A2,   // close  system  fflush   atan2
+	OC_F|F_co|Nx|Rx,    OC_F|F_ex|Nx|Rx,    OC_F|F_in|Nx|Rx,    OC_F|F_lg|Nx|Rx,    // cos    exp     int      log
+	OC_F|F_rn,          OC_F|F_si|Nx|Rx,    OC_F|F_sq|Nx|Rx,    OC_F|F_sr|Nx,       // rand   sin     sqrt     srand
+	OC_B|B_ge|_s_vv_|A3,OC_B|B_gs|ss_vv_|A2,OC_B|B_ix|_ss_vv|A2,                    // gensub gsub    index  /*length was here*/
+	OC_B|B_ma|__s__v|A2,OC_B|B_sp|__s_vv|A2,OC_SPRINTF,         OC_B|B_su|ss_vv_|A2,// match  split   sprintf  sub
+	OC_B|B_ss|__svvv|A2,OC_F|F_ti,          OC_B|B_ti|__s_vv,   OC_B|B_mt|__s_vv,   // substr systime strftime mktime
+	OC_B|B_lo|__s__v|A1,OC_B|B_up|__s__v|A1,                                        // tolower toupper
+	OC_F|F_le|Sx,   // length
+	OC_GETLINE|SV,  // getline
+	0, 0, // func function
+	0, // BEGIN
+	0  // END
+#undef A1
+#undef A2
+#undef A3
+#undef OC_B
+#undef OC_F
 };
 
 /* internal variable names and their initial values       */
@@ -488,21 +547,29 @@ struct globals {
 	chain *seq;
 	node *break_ptr, *continue_ptr;
 	rstream *iF;
-	xhash *vhash, *ahash, *fdhash, *fnhash;
+	xhash *ahash;  /* argument names, used only while parsing function bodies */
+	xhash *fnhash; /* function names, used only in parsing stage */
+	xhash *vhash;  /* variables and arrays */
+	//xhash *fdhash; /* file objects, used only in execution stage */
+	//we are reusing ahash as fdhash, via define (see later)
 	const char *g_progname;
 	int g_lineno;
 	int nfields;
 	int maxfields; /* used in fsrealloc() only */
 	var *Fields;
-	nvblock *g_cb;
 	char *g_pos;
-	char *g_buf;
+	char g_saved_ch;
 	smallint icase;
 	smallint exiting;
 	smallint nextrec;
 	smallint nextfile;
 	smallint is_f0_split;
 	smallint t_rollback;
+
+	/* former statics from various functions */
+	smallint next_token__concat_inserted;
+	uint32_t next_token__save_tclass;
+	uint32_t next_token__save_info;
 };
 struct globals2 {
 	uint32_t t_info; /* often used */
@@ -515,32 +582,35 @@ struct globals2 {
 	/* former statics from various functions */
 	char *split_f0__fstrings;
 
-	uint32_t next_token__save_tclass;
-	uint32_t next_token__save_info;
-	uint32_t next_token__ltclass;
-	smallint next_token__concat_inserted;
-
-	smallint next_input_file__files_happen;
 	rstream next_input_file__rsm;
+	smallint next_input_file__files_happen;
+
+	smalluint exitcode;
 
-	var *evaluate__fnargs;
 	unsigned evaluate__seed;
+	var *evaluate__fnargs;
 	regex_t evaluate__sreg;
 
-	var ptest__v;
+	var ptest__tmpvar;
+	var awk_printf__tmpvar;
+	var as_regex__tmpvar;
+	var exit__tmpvar;
+	var main__tmpvar;
 
 	tsplitter exec_builtin__tspl;
 
 	/* biggest and least used members go last */
 	tsplitter fsplitter, rsplitter;
+
+	char g_buf[MAXVARFMT + 1];
 };
 #define G1 (ptr_to_globals[-1])
 #define G (*(struct globals2 *)ptr_to_globals)
 /* For debug. nm --size-sort awk.o | grep -vi ' [tr] ' */
-/*char G1size[sizeof(G1)]; - 0x74 */
-/*char Gsize[sizeof(G)]; - 0x1c4 */
+//char G1size[sizeof(G1)]; // 0x70
+//char Gsize[sizeof(G)]; // 0x2f8
 /* Trying to keep most of members accessible with short offsets: */
-/*char Gofs_seed[offsetof(struct globals2, evaluate__seed)]; - 0x90 */
+//char Gofs_seed[offsetof(struct globals2, evaluate__seed)]; // 0x7c
 #define t_double     (G1.t_double    )
 #define beginseq     (G1.beginseq    )
 #define mainseq      (G1.mainseq     )
@@ -549,18 +619,20 @@ struct globals2 {
 #define break_ptr    (G1.break_ptr   )
 #define continue_ptr (G1.continue_ptr)
 #define iF           (G1.iF          )
-#define vhash        (G1.vhash       )
 #define ahash        (G1.ahash       )
-#define fdhash       (G1.fdhash      )
 #define fnhash       (G1.fnhash      )
+#define vhash        (G1.vhash       )
+#define fdhash       ahash
+//^^^^^^^^^^^^^^^^^^ ahash is cleared after every function parsing,
+// and ends up empty after parsing phase. Thus, we can simply reuse it
+// for fdhash in execution stage.
 #define g_progname   (G1.g_progname  )
 #define g_lineno     (G1.g_lineno    )
 #define nfields      (G1.nfields     )
 #define maxfields    (G1.maxfields   )
 #define Fields       (G1.Fields      )
-#define g_cb         (G1.g_cb        )
 #define g_pos        (G1.g_pos       )
-#define g_buf        (G1.g_buf       )
+#define g_saved_ch   (G1.g_saved_ch  )
 #define icase        (G1.icase       )
 #define exiting      (G1.exiting     )
 #define nextrec      (G1.nextrec     )
@@ -574,25 +646,13 @@ struct globals2 {
 #define intvar       (G.intvar      )
 #define fsplitter    (G.fsplitter   )
 #define rsplitter    (G.rsplitter   )
+#define g_buf        (G.g_buf       )
 #define INIT_G() do { \
 	SET_PTR_TO_GLOBALS((char*)xzalloc(sizeof(G1)+sizeof(G)) + sizeof(G1)); \
-	G.next_token__ltclass = TC_OPTERM; \
+	t_tclass = TC_NEWLINE; \
 	G.evaluate__seed = 1; \
 } while (0)
 
-
-/* function prototypes */
-static void handle_special(var *);
-static node *parse_expr(uint32_t);
-static void chain_group(void);
-static var *evaluate(node *, var *);
-static rstream *next_input_file(void);
-static int fmt_num(char *, int, const char *, double, int);
-static int awk_exit(int) NORETURN;
-
-/* ---- error handling ---- */
-
-static const char EMSG_INTERNAL_ERROR[] ALIGN1 = "Internal error";
 static const char EMSG_UNEXP_EOS[] ALIGN1 = "Unexpected end of string";
 static const char EMSG_UNEXP_TOKEN[] ALIGN1 = "Unexpected token";
 static const char EMSG_DIV_BY_ZERO[] ALIGN1 = "Division by zero";
@@ -604,10 +664,7 @@ static const char EMSG_UNDEF_FUNC[] ALIG
 static const char EMSG_NO_MATH[] ALIGN1 = "Math support is not compiled in";
 static const char EMSG_NEGATIVE_FIELD[] ALIGN1 = "Access to negative field";
 
-static void zero_out_var(var *vp)
-{
-	memset(vp, 0, sizeof(*vp));
-}
+static int awk_exit(void) NORETURN;
 
 static void syntax_error(const char *message) NORETURN;
 static void syntax_error(const char *message)
@@ -638,12 +695,40 @@ static xhash *hash_init(void)
 	return newhash;
 }
 
+static void hash_clear(xhash *hash)
+{
+	unsigned i;
+	hash_item *hi, *thi;
+
+	for (i = 0; i < hash->csize; i++) {
+		hi = hash->items[i];
+		while (hi) {
+			thi = hi;
+			hi = hi->next;
+//FIXME: this assumes that it's a hash of *variables*:
+			free(thi->data.v.string);
+			free(thi);
+		}
+		hash->items[i] = NULL;
+	}
+	hash->glen = hash->nel = 0;
+}
+
+#if 0 //UNUSED
+static void hash_free(xhash *hash)
+{
+	hash_clear(hash);
+	free(hash->items);
+	free(hash);
+}
+#endif
+
 /* find item in hash, return ptr to data, NULL if not found */
-static void *hash_search(xhash *hash, const char *name)
+static NOINLINE void *hash_search3(xhash *hash, const char *name, unsigned idx)
 {
 	hash_item *hi;
 
-	hi = hash->items[hashidx(name) % hash->csize];
+	hi = hash->items[idx % hash->csize];
 	while (hi) {
 		if (strcmp(hi->name, name) == 0)
 			return &hi->data;
@@ -652,6 +737,11 @@ static void *hash_search(xhash *hash, co
 	return NULL;
 }
 
+static void *hash_search(xhash *hash, const char *name)
+{
+	return hash_search3(hash, name,	hashidx(name));
+}
+
 /* grow hash if it becomes too big */
 static void hash_rebuild(xhash *hash)
 {
@@ -687,16 +777,17 @@ static void *hash_find(xhash *hash, cons
 	unsigned idx;
 	int l;
 
-	hi = hash_search(hash, name);
+	idx = hashidx(name);
+	hi = hash_search3(hash, name, idx);
 	if (!hi) {
-		if (++hash->nel / hash->csize > 10)
+		if (++hash->nel > hash->csize * 8)
 			hash_rebuild(hash);
 
 		l = strlen(name) + 1;
 		hi = xzalloc(sizeof(*hi) + l);
 		strcpy(hi->name, name);
 
-		idx = hashidx(name) % hash->csize;
+		idx = idx % hash->csize;
 		hi->next = hash->items[idx];
 		hash->items[idx] = hi;
 		hash->glen += l;
@@ -731,7 +822,7 @@ static void hash_remove(xhash *hash, con
 
 static char *skip_spaces(char *p)
 {
-	while (1) {
+	for (;;) {
 		if (*p == '\\' && p[1] == '\n') {
 			p++;
 			t_lineno++;
@@ -747,8 +838,10 @@ static char *skip_spaces(char *p)
 static char *nextword(char **s)
 {
 	char *p = *s;
-	while (*(*s)++ != '\0')
+	char *q = p;
+	while (*q++ != '\0')
 		continue;
+	*s = q;
 	return p;
 }
 
@@ -811,10 +904,27 @@ static double my_strtod(char **pp)
 
 /* -------- working with variables (set/get/copy/etc) -------- */
 
-static xhash *iamarray(var *v)
+static void fmt_num(const char *format, double n)
 {
-	var *a = v;
+	if (n == (long long)n) {
+		snprintf(g_buf, MAXVARFMT, "%lld", (long long)n);
+	} else {
+		const char *s = format;
+		char c;
+
+		do { c = *s; } while (c && *++s);
+		if (strchr("diouxX", c)) {
+			snprintf(g_buf, MAXVARFMT, format, (int)n);
+		} else if (strchr("eEfFgGaA", c)) {
+			snprintf(g_buf, MAXVARFMT, format, n);
+		} else {
+			syntax_error(EMSG_INV_FMT);
+		}
+	}
+}
 
+static xhash *iamarray(var *a)
+{
 	while (a->type & VF_CHILD)
 		a = a->x.parent;
 
@@ -825,23 +935,7 @@ static xhash *iamarray(var *v)
 	return a->x.array;
 }
 
-static void clear_array(xhash *array)
-{
-	unsigned i;
-	hash_item *hi, *thi;
-
-	for (i = 0; i < array->csize; i++) {
-		hi = array->items[i];
-		while (hi) {
-			thi = hi;
-			hi = hi->next;
-			free(thi->data.v.string);
-			free(thi);
-		}
-		array->items[i] = NULL;
-	}
-	array->glen = array->nel = 0;
-}
+#define clear_array(array) hash_clear(array)
 
 /* clear a variable */
 static var *clrvar(var *v)
@@ -855,6 +949,8 @@ static var *clrvar(var *v)
 	return v;
 }
 
+static void handle_special(var *);
+
 /* assign string value to variable */
 static var *setvar_p(var *v, char *value)
 {
@@ -901,7 +997,7 @@ static const char *getvar_s(var *v)
 {
 	/* if v is numeric and has no cached string, convert it to string */
 	if ((v->type & (VF_NUMBER | VF_CACHED)) == VF_NUMBER) {
-		fmt_num(g_buf, MAXVARFMT, getvar_s(intvar[CONVFMT]), v->number, TRUE);
+		fmt_num(getvar_s(intvar[CONVFMT]), v->number);
 		v->string = xstrdup(g_buf);
 		v->type |= VF_CACHED;
 	}
@@ -920,6 +1016,7 @@ static double getvar_i(var *v)
 			v->number = my_strtod(&s);
 			debug_printf_eval("%f (s:'%s')\n", v->number, s);
 			if (v->type & VF_USER) {
+//TODO: skip_spaces() also skips backslash+newline, is it intended here?
 				s = skip_spaces(s);
 				if (*s != '\0')
 					v->type &= ~VF_USER;
@@ -981,94 +1078,28 @@ static int istrue(var *v)
 	return (v->string && v->string[0]);
 }
 
-/* temporary variables allocator. Last allocated should be first freed */
-static var *nvalloc(int n)
-{
-	nvblock *pb = NULL;
-	var *v, *r;
-	int size;
-
-	while (g_cb) {
-		pb = g_cb;
-		if ((g_cb->pos - g_cb->nv) + n <= g_cb->size)
-			break;
-		g_cb = g_cb->next;
-	}
-
-	if (!g_cb) {
-		size = (n <= MINNVBLOCK) ? MINNVBLOCK : n;
-		g_cb = xzalloc(sizeof(nvblock) + size * sizeof(var));
-		g_cb->size = size;
-		g_cb->pos = g_cb->nv;
-		g_cb->prev = pb;
-		/*g_cb->next = NULL; - xzalloc did it */
-		if (pb)
-			pb->next = g_cb;
-	}
-
-	v = r = g_cb->pos;
-	g_cb->pos += n;
-
-	while (v < g_cb->pos) {
-		v->type = 0;
-		v->string = NULL;
-		v++;
-	}
-
-	return r;
-}
-
-static void nvfree(var *v)
-{
-	var *p;
-
-	if (v < g_cb->nv || v >= g_cb->pos)
-		syntax_error(EMSG_INTERNAL_ERROR);
-
-	for (p = v; p < g_cb->pos; p++) {
-		if ((p->type & (VF_ARRAY | VF_CHILD)) == VF_ARRAY) {
-			clear_array(iamarray(p));
-			free(p->x.array->items);
-			free(p->x.array);
-		}
-		if (p->type & VF_WALK) {
-			walker_list *n;
-			walker_list *w = p->x.walker;
-			debug_printf_walker("nvfree: freeing walker @%p\n", &p->x.walker);
-			p->x.walker = NULL;
-			while (w) {
-				n = w->prev;
-				debug_printf_walker(" free(%p)\n", w);
-				free(w);
-				w = n;
-			}
-		}
-		clrvar(p);
-	}
-
-	g_cb->pos = v;
-	while (g_cb->prev && g_cb->pos == g_cb->nv) {
-		g_cb = g_cb->prev;
-	}
-}
-
 /* ------- awk program text parsing ------- */
 
-/* Parse next token pointed by global pos, place results into global ttt.
- * If token isn't expected, give away. Return token class
+/* Parse next token pointed by global pos, place results into global t_XYZ variables.
+ * If token isn't expected, print error message and die.
+ * Return token class (also store it in t_tclass).
  */
 static uint32_t next_token(uint32_t expected)
 {
-#define concat_inserted (G.next_token__concat_inserted)
-#define save_tclass     (G.next_token__save_tclass)
-#define save_info       (G.next_token__save_info)
-/* Initialized to TC_OPTERM: */
-#define ltclass         (G.next_token__ltclass)
+#define concat_inserted (G1.next_token__concat_inserted)
+#define save_tclass     (G1.next_token__save_tclass)
+#define save_info       (G1.next_token__save_info)
 
-	char *p, *s;
+	char *p;
 	const char *tl;
-	uint32_t tc;
 	const uint32_t *ti;
+	uint32_t tc, last_token_class;
+
+	last_token_class = t_tclass; /* t_tclass is initialized to TC_NEWLINE */
+
+	debug_printf_parse("%s() expected(%x):", __func__, expected);
+	debug_parse_print_tc(expected);
+	debug_printf_parse("\n");
 
 	if (t_rollback) {
 		debug_printf_parse("%s: using rolled-back token\n", __func__);
@@ -1080,6 +1111,10 @@ static uint32_t next_token(uint32_t expe
 		t_info = save_info;
 	} else {
 		p = g_pos;
+		if (g_saved_ch != '\0') {
+			*p = g_saved_ch;
+			g_saved_ch = '\0';
+		}
  readnext:
 		p = skip_spaces(p);
 		g_lineno = t_lineno;
@@ -1087,15 +1122,12 @@ static uint32_t next_token(uint32_t expe
 			while (*p != '\n' && *p != '\0')
 				p++;
 
-		if (*p == '\n')
-			t_lineno++;
-
 		if (*p == '\0') {
 			tc = TC_EOF;
 			debug_printf_parse("%s: token found: TC_EOF\n", __func__);
 		} else if (*p == '\"') {
 			/* it's a string */
-			t_string = s = ++p;
+			char *s = t_string = ++p;
 			while (*p != '\"') {
 				char *pp;
 				if (*p == '\0' || *p == '\n')
@@ -1110,7 +1142,7 @@ static uint32_t next_token(uint32_t expe
 			debug_printf_parse("%s: token found:'%s' TC_STRING\n", __func__, t_string);
 		} else if ((expected & TC_REGEXP) && *p == '/') {
 			/* it's regexp */
-			t_string = s = ++p;
+			char *s	= t_string = ++p;
 			while (*p != '/') {
 				if (*p == '\0' || *p == '\n')
 					syntax_error(EMSG_UNEXP_EOS);
@@ -1141,6 +1173,11 @@ static uint32_t next_token(uint32_t expe
 			tc = TC_NUMBER;
 			debug_printf_parse("%s: token found:%f TC_NUMBER\n", __func__, t_double);
 		} else {
+			char *end_of_name;
+
+			if (*p == '\n')
+				t_lineno++;
+
 			/* search for something known */
 			tl = tokenlist;
 			tc = 0x00000001;
@@ -1155,9 +1192,9 @@ static uint32_t next_token(uint32_t expe
 				 * token matches,
 				 * and it's not a longer word,
 				 */
-				if ((tc & (expected | TC_WORD | TC_NEWLINE))
+				if ((tc & (expected | TS_WORD | TC_NEWLINE))
 				 && strncmp(p, tl, l) == 0
-				 && !((tc & TC_WORD) && isalnum_(p[l]))
+				 && !((tc & TS_WORD) && isalnum_(p[l]))
 				) {
 					/* then this is what we are looking for */
 					t_info = *ti;
@@ -1174,67 +1211,94 @@ static uint32_t next_token(uint32_t expe
 			if (!isalnum_(*p))
 				syntax_error(EMSG_UNEXP_TOKEN); /* no */
 			/* yes */
-			t_string = --p;
-			while (isalnum_(*++p)) {
-				p[-1] = *p;
-			}
-			p[-1] = '\0';
-			tc = TC_VARIABLE;
-			/* also consume whitespace between functionname and bracket */
-			if (!(expected & TC_VARIABLE) || (expected & TC_ARRAY))
+			t_string = p;
+			while (isalnum_(*p))
+				p++;
+			end_of_name = p;
+
+			if (last_token_class == TC_FUNCDECL)
+				/* eat space in "function FUNC (...) {...}" declaration */
 				p = skip_spaces(p);
+			else if (expected & TC_ARRAY) {
+				/* eat space between array name and [ */
+				char *s = skip_spaces(p);
+				if (*s == '[') /* array ref, not just a name? */
+					p = s;
+			}
+			/* else: do NOT consume whitespace after variable name!
+			 * gawk allows definition "function FUNC (p) {...}" - note space,
+			 * but disallows the call "FUNC (p)" because it isn't one -
+			 * expression "v (a)" should NOT be parsed as TC_FUNCTION:
+			 * it is a valid concatenation if "v" is a variable,
+			 * not a function name (and type of name is not known at parse time).
+			 */
+
 			if (*p == '(') {
+				p++;
 				tc = TC_FUNCTION;
 				debug_printf_parse("%s: token found:'%s' TC_FUNCTION\n", __func__, t_string);
+			} else if (*p == '[') {
+				p++;
+				tc = TC_ARRAY;
+				debug_printf_parse("%s: token found:'%s' TC_ARRAY\n", __func__, t_string);
 			} else {
-				if (*p == '[') {
-					p++;
-					tc = TC_ARRAY;
-					debug_printf_parse("%s: token found:'%s' TC_ARRAY\n", __func__, t_string);
-				} else
-					debug_printf_parse("%s: token found:'%s' TC_VARIABLE\n", __func__, t_string);
+				tc = TC_VARIABLE;
+				debug_printf_parse("%s: token found:'%s' TC_VARIABLE\n", __func__, t_string);
+				if (end_of_name == p) {
+					/* there is no space for trailing NUL in t_string!
+					 * We need to save the char we are going to NUL.
+					 * (we'll use it in future call to next_token())
+					 */
+					g_saved_ch = *end_of_name;
+// especially pathological example is V="abc"; V.2 - it's V concatenated to .2
+// (it evaluates to "abc0.2"). Because of this case, we can't simply cache
+// '.' and analyze it later: we also have to *store it back* in next
+// next_token(), in order to give my_strtod() the undamaged ".2" string.
+				}
 			}
+			*end_of_name = '\0'; /* terminate t_string */
 		}
  token_found:
 		g_pos = p;
 
 		/* skipping newlines in some cases */
-		if ((ltclass & TC_NOTERM) && (tc & TC_NEWLINE))
+		if ((last_token_class & TS_NOTERM) && (tc & TC_NEWLINE))
 			goto readnext;
 
 		/* insert concatenation operator when needed */
-		debug_printf_parse("%s: %x %x %x concat_inserted?\n", __func__,
-			(ltclass & TC_CONCAT1), (tc & TC_CONCAT2), (expected & TC_BINOP));
-		if ((ltclass & TC_CONCAT1) && (tc & TC_CONCAT2) && (expected & TC_BINOP)
-		 && !(ltclass == TC_LENGTH && tc == TC_SEQSTART) /* but not for "length(..." */
+		debug_printf_parse("%s: concat_inserted if all nonzero: %x %x %x %x\n", __func__,
+			(last_token_class & TS_CONCAT_L), (tc & TS_CONCAT_R), (expected & TS_BINOP),
+			!(last_token_class == TC_LENGTH && tc == TC_LPAREN));
+		if ((last_token_class & TS_CONCAT_L) && (tc & TS_CONCAT_R) && (expected & TS_BINOP)
+		 && !(last_token_class == TC_LENGTH && tc == TC_LPAREN) /* but not for "length(..." */
 		) {
 			concat_inserted = TRUE;
 			save_tclass = tc;
 			save_info = t_info;
-			tc = TC_BINOP;
+			tc = TC_BINOPX;
 			t_info = OC_CONCAT | SS | P(35);
 		}
 
-		debug_printf_parse("%s: t_tclass=tc=%x\n", __func__, t_tclass);
 		t_tclass = tc;
+		debug_printf_parse("%s: t_tclass=tc=%x\n", __func__, tc);
 	}
-	ltclass = t_tclass;
-
 	/* Are we ready for this? */
-	if (!(ltclass & expected)) {
-		syntax_error((ltclass & (TC_NEWLINE | TC_EOF)) ?
+	if (!(t_tclass & expected)) {
+		syntax_error((last_token_class & (TC_NEWLINE | TC_EOF)) ?
 				EMSG_UNEXP_EOS : EMSG_UNEXP_TOKEN);
 	}
 
-	debug_printf_parse("%s: returning, ltclass:%x t_double:%f\n", __func__, ltclass, t_double);
-	return ltclass;
+	debug_printf_parse("%s: returning, t_double:%f t_tclass:", __func__, t_double);
+	debug_parse_print_tc(t_tclass);
+	debug_printf_parse("\n");
+
+	return t_tclass;
 #undef concat_inserted
 #undef save_tclass
 #undef save_info
-#undef ltclass
 }
 
-static void rollback_token(void)
+static ALWAYS_INLINE void rollback_token(void)
 {
 	t_rollback = TRUE;
 }
@@ -1251,169 +1315,188 @@ static node *new_node(uint32_t info)
 
 static void mk_re_node(const char *s, node *n, regex_t *re)
 {
-	n->info = OC_REGEXP;
+	n->info = TI_REGEXP;
 	n->l.re = re;
 	n->r.ire = re + 1;
 	xregcomp(re, s, REG_EXTENDED);
 	xregcomp(re + 1, s, REG_EXTENDED | REG_ICASE);
 }
 
-static node *condition(void)
+static node *parse_expr(uint32_t);
+
+static node *parse_lrparen_list(void)
 {
-	next_token(TC_SEQSTART);
-	return parse_expr(TC_SEQTERM);
+	next_token(TC_LPAREN);
+	return parse_expr(TC_RPAREN);
 }
 
 /* parse expression terminated by given argument, return ptr
  * to built subtree. Terminator is eaten by parse_expr */
-static node *parse_expr(uint32_t iexp)
+static node *parse_expr(uint32_t term_tc)
 {
 	node sn;
 	node *cn = &sn;
 	node *vn, *glptr;
-	uint32_t tc, xtc;
+	uint32_t tc, expected_tc;
 	var *v;
 
-	debug_printf_parse("%s(%x)\n", __func__, iexp);
+	debug_printf_parse("%s() term_tc(%x):", __func__, term_tc);
+	debug_parse_print_tc(term_tc);
+	debug_printf_parse("\n");
 
 	sn.info = PRIMASK;
 	sn.r.n = sn.a.n = glptr = NULL;
-	xtc = TC_OPERAND | TC_UOPPRE | TC_REGEXP | iexp;
+	expected_tc = TS_OPERAND | TS_UOPPRE | TC_REGEXP | term_tc;
 
-	while (!((tc = next_token(xtc)) & iexp)) {
+	while (!((tc = next_token(expected_tc)) & term_tc)) {
 
-		if (glptr && (t_info == (OC_COMPARE | VV | P(39) | 2))) {
+		if (glptr && (t_info == TI_LESS)) {
 			/* input redirection (<) attached to glptr node */
 			debug_printf_parse("%s: input redir\n", __func__);
 			cn = glptr->l.n = new_node(OC_CONCAT | SS | P(37));
 			cn->a.n = glptr;
-			xtc = TC_OPERAND | TC_UOPPRE;
+			expected_tc = TS_OPERAND | TS_UOPPRE;
 			glptr = NULL;
-
-		} else if (tc & (TC_BINOP | TC_UOPPOST)) {
-			debug_printf_parse("%s: TC_BINOP | TC_UOPPOST tc:%x\n", __func__, tc);
+			continue;
+		}
+		if (tc & (TS_BINOP | TC_UOPPOST)) {
+			debug_printf_parse("%s: TS_BINOP | TC_UOPPOST tc:%x\n", __func__, tc);
 			/* for binary and postfix-unary operators, jump back over
 			 * previous operators with higher priority */
 			vn = cn;
 			while (((t_info & PRIMASK) > (vn->a.n->info & PRIMASK2))
-			    || ((t_info == vn->info) && ((t_info & OPCLSMASK) == OC_COLON))
+			    || ((t_info == vn->info) && t_info == TI_COLON)
 			) {
 				vn = vn->a.n;
 				if (!vn->a.n) syntax_error(EMSG_UNEXP_TOKEN);
 			}
-			if ((t_info & OPCLSMASK) == OC_TERNARY)
+			if (t_info == TI_TERNARY)
+//TODO: why?
 				t_info += P(6);
 			cn = vn->a.n->r.n = new_node(t_info);
 			cn->a.n = vn->a.n;
-			if (tc & TC_BINOP) {
+			if (tc & TS_BINOP) {
 				cn->l.n = vn;
-				xtc = TC_OPERAND | TC_UOPPRE | TC_REGEXP;
-				if ((t_info & OPCLSMASK) == OC_PGETLINE) {
+//FIXME: this is the place to detect and reject assignments to non-lvalues.
+//Currently we allow "assignments" to consts and temporaries, nonsense like this:
+// awk 'BEGIN { "qwe" = 1 }'
+// awk 'BEGIN { 7 *= 7 }'
+// awk 'BEGIN { length("qwe") = 1 }'
+// awk 'BEGIN { (1+1) += 3 }'
+				expected_tc = TS_OPERAND | TS_UOPPRE | TC_REGEXP;
+				if (t_info == TI_PGETLINE) {
 					/* it's a pipe */
 					next_token(TC_GETLINE);
 					/* give maximum priority to this pipe */
 					cn->info &= ~PRIMASK;
-					xtc = TC_OPERAND | TC_UOPPRE | TC_BINOP | iexp;
+					expected_tc = TS_OPERAND | TS_UOPPRE | TS_BINOP | term_tc;
 				}
 			} else {
 				cn->r.n = vn;
-				xtc = TC_OPERAND | TC_UOPPRE | TC_BINOP | iexp;
+				expected_tc = TS_OPERAND | TS_UOPPRE | TS_BINOP | term_tc;
 			}
 			vn->a.n = cn;
+			continue;
+		}
 
-		} else {
-			debug_printf_parse("%s: other\n", __func__);
-			/* for operands and prefix-unary operators, attach them
-			 * to last node */
-			vn = cn;
-			cn = vn->r.n = new_node(t_info);
-			cn->a.n = vn;
-			xtc = TC_OPERAND | TC_UOPPRE | TC_REGEXP;
-			if (tc & (TC_OPERAND | TC_REGEXP)) {
-				debug_printf_parse("%s: TC_OPERAND | TC_REGEXP\n", __func__);
-				xtc = TC_UOPPRE | TC_UOPPOST | TC_BINOP | TC_OPERAND | iexp;
-				/* one should be very careful with switch on tclass -
-				 * only simple tclasses should be used! */
-				switch (tc) {
-				case TC_VARIABLE:
-				case TC_ARRAY:
-					debug_printf_parse("%s: TC_VARIABLE | TC_ARRAY\n", __func__);
-					cn->info = OC_VAR;
-					v = hash_search(ahash, t_string);
-					if (v != NULL) {
-						cn->info = OC_FNARG;
-						cn->l.aidx = v->x.aidx;
-					} else {
-						cn->l.v = newvar(t_string);
-					}
-					if (tc & TC_ARRAY) {
-						cn->info |= xS;
-						cn->r.n = parse_expr(TC_ARRTERM);
-					}
-					break;
+		debug_printf_parse("%s: other, t_info:%x\n", __func__, t_info);
+		/* for operands and prefix-unary operators, attach them
+		 * to last node */
+		vn = cn;
+		cn = vn->r.n = new_node(t_info);
+		cn->a.n = vn;
+
+		expected_tc = TS_OPERAND | TS_UOPPRE | TC_REGEXP;
+		if (t_info == TI_PREINC || t_info == TI_PREDEC)
+			expected_tc = TS_LVALUE | TC_UOPPRE1;
 
-				case TC_NUMBER:
-				case TC_STRING:
-					debug_printf_parse("%s: TC_NUMBER | TC_STRING\n", __func__);
-					cn->info = OC_VAR;
-					v = cn->l.v = xzalloc(sizeof(var));
-					if (tc & TC_NUMBER)
-						setvar_i(v, t_double);
-					else {
-						setvar_s(v, t_string);
-						xtc &= ~TC_UOPPOST; /* "str"++ is not allowed */
-					}
-					break;
+		if (!(tc & (TS_OPERAND | TC_REGEXP)))
+			continue;
 
-				case TC_REGEXP:
-					debug_printf_parse("%s: TC_REGEXP\n", __func__);
-					mk_re_node(t_string, cn, xzalloc(sizeof(regex_t)*2));
-					break;
+		debug_printf_parse("%s: TS_OPERAND | TC_REGEXP\n", __func__);
+		expected_tc = TS_UOPPRE | TC_UOPPOST | TS_BINOP | TS_OPERAND | term_tc;
+		/* one should be very careful with switch on tclass -
+		 * only simple tclasses should be used (TC_xyz, not TS_xyz) */
+		switch (tc) {
+		case TC_VARIABLE:
+		case TC_ARRAY:
+			debug_printf_parse("%s: TC_VARIABLE | TC_ARRAY\n", __func__);
+			cn->info = OC_VAR;
+			v = hash_search(ahash, t_string);
+			if (v != NULL) {
+				cn->info = OC_FNARG;
+				cn->l.aidx = v->x.aidx;
+			} else {
+				cn->l.v = newvar(t_string);
+			}
+			if (tc & TC_ARRAY) {
+				cn->info |= xS;
+				cn->r.n = parse_expr(TC_ARRTERM);
+			}
+			break;
 
-				case TC_FUNCTION:
-					debug_printf_parse("%s: TC_FUNCTION\n", __func__);
-					cn->info = OC_FUNC;
-					cn->r.f = newfunc(t_string);
-					cn->l.n = condition();
-					break;
+		case TC_NUMBER:
+		case TC_STRING:
+			debug_printf_parse("%s: TC_NUMBER | TC_STRING\n", __func__);
+			cn->info = OC_VAR;
+			v = cn->l.v = xzalloc(sizeof(var));
+			if (tc & TC_NUMBER)
+				setvar_i(v, t_double);
+			else {
+				setvar_s(v, t_string);
+				expected_tc &= ~TC_UOPPOST; /* "str"++ is not allowed */
+			}
+			break;
 
-				case TC_SEQSTART:
-					debug_printf_parse("%s: TC_SEQSTART\n", __func__);
-					cn = vn->r.n = parse_expr(TC_SEQTERM);
-					if (!cn)
-						syntax_error("Empty sequence");
-					cn->a.n = vn;
-					break;
+		case TC_REGEXP:
+			debug_printf_parse("%s: TC_REGEXP\n", __func__);
+			mk_re_node(t_string, cn, xzalloc(sizeof(regex_t)*2));
+			break;
 
-				case TC_GETLINE:
-					debug_printf_parse("%s: TC_GETLINE\n", __func__);
-					glptr = cn;
-					xtc = TC_OPERAND | TC_UOPPRE | TC_BINOP | iexp;
-					break;
+		case TC_FUNCTION:
+			debug_printf_parse("%s: TC_FUNCTION\n", __func__);
+			cn->info = OC_FUNC;
+			cn->r.f = newfunc(t_string);
+			cn->l.n = parse_expr(TC_RPAREN);
+			break;
 
-				case TC_BUILTIN:
-					debug_printf_parse("%s: TC_BUILTIN\n", __func__);
-					cn->l.n = condition();
-					break;
+		case TC_LPAREN:
+			debug_printf_parse("%s: TC_LPAREN\n", __func__);
+			cn = vn->r.n = parse_expr(TC_RPAREN);
+			if (!cn)
+				syntax_error("Empty sequence");
+			cn->a.n = vn;
+			break;
 
-				case TC_LENGTH:
-					debug_printf_parse("%s: TC_LENGTH\n", __func__);
-					next_token(TC_SEQSTART /* length(...) */
-						| TC_OPTERM    /* length; (or newline)*/
-						| TC_GRPTERM   /* length } */
-						| TC_BINOPX    /* length <op> NUM */
-						| TC_COMMA     /* print length, 1 */
-					);
-					rollback_token();
-					if (t_tclass & TC_SEQSTART) {
-						/* It was a "(" token. Handle just like TC_BUILTIN */
-						cn->l.n = condition();
-					}
-					break;
-				}
+		case TC_GETLINE:
+			debug_printf_parse("%s: TC_GETLINE\n", __func__);
+			glptr = cn;
+			expected_tc = TS_OPERAND | TS_UOPPRE | TS_BINOP | term_tc;
+			break;
+
+		case TC_BUILTIN:
+			debug_printf_parse("%s: TC_BUILTIN\n", __func__);
+			cn->l.n = parse_lrparen_list();
+			break;
+
+		case TC_LENGTH:
+			debug_printf_parse("%s: TC_LENGTH\n", __func__);
+			tc = next_token(TC_LPAREN /* length(...) */
+				| TC_SEMICOL   /* length; */
+				| TC_NEWLINE   /* length<newline> */
+				| TC_RBRACE    /* length } */
+				| TC_BINOPX    /* length <op> NUM */
+				| TC_COMMA     /* print length, 1 */
+			);
+			if (tc != TC_LPAREN)
+				rollback_token();
+			else {
+				/* It was a "(" token. Handle just like TC_BUILTIN */
+				cn->l.n = parse_expr(TC_RPAREN);
 			}
+			break;
 		}
-	}
+	} /* while() */
 
 	debug_printf_parse("%s() returns %p\n", __func__, sn.r.n);
 	return sn.r.n;
@@ -1430,7 +1513,7 @@ static node *chain_node(uint32_t info)
 	if (seq->programname != g_progname) {
 		seq->programname = g_progname;
 		n = chain_node(OC_NEWSOURCE);
-		n->l.new_progname = xstrdup(g_progname);
+		n->l.new_progname = g_progname;
 	}
 
 	n = seq->last;
@@ -1446,14 +1529,16 @@ static void chain_expr(uint32_t info)
 
 	n = chain_node(info);
 
-	n->l.n = parse_expr(TC_OPTERM | TC_GRPTERM);
+	n->l.n = parse_expr(TC_SEMICOL | TC_NEWLINE | TC_RBRACE);
 	if ((info & OF_REQUIRED) && !n->l.n)
 		syntax_error(EMSG_TOO_FEW_ARGS);
 
-	if (t_tclass & TC_GRPTERM)
+	if (t_tclass & TC_RBRACE)
 		rollback_token();
 }
 
+static void chain_group(void);
+
 static node *chain_loop(node *nn)
 {
 	node *n, *n2, *save_brk, *save_cont;
@@ -1477,207 +1562,284 @@ static node *chain_loop(node *nn)
 	return n;
 }
 
+static void chain_until_rbrace(void)
+{
+	uint32_t tc;
+	while ((tc = next_token(TS_GRPSEQ | TC_RBRACE)) != TC_RBRACE) {
+		debug_printf_parse("%s: !TC_RBRACE\n", __func__);
+		if (tc == TC_NEWLINE)
+			continue;
+		rollback_token();
+		chain_group();
+	}
+	debug_printf_parse("%s: TC_RBRACE\n", __func__);
+}
+
 /* parse group and attach it to chain */
 static void chain_group(void)
 {
-	uint32_t c;
+	uint32_t tc;
 	node *n, *n2, *n3;
 
 	do {
-		c = next_token(TC_GRPSEQ);
-	} while (c & TC_NEWLINE);
+		tc = next_token(TS_GRPSEQ);
+	} while (tc == TC_NEWLINE);
 
-	if (c & TC_GRPSTART) {
-		debug_printf_parse("%s: TC_GRPSTART\n", __func__);
-		while (next_token(TC_GRPSEQ | TC_GRPTERM) != TC_GRPTERM) {
-			debug_printf_parse("%s: !TC_GRPTERM\n", __func__);
-			if (t_tclass & TC_NEWLINE)
-				continue;
-			rollback_token();
-			chain_group();
-		}
-		debug_printf_parse("%s: TC_GRPTERM\n", __func__);
-	} else if (c & (TC_OPSEQ | TC_OPTERM)) {
-		debug_printf_parse("%s: TC_OPSEQ | TC_OPTERM\n", __func__);
+	if (tc == TC_LBRACE) {
+		debug_printf_parse("%s: TC_LBRACE\n", __func__);
+		chain_until_rbrace();
+		return;
+	}
+	if (tc & (TS_OPSEQ | TC_SEMICOL)) {
+		debug_printf_parse("%s: TS_OPSEQ | TC_SEMICOL\n", __func__);
 		rollback_token();
 		chain_expr(OC_EXEC | Vx);
-	} else {
-		/* TC_STATEMNT */
-		debug_printf_parse("%s: TC_STATEMNT(?)\n", __func__);
-		switch (t_info & OPCLSMASK) {
-		case ST_IF:
-			debug_printf_parse("%s: ST_IF\n", __func__);
-			n = chain_node(OC_BR | Vx);
-			n->l.n = condition();
+		return;
+	}
+
+	/* TS_STATEMNT */
+	debug_printf_parse("%s: TS_STATEMNT(?)\n", __func__);
+	switch (t_info & OPCLSMASK) {
+	case ST_IF:
+		debug_printf_parse("%s: ST_IF\n", __func__);
+		n = chain_node(OC_BR | Vx);
+		n->l.n = parse_lrparen_list();
+		chain_group();
+		n2 = chain_node(OC_EXEC);
+		n->r.n = seq->last;
+		if (next_token(TS_GRPSEQ | TC_RBRACE | TC_ELSE) == TC_ELSE) {
 			chain_group();
-			n2 = chain_node(OC_EXEC);
-			n->r.n = seq->last;
-			if (next_token(TC_GRPSEQ | TC_GRPTERM | TC_ELSE) == TC_ELSE) {
-				chain_group();
-				n2->a.n = seq->last;
-			} else {
-				rollback_token();
-			}
-			break;
+			n2->a.n = seq->last;
+		} else {
+			rollback_token();
+		}
+		break;
 
-		case ST_WHILE:
-			debug_printf_parse("%s: ST_WHILE\n", __func__);
-			n2 = condition();
-			n = chain_loop(NULL);
-			n->l.n = n2;
-			break;
+	case ST_WHILE:
+		debug_printf_parse("%s: ST_WHILE\n", __func__);
+		n2 = parse_lrparen_list();
+		n = chain_loop(NULL);
+		n->l.n = n2;
+		break;
 
-		case ST_DO:
-			debug_printf_parse("%s: ST_DO\n", __func__);
-			n2 = chain_node(OC_EXEC);
-			n = chain_loop(NULL);
-			n2->a.n = n->a.n;
-			next_token(TC_WHILE);
-			n->l.n = condition();
-			break;
+	case ST_DO:
+		debug_printf_parse("%s: ST_DO\n", __func__);
+		n2 = chain_node(OC_EXEC);
+		n = chain_loop(NULL);
+		n2->a.n = n->a.n;
+		next_token(TC_WHILE);
+		n->l.n = parse_lrparen_list();
+		break;
 
-		case ST_FOR:
-			debug_printf_parse("%s: ST_FOR\n", __func__);
-			next_token(TC_SEQSTART);
-			n2 = parse_expr(TC_SEMICOL | TC_SEQTERM);
-			if (t_tclass & TC_SEQTERM) {	/* for-in */
-				if (!n2 || (n2->info & OPCLSMASK) != OC_IN)
-					syntax_error(EMSG_UNEXP_TOKEN);
-				n = chain_node(OC_WALKINIT | VV);
-				n->l.n = n2->l.n;
-				n->r.n = n2->r.n;
-				n = chain_loop(NULL);
-				n->info = OC_WALKNEXT | Vx;
-				n->l.n = n2->l.n;
-			} else {			/* for (;;) */
-				n = chain_node(OC_EXEC | Vx);
-				n->l.n = n2;
-				n2 = parse_expr(TC_SEMICOL);
-				n3 = parse_expr(TC_SEQTERM);
-				n = chain_loop(n3);
-				n->l.n = n2;
-				if (!n2)
-					n->info = OC_EXEC;
-			}
-			break;
+	case ST_FOR:
+		debug_printf_parse("%s: ST_FOR\n", __func__);
+		next_token(TC_LPAREN);
+		n2 = parse_expr(TC_SEMICOL | TC_RPAREN);
+		if (t_tclass & TC_RPAREN) {	/* for (I in ARRAY) */
+			if (!n2 || n2->info != TI_IN)
+				syntax_error(EMSG_UNEXP_TOKEN);
+			n = chain_node(OC_WALKINIT | VV);
+			n->l.n = n2->l.n;
+			n->r.n = n2->r.n;
+			n = chain_loop(NULL);
+			n->info = OC_WALKNEXT | Vx;
+			n->l.n = n2->l.n;
+		} else {			/* for (;;) */
+			n = chain_node(OC_EXEC | Vx);
+			n->l.n = n2;
+			n2 = parse_expr(TC_SEMICOL);
+			n3 = parse_expr(TC_RPAREN);
+			n = chain_loop(n3);
+			n->l.n = n2;
+			if (!n2)
+				n->info = OC_EXEC;
+		}
+		break;
 
-		case OC_PRINT:
-		case OC_PRINTF:
-			debug_printf_parse("%s: OC_PRINT[F]\n", __func__);
-			n = chain_node(t_info);
-			n->l.n = parse_expr(TC_OPTERM | TC_OUTRDR | TC_GRPTERM);
-			if (t_tclass & TC_OUTRDR) {
-				n->info |= t_info;
-				n->r.n = parse_expr(TC_OPTERM | TC_GRPTERM);
-			}
-			if (t_tclass & TC_GRPTERM)
-				rollback_token();
-			break;
+	case OC_PRINT:
+	case OC_PRINTF:
+		debug_printf_parse("%s: OC_PRINT[F]\n", __func__);
+		n = chain_node(t_info);
+		n->l.n = parse_expr(TC_SEMICOL | TC_NEWLINE | TC_OUTRDR | TC_RBRACE);
+		if (t_tclass & TC_OUTRDR) {
+			n->info |= t_info;
+			n->r.n = parse_expr(TC_SEMICOL | TC_NEWLINE | TC_RBRACE);
+		}
+		if (t_tclass & TC_RBRACE)
+			rollback_token();
+		break;
 
-		case OC_BREAK:
-			debug_printf_parse("%s: OC_BREAK\n", __func__);
-			n = chain_node(OC_EXEC);
-			n->a.n = break_ptr;
-			chain_expr(t_info);
-			break;
+	case OC_BREAK:
+		debug_printf_parse("%s: OC_BREAK\n", __func__);
+		n = chain_node(OC_EXEC);
+		if (!break_ptr)
+			syntax_error("'break' not in a loop");
+		n->a.n = break_ptr;
+		chain_expr(t_info);
+		break;
 
-		case OC_CONTINUE:
-			debug_printf_parse("%s: OC_CONTINUE\n", __func__);
-			n = chain_node(OC_EXEC);
-			n->a.n = continue_ptr;
-			chain_expr(t_info);
-			break;
+	case OC_CONTINUE:
+		debug_printf_parse("%s: OC_CONTINUE\n", __func__);
+		n = chain_node(OC_EXEC);
+		if (!continue_ptr)
+			syntax_error("'continue' not in a loop");
+		n->a.n = continue_ptr;
+		chain_expr(t_info);
+		break;
 
-		/* delete, next, nextfile, return, exit */
-		default:
-			debug_printf_parse("%s: default\n", __func__);
-			chain_expr(t_info);
-		}
+	/* delete, next, nextfile, return, exit */
+	default:
+		debug_printf_parse("%s: default\n", __func__);
+		chain_expr(t_info);
 	}
 }
 
 static void parse_program(char *p)
 {
-	uint32_t tclass;
-	node *cn;
-	func *f;
-	var *v;
+	debug_printf_parse("%s()\n", __func__);
 
 	g_pos = p;
 	t_lineno = 1;
-	while ((tclass = next_token(TC_EOF | TC_OPSEQ | TC_GRPSTART |
-			TC_OPTERM | TC_BEGIN | TC_END | TC_FUNCDECL)) != TC_EOF) {
+	for (;;) {
+		uint32_t tclass;
 
-		if (tclass & TC_OPTERM) {
-			debug_printf_parse("%s: TC_OPTERM\n", __func__);
+		tclass = next_token(TS_OPSEQ | TC_LBRACE | TC_BEGIN | TC_END | TC_FUNCDECL
+			| TC_EOF | TC_NEWLINE /* but not TC_SEMICOL */);
+ got_tok:
+		if (tclass == TC_EOF) {
+			debug_printf_parse("%s: TC_EOF\n", __func__);
+			break;
+		}
+		if (tclass == TC_NEWLINE) {
+			debug_printf_parse("%s: TC_NEWLINE\n", __func__);
 			continue;
 		}
-
-		seq = &mainseq;
-		if (tclass & TC_BEGIN) {
+		if (tclass == TC_BEGIN) {
 			debug_printf_parse("%s: TC_BEGIN\n", __func__);
 			seq = &beginseq;
-			chain_group();
-		} else if (tclass & TC_END) {
+			/* ensure there is no newline between BEGIN and { */
+			next_token(TC_LBRACE);
+			chain_until_rbrace();
+			goto next_tok;
+		}
+		if (tclass == TC_END) {
 			debug_printf_parse("%s: TC_END\n", __func__);
 			seq = &endseq;
-			chain_group();
-		} else if (tclass & TC_FUNCDECL) {
+			/* ensure there is no newline between END and { */
+			next_token(TC_LBRACE);
+			chain_until_rbrace();
+			goto next_tok;
+		}
+		if (tclass == TC_FUNCDECL) {
+			func *f;
+
 			debug_printf_parse("%s: TC_FUNCDECL\n", __func__);
 			next_token(TC_FUNCTION);
-			g_pos++;
 			f = newfunc(t_string);
-			f->body.first = NULL;
-			f->nargs = 0;
-			/* Match func arg list: a comma sep list of >= 0 args, and a close paren */
-			while (next_token(TC_VARIABLE | TC_SEQTERM | TC_COMMA)) {
-				/* Either an empty arg list, or trailing comma from prev iter
-				 * must be followed by an arg */
-				if (f->nargs == 0 && t_tclass == TC_SEQTERM)
-					break;
-
-				/* TC_SEQSTART/TC_COMMA must be followed by TC_VARIABLE */
-				if (t_tclass != TC_VARIABLE)
+			if (f->defined)
+				syntax_error("Duplicate function");
+			f->defined = 1;
+			//f->body.first = NULL; - already is
+			//f->nargs = 0; - already is
+			/* func arg list: comma sep list of args, and a close paren */
+			for (;;) {
+				var *v;
+				if (next_token(TC_VARIABLE | TC_RPAREN) == TC_RPAREN) {
+					if (f->nargs == 0)
+						break; /* func() is ok */
+					/* func(a,) is not ok */
 					syntax_error(EMSG_UNEXP_TOKEN);
-
+				}
 				v = findvar(ahash, t_string);
 				v->x.aidx = f->nargs++;
-
 				/* Arg followed either by end of arg list or 1 comma */
-				if (next_token(TC_COMMA | TC_SEQTERM) & TC_SEQTERM)
+				if (next_token(TC_COMMA | TC_RPAREN) == TC_RPAREN)
 					break;
-				if (t_tclass != TC_COMMA)
-					syntax_error(EMSG_UNEXP_TOKEN);
+				/* it was a comma, we ate it */
 			}
 			seq = &f->body;
-			chain_group();
-			clear_array(ahash);
-		} else if (tclass & TC_OPSEQ) {
-			debug_printf_parse("%s: TC_OPSEQ\n", __func__);
+			/* ensure there is { after "func F(...)" - but newlines are allowed */
+			while (next_token(TC_LBRACE | TC_NEWLINE) == TC_NEWLINE)
+				continue;
+			chain_until_rbrace();
+			hash_clear(ahash);
+			goto next_tok;
+		}
+		seq = &mainseq;
+		if (tclass & TS_OPSEQ) {
+			node *cn;
+
+			debug_printf_parse("%s: TS_OPSEQ\n", __func__);
 			rollback_token();
 			cn = chain_node(OC_TEST);
-			cn->l.n = parse_expr(TC_OPTERM | TC_EOF | TC_GRPSTART);
-			if (t_tclass & TC_GRPSTART) {
-				debug_printf_parse("%s: TC_GRPSTART\n", __func__);
-				rollback_token();
-				chain_group();
+			cn->l.n = parse_expr(TC_SEMICOL | TC_NEWLINE | TC_EOF | TC_LBRACE);
+			if (t_tclass == TC_LBRACE) {
+				debug_printf_parse("%s: TC_LBRACE\n", __func__);
+				chain_until_rbrace();
 			} else {
-				debug_printf_parse("%s: !TC_GRPSTART\n", __func__);
+				/* no action, assume default "{ print }" */
+				debug_printf_parse("%s: !TC_LBRACE\n", __func__);
 				chain_node(OC_PRINT);
 			}
 			cn->r.n = mainseq.last;
-		} else /* if (tclass & TC_GRPSTART) */ {
-			debug_printf_parse("%s: TC_GRPSTART(?)\n", __func__);
-			rollback_token();
-			chain_group();
+			goto next_tok;
 		}
-	}
-	debug_printf_parse("%s: TC_EOF\n", __func__);
+		/* tclass == TC_LBRACE */
+		debug_printf_parse("%s: TC_LBRACE(?)\n", __func__);
+		chain_until_rbrace();
+ next_tok:
+		/* Same as next_token() at the top of the loop, + TC_SEMICOL */
+		tclass = next_token(TS_OPSEQ | TC_LBRACE | TC_BEGIN | TC_END | TC_FUNCDECL
+			| TC_EOF | TC_NEWLINE | TC_SEMICOL);
+		/* gawk allows many newlines, but does not allow more than one semicolon:
+		 *  BEGIN {...}<newline>;<newline>;
+		 * would complain "each rule must have a pattern or an action part".
+		 * Same message for
+		 *  ; BEGIN {...}
+		 */
+		if (tclass != TC_SEMICOL)
+			goto got_tok; /* use this token */
+		/* else: loop back - ate the semicolon, get and use _next_ token */
+	} /* for (;;) */
 }
 
-
 /* -------- program execution part -------- */
 
+/* temporary variables allocator */
+static var *nvalloc(int sz)
+{
+	return xzalloc(sz * sizeof(var));
+}
+
+static void nvfree(var *v, int sz)
+{
+	var *p = v;
+
+	while (--sz >= 0) {
+		if ((p->type & (VF_ARRAY | VF_CHILD)) == VF_ARRAY) {
+			clear_array(iamarray(p));
+			free(p->x.array->items);
+			free(p->x.array);
+		}
+		if (p->type & VF_WALK) {
+			walker_list *n;
+			walker_list *w = p->x.walker;
+			debug_printf_walker("nvfree: freeing walker @%p\n", &p->x.walker);
+			p->x.walker = NULL;
+			while (w) {
+				n = w->prev;
+				debug_printf_walker(" free(%p)\n", w);
+				free(w);
+				w = n;
+			}
+		}
+		clrvar(p);
+		p++;
+	}
+
+	free(v);
+}
+
 static node *mk_splitter(const char *s, tsplitter *spl)
 {
 	regex_t *re, *ire;
@@ -1686,7 +1848,7 @@ static node *mk_splitter(const char *s,
 	re = &spl->re[0];
 	ire = &spl->re[1];
 	n = &spl->n;
-	if ((n->info & OPCLSMASK) == OC_REGEXP) {
+	if (n->info == TI_REGEXP) {
 		regfree(re);
 		regfree(ire); // TODO: nuke ire, use re+1?
 	}
@@ -1699,21 +1861,28 @@ static node *mk_splitter(const char *s,
 	return n;
 }
 
-/* use node as a regular expression. Supplied with node ptr and regex_t
+static var *evaluate(node *, var *);
+
+/* Use node as a regular expression. Supplied with node ptr and regex_t
  * storage space. Return ptr to regex (if result points to preg, it should
- * be later regfree'd manually
+ * be later regfree'd manually).
  */
 static regex_t *as_regex(node *op, regex_t *preg)
 {
 	int cflags;
-	var *v;
 	const char *s;
 
-	if ((op->info & OPCLSMASK) == OC_REGEXP) {
+	if (op->info == TI_REGEXP) {
 		return icase ? op->r.ire : op->l.re;
 	}
-	v = nvalloc(1);
-	s = getvar_s(evaluate(op, v));
+
+	//tmpvar = nvalloc(1);
+#define TMPVAR (&G.as_regex__tmpvar)
+	// We use a single "static" tmpvar (instead of on-stack or malloced one)
+	// to decrease memory consumption in deeply-recursive awk programs.
+	// The rule to work safely is to never call evaluate() while our static
+	// TMPVAR's value is still needed.
+	s = getvar_s(evaluate(op, TMPVAR));
 
 	cflags = icase ? REG_EXTENDED | REG_ICASE : REG_EXTENDED;
 	/* Testcase where REG_EXTENDED fails (unpaired '{'):
@@ -1725,7 +1894,8 @@ static regex_t *as_regex(node *op, regex
 		cflags &= ~REG_EXTENDED;
 		xregcomp(preg, s, cflags);
 	}
-	nvfree(v);
+	//nvfree(tmpvar, 1);
+#undef TMPVAR
 	return preg;
 }
 
@@ -1745,12 +1915,22 @@ static char* qrealloc(char *b, int n, in
 /* resize field storage space */
 static void fsrealloc(int size)
 {
-	int i;
+	int i, newsize;
 
 	if (size >= maxfields) {
+		/* Sanity cap, easier than catering for overflows */
+		if (size > 0xffffff)
+			bb_die_memory_exhausted();
+
 		i = maxfields;
 		maxfields = size + 16;
-		Fields = xrealloc(Fields, maxfields * sizeof(Fields[0]));
+
+		newsize = maxfields * sizeof(Fields[0]);
+		debug_printf_eval("fsrealloc: xrealloc(%p, %u)\n", Fields, newsize);
+		Fields = xrealloc(Fields, newsize);
+		debug_printf_eval("fsrealloc: Fields=%p..%p\n", Fields, (char*)Fields + newsize - 1);
+		/* ^^^ did Fields[] move? debug aid for L.v getting "upstaged" by R.v in evaluate() */
+
 		for (; i < maxfields; i++) {
 			Fields[i].type = VF_SPECIAL;
 			Fields[i].string = NULL;
@@ -1802,13 +1982,13 @@ static int awk_split(const char *s, node
 		c[2] = '\n';
 
 	n = 0;
-	if ((spl->info & OPCLSMASK) == OC_REGEXP) {  /* regex split */
+	if (spl->info == TI_REGEXP) {  /* regex split */
 		if (!*s)
 			return n; /* "": zero fields */
 		n++; /* at least one field will be there */
 		do {
 			int l;
-			regmatch_t pmatch[2]; // TODO: why [2]? [1] is enough...
+			regmatch_t pmatch[1];
 
 			l = strcspn(s, c+2); /* len till next NUL or \n */
 			if (regexec1_nonempty(icase ? spl->r.ire : spl->l.re, s, pmatch) == 0
@@ -1969,7 +2149,7 @@ static node *nextarg(node **pn)
 	node *n;
 
 	n = *pn;
-	if (n && (n->info & OPCLSMASK) == OC_COMMA) {
+	if (n && n->info == TI_COMMA) {
 		*pn = n->r.n;
 		n = n->l.n;
 	} else {
@@ -2000,8 +2180,7 @@ static void hashwalk_init(var *v, xhash
 	for (i = 0; i < array->csize; i++) {
 		hi = array->items[i];
 		while (hi) {
-			strcpy(w->end, hi->name);
-			nextword(&w->end);
+			w->end = stpcpy(w->end, hi->name) + 1;
 			hi = hi->next;
 		}
 	}
@@ -2027,15 +2206,18 @@ static int hashwalk_next(var *v)
 /* evaluate node, return 1 when result is true, 0 otherwise */
 static int ptest(node *pattern)
 {
-	/* ptest__v is "static": to save stack space? */
-	return istrue(evaluate(pattern, &G.ptest__v));
+	// We use a single "static" tmpvar (instead of on-stack or malloced one)
+	// to decrease memory consumption in deeply-recursive awk programs.
+	// The rule to work safely is to never call evaluate() while our static
+	// TMPVAR's value is still needed.
+	return istrue(evaluate(pattern, &G.ptest__tmpvar));
 }
 
 /* read next record from stream rsm into a variable v */
 static int awk_getline(rstream *rsm, var *v)
 {
 	char *b;
-	regmatch_t pmatch[2]; // TODO: why [2]? [1] is enough...
+	regmatch_t pmatch[1];
 	int size, a, p, pp = 0;
 	int fd, so, eo, r, rp;
 	char c, *m, *s;
@@ -2061,7 +2243,7 @@ static int awk_getline(rstream *rsm, var
 		so = eo = p;
 		r = 1;
 		if (p > 0) {
-			if ((rsplitter.n.info & OPCLSMASK) == OC_REGEXP) {
+			if (rsplitter.n.info == TI_REGEXP) {
 				if (regexec(icase ? rsplitter.n.r.ire : rsplitter.n.l.re,
 							b, 1, pmatch, 0) == 0) {
 					so = pmatch[0].rm_so;
@@ -2133,42 +2315,36 @@ static int awk_getline(rstream *rsm, var
 	return r;
 }
 
-static int fmt_num(char *b, int size, const char *format, double n, int int_as_int)
-{
-	int r = 0;
-	char c;
-	const char *s = format;
-
-	if (int_as_int && n == (long long)n) {
-		r = snprintf(b, size, "%lld", (long long)n);
-	} else {
-		do { c = *s; } while (c && *++s);
-		if (strchr("diouxX", c)) {
-			r = snprintf(b, size, format, (int)n);
-		} else if (strchr("eEfgG", c)) {
-			r = snprintf(b, size, format, n);
-		} else {
-			syntax_error(EMSG_INV_FMT);
-		}
-	}
-	return r;
-}
-
 /* formatted output into an allocated buffer, return ptr to buffer */
-static char *awk_printf(node *n)
+#if !ENABLE_FEATURE_AWK_GNU_EXTENSIONS
+# define awk_printf(a, b) awk_printf(a)
+#endif
+static char *awk_printf(node *n, size_t *len)
 {
-	char *b = NULL;
-	char *fmt, *s, *f;
-	const char *s1;
-	int i, j, incr, bsize;
-	char c, c1;
-	var *v, *arg;
+	char *b;
+	char *fmt, *f;
+	size_t i;
 
-	v = nvalloc(1);
-	fmt = f = xstrdup(getvar_s(evaluate(nextarg(&n), v)));
+	//tmpvar = nvalloc(1);
+#define TMPVAR (&G.awk_printf__tmpvar)
+	// We use a single "static" tmpvar (instead of on-stack or malloced one)
+	// to decrease memory consumption in deeply-recursive awk programs.
+	// The rule to work safely is to never call evaluate() while our static
+	// TMPVAR's value is still needed.
+	fmt = f = xstrdup(getvar_s(evaluate(nextarg(&n), TMPVAR)));
+	// ^^^^^^^^^ here we immediately strdup() the value, so the later call
+	// to evaluate() potentially recursing into another awk_printf() can't
+	// mangle the value.
 
+	b = NULL;
 	i = 0;
-	while (*f) {
+	while (*f) { /* "print one format spec" loop */
+		char *s;
+		char c;
+		char sv;
+		var *arg;
+		size_t slen;
+
 		s = f;
 		while (*f && (*f != '%' || *++f == '%'))
 			f++;
@@ -2177,38 +2353,68 @@ static char *awk_printf(node *n)
 				syntax_error("%*x formats are not supported");
 			f++;
 		}
-
-		incr = (f - s) + MAXVARFMT;
-		b = qrealloc(b, incr + i, &bsize);
 		c = *f;
-		if (c != '\0')
-			f++;
-		c1 = *f;
+		if (!c) {
+			/* Tail of fmt with no percent chars,
+			 * or "....%" (percent seen, but no format specifier char found)
+			 */
+			slen = strlen(s);
+			goto tail;
+		}
+		sv = *++f;
 		*f = '\0';
-		arg = evaluate(nextarg(&n), v);
+		arg = evaluate(nextarg(&n), TMPVAR);
 
-		j = i;
-		if (c == 'c' || !c) {
-			i += sprintf(b+i, s, is_numeric(arg) ?
-					(char)getvar_i(arg) : *getvar_s(arg));
-		} else if (c == 's') {
-			s1 = getvar_s(arg);
-			b = qrealloc(b, incr+i+strlen(s1), &bsize);
-			i += sprintf(b+i, s, s1);
+		/* Result can be arbitrarily long. Example:
+		 *  printf "%99999s", "BOOM"
+		 */
+		if (c == 'c') {
+			char cc = is_numeric(arg) ? getvar_i(arg) : *getvar_s(arg);
+			char *r = xasprintf(s, cc ? cc : '^' /* else strlen will be wrong */);
+			slen = strlen(r);
+			if (cc == '\0') /* if cc is NUL, re-format the string with it */
+				sprintf(r, s, cc);
+			s = r;
 		} else {
-			i += fmt_num(b+i, incr, s, getvar_i(arg), FALSE);
+			if (c == 's') {
+				s = xasprintf(s, getvar_s(arg));
+			} else {
+				double d = getvar_i(arg);
+				if (strchr("diouxX", c)) {
+//TODO: make it wider here (%x -> %llx etc)?
+					s = xasprintf(s, (int)d);
+				} else if (strchr("eEfFgGaA", c)) {
+					s = xasprintf(s, d);
+				} else {
+					syntax_error(EMSG_INV_FMT);
+				}
+			}
+			slen = strlen(s);
 		}
-		*f = c1;
+		*f = sv;
 
-		/* if there was an error while sprintf, return value is negative */
-		if (i < j)
-			i = j;
+		if (i == 0) {
+			b = s;
+			i = slen;
+			continue;
+		}
+ tail:
+		b = xrealloc(b, i + slen + 1);
+		strcpy(b + i, s);
+		i += slen;
+		if (!c) /* tail? */
+			break;
+		free(s);
 	}
 
 	free(fmt);
-	nvfree(v);
-	b = xrealloc(b, i + 1);
-	b[i] = '\0';
+	//nvfree(tmpvar, 1);
+#undef TMPVAR
+
+#if ENABLE_FEATURE_AWK_GNU_EXTENSIONS
+	if (len)
+		*len = i;
+#endif
 	return b;
 }
 
@@ -2338,33 +2544,59 @@ static NOINLINE int do_mktime(const char
 	return mktime(&then);
 }
 
+/* Reduce stack usage in exec_builtin() by keeping match() code separate */
+static NOINLINE var *do_match(node *an1, const char *as0)
+{
+	regmatch_t pmatch[1];
+	regex_t sreg, *re;
+	int n, start, len;
+
+	re = as_regex(an1, &sreg);
+	n = regexec(re, as0, 1, pmatch, 0);
+	if (re == &sreg)
+		regfree(re);
+	start = 0;
+	len = -1;
+	if (n == 0) {
+		start = pmatch[0].rm_so + 1;
+		len = pmatch[0].rm_eo - pmatch[0].rm_so;
+	}
+	setvar_i(newvar("RLENGTH"), len);
+	return setvar_i(newvar("RSTART"), start);
+}
+
+/* Reduce stack usage in evaluate() by keeping builtins' code separate */
 static NOINLINE var *exec_builtin(node *op, var *res)
 {
 #define tspl (G.exec_builtin__tspl)
 
-	var *tv;
+	var *tmpvars;
 	node *an[4];
 	var *av[4];
 	const char *as[4];
-	regmatch_t pmatch[2];
-	regex_t sreg, *re;
 	node *spl;
 	uint32_t isr, info;
 	int nargs;
 	time_t tt;
 	int i, l, ll, n;
 
-	tv = nvalloc(4);
+	tmpvars = nvalloc(4);
+#define TMPVAR0 (tmpvars)
+#define TMPVAR1 (tmpvars + 1)
+#define TMPVAR2 (tmpvars + 2)
+#define TMPVAR3 (tmpvars + 3)
+#define TMPVAR(i) (tmpvars + (i))
 	isr = info = op->info;
 	op = op->l.n;
 
 	av[2] = av[3] = NULL;
 	for (i = 0; i < 4 && op; i++) {
 		an[i] = nextarg(&op);
-		if (isr & 0x09000000)
-			av[i] = evaluate(an[i], &tv[i]);
-		if (isr & 0x08000000)
-			as[i] = getvar_s(av[i]);
+		if (isr & 0x09000000) {
+			av[i] = evaluate(an[i], TMPVAR(i));
+			if (isr & 0x08000000)
+				as[i] = getvar_s(av[i]);
+		}
 		isr >>= 1;
 	}
 
@@ -2386,8 +2618,8 @@ static NOINLINE var *exec_builtin(node *
 		char *s, *s1;
 
 		if (nargs > 2) {
-			spl = (an[2]->info & OPCLSMASK) == OC_REGEXP ?
-				an[2] : mk_splitter(getvar_s(evaluate(an[2], &tv[2])), &tspl);
+			spl = (an[2]->info == TI_REGEXP) ? an[2]
+				: mk_splitter(getvar_s(evaluate(an[2], TMPVAR2)), &tspl);
 		} else {
 			spl = &fsplitter.n;
 		}
@@ -2501,20 +2733,7 @@ static NOINLINE var *exec_builtin(node *
 		break;
 
 	case B_ma:
-		re = as_regex(an[1], &sreg);
-		n = regexec(re, as[0], 1, pmatch, 0);
-		if (n == 0) {
-			pmatch[0].rm_so++;
-			pmatch[0].rm_eo++;
-		} else {
-			pmatch[0].rm_so = 0;
-			pmatch[0].rm_eo = -1;
-		}
-		setvar_i(newvar("RSTART"), pmatch[0].rm_so);
-		setvar_i(newvar("RLENGTH"), pmatch[0].rm_eo - pmatch[0].rm_so);
-		setvar_i(res, pmatch[0].rm_so);
-		if (re == &sreg)
-			regfree(re);
+		res = do_match(an[1], as[0]);
 		break;
 
 	case B_ge:
@@ -2530,14 +2749,79 @@ static NOINLINE var *exec_builtin(node *
 		break;
 	}
 
-	nvfree(tv);
+	nvfree(tmpvars, 4);
+#undef TMPVAR0
+#undef TMPVAR1
+#undef TMPVAR2
+#undef TMPVAR3
+#undef TMPVAR
+
 	return res;
 #undef tspl
 }
 
+/* if expr looks like "var=value", perform assignment and return 1,
+ * otherwise return 0 */
+static int is_assignment(const char *expr)
+{
+	char *exprc, *val;
+
+	val = (char*)endofname(expr);
+	if (val == (char*)expr || *val != '=') {
+		return FALSE;
+	}
+
+	exprc = xstrdup(expr);
+	val = exprc + (val - expr);
+	*val++ = '\0';
+
+	unescape_string_in_place(val);
+	setvar_u(newvar(exprc), val);
+	free(exprc);
+	return TRUE;
+}
+
+/* switch to next input file */
+static rstream *next_input_file(void)
+{
+#define rsm          (G.next_input_file__rsm)
+#define files_happen (G.next_input_file__files_happen)
+
+	const char *fname, *ind;
+
+	if (rsm.F)
+		fclose(rsm.F);
+	rsm.F = NULL;
+	rsm.pos = rsm.adv = 0;
+
+	for (;;) {
+		if (getvar_i(intvar[ARGIND])+1 >= getvar_i(intvar[ARGC])) {
+			if (files_happen)
+				return NULL;
+			fname = "-";
+			rsm.F = stdin;
+			break;
+		}
+		ind = getvar_s(incvar(intvar[ARGIND]));
+		fname = getvar_s(findvar(iamarray(intvar[ARGV]), ind));
+		if (fname && *fname && !is_assignment(fname)) {
+			rsm.F = xfopen_stdin(fname);
+			break;
+		}
+	}
+
+	files_happen = TRUE;
+	setvar_s(intvar[FILENAME], fname);
+	return &rsm;
+#undef rsm
+#undef files_happen
+}
+
 /*
  * Evaluate node - the heart of the program. Supplied with subtree
- * and place where to store result. returns ptr to result.
+ * and "res" variable to assign the result to if we evaluate an expression.
+ * If node refers to e.g. a variable or a field, no assignment happens.
+ * Return ptr to the result (which may or may not be the "res" variable!)
  */
 #define XC(n) ((n) >> 8)
 
@@ -2549,14 +2833,16 @@ static var *evaluate(node *op, var *res)
 #define seed   (G.evaluate__seed)
 #define sreg   (G.evaluate__sreg)
 
-	var *v1;
+	var *tmpvars;
 
 	if (!op)
 		return setvar_s(res, NULL);
 
 	debug_printf_eval("entered %s()\n", __func__);
 
-	v1 = nvalloc(2);
+	tmpvars = nvalloc(2);
+#define TMPVAR0 (tmpvars)
+#define TMPVAR1 (tmpvars + 1)
 
 	while (op) {
 		struct {
@@ -2578,48 +2864,35 @@ static var *evaluate(node *op, var *res)
 		op1 = op->l.n;
 		debug_printf_eval("opinfo:%08x opn:%08x\n", opinfo, opn);
 
-		/* "delete" is special:
-		 * "delete array[var--]" must evaluate index expr only once,
-		 * must not evaluate it in "execute inevitable things" part.
+		/* execute inevitable things */
+		if (opinfo & OF_RES1) {
+			if ((opinfo & OF_REQUIRED) && !op1)
+				syntax_error(EMSG_TOO_FEW_ARGS);
+			L.v = evaluate(op1, TMPVAR0);
+			if (opinfo & OF_STR1) {
+				L.s = getvar_s(L.v);
+				debug_printf_eval("L.s:'%s'\n", L.s);
+			}
+			if (opinfo & OF_NUM1) {
+				L_d = getvar_i(L.v);
+				debug_printf_eval("L_d:%f\n", L_d);
+			}
+		}
+		/* NB: Must get string/numeric values of L (done above)
+		 * _before_ evaluate()'ing R.v: if both L and R are $NNNs,
+		 * and right one is large, then L.v points to Fields[NNN1],
+		 * second evaluate() reallocates and moves (!) Fields[],
+		 * R.v points to Fields[NNN2] but L.v now points to freed mem!
+		 * (Seen trying to evaluate "$444 $44444")
 		 */
-		if (XC(opinfo & OPCLSMASK) == XC(OC_DELETE)) {
-			uint32_t info = op1->info & OPCLSMASK;
-			var *v;
-
-			debug_printf_eval("DELETE\n");
-			if (info == OC_VAR) {
-				v = op1->l.v;
-			} else if (info == OC_FNARG) {
-				v = &fnargs[op1->l.aidx];
-			} else {
-				syntax_error(EMSG_NOT_ARRAY);
+		if (opinfo & OF_RES2) {
+			R.v = evaluate(op->r.n, TMPVAR1);
+			//TODO: L.v may be invalid now, set L.v to NULL to catch bugs?
+			//L.v = NULL;
+			if (opinfo & OF_STR2) {
+				R.s = getvar_s(R.v);
+				debug_printf_eval("R.s:'%s'\n", R.s);
 			}
-			if (op1->r.n) { /* array ref? */
-				const char *s;
-				s = getvar_s(evaluate(op1->r.n, v1));
-				hash_remove(iamarray(v), s);
-			} else {
-				clear_array(iamarray(v));
-			}
-			goto next;
-		}
-
-		/* execute inevitable things */
-		if (opinfo & OF_RES1)
-			L.v = evaluate(op1, v1);
-		if (opinfo & OF_RES2)
-			R.v = evaluate(op->r.n, v1+1);
-		if (opinfo & OF_STR1) {
-			L.s = getvar_s(L.v);
-			debug_printf_eval("L.s:'%s'\n", L.s);
-		}
-		if (opinfo & OF_STR2) {
-			R.s = getvar_s(R.v);
-			debug_printf_eval("R.s:'%s'\n", R.s);
-		}
-		if (opinfo & OF_NUM1) {
-			L_d = getvar_i(L.v);
-			debug_printf_eval("L_d:%f\n", L_d);
 		}
 
 		debug_printf_eval("switch(0x%x)\n", XC(opinfo & OPCLSMASK));
@@ -2629,7 +2902,8 @@ static var *evaluate(node *op, var *res)
 
 		/* test pattern */
 		case XC( OC_TEST ):
-			if ((op1->info & OPCLSMASK) == OC_COMMA) {
+			debug_printf_eval("TEST\n");
+			if (op1->info == TI_COMMA) {
 				/* it's range pattern */
 				if ((opinfo & OF_CHECKED) || ptest(op1->l.n)) {
 					op->info |= OF_CHECKED;
@@ -2646,25 +2920,32 @@ static var *evaluate(node *op, var *res)
 
 		/* just evaluate an expression, also used as unconditional jump */
 		case XC( OC_EXEC ):
+			debug_printf_eval("EXEC\n");
 			break;
 
 		/* branch, used in if-else and various loops */
 		case XC( OC_BR ):
+			debug_printf_eval("BR\n");
 			op = istrue(L.v) ? op->a.n : op->r.n;
 			break;
 
 		/* initialize for-in loop */
 		case XC( OC_WALKINIT ):
+			debug_printf_eval("WALKINIT\n");
 			hashwalk_init(L.v, iamarray(R.v));
 			break;
 
 		/* get next array item */
 		case XC( OC_WALKNEXT ):
+			debug_printf_eval("WALKNEXT\n");
 			op = hashwalk_next(L.v) ? op->a.n : op->r.n;
 			break;
 
 		case XC( OC_PRINT ):
-		case XC( OC_PRINTF ): {
+			debug_printf_eval("PRINT /\n");
+		case XC( OC_PRINTF ):
+			debug_printf_eval("PRINTF\n");
+		{
 			FILE *F = stdout;
 
 			if (op->r.n) {
@@ -2682,55 +2963,94 @@ static var *evaluate(node *op, var *res)
 				F = rsm->F;
 			}
 
+			/* Can't just check 'opinfo == OC_PRINT' here, parser ORs
+			 * additional bits to opinfos of print/printf with redirects
+			 */
 			if ((opinfo & OPCLSMASK) == OC_PRINT) {
 				if (!op1) {
 					fputs(getvar_s(intvar[F0]), F);
 				} else {
-					while (op1) {
-						var *v = evaluate(nextarg(&op1), v1);
+					for (;;) {
+						var *v = evaluate(nextarg(&op1), TMPVAR0);
 						if (v->type & VF_NUMBER) {
-							fmt_num(g_buf, MAXVARFMT, getvar_s(intvar[OFMT]),
-									getvar_i(v), TRUE);
+							fmt_num(getvar_s(intvar[OFMT]),
+									getvar_i(v));
 							fputs(g_buf, F);
 						} else {
 							fputs(getvar_s(v), F);
 						}
-
-						if (op1)
-							fputs(getvar_s(intvar[OFS]), F);
+						if (!op1)
+							break;
+						fputs(getvar_s(intvar[OFS]), F);
 					}
 				}
 				fputs(getvar_s(intvar[ORS]), F);
-
-			} else {	/* OC_PRINTF */
-				char *s = awk_printf(op1);
+			} else {	/* PRINTF */
+				IF_FEATURE_AWK_GNU_EXTENSIONS(size_t len;)
+				char *s = awk_printf(op1, &len);
+#if ENABLE_FEATURE_AWK_GNU_EXTENSIONS
+				fwrite(s, len, 1, F);
+#else
 				fputs(s, F);
+#endif
 				free(s);
 			}
 			fflush(F);
 			break;
 		}
 
-		/* case XC( OC_DELETE ): - moved to happen before arg evaluation */
+		case XC( OC_DELETE ):
+			debug_printf_eval("DELETE\n");
+		{
+			/* "delete" is special:
+			 * "delete array[var--]" must evaluate index expr only once.
+			 */
+			uint32_t info = op1->info & OPCLSMASK;
+			var *v;
+
+			if (info == OC_VAR) {
+				v = op1->l.v;
+			} else if (info == OC_FNARG) {
+				v = &fnargs[op1->l.aidx];
+			} else {
+				syntax_error(EMSG_NOT_ARRAY);
+			}
+			if (op1->r.n) { /* array ref? */
+				const char *s;
+				s = getvar_s(evaluate(op1->r.n, TMPVAR0));
+				hash_remove(iamarray(v), s);
+			} else {
+				clear_array(iamarray(v));
+			}
+			break;
+		}
 
 		case XC( OC_NEWSOURCE ):
+			debug_printf_eval("NEWSOURCE\n");
 			g_progname = op->l.new_progname;
 			break;
 
 		case XC( OC_RETURN ):
+			debug_printf_eval("RETURN\n");
 			copyvar(res, L.v);
 			break;
 
 		case XC( OC_NEXTFILE ):
+			debug_printf_eval("NEXTFILE\n");
 			nextfile = TRUE;
 		case XC( OC_NEXT ):
+			debug_printf_eval("NEXT\n");
 			nextrec = TRUE;
 		case XC( OC_DONE ):
+			debug_printf_eval("DONE\n");
 			clrvar(res);
 			break;
 
 		case XC( OC_EXIT ):
-			awk_exit(L_d);
+			debug_printf_eval("EXIT\n");
+			if (op1)
+				G.exitcode = (int)L_d;
+			awk_exit();
 
 		/* -- recursive node type -- */
 
@@ -2749,15 +3069,18 @@ static var *evaluate(node *op, var *res)
 			break;
 
 		case XC( OC_IN ):
+			debug_printf_eval("IN\n");
 			setvar_i(res, hash_search(iamarray(R.v), L.s) ? 1 : 0);
 			break;
 
 		case XC( OC_REGEXP ):
+			debug_printf_eval("REGEXP\n");
 			op1 = op;
 			L.s = getvar_s(intvar[F0]);
 			goto re_cont;
 
 		case XC( OC_MATCH ):
+			debug_printf_eval("MATCH\n");
 			op1 = op->r.n;
  re_cont:
 			{
@@ -2772,61 +3095,80 @@ static var *evaluate(node *op, var *res)
 		case XC( OC_MOVE ):
 			debug_printf_eval("MOVE\n");
 			/* if source is a temporary string, jusk relink it to dest */
-//Disabled: if R.v is numeric but happens to have cached R.v->string,
-//then L.v ends up being a string, which is wrong
-//			if (R.v == v1+1 && R.v->string) {
-//				res = setvar_p(L.v, R.v->string);
-//				R.v->string = NULL;
-//			} else {
+			if (R.v == TMPVAR1
+			 && !(R.v->type & VF_NUMBER)
+				/* Why check !NUMBER? if R.v is a number but has cached R.v->string,
+				 * L.v ends up a string, which is wrong */
+			 /*&& R.v->string - always not NULL (right?) */
+			) {
+				res = setvar_p(L.v, R.v->string); /* avoids strdup */
+				R.v->string = NULL;
+			} else {
 				res = copyvar(L.v, R.v);
-//			}
+			}
 			break;
 
 		case XC( OC_TERNARY ):
-			if ((op->r.n->info & OPCLSMASK) != OC_COLON)
+			debug_printf_eval("TERNARY\n");
+			if (op->r.n->info != TI_COLON)
 				syntax_error(EMSG_POSSIBLE_ERROR);
 			res = evaluate(istrue(L.v) ? op->r.n->l.n : op->r.n->r.n, res);
 			break;
 
 		case XC( OC_FUNC ): {
-			var *vbeg, *v;
+			var *argvars, *sv_fnargs;
 			const char *sv_progname;
+			int nargs, i;
 
-			/* The body might be empty, still has to eval the args */
-			if (!op->r.n->info && !op->r.f->body.first)
+			debug_printf_eval("FUNC\n");
+
+			if (!op->r.f->defined)
 				syntax_error(EMSG_UNDEF_FUNC);
 
-			vbeg = v = nvalloc(op->r.f->nargs + 1);
+			/* The body might be empty, still has to eval the args */
+			nargs = op->r.f->nargs;
+			argvars = nvalloc(nargs);
+			i = 0;
 			while (op1) {
-				var *arg = evaluate(nextarg(&op1), v1);
-				copyvar(v, arg);
-				v->type |= VF_CHILD;
-				v->x.parent = arg;
-				if (++v - vbeg >= op->r.f->nargs)
-					break;
+				var *arg = evaluate(nextarg(&op1), TMPVAR0);
+				if (i == nargs) {
+					/* call with more arguments than function takes.
+					 * (gawk warns: "warning: function 'f' called with more arguments than declared").
+					 * They are still evaluated, but discarded: */
+					clrvar(arg);
+					continue;
+				}
+				copyvar(&argvars[i], arg);
+				argvars[i].type |= VF_CHILD;
+				argvars[i].x.parent = arg;
+				i++;
 			}
 
-			v = fnargs;
-			fnargs = vbeg;
+			sv_fnargs = fnargs;
 			sv_progname = g_progname;
 
+			fnargs = argvars;
 			res = evaluate(op->r.f->body.first, res);
+			nvfree(argvars, nargs);
 
 			g_progname = sv_progname;
-			nvfree(fnargs);
-			fnargs = v;
+			fnargs = sv_fnargs;
 
 			break;
 		}
 
 		case XC( OC_GETLINE ):
-		case XC( OC_PGETLINE ): {
+			debug_printf_eval("GETLINE /\n");
+		case XC( OC_PGETLINE ):
+			debug_printf_eval("PGETLINE\n");
+		{
 			rstream *rsm;
 			int i;
 
 			if (op1) {
 				rsm = newfile(L.s);
 				if (!rsm->F) {
+					/* NB: can't use "opinfo == TI_PGETLINE", would break "cmd" | getline */
 					if ((opinfo & OPCLSMASK) == OC_PGETLINE) {
 						rsm->F = popen(L.s, "r");
 						rsm->is_pipe = TRUE;
@@ -2861,16 +3203,34 @@ static var *evaluate(node *op, var *res)
 		/* simple builtins */
 		case XC( OC_FBLTIN ): {
 			double R_d = R_d; /* for compiler */
+			debug_printf_eval("FBLTIN\n");
+
+			if (op1 && op1->info == TI_COMMA)
+				/* Simple builtins take one arg maximum */
+				syntax_error("Too many arguments");
 
 			switch (opn) {
 			case F_in:
 				R_d = (long long)L_d;
 				break;
 
-			case F_rn:
-				R_d = (double)rand() / (double)RAND_MAX;
+			case F_rn: /*rand*/
+				if (op1)
+					syntax_error("Too many arguments");
+			{
+#if RAND_MAX >= 0x7fffffff
+				uint32_t u = ((uint32_t)rand() << 16) ^ rand();
+				uint64_t v = ((uint64_t)rand() << 32) | u;
+				/* the above shift+or is optimized out on 32-bit arches */
+# if RAND_MAX > 0x7fffffff
+				v &= 0x7fffffffffffffffULL;
+# endif
+				R_d = (double)v / 0x8000000000000000ULL;
+#else
+# error Not implemented for this value of RAND_MAX
+#endif
 				break;
-
+			}
 			case F_co:
 				if (ENABLE_FEATURE_AWK_LIBM) {
 					R_d = cos(L_d);
@@ -2910,7 +3270,9 @@ static var *evaluate(node *op, var *res)
 				srand(seed);
 				break;
 
-			case F_ti:
+			case F_ti: /*systime*/
+				if (op1)
+					syntax_error("Too many arguments");
 				R_d = time(NULL);
 				break;
 
@@ -2949,7 +3311,7 @@ static var *evaluate(node *op, var *res)
 				rstream *rsm;
 				int err = 0;
 				rsm = (rstream *)hash_search(fdhash, L.s);
-				debug_printf_eval("OC_FBLTIN F_cl rsm:%p\n", rsm);
+				debug_printf_eval("OC_FBLTIN close: op1:%p s:'%s' rsm:%p\n", op1, L.s, rsm);
 				if (rsm) {
 					debug_printf_eval("OC_FBLTIN F_cl "
 						"rsm->is_pipe:%d, ->F:%p\n",
@@ -2960,6 +3322,11 @@ static var *evaluate(node *op, var *res)
 					 */
 					if (rsm->F)
 						err = rsm->is_pipe ? pclose(rsm->F) : fclose(rsm->F);
+//TODO: fix this case:
+// $ awk 'BEGIN { print close(""); print ERRNO }'
+// -1
+// close of redirection that was never opened
+// (we print 0, 0)
 					free(rsm->buffer);
 					hash_remove(fdhash, L.s);
 				}
@@ -2974,14 +3341,18 @@ static var *evaluate(node *op, var *res)
 		}
 
 		case XC( OC_BUILTIN ):
+			debug_printf_eval("BUILTIN\n");
 			res = exec_builtin(op, res);
 			break;
 
 		case XC( OC_SPRINTF ):
-			setvar_p(res, awk_printf(op1));
+			debug_printf_eval("SPRINTF\n");
+			setvar_p(res, awk_printf(op1, NULL));
 			break;
 
-		case XC( OC_UNARY ): {
+		case XC( OC_UNARY ):
+			debug_printf_eval("UNARY\n");
+		{
 			double Ld, R_d;
 
 			Ld = R_d = getvar_i(R.v);
@@ -3011,7 +3382,9 @@ static var *evaluate(node *op, var *res)
 			break;
 		}
 
-		case XC( OC_FIELD ): {
+		case XC( OC_FIELD ):
+			debug_printf_eval("FIELD\n");
+		{
 			int i = (int)getvar_i(R.v);
 			if (i < 0)
 				syntax_error(EMSG_NEGATIVE_FIELD);
@@ -3028,26 +3401,33 @@ static var *evaluate(node *op, var *res)
 
 		/* concatenation (" ") and index joining (",") */
 		case XC( OC_CONCAT ):
+			debug_printf_eval("CONCAT /\n");
 		case XC( OC_COMMA ): {
 			const char *sep = "";
-			if ((opinfo & OPCLSMASK) == OC_COMMA)
+			debug_printf_eval("COMMA\n");
+			if (opinfo == TI_COMMA)
 				sep = getvar_s(intvar[SUBSEP]);
 			setvar_p(res, xasprintf("%s%s%s", L.s, sep, R.s));
 			break;
 		}
 
 		case XC( OC_LAND ):
+			debug_printf_eval("LAND\n");
 			setvar_i(res, istrue(L.v) ? ptest(op->r.n) : 0);
 			break;
 
 		case XC( OC_LOR ):
+			debug_printf_eval("LOR\n");
 			setvar_i(res, istrue(L.v) ? 1 : ptest(op->r.n));
 			break;
 
 		case XC( OC_BINARY ):
-		case XC( OC_REPLACE ): {
+			debug_printf_eval("BINARY /\n");
+		case XC( OC_REPLACE ):
+			debug_printf_eval("REPLACE\n");
+		{
 			double R_d = getvar_i(R.v);
-			debug_printf_eval("BINARY/REPLACE: R_d:%f opn:%c\n", R_d, opn);
+			debug_printf_eval("R_d:%f opn:%c\n", R_d, opn);
 			switch (opn) {
 			case '+':
 				L_d += R_d;
@@ -3083,6 +3463,7 @@ static var *evaluate(node *op, var *res)
 		case XC( OC_COMPARE ): {
 			int i = i; /* for compiler */
 			double Ld;
+			debug_printf_eval("COMPARE\n");
 
 			if (is_numeric(L.v) && is_numeric(R.v)) {
 				Ld = getvar_i(L.v) - getvar_i(R.v);
@@ -3109,7 +3490,7 @@ static var *evaluate(node *op, var *res)
 		default:
 			syntax_error(EMSG_POSSIBLE_ERROR);
 		} /* switch */
- next:
+
 		if ((opinfo & OPCLSMASK) <= SHIFT_TIL_THIS)
 			op = op->a.n;
 		if ((opinfo & OPCLSMASK) >= RECUR_FROM_THIS)
@@ -3118,7 +3499,10 @@ static var *evaluate(node *op, var *res)
 			break;
 	} /* while (op) */
 
-	nvfree(v1);
+	nvfree(tmpvars, 2);
+#undef TMPVAR0
+#undef TMPVAR1
+
 	debug_printf_eval("returning from %s(): %p\n", __func__, res);
 	return res;
 #undef fnargs
@@ -3126,25 +3510,21 @@ static var *evaluate(node *op, var *res)
 #undef sreg
 }
 
-
 /* -------- main & co. -------- */
 
-static int awk_exit(int r)
+static int awk_exit(void)
 {
-	var tv;
 	unsigned i;
-	hash_item *hi;
-
-	zero_out_var(&tv);
 
 	if (!exiting) {
 		exiting = TRUE;
 		nextrec = FALSE;
-		evaluate(endseq.first, &tv);
+		evaluate(endseq.first, &G.exit__tmpvar);
 	}
 
 	/* waiting for children */
 	for (i = 0; i < fdhash->csize; i++) {
+		hash_item *hi;
 		hi = fdhash->items[i];
 		while (hi) {
 			if (hi->data.rs.F && hi->data.rs.is_pipe)
@@ -3153,65 +3533,7 @@ static int awk_exit(int r)
 		}
 	}
 
-	exit(r);
-}
-
-/* if expr looks like "var=value", perform assignment and return 1,
- * otherwise return 0 */
-static int is_assignment(const char *expr)
-{
-	char *exprc, *val;
-
-	if (!isalnum_(*expr) || (val = strchr(expr, '=')) == NULL) {
-		return FALSE;
-	}
-
-	exprc = xstrdup(expr);
-	val = exprc + (val - expr);
-	*val++ = '\0';
-
-	unescape_string_in_place(val);
-	setvar_u(newvar(exprc), val);
-	free(exprc);
-	return TRUE;
-}
-
-/* switch to next input file */
-static rstream *next_input_file(void)
-{
-#define rsm          (G.next_input_file__rsm)
-#define files_happen (G.next_input_file__files_happen)
-
-	FILE *F;
-	const char *fname, *ind;
-
-	if (rsm.F)
-		fclose(rsm.F);
-	rsm.F = NULL;
-	rsm.pos = rsm.adv = 0;
-
-	for (;;) {
-		if (getvar_i(intvar[ARGIND])+1 >= getvar_i(intvar[ARGC])) {
-			if (files_happen)
-				return NULL;
-			fname = "-";
-			F = stdin;
-			break;
-		}
-		ind = getvar_s(incvar(intvar[ARGIND]));
-		fname = getvar_s(findvar(iamarray(intvar[ARGV]), ind));
-		if (fname && *fname && !is_assignment(fname)) {
-			F = xfopen_stdin(fname);
-			break;
-		}
-	}
-
-	files_happen = TRUE;
-	setvar_s(intvar[FILENAME], fname);
-	rsm.F = F;
-	return &rsm;
-#undef rsm
-#undef files_happen
+	exit(G.exitcode);
 }
 
 int awk_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -3224,12 +3546,7 @@ int awk_main(int argc UNUSED_PARAM, char
 #if ENABLE_FEATURE_AWK_GNU_EXTENSIONS
 	llist_t *list_e = NULL;
 #endif
-	int i, j;
-	var *v;
-	var tv;
-	char **envp;
-	char *vnames = (char *)vNames; /* cheat */
-	char *vvalues = (char *)vValues;
+	int i;
 
 	INIT_G();
 
@@ -3238,48 +3555,43 @@ int awk_main(int argc UNUSED_PARAM, char
 	if (ENABLE_LOCALE_SUPPORT)
 		setlocale(LC_NUMERIC, "C");
 
-	zero_out_var(&tv);
-
-	/* allocate global buffer */
-	g_buf = xmalloc(MAXVARFMT + 1);
-
-	vhash = hash_init();
-	ahash = hash_init();
-	fdhash = hash_init();
-	fnhash = hash_init();
-
 	/* initialize variables */
-	for (i = 0; *vnames; i++) {
-		intvar[i] = v = newvar(nextword(&vnames));
-		if (*vvalues != '\377')
-			setvar_s(v, nextword(&vvalues));
-		else
-			setvar_i(v, 0);
-
-		if (*vnames == '*') {
-			v->type |= VF_SPECIAL;
-			vnames++;
+	vhash = hash_init();
+	{
+		char *vnames = (char *)vNames; /* cheat */
+		char *vvalues = (char *)vValues;
+		for (i = 0; *vnames; i++) {
+			var *v;
+			intvar[i] = v = newvar(nextword(&vnames));
+			if (*vvalues != '\377')
+				setvar_s(v, nextword(&vvalues));
+			else
+				setvar_i(v, 0);
+
+			if (*vnames == '*') {
+				v->type |= VF_SPECIAL;
+				vnames++;
+			}
 		}
 	}
 
 	handle_special(intvar[FS]);
 	handle_special(intvar[RS]);
 
-	newfile("/dev/stdin")->F = stdin;
-	newfile("/dev/stdout")->F = stdout;
-	newfile("/dev/stderr")->F = stderr;
-
 	/* Huh, people report that sometimes environ is NULL. Oh well. */
-	if (environ) for (envp = environ; *envp; envp++) {
-		/* environ is writable, thus we don't strdup it needlessly */
-		char *s = *envp;
-		char *s1 = strchr(s, '=');
-		if (s1) {
-			*s1 = '\0';
-			/* Both findvar and setvar_u take const char*
-			 * as 2nd arg -> environment is not trashed */
-			setvar_u(findvar(iamarray(intvar[ENVIRON]), s), s1 + 1);
-			*s1 = '=';
+	if (environ) {
+		char **envp;
+		for (envp = environ; *envp; envp++) {
+			/* environ is writable, thus we don't strdup it needlessly */
+			char *s = *envp;
+			char *s1 = strchr(s, '=');
+			if (s1) {
+				*s1 = '\0';
+				/* Both findvar and setvar_u take const char*
+				 * as 2nd arg -> environment is not trashed */
+				setvar_u(findvar(iamarray(intvar[ENVIRON]), s), s1 + 1);
+				*s1 = '=';
+			}
 		}
 	}
 	opt = getopt32(argv, OPTSTR_AWK, &opt_F, &list_v, &list_f, IF_FEATURE_AWK_GNU_EXTENSIONS(&list_e,) NULL);
@@ -3295,20 +3607,19 @@ int awk_main(int argc UNUSED_PARAM, char
 		if (!is_assignment(llist_pop(&list_v)))
 			bb_show_usage();
 	}
+
+	/* Parse all supplied programs */
+	fnhash = hash_init();
+	ahash = hash_init();
 	while (list_f) {
-		char *s = NULL;
-		FILE *from_file;
+		int fd;
+		char *s;
 
 		g_progname = llist_pop(&list_f);
-		from_file = xfopen_stdin(g_progname);
-		/* one byte is reserved for some trick in next_token */
-		for (i = j = 1; j > 0; i += j) {
-			s = xrealloc(s, i + 4096);
-			j = fread(s + i, 1, 4094, from_file);
-		}
-		s[i] = '\0';
-		fclose(from_file);
-		parse_program(s + 1);
+		fd = xopen_stdin(g_progname);
+		s = xmalloc_read(fd, NULL); /* it's NUL-terminated */
+		close(fd);
+		parse_program(s);
 		free(s);
 	}
 	g_progname = "cmd. line";
@@ -3317,11 +3628,23 @@ int awk_main(int argc UNUSED_PARAM, char
 		parse_program(llist_pop(&list_e));
 	}
 #endif
+//FIXME: preserve order of -e and -f
+//TODO: implement -i LIBRARY and -E FILE too, they are easy-ish
 	if (!(opt & (OPT_f | OPT_e))) {
 		if (!*argv)
 			bb_show_usage();
 		parse_program(*argv++);
 	}
+	/* Free unused parse structures */
+	//hash_free(fnhash); // ~250 bytes when empty, used only for function names
+	//^^^^^^^^^^^^^^^^^ does not work, hash_clear() inside SEGVs
+	// (IOW: hash_clear() assumes it's a hash of variables. fnhash is not).
+	free(fnhash->items);
+	free(fnhash);
+	fnhash = NULL; // debug
+	//hash_free(ahash); // empty after parsing, will reuse as fdhash instead of freeing
+
+	/* Parsing done, on to executing */
 
 	/* fill in ARGV array */
 	setari_u(intvar[ARGV], 0, "awk");
@@ -3330,9 +3653,14 @@ int awk_main(int argc UNUSED_PARAM, char
 		setari_u(intvar[ARGV], ++i, *argv++);
 	setvar_i(intvar[ARGC], i + 1);
 
-	evaluate(beginseq.first, &tv);
+	//fdhash = ahash; // done via define
+	newfile("/dev/stdin")->F = stdin;
+	newfile("/dev/stdout")->F = stdout;
+	newfile("/dev/stderr")->F = stderr;
+
+	evaluate(beginseq.first, &G.main__tmpvar);
 	if (!mainseq.first && !endseq.first)
-		awk_exit(EXIT_SUCCESS);
+		awk_exit();
 
 	/* input file could already be opened in BEGIN block */
 	if (!iF)
@@ -3347,7 +3675,7 @@ int awk_main(int argc UNUSED_PARAM, char
 			nextrec = FALSE;
 			incvar(intvar[NR]);
 			incvar(intvar[FNR]);
-			evaluate(mainseq.first, &tv);
+			evaluate(mainseq.first, &G.main__tmpvar);
 
 			if (nextfile)
 				break;
@@ -3359,6 +3687,6 @@ int awk_main(int argc UNUSED_PARAM, char
 		iF = next_input_file();
 	}
 
-	awk_exit(EXIT_SUCCESS);
+	awk_exit();
 	/*return 0;*/
 }
diff -urpN busybox-1.33.1/editors/cmp.c busybox-1.34.0/editors/cmp.c
--- busybox-1.33.1/editors/cmp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/cmp.c	2021-06-16 17:02:16.000000000 +0700
@@ -18,7 +18,7 @@
 //kbuild:lib-$(CONFIG_CMP) += cmp.o
 
 //usage:#define cmp_trivial_usage
-//usage:       "[-l] [-s] FILE1 [FILE2" IF_DESKTOP(" [SKIP1 [SKIP2]]") "]"
+//usage:       "[-ls] FILE1 [FILE2" IF_DESKTOP(" [SKIP1 [SKIP2]]") "]"
 //usage:#define cmp_full_usage "\n\n"
 //usage:       "Compare FILE1 with FILE2 (or stdin)\n"
 //usage:     "\n	-l	Write the byte numbers (decimal) and values (octal)"
diff -urpN busybox-1.33.1/editors/diff.c busybox-1.34.0/editors/diff.c
--- busybox-1.33.1/editors/diff.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/diff.c	2021-04-15 00:05:01.000000000 +0700
@@ -1050,7 +1050,7 @@ int diff_main(int argc UNUSED_PARAM, cha
 		/* diffreg can get non-regular files here */
 		print_status(gotstdin > 1 ? STATUS_SAME : diffreg(file), file);
 
-		if (dirfile)
+		if (ENABLE_FEATURE_CLEAN_UP && dirfile)
 			free(file[dir]);
 	}
 
diff -urpN busybox-1.33.1/editors/ed.c busybox-1.34.0/editors/ed.c
--- busybox-1.33.1/editors/ed.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/ed.c	2021-04-15 00:05:01.000000000 +0700
@@ -553,7 +553,7 @@ static int printLines(int num1, int num2
 			fputc_printable(ch | PRINTABLE_META, stdout);
 		}
 
-		fputs("$\n", stdout);
+		fputs_stdout("$\n");
 
 		setCurNum(num1++);
 		lp = lp->next;
diff -urpN busybox-1.33.1/editors/sed.c busybox-1.34.0/editors/sed.c
--- busybox-1.33.1/editors/sed.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/sed.c	2021-06-16 17:02:16.000000000 +0700
@@ -70,7 +70,7 @@
 //usage:#define sed_full_usage "\n\n"
 //usage:       "	-e CMD	Add CMD to sed commands to be executed"
 //usage:     "\n	-f FILE	Add FILE contents to sed commands to be executed"
-//usage:     "\n	-i[SFX]	Edit files in-place (otherwise sends to stdout)"
+//usage:     "\n	-i[SFX]	Edit files in-place (otherwise write to stdout)"
 //usage:     "\n		Optionally back files up, appending SFX"
 //usage:     "\n	-n	Suppress automatic printing of pattern space"
 //usage:     "\n	-r,-E	Use extended regex syntax"
diff -urpN busybox-1.33.1/editors/vi.c busybox-1.34.0/editors/vi.c
--- busybox-1.33.1/editors/vi.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/editors/vi.c	2021-08-19 20:02:34.000000000 +0700
@@ -7,7 +7,6 @@
  */
 //
 //Things To Do:
-//	EXINIT
 //	$HOME/.exrc  and  ./.exrc
 //	add magic to search	/foo.*bar
 //	add :help command
@@ -54,6 +53,14 @@
 //config:	Enable a limited set of colon commands. This does not
 //config:	provide an "ex" mode.
 //config:
+//config:config FEATURE_VI_COLON_EXPAND
+//config:	bool "Expand \"%\" and \"#\" in colon commands"
+//config:	default y
+//config:	depends on FEATURE_VI_COLON
+//config:	help
+//config:	Expand the special characters \"%\" (current filename)
+//config:	and \"#\" (alternate filename) in colon commands.
+//config:
 //config:config FEATURE_VI_YANKMARK
 //config:	bool "Enable yank/put commands and mark cmds"
 //config:	default y
@@ -160,13 +167,21 @@
 //config:	and will generally malloc() larger objects and less frequently.
 //config:	Unless you want more (or less) frequent "undo points" while typing,
 //config:	you should probably leave this unchanged.
+//config:
+//config:config FEATURE_VI_VERBOSE_STATUS
+//config:	bool "Enable verbose status reporting"
+//config:	default y
+//config:	depends on VI
+//config:	help
+//config:	Enable more verbose reporting of the results of yank, change,
+//config:	delete, undo and substitution commands.
 
 //applet:IF_VI(APPLET(vi, BB_DIR_BIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_VI) += vi.o
 
 //usage:#define vi_trivial_usage
-//usage:       IF_FEATURE_VI_COLON("[-c CMD] ")IF_FEATURE_VI_READONLY("[-R] ")"[FILE]..."
+//usage:       IF_FEATURE_VI_COLON("[-c CMD] ")IF_FEATURE_VI_READONLY("[-R] ")"[-H] [FILE]..."
 //usage:#define vi_full_usage "\n\n"
 //usage:       "Edit FILE\n"
 //usage:	IF_FEATURE_VI_COLON(
@@ -176,6 +191,7 @@
 //usage:     "\n	-R	Read-only"
 //usage:	)
 //usage:     "\n	-H	List available features"
+// note: non-standard, "vim -H" is Hebrew mode (bidi support)
 
 #include "libbb.h"
 // Should be after libbb.h: on some systems regex.h needs sys/types.h:
@@ -242,7 +258,7 @@ enum {
 //#define ESC_CURSOR_UP   ESC"[A"
 //#define ESC_CURSOR_DOWN "\n"
 
-#if ENABLE_FEATURE_VI_DOT_CMD || ENABLE_FEATURE_VI_YANKMARK
+#if ENABLE_FEATURE_VI_DOT_CMD
 // cmds modifying text[]
 static const char modifying_cmds[] ALIGN1 = "aAcCdDiIJoOpPrRs""xX<>~";
 #endif
@@ -254,12 +270,17 @@ enum {
 	BACK = -1,	// code depends on "-1" for array index
 	LIMITED = 0,	// char_search() only current line
 	FULL = 1,	// char_search() to the end/beginning of entire text
+	PARTIAL = 0,	// buffer contains partial line
+	WHOLE = 1,	// buffer contains whole lines
+	MULTI = 2,	// buffer may include newlines
 
 	S_BEFORE_WS = 1,	// used in skip_thing() for moving "dot"
 	S_TO_WS = 2,		// used in skip_thing() for moving "dot"
 	S_OVER_WS = 3,		// used in skip_thing() for moving "dot"
 	S_END_PUNCT = 4,	// used in skip_thing() for moving "dot"
 	S_END_ALNUM = 5,	// used in skip_thing() for moving "dot"
+
+	C_END = -1,	// cursor is at end of line due to '$' command
 };
 
 
@@ -274,16 +295,33 @@ struct globals {
 	int text_size;		// size of the allocated buffer
 
 	// the rest
-	smallint vi_setops;
-#define VI_AUTOINDENT 1
-#define VI_SHOWMATCH  2
-#define VI_IGNORECASE 4
-#define VI_ERR_METHOD 8
+#if ENABLE_FEATURE_VI_SETOPTS
+	smallint vi_setops;     // set by setops()
+#define VI_AUTOINDENT (1 << 0)
+#define VI_EXPANDTAB  (1 << 1)
+#define VI_ERR_METHOD (1 << 2)
+#define VI_IGNORECASE (1 << 3)
+#define VI_SHOWMATCH  (1 << 4)
+#define VI_TABSTOP    (1 << 5)
 #define autoindent (vi_setops & VI_AUTOINDENT)
-#define showmatch  (vi_setops & VI_SHOWMATCH )
+#define expandtab  (vi_setops & VI_EXPANDTAB )
+#define err_method (vi_setops & VI_ERR_METHOD) // indicate error with beep or flash
 #define ignorecase (vi_setops & VI_IGNORECASE)
-// indicate error with beep or flash
-#define err_method (vi_setops & VI_ERR_METHOD)
+#define showmatch  (vi_setops & VI_SHOWMATCH )
+// order of constants and strings must match
+#define OPTS_STR \
+		"ai\0""autoindent\0" \
+		"et\0""expandtab\0" \
+		"fl\0""flash\0" \
+		"ic\0""ignorecase\0" \
+		"sm\0""showmatch\0" \
+		"ts\0""tabstop\0"
+#else
+#define autoindent (0)
+#define expandtab  (0)
+#define err_method (0)
+#define ignorecase (0)
+#endif
 
 #if ENABLE_FEATURE_VI_READONLY
 	smallint readonly_mode;
@@ -313,23 +351,35 @@ struct globals {
 	                         // [don't make smallint!]
 	int last_status_cksum;   // hash of current status line
 	char *current_filename;
+#if ENABLE_FEATURE_VI_COLON_EXPAND
+	char *alt_filename;
+#endif
 	char *screenbegin;       // index into text[], of top line on the screen
 	char *screen;            // pointer to the virtual screen buffer
 	int screensize;          //            and its size
 	int tabstop;
-	int last_forward_char;   // last char searched for with 'f' (int because of Unicode)
+	int last_search_char;    // last char searched for (int because of Unicode)
+	smallint last_search_cmd;    // command used to invoke last char search
 #if ENABLE_FEATURE_VI_CRASHME
 	char last_input_char;    // last char read from user
 #endif
+#if ENABLE_FEATURE_VI_UNDO_QUEUE
+	char undo_queue_state;   // One of UNDO_INS, UNDO_DEL, UNDO_EMPTY
+#endif
 
 #if ENABLE_FEATURE_VI_DOT_CMD
 	smallint adding2q;	 // are we currently adding user input to q
 	int lmc_len;             // length of last_modifying_cmd
 	char *ioq, *ioq_start;   // pointer to string for get_one_char to "read"
+	int dotcnt;              // number of times to repeat '.' command
 #endif
 #if ENABLE_FEATURE_VI_SEARCH
 	char *last_search_pattern; // last pattern from a '/' or '?' search
 #endif
+#if ENABLE_FEATURE_VI_SETOPTS
+	int indentcol;		// column of recently autoindent, 0 or -1
+#endif
+	smallint cmd_error;
 
 	// former statics
 #if ENABLE_FEATURE_VI_YANKMARK
@@ -343,13 +393,15 @@ struct globals {
 	smalluint YDreg;//,Ureg;// default delete register and orig line for "U"
 #define Ureg 27
 	char *reg[28];          // named register a-z, "D", and "U" 0-25,26,27
+	char regtype[28];       // buffer type: WHOLE, MULTI or PARTIAL
 	char *mark[28];         // user marks points somewhere in text[]-  a-z and previous context ''
-	char *context_start, *context_end;
 #endif
 #if ENABLE_FEATURE_VI_USE_SIGNALS
 	sigjmp_buf restart;     // int_handler() jumps to location remembered here
 #endif
 	struct termios term_orig; // remember what the cooked mode was
+	int cindex;               // saved character index for up/down motion
+	smallint keep_index;      // retain saved character index
 #if ENABLE_FEATURE_VI_COLON
 	char *initial_cmds[3];  // currently 2 entries, NULL terminated
 #endif
@@ -375,26 +427,22 @@ struct globals {
 #define UNDO_DEL         1
 #define UNDO_INS_CHAIN   2
 #define UNDO_DEL_CHAIN   3
-// UNDO_*_QUEUED must be equal to UNDO_xxx ORed with UNDO_QUEUED_FLAG
-#define UNDO_QUEUED_FLAG 4
+# if ENABLE_FEATURE_VI_UNDO_QUEUE
 #define UNDO_INS_QUEUED  4
 #define UNDO_DEL_QUEUED  5
-#define UNDO_USE_SPOS   32
-#define UNDO_EMPTY      64
+# endif
+
 // Pass-through flags for functions that can be undone
 #define NO_UNDO          0
 #define ALLOW_UNDO       1
 #define ALLOW_UNDO_CHAIN 2
 # if ENABLE_FEATURE_VI_UNDO_QUEUE
 #define ALLOW_UNDO_QUEUED 3
-	char undo_queue_state;
-	int undo_q;
-	char *undo_queue_spos;	// Start position of queued operation
-	char undo_queue[CONFIG_FEATURE_VI_UNDO_QUEUE_MAX];
 # else
 // If undo queuing disabled, don't invoke the missing queue logic
-#define ALLOW_UNDO_QUEUED 1
+#define ALLOW_UNDO_QUEUED ALLOW_UNDO
 # endif
+
 	struct undo_object {
 		struct undo_object *prev;	// Linking back avoids list traversal (LIFO)
 		int start;		// Offset where the data should be restored/deleted
@@ -402,6 +450,13 @@ struct globals {
 		uint8_t u_type;		// 0=deleted, 1=inserted, 2=swapped
 		char undo_text[1];	// text that was deleted (if deletion)
 	} *undo_stack_tail;
+# if ENABLE_FEATURE_VI_UNDO_QUEUE
+#define UNDO_USE_SPOS   32
+#define UNDO_EMPTY      64
+	char *undo_queue_spos;	// Start position of queued operation
+	int undo_q;
+	char undo_queue[CONFIG_FEATURE_VI_UNDO_QUEUE_MAX];
+# endif
 #endif /* ENABLE_FEATURE_VI_UNDO */
 };
 #define G (*ptr_to_globals)
@@ -427,11 +482,13 @@ struct globals {
 #define have_status_msg         (G.have_status_msg    )
 #define last_status_cksum       (G.last_status_cksum  )
 #define current_filename        (G.current_filename   )
+#define alt_filename            (G.alt_filename       )
 #define screen                  (G.screen             )
 #define screensize              (G.screensize         )
 #define screenbegin             (G.screenbegin        )
 #define tabstop                 (G.tabstop            )
-#define last_forward_char       (G.last_forward_char  )
+#define last_search_char        (G.last_search_char   )
+#define last_search_cmd         (G.last_search_cmd    )
 #if ENABLE_FEATURE_VI_CRASHME
 #define last_input_char         (G.last_input_char    )
 #endif
@@ -444,7 +501,10 @@ struct globals {
 #define lmc_len                 (G.lmc_len            )
 #define ioq                     (G.ioq                )
 #define ioq_start               (G.ioq_start          )
+#define dotcnt                  (G.dotcnt             )
 #define last_search_pattern     (G.last_search_pattern)
+#define indentcol               (G.indentcol          )
+#define cmd_error               (G.cmd_error          )
 
 #define edit_file__cur_line     (G.edit_file__cur_line)
 #define refresh__old_offset     (G.refresh__old_offset)
@@ -452,11 +512,12 @@ struct globals {
 
 #define YDreg          (G.YDreg         )
 //#define Ureg           (G.Ureg          )
+#define regtype        (G.regtype       )
 #define mark           (G.mark          )
-#define context_start  (G.context_start )
-#define context_end    (G.context_end   )
 #define restart        (G.restart       )
 #define term_orig      (G.term_orig     )
+#define cindex         (G.cindex        )
+#define keep_index     (G.keep_index    )
 #define initial_cmds   (G.initial_cmds  )
 #define readbuffer     (G.readbuffer    )
 #define scr_out_buf    (G.scr_out_buf   )
@@ -478,6 +539,7 @@ struct globals {
 	last_modified_count = -1; \
 	/* "" but has space for 2 chars: */ \
 	IF_FEATURE_VI_SEARCH(last_search_pattern = xzalloc(2);) \
+	tabstop = 8; \
 } while (0)
 
 #if ENABLE_FEATURE_VI_CRASHME
@@ -522,7 +584,7 @@ static void show_help(void)
 
 static void write1(const char *out)
 {
-	fputs(out, stdout);
+	fputs_stdout(out);
 }
 
 #if ENABLE_FEATURE_VI_WIN_RESIZE
@@ -716,6 +778,30 @@ static int next_tabstop(int col)
 	return col + ((tabstop - 1) - (col % tabstop));
 }
 
+static int prev_tabstop(int col)
+{
+	return col - ((col % tabstop) ?: tabstop);
+}
+
+static int next_column(char c, int co)
+{
+	if (c == '\t')
+		co = next_tabstop(co);
+	else if ((unsigned char)c < ' ' || c == 0x7f)
+		co++; // display as ^X, use 2 columns
+	return co + 1;
+}
+
+static int get_column(char *p)
+{
+	const char *r;
+	int co = 0;
+
+	for (r = begin_line(p); r < p; r++)
+		co = next_column(*r, co);
+	return co;
+}
+
 //----- Erase the Screen[] memory ------------------------------
 static void screen_erase(void)
 {
@@ -744,7 +830,7 @@ static void new_screen(int ro, int co)
 }
 
 //----- Synchronize the cursor to Dot --------------------------
-static NOINLINE void sync_cursor(char *d, int *row, int *col)
+static void sync_cursor(char *d, int *row, int *col)
 {
 	char *beg_cur;	// begin and end of "d" line
 	char *tp;
@@ -792,21 +878,16 @@ static NOINLINE void sync_cursor(char *d
 
 	// find out what col "d" is on
 	co = 0;
-	while (tp < d) { // drive "co" to correct column
+	do { // drive "co" to correct column
 		if (*tp == '\n') //vda || *tp == '\0')
 			break;
-		if (*tp == '\t') {
-			// handle tabs like real vi
-			if (d == tp && cmd_mode) {
-				break;
-			}
-			co = next_tabstop(co);
-		} else if ((unsigned char)*tp < ' ' || *tp == 0x7f) {
-			co++; // display as ^X, use 2 columns
+		co = next_column(*tp, co) - 1;
+		// inserting text before a tab, don't include its position
+		if (cmd_mode && tp == d - 1 && *d == '\t') {
+			co++;
+			break;
 		}
-		co++;
-		tp++;
-	}
+	} while (tp++ < d && ++co);
 
 	// "co" is the column where "dot" is.
 	// The screen has "columns" columns.
@@ -987,6 +1068,9 @@ static void refresh(int full_screen)
 
 	place_cursor(crow, ccol);
 
+	if (!keep_index)
+		cindex = ccol + offset;
+
 	old_offset = offset;
 #undef old_offset
 }
@@ -1018,6 +1102,7 @@ static void indicate_error(void)
 	if (crashme > 0)
 		return;
 #endif
+	cmd_error = TRUE;
 	if (!err_method) {
 		write1(ESC_BELL);
 	} else {
@@ -1072,8 +1157,8 @@ static int get_one_char(void)
 	}
 	// we are adding STDIN chars to q.
 	c = readit();
-	if (lmc_len >= ARRAY_SIZE(last_modifying_cmd) - 1) {
-		// last_modifying_cmd[] is too small, can't remeber the cmd
+	if (lmc_len >= ARRAY_SIZE(last_modifying_cmd) - 2) {
+		// last_modifying_cmd[] is too small, can't remember the cmd
 		// - drop it
 		adding2q = 0;
 		lmc_len = 0;
@@ -1086,6 +1171,27 @@ static int get_one_char(void)
 # define get_one_char() readit()
 #endif
 
+// Get type of thing to operate on and adjust count
+static int get_motion_char(void)
+{
+	int c, cnt;
+
+	c = get_one_char();
+	if (isdigit(c)) {
+		if (c != '0') {
+			// get any non-zero motion count
+			for (cnt = 0; isdigit(c); c = get_one_char())
+				cnt = cnt * 10 + (c - '0');
+			cmdcnt = (cmdcnt ?: 1) * cnt;
+		} else {
+			// ensure standalone '0' works
+			cmdcnt = 0;
+		}
+	}
+
+	return c;
+}
+
 // Get input line (uses "status line" area)
 static char *get_input_line(const char *prompt)
 {
@@ -1098,17 +1204,17 @@ static char *get_input_line(const char *
 	strcpy(buf, prompt);
 	last_status_cksum = 0;	// force status update
 	go_bottom_and_clear_to_eol();
-	write1(prompt);      // write out the :, /, or ? prompt
+	write1(buf);      // write out the :, /, or ? prompt
 
 	i = strlen(buf);
-	while (i < MAX_INPUT_LEN) {
+	while (i < MAX_INPUT_LEN - 1) {
 		c = get_one_char();
 		if (c == '\n' || c == '\r' || c == 27)
 			break;		// this is end of input
 		if (c == term_orig.c_cc[VERASE] || c == 8 || c == 127) {
 			// user wants to erase prev char
-			buf[--i] = '\0';
 			write1("\b \b"); // erase char on screen
+			buf[--i] = '\0';
 			if (i <= 0) // user backs up before b-o-l, exit
 				break;
 		} else if (c > 0 && c < 256) { // exclude Unicode
@@ -1314,15 +1420,20 @@ static void not_implemented(const char *
 
 //----- Block insert/delete, undo ops --------------------------
 #if ENABLE_FEATURE_VI_YANKMARK
-static char *text_yank(char *p, char *q, int dest)	// copy text into a register
+// copy text into a register
+static char *text_yank(char *p, char *q, int dest, int buftype)
 {
+	char *oldreg = reg[dest];
 	int cnt = q - p;
 	if (cnt < 0) {		// they are backwards- reverse them
 		p = q;
 		cnt = -cnt;
 	}
-	free(reg[dest]);	//  if already a yank register, free it
+	// Don't free register yet.  This prevents the memory allocator
+	// from reusing the free block so we can detect if it's changed.
 	reg[dest] = xstrndup(p, cnt + 1);
+	regtype[dest] = buftype;
+	free(oldreg);
 	return p;
 }
 
@@ -1342,18 +1453,10 @@ static char what_reg(void)
 
 static void check_context(char cmd)
 {
-	// A context is defined to be "modifying text"
-	// Any modifying command establishes a new context.
-
-	if (dot < context_start || dot > context_end) {
-		if (strchr(modifying_cmds, cmd) != NULL) {
-			// we are trying to modify text[]- make this the current context
-			mark[27] = mark[26];	// move cur to prev
-			mark[26] = dot;	// move local to cur
-			context_start = prev_line(prev_line(dot));
-			context_end = next_line(next_line(dot));
-			//loiter= start_loiter= now;
-		}
+	// Certain movement commands update the context.
+	if (strchr(":%{}'GHLMz/?Nn", cmd) != NULL) {
+		mark[27] = mark[26];	// move cur to prev
+		mark[26] = dot;	// move local to cur
 	}
 }
 
@@ -1368,15 +1471,29 @@ static char *swap_context(char *p) // go
 		tmp = mark[27];
 		mark[27] = p;
 		mark[26] = p = tmp;
-		context_start = prev_line(prev_line(prev_line(p)));
-		context_end = next_line(next_line(next_line(p)));
 	}
 	return p;
 }
+
+# if ENABLE_FEATURE_VI_VERBOSE_STATUS
+static void yank_status(const char *op, const char *p, int cnt)
+{
+	int lines, chars;
+
+	lines = chars = 0;
+	while (*p) {
+		++chars;
+		if (*p++ == '\n')
+			++lines;
+	}
+	status_line("%s %d lines (%d chars) from [%c]",
+				op, lines * cnt, chars * cnt, what_reg());
+}
+# endif
 #endif /* FEATURE_VI_YANKMARK */
 
 #if ENABLE_FEATURE_VI_UNDO
-static void undo_push(char *, unsigned, unsigned char);
+static void undo_push(char *, unsigned, int);
 #endif
 
 // open a hole in text[]
@@ -1503,9 +1620,12 @@ static void flush_undo_data(void)
 
 // Undo functions and hooks added by Jody Bruchon (jody@jodybruchon.com)
 // Add to the undo stack
-static void undo_push(char *src, unsigned length, uint8_t u_type)
+static void undo_push(char *src, unsigned length, int u_type)
 {
 	struct undo_object *undo_entry;
+# if ENABLE_FEATURE_VI_UNDO_QUEUE
+	int use_spos = u_type & UNDO_USE_SPOS;
+# endif
 
 	// "u_type" values
 	// UNDO_INS: insertion, undo will remove from buffer
@@ -1514,8 +1634,8 @@ static void undo_push(char *src, unsigne
 	// The CHAIN operations are for handling multiple operations that the user
 	// performs with a single action, i.e. REPLACE mode or find-and-replace commands
 	// UNDO_{INS,DEL}_QUEUED: If queuing feature is enabled, allow use of the queue
-	// for the INS/DEL operation. The raw values should be equal to the values of
-	// UNDO_{INS,DEL} ORed with UNDO_QUEUED_FLAG
+	// for the INS/DEL operation.
+	// UNDO_{INS,DEL} ORed with UNDO_USE_SPOS: commit the undo queue
 
 # if ENABLE_FEATURE_VI_UNDO_QUEUE
 	// This undo queuing functionality groups multiple character typing or backspaces
@@ -1568,9 +1688,7 @@ static void undo_push(char *src, unsigne
 		}
 		break;
 	}
-# else
-	// If undo queuing is disabled, ignore the queuing flag entirely
-	u_type = u_type & ~UNDO_QUEUED_FLAG;
+	u_type &= ~UNDO_USE_SPOS;
 # endif
 
 	// Allocate a new undo object
@@ -1587,12 +1705,11 @@ static void undo_push(char *src, unsigne
 	}
 	undo_entry->length = length;
 # if ENABLE_FEATURE_VI_UNDO_QUEUE
-	if ((u_type & UNDO_USE_SPOS) != 0) {
+	if (use_spos) {
 		undo_entry->start = undo_queue_spos - text;	// use start position from queue
 	} else {
 		undo_entry->start = src - text;	// use offset from start of text buffer
 	}
-	u_type = (u_type & ~UNDO_USE_SPOS);
 # else
 	undo_entry->start = src - text;
 # endif
@@ -1645,10 +1762,12 @@ static void undo_pop(void)
 		u_start = text + undo_entry->start;
 		text_hole_make(u_start, undo_entry->length);
 		memcpy(u_start, undo_entry->undo_text, undo_entry->length);
+# if ENABLE_FEATURE_VI_VERBOSE_STATUS
 		status_line("Undo [%d] %s %d chars at position %d",
 			modified_count, "restored",
 			undo_entry->length, undo_entry->start
 		);
+# endif
 		break;
 	case UNDO_INS:
 	case UNDO_INS_CHAIN:
@@ -1656,10 +1775,12 @@ static void undo_pop(void)
 		u_start = undo_entry->start + text;
 		u_end = u_start - 1 + undo_entry->length;
 		text_hole_delete(u_start, u_end, NO_UNDO);
+# if ENABLE_FEATURE_VI_VERBOSE_STATUS
 		status_line("Undo [%d] %s %d chars at position %d",
 			modified_count, "deleted",
 			undo_entry->length, undo_entry->start
 		);
+# endif
 		break;
 	}
 	repeat = 0;
@@ -1723,17 +1844,11 @@ static char *move_to_col(char *p, int l)
 
 	p = begin_line(p);
 	co = 0;
-	while (co < l && p < end) {
+	do {
 		if (*p == '\n') //vda || *p == '\0')
 			break;
-		if (*p == '\t') {
-			co = next_tabstop(co);
-		} else if (*p < ' ' || *p == 127) {
-			co++; // display as ^X, use 2 columns
-		}
-		co++;
-		p++;
-	}
+		co = next_column(*p, co);
+	} while (co <= l && p++ < end);
 	return p;
 }
 
@@ -1756,6 +1871,33 @@ static void dot_skip_over_ws(void)
 		dot++;
 }
 
+static void dot_to_char(int cmd)
+{
+	char *q = dot;
+	int dir = islower(cmd) ? FORWARD : BACK;
+
+	if (last_search_char == 0)
+		return;
+
+	do {
+		do {
+			q += dir;
+			if ((dir == FORWARD ? q > end - 1 : q < text) || *q == '\n') {
+				indicate_error();
+				return;
+			}
+		} while (*q != last_search_char);
+	} while (--cmdcnt > 0);
+
+	dot = q;
+
+	// place cursor before/after char as required
+	if (cmd == 't')
+		dot_left();
+	else if (cmd == 'T')
+		dot_right();
+}
+
 static void dot_scroll(int cnt, int dir)
 {
 	char *q;
@@ -1798,13 +1940,9 @@ static char *bound_dot(char *p) // make
 static void start_new_cmd_q(char c)
 {
 	// get buffer for new cmd
-	// if there is a current cmd count put it in the buffer first
-	if (cmdcnt > 0) {
-		lmc_len = sprintf(last_modifying_cmd, "%u%c", cmdcnt, c);
-	} else { // just save char c onto queue
-		last_modifying_cmd[0] = c;
-		lmc_len = 1;
-	}
+	dotcnt = cmdcnt ?: 1;
+	last_modifying_cmd[0] = c;
+	lmc_len = 1;
 	adding2q = 1;
 }
 static void end_cmd_q(void)
@@ -1819,12 +1957,11 @@ static void end_cmd_q(void)
 #endif /* FEATURE_VI_DOT_CMD */
 
 // copy text into register, then delete text.
-// if dist <= 0, do not include, or go past, a NewLine
 //
 #if !ENABLE_FEATURE_VI_UNDO
 #define yank_delete(a,b,c,d,e) yank_delete(a,b,c,d)
 #endif
-static char *yank_delete(char *start, char *stop, int dist, int yf, int undo)
+static char *yank_delete(char *start, char *stop, int buftype, int yf, int undo)
 {
 	char *p;
 
@@ -1835,22 +1972,11 @@ static char *yank_delete(char *start, ch
 		start = stop;
 		stop = p;
 	}
-	if (dist <= 0) {
-		// we cannot cross NL boundaries
-		p = start;
-		if (*p == '\n')
-			return p;
-		// dont go past a NewLine
-		for (; p + 1 <= stop; p++) {
-			if (p[1] == '\n') {
-				stop = p;	// "stop" just before NewLine
-				break;
-			}
-		}
-	}
+	if (buftype == PARTIAL && *start == '\n')
+		return start;
 	p = start;
 #if ENABLE_FEATURE_VI_YANKMARK
-	text_yank(start, stop, YDreg);
+	text_yank(start, stop, YDreg, buftype);
 #endif
 	if (yf == YANKDEL) {
 		p = text_hole_delete(start, stop, undo);
@@ -1897,6 +2023,11 @@ static int file_insert(const char *fn, c
 		p = text_hole_delete(p + cnt, p + size - 1, NO_UNDO);
 		status_line_bold("can't read '%s'", fn);
 	}
+# if ENABLE_FEATURE_VI_UNDO
+	else {
+		undo_push_insert(p, size, ALLOW_UNDO);
+	}
+# endif
  fi:
 	close(fd);
 
@@ -1976,11 +2107,27 @@ static uintptr_t stupid_insert(char *p,
 	return bias;
 }
 
+// find number of characters in indent, p must be at beginning of line
+static size_t indent_len(char *p)
+{
+	char *r = p;
+
+	while (r < (end - 1) && isblank(*r))
+		r++;
+	return r - p;
+}
+
 #if !ENABLE_FEATURE_VI_UNDO
 #define char_insert(a,b,c) char_insert(a,b)
 #endif
 static char *char_insert(char *p, char c, int undo) // insert the char c at 'p'
 {
+#if ENABLE_FEATURE_VI_SETOPTS
+	size_t len;
+	int col, ntab, nspc;
+#endif
+	char *bol = begin_line(p);
+
 	if (c == 22) {		// Is this an ctrl-V?
 		p += stupid_insert(p, '^');	// use ^ to indicate literal next
 		refresh(FALSE);	// show the ^
@@ -1998,9 +2145,49 @@ static char *char_insert(char *p, char c
 		cmdcnt = 0;
 		end_cmd_q();	// stop adding to q
 		last_status_cksum = 0;	// force status update
-		if ((p[-1] != '\n') && (dot > text)) {
+		if ((dot > text) && (p[-1] != '\n')) {
 			p--;
 		}
+#if ENABLE_FEATURE_VI_SETOPTS
+		if (autoindent) {
+			len = indent_len(bol);
+			if (len && get_column(bol + len) == indentcol && bol[len] == '\n') {
+				// remove autoindent from otherwise empty line
+				text_hole_delete(bol, bol + len - 1, undo);
+				p = bol;
+			}
+		}
+#endif
+	} else if (c == 4) {	// ctrl-D reduces indentation
+		char *r = bol + indent_len(bol);
+		int prev = prev_tabstop(get_column(r));
+		while (r > bol && get_column(r) > prev) {
+			if (p > bol)
+				p--;
+			r--;
+			r = text_hole_delete(r, r, ALLOW_UNDO_QUEUED);
+		}
+
+#if ENABLE_FEATURE_VI_SETOPTS
+		if (autoindent && indentcol && r == end_line(p)) {
+			// record changed size of autoindent
+			indentcol = get_column(p);
+			return p;
+		}
+#endif
+#if ENABLE_FEATURE_VI_SETOPTS
+	} else if (c == '\t' && expandtab) {	// expand tab
+		col = get_column(p);
+		col = next_tabstop(col) - col + 1;
+		while (col--) {
+# if ENABLE_FEATURE_VI_UNDO
+			undo_push_insert(p, 1, undo);
+# else
+			modified_count++;
+# endif
+			p += 1 + stupid_insert(p, ' ');
+		}
+#endif
 	} else if (c == term_orig.c_cc[VERASE] || c == 8 || c == 127) { // Is this a BS
 		if (p > text) {
 			p--;
@@ -2025,27 +2212,84 @@ static char *char_insert(char *p, char c
 			showmatching(p - 1);
 		}
 		if (autoindent && c == '\n') {	// auto indent the new line
-			char *q;
-			size_t len;
-			q = prev_line(p);	// use prev line as template
-			len = strspn(q, " \t"); // space or tab
+			// use indent of current/previous line
+			bol = indentcol < 0 ? p : prev_line(p);
+			len = indent_len(bol);
+			col = get_column(bol + len);
+
+			if (len && col == indentcol) {
+				// previous line was empty except for autoindent
+				// move the indent to the current line
+				memmove(bol + 1, bol, len);
+				*bol = '\n';
+				return p;
+			}
+
+			if (indentcol < 0)
+				p--;	// open above, indent before newly inserted NL
+
 			if (len) {
-				uintptr_t bias;
-				bias = text_hole_make(p, len);
-				p += bias;
-				q += bias;
-#if ENABLE_FEATURE_VI_UNDO
-				undo_push_insert(p, len, undo);
-#endif
-				memcpy(p, q, len);
-				p += len;
+				indentcol = col;
+				if (expandtab) {
+					ntab = 0;
+					nspc = col;
+				} else {
+					ntab = col / tabstop;
+					nspc = col % tabstop;
+				}
+				p += text_hole_make(p, ntab + nspc);
+# if ENABLE_FEATURE_VI_UNDO
+				undo_push_insert(p, ntab + nspc, undo);
+# endif
+				memset(p, '\t', ntab);
+				p += ntab;
+				memset(p, ' ', nspc);
+				return p + nspc;
 			}
 		}
 #endif
 	}
+#if ENABLE_FEATURE_VI_SETOPTS
+	indentcol = 0;
+#endif
 	return p;
 }
 
+#if ENABLE_FEATURE_VI_COLON_EXPAND
+static void init_filename(char *fn)
+{
+	char *copy = xstrdup(fn);
+
+	if (current_filename == NULL) {
+		current_filename = copy;
+	} else {
+		free(alt_filename);
+		alt_filename = copy;
+	}
+}
+#else
+# define init_filename(f) ((void)(0))
+#endif
+
+static void update_filename(char *fn)
+{
+#if ENABLE_FEATURE_VI_COLON_EXPAND
+	if (fn == NULL)
+		return;
+
+	if (current_filename == NULL || strcmp(fn, current_filename) != 0) {
+		free(alt_filename);
+		alt_filename = current_filename;
+		current_filename = xstrdup(fn);
+	}
+#else
+	if (fn != current_filename) {
+		free(current_filename);
+		current_filename = xstrdup(fn);
+	}
+#endif
+}
+
 // read text from file or create an empty buf
 // will also update current_filename
 static int init_text_buffer(char *fn)
@@ -2057,10 +2301,7 @@ static int init_text_buffer(char *fn)
 	text_size = 10240;
 	screenbegin = dot = end = text = xzalloc(text_size);
 
-	if (fn != current_filename) {
-		free(current_filename);
-		current_filename = xstrdup(fn);
-	}
+	update_filename(fn);
 	rc = file_insert(fn, text, 1);
 	if (rc < 0) {
 		// file doesnt exist. Start empty buf with dummy line
@@ -2097,16 +2338,6 @@ static uintptr_t string_insert(char *p,
 	bias = text_hole_make(p, i);
 	p += bias;
 	memcpy(p, s, i);
-#if ENABLE_FEATURE_VI_YANKMARK
-	{
-		int cnt;
-		for (cnt = 0; *s != '\0'; s++) {
-			if (*s == '\n')
-				cnt++;
-		}
-		status_line("Put %d lines (%d chars) from [%c]", cnt, i, what_reg());
-	}
-#endif
 	return bias;
 }
 #endif
@@ -2146,16 +2377,16 @@ static char *char_search(char *p, const
 	struct re_pattern_buffer preg;
 	const char *err;
 	char *q;
-	int i;
-	int size;
-	int range;
+	int i, size, range, start;
 
-	re_syntax_options = RE_SYNTAX_POSIX_EXTENDED;
+	re_syntax_options = RE_SYNTAX_POSIX_BASIC & (~RE_DOT_NEWLINE);
 	if (ignorecase)
-		re_syntax_options = RE_SYNTAX_POSIX_EXTENDED | RE_ICASE;
+		re_syntax_options |= RE_ICASE;
 
 	memset(&preg, 0, sizeof(preg));
 	err = re_compile_pattern(pat, strlen(pat), &preg);
+	preg.not_bol = p != text;
+	preg.not_eol = p != end - 1;
 	if (err != NULL) {
 		status_line_bold("bad search pattern '%s': %s", pat, err);
 		return p;
@@ -2173,31 +2404,26 @@ static char *char_search(char *p, const
 
 	// RANGE could be negative if we are searching backwards
 	range = q - p;
-	q = p;
-	size = range;
 	if (range < 0) {
-		size = -size;
-		q = p - size;
-		if (q < text)
-			q = text;
+		size = -range;
+		start = size;
+	} else {
+		size = range;
+		start = 0;
 	}
+	q = p - start;
+	if (q < text)
+		q = text;
 	// search for the compiled pattern, preg, in p[]
-	// range < 0: search backward
-	// range > 0: search forward
-	// 0 < start < size
+	// range < 0, start == size: search backward
+	// range > 0, start == 0: search forward
 	// re_search() < 0: not found or error
 	// re_search() >= 0: index of found pattern
 	//           struct pattern   char     int   int    int    struct reg
 	// re_search(*pattern_buffer, *string, size, start, range, *regs)
-	i = re_search(&preg, q, size, /*start:*/ 0, range, /*struct re_registers*:*/ NULL);
+	i = re_search(&preg, q, size, start, range, /*struct re_registers*:*/ NULL);
 	regfree(&preg);
-	if (i < 0)
-		return NULL;
-	if (dir_and_range > 0) // FORWARD?
-		p = p + i;
-	else
-		p = p - i;
-	return p;
+	return i < 0 ? NULL : q + i;
 }
 # else
 #  if ENABLE_FEATURE_VI_SETOPTS
@@ -2246,114 +2472,281 @@ static char *char_search(char *p, const
 
 //----- The Colon commands -------------------------------------
 #if ENABLE_FEATURE_VI_COLON
-static char *get_one_address(char *p, int *addr)	// get colon addr, if present
+static char *get_one_address(char *p, int *result)	// get colon addr, if present
 {
-	int st;
-	char *q;
-	IF_FEATURE_VI_YANKMARK(char c;)
+	int st, num, sign, addr, new_addr;
+# if ENABLE_FEATURE_VI_YANKMARK || ENABLE_FEATURE_VI_SEARCH
+	char *q, c;
+# endif
+	IF_FEATURE_VI_SEARCH(int dir;)
 
-	*addr = -1;			// assume no addr
-	if (*p == '.') {	// the current line
-		p++;
-		q = begin_line(dot);
-		*addr = count_lines(text, q);
-	}
-#if ENABLE_FEATURE_VI_YANKMARK
-	else if (*p == '\'') {	// is this a mark addr
-		p++;
-		c = tolower(*p);
-		p++;
-		if (c >= 'a' && c <= 'z') {
-			// we have a mark
-			c = c - 'a';
-			q = mark[(unsigned char) c];
-			if (q != NULL) {	// is mark valid
-				*addr = count_lines(text, q);
-			}
+	addr = -1;			// assume no addr
+	sign = 0;
+	for (;;) {
+		new_addr = -1;
+		if (isblank(*p)) {
+			p++;
+		} else if (*p == '.') {	// the current line
+			p++;
+			new_addr = count_lines(text, dot);
 		}
-	}
-#endif
-#if ENABLE_FEATURE_VI_SEARCH
-	else if (*p == '/') {	// a search pattern
-		q = strchrnul(p + 1, '/');
-		if (p + 1 != q) {
-			// save copy of new pattern
-			free(last_search_pattern);
-			last_search_pattern = xstrndup(p, q - p);
+# if ENABLE_FEATURE_VI_YANKMARK
+		else if (*p == '\'') {	// is this a mark addr
+			p++;
+			c = tolower(*p);
+			p++;
+			q = NULL;
+			if (c >= 'a' && c <= 'z') {
+				// we have a mark
+				c = c - 'a';
+				q = mark[(unsigned char) c];
+			}
+			if (q == NULL)	// is mark valid
+				return NULL;
+			new_addr = count_lines(text, q);
 		}
-		p = q;
-		if (*p == '/')
+# endif
+# if ENABLE_FEATURE_VI_SEARCH
+		else if (*p == '/' || *p == '?') {	// a search pattern
+			c = *p;
+			q = strchrnul(p + 1, c);
+			if (p + 1 != q) {
+				// save copy of new pattern
+				free(last_search_pattern);
+				last_search_pattern = xstrndup(p, q - p);
+			}
+			p = q;
+			if (*p == c)
+				p++;
+			if (c == '/') {
+				q = next_line(dot);
+				dir = (FORWARD << 1) | FULL;
+			} else {
+				q = begin_line(dot);
+				dir = ((unsigned)BACK << 1) | FULL;
+			}
+			q = char_search(q, last_search_pattern + 1, dir);
+			if (q == NULL)
+				return NULL;
+			new_addr = count_lines(text, q);
+		}
+# endif
+		else if (*p == '$') {	// the last line in file
 			p++;
-		q = char_search(next_line(dot), last_search_pattern + 1,
-						(FORWARD << 1) | FULL);
-		if (q != NULL) {
-			*addr = count_lines(text, q);
+			new_addr = count_lines(text, end - 1);
+		} else if (isdigit(*p)) {
+			sscanf(p, "%d%n", &num, &st);
+			p += st;
+			if (addr < 0) {	// specific line number
+				addr = num;
+			} else {	// offset from current addr
+				addr += sign >= 0 ? num : -num;
+			}
+			sign = 0;
+		} else if (*p == '-' || *p == '+') {
+			sign = *p++ == '-' ? -1 : 1;
+			if (addr < 0) {	// default address is dot
+				addr = count_lines(text, dot);
+			}
+		} else {
+			addr += sign;	// consume unused trailing sign
+			break;
+		}
+		if (new_addr >= 0) {
+			if (addr >= 0)	// only one new address per expression
+				return NULL;
+			addr = new_addr;
 		}
 	}
-#endif
-	else if (*p == '$') {	// the last line in file
-		p++;
-		q = begin_line(end - 1);
-		*addr = count_lines(text, q);
-	} else if (isdigit(*p)) {	// specific line number
-		sscanf(p, "%d%n", addr, &st);
-		p += st;
-	} else {
-		// unrecognized address - assume -1
-		*addr = -1;
-	}
+	*result = addr;
 	return p;
 }
 
-static char *get_address(char *p, int *b, int *e)	// get two colon addrs, if present
+# define GET_ADDRESS   0
+# define GET_SEPARATOR 1
+
+// Read line addresses for a colon command.  The user can enter as
+// many as they like but only the last two will be used.
+static char *get_address(char *p, int *b, int *e)
 {
+	int state = GET_ADDRESS;
+	char *save_dot = dot;
+
 	//----- get the address' i.e., 1,3   'a,'b  -----
-	// get FIRST addr, if present
-	while (isblank(*p))
-		p++;				// skip over leading spaces
-	if (*p == '%') {			// alias for 1,$
-		p++;
-		*b = 1;
-		*e = count_lines(text, end-1);
-		goto ga0;
-	}
-	p = get_one_address(p, b);
-	while (isblank(*p))
-		p++;
-	if (*p == ',') {			// is there a address separator
-		p++;
-		while (isblank(*p))
+	for (;;) {
+		if (isblank(*p)) {
+			p++;
+		} else if (*p == '%' && state == GET_ADDRESS) {	// alias for 1,$
 			p++;
-		// get SECOND addr, if present
-		p = get_one_address(p, e);
+			*b = 1;
+			*e = count_lines(text, end-1);
+			state = GET_SEPARATOR;
+		} else if (state == GET_SEPARATOR && (*p == ',' || *p == ';')) {
+			if (*p == ';')
+				dot = find_line(*e);
+			p++;
+			*b = *e;
+			state = GET_ADDRESS;
+		} else if (state == GET_ADDRESS) {
+			p = get_one_address(p, e);
+			if (p == NULL)
+				break;
+			state = GET_SEPARATOR;
+		} else {
+			if (state == GET_SEPARATOR && *b >= 0 && *e < 0)
+				*e = count_lines(text, dot);
+			break;
+		}
 	}
- ga0:
-	while (isblank(*p))
-		p++;				// skip over trailing spaces
+	dot = save_dot;
 	return p;
 }
 
-#if ENABLE_FEATURE_VI_SET && ENABLE_FEATURE_VI_SETOPTS
-static void setops(const char *args, const char *opname, int flg_no,
-			const char *short_opname, int opt)
-{
-	const char *a = args + flg_no;
-	int l = strlen(opname) - 1; // opname have + ' '
-
-	// maybe strncmp? we had tons of erroneous strncasecmp's...
-	if (strncasecmp(a, opname, l) == 0
-	 || strncasecmp(a, short_opname, 2) == 0
-	) {
-		if (flg_no)
-			vi_setops &= ~opt;
-		else
-			vi_setops |= opt;
+# if ENABLE_FEATURE_VI_SET && ENABLE_FEATURE_VI_SETOPTS
+static void setops(char *args, int flg_no)
+{
+	char *eq;
+	int index;
+
+	eq = strchr(args, '=');
+	if (eq) *eq = '\0';
+	index = index_in_strings(OPTS_STR, args + flg_no);
+	if (eq) *eq = '=';
+	if (index < 0) {
+ bad:
+		status_line_bold("bad option: %s", args);
+		return;
+	}
+
+	index = 1 << (index >> 1); // convert to VI_bit
+
+	if (index & VI_TABSTOP) {
+		int t;
+		if (!eq || flg_no) // no "=NNN" or it is "notabstop"?
+			goto bad;
+		t = bb_strtou(eq + 1, NULL, 10);
+		if (t <= 0 || t > MAX_TABSTOP)
+			goto bad;
+		tabstop = t;
+		return;
+	}
+	if (eq)	goto bad; // boolean option has "="?
+	if (flg_no) {
+		vi_setops &= ~index;
+	} else {
+		vi_setops |= index;
 	}
 }
-#endif
+# endif
+
+# if ENABLE_FEATURE_VI_COLON_EXPAND
+static char *expand_args(char *args)
+{
+	char *s, *t;
+	const char *replace;
+
+	args = xstrdup(args);
+	for (s = args; *s; s++) {
+		if (*s == '%') {
+			replace = current_filename;
+		} else if (*s == '#') {
+			replace = alt_filename;
+		} else {
+			if (*s == '\\' && s[1] != '\0') {
+				for (t = s++; *t; t++)
+					*t = t[1];
+			}
+			continue;
+		}
 
+		if (replace == NULL) {
+			free(args);
+			status_line_bold("No previous filename");
+			return NULL;
+		}
+
+		*s = '\0';
+		t = xasprintf("%s%s%s", args, replace, s+1);
+		s = t + (s - args) + strlen(replace);
+		free(args);
+		args = t;
+	}
+	return args;
+}
+# else
+#  define expand_args(a) (a)
+# endif
 #endif /* FEATURE_VI_COLON */
 
+#if ENABLE_FEATURE_VI_REGEX_SEARCH
+# define MAX_SUBPATTERN 10	// subpatterns \0 .. \9
+
+// Like strchr() but skipping backslash-escaped characters
+static char *strchr_backslash(const char *s, int c)
+{
+	while (*s) {
+		if (*s == c)
+			return (char *)s;
+		if (*s == '\\')
+			if (*++s == '\0')
+				break;
+		s++;
+	}
+	return NULL;
+}
+
+// If the return value is not NULL the caller should free R
+static char *regex_search(char *q, regex_t *preg, const char *Rorig,
+				size_t *len_F, size_t *len_R, char **R)
+{
+	regmatch_t regmatch[MAX_SUBPATTERN], *cur_match;
+	char *found = NULL;
+	const char *t;
+	char *r;
+
+	regmatch[0].rm_so = 0;
+	regmatch[0].rm_eo = end_line(q) - q;
+	if (regexec(preg, q, MAX_SUBPATTERN, regmatch, REG_STARTEND) != 0)
+		return found;
+
+	found = q + regmatch[0].rm_so;
+	*len_F = regmatch[0].rm_eo - regmatch[0].rm_so;
+	*R = NULL;
+
+ fill_result:
+	// first pass calculates len_R, second fills R
+	*len_R = 0;
+	for (t = Rorig, r = *R; *t; t++) {
+		size_t len = 1;	// default is to copy one char from replace pattern
+		const char *from = t;
+		if (*t == '\\') {
+			from = ++t;	// skip backslash
+			if (*t >= '0' && *t < '0' + MAX_SUBPATTERN) {
+				cur_match = regmatch + (*t - '0');
+				if (cur_match->rm_so >= 0) {
+					len = cur_match->rm_eo - cur_match->rm_so;
+					from = q + cur_match->rm_so;
+				}
+			}
+		}
+		*len_R += len;
+		if (*R) {
+			memcpy(r, from, len);
+			r += len;
+			/* *r = '\0'; - xzalloc did it */
+		}
+	}
+	if (*R == NULL) {
+		*R = xzalloc(*len_R + 1);
+		goto fill_result;
+	}
+
+	return found;
+}
+#else /* !ENABLE_FEATURE_VI_REGEX_SEARCH */
+# define strchr_backslash(s, c) strchr(s, c)
+#endif /* ENABLE_FEATURE_VI_REGEX_SEARCH */
+
 // buf must be no longer than MAX_INPUT_LEN!
 static void colon(char *buf)
 {
@@ -2368,7 +2761,7 @@ static void colon(char *buf)
 	if (cnt == 0)
 		return;
 	if (strncmp(p, "quit", cnt) == 0
-	 || strncmp(p, "q!", cnt) == 0
+	 || strcmp(p, "q!") == 0
 	) {
 		if (modified_count && p[1] != '!') {
 			status_line_bold("No write since last change (:%s! overrides)", p);
@@ -2378,8 +2771,8 @@ static void colon(char *buf)
 		return;
 	}
 	if (strncmp(p, "write", cnt) == 0
-	 || strncmp(p, "wq", cnt) == 0
-	 || strncmp(p, "wn", cnt) == 0
+	 || strcmp(p, "wq") == 0
+	 || strcmp(p, "wn") == 0
 	 || (p[0] == 'x' && !p[1])
 	) {
 		if (modified_count != 0 || p[0] != 'x') {
@@ -2397,7 +2790,6 @@ static void colon(char *buf)
 			);
 			if (p[0] == 'x'
 			 || p[1] == 'q' || p[1] == 'n'
-			 || p[1] == 'Q' || p[1] == 'N'
 			) {
 				editing = 0;
 			}
@@ -2417,12 +2809,9 @@ static void colon(char *buf)
 #else
 
 	char c, *buf1, *q, *r;
-	char *fn, cmd[MAX_INPUT_LEN], args[MAX_INPUT_LEN];
+	char *fn, cmd[MAX_INPUT_LEN], *cmdend, *args, *exp = NULL;
 	int i, l, li, b, e;
 	int useforce;
-# if ENABLE_FEATURE_VI_SEARCH || ENABLE_FEATURE_ALLOW_EXEC
-	char *orig_buf;
-# endif
 
 	// :3154	// if (-e line 3154) goto it  else stay put
 	// :4,33w! foo	// write a portion of buffer to file "foo"
@@ -2446,58 +2835,61 @@ static void colon(char *buf)
 
 	li = i = 0;
 	b = e = -1;
-	q = text;			// assume 1,$ for the range
-	r = end - 1;
 	li = count_lines(text, end - 1);
 	fn = current_filename;
 
 	// look for optional address(es)  :.  :1  :1,9   :'q,'a   :%
+	buf1 = buf;
 	buf = get_address(buf, &b, &e);
-
-# if ENABLE_FEATURE_VI_SEARCH || ENABLE_FEATURE_ALLOW_EXEC
-	// remember orig command line
-	orig_buf = buf;
-# endif
+	if (buf == NULL) {
+		status_line_bold("Bad address: %s", buf1);
+		goto ret;
+	}
 
 	// get the COMMAND into cmd[]
+	strcpy(cmd, buf);
 	buf1 = cmd;
-	while (*buf != '\0') {
-		if (isspace(*buf))
-			break;
-		*buf1++ = *buf++;
+	while (!isspace(*buf1) && *buf1 != '\0') {
+		buf1++;
 	}
-	*buf1 = '\0';
+	cmdend = buf1;
 	// get any ARGuments
-	while (isblank(*buf))
-		buf++;
-	strcpy(args, buf);
+	while (isblank(*buf1))
+		buf1++;
+	args = buf1;
+	*cmdend = '\0';
 	useforce = FALSE;
-	buf1 = last_char_is(cmd, '!');
-	if (buf1) {
+	if (cmdend > cmd && cmdend[-1] == '!') {
 		useforce = TRUE;
-		*buf1 = '\0';   // get rid of !
+		cmdend[-1] = '\0';   // get rid of !
 	}
-	if (b >= 0) {
-		// if there is only one addr, then the addr
-		// is the line number of the single line the
-		// user wants. So, reset the end
-		// pointer to point at end of the "b" line
-		q = find_line(b);	// what line is #b
-		r = end_line(q);
-		li = 1;
-	}
-	if (e >= 0) {
-		// we were given two addrs.  change the
-		// end pointer to the addr given by user.
-		r = find_line(e);	// what line is #e
-		r = end_line(r);
-		li = e - b + 1;
+	// assume the command will want a range, certain commands
+	// (read, substitute) need to adjust these assumptions
+	if (e < 0) {
+		q = text;			// no addr, use 1,$ for the range
+		r = end - 1;
+	} else {
+		// at least one addr was given, get its details
+		q = r = find_line(e);
+		if (b < 0) {
+			// if there is only one addr, then it's the line
+			// number of the single line the user wants.
+			// Reset the end pointer to the end of that line.
+			r = end_line(q);
+			li = 1;
+		} else {
+			// we were given two addrs.  change the
+			// start pointer to the addr given by user.
+			q = find_line(b);	// what line is #b
+			r = end_line(r);
+			li = e - b + 1;
+		}
 	}
 	// ------------ now look for the command ------------
 	i = strlen(cmd);
 	if (i == 0) {		// :123CR goto line #123
-		if (b >= 0) {
-			dot = find_line(b);	// what line is #b
+		if (e >= 0) {
+			dot = find_line(e);	// what line is #e
 			dot_skip_over_ws();
 		}
 	}
@@ -2505,9 +2897,12 @@ static void colon(char *buf)
 	else if (cmd[0] == '!') {	// run a cmd
 		int retcode;
 		// :!ls   run the <cmd>
+		exp = expand_args(buf + 1);
+		if (exp == NULL)
+			goto ret;
 		go_bottom_and_clear_to_eol();
 		cookmode();
-		retcode = system(orig_buf + 1);	// run the cmd
+		retcode = system(exp);	// run the cmd
 		if (retcode)
 			printf("\nshell returned %i\n\n", retcode);
 		rawmode();
@@ -2515,16 +2910,16 @@ static void colon(char *buf)
 	}
 # endif
 	else if (cmd[0] == '=' && !cmd[1]) {	// where is the address
-		if (b < 0) {	// no addr given- use defaults
-			b = e = count_lines(text, dot);
+		if (e < 0) {	// no addr given- use defaults
+			e = count_lines(text, dot);
 		}
-		status_line("%d", b);
+		status_line("%d", e);
 	} else if (strncmp(cmd, "delete", i) == 0) {	// delete lines
-		if (b < 0) {	// no addr given- use defaults
+		if (e < 0) {	// no addr given- use defaults
 			q = begin_line(dot);	// assume .,. for the range
 			r = end_line(dot);
 		}
-		dot = yank_delete(q, r, 1, YANKDEL, ALLOW_UNDO);	// save, then delete lines
+		dot = yank_delete(q, r, WHOLE, YANKDEL, ALLOW_UNDO);	// save, then delete lines
 		dot_skip_over_ws();
 	} else if (strncmp(cmd, "edit", i) == 0) {	// Edit a file
 		int size;
@@ -2536,11 +2931,10 @@ static void colon(char *buf)
 		}
 		if (args[0]) {
 			// the user supplied a file name
-			fn = args;
-		} else if (current_filename && current_filename[0]) {
-			// no user supplied name- use the current filename
-			// fn = current_filename;  was set by default
-		} else {
+			fn = exp = expand_args(args);
+			if (exp == NULL)
+				goto ret;
+		} else if (current_filename == NULL) {
 			// no user file name, no current name- punt
 			status_line_bold("No current filename");
 			goto ret;
@@ -2563,7 +2957,7 @@ static void colon(char *buf)
 		status_line("'%s'%s"
 			IF_FEATURE_VI_READONLY("%s")
 			" %uL, %uC",
-			current_filename,
+			fn,
 			(size < 0 ? " [New file]" : ""),
 			IF_FEATURE_VI_READONLY(
 				((readonly_mode) ? " [Readonly]" : ""),
@@ -2571,14 +2965,16 @@ static void colon(char *buf)
 			li, (int)(end - text)
 		);
 	} else if (strncmp(cmd, "file", i) == 0) {	// what File is this
-		if (b != -1 || e != -1) {
+		if (e >= 0) {
 			status_line_bold("No address allowed on this command");
 			goto ret;
 		}
 		if (args[0]) {
 			// user wants a new filename
-			free(current_filename);
-			current_filename = xstrdup(args);
+			exp = expand_args(args);
+			if (exp == NULL)
+				goto ret;
+			update_filename(exp);
 		} else {
 			// user wants file status info
 			last_status_cksum = 0;	// force status update
@@ -2591,7 +2987,7 @@ static void colon(char *buf)
 		rawmode();
 		Hit_Return();
 	} else if (strncmp(cmd, "list", i) == 0) {	// literal print line
-		if (b < 0) {	// no addr given- use defaults
+		if (e < 0) {	// no addr given- use defaults
 			q = begin_line(dot);	// assume .,. for the range
 			r = end_line(dot);
 		}
@@ -2658,23 +3054,30 @@ static void colon(char *buf)
 		}
 		editing = 0;
 	} else if (strncmp(cmd, "read", i) == 0) {	// read file into text[]
-		int size;
+		int size, num;
 
-		fn = args;
-		if (!fn[0]) {
-			status_line_bold("No filename given");
+		if (args[0]) {
+			// the user supplied a file name
+			fn = exp = expand_args(args);
+			if (exp == NULL)
+				goto ret;
+			init_filename(fn);
+		} else if (current_filename == NULL) {
+			// no user file name, no current name- punt
+			status_line_bold("No current filename");
 			goto ret;
 		}
-		if (b < 0) {	// no addr given- use defaults
-			q = begin_line(dot);	// assume "dot"
-		}
-		// read after current line- unless user said ":0r foo"
-		if (b != 0) {
-			q = next_line(q);
+		if (e == 0) {	// user said ":0r foo"
+			q = text;
+		} else {	// read after given line or current line if none given
+			q = next_line(e > 0 ? find_line(e) : dot);
 			// read after last line
 			if (q == end-1)
 				++q;
 		}
+		num = count_lines(text, q);
+		if (q == end)
+			num++;
 		{ // dance around potentially-reallocated text[]
 			uintptr_t ofs = q - text;
 			size = file_insert(fn, q, 0);
@@ -2691,11 +3094,7 @@ static void colon(char *buf)
 			IF_FEATURE_VI_READONLY((readonly_mode ? " [Readonly]" : ""),)
 			li, size
 		);
-		if (size > 0) {
-			// if the insert is before "dot" then we need to update
-			if (q <= dot)
-				dot += size;
-		}
+		dot = find_line(num);
 	} else if (strncmp(cmd, "rewind", i) == 0) {	// rewind cmd line args
 		if (modified_count && !useforce) {
 			status_line_bold("No write since last change (:%s! overrides)", cmd);
@@ -2707,20 +3106,21 @@ static void colon(char *buf)
 # if ENABLE_FEATURE_VI_SET
 	} else if (strncmp(cmd, "set", i) == 0) {	// set or clear features
 #  if ENABLE_FEATURE_VI_SETOPTS
-		char *argp;
+		char *argp, *argn, oldch;
 #  endif
-		i = 0;			// offset into args
 		// only blank is regarded as args delimiter. What about tab '\t'?
-		if (!args[0] || strcasecmp(args, "all") == 0) {
+		if (!args[0] || strcmp(args, "all") == 0) {
 			// print out values of all options
 #  if ENABLE_FEATURE_VI_SETOPTS
 			status_line_bold(
 				"%sautoindent "
+				"%sexpandtab "
 				"%sflash "
 				"%signorecase "
 				"%sshowmatch "
 				"tabstop=%u",
 				autoindent ? "" : "no",
+				expandtab ? "" : "no",
 				err_method ? "" : "no",
 				ignorecase ? "" : "no",
 				showmatch ? "" : "no",
@@ -2732,20 +3132,15 @@ static void colon(char *buf)
 #  if ENABLE_FEATURE_VI_SETOPTS
 		argp = args;
 		while (*argp) {
-			if (strncmp(argp, "no", 2) == 0)
-				i = 2;		// ":set noautoindent"
-			setops(argp, "autoindent ", i, "ai", VI_AUTOINDENT);
-			setops(argp, "flash "     , i, "fl", VI_ERR_METHOD);
-			setops(argp, "ignorecase ", i, "ic", VI_IGNORECASE);
-			setops(argp, "showmatch " , i, "sm", VI_SHOWMATCH );
-			if (strncmp(argp + i, "tabstop=", 8) == 0) {
-				int t = 0;
-				sscanf(argp + i+8, "%u", &t);
-				if (t > 0 && t <= MAX_TABSTOP)
-					tabstop = t;
-			}
-			argp = skip_non_whitespace(argp);
-			argp = skip_whitespace(argp);
+			i = 0;
+			if (argp[0] == 'n' && argp[1] == 'o') // "noXXX"
+				i = 2;
+			argn = skip_non_whitespace(argp);
+			oldch = *argn;
+			*argn = '\0';
+			setops(argp, i);
+			*argn = oldch;
+			argp = skip_whitespace(argn);
 		}
 #  endif /* FEATURE_VI_SETOPTS */
 # endif /* FEATURE_VI_SET */
@@ -2754,54 +3149,117 @@ static void colon(char *buf)
 	} else if (cmd[0] == 's') {	// substitute a pattern with a replacement pattern
 		char *F, *R, *flags;
 		size_t len_F, len_R;
-		int gflag;		// global replace flag
-#  if ENABLE_FEATURE_VI_UNDO
-		int dont_chain_first_item = ALLOW_UNDO;
+		int gflag = 0;		// global replace flag
+		int subs = 0;	// number of substitutions
+#  if ENABLE_FEATURE_VI_VERBOSE_STATUS
+		int last_line = 0, lines = 0;
+#  endif
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+		regex_t preg;
+		int cflags;
+		char *Rorig;
+#   if ENABLE_FEATURE_VI_UNDO
+		int undo = 0;
+#   endif
 #  endif
 
 		// F points to the "find" pattern
 		// R points to the "replace" pattern
 		// replace the cmd line delimiters "/" with NULs
-		c = orig_buf[1];	// what is the delimiter
-		F = orig_buf + 2;	// start of "find"
-		R = strchr(F, c);	// middle delimiter
+		c = buf[1];	// what is the delimiter
+		F = buf + 2;	// start of "find"
+		R = strchr_backslash(F, c);	// middle delimiter
 		if (!R)
 			goto colon_s_fail;
 		len_F = R - F;
 		*R++ = '\0';	// terminate "find"
-		flags = strchr(R, c);
-		if (!flags)
-			goto colon_s_fail;
-		len_R = flags - R;
-		*flags++ = '\0';	// terminate "replace"
-		gflag = *flags;
+		flags = strchr_backslash(R, c);
+		if (flags) {
+			*flags++ = '\0';	// terminate "replace"
+			gflag = *flags;
+		}
 
-		q = begin_line(q);
-		if (b < 0) {	// maybe :s/foo/bar/
+		if (len_F) {	// save "find" as last search pattern
+			free(last_search_pattern);
+			last_search_pattern = xstrdup(F - 1);
+			last_search_pattern[0] = '/';
+		} else if (last_search_pattern[1] == '\0') {
+			status_line_bold("No previous search");
+			goto ret;
+		} else {
+			F = last_search_pattern + 1;
+			len_F = strlen(F);
+		}
+
+		if (e < 0) {	// no addr given
 			q = begin_line(dot);      // start with cur line
-			b = count_lines(text, q); // cur line number
+			r = end_line(dot);
+			b = e = count_lines(text, q); // cur line number
+		} else if (b < 0) {	// one addr given
+			b = e;
 		}
-		if (e < 0)
-			e = b;		// maybe :.s/foo/bar/
+
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+		Rorig = R;
+		cflags = 0;
+		if (ignorecase)
+			cflags = REG_ICASE;
+		memset(&preg, 0, sizeof(preg));
+		if (regcomp(&preg, F, cflags) != 0) {
+			status_line(":s bad search pattern");
+			goto regex_search_end;
+		}
+#  else
+		len_R = strlen(R);
+#  endif
 
 		for (i = b; i <= e; i++) {	// so, :20,23 s \0 find \0 replace \0
 			char *ls = q;		// orig line start
 			char *found;
  vc4:
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+			found = regex_search(q, &preg, Rorig, &len_F, &len_R, &R);
+#  else
 			found = char_search(q, F, (FORWARD << 1) | LIMITED);	// search cur line only for "find"
+#  endif
 			if (found) {
 				uintptr_t bias;
 				// we found the "find" pattern - delete it
 				// For undo support, the first item should not be chained
-				text_hole_delete(found, found + len_F - 1, dont_chain_first_item);
-#  if ENABLE_FEATURE_VI_UNDO
-				dont_chain_first_item = ALLOW_UNDO_CHAIN;
+				// This needs to be handled differently depending on
+				// whether or not regex support is enabled.
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+#   define TEST_LEN_F len_F	// len_F may be zero
+#   define TEST_UNDO1 undo++
+#   define TEST_UNDO2 undo++
+#  else
+#   define TEST_LEN_F 1		// len_F is never zero
+#   define TEST_UNDO1 subs
+#   define TEST_UNDO2 1
 #  endif
-				// insert the "replace" patern
-				bias = string_insert(found, R, ALLOW_UNDO_CHAIN);
-				found += bias;
-				ls += bias;
-				//q += bias; - recalculated anyway
+				if (TEST_LEN_F)	// match can be empty, no delete needed
+					text_hole_delete(found, found + len_F - 1,
+								TEST_UNDO1 ? ALLOW_UNDO_CHAIN : ALLOW_UNDO);
+				if (len_R != 0) {	// insert the "replace" pattern, if required
+					bias = string_insert(found, R,
+								TEST_UNDO2 ? ALLOW_UNDO_CHAIN : ALLOW_UNDO);
+					found += bias;
+					ls += bias;
+					//q += bias; - recalculated anyway
+				}
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+				free(R);
+#  endif
+				if (TEST_LEN_F || len_R != 0) {
+					dot = ls;
+					subs++;
+#  if ENABLE_FEATURE_VI_VERBOSE_STATUS
+					if (last_line != i) {
+						last_line = i;
+						++lines;
+					}
+#  endif
+				}
 				// check for "global"  :s/foo/bar/g
 				if (gflag == 'g') {
 					if ((found + len_R) < end_line(ls)) {
@@ -2812,12 +3270,25 @@ static void colon(char *buf)
 			}
 			q = next_line(ls);
 		}
+		if (subs == 0) {
+			status_line_bold("No match");
+		} else {
+			dot_skip_over_ws();
+#  if ENABLE_FEATURE_VI_VERBOSE_STATUS
+			if (subs > 1)
+				status_line("%d substitutions on %d lines", subs, lines);
+#  endif
+		}
+#  if ENABLE_FEATURE_VI_REGEX_SEARCH
+ regex_search_end:
+		regfree(&preg);
+#  endif
 # endif /* FEATURE_VI_SEARCH */
 	} else if (strncmp(cmd, "version", i) == 0) {  // show software version
 		status_line(BB_VER);
 	} else if (strncmp(cmd, "write", i) == 0  // write text to file
-	        || strncmp(cmd, "wq", i) == 0
-	        || strncmp(cmd, "wn", i) == 0
+	        || strcmp(cmd, "wq") == 0
+	        || strcmp(cmd, "wn") == 0
 	        || (cmd[0] == 'x' && !cmd[1])
 	) {
 		int size;
@@ -2825,10 +3296,21 @@ static void colon(char *buf)
 
 		// is there a file name to write to?
 		if (args[0]) {
-			fn = args;
+			struct stat statbuf;
+
+			exp = expand_args(args);
+			if (exp == NULL)
+				goto ret;
+			if (!useforce && (fn == NULL || strcmp(fn, exp) != 0) &&
+					stat(exp, &statbuf) == 0) {
+				status_line_bold("File exists (:w! overrides)");
+				goto ret;
+			}
+			fn = exp;
+			init_filename(fn);
 		}
 # if ENABLE_FEATURE_VI_READONLY
-		if (readonly_mode && !useforce) {
+		else if (readonly_mode && !useforce && fn) {
 			status_line_bold("'%s' is read only", fn);
 			goto ret;
 		}
@@ -2864,10 +3346,20 @@ static void colon(char *buf)
 					modified_count = 0;
 					last_modified_count = -1;
 				}
-				if (cmd[0] == 'x'
-				 || cmd[1] == 'q' || cmd[1] == 'n'
-				 || cmd[1] == 'Q' || cmd[1] == 'N'
-				) {
+				if (cmd[1] == 'n') {
+					editing = 0;
+				} else if (cmd[0] == 'x' || cmd[1] == 'q') {
+					// are there other files to edit?
+					int n = cmdline_filecnt - optind - 1;
+					if (n > 0) {
+						if (useforce) {
+							// force end of argv list
+							optind = cmdline_filecnt;
+						} else {
+							status_line_bold("%u more file(s) to edit", n);
+							goto ret;
+						}
+					}
 					editing = 0;
 				}
 			}
@@ -2878,7 +3370,7 @@ static void colon(char *buf)
 			q = begin_line(dot);	// assume .,. for the range
 			r = end_line(dot);
 		}
-		text_yank(q, r, YDreg);
+		text_yank(q, r, YDreg, WHOLE);
 		li = count_lines(q, r);
 		status_line("Yank %d lines (%d chars) into [%c]",
 				li, strlen(reg[YDreg]), what_reg());
@@ -2888,6 +3380,9 @@ static void colon(char *buf)
 		not_implemented(cmd);
 	}
  ret:
+# if ENABLE_FEATURE_VI_COLON_EXPAND
+	free(exp);
+# endif
 	dot = bound_dot(dot);	// make sure "dot" is valid
 	return;
 # if ENABLE_FEATURE_VI_SEARCH
@@ -3001,80 +3496,114 @@ static void int_handler(int sig)
 
 static void do_cmd(int c);
 
-static int find_range(char **start, char **stop, char c)
+static int at_eof(const char *s)
 {
-	char *save_dot, *p, *q, *t;
-	int cnt, multiline = 0, forward;
+	// does 's' point to end of file, even with no terminating newline?
+	return ((s == end - 2 && s[1] == '\n') || s == end - 1);
+}
+
+static int find_range(char **start, char **stop, int cmd)
+{
+	char *p, *q, *t;
+	int buftype = -1;
+	int c;
 
-	save_dot = dot;
 	p = q = dot;
 
-	// will a 'G' command move forwards or backwards?
-	forward = cmdcnt == 0 || cmdcnt > count_lines(text, dot);
+#if ENABLE_FEATURE_VI_YANKMARK
+	if (cmd == 'Y') {
+		c = 'y';
+	} else
+#endif
+	{
+		c = get_motion_char();
+	}
 
-	if (strchr("cdy><", c)) {
+#if ENABLE_FEATURE_VI_YANKMARK
+	if ((cmd == 'Y' || cmd == c) && strchr("cdy><", c)) {
+#else
+	if (cmd == c && strchr("cd><", c)) {
+#endif
 		// these cmds operate on whole lines
-		p = q = begin_line(p);
-		for (cnt = 1; cnt < cmdcnt; cnt++) {
-			q = next_line(q);
-		}
-		q = end_line(q);
-	} else if (strchr("^%$0bBeEfth\b\177", c)) {
-		// These cmds operate on char positions
+		buftype = WHOLE;
+		if (--cmdcnt > 0) {
+			do_cmd('j');
+			if (cmd_error)
+				buftype = -1;
+		}
+	} else if (strchr("^%$0bBeEfFtThnN/?|{}\b\177", c)) {
+		// Most operate on char positions within a line.  Of those that
+		// don't '%' needs no special treatment, search commands are
+		// marked as MULTI and  "{}" are handled below.
+		buftype = strchr("nN/?", c) ? MULTI : PARTIAL;
 		do_cmd(c);		// execute movement cmd
-		q = dot;
+		if (p == dot)	// no movement is an error
+			buftype = -1;
 	} else if (strchr("wW", c)) {
+		buftype = MULTI;
 		do_cmd(c);		// execute movement cmd
-		// if we are at the next word's first char
-		// step back one char
-		// but check the possibilities when it is true
-		if (dot > text && ((isspace(dot[-1]) && !isspace(dot[0]))
-				|| (ispunct(dot[-1]) && !ispunct(dot[0]))
-				|| (isalnum(dot[-1]) && !isalnum(dot[0]))))
-			dot--;		// move back off of next word
-		if (dot > text && *dot == '\n')
-			dot--;		// stay off NL
-		q = dot;
-	} else if (strchr("H-k{", c) || (c == 'G' && !forward)) {
-		// these operate on multi-lines backwards
-		q = end_line(dot);	// find NL
+		// step back one char, but not if we're at end of file,
+		// or if we are at EOF and search was for 'w' and we're at
+		// the start of a 'W' word.
+		if (dot > p && (!at_eof(dot) || (c == 'w' && ispunct(*dot))))
+			dot--;
+		t = dot;
+		// don't include trailing WS as part of word
+		while (dot > p && isspace(*dot)) {
+			if (*dot-- == '\n')
+				t = dot;
+		}
+		// for non-change operations WS after NL is not part of word
+		if (cmd != 'c' && dot != t && *dot != '\n')
+			dot = t;
+	} else if (strchr("GHL+-gjk'\r\n", c)) {
+		// these operate on whole lines
+		buftype = WHOLE;
 		do_cmd(c);		// execute movement cmd
-		dot_begin();
-		p = dot;
-	} else if (strchr("L+j}\r\n", c) || (c == 'G' && forward)) {
-		// these operate on multi-lines forwards
-		p = begin_line(dot);
+		if (cmd_error)
+			buftype = -1;
+	} else if (c == ' ' || c == 'l') {
+		// forward motion by character
+		int tmpcnt = (cmdcnt ?: 1);
+		buftype = PARTIAL;
 		do_cmd(c);		// execute movement cmd
-		dot_end();		// find NL
-		q = dot;
-	} else {
-		// nothing -- this causes any other values of c to
-		// represent the one-character range under the
-		// cursor.  this is correct for ' ' and 'l', but
-		// perhaps no others.
-		//
+		// exclude last char unless range isn't what we expected
+		// this indicates we've hit EOL
+		if (tmpcnt == dot - p)
+			dot--;
 	}
+
+	if (buftype == -1) {
+		if (c != 27)
+			indicate_error();
+		return buftype;
+	}
+
+	q = dot;
 	if (q < p) {
 		t = q;
 		q = p;
 		p = t;
 	}
 
-	// backward char movements don't include start position
-	if (q > p && strchr("^0bBh\b\177", c)) q--;
-
-	multiline = 0;
-	for (t = p; t <= q; t++) {
-		if (*t == '\n') {
-			multiline = 1;
-			break;
+	// movements which don't include end of range
+	if (q > p) {
+		if (strchr("^0bBFThnN/?|\b\177", c)) {
+			q--;
+		} else if (strchr("{}", c)) {
+			buftype = (p == begin_line(p) && (*q == '\n' || at_eof(q))) ?
+							WHOLE : MULTI;
+			if (!at_eof(q)) {
+				q--;
+				if (q > p && p != begin_line(p))
+					q--;
+			}
 		}
 	}
 
 	*start = p;
 	*stop = q;
-	dot = save_dot;
-	return multiline;
+	return buftype;
 }
 
 //---------------------------------------------------------------------
@@ -3105,11 +3634,20 @@ static void do_cmd(int c)
 	int dir;
 	int cnt, i, j;
 	int c1;
+#if ENABLE_FEATURE_VI_YANKMARK
+	char *orig_dot = dot;
+#endif
+#if ENABLE_FEATURE_VI_UNDO
+	int allow_undo = ALLOW_UNDO;
+	int undo_del = UNDO_DEL;
+#endif
 
 //	c1 = c; // quiet the compiler
 //	cnt = yf = 0; // quiet the compiler
 //	p = q = save_dot = buf; // quiet the compiler
 	memset(buf, '\0', sizeof(buf));
+	keep_index = FALSE;
+	cmd_error = FALSE;
 
 	show_status_line();
 
@@ -3139,7 +3677,7 @@ static void do_cmd(int c)
 		} else {
 			if (1 <= c || Isprint(c)) {
 				if (c != 27)
-					dot = yank_delete(dot, dot, 0, YANKDEL, ALLOW_UNDO);	// delete char
+					dot = yank_delete(dot, dot, PARTIAL, YANKDEL, ALLOW_UNDO);	// delete char
 				dot = char_insert(dot, c, ALLOW_UNDO_CHAIN);	// insert new char
 			}
 			goto dc1;
@@ -3185,11 +3723,9 @@ static void do_cmd(int c)
 		//case '*':	// *-
 		//case '=':	// =-
 		//case '@':	// @-
-		//case 'F':	// F-
 		//case 'K':	// K-
 		//case 'Q':	// Q-
 		//case 'S':	// S-
-		//case 'T':	// T-
 		//case 'V':	// V-
 		//case '[':	// [-
 		//case '\\':	// \-
@@ -3232,23 +3768,30 @@ static void do_cmd(int c)
 	case 10:			// Newline ^J
 	case 'j':			// j- goto next line, same col
 	case KEYCODE_DOWN:	// cursor key Down
+	case 13:			// Carriage Return ^M
+	case '+':			// +- goto next line
+		q = dot;
 		do {
-			dot_next();		// go to next B-o-l
-			// try stay in same col
-			dot = move_to_col(dot, ccol + offset);
+			p = next_line(q);
+			if (p == end_line(q)) {
+				indicate_error();
+				goto dc1;
+			}
+			q = p;
 		} while (--cmdcnt > 0);
+		dot = q;
+		if (c == 13 || c == '+') {
+			dot_skip_over_ws();
+		} else {
+			// try to stay in saved column
+			dot = cindex == C_END ? end_line(dot) : move_to_col(dot, cindex);
+			keep_index = TRUE;
+		}
 		break;
 	case 12:			// ctrl-L  force redraw whole screen
 	case 18:			// ctrl-R  force redraw
 		redraw(TRUE);	// this will redraw the entire display
 		break;
-	case 13:			// Carriage Return ^M
-	case '+':			// +- goto next line
-		do {
-			dot_next();
-			dot_skip_over_ws();
-		} while (--cmdcnt > 0);
-		break;
 	case 21:			// ctrl-U  scroll up half screen
 		dot_scroll((rows - 2) / 2, -1);
 		break;
@@ -3289,11 +3832,16 @@ static void do_cmd(int c)
 				dot = q;
 				dot_begin();	// go to B-o-l
 				dot_skip_over_ws();
+			} else {
+				indicate_error();
 			}
 		} else if (c1 == '\'') {	// goto previous context
 			dot = swap_context(dot);	// swap current and previous context
 			dot_begin();	// go to B-o-l
 			dot_skip_over_ws();
+#if ENABLE_FEATURE_VI_YANKMARK
+			orig_dot = dot;	// this doesn't update stored contexts
+#endif
 		} else {
 			indicate_error();
 		}
@@ -3318,12 +3866,14 @@ static void do_cmd(int c)
 			status_line_bold("Nothing in register %c", what_reg());
 			break;
 		}
+		cnt = 0;
+		i = cmdcnt ?: 1;
 		// are we putting whole lines or strings
-		if (strchr(p, '\n') != NULL) {
+		if (regtype[YDreg] == WHOLE) {
 			if (c == 'P') {
 				dot_begin();	// putting lines- Put above
 			}
-			if (c == 'p') {
+			else /* if ( c == 'p') */ {
 				// are we putting after very last line?
 				if (end_line(dot) == (end - 1)) {
 					dot = end;	// force dot to end of text[]
@@ -3334,8 +3884,22 @@ static void do_cmd(int c)
 		} else {
 			if (c == 'p')
 				dot_right();	// move to right, can move to NL
+			// how far to move cursor if register doesn't have a NL
+			if (strchr(p, '\n') == NULL)
+				cnt = i * strlen(p) - 1;
 		}
-		string_insert(dot, p, ALLOW_UNDO);	// insert the string
+		do {
+			// dot is adjusted if text[] is reallocated so we don't have to
+			string_insert(dot, p, allow_undo);	// insert the string
+# if ENABLE_FEATURE_VI_UNDO
+			allow_undo = ALLOW_UNDO_CHAIN;
+# endif
+		} while (--cmdcnt > 0);
+		dot += cnt;
+		dot_skip_over_ws();
+# if ENABLE_FEATURE_VI_YANKMARK && ENABLE_FEATURE_VI_VERBOSE_STATUS
+		yank_status("Put", p, i);
+# endif
 		end_cmd_q();	// stop adding to q
 		break;
 	case 'U':			// U- Undo; replace current line with original version
@@ -3346,6 +3910,9 @@ static void do_cmd(int c)
 			p += string_insert(p, reg[Ureg], ALLOW_UNDO_CHAIN);	// insert orig line
 			dot = p;
 			dot_skip_over_ws();
+# if ENABLE_FEATURE_VI_YANKMARK && ENABLE_FEATURE_VI_VERBOSE_STATUS
+			yank_status("Undo", reg[Ureg], 1);
+# endif
 		}
 		break;
 #endif /* FEATURE_VI_YANKMARK */
@@ -3362,6 +3929,8 @@ static void do_cmd(int c)
 				break;
 			dot_next();
 		}
+		cindex = C_END;
+		keep_index = TRUE;
 		break;
 	case '%':			// %- find matching char of pair () [] {}
 		for (q = dot; q < end && *q != '\n'; q++) {
@@ -3380,129 +3949,103 @@ static void do_cmd(int c)
 			indicate_error();
 		break;
 	case 'f':			// f- forward to a user specified char
-		last_forward_char = get_one_char();	// get the search char
-		//
-		// dont separate these two commands. 'f' depends on ';'
-		//
-		//**** fall through to ... ';'
-	case ';':			// ;- look at rest of line for last forward char
-		do {
-			if (last_forward_char == 0)
-				break;
-			q = dot + 1;
-			while (q < end - 1 && *q != '\n' && *q != last_forward_char) {
-				q++;
-			}
-			if (*q == last_forward_char)
-				dot = q;
-		} while (--cmdcnt > 0);
-		break;
-	case ',':           // repeat latest 'f' in opposite direction
-		if (last_forward_char == 0)
-			break;
-		do {
-			q = dot - 1;
-			while (q >= text && *q != '\n' && *q != last_forward_char) {
-				q--;
-			}
-			if (q >= text && *q == last_forward_char)
-				dot = q;
-		} while (--cmdcnt > 0);
-		break;
-
-	case '-':			// -- goto prev line
-		do {
-			dot_prev();
-			dot_skip_over_ws();
-		} while (--cmdcnt > 0);
+	case 'F':			// F- backward to a user specified char
+	case 't':			// t- move to char prior to next x
+	case 'T':			// T- move to char after previous x
+		last_search_char = get_one_char();	// get the search char
+		last_search_cmd = c;
+		// fall through
+	case ';':			// ;- look at rest of line for last search char
+	case ',':           // ,- repeat latest search in opposite direction
+		dot_to_char(c != ',' ? last_search_cmd : last_search_cmd ^ 0x20);
 		break;
 #if ENABLE_FEATURE_VI_DOT_CMD
 	case '.':			// .- repeat the last modifying command
 		// Stuff the last_modifying_cmd back into stdin
 		// and let it be re-executed.
 		if (lmc_len != 0) {
-			ioq = ioq_start = xstrndup(last_modifying_cmd, lmc_len);
+			if (cmdcnt)	// update saved count if current count is non-zero
+				dotcnt = cmdcnt;
+			last_modifying_cmd[lmc_len] = '\0';
+			ioq = ioq_start = xasprintf("%u%s", dotcnt, last_modifying_cmd);
 		}
 		break;
 #endif
 #if ENABLE_FEATURE_VI_SEARCH
-	case '?':			// /- search for a pattern
-	case '/':			// /- search for a pattern
+	case 'N':			// N- backward search for last pattern
+		dir = last_search_pattern[0] == '/' ? BACK : FORWARD;
+		goto dc4;		// now search for pattern
+		break;
+	case '?':			// ?- backward search for a pattern
+	case '/':			// /- forward search for a pattern
 		buf[0] = c;
 		buf[1] = '\0';
 		q = get_input_line(buf);	// get input line- use "status line"
-		if (q[0] && !q[1]) {
+		if (!q[0])	// user changed mind and erased the "/"-  do nothing
+			break;
+		if (!q[1]) {	// if no pat re-use old pat
 			if (last_search_pattern[0])
 				last_search_pattern[0] = c;
-			goto dc3; // if no pat re-use old pat
-		}
-		if (q[0]) {       // strlen(q) > 1: new pat- save it and find
-			// there is a new pat
+		} else {	// strlen(q) > 1: new pat- save it and find
 			free(last_search_pattern);
 			last_search_pattern = xstrdup(q);
-			goto dc3;	// now find the pattern
 		}
-		// user changed mind and erased the "/"-  do nothing
-		break;
-	case 'N':			// N- backward search for last pattern
-		dir = BACK;		// assume BACKWARD search
-		p = dot - 1;
-		if (last_search_pattern[0] == '?') {
-			dir = FORWARD;
-			p = dot + 1;
-		}
-		goto dc4;		// now search for pattern
-		break;
+		// fall through
 	case 'n':			// n- repeat search for last pattern
 		// search rest of text[] starting at next char
-		// if search fails return orignal "p" not the "p+1" address
-		do {
-			const char *msg;
- dc3:
-			dir = FORWARD;	// assume FORWARD search
-			p = dot + 1;
-			if (last_search_pattern[0] == '?') {
-				dir = BACK;
-				p = dot - 1;
-			}
+		// if search fails "dot" is unchanged
+		dir = last_search_pattern[0] == '/' ? FORWARD : BACK;
  dc4:
-			q = char_search(p, last_search_pattern + 1, (dir << 1) | FULL);
+		if (last_search_pattern[1] == '\0') {
+			status_line_bold("No previous search");
+			break;
+		}
+		do {
+			q = char_search(dot + dir, last_search_pattern + 1,
+						(dir << 1) | FULL);
 			if (q != NULL) {
 				dot = q;	// good search, update "dot"
-				msg = NULL;
-				goto dc2;
-			}
-			// no pattern found between "dot" and "end"- continue at top
-			p = text;
-			if (dir == BACK) {
-				p = end - 1;
-			}
-			q = char_search(p, last_search_pattern + 1, (dir << 1) | FULL);
-			if (q != NULL) {	// found something
-				dot = q;	// found new pattern- goto it
-				msg = "search hit BOTTOM, continuing at TOP";
-				if (dir == BACK) {
-					msg = "search hit TOP, continuing at BOTTOM";
-				}
 			} else {
-				msg = "Pattern not found";
+				// no pattern found between "dot" and top/bottom of file
+				// continue from other end of file
+				const char *msg;
+				q = char_search(dir == FORWARD ? text : end - 1,
+						last_search_pattern + 1, (dir << 1) | FULL);
+				if (q != NULL) {	// found something
+					dot = q;	// found new pattern- goto it
+					msg = "search hit %s, continuing at %s";
+				} else {	// pattern is nowhere in file
+					cmdcnt = 0;	// force exit from loop
+					msg = "Pattern not found";
+				}
+				if (dir == FORWARD)
+					status_line_bold(msg, "BOTTOM", "TOP");
+				else
+					status_line_bold(msg, "TOP", "BOTTOM");
 			}
- dc2:
-			if (msg)
-				status_line_bold("%s", msg);
 		} while (--cmdcnt > 0);
 		break;
 	case '{':			// {- move backward paragraph
-		q = char_search(dot, "\n\n", ((unsigned)BACK << 1) | FULL);
-		if (q != NULL) {	// found blank line
-			dot = next_line(q);	// move to next blank line
-		}
-		break;
 	case '}':			// }- move forward paragraph
-		q = char_search(dot, "\n\n", (FORWARD << 1) | FULL);
-		if (q != NULL) {	// found blank line
-			dot = next_line(q);	// move to next blank line
-		}
+		dir = c == '}' ? FORWARD : BACK;
+		do {
+			int skip = TRUE; // initially skip consecutive empty lines
+			while (dir == FORWARD ? dot < end - 1 : dot > text) {
+				if (*dot == '\n' && dot[dir] == '\n') {
+					if (!skip) {
+						if (dir == FORWARD)
+							++dot;	// move to next blank line
+						goto dc2;
+					}
+				}
+				else {
+					skip = FALSE;
+				}
+				dot += dir;
+			}
+			goto dc6; // end of file
+ dc2:		continue;
+		} while (--cmdcnt > 0);
 		break;
 #endif /* FEATURE_VI_SEARCH */
 	case '0':			// 0- goto beginning of line
@@ -3528,28 +4071,31 @@ static void do_cmd(int c)
 	case '<':			// <- Left  shift something
 	case '>':			// >- Right shift something
 		cnt = count_lines(text, dot);	// remember what line we are on
-		c1 = get_one_char();	// get the type of thing to delete
-		find_range(&p, &q, c1);
-		yank_delete(p, q, 1, YANKONLY, NO_UNDO);	// save copy before change
-		p = begin_line(p);
-		q = end_line(q);
+		if (find_range(&p, &q, c) == -1)
+			goto dc6;
 		i = count_lines(p, q);	// # of lines we are shifting
-		for ( ; i > 0; i--, p = next_line(p)) {
+		for (p = begin_line(p); i > 0; i--, p = next_line(p)) {
 			if (c == '<') {
-				// shift left- remove tab or 8 spaces
+				// shift left- remove tab or tabstop spaces
 				if (*p == '\t') {
 					// shrink buffer 1 char
-					text_hole_delete(p, p, NO_UNDO);
+					text_hole_delete(p, p, allow_undo);
 				} else if (*p == ' ') {
 					// we should be calculating columns, not just SPACE
 					for (j = 0; *p == ' ' && j < tabstop; j++) {
-						text_hole_delete(p, p, NO_UNDO);
+						text_hole_delete(p, p, allow_undo);
+#if ENABLE_FEATURE_VI_UNDO
+						allow_undo = ALLOW_UNDO_CHAIN;
+#endif
 					}
 				}
-			} else if (c == '>') {
-				// shift right -- add tab or 8 spaces
-				char_insert(p, '\t', ALLOW_UNDO);
+			} else /* if (c == '>') */ {
+				// shift right -- add tab or tabstop spaces
+				char_insert(p, '\t', allow_undo);
 			}
+#if ENABLE_FEATURE_VI_UNDO
+			allow_undo = ALLOW_UNDO_CHAIN;
+#endif
 		}
 		dot = find_line(cnt);	// what line were we on
 		dot_skip_over_ws();
@@ -3583,7 +4129,7 @@ static void do_cmd(int c)
 		save_dot = dot;
 		dot = dollar_line(dot);	// move to before NL
 		// copy text into a register and delete
-		dot = yank_delete(save_dot, dot, 0, YANKDEL, ALLOW_UNDO);	// delete to e-o-l
+		dot = yank_delete(save_dot, dot, PARTIAL, YANKDEL, ALLOW_UNDO);	// delete to e-o-l
 		if (c == 'C')
 			goto dc_i;	// start inserting
 #if ENABLE_FEATURE_VI_DOT_CMD
@@ -3600,6 +4146,7 @@ static void do_cmd(int c)
 			buf[1] = (c1 >= 0 ? c1 : '*');
 			buf[2] = '\0';
 			not_implemented(buf);
+			cmd_error = TRUE;
 			break;
 		}
 		if (cmdcnt == 0)
@@ -3610,6 +4157,7 @@ static void do_cmd(int c)
 		if (cmdcnt > 0) {
 			dot = find_line(cmdcnt);	// what line is #cmdcnt
 		}
+		dot_begin();
 		dot_skip_over_ws();
 		break;
 	case 'H':			// H- goto top line on screen
@@ -3617,9 +4165,10 @@ static void do_cmd(int c)
 		if (cmdcnt > (rows - 1)) {
 			cmdcnt = (rows - 1);
 		}
-		if (--cmdcnt > 0) {
-			do_cmd('+');
+		while (--cmdcnt > 0) {
+			dot_next();
 		}
+		dot_begin();
 		dot_skip_over_ws();
 		break;
 	case 'I':			// I- insert before first non-blank
@@ -3656,8 +4205,8 @@ static void do_cmd(int c)
 		if (cmdcnt > (rows - 1)) {
 			cmdcnt = (rows - 1);
 		}
-		if (--cmdcnt > 0) {
-			do_cmd('-');
+		while (--cmdcnt > 0) {
+			dot_prev();
 		}
 		dot_begin();
 		dot_skip_over_ws();
@@ -3666,19 +4215,21 @@ static void do_cmd(int c)
 		dot = screenbegin;
 		for (cnt = 0; cnt < (rows-1) / 2; cnt++)
 			dot = next_line(dot);
+		dot_skip_over_ws();
 		break;
-	case 'O':			// O- open a empty line above
-		//    0i\n ESC -i
-		p = begin_line(dot);
-		if (p[-1] == '\n') {
+	case 'O':			// O- open an empty line above
+		dot_begin();
+#if ENABLE_FEATURE_VI_SETOPTS
+		indentcol = -1;
+#endif
+		goto dc3;
+	case 'o':			// o- open an empty line below
+		dot_end();
+ dc3:
+		dot = char_insert(dot, '\n', ALLOW_UNDO);
+		if (c == 'O' && !autoindent) {
+			// done in char_insert() for 'O'+autoindent
 			dot_prev();
-	case 'o':			// o- open a empty line below; Yes, I know it is in the middle of the "if (..."
-			dot_end();
-			dot = char_insert(dot, '\n', ALLOW_UNDO);
-		} else {
-			dot_begin();	// 0
-			dot = char_insert(dot, '\n', ALLOW_UNDO);	// i\n ESC
-			dot_prev();	// -
 		}
 		goto dc_i;
 		break;
@@ -3689,7 +4240,7 @@ static void do_cmd(int c)
 		break;
 	case KEYCODE_DELETE:
 		if (dot < end - 1)
-			dot = yank_delete(dot, dot, 1, YANKDEL, ALLOW_UNDO);
+			dot = yank_delete(dot, dot, PARTIAL, YANKDEL, ALLOW_UNDO);
 		break;
 	case 'X':			// X- delete char before dot
 	case 'x':			// x- delete the current char
@@ -3701,7 +4252,10 @@ static void do_cmd(int c)
 			if (dot[dir] != '\n') {
 				if (c == 'X')
 					dot--;	// delete prev char
-				dot = yank_delete(dot, dot, 0, YANKDEL, ALLOW_UNDO);	// delete char
+				dot = yank_delete(dot, dot, PARTIAL, YANKDEL, allow_undo);	// delete char
+#if ENABLE_FEATURE_VI_UNDO
+				allow_undo = ALLOW_UNDO_CHAIN;
+#endif
 			}
 		} while (--cmdcnt > 0);
 		end_cmd_q();	// stop adding to q
@@ -3716,7 +4270,7 @@ static void do_cmd(int c)
 			break;
 		}
 		if (modified_count) {
-			if (ENABLE_FEATURE_VI_READONLY && readonly_mode) {
+			if (ENABLE_FEATURE_VI_READONLY && readonly_mode && current_filename) {
 				status_line_bold("'%s' is read only", current_filename);
 				break;
 			}
@@ -3730,6 +4284,14 @@ static void do_cmd(int c)
 		} else {
 			editing = 0;
 		}
+		// are there other files to edit?
+		j = cmdline_filecnt - optind - 1;
+		if (editing == 0 && j > 0) {
+			editing = 1;
+			modified_count = 0;
+			last_modified_count = -1;
+			status_line_bold("%u more file(s) to edit", j);
+		}
 		break;
 	case '^':			// ^- move to first non-blank on line
 		dot_begin();
@@ -3761,103 +4323,91 @@ static void do_cmd(int c)
 	case 'Y':			// Y- Yank a line
 #endif
 	{
-		int yf, ml, whole = 0;
-		yf = YANKDEL;	// assume either "c" or "d"
+		int yf = YANKDEL;	// assume either "c" or "d"
+		int buftype;
 #if ENABLE_FEATURE_VI_YANKMARK
+# if ENABLE_FEATURE_VI_VERBOSE_STATUS
+		char *savereg = reg[YDreg];
+# endif
 		if (c == 'y' || c == 'Y')
 			yf = YANKONLY;
 #endif
-		c1 = 'y';
-		if (c != 'Y')
-			c1 = get_one_char();	// get the type of thing to delete
 		// determine range, and whether it spans lines
-		ml = find_range(&p, &q, c1);
-		place_cursor(0, 0);
-		if (c1 == 27) {	// ESC- user changed mind and wants out
-			c = c1 = 27;	// Escape- do nothing
-		} else if (strchr("wW", c1)) {
-			ml = 0;	// multi-line ranges aren't allowed for words
-			if (c == 'c') {
-				// don't include trailing WS as part of word
-				while (isspace(*q) && q > p) {
-					q--;
-				}
-			}
-			dot = yank_delete(p, q, ml, yf, ALLOW_UNDO);	// delete word
-		} else if (strchr("^0bBeEft%$ lh\b\177", c1)) {
-			// partial line copy text into a register and delete
-			dot = yank_delete(p, q, ml, yf, ALLOW_UNDO);	// delete word
-		} else if (strchr("cdykjGHL+-{}\r\n", c1)) {
-			// whole line copy text into a register and delete
-			dot = yank_delete(p, q, ml, yf, ALLOW_UNDO);	// delete lines
-			whole = 1;
-		} else {
-			// could not recognize object
-			c = c1 = 27;	// error-
-			ml = 0;
-			indicate_error();
+		buftype = find_range(&p, &q, c);
+		if (buftype == -1)	// invalid range
+			goto dc6;
+		if (buftype == WHOLE) {
+			save_dot = p;	// final cursor position is start of range
+			p = begin_line(p);
+			q = end_line(q);
 		}
-		if (ml && whole) {
+		dot = yank_delete(p, q, buftype, yf, ALLOW_UNDO);	// delete word
+		if (buftype == WHOLE) {
 			if (c == 'c') {
 				dot = char_insert(dot, '\n', ALLOW_UNDO_CHAIN);
 				// on the last line of file don't move to prev line
-				if (whole && dot != (end-1)) {
+				if (dot != (end-1)) {
 					dot_prev();
 				}
 			} else if (c == 'd') {
 				dot_begin();
 				dot_skip_over_ws();
+			} else {
+				dot = save_dot;
 			}
 		}
-		if (c1 != 27) {
-			// if CHANGING, not deleting, start inserting after the delete
-			if (c == 'c') {
-				strcpy(buf, "Change");
-				goto dc_i;	// start inserting
-			}
-			if (c == 'd') {
-				strcpy(buf, "Delete");
-			}
-#if ENABLE_FEATURE_VI_YANKMARK
-			if (c == 'y' || c == 'Y') {
-				strcpy(buf, "Yank");
-			}
-			p = reg[YDreg];
-			q = p + strlen(p);
-			for (cnt = 0; p <= q; p++) {
-				if (*p == '\n')
-					cnt++;
-			}
-			status_line("%s %u lines (%u chars) using [%c]",
-				buf, cnt, (unsigned)strlen(reg[YDreg]), what_reg());
-#endif
-			end_cmd_q();	// stop adding to q
+		// if CHANGING, not deleting, start inserting after the delete
+		if (c == 'c') {
+			goto dc_i;	// start inserting
 		}
+#if ENABLE_FEATURE_VI_YANKMARK && ENABLE_FEATURE_VI_VERBOSE_STATUS
+		// only update status if a yank has actually happened
+		if (reg[YDreg] != savereg)
+			yank_status(c == 'd' ? "Delete" : "Yank", reg[YDreg], 1);
+#endif
+ dc6:
+		end_cmd_q();	// stop adding to q
 		break;
 	}
 	case 'k':			// k- goto prev line, same col
 	case KEYCODE_UP:		// cursor key Up
+	case '-':			// -- goto prev line
+		q = dot;
 		do {
-			dot_prev();
-			dot = move_to_col(dot, ccol + offset);	// try stay in same col
+			p = prev_line(q);
+			if (p == begin_line(q)) {
+				indicate_error();
+				goto dc1;
+			}
+			q = p;
 		} while (--cmdcnt > 0);
+		dot = q;
+		if (c == '-') {
+			dot_skip_over_ws();
+		} else {
+			// try to stay in saved column
+			dot = cindex == C_END ? end_line(dot) : move_to_col(dot, cindex);
+			keep_index = TRUE;
+		}
 		break;
 	case 'r':			// r- replace the current char with user input
 		c1 = get_one_char();	// get the replacement char
-		if (*dot != '\n') {
-			dot = text_hole_delete(dot, dot, ALLOW_UNDO);
-			dot = char_insert(dot, c1, ALLOW_UNDO_CHAIN);
+		if (c1 != 27) {
+			if (end_line(dot) - dot < (cmdcnt ?: 1)) {
+				indicate_error();
+				goto dc6;
+			}
+			do {
+				dot = text_hole_delete(dot, dot, allow_undo);
+#if ENABLE_FEATURE_VI_UNDO
+				allow_undo = ALLOW_UNDO_CHAIN;
+#endif
+				dot = char_insert(dot, c1, allow_undo);
+			} while (--cmdcnt > 0);
 			dot_left();
 		}
 		end_cmd_q();	// stop adding to q
 		break;
-	case 't':			// t- move to char prior to next x
-		last_forward_char = get_one_char();
-		do_cmd(';');
-		if (*dot == last_forward_char)
-			dot_left();
-		last_forward_char = 0;
-		break;
 	case 'w':			// w- forward a word
 		do {
 			if (isalnum(*dot) || *dot == '_') {	// we are on ALNUM
@@ -3888,14 +4438,11 @@ static void do_cmd(int c)
 	case '~':			// ~- flip the case of letters   a-z -> A-Z
 		do {
 #if ENABLE_FEATURE_VI_UNDO
-			if (islower(*dot)) {
-				undo_push(dot, 1, UNDO_DEL);
-				*dot = toupper(*dot);
-				undo_push(dot, 1, UNDO_INS_CHAIN);
-			} else if (isupper(*dot)) {
-				undo_push(dot, 1, UNDO_DEL);
-				*dot = tolower(*dot);
+			if (isalpha(*dot)) {
+				undo_push(dot, 1, undo_del);
+				*dot = islower(*dot) ? toupper(*dot) : tolower(*dot);
 				undo_push(dot, 1, UNDO_INS_CHAIN);
+				undo_del = UNDO_DEL_CHAIN;
 			}
 #else
 			if (islower(*dot)) {
@@ -3943,7 +4490,8 @@ static void do_cmd(int c)
 		dot = bound_dot(dot);	// make sure "dot" is valid
 	}
 #if ENABLE_FEATURE_VI_YANKMARK
-	check_context(c);	// update the current context
+	if (dot != orig_dot)
+		check_context(c);	// update the current context
 #endif
 
 	if (!isdigit(c))
@@ -4201,7 +4749,6 @@ static void edit_file(char *fn)
 	mark[26] = mark[27] = text;	// init "previous context"
 #endif
 
-	last_forward_char = '\0';
 #if ENABLE_FEATURE_VI_CRASHME
 	last_input_char = '\0';
 #endif
@@ -4222,13 +4769,11 @@ static void edit_file(char *fn)
 
 	cmd_mode = 0;		// 0=command  1=insert  2='R'eplace
 	cmdcnt = 0;
-	tabstop = 8;
 	offset = 0;			// no horizontal offset
 	c = '\0';
 #if ENABLE_FEATURE_VI_DOT_CMD
 	free(ioq_start);
 	ioq_start = NULL;
-	lmc_len = 0;
 	adding2q = 0;
 #endif
 
@@ -4276,7 +4821,7 @@ static void edit_file(char *fn)
 		// save a copy of the current line- for the 'U" command
 		if (begin_line(dot) != cur_line) {
 			cur_line = begin_line(dot);
-			text_yank(begin_line(dot), end_line(dot), Ureg);
+			text_yank(begin_line(dot), end_line(dot), Ureg, PARTIAL);
 		}
 #endif
 #if ENABLE_FEATURE_VI_DOT_CMD
@@ -4339,10 +4884,10 @@ int vi_main(int argc, char **argv)
 	}
 #endif
 
-	// autoindent is not default in vim 7.3
-	vi_setops = /*VI_AUTOINDENT |*/ VI_SHOWMATCH | VI_IGNORECASE;
-	//  1-  process $HOME/.exrc file (not inplemented yet)
-	//  2-  process EXINIT variable from environment
+	// 0: all of our options are disabled by default in vim
+	//vi_setops = 0;
+	//  1-  process EXINIT variable from environment
+	//  2-  if EXINIT is unset process $HOME/.exrc file (not inplemented yet)
 	//  3-  process command line args
 #if ENABLE_FEATURE_VI_COLON
 	{
@@ -4351,7 +4896,11 @@ int vi_main(int argc, char **argv)
 			initial_cmds[0] = xstrndup(p, MAX_INPUT_LEN);
 	}
 #endif
-	while ((c = getopt(argc, argv, "hCRH" IF_FEATURE_VI_COLON("c:"))) != -1) {
+	while ((c = getopt(argc, argv,
+#if ENABLE_FEATURE_VI_CRASHME
+			"C"
+#endif
+			"RHh" IF_FEATURE_VI_COLON("c:"))) != -1) {
 		switch (c) {
 #if ENABLE_FEATURE_VI_CRASHME
 		case 'C':
diff -urpN busybox-1.33.1/examples/udhcp/udhcpd.conf busybox-1.34.0/examples/udhcp/udhcpd.conf
--- busybox-1.33.1/examples/udhcp/udhcpd.conf	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/examples/udhcp/udhcpd.conf	2021-06-16 17:02:16.000000000 +0700
@@ -79,7 +79,7 @@ option	staticroutes	10.0.0.0/8 10.127.0.
 option	0x08	01020304	# option 8: "cookie server IP addr: 1.2.3.4"
 option	14	"dumpfile"
 
-# Currently supported options [hex option value] (for more info, see options.c):
+# Currently supported options [hex option value] (for more info, see common.c):
 #opt lease      NUM             # [0x33]
 #opt subnet     IP              # [0x01]
 #opt broadcast  IP              # [0x1c]
@@ -91,17 +91,20 @@ option	14	"dumpfile"
 #opt search     STRING_LIST     # [0x77] search domains
 #opt nisdomain  STRING          # [0x28]
 #opt timezone   NUM             # [0x02] (localtime - UTC_time) in seconds. signed
+#opt tzstr      STRING          # [0x64] RFC 4833. IEEE 1003.1 TZ string
+#opt tzdbstr    STRING          # [0x65] RFC 4833. Reference to the TZ database string
 #opt tftp       STRING          # [0x42] tftp server name
 #opt bootfile   STRING          # [0x43] tftp file to download (e.g. kernel image)
 #opt bootsize   NUM             # [0x0d] size of that file
 #opt rootpath   STRING          # [0x11] (NFS) path to mount as root fs
 #opt wpad       STRING          # [0xfc] Web Proxy Auto Discovery Protocol
 #opt serverid   IP              # [0x36] default: server's IP
-#opt message    STRING          # [0x38] error message (udhcpd sends it on success too)
+#opt message    STRING          # [0x38] error message (if set, udhcpd would send it on success too)
 #opt vlanid     NUM             # [0x84] 802.1P VLAN ID
 #opt vlanpriority NUM           # [0x85] 802.1Q VLAN priority
+#opt vendor     STRING          # [0x3c] client's vendor string, not intended to be sent by DHCP servers
 # RFC 5071: PXELINUX Options
-#opt 0xd0       F100747E        # [0xd0] magic
+#opt 0xd0       F100747E        # [0xd0] magic needed for other options to be recognized by clients
 #opt pxeconffile STRING         # [0xd1]
 #opt pxepathprefix STRING       # [0xd2]
 #opt reboottime NUM             # [0xd3] bootstrap timeout
diff -urpN busybox-1.33.1/findutils/grep.c busybox-1.34.0/findutils/grep.c
--- busybox-1.33.1/findutils/grep.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/findutils/grep.c	2021-07-20 21:57:20.000000000 +0700
@@ -57,14 +57,12 @@
 #include "common_bufsiz.h"
 #include "xregex.h"
 
-
-/* options */
 //usage:#define grep_trivial_usage
 //usage:       "[-HhnlLoqvsrRiwFE"
 //usage:	IF_EXTRA_COMPAT("z")
 //usage:       "] [-m N] "
-//usage:	IF_FEATURE_GREP_CONTEXT("[-A/B/C N] ")
-//usage:       "PATTERN/-e PATTERN.../-f FILE [FILE]..."
+//usage:	IF_FEATURE_GREP_CONTEXT("[-A|B|C N] ")
+//usage:       "{ PATTERN | -e PATTERN... | -f FILE... } [FILE]..."
 //usage:#define grep_full_usage "\n\n"
 //usage:       "Search for PATTERN in FILEs (or stdin)\n"
 //usage:     "\n	-H	Add 'filename:' prefix"
diff -urpN busybox-1.33.1/include/bb_e2fs_defs.h busybox-1.34.0/include/bb_e2fs_defs.h
--- busybox-1.33.1/include/bb_e2fs_defs.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/include/bb_e2fs_defs.h	2021-07-20 21:57:20.000000000 +0700
@@ -182,11 +182,12 @@ struct ext2_dx_countlimit {
 #define EXT2_NOTAIL_FL			0x00008000 /* file tail should not be merged */
 #define EXT2_DIRSYNC_FL			0x00010000 /* Synchronous directory modifications */
 #define EXT2_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
-#define EXT3_EXTENTS_FL			0x00080000 /* Inode uses extents */
-#define EXT2_RESERVED_FL		0x80000000 /* reserved for ext2 lib */
-
-#define EXT2_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define EXT2_FL_USER_MODIFIABLE		0x000080FF /* User modifiable flags */
+#define EXT2_EXTENT_FL			0x00080000 /* Extents */
+#define EXT2_VERITY_FL			0x00100000
+#define EXT2_NOCOW_FL			0x00800000 /* Do not cow file */
+#define EXT2_INLINE_DATA_FL		0x10000000
+#define EXT2_PROJINHERIT_FL		0x20000000
+#define EXT2_CASEFOLD_FL		0x40000000
 
 /*
  * ioctl commands
@@ -195,6 +196,18 @@ struct ext2_dx_countlimit {
 #define EXT2_IOC_SETFLAGS		_IOW('f', 2, long)
 #define EXT2_IOC_GETVERSION		_IOR('v', 1, long)
 #define EXT2_IOC_SETVERSION		_IOW('v', 2, long)
+//NB: despite "long" in defs above, these ioctls use an _int_!
+//passing them a pointer to long will read/write only int-sized data!
+struct ext2_fsxattr {
+	uint32_t	fsx_xflags;	/* xflags field value (get/set) */
+	uint32_t	fsx_extsize;	/* extsize field value (get/set)*/
+	uint32_t	fsx_nextents;	/* nextents field value (get)	*/
+	uint32_t	fsx_projid;	/* project identifier (get/set) */
+	uint32_t	fsx_cowextsize;	/* CoW extsize field value (get/set)*/
+	unsigned char	fsx_pad[8];
+};
+#define EXT2_IOC_FSGETXATTR		_IOR('X', 31, struct ext2_fsxattr)
+#define EXT2_IOC_FSSETXATTR		_IOW('X', 32, struct ext2_fsxattr)
 
 /*
  * Structure of an inode on the disk
diff -urpN busybox-1.33.1/include/dump.h busybox-1.34.0/include/dump.h
--- busybox-1.33.1/include/dump.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/include/dump.h	2021-07-20 21:57:20.000000000 +0700
@@ -32,8 +32,10 @@ typedef struct dumper_t {
 	off_t dump_skip;                /* bytes to skip */
 	int dump_length;                /* max bytes to read */
 	smallint dump_vflag;            /*enum dump_vflag_t*/
-	const char *eofstring;
 	FS *fshead;
+	const char *xxd_eofstring;
+	off_t address;           /* address/offset in stream */
+	long long xxd_displayoff;
 } dumper_t;
 
 dumper_t* alloc_dumper(void) FAST_FUNC;
diff -urpN busybox-1.33.1/include/libbb.h busybox-1.34.0/include/libbb.h
--- busybox-1.33.1/include/libbb.h	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/include/libbb.h	2021-07-20 21:57:20.000000000 +0700
@@ -106,7 +106,11 @@
 #  define updwtmpx updwtmp
 #  define _PATH_UTMPX _PATH_UTMP
 # else
-#  include <utmp.h>
+#  if !defined(__FreeBSD__)
+#   include <utmp.h>
+#  else
+#   define _PATH_UTMPX "/var/run/utx.active"
+#  endif
 #  include <utmpx.h>
 #  if defined _PATH_UTMP && !defined _PATH_UTMPX
 #   define _PATH_UTMPX _PATH_UTMP
@@ -188,6 +192,28 @@ int klogctl(int type, char *b, int len);
 # define BUFSIZ 4096
 #endif
 
+#if __GNUC_PREREQ(5,0)
+/* Since musl is apparently unable to get it right and would use
+ * a function call to a single-instruction function of "bswap %eax",
+ * reroute to gcc builtins:
+ */
+# undef  bswap_16
+# undef  bswap_32
+# undef  bswap_64
+# define bswap_16(x) __builtin_bswap16(x)
+# define bswap_32(x) __builtin_bswap32(x)
+# define bswap_64(x) __builtin_bswap64(x)
+# if BB_LITTLE_ENDIAN
+#   undef ntohs
+#   undef htons
+#   undef ntohl
+#   undef htonl
+#   define ntohs(x) __builtin_bswap16(x)
+#   define htons(x) __builtin_bswap16(x)
+#   define ntohl(x) __builtin_bswap32(x)
+#   define htonl(x) __builtin_bswap32(x)
+# endif
+#endif
 
 /* Busybox does not use threads, we can speed up stdio. */
 #ifdef HAVE_UNLOCKED_STDIO
@@ -424,23 +450,29 @@ enum {	/* cp.c, mv.c, install.c depend o
 	FILEUTILS_RECUR           = 1 << 2, /* -R */
 	FILEUTILS_FORCE           = 1 << 3, /* -f */
 	FILEUTILS_INTERACTIVE     = 1 << 4, /* -i */
-	FILEUTILS_MAKE_HARDLINK   = 1 << 5, /* -l */
-	FILEUTILS_MAKE_SOFTLINK   = 1 << 6, /* -s */
-	FILEUTILS_DEREF_SOFTLINK  = 1 << 7, /* -L */
-	FILEUTILS_DEREFERENCE_L0  = 1 << 8, /* -H */
+	FILEUTILS_NO_OVERWRITE    = 1 << 5, /* -n */
+	FILEUTILS_MAKE_HARDLINK   = 1 << 6, /* -l */
+	FILEUTILS_MAKE_SOFTLINK   = 1 << 7, /* -s */
+	FILEUTILS_DEREF_SOFTLINK  = 1 << 8, /* -L */
+	FILEUTILS_DEREFERENCE_L0  = 1 << 9, /* -H */
 	/* -a = -pdR (mapped in cp.c) */
 	/* -r = -dR  (mapped in cp.c) */
 	/* -P = -d   (mapped in cp.c) */
-	FILEUTILS_VERBOSE         = (1 << 12) * ENABLE_FEATURE_VERBOSE,	/* -v */
-	FILEUTILS_UPDATE          = 1 << 13, /* -u */
-	FILEUTILS_NO_TARGET_DIR	  = 1 << 14, /* -T */
+	FILEUTILS_VERBOSE         = (1 << 13) * ENABLE_FEATURE_VERBOSE,	/* -v */
+	FILEUTILS_UPDATE          = 1 << 14, /* -u */
+	FILEUTILS_NO_TARGET_DIR	  = 1 << 15, /* -T */
+	FILEUTILS_TARGET_DIR	  = 1 << 16, /* -t DIR */
 #if ENABLE_SELINUX
-	FILEUTILS_PRESERVE_SECURITY_CONTEXT = 1 << 15, /* -c */
+	FILEUTILS_PRESERVE_SECURITY_CONTEXT = 1 << 17, /* -c */
 #endif
-	FILEUTILS_RMDEST          = 1 << (16 - !ENABLE_SELINUX), /* --remove-destination */
-	/* bit 17 skipped for "cp --parents" */
-	FILEUTILS_REFLINK         = 1 << (18 - !ENABLE_SELINUX), /* cp --reflink=auto */
-	FILEUTILS_REFLINK_ALWAYS  = 1 << (19 - !ENABLE_SELINUX), /* cp --reflink[=always] */
+#define FILEUTILS_CP_OPTSTR "pdRfinlsLHarPvuTt:" IF_SELINUX("c")
+/* How many bits in FILEUTILS_CP_OPTSTR? */
+	FILEUTILS_CP_OPTBITS      = 18 - !ENABLE_SELINUX,
+
+	FILEUTILS_RMDEST          = 1 << (19 - !ENABLE_SELINUX), /* cp --remove-destination */
+	/* bit 18 skipped for "cp --parents" */
+	FILEUTILS_REFLINK         = 1 << (20 - !ENABLE_SELINUX), /* cp --reflink=auto */
+	FILEUTILS_REFLINK_ALWAYS  = 1 << (21 - !ENABLE_SELINUX), /* cp --reflink[=always] */
 	/*
 	 * Hole. cp may have some bits set here,
 	 * they should not affect remove_file()/copy_file()
@@ -450,7 +482,7 @@ enum {	/* cp.c, mv.c, install.c depend o
 #endif
 	FILEUTILS_IGNORE_CHMOD_ERR = 1 << 31,
 };
-#define FILEUTILS_CP_OPTSTR "pdRfilsLHarPvuT" IF_SELINUX("c")
+
 extern int remove_file(const char *path, int flags) FAST_FUNC;
 /* NB: without FILEUTILS_RECUR in flags, it will basically "cat"
  * the source, not copy (unless "source" is a directory).
@@ -480,6 +512,11 @@ int recursive_action(const char *fileNam
 	void *userData
 ) FAST_FUNC;
 
+/* Simpler version: call a function on each dirent in a directory */
+int iterate_on_dir(const char *dir_name,
+		int FAST_FUNC (*func)(const char *, struct dirent *, void *),
+		void *private) FAST_FUNC;
+
 extern int device_open(const char *device, int mode) FAST_FUNC;
 enum { GETPTY_BUFSIZE = 16 }; /* more than enough for "/dev/ttyXXX" */
 extern int xgetpty(char *line) FAST_FUNC;
@@ -567,7 +604,7 @@ void bb_signals(int sigs, void (*f)(int)
 /* Unlike signal() and bb_signals, sets handler with sigaction()
  * and in a way that while signal handler is run, no other signals
  * will be blocked; syscalls will not be restarted: */
-void bb_signals_recursive_norestart(int sigs, void (*f)(int)) FAST_FUNC;
+void bb_signals_norestart(int sigs, void (*f)(int)) FAST_FUNC;
 /* syscalls like read() will be interrupted with EINTR: */
 void signal_no_SA_RESTART_empty_mask(int sig, void (*handler)(int)) FAST_FUNC;
 /* syscalls like read() won't be interrupted (though select/poll will be): */
@@ -619,7 +656,7 @@ uoff_t FAST_FUNC get_volume_size_in_byte
 		unsigned override_units,
 		int extend);
 
-void xpipe(int filedes[2]) FAST_FUNC;
+void xpipe(int *filedes) FAST_FUNC;
 /* In this form code with pipes is much more readable */
 struct fd_pair { int rd; int wr; };
 #define piped_pair(pair)  pipe(&((pair).rd))
@@ -657,6 +694,7 @@ void parse_datestr(const char *date_str,
 time_t validate_tm_time(const char *date_str, struct tm *ptm) FAST_FUNC;
 char *strftime_HHMMSS(char *buf, unsigned len, time_t *tp) FAST_FUNC;
 char *strftime_YYYYMMDDHHMMSS(char *buf, unsigned len, time_t *tp) FAST_FUNC;
+void xgettimeofday(struct timeval *tv) FAST_FUNC;
 void xsettimeofday(const struct timeval *tv) FAST_FUNC;
 
 
@@ -869,6 +907,7 @@ char *xmalloc_substitute_string(const ch
 int bb_putchar(int ch) FAST_FUNC;
 /* Note: does not use stdio, writes to fd 2 directly */
 int bb_putchar_stderr(char ch) FAST_FUNC;
+int fputs_stdout(const char *s) FAST_FUNC;
 char *xasprintf(const char *format, ...) __attribute__ ((format(printf, 1, 2))) FAST_FUNC RETURNS_MALLOC;
 char *auto_string(char *str) FAST_FUNC;
 // gcc-4.1.1 still isn't good enough at optimizing it
@@ -1037,10 +1076,10 @@ char *smart_ulltoa5(unsigned long long u
 /* If block_size == 0, display size without fractional part,
  * else display (size * block_size) with one decimal digit.
  * If display_unit == 0, show value no bigger than 1024 with suffix (K,M,G...),
- * else divide by display_unit and do not use suffix. */
+ * else divide by display_unit and do not use suffix.
+ * Returns "auto pointer" */
 #define HUMAN_READABLE_MAX_WIDTH      7  /* "1024.0G" */
 #define HUMAN_READABLE_MAX_WIDTH_STR "7"
-//TODO: provide pointer to buf (avoid statics)?
 const char *make_human_readable_str(unsigned long long size,
 		unsigned long block_size, unsigned long display_unit) FAST_FUNC;
 /* Put a string of hex bytes ("1b2e66fe"...), return advanced pointer */
@@ -1213,6 +1252,7 @@ void run_noexec_applet_and_exit(int a, c
 int find_applet_by_name(const char *name) FAST_FUNC;
 void run_applet_no_and_exit(int a, const char *name, char **argv) NORETURN FAST_FUNC;
 #endif
+void show_usage_if_dash_dash_help(int applet_no, char **argv) FAST_FUNC;
 #if defined(__linux__)
 void set_task_comm(const char *comm) FAST_FUNC;
 #else
@@ -1744,6 +1784,7 @@ extern void print_login_issue(const char
 extern void print_login_prompt(void) FAST_FUNC;
 
 char *xmalloc_ttyname(int fd) FAST_FUNC RETURNS_MALLOC;
+int is_TERM_dumb(void) FAST_FUNC;
 /* NB: typically you want to pass fd 0, not 1. Think 'applet | grep something' */
 int get_terminal_width_height(int fd, unsigned *width, unsigned *height) FAST_FUNC;
 int get_terminal_width(int fd) FAST_FUNC;
diff -urpN busybox-1.33.1/include/platform.h busybox-1.34.0/include/platform.h
--- busybox-1.33.1/include/platform.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/include/platform.h	2021-06-16 17:02:16.000000000 +0700
@@ -195,6 +195,7 @@
 #endif
 
 #if ULONG_MAX > 0xffffffff
+/* inline 64-bit bswap only on 64-bit arches */
 # define bb_bswap_64(x) bswap_64(x)
 #endif
 
@@ -319,7 +320,7 @@ typedef unsigned smalluint;
 #endif
 
 /* Define bb_setpgrp */
-#if defined(__digital__) && defined(__unix__)
+#if (defined(__digital__) && defined(__unix__)) || defined(__FreeBSD__)
 /* use legacy setpgrp(pid_t, pid_t) for now.  move to platform.c */
 # define bb_setpgrp() do { pid_t __me = getpid(); setpgrp(__me, __me); } while (0)
 #else
@@ -407,6 +408,7 @@ typedef unsigned smalluint;
 #define HAVE_SETBIT 1
 #define HAVE_SIGHANDLER_T 1
 #define HAVE_STPCPY 1
+#define HAVE_STPNCPY 1
 #define HAVE_MEMPCPY 1
 #define HAVE_STRCASESTR 1
 #define HAVE_STRCHRNUL 1
@@ -423,6 +425,9 @@ typedef unsigned smalluint;
 #define HAVE_NET_ETHERNET_H 1
 #define HAVE_SYS_STATFS_H 1
 #define HAVE_PRINTF_PERCENTM 1
+#define HAVE_WAIT3 1
+#define HAVE_DEV_FD 1
+#define DEV_FD_PREFIX "/dev/fd/"
 
 #if defined(__UCLIBC__)
 # if UCLIBC_VERSION < KERNEL_VERSION(0, 9, 32)
@@ -442,6 +447,7 @@ typedef unsigned smalluint;
 # undef HAVE_MKDTEMP
 # undef HAVE_SETBIT
 # undef HAVE_STPCPY
+# undef HAVE_STPNCPY
 # undef HAVE_STRCASESTR
 # undef HAVE_STRCHRNUL
 # undef HAVE_STRSEP
@@ -514,6 +520,7 @@ typedef unsigned smalluint;
 
 #if defined(__digital__) && defined(__unix__)
 # undef HAVE_STPCPY
+# undef HAVE_STPNCPY
 #endif
 
 #if defined(ANDROID) || defined(__ANDROID__)
@@ -530,6 +537,10 @@ typedef unsigned smalluint;
 #  undef HAVE_TTYNAME_R
 #  undef HAVE_GETLINE
 #  undef HAVE_STPCPY
+#  undef HAVE_STPNCPY
+# endif
+# if __ANDROID_API__ >= 21
+#  undef HAVE_WAIT3
 # endif
 # undef HAVE_MEMPCPY
 # undef HAVE_STRCHRNUL
@@ -574,6 +585,10 @@ typedef void (*sighandler_t)(int);
 extern char *stpcpy(char *p, const char *to_add) FAST_FUNC;
 #endif
 
+#ifndef HAVE_STPNCPY
+extern char *stpncpy(char *p, const char *to_add, size_t n) FAST_FUNC;
+#endif
+
 #ifndef HAVE_MEMPCPY
 #include <string.h>
 /* In case we are wrong about !HAVE_MEMPCPY, and toolchain _does_ have
diff -urpN busybox-1.33.1/init/bootchartd.c busybox-1.34.0/init/bootchartd.c
--- busybox-1.33.1/init/bootchartd.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/init/bootchartd.c	2021-01-08 15:30:27.000000000 +0700
@@ -218,10 +218,10 @@ static char *make_tempdir(void)
 
 static void do_logging(unsigned sample_period_us, int process_accounting)
 {
-	FILE *proc_stat = xfopen("proc_stat.log", "w");
-	FILE *proc_diskstats = xfopen("proc_diskstats.log", "w");
-	//FILE *proc_netdev = xfopen("proc_netdev.log", "w");
-	FILE *proc_ps = xfopen("proc_ps.log", "w");
+	FILE *proc_stat = xfopen_for_write("proc_stat.log");
+	FILE *proc_diskstats = xfopen_for_write("proc_diskstats.log");
+	//FILE *proc_netdev = xfopen_for_write("proc_netdev.log");
+	FILE *proc_ps = xfopen_for_write("proc_ps.log");
 	int look_for_login_process = (getppid() == 1);
 	unsigned count = 60*1000*1000 / sample_period_us; /* ~1 minute */
 
@@ -268,7 +268,7 @@ static void finalize(char *tempdir, cons
 	//local pacct=
 	//[ -e kernel_pacct ] && pacct=kernel_pacct
 
-	FILE *header_fp = xfopen("header", "w");
+	FILE *header_fp = xfopen_for_write("header");
 
 	if (process_accounting)
 		acct(NULL);
diff -urpN busybox-1.33.1/klibc-utils/nuke.c busybox-1.34.0/klibc-utils/nuke.c
--- busybox-1.33.1/klibc-utils/nuke.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/klibc-utils/nuke.c	2021-01-08 15:30:27.000000000 +0700
@@ -5,7 +5,7 @@
  */
 //config:config NUKE
 //config:	bool "nuke (2.9 kb)"
-//config:	default y
+//config:	default n  # off by default: too "accidentally destructive"
 //config:	help
 //config:	Alias to "rm -rf".
 
diff -urpN busybox-1.33.1/klibc-utils/resume.c busybox-1.34.0/klibc-utils/resume.c
--- busybox-1.33.1/klibc-utils/resume.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/klibc-utils/resume.c	2021-04-15 00:05:01.000000000 +0700
@@ -103,10 +103,17 @@ int resume_main(int argc UNUSED_PARAM, c
 	if (major(resume_device) == 0) {
 		bb_error_msg_and_die("invalid resume device: %s", argv[0]);
 	}
+
 	ofs = (argv[1] ? xstrtoull(argv[1], 0) : 0);
+	/* Old kernels have no /sys/power/resume_offset, set it only if necessary */
+	if (ofs != 0) {
+		fd = xopen("/sys/power/resume_offset", O_WRONLY);
+		s = xasprintf("%llu", ofs);
+		xwrite_str(fd, s);
+	}
 
 	fd = xopen("/sys/power/resume", O_WRONLY);
-	s = xasprintf("%u:%u:%llu", major(resume_device), minor(resume_device), ofs);
+	s = xasprintf("%u:%u", major(resume_device), minor(resume_device));
 
 	xwrite_str(fd, s);
 	/* if write() returns, resume did not succeed */
diff -urpN busybox-1.33.1/libbb/appletlib.c busybox-1.34.0/libbb/appletlib.c
--- busybox-1.33.1/libbb/appletlib.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/appletlib.c	2021-08-19 20:02:34.000000000 +0700
@@ -176,7 +176,7 @@ void FAST_FUNC bb_show_usage(void)
 
 int FAST_FUNC find_applet_by_name(const char *name)
 {
-	unsigned i, max;
+	unsigned i;
 	int j;
 	const char *p;
 
@@ -200,105 +200,43 @@ int FAST_FUNC find_applet_by_name(const
 #endif
 
 	p = applet_names;
-	i = 0;
 #if KNOWN_APPNAME_OFFSETS <= 0
-	max = NUM_APPLETS;
+	i = 0;
 #else
-	max = NUM_APPLETS * KNOWN_APPNAME_OFFSETS;
+	i = NUM_APPLETS * (KNOWN_APPNAME_OFFSETS - 1);
 	for (j = ARRAY_SIZE(applet_nameofs)-1; j >= 0; j--) {
 		const char *pp = applet_names + applet_nameofs[j];
 		if (strcmp(name, pp) >= 0) {
 			//bb_error_msg("name:'%s' >= pp:'%s'", name, pp);
 			p = pp;
-			i = max - NUM_APPLETS;
 			break;
 		}
-		max -= NUM_APPLETS;
+		i -= NUM_APPLETS;
 	}
-	max /= (unsigned)KNOWN_APPNAME_OFFSETS;
 	i /= (unsigned)KNOWN_APPNAME_OFFSETS;
-	//bb_error_msg("name:'%s' starting from:'%s' i:%u max:%u", name, p, i, max);
+	//bb_error_msg("name:'%s' starting from:'%s' i:%u", name, p, i);
 #endif
 
 	/* Open-coded linear search without strcmp/strlen calls for speed */
-
-#if 0 /*BB_UNALIGNED_MEMACCESS_OK && BB_LITTLE_ENDIAN*/
-	/* skip "[\0" name, it's surely not it */
-	if (ENABLE_TEST && LONE_CHAR(p, '['))
-		i++, p += 2;
-	/* All remaining applet names in p[] are at least 2 chars long */
-	/* name[] is also at least 2 chars long */
-
-	n32 = (name[0] << 0) | (name[1] << 8) | (name[2] << 16);
-	while (i < max) {
-		uint32_t p32;
-		char ch;
-
-		/* Quickly check match of the first 3 bytes */
-		move_from_unaligned32(p32, p);
-		p += 3;
-		if ((p32 & 0x00ffffff) != n32) {
-			/* Most likely case: 3 first bytes do not match */
-			i++;
-			if ((p32 & 0x00ff0000) == '\0')
-				continue; // p[2] was NUL
-			p++;
-			if ((p32 & 0xff000000) == '\0')
-				continue; // p[3] was NUL
-			/* p[0..3] aren't matching and none is NUL, check the rest */
-			while (*p++ != '\0')
-				continue;
-			continue;
-		}
-
-		/* Unlikely branch: first 3 bytes ([0..2]) match */
-		if ((p32 & 0x00ff0000) == '\0') {
-			/* name is 2-byte long, it is full match */
-			//bb_error_msg("found:'%s' i:%u", name, i);
-			return i;
-		}
-		/* Check remaining bytes [3..NUL] */
-		ch = (p32 >> 24);
-		j = 3;
-		while (ch == name[j]) {
-			if (ch == '\0') {
-				//bb_error_msg("found:'%s' i:%u", name, i);
-				return i;
-			}
-			ch = *++p;
-			j++;
-		}
-		/* Not a match. Skip it, including NUL */
-		while (ch != '\0')
-			ch = *++p;
-		p++;
-		i++;
-	}
-	return -1;
-#else
-	while (i < max) {
-		char ch;
-		j = 0;
-		/* Do we see "name\0" in applet_names[p] position? */
-		while ((ch = *p) == name[j]) {
-			if (ch == '\0') {
+	while (*p) {
+		/* Do we see "name\0" at current position in applet_names? */
+		for (j = 0; *p == name[j]; ++j) {
+			if (*p++ == '\0') {
 				//bb_error_msg("found:'%s' i:%u", name, i);
 				return i; /* yes */
 			}
-			p++;
-			j++;
 		}
-		/* No.
-		 * p => 1st non-matching char in applet_names[],
-		 * skip to and including NUL.
-		 */
-		while (ch != '\0')
-			ch = *++p;
-		p++;
+		/* No. Have we gone too far, alphabetically? */
+		if (*p > name[j]) {
+			//bb_error_msg("break:'%s' i:%u", name, i);
+			break;
+		}
+		/* No. Move to the start of the next applet name. */
+		while (*p++ != '\0')
+			continue;
 		i++;
 	}
 	return -1;
-#endif
 }
 
 
@@ -325,9 +263,14 @@ void lbb_prepare(const char *applet
 	 && strcmp(argv[1], "--help") == 0
 	 && !is_prefixed_with(applet, "busybox")
 	) {
-		/* Special case. POSIX says "test --help"
-		 * should be no different from e.g. "test --foo".  */
-		if (!ENABLE_TEST || strcmp(applet_name, "test") != 0)
+		/* Special cases. POSIX says "test --help"
+		 * should be no different from e.g. "test --foo".
+		 */
+		if (!(ENABLE_TEST && strcmp(applet_name, "test") == 0)
+		 && !(ENABLE_TRUE && strcmp(applet_name, "true") == 0)
+		 && !(ENABLE_FALSE && strcmp(applet_name, "false") == 0)
+		 && !(ENABLE_ECHO && strcmp(applet_name, "echo") == 0)
+		)
 			bb_show_usage();
 	}
 #endif
@@ -950,37 +893,39 @@ int busybox_main(int argc UNUSED_PARAM,
 
 	if (strcmp(argv[1], "--help") == 0) {
 		/* "busybox --help [<applet>]" */
-		if (!argv[2])
+		if (!argv[2]
+#  if ENABLE_FEATURE_SH_STANDALONE && ENABLE_FEATURE_TAB_COMPLETION
+		 || strcmp(argv[2], "busybox") == 0 /* prevent getting "No help available" */
+#  endif
+		)
 			goto help;
 		/* convert to "<applet> --help" */
-		argv[0] = argv[2];
+		applet_name = argv[0] = argv[2];
 		argv[2] = NULL;
+		if (find_applet_by_name(applet_name) >= 0) {
+			/* Make "--help foo" exit with 0: */
+			xfunc_error_retval = 0;
+			bb_show_usage();
+		} /* else: unknown applet, fall through (causes "applet not found" later) */
 	} else {
 		/* "busybox <applet> arg1 arg2 ..." */
 		argv++;
+		/* We support "busybox /a/path/to/applet args..." too. Allows for
+		 * "#!/bin/busybox"-style wrappers
+		 */
+		applet_name = bb_get_last_path_component_nostrip(argv[0]);
 	}
-	/* We support "busybox /a/path/to/applet args..." too. Allows for
-	 * "#!/bin/busybox"-style wrappers */
-	applet_name = bb_get_last_path_component_nostrip(argv[0]);
 	run_applet_and_exit(applet_name, argv);
 }
 # endif
 
 # if NUM_APPLETS > 0
-void FAST_FUNC run_applet_no_and_exit(int applet_no, const char *name, char **argv)
+void FAST_FUNC show_usage_if_dash_dash_help(int applet_no, char **argv)
 {
-	int argc = string_array_len(argv);
-
-	/*
-	 * We do not use argv[0]: do not want to repeat massaging of
-	 * "-/sbin/halt" -> "halt", for example.
-	 */
-	applet_name = name;
-
 	/* Special case. POSIX says "test --help"
 	 * should be no different from e.g. "test --foo".
 	 * Thus for "test", we skip --help check.
-	 * "true" and "false" are also special.
+	 * "true", "false", "echo" are also special.
 	 */
 	if (1
 #  if defined APPLET_NO_test
@@ -992,16 +937,36 @@ void FAST_FUNC run_applet_no_and_exit(in
 #  if defined APPLET_NO_false
 	 && applet_no != APPLET_NO_false
 #  endif
+#  if defined APPLET_NO_echo
+	 && applet_no != APPLET_NO_echo
+#  endif
 	) {
-		if (argc == 2 && strcmp(argv[1], "--help") == 0) {
+		if (argv[1] && !argv[2] && strcmp(argv[1], "--help") == 0) {
 			/* Make "foo --help" exit with 0: */
 			xfunc_error_retval = 0;
 			bb_show_usage();
 		}
 	}
+}
+
+void FAST_FUNC run_applet_no_and_exit(int applet_no, const char *name, char **argv)
+{
+	int argc;
+
+	/*
+	 * We do not use argv[0]: do not want to repeat massaging of
+	 * "-/sbin/halt" -> "halt", for example.
+	 */
+	applet_name = name;
+
+	show_usage_if_dash_dash_help(applet_no, argv);
+
 	if (ENABLE_FEATURE_SUID)
 		check_suid(applet_no);
+
+	argc = string_array_len(argv);
 	xfunc_error_retval = applet_main[applet_no](argc, argv);
+
 	/* Note: applet_main() may also not return (die on a xfunc or such) */
 	xfunc_die();
 }
diff -urpN busybox-1.33.1/libbb/bb_askpass.c busybox-1.34.0/libbb/bb_askpass.c
--- busybox-1.33.1/libbb/bb_askpass.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/bb_askpass.c	2021-04-15 00:05:01.000000000 +0700
@@ -25,7 +25,7 @@ char* FAST_FUNC bb_ask_noecho(int fd, in
 	/* Was buggy: was printing prompt *before* flushing input,
 	 * which was upsetting "expect" based scripts of some users.
 	 */
-	fputs(prompt, stdout);
+	fputs_stdout(prompt);
 	fflush_all();
 
 	tcgetattr(fd, &oldtio);
diff -urpN busybox-1.33.1/libbb/compare_string_array.c busybox-1.34.0/libbb/compare_string_array.c
--- busybox-1.33.1/libbb/compare_string_array.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/compare_string_array.c	2021-04-15 00:05:01.000000000 +0700
@@ -63,13 +63,19 @@ int FAST_FUNC index_in_str_array(const c
 
 int FAST_FUNC index_in_strings(const char *strings, const char *key)
 {
-	int idx = 0;
+	int j, idx = 0;
 
 	while (*strings) {
-		if (strcmp(strings, key) == 0) {
-			return idx;
+		/* Do we see "key\0" at current position in strings? */
+		for (j = 0; *strings == key[j]; ++j) {
+			if (*strings++ == '\0') {
+				//bb_error_msg("found:'%s' i:%u", key, idx);
+				return idx; /* yes */
+			}
 		}
-		strings += strlen(strings) + 1; /* skip NUL */
+		/* No.  Move to the start of the next string. */
+		while (*strings++ != '\0')
+			continue;
 		idx++;
 	}
 	return -1;
diff -urpN busybox-1.33.1/libbb/copy_file.c busybox-1.34.0/libbb/copy_file.c
--- busybox-1.33.1/libbb/copy_file.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/copy_file.c	2021-07-20 21:57:20.000000000 +0700
@@ -111,6 +111,8 @@ int FAST_FUNC copy_file(const char *sour
 			bb_error_msg("'%s' and '%s' are the same file", source, dest);
 			return -1;
 		}
+		if (flags & FILEUTILS_NO_OVERWRITE) /* cp -n */
+			return 0;
 		dest_exists = 1;
 	}
 
diff -urpN busybox-1.33.1/libbb/dump.c busybox-1.34.0/libbb/dump.c
--- busybox-1.33.1/libbb/dump.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/dump.c	2021-07-20 21:57:20.000000000 +0700
@@ -34,7 +34,6 @@ typedef struct priv_dumper_t {
 	FU *endfu;
 	off_t savaddress;        /* saved address/offset in stream */
 	off_t eaddress;          /* end address */
-	off_t address;           /* address/offset in stream */
 	int blocksize;
 	smallint exitval;        /* final exit value */
 
@@ -211,7 +210,7 @@ static NOINLINE void rewrite(priv_dumper
 				pr->bcnt = fu->bcnt;
 				if (fu->bcnt == 0) {
 					if (!prec)
-						bb_simple_error_msg_and_die("%%s needs precision or byte count");
+						bb_simple_error_msg_and_die("%s needs precision or byte count");
 					pr->bcnt = atoi(prec);
 				}
 			} else
@@ -228,7 +227,8 @@ static NOINLINE void rewrite(priv_dumper
 					if ((p1[2] != 'd') && (p1[2] != 'o') && (p1[2] != 'x')) {
 						goto DO_BAD_CONV_CHAR;
 					}
-					*p1 = p1[2];
+					*p1++ = 'l';
+					*p1++ = 'l';
 					break;
 				case 'c':	/* %_c: chars, \ooo, \n \r \t etc */
 					pr->flags = F_C;
@@ -334,14 +334,14 @@ static void do_skip(priv_dumper_t *dumpe
 	) {
 		/* If st_size is valid and pub.dump_skip >= st_size */
 		dumper->pub.dump_skip -= sbuf.st_size;
-		dumper->address += sbuf.st_size;
+		dumper->pub.address += sbuf.st_size;
 		return;
 	}
 	if (fseeko(stdin, dumper->pub.dump_skip, SEEK_SET)) {
 		bb_simple_perror_msg_and_die(fname);
 	}
-	dumper->address += dumper->pub.dump_skip;
-	dumper->savaddress = dumper->address;
+	dumper->pub.address += dumper->pub.dump_skip;
+	dumper->savaddress = dumper->pub.address;
 	dumper->pub.dump_skip = 0;
 }
 
@@ -356,6 +356,7 @@ static NOINLINE int next(priv_dumper_t *
 				if (!freopen(fname, "r", stdin)) {
 					bb_simple_perror_msg(fname);
 					dumper->exitval = 1;
+					dumper->next__done = 1;
 					continue;
 				}
 			}
@@ -379,7 +380,7 @@ static unsigned char *get(priv_dumper_t
 	int blocksize = dumper->blocksize;
 
 	if (!dumper->get__curp) {
-		dumper->address = (off_t)0; /*DBU:[dave@cray.com] initialize,initialize..*/
+		dumper->pub.address = (off_t)0; /*DBU:[dave@cray.com] initialize,initialize..*/
 		dumper->get__curp = xmalloc(blocksize);
 		dumper->get__savp = xzalloc(blocksize); /* need to be initialized */
 	} else {
@@ -387,7 +388,7 @@ static unsigned char *get(priv_dumper_t
 		dumper->get__curp = dumper->get__savp;
 		dumper->get__savp = tmp;
 		dumper->savaddress += blocksize;
-		dumper->address = dumper->savaddress;
+		dumper->pub.address = dumper->savaddress;
 	}
 	need = blocksize;
 	nread = 0;
@@ -410,7 +411,7 @@ static unsigned char *get(priv_dumper_t
 				}
 			}
 			memset(dumper->get__curp + nread, 0, need);
-			dumper->eaddress = dumper->address + nread;
+			dumper->eaddress = dumper->pub.address + nread;
 			return dumper->get__curp;
 		}
 		n = fread(dumper->get__curp + nread, sizeof(unsigned char),
@@ -442,7 +443,7 @@ static unsigned char *get(priv_dumper_t
 			}
 			dumper->pub.dump_vflag = DUP;
 			dumper->savaddress += blocksize;
-			dumper->address = dumper->savaddress;
+			dumper->pub.address = dumper->savaddress;
 			need = blocksize;
 			nread = 0;
 		} else {
@@ -543,8 +544,8 @@ static void display(priv_dumper_t* dumpe
 
 		fs = dumper->pub.fshead;
 		savebp = bp;
-		saveaddress = dumper->address;
-		for (; fs; fs = fs->nextfs, bp = savebp, dumper->address = saveaddress) {
+		saveaddress = dumper->pub.address;
+		for (; fs; fs = fs->nextfs, bp = savebp, dumper->pub.address = saveaddress) {
 			FU *fu;
 			for (fu = fs->nextfu; fu; fu = fu->nextfu) {
 				int cnt;
@@ -553,14 +554,14 @@ static void display(priv_dumper_t* dumpe
 				}
 				for (cnt = fu->reps; cnt; --cnt) {
 					PR *pr;
-					for (pr = fu->nextpr; pr; dumper->address += pr->bcnt,
+					for (pr = fu->nextpr; pr; dumper->pub.address += pr->bcnt,
 								bp += pr->bcnt, pr = pr->nextpr) {
 						if (dumper->eaddress
-						 && dumper->address >= dumper->eaddress
+						 && dumper->pub.address >= dumper->eaddress
 						) {
-							if (dumper->pub.eofstring) {
+							if (dumper->pub.xxd_eofstring) {
 								/* xxd support: requested to not pad incomplete blocks */
-								fputs(dumper->pub.eofstring, stdout);
+								fputs_stdout(dumper->pub.xxd_eofstring);
 								return;
 							}
 							if (!(pr->flags & (F_TEXT | F_BPAD)))
@@ -572,7 +573,7 @@ static void display(priv_dumper_t* dumpe
 						}
 						switch (pr->flags) {
 						case F_ADDRESS:
-							printf(pr->fmt, (unsigned) dumper->address);
+							printf(pr->fmt, (unsigned long long) dumper->pub.address + dumper->pub.xxd_displayoff);
 							break;
 						case F_BPAD:
 							printf(pr->fmt, "");
@@ -666,15 +667,15 @@ static void display(priv_dumper_t* dumpe
 		 * of blocksize, and no partial block ever found.
 		 */
 		if (!dumper->eaddress) {
-			if (!dumper->address) {
+			if (!dumper->pub.address) {
 				return;
 			}
-			dumper->eaddress = dumper->address;
+			dumper->eaddress = dumper->pub.address;
 		}
 		for (pr = dumper->endfu->nextpr; pr; pr = pr->nextpr) {
 			switch (pr->flags) {
 			case F_ADDRESS:
-				printf(pr->fmt, (unsigned) dumper->eaddress);
+				printf(pr->fmt, (unsigned long long) dumper->eaddress + dumper->pub.xxd_displayoff);
 				break;
 			case F_TEXT:
 				printf(pr->fmt);
diff -urpN busybox-1.33.1/libbb/duration.c busybox-1.34.0/libbb/duration.c
--- busybox-1.33.1/libbb/duration.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/duration.c	2021-04-15 00:05:01.000000000 +0700
@@ -37,8 +37,18 @@ duration_t FAST_FUNC parse_duration_str(
 	if (strchr(str, '.')) {
 		double d;
 		char *pp;
-		int len = strspn(str, "0123456789.");
-		char sv = str[len];
+		int len;
+		char sv;
+
+# if ENABLE_LOCALE_SUPPORT
+		/* Undo busybox.c: on input, we want to use dot
+		 * as fractional separator in strtod(),
+		 * regardless of current locale
+		 */
+		setlocale(LC_NUMERIC, "C");
+# endif
+		len = strspn(str, "0123456789.");
+		sv = str[len];
 		str[len] = '\0';
 		errno = 0;
 		d = strtod(str, &pp);
diff -urpN busybox-1.33.1/libbb/fgets_str.c busybox-1.34.0/libbb/fgets_str.c
--- busybox-1.33.1/libbb/fgets_str.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/fgets_str.c	2021-04-15 00:05:01.000000000 +0700
@@ -17,7 +17,7 @@ static char *xmalloc_fgets_internal(FILE
 	int linebufsz = 0;
 	int idx = 0;
 	int ch;
-	size_t maxsz = *maxsz_p;
+	size_t maxsz = maxsz_p ? *maxsz_p : INT_MAX - 4095;
 
 	while (1) {
 		ch = fgetc(file);
@@ -53,7 +53,8 @@ static char *xmalloc_fgets_internal(FILE
 	/* Grow/shrink *first*, then store NUL */
 	linebuf = xrealloc(linebuf, idx + 1);
 	linebuf[idx] = '\0';
-	*maxsz_p = idx;
+	if (maxsz_p)
+		*maxsz_p = idx;
 	return linebuf;
 }
 
@@ -63,23 +64,15 @@ static char *xmalloc_fgets_internal(FILE
  * Return NULL if EOF is reached immediately.  */
 char* FAST_FUNC xmalloc_fgets_str(FILE *file, const char *terminating_string)
 {
-	size_t maxsz = INT_MAX - 4095;
-	return xmalloc_fgets_internal(file, terminating_string, 0, &maxsz);
+	return xmalloc_fgets_internal(file, terminating_string, 0, NULL);
 }
 
 char* FAST_FUNC xmalloc_fgets_str_len(FILE *file, const char *terminating_string, size_t *maxsz_p)
 {
-	size_t maxsz;
-
-	if (!maxsz_p) {
-		maxsz = INT_MAX - 4095;
-		maxsz_p = &maxsz;
-	}
 	return xmalloc_fgets_internal(file, terminating_string, 0, maxsz_p);
 }
 
 char* FAST_FUNC xmalloc_fgetline_str(FILE *file, const char *terminating_string)
 {
-	size_t maxsz = INT_MAX - 4095;
-	return xmalloc_fgets_internal(file, terminating_string, 1, &maxsz);
+	return xmalloc_fgets_internal(file, terminating_string, 1, NULL);
 }
diff -urpN busybox-1.33.1/libbb/getopt32.c busybox-1.34.0/libbb/getopt32.c
--- busybox-1.33.1/libbb/getopt32.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/getopt32.c	2021-06-16 17:02:16.000000000 +0700
@@ -89,6 +89,12 @@ getopt32(char **argv, const char *applet
         root:x:0:0:root:/root:/bin/bash
         user:x:500:500::/home/user:/bin/bash
 
+ "^"    options string is "^optchars""\0""opt_complementary".
+
+ "!"    If the first character in the applet_opts string is a '!',
+        report bad options, missing required options,
+        inconsistent options with all-ones return value (instead of abort.
+
  "+"    If the first character in the applet_opts string is a plus,
         then option processing will stop as soon as a non-option is
         encountered in the argv array.  Useful for applets like env
@@ -96,10 +102,7 @@ getopt32(char **argv, const char *applet
         env -i ls -d /
         Here we want env to process just the '-i', not the '-d'.
 
- "!"    Report bad options, missing required options,
-        inconsistent options with all-ones return value (instead of abort).
-
- "^"    options string is "^optchars""\0""opt_complementary".
+        (The order of multiple prefixes must be "^!+...")
 
 uint32_t
 getopt32long(char **argv, const char *applet_opts, const char *logopts...)
diff -urpN busybox-1.33.1/libbb/iterate_on_dir.c busybox-1.34.0/libbb/iterate_on_dir.c
--- busybox-1.33.1/libbb/iterate_on_dir.c	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/libbb/iterate_on_dir.c	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,28 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * See README for additional information
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//kbuild:lib-y += iterate_on_dir.o
+
+#include "libbb.h"
+
+/* Iterate a function on each entry of a directory */
+int FAST_FUNC iterate_on_dir(const char *dir_name,
+		int FAST_FUNC (*func)(const char *, struct dirent *, void *),
+		void *private)
+{
+	DIR *dir;
+	struct dirent *de;
+
+	dir = opendir(dir_name);
+	if (dir == NULL) {
+		return -1;
+	}
+	while ((de = readdir(dir)) != NULL) {
+		func(dir_name, de, private);
+	}
+	closedir(dir);
+	return 0;
+}
diff -urpN busybox-1.33.1/libbb/lineedit.c busybox-1.34.0/libbb/lineedit.c
--- busybox-1.33.1/libbb/lineedit.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/lineedit.c	2021-04-15 00:05:01.000000000 +0700
@@ -312,7 +312,7 @@ static void BB_PUTCHAR(wchar_t c)
 		ssize_t len = wcrtomb(buf, c, &mbst);
 		if (len > 0) {
 			buf[len] = '\0';
-			fputs(buf, stdout);
+			fputs_stdout(buf);
 		}
 	} else {
 		/* In this case, c is always one byte */
@@ -460,7 +460,7 @@ static void beep(void)
  */
 static void put_prompt_custom(bool is_full)
 {
-	fputs((is_full ? cmdedit_prompt : prompt_last_line), stdout);
+	fputs_stdout((is_full ? cmdedit_prompt : prompt_last_line));
 	cursor = 0;
 	cmdedit_y = cmdedit_prmt_len / cmdedit_termw; /* new quasireal y */
 	cmdedit_x = cmdedit_prmt_len % cmdedit_termw;
@@ -769,8 +769,6 @@ static unsigned path_parse(char ***p)
 		if (!tmp)
 			break;
 		tmp++;
-		if (*tmp == '\0')
-			break;  /* :<empty> */
 		npth++;
 	}
 
@@ -782,8 +780,6 @@ static unsigned path_parse(char ***p)
 		if (!tmp)
 			break;
 		*tmp++ = '\0'; /* ':' -> '\0' */
-		if (*tmp == '\0')
-			break; /* :<empty> */
 		res[npth++] = tmp;
 	}
 	/* special case: "match subdirectories of the current directory" */
@@ -854,6 +850,7 @@ static NOINLINE unsigned complete_cmd_di
 		struct dirent *next;
 		struct stat st;
 		char *found;
+		const char *lpath;
 
 		if (paths[i] == NULL) { /* path_parse()'s last component? */
 			/* in PATH completion, current dir's subdir names
@@ -863,7 +860,8 @@ static NOINLINE unsigned complete_cmd_di
 			paths[i] = (char *)".";
 		}
 
-		dir = opendir(paths[i]);
+		lpath = *paths[i] ? paths[i] : ".";
+		dir = opendir(lpath);
 		if (!dir)
 			continue; /* don't print an error */
 
@@ -878,7 +876,7 @@ static NOINLINE unsigned complete_cmd_di
 			if (strncmp(basecmd, name_found, baselen) != 0)
 				continue; /* no */
 
-			found = concat_path_file(paths[i], name_found);
+			found = concat_path_file(lpath, name_found);
 			/* NB: stat() first so that we see is it a directory;
 			 * but if that fails, use lstat() so that
 			 * we still match dangling links */
@@ -1073,7 +1071,7 @@ static NOINLINE int build_match_prefix(c
 		continue;
 	for (--i; i >= 0; i--) {
 		int cur = int_buf[i];
-		if (cur == ' ' || cur == '<' || cur == '>' || cur == '|' || cur == '&') {
+		if (cur == ' ' || cur == '<' || cur == '>' || cur == '|' || cur == '&' || cur == '=') {
 			remove_chunk(int_buf, 0, i + 1);
 			break;
 		}
@@ -1316,7 +1314,7 @@ static NOINLINE void input_tab(smallint
 			strcpy(&command[cursor_mb], chosen_match + match_pfx_len);
 			len = load_string(command);
 			/* add match and tail */
-			sprintf(&command[cursor_mb], "%s%s", chosen_match + match_pfx_len, match_buf);
+			stpcpy(stpcpy(&command[cursor_mb], chosen_match + match_pfx_len), match_buf);
 			command_len = load_string(command);
 			/* write out the matched command */
 			/* paranoia: load_string can return 0 on conv error,
@@ -1851,7 +1849,7 @@ static void ask_terminal(void)
 	pfd.events = POLLIN;
 	if (safe_poll(&pfd, 1, 0) == 0) {
 		S.sent_ESC_br6n = 1;
-		fputs(ESC"[6n", stdout);
+		fputs_stdout(ESC"[6n");
 		fflush_all(); /* make terminal see it ASAP! */
 	}
 }
@@ -2957,7 +2955,7 @@ int FAST_FUNC read_line_input(line_input
 #undef read_line_input
 int FAST_FUNC read_line_input(const char* prompt, char* command, int maxsize)
 {
-	fputs(prompt, stdout);
+	fputs_stdout(prompt);
 	fflush_all();
 	if (!fgets(command, maxsize, stdin))
 		return -1;
diff -urpN busybox-1.33.1/libbb/login.c busybox-1.34.0/libbb/login.c
--- busybox-1.33.1/libbb/login.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/login.c	2021-04-15 00:05:01.000000000 +0700
@@ -120,7 +120,7 @@ void FAST_FUNC print_login_issue(const c
 				buf[0] = c;
 			}
 		}
-		fputs(outbuf, stdout);
+		fputs_stdout(outbuf);
 	}
 	fclose(fp);
 	fflush_all();
@@ -130,8 +130,8 @@ void FAST_FUNC print_login_prompt(void)
 {
 	char *hostname = safe_gethostname();
 
-	fputs(hostname, stdout);
-	fputs(LOGIN, stdout);
+	fputs_stdout(hostname);
+	fputs_stdout(LOGIN);
 	fflush_all();
 	free(hostname);
 }
diff -urpN busybox-1.33.1/libbb/platform.c busybox-1.34.0/libbb/platform.c
--- busybox-1.33.1/libbb/platform.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/platform.c	2021-04-15 00:05:01.000000000 +0700
@@ -166,6 +166,18 @@ char* FAST_FUNC stpcpy(char *p, const ch
 }
 #endif
 
+#ifndef HAVE_STPNCPY
+char* FAST_FUNC stpncpy(char *p, const char *to_add, size_t n)
+{
+	while (n != 0 && (*p = *to_add) != '\0') {
+		p++;
+		to_add++;
+		n--;
+	}
+	return p;
+}
+#endif
+
 #ifndef HAVE_GETLINE
 ssize_t FAST_FUNC getline(char **lineptr, size_t *n, FILE *stream)
 {
diff -urpN busybox-1.33.1/libbb/print_numbered_lines.c busybox-1.34.0/libbb/print_numbered_lines.c
--- busybox-1.33.1/libbb/print_numbered_lines.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/print_numbered_lines.c	2021-04-15 00:05:01.000000000 +0700
@@ -22,10 +22,11 @@ int FAST_FUNC print_numbered_lines(struc
 		if (ns->all
 		 || (ns->nonempty && line[0])
 		) {
-			printf("%*u%s%s\n", ns->width, N, ns->sep, line);
+			printf("%*u%s", ns->width, N, ns->sep);
 			N += ns->inc;
 		} else if (ns->empty_str)
-			fputs(ns->empty_str, stdout);
+			fputs_stdout(ns->empty_str);
+		puts(line);
 		free(line);
 	}
 	ns->start = N;
diff -urpN busybox-1.33.1/libbb/procps.c busybox-1.34.0/libbb/procps.c
--- busybox-1.33.1/libbb/procps.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/libbb/procps.c	2021-01-08 15:30:27.000000000 +0700
@@ -21,40 +21,29 @@ typedef struct cache_t {
 	int size;
 } cache_t;
 
-static cache_t username, groupname;
+static cache_t *cache_user_group;
 
-static void clear_cache(cache_t *cp)
-{
-	free(cp->cache);
-	cp->cache = NULL;
-	cp->size = 0;
-}
 void FAST_FUNC clear_username_cache(void)
 {
-	clear_cache(&username);
-	clear_cache(&groupname);
+	if (cache_user_group) {
+		free(cache_user_group[0].cache);
+		free(cache_user_group[1].cache);
+		free(cache_user_group);
+		cache_user_group = NULL;
+	}
 }
 
-#if 0 /* more generic, but we don't need that yet */
-/* Returns -N-1 if not found. */
-/* cp->cache[N] is allocated and must be filled in this case */
-static int get_cached(cache_t *cp, uid_t id)
-{
-	int i;
-	for (i = 0; i < cp->size; i++)
-		if (cp->cache[i].id == id)
-			return i;
-	i = cp->size++;
-	cp->cache = xrealloc_vector(cp->cache, 2, i);
-	cp->cache[i++].id = id;
-	return -i;
-}
-#endif
-
-static char* get_cached(cache_t *cp, uid_t id,
+static char* get_cached(int user_group, uid_t id,
 			char* FAST_FUNC x2x_utoa(uid_t id))
 {
+	cache_t *cp;
 	int i;
+
+	if (!cache_user_group)
+		cache_user_group = xzalloc(sizeof(cache_user_group[0]) * 2);
+
+	cp = &cache_user_group[user_group];
+
 	for (i = 0; i < cp->size; i++)
 		if (cp->cache[i].id == id)
 			return cp->cache[i].name;
@@ -67,11 +56,11 @@ static char* get_cached(cache_t *cp, uid
 }
 const char* FAST_FUNC get_cached_username(uid_t uid)
 {
-	return get_cached(&username, uid, uid2uname_utoa);
+	return get_cached(0, uid, uid2uname_utoa);
 }
 const char* FAST_FUNC get_cached_groupname(gid_t gid)
 {
-	return get_cached(&groupname, gid, gid2group_utoa);
+	return get_cached(1, gid, gid2group_utoa);
 }
 
 
diff -urpN busybox-1.33.1/libbb/pw_encrypt.c busybox-1.34.0/libbb/pw_encrypt.c
--- busybox-1.33.1/libbb/pw_encrypt.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/pw_encrypt.c	2021-01-08 15:30:27.000000000 +0700
@@ -7,7 +7,9 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 #if !ENABLE_USE_BB_CRYPT
-#include <crypt.h>
+# if !defined(__FreeBSD__)
+#  include <crypt.h>
+# endif
 #endif
 #include "libbb.h"
 
diff -urpN busybox-1.33.1/libbb/remove_file.c busybox-1.34.0/libbb/remove_file.c
--- busybox-1.33.1/libbb/remove_file.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/remove_file.c	2021-07-20 21:57:20.000000000 +0700
@@ -60,11 +60,7 @@ int FAST_FUNC remove_file(const char *pa
 				status = -1;
 			free(new_path);
 		}
-
-		if (closedir(dp) < 0) {
-			bb_perror_msg("can't close '%s'", path);
-			return -1;
-		}
+		closedir(dp);
 
 		if (flags & FILEUTILS_INTERACTIVE) {
 			fprintf(stderr, "%s: remove directory '%s'? ",
diff -urpN busybox-1.33.1/libbb/signals.c busybox-1.34.0/libbb/signals.c
--- busybox-1.33.1/libbb/signals.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/signals.c	2021-06-16 17:02:16.000000000 +0700
@@ -56,7 +56,7 @@ void FAST_FUNC bb_signals(int sigs, void
 	}
 }
 
-void FAST_FUNC bb_signals_recursive_norestart(int sigs, void (*f)(int))
+void FAST_FUNC bb_signals_norestart(int sigs, void (*f)(int))
 {
 	int sig_no = 0;
 	int bit = 1;
diff -urpN busybox-1.33.1/libbb/time.c busybox-1.34.0/libbb/time.c
--- busybox-1.33.1/libbb/time.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/libbb/time.c	2021-01-08 15:30:27.000000000 +0700
@@ -291,19 +291,19 @@ unsigned FAST_FUNC monotonic_sec(void)
 unsigned long long FAST_FUNC monotonic_ns(void)
 {
 	struct timeval tv;
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	return tv.tv_sec * 1000000000ULL + tv.tv_usec * 1000;
 }
 unsigned long long FAST_FUNC monotonic_us(void)
 {
 	struct timeval tv;
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	return tv.tv_sec * 1000000ULL + tv.tv_usec;
 }
 unsigned long long FAST_FUNC monotonic_ms(void)
 {
 	struct timeval tv;
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	return tv.tv_sec * 1000ULL + tv.tv_usec / 1000;
 }
 unsigned FAST_FUNC monotonic_sec(void)
diff -urpN busybox-1.33.1/libbb/vfork_daemon_rexec.c busybox-1.34.0/libbb/vfork_daemon_rexec.c
--- busybox-1.33.1/libbb/vfork_daemon_rexec.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/vfork_daemon_rexec.c	2021-04-15 00:05:01.000000000 +0700
@@ -109,8 +109,13 @@ int FAST_FUNC run_nofork_applet(int appl
 		char *tmp_argv[argc+1];
 		memcpy(tmp_argv, argv, (argc+1) * sizeof(tmp_argv[0]));
 		applet_name = tmp_argv[0];
+
+		/* longjmp's (instead of returning) if --help is seen */
+		show_usage_if_dash_dash_help(applet_no, argv);
+
 		/* Finally we can call NOFORK applet's main() */
 		rc = applet_main[applet_no](argc, tmp_argv);
+
 		/* Important for shells: `which CMD` was failing */
 		fflush_all();
 	} else {
diff -urpN busybox-1.33.1/libbb/xfuncs.c busybox-1.34.0/libbb/xfuncs.c
--- busybox-1.33.1/libbb/xfuncs.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/libbb/xfuncs.c	2021-06-16 17:02:16.000000000 +0700
@@ -303,6 +303,12 @@ int FAST_FUNC get_terminal_width(int fd)
 	return width;
 }
 
+int FAST_FUNC is_TERM_dumb(void)
+{
+	char *term = getenv("TERM");
+	return term && strcmp(term, "dumb") == 0;
+}
+
 int FAST_FUNC tcsetattr_stdin_TCSANOW(const struct termios *tp)
 {
 	return tcsetattr(STDIN_FILENO, TCSANOW, tp);
diff -urpN busybox-1.33.1/libbb/xfuncs_printf.c busybox-1.34.0/libbb/xfuncs_printf.c
--- busybox-1.33.1/libbb/xfuncs_printf.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/libbb/xfuncs_printf.c	2021-04-15 00:05:01.000000000 +0700
@@ -224,7 +224,7 @@ int FAST_FUNC rename_or_warn(const char
 	return n;
 }
 
-void FAST_FUNC xpipe(int filedes[2])
+void FAST_FUNC xpipe(int *filedes)
 {
 	if (pipe(filedes))
 		bb_simple_perror_msg_and_die("can't create pipe");
@@ -318,6 +318,11 @@ int FAST_FUNC bb_putchar(int ch)
 	return putchar(ch);
 }
 
+int FAST_FUNC fputs_stdout(const char *s)
+{
+	return fputs(s, stdout);
+}
+
 /* Die with an error message if we can't copy an entire FILE* to stdout,
  * then close that file. */
 void FAST_FUNC xprint_and_close_file(FILE *file)
@@ -720,3 +725,14 @@ void FAST_FUNC xsettimeofday(const struc
 	if (settimeofday(tv, NULL))
 		bb_simple_perror_msg_and_die("settimeofday");
 }
+
+void FAST_FUNC xgettimeofday(struct timeval *tv)
+{
+#if 0
+	if (gettimeofday(tv, NULL))
+		bb_simple_perror_msg_and_die("gettimeofday");
+#else
+	/* Never fails on Linux */
+	gettimeofday(tv, NULL);
+#endif
+}
diff -urpN busybox-1.33.1/loginutils/cryptpw.c busybox-1.34.0/loginutils/cryptpw.c
--- busybox-1.33.1/loginutils/cryptpw.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/loginutils/cryptpw.c	2021-04-15 00:05:01.000000000 +0700
@@ -32,7 +32,7 @@
 //kbuild:lib-$(CONFIG_MKPASSWD) += cryptpw.o
 
 //usage:#define cryptpw_trivial_usage
-//usage:       "[-s] [-p N] [-m TYPE] [-S SALT] [PASSWORD] [SALT]"
+//usage:       "[-P FD] [-m TYPE] [-S SALT] [PASSWORD] [SALT]"
 /* We do support -s, we just don't mention it */
 //usage:#define cryptpw_full_usage "\n\n"
 //usage:       "Print crypt(3) hashed PASSWORD\n"
@@ -72,8 +72,8 @@ ENVIRONMENT
     A list of options which will be evaluated before the ones
     specified on the command line.
 BUGS
-    This programs suffers of a bad case of featuritis.
-    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    This program suffers of a bad case of featuritis.
+    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 Very true...
 
diff -urpN busybox-1.33.1/loginutils/login.c busybox-1.34.0/loginutils/login.c
--- busybox-1.33.1/loginutils/login.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/loginutils/login.c	2021-06-16 17:02:16.000000000 +0700
@@ -60,6 +60,11 @@
 //usage:     "\n	-f	Don't authenticate (user already authenticated)"
 //usage:     "\n	-h HOST	Host user came from (for network logins)"
 //usage:     "\n	-p	Preserve environment"
+//usage:     "\n"
+//usage:     "\n$LOGIN_TIMEOUT		Seconds (default 60, 0 - disable)"
+//usage:	IF_LOGIN_SCRIPTS(
+//usage:     "\n$LOGIN_PRE_SUID_SCRIPT	Execute before user ID change"
+//usage:	)
 
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -130,7 +135,6 @@ static const struct pam_conv conv = {
 #endif
 
 enum {
-	TIMEOUT = 60,
 	EMPTY_USERNAME_COUNT = 10,
 	/* Some users found 32 chars limit to be too low: */
 	USERNAME_SIZE = 64,
@@ -139,6 +143,7 @@ enum {
 
 struct globals {
 	struct termios tty_attrs;
+	int timeout;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { setup_common_bufsiz(); } while (0)
@@ -302,7 +307,7 @@ static void alarm_handler(int sig UNUSED
 	 * when you are back at shell prompt, echo will be still off.
 	 */
 	tcsetattr_stdin_TCSANOW(&G.tty_attrs);
-	printf("\r\nLogin timed out after %u seconds\r\n", TIMEOUT);
+	printf("\r\nLogin timed out after %u seconds\r\n", G.timeout);
 	fflush_all();
 	/* unix API is brain damaged regarding O_NONBLOCK,
 	 * we should undo it, or else we can affect other processes */
@@ -345,6 +350,8 @@ int login_main(int argc UNUSED_PARAM, ch
 
 	INIT_G();
 
+	G.timeout = xatoi_positive(getenv("LOGIN_TIMEOUT") ? : "60");
+
 	/* More of suid paranoia if called by non-root: */
 	/* Clear dangerous stuff, set PATH */
 	run_by_root = !sanitize_env_if_suid();
@@ -376,7 +383,7 @@ int login_main(int argc UNUSED_PARAM, ch
 
 	/* We install timeout handler only _after_ we saved G.tty_attrs */
 	signal(SIGALRM, alarm_handler);
-	alarm(TIMEOUT);
+	alarm(G.timeout);
 
 	/* Find out and memorize our tty name */
 	full_tty = xmalloc_ttyname(STDIN_FILENO);
@@ -435,6 +442,9 @@ int login_main(int argc UNUSED_PARAM, ch
 		}
 		/* check that the account is healthy */
 		pamret = pam_acct_mgmt(pamh, 0);
+		if (pamret == PAM_NEW_AUTHTOK_REQD) {
+			pamret = pam_chauthtok(pamh, PAM_CHANGE_EXPIRED_AUTHTOK);
+		}
 		if (pamret != PAM_SUCCESS) {
 			failed_msg = "acct_mgmt";
 			goto pam_auth_failed;
diff -urpN busybox-1.33.1/loginutils/su.c busybox-1.34.0/loginutils/su.c
--- busybox-1.33.1/loginutils/su.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/loginutils/su.c	2021-06-16 17:02:16.000000000 +0700
@@ -35,7 +35,7 @@
 //kbuild:lib-$(CONFIG_SU) += su.o
 
 //usage:#define su_trivial_usage
-//usage:       "[-lmp] [-] [-s SH] [USER [SCRIPT ARGS / -c 'CMD' ARG0 ARGS]]"
+//usage:       "[-lmp] [-s SH] [-] [USER [FILE ARGS | -c 'CMD' [ARG0 ARGS]]]"
 //usage:#define su_full_usage "\n\n"
 //usage:       "Run shell under USER (by default, root)\n"
 //usage:     "\n	-,-l	Clear environment, go to home dir, run shell as login shell"
diff -urpN busybox-1.33.1/mailutils/mail.c busybox-1.34.0/mailutils/mail.c
--- busybox-1.33.1/mailutils/mail.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/mailutils/mail.c	2021-01-08 15:30:27.000000000 +0700
@@ -6,7 +6,13 @@
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
-#include <sys/prctl.h>
+#if defined(__linux__)
+# include <sys/prctl.h>
+# define PRCTL
+#elif defined(__FreeBSD__)
+# include <sys/procctl.h>
+# define PROCCTL
+#endif
 #include "libbb.h"
 #include "mail.h"
 
@@ -55,7 +61,14 @@ void FAST_FUNC launch_helper(const char
 		xmove_fd(child_in.rd, STDIN_FILENO);
 		xmove_fd(child_out.wr, STDOUT_FILENO);
 		// if parent dies, get SIGTERM
+#if defined(PRCTL)
 		prctl(PR_SET_PDEATHSIG, SIGTERM, 0, 0, 0);
+#elif defined(PROCCTL)
+		{
+			int signum = SIGTERM;
+			procctl(P_PID, 0, PROC_PDEATHSIG_CTL, &signum);
+		}
+#endif
 		// try to execute connection helper
 		// NB: SIGCHLD & SIGALRM revert to SIG_DFL on exec
 		BB_EXECVP_or_die((char**)argv);
diff -urpN busybox-1.33.1/miscutils/ascii.c busybox-1.34.0/miscutils/ascii.c
--- busybox-1.33.1/miscutils/ascii.c	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/miscutils/ascii.c	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,51 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2021 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config ASCII
+//config:	bool "ascii"
+//config:	default y
+//config:	help
+//config:	Print ascii table.
+//config:
+
+//applet:IF_ASCII(APPLET(ascii, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_ASCII) += ascii.o
+
+//usage:#define ascii_trivial_usage NOUSAGE_STR
+//usage:#define ascii_full_usage ""
+
+#include "libbb.h"
+
+int ascii_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int ascii_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+	const char *ctrl =
+		"NUL""SOH""STX""ETX""EOT""ENQ""ACK""BEL"
+		"BS ""HT ""NL ""VT ""FF ""CR ""SO ""SI "
+		"DLE""DC1""DC2""DC3""DC4""NAK""SYN""ETB"
+		"CAN""EM ""SUB""ESC""FS ""GS ""RS ""US "
+	;
+//TODO: od has a similar table, can we reuse it?
+	char last[2];
+	unsigned i;
+
+	last[1] = '\0';
+	printf("Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex\n");
+	for (i = 0; i < 16; i++) {
+		printf("%3u %02x %.3s%4u %02x %.3s%4u %02x %c%4u %02x %c%4u %02x %c%4u %02x %c%5u %02x %c%5u %02x %s\n",
+			i+0x00, i+0x00, ctrl + i*3,
+			i+0x10, i+0x10, ctrl + i*3 + 16*3,
+			i+0x20, i+0x20, i+0x20,
+			i+0x30, i+0x30, i+0x30,
+			i+0x40, i+0x40, i+0x40,
+			i+0x50, i+0x50, i+0x50,
+			i+0x60, i+0x60, i+0x60,
+			i+0x70, i+0x70, (i+0x70 == 0x7f ? "DEL" : (last[0] = i+0x70, last))
+		);
+	}
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.33.1/miscutils/bc.c busybox-1.34.0/miscutils/bc.c
--- busybox-1.33.1/miscutils/bc.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/miscutils/bc.c	2021-06-16 17:02:16.000000000 +0700
@@ -5,7 +5,7 @@
  * Original code copyright (c) 2018 Gavin D. Howard and contributors.
  */
 //TODO:
-// maybe implement a^b for non-integer b?
+// maybe implement a^b for non-integer b? (see zbc_num_p())
 
 #define DEBUG_LEXER   0
 #define DEBUG_COMPILE 0
@@ -108,14 +108,14 @@
 
 //See www.gnu.org/software/bc/manual/bc.html
 //usage:#define bc_trivial_usage
-//usage:       "[-sqlw] FILE..."
+//usage:       "[-sqlw] [FILE]..."
 //usage:
 //usage:#define bc_full_usage "\n"
 //usage:     "\nArbitrary precision calculator"
 //usage:     "\n"
 ///////:     "\n	-i	Interactive" - has no effect for now
 //usage:     "\n	-q	Quiet"
-//usage:     "\n	-l	Load standard math library"
+//usage:     "\n	-l	Load standard library"
 //usage:     "\n	-s	Be POSIX compatible"
 //usage:     "\n	-w	Warn if extensions are used"
 ///////:     "\n	-v	Version"
@@ -138,11 +138,54 @@
 //usage:
 //usage:#define dc_full_usage "\n"
 //usage:     "\nTiny RPN calculator. Operations:"
-//usage:     "\n+, -, *, /, %, ~, ^," IF_FEATURE_DC_BIG(" |,")
+//usage:     "\nArithmetic: + - * / % ^"
+//usage:	IF_FEATURE_DC_BIG(
+//usage:     "\n~ - divide with remainder"
+//usage:     "\n| - modular exponentiation"
+//usage:     "\nv - square root"
+////////     "\nA-F -                   digits 10..15
+////////     "\n_NNN -                  push negative number -NNN
+////////     "\n[string] -              push string (in FreeBSD, \[, \] and \\ are escapes, not implemented here and in GNU)
+////////     "\nR - DC_LEX_POP          pop and discard
+////////     "\nc - DC_LEX_CLEAR_STACK  clear stack
+////////     "\nd - DC_LEX_DUPLICATE    duplicate top-of-stack
+////////     "\nr - DC_LEX_SWAP         swap top-of-stack
+////////     "\n:r - DC_LEX_COLON       pop index, pop value, store to array 'r'
+////////     "\n;r - DC_LEX_SCOLON      pop index, fetch from array 'r', push
+////////     "\nLr - DC_LEX_LOAD_POP    pop register 'r', push
+////////     "\nSr - DC_LEX_STORE_PUSH  pop, push to register 'r'
+////////     "\nlr - DC_LEX_LOAD        read register 'r', push
+////////     "\nsr - DC_LEX_OP_ASSIGN   pop, assign to register 'r'
+////////     "\n? - DC_LEX_READ         read line and execute
+////////     "\nx - DC_LEX_EXECUTE      pop string and execute
+////////     "\n<r - XC_LEX_OP_REL_GT   pop, pop, execute register 'r' if top-of-stack was less
+////////     "\n>r - XC_LEX_OP_REL_LT   pop, pop, execute register 'r' if top-of-stack was greater
+////////     "\n=r - XC_LEX_OP_REL_EQ   pop, pop, execute register 'r' if equal
+////////     "\n                        !<r !>r !=r - negated forms
+////////     "\n                        >tef - "if greater execute register 't' else execute 'f'"
+////////     "\nQ - DC_LEX_NQUIT        pop, "break N" from macro invocations
+////////     "\nq - DC_LEX_QUIT         "break 2" (if less than 2 levels of macros, exit dc)
+////////     "\nX - DC_LEX_SCALE_FACTOR pop, push number of fractional digits
+////////     "\nZ - DC_LEX_LENGTH       pop, push number of digits it has (or number of characters in string)
+////////     "\na - DC_LEX_ASCIIFY      pop, push low-order byte as char or 1st char of string
+////////     "\n( - DC_LEX_LPAREN       (FreeBSD, not in GNU) pop, pop, if top-of-stack was less push 1 else push 0
+////////     "\n{ - DC_LEX_LBRACE       (FreeBSD, not in GNU) pop, pop, if top-of-stack was less-or-equal push 1 else push 0
+////////     "\nG - DC_LEX_EQ_NO_REG    (FreeBSD, not in GNU) pop, pop, if equal push 1 else push 0
+////////     "\nN - DC_LEX_OP_BOOL_NOT  (FreeBSD, not in GNU) pop, if 0 push 1 else push 0
+////////                                FreeBSD also has J and M commands, used internally by bc
+////////     "\nn - DC_LEX_PRINT_POP    pop, print without newline
+////////     "\nP - DC_LEX_PRINT_STREAM pop, print string or hex bytes
+//usage:	)
 //usage:     "\np - print top of the stack without popping"
 //usage:     "\nf - print entire stack"
-//usage:     "\nk - pop the value and set the precision"
+////////     "\nz - DC_LEX_STACK_LEVEL  push stack depth
+////////     "\nK - DC_LEX_SCALE        push precision
+////////     "\nI - DC_LEX_IBASE        push input radix
+////////     "\nO - DC_LEX_OBASE        push output radix
+//usage:	IF_FEATURE_DC_BIG(
+//usage:     "\nk - pop the value and set precision"
 //usage:     "\ni - pop the value and set input radix"
+//usage:	)
 //usage:     "\no - pop the value and set output radix"
 //usage:     "\nExamples: dc -e'2 2 + p' -> 4, dc -e'8 8 * 2 2 + / p' -> 16"
 //usage:
@@ -231,7 +274,7 @@ typedef struct BcNum {
 #define BC_NUM_MAX_IBASE        36
 // larger value might speed up BIGNUM calculations a bit:
 #define BC_NUM_DEF_SIZE         16
-#define BC_NUM_PRINT_WIDTH      69
+#define BC_NUM_PRINT_WIDTH      70
 
 #define BC_NUM_KARATSUBA_LEN    32
 
@@ -1343,6 +1386,12 @@ static void bc_num_copy(BcNum *d, BcNum
 	}
 }
 
+static void bc_num_init_and_copy(BcNum *d, BcNum *s)
+{
+	bc_num_init(d, s->len);
+	bc_num_copy(d, s);
+}
+
 static BC_STATUS zbc_num_ulong_abs(BcNum *n, unsigned long *result_p)
 {
 	size_t i;
@@ -1827,7 +1876,7 @@ static FAST_FUNC BC_STATUS zbc_num_k(BcN
 #define zbc_num_k(...) (zbc_num_k(__VA_ARGS__) COMMA_SUCCESS)
 {
 	BcStatus s;
-	size_t max = BC_MAX(a->len, b->len), max2 = (max + 1) / 2;
+	size_t max, max2;
 	BcNum l1, h1, l2, h2, m2, m1, z0, z1, z2, temp;
 	bool aone;
 
@@ -1841,9 +1890,9 @@ static FAST_FUNC BC_STATUS zbc_num_k(BcN
 		RETURN_STATUS(BC_STATUS_SUCCESS);
 	}
 
-	if (a->len + b->len < BC_NUM_KARATSUBA_LEN
-	 || a->len < BC_NUM_KARATSUBA_LEN
+	if (a->len < BC_NUM_KARATSUBA_LEN
 	 || b->len < BC_NUM_KARATSUBA_LEN
+	/* || a->len + b->len < BC_NUM_KARATSUBA_LEN - redundant check */
 	) {
 		size_t i, j, len;
 
@@ -1877,6 +1926,7 @@ static FAST_FUNC BC_STATUS zbc_num_k(BcN
 		RETURN_STATUS(BC_STATUS_SUCCESS);
 	}
 
+	max = BC_MAX(a->len, b->len);
 	bc_num_init(&l1, max);
 	bc_num_init(&h1, max);
 	bc_num_init(&l2, max);
@@ -1888,6 +1938,7 @@ static FAST_FUNC BC_STATUS zbc_num_k(BcN
 	bc_num_init(&z2, max);
 	bc_num_init(&temp, max + max);
 
+	max2 = (max + 1) / 2;
 	bc_num_split(a, max2, &l1, &h1);
 	bc_num_split(b, max2, &l2, &h2);
 
@@ -1940,11 +1991,8 @@ static FAST_FUNC BC_STATUS zbc_num_m(BcN
 	scale = BC_MIN(a->rdx + b->rdx, scale);
 	maxrdx = BC_MAX(maxrdx, scale);
 
-	bc_num_init(&cpa, a->len);
-	bc_num_init(&cpb, b->len);
-
-	bc_num_copy(&cpa, a);
-	bc_num_copy(&cpb, b);
+	bc_num_init_and_copy(&cpa, a);
+	bc_num_init_and_copy(&cpb, b);
 	cpa.neg = cpb.neg = false;
 
 	s = zbc_num_shift(&cpa, maxrdx);
@@ -2107,6 +2155,7 @@ static FAST_FUNC BC_STATUS zbc_num_p(BcN
 	BcNum copy;
 	unsigned long pow;
 	size_t i, powrdx, resrdx;
+	size_t a_rdx;
 	bool neg;
 
 	// GNU bc does not allow 2^2.0 - we do
@@ -2114,6 +2163,9 @@ static FAST_FUNC BC_STATUS zbc_num_p(BcN
 		if (b->num[i] != 0)
 			RETURN_STATUS(bc_error("not an integer"));
 
+// a^b for non-integer b (for a>0) can be implemented as exp(ln(a)*b).
+// Possibly better precision would be given by a^int(b) * exp(ln(a)*frac(b)).
+
 	if (b->len == 0) {
 		bc_num_one(c);
 		RETURN_STATUS(BC_STATUS_SUCCESS);
@@ -2135,18 +2187,31 @@ static FAST_FUNC BC_STATUS zbc_num_p(BcN
 	if (s) RETURN_STATUS(s);
 	// b is not used beyond this point
 
-	bc_num_init(&copy, a->len);
-	bc_num_copy(&copy, a);
+	bc_num_init_and_copy(&copy, a);
+	a_rdx = a->rdx; // pull it into a CPU register (hopefully)
+	// a is not used beyond this point
 
 	if (!neg) {
-		if (a->rdx > scale)
-			scale = a->rdx;
-		if (a->rdx * pow < scale)
-			scale = a->rdx * pow;
+		unsigned long new_scale;
+		if (a_rdx > scale)
+			scale = a_rdx;
+		new_scale = a_rdx * pow;
+		// Don't fall for multiplication overflow. Example:
+		// 0.01^2147483648 a_rdx:2 pow:0x80000000, 32bit mul is 0.
+//not that it matters with current algorithm, it would OOM on such large powers,
+//but it can be improved to detect zero results etc. Example: with scale=0,
+//result of 0.01^N for any N>1 is 0: 0.01^2 = 0.0001 ~= 0.00 (trunc to scale)
+//then this would matter:
+		// if a_rdx != 0 and new_scale < pow, we had overflow,
+		// correct "new_scale" value is larger than ULONG_MAX,
+		// thus larger than any possible current value of "scale",
+		// thus "scale = new_scale" should not be done:
+		if (a_rdx == 0 || new_scale >= pow)
+			if (new_scale < scale)
+				scale = new_scale;
 	}
 
-
-	for (powrdx = a->rdx; !(pow & 1); pow >>= 1) {
+	for (powrdx = a_rdx; !(pow & 1); pow >>= 1) {
 		powrdx <<= 1;
 		s = zbc_num_mul(&copy, &copy, &copy, powrdx);
 		if (s) goto err;
@@ -2448,8 +2513,7 @@ static void bc_array_copy(BcVec *d, cons
 	dnum = (void*)d->v;
 	snum = (void*)s->v;
 	for (i = 0; i < s->len; i++, dnum++, snum++) {
-		bc_num_init(dnum, snum->len);
-		bc_num_copy(dnum, snum);
+		bc_num_init_and_copy(dnum, snum);
 	}
 }
 
@@ -2463,8 +2527,7 @@ static void dc_result_copy(BcResult *d,
 		case XC_RESULT_IBASE:
 		case XC_RESULT_SCALE:
 		case XC_RESULT_OBASE:
-			bc_num_init(&d->d.n, src->d.n.len);
-			bc_num_copy(&d->d.n, &src->d.n);
+			bc_num_init_and_copy(&d->d.n, &src->d.n);
 			break;
 		case XC_RESULT_VAR:
 		case XC_RESULT_ARRAY:
@@ -2524,9 +2587,6 @@ static void xc_read_line(BcVec *vec, FIL
 
 #if ENABLE_FEATURE_BC_INTERACTIVE
 	if (G_interrupt) { // ^C was pressed
-# if ENABLE_FEATURE_EDITING
- intr:
-# endif
 		if (fp != stdin) {
 			// ^C while running a script (bc SCRIPT): die.
 			// We do not return to interactive prompt:
@@ -2537,11 +2597,11 @@ static void xc_read_line(BcVec *vec, FIL
 			// the shell would be unexpected.
 			xfunc_die();
 		}
-		// ^C while interactive input
+		// There was ^C while running calculations
 		G_interrupt = 0;
-		// GNU bc says "interrupted execution."
+		// GNU bc says "interrupted execution." (to stdout, not stderr)
 		// GNU dc says "Interrupt!"
-		fputs("\ninterrupted execution\n", stderr);
+		puts("\ninterrupted execution");
 	}
 
 # if ENABLE_FEATURE_EDITING
@@ -2552,9 +2612,10 @@ static void xc_read_line(BcVec *vec, FIL
 #  define line_buf bb_common_bufsiz1
 		n = read_line_input(G.line_input_state, "", line_buf, COMMON_BUFSIZE);
 		if (n <= 0) { // read errors or EOF, or ^D, or ^C
-			if (n == 0) // ^C
-				goto intr;
-			bc_vec_pushZeroByte(vec); // ^D or EOF (or error)
+			//GNU bc prints this on ^C:
+			//if (n == 0) // ^C
+			//	puts("(interrupt) Exiting bc.");
+			bc_vec_pushZeroByte(vec);
 			return;
 		}
 		i = 0;
@@ -5568,11 +5629,10 @@ static BC_STATUS zxc_num_printNum(BcNum
 	}
 
 	bc_vec_init(&stack, sizeof(long), NULL);
-	bc_num_init(&intp, n->len);
+	bc_num_init_and_copy(&intp, n);
 	bc_num_init(&fracp, n->rdx);
 	bc_num_init(&digit, width);
 	bc_num_init(&frac_len, BC_NUM_INT(n));
-	bc_num_copy(&intp, n);
 	bc_num_one(&frac_len);
 	base.cap = ARRAY_SIZE(base_digs);
 	base.num = base_digs;
@@ -5741,8 +5801,7 @@ static BC_STATUS zxc_program_negate(void
 	s = zxc_program_prep(&ptr, &num);
 	if (s) RETURN_STATUS(s);
 
-	bc_num_init(&res.d.n, num->len);
-	bc_num_copy(&res.d.n, num);
+	bc_num_init_and_copy(&res.d.n, num);
 	if (res.d.n.len) res.d.n.neg = !res.d.n.neg;
 
 	xc_program_retire(&res, XC_RESULT_TEMP);
@@ -5981,8 +6040,7 @@ static BC_STATUS zxc_program_assign(char
 		s = BC_STATUS_SUCCESS;
 	}
 
-	bc_num_init(&res.d.n, l->len);
-	bc_num_copy(&res.d.n, l);
+	bc_num_init_and_copy(&res.d.n, l);
 	xc_program_binOpRetire(&res);
 
 	RETURN_STATUS(s);
@@ -6079,8 +6137,7 @@ static BC_STATUS zbc_program_incdec(char
 
 	if (inst == BC_INST_INC_POST || inst == BC_INST_DEC_POST) {
 		copy.t = XC_RESULT_TEMP;
-		bc_num_init(&copy.d.n, num->len);
-		bc_num_copy(&copy.d.n, num);
+		bc_num_init_and_copy(&copy.d.n, num);
 	}
 
 	res.t = BC_RESULT_ONE;
@@ -6182,8 +6239,7 @@ static BC_STATUS zbc_program_return(char
 
 		s = zxc_program_num(operand, &num);
 		if (s) RETURN_STATUS(s);
-		bc_num_init(&res.d.n, num->len);
-		bc_num_copy(&res.d.n, num);
+		bc_num_init_and_copy(&res.d.n, num);
 		bc_vec_pop(&G.prog.results);
 	} else {
 		if (f->voidfunc)
@@ -6217,13 +6273,20 @@ static unsigned long xc_program_len(BcNu
 {
 	size_t len = n->len;
 
-	if (n->rdx != len) return len;
+	if (n->rdx != len)
+		// length(100): rdx 0 len 3, return 3
+		// length(0.01-0.01): rdx 2 len 0, return 2
+		// dc: 0.01 0.01 - Zp: rdx 2 len 0, return 1
+		return len != 0 ? len : (IS_BC ? n->rdx : 1);
+
+	// length(0): return 1
+	// length(0.000nnn): count nnn
 	for (;;) {
 		if (len == 0) break;
 		len--;
 		if (n->num[len] != 0) break;
 	}
-	return len;
+	return len + 1;
 }
 
 static BC_STATUS zxc_program_builtin(char inst)
@@ -6251,12 +6314,12 @@ static BC_STATUS zxc_program_builtin(cha
 	if (inst == XC_INST_SQRT)
 		s = zbc_num_sqrt(num, &res.d.n, G.prog.scale);
 #if ENABLE_BC
-	else if (len != 0 && opnd->t == XC_RESULT_ARRAY) {
+	else if (len && opnd->t == XC_RESULT_ARRAY) {
 		bc_num_ulong2num(&res.d.n, (unsigned long) ((BcVec *) num)->len);
 	}
 #endif
 #if ENABLE_DC
-	else if (len != 0 && !BC_PROG_NUM(opnd, num)) {
+	else if (len && !BC_PROG_NUM(opnd, num)) {
 		char **str;
 		size_t idx = opnd->t == XC_RESULT_STR ? opnd->d.id.idx : num->rdx;
 
@@ -6265,6 +6328,8 @@ static BC_STATUS zxc_program_builtin(cha
 	}
 #endif
 	else {
+//TODO: length(.00) and scale(.00) should return 2, they return 1 and 0 now
+//(don't forget to check that dc Z and X commands do not break)
 		bc_num_ulong2num(&res.d.n, len ? xc_program_len(num) : xc_program_scale(num));
 	}
 
@@ -6448,7 +6513,7 @@ static BC_STATUS zdc_program_printStream
 		char *str;
 		idx = (r->t == XC_RESULT_STR) ? r->d.id.idx : n->rdx;
 		str = *xc_program_str(idx);
-		fputs(str, stdout);
+		fputs_stdout(str);
 	}
 
 	RETURN_STATUS(s);
@@ -7372,11 +7437,29 @@ static unsigned xc_vm_envLen(const char
 
 	lenv = getenv(var);
 	len = BC_NUM_PRINT_WIDTH;
-	if (!lenv) return len;
+	if (lenv) {
+		len = bb_strtou(lenv, NULL, 10);
+		if (len == 0 || len > INT_MAX)
+			len = INT_MAX;
+		if (errno)
+			len = BC_NUM_PRINT_WIDTH;
+	}
 
-	len = bb_strtou(lenv, NULL, 10) - 1;
-	if (errno || len < 2 || len >= INT_MAX)
-		len = BC_NUM_PRINT_WIDTH;
+	// dc (GNU bc 1.07.1) 1.4.1 seems to use width
+	// 1 char wider than bc from the same package.
+	// Both default width, and xC_LINE_LENGTH=N are wider:
+	// "DC_LINE_LENGTH=5 dc -e'123456 p'" prints:
+	//	|1234\   |
+	//	|56      |
+	// "echo '123456' | BC_LINE_LENGTH=5 bc" prints:
+	//	|123\    |
+	//	|456     |
+	// Do the same, but it might be a bug in GNU package
+	if (IS_BC)
+		len--;
+
+	if (len < 2)
+		len = IS_BC ? BC_NUM_PRINT_WIDTH - 1 : BC_NUM_PRINT_WIDTH;
 
 	return len;
 }
@@ -7467,16 +7550,6 @@ int dc_main(int argc UNUSED_PARAM, char
 
 	INIT_G();
 
-	// TODO: dc (GNU bc 1.07.1) 1.4.1 seems to use width
-	// 1 char wider than bc from the same package.
-	// Both default width, and xC_LINE_LENGTH=N are wider:
-	// "DC_LINE_LENGTH=5 dc -e'123456 p'" prints:
-	//	|1234\   |
-	//	|56      |
-	// "echo '123456' | BC_LINE_LENGTH=5 bc" prints:
-	//	|123\    |
-	//	|456     |
-	// Do the same, or it's a bug?
 	xc_vm_init("DC_LINE_LENGTH");
 
 	// Run -e'SCRIPT' and -fFILE in order of appearance, then handle FILEs
diff -urpN busybox-1.33.1/miscutils/chat.c busybox-1.34.0/miscutils/chat.c
--- busybox-1.33.1/miscutils/chat.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/chat.c	2021-06-16 17:02:16.000000000 +0700
@@ -79,7 +79,7 @@
 //kbuild:lib-$(CONFIG_CHAT) += chat.o
 
 //usage:#define chat_trivial_usage
-//usage:       "EXPECT [SEND [EXPECT [SEND...]]]"
+//usage:       "EXPECT [SEND [EXPECT [SEND]]...]"
 //usage:#define chat_full_usage "\n\n"
 //usage:       "Useful for interacting with a modem connected to stdin/stdout.\n"
 //usage:       "A script consists of \"expect-send\" argument pairs.\n"
diff -urpN busybox-1.33.1/miscutils/conspy.c busybox-1.34.0/miscutils/conspy.c
--- busybox-1.33.1/miscutils/conspy.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/conspy.c	2021-04-15 00:05:01.000000000 +0700
@@ -107,8 +107,8 @@ enum {
 
 static void putcsi(const char *s)
 {
-	fputs(ESC"[", stdout);
-	fputs(s, stdout);
+	fputs_stdout(ESC"[");
+	fputs_stdout(s);
 }
 
 static void clrscr(void)
diff -urpN busybox-1.33.1/miscutils/dc.c busybox-1.34.0/miscutils/dc.c
--- busybox-1.33.1/miscutils/dc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/dc.c	2021-04-15 00:05:01.000000000 +0700
@@ -229,6 +229,7 @@ static void stack_machine(const char *ar
 	const struct op *o;
 
  next:
+//TODO: needs setlocale(LC_NUMERIC, "C")?
 	number = strtod(argument, &end);
 	if (end != argument) {
 		argument = end;
diff -urpN busybox-1.33.1/miscutils/flashcp.c busybox-1.34.0/miscutils/flashcp.c
--- busybox-1.33.1/miscutils/flashcp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/flashcp.c	2021-06-16 17:02:16.000000000 +0700
@@ -19,9 +19,9 @@
 //kbuild:lib-$(CONFIG_FLASHCP) += flashcp.o
 
 //usage:#define flashcp_trivial_usage
-//usage:       "-v FILE MTD_DEVICE"
+//usage:       "[-v] FILE MTD_DEVICE"
 //usage:#define flashcp_full_usage "\n\n"
-//usage:       "Copy an image to MTD device\n"
+//usage:       "Copy FILE to MTD device\n"
 //usage:     "\n	-v	Verbose"
 
 #include "libbb.h"
diff -urpN busybox-1.33.1/miscutils/i2c_tools.c busybox-1.34.0/miscutils/i2c_tools.c
--- busybox-1.33.1/miscutils/i2c_tools.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/miscutils/i2c_tools.c	2021-06-16 17:02:16.000000000 +0700
@@ -1149,12 +1149,12 @@ static void NORETURN list_i2c_busses_and
 		/* Simple version for ISA chips. */
 		snprintf(path, NAME_MAX, "%s/%s/name",
 			 i2cdev_path, de->d_name);
-		fp = fopen(path, "r");
+		fp = fopen_for_read(path);
 		if (fp == NULL) {
 			snprintf(path, NAME_MAX,
 				 "%s/%s/device/name",
 				 i2cdev_path, de->d_name);
-			fp = fopen(path, "r");
+			fp = fopen_for_read(path);
 		}
 
 		/* Non-ISA chips require the hard-way. */
@@ -1175,7 +1175,7 @@ static void NORETURN list_i2c_busses_and
 						 "%s/%s/device/%s/name",
 						 i2cdev_path, de->d_name,
 						 subde->d_name);
-					fp = fopen(path, "r");
+					fp = fopen_for_read(path);
 					break;
 				}
 			}
@@ -1394,7 +1394,7 @@ static void check_i2c_func(int fd)
 }
 
 //usage:#define i2ctransfer_trivial_usage
-//usage:       "[-fay] I2CBUS {rLENGTH[@ADDR] | wLENGTH[@ADDR] DATA...}..."
+//usage:       "[-fay] I2CBUS { rLENGTH[@ADDR] | wLENGTH[@ADDR] DATA...}..."
 //usage:#define i2ctransfer_full_usage "\n\n"
 //usage:       "Read/write I2C data in one transfer"
 //usage:     "\n"
diff -urpN busybox-1.33.1/miscutils/man.c busybox-1.34.0/miscutils/man.c
--- busybox-1.33.1/miscutils/man.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/man.c	2021-06-16 17:02:16.000000000 +0700
@@ -324,7 +324,7 @@ int man_main(int argc UNUSED_PARAM, char
 
 	/* is 1st ARG a SECTION? */
 	sec_list = conf_sec_list;
-	if (is_section_name(conf_sec_list, *argv)) {
+	if (is_section_name(conf_sec_list, *argv) && argv[1]) {
 		/* yes */
 		sec_list = *argv++;
 	}
diff -urpN busybox-1.33.1/miscutils/microcom.c busybox-1.34.0/miscutils/microcom.c
--- busybox-1.33.1/miscutils/microcom.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/microcom.c	2021-06-16 17:02:16.000000000 +0700
@@ -18,14 +18,14 @@
 //kbuild:lib-$(CONFIG_MICROCOM) += microcom.o
 
 //usage:#define microcom_trivial_usage
-//usage:       "[-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY"
+//usage:       "[-d DELAY_MS] [-t TIMEOUT_MS ] [-s SPEED] [-X] TTY"
 //usage:#define microcom_full_usage "\n\n"
-//usage:       "Copy bytes for stdin to TTY and from TTY to stdout\n"
-//usage:     "\n	-d	Wait up to DELAY ms for TTY output before sending every"
-//usage:     "\n		next byte to it"
-//usage:     "\n	-t	Exit if both stdin and TTY are silent for TIMEOUT ms"
-//usage:     "\n	-s	Set serial line to SPEED"
-//usage:     "\n	-X	Disable special meaning of NUL and Ctrl-X from stdin"
+//usage:       "Copy bytes from stdin to TTY and from TTY to stdout\n"
+//usage:     "\n	-d DELAY	Wait up to DELAY ms for TTY output before sending"
+//usage:     "\n			every next byte to it"
+//usage:     "\n	-t TIMEOUT	Exit if both stdin and TTY are silent for TIMEOUT ms"
+//usage:     "\n	-s SPEED	Set serial line to SPEED"
+//usage:     "\n	-X		Disable special meaning of NUL and Ctrl-X from stdin"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
diff -urpN busybox-1.33.1/miscutils/mt.c busybox-1.34.0/miscutils/mt.c
--- busybox-1.33.1/miscutils/mt.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/mt.c	2021-06-16 17:02:16.000000000 +0700
@@ -19,7 +19,7 @@
 //usage:#define mt_full_usage "\n\n"
 //usage:       "Control magnetic tape drive operation\n"
 //usage:       "\n"
-//usage:       "Available Opcodes:\n"
+//usage:       "Opcodes:\n"
 //usage:       "\n"
 //usage:       "bsf bsfm bsr bss datacompression drvbuffer eof eom erase\n"
 //usage:       "fsf fsfm fsr fss load lock mkpart nop offline ras1 ras2\n"
diff -urpN busybox-1.33.1/miscutils/strings.c busybox-1.34.0/miscutils/strings.c
--- busybox-1.33.1/miscutils/strings.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/strings.c	2021-06-16 17:02:16.000000000 +0700
@@ -18,7 +18,7 @@
 //kbuild:lib-$(CONFIG_STRINGS) += strings.o
 
 //usage:#define strings_trivial_usage
-//usage:       "[-fo] [-t o/d/x] [-n LEN] [FILE]..."
+//usage:       "[-fo] [-t o|d|x] [-n LEN] [FILE]..."
 //usage:#define strings_full_usage "\n\n"
 //usage:       "Display printable strings in a binary file\n"
 //We usually don't bother user with "nop" options. They work, but are not shown:
@@ -26,7 +26,7 @@
 //unimplemented alternative is -d: Only strings from initialized, loaded data sections
 //usage:     "\n	-f		Precede strings with filenames"
 //usage:     "\n	-o		Precede strings with octal offsets"
-//usage:     "\n	-t o/d/x	Precede strings with offsets in base 8/10/16"
+//usage:     "\n	-t o|d|x	Precede strings with offsets in base 8/10/16"
 //usage:     "\n	-n LEN		At least LEN characters form a string (default 4)"
 
 #include "libbb.h"
@@ -92,7 +92,7 @@ int strings_main(int argc UNUSED_PARAM,
 						if (option_mask32 & (PRINT_OFFSET | PRINT_RADIX)) {
 							printf(radix_fmt, offset - n);
 						}
-						fputs(string, stdout);
+						fputs_stdout(string);
 					}
 					count++;
 				}
diff -urpN busybox-1.33.1/miscutils/time.c busybox-1.34.0/miscutils/time.c
--- busybox-1.33.1/miscutils/time.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/time.c	2021-04-27 00:21:10.000000000 +0700
@@ -33,6 +33,13 @@
 
 #include "libbb.h"
 
+#ifndef HAVE_WAIT3
+static pid_t wait3(int *status, int options, struct rusage *rusage)
+{
+	return wait4(-1, status, options, rusage);
+}
+#endif
+
 /* Information on the resources used by a child process.  */
 typedef struct {
 	int waitstatus;
diff -urpN busybox-1.33.1/miscutils/ts.c busybox-1.34.0/miscutils/ts.c
--- busybox-1.33.1/miscutils/ts.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/miscutils/ts.c	2021-06-16 17:02:16.000000000 +0700
@@ -13,7 +13,10 @@
 
 //usage:#define ts_trivial_usage
 //usage:       "[-is] [STRFTIME]"
-//usage:#define ts_full_usage ""
+//usage:#define ts_full_usage "\n\n"
+//usage:       "Pipe stdin to stdout, add timestamp to each line\n"
+//usage:     "\n	-s	Time since start"
+//usage:     "\n	-i	Time since previous line"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -47,13 +50,13 @@ int ts_main(int argc UNUSED_PARAM, char
 
 #define date_buf bb_common_bufsiz1
 	setup_common_bufsiz();
-	gettimeofday(&base, NULL);
+	xgettimeofday(&base);
 
 	while ((line = xmalloc_fgets(stdin)) != NULL) {
 		struct timeval ts;
 		struct tm tm_time;
 
-		gettimeofday(&ts, NULL);
+		xgettimeofday(&ts);
 		if (opt) {
 			/* -i and/or -s */
 			struct timeval ts1 = ts1;
diff -urpN busybox-1.33.1/miscutils/ubi_tools.c busybox-1.34.0/miscutils/ubi_tools.c
--- busybox-1.33.1/miscutils/ubi_tools.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/ubi_tools.c	2021-06-16 17:02:16.000000000 +0700
@@ -251,7 +251,7 @@ int ubi_tools_main(int argc UNUSED_PARAM
 	} else
 
 //usage:#define ubirmvol_trivial_usage
-//usage:       "-n VOLID / -N VOLNAME UBI_DEVICE"
+//usage:       "-n VOLID | -N VOLNAME UBI_DEVICE"
 //usage:#define ubirmvol_full_usage "\n\n"
 //usage:       "Remove UBI volume\n"
 //usage:     "\n	-n VOLID	Volume ID"
diff -urpN busybox-1.33.1/miscutils/watchdog.c busybox-1.34.0/miscutils/watchdog.c
--- busybox-1.33.1/miscutils/watchdog.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/miscutils/watchdog.c	2021-04-15 00:05:01.000000000 +0700
@@ -18,6 +18,21 @@
 //config:	watchdog applet ever fails to write the magic character within a
 //config:	certain amount of time, the watchdog device assumes the system has
 //config:	hung, and will cause the hardware to reboot.
+//config:
+//config:config FEATURE_WATCHDOG_OPEN_TWICE
+//config:	bool "Open watchdog device twice, closing it gracefully in between"
+//config:	depends on WATCHDOG
+//config:	default n   # this behavior was essentially a hack for a broken driver
+//config:	help
+//config:	When enabled, the watchdog device is opened and then immediately
+//config:	magic-closed, before being opened a second time. This may be necessary
+//config:	for some watchdog devices, but can cause spurious warnings in the
+//config:	kernel log if the nowayout feature is enabled. If this workaround
+//config:	is really needed for you machine to work properly, consider whether
+//config:	it should be fixed in the kernel driver instead. Even when disabled,
+//config:	the behaviour is easily emulated with a "printf 'V' > /dev/watchdog"
+//config:	immediately before starting the busybox watchdog daemon. Say n unless
+//config:	you know that you absolutely need this.
 
 //applet:IF_WATCHDOG(APPLET(watchdog, BB_DIR_SBIN, BB_SUID_DROP))
 
@@ -50,10 +65,6 @@
 # define WDIOS_ENABLECARD 2
 #endif
 
-#define OPT_FOREGROUND  (1 << 0)
-#define OPT_STIMER      (1 << 1)
-#define OPT_HTIMER      (1 << 2)
-
 static void shutdown_watchdog(void)
 {
 	static const char V = 'V';
@@ -73,6 +84,7 @@ static void watchdog_open(const char* de
 	/* Use known fd # - avoid needing global 'int fd' */
 	xmove_fd(xopen(device, O_WRONLY), 3);
 
+#if ENABLE_FEATURE_WATCHDOG_OPEN_TWICE
 	/* If the watchdog driver can do something other than cause a reboot
 	 * on a timeout, then it's possible this program may be starting from
 	 * a state when the watchdog hadn't been previously stopped with
@@ -82,6 +94,7 @@ static void watchdog_open(const char* de
 	shutdown_watchdog();
 
 	xmove_fd(xopen(device, O_WRONLY), 3);
+#endif
 }
 
 int watchdog_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -100,6 +113,9 @@ int watchdog_main(int argc UNUSED_PARAM,
 	char *st_arg;
 	char *ht_arg;
 
+#define OPT_FOREGROUND  (1 << 0)
+#define OPT_STIMER      (1 << 1)
+#define OPT_HTIMER      (1 << 2)
 	opts = getopt32(argv, "^" "Ft:T:" "\0" "=1"/*must have exactly 1 arg*/,
 				&st_arg, &ht_arg
 	);
@@ -132,7 +148,7 @@ int watchdog_main(int argc UNUSED_PARAM,
 #if 0
 	ioctl_or_warn(3, WDIOC_GETTIMEOUT, &htimer_duration);
 	printf("watchdog: SW timer is %dms, HW timer is %ds\n",
-		stimer_duration, htimer_duration * 1000);
+		stimer_duration, htimer_duration);
 #endif
 
 	write_pidfile_std_path_and_ext("watchdog");
diff -urpN busybox-1.33.1/modutils/modinfo.c busybox-1.34.0/modutils/modinfo.c
--- busybox-1.33.1/modutils/modinfo.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/modutils/modinfo.c	2021-07-20 21:57:20.000000000 +0700
@@ -131,7 +131,7 @@ static void modinfo(const char *path, co
 //usage:     "\n	-p		Shortcut for '-F parm'"
 ////usage:     "\n	-n		Shortcut for '-F filename'"
 //usage:     "\n	-F keyword	Keyword to look for"
-//usage:     "\n	-0		Separate output with NULs"
+//usage:     "\n	-0		NUL terminated output"
 //usage:#define modinfo_example_usage
 //usage:       "$ modinfo -F vermagic loop\n"
 
diff -urpN busybox-1.33.1/modutils/modprobe.c busybox-1.34.0/modutils/modprobe.c
--- busybox-1.33.1/modutils/modprobe.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/modutils/modprobe.c	2021-07-20 21:57:20.000000000 +0700
@@ -629,8 +629,9 @@ int modprobe_main(int argc UNUSED_PARAM,
 		config_close(parser);
 
 		parser = config_open2("modules.builtin", fopen_for_read);
+		/* this file contains lines like "kernel/fs/binfmt_script.ko" */
 		while (config_read(parser, &s, 1, 1, "# \t", PARSE_NORMAL))
-			get_or_add_modentry(s)->flags |= MODULE_FLAG_BUILTIN;
+			get_or_add_modentry(bb_basename(s))->flags |= MODULE_FLAG_BUILTIN;
 		config_close(parser);
 	}
 
diff -urpN busybox-1.33.1/networking/brctl.c busybox-1.34.0/networking/brctl.c
--- busybox-1.33.1/networking/brctl.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/brctl.c	2021-04-15 00:05:01.000000000 +0700
@@ -89,6 +89,7 @@ static unsigned str_to_jiffies(const cha
 {
 	double dd;
 	char *endptr;
+//TODO: needs setlocale(LC_NUMERIC, "C")?
 	dd = /*bb_*/strtod(time_str, &endptr);
 	if (endptr == time_str || dd < 0)
 		bb_error_msg_and_die(bb_msg_invalid_arg_to, time_str, "timespec");
@@ -156,7 +157,7 @@ static int show_bridge(const char *name,
 	else
 	if (LONE_CHAR(filedata, '1'))
 		strcpy(filedata, "yes");
-	fputs(filedata, stdout);
+	fputs_stdout(filedata);
 
 	/* sfx points past "BR/bridge/", turn it into "BR/brif": */
 	sfx[-4] = 'f'; sfx[-3] = '\0';
diff -urpN busybox-1.33.1/networking/dnsd.c busybox-1.34.0/networking/dnsd.c
--- busybox-1.33.1/networking/dnsd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/dnsd.c	2021-04-15 00:05:01.000000000 +0700
@@ -379,7 +379,8 @@ Domain name in a message can be represen
  */
 static int process_packet(struct dns_entry *conf_data,
 		uint32_t conf_ttl,
-		uint8_t *buf)
+		uint8_t *buf,
+		unsigned buflen)
 {
 	struct dns_head *head;
 	struct type_and_class *unaligned_type_class;
@@ -402,9 +403,6 @@ static int process_packet(struct dns_ent
 		bb_simple_error_msg("response packet, ignored");
 		return 0; /* don't reply */
 	}
-	/* QR = 1 "response", RCODE = 4 "Not Implemented" */
-	outr_flags = htons(0x8000 | 4);
-	err_msg = NULL;
 
 	/* start of query string */
 	query_string = (void *)(head + 1);
@@ -416,6 +414,15 @@ static int process_packet(struct dns_ent
 	/* where to append answer block */
 	answb = (void *)(unaligned_type_class + 1);
 
+	if (buflen < answb - buf) {
+		bb_simple_error_msg("packet too short");
+		return 0; /* don't reply */
+	}
+
+	/* QR = 1 "response", RCODE = 4 "Not Implemented" */
+	outr_flags = htons(0x8000 | 4);
+	err_msg = NULL;
+
 	/* OPCODE != 0 "standard query"? */
 	if ((head->flags & htons(0x7800)) != 0) {
 		err_msg = "opcode != 0";
@@ -559,7 +566,7 @@ int dnsd_main(int argc UNUSED_PARAM, cha
 		if (OPT_verbose)
 			bb_simple_info_msg("got UDP packet");
 		buf[r] = '\0'; /* paranoia */
-		r = process_packet(conf_data, conf_ttl, buf);
+		r = process_packet(conf_data, conf_ttl, buf, r);
 		if (r <= 0)
 			continue;
 		send_to_from(udps, buf, r, 0, &from->u.sa, &to->u.sa, lsa->len);
diff -urpN busybox-1.33.1/networking/ftpd.c busybox-1.34.0/networking/ftpd.c
--- busybox-1.33.1/networking/ftpd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/ftpd.c	2021-07-20 21:57:20.000000000 +0700
@@ -54,7 +54,7 @@
 //kbuild:lib-$(CONFIG_FTPD) += ftpd.o
 
 //usage:#define ftpd_trivial_usage
-//usage:       "[-wvS]"IF_FEATURE_FTPD_AUTHENTICATION(" [-a USER]")" [-t N] [-T N] [DIR]"
+//usage:       "[-wvS]"IF_FEATURE_FTPD_AUTHENTICATION(" [-a USER]")" [-t SEC] [-T SEC] [DIR]"
 //usage:#define ftpd_full_usage "\n\n"
 //usage:	IF_NOT_FEATURE_FTPD_AUTHENTICATION(
 //usage:       "Anonymous FTP server. Client access occurs under ftpd's UID.\n"
@@ -63,7 +63,7 @@
 //usage:       "FTP server. "
 //usage:	)
 //usage:       "Chroots to DIR, if this fails (run by non-root), cds to it.\n"
-//usage:       "Should be used as inetd service, inetd.conf line:\n"
+//usage:       "It is an inetd service, inetd.conf line:\n"
 //usage:       "	21 stream tcp nowait root ftpd ftpd /files/to/serve\n"
 //usage:       "Can be run from tcpsvd:\n"
 //usage:       "	tcpsvd -vE 0.0.0.0 21 ftpd /files/to/serve"
diff -urpN busybox-1.33.1/networking/httpd.c busybox-1.34.0/networking/httpd.c
--- busybox-1.33.1/networking/httpd.c	2021-03-09 06:28:26.000000000 +0700
+++ busybox-1.34.0/networking/httpd.c	2021-06-16 17:02:16.000000000 +0700
@@ -298,8 +298,19 @@
 # include <sys/sendfile.h>
 #endif
 
+/* see sys/netinet6/in6.h */
+#if defined(__FreeBSD__)
+# define s6_addr32 __u6_addr.__u6_addr32
+#endif
+
 #define DEBUG 0
 
+#if DEBUG
+# define dbg(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define dbg(...) ((void)0)
+#endif
+
 #define IOBUF_SIZE 8192
 #define MAX_HTTP_HEADERS_SIZE (32*1024)
 
@@ -339,13 +350,6 @@ typedef struct Htaccess_Proxy {
 	char *url_to;
 } Htaccess_Proxy;
 
-typedef enum CGI_type {
-	CGI_NONE = 0,
-	CGI_NORMAL,
-	CGI_INDEX,
-	CGI_INTERPRETER,
-} CGI_type;
-
 enum {
 	HTTP_OK = 200,
 	HTTP_PARTIAL_CONTENT = 206,
@@ -550,7 +554,6 @@ enum {
 enum {
 	SEND_HEADERS     = (1 << 0),
 	SEND_BODY        = (1 << 1),
-	SEND_HEADERS_AND_BODY = SEND_HEADERS + SEND_BODY,
 };
 static void send_file_and_exit(const char *url, int what) NORETURN;
 
@@ -682,7 +685,7 @@ enum {
 	SIGNALED_PARSE = 1, /* path will be "/etc" */
 	SUBDIR_PARSE   = 2, /* path will be derived from URL */
 };
-static void parse_conf(const char *path, int flag)
+static int parse_conf(const char *path, int flag)
 {
 	/* internally used extra flag state */
 	enum { TRY_CURDIR_PARSE = 3 };
@@ -716,7 +719,7 @@ static void parse_conf(const char *path,
 	while ((f = fopen_for_read(filename)) == NULL) {
 		if (flag >= SUBDIR_PARSE) { /* SUBDIR or TRY_CURDIR */
 			/* config file not found, no changes to config */
-			return;
+			return -1;
 		}
 		if (flag == FIRST_PARSE) {
 			/* -c CONFFILE given, but CONFFILE doesn't exist? */
@@ -974,6 +977,7 @@ static void parse_conf(const char *path,
 	} /* while (fgets) */
 
 	fclose(f);
+	return 0;
 }
 
 #if ENABLE_FEATURE_HTTPD_ENCODE_URL_STR
@@ -1160,8 +1164,7 @@ static void send_headers(unsigned respon
 			fprintf(stderr, "headers: '%s'\n", iobuf);
 		}
 		full_write(STDOUT_FILENO, iobuf, len);
-		if (DEBUG)
-			fprintf(stderr, "writing error page: '%s'\n", error_page);
+		dbg("writing error page: '%s'\n", error_page);
 		return send_file_and_exit(error_page, SEND_BODY);
 	}
 #endif
@@ -1502,8 +1505,7 @@ static NOINLINE void cgi_io_loop_and_exi
 			}
 			if (full_write(STDOUT_FILENO, rbuf, count) != count)
 				break;
-			if (DEBUG)
-				fprintf(stderr, "cgi read %d bytes: '%.*s'\n", count, count, rbuf);
+			dbg("cgi read %d bytes: '%.*s'\n", count, count, rbuf);
 		} /* if (pfd[FROM_CGI].revents) */
 	} /* while (1) */
 	log_and_exit();
@@ -1749,8 +1751,7 @@ static NOINLINE void send_file_and_exit(
 		/* file_size and last_mod are already populated */
 	}
 	if (fd < 0) {
-		if (DEBUG)
-			bb_perror_msg("can't open '%s'", url);
+		dbg("can't open '%s'\n", url);
 		/* Error pages are sent by using send_file_and_exit(SEND_BODY).
 		 * IOW: it is unsafe to call send_headers_and_exit
 		 * if what is SEND_BODY! Can recurse! */
@@ -1763,8 +1764,7 @@ static NOINLINE void send_file_and_exit(
 	sprintf(G.etag, "\"%llx-%llx\"", (unsigned long long)last_mod, (unsigned long long)file_size);
 
 	if (G.if_none_match) {
-		if (DEBUG)
-			bb_perror_msg("If-None-Match and file's ETag are: '%s' '%s'\n", G.if_none_match, G.etag);
+		dbg("If-None-Match:'%s' file's ETag:'%s'\n", G.if_none_match, G.etag);
 		/* Weak ETag comparision.
 		 * If-None-Match may have many ETags but they are quoted so we can use simple substring search */
 		if (strstr(G.if_none_match, G.etag))
@@ -1840,9 +1840,7 @@ static NOINLINE void send_file_and_exit(
 		}
 	}
 
-	if (DEBUG)
-		bb_error_msg("sending file '%s' content-type: %s",
-			url, found_mime_type);
+	dbg("sending file '%s' content-type:%s\n", url, found_mime_type);
 
 #if ENABLE_FEATURE_HTTPD_RANGES
 	if (what == SEND_BODY /* err pages and ranges don't mix */
@@ -1912,9 +1910,7 @@ static void if_ip_denied_send_HTTP_FORBI
 	Htaccess_IP *cur;
 
 	for (cur = G.ip_a_d; cur; cur = cur->next) {
-#if DEBUG
-		fprintf(stderr,
-			"checkPermIP: '%s' ? '%u.%u.%u.%u/%u.%u.%u.%u'\n",
+		dbg("checkPermIP: '%s' ? '%u.%u.%u.%u/%u.%u.%u.%u'\n",
 			rmt_ip_str,
 			(unsigned char)(cur->ip >> 24),
 			(unsigned char)(cur->ip >> 16),
@@ -1925,7 +1921,6 @@ static void if_ip_denied_send_HTTP_FORBI
 			(unsigned char)(cur->mask >> 8),
 			(unsigned char)(cur->mask)
 		);
-#endif
 		if ((remote_ip & cur->mask) == cur->ip) {
 			if (cur->allow_deny == 'A')
 				return;
@@ -2017,8 +2012,7 @@ static int check_user_passwd(const char
 		if (prev && strcmp(prev, dir_prefix) != 0)
 			continue;
 
-		if (DEBUG)
-			fprintf(stderr, "checkPerm: '%s' ? '%s'\n", dir_prefix, user_and_passwd);
+		dbg("checkPerm: '%s' ? '%s'\n", dir_prefix, user_and_passwd);
 
 		/* If it's not a prefix match, continue searching */
 		len = strlen(dir_prefix);
@@ -2169,7 +2163,6 @@ static void send_REQUEST_TIMEOUT_and_exi
 static void handle_incoming_and_exit(const len_and_sockaddr *fromAddr) NORETURN;
 static void handle_incoming_and_exit(const len_and_sockaddr *fromAddr)
 {
-	static const char request_GET[] ALIGN1 = "GET";
 	struct stat sb;
 	char *urlcopy;
 	char *urlp;
@@ -2180,14 +2173,21 @@ static void handle_incoming_and_exit(con
 #if ENABLE_FEATURE_HTTPD_CGI
 	unsigned total_headers_len;
 #endif
-#if ENABLE_FEATURE_HTTPD_CGI
-	static const char request_HEAD[] ALIGN1 = "HEAD";
 	const char *prequest;
-	unsigned long length = 0;
-	enum CGI_type cgi_type = CGI_NONE;
-#elif ENABLE_FEATURE_HTTPD_PROXY
-#define prequest request_GET
-	unsigned long length = 0;
+	static const char request_GET[]  ALIGN1 = "GET";
+	static const char request_HEAD[] ALIGN1 = "HEAD";
+#if ENABLE_FEATURE_HTTPD_CGI
+	static const char request_POST[] ALIGN1 = "POST";
+	unsigned long POST_length;
+	enum CGI_type {
+		CGI_NONE = 0,
+		CGI_NORMAL,
+		CGI_INDEX,
+		CGI_INTERPRETER,
+	} cgi_type = CGI_NONE;
+#endif
+#if ENABLE_FEATURE_HTTPD_PROXY
+	Htaccess_Proxy *proxy_entry;
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
 	smallint authorized = -1;
@@ -2227,35 +2227,33 @@ static void handle_incoming_and_exit(con
 	/* Install timeout handler. get_line() needs it. */
 	signal(SIGALRM, send_REQUEST_TIMEOUT_and_exit);
 
-	if (!get_line()) /* EOF or error or empty line */
-		send_headers_and_exit(HTTP_BAD_REQUEST);
+	if (!get_line()) { /* EOF or error or empty line */
+		/* Observed Firefox to "speculatively" open
+		 * extra connections to a new site on first access,
+		 * they are closed in ~5 seconds with nothing
+		 * being sent at all.
+		 * (Presumably it's a method to decrease latency?)
+		 */
+		if (verbose > 2)
+			bb_simple_error_msg("eof on read, closing");
+		/* Don't bother generating error page in this case,
+		 * just close the socket.
+		 */
+		//send_headers_and_exit(HTTP_BAD_REQUEST);
+		_exit(xfunc_error_retval);
+	}
+	dbg("Request:'%s'\n", iobuf);
 
-	/* Determine type of request (GET/POST) */
+	/* Find URL */
 	// rfc2616: method and URI is separated by exactly one space
 	//urlp = strpbrk(iobuf, " \t"); - no, tab isn't allowed
 	urlp = strchr(iobuf, ' ');
 	if (urlp == NULL)
 		send_headers_and_exit(HTTP_BAD_REQUEST);
 	*urlp++ = '\0';
-#if ENABLE_FEATURE_HTTPD_CGI
-	prequest = request_GET;
-	if (strcasecmp(iobuf, prequest) != 0) {
-		prequest = request_HEAD;
-		if (strcasecmp(iobuf, prequest) != 0) {
-			prequest = "POST";
-			if (strcasecmp(iobuf, prequest) != 0)
-				send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
-		}
-	}
-#else
-	if (strcasecmp(iobuf, request_GET) != 0)
-		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
-#endif
-	// rfc2616: method and URI is separated by exactly one space
 	//urlp = skip_whitespace(urlp); - should not be necessary
 	if (urlp[0] != '/')
 		send_headers_and_exit(HTTP_BAD_REQUEST);
-
 	/* Find end of URL */
 	HTTP_slash = strchr(urlp, ' ');
 	/* Is it " HTTP/"? */
@@ -2263,48 +2261,62 @@ static void handle_incoming_and_exit(con
 		send_headers_and_exit(HTTP_BAD_REQUEST);
 	*HTTP_slash++ = '\0';
 
-	/* Copy URL from after "GET "/"POST " to stack-allocated char[] */
-	urlcopy = alloca((HTTP_slash - urlp) + 2 + strlen(index_page));
-	/*if (urlcopy == NULL)
-	 *	send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);*/
-	strcpy(urlcopy, urlp);
-	/* NB: urlcopy ptr is never changed after this */
-
 #if ENABLE_FEATURE_HTTPD_PROXY
-	{
+	proxy_entry = find_proxy_entry(urlp);
+	if (proxy_entry) {
 		int proxy_fd;
 		len_and_sockaddr *lsa;
-		Htaccess_Proxy *proxy_entry = find_proxy_entry(urlcopy);
 
-		if (proxy_entry) {
-			if (verbose > 1)
-				bb_error_msg("proxy:%s", urlcopy);
-			lsa = host2sockaddr(proxy_entry->host_port, 80);
-			if (!lsa)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			proxy_fd = socket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
-			if (proxy_fd < 0)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
-				send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
-			/* Disable peer header reading timeout */
-			alarm(0);
-			/* Config directive was of the form:
-			 *   P:/url:[http://]hostname[:port]/new/path
-			 * When /urlSFX is requested, reverse proxy it
-			 * to http://hostname[:port]/new/pathSFX
-			 */
-			fdprintf(proxy_fd, "%s %s%s %s\r\n",
-					prequest, /* "GET" or "POST" */
-					proxy_entry->url_to, /* "/new/path" */
-					urlcopy + strlen(proxy_entry->url_from), /* "SFX" */
-					HTTP_slash /* "HTTP/xyz" */
-			);
-			cgi_io_loop_and_exit(proxy_fd, proxy_fd, /*max POST length:*/ INT_MAX);
-		}
+		if (verbose > 1)
+			bb_error_msg("proxy:%s", urlp);
+		lsa = host2sockaddr(proxy_entry->host_port, 80);
+		if (!lsa)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		proxy_fd = socket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
+		if (proxy_fd < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		/* Disable peer header reading timeout */
+		alarm(0);
+		/* Config directive was of the form:
+		 *   P:/url:[http://]hostname[:port]/new/path
+		 * When /urlSFX is requested, reverse proxy it
+		 * to http://hostname[:port]/new/pathSFX
+		 */
+		fdprintf(proxy_fd, "%s %s%s %s\r\n",
+				iobuf, /* "GET" / "POST" / etc */
+				proxy_entry->url_to, /* "/new/path" */
+				urlp + strlen(proxy_entry->url_from), /* "SFX" */
+				HTTP_slash /* "HTTP/xyz" */
+		);
+		cgi_io_loop_and_exit(proxy_fd, proxy_fd, /*max POST length:*/ INT_MAX);
 	}
 #endif
 
+	/* Determine type of request (GET/POST/...) */
+	prequest = request_GET;
+	if (strcasecmp(iobuf, prequest) == 0)
+		goto found;
+	prequest = request_HEAD;
+	if (strcasecmp(iobuf, prequest) == 0)
+		goto found;
+#if !ENABLE_FEATURE_HTTPD_CGI
+	send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
+#else
+	prequest = request_POST;
+	if (strcasecmp(iobuf, prequest) == 0)
+		goto found;
+	/* For CGI, allow DELETE, PUT, OPTIONS, etc too */
+	prequest = alloca(16);
+	safe_strncpy((char*)prequest, iobuf, 16);
+#endif
+ found:
+	/* Copy URL to stack-allocated char[] */
+	urlcopy = alloca((HTTP_slash - urlp) + 2 + strlen(index_page));
+	strcpy(urlcopy, urlp);
+	/* NB: urlcopy ptr is never changed after this */
+
 	/* Extract url args if present */
 	g_query = strchr(urlcopy, '?');
 	if (g_query)
@@ -2323,7 +2335,7 @@ static void handle_incoming_and_exit(con
 	/* Algorithm stolen from libbb bb_simplify_path(),
 	 * but don't strdup, retain trailing slash, protect root */
 	urlp = tptr = urlcopy;
-	for (;;) {
+	while (1) {
 		if (*urlp == '/') {
 			/* skip duplicate (or initial) slash */
 			if (*tptr == '/') {
@@ -2354,13 +2366,6 @@ static void handle_incoming_and_exit(con
 		tptr++;
 	}
 
-	/* If URL is a directory, add '/' */
-	if (urlp[-1] != '/') {
-		if (is_directory(urlcopy + 1, /*followlinks:*/ 1)) {
-			found_moved_temporarily = urlcopy;
-		}
-	}
-
 	/* Log it */
 	if (verbose > 1)
 		bb_error_msg("url:%s", urlcopy);
@@ -2369,11 +2374,9 @@ static void handle_incoming_and_exit(con
 	while ((tptr = strchr(tptr + 1, '/')) != NULL) {
 		/* have path1/path2 */
 		*tptr = '\0';
-		if (is_directory(urlcopy + 1, /*followlinks:*/ 1)) {
-			/* may have subdir config */
-			parse_conf(urlcopy + 1, SUBDIR_PARSE);
+		/* may have subdir config */
+		if (parse_conf(urlcopy + 1, SUBDIR_PARSE) == 0)
 			if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
-		}
 		*tptr = '/';
 	}
 
@@ -2400,36 +2403,45 @@ static void handle_incoming_and_exit(con
 		strcpy(urlp, index_page);
 	}
 	if (stat(tptr, &sb) == 0) {
+		/* If URL is a directory with no slash, set up
+		 * "HTTP/1.1 302 Found" "Location: /dir/" reply */
+		if (urlp[-1] != '/' && S_ISDIR(sb.st_mode)) {
+			found_moved_temporarily = urlcopy;
+		} else {
 #if ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
-		char *suffix = strrchr(tptr, '.');
-		if (suffix) {
-			Htaccess *cur;
-			for (cur = script_i; cur; cur = cur->next) {
-				if (strcmp(cur->before_colon + 1, suffix) == 0) {
-					cgi_type = CGI_INTERPRETER;
-					break;
+			char *suffix = strrchr(tptr, '.');
+			if (suffix) {
+				Htaccess *cur;
+				for (cur = script_i; cur; cur = cur->next) {
+					if (strcmp(cur->before_colon + 1, suffix) == 0) {
+						cgi_type = CGI_INTERPRETER;
+						break;
+					}
 				}
 			}
-		}
 #endif
-		if (!found_moved_temporarily) {
 			file_size = sb.st_size;
 			last_mod = sb.st_mtime;
 		}
 	}
 #if ENABLE_FEATURE_HTTPD_CGI
 	else if (urlp[-1] == '/') {
-		/* It's a dir URL and there is no index.html
-		 * Try cgi-bin/index.cgi */
-		if (access("/cgi-bin/index.cgi"+1, X_OK) == 0) {
-			cgi_type = CGI_INDEX;
-		}
+		/* It's a dir URL and there is no index.html */
+		/* Is there cgi-bin/index.cgi? */
+		if (access("/cgi-bin/index.cgi"+1, X_OK) != 0)
+			send_headers_and_exit(HTTP_NOT_FOUND); /* no */
+		cgi_type = CGI_INDEX;
 	}
 #endif
+
+#if ENABLE_FEATURE_HTTPD_BASIC_AUTH || ENABLE_FEATURE_HTTPD_CGI
+	/* check_user_passwd() would be confused by added .../index.html, truncate it */
 	urlp[0] = '\0';
+#endif
 
 #if ENABLE_FEATURE_HTTPD_CGI
 	total_headers_len = 0;
+	POST_length = 0;
 #endif
 
 	/* Read until blank line */
@@ -2443,26 +2455,18 @@ static void handle_incoming_and_exit(con
 		if (total_headers_len >= MAX_HTTP_HEADERS_SIZE)
 			send_headers_and_exit(HTTP_ENTITY_TOO_LARGE);
 #endif
-		if (DEBUG)
-			bb_error_msg("header: '%s'", iobuf);
-#if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
-		/* Try and do our best to parse more lines */
-		if (STRNCASECMP(iobuf, "Content-Length:") == 0) {
-			/* extra read only for POST */
-			if (prequest != request_GET
-# if ENABLE_FEATURE_HTTPD_CGI
-			 && prequest != request_HEAD
-# endif
-			) {
-				tptr = skip_whitespace(iobuf + sizeof("Content-Length:") - 1);
-				if (!tptr[0])
-					send_headers_and_exit(HTTP_BAD_REQUEST);
-				/* not using strtoul: it ignores leading minus! */
-				length = bb_strtou(tptr, NULL, 10);
-				/* length is "ulong", but we need to pass it to int later */
-				if (errno || length > INT_MAX)
-					send_headers_and_exit(HTTP_BAD_REQUEST);
-			}
+		dbg("header:'%s'\n", iobuf);
+#if ENABLE_FEATURE_HTTPD_CGI
+		/* Only POST needs to know POST_length */
+		if (prequest == request_POST && STRNCASECMP(iobuf, "Content-Length:") == 0) {
+			tptr = skip_whitespace(iobuf + sizeof("Content-Length:") - 1);
+			if (!tptr[0])
+				send_headers_and_exit(HTTP_BAD_REQUEST);
+			/* not using strtoul: it ignores leading minus! */
+			POST_length = bb_strtou(tptr, NULL, 10);
+			/* length is "ulong", but we need to pass it to int later */
+			if (errno || POST_length > INT_MAX)
+				send_headers_and_exit(HTTP_BAD_REQUEST);
 			continue;
 		}
 #endif
@@ -2572,37 +2576,36 @@ static void handle_incoming_and_exit(con
 		send_headers_and_exit(HTTP_UNAUTHORIZED);
 #endif
 
-	if (found_moved_temporarily) {
+	if (found_moved_temporarily)
 		send_headers_and_exit(HTTP_MOVED_TEMPORARILY);
-	}
-
-	tptr = urlcopy + 1;      /* skip first '/' */
 
 #if ENABLE_FEATURE_HTTPD_CGI
 	if (cgi_type != CGI_NONE) {
 		send_cgi_and_exit(
 			(cgi_type == CGI_INDEX) ? "/cgi-bin/index.cgi"
 			/*CGI_NORMAL or CGI_INTERPRETER*/ : urlcopy,
-			urlcopy, prequest, length
+			urlcopy, prequest, POST_length
 		);
 	}
 #endif
 
-	if (urlp[-1] == '/') {
-		strcpy(urlp, index_page);
-	}
-
 #if ENABLE_FEATURE_HTTPD_CGI
 	if (prequest != request_GET && prequest != request_HEAD) {
-		/* POST for files does not make sense */
+		/* POST / DELETE / PUT / OPTIONS for files do not make sense */
 		send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
 	}
-	send_file_and_exit(tptr,
-		(prequest != request_HEAD ? SEND_HEADERS_AND_BODY : SEND_HEADERS)
-	);
 #else
-	send_file_and_exit(tptr, SEND_HEADERS_AND_BODY);
+	/* !CGI: it can be only GET or HEAD */
 #endif
+
+#if ENABLE_FEATURE_HTTPD_BASIC_AUTH
+	/* Restore truncated .../index.html */
+	if (urlp[-1] == '/')
+		urlp[0] = index_page[0];
+#endif
+	send_file_and_exit(urlcopy + 1,
+		(prequest != request_HEAD ? (SEND_HEADERS + SEND_BODY) : SEND_HEADERS)
+	);
 }
 
 /*
@@ -2629,6 +2632,13 @@ static void mini_httpd(int server_socket
 		n = accept(server_socket, &fromAddr.u.sa, &fromAddr.len);
 		if (n < 0)
 			continue;
+//TODO: we can reject connects from denied IPs right away;
+//also, we might want to do one MSG_DONTWAIT'ed recv() here
+//to detect immediate EOF,
+//to avoid forking a whole new process for attackers
+//who open and close lots of connections.
+//(OTOH, the real mitigtion for this sort of thing is
+//to ratelimit connects in iptables)
 
 		/* set the KEEPALIVE option to cull dead connections */
 		setsockopt_keepalive(n);
@@ -2783,12 +2793,12 @@ int httpd_main(int argc UNUSED_PARAM, ch
 			, &verbose
 		);
 	if (opt & OPT_DECODE_URL) {
-		fputs(percent_decode_in_place(url_for_decode, /*strict:*/ 0), stdout);
+		fputs_stdout(percent_decode_in_place(url_for_decode, /*strict:*/ 0));
 		return 0;
 	}
 #if ENABLE_FEATURE_HTTPD_ENCODE_URL_STR
 	if (opt & OPT_ENCODE_URL) {
-		fputs(encodeString(url_for_encode), stdout);
+		fputs_stdout(encodeString(url_for_encode));
 		return 0;
 	}
 #endif
diff -urpN busybox-1.33.1/networking/httpd_post_upload.cgi busybox-1.34.0/networking/httpd_post_upload.cgi
--- busybox-1.33.1/networking/httpd_post_upload.cgi	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/httpd_post_upload.cgi	2021-06-16 17:02:16.000000000 +0700
@@ -18,7 +18,7 @@
 # ^M    <--------- extra empty line
 # -----------------------------29995809218093749221856446032--^M
 
-file=/tmp/$$-$RANDOM
+file=$(mktemp)
 
 CR=`printf '\r'`
 
diff -urpN busybox-1.33.1/networking/inetd.c busybox-1.34.0/networking/inetd.c
--- busybox-1.33.1/networking/inetd.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/networking/inetd.c	2021-04-27 00:21:10.000000000 +0700
@@ -1697,11 +1697,11 @@ static void FAST_FUNC chargen_dg(int s,
  * we must add 2208988800 seconds to this figure to make up for
  * some seventy years Bell Labs was asleep.
  */
-static uint32_t machtime(void)
+static NOINLINE uint32_t machtime(void)
 {
 	struct timeval tv;
 
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	return htonl((uint32_t)(tv.tv_sec + 2208988800U));
 }
 /* ARGSUSED */
diff -urpN busybox-1.33.1/networking/libiproute/ipaddress.c busybox-1.34.0/networking/libiproute/ipaddress.c
--- busybox-1.33.1/networking/libiproute/ipaddress.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/libiproute/ipaddress.c	2021-04-15 00:05:01.000000000 +0700
@@ -192,20 +192,20 @@ static NOINLINE int print_linkinfo(const
 		printf("%c    link/%s ", _SL_, ll_type_n2a(ifi->ifi_type, b1));
 
 		if (tb[IFLA_ADDRESS]) {
-			fputs(ll_addr_n2a(RTA_DATA(tb[IFLA_ADDRESS]),
+			fputs_stdout(ll_addr_n2a(RTA_DATA(tb[IFLA_ADDRESS]),
 						      RTA_PAYLOAD(tb[IFLA_ADDRESS]),
 						      ifi->ifi_type,
-						      b1, sizeof(b1)), stdout);
+						      b1, sizeof(b1)));
 		}
 		if (tb[IFLA_BROADCAST]) {
 			if (ifi->ifi_flags & IFF_POINTOPOINT)
 				printf(" peer ");
 			else
 				printf(" brd ");
-			fputs(ll_addr_n2a(RTA_DATA(tb[IFLA_BROADCAST]),
+			fputs_stdout(ll_addr_n2a(RTA_DATA(tb[IFLA_BROADCAST]),
 						      RTA_PAYLOAD(tb[IFLA_BROADCAST]),
 						      ifi->ifi_type,
-						      b1, sizeof(b1)), stdout);
+						      b1, sizeof(b1)));
 		}
 	}
 	bb_putchar('\n');
@@ -307,9 +307,7 @@ static int FAST_FUNC print_addrinfo(cons
 		printf("    family %d ", ifa->ifa_family);
 
 	if (rta_tb[IFA_LOCAL]) {
-		fputs(rt_addr_n2a(ifa->ifa_family, RTA_DATA(rta_tb[IFA_LOCAL])),
-			stdout
-		);
+		fputs_stdout(rt_addr_n2a(ifa->ifa_family, RTA_DATA(rta_tb[IFA_LOCAL])));
 
 		if (rta_tb[IFA_ADDRESS] == NULL
 		 || memcmp(RTA_DATA(rta_tb[IFA_ADDRESS]), RTA_DATA(rta_tb[IFA_LOCAL]), 4) == 0
@@ -363,7 +361,7 @@ static int FAST_FUNC print_addrinfo(cons
 	if (ifa_flags)
 		printf("flags %02x ", ifa_flags);
 	if (rta_tb[IFA_LABEL])
-		fputs((char*)RTA_DATA(rta_tb[IFA_LABEL]), stdout);
+		fputs_stdout((char*)RTA_DATA(rta_tb[IFA_LABEL]));
 	if (rta_tb[IFA_CACHEINFO]) {
 		struct ifa_cacheinfo *ci = RTA_DATA(rta_tb[IFA_CACHEINFO]);
 		char buf[128];
diff -urpN busybox-1.33.1/networking/libiproute/iprule.c busybox-1.34.0/networking/libiproute/iprule.c
--- busybox-1.33.1/networking/libiproute/iprule.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/libiproute/iprule.c	2021-04-15 00:05:01.000000000 +0700
@@ -88,10 +88,9 @@ static int FAST_FUNC print_rule(const st
 				r->rtm_src_len
 			);
 		} else {
-			fputs(format_host(r->rtm_family,
+			fputs_stdout(format_host(r->rtm_family,
 						RTA_PAYLOAD(tb[RTA_SRC]),
-						RTA_DATA(tb[RTA_SRC])),
-				stdout
+						RTA_DATA(tb[RTA_SRC]))
 			);
 		}
 	} else if (r->rtm_src_len) {
@@ -178,7 +177,7 @@ static int FAST_FUNC print_rule(const st
 		} else
 			printf("masquerade");
 	} else if (r->rtm_type != RTN_UNICAST)
-		fputs(rtnl_rtntype_n2a(r->rtm_type), stdout);
+		fputs_stdout(rtnl_rtntype_n2a(r->rtm_type));
 
 	bb_putchar('\n');
 	/*fflush_all();*/
diff -urpN busybox-1.33.1/networking/nameif.c busybox-1.34.0/networking/nameif.c
--- busybox-1.33.1/networking/nameif.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/nameif.c	2021-06-16 17:02:16.000000000 +0700
@@ -52,10 +52,10 @@
 //usage:#define nameif_full_usage "\n\n"
 //usage:	"Rename network interface while it in the down state."
 //usage:	IF_NOT_FEATURE_NAMEIF_EXTENDED(
-//usage:     "\nThe device with address HWADDR is renamed to IFACE."
+//usage:     "\nThe device with address HWADDR is renamed to IFNAME."
 //usage:	)
 //usage:	IF_FEATURE_NAMEIF_EXTENDED(
-//usage:     "\nThe device matched by SELECTOR is renamed to IFACE."
+//usage:     "\nThe device matched by SELECTOR is renamed to IFNAME."
 //usage:     "\nSELECTOR can be a combination of:"
 //usage:     "\n	driver=STRING"
 //usage:     "\n	bus=STRING"
diff -urpN busybox-1.33.1/networking/nslookup.c busybox-1.34.0/networking/nslookup.c
--- busybox-1.33.1/networking/nslookup.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/networking/nslookup.c	2021-06-16 17:02:16.000000000 +0700
@@ -25,7 +25,7 @@
 //usage:#define nslookup_full_usage "\n\n"
 //usage:       "Query DNS about HOST"
 //usage:       IF_FEATURE_NSLOOKUP_BIG("\n")
-//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,any")
+//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,srv,any")
 //usage:#define nslookup_example_usage
 //usage:       "$ nslookup localhost\n"
 //usage:       "Server:     default\n"
@@ -349,6 +349,8 @@ static int parse_reply(const unsigned ch
 	header = (HEADER *)msg;
 	if (!header->aa)
 		printf("Non-authoritative answer:\n");
+	else if (option_mask32 & OPT_debug)
+		printf("Non-authoritative answer:\n" + 4);
 
 	if (ns_initparse(msg, len, &handle) != 0) {
 		//printf("Unable to parse reply: %s\n", strerror(errno));
@@ -381,7 +383,7 @@ static int parse_reply(const unsigned ch
 				return -1;
 			}
 			inet_ntop(AF_INET6, ns_rr_rdata(rr), astr, sizeof(astr));
-			/* bind-utils-9.11.3 uses the same format for A and AAAA answers */
+			/* bind-utils 9.11.3 uses the same format for A and AAAA answers */
 			printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
 			break;
 #endif
@@ -580,7 +582,7 @@ static int send_queries(struct ns *ns)
 			printf("Address:\t%s\n\n",
 				auto_string(xmalloc_sockaddr2dotted(&ns->lsa->u.sa))
 			);
-			/* In "Address", bind-utils-9.11.3 show port after a hash: "1.2.3.4#53" */
+			/* In "Address", bind-utils 9.11.3 show port after a hash: "1.2.3.4#53" */
 			/* Should we do the same? */
 		}
 
@@ -640,12 +642,26 @@ static int send_queries(struct ns *ns)
 				printf("*** Can't find %s: Parse error\n", G.query[qn].name);
 				G.exitcode = EXIT_FAILURE;
 				break;
-
-			case 0:
-				printf("*** Can't find %s: No answer\n", G.query[qn].name);
-				break;
-			}
-		}
+			/* bind-utils 9.11.25 just says nothing in this case */
+			//case 0:
+			//	break;
+			}
+		}
+/* NB: in case of authoritative, empty answer (NODATA), IOW: one with
+ * ns_msg_count() == 0, bind-utils 9.11.25 shows no trace of this answer
+ * (unless -debug, where it says:
+ * ------------
+ *     QUESTIONS:
+ *     host.com, type = AAAA, class = IN
+ *     ANSWERS:
+ *     AUTHORITY RECORDS:
+ *     ADDITIONAL RECORDS:
+ * ------------
+ * ). Due to printing of below '\n', we do show an additional empty line.
+ * This is better than not showing any indication of this reply at all,
+ * yet maintains "compatibility". I wonder whether it's better to break compat
+ * and emit something more meaningful, e.g. print "Empty answer (NODATA)"?
+ */
 		bb_putchar('\n');
 		n_replies++;
 		if (n_replies >= G.query_count)
@@ -697,7 +713,7 @@ static void parse_resolvconf(void)
 {
 	FILE *resolv;
 
-	resolv = fopen("/etc/resolv.conf", "r");
+	resolv = fopen_for_read("/etc/resolv.conf");
 	if (resolv) {
 		char line[512];	/* "search" is defined to be up to 256 chars */
 
diff -urpN busybox-1.33.1/networking/ntpd.c busybox-1.34.0/networking/ntpd.c
--- busybox-1.33.1/networking/ntpd.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/networking/ntpd.c	2021-04-27 00:21:10.000000000 +0700
@@ -113,6 +113,13 @@
 # define IPTOS_DSCP_AF21 0x48
 #endif
 
+#if defined(__FreeBSD__)
+/* see sys/timex.h */
+# define adjtimex ntp_adjtime
+# define ADJ_OFFSET     MOD_OFFSET
+# define ADJ_STATUS     MOD_STATUS
+# define ADJ_TIMECONST  MOD_TIMECONST
+#endif
 
 /* Verbosity control (max level of -dddd options accepted).
  * max 6 is very talkative (and bloated). 3 is non-bloated,
@@ -120,24 +127,15 @@
  */
 #define MAX_VERBOSE     3
 
-
 /* High-level description of the algorithm:
  *
  * We start running with very small poll_exp, BURSTPOLL,
  * in order to quickly accumulate INITIAL_SAMPLES datapoints
  * for each peer. Then, time is stepped if the offset is larger
- * than STEP_THRESHOLD, otherwise it isn't; anyway, we enlarge
- * poll_exp to MINPOLL and enter frequency measurement step:
- * we collect new datapoints but ignore them for WATCH_THRESHOLD
- * seconds. After WATCH_THRESHOLD seconds we look at accumulated
- * offset and estimate frequency drift.
+ * than STEP_THRESHOLD, otherwise it isn't stepped.
  *
- * (frequency measurement step seems to not be strictly needed,
- * it is conditionally disabled with USING_INITIAL_FREQ_ESTIMATION
- * define set to 0)
- *
- * After this, we enter "steady state": we collect a datapoint,
- * we select the best peer, if this datapoint is not a new one
+ * Then poll_exp is set to MINPOLL, and we enter "steady state": we collect
+ * a datapoint, we select the best peer, if this datapoint is not a new one
  * (IOW: if this datapoint isn't for selected peer), sleep
  * and collect another one; otherwise, use its offset to update
  * frequency drift, if offset is somewhat large, reduce poll_exp,
@@ -162,7 +160,7 @@
  *   datapoints after the step.
  */
 
-#define INITIAL_SAMPLES    4    /* how many samples do we want for init */
+#define INITIAL_SAMPLES    3    /* how many samples do we want for init */
 #define MIN_FREQHOLD      10    /* adjust offset, but not freq in this many first adjustments */
 #define BAD_DELAY_GROWTH   4    /* drop packet if its delay grew by more than this factor */
 
@@ -182,13 +180,10 @@
 // ^^^^ used to be 0.125.
 // Since Linux 2.6.26 (circa 2006), kernel accepts (-0.5s, +0.5s) range
 
-/* Stepout threshold (sec). std ntpd uses 900 (11 mins (!)) */
-//UNUSED: #define WATCH_THRESHOLD  128
-/* NB: set WATCH_THRESHOLD to ~60 when debugging to save time) */
-//UNUSED: #define PANIC_THRESHOLD 1000    /* panic threshold (sec) */
 
-/*
- * If we got |offset| > BIGOFF from a peer, cap next query interval
+// #define PANIC_THRESHOLD 1000    /* panic threshold (sec) */
+
+/* If we got |offset| > BIGOFF from a peer, cap next query interval
  * for this peer by this many seconds:
  */
 #define BIGOFF          STEP_THRESHOLD
@@ -197,18 +192,16 @@
 #define FREQ_TOLERANCE  0.000015 /* frequency tolerance (15 PPM) */
 #define BURSTPOLL       0       /* initial poll */
 #define MINPOLL         5       /* minimum poll interval. std ntpd uses 6 (6: 64 sec) */
-/*
- * If offset > discipline_jitter * POLLADJ_GATE, and poll interval is > 2^BIGPOLL,
+/* If offset > discipline_jitter * POLLADJ_GATE, and poll interval is > 2^BIGPOLL,
  * then it is decreased _at once_. (If <= 2^BIGPOLL, it will be decreased _eventually_).
  */
 #define BIGPOLL         9       /* 2^9 sec ~= 8.5 min */
 #define MAXPOLL         12      /* maximum poll interval (12: 1.1h, 17: 36.4h). std ntpd uses 17 */
-/*
- * Actively lower poll when we see such big offsets.
+/* Actively lower poll when we see such big offsets.
  * With SLEW_THRESHOLD = 0.125, it means we try to sync more aggressively
  * if offset increases over ~0.04 sec
  */
-//#define POLLDOWN_OFFSET (SLEW_THRESHOLD / 3)
+// #define POLLDOWN_OFFSET (SLEW_THRESHOLD / 3)
 #define MINDISP         0.01    /* minimum dispersion (sec) */
 #define MAXDISP         16      /* maximum dispersion (sec) */
 #define MAXSTRAT        16      /* maximum stratum (infinity metric) */
@@ -216,7 +209,16 @@
 #define MIN_SELECTED    1       /* minimum intersection survivors */
 #define MIN_CLUSTERED   3       /* minimum cluster survivors */
 
-#define MAXDRIFT        0.000500 /* frequency drift we can correct (500 PPM) */
+/* Correct frequency ourself (0) or let kernel do it (1)? */
+#define USING_KERNEL_PLL_LOOP 1
+// /* frequency drift we can correct (500 PPM) */
+// #define MAXDRIFT        0.000500
+// /* Compromise Allan intercept (sec). doc uses 1500, std ntpd uses 512 */
+// #define ALLAN           512
+// /* PLL loop gain */
+// #define PLL             65536
+// /* FLL loop gain [why it depends on MAXPOLL??] */
+// #define FLL             (MAXPOLL + 1)
 
 /* Poll-adjust threshold.
  * When we see that offset is small enough compared to discipline jitter,
@@ -232,12 +234,6 @@
  */
 #define POLLADJ_GATE    4
 #define TIMECONST_HACK_GATE 2
-/* Compromise Allan intercept (sec). doc uses 1500, std ntpd uses 512 */
-#define ALLAN           512
-/* PLL loop gain */
-#define PLL             65536
-/* FLL loop gain [why it depends on MAXPOLL??] */
-#define FLL             (MAXPOLL + 1)
 /* Parameter averaging constant */
 #define AVG             4
 
@@ -365,10 +361,6 @@ typedef struct {
 	char             p_hostname[1];
 } peer_t;
 
-
-#define USING_KERNEL_PLL_LOOP          1
-#define USING_INITIAL_FREQ_ESTIMATION  0
-
 enum {
 	OPT_n = (1 << 0),
 	OPT_q = (1 << 1),
@@ -447,7 +439,7 @@ struct globals {
 	 */
 #define G_precision_exp  -9
 	/*
-	 * G_precision_exp is used only for construction outgoing packets.
+	 * G_precision_exp is used only for constructing outgoing packets.
 	 * It's ok to set G_precision_sec to a slightly different value
 	 * (One which is "nicer looking" in logs).
 	 * Exact value would be (1.0 / (1 << (- G_precision_exp))):
@@ -455,12 +447,7 @@ struct globals {
 #define G_precision_sec  0.002
 	uint8_t  stratum;
 
-#define STATE_NSET      0       /* initial state, "nothing is set" */
-//#define STATE_FSET    1       /* frequency set from file */
-//#define STATE_SPIK    2       /* spike detected */
-//#define STATE_FREQ    3       /* initial frequency */
-#define STATE_SYNC      4       /* clock synchronized (normal operation) */
-	uint8_t  discipline_state;      // doc calls it c.state
+	//uint8_t  discipline_state;      // doc calls it c.state
 	uint8_t  poll_exp;              // s.poll
 	int      polladj_count;         // c.count
 	int      FREQHOLD_cnt;
@@ -483,7 +470,6 @@ struct globals {
 };
 #define G (*ptr_to_globals)
 
-
 #define VERB1 if (MAX_VERBOSE && G.verbose)
 #define VERB2 if (MAX_VERBOSE >= 2 && G.verbose >= 2)
 #define VERB3 if (MAX_VERBOSE >= 3 && G.verbose >= 3)
@@ -560,19 +546,19 @@ static double
 gettime1900d(void)
 {
 	struct timeval tv;
-	gettimeofday(&tv, NULL); /* never fails */
+	xgettimeofday(&tv);
 	G.cur_time = tv.tv_sec + (1.0e-6 * tv.tv_usec) + OFFSET_1900_1970;
 	return G.cur_time;
 }
 
 static void
-d_to_tv(double d, struct timeval *tv)
+d_to_tv(struct timeval *tv, double d)
 {
 	tv->tv_sec = (long)d;
 	tv->tv_usec = (d - tv->tv_sec) * 1000000;
 }
 
-static double
+static NOINLINE double
 lfp_to_d(l_fixedpt_t lfp)
 {
 	double ret;
@@ -581,7 +567,7 @@ lfp_to_d(l_fixedpt_t lfp)
 	ret = (double)lfp.int_partl + ((double)lfp.fractionl / UINT_MAX);
 	return ret;
 }
-static double
+static NOINLINE double
 sfp_to_d(s_fixedpt_t sfp)
 {
 	double ret;
@@ -591,25 +577,25 @@ sfp_to_d(s_fixedpt_t sfp)
 	return ret;
 }
 #if ENABLE_FEATURE_NTPD_SERVER
-static l_fixedpt_t
-d_to_lfp(double d)
+static NOINLINE void
+d_to_lfp(l_fixedpt_t *lfp, double d)
 {
-	l_fixedpt_t lfp;
-	lfp.int_partl = (uint32_t)d;
-	lfp.fractionl = (uint32_t)((d - lfp.int_partl) * UINT_MAX);
-	lfp.int_partl = htonl(lfp.int_partl);
-	lfp.fractionl = htonl(lfp.fractionl);
-	return lfp;
-}
-static s_fixedpt_t
-d_to_sfp(double d)
-{
-	s_fixedpt_t sfp;
-	sfp.int_parts = (uint16_t)d;
-	sfp.fractions = (uint16_t)((d - sfp.int_parts) * USHRT_MAX);
-	sfp.int_parts = htons(sfp.int_parts);
-	sfp.fractions = htons(sfp.fractions);
-	return sfp;
+	uint32_t intl;
+	uint32_t frac;
+	intl = (uint32_t)d;
+	frac = (uint32_t)((d - intl) * UINT_MAX);
+	lfp->int_partl = htonl(intl);
+	lfp->fractionl = htonl(frac);
+}
+static NOINLINE void
+d_to_sfp(s_fixedpt_t *sfp, double d)
+{
+	uint16_t ints;
+	uint16_t frac;
+	ints = (uint16_t)d;
+	frac = (uint16_t)((d - ints) * USHRT_MAX);
+	sfp->int_parts = htons(ints);
+	sfp->fractions = htons(frac);
 }
 #endif
 
@@ -650,104 +636,11 @@ filter_datapoints(peer_t *p)
 	double sum, wavg;
 	datapoint_t *fdp;
 
-#if 0
 /* Simulations have shown that use of *averaged* offset for p->filter_offset
  * is in fact worse than simply using last received one: with large poll intervals
  * (>= 2048) averaging code uses offset values which are outdated by hours,
  * and time/frequency correction goes totally wrong when fed essentially bogus offsets.
  */
-	int got_newest;
-	double minoff, maxoff, w;
-	double x = x; /* for compiler */
-	double oldest_off = oldest_off;
-	double oldest_age = oldest_age;
-	double newest_off = newest_off;
-	double newest_age = newest_age;
-
-	fdp = p->filter_datapoint;
-
-	minoff = maxoff = fdp[0].d_offset;
-	for (i = 1; i < NUM_DATAPOINTS; i++) {
-		if (minoff > fdp[i].d_offset)
-			minoff = fdp[i].d_offset;
-		if (maxoff < fdp[i].d_offset)
-			maxoff = fdp[i].d_offset;
-	}
-
-	idx = p->datapoint_idx; /* most recent datapoint's index */
-	/* Average offset:
-	 * Drop two outliers and take weighted average of the rest:
-	 * most_recent/2 + older1/4 + older2/8 ... + older5/32 + older6/32
-	 * we use older6/32, not older6/64 since sum of weights should be 1:
-	 * 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/32 = 1
-	 */
-	wavg = 0;
-	w = 0.5;
-	/*                     n-1
-	 *                     ---    dispersion(i)
-	 * filter_dispersion =  \     -------------
-	 *                      /       (i+1)
-	 *                     ---     2
-	 *                     i=0
-	 */
-	got_newest = 0;
-	sum = 0;
-	for (i = 0; i < NUM_DATAPOINTS; i++) {
-		VERB5 {
-			bb_error_msg("datapoint[%d]: off:%f disp:%f(%f) age:%f%s",
-				i,
-				fdp[idx].d_offset,
-				fdp[idx].d_dispersion, dispersion(&fdp[idx]),
-				G.cur_time - fdp[idx].d_recv_time,
-				(minoff == fdp[idx].d_offset || maxoff == fdp[idx].d_offset)
-					? " (outlier by offset)" : ""
-			);
-		}
-
-		sum += dispersion(&fdp[idx]) / (2 << i);
-
-		if (minoff == fdp[idx].d_offset) {
-			minoff -= 1; /* so that we don't match it ever again */
-		} else
-		if (maxoff == fdp[idx].d_offset) {
-			maxoff += 1;
-		} else {
-			oldest_off = fdp[idx].d_offset;
-			oldest_age = G.cur_time - fdp[idx].d_recv_time;
-			if (!got_newest) {
-				got_newest = 1;
-				newest_off = oldest_off;
-				newest_age = oldest_age;
-			}
-			x = oldest_off * w;
-			wavg += x;
-			w /= 2;
-		}
-
-		idx = (idx - 1) & (NUM_DATAPOINTS - 1);
-	}
-	p->filter_dispersion = sum;
-	wavg += x; /* add another older6/64 to form older6/32 */
-	/* Fix systematic underestimation with large poll intervals.
-	 * Imagine that we still have a bit of uncorrected drift,
-	 * and poll interval is big (say, 100 sec). Offsets form a progression:
-	 * 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 - 0.7 is most recent.
-	 * The algorithm above drops 0.0 and 0.7 as outliers,
-	 * and then we have this estimation, ~25% off from 0.7:
-	 * 0.1/32 + 0.2/32 + 0.3/16 + 0.4/8 + 0.5/4 + 0.6/2 = 0.503125
-	 */
-	x = oldest_age - newest_age;
-	if (x != 0) {
-		x = newest_age / x; /* in above example, 100 / (600 - 100) */
-		if (x < 1) { /* paranoia check */
-			x = (newest_off - oldest_off) * x; /* 0.5 * 100/500 = 0.1 */
-			wavg += x;
-		}
-	}
-	p->filter_offset = wavg;
-
-#else
-
 	fdp = p->filter_datapoint;
 	idx = p->datapoint_idx; /* most recent datapoint's index */
 
@@ -770,7 +663,6 @@ filter_datapoints(peer_t *p)
 	}
 	wavg /= NUM_DATAPOINTS;
 	p->filter_dispersion = sum;
-#endif
 
 	/*                  +-----                 -----+ ^ 1/2
 	 *                  |       n-1                 |
@@ -1082,7 +974,6 @@ send_query_to_peer(peer_t *p)
 	set_next(p, RESPONSE_INTERVAL);
 }
 
-
 /* Note that there is no provision to prevent several run_scripts
  * to be started in quick succession. In fact, it happens rather often
  * if initial syncronization results in a step.
@@ -1144,9 +1035,9 @@ step_time(double offset)
 	char buf[sizeof("yyyy-mm-dd hh:mm:ss") + /*paranoia:*/ 4];
 	time_t tval;
 
-	gettimeofday(&tvc, NULL); /* never fails */
+	xgettimeofday(&tvc);
 	dtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;
-	d_to_tv(dtime, &tvn);
+	d_to_tv(&tvn, dtime);
 	xsettimeofday(&tvn);
 
 	VERB2 {
@@ -1541,15 +1432,14 @@ select_and_cluster(void)
  * Local clock discipline and its helpers
  */
 static void
-set_new_values(int disc_state, double offset, double recv_time)
+set_new_values(double offset, double recv_time)
 {
 	/* Enter new state and set state variables. Note we use the time
 	 * of the last clock filter sample, which must be earlier than
 	 * the current time.
 	 */
-	VERB4 bb_error_msg("disc_state=%d last update offset=%f recv_time=%f",
-			disc_state, offset, recv_time);
-	G.discipline_state = disc_state;
+	VERB4 bb_error_msg("last update offset=%f recv_time=%f",
+			offset, recv_time);
 	G.last_update_offset = offset;
 	G.last_update_recv_time = recv_time;
 }
@@ -1565,8 +1455,6 @@ update_local_clock(peer_t *p)
 	double abs_offset;
 #if !USING_KERNEL_PLL_LOOP
 	double freq_drift;
-#endif
-#if !USING_KERNEL_PLL_LOOP || USING_INITIAL_FREQ_ESTIMATION
 	double since_last_update;
 #endif
 	double etemp, dtemp;
@@ -1596,63 +1484,15 @@ update_local_clock(peer_t *p)
 	 * action is and defines how the system reacts to large time
 	 * and frequency errors.
 	 */
-#if !USING_KERNEL_PLL_LOOP || USING_INITIAL_FREQ_ESTIMATION
-	since_last_update = recv_time - G.reftime;
-#endif
 #if !USING_KERNEL_PLL_LOOP
+	since_last_update = recv_time - G.reftime;
 	freq_drift = 0;
 #endif
-#if USING_INITIAL_FREQ_ESTIMATION
-	if (G.discipline_state == STATE_FREQ) {
-		/* Ignore updates until the stepout threshold */
-		if (since_last_update < WATCH_THRESHOLD) {
-			VERB4 bb_error_msg("measuring drift, datapoint ignored, %f sec remains",
-					WATCH_THRESHOLD - since_last_update);
-			return 0; /* "leave poll interval as is" */
-		}
-# if !USING_KERNEL_PLL_LOOP
-		freq_drift = (offset - G.last_update_offset) / since_last_update;
-# endif
-	}
-#endif
 
 	/* There are two main regimes: when the
 	 * offset exceeds the step threshold and when it does not.
 	 */
 	if (abs_offset > STEP_THRESHOLD) {
-#if 0
-		double remains;
-
-// This "spike state" seems to be useless, peer selection already drops
-// occassional "bad" datapoints. If we are here, there were _many_
-// large offsets. When a few first large offsets are seen,
-// we end up in "no valid datapoints, no peer selected" state.
-// Only when enough of them are seen (which means it's not a fluke),
-// we end up here. Looks like _our_ clock is off.
-		switch (G.discipline_state) {
-		case STATE_SYNC:
-			/* The first outlyer: ignore it, switch to SPIK state */
-			VERB3 bb_error_msg("update from %s: offset:%+f, spike%s",
-				p->p_dotted, offset,
-				"");
-			G.discipline_state = STATE_SPIK;
-			return -1; /* "decrease poll interval" */
-
-		case STATE_SPIK:
-			/* Ignore succeeding outlyers until either an inlyer
-			 * is found or the stepout threshold is exceeded.
-			 */
-			remains = WATCH_THRESHOLD - since_last_update;
-			if (remains > 0) {
-				VERB3 bb_error_msg("update from %s: offset:%+f, spike%s",
-					p->p_dotted, offset,
-					", datapoint ignored");
-				return -1; /* "decrease poll interval" */
-			}
-			/* fall through: we need to step */
-		} /* switch */
-#endif
-
 		/* Step the time and clamp down the poll interval.
 		 *
 		 * In NSET state an initial frequency correction is
@@ -1687,16 +1527,17 @@ update_local_clock(peer_t *p)
 
 		recv_time += offset;
 
-#if USING_INITIAL_FREQ_ESTIMATION
-		if (G.discipline_state == STATE_NSET) {
-			set_new_values(STATE_FREQ, /*offset:*/ 0, recv_time);
-			return 1; /* "ok to increase poll interval" */
-		}
-#endif
 		abs_offset = offset = 0;
-		set_new_values(STATE_SYNC, offset, recv_time);
+		set_new_values(offset, recv_time);
 	} else { /* abs_offset <= STEP_THRESHOLD */
 
+		if (option_mask32 & OPT_q) {
+			/* We were only asked to set time once.
+			 * The clock is precise enough, no need to step.
+			 */
+			exit(0);
+		}
+
 		/* The ratio is calculated before jitter is updated to make
 		 * poll adjust code more sensitive to large offsets.
 		 */
@@ -1711,75 +1552,31 @@ update_local_clock(peer_t *p)
 		if (G.discipline_jitter < G_precision_sec)
 			G.discipline_jitter = G_precision_sec;
 
-		switch (G.discipline_state) {
-		case STATE_NSET:
-			if (option_mask32 & OPT_q) {
-				/* We were only asked to set time once.
-				 * The clock is precise enough, no need to step.
-				 */
-				exit(0);
-			}
-#if USING_INITIAL_FREQ_ESTIMATION
-			/* This is the first update received and the frequency
-			 * has not been initialized. The first thing to do
-			 * is directly measure the oscillator frequency.
-			 */
-			set_new_values(STATE_FREQ, offset, recv_time);
-#else
-			set_new_values(STATE_SYNC, offset, recv_time);
-#endif
-			VERB4 bb_simple_error_msg("transitioning to FREQ, datapoint ignored");
-			return 0; /* "leave poll interval as is" */
-
-#if 0 /* this is dead code for now */
-		case STATE_FSET:
-			/* This is the first update and the frequency
-			 * has been initialized. Adjust the phase, but
-			 * don't adjust the frequency until the next update.
-			 */
-			set_new_values(STATE_SYNC, offset, recv_time);
-			/* freq_drift remains 0 */
-			break;
-#endif
-
-#if USING_INITIAL_FREQ_ESTIMATION
-		case STATE_FREQ:
-			/* since_last_update >= WATCH_THRESHOLD, we waited enough.
-			 * Correct the phase and frequency and switch to SYNC state.
-			 * freq_drift was already estimated (see code above)
-			 */
-			set_new_values(STATE_SYNC, offset, recv_time);
-			break;
-#endif
-
-		default:
 #if !USING_KERNEL_PLL_LOOP
-			/* Compute freq_drift due to PLL and FLL contributions.
-			 *
-			 * The FLL and PLL frequency gain constants
-			 * depend on the poll interval and Allan
-			 * intercept. The FLL is not used below one-half
-			 * the Allan intercept. Above that the loop gain
-			 * increases in steps to 1 / AVG.
-			 */
-			if ((1 << G.poll_exp) > ALLAN / 2) {
-				etemp = FLL - G.poll_exp;
-				if (etemp < AVG)
-					etemp = AVG;
-				freq_drift += (offset - G.last_update_offset) / (MAXD(since_last_update, ALLAN) * etemp);
-			}
-			/* For the PLL the integration interval
-			 * (numerator) is the minimum of the update
-			 * interval and poll interval. This allows
-			 * oversampling, but not undersampling.
-			 */
-			etemp = MIND(since_last_update, (1 << G.poll_exp));
-			dtemp = (4 * PLL) << G.poll_exp;
-			freq_drift += offset * etemp / SQUARE(dtemp);
+		/* Compute freq_drift due to PLL and FLL contributions.
+		 *
+		 * The FLL and PLL frequency gain constants
+		 * depend on the poll interval and Allan
+		 * intercept. The FLL is not used below one-half
+		 * the Allan intercept. Above that the loop gain
+		 * increases in steps to 1 / AVG.
+		 */
+		if ((1 << G.poll_exp) > ALLAN / 2) {
+			etemp = FLL - G.poll_exp;
+			if (etemp < AVG)
+				etemp = AVG;
+			freq_drift += (offset - G.last_update_offset) / (MAXD(since_last_update, ALLAN) * etemp);
+		}
+		/* For the PLL the integration interval
+		 * (numerator) is the minimum of the update
+		 * interval and poll interval. This allows
+		 * oversampling, but not undersampling.
+		 */
+		etemp = MIND(since_last_update, (1 << G.poll_exp));
+		dtemp = (4 * PLL) << G.poll_exp;
+		freq_drift += offset * etemp / SQUARE(dtemp);
 #endif
-			set_new_values(STATE_SYNC, offset, recv_time);
-			break;
-		}
+		set_new_values(offset, recv_time);
 		if (G.stratum != p->lastpkt_stratum + 1) {
 			G.stratum = p->lastpkt_stratum + 1;
 			run_script("stratum", offset);
@@ -1798,9 +1595,7 @@ update_local_clock(peer_t *p)
 	G.rootdisp = p->lastpkt_rootdisp + dtemp;
 	VERB4 bb_error_msg("updating leap/refid/reftime/rootdisp from peer %s", p->p_dotted);
 
-	/* We are in STATE_SYNC now, but did not do adjtimex yet.
-	 * (Any other state does not reach this, they all return earlier)
-	 * By this time, freq_drift and offset are set
+	/* By this time, freq_drift and offset are set
 	 * to values suitable for adjtimex.
 	 */
 #if !USING_KERNEL_PLL_LOOP
@@ -1956,7 +1751,6 @@ update_local_clock(peer_t *p)
 	return 1; /* "ok to increase poll interval" */
 }
 
-
 /*
  * We've got a new reply packet from a peer, process it
  * (helpers first)
@@ -2323,17 +2117,17 @@ recv_and_process_client_pkt(void /*int f
 	msg.m_ppoll = G.poll_exp;
 	msg.m_precision_exp = G_precision_exp;
 	/* this time was obtained between poll() and recv() */
-	msg.m_rectime = d_to_lfp(G.cur_time);
-	msg.m_xmttime = d_to_lfp(gettime1900d()); /* this instant */
+	d_to_lfp(&msg.m_rectime, G.cur_time);
+	d_to_lfp(&msg.m_xmttime, gettime1900d()); /* this instant */
 	if (G.peer_cnt == 0) {
 		/* we have no peers: "stratum 1 server" mode. reftime = our own time */
 		G.reftime = G.cur_time;
 	}
-	msg.m_reftime = d_to_lfp(G.reftime);
+	d_to_lfp(&msg.m_reftime, G.reftime);
 	msg.m_orgtime = query_xmttime;
-	msg.m_rootdelay = d_to_sfp(G.rootdelay);
+	d_to_sfp(&msg.m_rootdelay, G.rootdelay);
 //simple code does not do this, fix simple code!
-	msg.m_rootdisp = d_to_sfp(G.rootdisp);
+	d_to_sfp(&msg.m_rootdisp, G.rootdisp);
 	//version = (query_status & VERSION_MASK); /* ... >> VERSION_SHIFT - done below instead */
 	msg.m_refid = G.refid; // (version > (3 << VERSION_SHIFT)) ? G.refid : G.refid3;
 
@@ -2342,6 +2136,12 @@ recv_and_process_client_pkt(void /*int f
 	do_sendto(G_listen_fd,
 		/*from:*/ &to->u.sa, /*to:*/ from, /*addrlen:*/ to->len,
 		&msg, size);
+	VERB3 {
+		char *addr;
+		addr = xmalloc_sockaddr2dotted_noport(from);
+		bb_error_msg("responded to query from %s", addr);
+		free(addr);
+	}
 
  bail:
 	free(to);
@@ -2760,7 +2560,7 @@ int ntpd_main(int argc UNUSED_PARAM, cha
 		timeout++; /* (nextaction - G.cur_time) rounds down, compensating */
 
 		/* Here we may block */
-		VERB2 {
+		VERB3 {
 			if (i > (ENABLE_FEATURE_NTPD_SERVER && G_listen_fd != -1)) {
 				/* We wait for at least one reply.
 				 * Poll for it, without wasting time for message.
diff -urpN busybox-1.33.1/networking/ping.c busybox-1.34.0/networking/ping.c
--- busybox-1.33.1/networking/ping.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/ping.c	2021-01-08 15:30:27.000000000 +0700
@@ -122,6 +122,10 @@
 //usage:       "round-trip min/avg/max = 20.1/20.1/20.1 ms\n"
 
 #include <net/if.h>
+#if defined(__FreeBSD__)
+# include <netinet/in.h> /* struct ip and friends */
+# include <netinet/ip.h>
+#endif
 #include <netinet/ip_icmp.h>
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -160,6 +164,40 @@
 # endif
 #endif
 
+#if defined(__FreeBSD__)
+/**
+ * On BSD the IPv4 struct is called struct ip and instead of iXX
+ * the members are called ip_XX. One could change this code to use
+ * struct ip but that would require to define _BSD_SOURCE and that
+ * might have other complications. Instead make sure struct iphdr
+ * is present on FreeBSD. The below is taken from GLIBC.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ */
+struct iphdr {
+# if BYTE_ORDER == LITTLE_ENDIAN
+	unsigned int ihl:4;
+	unsigned int version:4;
+# elif BYTE_ORDER == BIG_ENDIAN
+	unsigned int version:4;
+	unsigned int ihl:4;
+# endif
+	uint8_t  tos;
+	uint16_t tot_len;
+	uint16_t id;
+	uint16_t frag_off;
+	uint8_t  ttl;
+	uint8_t  protocol;
+	uint16_t check;
+	uint32_t saddr;
+	uint32_t daddr;
+	/*The options start here. */
+};
+#endif
+
 enum {
 	DEFDATALEN = 56,
 	MAXIPLEN = 60,
diff -urpN busybox-1.33.1/networking/tc.c busybox-1.34.0/networking/tc.c
--- busybox-1.33.1/networking/tc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tc.c	2021-07-20 21:57:20.000000000 +0700
@@ -111,16 +111,14 @@ static char* print_tc_classid(uint32_t c
 #if 0 /* IMPOSSIBLE */
 	if (cid == TC_H_ROOT)
 		return xasprintf("root");
-	else
 #endif
 	if (cid == TC_H_UNSPEC)
 		return xasprintf("none");
-	else if (TC_H_MAJ(cid) == 0)
+	if (TC_H_MAJ(cid) == 0)
 		return xasprintf(":%x", TC_H_MIN(cid));
-	else if (TC_H_MIN(cid) == 0)
+	if (TC_H_MIN(cid) == 0)
 		return xasprintf("%x:", TC_H_MAJ(cid)>>16);
-	else
-		return xasprintf("%x:%x", TC_H_MAJ(cid)>>16, TC_H_MIN(cid));
+	return xasprintf("%x:%x", TC_H_MAJ(cid)>>16, TC_H_MIN(cid));
 }
 
 /* Get a qdisc handle.  Return 0 on success, !0 otherwise.  */
@@ -376,8 +374,10 @@ static FAST_FUNC int print_qdisc(
 			prio_print_opt(tb[TCA_OPTIONS]);
 		} else if (qqq == 1) { /* class based queuing */
 			cbq_print_opt(tb[TCA_OPTIONS]);
-		} else
-			bb_error_msg("unknown %s", name);
+		} else {
+			/* don't know how to print options for this qdisc */
+			printf("(options for %s)", name);
+		}
 	}
 	bb_putchar('\n');
 	return 0;
@@ -405,7 +405,7 @@ static FAST_FUNC int print_class(
 		return -1;
 	}
 	/* not the desired interface? */
-	if (filter_qdisc && TC_H_MAJ(msg->tcm_handle^filter_qdisc))
+	if (filter_qdisc && TC_H_MAJ(msg->tcm_handle ^ filter_qdisc))
 		return 0;
 	memset (tb, 0, sizeof(tb));
 	parse_rtattr(tb, TCA_MAX, TCA_RTA(msg), len);
@@ -418,8 +418,8 @@ static FAST_FUNC int print_class(
 
 	name = (char*)RTA_DATA(tb[TCA_KIND]);
 	classid = !msg->tcm_handle ? NULL : print_tc_classid(
-				filter_qdisc ? TC_H_MIN(msg->tcm_parent) : msg->tcm_parent);
-	printf ("class %s %s", name, classid);
+				filter_qdisc ? TC_H_MIN(msg->tcm_handle) : msg->tcm_handle);
+	printf ("class %s %s ", name, classid);
 	if (ENABLE_FEATURE_CLEAN_UP)
 		free(classid);
 
@@ -445,8 +445,10 @@ static FAST_FUNC int print_class(
 		} else if (qqq == 1) { /* class based queuing */
 			/* cbq_print_copt() is identical to cbq_print_opt(). */
 			cbq_print_opt(tb[TCA_OPTIONS]);
-		} else
-			bb_error_msg("unknown %s", name);
+		} else {
+			/* don't know how to print options for this class */
+			printf("(options for %s)", name);
+		}
 	}
 	bb_putchar('\n');
 
@@ -511,12 +513,11 @@ int tc_main(int argc UNUSED_PARAM, char
 	ret = EXIT_SUCCESS;
 
 	obj = index_in_substrings(objects, *argv++);
-
 	if (obj < 0)
 		bb_show_usage();
-	if (!*argv)
-		cmd = CMD_show; /* list is the default */
-	else {
+
+	cmd = CMD_show; /* list (aka show) is the default */
+	if (*argv) {
 		cmd = index_in_substrings(commands, *argv);
 		if (cmd < 0)
 			invarg_1_to_2(*argv, argv[-1]);
@@ -538,16 +539,17 @@ int tc_main(int argc UNUSED_PARAM, char
 			msg.tcm_ifindex = xll_name_to_index(dev);
 			if (cmd >= CMD_show)
 				filter_ifindex = msg.tcm_ifindex;
-		} else
-		if ((arg == ARG_qdisc && obj == OBJ_class && cmd >= CMD_show)
-		 || (arg == ARG_handle && obj == OBJ_qdisc && cmd == CMD_change)
+			continue;
+		}
+		if ((arg == ARG_qdisc && obj == OBJ_class && cmd >= CMD_show)    /* tc class show|list qdisc HANDLE */
+		 || (arg == ARG_handle && obj == OBJ_qdisc && cmd == CMD_change) /* tc qdisc change handle HANDLE */
 		) {
 			NEXT_ARG();
 			/* We don't care about duparg2("qdisc handle",*argv) for now */
 			if (get_qdisc_handle(&filter_qdisc, *argv))
 				invarg_1_to_2(*argv, "qdisc");
 		} else
-		if (obj != OBJ_qdisc
+		if (obj != OBJ_qdisc /* tc class|filter root|parent | tc filter preference|priority|protocol */
 		 && (arg == ARG_root
 		    || arg == ARG_parent
 		    || (obj == OBJ_filter && arg >= ARG_pref)
diff -urpN busybox-1.33.1/networking/tcpudp.c busybox-1.34.0/networking/tcpudp.c
--- busybox-1.33.1/networking/tcpudp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tcpudp.c	2021-06-16 17:02:16.000000000 +0700
@@ -216,17 +216,25 @@ enum {
 	OPT_K = (1 << 16),
 };
 
-static void connection_status(void)
+static void if_verbose_print_connection_status(void)
 {
-	/* "only 1 client max" desn't need this */
-	if (cmax > 1)
-		bb_error_msg("status %u/%u", cnum, cmax);
+	if (verbose) {
+		/* "only 1 client max" desn't need this */
+		if (cmax > 1)
+			bb_error_msg("status %u/%u", cnum, cmax);
+	}
 }
 
+/* SIGCHLD handler is reentrancy-safe because SIGCHLD is unmasked
+ * only over accept() or recvfrom() calls, not over memory allocations
+ * or printouts. Do need to save/restore errno in order not to mangle
+ * these syscalls' error code, if any.
+ */
 static void sig_child_handler(int sig UNUSED_PARAM)
 {
 	int wstat;
 	pid_t pid;
+	int sv_errno = errno;
 
 	while ((pid = wait_any_nohang(&wstat)) > 0) {
 		if (max_per_host)
@@ -236,8 +244,8 @@ static void sig_child_handler(int sig UN
 		if (verbose)
 			print_waitstat(pid, wstat);
 	}
-	if (verbose)
-		connection_status();
+	if_verbose_print_connection_status();
+	errno = sv_errno;
 }
 
 int tcpudpsvd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -458,7 +466,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 		xconnect(0, &remote.u.sa, sa_len);
 	/* hole? at this point we have no wildcard udp socket...
 	 * can this cause clients to get "port unreachable" icmp?
-	 * Yup, time window is very small, but it exists (is it?) */
+	 * Yup, time window is very small, but it exists (does it?) */
 		/* ..."open new socket", continued */
 		xbind(sock, &lsa->u.sa, sa_len);
 		socket_want_pktinfo(sock);
@@ -491,8 +499,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 	if (pid != 0) {
 		/* Parent */
 		cnum++;
-		if (verbose)
-			connection_status();
+		if_verbose_print_connection_status();
 		if (hccp)
 			hccp->pid = pid;
 		/* clean up changes done by vforked child */
@@ -586,8 +593,14 @@ int tcpudpsvd_main(int argc UNUSED_PARAM
 
 	xdup2(0, 1);
 
+	/* Restore signal handling for the to-be-execed process */
 	signal(SIGPIPE, SIG_DFL); /* this one was SIG_IGNed */
-	/* Non-ignored signals revert to SIG_DFL on exec anyway */
+	/* Non-ignored signals revert to SIG_DFL on exec anyway
+	 * But we can get signals BEFORE execvp(), this is unlikely
+	 * but it would invoke sig_child_handler(), which would
+	 * check waitpid(WNOHANG), then print "status N/M" if verbose.
+	 * I guess we can live with that possibility.
+	 */
 	/*signal(SIGCHLD, SIG_DFL);*/
 	sig_unblock(SIGCHLD);
 
diff -urpN busybox-1.33.1/networking/telnetd.c busybox-1.34.0/networking/telnetd.c
--- busybox-1.33.1/networking/telnetd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/telnetd.c	2021-06-16 17:02:16.000000000 +0700
@@ -109,6 +109,7 @@
 //usage:     "\n	-i		Inetd mode"
 //usage:	IF_FEATURE_TELNETD_INETD_WAIT(
 //usage:     "\n	-w SEC		Inetd 'wait' mode, linger time SEC"
+//usage:     "\n		inetd.conf line: 23 stream tcp wait root telnetd telnetd -w10"
 //usage:     "\n	-S		Log to syslog (implied by -i or without -F and -w)"
 //usage:	)
 //usage:	)
diff -urpN busybox-1.33.1/networking/tftp.c busybox-1.34.0/networking/tftp.c
--- busybox-1.33.1/networking/tftp.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tftp.c	2021-06-16 17:02:16.000000000 +0700
@@ -113,10 +113,9 @@
 //usage:#define tftpd_full_usage "\n\n"
 //usage:       "Transfer a file on tftp client's request\n"
 //usage:       "\n"
-//usage:       "tftpd should be used as an inetd service.\n"
-//usage:       "tftpd's line for inetd.conf:\n"
+//usage:       "tftpd is an inetd service, inetd.conf line:\n"
 //usage:       "	69 dgram udp nowait root tftpd tftpd -l /files/to/serve\n"
-//usage:       "It also can be ran from udpsvd:\n"
+//usage:       "Can be run from udpsvd:\n"
 //usage:       "	udpsvd -vE 0.0.0.0 69 tftpd /files/to/serve\n"
 //usage:     "\n	-r	Prohibit upload"
 //usage:     "\n	-c	Allow file creation via upload"
diff -urpN busybox-1.33.1/networking/tls.c busybox-1.34.0/networking/tls.c
--- busybox-1.33.1/networking/tls.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls.c	2021-04-27 00:21:10.000000000 +0700
@@ -18,6 +18,7 @@
 //kbuild:lib-$(CONFIG_TLS) += tls_aesgcm.o
 //kbuild:lib-$(CONFIG_TLS) += tls_rsa.o
 //kbuild:lib-$(CONFIG_TLS) += tls_fe.o
+//kbuild:lib-$(CONFIG_TLS) += tls_sp_c32.o
 
 #include "tls.h"
 
@@ -265,8 +266,9 @@ enum {
 	GOT_CERT_RSA_KEY_ALG   = 1 << 1,
 	GOT_CERT_ECDSA_KEY_ALG = 1 << 2, // so far unused
 	GOT_EC_KEY             = 1 << 3,
-	ENCRYPTION_AESGCM      = 1 << 4, // else AES-SHA (or NULL-SHA if ALLOW_RSA_NULL_SHA256=1)
-	ENCRYPT_ON_WRITE       = 1 << 5,
+	GOT_EC_CURVE_X25519    = 1 << 4, // else P256
+	ENCRYPTION_AESGCM      = 1 << 5, // else AES-SHA (or NULL-SHA if ALLOW_RSA_NULL_SHA256=1)
+	ENCRYPT_ON_WRITE       = 1 << 6,
 };
 
 struct record_hdr {
@@ -285,7 +287,11 @@ struct tls_handshake_data {
 //TODO: store just the DER key here, parse/use/delete it when sending client key
 //this way it will stay key type agnostic here.
 	psRsaKey_t server_rsa_pub_key;
-	uint8_t ecc_pub_key32[32];
+
+	/* peer's elliptic curve key data */
+	/* for x25519, it contains one point in first 32 bytes */
+	/* for P256, it contains x,y point pair, each 32 bytes long */
+	uint8_t ecc_pub_key32[2 * 32];
 
 /* HANDSHAKE HASH: */
 	//unsigned saved_client_hello_size;
@@ -1526,20 +1532,13 @@ static void send_client_hello_and_alloc_
 	};
 	static const uint8_t supported_groups[] = {
 		0x00,0x0a, //extension_type: "supported_groups"
-		0x00,0x04, //ext len
-		0x00,0x02, //list len
-		0x00,0x1d, //curve_x25519 (RFC 7748)
-		//0x00,0x1e, //curve_x448 (RFC 7748)
-		//0x00,0x17, //curve_secp256r1
+		0x00,0x06, //ext len
+		0x00,0x04, //list len
+		0x00,0x17, //curve_secp256r1 (aka P256)
 		//0x00,0x18, //curve_secp384r1
 		//0x00,0x19, //curve_secp521r1
-//TODO: implement secp256r1 (at least): dl.fedoraproject.org immediately aborts
-//if only x25519/x448 are advertised, seems to support only secpNNNr1 curves:
-// openssl s_client -connect dl.fedoraproject.org:443 -debug -tls1_2 -cipher ECDHE-RSA-AES128-GCM-SHA256
-//Peer signing digest: SHA512
-//Peer signature type: RSA
-//Server Temp Key: ECDH, P-256, 256 bits
-//TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
+		0x00,0x1d, //curve_x25519 (RFC 7748)
+		//0x00,0x1e, //curve_x448 (RFC 7748)
 	};
 	//static const uint8_t signature_algorithms[] = {
 	//	000d
@@ -1877,12 +1876,32 @@ static void process_server_key(tls_state
 	if (len < (1+2+1+32)) tls_error_die(tls);
 	keybuf += 4;
 
-	/* So far we only support curve_x25519 */
+#if BB_BIG_ENDIAN
+# define _0x03001741 0x03001741
+# define _0x03001d20 0x03001d20
+#else
+# define _0x03001741 0x41170003
+# define _0x03001d20 0x201d0003
+#endif
 	move_from_unaligned32(t32, keybuf);
-	if (t32 != htonl(0x03001d20))
-		bb_simple_error_msg_and_die("elliptic curve is not x25519");
+	keybuf += 4;
+	switch (t32) {
+	case _0x03001d20: //curve_x25519
+		tls->flags |= GOT_EC_CURVE_X25519;
+		memcpy(tls->hsd->ecc_pub_key32, keybuf, 32);
+		break;
+	case _0x03001741: //curve_secp256r1 (aka P256)
+		/* P256 point can be transmitted odd- or even-compressed
+		 * (first byte is 3 or 2) or uncompressed (4).
+		 */
+		if (*keybuf++ != 4)
+			bb_simple_error_msg_and_die("compressed EC points not supported");
+		memcpy(tls->hsd->ecc_pub_key32, keybuf, 2 * 32);
+		break;
+	default:
+		bb_error_msg_and_die("elliptic curve is not x25519 or P256: 0x%08x", t32);
+	}
 
-	memcpy(tls->hsd->ecc_pub_key32, keybuf + 4, 32);
 	tls->flags |= GOT_EC_KEY;
 	dbg("got eccPubKey\n");
 }
@@ -1918,9 +1937,7 @@ static void send_client_key_exchange(tls
 	};
 //FIXME: better size estimate
 	struct client_key_exchange *record = tls_get_zeroed_outbuf(tls, sizeof(*record));
-	uint8_t rsa_premaster[RSA_PREMASTER_SIZE];
-	uint8_t x25519_premaster[CURVE25519_KEYSIZE];
-	uint8_t *premaster;
+	uint8_t premaster[RSA_PREMASTER_SIZE > EC_CURVE_KEYSIZE ? RSA_PREMASTER_SIZE : EC_CURVE_KEYSIZE];
 	int premaster_size;
 	int len;
 
@@ -1929,19 +1946,19 @@ static void send_client_key_exchange(tls
 		if (!(tls->flags & GOT_CERT_RSA_KEY_ALG))
 			bb_simple_error_msg("server cert is not RSA");
 
-		tls_get_random(rsa_premaster, sizeof(rsa_premaster));
+		tls_get_random(premaster, RSA_PREMASTER_SIZE);
 		if (TLS_DEBUG_FIXED_SECRETS)
-			memset(rsa_premaster, 0x44, sizeof(rsa_premaster));
+			memset(premaster, 0x44, RSA_PREMASTER_SIZE);
 		// RFC 5246
 		// "Note: The version number in the PreMasterSecret is the version
 		// offered by the client in the ClientHello.client_version, not the
 		// version negotiated for the connection."
-		rsa_premaster[0] = TLS_MAJ;
-		rsa_premaster[1] = TLS_MIN;
-		dump_hex("premaster:%s\n", rsa_premaster, sizeof(rsa_premaster));
+		premaster[0] = TLS_MAJ;
+		premaster[1] = TLS_MIN;
+		dump_hex("premaster:%s\n", premaster, sizeof(premaster));
 		len = psRsaEncryptPub(/*pool:*/ NULL,
 			/* psRsaKey_t* */ &tls->hsd->server_rsa_pub_key,
-			rsa_premaster, /*inlen:*/ sizeof(rsa_premaster),
+			premaster, /*inlen:*/ RSA_PREMASTER_SIZE,
 			record->key + 2, sizeof(record->key) - 2,
 			data_param_ignored
 		);
@@ -1949,33 +1966,36 @@ static void send_client_key_exchange(tls
 		record->key[0] = len >> 8;
 		record->key[1] = len & 0xff;
 		len += 2;
-		premaster = rsa_premaster;
-		premaster_size = sizeof(rsa_premaster);
+		premaster_size = RSA_PREMASTER_SIZE;
 	} else {
 		/* ECDHE */
-		static const uint8_t basepoint9[CURVE25519_KEYSIZE] ALIGN1 = {9};
-		uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
-
 		if (!(tls->flags & GOT_EC_KEY))
-			bb_simple_error_msg("server did not provide EC key");
-
-		/* Generate random private key, see RFC 7748 */
-		tls_get_random(privkey, sizeof(privkey));
-		privkey[0] &= 0xf8;
-		privkey[CURVE25519_KEYSIZE-1] = ((privkey[CURVE25519_KEYSIZE-1] & 0x7f) | 0x40);
-
-		/* Compute public key */
-		curve25519(record->key + 1, privkey, basepoint9);
-
-		/* Compute premaster using peer's public key */
-		dbg("computing x25519_premaster\n");
-		curve25519(x25519_premaster, privkey, tls->hsd->ecc_pub_key32);
+			bb_simple_error_msg_and_die("server did not provide EC key");
 
-		len = CURVE25519_KEYSIZE;
+		if (tls->flags & GOT_EC_CURVE_X25519) {
+			/* ECDHE, curve x25519 */
+			dbg("computing x25519_premaster\n");
+			curve_x25519_compute_pubkey_and_premaster(
+					record->key + 1, premaster,
+					/*point:*/ tls->hsd->ecc_pub_key32
+			);
+			len = CURVE25519_KEYSIZE;
+			//record->key[0] = len;
+			//len++;
+			//premaster_size = CURVE25519_KEYSIZE;
+		} else {
+			/* ECDHE, curve P256 */
+			dbg("computing P256_premaster\n");
+			curve_P256_compute_pubkey_and_premaster(
+					record->key + 2, premaster,
+					/*point:*/ tls->hsd->ecc_pub_key32
+			);
+			record->key[1] = 4; /* "uncompressed point" */
+			len = 1 + P256_KEYSIZE * 2;
+		}
 		record->key[0] = len;
 		len++;
-		premaster = x25519_premaster;
-		premaster_size = sizeof(x25519_premaster);
+		premaster_size = P256_KEYSIZE; // = CURVE25519_KEYSIZE = 32
 	}
 
 	record->type = HANDSHAKE_CLIENT_KEY_EXCHANGE;
diff -urpN busybox-1.33.1/networking/tls.h busybox-1.34.0/networking/tls.h
--- busybox-1.33.1/networking/tls.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls.h	2021-04-27 00:21:10.000000000 +0700
@@ -105,4 +105,15 @@ void xorbuf_aligned_AES_BLOCK_SIZE(void*
 #include "tls_aes.h"
 #include "tls_aesgcm.h"
 #include "tls_rsa.h"
-#include "tls_fe.h"
+
+#define EC_CURVE_KEYSIZE   32
+#define P256_KEYSIZE       32
+#define CURVE25519_KEYSIZE 32
+
+void curve_x25519_compute_pubkey_and_premaster(
+		uint8_t *pubkey32, uint8_t *premaster32,
+		const uint8_t *peerkey32) FAST_FUNC;
+
+void curve_P256_compute_pubkey_and_premaster(
+		uint8_t *pubkey2x32, uint8_t *premaster32,
+		const uint8_t *peerkey2x32) FAST_FUNC;
diff -urpN busybox-1.33.1/networking/tls_fe.c busybox-1.34.0/networking/tls_fe.c
--- busybox-1.33.1/networking/tls_fe.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls_fe.c	2021-05-05 02:35:15.000000000 +0700
@@ -64,8 +64,8 @@ static void fprime_select(byte *dst, con
 #endif
 
 static void fe_select(byte *dst,
-		   const byte *zero, const byte *one,
-		   byte condition)
+		const byte *zero, const byte *one,
+		byte condition)
 {
 	const byte mask = -condition;
 	int i;
@@ -108,26 +108,26 @@ static void raw_try_sub(byte *x, const b
 #if 0 //UNUSED
 static int prime_msb(const byte *p)
 {
-    int i;
-    byte x;
-    int shift = 1;
-    int z     = F25519_SIZE - 1;
-
-   /*
-       Test for any hot bits.
-       As soon as one instance is encountered set shift to 0.
-    */
+	int i;
+	byte x;
+	int shift = 1;
+	int z     = F25519_SIZE - 1;
+
+	/*
+	    Test for any hot bits.
+	    As soon as one instance is encountered set shift to 0.
+	 */
 	for (i = F25519_SIZE - 1; i >= 0; i--) {
-        shift &= ((shift ^ ((-p[i] | p[i]) >> 7)) & 1);
-        z -= shift;
-    }
+		shift &= ((shift ^ ((-p[i] | p[i]) >> 7)) & 1);
+		z -= shift;
+	}
 	x = p[z];
 	z <<= 3;
-    shift = 1;
-    for (i = 0; i < 8; i++) {
-        shift &= ((-(x >> i) | (x >> i)) >> (7 - i) & 1);
-        z += shift;
-    }
+	shift = 1;
+	for (i = 0; i < 8; i++) {
+		shift &= ((-(x >> i) | (x >> i)) >> (7 - i) & 1);
+		z += shift;
+	}
 
 	return z - 1;
 }
@@ -163,11 +163,11 @@ static void fprime_mul(byte *r, const by
 		const byte bit = (b[i >> 3] >> (i & 7)) & 1;
 		byte plusa[F25519_SIZE];
 
-	    for (j = 0; j < F25519_SIZE; j++) {
-		    c |= ((word16)r[j]) << 1;
-		    r[j] = (byte)c;
-		    c >>= 8;
-	    }
+		for (j = 0; j < F25519_SIZE; j++) {
+			c |= ((word16)r[j]) << 1;
+			r[j] = (byte)c;
+			c >>= 8;
+		}
 		raw_try_sub(r, modulus);
 
 		fprime_copy(plusa, r);
@@ -315,7 +315,7 @@ static void fe_mul__distinct(byte *r, co
 
 		for (; j < F25519_SIZE; j++)
 			c += ((word32)a[j]) *
-			     ((word32)b[i + F25519_SIZE - j]) * 38;
+				((word32)b[i + F25519_SIZE - j]) * 38;
 
 		r[i] = c;
 	}
@@ -383,12 +383,10 @@ static void fe_inv__distinct(byte *r, co
 	 * to avoid copying temporaries.
 	 */
 
-	/* 1 1 */
-	fe_mul__distinct(s, x, x);
-	fe_mul__distinct(r, s, x);
+	lm_copy(r, x);
 
-	/* 1 x 248 */
-	for (i = 0; i < 248; i++) {
+	/* 1, 1 x 249 */
+	for (i = 0; i < 249; i++) {
 		fe_mul__distinct(s, r, r);
 		fe_mul__distinct(r, s, x);
 	}
@@ -403,13 +401,11 @@ static void fe_inv__distinct(byte *r, co
 	/* 0 */
 	fe_mul__distinct(r, s, s);
 
-	/* 1 */
-	fe_mul__distinct(s, r, r);
-	fe_mul__distinct(r, s, x);
-
-	/* 1 */
-	fe_mul__distinct(s, r, r);
-	fe_mul__distinct(r, s, x);
+	/* 1, 1 */
+	for (i = 0; i < 2; i++) {
+		fe_mul__distinct(s, r, r);
+		fe_mul__distinct(r, s, x);
+	}
 }
 
 #if 0 //UNUSED
@@ -435,12 +431,10 @@ static void exp2523(byte *r, const byte
 	 *     111111... 01
 	 */
 
-	/* 1 1 */
-	fe_mul__distinct(r, x, x);
-	fe_mul__distinct(s, r, x);
+	lm_copy(s, x);
 
-	/* 1 x 248 */
-	for (i = 0; i < 248; i++) {
+	/* 1, 1 x 249 */
+	for (i = 0; i < 249; i++) {
 		fe_mul__distinct(r, s, s);
 		fe_mul__distinct(s, r, x);
 	}
@@ -480,9 +474,9 @@ static void fe_sqrt(byte *r, const byte
 
 /* Differential addition */
 static void xc_diffadd(byte *x5, byte *z5,
-		       const byte *x1, const byte *z1,
-		       const byte *x2, const byte *z2,
-		       const byte *x3, const byte *z3)
+		const byte *x1, const byte *z1,
+		const byte *x2, const byte *z2,
+		const byte *x3, const byte *z3)
 {
 	/* Explicit formulas database: dbl-1987-m3
 	 *
@@ -522,7 +516,7 @@ static void xc_diffadd(byte *x5, byte *z
 
 /* Double an X-coordinate */
 static void xc_double(byte *x3, byte *z3,
-		      const byte *x1, const byte *z1)
+		const byte *x1, const byte *z1)
 {
 	/* Explicit formulas database: dbl-1987-m
 	 *
@@ -550,11 +544,14 @@ static void xc_double(byte *x3, byte *z3
 	fe_mul_c(z3, x1sq, 4);
 }
 
-void FAST_FUNC curve25519(byte *result, const byte *e, const byte *q)
+static void curve25519(byte *result, const byte *e, const byte *q)
 {
 	int i;
 
 	struct {
+		/* for bbox's special case of q == NULL meaning "use basepoint" */
+		/*static const*/ uint8_t basepoint9[CURVE25519_KEYSIZE]; // = {9};
+
 		/* from wolfssl-3.15.3/wolfssl/wolfcrypt/fe_operations.h */
 		/*static const*/ byte f25519_one[F25519_SIZE]; // = {1};
 
@@ -565,6 +562,7 @@ void FAST_FUNC curve25519(byte *result,
 		byte xm1[F25519_SIZE]; // = {1};
 		byte zm1[F25519_SIZE]; // = {0};
 	} z;
+#define basepoint9 z.basepoint9
 #define f25519_one z.f25519_one
 #define xm         z.xm
 #define zm         z.zm
@@ -575,6 +573,11 @@ void FAST_FUNC curve25519(byte *result,
 	zm[0] = 1;
 	xm1[0] = 1;
 
+	if (!q) {
+		basepoint9[0] = 9;
+		q = basepoint9;
+	}
+
 	/* Note: bit 254 is assumed to be 1 */
 	lm_copy(xm, q);
 
@@ -605,3 +608,23 @@ void FAST_FUNC curve25519(byte *result,
 	fe_mul__distinct(result, zm1, xm);
 	fe_normalize(result);
 }
+
+/* interface to bbox's TLS code: */
+
+void FAST_FUNC curve_x25519_compute_pubkey_and_premaster(
+		uint8_t *pubkey, uint8_t *premaster,
+		const uint8_t *peerkey32)
+{
+	uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
+
+	/* Generate random private key, see RFC 7748 */
+	tls_get_random(privkey, sizeof(privkey));
+	privkey[0] &= 0xf8;
+	privkey[CURVE25519_KEYSIZE-1] = ((privkey[CURVE25519_KEYSIZE-1] & 0x7f) | 0x40);
+
+	/* Compute public key */
+	curve25519(pubkey, privkey, NULL /* "use base point of x25519" */);
+
+	/* Compute premaster using peer's public key */
+	curve25519(premaster, privkey, peerkey32);
+}
diff -urpN busybox-1.33.1/networking/tls_fe.h busybox-1.34.0/networking/tls_fe.h
--- busybox-1.33.1/networking/tls_fe.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls_fe.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,7 +0,0 @@
-/*
- * Copyright (C) 2018 Denys Vlasenko
- *
- * Licensed under GPLv2, see file LICENSE in this source tree.
- */
-#define CURVE25519_KEYSIZE 32
-void curve25519(uint8_t *result, const uint8_t *e, const uint8_t *q) FAST_FUNC;
diff -urpN busybox-1.33.1/networking/tls_pstm.c busybox-1.34.0/networking/tls_pstm.c
--- busybox-1.33.1/networking/tls_pstm.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls_pstm.c	2021-04-27 23:35:20.000000000 +0700
@@ -438,9 +438,9 @@ int32 FAST_FUNC pstm_read_unsigned_bin(p
 			int32 idx = (c - 1) & ~3;
 			switch (c % 4) {
 				case 0:	do { pd[idx+0] = *b++;
-					case 3:	     pd[idx+1] = *b++;
-					case 2:	     pd[idx+2] = *b++;
-					case 1:	     pd[idx+3] = *b++;
+					case 3: pd[idx+1] = *b++;
+					case 2: pd[idx+2] = *b++;
+					case 1: pd[idx+3] = *b++;
 					idx -= 4;
 				} while ((c -= 4) > 0);
 			}
@@ -1427,7 +1427,7 @@ static int32 pstm_div(psPool_t *pool, ps
 		}
 
 		/* while (q{i-t-1} * (yt * b + y{t-1})) >
-			 xi * b**2 + xi-1 * b + xi-2
+			xi * b**2 + xi-1 * b + xi-2
 
 			do q{i-t-1} -= 1;
 		*/
diff -urpN busybox-1.33.1/networking/tls_pstm_montgomery_reduce.c busybox-1.34.0/networking/tls_pstm_montgomery_reduce.c
--- busybox-1.33.1/networking/tls_pstm_montgomery_reduce.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls_pstm_montgomery_reduce.c	2021-04-27 00:21:10.000000000 +0700
@@ -62,6 +62,7 @@
 #define LOOP_START \
    mu = c[x] * mp
 
+#if 0
 #define INNERMUL                                          \
 asm(                                                      \
    "movl %5,%%eax \n\t"                                   \
@@ -74,15 +75,38 @@ asm(
 :"=g"(_c[LO]), "=r"(cy)                                   \
 :"0"(_c[LO]), "1"(cy), "g"(mu), "g"(*tmpm++)              \
 : "%eax", "%edx", "cc")
+/*
+ * The above generated "error: 'asm' operand has impossible constraints" on Android.
+ * Do they reserve in their ABI a register for something, and there aren't enough left?
+ */
+#else
+/* Let's avoid two explicit "movl" by telling compiler to put input value of *tmpm++
+ * into EAX, and to expect cy result in EDX:
+ */
+#define INNERMUL                                          \
+asm(                                                      \
+   "mull %4       \n\t"                                   \
+   "addl %3,%%eax \n\t"                                   \
+   "adcl $0,%%edx \n\t"                                   \
+   "addl %%eax,%0 \n\t"                                   \
+   "adcl $0,%%edx \n\t"                                   \
+:"=g"(_c[LO]), "=&d"(cy)                                  \
+:"0"(_c[LO]), "g"(cy), "g"(mu), "a"(*tmpm++)              \
+:"cc")
+/* This doesn't tell compiler that we clobber EAX, but it probably won't need
+ * the value of *tmpm anyway, thus won't try to reuse EAX contents.
+ * TODO: fix it with dummy "=a"(clobbered_eax) output?
+ */
+#endif
 
 #define PROPCARRY                           \
 asm(                                        \
    "addl   %1,%0    \n\t"                   \
-   "setb   %%al     \n\t"                   \
-   "movzbl %%al,%1 \n\t"                    \
+   "sbb    %1,%1    \n\t"                   \
+   "neg    %1       \n\t"                   \
 :"=g"(_c[LO]), "=r"(cy)                     \
 :"0"(_c[LO]), "1"(cy)                       \
-: "%eax", "cc")
+:"cc")
 
 /******************************************************************************/
 #elif defined(PSTM_X86_64)
diff -urpN busybox-1.33.1/networking/tls_rsa.c busybox-1.34.0/networking/tls_rsa.c
--- busybox-1.33.1/networking/tls_rsa.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/tls_rsa.c	2021-04-27 23:35:20.000000000 +0700
@@ -15,7 +15,7 @@
         pkcs1Pad(in, inlen, out, outlen, cryptType)
 static //bbox
 int32 pkcs1Pad(unsigned char *in, uint32 inlen, unsigned char *out,
-					   uint32 outlen, int32 cryptType, void *userPtr)
+			uint32 outlen, int32 cryptType, void *userPtr)
 {
 	unsigned char   *c;
 	int32           randomLen;
@@ -60,7 +60,7 @@ int32 pkcs1Pad(unsigned char *in, uint32
         psRsaCrypt(      in, inlen, out, outlen, key, type)
 static //bbox
 int32 psRsaCrypt(psPool_t *pool, const unsigned char *in, uint32 inlen,
-			unsigned char *out, uint32 *outlen,	psRsaKey_t *key, int32 type,
+			unsigned char *out, uint32 *outlen, psRsaKey_t *key, int32 type,
 			void *data)
 {
 	pstm_int		tmp, tmpa, tmpb;
diff -urpN busybox-1.33.1/networking/tls_sp_c32.c busybox-1.34.0/networking/tls_sp_c32.c
--- busybox-1.33.1/networking/tls_sp_c32.c	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/networking/tls_sp_c32.c	2021-05-05 02:35:15.000000000 +0700
@@ -0,0 +1,927 @@
+/*
+ * Copyright (C) 2021 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+#define SP_DEBUG          0
+#define FIXED_SECRET      0
+#define FIXED_PEER_PUBKEY 0
+
+#if SP_DEBUG
+# define dbg(...) fprintf(stderr, __VA_ARGS__)
+static void dump_hex(const char *fmt, const void *vp, int len)
+{
+	char hexbuf[32 * 1024 + 4];
+	const uint8_t *p = vp;
+
+	bin2hex(hexbuf, (void*)p, len)[0] = '\0';
+	dbg(fmt, hexbuf);
+}
+#else
+# define dbg(...) ((void)0)
+# define dump_hex(...) ((void)0)
+#endif
+
+#undef DIGIT_BIT
+#define DIGIT_BIT  32
+typedef int32_t sp_digit;
+
+/* The code below is taken from parts of
+ *  wolfssl-3.15.3/wolfcrypt/src/sp_c32.c
+ * and heavily modified.
+ * Header comment is kept intact:
+ */
+
+/* sp.c
+ *
+ * Copyright (C) 2006-2018 wolfSSL Inc.
+ *
+ * This file is part of wolfSSL.
+ *
+ * wolfSSL is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * wolfSSL is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
+ */
+
+/* Implementation by Sean Parkinson. */
+
+typedef struct sp_point {
+	sp_digit x[2 * 10];
+	sp_digit y[2 * 10];
+	sp_digit z[2 * 10];
+	int infinity;
+} sp_point;
+
+/* The modulus (prime) of the curve P256. */
+static const sp_digit p256_mod[10] = {
+	0x3ffffff,0x3ffffff,0x3ffffff,0x003ffff,0x0000000,
+	0x0000000,0x0000000,0x0000400,0x3ff0000,0x03fffff,
+};
+
+#define p256_mp_mod ((sp_digit)0x000001)
+
+/* Write r as big endian to byte aray.
+ * Fixed length number of bytes written: 32
+ *
+ * r  A single precision integer.
+ * a  Byte array.
+ */
+static void sp_256_to_bin(sp_digit* r, uint8_t* a)
+{
+	int i, j, s = 0, b;
+
+	for (i = 0; i < 9; i++) {
+		r[i+1] += r[i] >> 26;
+		r[i] &= 0x3ffffff;
+	}
+	j = 256 / 8 - 1;
+	a[j] = 0;
+	for (i = 0; i < 10 && j >= 0; i++) {
+		b = 0;
+		a[j--] |= r[i] << s; b += 8 - s;
+		if (j < 0)
+			break;
+		while (b < 26) {
+			a[j--] = r[i] >> b; b += 8;
+			if (j < 0)
+				break;
+		}
+		s = 8 - (b - 26);
+		if (j >= 0)
+			a[j] = 0;
+		if (s != 0)
+			j++;
+	}
+}
+
+/* Read big endian unsigned byte aray into r.
+ *
+ * r  A single precision integer.
+ * a  Byte array.
+ * n  Number of bytes in array to read.
+ */
+static void sp_256_from_bin(sp_digit* r, int max, const uint8_t* a, int n)
+{
+	int i, j = 0, s = 0;
+
+	r[0] = 0;
+	for (i = n-1; i >= 0; i--) {
+		r[j] |= ((sp_digit)a[i]) << s;
+		if (s >= 18) {
+			r[j] &= 0x3ffffff;
+			s = 26 - s;
+			if (j + 1 >= max)
+				break;
+			r[++j] = a[i] >> s;
+			s = 8 - s;
+		}
+		else
+			s += 8;
+	}
+
+	for (j++; j < max; j++)
+		r[j] = 0;
+}
+
+/* Convert a point of big-endian 32-byte x,y pair to type sp_point. */
+static void sp_256_point_from_bin2x32(sp_point* p, const uint8_t *bin2x32)
+{
+	memset(p, 0, sizeof(*p));
+	/*p->infinity = 0;*/
+	sp_256_from_bin(p->x, 2 * 10, bin2x32, 32);
+	sp_256_from_bin(p->y, 2 * 10, bin2x32 + 32, 32);
+	//static const uint8_t one[1] = { 1 };
+	//sp_256_from_bin(p->z, 2 * 10, one, 1);
+	p->z[0] = 1;
+}
+
+/* Compare a with b.
+ *
+ * return -ve, 0 or +ve if a is less than, equal to or greater than b
+ * respectively.
+ */
+static sp_digit sp_256_cmp_10(const sp_digit* a, const sp_digit* b)
+{
+	sp_digit r;
+	int i;
+	for (i = 9; i >= 0; i--) {
+		r = a[i] - b[i];
+		if (r != 0)
+			break;
+	}
+	return r;
+}
+
+/* Compare two numbers to determine if they are equal.
+ *
+ * return 1 when equal and 0 otherwise.
+ */
+static int sp_256_cmp_equal_10(const sp_digit* a, const sp_digit* b)
+{
+	return sp_256_cmp_10(a, b) == 0;
+}
+
+/* Normalize the values in each word to 26 bits. */
+static void sp_256_norm_10(sp_digit* a)
+{
+	int i;
+	for (i = 0; i < 9; i++) {
+		a[i+1] += a[i] >> 26;
+		a[i] &= 0x3ffffff;
+	}
+}
+
+/* Add b to a into r. (r = a + b) */
+static void sp_256_add_10(sp_digit* r, const sp_digit* a, const sp_digit* b)
+{
+	int i;
+	for (i = 0; i < 10; i++)
+		r[i] = a[i] + b[i];
+}
+
+/* Sub b from a into r. (r = a - b) */
+static void sp_256_sub_10(sp_digit* r, const sp_digit* a, const sp_digit* b)
+{
+	int i;
+	for (i = 0; i < 10; i++)
+		r[i] = a[i] - b[i];
+}
+
+/* Shift number left one bit. Bottom bit is lost. */
+static void sp_256_rshift1_10(sp_digit* r, sp_digit* a)
+{
+	int i;
+	for (i = 0; i < 9; i++)
+		r[i] = ((a[i] >> 1) | (a[i + 1] << 25)) & 0x3ffffff;
+	r[9] = a[9] >> 1;
+}
+
+/* Mul a by scalar b and add into r. (r += a * b) */
+static void sp_256_mul_add_10(sp_digit* r, const sp_digit* a, sp_digit b)
+{
+	int64_t tb = b;
+	int64_t t = 0;
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		t += (tb * a[i]) + r[i];
+		r[i] = t & 0x3ffffff;
+		t >>= 26;
+	}
+	r[10] += t;
+}
+
+/* Multiply a and b into r. (r = a * b) */
+static void sp_256_mul_10(sp_digit* r, const sp_digit* a, const sp_digit* b)
+{
+	int i, j, k;
+	int64_t c;
+
+	c = ((int64_t)a[9]) * b[9];
+	r[19] = (sp_digit)(c >> 26);
+	c = (c & 0x3ffffff) << 26;
+	for (k = 17; k >= 0; k--) {
+		for (i = 9; i >= 0; i--) {
+			j = k - i;
+			if (j >= 10)
+				break;
+			if (j < 0)
+				continue;
+			c += ((int64_t)a[i]) * b[j];
+		}
+		r[k + 2] += c >> 52;
+		r[k + 1] = (c >> 26) & 0x3ffffff;
+		c = (c & 0x3ffffff) << 26;
+	}
+	r[0] = (sp_digit)(c >> 26);
+}
+
+/* Square a and put result in r. (r = a * a) */
+static void sp_256_sqr_10(sp_digit* r, const sp_digit* a)
+{
+	int i, j, k;
+	int64_t c;
+
+	c = ((int64_t)a[9]) * a[9];
+	r[19] = (sp_digit)(c >> 26);
+	c = (c & 0x3ffffff) << 26;
+	for (k = 17; k >= 0; k--) {
+		for (i = 9; i >= 0; i--) {
+			j = k - i;
+			if (j >= 10 || i <= j)
+				break;
+			if (j < 0)
+				continue;
+			c += ((int64_t)a[i]) * a[j] * 2;
+		}
+		if (i == j)
+			c += ((int64_t)a[i]) * a[i];
+		r[k + 2] += c >> 52;
+		r[k + 1] = (c >> 26) & 0x3ffffff;
+		c = (c & 0x3ffffff) << 26;
+	}
+	r[0] = (sp_digit)(c >> 26);
+}
+
+/* Divide the number by 2 mod the modulus (prime). (r = a / 2 % m) */
+static void sp_256_div2_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
+{
+	if (a[0] & 1)
+		sp_256_add_10(r, a, m);
+	sp_256_norm_10(r);
+	sp_256_rshift1_10(r, r);
+}
+
+/* Add two Montgomery form numbers (r = a + b % m) */
+static void sp_256_mont_add_10(sp_digit* r, const sp_digit* a, const sp_digit* b,
+		const sp_digit* m)
+{
+	sp_256_add_10(r, a, b);
+	sp_256_norm_10(r);
+	if ((r[9] >> 22) > 0)
+		sp_256_sub_10(r, r, m);
+	sp_256_norm_10(r);
+}
+
+/* Subtract two Montgomery form numbers (r = a - b % m) */
+static void sp_256_mont_sub_10(sp_digit* r, const sp_digit* a, const sp_digit* b,
+		const sp_digit* m)
+{
+	sp_256_sub_10(r, a, b);
+	if (r[9] >> 22)
+		sp_256_add_10(r, r, m);
+	sp_256_norm_10(r);
+}
+
+/* Double a Montgomery form number (r = a + a % m) */
+static void sp_256_mont_dbl_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
+{
+	sp_256_add_10(r, a, a);
+	sp_256_norm_10(r);
+	if ((r[9] >> 22) > 0)
+		sp_256_sub_10(r, r, m);
+	sp_256_norm_10(r);
+}
+
+/* Triple a Montgomery form number (r = a + a + a % m) */
+static void sp_256_mont_tpl_10(sp_digit* r, const sp_digit* a, const sp_digit* m)
+{
+	sp_256_add_10(r, a, a);
+	sp_256_norm_10(r);
+	if ((r[9] >> 22) > 0)
+		sp_256_sub_10(r, r, m);
+	sp_256_norm_10(r);
+	sp_256_add_10(r, r, a);
+	sp_256_norm_10(r);
+	if ((r[9] >> 22) > 0)
+		sp_256_sub_10(r, r, m);
+	sp_256_norm_10(r);
+}
+
+/* Shift the result in the high 256 bits down to the bottom. */
+static void sp_256_mont_shift_10(sp_digit* r, const sp_digit* a)
+{
+	int i;
+	sp_digit n, s;
+
+	s = a[10];
+	n = a[9] >> 22;
+	for (i = 0; i < 9; i++) {
+		n += (s & 0x3ffffff) << 4;
+		r[i] = n & 0x3ffffff;
+		n >>= 26;
+		s = a[11 + i] + (s >> 26);
+	}
+	n += s << 4;
+	r[9] = n;
+	memset(&r[10], 0, sizeof(*r) * 10);
+}
+
+/* Reduce the number back to 256 bits using Montgomery reduction.
+ *
+ * a   A single precision number to reduce in place.
+ * m   The single precision number representing the modulus.
+ * mp  The digit representing the negative inverse of m mod 2^n.
+ */
+static void sp_256_mont_reduce_10(sp_digit* a, const sp_digit* m, sp_digit mp)
+{
+	int i;
+	sp_digit mu;
+
+	if (mp != 1) {
+		for (i = 0; i < 9; i++) {
+			mu = (a[i] * mp) & 0x3ffffff;
+			sp_256_mul_add_10(a+i, m, mu);
+			a[i+1] += a[i] >> 26;
+		}
+		mu = (a[i] * mp) & 0x3fffffl;
+		sp_256_mul_add_10(a+i, m, mu);
+		a[i+1] += a[i] >> 26;
+		a[i] &= 0x3ffffff;
+	}
+	else {
+		for (i = 0; i < 9; i++) {
+			mu = a[i] & 0x3ffffff;
+			sp_256_mul_add_10(a+i, p256_mod, mu);
+			a[i+1] += a[i] >> 26;
+		}
+		mu = a[i] & 0x3fffffl;
+		sp_256_mul_add_10(a+i, p256_mod, mu);
+		a[i+1] += a[i] >> 26;
+		a[i] &= 0x3ffffff;
+	}
+
+	sp_256_mont_shift_10(a, a);
+	if ((a[9] >> 22) > 0)
+		sp_256_sub_10(a, a, m);
+	sp_256_norm_10(a);
+}
+
+/* Multiply two Montogmery form numbers mod the modulus (prime).
+ * (r = a * b mod m)
+ *
+ * r   Result of multiplication.
+ * a   First number to multiply in Montogmery form.
+ * b   Second number to multiply in Montogmery form.
+ * m   Modulus (prime).
+ * mp  Montogmery mulitplier.
+ */
+static void sp_256_mont_mul_10(sp_digit* r, const sp_digit* a, const sp_digit* b,
+		const sp_digit* m, sp_digit mp)
+{
+	sp_256_mul_10(r, a, b);
+	sp_256_mont_reduce_10(r, m, mp);
+}
+
+/* Square the Montgomery form number. (r = a * a mod m)
+ *
+ * r   Result of squaring.
+ * a   Number to square in Montogmery form.
+ * m   Modulus (prime).
+ * mp  Montogmery mulitplier.
+ */
+static void sp_256_mont_sqr_10(sp_digit* r, const sp_digit* a, const sp_digit* m,
+		sp_digit mp)
+{
+	sp_256_sqr_10(r, a);
+	sp_256_mont_reduce_10(r, m, mp);
+}
+
+/* Invert the number, in Montgomery form, modulo the modulus (prime) of the
+ * P256 curve. (r = 1 / a mod m)
+ *
+ * r   Inverse result.
+ * a   Number to invert.
+ */
+#if 0
+/* Mod-2 for the P256 curve. */
+static const uint32_t p256_mod_2[8] = {
+	0xfffffffd,0xffffffff,0xffffffff,0x00000000,
+	0x00000000,0x00000000,0x00000001,0xffffffff,
+};
+//Bit pattern:
+//2    2         2         2         2         2         2         1...1
+//5    5         4         3         2         1         0         9...0         9...1
+//543210987654321098765432109876543210987654321098765432109876543210...09876543210...09876543210
+//111111111111111111111111111111110000000000000000000000000000000100...00000111111...11111111101
+#endif
+static void sp_256_mont_inv_10(sp_digit* r, sp_digit* a)
+{
+	sp_digit t[2*10]; //can be just [10]?
+	int i;
+
+	memcpy(t, a, sizeof(sp_digit) * 10);
+	for (i = 254; i >= 0; i--) {
+		sp_256_mont_sqr_10(t, t, p256_mod, p256_mp_mod);
+		/*if (p256_mod_2[i / 32] & ((sp_digit)1 << (i % 32)))*/
+		if (i >= 224 || i == 192 || (i <= 95 && i != 1))
+			sp_256_mont_mul_10(t, t, a, p256_mod, p256_mp_mod);
+	}
+	memcpy(r, t, sizeof(sp_digit) * 10);
+}
+
+/* Multiply a number by Montogmery normalizer mod modulus (prime).
+ *
+ * r  The resulting Montgomery form number.
+ * a  The number to convert.
+ */
+static void sp_256_mod_mul_norm_10(sp_digit* r, const sp_digit* a)
+{
+	int64_t t[8];
+	int64_t o;
+	uint32_t a32;
+
+	/*  1  1  0 -1 -1 -1 -1  0 */
+	/*  0  1  1  0 -1 -1 -1 -1 */
+	/*  0  0  1  1  0 -1 -1 -1 */
+	/* -1 -1  0  2  2  1  0 -1 */
+	/*  0 -1 -1  0  2  2  1  0 */
+	/*  0  0 -1 -1  0  2  2  1 */
+	/* -1 -1  0  0  0  1  3  2 */
+	/*  1  0 -1 -1 -1 -1  0  3 */
+	// t[] should be calculated from "a" (converted from 26-bit to 32-bit vector a32[8])
+	// according to the above matrix:
+	//t[0] = 0 + a32[0] + a32[1]            - a32[3]   - a32[4]   - a32[5]   - a32[6]             ;
+	//t[1] = 0          + a32[1] + a32[2]              - a32[4]   - a32[5]   - a32[6]   - a32[7]  ;
+	//t[2] = 0                   + a32[2]   + a32[3]              - a32[5]   - a32[6]   - a32[7]  ;
+	//t[3] = 0 - a32[0] - a32[1]            + 2*a32[3] + 2*a32[4] + a32[5]              - a32[7]  ;
+	//t[4] = 0          - a32[1] - a32[2]              + 2*a32[4] + 2*a32[5] + a32[6]             ;
+	//t[5] = 0                   - a32[2]   - a32[3]              + 2*a32[5] + 2*a32[6] + a32[7]  ;
+	//t[6] = 0 - a32[0] - a32[1]                                  + a32[5]   + 3*a32[6] + 2*a32[7];
+	//t[7] = 0 + a32[0]          - a32[2]   - a32[3]   - a32[4]   - a32[5]              + 3*a32[7];
+	// We can do it "piecemeal" after each a32[i] is known, no need to store entire a32[8] vector:
+
+#define A32 (int64_t)a32
+	a32 = a[0] | (a[1] << 26);
+	t[0] = 0 + A32;
+	t[3] = 0 - A32;
+	t[6] = 0 - A32;
+	t[7] = 0 + A32;
+
+	a32 = (a[1] >> 6) | (a[2] << 20);
+	t[0] += A32    ;
+	t[1]  = 0 + A32;
+	t[3] -= A32    ;
+	t[4]  = 0 - A32;
+	t[6] -= A32    ;
+
+	a32 = (a[2] >> 12) | (a[3] << 14);
+	t[1] += A32    ;
+	t[2]  = 0 + A32;
+	t[4] -= A32    ;
+	t[5]  = 0 - A32;
+	t[7] -= A32    ;
+
+	a32 = (a[3] >> 18) | (a[4] << 8);
+	t[0] -= A32  ;
+	t[2] += A32  ;
+	t[3] += 2*A32;
+	t[5] -= A32  ;
+	t[7] -= A32  ;
+
+	a32 = (a[4] >> 24) | (a[5] << 2) | (a[6] << 28);
+	t[0] -= A32  ;
+	t[1] -= A32  ;
+	t[3] += 2*A32;
+	t[4] += 2*A32;
+	t[7] -= A32  ;
+
+	a32 = (a[6] >> 4) | (a[7] << 22);
+	t[0] -= A32  ;
+	t[1] -= A32  ;
+	t[2] -= A32  ;
+	t[3] += A32  ;
+	t[4] += 2*A32;
+	t[5] += 2*A32;
+	t[6] += A32  ;
+	t[7] -= A32  ;
+
+	a32 = (a[7] >> 10) | (a[8] << 16);
+	t[0] -= A32  ;
+	t[1] -= A32  ;
+	t[2] -= A32  ;
+	t[4] += A32  ;
+	t[5] += 2*A32;
+	t[6] += 3*A32;
+
+	a32 = (a[8] >> 16) | (a[9] << 10);
+	t[1] -= A32  ;
+	t[2] -= A32  ;
+	t[3] -= A32  ;
+	t[5] += A32  ;
+	t[6] += 2*A32;
+	t[7] += 3*A32;
+#undef A32
+
+	t[1] += t[0] >> 32; t[0] &= 0xffffffff;
+	t[2] += t[1] >> 32; t[1] &= 0xffffffff;
+	t[3] += t[2] >> 32; t[2] &= 0xffffffff;
+	t[4] += t[3] >> 32; t[3] &= 0xffffffff;
+	t[5] += t[4] >> 32; t[4] &= 0xffffffff;
+	t[6] += t[5] >> 32; t[5] &= 0xffffffff;
+	t[7] += t[6] >> 32; t[6] &= 0xffffffff;
+	o     = t[7] >> 32; t[7] &= 0xffffffff;
+	t[0] += o;
+	t[3] -= o;
+	t[6] -= o;
+	t[7] += o;
+	t[1] += t[0] >> 32; //t[0] &= 0xffffffff;
+	t[2] += t[1] >> 32; //t[1] &= 0xffffffff;
+	t[3] += t[2] >> 32; //t[2] &= 0xffffffff;
+	t[4] += t[3] >> 32; //t[3] &= 0xffffffff;
+	t[5] += t[4] >> 32; //t[4] &= 0xffffffff;
+	t[6] += t[5] >> 32; //t[5] &= 0xffffffff;
+	t[7] += t[6] >> 32; //t[6] &= 0xffffffff; - (uint32_t)t[i] casts below accomplish masking
+
+	r[0] = 0x3ffffff & ((sp_digit)((uint32_t)t[0]));
+	r[1] = 0x3ffffff & ((sp_digit)((uint32_t)t[0] >> 26) | ((sp_digit)t[1] <<  6));
+	r[2] = 0x3ffffff & ((sp_digit)((uint32_t)t[1] >> 20) | ((sp_digit)t[2] << 12));
+	r[3] = 0x3ffffff & ((sp_digit)((uint32_t)t[2] >> 14) | ((sp_digit)t[3] << 18));
+	r[4] = 0x3ffffff & ((sp_digit)((uint32_t)t[3] >>  8) | ((sp_digit)t[4] << 24));
+	r[5] = 0x3ffffff & ((sp_digit)((uint32_t)t[4] >>  2));
+	r[6] = 0x3ffffff & ((sp_digit)((uint32_t)t[4] >> 28) | ((sp_digit)t[5] <<  4));
+	r[7] = 0x3ffffff & ((sp_digit)((uint32_t)t[5] >> 22) | ((sp_digit)t[6] << 10));
+	r[8] = 0x3ffffff & ((sp_digit)((uint32_t)t[6] >> 16) | ((sp_digit)t[7] << 16));
+	r[9] =             ((sp_digit)((uint32_t)t[7] >> 10));
+}
+
+/* Map the Montgomery form projective co-ordinate point to an affine point.
+ *
+ * r  Resulting affine co-ordinate point.
+ * p  Montgomery form projective co-ordinate point.
+ */
+static void sp_256_map_10(sp_point* r, sp_point* p)
+{
+	sp_digit t1[2*10];
+	sp_digit t2[2*10];
+
+	sp_256_mont_inv_10(t1, p->z);
+
+	sp_256_mont_sqr_10(t2, t1, p256_mod, p256_mp_mod);
+	sp_256_mont_mul_10(t1, t2, t1, p256_mod, p256_mp_mod);
+
+	/* x /= z^2 */
+	sp_256_mont_mul_10(r->x, p->x, t2, p256_mod, p256_mp_mod);
+	memset(r->x + 10, 0, sizeof(r->x) / 2);
+	sp_256_mont_reduce_10(r->x, p256_mod, p256_mp_mod);
+	/* Reduce x to less than modulus */
+	if (sp_256_cmp_10(r->x, p256_mod) >= 0)
+		sp_256_sub_10(r->x, r->x, p256_mod);
+	sp_256_norm_10(r->x);
+
+	/* y /= z^3 */
+	sp_256_mont_mul_10(r->y, p->y, t1, p256_mod, p256_mp_mod);
+	memset(r->y + 10, 0, sizeof(r->y) / 2);
+	sp_256_mont_reduce_10(r->y, p256_mod, p256_mp_mod);
+	/* Reduce y to less than modulus */
+	if (sp_256_cmp_10(r->y, p256_mod) >= 0)
+		sp_256_sub_10(r->y, r->y, p256_mod);
+	sp_256_norm_10(r->y);
+
+	memset(r->z, 0, sizeof(r->z));
+	r->z[0] = 1;
+}
+
+/* Double the Montgomery form projective point p.
+ *
+ * r  Result of doubling point.
+ * p  Point to double.
+ */
+static void sp_256_proj_point_dbl_10(sp_point* r, sp_point* p)
+{
+	sp_point tp;
+	sp_digit t1[2*10];
+	sp_digit t2[2*10];
+
+	/* Put point to double into result */
+	if (r != p)
+		*r = *p; /* struct copy */
+
+	if (r->infinity) {
+		/* If infinity, don't double (work on dummy value) */
+		r = &tp;
+	}
+	/* T1 = Z * Z */
+	sp_256_mont_sqr_10(t1, r->z, p256_mod, p256_mp_mod);
+	/* Z = Y * Z */
+	sp_256_mont_mul_10(r->z, r->y, r->z, p256_mod, p256_mp_mod);
+	/* Z = 2Z */
+	sp_256_mont_dbl_10(r->z, r->z, p256_mod);
+	/* T2 = X - T1 */
+	sp_256_mont_sub_10(t2, r->x, t1, p256_mod);
+	/* T1 = X + T1 */
+	sp_256_mont_add_10(t1, r->x, t1, p256_mod);
+	/* T2 = T1 * T2 */
+	sp_256_mont_mul_10(t2, t1, t2, p256_mod, p256_mp_mod);
+	/* T1 = 3T2 */
+	sp_256_mont_tpl_10(t1, t2, p256_mod);
+	/* Y = 2Y */
+	sp_256_mont_dbl_10(r->y, r->y, p256_mod);
+	/* Y = Y * Y */
+	sp_256_mont_sqr_10(r->y, r->y, p256_mod, p256_mp_mod);
+	/* T2 = Y * Y */
+	sp_256_mont_sqr_10(t2, r->y, p256_mod, p256_mp_mod);
+	/* T2 = T2/2 */
+	sp_256_div2_10(t2, t2, p256_mod);
+	/* Y = Y * X */
+	sp_256_mont_mul_10(r->y, r->y, r->x, p256_mod, p256_mp_mod);
+	/* X = T1 * T1 */
+	sp_256_mont_mul_10(r->x, t1, t1, p256_mod, p256_mp_mod);
+	/* X = X - Y */
+	sp_256_mont_sub_10(r->x, r->x, r->y, p256_mod);
+	/* X = X - Y */
+	sp_256_mont_sub_10(r->x, r->x, r->y, p256_mod);
+	/* Y = Y - X */
+	sp_256_mont_sub_10(r->y, r->y, r->x, p256_mod);
+	/* Y = Y * T1 */
+	sp_256_mont_mul_10(r->y, r->y, t1, p256_mod, p256_mp_mod);
+	/* Y = Y - T2 */
+	sp_256_mont_sub_10(r->y, r->y, t2, p256_mod);
+}
+
+/* Add two Montgomery form projective points.
+ *
+ * r  Result of addition.
+ * p  Frist point to add.
+ * q  Second point to add.
+ */
+static void sp_256_proj_point_add_10(sp_point* r, sp_point* p, sp_point* q)
+{
+	sp_digit t1[2*10];
+	sp_digit t2[2*10];
+	sp_digit t3[2*10];
+	sp_digit t4[2*10];
+	sp_digit t5[2*10];
+
+	/* Ensure only the first point is the same as the result. */
+	if (q == r) {
+		sp_point* a = p;
+		p = q;
+		q = a;
+	}
+
+	/* Check double */
+	sp_256_sub_10(t1, p256_mod, q->y);
+	sp_256_norm_10(t1);
+	if (sp_256_cmp_equal_10(p->x, q->x)
+	 && sp_256_cmp_equal_10(p->z, q->z)
+	 && (sp_256_cmp_equal_10(p->y, q->y) || sp_256_cmp_equal_10(p->y, t1))
+	) {
+		sp_256_proj_point_dbl_10(r, p);
+	}
+	else {
+		sp_point tp;
+		sp_point *v;
+
+		v = r;
+		if (p->infinity | q->infinity) {
+			memset(&tp, 0, sizeof(tp));
+			v = &tp;
+		}
+
+		*r = p->infinity ? *q : *p; /* struct copy */
+
+		/* U1 = X1*Z2^2 */
+		sp_256_mont_sqr_10(t1, q->z, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t3, t1, q->z, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t1, t1, v->x, p256_mod, p256_mp_mod);
+		/* U2 = X2*Z1^2 */
+		sp_256_mont_sqr_10(t2, v->z, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t4, t2, v->z, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t2, t2, q->x, p256_mod, p256_mp_mod);
+		/* S1 = Y1*Z2^3 */
+		sp_256_mont_mul_10(t3, t3, v->y, p256_mod, p256_mp_mod);
+		/* S2 = Y2*Z1^3 */
+		sp_256_mont_mul_10(t4, t4, q->y, p256_mod, p256_mp_mod);
+		/* H = U2 - U1 */
+		sp_256_mont_sub_10(t2, t2, t1, p256_mod);
+		/* R = S2 - S1 */
+		sp_256_mont_sub_10(t4, t4, t3, p256_mod);
+		/* Z3 = H*Z1*Z2 */
+		sp_256_mont_mul_10(v->z, v->z, q->z, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(v->z, v->z, t2, p256_mod, p256_mp_mod);
+		/* X3 = R^2 - H^3 - 2*U1*H^2 */
+		sp_256_mont_sqr_10(v->x, t4, p256_mod, p256_mp_mod);
+		sp_256_mont_sqr_10(t5, t2, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(v->y, t1, t5, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t5, t5, t2, p256_mod, p256_mp_mod);
+		sp_256_mont_sub_10(v->x, v->x, t5, p256_mod);
+		sp_256_mont_dbl_10(t1, v->y, p256_mod);
+		sp_256_mont_sub_10(v->x, v->x, t1, p256_mod);
+		/* Y3 = R*(U1*H^2 - X3) - S1*H^3 */
+		sp_256_mont_sub_10(v->y, v->y, v->x, p256_mod);
+		sp_256_mont_mul_10(v->y, v->y, t4, p256_mod, p256_mp_mod);
+		sp_256_mont_mul_10(t5, t5, t3, p256_mod, p256_mp_mod);
+		sp_256_mont_sub_10(v->y, v->y, t5, p256_mod);
+	}
+}
+
+/* Multiply the point by the scalar and return the result.
+ * If map is true then convert result to affine co-ordinates.
+ *
+ * r     Resulting point.
+ * g     Point to multiply.
+ * k     Scalar to multiply by.
+ * map   Indicates whether to convert result to affine.
+ */
+static void sp_256_ecc_mulmod_10(sp_point* r, const sp_point* g, const sp_digit* k /*, int map*/)
+{
+	enum { map = 1 }; /* we always convert result to affine coordinates */
+	sp_point t[3];
+	sp_digit n;
+	int i;
+	int c, y;
+
+	memset(t, 0, sizeof(t));
+
+	/* t[0] = {0, 0, 1} * norm */
+	t[0].infinity = 1;
+	/* t[1] = {g->x, g->y, g->z} * norm */
+	sp_256_mod_mul_norm_10(t[1].x, g->x);
+	sp_256_mod_mul_norm_10(t[1].y, g->y);
+	sp_256_mod_mul_norm_10(t[1].z, g->z);
+
+	i = 9;
+	c = 22;
+	n = k[i--] << (26 - c);
+	for (; ; c--) {
+		if (c == 0) {
+			if (i == -1)
+				break;
+
+			n = k[i--];
+			c = 26;
+		}
+
+		y = (n >> 25) & 1;
+		n <<= 1;
+
+		sp_256_proj_point_add_10(&t[y^1], &t[0], &t[1]);
+		memcpy(&t[2], &t[y], sizeof(sp_point));
+		sp_256_proj_point_dbl_10(&t[2], &t[2]);
+		memcpy(&t[y], &t[2], sizeof(sp_point));
+	}
+
+	if (map)
+		sp_256_map_10(r, &t[0]);
+	else
+		memcpy(r, &t[0], sizeof(sp_point));
+
+	memset(t, 0, sizeof(t)); //paranoia
+}
+
+/* Multiply the base point of P256 by the scalar and return the result.
+ * If map is true then convert result to affine co-ordinates.
+ *
+ * r     Resulting point.
+ * k     Scalar to multiply by.
+ * map   Indicates whether to convert result to affine.
+ */
+static void sp_256_ecc_mulmod_base_10(sp_point* r, sp_digit* k /*, int map*/)
+{
+	/* Since this function is called only once, save space:
+	 * don't have "static const sp_point p256_base = {...}",
+	 * it would have more zeros than data.
+	 */
+	static const uint8_t p256_base_bin[] = {
+		/* x (big-endian) */
+		0x6b,0x17,0xd1,0xf2,0xe1,0x2c,0x42,0x47,0xf8,0xbc,0xe6,0xe5,0x63,0xa4,0x40,0xf2,0x77,0x03,0x7d,0x81,0x2d,0xeb,0x33,0xa0,0xf4,0xa1,0x39,0x45,0xd8,0x98,0xc2,0x96,
+		/* y */
+		0x4f,0xe3,0x42,0xe2,0xfe,0x1a,0x7f,0x9b,0x8e,0xe7,0xeb,0x4a,0x7c,0x0f,0x9e,0x16,0x2b,0xce,0x33,0x57,0x6b,0x31,0x5e,0xce,0xcb,0xb6,0x40,0x68,0x37,0xbf,0x51,0xf5,
+		/* z will be set to 1, infinity flag to "false" */
+	};
+	sp_point p256_base;
+
+	sp_256_point_from_bin2x32(&p256_base, p256_base_bin);
+
+	sp_256_ecc_mulmod_10(r, &p256_base, k /*, map*/);
+}
+
+/* Multiply the point by the scalar and serialize the X ordinate.
+ * The number is 0 padded to maximum size on output.
+ *
+ * priv    Scalar to multiply the point by.
+ * pub2x32 Point to multiply.
+ * out32   Buffer to hold X ordinate.
+ */
+static void sp_ecc_secret_gen_256(const sp_digit priv[10], const uint8_t *pub2x32, uint8_t* out32)
+{
+	sp_point point[1];
+
+#if FIXED_PEER_PUBKEY
+	memset((void*)pub2x32, 0x55, 64);
+#endif
+	dump_hex("peerkey %s\n", pub2x32, 32); /* in TLS, this is peer's public key */
+	dump_hex("        %s\n", pub2x32 + 32, 32);
+
+	sp_256_point_from_bin2x32(point, pub2x32);
+	dump_hex("point->x %s\n", point->x, sizeof(point->x));
+	dump_hex("point->y %s\n", point->y, sizeof(point->y));
+
+	sp_256_ecc_mulmod_10(point, point, priv);
+
+	sp_256_to_bin(point->x, out32);
+	dump_hex("out32: %s\n", out32, 32);
+}
+
+/* Generates a scalar that is in the range 1..order-1. */
+#define SIMPLIFY 1
+/* Add 1 to a. (a = a + 1) */
+static void sp_256_add_one_10(sp_digit* a)
+{
+	a[0]++;
+	sp_256_norm_10(a);
+}
+static void sp_256_ecc_gen_k_10(sp_digit k[10])
+{
+#if !SIMPLIFY
+	/* The order of the curve P256 minus 2. */
+	static const sp_digit p256_order2[10] = {
+		0x063254f,0x272b0bf,0x1e84f3b,0x2b69c5e,0x3bce6fa,
+		0x3ffffff,0x3ffffff,0x00003ff,0x3ff0000,0x03fffff,
+	};
+#endif
+	uint8_t buf[32];
+
+	for (;;) {
+		tls_get_random(buf, sizeof(buf));
+#if FIXED_SECRET
+		memset(buf, 0x77, sizeof(buf));
+#endif
+		sp_256_from_bin(k, 10, buf, sizeof(buf));
+#if !SIMPLIFY
+		if (sp_256_cmp_10(k, p256_order2) < 0)
+			break;
+#else
+		/* non-loopy version (and not needing p256_order2[]):
+		 * if most-significant word seems that k can be larger
+		 * than p256_order2, fix it up:
+		 */
+		if (k[9] >= 0x03fffff)
+			k[9] = 0x03ffffe;
+		break;
+#endif
+	}
+	sp_256_add_one_10(k);
+#undef SIMPLIFY
+}
+
+/* Makes a random EC key pair. */
+static void sp_ecc_make_key_256(sp_digit privkey[10], uint8_t *pubkey)
+{
+	sp_point point[1];
+
+	sp_256_ecc_gen_k_10(privkey);
+	sp_256_ecc_mulmod_base_10(point, privkey);
+	sp_256_to_bin(point->x, pubkey);
+	sp_256_to_bin(point->y, pubkey + 32);
+
+	memset(point, 0, sizeof(point)); //paranoia
+}
+
+void FAST_FUNC curve_P256_compute_pubkey_and_premaster(
+		uint8_t *pubkey2x32, uint8_t *premaster32,
+		const uint8_t *peerkey2x32)
+{
+	sp_digit privkey[10];
+
+	sp_ecc_make_key_256(privkey, pubkey2x32);
+	dump_hex("pubkey: %s\n", pubkey2x32, 32);
+	dump_hex("        %s\n", pubkey2x32 + 32, 32);
+
+	/* Combine our privkey and peer's public key to generate premaster */
+	sp_ecc_secret_gen_256(privkey, /*x,y:*/peerkey2x32, premaster32);
+	dump_hex("premaster: %s\n", premaster32, 32);
+}
diff -urpN busybox-1.33.1/networking/traceroute.c busybox-1.34.0/networking/traceroute.c
--- busybox-1.33.1/networking/traceroute.c	2021-03-09 06:28:26.000000000 +0700
+++ busybox-1.34.0/networking/traceroute.c	2021-08-16 01:44:35.000000000 +0700
@@ -505,7 +505,7 @@ send_probe(int seq, int ttl)
 		struct outdata6_t *pkt = (void *) outdata;
 		pkt->ident6 = ident;
 		pkt->seq6   = htonl(seq);
-		/*gettimeofday(&pkt->tv, &tz);*/
+		/*xgettimeofday(&pkt->tv);*/
 		icp = outicmp6;
 	} else
 #endif
@@ -713,11 +713,16 @@ packet4_ok(int read_len, int seq)
 			up = (struct udphdr *)((char *)hip + hlen);
 			if (hlen + 12 <= read_len
 			 && hip->ip_p == IPPROTO_UDP
-// Off: since we do not form the entire IP packet,
+#if !defined(__FreeBSD__)
+// Disabled source check: since we do not form the entire IP packet,
 // but defer it to kernel, we can't set source port,
 // and thus can't check it here in the reply
 			/* && up->source == ident */
 			 && up->dest == htons(port + seq)
+#else
+			/* && up->uh_sport == ident */
+			 && up->uh_dport == htons(port + seq)
+#endif
 			) {
 				return (type == ICMP_TIMXCEED ? -1 : code + 1);
 			}
@@ -985,8 +990,13 @@ traceroute_init(int op, char **argv)
 				snd = xsocket(AF_INET, SOCK_DGRAM, 0);
 		}
 #if ENABLE_TRACEROUTE6
+# if defined(__FreeBSD__)
+#  define SOL_V6_OPTION SOL_IPV6
+# else
+#  define SOL_V6_OPTION SOL_RAW
+# endif
 		else {
-			if (setsockopt_int(rcvsock, SOL_RAW, IPV6_CHECKSUM, 2) != 0)
+			if (setsockopt_int(rcvsock, SOL_V6_OPTION, IPV6_CHECKSUM, 2) != 0)
 				bb_perror_msg_and_die("setsockopt(%s)", "IPV6_CHECKSUM");
 			if (op & OPT_USE_ICMP)
 				snd = xsocket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
diff -urpN busybox-1.33.1/networking/udhcp/Config.src busybox-1.34.0/networking/udhcp/Config.src
--- busybox-1.33.1/networking/udhcp/Config.src	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/Config.src	2021-01-08 15:30:27.000000000 +0700
@@ -104,6 +104,14 @@ INSERT
 comment "Common options for DHCP applets"
         depends on UDHCPD || UDHCPC || UDHCPC6 || DHCPRELAY
 
+config UDHCPC_DEFAULT_INTERFACE
+	string "Default interface name"
+	default "eth0"
+	depends on UDHCPC || UDHCPC6
+	help
+	The interface that will be used if no other interface is
+	specified on the commandline.
+
 config FEATURE_UDHCP_PORT
 	bool "Enable '-P port' option for udhcpd and udhcpc"
 	default n
diff -urpN busybox-1.33.1/networking/udhcp/arpping.c busybox-1.34.0/networking/udhcp/arpping.c
--- busybox-1.33.1/networking/udhcp/arpping.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/arpping.c	2021-06-16 17:02:16.000000000 +0700
@@ -47,6 +47,7 @@ int FAST_FUNC arpping(uint32_t test_nip,
 	int rv = 1;             /* "no reply received" yet */
 	struct sockaddr addr;   /* for interface name */
 	struct arpMsg arp;
+	const char *msg;
 
 	if (!timeo)
 		return 1;
@@ -58,7 +59,7 @@ int FAST_FUNC arpping(uint32_t test_nip,
 	}
 
 	if (setsockopt_broadcast(s) == -1) {
-		bb_simple_perror_msg("can't enable bcast on raw socket");
+		bb_simple_perror_msg("can't enable bcast on ARP socket");
 		goto ret;
 	}
 
@@ -131,6 +132,9 @@ int FAST_FUNC arpping(uint32_t test_nip,
 
  ret:
 	close(s);
-	log1("%srp reply received for this address", rv ? "no a" : "A");
+	msg = "no ARP reply received for this address";
+	if (rv == 0)
+		msg += 3;
+	log1s(msg);
 	return rv;
 }
diff -urpN busybox-1.33.1/networking/udhcp/common.c busybox-1.34.0/networking/udhcp/common.c
--- busybox-1.33.1/networking/udhcp/common.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/common.c	2021-06-16 17:02:16.000000000 +0700
@@ -49,6 +49,7 @@ const struct dhcp_optflag dhcp_optflags[
 	{ OPTION_U32                              , 0x33 }, /* DHCP_LEASE_TIME    */
 	{ OPTION_IP                               , 0x36 }, /* DHCP_SERVER_ID     */
 	{ OPTION_STRING                           , 0x38 }, /* DHCP_ERR_MESSAGE   */
+	{ OPTION_STRING                           , 0x3c }, /* DHCP_VENDOR        */
 //TODO: must be combined with 'sname' and 'file' handling:
 	{ OPTION_STRING_HOST                      , 0x42 }, /* DHCP_TFTP_SERVER_NAME */
 	{ OPTION_STRING                           , 0x43 }, /* DHCP_BOOT_FILE     */
@@ -83,7 +84,6 @@ const struct dhcp_optflag dhcp_optflags[
 	{ OPTION_U8                               , 0x35 }, /* DHCP_MESSAGE_TYPE  */
 	{ OPTION_U16                              , 0x39 }, /* DHCP_MAX_SIZE      */
 //looks like these opts will work just fine even without these defs:
-//	{ OPTION_STRING                           , 0x3c }, /* DHCP_VENDOR        */
 //	/* not really a string: */
 //	{ OPTION_STRING                           , 0x3d }, /* DHCP_CLIENT_ID     */
 	{ 0, 0 } /* zeroed terminating entry */
@@ -120,6 +120,7 @@ const char dhcp_option_strings[] ALIGN1
 	"lease" "\0"            /* DHCP_LEASE_TIME      */
 	"serverid" "\0"         /* DHCP_SERVER_ID       */
 	"message" "\0"          /* DHCP_ERR_MESSAGE     */
+	"vendor" "\0"           /* DHCP_VENDOR          */
 	"tftp" "\0"             /* DHCP_TFTP_SERVER_NAME*/
 	"bootfile" "\0"         /* DHCP_BOOT_FILE       */
 //	"userclass" "\0"        /* DHCP_USER_CLASS      */
@@ -184,6 +185,13 @@ const uint8_t dhcp_option_lengths[] ALIG
 	 */
 };
 
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+void FAST_FUNC log1s(const char *msg)
+{
+	if (dhcp_verbose >= 1)
+		bb_simple_info_msg(msg);
+}
+#endif
 
 #if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
 static void log_option(const char *pfx, const uint8_t *opt)
@@ -273,17 +281,27 @@ uint8_t* FAST_FUNC udhcp_scan_options(st
 			break;
 		}
 
-		if (scan_state->rem <= OPT_LEN)
-			goto complain; /* complain and return NULL */
-		len = 2 + scan_state->optionptr[OPT_LEN];
+		if (scan_state->rem <= OPT_LEN) /* [len] byte exists? */
+			goto complain; /* no, complain and return NULL */
+		len = scan_state->optionptr[OPT_LEN];
+		/* Skip options with zero length.
+		 * Users report that DHCP server on a TrendNet router (unknown model)
+		 * provides a zero-length option 12 (Host Name)
+		 * (this violates RFC 2132 section 3.14).
+		 */
+		if (len == 0) {
+			scan_state->rem -= 2;
+			scan_state->optionptr += 2;
+			continue;
+		}
+		len += 2;
 		scan_state->rem -= len;
-		/* So far no valid option with length 0 known. */
-		if (scan_state->rem < 0 || scan_state->optionptr[OPT_LEN] == 0)
-			goto complain; /* complain and return NULL */
+		if (scan_state->rem < 0) /* option is longer than options field? */
+			goto complain; /* yes, complain and return NULL */
 
 		if (scan_state->optionptr[OPT_CODE] == DHCP_OPTION_OVERLOAD) {
-			if (len >= 3)
-				scan_state->overload |= scan_state->optionptr[OPT_DATA];
+			/* len is known to be >= 3 now, [data] byte exists */
+			scan_state->overload |= scan_state->optionptr[OPT_DATA];
 		} else {
 			uint8_t *return_ptr = scan_state->optionptr;
 			scan_state->optionptr += len;
@@ -410,6 +428,40 @@ int FAST_FUNC udhcp_str2nip(const char *
 	return 1;
 }
 
+void* FAST_FUNC udhcp_insert_new_option(
+		struct option_set **opt_list,
+		unsigned code,
+		unsigned length,
+		bool dhcpv6)
+{
+	IF_NOT_UDHCPC6(bool dhcpv6 = 0;)
+	struct option_set *new, **curr;
+
+	log2("attaching option %02x to list", code);
+	new = xmalloc(sizeof(*new));
+	if (!dhcpv6) {
+		new->data = xzalloc(length + OPT_DATA);
+		new->data[OPT_CODE] = code;
+		new->data[OPT_LEN] = length;
+	} else {
+		new->data = xzalloc(length + D6_OPT_DATA);
+		new->data[D6_OPT_CODE] = code >> 8;
+		new->data[D6_OPT_CODE + 1] = code & 0xff;
+		new->data[D6_OPT_LEN] = length >> 8;
+		new->data[D6_OPT_LEN + 1] = length & 0xff;
+	}
+
+	curr = opt_list;
+//FIXME: DHCP6 codes > 255!!
+	while (*curr && (*curr)->data[OPT_CODE] < code)
+		curr = &(*curr)->next;
+
+	new->next = *curr;
+	*curr = new;
+
+	return new->data;
+}
+
 /* udhcp_str2optset:
  * Parse string option representation to binary form and add it to opt_list.
  * Called to parse "udhcpc -x OPTNAME:OPTVAL"
@@ -449,32 +501,12 @@ static NOINLINE void attach_option(
 
 	existing = udhcp_find_option(*opt_list, optflag->code);
 	if (!existing) {
-		struct option_set *new, **curr;
-
 		/* make a new option */
-		log2("attaching option %02x to list", optflag->code);
-		new = xmalloc(sizeof(*new));
-		if (!dhcpv6) {
-			new->data = xmalloc(length + OPT_DATA);
-			new->data[OPT_CODE] = optflag->code;
-			new->data[OPT_LEN] = length;
-			memcpy(new->data + OPT_DATA, buffer, length);
-		} else {
-			new->data = xmalloc(length + D6_OPT_DATA);
-			new->data[D6_OPT_CODE] = optflag->code >> 8;
-			new->data[D6_OPT_CODE + 1] = optflag->code & 0xff;
-			new->data[D6_OPT_LEN] = length >> 8;
-			new->data[D6_OPT_LEN + 1] = length & 0xff;
-			memcpy(new->data + D6_OPT_DATA, buffer,
-					length);
-		}
-
-		curr = opt_list;
-		while (*curr && (*curr)->data[OPT_CODE] < optflag->code)
-			curr = &(*curr)->next;
-
-		new->next = *curr;
-		*curr = new;
+		uint8_t *p = udhcp_insert_new_option(opt_list, optflag->code, length, dhcpv6);
+		if (!dhcpv6)
+			memcpy(p + OPT_DATA, buffer, length);
+		else
+			memcpy(p + D6_OPT_DATA, buffer, length);
 		goto ret;
 	}
 
diff -urpN busybox-1.33.1/networking/udhcp/common.h busybox-1.34.0/networking/udhcp/common.h
--- busybox-1.33.1/networking/udhcp/common.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/common.h	2021-06-16 17:02:16.000000000 +0700
@@ -275,7 +275,8 @@ struct option_set *udhcp_find_option(str
 # define IF_UDHCP_VERBOSE(...) __VA_ARGS__
 extern unsigned dhcp_verbose;
 # define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
-# define log1s(msg) do { if (dhcp_verbose >= 1) bb_simple_info_msg(msg); } while (0)
+//# define log1s(msg) do { if (dhcp_verbose >= 1) bb_simple_info_msg(msg); } while (0)
+void log1s(const char *msg) FAST_FUNC;
 # if CONFIG_UDHCP_DEBUG >= 2
 void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
 #  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
@@ -319,6 +320,16 @@ void udhcp_dump_packet(struct dhcp_packe
 
 /* 2nd param is "uint32_t*" */
 int FAST_FUNC udhcp_str2nip(const char *str, void *arg);
+
+#if !ENABLE_UDHCPC6
+#define udhcp_insert_new_option(opt_list, code, length, dhcpv6) \
+	udhcp_insert_new_option(opt_list, code, length)
+#endif
+void* FAST_FUNC udhcp_insert_new_option(struct option_set **opt_list,
+		unsigned code,
+		unsigned length,
+		bool dhcpv6);
+
 /* 2nd param is "struct option_set**" */
 #if !ENABLE_UDHCPC6
 #define udhcp_str2optset(str, arg, optflags, option_strings, dhcpv6) \
diff -urpN busybox-1.33.1/networking/udhcp/d6_dhcpc.c busybox-1.34.0/networking/udhcp/d6_dhcpc.c
--- busybox-1.33.1/networking/udhcp/d6_dhcpc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/d6_dhcpc.c	2021-07-20 21:57:20.000000000 +0700
@@ -441,7 +441,7 @@ static char **fill_envp(const uint8_t *o
 	return envp;
 }
 
-/* Call a script with a par file and env vars */
+/* Call a script with env vars */
 static void d6_run_script(const uint8_t *option, const uint8_t *option_end,
 		const char *name)
 {
@@ -464,7 +464,7 @@ static void d6_run_script(const uint8_t
 	free(envp);
 }
 
-/* Call a script with a par file and no env var */
+/* Call a script with no env var */
 static void d6_run_script_no_option(const char *name)
 {
 	d6_run_script(NULL, NULL, name);
@@ -479,16 +479,15 @@ static ALWAYS_INLINE uint32_t random_xid
 }
 
 /* Initialize the packet with the proper defaults */
-static uint8_t *init_d6_packet(struct d6_packet *packet, char type, uint32_t xid)
+static uint8_t *init_d6_packet(struct d6_packet *packet, char type)
 {
 	uint8_t *ptr;
-	struct d6_option *clientid;
 	unsigned secs;
 
 	memset(packet, 0, sizeof(*packet));
 
-	packet->d6_xid32 = xid;
-	packet->d6_msg_type = type;
+	packet->d6_xid32 = client_data.xid;
+	packet->d6_msg_type = type; /* union, overwrites lowest byte of d6_xid32 */
 
 	/* ELAPSED_TIME option is required to be present by the RFC,
 	 * and some servers do check for its presense. [which?]
@@ -503,9 +502,7 @@ static uint8_t *init_d6_packet(struct d6
 	*((uint16_t*)ptr) = (secs < 0xffff) ? htons(secs) : 0xffff;
 	ptr += 2;
 
-	/* add CLIENTID option */
-	clientid = (void*)client_data.clientid;
-	return mempcpy(ptr, clientid, clientid->len + 2+2);
+	return ptr;
 }
 
 static uint8_t *add_d6_client_options(uint8_t *ptr)
@@ -588,15 +585,15 @@ static int d6_mcast_from_client_data_ifi
  * about parameter values the client would like to have returned.
  */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_d6_info_request(uint32_t xid)
+static NOINLINE int send_d6_info_request(void)
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
 
-	/* Fill in: msg type, client id */
-	opt_ptr = init_d6_packet(&packet, D6_MSG_INFORMATION_REQUEST, xid);
+	/* Fill in: msg type, xid, ELAPSED_TIME */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_INFORMATION_REQUEST);
 
-	/* Add options:
+	/* Add options: client-id,
 	 * "param req" option according to -O, options specified with -x
 	 */
 	opt_ptr = add_d6_client_options(opt_ptr);
@@ -687,14 +684,14 @@ static NOINLINE int send_d6_info_request
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_d6_discover(uint32_t xid, struct in6_addr *requested_ipv6)
+static NOINLINE int send_d6_discover(struct in6_addr *requested_ipv6)
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
 	unsigned len;
 
-	/* Fill in: msg type, client id */
-	opt_ptr = init_d6_packet(&packet, D6_MSG_SOLICIT, xid);
+	/* Fill in: msg type, xid, ELAPSED_TIME */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_SOLICIT);
 
 	/* Create new IA_NA, optionally with included IAADDR with requested IP */
 	free(client6_data.ia_na);
@@ -726,7 +723,7 @@ static NOINLINE int send_d6_discover(uin
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, len);
 	}
 
-	/* Add options:
+	/* Add options: client-id,
 	 * "param req" option according to -O, options specified with -x
 	 */
 	opt_ptr = add_d6_client_options(opt_ptr);
@@ -766,13 +763,13 @@ static NOINLINE int send_d6_discover(uin
  * messages from the server.
  */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_d6_select(uint32_t xid)
+static NOINLINE int send_d6_select(void)
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
 
-	/* Fill in: msg type, client id */
-	opt_ptr = init_d6_packet(&packet, D6_MSG_REQUEST, xid);
+	/* Fill in: msg type, xid, ELAPSED_TIME */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_REQUEST);
 
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
@@ -783,7 +780,7 @@ static NOINLINE int send_d6_select(uint3
 	if (client6_data.ia_pd)
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
 
-	/* Add options:
+	/* Add options: client-id,
 	 * "param req" option according to -O, options specified with -x
 	 */
 	opt_ptr = add_d6_client_options(opt_ptr);
@@ -839,13 +836,13 @@ static NOINLINE int send_d6_select(uint3
  * about parameter values the client would like to have returned.
  */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_d6_renew(uint32_t xid, struct in6_addr *server_ipv6, struct in6_addr *our_cur_ipv6)
+static NOINLINE int send_d6_renew(struct in6_addr *server_ipv6, struct in6_addr *our_cur_ipv6)
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
 
-	/* Fill in: msg type, client id */
-	opt_ptr = init_d6_packet(&packet, DHCPREQUEST, xid);
+	/* Fill in: msg type, xid, ELAPSED_TIME */
+	opt_ptr = init_d6_packet(&packet, DHCPREQUEST);
 
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
@@ -856,7 +853,7 @@ static NOINLINE int send_d6_renew(uint32
 	if (client6_data.ia_pd)
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
 
-	/* Add options:
+	/* Add options: client-id,
 	 * "param req" option according to -O, options specified with -x
 	 */
 	opt_ptr = add_d6_client_options(opt_ptr);
@@ -878,9 +875,10 @@ int send_d6_release(struct in6_addr *ser
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
+	struct option_set *ci;
 
-	/* Fill in: msg type, client id */
-	opt_ptr = init_d6_packet(&packet, D6_MSG_RELEASE, random_xid());
+	/* Fill in: msg type, xid, ELAPSED_TIME */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_RELEASE);
 	/* server id */
 	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains our current IP) */
@@ -889,6 +887,10 @@ int send_d6_release(struct in6_addr *ser
 	/* IA PD */
 	if (client6_data.ia_pd)
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, client6_data.ia_pd->len + 2+2);
+	/* Client-id */
+	ci = udhcp_find_option(client_data.options, D6_OPT_CLIENTID);
+	if (ci)
+		opt_ptr = mempcpy(opt_ptr, ci->data, D6_OPT_DATA + 2+2 + 6);
 
 	bb_info_msg("sending %s", "release");
 	return d6_send_kernel_packet_from_client_data_ifindex(
@@ -952,7 +954,8 @@ static NOINLINE int d6_recv_raw_packet(s
 	if (peer_ipv6)
 		*peer_ipv6 = packet.ip6.ip6_src; /* struct copy */
 
-	log1("received %s", "a packet");
+	log2("received %s", "a packet");
+	/* log2 because more informative msg for valid packets is printed later at log1 level */
 	d6_dump_packet(&packet.data);
 
 	bytes -= sizeof(packet.ip6) + sizeof(packet.udp);
@@ -1040,7 +1043,6 @@ static int d6_raw_socket(int ifindex)
 	log2("opening raw socket on ifindex %d", ifindex);
 
 	fd = xsocket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IPV6));
-	log3("got raw socket fd %d", fd);
 
 	memset(&sock, 0, sizeof(sock)); /* let's be deterministic */
 	sock.sll_family = AF_PACKET;
@@ -1061,9 +1063,6 @@ static int d6_raw_socket(int ifindex)
 			log1("attached filter to raw socket fd %d", fd); // log?
 	}
 #endif
-
-	log1s("created raw socket");
-
 	return fd;
 }
 
@@ -1087,31 +1086,10 @@ static void change_listen_mode(int new_m
 	/* else LISTEN_NONE: client_data.sockfd stays closed */
 }
 
-/* Called only on SIGUSR1 */
-static void perform_renew(void)
-{
-	bb_simple_info_msg("performing DHCP renew");
-	switch (client_data.state) {
-	case BOUND:
-		change_listen_mode(LISTEN_KERNEL);
-	case RENEWING:
-	case REBINDING:
-		client_data.state = RENEW_REQUESTED;
-		break;
-	case RENEW_REQUESTED: /* impatient are we? fine, square 1 */
-		d6_run_script_no_option("deconfig");
-	case REQUESTING:
-	case RELEASED:
-		change_listen_mode(LISTEN_RAW);
-		client_data.state = INIT_SELECTING;
-		break;
-	case INIT_SELECTING:
-		break;
-	}
-}
-
 static void perform_d6_release(struct in6_addr *server_ipv6, struct in6_addr *our_cur_ipv6)
 {
+	change_listen_mode(LISTEN_NONE);
+
 	/* send release packet */
 	if (client_data.state == BOUND
 	 || client_data.state == RENEWING
@@ -1119,6 +1097,7 @@ static void perform_d6_release(struct in
 	 || client_data.state == RENEW_REQUESTED
 	) {
 		bb_simple_info_msg("unicasting a release");
+		client_data.xid = random_xid(); //TODO: can omit?
 		send_d6_release(server_ipv6, our_cur_ipv6); /* unicast */
 	}
 	bb_simple_info_msg("entering released state");
@@ -1129,21 +1108,9 @@ static void perform_d6_release(struct in
  * of the states above.
  */
 	d6_run_script_no_option("deconfig");
-	change_listen_mode(LISTEN_NONE);
 	client_data.state = RELEASED;
 }
 
-///static uint8_t* alloc_dhcp_option(int code, const char *str, int extra)
-///{
-///	uint8_t *storage;
-///	int len = strnlen(str, 255);
-///	storage = xzalloc(len + extra + OPT_DATA);
-///	storage[OPT_CODE] = code;
-///	storage[OPT_LEN] = len + extra;
-///	memcpy(storage + extra + OPT_DATA, str, len);
-///	return storage;
-///}
-
 #if BB_MMU
 static void client_background(void)
 {
@@ -1160,23 +1127,23 @@ static void client_background(void)
 //usage:# define IF_UDHCP_VERBOSE(...)
 //usage:#endif
 //usage:#define udhcpc6_trivial_usage
-//usage:       "[-fbnq"IF_UDHCP_VERBOSE("v")"odR] [-i IFACE] [-r IPv6] [-s PROG] [-p PIDFILE]\n"
-//usage:       "	[-x OPT:VAL]... [-O OPT]..." IF_FEATURE_UDHCP_PORT(" [-P PORT]")
+//usage:       "[-fbq"IF_UDHCP_VERBOSE("v")"R] [-t N] [-T SEC] [-A SEC|-n] [-i IFACE] [-s PROG]\n"
+//usage:       "	[-p PIDFILE]"IF_FEATURE_UDHCP_PORT(" [-P PORT]")" [-ldo] [-r IPv6] [-x OPT:VAL]... [-O OPT]..."
 //usage:#define udhcpc6_full_usage "\n"
-//usage:     "\n	-i IFACE	Interface to use (default eth0)"
+//usage:     "\n	-i IFACE	Interface to use (default "CONFIG_UDHCPC_DEFAULT_INTERFACE")"
 //usage:     "\n	-p FILE		Create pidfile"
 //usage:     "\n	-s PROG		Run PROG at DHCP events (default "CONFIG_UDHCPC_DEFAULT_SCRIPT")"
 //usage:     "\n	-B		Request broadcast replies"
 //usage:     "\n	-t N		Send up to N discover packets"
-//usage:     "\n	-T N		Pause between packets (default 3 seconds)"
-//usage:     "\n	-A N		Wait N seconds (default 20) after failure"
-//usage:     "\n	-f		Run in foreground"
+//usage:     "\n	-T SEC		Pause between packets (default 3)"
+//usage:     "\n	-A SEC		Wait if lease is not obtained (default 20)"
 //usage:	USE_FOR_MMU(
 //usage:     "\n	-b		Background if lease is not obtained"
 //usage:	)
 //usage:     "\n	-n		Exit if lease is not obtained"
 //usage:     "\n	-q		Exit after obtaining lease"
 //usage:     "\n	-R		Release IP on exit"
+//usage:     "\n	-f		Run in foreground"
 //usage:     "\n	-S		Log to syslog too"
 //usage:	IF_FEATURE_UDHCP_PORT(
 //usage:     "\n	-P PORT		Use PORT (default 546)"
@@ -1184,12 +1151,12 @@ static void client_background(void)
 ////usage:	IF_FEATURE_UDHCPC_ARPING(
 ////usage:     "\n	-a		Use arping to validate offered address"
 ////usage:	)
-//usage:     "\n	-O OPT		Request option OPT from server (cumulative)"
-//usage:     "\n	-o		Don't request any options (unless -O is given)"
-//usage:     "\n	-r IPv6		Request this address ('no' to not request any IP)"
-//usage:     "\n	-d		Request prefix"
 //usage:     "\n	-l		Send 'information request' instead of 'solicit'"
 //usage:     "\n			(used for servers which do not assign IPv6 addresses)"
+//usage:     "\n	-r IPv6		Request this address ('no' to not request any IP)"
+//usage:     "\n	-d		Request prefix"
+//usage:     "\n	-o		Don't request any options (unless -O is given)"
+//usage:     "\n	-O OPT		Request option OPT from server (cumulative)"
 //usage:     "\n	-x OPT:VAL	Include option OPT in sent packets (cumulative)"
 //usage:     "\n			Examples of string, numeric, and hex byte opts:"
 //usage:     "\n			-x hostname:bbox - option 12"
@@ -1208,7 +1175,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 {
 	const char *str_r;
 	IF_FEATURE_UDHCP_PORT(char *str_P;)
-	void *clientid_mac_ptr;
+	uint8_t *clientid_mac_ptr;
 	llist_t *list_O = NULL;
 	llist_t *list_x = NULL;
 	int tryagain_timeout = 20;
@@ -1217,10 +1184,9 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	struct in6_addr srv6_buf;
 	struct in6_addr ipv6_buf;
 	struct in6_addr *requested_ipv6;
-	uint32_t xid = 0;
 	int packet_num;
 	int timeout; /* must be signed */
-	unsigned already_waited_sec;
+	int lease_remaining; /* must be signed */
 	unsigned opt;
 	int retval;
 
@@ -1231,7 +1197,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	/* Default options */
 	IF_FEATURE_UDHCP_PORT(SERVER_PORT6 = 547;)
 	IF_FEATURE_UDHCP_PORT(CLIENT_PORT6 = 546;)
-	client_data.interface = "eth0";
+	client_data.interface = CONFIG_UDHCPC_DEFAULT_INTERFACE;
 	client_data.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;
 	client_data.sockfd = -1;
 
@@ -1305,6 +1271,18 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		free(optstr);
 	}
 
+	clientid_mac_ptr = NULL;
+	if (!udhcp_find_option(client_data.options, D6_OPT_CLIENTID)) {
+		/* not set, set the default client ID */
+		clientid_mac_ptr = udhcp_insert_new_option(
+				&client_data.options, D6_OPT_CLIENTID,
+				2+2 + 6, /*dhcp6:*/ 1);
+		clientid_mac_ptr += 2+2; /* skip option code, len */
+		clientid_mac_ptr[1] = 3; /* DUID-LL */
+		clientid_mac_ptr[3] = 1; /* type: ethernet */
+		clientid_mac_ptr += 2+2; /* skip DUID-LL, ethernet */
+	}
+
 	if (d6_read_interface(client_data.interface,
 			&client_data.ifindex,
 			&client6_data.ll_ip6,
@@ -1313,19 +1291,6 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		return 1;
 	}
 
-	/* Create client ID based on mac, set clientid_mac_ptr */
-	{
-		struct d6_option *clientid;
-		clientid = xzalloc(2+2+2+2+6);
-		clientid->code = D6_OPT_CLIENTID;
-		clientid->len = 2+2+6;
-		clientid->data[1] = 3; /* DUID-LL */
-		clientid->data[3] = 1; /* ethernet */
-		clientid_mac_ptr = clientid->data + 2+2;
-		memcpy(clientid_mac_ptr, client_data.client_mac, 6);
-		client_data.clientid = (void*)clientid;
-	}
-
 #if !BB_MMU
 	/* on NOMMU reexec (i.e., background) early */
 	if (!(opt & OPT_f)) {
@@ -1345,22 +1310,18 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 
 	client_data.state = INIT_SELECTING;
 	d6_run_script_no_option("deconfig");
-	change_listen_mode(LISTEN_RAW);
 	packet_num = 0;
 	timeout = 0;
-	already_waited_sec = 0;
+	lease_remaining = 0;
 
 	/* Main event loop. select() waits on signal pipe and possibly
 	 * on sockfd.
 	 * "continue" statements in code below jump to the top of the loop.
 	 */
 	for (;;) {
-		int tv;
 		struct pollfd pfds[2];
 		struct d6_packet packet;
 		uint8_t *packet_end;
-		/* silence "uninitialized!" warning */
-		unsigned timestamp_before_wait = timestamp_before_wait;
 
 		//bb_error_msg("sockfd:%d, listen_mode:%d", client_data.sockfd, client_data.listen_mode);
 
@@ -1373,17 +1334,27 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 
 		udhcp_sp_fd_set(pfds, client_data.sockfd);
 
-		tv = timeout - already_waited_sec;
 		retval = 0;
 		/* If we already timed out, fall through with retval = 0, else... */
-		if (tv > 0) {
-			log1("waiting %u seconds", tv);
-			timestamp_before_wait = (unsigned)monotonic_sec();
-			retval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);
+		if (timeout > 0) {
+			unsigned diff;
+
+			if (timeout > INT_MAX/1000)
+				timeout = INT_MAX/1000;
+			log1("waiting %u seconds", timeout);
+			diff = (unsigned)monotonic_sec();
+			retval = poll(pfds, 2, timeout * 1000);
+			diff = (unsigned)monotonic_sec() - diff;
+			lease_remaining -= diff;
+			if (lease_remaining < 0)
+				lease_remaining = 0;
+			timeout -= diff;
+			if (timeout < 0)
+				timeout = 0;
+
 			if (retval < 0) {
 				/* EINTR? A signal was caught, don't panic */
 				if (errno == EINTR) {
-					already_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;
 					continue;
 				}
 				/* Else: an error occured, panic! */
@@ -1408,26 +1379,27 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				goto ret0; /* iface is gone? */
 			}
 
-			memcpy(clientid_mac_ptr, client_data.client_mac, 6);
-
-			/* We will restart the wait in any case */
-			already_waited_sec = 0;
+			if (clientid_mac_ptr)
+				memcpy(clientid_mac_ptr, client_data.client_mac, 6);
 
 			switch (client_data.state) {
 			case INIT_SELECTING:
 				if (!discover_retries || packet_num < discover_retries) {
-					if (packet_num == 0)
-						xid = random_xid();
+					if (packet_num == 0) {
+						change_listen_mode(LISTEN_RAW);
+						client_data.xid = random_xid();
+					}
 					/* multicast */
 					if (opt & OPT_l)
-						send_d6_info_request(xid);
+						send_d6_info_request();
 					else
-						send_d6_discover(xid, requested_ipv6);
+						send_d6_discover(requested_ipv6);
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
 				}
  leasefail:
+				change_listen_mode(LISTEN_NONE);
 				d6_run_script_no_option("leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
@@ -1448,14 +1420,14 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					retval = 1;
 					goto ret;
 				}
-				/* wait before trying again */
+				/* Wait before trying again */
 				timeout = tryagain_timeout;
 				packet_num = 0;
 				continue;
 			case REQUESTING:
 				if (!discover_retries || packet_num < discover_retries) {
 					/* send multicast select packet */
-					send_d6_select(xid);
+					send_d6_select();
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
@@ -1464,21 +1436,20 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				 * "discover...select...discover..." loops
 				 * were seen in the wild. Treat them similarly
 				 * to "no response to discover" case */
-				change_listen_mode(LISTEN_RAW);
 				client_data.state = INIT_SELECTING;
 				goto leasefail;
 			case BOUND:
 				/* 1/2 lease passed, enter renewing state */
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
-				change_listen_mode(LISTEN_KERNEL);
+			got_SIGUSR1:
 				log1s("entering renew state");
+				change_listen_mode(LISTEN_KERNEL);
 				/* fall right through */
-			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
-			case_RENEW_REQUESTED:
+			case RENEW_REQUESTED: /* in manual (SIGUSR1) renew */
 			case RENEWING:
-				if (timeout >= 60) {
-					/* send an unicast renew request */
+				if (packet_num == 0) {
+					/* Send an unicast renew request */
 			/* Sometimes observed to fail (EADDRNOTAVAIL) to bind
 			 * a new UDP socket for sending inside send_renew.
 			 * I hazard to guess existing listening socket
@@ -1488,40 +1459,52 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 			 * into INIT_SELECTING state.
 			 */
 					if (opt & OPT_l)
-						send_d6_info_request(xid);
+						send_d6_info_request();
 					else
-						send_d6_renew(xid, &srv6_buf, requested_ipv6);
-					timeout >>= 1;
+						send_d6_renew(&srv6_buf, requested_ipv6);
+					timeout = discover_timeout;
+					packet_num++;
 					continue;
+				} /* else: we had sent one packet, but got no reply */
+				log1s("no response to renew");
+				if (lease_remaining > 30) {
+					/* Some lease time remains, try to renew later */
+					change_listen_mode(LISTEN_NONE);
+					goto BOUND_for_half_lease;
 				}
-				/* Timed out, enter rebinding state */
-				log1s("entering rebinding state");
+				/* Enter rebinding state */
 				client_data.state = REBINDING;
-				/* fall right through */
-			case REBINDING:
+				log1s("entering rebinding state");
 				/* Switch to bcast receive */
 				change_listen_mode(LISTEN_RAW);
+				packet_num = 0;
+				/* fall right through */
+			case REBINDING:
 				/* Lease is *really* about to run out,
 				 * try to find DHCP server using broadcast */
-				if (timeout > 0) {
+				if (lease_remaining > 0 && packet_num < 3) {
 					if (opt & OPT_l)
-						send_d6_info_request(xid);
+						send_d6_info_request();
 					else /* send a broadcast renew request */
-						send_d6_renew(xid, /*server_ipv6:*/ NULL, requested_ipv6);
-					timeout >>= 1;
+						send_d6_renew(/*server_ipv6:*/ NULL, requested_ipv6);
+					timeout = discover_timeout;
+					packet_num++;
 					continue;
 				}
 				/* Timed out, enter init state */
+				change_listen_mode(LISTEN_NONE);
 				bb_simple_info_msg("lease lost, entering init state");
 				d6_run_script_no_option("deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
-				/*timeout = 0; - already is */
+				timeout = 0;
 				packet_num = 0;
 				continue;
 			/* case RELEASED: */
 			}
-			/* yah, I know, *you* say it would never happen */
+			/* RELEASED state (when we got SIGUSR2) ends up here.
+			 * (wait for SIGUSR1 to re-init, or for TERM, etc)
+			 */
 			timeout = INT_MAX;
 			continue; /* back to main loop */
 		} /* if poll timed out */
@@ -1531,29 +1514,43 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		/* Is it a signal? */
 		switch (udhcp_sp_read()) {
 		case SIGUSR1:
+			if (client_data.state <= REQUESTING)
+				/* Initial negotiations in progress, do not disturb */
+				break;
+			if (client_data.state == REBINDING)
+				/* Do not go back from rebind to renew state */
+				break;
+
+			if (lease_remaining > 30) /* if renew fails, do not go back to BOUND */
+				lease_remaining = 30;
 			client_data.first_secs = 0; /* make secs field count from 0 */
-			already_waited_sec = 0;
-			perform_renew();
-			if (client_data.state == RENEW_REQUESTED) {
-				/* We might be either on the same network
-				 * (in which case renew might work),
-				 * or we might be on a completely different one
-				 * (in which case renew won't ever succeed).
-				 * For the second case, must make sure timeout
-				 * is not too big, or else we can send
-				 * futile renew requests for hours.
-				 */
-				if (timeout > 60)
-					timeout = 60;
-				goto case_RENEW_REQUESTED;
-			}
-			/* Start things over */
 			packet_num = 0;
+
+			switch (client_data.state) {
+			case BOUND:
+			case RENEWING:
+				/* Try to renew/rebind */
+				change_listen_mode(LISTEN_KERNEL);
+				client_data.state = RENEW_REQUESTED;
+				goto got_SIGUSR1;
+
+			case RENEW_REQUESTED:
+				/* Two SIGUSR1 received, start things over */
+				change_listen_mode(LISTEN_NONE);
+				d6_run_script_no_option("deconfig");
+
+			default:
+			/* case RELEASED: */
+				/* Wake from SIGUSR2-induced deconfigured state */
+				change_listen_mode(LISTEN_NONE);
+			}
+			client_data.state = INIT_SELECTING;
 			/* Kill any timeouts, user wants this to hurry along */
 			timeout = 0;
 			continue;
 		case SIGUSR2:
 			perform_d6_release(&srv6_buf, requested_ipv6);
+			/* ^^^ switches to LISTEN_NONE */
 			timeout = INT_MAX;
 			continue;
 		case SIGTERM:
@@ -1579,18 +1576,16 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				sleep(discover_timeout); /* 3 seconds by default */
 				change_listen_mode(client_data.listen_mode); /* just close and reopen */
 			}
-			/* If this packet will turn out to be unrelated/bogus,
-			 * we will go back and wait for next one.
-			 * Be sure timeout is properly decreased. */
-			already_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;
 			if (len < 0)
 				continue;
 			packet_end = (uint8_t*)&packet + len;
 		}
 
-		if ((packet.d6_xid32 & htonl(0x00ffffff)) != xid) {
-			log1("xid %x (our is %x), ignoring packet",
-				(unsigned)(packet.d6_xid32 & htonl(0x00ffffff)), (unsigned)xid);
+		if ((packet.d6_xid32 & htonl(0x00ffffff)) != client_data.xid) {
+			log1("xid %x (our is %x)%s",
+				(unsigned)(packet.d6_xid32 & htonl(0x00ffffff)), (unsigned)client_data.xid,
+				", ignoring packet"
+			);
 			continue;
 		}
 
@@ -1607,11 +1602,14 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		case RENEW_REQUESTED:
 		case REBINDING:
 			if (packet.d6_msg_type == D6_MSG_REPLY) {
+				unsigned start;
 				uint32_t lease_seconds;
 				struct d6_option *option;
 				unsigned address_timeout;
 				unsigned prefix_timeout;
  type_is_ok:
+				change_listen_mode(LISTEN_NONE);
+
 				address_timeout = 0;
 				prefix_timeout = 0;
 				option = d6_find_option(packet.d6_options, packet_end, D6_OPT_STATUS_CODE);
@@ -1622,14 +1620,12 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 							packet_end, "nak");
 					if (client_data.state != REQUESTING)
 						d6_run_script_no_option("deconfig");
-					change_listen_mode(LISTEN_RAW);
 					sleep(3); /* avoid excessive network traffic */
 					client_data.state = INIT_SELECTING;
 					client_data.first_secs = 0; /* make secs field count from 0 */
 					requested_ipv6 = NULL;
 					timeout = 0;
 					packet_num = 0;
-					already_waited_sec = 0;
 					continue;
 				}
 				option = d6_copy_option(packet.d6_options, packet_end, D6_OPT_SERVERID);
@@ -1645,10 +1641,10 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				client6_data.server_id = option;
 				if (packet.d6_msg_type == D6_MSG_ADVERTISE) {
 					/* enter requesting state */
+					change_listen_mode(LISTEN_RAW);
 					client_data.state = REQUESTING;
 					timeout = 0;
 					packet_num = 0;
-					already_waited_sec = 0;
 					continue;
 				}
 				/* It's a D6_MSG_REPLY */
@@ -1743,7 +1739,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					free(client6_data.ia_na);
 					client6_data.ia_na = d6_copy_option(packet.d6_options, packet_end, D6_OPT_IA_NA);
 					if (!client6_data.ia_na) {
-						bb_info_msg("no %s option, ignoring packet", "IA_NA");
+						bb_info_msg("no %s option%s", "IA_NA", ", ignoring packet");
 						continue;
 					}
 					if (client6_data.ia_na->len < (4 + 4 + 4) + (2 + 2 + 16 + 4 + 4)) {
@@ -1756,7 +1752,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 							D6_OPT_IAADDR
 					);
 					if (!iaaddr) {
-						bb_info_msg("no %s option, ignoring packet", "IAADDR");
+						bb_info_msg("no %s option%s", "IAADDR", ", ignoring packet");
 						continue;
 					}
 					if (iaaddr->len < (16 + 4 + 4)) {
@@ -1781,7 +1777,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					free(client6_data.ia_pd);
 					client6_data.ia_pd = d6_copy_option(packet.d6_options, packet_end, D6_OPT_IA_PD);
 					if (!client6_data.ia_pd) {
-						bb_info_msg("no %s option, ignoring packet", "IA_PD");
+						bb_info_msg("no %s option%s", "IA_PD", ", ignoring packet");
 						continue;
 					}
 					if (client6_data.ia_pd->len < (4 + 4 + 4) + (2 + 2 + 4 + 4 + 1 + 16)) {
@@ -1794,7 +1790,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 							D6_OPT_IAPREFIX
 					);
 					if (!iaprefix) {
-						bb_info_msg("no %s option, ignoring packet", "IAPREFIX");
+						bb_info_msg("no %s option%s", "IAPREFIX", ", ignoring packet");
 						continue;
 					}
 					if (iaprefix->len < (4 + 4 + 1 + 16)) {
@@ -1812,24 +1808,26 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					address_timeout = prefix_timeout;
 				if (!prefix_timeout)
 					prefix_timeout = address_timeout;
-				/* note: "int timeout" will not overflow even with 0xffffffff inputs here: */
-				timeout = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout) / 2;
+				lease_remaining = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout);
+				if (lease_remaining < 0) /* signed overflow? */
+					lease_remaining = INT_MAX;
 				if (opt & OPT_l) {
 					/* TODO: request OPTION_INFORMATION_REFRESH_TIME (32)
 					 * and use its value instead of the default 1 day.
 					 */
-					timeout = 24 * 60 * 60;
+					lease_remaining = 24 * 60 * 60;
 				}
 				/* paranoia: must not be too small */
-				/* timeout > 60 - ensures at least one unicast renew attempt */
-				if (timeout < 61)
-					timeout = 61;
+				if (lease_remaining < 30)
+					lease_remaining = 30;
+
 				/* enter bound state */
+				start = monotonic_sec();
 				d6_run_script(packet.d6_options, packet_end,
 					(client_data.state == REQUESTING ? "bound" : "renew"));
-
-				client_data.state = BOUND;
-				change_listen_mode(LISTEN_NONE);
+				lease_remaining -= (unsigned)monotonic_sec() - start;
+				if (lease_remaining < 0)
+					lease_remaining = 0;
 				if (opt & OPT_q) { /* quit after lease */
 					goto ret0;
 				}
@@ -1842,7 +1840,11 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 					opt = ((opt & ~OPT_b) | OPT_f);
 				}
 #endif
-				already_waited_sec = 0;
+
+ BOUND_for_half_lease:
+				timeout = (unsigned)lease_remaining / 2;
+				client_data.state = BOUND;
+				packet_num = 0;
 				continue; /* back to main loop */
 			}
 			continue;
diff -urpN busybox-1.33.1/networking/udhcp/d6_packet.c busybox-1.34.0/networking/udhcp/d6_packet.c
--- busybox-1.33.1/networking/udhcp/d6_packet.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/d6_packet.c	2021-06-16 17:02:16.000000000 +0700
@@ -44,7 +44,8 @@ int FAST_FUNC d6_recv_kernel_packet(stru
 		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
-	log1("received %s", "a packet");
+	log2("received %s", "a packet");
+	/* log2 because more informative msg for valid packets is printed later at log1 level */
 	d6_dump_packet(packet);
 
 	return bytes;
diff -urpN busybox-1.33.1/networking/udhcp/dhcpc.c busybox-1.34.0/networking/udhcp/dhcpc.c
--- busybox-1.33.1/networking/udhcp/dhcpc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/dhcpc.c	2021-07-20 21:57:20.000000000 +0700
@@ -55,8 +55,7 @@ struct tpacket_auxdata {
 #if ENABLE_LONG_OPTS
 static const char udhcpc_longopts[] ALIGN1 =
 	"clientid-none\0"  No_argument       "C"
-	"vendorclass\0"    Required_argument "V"
-	"hostname\0"       Required_argument "H"
+	"vendorclass\0"    Required_argument "V" //deprecated
 	"fqdn\0"           Required_argument "F"
 	"interface\0"      Required_argument "i"
 	"now\0"            No_argument       "n"
@@ -84,27 +83,25 @@ static const char udhcpc_longopts[] ALIG
 enum {
 	OPT_C = 1 << 0,
 	OPT_V = 1 << 1,
-	OPT_H = 1 << 2,
-	OPT_h = 1 << 3,
-	OPT_F = 1 << 4,
-	OPT_i = 1 << 5,
-	OPT_n = 1 << 6,
-	OPT_p = 1 << 7,
-	OPT_q = 1 << 8,
-	OPT_R = 1 << 9,
-	OPT_r = 1 << 10,
-	OPT_s = 1 << 11,
-	OPT_T = 1 << 12,
-	OPT_t = 1 << 13,
-	OPT_S = 1 << 14,
-	OPT_A = 1 << 15,
-	OPT_O = 1 << 16,
-	OPT_o = 1 << 17,
-	OPT_x = 1 << 18,
-	OPT_f = 1 << 19,
-	OPT_B = 1 << 20,
+	OPT_F = 1 << 2,
+	OPT_i = 1 << 3,
+	OPT_n = 1 << 4,
+	OPT_p = 1 << 5,
+	OPT_q = 1 << 6,
+	OPT_R = 1 << 7,
+	OPT_r = 1 << 8,
+	OPT_s = 1 << 9,
+	OPT_T = 1 << 10,
+	OPT_t = 1 << 11,
+	OPT_S = 1 << 12,
+	OPT_A = 1 << 13,
+	OPT_O = 1 << 14,
+	OPT_o = 1 << 15,
+	OPT_x = 1 << 16,
+	OPT_f = 1 << 17,
+	OPT_B = 1 << 18,
 /* The rest has variable bit positions, need to be clever */
-	OPTBIT_B = 20,
+	OPTBIT_B = 18,
 	USE_FOR_MMU(             OPTBIT_b,)
 	IF_FEATURE_UDHCPC_ARPING(OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPTBIT_P,)
@@ -569,8 +566,8 @@ static void fill_envp(struct dhcp_packet
 	}
 }
 
-/* Call a script with a par file and env vars */
-static void udhcp_run_script(struct dhcp_packet *packet, const char *name)
+/* Call a script with env vars */
+static void d4_run_script(struct dhcp_packet *packet, const char *name)
 {
 	char *argv[3];
 
@@ -588,6 +585,10 @@ static void udhcp_run_script(struct dhcp
 	client_data.envp = NULL;
 }
 
+static void d4_run_script_deconfig(void)
+{
+	d4_run_script(NULL, "deconfig");
+}
 
 /*** Sending/receiving packets ***/
 
@@ -604,7 +605,7 @@ static void init_packet(struct dhcp_pack
 	/* Fill in: op, htype, hlen, cookie fields; message type option: */
 	udhcp_init_header(packet, type);
 
-	packet->xid = random_xid();
+	packet->xid = client_data.xid;
 
 	client_data.last_secs = monotonic_sec();
 	if (client_data.first_secs == 0)
@@ -613,8 +614,6 @@ static void init_packet(struct dhcp_pack
 	packet->secs = (secs < 0xffff) ? htons(secs) : 0xffff;
 
 	memcpy(packet->chaddr, client_data.client_mac, 6);
-	if (client_data.clientid)
-		udhcp_add_binary_option(packet, client_data.clientid);
 }
 
 static void add_client_options(struct dhcp_packet *packet)
@@ -640,13 +639,6 @@ static void add_client_options(struct dh
 		packet->options[end + OPT_DATA + len] = DHCP_END;
 	}
 
-	if (client_data.vendorclass)
-		udhcp_add_binary_option(packet, client_data.vendorclass);
-	if (client_data.hostname)
-		udhcp_add_binary_option(packet, client_data.hostname);
-	if (client_data.fqdn)
-		udhcp_add_binary_option(packet, client_data.fqdn);
-
 	/* Request broadcast replies if we have no IP addr */
 	if ((option_mask32 & OPT_B) && packet->ciaddr == 0)
 		packet->flags |= htons(BROADCAST_FLAG);
@@ -671,6 +663,24 @@ static void add_client_options(struct dh
 	//	...add (DHCP_VENDOR, "udhcp "BB_VER) opt...
 }
 
+static void add_serverid_and_clientid_options(struct dhcp_packet *packet, uint32_t server)
+{
+	struct option_set *ci;
+
+	udhcp_add_simple_option(packet, DHCP_SERVER_ID, server);
+
+	/* RFC 2131 section 2:
+	 * If the client uses a 'client identifier' in one message,
+	 * it MUST use that same identifier in all subsequent messages.
+	 * section 3.1.6:
+	 * If the client used a 'client identifier' when it obtained the lease,
+	 * it MUST use the same 'client identifier' in the DHCPRELEASE message.
+	 */
+	ci = udhcp_find_option(client_data.options, DHCP_CLIENT_ID);
+	if (ci)
+		udhcp_add_binary_option(packet, ci->data);
+}
+
 /* RFC 2131
  * 4.4.4 Use of broadcast and unicast
  *
@@ -709,27 +719,24 @@ static int bcast_or_ucast(struct dhcp_pa
 
 /* Broadcast a DHCP discover packet to the network, with an optionally requested IP */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_discover(uint32_t xid, uint32_t requested)
+static NOINLINE int send_discover(uint32_t requested)
 {
 	struct dhcp_packet packet;
 
 	/* Fill in: op, htype, hlen, cookie, chaddr fields,
-	 * random xid field (we override it below),
-	 * client-id option (unless -C), message type option:
+	 * xid field, message type option:
 	 */
 	init_packet(&packet, DHCPDISCOVER);
 
-	packet.xid = xid;
 	if (requested)
 		udhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);
 
 	/* Add options: maxsize,
-	 * optionally: hostname, fqdn, vendorclass,
 	 * "param req" option according to -O, options specified with -x
 	 */
 	add_client_options(&packet);
 
-	bb_info_msg("sending %s", "discover");
+	bb_simple_info_msg("broadcasting discover");
 	return raw_bcast_from_client_data_ifindex(&packet, INADDR_ANY);
 }
 
@@ -738,10 +745,11 @@ static NOINLINE int send_discover(uint32
  * "The client _broadcasts_ a DHCPREQUEST message..."
  */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_select(uint32_t xid, uint32_t server, uint32_t requested)
+static NOINLINE int send_select(uint32_t server, uint32_t requested)
 {
 	struct dhcp_packet packet;
 	struct in_addr temp_addr;
+	char server_str[sizeof("255.255.255.255")];
 
 /*
  * RFC 2131 4.3.2 DHCPREQUEST message
@@ -756,33 +764,34 @@ static NOINLINE int send_select(uint32_t
  * include that list in all subsequent messages.
  */
 	/* Fill in: op, htype, hlen, cookie, chaddr fields,
-	 * random xid field (we override it below),
-	 * client-id option (unless -C), message type option:
+	 * xid field, message type option:
 	 */
 	init_packet(&packet, DHCPREQUEST);
 
-	packet.xid = xid;
 	udhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);
 
 	udhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);
 
 	/* Add options: maxsize,
-	 * optionally: hostname, fqdn, vendorclass,
-	 * "param req" option according to -O, and options specified with -x
+	 * "param req" option according to -O, options specified with -x
 	 */
 	add_client_options(&packet);
 
+	temp_addr.s_addr = server;
+	strcpy(server_str, inet_ntoa(temp_addr));
 	temp_addr.s_addr = requested;
-	bb_info_msg("sending select for %s", inet_ntoa(temp_addr));
+	bb_info_msg("broadcasting select for %s, server %s",
+			inet_ntoa(temp_addr),
+			server_str
+	);
 	return raw_bcast_from_client_data_ifindex(&packet, INADDR_ANY);
 }
 
 /* Unicast or broadcast a DHCP renew message */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_renew(uint32_t xid, uint32_t server, uint32_t ciaddr)
+static NOINLINE int send_renew(uint32_t server, uint32_t ciaddr)
 {
 	struct dhcp_packet packet;
-	struct in_addr temp_addr;
 
 /*
  * RFC 2131 4.3.2 DHCPREQUEST message
@@ -799,51 +808,46 @@ static NOINLINE int send_renew(uint32_t
  * replying to the client.
  */
 	/* Fill in: op, htype, hlen, cookie, chaddr fields,
-	 * random xid field (we override it below),
-	 * client-id option (unless -C), message type option:
+	 * xid field, message type option:
 	 */
 	init_packet(&packet, DHCPREQUEST);
 
-	packet.xid = xid;
 	packet.ciaddr = ciaddr;
 
 	/* Add options: maxsize,
-	 * optionally: hostname, fqdn, vendorclass,
-	 * "param req" option according to -O, and options specified with -x
+	 * "param req" option according to -O, options specified with -x
 	 */
 	add_client_options(&packet);
 
-	temp_addr.s_addr = server;
-	bb_info_msg("sending renew to %s", inet_ntoa(temp_addr));
+	if (server) {
+		struct in_addr temp_addr;
+		temp_addr.s_addr = server;
+		bb_info_msg("sending renew to server %s", inet_ntoa(temp_addr));
+	} else {
+		bb_simple_info_msg("broadcasting renew");
+	}
+
 	return bcast_or_ucast(&packet, ciaddr, server);
 }
 
 #if ENABLE_FEATURE_UDHCPC_ARPING
 /* Broadcast a DHCP decline message */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int send_decline(/*uint32_t xid,*/ uint32_t server, uint32_t requested)
+static NOINLINE int send_decline(uint32_t server, uint32_t requested)
 {
 	struct dhcp_packet packet;
 
 	/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,
-	 * client-id option (unless -C), message type option:
+	 * message type option:
 	 */
 	init_packet(&packet, DHCPDECLINE);
 
-#if 0
-	/* RFC 2131 says DHCPDECLINE's xid is randomly selected by client,
-	 * but in case the server is buggy and wants DHCPDECLINE's xid
-	 * to match the xid which started entire handshake,
-	 * we use the same xid we used in initial DHCPDISCOVER:
-	 */
-	packet.xid = xid;
-#endif
 	/* DHCPDECLINE uses "requested ip", not ciaddr, to store offered IP */
 	udhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);
 
-	udhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);
+	add_serverid_and_clientid_options(&packet, server);
 
-	bb_info_msg("sending %s", "decline");
+	bb_simple_info_msg("broadcasting decline");
 	return raw_bcast_from_client_data_ifindex(&packet, INADDR_ANY);
 }
 #endif
@@ -856,14 +860,14 @@ int send_release(uint32_t server, uint32
 	struct dhcp_packet packet;
 
 	/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,
-	 * client-id option (unless -C), message type option:
+	 * message type option:
 	 */
 	init_packet(&packet, DHCPRELEASE);
 
 	/* DHCPRELEASE uses ciaddr, not "requested ip", to store IP being released */
 	packet.ciaddr = ciaddr;
 
-	udhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);
+	add_serverid_and_clientid_options(&packet, server);
 
 	bb_info_msg("sending %s", "release");
 	/* Note: normally we unicast here since "server" is not zero.
@@ -875,7 +879,7 @@ int send_release(uint32_t server, uint32
 
 /* Returns -1 on errors that are fatal for the socket, -2 for those that aren't */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
+static NOINLINE int d4_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 {
 	int bytes;
 	struct ip_udp_dhcp_packet packet;
@@ -968,11 +972,12 @@ static NOINLINE int udhcp_recv_raw_packe
  skip_udp_sum_check:
 
 	if (packet.data.cookie != htonl(DHCP_MAGIC)) {
-		bb_simple_info_msg("packet with bad magic, ignoring");
+		log1s("packet with bad magic, ignoring");
 		return -2;
 	}
 
-	log1("received %s", "a packet");
+	log2("received %s", "a packet");
+	/* log2 because more informative msg for valid packets is printed later at log1 level */
 	udhcp_dump_packet(&packet.data);
 
 	bytes -= sizeof(packet.ip) + sizeof(packet.udp);
@@ -1016,7 +1021,6 @@ static int udhcp_raw_socket(int ifindex)
 	 * SOCK_DGRAM: remove link-layer headers on input (SOCK_RAW keeps them)
 	 * ETH_P_IP: want to receive only packets with IPv4 eth type
 	 */
-	log3("got raw socket fd %d", fd);
 
 	memset(&sock, 0, sizeof(sock)); /* let's be deterministic */
 	sock.sll_family = AF_PACKET;
@@ -1086,8 +1090,6 @@ static int udhcp_raw_socket(int ifindex)
 			log1s("can't set PACKET_AUXDATA on raw socket");
 	}
 
-	log1s("created raw socket");
-
 	return fd;
 }
 
@@ -1111,46 +1113,26 @@ static void change_listen_mode(int new_m
 	/* else LISTEN_NONE: client_data.sockfd stays closed */
 }
 
-/* Called only on SIGUSR1 */
-static void perform_renew(void)
-{
-	bb_simple_info_msg("performing DHCP renew");
-	switch (client_data.state) {
-	case BOUND:
-		change_listen_mode(LISTEN_KERNEL);
-	case RENEWING:
-	case REBINDING:
-		client_data.state = RENEW_REQUESTED;
-		break;
-	case RENEW_REQUESTED: /* impatient are we? fine, square 1 */
-		udhcp_run_script(NULL, "deconfig");
-	case REQUESTING:
-	case RELEASED:
-		change_listen_mode(LISTEN_RAW);
-		client_data.state = INIT_SELECTING;
-		break;
-	case INIT_SELECTING:
-		break;
-	}
-}
-
-static void perform_release(uint32_t server_addr, uint32_t requested_ip)
+static void perform_release(uint32_t server_id, uint32_t requested_ip)
 {
 	char buffer[sizeof("255.255.255.255")];
 	struct in_addr temp_addr;
 
+	change_listen_mode(LISTEN_NONE);
+
 	/* send release packet */
 	if (client_data.state == BOUND
 	 || client_data.state == RENEWING
 	 || client_data.state == REBINDING
 	 || client_data.state == RENEW_REQUESTED
 	) {
-		temp_addr.s_addr = server_addr;
+		temp_addr.s_addr = server_id;
 		strcpy(buffer, inet_ntoa(temp_addr));
 		temp_addr.s_addr = requested_ip;
 		bb_info_msg("unicasting a release of %s to %s",
 				inet_ntoa(temp_addr), buffer);
-		send_release(server_addr, requested_ip); /* unicast */
+		client_data.xid = random_xid(); //TODO: can omit?
+		send_release(server_id, requested_ip); /* unicast */
 	}
 	bb_simple_info_msg("entering released state");
 /*
@@ -1159,23 +1141,10 @@ static void perform_release(uint32_t ser
  * Users requested to be notified in all cases, even if not in one
  * of the states above.
  */
-	udhcp_run_script(NULL, "deconfig");
-
-	change_listen_mode(LISTEN_NONE);
+	d4_run_script_deconfig();
 	client_data.state = RELEASED;
 }
 
-static uint8_t* alloc_dhcp_option(int code, const char *str, int extra)
-{
-	uint8_t *storage;
-	int len = strnlen(str, 255);
-	storage = xzalloc(len + extra + OPT_DATA);
-	storage[OPT_CODE] = code;
-	storage[OPT_LEN] = len + extra;
-	memcpy(storage + extra + OPT_DATA, str, len);
-	return storage;
-}
-
 #if BB_MMU
 static void client_background(void)
 {
@@ -1192,11 +1161,11 @@ static void client_background(void)
 //usage:# define IF_UDHCP_VERBOSE(...)
 //usage:#endif
 //usage:#define udhcpc_trivial_usage
-//usage:       "[-fbq"IF_UDHCP_VERBOSE("v")"RB]"IF_FEATURE_UDHCPC_ARPING(" [-a[MSEC]]")" [-t N] [-T SEC] [-A SEC/-n]\n"
+//usage:       "[-fbq"IF_UDHCP_VERBOSE("v")"RB]"IF_FEATURE_UDHCPC_ARPING(" [-a[MSEC]]")" [-t N] [-T SEC] [-A SEC|-n]\n"
 //usage:       "	[-i IFACE]"IF_FEATURE_UDHCP_PORT(" [-P PORT]")" [-s PROG] [-p PIDFILE]\n"
 //usage:       "	[-oC] [-r IP] [-V VENDOR] [-F NAME] [-x OPT:VAL]... [-O OPT]..."
 //usage:#define udhcpc_full_usage "\n"
-//usage:     "\n	-i IFACE	Interface to use (default eth0)"
+//usage:     "\n	-i IFACE	Interface to use (default "CONFIG_UDHCPC_DEFAULT_INTERFACE")"
 //usage:	IF_FEATURE_UDHCP_PORT(
 //usage:     "\n	-P PORT		Use PORT (default 68)"
 //usage:	)
@@ -1236,26 +1205,24 @@ static void client_background(void)
 //usage:     "\n	USR1	Renew lease"
 //usage:     "\n	USR2	Release lease"
 
-
 int udhcpc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 {
 	uint8_t *message;
-	const char *str_V, *str_h, *str_F, *str_r;
+	const char *str_V, *str_F, *str_r;
 	IF_FEATURE_UDHCPC_ARPING(const char *str_a = "2000";)
 	IF_FEATURE_UDHCP_PORT(char *str_P;)
-	void *clientid_mac_ptr;
+	uint8_t *clientid_mac_ptr;
 	llist_t *list_O = NULL;
 	llist_t *list_x = NULL;
 	int tryagain_timeout = 20;
 	int discover_timeout = 3;
 	int discover_retries = 3;
-	uint32_t server_addr = server_addr; /* for compiler */
+	uint32_t server_id = server_id; /* for compiler */
 	uint32_t requested_ip = 0;
-	uint32_t xid = xid; /* for compiler */
 	int packet_num;
 	int timeout; /* must be signed */
-	unsigned already_waited_sec;
+	int lease_remaining; /* must be signed */
 	unsigned opt;
 	IF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)
 	int retval;
@@ -1265,7 +1232,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	/* Default options */
 	IF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)
 	IF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)
-	client_data.interface = "eth0";
+	client_data.interface = CONFIG_UDHCPC_DEFAULT_INTERFACE;
 	client_data.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;
 	client_data.sockfd = -1;
 	str_V = "udhcp "BB_VER;
@@ -1277,14 +1244,14 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	/* Parse command line */
 	opt = getopt32long(argv, "^"
 		/* O,x: list; -T,-t,-A take numeric param */
-		"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB"
+		"CV:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB"
 		USE_FOR_MMU("b")
 		IF_FEATURE_UDHCPC_ARPING("a::")
 		IF_FEATURE_UDHCP_PORT("P:")
 		"v"
 		"\0" IF_UDHCP_VERBOSE("vv") /* -v is a counter */
 		, udhcpc_longopts
-		, &str_V, &str_h, &str_h, &str_F
+		, &str_V, &str_F
 		, &client_data.interface, &client_data.pidfile /* i,p */
 		, &str_r /* r */
 		, &client_data.script /* s */
@@ -1295,14 +1262,14 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		IF_FEATURE_UDHCP_PORT(, &str_P)
 		IF_UDHCP_VERBOSE(, &dhcp_verbose)
 	);
-	if (opt & (OPT_h|OPT_H)) {
-		//msg added 2011-11
-		bb_simple_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
-		client_data.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);
-	}
 	if (opt & OPT_F) {
+		char *p;
+		unsigned len;
 		/* FQDN option format: [0x51][len][flags][0][0]<fqdn> */
-		client_data.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);
+		len = strlen(str_F);
+		p = udhcp_insert_new_option(
+				&client_data.options, DHCP_FQDN,
+				len + 3, /*dhcp6:*/ 0);
 		/* Flag bits: 0000NEOS
 		 * S: 1 = Client requests server to update A RR in DNS as well as PTR
 		 * O: 1 = Server indicates to client that DNS has been updated regardless
@@ -1311,12 +1278,14 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		 * N: 1 = Client requests server to not update DNS (S must be 0 then)
 		 * Two [0] bytes which follow are deprecated and must be 0.
 		 */
-		client_data.fqdn[OPT_DATA + 0] = 0x1;
-		/*client_data.fqdn[OPT_DATA + 1] = 0; - xzalloc did it */
-		/*client_data.fqdn[OPT_DATA + 2] = 0; */
+		p[OPT_DATA + 0] = 0x1;
+		/*p[OPT_DATA + 1] = 0; - xzalloc did it */
+		/*p[OPT_DATA + 2] = 0; */
+		memcpy(p + OPT_DATA + 3, str_F, len); /* do not store NUL byte */
 	}
 	if (opt & OPT_r)
-		requested_ip = inet_addr(str_r);
+		if (!inet_aton(str_r, (void*)&requested_ip))
+			bb_show_usage();
 #if ENABLE_FEATURE_UDHCP_PORT
 	if (opt & OPT_P) {
 		CLIENT_PORT = xatou16(str_P);
@@ -1349,7 +1318,29 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		);
 		free(optstr);
 	}
+	if (str_V[0] != '\0') {
+		char *p;
+		unsigned len = strnlen(str_V, 254);
+		p = udhcp_insert_new_option(
+				&client_data.options, DHCP_VENDOR,
+				len, /*dhcp6:*/ 0);
+		memcpy(p + OPT_DATA, str_V, len); /* do not store NUL byte */
+	}
+
+	clientid_mac_ptr = NULL;
+	if (!(opt & OPT_C) && !udhcp_find_option(client_data.options, DHCP_CLIENT_ID)) {
+		/* not suppressed and not set, create default client ID */
+		clientid_mac_ptr = udhcp_insert_new_option(
+				&client_data.options, DHCP_CLIENT_ID,
+				1 + 6, /*dhcp6:*/ 0);
+		clientid_mac_ptr[OPT_DATA] = 1; /* type: ethernet */
+		clientid_mac_ptr += OPT_DATA + 1; /* skip option code, len, ethernet */
+	}
 
+	/* Not really necessary (we redo it on every iteration)
+	 * but allows early (before daemonization) detection
+	 * of bad interface name.
+	 */
 	if (udhcp_read_interface(client_data.interface,
 			&client_data.ifindex,
 			NULL,
@@ -1358,24 +1349,6 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		return 1;
 	}
 
-	clientid_mac_ptr = NULL;
-	if (!(opt & OPT_C) && !udhcp_find_option(client_data.options, DHCP_CLIENT_ID)) {
-		/* not suppressed and not set, set the default client ID */
-		client_data.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, "", 7);
-		client_data.clientid[OPT_DATA] = 1; /* type: ethernet */
-		clientid_mac_ptr = client_data.clientid + OPT_DATA+1;
-		memcpy(clientid_mac_ptr, client_data.client_mac, 6);
-	}
-	if (str_V[0] != '\0') {
-		// can drop -V, str_V, client_data.vendorclass,
-		// but need to add "vendor" to the list of recognized
-		// string opts for this to work;
-		// and need to tweak add_client_options() too...
-		// ...so the question is, should we?
-		//bb_error_msg("option -V VENDOR is deprecated, use -x vendor:VENDOR");
-		client_data.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);
-	}
-
 #if !BB_MMU
 	/* on NOMMU reexec (i.e., background) early */
 	if (!(opt & OPT_f)) {
@@ -1396,22 +1369,18 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	srand(monotonic_us());
 
 	client_data.state = INIT_SELECTING;
-	udhcp_run_script(NULL, "deconfig");
-	change_listen_mode(LISTEN_RAW);
+	d4_run_script_deconfig();
 	packet_num = 0;
 	timeout = 0;
-	already_waited_sec = 0;
+	lease_remaining = 0;
 
 	/* Main event loop. select() waits on signal pipe and possibly
 	 * on sockfd.
 	 * "continue" statements in code below jump to the top of the loop.
 	 */
 	for (;;) {
-		int tv;
 		struct pollfd pfds[2];
 		struct dhcp_packet packet;
-		/* silence "uninitialized!" warning */
-		unsigned timestamp_before_wait = timestamp_before_wait;
 
 		//bb_error_msg("sockfd:%d, listen_mode:%d", client_data.sockfd, client_data.listen_mode);
 
@@ -1424,17 +1393,27 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 
 		udhcp_sp_fd_set(pfds, client_data.sockfd);
 
-		tv = timeout - already_waited_sec;
 		retval = 0;
 		/* If we already timed out, fall through with retval = 0, else... */
-		if (tv > 0) {
-			log1("waiting %u seconds", tv);
-			timestamp_before_wait = (unsigned)monotonic_sec();
-			retval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);
+		if (timeout > 0) {
+			unsigned diff;
+
+			if (timeout > INT_MAX/1000)
+				timeout = INT_MAX/1000;
+			log1("waiting %u seconds", timeout);
+			diff = (unsigned)monotonic_sec();
+			retval = poll(pfds, 2, timeout * 1000);
+			diff = (unsigned)monotonic_sec() - diff;
+			lease_remaining -= diff;
+			if (lease_remaining < 0)
+				lease_remaining = 0;
+			timeout -= diff;
+			if (timeout < 0)
+				timeout = 0;
+
 			if (retval < 0) {
 				/* EINTR? A signal was caught, don't panic */
 				if (errno == EINTR) {
-					already_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;
 					continue;
 				}
 				/* Else: an error occurred, panic! */
@@ -1461,22 +1440,22 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			if (clientid_mac_ptr)
 				memcpy(clientid_mac_ptr, client_data.client_mac, 6);
 
-			/* We will restart the wait in any case */
-			already_waited_sec = 0;
-
 			switch (client_data.state) {
 			case INIT_SELECTING:
 				if (!discover_retries || packet_num < discover_retries) {
-					if (packet_num == 0)
-						xid = random_xid();
+					if (packet_num == 0) {
+						change_listen_mode(LISTEN_RAW);
+						client_data.xid = random_xid();
+					}
 					/* broadcast */
-					send_discover(xid, requested_ip);
+					send_discover(requested_ip);
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
 				}
  leasefail:
-				udhcp_run_script(NULL, "leasefail");
+				change_listen_mode(LISTEN_NONE);
+				d4_run_script(NULL, "leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
 					bb_simple_info_msg("no lease, forking to background");
@@ -1496,14 +1475,14 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					retval = 1;
 					goto ret;
 				}
-				/* wait before trying again */
+				/* Wait before trying again */
 				timeout = tryagain_timeout;
 				packet_num = 0;
 				continue;
 			case REQUESTING:
 				if (packet_num < 3) {
 					/* send broadcast select packet */
-					send_select(xid, server_addr, requested_ip);
+					send_select(server_id, requested_ip);
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
@@ -1512,21 +1491,20 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				 * "discover...select...discover..." loops
 				 * were seen in the wild. Treat them similarly
 				 * to "no response to discover" case */
-				change_listen_mode(LISTEN_RAW);
 				client_data.state = INIT_SELECTING;
 				goto leasefail;
 			case BOUND:
 				/* 1/2 lease passed, enter renewing state */
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
-				change_listen_mode(LISTEN_KERNEL);
+			got_SIGUSR1:
 				log1s("entering renew state");
+				change_listen_mode(LISTEN_KERNEL);
 				/* fall right through */
-			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
-			case_RENEW_REQUESTED:
+			case RENEW_REQUESTED: /* in manual (SIGUSR1) renew */
 			case RENEWING:
-				if (timeout >= 60) {
-					/* send an unicast renew request */
+				if (packet_num == 0) {
+					/* Send an unicast renew request */
 			/* Sometimes observed to fail (EADDRNOTAVAIL) to bind
 			 * a new UDP socket for sending inside send_renew.
 			 * I hazard to guess existing listening socket
@@ -1535,15 +1513,9 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			 * Anyway, it does recover by eventually failing through
 			 * into INIT_SELECTING state.
 			 */
-					if (send_renew(xid, server_addr, requested_ip) >= 0) {
-						timeout >>= 1;
-//TODO: the timeout to receive an answer for our renew should not be selected
-//with "timeout = lease_seconds / 2; ...; timeout = timeout / 2": it is often huge.
-//Waiting e.g. 4*3600 seconds for a reply does not make sense
-//(if reply isn't coming, we keep an open socket for hours),
-//it should be something like 10 seconds.
-//Also, it's probably best to try sending renew in kernel mode a few (3-5) times
-//and fall back to raw mode if it does not work.
+					if (send_renew(server_id, requested_ip) >= 0) {
+						timeout = discover_timeout;
+						packet_num++;
 						continue;
 					}
 					/* else: error sending.
@@ -1551,33 +1523,44 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					 * which gave us bogus server ID 1.1.1.1
 					 * which wasn't reachable (and probably did not exist).
 					 */
+				} /* else: we had sent one packet, but got no reply */
+				log1s("no response to renew");
+				if (lease_remaining > 30) {
+					/* Some lease time remains, try to renew later */
+					change_listen_mode(LISTEN_NONE);
+					goto BOUND_for_half_lease;
 				}
-				/* Timed out or error, enter rebinding state */
-				log1s("entering rebinding state");
+				/* Enter rebinding state */
 				client_data.state = REBINDING;
-				/* fall right through */
-			case REBINDING:
+				log1s("entering rebinding state");
 				/* Switch to bcast receive */
 				change_listen_mode(LISTEN_RAW);
+				packet_num = 0;
+				/* fall right through */
+			case REBINDING:
 				/* Lease is *really* about to run out,
 				 * try to find DHCP server using broadcast */
-				if (timeout > 0) {
+				if (lease_remaining > 0 && packet_num < 3) {
 					/* send a broadcast renew request */
-					send_renew(xid, 0 /*INADDR_ANY*/, requested_ip);
-					timeout >>= 1;
+					send_renew(0 /*INADDR_ANY*/, requested_ip);
+					timeout = discover_timeout;
+					packet_num++;
 					continue;
 				}
 				/* Timed out, enter init state */
+				change_listen_mode(LISTEN_NONE);
 				bb_simple_info_msg("lease lost, entering init state");
-				udhcp_run_script(NULL, "deconfig");
+				d4_run_script_deconfig();
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
-				/*timeout = 0; - already is */
+				timeout = 0;
 				packet_num = 0;
 				continue;
 			/* case RELEASED: */
 			}
-			/* yah, I know, *you* say it would never happen */
+			/* RELEASED state (when we got SIGUSR2) ends up here.
+			 * (wait for SIGUSR1 to re-init, or for TERM, etc)
+			 */
 			timeout = INT_MAX;
 			continue; /* back to main loop */
 		} /* if poll timed out */
@@ -1587,29 +1570,42 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		/* Is it a signal? */
 		switch (udhcp_sp_read()) {
 		case SIGUSR1:
+			if (client_data.state <= REQUESTING)
+				/* Initial negotiations in progress, do not disturb */
+				break;
+			if (client_data.state == REBINDING)
+				/* Do not go back from rebind to renew state */
+				break;
+
+			if (lease_remaining > 30) /* if renew fails, do not go back to BOUND */
+				lease_remaining = 30;
 			client_data.first_secs = 0; /* make secs field count from 0 */
-			already_waited_sec = 0;
-			perform_renew();
-			if (client_data.state == RENEW_REQUESTED) {
-				/* We might be either on the same network
-				 * (in which case renew might work),
-				 * or we might be on a completely different one
-				 * (in which case renew won't ever succeed).
-				 * For the second case, must make sure timeout
-				 * is not too big, or else we can send
-				 * futile renew requests for hours.
-				 */
-				if (timeout > 60)
-					timeout = 60;
-				goto case_RENEW_REQUESTED;
-			}
-			/* Start things over */
 			packet_num = 0;
+
+			switch (client_data.state) {
+			case BOUND:
+			case RENEWING:
+				/* Try to renew/rebind */
+				client_data.state = RENEW_REQUESTED;
+				goto got_SIGUSR1;
+
+			case RENEW_REQUESTED:
+				/* Two SIGUSR1 received, start things over */
+				change_listen_mode(LISTEN_NONE);
+				d4_run_script_deconfig();
+
+			default:
+			/* case RELEASED: */
+				/* Wake from SIGUSR2-induced deconfigured state */
+				change_listen_mode(LISTEN_NONE);
+			}
+			client_data.state = INIT_SELECTING;
 			/* Kill any timeouts, user wants this to hurry along */
 			timeout = 0;
 			continue;
 		case SIGUSR2:
-			perform_release(server_addr, requested_ip);
+			perform_release(server_id, requested_ip);
+			/* ^^^ switches to LISTEN_NONE */
 			timeout = INT_MAX;
 			continue;
 		case SIGTERM:
@@ -1628,24 +1624,22 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			if (client_data.listen_mode == LISTEN_KERNEL)
 				len = udhcp_recv_kernel_packet(&packet, client_data.sockfd);
 			else
-				len = udhcp_recv_raw_packet(&packet, client_data.sockfd);
+				len = d4_recv_raw_packet(&packet, client_data.sockfd);
 			if (len == -1) {
 				/* Error is severe, reopen socket */
 				bb_error_msg("read error: "STRERROR_FMT", reopening socket" STRERROR_ERRNO);
 				sleep(discover_timeout); /* 3 seconds by default */
 				change_listen_mode(client_data.listen_mode); /* just close and reopen */
 			}
-			/* If this packet will turn out to be unrelated/bogus,
-			 * we will go back and wait for next one.
-			 * Be sure timeout is properly decreased. */
-			already_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;
 			if (len < 0)
 				continue;
 		}
 
-		if (packet.xid != xid) {
-			log1("xid %x (our is %x), ignoring packet",
-				(unsigned)packet.xid, (unsigned)xid);
+		if (packet.xid != client_data.xid) {
+			log1("xid %x (our is %x)%s",
+				(unsigned)packet.xid, (unsigned)client_data.xid,
+				", ignoring packet"
+			);
 			continue;
 		}
 
@@ -1654,13 +1648,13 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		 || memcmp(packet.chaddr, client_data.client_mac, 6) != 0
 		) {
 //FIXME: need to also check that last 10 bytes are zero
-			log1("chaddr does not match%s", ", ignoring packet"); // log2?
+			log1("chaddr does not match%s", ", ignoring packet");
 			continue;
 		}
 
 		message = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (message == NULL) {
-			bb_info_msg("no message type option%s", ", ignoring packet");
+			log1("no message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1668,6 +1662,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		case INIT_SELECTING:
 			/* Must be a DHCPOFFER */
 			if (*message == DHCPOFFER) {
+				struct in_addr temp_addr;
 				uint8_t *temp;
 
 /* What exactly is server's IP? There are several values.
@@ -1694,22 +1689,22 @@ int udhcpc_main(int argc UNUSED_PARAM, c
  * They either supply DHCP_SERVER_ID of 0.0.0.0 or don't supply it at all.
  * They say ISC DHCP client supports this case.
  */
-				server_addr = 0;
+				server_id = 0;
 				temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 				if (!temp) {
 					bb_simple_info_msg("no server ID, using 0.0.0.0");
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
-					move_from_unaligned32(server_addr, temp);
+					move_from_unaligned32(server_id, temp);
 				}
 				/*xid = packet.xid; - already is */
-				requested_ip = packet.yiaddr;
+				temp_addr.s_addr = requested_ip = packet.yiaddr;
+				log1("received offer of %s", inet_ntoa(temp_addr));
 
 				/* enter requesting state */
 				client_data.state = REQUESTING;
 				timeout = 0;
 				packet_num = 0;
-				already_waited_sec = 0;
 			}
 			continue;
 		case REQUESTING:
@@ -1718,27 +1713,39 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		case REBINDING:
 			if (*message == DHCPACK) {
 				unsigned start;
-				uint32_t lease_seconds;
 				struct in_addr temp_addr;
+				char server_str[sizeof("255.255.255.255")];
 				uint8_t *temp;
 
+				change_listen_mode(LISTEN_NONE);
+
+				temp_addr.s_addr = server_id;
+				strcpy(server_str, inet_ntoa(temp_addr));
+				temp_addr.s_addr = packet.yiaddr;
+
+				lease_remaining = 60 * 60;
 				temp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);
-				if (!temp) {
-					bb_simple_info_msg("no lease time with ACK, using 1 hour lease");
-					lease_seconds = 60 * 60;
-				} else {
+				if (temp) {
+					uint32_t lease;
 					/* it IS unaligned sometimes, don't "optimize" */
-					move_from_unaligned32(lease_seconds, temp);
-					lease_seconds = ntohl(lease_seconds);
-					/* paranoia: must not be too small and not prone to overflows */
-					/* timeout > 60 - ensures at least one unicast renew attempt */
-					if (lease_seconds < 2 * 61)
-						lease_seconds = 2 * 61;
-					//if (lease_seconds > 0x7fffffff)
-					//	lease_seconds = 0x7fffffff;
-					//^^^not necessary since "timeout = lease_seconds / 2"
-					//does not overflow even for 0xffffffff.
+					move_from_unaligned32(lease, temp);
+					lease_remaining = ntohl(lease);
 				}
+				/* Log message _before_ we sanitize lease */
+				bb_info_msg("lease of %s obtained from %s, lease time %u%s",
+					inet_ntoa(temp_addr), server_str, (unsigned)lease_remaining,
+					temp ? "" : " (default)"
+				);
+				/* paranoia: must not be too small and not prone to overflows */
+				/* NB: 60s leases _are_ used in real world
+				 * (temporary IPs while ISP modem initializes)
+				 * do not break this case by bumping it up.
+				 */
+				if (lease_remaining < 0) /* signed overflow? */
+					lease_remaining = INT_MAX;
+				if (lease_remaining < 30)
+					lease_remaining = 30;
+				requested_ip = packet.yiaddr;
 #if ENABLE_FEATURE_UDHCPC_ARPING
 				if (opt & OPT_a) {
 /* RFC 2131 3.1 paragraph 5:
@@ -1750,7 +1757,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
  * address is already in use (e.g., through the use of ARP),
  * the client MUST send a DHCPDECLINE message to the server and restarts
  * the configuration process..." */
-					if (!arpping(packet.yiaddr,
+					if (!arpping(requested_ip,
 							NULL,
 							(uint32_t) 0,
 							client_data.client_mac,
@@ -1759,38 +1766,26 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					) {
 						bb_simple_info_msg("offered address is in use "
 							"(got ARP reply), declining");
-						send_decline(/*xid,*/ server_addr, packet.yiaddr);
+						client_data.xid = random_xid(); //TODO: can omit?
+						send_decline(server_id, packet.yiaddr);
 
 						if (client_data.state != REQUESTING)
-							udhcp_run_script(NULL, "deconfig");
-						change_listen_mode(LISTEN_RAW);
+							d4_run_script_deconfig();
 						client_data.state = INIT_SELECTING;
 						client_data.first_secs = 0; /* make secs field count from 0 */
 						requested_ip = 0;
 						timeout = tryagain_timeout;
 						packet_num = 0;
-						already_waited_sec = 0;
 						continue; /* back to main loop */
 					}
 				}
 #endif
 				/* enter bound state */
-				temp_addr.s_addr = packet.yiaddr;
-				bb_info_msg("lease of %s obtained, lease time %u",
-					inet_ntoa(temp_addr), (unsigned)lease_seconds);
-				requested_ip = packet.yiaddr;
-
 				start = monotonic_sec();
-				udhcp_run_script(&packet, client_data.state == REQUESTING ? "bound" : "renew");
-				already_waited_sec = (unsigned)monotonic_sec() - start;
-				timeout = lease_seconds / 2;
-				if ((unsigned)timeout < already_waited_sec) {
-					/* Something went wrong. Back to discover state */
-					timeout = already_waited_sec = 0;
-				}
-
-				client_data.state = BOUND;
-				change_listen_mode(LISTEN_NONE);
+				d4_run_script(&packet, client_data.state == REQUESTING ? "bound" : "renew");
+				lease_remaining -= (unsigned)monotonic_sec() - start;
+				if (lease_remaining < 0)
+					lease_remaining = 0;
 				if (opt & OPT_q) { /* quit after lease */
 					goto ret0;
 				}
@@ -1803,9 +1798,12 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					opt = ((opt & ~OPT_b) | OPT_f);
 				}
 #endif
+ BOUND_for_half_lease:
+				timeout = (unsigned)lease_remaining / 2;
+				client_data.state = BOUND;
 				/* make future renew packets use different xid */
-				/* xid = random_xid(); ...but why bother? */
-
+				/* client_data.xid = random_xid(); ...but why bother? */
+				packet_num = 0;
 				continue; /* back to main loop */
 			}
 			if (*message == DHCPNAK) {
@@ -1813,34 +1811,27 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				 * "wrong" server can reply first, with a NAK.
 				 * Do not interpret it as a NAK from "our" server.
 				 */
-				if (server_addr != 0) {
-					uint32_t svid;
-					uint8_t *temp;
-
-					temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
-					if (!temp) {
- non_matching_svid:
-						log1("received DHCP NAK with wrong"
-							" server ID%s", ", ignoring packet");
-						continue;
-					}
+				uint32_t svid = 0; /* we treat no server id as 0.0.0.0 */
+				uint8_t *temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
+				if (temp)
 					move_from_unaligned32(svid, temp);
-					if (svid != server_addr)
-						goto non_matching_svid;
+				if (svid != server_id) {
+					log1("received DHCP NAK with wrong"
+						" server ID%s", ", ignoring packet");
+					continue;
 				}
 				/* return to init state */
+				change_listen_mode(LISTEN_NONE);
 				bb_info_msg("received %s", "DHCP NAK");
-				udhcp_run_script(&packet, "nak");
+				d4_run_script(&packet, "nak");
 				if (client_data.state != REQUESTING)
-					udhcp_run_script(NULL, "deconfig");
-				change_listen_mode(LISTEN_RAW);
+					d4_run_script_deconfig();
 				sleep(3); /* avoid excessive network traffic */
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				requested_ip = 0;
 				timeout = 0;
 				packet_num = 0;
-				already_waited_sec = 0;
 			}
 			continue;
 		/* case BOUND: - ignore all packets */
@@ -1851,7 +1842,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 
  ret0:
 	if (opt & OPT_R) /* release on quit */
-		perform_release(server_addr, requested_ip);
+		perform_release(server_id, requested_ip);
 	retval = 0;
  ret:
 	/*if (client_data.pidfile) - remove_pidfile has its own check */
diff -urpN busybox-1.33.1/networking/udhcp/dhcpc.h busybox-1.34.0/networking/udhcp/dhcpc.h
--- busybox-1.33.1/networking/udhcp/dhcpc.h	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/dhcpc.h	2021-06-16 17:02:16.000000000 +0700
@@ -11,16 +11,13 @@ struct client_data_t {
 	uint8_t client_mac[6];          /* Our mac address */
 	IF_FEATURE_UDHCP_PORT(uint16_t port;)
 	int ifindex;                    /* Index number of the interface to use */
+	uint32_t xid;
 	uint8_t opt_mask[256 / 8];      /* Bitmask of options to send (-O option) */
 // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TODO: DHCPv6 has 16-bit option numbers
 	const char *interface;          /* The name of the interface to use */
 	char *pidfile;                  /* Optionally store the process ID */
 	const char *script;             /* User script to run at dhcp events */
 	struct option_set *options;     /* list of DHCP options to send to server */
-	uint8_t *clientid;              /* Optional client id to use */
-	uint8_t *vendorclass;           /* Optional vendor class-id to use */
-	uint8_t *hostname;              /* Optional hostname to use */
-	uint8_t *fqdn;                  /* Optional fully qualified domain name to use */
 	llist_t *envp;                  /* list of DHCP options used for env vars */
 
 	unsigned first_secs;
diff -urpN busybox-1.33.1/networking/udhcp/dhcpd.c busybox-1.34.0/networking/udhcp/dhcpd.c
--- busybox-1.33.1/networking/udhcp/dhcpd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/dhcpd.c	2021-06-16 17:02:16.000000000 +0700
@@ -295,12 +295,11 @@ static uint32_t find_free_or_expired_nip
 		uint32_t nip;
 		struct dyn_lease *lease;
 
-		/* ie, 192.168.55.0 */
-		if ((addr & 0xff) == 0)
-			goto next_addr;
-		/* ie, 192.168.55.255 */
-		if ((addr & 0xff) == 0xff)
-			goto next_addr;
+		/* (Addresses ending in .0 or .255 can legitimately be allocated
+		 * in various situations, so _don't_ skip these.  The user needs
+		 * to choose start_ip and end_ip correctly for a particular
+		 * network environment.) */
+
 		nip = htonl(addr);
 		/* skip our own address */
 		if (nip == server_data.server_nip)
@@ -1048,7 +1047,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 			move_from_unaligned32(server_id_network_order, server_id_opt);
 			if (server_id_network_order != server_data.server_nip) {
 				/* client talks to somebody else */
-				log1("server ID doesn't match%s", ", ignoring");
+				log1("server ID doesn't match%s", ", ignoring packet");
 				continue;
 			}
 		}
@@ -1171,7 +1170,7 @@ o DHCPREQUEST generated during REBINDING
 			if (!requested_ip_opt) {
 				requested_nip = packet.ciaddr;
 				if (requested_nip == 0) {
-					log1("no requested IP and no ciaddr%s", ", ignoring");
+					log1("no requested IP and no ciaddr%s", ", ignoring packet");
 					break;
 				}
 			}
diff -urpN busybox-1.33.1/networking/udhcp/dumpleases.c busybox-1.34.0/networking/udhcp/dumpleases.c
--- busybox-1.33.1/networking/udhcp/dumpleases.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/dumpleases.c	2021-04-15 00:05:01.000000000 +0700
@@ -112,7 +112,7 @@ int dumpleases_main(int argc UNUSED_PARA
 			printf("%02u:%02u:%02u\n", h, m, (unsigned)expires);
 		} else { /* -a */
 			time_t t = expires_abs;
-			fputs(ctime(&t), stdout);
+			fputs_stdout(ctime(&t));
 		}
 	}
 	/* close(fd); */
diff -urpN busybox-1.33.1/networking/udhcp/packet.c busybox-1.34.0/networking/udhcp/packet.c
--- busybox-1.33.1/networking/udhcp/packet.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/packet.c	2021-06-16 17:02:16.000000000 +0700
@@ -95,7 +95,8 @@ int FAST_FUNC udhcp_recv_kernel_packet(s
 		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
-	log1("received %s", "a packet");
+	log2("received %s", "a packet");
+	/* log2 because more informative msg for valid packets is printed later at log1 level */
 	udhcp_dump_packet(packet);
 
 	return bytes;
diff -urpN busybox-1.33.1/networking/udhcp/signalpipe.c busybox-1.34.0/networking/udhcp/signalpipe.c
--- busybox-1.33.1/networking/udhcp/signalpipe.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/signalpipe.c	2021-04-15 00:05:01.000000000 +0700
@@ -65,7 +65,7 @@ void FAST_FUNC udhcp_sp_setup(void)
 /* Quick little function to setup the pfds.
  * Limited in that you can only pass one extra fd.
  */
-void FAST_FUNC udhcp_sp_fd_set(struct pollfd pfds[2], int extra_fd)
+void FAST_FUNC udhcp_sp_fd_set(struct pollfd *pfds, int extra_fd)
 {
 	pfds[0].fd = READ_FD;
 	pfds[0].events = POLLIN;
diff -urpN busybox-1.33.1/networking/udhcp/socket.c busybox-1.34.0/networking/udhcp/socket.c
--- busybox-1.33.1/networking/udhcp/socket.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/udhcp/socket.c	2021-06-16 17:02:16.000000000 +0700
@@ -82,7 +82,7 @@ int FAST_FUNC udhcp_listen_socket(/*uint
 	struct sockaddr_in addr;
 	char *colon;
 
-	log1("opening listen socket on *:%d %s", port, inf);
+	log2("opening listen socket on *:%d %s", port, inf);
 	fd = xsocket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 
 	setsockopt_reuseaddr(fd);
diff -urpN busybox-1.33.1/networking/vconfig.c busybox-1.34.0/networking/vconfig.c
--- busybox-1.33.1/networking/vconfig.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/vconfig.c	2021-06-16 17:02:16.000000000 +0700
@@ -20,12 +20,12 @@
 //usage:       "COMMAND [OPTIONS]"
 //usage:#define vconfig_full_usage "\n\n"
 //usage:       "Create and remove virtual ethernet devices\n"
-//usage:     "\n	add		IFACE VLAN_ID"
-//usage:     "\n	rem		VLAN_NAME"
-//usage:     "\n	set_flag	IFACE 0|1 VLAN_QOS"
-//usage:     "\n	set_egress_map	VLAN_NAME SKB_PRIO VLAN_QOS"
-//usage:     "\n	set_ingress_map	VLAN_NAME SKB_PRIO VLAN_QOS"
-//usage:     "\n	set_name_type	NAME_TYPE"
+//usage:     "\n	add IFACE VLAN_ID"
+//usage:     "\n	rem VLAN_NAME"
+//usage:     "\n	set_flag IFACE 0|1 VLAN_QOS"
+//usage:     "\n	set_egress_map VLAN_NAME SKB_PRIO VLAN_QOS"
+//usage:     "\n	set_ingress_map VLAN_NAME SKB_PRIO VLAN_QOS"
+//usage:     "\n	set_name_type NAME_TYPE"
 
 #include "libbb.h"
 #include <net/if.h>
diff -urpN busybox-1.33.1/networking/wget.c busybox-1.34.0/networking/wget.c
--- busybox-1.33.1/networking/wget.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/networking/wget.c	2021-05-05 02:35:15.000000000 +0700
@@ -25,6 +25,13 @@
 //config:	default y
 //config:	depends on WGET
 //config:
+//config:config FEATURE_WGET_FTP
+//config:	bool "Enable FTP protocol (+1k)"
+//config:	default y
+//config:	depends on WGET
+//config:	help
+//config:	To support FTPS, enable FEATURE_WGET_HTTPS as well.
+//config:
 //config:config FEATURE_WGET_AUTHENTICATION
 //config:	bool "Enable HTTP authentication"
 //config:	default y
@@ -48,12 +55,12 @@
 //config:
 //config:config FEATURE_WGET_HTTPS
 //config:	bool "Support HTTPS using internal TLS code"
-//it also enables FTPS support, but it's not well tested yet
 //config:	default y
 //config:	depends on WGET
 //config:	select TLS
 //config:	help
 //config:	wget will use internal TLS code to connect to https:// URLs.
+//config:	It also enables FTPS support, but it's not well tested yet.
 //config:	Note:
 //config:	On NOMMU machines, ssl_helper applet should be available
 //config:	in the $PATH for this to work. Make sure to select that applet.
@@ -173,6 +180,7 @@
 
 
 #define SSL_SUPPORTED (ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_HTTPS)
+#define FTPS_SUPPORTED (ENABLE_FEATURE_WGET_FTP && ENABLE_FEATURE_WGET_HTTPS)
 
 struct host_info {
 	char *allocated;
@@ -182,14 +190,16 @@ struct host_info {
 	char       *host;
 	int         port;
 };
-static const char P_FTP[] ALIGN1 = "ftp";
 static const char P_HTTP[] ALIGN1 = "http";
 #if SSL_SUPPORTED
-# if ENABLE_FEATURE_WGET_HTTPS
-static const char P_FTPS[] ALIGN1 = "ftps";
-# endif
 static const char P_HTTPS[] ALIGN1 = "https";
 #endif
+#if ENABLE_FEATURE_WGET_FTP
+static const char P_FTP[] ALIGN1 = "ftp";
+#endif
+#if FTPS_SUPPORTED
+static const char P_FTPS[] ALIGN1 = "ftps";
+#endif
 
 #if ENABLE_FEATURE_WGET_LONG_OPTIONS
 /* User-specified headers prevent using our corresponding built-in headers.  */
@@ -482,6 +492,7 @@ static char fgets_trim_sanitize(FILE *fp
 	return c;
 }
 
+#if ENABLE_FEATURE_WGET_FTP
 static int ftpcmd(const char *s1, const char *s2, FILE *fp)
 {
 	int result;
@@ -507,6 +518,7 @@ static int ftpcmd(const char *s1, const
 	G.wget_buf[3] = ' ';
 	return result;
 }
+#endif
 
 static void parse_url(const char *src_url, struct host_info *h)
 {
@@ -515,30 +527,31 @@ static void parse_url(const char *src_ur
 	free(h->allocated);
 	h->allocated = url = xstrdup(src_url);
 
-	h->protocol = P_FTP;
+	h->protocol = P_HTTP;
 	p = strstr(url, "://");
 	if (p) {
 		*p = '\0';
 		h->host = p + 3;
+#if ENABLE_FEATURE_WGET_FTP
 		if (strcmp(url, P_FTP) == 0) {
 			h->port = bb_lookup_std_port(P_FTP, "tcp", 21);
+			h->protocol = P_FTP;
 		} else
-#if SSL_SUPPORTED
-# if ENABLE_FEATURE_WGET_HTTPS
+#endif
+#if FTPS_SUPPORTED
 		if (strcmp(url, P_FTPS) == 0) {
 			h->port = bb_lookup_std_port(P_FTPS, "tcp", 990);
 			h->protocol = P_FTPS;
 		} else
-# endif
+#endif
+#if SSL_SUPPORTED
 		if (strcmp(url, P_HTTPS) == 0) {
 			h->port = bb_lookup_std_port(P_HTTPS, "tcp", 443);
 			h->protocol = P_HTTPS;
 		} else
 #endif
 		if (strcmp(url, P_HTTP) == 0) {
- http:
-			h->port = bb_lookup_std_port(P_HTTP, "tcp", 80);
-			h->protocol = P_HTTP;
+			goto http;
 		} else {
 			*p = ':';
 			bb_error_msg_and_die("not an http or ftp url: %s", url);
@@ -546,7 +559,8 @@ static void parse_url(const char *src_ur
 	} else {
 		// GNU wget is user-friendly and falls back to http://
 		h->host = url;
-		goto http;
+ http:
+		h->port = bb_lookup_std_port(P_HTTP, "tcp", 80);
 	}
 
 	// FYI:
@@ -796,6 +810,7 @@ static void spawn_ssl_client(const char
 }
 #endif
 
+#if ENABLE_FEATURE_WGET_FTP
 static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_sockaddr *lsa)
 {
 	FILE *sfp;
@@ -803,7 +818,7 @@ static FILE* prepare_ftp_session(FILE **
 	int port;
 
 	sfp = open_socket(lsa);
-#if ENABLE_FEATURE_WGET_HTTPS
+#if FTPS_SUPPORTED
 	if (target->protocol == P_FTPS)
 		spawn_ssl_client(target->host, fileno(sfp), TLSLOOP_EXIT_ON_LOCAL_EOF);
 #endif
@@ -859,7 +874,7 @@ static FILE* prepare_ftp_session(FILE **
 
 	*dfpp = open_socket(lsa);
 
-#if ENABLE_FEATURE_WGET_HTTPS
+#if FTPS_SUPPORTED
 	if (target->protocol == P_FTPS) {
 		/* "PROT P" enables encryption of data stream.
 		 * Without it (or with "PROT C"), data is sent unencrypted.
@@ -885,6 +900,7 @@ static FILE* prepare_ftp_session(FILE **
 
 	return sfp;
 }
+#endif
 
 static void NOINLINE retrieve_file_data(FILE *dfp)
 {
@@ -1330,6 +1346,8 @@ However, in real world it was observed t
 		case 301:
 		case 302:
 		case 303:
+		case 307:
+		case 308:
 			break;
 
 		case 206: /* Partial Content */
@@ -1407,10 +1425,12 @@ However, in real world it was observed t
 		/* For HTTP, data is pumped over the same connection */
 		dfp = sfp;
 	} else {
+#if ENABLE_FEATURE_WGET_FTP
 		/*
 		 *  FTP session
 		 */
 		sfp = prepare_ftp_session(&dfp, &target, lsa);
+#endif
 	}
 
 	free(lsa);
@@ -1428,6 +1448,7 @@ However, in real world it was observed t
 			fprintf(stderr, "remote file exists\n");
 	}
 
+#if ENABLE_FEATURE_WGET_FTP
 	if (dfp != sfp) {
 		/* It's ftp. Close data connection properly */
 		fclose(dfp);
@@ -1435,6 +1456,7 @@ However, in real world it was observed t
 			bb_error_msg_and_die("ftp error: %s", G.wget_buf);
 		/* ftpcmd("QUIT", NULL, sfp); - why bother? */
 	}
+#endif
 	fclose(sfp);
 
 	free(server.allocated);
diff -urpN busybox-1.33.1/procps/free.c busybox-1.34.0/procps/free.c
--- busybox-1.33.1/procps/free.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/free.c	2021-07-20 21:57:20.000000000 +0700
@@ -19,9 +19,9 @@
 //kbuild:lib-$(CONFIG_FREE) += free.o
 
 //usage:#define free_trivial_usage
-//usage:       "" IF_DESKTOP("[-b/k/m/g]")
+//usage:       "" IF_DESKTOP("[-bkmgh]")
 //usage:#define free_full_usage "\n\n"
-//usage:       "Display the amount of free and used system memory"
+//usage:       "Display free and used memory"
 //usage:
 //usage:#define free_example_usage
 //usage:       "$ free\n"
@@ -29,6 +29,27 @@
 //usage:       "  Mem:       257628       248724         8904        59644        93124\n"
 //usage:       " Swap:       128516         8404       120112\n"
 //usage:       "Total:       386144       257128       129016\n"
+//procps-ng 3.3.15:
+// -b, --bytes         show output in bytes
+//     --kilo          show output in kilobytes
+//     --mega          show output in megabytes
+//     --giga          show output in gigabytes
+//     --tera          show output in terabytes
+//     --peta          show output in petabytes
+// -k, --kibi          show output in kibibytes
+// -m, --mebi          show output in mebibytes
+// -g, --gibi          show output in gibibytes
+//     --tebi          show output in tebibytes
+//     --pebi          show output in pebibytes
+// -h, --human         show human-readable output
+//     --si            use powers of 1000 not 1024
+// -l, --lohi          show detailed low and high memory statistics
+// -t, --total         show total for RAM + swap
+// -s N, --seconds N   repeat printing every N seconds
+// -c N, --count N     repeat printing N times, then exit
+// -w, --wide          wide output
+//
+//NB: if we implement -s or -c, need to stop being NOFORK!
 
 #include "libbb.h"
 #ifdef __linux__
@@ -38,18 +59,22 @@
 struct globals {
 	unsigned mem_unit;
 #if ENABLE_DESKTOP
-	uint8_t unit_steps;
-# define G_unit_steps g->unit_steps
+	unsigned unit;
+# define G_unit g->unit
 #else
-# define G_unit_steps 10
+# define G_unit (1 << 10)
 #endif
 	unsigned long cached_kb, available_kb, reclaimable_kb;
 };
 /* Because of NOFORK, "globals" are not in global data */
 
-static unsigned long long scale(struct globals *g, unsigned long d)
+static const char *scale(struct globals *g, unsigned long d)
 {
-	return ((unsigned long long)d * g->mem_unit) >> G_unit_steps;
+	/* Display (size * block_size) with one decimal digit.
+	 * If display_unit == 0, show value no bigger than 1024 with suffix (K,M,G...),
+	 * else divide by display_unit and do not use suffix.
+	 * Returns "auto pointer" */
+	return make_human_readable_str(d, g->mem_unit, G_unit);
 }
 
 /* NOINLINE reduces main() stack usage, which makes code smaller (on x86 at least) */
@@ -88,20 +113,27 @@ int free_main(int argc UNUSED_PARAM, cha
 	int seen_available;
 
 #if ENABLE_DESKTOP
-	G.unit_steps = 10;
+	G.unit = 1 << 10;
 	if (argv[1] && argv[1][0] == '-') {
 		switch (argv[1][1]) {
 		case 'b':
-			G.unit_steps = 0;
+			G.unit = 1;
 			break;
 		case 'k': /* 2^10 */
-			/* G.unit_steps = 10; - already is */
+			/* G.unit = 1 << 10; - already is */
 			break;
 		case 'm': /* 2^20 */
-			G.unit_steps = 20;
+			G.unit = 1 << 20;
 			break;
 		case 'g': /* 2^30 */
-			G.unit_steps = 30;
+			G.unit = 1 << 30;
+			break;
+//		case 't':
+// -- WRONG, -t is not "terabytes" in procps-ng, it's --total
+//			G.unit = 1 << 40;
+//			break;
+		case 'h':
+			G.unit = 0; /* human readable */
 			break;
 		default:
 			bb_show_usage();
@@ -126,23 +158,13 @@ int free_main(int argc UNUSED_PARAM, cha
 	cached += ((unsigned long long) G.reclaimable_kb * 1024) / G.mem_unit;
 	cached_plus_free = cached + info.freeram;
 
-/* In case (long long * G.mem_unit) can overflow, this can be used to reduce the chances */
-#if 0 //ENABLE_DESKTOP
-	while (!(G.mem_unit & 1) && G.unit_steps != 0) {
-		G.mem_unit >>= 1;
-		G.unit_steps--;
-		//bb_error_msg("mem_unit:%d unit_steps:%d", G.mem_unit, G.unit_steps);
-	}
-#endif
-
-#define FIELDS_6 "%12llu %11llu %11llu %11llu %11llu %11llu\n"
-#define FIELDS_3 (FIELDS_6 + 6 + 7 + 7)
-#define FIELDS_2 (FIELDS_6 + 6 + 7 + 7 + 7)
-
-	printf(FIELDS_6,
+	printf("%12s%12s%12s",
 		scale(&G, info.totalram),                //total
 		scale(&G, info.totalram - cached_plus_free), //used
-		scale(&G, info.freeram),                 //free
+		scale(&G, info.freeram)                  //free
+	);
+	/* using two printf's: only 4 auto strings are supported, we need 6 */
+	printf("%12s%12s%12s\n",
 		scale(&G, info.sharedram),               //shared
 		scale(&G, cached),                       //buff/cache
 		scale(&G, available)                     //available
@@ -152,14 +174,14 @@ int free_main(int argc UNUSED_PARAM, cha
 	 * buffer cache as free memory. */
 	if (!seen_available) {
 		printf("-/+ buffers/cache: ");
-		printf(FIELDS_2,
+		printf("%12s%12s%12s\n" + 4,
 			scale(&G, info.totalram - cached_plus_free), //used
 			scale(&G, cached_plus_free)                  //free
 		);
 	}
 #if BB_MMU
 	printf("Swap:  ");
-	printf(FIELDS_3,
+	printf("%12s%12s%12s\n",
 		scale(&G, info.totalswap),                 //total
 		scale(&G, info.totalswap - info.freeswap), //used
 		scale(&G, info.freeswap)                   //free
diff -urpN busybox-1.33.1/procps/kill.c busybox-1.34.0/procps/kill.c
--- busybox-1.33.1/procps/kill.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/kill.c	2021-06-16 17:02:16.000000000 +0700
@@ -59,7 +59,7 @@
 //usage:       "$ kill 252\n"
 //usage:
 //usage:#define killall_trivial_usage
-//usage:       "[-l] [-q] [-SIG] PROCESS_NAME..."
+//usage:       "[-lq] [-SIG] PROCESS_NAME..."
 //usage:#define killall_full_usage "\n\n"
 //usage:       "Send a signal (default: TERM) to given processes\n"
 //usage:     "\n	-l	List all signal names and numbers"
diff -urpN busybox-1.33.1/procps/lsof.c busybox-1.34.0/procps/lsof.c
--- busybox-1.33.1/procps/lsof.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/lsof.c	2021-07-20 21:57:20.000000000 +0700
@@ -66,7 +66,7 @@ int lsof_main(int argc UNUSED_PARAM, cha
 
 				safe_strncpy(name + baseofs, entry->d_name, 10);
 				if ((fdlink = xmalloc_readlink(name)) != NULL) {
-					printf("%d\t%s\t%s\n", proc->pid, proc->exe, fdlink);
+					printf("%d\t%s\t%s\t%s\n", proc->pid, proc->exe, entry->d_name, fdlink);
 					free(fdlink);
 				}
 			}
diff -urpN busybox-1.33.1/procps/nmeter.c busybox-1.34.0/procps/nmeter.c
--- busybox-1.33.1/procps/nmeter.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/procps/nmeter.c	2021-01-08 15:30:27.000000000 +0700
@@ -952,11 +952,11 @@ int nmeter_main(int argc UNUSED_PARAM, c
 	reset_outbuf();
 
 	if (G.delta >= 0) {
-		gettimeofday(&G.tv, NULL);
+		xgettimeofday(&G.tv);
 		usleep(G.delta > 1000000 ? 1000000 : G.delta - G.tv.tv_usec % G.deltanz);
 	}
 
-	gettimeofday(&G.start, NULL);
+	xgettimeofday(&G.start);
 	G.tv = G.start;
 	while (1) {
 		collect_info(first);
@@ -971,7 +971,7 @@ int nmeter_main(int argc UNUSED_PARAM, c
 		if (G.delta >= 0) {
 			int rem;
 			// can be commented out, will sacrifice sleep time precision a bit
-			gettimeofday(&G.tv, NULL);
+			xgettimeofday(&G.tv);
 			if (need_seconds)
 				rem = G.delta - ((ullong)G.tv.tv_sec*1000000 + G.tv.tv_usec) % G.deltanz;
 			else
@@ -983,7 +983,7 @@ int nmeter_main(int argc UNUSED_PARAM, c
 			}
 			usleep(rem);
 		}
-		gettimeofday(&G.tv, NULL);
+		xgettimeofday(&G.tv);
 	}
 
 	/*return 0;*/
diff -urpN busybox-1.33.1/procps/pgrep.c busybox-1.34.0/procps/pgrep.c
--- busybox-1.33.1/procps/pgrep.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/pgrep.c	2021-06-16 17:02:16.000000000 +0700
@@ -44,17 +44,17 @@
 //usage:     "\n	-P	Match parent process ID"
 //usage:
 //usage:#define pkill_trivial_usage
-//usage:       "[-l|-SIGNAL] [-fnovx] [-s SID|-P PPID|PATTERN]"
+//usage:       "[-l|-SIGNAL] [-xfvno] [-s SID|-P PPID|PATTERN]"
 //usage:#define pkill_full_usage "\n\n"
-//usage:       "Send a signal to process(es) selected by regex PATTERN\n"
+//usage:       "Send signal to processes selected by regex PATTERN\n"
 //usage:     "\n	-l	List all signals"
+//usage:     "\n	-x	Match whole name (not substring)"
 //usage:     "\n	-f	Match against entire command line"
+//usage:     "\n	-s SID	Match session ID (0 for current)"
+//usage:     "\n	-P PPID	Match parent process ID"
+//usage:     "\n	-v	Negate the match"
 //usage:     "\n	-n	Signal the newest process only"
 //usage:     "\n	-o	Signal the oldest process only"
-//usage:     "\n	-v	Negate the match"
-//usage:     "\n	-x	Match whole name (not substring)"
-//usage:     "\n	-s	Match session ID (0 for current)"
-//usage:     "\n	-P	Match parent process ID"
 
 #include "libbb.h"
 #include "xregex.h"
diff -urpN busybox-1.33.1/procps/pmap.c busybox-1.34.0/procps/pmap.c
--- busybox-1.33.1/procps/pmap.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/pmap.c	2021-01-08 15:30:27.000000000 +0700
@@ -27,20 +27,14 @@
 
 #include "libbb.h"
 
-#if ULONG_MAX == 0xffffffff
+#if ULLONG_MAX == 0xffffffff
 # define TABS "\t"
-# define AFMT "8"
+# define AFMTLL "8"
 # define DASHES ""
 #else
 # define TABS "\t\t"
-# define AFMT "16"
-# define DASHES "--------"
-#endif
-
-#if ULLONG_MAX == 0xffffffff
-# define AFMTLL "8"
-#else
 # define AFMTLL "16"
+# define DASHES "--------"
 #endif
 
 enum {
diff -urpN busybox-1.33.1/procps/powertop.c busybox-1.34.0/procps/powertop.c
--- busybox-1.33.1/procps/powertop.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/powertop.c	2021-04-15 00:05:01.000000000 +0700
@@ -818,7 +818,7 @@ int powertop_main(int argc UNUSED_PARAM,
 
 		for (i = 0; i < MAX_CSTATE_COUNT + 2; i++)
 			if (cstate_lines[i][0])
-				fputs(cstate_lines[i], stdout);
+				fputs_stdout(cstate_lines[i]);
 
 		i = process_timer_stats();
 #if ENABLE_FEATURE_POWERTOP_PROCIRQ
diff -urpN busybox-1.33.1/procps/sysctl.c busybox-1.34.0/procps/sysctl.c
--- busybox-1.33.1/procps/sysctl.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/sysctl.c	2021-06-16 17:02:16.000000000 +0700
@@ -21,16 +21,16 @@
 //kbuild:lib-$(CONFIG_BB_SYSCTL) += sysctl.o
 
 //usage:#define sysctl_trivial_usage
-//usage:       "-p [-enq] [FILE...] / [-enqaw] [KEY[=VALUE]]..."
+//usage:       "[-enq] { -a | -p [FILE]... | [-w] [KEY[=VALUE]]... }"
 //usage:#define sysctl_full_usage "\n\n"
 //usage:       "Show/set kernel parameters\n"
-//usage:     "\n	-p	Set values from FILEs (default /etc/sysctl.conf)"
 //usage:     "\n	-e	Don't warn about unknown keys"
 //usage:     "\n	-n	Don't show key names"
 //usage:     "\n	-q      Quiet"
 //usage:     "\n	-a	Show all values"
 /* Same as -a, no need to show it */
 /* //usage:     "\n	-A	Show all values in table form" */
+//usage:     "\n	-p	Set values from FILEs (default /etc/sysctl.conf)"
 //usage:     "\n	-w	Set values"
 //usage:
 //usage:#define sysctl_example_usage
diff -urpN busybox-1.33.1/procps/top.c busybox-1.34.0/procps/top.c
--- busybox-1.33.1/procps/top.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/top.c	2021-06-16 17:02:16.000000000 +0700
@@ -712,7 +712,7 @@ static NOINLINE void display_process_lis
 		);
 		if ((int)(scr_width - col) > 1)
 			read_cmdline(line_buf + col, scr_width - col, s->pid, s->comm);
-		fputs(line_buf, stdout);
+		fputs_stdout(line_buf);
 		/* printf(" %d/%d %lld/%lld", s->pcpu, total_pcpu,
 			cur_jif.busy - prev_jif.busy, cur_jif.total - prev_jif.total); */
 		s++;
@@ -1052,9 +1052,9 @@ static unsigned handle_input(unsigned sc
 //usage:       "[-b"IF_FEATURE_TOPMEM("m")IF_FEATURE_SHOW_THREADS("H")"]"
 //usage:       " [-n COUNT] [-d SECONDS]"
 //usage:#define top_full_usage "\n\n"
-//usage:       "Provide a view of process activity in real time."
+//usage:       "Show a view of process activity in real time."
 //usage:   "\n""Read the status of all processes from /proc each SECONDS"
-//usage:   "\n""and display a screenful of them."
+//usage:   "\n""and show a screenful of them."
 //usage:   "\n"
 //usage:	IF_FEATURE_TOP_INTERACTIVE(
 //usage:       "Keys:"
diff -urpN busybox-1.33.1/procps/watch.c busybox-1.34.0/procps/watch.c
--- busybox-1.33.1/procps/watch.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/procps/watch.c	2021-06-16 17:02:16.000000000 +0700
@@ -22,7 +22,7 @@
 //usage:       "[-n SEC] [-t] PROG ARGS"
 //usage:#define watch_full_usage "\n\n"
 //usage:       "Run PROG periodically\n"
-//usage:     "\n	-n SEC	Loop period (default 2)"
+//usage:     "\n	-n SEC	Period (default 2)"
 //usage:     "\n	-t	Don't print header"
 //usage:
 //usage:#define watch_example_usage
diff -urpN busybox-1.33.1/runit/runsv.c busybox-1.34.0/runit/runsv.c
--- busybox-1.33.1/runit/runsv.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/runit/runsv.c	2021-06-16 17:02:16.000000000 +0700
@@ -62,12 +62,12 @@ static void gettimeofday_ns(struct times
 	 && sizeof(((struct timeval*)ts)->tv_usec) == sizeof(ts->tv_nsec)
 	) {
 		/* Cheat */
-		gettimeofday((void*)ts, NULL);
+		xgettimeofday((void*)ts);
 		ts->tv_nsec *= 1000;
 	} else {
 		/* For example, musl has "incompatible" layouts */
 		struct timeval tv;
-	        gettimeofday(&tv, NULL);
+		xgettimeofday(&tv);
 		ts->tv_sec = tv.tv_sec;
 		ts->tv_nsec = tv.tv_usec * 1000;
 	}
@@ -149,17 +149,18 @@ static void warn_cannot(const char *m)
 	warn2_cannot(m, "");
 }
 
-static void s_child(int sig_no UNUSED_PARAM)
+/* SIGCHLD/TERM handler is reentrancy-safe because they are unmasked
+ * only over poll() call, not over memory allocations
+ * or printouts. Do not need to save/restore errno either,
+ * as poll() error is not checked there.
+ */
+static void s_chld_term(int sig_no)
 {
+	if (sig_no == SIGTERM)
+		sigterm = 1;
 	write(selfpipe.wr, "", 1);
 }
 
-static void s_term(int sig_no UNUSED_PARAM)
-{
-	sigterm = 1;
-	write(selfpipe.wr, "", 1); /* XXX */
-}
-
 static int open_trunc_or_warn(const char *name)
 {
 	/* Why O_NDELAY? */
@@ -380,11 +381,14 @@ static void startservice(struct svdir *s
 				xdup2(logpipe.wr, 1);
 			}
 		}
-		/* Non-ignored signals revert to SIG_DFL on exec anyway */
-		/*bb_signals(0
-			+ (1 << SIGCHLD)
-			+ (1 << SIGTERM)
-			, SIG_DFL);*/
+		/* Non-ignored signals revert to SIG_DFL on exec.
+		 * But we can get signals BEFORE execl(), unlikely as that may be.
+		 * SIGCHLD is safe (would merely write to selfpipe),
+		 * but SIGTERM would set sigterm = 1 (with vfork, we affect parent).
+		 * Avoid that.
+		 */
+		/*signal(SIGCHLD, SIG_DFL);*/
+		signal(SIGTERM, SIG_DFL);
 		sig_unblock(SIGCHLD);
 		sig_unblock(SIGTERM);
 		execv(arg[0], (char**) arg);
@@ -511,9 +515,15 @@ int runsv_main(int argc UNUSED_PARAM, ch
 	ndelay_on(selfpipe.wr);
 
 	sig_block(SIGCHLD);
-	bb_signals_recursive_norestart(1 << SIGCHLD, s_child);
 	sig_block(SIGTERM);
-	bb_signals_recursive_norestart(1 << SIGTERM, s_term);
+	/* No particular reason why we don't set SA_RESTART
+	 * (poll() wouldn't restart regardless of that flag),
+	 * we just follow what runit-2.1.2 does:
+	 */
+	bb_signals_norestart(0
+			+ (1 << SIGCHLD)
+			+ (1 << SIGTERM)
+			, s_chld_term);
 
 	xchdir(dir);
 	/* bss: svd[0].pid = 0; */
@@ -625,6 +635,7 @@ int runsv_main(int argc UNUSED_PARAM, ch
 		sig_unblock(SIGTERM);
 		sig_unblock(SIGCHLD);
 		poll(x, 2 + haslog, 3600*1000);
+		/* NB: signal handlers can trash errno of poll() */
 		sig_block(SIGTERM);
 		sig_block(SIGCHLD);
 
diff -urpN busybox-1.33.1/runit/svlogd.c busybox-1.34.0/runit/svlogd.c
--- busybox-1.33.1/runit/svlogd.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/runit/svlogd.c	2021-06-16 17:02:16.000000000 +0700
@@ -140,12 +140,12 @@ log message, you can use a pattern like
 //usage:#define svlogd_full_usage "\n\n"
 //usage:       "Read log data from stdin and write to rotated log files in DIRs"
 //usage:   "\n"
-//usage:   "\n""-r C		Replace non-printable characters with C"
-//usage:   "\n""-R CHARS	Also replace CHARS with C (default _)"
-//usage:   "\n""-t		Timestamp with @tai64n"
-//usage:   "\n""-tt		Timestamp with yyyy-mm-dd_hh:mm:ss.sssss"
-//usage:   "\n""-ttt		Timestamp with yyyy-mm-ddThh:mm:ss.sssss"
-//usage:   "\n""-v		Verbose"
+//usage:   "\n""	-r C	Replace non-printable characters with C"
+//usage:   "\n""	-R CHARS Also replace CHARS with C (default _)"
+//usage:   "\n""	-t	Timestamp with @tai64n"
+//usage:   "\n""	-tt	Timestamp with yyyy-mm-dd_hh:mm:ss.sssss"
+//usage:   "\n""	-ttt	Timestamp with yyyy-mm-ddThh:mm:ss.sssss"
+//usage:   "\n""	-v	Verbose"
 //usage:   "\n"
 //usage:   "\n""DIR/config file modifies behavior:"
 //usage:   "\n""sSIZE - when to rotate logs (default 1000000, 0 disables)"
@@ -351,7 +351,7 @@ static void fmt_time_human_30nul(char *s
 	struct tm *ptm;
 	struct timeval tv;
 
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	ptm = gmtime_r(&tv.tv_sec, &tm);
 	/* ^^^ using gmtime_r() instead of gmtime() to not use static data */
 	sprintf(s, "%04u-%02u-%02u%c%02u:%02u:%02u.%06u000",
@@ -376,7 +376,7 @@ static void fmt_time_bernstein_25(char *
 	struct timeval tv;
 	unsigned sec_hi;
 
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	sec_hi = (0x400000000000000aULL + tv.tv_sec) >> 32;
 	tv.tv_sec = (time_t)(0x400000000000000aULL) + tv.tv_sec;
 	tv.tv_usec *= 1000;
@@ -412,19 +412,32 @@ static void processorstart(struct logdir
 		int fd;
 
 		/* child */
-		/* Non-ignored signals revert to SIG_DFL on exec anyway */
+		/* Non-ignored signals revert to SIG_DFL on exec anyway.
+		 * But we can get signals BEFORE execl(), this is unlikely
+		 * but wouldn't be good...
+		 */
 		/*bb_signals(0
 			+ (1 << SIGTERM)
+			//+ (1 << SIGCHLD)
 			+ (1 << SIGALRM)
 			+ (1 << SIGHUP)
 			, SIG_DFL);*/
-		sig_unblock(SIGTERM);
-		sig_unblock(SIGALRM);
-		sig_unblock(SIGHUP);
+		/* runit 2.1.2 does not unblock SIGCHLD, a bug? we do: */
+		sigprocmask(SIG_UNBLOCK, &blocked_sigset, NULL);
 
 		if (verbose)
 			bb_error_msg(INFO"processing: %s/%s", ld->name, ld->fnsave);
-		fd = xopen(ld->fnsave, O_RDONLY|O_NDELAY);
+
+		fd = open_or_warn(ld->fnsave, O_RDONLY|O_NDELAY);
+		/* Used to have xopen() above, but it causes infinite restarts of processor
+		 * if file is gone - which can happen even because of _us_!
+		 * Users report that if on reboot, time is reset to before existing
+		 * logfiles creation time, rmoldest() deletes the newest logfile (!)
+		 * and we end up here trying to open this now-deleted file.
+		 */
+		if (fd < 0)
+			_exit(0); /* fake "success": do not run processor again */
+
 		xmove_fd(fd, 0);
 		ld->fnsave[26] = 't'; /* <- that's why we need sv_ch! */
 		fd = xopen(ld->fnsave, O_WRONLY|O_NDELAY|O_TRUNC|O_CREAT);
@@ -1098,10 +1111,10 @@ int svlogd_main(int argc, char **argv)
 	sigaddset(&blocked_sigset, SIGALRM);
 	sigaddset(&blocked_sigset, SIGHUP);
 	sigprocmask(SIG_BLOCK, &blocked_sigset, NULL);
-	bb_signals_recursive_norestart(1 << SIGTERM, sig_term_handler);
-	bb_signals_recursive_norestart(1 << SIGCHLD, sig_child_handler);
-	bb_signals_recursive_norestart(1 << SIGALRM, sig_alarm_handler);
-	bb_signals_recursive_norestart(1 << SIGHUP, sig_hangup_handler);
+	bb_signals_norestart(1 << SIGTERM, sig_term_handler);
+	bb_signals_norestart(1 << SIGCHLD, sig_child_handler);
+	bb_signals_norestart(1 << SIGALRM, sig_alarm_handler);
+	bb_signals_norestart(1 << SIGHUP, sig_hangup_handler);
 
 	/* Without timestamps, we don't have to print each line
 	 * separately, so we can look for _last_ newline, not first,
diff -urpN busybox-1.33.1/scripts/basic/docproc.c busybox-1.34.0/scripts/basic/docproc.c
--- busybox-1.33.1/scripts/basic/docproc.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/basic/docproc.c	2021-04-27 00:21:10.000000000 +0700
@@ -182,10 +182,10 @@ void find_export_symbols(char * filename
 			perror(real_filename);
 		}
 		while (fgets(line, MAXLINESZ, fp)) {
-			char *p;
-			char *e;
-			if (((p = strstr(line, "EXPORT_SYMBOL_GPL")) != 0) ||
-			    ((p = strstr(line, "EXPORT_SYMBOL")) != 0)) {
+			unsigned char *p;
+			unsigned char *e;
+			if (((p = (unsigned char *)strstr(line, "EXPORT_SYMBOL_GPL")) != 0) ||
+			    ((p = (unsigned char *)strstr(line, "EXPORT_SYMBOL")) != 0)) {
 				/* Skip EXPORT_SYMBOL{_GPL} */
 				while (isalnum(*p) || *p == '_')
 					p++;
@@ -202,7 +202,7 @@ void find_export_symbols(char * filename
 				while (isalnum(*e) || *e == '_')
 					e++;
 				*e = '\0';
-				add_new_symbol(sym, p);
+				add_new_symbol(sym, (char*)p);
 			}
 		}
 		fclose(fp);
@@ -266,7 +266,7 @@ void singfunc(char * filename, char * li
 
 	/* Split line up in individual parameters preceded by FUNCTION */
 	for (i=0; line[i]; i++) {
-		if (isspace(line[i])) {
+		if (isspace((unsigned char) line[i])) {
 			line[i] = '\0';
 			startofsym = 1;
 			continue;
@@ -293,10 +293,10 @@ void singfunc(char * filename, char * li
 void parse_file(FILE *infile)
 {
 	char line[MAXLINESZ];
-	char * s;
+	unsigned char * s;
 	while (fgets(line, MAXLINESZ, infile)) {
 		if (line[0] == '!') {
-			s = line + 2;
+			s = (unsigned char *)line + 2;
 			switch (line[1]) {
 				case 'E':
 					while (*s && !isspace(*s)) s++;
@@ -320,7 +320,7 @@ void parse_file(FILE *infile)
 					/* function names */
 					while (isspace(*s))
 						s++;
-					singlefunctions(line +2, s);
+					singlefunctions(line +2, (char*)s);
 					break;
 				default:
 					defaultline(line);
diff -urpN busybox-1.33.1/scripts/basic/fixdep.c busybox-1.34.0/scripts/basic/fixdep.c
--- busybox-1.33.1/scripts/basic/fixdep.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/basic/fixdep.c	2021-04-27 00:21:10.000000000 +0700
@@ -226,10 +226,10 @@ void use_config(char *m, int slen)
 void parse_config_file(char *map, size_t len)
 {
 	/* modified for bbox */
-	char *end_3 = map + len - 3; /* 3 == length of "IF_" */
-	char *end_7 = map + len - 7;
-	char *p = map;
-	char *q;
+	unsigned char *end_3 = (unsigned char *)map + len - 3; /* 3 == length of "IF_" */
+	unsigned char *end_7 = (unsigned char *)map + len - 7;
+	unsigned char *p = (unsigned char *)map;
+	unsigned char *q;
 	int off;
 
 	for (; p <= end_3; p++) {
@@ -263,7 +263,7 @@ void parse_config_file(char *map, size_t
 				break;
 		}
 		if (q != p) {
-			use_config(p, q-p);
+			use_config((char*)p, q - p);
 		}
 	}
 }
@@ -335,7 +335,7 @@ void parse_dep_file(void *map, size_t le
 		p = m;
 		while (p < end && *p != ' ') p++;
 		if (p == end) {
-			do p--; while (!isalnum(*p));
+			do p--; while (!isalnum((unsigned char)*p));
 			p++;
 		}
 		memcpy(s, m, p-m); s[p-m] = 0;
diff -urpN busybox-1.33.1/scripts/basic/split-include.c busybox-1.34.0/scripts/basic/split-include.c
--- busybox-1.33.1/scripts/basic/split-include.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/basic/split-include.c	2021-04-27 00:21:10.000000000 +0700
@@ -116,7 +116,7 @@ int main(int argc, const char * argv [])
 	/* We found #define CONFIG_foo or #undef CONFIG_foo.
 	 * Make the output file name. */
 	str_config += sizeof(" CONFIG_") - 1;
-	for (itarget = 0; !isspace(str_config[itarget]); itarget++)
+	for (itarget = 0; !isspace((unsigned char)str_config[itarget]); itarget++)
 	{
 	    int c = (unsigned char) str_config[itarget];
 	    if (isupper(c)) c = tolower(c);
@@ -131,7 +131,7 @@ int main(int argc, const char * argv [])
 	is_same = 0;
 	if ((fp_target = fopen(ptarget, "r")) != NULL)
 	{
-	    if (!fgets(old_line, buffer_size, fp_target))
+	    if (!fgets(old_line, buffer_size, fp_target) && ferror(fp_target))
 		ERROR_EXIT(ptarget);
 	    if (fclose(fp_target) != 0)
 		ERROR_EXIT(ptarget);
diff -urpN busybox-1.33.1/scripts/bb_release busybox-1.34.0/scripts/bb_release
--- busybox-1.33.1/scripts/bb_release	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/scripts/bb_release	2021-01-08 15:30:27.000000000 +0700
@@ -8,6 +8,7 @@
 
 #svn co svn://busybox.net/trunk/busybox
 cd busybox || { echo "cd busybox failed"; exit 1; }
+chmod -Rc u+w,a+rX,go-w .
 make release || { echo "make release failed"; exit 1; }
 cd ..
 
diff -urpN busybox-1.33.1/scripts/bloat-o-meter busybox-1.34.0/scripts/bloat-o-meter
--- busybox-1.33.1/scripts/bloat-o-meter	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/bloat-o-meter	2021-04-15 00:05:01.000000000 +0700
@@ -43,7 +43,15 @@ if f1 is None or f2 is None:
 
 sym_args = " ".join(sys.argv[3 + flag_timing + dashes:])
 def getsizes(file):
-    sym, alias, lut = {}, {}, {}
+    sym, alias, lut, section = {}, {}, {}, {}
+    for l in os.popen("readelf -W -S " + file).readlines():
+        x = l.replace("[ ", "[", 1).split()
+        if len(x)<6: continue
+        # Should take these into account too!
+        #if x[1] not in [".text", ".rodata", ".symtab", ".strtab"]: continue
+        if x[1] not in [".rodata"]: continue
+        sym[x[1]] = {"addr" : int(x[3], 16), "size" : int(x[5], 16)}
+        section[x[0][1:-1]] = {"name" : x[1]}
     for l in os.popen("readelf -W -s %s %s" % (sym_args, file)).readlines():
         l = l.strip()
         if not (len(l) and l[0].isdigit() and len(l.split()) == 8):
@@ -59,6 +67,10 @@ def getsizes(file):
         else:
             sym[name] = {"addr" : value, "size":  size}
             lut[(value, size)] = 0
+            # If this item is in a known section deduct its size from
+            # the size of the section
+            if ndx in section:
+                sym[section[ndx]["name"]]["size"] -= size
     for addr, sz in iter(alias.keys()):
         # If the non-GLOBAL sym has an implementation elsewhere then
         # it's an alias, disregard it.
@@ -66,13 +78,6 @@ def getsizes(file):
             # If this non-GLOBAL sym does not have an implementation at
             # another address, then treat it as a normal symbol.
             sym[alias[(addr, sz)]["name"]] = {"addr" : addr, "size": sz}
-    for l in os.popen("readelf -W -S " + file).readlines():
-        x = l.split()
-        if len(x)<6: continue
-        # Should take these into account too!
-        #if x[1] not in [".text", ".rodata", ".symtab", ".strtab"]: continue
-        if x[1] not in [".rodata"]: continue
-        sym[x[1]] = {"addr" : int(x[3], 16), "size" : int(x[5], 16)}
     return sym
 
 if flag_timing:
diff -urpN busybox-1.33.1/scripts/gcc-version.sh busybox-1.34.0/scripts/gcc-version.sh
--- busybox-1.33.1/scripts/gcc-version.sh	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/gcc-version.sh	2021-04-27 00:21:10.000000000 +0700
@@ -7,6 +7,6 @@
 #
 
 compiler="$*"
-
-MAJ_MIN=$(echo __GNUC__ __GNUC_MINOR__ | $compiler -E -xc - | tail -n 1)
+# tr -d '\r': fix up msdos-style line endings (Cygwin et al)
+MAJ_MIN=$(echo __GNUC__ __GNUC_MINOR__ | $compiler -E -xc - | tr -d '\r' | tail -n 1)
 printf '%02d%02d\n' $MAJ_MIN
diff -urpN busybox-1.33.1/scripts/gen_build_files.sh busybox-1.34.0/scripts/gen_build_files.sh
--- busybox-1.33.1/scripts/gen_build_files.sh	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/gen_build_files.sh	2021-06-16 17:02:16.000000000 +0700
@@ -4,6 +4,8 @@
 # but users complain that many sed implementations
 # are misinterpreting --.
 
+export LC_ALL=C
+
 test $# -ge 2 || { echo "Syntax: $0 SRCTREE OBJTREE"; exit 1; }
 
 # cd to objtree
diff -urpN busybox-1.33.1/scripts/kconfig/conf.c busybox-1.34.0/scripts/kconfig/conf.c
--- busybox-1.33.1/scripts/kconfig/conf.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/kconfig/conf.c	2021-04-27 00:21:10.000000000 +0700
@@ -44,7 +44,7 @@ static void strip(char *str)
 	char *p = str;
 	int l;
 
-	while ((isspace(*p)))
+	while ((isspace((unsigned char)*p)))
 		p++;
 	l = strlen(p);
 	if (p != str)
@@ -52,7 +52,7 @@ static void strip(char *str)
 	if (!l)
 		return;
 	p = str + l - 1;
-	while ((isspace(*p)))
+	while ((isspace((unsigned char)*p)))
 		*p-- = 0;
 }
 
@@ -401,7 +401,7 @@ static int conf_choice(struct menu *menu
 			}
 			if (!line[0])
 				cnt = def;
-			else if (isdigit(line[0]))
+			else if (isdigit((unsigned char)line[0]))
 				cnt = atoi(line);
 			else
 				continue;
diff -urpN busybox-1.33.1/scripts/kconfig/confdata.c busybox-1.34.0/scripts/kconfig/confdata.c
--- busybox-1.33.1/scripts/kconfig/confdata.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/kconfig/confdata.c	2021-06-16 17:02:16.000000000 +0700
@@ -54,7 +54,7 @@ static char *conf_expand_value(const cha
 		strncat(res_value, in, src - in);
 		src++;
 		dst = name;
-		while (isalnum(*src) || *src == '_')
+		while (isalnum((unsigned char)*src) || *src == '_')
 			*dst++ = *src++;
 		*dst = 0;
 		sym = sym_lookup(name, 0);
@@ -342,6 +342,8 @@ int conf_write(const char *name)
 	time_t now;
 	int use_timestamp = 1;
 	char *env;
+	char *source_date_epoch;
+	struct tm *build_time;
 
 	dirname[0] = 0;
 	if (name && name[0]) {
@@ -378,7 +380,16 @@ int conf_write(const char *name)
 	}
 	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
-	time(&now);
+
+	source_date_epoch = getenv("SOURCE_DATE_EPOCH");
+	if (source_date_epoch && *source_date_epoch) {
+		now = strtoull(source_date_epoch, NULL, 10);
+		build_time = gmtime(&now);
+	} else {
+		time(&now);
+		build_time = localtime(&now);
+	}
+
 	env = getenv("KCONFIG_NOTIMESTAMP");
 	if (env && *env)
 		use_timestamp = 0;
@@ -398,14 +409,14 @@ int conf_write(const char *name)
 		if (use_timestamp) {
 			size_t ret = \
 				strftime(buf, sizeof(buf), "#define AUTOCONF_TIMESTAMP "
-					"\"%Y-%m-%d %H:%M:%S %Z\"\n", localtime(&now));
+					"\"%Y-%m-%d %H:%M:%S %Z\"\n", build_time);
 			/* if user has Factory timezone or some other odd install, the
 			 * %Z above will overflow the string leaving us with undefined
 			 * results ... so let's try again without the timezone.
 			 */
 			if (ret == 0)
 				strftime(buf, sizeof(buf), "#define AUTOCONF_TIMESTAMP "
-					"\"%Y-%m-%d %H:%M:%S\"\n", localtime(&now));
+					"\"%Y-%m-%d %H:%M:%S\"\n", build_time);
 		} else { /* bbox */
 			strcpy(buf, "#define AUTOCONF_TIMESTAMP \"\"\n");
 		}
diff -urpN busybox-1.33.1/scripts/kconfig/mconf.c busybox-1.34.0/scripts/kconfig/mconf.c
--- busybox-1.33.1/scripts/kconfig/mconf.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/kconfig/mconf.c	2021-04-27 00:21:10.000000000 +0700
@@ -771,7 +771,7 @@ static void conf(struct menu *menu)
 		if (!type)
 			continue;
 
-		for (i = 0; input_buf[i] && !isspace(input_buf[i]); i++)
+		for (i = 0; input_buf[i] && !isspace((unsigned char)input_buf[i]); i++)
 			;
 		if (i >= sizeof(active_entry))
 			i = sizeof(active_entry) - 1;
diff -urpN busybox-1.33.1/scripts/randomtest busybox-1.34.0/scripts/randomtest
--- busybox-1.33.1/scripts/randomtest	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/randomtest	2021-08-16 01:46:14.000000000 +0700
@@ -83,7 +83,6 @@ if test x"$LIBC" = x"uclibc"; then
 	\
 	| grep -v CONFIG_FEATURE_2_4_MODULES \
 	| grep -v CONFIG_FEATURE_SYNC_FANCY \
-	| grep -v CONFIG_FEATURE_TOUCH_NODEREF \
 	| grep -v CONFIG_NANDWRITE \
 	| grep -v CONFIG_NANDDUMP \
 	| grep -v CONFIG_BLKDISCARD \
@@ -100,7 +99,6 @@ if test x"$LIBC" = x"uclibc"; then
 	echo '# CONFIG_PIE is not set' >>.config
 	echo '# CONFIG_FEATURE_2_4_MODULES is not set' >>.config
 	echo '# CONFIG_FEATURE_SYNC_FANCY is not set' >>.config
-	echo '# CONFIG_FEATURE_TOUCH_NODEREF is not set' >>.config
 	# My uclibc installation does not support some needed APIs...
 	echo '# CONFIG_NANDWRITE is not set' >>.config
 	echo '# CONFIG_NANDDUMP is not set' >>.config
diff -urpN busybox-1.33.1/scripts/randomtest.loop busybox-1.34.0/scripts/randomtest.loop
--- busybox-1.33.1/scripts/randomtest.loop	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/randomtest.loop	2021-08-19 20:02:34.000000000 +0700
@@ -6,13 +6,18 @@ run_testsuite=true
 run_single_test=false
 run_single_test=true
 
-test -d "$1" || { echo "'$1' is not a directory"; exit 1; }
-test -x "$1/scripts/randomtest" || { echo "No scripts/randomtest in '$1'"; exit 1; }
-
 export LIBC="uclibc"
 export CROSS_COMPILER_PREFIX="i686-"
 export MAKEOPTS="-j9"
 
+test -d "$1" || { echo "'$1' is not a directory"; exit 1; }
+test -x "$1/scripts/randomtest" || { echo "No scripts/randomtest in '$1'"; exit 1; }
+
+test "$SKIP_MOUNT_MAND_TESTS" = "1" || {
+	echo "SKIP_MOUNT_MAND_TESTS not set, some mount tests will fail"
+	echo "if current kernel has CONFIG_MANDATORY_FILE_LOCKING off."
+}
+
 cnt=0
 fail=0
 while sleep 1; do
diff -urpN busybox-1.33.1/scripts/trylink busybox-1.34.0/scripts/trylink
--- busybox-1.33.1/scripts/trylink	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/scripts/trylink	2021-04-15 00:05:01.000000000 +0700
@@ -1,5 +1,6 @@
 #!/bin/sh
 
+#debug=true
 debug=false
 
 # Linker flags used:
@@ -77,7 +78,13 @@ CFLAGS="$3"
 LDFLAGS="$4"
 O_FILES="$5"
 A_FILES="$6"
+# We try to drop libraries from LDLIBS if build works without them,
+# but ones from CONFIG_EXTRA_LDLIBS are always linked in.
+# (For example, musl has stub utmp implementation, and if you link with
+# a real utmp library in LDLIBS, dropping it "works" but resulting binary
+# does not work properly).
 LDLIBS="$7"
+CONFIG_EXTRA_LDLIBS="$8"
 
 # The --sort-section option is not supported by older versions of ld
 SORT_SECTION="-Wl,--sort-section,alignment"
@@ -125,8 +132,8 @@ LDLIBS=`echo "$LDLIBS" | xargs -n1 | sor
 # First link with all libs. If it fails, bail out
 echo "Trying libraries: $LDLIBS"
 # "lib1 lib2 lib3" -> "-llib1 -llib2 -llib3"
-l_list=`echo " $LDLIBS " | sed -e 's: \([^- ][^ ]*\): -l\1:g'`
-test "x$l_list" != "x" && l_list="$START_GROUP $l_list $END_GROUP"
+l_list=`echo " $LDLIBS $CONFIG_EXTRA_LDLIBS " | sed -e 's: \([^- ][^ ]*\): -l\1:g' -e 's/^ *//'`
+test x"$l_list" != x"" && l_list="$START_GROUP $l_list $END_GROUP"
 try $CC $CFLAGS $LDFLAGS \
 	-o $EXE \
 	$SORT_COMMON \
@@ -151,7 +158,7 @@ while test "$LDLIBS"; do
     for one in $LDLIBS; do
 	without_one=`echo " $LDLIBS " | sed "s/ $one / /g" | xargs`
 	# "lib1 lib2 lib3" -> "-llib1 -llib2 -llib3"
-	l_list=`echo " $without_one " | sed -e 's: \([^- ][^ ]*\): -l\1:g'`
+	l_list=`echo " $without_one $CONFIG_EXTRA_LDLIBS " | sed -e 's: \([^- ][^ ]*\): -l\1:g' -e 's/^ *//'`
 	test x"$l_list" != x"" && l_list="$START_GROUP $l_list $END_GROUP"
 	$debug && echo "Trying -l options: '$l_list'"
 	try $CC $CFLAGS $LDFLAGS \
@@ -179,8 +186,8 @@ done
 
 # Make the binary with final, minimal list of libs
 echo "Final link with: ${LDLIBS:-<none>}"
-l_list=`echo " $LDLIBS " | sed -e 's: \([^- ][^ ]*\): -l\1:g'`
-test "x$l_list" != "x" && l_list="$START_GROUP $l_list $END_GROUP"
+l_list=`echo " $LDLIBS $CONFIG_EXTRA_LDLIBS " | sed -e 's: \([^- ][^ ]*\): -l\1:g' -e 's/^ *//'`
+test x"$l_list" != x"" && l_list="$START_GROUP $l_list $END_GROUP"
 # --verbose gives us gobs of info to stdout (e.g. linker script used)
 if ! test -f busybox_ldscript; then
     try $CC $CFLAGS $LDFLAGS \
diff -urpN busybox-1.33.1/selinux/chcon.c busybox-1.34.0/selinux/chcon.c
--- busybox-1.33.1/selinux/chcon.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/selinux/chcon.c	2021-04-15 00:05:01.000000000 +0700
@@ -26,7 +26,7 @@
 //usage:	)
 //usage:
 //usage:#define chcon_full_usage "\n\n"
-//usage:       "Change the security context of each FILE to CONTEXT\n"
+//usage:       "Change the security context of FILEs to CONTEXT\n"
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-c	Report changes made"
 //usage:     "\n	-h	Affect symlinks instead of their targets"
diff -urpN busybox-1.33.1/shell/ash.c busybox-1.34.0/shell/ash.c
--- busybox-1.33.1/shell/ash.c	2021-05-04 01:06:49.000000000 +0700
+++ busybox-1.34.0/shell/ash.c	2021-08-16 00:57:08.000000000 +0700
@@ -229,6 +229,14 @@
 #define    BASH_READ_D          ENABLE_ASH_BASH_COMPAT
 #define IF_BASH_READ_D              IF_ASH_BASH_COMPAT
 #define    BASH_WAIT_N          ENABLE_ASH_BASH_COMPAT
+/* <(...) and >(...) */
+#if HAVE_DEV_FD
+# define    BASH_PROCESS_SUBST   ENABLE_ASH_BASH_COMPAT
+# define IF_BASH_PROCESS_SUBST       IF_ASH_BASH_COMPAT
+#else
+# define    BASH_PROCESS_SUBST 0
+# define IF_BASH_PROCESS_SUBST(...)
+#endif
 
 #if defined(__ANDROID_API__) && __ANDROID_API__ <= 24
 /* Bionic at least up to version 24 has no glob() */
@@ -314,9 +322,12 @@ typedef long arith_t;
 
 /* ============ Shell options */
 
+/* If you add/change options hare, update --help text too */
 static const char *const optletters_optnames[] = {
 	"e"   "errexit",
 	"f"   "noglob",
+/* bash has '-o ignoreeof', but no short synonym -I for it */
+/* (in bash, set -I disables invisible variables (what's that?)) */
 	"I"   "ignoreeof",
 /* The below allowed this invocation:
  * ash -c 'set -i; echo $-; sleep 5; echo $-'
@@ -325,9 +336,10 @@ static const char *const optletters_optn
  * In our code, this is denoted by empty long name:
  */
 	"i"   "",
+/* (removing "i" altogether would remove it from "$-", not good) */
 	"m"   "monitor",
 	"n"   "noexec",
-/* Ditto: bash has no "set -s" */
+/* Ditto: bash has no "set -s", "set -c" */
 	"s"   "",
 	"c"   "",
 	"x"   "xtrace",
@@ -800,6 +812,12 @@ out2str(const char *p)
 #define CTLENDARI    ((unsigned char)'\207')
 #define CTLQUOTEMARK ((unsigned char)'\210')
 #define CTL_LAST CTLQUOTEMARK
+#if BASH_PROCESS_SUBST
+# define CTLTOPROC    ((unsigned char)'\211')
+# define CTLFROMPROC  ((unsigned char)'\212')
+# undef CTL_LAST
+# define CTL_LAST CTLFROMPROC
+#endif
 
 /* variable substitution byte (follows CTLVAR) */
 #define VSTYPE  0x0f            /* type of variable substitution */
@@ -1071,6 +1089,10 @@ trace_puts_quoted(char *s)
 		case CTLESC: c = 'e'; goto backslash;
 		case CTLVAR: c = 'v'; goto backslash;
 		case CTLBACKQ: c = 'q'; goto backslash;
+#if BASH_PROCESS_SUBST
+		case CTLTOPROC: c = 'p'; goto backslash;
+		case CTLFROMPROC: c = 'P'; goto backslash;
+#endif
  backslash:
 			putc('\\', tracefile);
 			putc(c, tracefile);
@@ -1232,8 +1254,17 @@ sharg(union node *arg, FILE *fp)
 		case CTLENDVAR:
 			putc('}', fp);
 			break;
+#if BASH_PROCESS_SUBST
+		case CTLTOPROC:
+			putc('>', fp);
+			goto backq;
+		case CTLFROMPROC:
+			putc('<', fp);
+			goto backq;
+#endif
 		case CTLBACKQ:
 			putc('$', fp);
+ IF_BASH_PROCESS_SUBST(backq:)
 			putc('(', fp);
 			shtree(bqlist->n, -1, NULL, fp);
 			putc(')', fp);
@@ -3230,8 +3261,13 @@ static const uint8_t syntax_index_table[
 	/* 134 CTLARI       */ CCTL_CCTL_CCTL_CCTL,
 	/* 135 CTLENDARI    */ CCTL_CCTL_CCTL_CCTL,
 	/* 136 CTLQUOTEMARK */ CCTL_CCTL_CCTL_CCTL,
+#if BASH_PROCESS_SUBST
+	/* 137 CTLTOPROC    */ CCTL_CCTL_CCTL_CCTL,
+	/* 138 CTLFROMPROC  */ CCTL_CCTL_CCTL_CCTL,
+#else
 	/* 137      */ CWORD_CWORD_CWORD_CWORD,
 	/* 138      */ CWORD_CWORD_CWORD_CWORD,
+#endif
 	/* 139      */ CWORD_CWORD_CWORD_CWORD,
 	/* 140      */ CWORD_CWORD_CWORD_CWORD,
 	/* 141      */ CWORD_CWORD_CWORD_CWORD,
@@ -4259,9 +4295,7 @@ sprint_status48(char *os, int status, in
 #endif
 		}
 		st &= 0x7f;
-//TODO: use bbox's get_signame? strsignal adds ~600 bytes to text+rodata
-		//s = stpncpy(s, strsignal(st), 32); //not all libc have stpncpy()
-		s += fmtstr(s, 32, strsignal(st));
+		s = stpncpy(s, strsignal(st), 32);
 		if (WCOREDUMP(status)) {
 			s = stpcpy(s, " (core dumped)");
 		}
@@ -4847,9 +4881,24 @@ cmdputs(const char *s)
 			quoted >>= 1;
 			subtype = 0;
 			goto dostr;
+#if BASH_PROCESS_SUBST
+		case CTLBACKQ:
+			c = '$';
+			str = "(...)";
+			break;
+		case CTLTOPROC:
+			c = '>';
+			str = "(...)";
+			break;
+		case CTLFROMPROC:
+			c = '<';
+			str = "(...)";
+			break;
+#else
 		case CTLBACKQ:
 			str = "$(...)";
 			goto dostr;
+#endif
 #if ENABLE_FEATURE_SH_MATH
 		case CTLARI:
 			str = "$((";
@@ -5889,6 +5938,21 @@ redirectsafe(union node *redir, int flag
 	return err;
 }
 
+#if BASH_PROCESS_SUBST
+static void
+pushfd(int fd)
+{
+	struct redirtab *sv;
+
+	sv = ckzalloc(sizeof(*sv) + sizeof(sv->two_fd[0]));
+	sv->pair_count = 1;
+	sv->two_fd[0].orig_fd = fd;
+	sv->two_fd[0].moved_to = CLOSED;
+	sv->next = redirlist;
+	redirlist = sv;
+}
+#endif
+
 static struct redirtab*
 pushredir(union node *redir)
 {
@@ -6527,10 +6591,20 @@ evaltreenr(union node *n, int flags)
 }
 
 static void FAST_FUNC
-evalbackcmd(union node *n, struct backcmd *result)
+evalbackcmd(union node *n, struct backcmd *result
+				IF_BASH_PROCESS_SUBST(, int ctl))
 {
 	int pip[2];
 	struct job *jp;
+#if BASH_PROCESS_SUBST
+	/* determine end of pipe used by parent (ip) and child (ic) */
+	const int ip = (ctl == CTLTOPROC);
+	const int ic = !(ctl == CTLTOPROC);
+#else
+	const int ctl = CTLBACKQ;
+	const int ip = 0;
+	const int ic = 1;
+#endif
 
 	result->fd = -1;
 	result->buf = NULL;
@@ -6542,15 +6616,17 @@ evalbackcmd(union node *n, struct backcm
 
 	if (pipe(pip) < 0)
 		ash_msg_and_raise_perror("can't create pipe");
-	jp = makejob(/*n,*/ 1);
-	if (forkshell(jp, n, FORK_NOJOB) == 0) {
+	/* process substitution uses NULL job/node, like openhere() */
+	jp = (ctl == CTLBACKQ) ? makejob(/*n,*/ 1) : NULL;
+	if (forkshell(jp, (ctl == CTLBACKQ) ? n : NULL, FORK_NOJOB) == 0) {
 		/* child */
 		FORCE_INT_ON;
-		close(pip[0]);
-		if (pip[1] != 1) {
-			/*close(1);*/
-			dup2_or_raise(pip[1], 1);
-			close(pip[1]);
+		close(pip[ip]);
+		/* ic is index of child end of pipe *and* fd to connect it to */
+		if (pip[ic] != ic) {
+			/*close(ic);*/
+			dup2_or_raise(pip[ic], ic);
+			close(pip[ic]);
 		}
 /* TODO: eflag clearing makes the following not abort:
  *  ash -c 'set -e; z=$(false;echo foo); echo $z'
@@ -6566,8 +6642,18 @@ evalbackcmd(union node *n, struct backcm
 		/* NOTREACHED */
 	}
 	/* parent */
-	close(pip[1]);
-	result->fd = pip[0];
+#if BASH_PROCESS_SUBST
+	if (ctl != CTLBACKQ) {
+		int fd = fcntl(pip[ip], F_DUPFD, 64);
+		if (fd > 0) {
+			close(pip[ip]);
+			pip[ip] = fd;
+		}
+		pushfd(pip[ip]);
+	}
+#endif
+	close(pip[ic]);
+	result->fd = pip[ip];
 	result->jp = jp;
 
  out:
@@ -6579,8 +6665,11 @@ evalbackcmd(union node *n, struct backcm
  * Expand stuff in backwards quotes.
  */
 static void
-expbackq(union node *cmd, int flag)
+expbackq(union node *cmd, int flag IF_BASH_PROCESS_SUBST(, int ctl))
 {
+#if !BASH_PROCESS_SUBST
+	const int ctl = CTLBACKQ;
+#endif
 	struct backcmd in;
 	int i;
 	char buf[128];
@@ -6595,9 +6684,15 @@ expbackq(union node *cmd, int flag)
 	INT_OFF;
 	startloc = expdest - (char *)stackblock();
 	pushstackmark(&smark, startloc);
-	evalbackcmd(cmd, &in);
+	evalbackcmd(cmd, &in IF_BASH_PROCESS_SUBST(, ctl));
 	popstackmark(&smark);
 
+	if (ctl != CTLBACKQ) {
+		sprintf(buf, DEV_FD_PREFIX"%d", in.fd);
+		strtodest(buf, BASESYNTAX);
+		goto done;
+	}
+
 	p = in.buf;
 	i = in.nleft;
 	if (i == 0)
@@ -6619,6 +6714,7 @@ expbackq(union node *cmd, int flag)
 		close(in.fd);
 		back_exitstatus = waitforjob(in.jp);
 	}
+ done:
 	INT_ON;
 
 	/* Eat all trailing newlines */
@@ -6706,6 +6802,10 @@ argstr(char *p, int flag)
 		CTLESC,
 		CTLVAR,
 		CTLBACKQ,
+#if BASH_PROCESS_SUBST
+		CTLTOPROC,
+		CTLFROMPROC,
+#endif
 #if ENABLE_FEATURE_SH_MATH
 		CTLARI,
 		CTLENDARI,
@@ -6805,8 +6905,12 @@ argstr(char *p, int flag)
 			p = evalvar(p, flag | inquotes);
 			TRACE(("argstr: evalvar:'%s'\n", (char *)stackblock()));
 			goto start;
+#if BASH_PROCESS_SUBST
+		case CTLTOPROC:
+		case CTLFROMPROC:
+#endif
 		case CTLBACKQ:
-			expbackq(argbackq->n, flag | inquotes);
+			expbackq(argbackq->n, flag | inquotes IF_BASH_PROCESS_SUBST(, c));
 			goto start;
 #if ENABLE_FEATURE_SH_MATH
 		case CTLARI:
@@ -6866,7 +6970,8 @@ scanright(char *startp, char *rmesc, cha
 	 * Logic:
 	 * loc starts at NUL at the end of startp, loc2 starts at the end of rmesc,
 	 * and on each iteration they go back two/one char until they reach the beginning.
-	 * We try to find a match in "raw_value_of_v", "raw_value_of_", "raw_value_of" etc.
+	 * We try to match "raw_value_of_v", "raw_value_of_", "raw_value_of" etc.
+	 * If one of these matches, return pointer past last matched char in startp.
 	 */
 	/* TODO: document in what other circumstances we are called. */
 
@@ -7154,6 +7259,7 @@ subevalvar(char *start, char *str, int s
 #if BASH_PATTERN_SUBST
 	workloc = expdest - (char *)stackblock();
 	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
+		size_t no_meta_len;
 		int len;
 		char *idx, *end;
 
@@ -7171,17 +7277,44 @@ subevalvar(char *start, char *str, int s
 		if (str[0] == '\0')
 			goto out1;
 
+		no_meta_len = (ENABLE_ASH_OPTIMIZE_FOR_SIZE || strpbrk(str, "*?[\\")) ? 0 : strlen(str);
 		len = 0;
 		idx = startp;
 		end = str - 1;
-		while (idx < end) {
+		while (idx <= end) {
  try_to_match:
-			loc = scanright(idx, rmesc, rmescend, str, quotes, 1);
+			if (no_meta_len == 0) {
+				/* pattern has meta chars, have to glob; or ENABLE_ASH_OPTIMIZE_FOR_SIZE */
+				loc = scanright(idx, rmesc, rmescend, str, quotes, /*match_at_start:*/ 1);
+			} else {
+				/* Testcase for very slow replace (performs about 22k replaces):
+				 * x=::::::::::::::::::::::
+				 * x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;echo ${#x}
+				 * echo "${x//:/|}"
+				 */
+				if (strncmp(rmesc, str, no_meta_len) != 0)
+					goto no_match;
+				loc = idx;
+				if (!quotes) {
+					loc += no_meta_len;
+				} else {
+					size_t n = no_meta_len;
+					do {
+						if ((unsigned char)*loc == CTLESC)
+							loc++;
+						loc++;
+					} while (--n != 0);
+				}
+			}
 			//bb_error_msg("scanright('%s'):'%s'", str, loc);
 			if (!loc) {
+				char *restart_detect;
+ no_match:
 				/* No match, advance */
-				char *restart_detect = stackblock();
+				restart_detect = stackblock();
  skip_matching:
+				if (idx >= end)
+					break;
 				STPUTC(*idx, expdest);
 				if (quotes && (unsigned char)*idx == CTLESC) {
 					idx++;
@@ -7194,8 +7327,6 @@ subevalvar(char *start, char *str, int s
 				len++;
 				rmesc++;
 				/* continue; - prone to quadratic behavior, smarter code: */
-				if (idx >= end)
-					break;
 				if (str[0] == '*') {
 					/* Pattern is "*foo". If "*foo" does not match "long_string",
 					 * it would never match "ong_string" etc, no point in trying.
@@ -11372,10 +11503,10 @@ static void FAST_FUNC
 change_epoch(struct var *vepoch, const char *fmt)
 {
 	struct timeval tv;
-	char buffer[sizeof("%lu.nnnnnn") + sizeof(long)*3];
+	char buffer[sizeof("%llu.nnnnnn") + sizeof(long long)*3];
 
-	gettimeofday(&tv, NULL);
-	sprintf(buffer, fmt, (unsigned long)tv.tv_sec, (unsigned)tv.tv_usec);
+	xgettimeofday(&tv);
+	sprintf(buffer, fmt, (unsigned long long)tv.tv_sec, (unsigned)tv.tv_usec);
 	setvar(vepoch->var_text, buffer, VNOFUNC);
 	vepoch->flags &= ~VNOFUNC;
 }
@@ -11383,13 +11514,13 @@ change_epoch(struct var *vepoch, const c
 static void FAST_FUNC
 change_seconds(const char *value UNUSED_PARAM)
 {
-	change_epoch(&vepochs, "%lu");
+	change_epoch(&vepochs, "%llu");
 }
 
 static void FAST_FUNC
 change_realtime(const char *value UNUSED_PARAM)
 {
-	change_epoch(&vepochr, "%lu.%06u");
+	change_epoch(&vepochr, "%llu.%06u");
 }
 #endif
 
@@ -12196,8 +12327,9 @@ realeofmark(const char *eofmark)
 #define CHECKEND()      {goto checkend; checkend_return:;}
 #define PARSEREDIR()    {goto parseredir; parseredir_return:;}
 #define PARSESUB()      {goto parsesub; parsesub_return:;}
-#define PARSEBACKQOLD() {oldstyle = 1; goto parsebackq; parsebackq_oldreturn:;}
-#define PARSEBACKQNEW() {oldstyle = 0; goto parsebackq; parsebackq_newreturn:;}
+#define PARSEBACKQOLD() {style = OLD; goto parsebackq; parsebackq_oldreturn:;}
+#define PARSEBACKQNEW() {style = NEW; goto parsebackq; parsebackq_newreturn:;}
+#define PARSEPROCSUB()  {style = PSUB; goto parsebackq; parsebackq_psreturn:;}
 #define PARSEARITH()    {goto parsearith; parsearith_return:;}
 static int
 readtoken1(int c, int syntax, char *eofmark, int striptabs)
@@ -12208,7 +12340,9 @@ readtoken1(int c, int syntax, char *eofm
 	size_t len;
 	struct nodelist *bqlist;
 	smallint quotef;
-	smallint oldstyle;
+	smallint style;
+	enum { OLD, NEW, PSUB };
+#define oldstyle (style == OLD)
 	smallint pssyntax;   /* we are expanding a prompt string */
 	IF_BASH_DOLLAR_SQUOTE(smallint bash_dollar_squote = 0;)
 	/* syntax stack */
@@ -12390,6 +12524,15 @@ readtoken1(int c, int syntax, char *eofm
 					pungetc();
 				}
 #endif
+#if BASH_PROCESS_SUBST
+				if (c == '<' || c == '>') {
+					if (pgetc() == '(') {
+						PARSEPROCSUB();
+						break;
+					}
+					pungetc();
+				}
+#endif
 				goto endword;   /* exit outer loop */
 			}
 			IF_ASH_ALIAS(if (c != PEOA))
@@ -12635,7 +12778,7 @@ parsesub: {
 			do {
 				STPUTC(c, out);
 				c = pgetc_eatbnl();
-			} while (!subtype && isdigit(c));
+			} while ((subtype == 0 || subtype == VSLENGTH) && isdigit(c));
 		} else if (c != '}') {
 			/* $[{[#]]<specialchar>[}] */
 			int cc = c;
@@ -12665,11 +12808,6 @@ parsesub: {
 		} else
 			goto badsub;
 
-		if (c != '}' && subtype == VSLENGTH) {
-			/* ${#VAR didn't end with } */
-			goto badsub;
-		}
-
 		if (subtype == 0) {
 			static const char types[] ALIGN1 = "}-+?=";
 			/* ${VAR...} but not $VAR or ${#VAR} */
@@ -12726,6 +12864,8 @@ parsesub: {
 #endif
 			}
 		} else {
+			if (subtype == VSLENGTH && c != '}')
+				subtype = 0;
  badsub:
 			pungetc();
 		}
@@ -12874,9 +13014,18 @@ parsebackq: {
 		memcpy(out, str, savelen);
 		STADJUST(savelen, out);
 	}
-	USTPUTC(CTLBACKQ, out);
+#if BASH_PROCESS_SUBST
+	if (style == PSUB)
+		USTPUTC(c == '<' ? CTLFROMPROC : CTLTOPROC, out);
+	else
+#endif
+		USTPUTC(CTLBACKQ, out);
 	if (oldstyle)
 		goto parsebackq_oldreturn;
+#if BASH_PROCESS_SUBST
+	else if (style == PSUB)
+		goto parsebackq_psreturn;
+#endif
 	goto parsebackq_newreturn;
 }
 
@@ -13328,6 +13477,9 @@ cmdloop(int top)
 		if (doing_jobctl)
 			showjobs(SHOW_CHANGED|SHOW_STDERR);
 #endif
+#if BASH_PROCESS_SUBST
+		unwindredir(NULL);
+#endif
 		inter = 0;
 		if (iflag && top) {
 			inter++;
@@ -14033,6 +14185,10 @@ readcmd(int argc UNUSED_PARAM, char **ar
 		}
 	}
 
+	if (!ENABLE_ASH_BASH_COMPAT && !argptr) {
+		bb_simple_error_msg("read: need variable name");
+		return 1;
+	}
 	params.argv = argptr;
 	params.setvar = setvar0;
 	params.ifs = bltinlookup("IFS"); /* can be NULL */
@@ -14266,7 +14422,8 @@ init(void)
 
 
 //usage:#define ash_trivial_usage
-//usage:	"[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]"
+//usage:	"[-il] [-|+Cabefmnuvx] [-|+o OPT]... [-c 'SCRIPT' [ARG0 ARGS] | FILE [ARGS] | -s [ARGS]]"
+////////	comes from ^^^^^^^^^^optletters
 //usage:#define ash_full_usage "\n\n"
 //usage:	"Unix shell interpreter"
 
@@ -14313,9 +14470,9 @@ procargs(char **argv)
 	}
 	if (mflag == 2)
 		mflag = iflag;
+	/* Unset options which weren't explicitly set or unset */
 	for (i = 0; i < NOPTS; i++)
-		if (optlist[i] == 2)
-			optlist[i] = 0;
+		optlist[i] &= 1; /* same effect as "if (optlist[i] == 2) optlist[i] = 0;" */
 #if DEBUG == 2
 	debug = 1;
 #endif
diff -urpN busybox-1.33.1/shell/ash_remove_unnecessary_code_in_backquote_expansion.patch busybox-1.34.0/shell/ash_remove_unnecessary_code_in_backquote_expansion.patch
--- busybox-1.33.1/shell/ash_remove_unnecessary_code_in_backquote_expansion.patch	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_remove_unnecessary_code_in_backquote_expansion.patch	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,135 @@
+From: Herbert Xu <herbert@xxxxxxxxxxxxxxxxxxx>
+Date: Thu, 19 Apr 2018 18:16:12 +0800
+
+> ash originally had support for omitting the fork when expanding a
+> builtin in backquotes.  dash has gradually been removing this support,
+> most recently in commit 66b614e29038e31745c4a5d296f64f8d64f5c377
+> ("[EVAL] Remove unused EV_BACKCMD flag").
+>
+> Some traces still remain, however.  Remove:
+>
+> - the buf and nleft elements of the backcmd structure;
+> - a misleading comment regarding handling of builtins.
+>
+> Signed-off-by: Ron Yorston <rmy@xxxxxxxxxxxx>
+
+Unfortunately we may need this at some point in the future due
+to changes in POSIX.  So let's keep it around for now until we
+get things such as `jobs -p` to work.
+
+*************************************
+
+From: Ron Yorston <rmy@xxxxxxxxxxxx>
+Date: Thu, 19 Apr 2018 17:18:47 +0100
+
+>Unfortunately we may need this at some point in the future due
+>to changes in POSIX.  So let's keep it around for now until we
+>get things such as `jobs -p` to work.
+
+As you wish.
+
+Something even more trivial I noticed later:  the TRACE at the end of
+expbackq incorrectly refers to the function as evalbackq.
+
+*************************************
+
+Date: Tue, 10 Apr 2018 13:23:35 +0100
+From: Ron Yorston <rmy@pobox.com>
+To: busybox@busybox.net
+Subject: [PATCH] ash: remove unnecessary code in backquote expansion
+
+Some traces remain of ash's ancient support for omitting the fork when
+expanding a builtin command in backquotes.
+
+Remove:
+
+- the buf and nleft elements of the backcmd structure;
+- a misleading comment regarding handling of builtins.
+
+I've submitted a similar patch to dash.
+
+Signed-off-by: Ron Yorston <rmy@pobox.com>
+---
+ shell/ash.c | 37 +++++++++----------------------------
+ 1 file changed, 9 insertions(+), 28 deletions(-)
+
+diff --git a/shell/ash.c b/shell/ash.c
+index 45c747dbc..6f1458722 100644
+--- a/shell/ash.c
++++ b/shell/ash.c
+@@ -6356,15 +6356,12 @@ exptilde(char *startp, char *p, int flags)
+ }
+ 
+ /*
+- * Execute a command inside back quotes.  If it's a builtin command, we
+- * want to save its output in a block obtained from malloc.  Otherwise
+- * we fork off a subprocess and get the output of the command via a pipe.
+- * Should be called with interrupts off.
++ * Execute a command inside back quotes.  We fork off a subprocess and
++ * get the output of the command via a pipe.  Should be called with
++ * interrupts off.
+  */
+ struct backcmd {                /* result of evalbackcmd */
+ 	int fd;                 /* file descriptor to read from */
+-	int nleft;              /* number of chars in buffer */
+-	char *buf;              /* buffer */
+ 	struct job *jp;         /* job structure for command */
+ };
+ 
+@@ -6394,8 +6391,6 @@ evalbackcmd(union node *n, struct backcmd *result)
+ 	struct job *jp;
+ 
+ 	result->fd = -1;
+-	result->buf = NULL;
+-	result->nleft = 0;
+ 	result->jp = NULL;
+ 	if (n == NULL) {
+ 		goto out;
+@@ -6432,8 +6427,7 @@ evalbackcmd(union node *n, struct backcmd *result)
+ 	result->jp = jp;
+ 
+  out:
+-	TRACE(("evalbackcmd done: fd=%d buf=0x%x nleft=%d jp=0x%x\n",
+-		result->fd, result->buf, result->nleft, result->jp));
++	TRACE(("evalbackcmd done: fd=%d jp=0x%x\n", result->fd, result->jp));
+ }
+ 
+ /*
+@@ -6445,7 +6439,6 @@ expbackq(union node *cmd, int flag)
+ 	struct backcmd in;
+ 	int i;
+ 	char buf[128];
+-	char *p;
+ 	char *dest;
+ 	int startloc;
+ 	int syntax = flag & EXP_QUOTED ? DQSYNTAX : BASESYNTAX;
+@@ -6457,24 +6450,12 @@ expbackq(union node *cmd, int flag)
+ 	evalbackcmd(cmd, &in);
+ 	popstackmark(&smark);
+ 
+-	p = in.buf;
+-	i = in.nleft;
+-	if (i == 0)
+-		goto read;
+-	for (;;) {
+-		memtodest(p, i, syntax, flag & QUOTES_ESC);
+- read:
+-		if (in.fd < 0)
+-			break;
+-		i = nonblock_immune_read(in.fd, buf, sizeof(buf));
+-		TRACE(("expbackq: read returns %d\n", i));
+-		if (i <= 0)
+-			break;
+-		p = buf;
+-	}
+-
+-	free(in.buf);
+ 	if (in.fd >= 0) {
++		while ((i = nonblock_immune_read(in.fd, buf, sizeof(buf))) > 0) {
++			TRACE(("expbackq: read returns %d\n", i));
++			memtodest(buf, i, syntax, flag & QUOTES_ESC);
++		}
++
+ 		close(in.fd);
+ 		back_exitstatus = waitforjob(in.jp);
+ 	}
diff -urpN busybox-1.33.1/shell/ash_test/ash-misc/control_char3.right busybox-1.34.0/shell/ash_test/ash-misc/control_char3.right
--- busybox-1.33.1/shell/ash_test/ash-misc/control_char3.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-misc/control_char3.right	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1 @@
+SHELL: line 1: : not found
diff -urpN busybox-1.33.1/shell/ash_test/ash-misc/control_char3.tests busybox-1.34.0/shell/ash_test/ash-misc/control_char3.tests
--- busybox-1.33.1/shell/ash_test/ash-misc/control_char3.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-misc/control_char3.tests	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,2 @@
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+$THIS_SH -c '\' SHELL
diff -urpN busybox-1.33.1/shell/ash_test/ash-misc/control_char4.right busybox-1.34.0/shell/ash_test/ash-misc/control_char4.right
--- busybox-1.33.1/shell/ash_test/ash-misc/control_char4.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-misc/control_char4.right	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1 @@
+SHELL: line 1: -: not found
diff -urpN busybox-1.33.1/shell/ash_test/ash-misc/control_char4.tests busybox-1.34.0/shell/ash_test/ash-misc/control_char4.tests
--- busybox-1.33.1/shell/ash_test/ash-misc/control_char4.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-misc/control_char4.tests	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,2 @@
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+$THIS_SH -c '"-"' SHELL
diff -urpN busybox-1.33.1/shell/ash_test/ash-parsing/bkslash_newline4.right busybox-1.34.0/shell/ash_test/ash-parsing/bkslash_newline4.right
--- busybox-1.33.1/shell/ash_test/ash-parsing/bkslash_newline4.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-parsing/bkslash_newline4.right	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,4 @@
+1:1
+22:22
+3:3
+Ok:0
diff -urpN busybox-1.33.1/shell/ash_test/ash-parsing/bkslash_newline4.tests busybox-1.34.0/shell/ash_test/ash-parsing/bkslash_newline4.tests
--- busybox-1.33.1/shell/ash_test/ash-parsing/bkslash_newline4.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-parsing/bkslash_newline4.tests	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,14 @@
+set -- 1 22 333
+echo 1:$\
+1
+echo 22:$\
+{\
+2\
+}
+echo 3:$\
+{\
+#\
+3\
+}
+echo Ok:$\
+?
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/bash_procsub.right busybox-1.34.0/shell/ash_test/ash-psubst/bash_procsub.right
--- busybox-1.33.1/shell/ash_test/ash-psubst/bash_procsub.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/bash_procsub.right	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,9 @@
+hello 1
+hello 2
+hello 3
+<(echo "hello 0")
+hello 4
+HI THERE
+hello error
+hello error
+hello stderr
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/bash_procsub.tests busybox-1.34.0/shell/ash_test/ash-psubst/bash_procsub.tests
--- busybox-1.33.1/shell/ash_test/ash-psubst/bash_procsub.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/bash_procsub.tests	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,33 @@
+# simplest case
+cat <(echo "hello 1")
+
+# can have more than one
+cat <(echo "hello 2") <(echo "hello 3")
+
+# doesn't work in quotes
+echo "<(echo \"hello 0\")"
+
+# process substitution can be nested inside command substitution
+echo $(cat <(echo "hello 4"))
+
+# example from http://wiki.bash-hackers.org/syntax/expansion/proc_subst
+# process substitutions can be passed to a function as parameters or
+# variables
+f() {
+	cat "$1" >"$x"
+}
+x=>(tr '[:lower:]' '[:upper:]') f <(echo 'hi there')
+
+# process substitution can be combined with redirection on exec
+rm -f err
+# save stderr
+exec 4>&2
+# copy stderr to a file
+exec 2> >(tee err)
+echo "hello error" >&2
+sync
+# restore stderr
+exec 2>&4
+cat err
+rm -f err
+echo "hello stderr" >&2
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/falsetick.right busybox-1.34.0/shell/ash_test/ash-psubst/falsetick.right
--- busybox-1.33.1/shell/ash_test/ash-psubst/falsetick.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/falsetick.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,24 @@
+0
+0
+0
+0
+2
+2
+2
+2
+./falsetick.tests: line 12: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 13: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 14: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 15: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 16: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 17: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 18: can't create /does/not/exist: nonexistent directory
+1
+./falsetick.tests: line 19: can't create /does/not/exist: nonexistent directory
+1
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/falsetick.tests busybox-1.34.0/shell/ash_test/ash-psubst/falsetick.tests
--- busybox-1.33.1/shell/ash_test/ash-psubst/falsetick.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/falsetick.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,19 @@
+# Exitcode 0 (`` has no exitcode, but assignment has):
+true;  a=``; echo $?
+false; a=``; echo $?
+true;  a=$(); echo $?
+false; a=$(); echo $?
+# Exitcode 2 (`cmd` expansion sets exitcode after assignment set it to 0):
+true;  a=`exit 2`; echo $?
+false; a=`exit 2`; echo $?
+true;  a=$(exit 2); echo $?
+false; a=$(exit 2); echo $?
+# Exitcode 1 (redirect sets exitcode to 1 on error after them):
+true;  a=`` >/does/not/exist; echo $?
+false; a=`` >/does/not/exist; echo $?
+true;  a=$() >/does/not/exist; echo $?
+false; a=$() >/does/not/exist; echo $?
+true;  a=`exit 2` >/does/not/exist; echo $?
+false; a=`exit 2` >/does/not/exist; echo $?
+true;  a=$(exit 2) >/does/not/exist; echo $?
+false; a=$(exit 2) >/does/not/exist; echo $?
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/falsetick2.right busybox-1.34.0/shell/ash_test/ash-psubst/falsetick2.right
--- busybox-1.33.1/shell/ash_test/ash-psubst/falsetick2.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/falsetick2.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1 @@
+Two:2 v:[]
diff -urpN busybox-1.33.1/shell/ash_test/ash-psubst/falsetick2.tests busybox-1.34.0/shell/ash_test/ash-psubst/falsetick2.tests
--- busybox-1.33.1/shell/ash_test/ash-psubst/falsetick2.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-psubst/falsetick2.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,3 @@
+v=v
+v=`exit 2` `false`
+echo Two:$? v:"[$v]"
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var6.right busybox-1.34.0/shell/ash_test/ash-vars/var6.right
--- busybox-1.33.1/shell/ash_test/ash-vars/var6.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var6.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,2 @@
+SHELL: line 1: syntax error: bad substitution
+SHELL: line 1: syntax error: bad substitution
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var6.tests busybox-1.34.0/shell/ash_test/ash-vars/var6.tests
--- busybox-1.33.1/shell/ash_test/ash-vars/var6.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var6.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,5 @@
+# reject invalid vars
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+"$THIS_SH" -c 'echo ${1q}' SHELL
+"$THIS_SH" -c 'echo ${&}' SHELL
+#"$THIS_SH" -c 'echo ${$}' SHELL -- this is valid as it's the same as $$
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var_bash_repl_empty_var.right busybox-1.34.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.right
--- busybox-1.33.1/shell/ash_test/ash-vars/var_bash_repl_empty_var.right	2021-05-04 01:06:49.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var_bash_repl_empty_var.right	2021-04-15 00:05:01.000000000 +0700
@@ -1,3 +1,3 @@
 
-
+w
 Ok:0
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var_nested1.right busybox-1.34.0/shell/ash_test/ash-vars/var_nested1.right
--- busybox-1.33.1/shell/ash_test/ash-vars/var_nested1.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var_nested1.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,3 @@
+Expected:AB Actual:AB
+Expected:Ab Actual:Ab
+Expected:ab Actual:ab
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var_nested1.tests busybox-1.34.0/shell/ash_test/ash-vars/var_nested1.tests
--- busybox-1.33.1/shell/ash_test/ash-vars/var_nested1.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var_nested1.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,16 @@
+f() { a=A; b=B; }
+
+a=a
+b=b
+f
+echo Expected:AB Actual:$a$b
+
+a=a
+b=b
+b= f
+echo Expected:Ab Actual:$a$b
+
+a=a
+b=b
+a= b= f
+echo Expected:ab Actual:$a$b
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var_nested2.right busybox-1.34.0/shell/ash_test/ash-vars/var_nested2.right
--- busybox-1.33.1/shell/ash_test/ash-vars/var_nested2.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var_nested2.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1 @@
+aB
diff -urpN busybox-1.33.1/shell/ash_test/ash-vars/var_nested2.tests busybox-1.34.0/shell/ash_test/ash-vars/var_nested2.tests
--- busybox-1.33.1/shell/ash_test/ash-vars/var_nested2.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/ash_test/ash-vars/var_nested2.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,2 @@
+# the bug was easier to trigger in one-liner form
+a=a; b=b; f() { a=A; b=B; }; a= f; echo $a$b
diff -urpN busybox-1.33.1/shell/hush.c busybox-1.34.0/shell/hush.c
--- busybox-1.33.1/shell/hush.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/shell/hush.c	2021-08-16 01:44:35.000000000 +0700
@@ -127,11 +127,6 @@
 //config:	help
 //config:	Enable {abc,def} extension.
 //config:
-//config:config HUSH_LINENO_VAR
-//config:	bool "$LINENO variable"
-//config:	default y
-//config:	depends on HUSH_BASH_COMPAT
-//config:
 //config:config HUSH_BASH_SOURCE_CURDIR
 //config:	bool "'source' and '.' builtins search current directory after $PATH"
 //config:	default n   # do not encourage non-standard behavior
@@ -139,6 +134,11 @@
 //config:	help
 //config:	This is not compliant with standards. Avoid if possible.
 //config:
+//config:config HUSH_LINENO_VAR
+//config:	bool "$LINENO variable (bashism)"
+//config:	default y
+//config:	depends on SHELL_HUSH
+//config:
 //config:config HUSH_INTERACTIVE
 //config:	bool "Interactive mode"
 //config:	default y
@@ -339,7 +339,7 @@
  * therefore we don't show them either.
  */
 //usage:#define hush_trivial_usage
-//usage:	"[-enxl] [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]"
+//usage:	"[-enxl] [-c 'SCRIPT' [ARG0 ARGS] | FILE [ARGS] | -s [ARGS]]"
 //usage:#define hush_full_usage "\n\n"
 //usage:	"Unix shell interpreter"
 
@@ -384,6 +384,7 @@
 #define BASH_PATTERN_SUBST ENABLE_HUSH_BASH_COMPAT
 #define BASH_SUBSTR        ENABLE_HUSH_BASH_COMPAT
 #define BASH_SOURCE        ENABLE_HUSH_BASH_COMPAT
+#define BASH_DOLLAR_SQUOTE ENABLE_HUSH_BASH_COMPAT
 #define BASH_HOSTNAME_VAR  ENABLE_HUSH_BASH_COMPAT
 #define BASH_EPOCH_VARS    ENABLE_HUSH_BASH_COMPAT
 #define BASH_TEST2         (ENABLE_HUSH_BASH_COMPAT && ENABLE_HUSH_TEST)
@@ -1027,7 +1028,7 @@ struct globals {
 	struct sigaction sa;
 	char optstring_buf[sizeof("eixcs")];
 #if BASH_EPOCH_VARS
-	char epoch_buf[sizeof("%lu.nnnnnn") + sizeof(long)*3];
+	char epoch_buf[sizeof("%llu.nnnnnn") + sizeof(long long)*3];
 #endif
 #if ENABLE_FEATURE_EDITING
 	char user_input_buf[CONFIG_FEATURE_EDITING_MAX_LEN];
@@ -2277,13 +2278,13 @@ static const char* FAST_FUNC get_local_v
 	{
 		const char *fmt = NULL;
 		if (strcmp(name, "EPOCHSECONDS") == 0)
-			fmt = "%lu";
+			fmt = "%llu";
 		else if (strcmp(name, "EPOCHREALTIME") == 0)
-			fmt = "%lu.%06u";
+			fmt = "%llu.%06u";
 		if (fmt) {
 			struct timeval tv;
-			gettimeofday(&tv, NULL);
-			sprintf(G.epoch_buf, fmt, (unsigned long)tv.tv_sec,
+			xgettimeofday(&tv);
+			sprintf(G.epoch_buf, fmt, (unsigned long long)tv.tv_sec,
 					(unsigned)tv.tv_usec);
 			return G.epoch_buf;
 		}
@@ -2670,6 +2671,8 @@ static int get_user_input(struct in_str
 	}
 	if (r < 0) {
 		/* EOF/error detected */
+		/* ^D on interactive input goes to next line before exiting: */
+		write(STDOUT_FILENO, "\n", 1);
 		i->p = NULL;
 		i->peek_buf[0] = r = EOF;
 		return r;
@@ -2692,7 +2695,7 @@ static int get_user_input(struct in_str
 			 * Without check_and_run_traps, handler never runs.
 			 */
 			check_and_run_traps();
-			fputs(prompt_str, stdout);
+			fputs_stdout(prompt_str);
 			fflush_all();
 		}
 		r = hfgetc(i->file);
@@ -3694,9 +3697,10 @@ static void debug_print_tree(struct pipe
 
 	pin = 0;
 	while (pi) {
-		fdprintf(2, "%*spipe %d %sres_word=%s followup=%d %s\n",
+		fdprintf(2, "%*spipe %d #cmds:%d %sres_word=%s followup=%d %s\n",
 				lvl*2, "",
 				pin,
+				pi->num_cmds,
 				(IF_HAS_KEYWORDS(pi->pi_inverted ? "! " :) ""),
 				RES[pi->res_word],
 				pi->followup, PIPE[pi->followup]
@@ -3839,6 +3843,9 @@ static void done_pipe(struct parse_conte
 #endif
 		/* Replace all pipes in ctx with one newly created */
 		ctx->list_head = ctx->pipe = pi;
+		/* for cases like "cmd && &", do not be tricked by last command
+		 * being null - the entire {...} & is NOT null! */
+		not_null = 1;
 	} else {
  no_conv:
 		ctx->pipe->followup = type;
@@ -4249,7 +4256,7 @@ static int done_word(struct parse_contex
 		 || endofname(command->argv[0])[0] != '\0'
 		) {
 			/* bash says just "not a valid identifier" */
-			syntax_error("not a valid identifier in for");
+			syntax_error("bad variable name in for");
 			return 1;
 		}
 		/* Force FOR to have just one word (variable name) */
@@ -4913,6 +4920,101 @@ static int add_till_closing_bracket(o_st
 }
 #endif /* ENABLE_HUSH_TICK || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_DOLLAR_OPS */
 
+#if BASH_DOLLAR_SQUOTE
+/* Return code: 1 for "found and parsed", 0 for "seen something else" */
+# if BB_MMU
+#define parse_dollar_squote(as_string, dest, input) \
+	parse_dollar_squote(dest, input)
+#define as_string NULL
+# endif
+static int parse_dollar_squote(o_string *as_string, o_string *dest, struct in_str *input)
+{
+	int start;
+	int ch = i_peek_and_eat_bkslash_nl(input);  /* first character after the $ */
+	debug_printf_parse("parse_dollar_squote entered: ch='%c'\n", ch);
+	if (ch != '\'')
+		return 0;
+
+	dest->has_quoted_part = 1;
+	start = dest->length;
+
+	ch = i_getch(input); /* eat ' */
+	nommu_addchr(as_string, ch);
+	while (1) {
+		ch = i_getch(input);
+		nommu_addchr(as_string, ch);
+		if (ch == EOF) {
+			syntax_error_unterm_ch('\'');
+			return 0;
+		}
+		if (ch == '\'')
+			break;
+		if (ch == SPECIAL_VAR_SYMBOL) {
+			/* Convert raw ^C to corresponding special variable reference */
+			o_addchr(dest, SPECIAL_VAR_SYMBOL);
+			o_addchr(dest, SPECIAL_VAR_QUOTED_SVS);
+			/* will addchr() another SPECIAL_VAR_SYMBOL (see after the if() block) */
+		} else if (ch == '\\') {
+			static const char C_escapes[] ALIGN1 = "nrbtfav""x\\01234567";
+
+			ch = i_getch(input);
+			nommu_addchr(as_string, ch);
+			if (strchr(C_escapes, ch)) {
+				char buf[4];
+				char *p = buf;
+				int cnt = 2;
+
+				buf[0] = ch;
+				if ((unsigned char)(ch - '0') <= 7) { /* \ooo */
+					do {
+						ch = i_peek(input);
+						if ((unsigned char)(ch - '0') > 7)
+							break;
+						*++p = ch = i_getch(input);
+						nommu_addchr(as_string, ch);
+					} while (--cnt != 0);
+				} else if (ch == 'x') { /* \xHH */
+					do {
+						ch = i_peek(input);
+						if (!isxdigit(ch))
+							break;
+						*++p = ch = i_getch(input);
+						nommu_addchr(as_string, ch);
+					} while (--cnt != 0);
+					if (cnt == 2) { /* \x but next char is "bad" */
+						ch = 'x';
+						goto unrecognized;
+					}
+				} /* else simple seq like \\ or \t */
+				*++p = '\0';
+				p = buf;
+				ch = bb_process_escape_sequence((void*)&p);
+				//bb_error_msg("buf:'%s' ch:%x", buf, ch);
+				if (ch == '\0')
+					continue; /* bash compat: $'...\0...' emits nothing */
+			} else { /* unrecognized "\z": encode both chars unless ' or " */
+				if (ch != '\'' && ch != '"') {
+ unrecognized:
+					o_addqchr(dest, '\\');
+				}
+			}
+		} /* if (\...) */
+		o_addqchr(dest, ch);
+	}
+
+	if (dest->length == start) {
+		/* $'', $'\0', $'\000\x00' and the like */
+		o_addchr(dest, SPECIAL_VAR_SYMBOL);
+		o_addchr(dest, SPECIAL_VAR_SYMBOL);
+	}
+
+	return 1;
+# undef as_string
+}
+#else
+# define parse_dollar_squote(as_string, dest, input) 0
+#endif /* BASH_DOLLAR_SQUOTE */
+
 /* Return code: 0 for OK, 1 for syntax error */
 #if BB_MMU
 #define parse_dollar(as_string, dest, input, quote_mask) \
@@ -4925,7 +5027,7 @@ static int parse_dollar(o_string *as_str
 {
 	int ch = i_peek_and_eat_bkslash_nl(input);  /* first character after the $ */
 
-	debug_printf_parse("parse_dollar entered: ch='%c'\n", ch);
+	debug_printf_parse("parse_dollar entered: ch='%c' quote_mask:0x%x\n", ch, quote_mask);
 	if (isalpha(ch)) {
  make_var:
 		ch = i_getch(input);
@@ -4992,6 +5094,32 @@ static int parse_dollar(o_string *as_str
 		 * which check invalid constructs like ${%}.
 		 * Oh well... let's check that the var name part is fine... */
 
+		if (isdigit(len_single_ch)
+		 || (len_single_ch == '#' && isdigit(i_peek_and_eat_bkslash_nl(input)))
+		) {
+			/* Execution engine uses plain xatoi_positive()
+			 * to interpret ${NNN} and {#NNN},
+			 * check syntax here in the parser.
+			 * (bash does not support expressions in ${#NN},
+			 * e.g. ${#$var} and {#1:+WORD} are not supported).
+			 */
+			unsigned cnt = 9; /* max 9 digits for ${NN} and 8 for {#NN} */
+			while (1) {
+				o_addchr(dest, ch);
+				debug_printf_parse(": '%c'\n", ch);
+				ch = i_getch_and_eat_bkslash_nl(input);
+				nommu_addchr(as_string, ch);
+				if (ch == '}')
+					break;
+				if (--cnt == 0)
+					goto bad_dollar_syntax;
+				if (len_single_ch != '#' && strchr(VAR_SUBST_OPS, ch))
+					/* ${NN<op>...} is valid */
+					goto eat_until_closing;
+				if (!isdigit(ch))
+					goto bad_dollar_syntax;
+			}
+		} else
 		while (1) {
 			unsigned pos;
 
@@ -5002,7 +5130,6 @@ static int parse_dollar(o_string *as_str
 			nommu_addchr(as_string, ch);
 			if (ch == '}')
 				break;
-
 			if (!isalnum(ch) && ch != '_') {
 				unsigned end_ch;
 				unsigned char last_ch;
@@ -5021,6 +5148,7 @@ static int parse_dollar(o_string *as_str
 					 * special var name, e.g. ${#!}.
 					 */
 				}
+ eat_until_closing:
 				/* Eat everything until closing '}' (or ':') */
 				end_ch = '}';
 				if (BASH_SUBSTR
@@ -5215,6 +5343,8 @@ static int encode_string(o_string *as_st
 		goto again;
 	}
 	if (ch == '$') {
+		//if (parse_dollar_squote(as_string, dest, input))
+		//	goto again;
 		if (!parse_dollar(as_string, dest, input, /*quote_mask:*/ 0x80)) {
 			debug_printf_parse("encode_string return 0: "
 					"parse_dollar returned 0 (error)\n");
@@ -5235,6 +5365,11 @@ static int encode_string(o_string *as_st
 	}
 #endif
 	o_addQchr(dest, ch);
+	if (ch == SPECIAL_VAR_SYMBOL) {
+		/* Convert "^C" to corresponding special variable reference */
+		o_addchr(dest, SPECIAL_VAR_QUOTED_SVS);
+		o_addchr(dest, SPECIAL_VAR_SYMBOL);
+	}
 	goto again;
 #undef as_string
 }
@@ -5346,6 +5481,11 @@ static struct pipe *parse_stream(char **
 			if (ch == '\n')
 				continue; /* drop \<newline>, get next char */
 			nommu_addchr(&ctx.as_string, '\\');
+			if (ch == SPECIAL_VAR_SYMBOL) {
+				nommu_addchr(&ctx.as_string, ch);
+				/* Convert \^C to corresponding special variable reference */
+				goto case_SPECIAL_VAR_SYMBOL;
+			}
 			o_addchr(&ctx.word, '\\');
 			if (ch == EOF) {
 				/* Testcase: eval 'echo Ok\' */
@@ -5670,6 +5810,7 @@ static struct pipe *parse_stream(char **
 		/* Note: nommu_addchr(&ctx.as_string, ch) is already done */
 
 		switch (ch) {
+		case_SPECIAL_VAR_SYMBOL:
 		case SPECIAL_VAR_SYMBOL:
 			/* Convert raw ^C to corresponding special variable reference */
 			o_addchr(&ctx.word, SPECIAL_VAR_SYMBOL);
@@ -5680,6 +5821,8 @@ static struct pipe *parse_stream(char **
 			o_addchr(&ctx.word, ch);
 			continue; /* get next char */
 		case '$':
+			if (parse_dollar_squote(&ctx.as_string, &ctx.word, input))
+				continue; /* get next char */
 			if (!parse_dollar(&ctx.as_string, &ctx.word, input, /*quote_mask:*/ 0)) {
 				debug_printf_parse("parse_stream parse error: "
 					"parse_dollar returned 0 (error)\n");
@@ -5807,7 +5950,6 @@ static struct pipe *parse_stream(char **
 			if (ctx.ctx_res_w == RES_MATCH)
 				goto case_semi;
 #endif
-
 		case '}':
 			/* proper use of this character is caught by end_trigger:
 			 * if we see {, we call parse_group(..., end_trigger='}')
@@ -6123,6 +6265,8 @@ static char *encode_then_expand_vararg(c
 			continue;
 		}
 		if (ch == '$') {
+			if (parse_dollar_squote(NULL, &dest, &input))
+				continue;
 			if (!parse_dollar(NULL, &dest, &input, /*quote_mask:*/ 0x80)) {
 				debug_printf_parse("%s: error: parse_dollar returned 0 (error)\n", __func__);
 				goto ret;
@@ -6322,6 +6466,18 @@ static arith_t expand_and_evaluate_arith
 /* ${var/[/]pattern[/repl]} helpers */
 static char *strstr_pattern(char *val, const char *pattern, int *size)
 {
+	int sz = strcspn(pattern, "*?[\\");
+	if (pattern[sz] == '\0') {
+		/* Optimization for trivial patterns.
+		 * Testcase for very slow replace (performs about 22k replaces):
+		 * x=::::::::::::::::::::::
+		 * x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;x=$x$x;echo ${#x}
+		 * echo "${x//:/|}"
+		 */
+		*size = sz;
+		return strstr(val, pattern);
+	}
+
 	while (1) {
 		char *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);
 		debug_printf_varexp("val:'%s' pattern:'%s' end:'%s'\n", val, pattern, end);
@@ -10163,7 +10319,8 @@ int hush_main(int argc, char **argv)
 	/* http://www.opengroup.org/onlinepubs/9699919799/utilities/sh.html */
 	flags = (argv[0] && argv[0][0] == '-') ? OPT_login : 0;
 	while (1) {
-		int opt = getopt(argc, argv, "+cexinsl"
+		int opt = getopt(argc, argv, "+" /* stop at 1st non-option */
+				"cexinsl"
 #if !BB_MMU
 				"<:$:R:V:"
 # if ENABLE_HUSH_FUNCTIONS
@@ -10255,12 +10412,13 @@ int hush_main(int argc, char **argv)
 		}
 # endif
 #endif
-		case 'n':
-		case 'x':
-		case 'e':
+		/*case '?': invalid option encountered (set_mode('?') will fail) */
+		/*case 'n':*/
+		/*case 'x':*/
+		/*case 'e':*/
+		default:
 			if (set_mode(1, opt, NULL) == 0) /* no error */
 				break;
-		default:
 			bb_show_usage();
 		}
 	} /* option parsing loop */
@@ -10795,10 +10953,17 @@ static int FAST_FUNC builtin_read(char *
 	 */
 	params.read_flags = getopt32(argv,
 # if BASH_READ_D
-		"!srn:p:t:u:d:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u, &params.opt_d
+		IF_NOT_HUSH_BASH_COMPAT("^")
+		"!srn:p:t:u:d:" IF_NOT_HUSH_BASH_COMPAT("\0" "-1"/*min 1 arg*/),
+		&params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u, &params.opt_d
 # else
-		"!srn:p:t:u:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u
-# endif
+		IF_NOT_HUSH_BASH_COMPAT("^")
+		"!srn:p:t:u:" IF_NOT_HUSH_BASH_COMPAT("\0" "-1"/*min 1 arg*/),
+		&params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u
+# endif
+//TODO: print "read: need variable name"
+//for the case of !BASH "read" with no args (now it fails silently)
+//(or maybe extend getopt32() to emit a message if "-1" fails)
 	);
 	if ((uint32_t)params.read_flags == (uint32_t)-1)
 		return EXIT_FAILURE;
diff -urpN busybox-1.33.1/shell/hush_test/hush-misc/control_char3.right busybox-1.34.0/shell/hush_test/hush-misc/control_char3.right
--- busybox-1.33.1/shell/hush_test/hush-misc/control_char3.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-misc/control_char3.right	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1 @@
+hush: can't execute '': No such file or directory
diff -urpN busybox-1.33.1/shell/hush_test/hush-misc/control_char3.tests busybox-1.34.0/shell/hush_test/hush-misc/control_char3.tests
--- busybox-1.33.1/shell/hush_test/hush-misc/control_char3.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-misc/control_char3.tests	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,2 @@
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+$THIS_SH -c '\' SHELL
diff -urpN busybox-1.33.1/shell/hush_test/hush-misc/control_char4.right busybox-1.34.0/shell/hush_test/hush-misc/control_char4.right
--- busybox-1.33.1/shell/hush_test/hush-misc/control_char4.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-misc/control_char4.right	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1 @@
+hush: can't execute '-': No such file or directory
diff -urpN busybox-1.33.1/shell/hush_test/hush-misc/control_char4.tests busybox-1.34.0/shell/hush_test/hush-misc/control_char4.tests
--- busybox-1.33.1/shell/hush_test/hush-misc/control_char4.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-misc/control_char4.tests	2021-06-16 17:02:16.000000000 +0700
@@ -0,0 +1,2 @@
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+$THIS_SH -c '"-"' SHELL
diff -urpN busybox-1.33.1/shell/hush_test/hush-parsing/bkslash_newline4.right busybox-1.34.0/shell/hush_test/hush-parsing/bkslash_newline4.right
--- busybox-1.33.1/shell/hush_test/hush-parsing/bkslash_newline4.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-parsing/bkslash_newline4.right	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,4 @@
+1:1
+22:22
+3:3
+Ok:0
diff -urpN busybox-1.33.1/shell/hush_test/hush-parsing/bkslash_newline4.tests busybox-1.34.0/shell/hush_test/hush-parsing/bkslash_newline4.tests
--- busybox-1.33.1/shell/hush_test/hush-parsing/bkslash_newline4.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-parsing/bkslash_newline4.tests	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,14 @@
+set -- 1 22 333
+echo 1:$\
+1
+echo 22:$\
+{\
+2\
+}
+echo 3:$\
+{\
+#\
+3\
+}
+echo Ok:$\
+?
diff -urpN busybox-1.33.1/shell/hush_test/hush-psubst/falsetick.right busybox-1.34.0/shell/hush_test/hush-psubst/falsetick.right
--- busybox-1.33.1/shell/hush_test/hush-psubst/falsetick.right	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-psubst/falsetick.right	2021-08-16 00:57:08.000000000 +0700
@@ -22,6 +22,3 @@ hush: can't open '/does/not/exist': No s
 1
 hush: can't open '/does/not/exist': No such file or directory
 1
-hush: can't open '/does/not/exist': No such file or directory
-1
-Done: a=b
diff -urpN busybox-1.33.1/shell/hush_test/hush-psubst/falsetick.tests busybox-1.34.0/shell/hush_test/hush-psubst/falsetick.tests
--- busybox-1.33.1/shell/hush_test/hush-psubst/falsetick.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-psubst/falsetick.tests	2021-08-16 00:57:08.000000000 +0700
@@ -17,6 +17,3 @@ true;  a=`exit 2` >/does/not/exist; echo
 false; a=`exit 2` >/does/not/exist; echo $?
 true;  a=$(exit 2) >/does/not/exist; echo $?
 false; a=$(exit 2) >/does/not/exist; echo $?
-# ...and assignment still happens despite redirect error:
-true;  a=$(echo b) >/does/not/exist; echo $?
-echo "Done: a=$a"
diff -urpN busybox-1.33.1/shell/hush_test/hush-psubst/falsetick3.right busybox-1.34.0/shell/hush_test/hush-psubst/falsetick3.right
--- busybox-1.33.1/shell/hush_test/hush-psubst/falsetick3.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-psubst/falsetick3.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,3 @@
+hush: can't open '/does/not/exist': No such file or directory
+1
+Done: a=b
diff -urpN busybox-1.33.1/shell/hush_test/hush-psubst/falsetick3.tests busybox-1.34.0/shell/hush_test/hush-psubst/falsetick3.tests
--- busybox-1.33.1/shell/hush_test/hush-psubst/falsetick3.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-psubst/falsetick3.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,3 @@
+# assignment still happens despite redirect error
+true;  a=$(echo b) >/does/not/exist; echo $?
+echo "Done: a=$a"
diff -urpN busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash1.right busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash1.right
--- busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash1.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash1.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,10 @@
+a	b
+$'a\tb'
+a
+b c
+def
+a'b c"d e\f
+a3b c3b e33f
+a\80b c08b
+a3b c30b
+x	y
diff -urpN busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash1.tests busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash1.tests
--- busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash1.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash1.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,8 @@
+echo $'a\tb'
+echo "$'a\tb'"
+echo $'a\nb' $'c\nd''ef'
+echo $'a\'b' $'c\"d' $'e\\f'
+echo $'a\63b' $'c\063b' $'e\0633f'
+echo $'a\80b' $'c\608b'
+echo $'a\x33b' $'c\x330b'
+echo $'x\x9y'
diff -urpN busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash2.right busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash2.right
--- busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash2.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash2.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,6 @@
+strstrstrstrstrstrstrstrstrstrstrstrstrstrstrstrstr
+strstrstrstrstrstrstrstrstrstrstrstrstrstrstrstrstr
+80:\
+81:\
+82:\
+Done:0
diff -urpN busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash2.tests busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash2.tests
--- busybox-1.33.1/shell/hush_test/hush-quoting/dollar_squote_bash2.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-quoting/dollar_squote_bash2.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1,10 @@
+# Embedded NULs
+echo $'str\x00'strstrstrstrstrstrstrstrstrstrstrstrstrstrstrstr
+echo $'str\000'strstrstrstrstrstrstrstrstrstrstrstrstrstrstrstr
+
+# The chars after '\' are hex 0x80,81,82...
+echo 80:$'\'
+echo 81:$'\'
+echo 82:$'\'
+
+echo Done:$?
diff -urpN busybox-1.33.1/shell/hush_test/hush-vars/var6.right busybox-1.34.0/shell/hush_test/hush-vars/var6.right
--- busybox-1.33.1/shell/hush_test/hush-vars/var6.right	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-vars/var6.right	2021-07-20 21:57:20.000000000 +0700
@@ -1,2 +1,2 @@
-hush: invalid number '1q'
+hush: syntax error: unterminated ${name}
 hush: syntax error: unterminated ${name}
diff -urpN busybox-1.33.1/shell/hush_test/hush-vars/var6.tests busybox-1.34.0/shell/hush_test/hush-vars/var6.tests
--- busybox-1.33.1/shell/hush_test/hush-vars/var6.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-vars/var6.tests	2021-08-16 00:57:08.000000000 +0700
@@ -1,4 +1,5 @@
 # reject invalid vars
-"$THIS_SH" -c 'echo ${1q}'
-"$THIS_SH" -c 'echo ${&}'
-#"$THIS_SH" -c 'echo ${$}' -- this is valid as it's the same as $$
+# (set argv0 to "SHELL" to avoid "/path/to/shell: blah" in error messages)
+"$THIS_SH" -c 'echo ${1q}' SHELL
+"$THIS_SH" -c 'echo ${&}' SHELL
+#"$THIS_SH" -c 'echo ${$}' SHELL -- this is valid as it's the same as $$
diff -urpN busybox-1.33.1/shell/hush_test/hush-vars/var_bash7.right busybox-1.34.0/shell/hush_test/hush-vars/var_bash7.right
--- busybox-1.33.1/shell/hush_test/hush-vars/var_bash7.right	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-vars/var_bash7.right	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1 @@
+B
diff -urpN busybox-1.33.1/shell/hush_test/hush-vars/var_bash7.tests busybox-1.34.0/shell/hush_test/hush-vars/var_bash7.tests
--- busybox-1.33.1/shell/hush_test/hush-vars/var_bash7.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/shell/hush_test/hush-vars/var_bash7.tests	2021-08-16 00:57:08.000000000 +0700
@@ -0,0 +1 @@
+x=AB; echo "${x#$'\x41'}"
diff -urpN busybox-1.33.1/shell/match.c busybox-1.34.0/shell/match.c
--- busybox-1.33.1/shell/match.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/match.c	2021-08-16 00:57:08.000000000 +0700
@@ -64,11 +64,10 @@ char* FAST_FUNC scan_and_match(char *str
 	}
 
 	while (loc != end) {
-		char c;
 		int r;
 
-		c = *loc;
 		if (flags & SCAN_MATCH_LEFT_HALF) {
+			char c = *loc;
 			*loc = '\0';
 			r = fnmatch(pattern, string, 0);
 			//bb_error_msg("fnmatch('%s','%s',0):%d", pattern, string, r);
diff -urpN busybox-1.33.1/shell/shell_common.c busybox-1.34.0/shell/shell_common.c
--- busybox-1.33.1/shell/shell_common.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/shell/shell_common.c	2021-06-16 17:02:16.000000000 +0700
@@ -59,7 +59,7 @@ shell_builtin_read(struct builtin_read_p
 	while (*pp) {
 		if (endofname(*pp)[0] != '\0') {
 			/* Mimic bash message */
-			bb_error_msg("read: '%s': not a valid identifier", *pp);
+			bb_error_msg("read: '%s': bad variable name", *pp);
 			return (const char *)(uintptr_t)1;
 		}
 		pp++;
@@ -230,7 +230,7 @@ shell_builtin_read(struct builtin_read_p
 		 * without variable names (bash compat).
 		 * Thus, "read" and "read REPLY" are not the same.
 		 */
-		if (!params->opt_d && argv[0]) {
+		if (argv[0]) {
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05 */
 			const char *is_ifs = strchr(ifs, c);
 			if (startword && is_ifs) {
diff -urpN busybox-1.33.1/sysklogd/klogd.c busybox-1.34.0/sysklogd/klogd.c
--- busybox-1.33.1/sysklogd/klogd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/sysklogd/klogd.c	2021-06-16 17:02:16.000000000 +0700
@@ -100,7 +100,7 @@ static void klogd_close(void)
 #else
 
 # ifndef _PATH_KLOG
-#  ifdef __GNU__
+#  if defined(__GNU__) || defined (__FreeBSD__)
 #   define _PATH_KLOG "/dev/klog"
 #  else
 #   error "your system's _PATH_KLOG is unknown"
@@ -226,7 +226,7 @@ int klogd_main(int argc UNUSED_PARAM, ch
 
 	signal(SIGHUP, SIG_IGN);
 	/* We want klogd_read to not be restarted, thus _norestart: */
-	bb_signals_recursive_norestart(BB_FATAL_SIGS, record_signo);
+	bb_signals_norestart(BB_FATAL_SIGS, record_signo);
 
 	syslog(LOG_NOTICE, "klogd started: %s", bb_banner);
 
diff -urpN busybox-1.33.1/sysklogd/logger.c busybox-1.34.0/sysklogd/logger.c
--- busybox-1.33.1/sysklogd/logger.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/sysklogd/logger.c	2021-06-16 17:02:16.000000000 +0700
@@ -26,7 +26,7 @@
 //usage:       "Write MESSAGE (or stdin) to syslog\n"
 //usage:     "\n	-s	Log to stderr as well as the system log"
 //usage:     "\n	-t TAG	Log using the specified tag (defaults to user name)"
-//usage:     "\n	-p PRIO	Priority (numeric or facility.level pair)"
+//usage:     "\n	-p PRIO	Priority (number or FACILITY.LEVEL pair)"
 //usage:
 //usage:#define logger_example_usage
 //usage:       "$ logger \"hello\"\n"
diff -urpN busybox-1.33.1/sysklogd/logread.c busybox-1.34.0/sysklogd/logread.c
--- busybox-1.33.1/sysklogd/logread.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/sysklogd/logread.c	2021-04-15 00:05:01.000000000 +0700
@@ -205,7 +205,7 @@ int logread_main(int argc UNUSED_PARAM,
 		cur = shbuf_tail;
 #else
 		while (cur != shbuf_tail) {
-			fputs(shbuf_data + cur, stdout);
+			fputs_stdout(shbuf_data + cur);
 			cur += strlen(shbuf_data + cur) + 1;
 			if (cur >= shbuf_size)
 				cur = 0;
@@ -217,7 +217,7 @@ int logread_main(int argc UNUSED_PARAM,
 
 #if ENABLE_FEATURE_LOGREAD_REDUCED_LOCKING
 		for (i = 0; i < len_total; i += strlen(copy + i) + 1) {
-			fputs(copy + i, stdout);
+			fputs_stdout(copy + i);
 		}
 		free(copy);
 #endif
diff -urpN busybox-1.33.1/sysklogd/syslogd.c busybox-1.34.0/sysklogd/syslogd.c
--- busybox-1.33.1/sysklogd/syslogd.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/sysklogd/syslogd.c	2021-01-08 15:30:27.000000000 +0700
@@ -842,7 +842,7 @@ static void timestamp_and_log(int pri, c
 #if ENABLE_FEATURE_SYSLOGD_PRECISE_TIMESTAMPS
 	if (!timestamp) {
 		struct timeval tv;
-		gettimeofday(&tv, NULL);
+		xgettimeofday(&tv);
 		now = tv.tv_sec;
 		timestamp = ctime(&now) + 4; /* skip day of week */
 		/* overwrite year by milliseconds, zero terminate */
diff -urpN busybox-1.33.1/testsuite/awk.tests busybox-1.34.0/testsuite/awk.tests
--- busybox-1.33.1/testsuite/awk.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/awk.tests	2021-08-19 20:02:34.000000000 +0700
@@ -45,6 +45,16 @@ testing "awk handles empty function f(ar
 	"" ""
 
 prg='
+function empty_fun(){}
+END {empty_fun()
+  print "Ok"
+}'
+testing "awk handles empty function f(){}" \
+	"awk '$prg'" \
+	"Ok\n" \
+	"" ""
+
+prg='
 function outer_fun() {
   return 1
 }
@@ -71,6 +81,23 @@ testing "awk properly handles undefined
 	"L1\n\nawk: cmd. line:5: Call to undefined function\n" \
 	"" ""
 
+prg='
+BEGIN {
+  v=1
+  a=2
+  print v (a)
+}'
+testing "awk 'v (a)' is not a function call, it is a concatenation" \
+	"awk '$prg' 2>&1" \
+	"12\n" \
+	"" ""
+
+prg='func f(){print"F"};func g(){print"G"};BEGIN{f(g(),g())}'
+testing "awk unused function args are evaluated" \
+	"awk '$prg' 2>&1" \
+	"G\nG\nF\n" \
+	"" ""
+
 
 optional DESKTOP
 testing "awk hex const 1" "awk '{ print or(0xffffffff,1) }'" "4294967295\n" "" "\n"
@@ -352,19 +379,14 @@ testing "awk -e and ARGC" \
 	""
 SKIP=
 
-# The examples are in fact not valid awk programs (break/continue
-# can only be used inside loops).
-# But we do accept them outside of loops.
-# We had a bug with misparsing "break ; else" sequence.
-# Test that *that* bug is fixed, using simplest possible scripts:
 testing "awk break" \
 	"awk -f - 2>&1; echo \$?" \
-	"0\n" \
+	"awk: -:1: 'break' not in a loop\n1\n" \
 	"" \
 	'BEGIN { if (1) break; else a = 1 }'
 testing "awk continue" \
 	"awk -f - 2>&1; echo \$?" \
-	"0\n" \
+	"awk: -:1: 'continue' not in a loop\n1\n" \
 	"" \
 	'BEGIN { if (1) continue; else a = 1 }'
 
@@ -383,6 +405,19 @@ testing "awk errors on missing delete ar
 	"awk -e '{delete}' 2>&1" "awk: cmd. line:1: Too few arguments\n" "" ""
 SKIP=
 
+optional FEATURE_AWK_GNU_EXTENSIONS
+testing "awk printf('%c') can output NUL" \
+	"awk '{printf(\"hello%c null\n\", 0)}'" "hello\0 null\n" "" "\n"
+SKIP=
+
+optional FEATURE_AWK_GNU_EXTENSIONS DESKTOP
+testing "awk printf('%-10c') can output NUL" \
+	"awk 'BEGIN { printf \"[%-10c]\n\", 0 }' | od -tx1" "\
+0000000 5b 00 20 20 20 20 20 20 20 20 20 5d 0a
+0000015
+" "" ""
+SKIP=
+
 # testing "description" "command" "result" "infile" "stdin"
 testing 'awk negative field access' \
 	'awk 2>&1 -- '\''{ $(-1) }'\' \
@@ -413,4 +448,19 @@ testing 'awk $NF is empty' \
 	'' \
 	'a=====123='
 
+testing "awk exit N propagates through END's exit" \
+	"awk 'BEGIN { exit 42 } END { exit }'; echo \$?" \
+	"42\n" \
+	'' ''
+
+testing "awk print + redirect" \
+	"awk 'BEGIN { print \"STDERR %s\" >\"/dev/stderr\" }' 2>&1" \
+	"STDERR %s\n" \
+	'' ''
+
+testing "awk \"cmd\" | getline" \
+	"awk 'BEGIN { \"echo HELLO\" | getline; print }'" \
+	"HELLO\n" \
+	'' ''
+
 exit $FAILCOUNT
diff -urpN busybox-1.33.1/testsuite/bc.tests busybox-1.34.0/testsuite/bc.tests
--- busybox-1.33.1/testsuite/bc.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/bc.tests	2021-04-15 00:05:01.000000000 +0700
@@ -182,6 +182,11 @@ testing "bc print 1,2,3" \
 	"123" \
 	"" "print 1,2,3"
 
+testing "bc length" \
+	"bc" \
+	"1\n3\n1\n3\n3\n" \
+	"" "length(0); length(100); length(0.01); length(0.00120); length(0.012-0.012);"
+
 testing "bc { print 1 }" \
 	"bc" \
 	"1" \
diff -urpN busybox-1.33.1/testsuite/cat.tests busybox-1.34.0/testsuite/cat.tests
--- busybox-1.33.1/testsuite/cat.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/cat.tests	2021-04-15 00:05:01.000000000 +0700
@@ -22,4 +22,28 @@ testing 'cat -v' \
 	'foo\n'
 SKIP=
 
+optional FEATURE_CATN
+testing 'cat -n' \
+	'cat -n' \
+"\
+     1	line 1
+     2	
+     3	line 3
+" \
+	'' \
+	'line 1\n\nline 3\n'
+SKIP=
+
+optional FEATURE_CATN
+testing 'cat -b' \
+	'cat -b' \
+"\
+     1	line 1
+
+     2	line 3
+" \
+	'' \
+	'line 1\n\nline 3\n'
+SKIP=
+
 exit $FAILCOUNT
diff -urpN busybox-1.33.1/testsuite/cut.tests busybox-1.34.0/testsuite/cut.tests
--- busybox-1.33.1/testsuite/cut.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/cut.tests	2021-08-16 01:44:35.000000000 +0700
@@ -15,4 +15,70 @@ testing "cut '-' (stdin) and multi file
 	"the quick brown fox\n" \
 	"jumps over the lazy dog\n" \
 
+abc="\
+one:two:three:four:five:six:seven
+alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
+the quick brown fox jumps over the lazy dog
+"
+
+testing "cut -b a,a,a" "cut -b 3,3,3 input" "e\np\ne\n" "$abc" ""
+
+testing "cut -b overlaps" "cut -b 1-3,2-5,7-9,9-10 input" \
+  "one:to:th\nalphabeta\nthe qick \n" "$abc" ""
+testing "-b encapsulated" "cut -b 3-8,4-6 input" "e:two:\npha:be\ne quic\n" \
+  "$abc" ""
+# --output-delimiter not implemnted (yet?)
+#testing "cut -bO overlaps" \
+#  "cut --output-delimiter ' ' -b 1-3,2-5,7-9,9-10 input" \
+#  "one:t o:th\nalpha beta\nthe q ick \n" "$abc" ""
+testing "cut high-low error" "cut -b 8-3 abc.txt 2>/dev/null || echo err" "err\n" \
+  "$abc" ""
+
+testing "cut -c a-b" "cut -c 4-10 input" ":two:th\nha:beta\n quick \n" "$abc" ""
+testing "cut -c a-" "cut -c 41- input" "\ntheta:iota:kappa:lambda:mu\ndog\n" "$abc" ""
+testing "cut -c -b" "cut -c -39 input" \
+  "one:two:three:four:five:six:seven\nalpha:beta:gamma:delta:epsilon:zeta:eta\nthe quick brown fox jumps over the lazy\n" \
+  "$abc" ""
+testing "cut -c a" "cut -c 40 input" "\n:\n \n" "$abc" ""
+testing "cut -c a,b-c,d" "cut -c 3,5-7,10 input" "etwoh\npa:ba\nequi \n" "$abc" ""
+
+testing "cut -f a-" "cut -d ':' -f 5- input" "five:six:seven\nepsilon:zeta:eta:theta:iota:kappa:lambda:mu\nthe quick brown fox jumps over the lazy dog\n" "$abc" ""
+
+testing "cut show whole line with no delim" "cut -d ' ' -f 3 input" \
+	"one:two:three:four:five:six:seven\nalpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu\nbrown\n" "$abc" ""
+
+testing "cut with echo, -c (a-b)" "echo 'ref_categorie=test' | cut -c 1-15 " "ref_categorie=t\n" "" ""
+testing "cut with echo, -c (a)" "echo 'ref_categorie=test' | cut -c 14" "=\n" "" ""
+
+testing "cut with -c (a,b,c)" "cut -c 4,5,20 input" "det\n" "abcdefghijklmnopqrstuvwxyz" ""
+
+testing "cut with -b (a,b,c)" "cut -b 4,5,20 input" "det\n" "abcdefghijklmnopqrstuvwxyz" ""
+
+input="\
+406378:Sales:Itorre:Jan
+031762:Marketing:Nasium:Jim
+636496:Research:Ancholie:Mel
+396082:Sales:Jucacion:Ed
+"
+testing "cut with -d -f(:) -s" "cut -d: -f3 -s input" "Itorre\nNasium\nAncholie\nJucacion\n" "$input" ""
+testing "cut with -d -f( ) -s" "cut -d' ' -f3 -s input && echo yes" "yes\n" "$input" ""
+testing "cut with -d -f(a) -s" "cut -da -f3 -s input" "n\nsium:Jim\n\ncion:Ed\n" "$input" ""
+testing "cut with -d -f(a) -s -n" "cut -da -f3 -s -n input" "n\nsium:Jim\n\ncion:Ed\n" "$input" ""
+
+# substitute for awk
+optional FEATURE_CUT_REGEX
+testing "cut -DF" "cut -DF 2,7,5" \
+  "said and your\nare\nis demand. supply\nforecast :\nyou you better,\n\nEm: Took hate\n" "" \
+"Bother, said Pooh. It's your husband, and he has a gun.
+Cheerios are donut seeds.
+Talk is cheap because supply exceeds demand.
+Weather forecast for tonight : dark.
+Apple: you can buy better, but you can't pay more.
+Subcalifragilisticexpialidocious.
+Auntie Em: Hate you, hate Kansas. Took the dog. Dorothy."
+SKIP=
+
+testing "cut empty field" "cut -d ':' -f 1-3" "a::b\n" "" "a::b\n"
+testing "cut empty field 2" "cut -d ':' -f 3-5" "b::c\n" "" "a::b::c:d\n"
+
 exit $FAILCOUNT
diff -urpN busybox-1.33.1/testsuite/dc.tests busybox-1.34.0/testsuite/dc.tests
--- busybox-1.33.1/testsuite/dc.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/dc.tests	2021-04-15 00:05:01.000000000 +0700
@@ -114,6 +114,11 @@ testing "dc newline can be a register" \
 	"2\n9\n" \
 	"" "[2p]s\n[3p]l\nx\n9p"
 
+testing "dc Z (length) for numbers" \
+	"dc" \
+	"1\n1\n3\n1\n3\n1\n" \
+	"" "0Zp\n0.000Zp\n100Zp\n0.01Zp\n0.00120Zp\n0.0012 0.0012 - Zp\n"
+
 for f in dc_*.dc; do
 	r="`basename "$f" .dc`_results.txt"
 	test -f "$r" || continue
diff -urpN busybox-1.33.1/testsuite/dc_add_results.txt busybox-1.34.0/testsuite/dc_add_results.txt
--- busybox-1.33.1/testsuite/dc_add_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_add_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -9,9 +9,9 @@
 1998
 324869359109479
 2378639108055453348401
-78562139406792834691802347619083467219846713490861872324967138636055\
-45508706362018540498696043776980521464405852627147161556994835657433\
-00967298
+785621394067928346918023476190834672198467134908618723249671386360554\
+550870636201854049869604377698052146440585262714716155699483565743300\
+967298
 1.1
 1.1
 37842935130118.1187478621432354
@@ -20,21 +20,21 @@
 -2
 -19
 -1287904651762470260258
-100000000000000000000000000000000000000000000000000000000000.0000000\
-00000000000000000000000000000000000000000000000000000000000000000000\
-000000000000000000000000000000000000000000000
-100000000000000000000000000000000000000000000000000000000000.0000000\
-00000000000000000000000000000000000000000000000000000000000000000000\
-000000000000000000000000000000000000000000000
-100000000000000000000000000000000000000000000000000000000000.0000000\
-00000000000000000000000000000000000000000000000000000000000000000000\
-000000000000000000000000000000000000000009999
-99999999999999999999999999999999999999999999999999999999999.99999999\
-99999999999999999999999999999999999999999999999999000000000000000000\
-00000000000000000000000000000000000000009999
-99999999999999999999999999999999999990000000000000000000000.00000000\
-00000000000000000000000000000000000000000000000000000000000000000000\
-00000000000000000000000000000000000000009999
+100000000000000000000000000000000000000000000000000000000000.00000000\
+000000000000000000000000000000000000000000000000000000000000000000000\
+0000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.00000000\
+000000000000000000000000000000000000000000000000000000000000000000000\
+0000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.00000000\
+000000000000000000000000000000000000000000000000000000000000000000000\
+0000000000000000000000000000000000000009999
+99999999999999999999999999999999999999999999999999999999999.999999999\
+999999999999999999999999999999999999999999999999900000000000000000000\
+000000000000000000000000000000000000009999
+99999999999999999999999999999999999990000000000000000000000.000000000\
+000000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000009999
 122761518
 -14338.391079082
 -2422295.6865057444
diff -urpN busybox-1.33.1/testsuite/dc_decimal_results.txt busybox-1.34.0/testsuite/dc_decimal_results.txt
--- busybox-1.33.1/testsuite/dc_decimal_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_decimal_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -9,19 +9,17 @@
 123
 7505
 1023468723275435238491972521917846
-43434724324317058673920735170382703980273527090273892739207390379379\
-60379637893607893607893670530278200795207952702873892786172916728961\
-78390789360741897358785738607967926792673752073092537298378279365279\
-3
+434347243243170586739207351703827039802735270902738927392073903793796\
+037963789360789360789367053027820079520795270287389278617291672896178\
+3907893607418973587857386079679267926737520730925372983782793652793
 -1
 -203
 -57
 -18586
 -31378682943772818461924738352952347258
--8239456287456735894950672387239865203756982376208346745096273452730\
-96287563846592384526349872634895763257893467523987578690283762897568\
-45907234875807107108781350187590812735901871502384171023987230138727\
-8
+-82394562874567358949506723872398652037569823762083467450962734527309\
+628756384659238452634987263489576325789346752398757869028376289756845\
+9072348758071071087813501875908127359018715023841710239872301387278
 .123521346523546
 .1245923756273856
 -.1024678456387
@@ -31,21 +29,21 @@
 234237468293576.000000000000000000000000000000
 23987623568943567.00000000000000000005677834650000000000000
 23856934568940675.000000000000000435676782300000000000000456784
-77567648698496.00000000000000000058767475000000000045856380000000000\
-0000
-2348672354968723.237482354600000000000325698739450234689243562387000\
-0000034578
+77567648698496.000000000000000000587674750000000000458563800000000000\
+000
+2348672354968723.2374823546000000000003256987394502346892435623870000\
+000034578
 -2354768.000000000000000000000000000000000000
 -96739874567.000000000347683456
 -3764568345.000000000004573845000000347683460
 -356784356.934568495770004586495678300000000
-74325437345273852773827101738273127312738521733017537073520735207307\
-570358738257390761276072160719802671980267018728630178.7082681027680\
-52176021786784127612768127086782782176817317820783071097801773817867\
-8012767377058785378278207385237085237803278203782037237582795870
--7567527327852738512737285378527382578372836789657385273852729836783\
-72867327835672967385278372637862738627836279863782673862783670.71738\
-17836173871836718637861073861783678160376017836701860376017810773527\
-8372832783728367826738627836278378260736270367362073867097307925
-9812734012837410982345719208345712908357412903587192048571920458712.\
-23957182459817249058172945781
+743254373452738527738271017382731273127385217330175370735207352073075\
+70358738257390761276072160719802671980267018728630178.708268102768052\
+176021786784127612768127086782782176817317820783071097801773817867801\
+2767377058785378278207385237085237803278203782037237582795870
+-75675273278527385127372853785273825783728367896573852738527298367837\
+2867327835672967385278372637862738627836279863782673862783670.7173817\
+836173871836718637861073861783678160376017836701860376017810773527837\
+2832783728367826738627836278378260736270367362073867097307925
+9812734012837410982345719208345712908357412903587192048571920458712.2\
+3957182459817249058172945781
diff -urpN busybox-1.33.1/testsuite/dc_divmod_results.txt busybox-1.34.0/testsuite/dc_divmod_results.txt
--- busybox-1.33.1/testsuite/dc_divmod_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_divmod_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -58,8 +58,8 @@
 100864416620775.31076855630746548983
 -53336.193401942302558132911110799109649707477
 .00000000052530099381
-.0000000000000000000000000000000000000000000000000000000000000001907\
-266929376630027064745963897
+.00000000000000000000000000000000000000000000000000000000000000019072\
+66929376630027064745963897
 42612515855353136519261264261472677699404182.78776061098893912189
 0
 0
@@ -121,6 +121,6 @@
 100864416620775
 -3878923750692883.7238596702834756902
 0
-.0000000000000000000000000000000000000000000184866017689020776005643\
-3621086
+.00000000000000000000000000000000000000000001848660176890207760056433\
+621086
 42612515855353136519261264261472677699404182
diff -urpN busybox-1.33.1/testsuite/dc_multiply_results.txt busybox-1.34.0/testsuite/dc_multiply_results.txt
--- busybox-1.33.1/testsuite/dc_multiply_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_multiply_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -15,8 +15,8 @@
 3543531533584430580556128344529291738
 568600835566479683035874339053.4411638427543228060
 7487566285885.8557453089005171423976251098
-373846412427291014394738378015501363938345620046.7869650248829232267\
-2297002026819
+373846412427291014394738378015501363938345620046.78696502488292322672\
+297002026819
 -1
 -2
 -2751507058396910892
diff -urpN busybox-1.33.1/testsuite/dc_power_results.txt busybox-1.34.0/testsuite/dc_power_results.txt
--- busybox-1.33.1/testsuite/dc_power_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_power_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -10,15 +10,15 @@
 18927361346
 .23523785962738592635777
 328956734869213746.89782398457234
-16473742664221279051571200630760751138799221376964991600670000200609\
-08006052596520320731708604393844468006290371918262741885989163144389\
-39367835091560809036359941703341471396407660150658436796925310445979\
-21333166245765946557344383284626113908419359990042883048537750217279\
-17481980123593363177308481941550382845381799410533956718500484099889\
-610805653325917409549921909941664118421333562129
+164737426642212790515712006307607511387992213769649916006700002006090\
+800605259652032073170860439384446800629037191826274188598916314438939\
+367835091560809036359941703341471396407660150658436796925310445979213\
+331662457659465573443832846261139084193599900428830485377502172791748\
+198012359336317730848194155038284538179941053395671850048409988961080\
+5653325917409549921909941664118421333562129
 0
-43287877285033571298394739716218787350087163435619825150259705419.98\
-016445740928054425
+43287877285033571298394739716218787350087163435619825150259705419.980\
+16445740928054425
 1.00000000000000000000
 .50000000000000000000
 .10000000000000000000
@@ -31,27 +31,27 @@
 1
 -2
 4
-14997322375665265051328725757939209353051902095893907150382724666290\
-49749481660976421019742616298227588464420182758442163654172400528243\
-00885441207762486233574213374503090372518590691583139696652847404883\
-08573912261119588874308960204159666762789603037188471170006223907416\
-60492840269152716750700089148882139254399347568222390231015487895905\
-73727080561379177721440905866857248917982113340543176658480139248897\
-54802503253413282808814063861470711399810899724515727713334909764746\
-27910290211411231279325882505708287941671508154740003122373284699097\
-78346501539634198926772266511968381368929692275950529960923432771985\
-12597189390708050983487158873301681237787429436264801751664042999180\
-3448659818912436089
-11478830555358864333472551120140548480416206583184496764727387456058\
-792742209537931243951391229607936
+149973223756652650513287257579392093530519020958939071503827246662904\
+974948166097642101974261629822758846442018275844216365417240052824300\
+885441207762486233574213374503090372518590691583139696652847404883085\
+739122611195888743089602041596667627896030371884711700062239074166049\
+284026915271675070008914888213925439934756822239023101548789590573727\
+080561379177721440905866857248917982113340543176658480139248897548025\
+032534132828088140638614707113998108997245157277133349097647462791029\
+021141123127932588250570828794167150815474000312237328469909778346501\
+539634198926772266511968381368929692275950529960923432771985125971893\
+907080509834871588733016812377874294362648017516640429991803448659818\
+912436089
+114788305553588643334725511201405484804162065831844967647273874560587\
+92742209537931243951391229607936
 -.00000000000000017759
--2067373624686414405470850679965010694114490999957199847684803894306\
-56243666149296582304582679590231948238805965642713928910384741502707\
-.23224479257866798694
-11606078892843496082360561256965139908586179418605021706789617179085\
-85768049299693425729565480314913006780973928345684673490252494674985\
-0186164225375953066263609289359900615361965737717208159874390.293769\
-70206344604971
+-20673736246864144054708506799650106941144909999571998476848038943065\
+6243666149296582304582679590231948238805965642713928910384741502707.2\
+3224479257866798694
+116060788928434960823605612569651399085861794186050217067896171790858\
+576804929969342572956548031491300678097392834568467349025249467498501\
+86164225375953066263609289359900615361965737717208159874390.293769702\
+06344604971
 -1.00000000000000000000
 1.00000000000000000000
 -.50000000000000000000
@@ -59,14 +59,14 @@
 0
 0
 -.00000000000002874159
--1945134149489344891879057554905782841936258356736314337975569799825\
-94091939572752348215929683891336730843553721422164737465108229034947\
-87333189564755763444242676978610321731298729194092653999616928308494\
-26419468484566422775668903315088810746121307679948574976162519479931\
-18935243698160094347216562490000767121041786977792546155155934655909\
-14123833869470494708767968978717730012864171105540029928688274136791\
-98175053824022144065005509214813689232148489884560100200475909009813\
-340098100705258138.98542904577525702068
+-19451341494893448918790575549057828419362583567363143379755697998259\
+409193957275234821592968389133673084355372142216473746510822903494787\
+333189564755763444242676978610321731298729194092653999616928308494264\
+194684845664227756689033150888107461213076799485749761625194799311893\
+524369816009434721656249000076712104178697779254615515593465590914123\
+833869470494708767968978717730012864171105540029928688274136791981750\
+538240221440650055092148136892321484898845601002004759090098133400981\
+00705258138.98542904577525702068
 0
 0
 0
diff -urpN busybox-1.33.1/testsuite/dc_subtract_results.txt busybox-1.34.0/testsuite/dc_subtract_results.txt
--- busybox-1.33.1/testsuite/dc_subtract_results.txt	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/testsuite/dc_subtract_results.txt	2021-01-08 15:30:27.000000000 +0700
@@ -8,15 +8,15 @@
 2874519803456326214611
 9000000000000000000000000000000000000001
 1
-9000000000000000000000000000000000000000.000000000000000000000000000\
-00000001
+9000000000000000000000000000000000000000.0000000000000000000000000000\
+0000001
 .0000000000000000000000000000000001
-9999999999999999999999999999999999999999.999999999999999999999999999\
+9999999999999999999999999999999999999999.9999999999999999999999999999\
+9999999999999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.999999999999999999999999999\
 99999999999999999999999999999999999999999999999999999999999
-10000000000000000000000000000000000000000.99999999999999999999999999\
-999999999999999999999999999999999999999999999999999999999999
-10000000000000000000000000000000000000000.00000000009999999999999999\
-99999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.000000000099999999999999999\
+9999999999999999999999999999999999999999999999999
 -8
 -182934721309467230894628759280719690
 1245723576605103923392087218483
diff -urpN busybox-1.33.1/testsuite/dd/dd-count-bytes busybox-1.34.0/testsuite/dd/dd-count-bytes
--- busybox-1.33.1/testsuite/dd/dd-count-bytes	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/testsuite/dd/dd-count-bytes	2021-08-16 04:01:54.000000000 +0700
@@ -0,0 +1,3 @@
+# FEATURE: CONFIG_FEATURE_DD_IBS_OBS
+
+test "$(echo I WANT | busybox dd count=3 iflag=count_bytes 2>/dev/null)" = "I W"
diff -urpN busybox-1.33.1/testsuite/mv/mv-files-to-dir-2 busybox-1.34.0/testsuite/mv/mv-files-to-dir-2
--- busybox-1.33.1/testsuite/mv/mv-files-to-dir-2	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/testsuite/mv/mv-files-to-dir-2	2021-07-20 21:57:20.000000000 +0700
@@ -0,0 +1,16 @@
+echo file number one > file1
+echo file number two > file2
+ln -s file2 link1
+mkdir dir1
+TZ=UTC0 touch -d '2000-01-30 05:24:08' dir1/file3
+mkdir there
+busybox mv -t there file1 file2 link1 dir1
+test -f there/file1
+test -f there/file2
+test -f there/dir1/file3
+test -L there/link1
+test xfile2 = x`readlink there/link1`
+test ! -e file1
+test ! -e file2
+test ! -e link1
+test ! -e dir1/file3
diff -urpN busybox-1.33.1/testsuite/nl.tests busybox-1.34.0/testsuite/nl.tests
--- busybox-1.33.1/testsuite/nl.tests	1970-01-01 07:00:00.000000000 +0700
+++ busybox-1.34.0/testsuite/nl.tests	2021-04-15 00:05:01.000000000 +0700
@@ -0,0 +1,39 @@
+#!/bin/sh
+# Copyright 2021 by Ron Yorston
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "test name" "commands" "expected result" "file input" "stdin"
+
+testing "nl numbers all lines" \
+	"nl -b a input" \
+"\
+     1	line 1
+     2	
+     3	line 3
+" \
+	"line 1\n\nline 3\n" \
+	""
+
+testing "nl numbers non-empty lines" \
+	"nl -b t input" \
+"\
+     1	line 1
+       
+     2	line 3
+" \
+	"line 1\n\nline 3\n" \
+	""
+
+testing "nl numbers no lines" \
+	"nl -b n input" \
+"\
+       line 1
+       
+       line 3
+" \
+	"line 1\n\nline 3\n" \
+	""
+
+exit $FAILCOUNT
diff -urpN busybox-1.33.1/testsuite/start-stop-daemon.tests busybox-1.34.0/testsuite/start-stop-daemon.tests
--- busybox-1.33.1/testsuite/start-stop-daemon.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/start-stop-daemon.tests	2021-04-15 00:05:01.000000000 +0700
@@ -21,8 +21,13 @@ testing "start-stop-daemon without -x an
 	"1\n" \
 	"" ""
 
+# This runs /bin/false with argv[0..2] of { "qwerty", "false", NULL }.
+#
 # Unfortunately, this does not actually check argv[0] correctness,
 # but at least it checks that pathname to exec() is correct
+#
+# NB: this fails if /bin/false is a busybox symlink:
+# busybox looks at argv[0] and says "qwerty: applet not found"
 testing "start-stop-daemon with both -x and -a" \
 	'start-stop-daemon -S -x /bin/false -a qwerty false 2>&1; echo $?' \
 	"1\n" \
diff -urpN busybox-1.33.1/testsuite/tar.tests busybox-1.34.0/testsuite/tar.tests
--- busybox-1.33.1/testsuite/tar.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/tar.tests	2021-08-19 20:02:34.000000000 +0700
@@ -3,6 +3,7 @@
 # Licensed under GPLv2, see file LICENSE in this source tree.
 
 . ./testing.sh
+test -f "$bindir/.config" && . "$bindir/.config"
 
 unset LANG
 unset LANGUAGE
@@ -12,7 +13,7 @@ umask 022
 
 # testing "test name" "script" "expected result" "file input" "stdin"
 
-testing "Empty file is not a tarball" '\
+testing "tar Empty file is not a tarball" '\
 tar xvf - 2>&1; echo $?
 ' "\
 tar: short read
@@ -25,7 +26,7 @@ optional FEATURE_SEAMLESS_GZ GUNZIP
 # In NOMMU case, "invalid magic" message comes from gunzip child process.
 # Otherwise, it comes from tar.
 # Need to fix output up to avoid false positive.
-testing "Empty file is not a tarball.tar.gz" '\
+testing "tar Empty file is not a tarball.tar.gz" '\
 { tar xvzf - 2>&1; echo $?; } | grep -Fv "invalid magic"
 ' "\
 tar: short read
@@ -34,7 +35,7 @@ tar: short read
 "" ""
 SKIP=
 
-testing "Two zeroed blocks is a ('truncated') empty tarball" '\
+testing "tar Two zeroed blocks is a ('truncated') empty tarball" '\
 dd if=/dev/zero bs=512 count=2 2>/dev/null | tar xvf - 2>&1; echo $?
 ' "\
 0
@@ -42,7 +43,7 @@ dd if=/dev/zero bs=512 count=2 2>/dev/nu
 "" ""
 SKIP=
 
-testing "Twenty zeroed blocks is an empty tarball" '\
+testing "tar Twenty zeroed blocks is an empty tarball" '\
 dd if=/dev/zero bs=512 count=20 2>/dev/null | tar xvf - 2>&1; echo $?
 ' "\
 0
@@ -313,9 +314,10 @@ l4/V8LDoe90yiWJhOJvIypgEfxdyRThQkBVn/bI=
 SKIP=
 cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+if test x"$CONFIG_UNICODE_USING_LOCALE" != x"y"; then
 mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional UNICODE_SUPPORT FEATURE_TAR_GNU_EXTENSIONS FEATURE_SEAMLESS_BZ2 FEATURE_TAR_AUTODETECT
-testing "Pax-encoded UTF8 names and symlinks" '\
+testing "tar Pax-encoded UTF8 names and symlinks" '\
 tar xvf ../tar.utf8.tar.bz2 2>&1; echo $?
 export LANG=en_US.UTF-8
 ls -l etc/ssl/certs/* | sed "s:.*etc/:etc/:" | sort
@@ -334,10 +336,11 @@ etc/ssl/certs/f80cc7f6.0 -> EBG_Elektron
 "" ""
 SKIP=
 cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
+fi
 
 mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional FEATURE_SEAMLESS_BZ2 FEATURE_TAR_AUTODETECT LS
-testing "Symlink attack: create symlink and then write through it" '\
+testing "tar Symlink attack: create symlink and then write through it" '\
 exec 2>&1
 uudecode -o input && tar xvf input; echo $?
 ls /tmp/bb_test_evilfile
@@ -367,7 +370,7 @@ cd .. || exit 1; rm -rf tar.tempdir 2>/d
 
 mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional FEATURE_TAR_CREATE
-testing "Symlinks and hardlinks coexist" '\
+testing "tar Symlinks and hardlinks coexist" '\
 mkdir dir
 >dir/a
 ln -s ../dir/a dir/b
diff -urpN busybox-1.33.1/testsuite/unlzma.tests busybox-1.34.0/testsuite/unlzma.tests
--- busybox-1.33.1/testsuite/unlzma.tests	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/testsuite/unlzma.tests	2021-06-16 17:02:16.000000000 +0700
@@ -8,14 +8,23 @@
 
 # Damaged encrypted streams
 testing "unlzma (bad archive 1)" \
-	"unlzma <unlzma_issue_1.lzma >/dev/null; echo \$?" \
-"1
+	"unlzma <unlzma_issue_1.lzma 2>&1 >/dev/null; echo \$?" \
+"unlzma: corrupted data
+1
 " "" ""
 
 # Damaged encrypted streams
 testing "unlzma (bad archive 2)" \
-	"unlzma <unlzma_issue_2.lzma >/dev/null; echo \$?" \
-"1
+	"unlzma <unlzma_issue_2.lzma 2>&1 >/dev/null; echo \$?" \
+"unlzma: corrupted data
+1
+" "" ""
+
+# Damaged encrypted streams
+testing "unlzma (bad archive 3)" \
+	"unlzma <unlzma_issue_3.lzma 2>&1 >/dev/null; echo \$?" \
+"unlzma: corrupted data
+1
 " "" ""
 
 exit $FAILCOUNT
Binary files busybox-1.33.1/testsuite/unlzma_issue_3.lzma and busybox-1.34.0/testsuite/unlzma_issue_3.lzma differ
diff -urpN busybox-1.33.1/util-linux/blockdev.c busybox-1.34.0/util-linux/blockdev.c
--- busybox-1.33.1/util-linux/blockdev.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/blockdev.c	2021-07-20 21:57:20.000000000 +0700
@@ -25,8 +25,11 @@
 //usage:     "\n	--getbsz	Get block size"
 //usage:     "\n	--setbsz BYTES	Set block size"
 //usage:     "\n	--getsz		Get device size in 512-byte sectors"
-/*//usage:     "\n	--getsize	Get device size in sectors (deprecated)"*/
+///////:     "\n	--getsize	Get device size in sectors (deprecated)"
+///////^^^^^ supported, but not shown in help ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 //usage:     "\n	--getsize64	Get device size in bytes"
+//usage:     "\n	--getra		Get readahead in 512-byte sectors"
+//usage:     "\n	--setra SECTORS	Set readahead"
 //usage:     "\n	--flushbufs	Flush buffers"
 //usage:     "\n	--rereadpt	Reread partition table"
 // util-linux 2.31 also has:
@@ -57,6 +60,9 @@ static const char bdcmd_names[] ALIGN1 =
 	"getsz"     "\0"
 	"getsize"   "\0"
 	"getsize64" "\0"
+	"getra"     "\0"
+	"setra"     "\0"
+#define CMD_SETRA 10
 	"flushbufs" "\0"
 	"rereadpt"  "\0"
 ;
@@ -70,6 +76,8 @@ static const uint32_t bdcmd_ioctl[] ALIG
 	BLKGETSIZE64,   //getsz
 	BLKGETSIZE,     //getsize
 	BLKGETSIZE64,   //getsize64
+	BLKRAGET,       //getra
+	BLKRASET,       //setra
 	BLKFLSBUF,      //flushbufs
 	BLKRRPART,      //rereadpt
 };
@@ -95,6 +103,8 @@ static const uint8_t bdcmd_flags[] ALIGN
 	ARG_U64 + FL_SCALE512,             //getsz
 	ARG_ULONG,                         //getsize
 	ARG_U64,                           //getsize64
+	ARG_ULONG,                         //getra
+	ARG_ULONG + FL_NORESULT,           //setra
 	ARG_NONE + FL_NORESULT,            //flushbufs
 	ARG_NONE + FL_NORESULT,            //rereadpt
 };
@@ -130,8 +140,9 @@ int blockdev_main(int argc UNUSED_PARAM,
 	/* setrw translates to BLKROSET(0), most other ioctls don't care... */
 	/* ...setro will do BLKROSET(1) */
 	u64 = (bdcmd == CMD_SETRO);
-	if (bdcmd == CMD_SETBSZ) {
+	if (bdcmd == CMD_SETBSZ || bdcmd == CMD_SETRA) {
 		/* ...setbsz is BLKBSZSET(bytes) */
+		/* ...setra is BLKRASET(512 bytes) */
 		u64 = xatoi_positive(*++argv);
 	}
 
@@ -145,8 +156,11 @@ int blockdev_main(int argc UNUSED_PARAM,
 #if BB_BIG_ENDIAN
 	/* Store data properly wrt data size.
 	 * (1) It's no-op for little-endian.
-	 * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,
-	 * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.
+	 * (2) it's no-op for 0 and -1.
+	 * --setro uses arg != 0 and != -1, and it is ARG_INT
+	 * --setbsz USER_VAL is also ARG_INT
+	 * --setra USER_VAL is ARG_ULONG, but it is passed by value,
+	 * not reference (see below in ioctl call).
 	 * Thus, we don't need to handle ARG_ULONG.
 	 */
 	switch (flags & ARG_MASK) {
@@ -161,7 +175,11 @@ int blockdev_main(int argc UNUSED_PARAM,
 	}
 #endif
 
-	if (ioctl(fd, bdcmd_ioctl[bdcmd], &ioctl_val_on_stack.u64) == -1)
+	if (ioctl(fd, bdcmd_ioctl[bdcmd],
+			bdcmd == CMD_SETRA
+				? (void*)(uintptr_t)u64 /* BLKRASET passes _value_, not pointer to it */
+				: &ioctl_val_on_stack.u64
+		) == -1)
 		bb_simple_perror_msg_and_die(*argv);
 
 	/* Fetch it into register(s) */
diff -urpN busybox-1.33.1/util-linux/dmesg.c busybox-1.34.0/util-linux/dmesg.c
--- busybox-1.33.1/util-linux/dmesg.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/dmesg.c	2021-06-16 17:02:16.000000000 +0700
@@ -46,7 +46,7 @@
 //kbuild:lib-$(CONFIG_DMESG) += dmesg.o
 
 //usage:#define dmesg_trivial_usage
-//usage:       "[-c] [-n LEVEL] [-s SIZE]"
+//usage:       "[-cr] [-n LEVEL] [-s SIZE]"
 //usage:#define dmesg_full_usage "\n\n"
 //usage:       "Print or control the kernel ring buffer\n"
 //usage:     "\n	-c		Clear ring buffer after printing"
diff -urpN busybox-1.33.1/util-linux/fdisk.c busybox-1.34.0/util-linux/fdisk.c
--- busybox-1.33.1/util-linux/fdisk.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/fdisk.c	2021-07-20 21:57:20.000000000 +0700
@@ -232,8 +232,8 @@ struct pte {
 };
 
 #define unable_to_open "can't open '%s'"
-#define unable_to_read "can't read from %s"
-#define unable_to_seek "can't seek on %s"
+#define unable_to_read "can't read '%s'"
+#define unable_to_seek "can't seek '%s'"
 
 enum label_type {
 	LABEL_DOS, LABEL_SUN, LABEL_SGI, LABEL_AIX, LABEL_OSF, LABEL_GPT
diff -urpN busybox-1.33.1/util-linux/fdisk_gpt.c busybox-1.34.0/util-linux/fdisk_gpt.c
--- busybox-1.33.1/util-linux/fdisk_gpt.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/fdisk_gpt.c	2021-04-15 00:05:01.000000000 +0700
@@ -87,7 +87,7 @@ gpt_print_wide36(uint16_t *s)
 	}
 	wc[i] = 0;
 	if (wcstombs(buf, wc, sizeof(buf)) <= sizeof(buf)-1)
-		fputs(printable_string(buf), stdout);
+		fputs_stdout(printable_string(buf));
 #else
 	char buf[37];
 	int i = 0;
@@ -98,7 +98,7 @@ gpt_print_wide36(uint16_t *s)
 		i++;
 	}
 	buf[i] = '\0';
-	fputs(buf, stdout);
+	fputs_stdout(buf);
 #endif
 }
 
diff -urpN busybox-1.33.1/util-linux/fdisk_sun.c busybox-1.34.0/util-linux/fdisk_sun.c
--- busybox-1.33.1/util-linux/fdisk_sun.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/fdisk_sun.c	2021-08-19 20:02:34.000000000 +0700
@@ -292,10 +292,10 @@ create_sunlabel(void)
 		} else {
 			g_heads = read_int(1, g_heads, 1024, 0, "Heads");
 			g_sectors = read_int(1, g_sectors, 1024, 0, "Sectors/track");
-		if (g_cylinders)
-			g_cylinders = read_int(1, g_cylinders - 2, 65535, 0, "Cylinders");
-		else
-			g_cylinders = read_int(1, 0, 65535, 0, "Cylinders");
+			if (g_cylinders)
+				g_cylinders = read_int(1, g_cylinders - 2, 65535, 0, "Cylinders");
+			else
+				g_cylinders = read_int(1, 0, 65535, 0, "Cylinders");
 			sunlabel->nacyl = SUN_SSWAP16(read_int(0, 2, 65535, 0, "Alternate cylinders"));
 			sunlabel->pcylcount = SUN_SSWAP16(read_int(0, g_cylinders + SUN_SSWAP16(sunlabel->nacyl), 65535, 0, "Physical cylinders"));
 			sunlabel->rspeed = SUN_SSWAP16(read_int(1, 5400, 100000, 0, "Rotation speed (rpm)"));
diff -urpN busybox-1.33.1/util-linux/flock.c busybox-1.34.0/util-linux/flock.c
--- busybox-1.33.1/util-linux/flock.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/flock.c	2021-06-16 17:02:16.000000000 +0700
@@ -14,7 +14,7 @@
 //kbuild:lib-$(CONFIG_FLOCK) += flock.o
 
 //usage:#define flock_trivial_usage
-//usage:       "[-sxun] FD|{FILE [-c] PROG ARGS}"
+//usage:       "[-sxun] FD | { FILE [-c] PROG ARGS }"
 //usage:#define flock_full_usage "\n\n"
 //usage:       "[Un]lock file descriptor, or lock FILE, run PROG\n"
 //usage:     "\n	-s	Shared lock"
diff -urpN busybox-1.33.1/util-linux/hexdump_xxd.c busybox-1.34.0/util-linux/hexdump_xxd.c
--- busybox-1.33.1/util-linux/hexdump_xxd.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/hexdump_xxd.c	2021-07-20 21:57:20.000000000 +0700
@@ -41,15 +41,17 @@
 //    -u          use upper case hex letters.
 
 //usage:#define xxd_trivial_usage
-//usage:       "[-pr] [-g N] [-c N] [-n LEN] [-s OFS] [FILE]"
+//usage:       "[-pri] [-g N] [-c N] [-n LEN] [-s OFS] [-o OFS] [FILE]"
 //usage:#define xxd_full_usage "\n\n"
 //usage:       "Hex dump FILE (or stdin)\n"
 //usage:     "\n	-g N		Bytes per group"
 //usage:     "\n	-c N		Bytes per line"
 //usage:     "\n	-p		Show only hex bytes, assumes -c30"
+//usage:     "\n	-i		C include file style"
 // exactly the same help text lines in hexdump and xxd:
 //usage:     "\n	-l LENGTH	Show only first LENGTH bytes"
 //usage:     "\n	-s OFFSET	Skip OFFSET bytes"
+//usage:     "\n	-o OFFSET	Add OFFSET to displayed offset"
 //usage:     "\n	-r		Reverse (with -p, assumes no offsets in input)"
 
 #include "libbb.h"
@@ -61,7 +63,11 @@
 #define OPT_s (1 << 1)
 #define OPT_a (1 << 2)
 #define OPT_p (1 << 3)
-#define OPT_r (1 << 4)
+#define OPT_i (1 << 4)
+#define OPT_r (1 << 5)
+#define OPT_g (1 << 6)
+#define OPT_c (1 << 7)
+#define OPT_o (1 << 8)
 
 static void reverse(unsigned opt, unsigned cols, const char *filename)
 {
@@ -122,20 +128,30 @@ static void reverse(unsigned opt, unsign
 	fflush_stdout_and_exit(EXIT_SUCCESS);
 }
 
+static void print_C_style(const char *p, const char *hdr)
+{
+	printf(hdr, isdigit(p[0]) ? "__" : "");
+	while (*p) {
+		bb_putchar(isalnum(*p) ? *p : '_');
+		p++;
+	}
+}
+
 int xxd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int xxd_main(int argc UNUSED_PARAM, char **argv)
 {
 	char buf[80];
 	dumper_t *dumper;
-	char *opt_l, *opt_s;
+	char *opt_l, *opt_s, *opt_o;
 	unsigned bytes = 2;
 	unsigned cols = 0;
 	unsigned opt;
+	int r;
 
 	dumper = alloc_dumper();
 
-	opt = getopt32(argv, "^" "l:s:aprg:+c:+" "\0" "?1" /* 1 argument max */,
-			&opt_l, &opt_s, &bytes, &cols
+	opt = getopt32(argv, "^" "l:s:apirg:+c:+o:" "\0" "?1" /* 1 argument max */,
+			&opt_l, &opt_s, &bytes, &cols, &opt_o
 	);
 	argv += optind;
 
@@ -158,14 +174,24 @@ int xxd_main(int argc UNUSED_PARAM, char
 		//BUGGY for /proc/version (unseekable?)
 	}
 
+	if (opt & OPT_o) {
+		/* -o accepts negative numbers too */
+		dumper->xxd_displayoff = xstrtoll(opt_o, /*base:*/ 0);
+	}
+
 	if (opt & OPT_p) {
 		if (cols == 0)
 			cols = 30;
 		bytes = cols; /* -p ignores -gN */
 	} else {
 		if (cols == 0)
-			cols = 16;
-		bb_dump_add(dumper, "\"%08.8_ax: \""); // "address: "
+			cols = (opt & OPT_i) ? 12 : 16;
+		if (opt & OPT_i) {
+			bytes = 1; // -i ignores -gN
+			// output is "  0xXX, 0xXX, 0xXX...", add leading space
+			bb_dump_add(dumper, "\" \"");
+		} else
+			bb_dump_add(dumper, "\"%08.8_ax: \""); // "address: "
 	}
 
 	if (opt & OPT_r) {
@@ -173,11 +199,15 @@ int xxd_main(int argc UNUSED_PARAM, char
 	}
 
 	if (bytes < 1 || bytes >= cols) {
-		sprintf(buf, "%u/1 \"%%02x\"", cols); // cols * "xx"
+		sprintf(buf, "%u/1 \"%%02x\"", cols); // cols * "XX"
 		bb_dump_add(dumper, buf);
 	}
 	else if (bytes == 1) {
-		sprintf(buf, "%u/1 \"%%02x \"", cols); // cols * "xx "
+		if (opt & OPT_i)
+			sprintf(buf, "%u/1 \" 0x%%02x,\"", cols); // cols * " 0xXX,"
+//TODO: compat: omit the last comma after the very last byte
+		else
+			sprintf(buf, "%u/1 \"%%02x \"", cols); // cols * "XX "
 		bb_dump_add(dumper, buf);
 	}
 	else {
@@ -201,13 +231,22 @@ int xxd_main(int argc UNUSED_PARAM, char
 		free(bigbuf);
 	}
 
-	if (!(opt & OPT_p)) {
+	if (!(opt & (OPT_p|OPT_i))) {
 		sprintf(buf, "\"  \"%u/1 \"%%_p\"\"\n\"", cols); // "  ASCII\n"
 		bb_dump_add(dumper, buf);
 	} else {
 		bb_dump_add(dumper, "\"\n\"");
-		dumper->eofstring = "\n";
+		dumper->xxd_eofstring = "\n";
 	}
 
-	return bb_dump_dump(dumper, argv);
+	if ((opt & OPT_i) && argv[0]) {
+		print_C_style(argv[0], "unsigned char %s");
+		printf("[] = {\n");
+	}
+	r = bb_dump_dump(dumper, argv);
+	if (r == 0 && (opt & OPT_i) && argv[0]) {
+		print_C_style(argv[0], "};\nunsigned int %s");
+		printf("_len = %"OFF_FMT"u;\n", dumper->address);
+	}
+	return r;
 }
diff -urpN busybox-1.33.1/util-linux/hwclock.c busybox-1.34.0/util-linux/hwclock.c
--- busybox-1.33.1/util-linux/hwclock.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/util-linux/hwclock.c	2021-01-08 15:30:27.000000000 +0700
@@ -79,7 +79,7 @@ static time_t read_rtc(const char **pp_r
 		int before = tm_time.tm_sec;
 		while (1) {
 			rtc_read_tm(&tm_time, fd);
-			gettimeofday(sys_tv, NULL);
+			xgettimeofday(sys_tv);
 			if (before != (int)tm_time.tm_sec)
 				break;
 		}
@@ -205,7 +205,7 @@ static void from_sys_clock(const char **
 	int rtc;
 
 	rtc = rtc_xopen(pp_rtcname, O_WRONLY);
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	/* Prepare tm_time */
 	if (sizeof(time_t) == sizeof(tv.tv_sec)) {
 		if (utc)
@@ -253,7 +253,7 @@ static void from_sys_clock(const char **
 		unsigned rem_usec;
 		time_t t;
 
-		gettimeofday(&tv, NULL);
+		xgettimeofday(&tv);
 
 		t = tv.tv_sec;
 		rem_usec = 1000000 - tv.tv_usec;
@@ -274,7 +274,7 @@ static void from_sys_clock(const char **
 		}
 
 		/* gmtime/localtime took some time, re-get cur time */
-		gettimeofday(&tv, NULL);
+		xgettimeofday(&tv);
 
 		if (tv.tv_sec < t /* we are still in old second */
 		 || (tv.tv_sec == t && tv.tv_usec < adj) /* not too far into next second */
diff -urpN busybox-1.33.1/util-linux/ionice.c busybox-1.34.0/util-linux/ionice.c
--- busybox-1.33.1/util-linux/ionice.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/ionice.c	2021-07-20 21:57:20.000000000 +0700
@@ -18,11 +18,13 @@
 //kbuild:lib-$(CONFIG_IONICE) += ionice.o
 
 //usage:#define ionice_trivial_usage
-//usage:	"[-c 1-3] [-n 0-7] [-p PID] [PROG ARGS]"
+//usage:	"[-c 1-3] [-n 0-7] [-t] { -p PID | PROG ARGS }"
+//TODO: | -P PGID | -u UID; also -pPu can take _list of_ IDs
 //usage:#define ionice_full_usage "\n\n"
 //usage:       "Change I/O priority and class\n"
 //usage:     "\n	-c N	Class. 1:realtime 2:best-effort 3:idle"
 //usage:     "\n	-n N	Priority"
+//usage:     "\n	-t	Ignore errors"
 
 #include <sys/syscall.h>
 #include <asm/unistd.h>
@@ -64,14 +66,15 @@ int ionice_main(int argc UNUSED_PARAM, c
 	int pid = 0; /* affect own process */
 	int opt;
 	enum {
-		OPT_n = 1,
-		OPT_c = 2,
-		OPT_p = 4,
+		OPT_n = 1 << 0,
+		OPT_c = 1 << 1,
+		OPT_p = 1 << 2,
+		OPT_t = 1 << 3,
 	};
 
-	/* Numeric params */
 	/* '+': stop at first non-option */
-	opt = getopt32(argv, "+n:+c:+p:+", &pri, &ioclass, &pid);
+	/* numeric params for -n -c -p */
+	opt = getopt32(argv, "+""n:+c:+p:+t", &pri, &ioclass, &pid);
 	argv += optind;
 
 	if (opt & OPT_c) {
@@ -104,7 +107,8 @@ int ionice_main(int argc UNUSED_PARAM, c
 //pri, ioclass, pri | (ioclass << IOPRIO_CLASS_SHIFT));
 		pri |= (ioclass << IOPRIO_CLASS_SHIFT);
 		if (ioprio_set(IOPRIO_WHO_PROCESS, pid, pri) == -1)
-			bb_perror_msg_and_die("ioprio_%cet", 's');
+			if (!(opt & OPT_t))
+				bb_perror_msg_and_die("ioprio_%cet", 's');
 		if (argv[0]) {
 			BB_EXECVP_or_die(argv);
 		}
diff -urpN busybox-1.33.1/util-linux/mdev.c busybox-1.34.0/util-linux/mdev.c
--- busybox-1.33.1/util-linux/mdev.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/util-linux/mdev.c	2021-01-08 15:30:27.000000000 +0700
@@ -963,7 +963,7 @@ static void load_firmware(const char *fi
 static char *curtime(void)
 {
 	struct timeval tv;
-	gettimeofday(&tv, NULL);
+	xgettimeofday(&tv);
 	sprintf(
 		strftime_HHMMSS(G.timestr, sizeof(G.timestr), &tv.tv_sec),
 		".%06u",
diff -urpN busybox-1.33.1/util-linux/mountpoint.c busybox-1.34.0/util-linux/mountpoint.c
--- busybox-1.33.1/util-linux/mountpoint.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/mountpoint.c	2021-06-16 17:02:16.000000000 +0700
@@ -19,13 +19,14 @@
 //kbuild:lib-$(CONFIG_MOUNTPOINT) += mountpoint.o
 
 //usage:#define mountpoint_trivial_usage
-//usage:       "[-q] <[-dn] DIR | -x DEVICE>"
+//usage:       "[-q] { [-dn] DIR | -x DEVICE }"
 //usage:#define mountpoint_full_usage "\n\n"
-//usage:       "Check if the directory is a mountpoint\n"
+//usage:       "Check if DIR is a mountpoint\n"
 //usage:     "\n	-q	Quiet"
-//usage:     "\n	-d	Print major/minor device number of the filesystem"
+//usage:     "\n	-d	Print major:minor of the filesystem"
 //usage:     "\n	-n	Print device name of the filesystem"
-//usage:     "\n	-x	Print major/minor device number of the blockdevice"
+//////// -n is not supported by util-linux-2.36.1 ^^^^^^^^^^^^^^^^^^
+//usage:     "\n	-x	Print major:minor of DEVICE"
 //usage:
 //usage:#define mountpoint_example_usage
 //usage:       "$ mountpoint /proc\n"
diff -urpN busybox-1.33.1/util-linux/readprofile.c busybox-1.34.0/util-linux/readprofile.c
--- busybox-1.33.1/util-linux/readprofile.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/readprofile.c	2021-06-16 17:02:16.000000000 +0700
@@ -44,8 +44,8 @@
 //usage:#define readprofile_trivial_usage
 //usage:       "[OPTIONS]"
 //usage:#define readprofile_full_usage "\n\n"
-//usage:       "	-m mapfile	(Default: /boot/System.map)"
-//usage:     "\n	-p profile	(Default: /proc/profile)"
+//usage:       "	-m MAPFILE	(Default: /boot/System.map)"
+//usage:     "\n	-p PROFILE	(Default: /proc/profile)"
 //usage:     "\n	-M NUM		Set the profiling multiplier to NUM"
 //usage:     "\n	-i		Print only info about the sampling step"
 //usage:     "\n	-v		Verbose"
diff -urpN busybox-1.33.1/util-linux/renice.c busybox-1.34.0/util-linux/renice.c
--- busybox-1.33.1/util-linux/renice.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/renice.c	2021-06-16 17:02:16.000000000 +0700
@@ -29,7 +29,7 @@
 //kbuild:lib-$(CONFIG_RENICE) += renice.o
 
 //usage:#define renice_trivial_usage
-//usage:       "[-n] PRIORITY [[-p | -g | -u] ID...]..."
+//usage:       "[-n] PRIORITY [[-p|g|u] ID...]..."
 //usage:#define renice_full_usage "\n\n"
 //usage:       "Change scheduling priority of a running process\n"
 //usage:     "\n	-n	Add PRIORITY to current nice value"
diff -urpN busybox-1.33.1/util-linux/rev.c busybox-1.34.0/util-linux/rev.c
--- busybox-1.33.1/util-linux/rev.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/rev.c	2021-04-15 00:05:01.000000000 +0700
@@ -108,7 +108,7 @@ int rev_main(int argc UNUSED_PARAM, char
 #else
 			strrev(buf, strlen(buf));
 #endif
-			fputs(buf, stdout);
+			fputs_stdout(buf);
 		}
 		fclose(fp);
 	} while (*argv);
diff -urpN busybox-1.33.1/util-linux/script.c busybox-1.34.0/util-linux/script.c
--- busybox-1.33.1/util-linux/script.c	2021-01-01 20:37:14.000000000 +0700
+++ busybox-1.34.0/util-linux/script.c	2021-01-08 15:30:27.000000000 +0700
@@ -172,7 +172,7 @@ int script_main(int argc UNUSED_PARAM, c
 						struct timeval tv;
 						double newtime;
 
-						gettimeofday(&tv, NULL);
+						xgettimeofday(&tv);
 						newtime = tv.tv_sec + (double) tv.tv_usec / 1000000;
 						fprintf(timing_fp, "%f %u\n", newtime - oldtime, count);
 						oldtime = newtime;
diff -urpN busybox-1.33.1/util-linux/switch_root.c busybox-1.34.0/util-linux/switch_root.c
--- busybox-1.33.1/util-linux/switch_root.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/switch_root.c	2021-07-20 21:57:20.000000000 +0700
@@ -68,11 +68,22 @@ extern int capget(cap_user_header_t head
 # define MS_MOVE     8192
 #endif
 
+static void delete_contents(const char *directory, dev_t rootdev);
+
+static int FAST_FUNC rmrf(const char *directory, struct dirent *d, void *rootdevp)
+{
+	char *newdir = concat_subpath_file(directory, d->d_name);
+	if (newdir) { // not . or ..
+		// Recurse to delete contents
+		delete_contents(newdir, *(dev_t*)rootdevp);
+		free(newdir);
+	}
+	return 0;
+}
+
 // Recursively delete contents of rootfs
 static void delete_contents(const char *directory, dev_t rootdev)
 {
-	DIR *dir;
-	struct dirent *d;
 	struct stat st;
 
 	// Don't descend into other filesystems
@@ -81,25 +92,7 @@ static void delete_contents(const char *
 
 	// Recursively delete the contents of directories
 	if (S_ISDIR(st.st_mode)) {
-		dir = opendir(directory);
-		if (dir) {
-			while ((d = readdir(dir))) {
-				char *newdir = d->d_name;
-
-				// Skip . and ..
-				if (DOT_OR_DOTDOT(newdir))
-					continue;
-
-				// Recurse to delete contents
-				newdir = concat_path_file(directory, newdir);
-				delete_contents(newdir, rootdev);
-				free(newdir);
-			}
-			closedir(dir);
-
-			// Directory should now be empty, zap it
-			rmdir(directory);
-		}
+		iterate_on_dir(directory, rmrf, &rootdev);
 	} else {
 		// It wasn't a directory, zap it
 		unlink(directory);
diff -urpN busybox-1.33.1/util-linux/taskset.c busybox-1.34.0/util-linux/taskset.c
--- busybox-1.33.1/util-linux/taskset.c	2021-01-01 17:52:27.000000000 +0700
+++ busybox-1.34.0/util-linux/taskset.c	2021-08-16 01:44:35.000000000 +0700
@@ -34,10 +34,12 @@
 //kbuild:lib-$(CONFIG_TASKSET) += taskset.o
 
 //usage:#define taskset_trivial_usage
-//usage:       "[-p] [HEXMASK] PID | PROG ARGS"
+//usage:       "[-ap] [HEXMASK"IF_FEATURE_TASKSET_CPULIST(" | -c LIST")"] { PID | PROG ARGS }"
 //usage:#define taskset_full_usage "\n\n"
 //usage:       "Set or get CPU affinity\n"
-//usage:     "\n	-p	Operate on an existing PID"
+//usage:     "\n	-p	Operate on PID"
+//usage:     "\n	-a	Operate on all threads"
+//usage:     "\n	-c	Affinity is a list, not mask"
 //usage:
 //usage:#define taskset_example_usage
 //usage:       "$ taskset 0x7 ./dgemm_test&\n"
@@ -205,42 +207,18 @@ static void print_cpulist(const ul *mask
 }
 #endif
 
-int taskset_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int taskset_main(int argc UNUSED_PARAM, char **argv)
+enum {
+	OPT_p = 1 << 0,
+	OPT_a = 1 << 1,
+	OPT_c = (1 << 2) * ENABLE_FEATURE_TASKSET_CPULIST,
+};
+
+static int process_pid_str(const char *pid_str, unsigned opts, char *aff)
 {
 	ul *mask;
 	unsigned mask_size_in_bytes;
-	pid_t pid = 0;
 	const char *current_new;
-	char *aff;
-	unsigned opts;
-	enum {
-		OPT_p = 1 << 0,
-		OPT_c = (1 << 1) * ENABLE_FEATURE_TASKSET_CPULIST,
-	};
-
-	/* NB: we mimic util-linux's taskset: -p does not take
-	 * an argument, i.e., "-pN" is NOT valid, only "-p N"!
-	 * Indeed, util-linux-2.13-pre7 uses:
-	 * getopt_long(argc, argv, "+pchV", ...), not "...p:..." */
-
-	opts = getopt32(argv, "^+" "p"IF_FEATURE_TASKSET_CPULIST("c")
-			"\0" "-1" /* at least 1 arg */);
-	argv += optind;
-
-	aff = *argv++;
-	if (opts & OPT_p) {
-		char *pid_str = aff;
-		if (*argv) { /* "-p <aff> <pid> ...rest.is.ignored..." */
-			pid_str = *argv; /* NB: *argv != NULL in this case */
-		}
-		/* else it was just "-p <pid>", and *argv == NULL */
-		pid = xatoul_range(pid_str, 1, ((unsigned)(pid_t)ULONG_MAX) >> 1);
-	} else {
-		/* <aff> <cmd...> */
-		if (!*argv)
-			bb_show_usage();
-	}
+	pid_t pid = !pid_str ? 0 : xatou_range(pid_str, 1, INT_MAX); /* disallow "0": "taskset -p 0" should fail */
 
 	mask_size_in_bytes = SZOF_UL;
 	current_new = "current";
@@ -255,13 +233,12 @@ int taskset_main(int argc UNUSED_PARAM,
 #endif
 			printf("pid %d's %s affinity mask: "TASKSET_PRINTF_MASK"\n",
 				pid, current_new, from_mask(mask, mask_size_in_bytes));
-		if (*argv == NULL) {
+		if (!aff) {
 			/* Either it was just "-p <pid>",
 			 * or it was "-p <aff> <pid>" and we came here
 			 * for the second time (see goto below) */
-			return EXIT_SUCCESS;
+			return 0;
 		}
-		*argv = NULL;
 		current_new = "new";
 	}
 	memset(mask, 0, mask_size_in_bytes);
@@ -331,8 +308,61 @@ int taskset_main(int argc UNUSED_PARAM,
 		bb_perror_msg_and_die("can't %cet pid %d's affinity", 's', pid);
 	//bb_error_msg("set mask[0]:%lx", mask[0]);
 
-	if (!argv[0]) /* "-p <aff> <pid> [...ignored...]" */
+	if ((opts & OPT_p) && aff) { /* "-p <aff> <pid> [...ignored...]" */
+		aff = NULL;
 		goto print_aff; /* print new affinity and exit */
+	}
+	return 0;
+}
+
+static int FAST_FUNC iter(const char *dn UNUSED_PARAM, struct dirent *ent, void *aff)
+{
+	if (isdigit(ent->d_name[0]))
+		return process_pid_str(ent->d_name, option_mask32, aff);
+	return 0;
+}
+
+int taskset_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int taskset_main(int argc UNUSED_PARAM, char **argv)
+{
+	const char *pid_str;
+	char *aff;
+	unsigned opts;
+
+	/* NB: we mimic util-linux's taskset: -p does not take
+	 * an argument, i.e., "-pN" is NOT valid, only "-p N"!
+	 * Indeed, util-linux-2.13-pre7 uses:
+	 * getopt_long(argc, argv, "+pchV", ...), not "...p:..." */
+
+	opts = getopt32(argv, "^+" "pa"IF_FEATURE_TASKSET_CPULIST("c")
+			"\0" "-1" /* at least 1 arg */);
+	argv += optind;
+
+	aff = *argv++;
+	if (!(opts & OPT_p)) {
+		/* <aff> <cmd...> */
+		if (!*argv)
+			bb_show_usage();
+		process_pid_str(NULL, opts, aff);
+		BB_EXECVP_or_die(argv);
+	}
 
-	BB_EXECVP_or_die(argv);
+	pid_str = aff;
+	if (*argv) /* "-p <aff> <pid> ...rest.is.ignored..." */
+		pid_str = *argv;
+	else
+		aff = NULL;
+
+	if (opts & OPT_a) {
+		char *dn;
+		int r;
+
+		dn = xasprintf("/proc/%s/task", pid_str);
+		r = iterate_on_dir(dn, iter, aff);
+		IF_FEATURE_CLEAN_UP(free(dn);)
+		if (r == 0)
+			return r; /* EXIT_SUCCESS */
+		/* else: no /proc/PID/task, act as if no -a was given */
+	}
+	return process_pid_str(pid_str, opts, aff);
 }
